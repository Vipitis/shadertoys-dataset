{"id": "3tBBDW", "name": "Hexagonal bokeh blur", "author": "luluco250", "description": "Hack-ish bokeh-like blur using three linear blurs at different 30° angles and a mix of median with average weighted blur.\nI've also made small use of inverse tonemapping for an HDR-like look.\nClick and drag from the center to scale and rotate the shape.", "tags": ["2d", "blur", "filter", "bokeh", "hexagon"], "likes": 23, "viewed": 2050, "published": 3, "date": "1598910765", "time_retrieved": "2024-07-30T20:48:05.762354", "image_code": "/*\n\nCopyright (c) 2020 Lucas Melo\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\n\nvoid mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    /*if (iMouse.z > 0.0)\n    {\n    \tfloat scale = 1.0;\n        vec2 m = iMouse.xy * ps;\n        scale += distance(m, vec2(0.5)) * 3.0;\n        \n        uv = ScaleCoord(uv, vec2(1.0 / scale), vec2(0.5));\n    }*/\n    \n    color = texture(iChannel0, uv);\n    color.rgb *= Exposure;\n    color.rgb = Tonemap(color.rgb);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Angle = 45.0;\nconst float Exposure = exp2(-3.0);\n\nconst int BlurSamples = 9;\nconst float BlurScale = 2.3;\nconst float BlurBrightness = 0.5;\n\nconst float Gamma = 2.333333;\n\nconst float Pi = 3.1415926;\nconst float Deg2Rad = Pi / 180.0;\nconst float Rad2Deg = 180.0 / Pi;\n\nvec2 ScaleCoord(vec2 coord, vec2 scale, vec2 pivot)\n{\n    return (coord - pivot) * scale + pivot;\n}\n\n// https://en.wikipedia.org/wiki/Rotation_%28mathematics%29#Two_dimensions\nvec2 Rotate(vec2 p, float deg)\n{\n    float rad = Deg2Rad * deg;\n    float s = sin(rad);\n    float c = cos(rad);\n    \n    vec2 res;\n    res.x = p.x * c - p.y * s;\n    res.y = p.x * s + p.y * c;\n    \n    return res;\n}\n\nfloat AngleBetween(vec2 a, vec2 b)\n{\n    vec2 d = b - a;\n    float angle = atan(d.y, d.x);\n    angle *= Rad2Deg;\n    \n    return angle; \n}\n\nvec4 Blur(\n    sampler2D sp,\n    vec2 uv,\n    vec2 dir,\n    const int samples,\n    float bright)\n{\n    if (samples < 1)\n        return vec4(0.0);\n    \n    if (samples == 1)\n        return texture(sp, uv);\n    \n    uv -= float(samples / 2) * dir;\n    \n    vec4 color = texture(sp, uv);\n    vec4 maxColor = color;\n    \n    for (int i = 1; i < samples; ++i)\n    {\n        uv += dir;\n        \n        vec4 pixel = texture(sp, uv);\n        color += pixel;\n        maxColor = max(maxColor, pixel);\n    }\n    \n    color /= float(samples);\n    \n    color = mix(color, maxColor, color * bright);\n    \n    return color;\n}\n\nfloat GetScale(vec2 uv, float t)\n{\n    float scale = sin(uv.x + uv.y + t * 0.6) * 0.5 + 0.5;\n    scale = pow(abs(scale), 0.9) * 6.0;\n    scale = min(scale, 1.0);\n    \n    return scale;\n}\n\nfloat GetScale(vec2 uv, float t, vec4 mouse, vec2 ps)\n{\n    float scale = BlurScale;\n    \n    if (mouse.z < 1.0)\n        return BlurScale * GetScale(uv, t);\n    \n    scale *= distance(mouse.xy * ps, vec2(0.5)) * 3.0;\n    \n    return scale;\n}\n\nfloat GetAngle(vec4 mouse, vec2 ps)\n{\n    if (mouse.z < 1.0)\n        return Angle;\n    \n    float angle = 90.0 - AngleBetween(mouse.xy * ps, vec2(0.5));\n    \n    return angle;\n}\n\nvec3 Reinhard(vec3 color)\n{\n    return color / (1.0 + color);\n}\n\nvec3 ReinhardInv(vec3 color)\n{\n    return -(color / min(color - 1.0, -0.1));\n}\n\nvec3 UE3Tonemap(vec3 color)\n{\n    return color / (color + 0.155) * 1.019;\n}\n\nvec3 UE3TonemapInv(vec3 color)\n{\n    return (color * -0.155) / (max(color, 0.01) - 1.019);\n}\n\nvec3 BakingLabACESTonemap(vec3 color, bool isInverse)\n{\n\tconst float A = 0.0245786;\n    const float B = 0.000090537;\n    const float C = 0.983729;\n    const float D = 0.4329510;\n    const float E = 0.238081;\n    \n    if (!isInverse)\n    {\n        color = (\n            (color * (color + A) - B) /\n            (color * (C * color + D) + E));\n        color = clamp(color, 0.0, 1.0);\n        \n        return color;\n    }\n    \n    color = abs(\n        (\n            (A - D * color) -\n            sqrt(\n                pow(abs(D * color - A), vec3(2.0)) -\n                4.0 * (C * color - 1.0) * (B + E * color))\n        ) /\n        (2.0 * (C * color - 1.0))\n    );\n    \n    return color;\n}\n\nvec3 Tonemap(vec3 color)\n{\n    color = Reinhard(color);\n    color = pow(abs(color), vec3(1.0 / Gamma));\n    \n    return color;\n}\n\nvec3 InvTonemap(vec3 color)\n{\n    color = pow(abs(color), vec3(Gamma));\n    color = ReinhardInv(color);\n    \n    return color;\n}\n", "buffer_a_code": "void mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / vec2(textureSize(iChannel0, 0)) * 3.0;\n    \n    vec2 uv0 = coord;\n    uv0.x += iTime * 10.0;\n    uv0.y -= iTime * 2.0;\n    uv0 *= ps * 0.4;\n    \n    vec4 color0 = texture(iChannel0, uv0);\n    \n    vec2 uv1 = coord;\n    uv1.x -= iTime * 20.0;\n    uv1.y += iTime * 30.0;\n    uv1 *= ps * 0.3;\n    \n    vec4 color1 = texture(iChannel0, uv1);\n    \n    color = max(color0, color1);\n    \n    color.rgb = InvTonemap(color.rgb);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    float angle = GetAngle(iMouse, ps);\n    \n    vec2 dir = Rotate(vec2(0, 1), -angle);\n    dir *= ps * GetScale(uv, iTime, iMouse, ps);\n    \n    color = Blur(\n        iChannel0,\n        uv,\n        dir,\n        BlurSamples,\n        BlurBrightness);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    float angle = GetAngle(iMouse, ps);\n    \n    vec2 dir = Rotate(vec2(1, 0), 30.0 - angle);\n    dir *= ps * GetScale(uv, iTime, iMouse, ps);\n    \n    color = Blur(\n        iChannel0,\n        uv,\n        dir,\n        BlurSamples,\n        BlurBrightness);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 color, vec2 coord)\n{\n    vec2 ps = 1.0 / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    float angle = GetAngle(iMouse, ps);\n    \n    vec2 dir = Rotate(vec2(1, 0), -30.0 - angle);\n    dir *= ps * GetScale(uv, iTime, iMouse, ps);\n    \n    color = Blur(\n        iChannel0,\n        uv,\n        dir,\n        BlurSamples,\n        BlurBrightness);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBBDW.jpg", "access": "api", "license": "mit", "functions": [[1063, 1063, 1107, 1107, 1492]], "test": "untested"}
{"id": "3lBfWW", "name": "Reddit scroller by MareeBree", "author": "mareebree", "description": "Reddit scroller", "tags": ["reddit"], "likes": 12, "viewed": 560, "published": 3, "date": "1598894471", "time_retrieved": "2024-07-30T20:48:06.827506", "image_code": "#define S(x,y,z) smoothstep(x,y,z)\n#define AR (iResolution.x/iResolution.y)\n#define PI (3.1415)\n\n#define TEXT_COLOR vec3(0.8,0.8,0.8)\n#define HIGHLIGHT_COLOR vec3(0.05,0.5,0.8)\n#define LIGHT_BG vec3(0.1,0.1,0.1)\n#define LIGHT_TEXT_COLOR vec3(0.1,0.1,0.1)\n#define VOTEUP_COLOR vec3(255.0/255.0, 139.0/255.0, 90.0/255.0)\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 inverseColor(vec3 col)\n{\n    return vec3(1.0-col.r,1.0-col.g,1.0-col.b);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float c){\n    vec2 co = vec2(c,c);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rotate(vec2 uv, float angle)\n{\n    uv -= 0.5;\n    mat2 mat = mat2(vec2(cos(angle), sin(angle)),vec2(-sin(angle), cos(angle)));\n    return mat*uv + 0.5;\n}\n\n// -------------b\n// |\t\t\t|\n// |\t\t\t|\n// a-------------\nfloat inRect(vec2 x ,vec2 a, vec2 b)\n{\n    return x.x > a.x && x.x < b.x && x.y > a.y && x.y < b.y ? 1.0 : 0.0;\n}\n\nfloat rectMask(vec2 uv, vec2 a, vec2 b)\n{\n    float lb = 0.01;\n    float m = S(a.x,a.x+lb,uv.x);\n    m = min(S(b.x+lb,b.x,uv.x),m);\n    m = min(S(a.y,a.y+lb,uv.y),m);\n    m = min(S(b.y+lb,b.y,uv.y),m);\n    return m;\n}\n\nfloat inUVRange(vec2 uv)\n{\n    return inRect(uv,vec2(0.0),vec2(1.0));\n}\n\n// UV is already 0.0-1.0 i assume\nvec2 uvToRect(vec2 uv, vec2 a, vec2 b)\n{\n    uv -= a;\n    uv /= (b-a);\n    return uv;\n}\n\nfloat roundBoxMask( vec2 uv, vec2 size, float radius )\n{\n  return inRect(uv, vec2(0.1),vec2(0.9));\n}\n\nfloat searchIconMask(vec2 uv)\n{\n    float d = length(uv+vec2(0.1,-0.1)-vec2(0.5));\n    \n    float cs = 0.3; // Circle size\n    float lt = 0.1; // Line thickness\n    \n    float cm = S(cs+0.01,cs,d); // Circle mask\n    cm -= S(cs-lt+0.01,cs-lt,d);\n    cm = clamp(cm,0.0,1.0);\n    \n    float lm = S(1.0,1.01,uv.x+uv.y); // Line mask\n    lm = min(lm,S(1.01+lt,1.00+lt,uv.x+uv.y));\n    lm *= S(0.2,0.21,uv.x-uv.y);\n    lm *= S(0.86,0.85,uv.x-uv.y);\n    \n    return cm + lm;\n}\n\nfloat redditIconMask(vec2 uv)\n{\n    uv = uvToRect(uv,vec2(0.2,0.2),vec2(0.8,0.8));\n    \n    float iconMask = 0.0;\n    \n    // Head\n    vec2 headUV = uv - vec2(0.5,0.4);\n    float a = 1.2;\n    float b = 0.9;\n    float d = (headUV.x*headUV.x)/(a*a) + (headUV.y*headUV.y)/(b*b);\n    iconMask = S(0.11,0.1,d);\n    \n    // Ears\n    vec2 earPos = vec2(0.35,0.13);\n    float earSize = 0.12;\n    iconMask += S(earSize+0.01,earSize, length(headUV - earPos));\n    iconMask += S(earSize+0.01,earSize, length(headUV - earPos*vec2(-1.0,1.0)));\n    iconMask = min(1.0,iconMask);\n    \n    // Antenna\n    float lineThickness = 0.02;\n    float lineMask = S(0.5-lineThickness,0.5-lineThickness+0.01,uv.x);\n    lineMask = min(lineMask,S(0.5+lineThickness+0.01,0.5+lineThickness,uv.x));\n    lineMask *= S(0.6,0.61,uv.y);\n    lineMask *= S(0.84,0.83,uv.y);\n    vec2 dLinePos = vec2(1.0,-2.0);\n    lineThickness *= 2.0;\n    float lineHeight = -1.14;\n    float dLineMask = S(lineHeight-lineThickness,lineHeight-lineThickness+0.01,dLinePos.x*uv.x+dLinePos.y*uv.y);\n    dLineMask = min(dLineMask,S(lineHeight+lineThickness+0.01,lineHeight+lineThickness,dLinePos.x*uv.x+dLinePos.y*uv.y));\n    dLineMask *= S(0.48,0.49,uv.x);\n    dLineMask *= S(0.61,0.6,uv.x);\n    float circleAntennaSize = 0.07;\n    vec2 circlePos = vec2(0.65,0.89);\n    float circleMask = S(circleAntennaSize+0.01,circleAntennaSize,length(uv-circlePos));\n    \n    iconMask += lineMask+dLineMask+circleMask;\n    iconMask = min(iconMask,1.0);\n    \n    \n    // Eyes\n    //vec2 eyePos = vec2(0.15,0.06);\n    //float eyeSize = 0.07;\n    //iconMask -= S(eyeSize+0.01,eyeSize, length(headUV - eyePos));\n    //iconMask -= S(eyeSize+0.01,eyeSize, length(headUV - eyePos*vec2(-1.0,1.0)));\n    //iconMask = max(0.0,iconMask);\n    \n    return iconMask;\n}\n\nfloat communityIconMask(vec2 uv)\n{\n    uv = uvToRect(uv,vec2(0.2,0.2),vec2(0.8,0.8));\n    \n    float m = 0.0;\n    \n    vec2 ruv = uvToRect(uv,vec2(0.1,0.1),vec2(0.4,0.4));\n    m += inUVRange(ruv)*S(0.51,0.5,length(ruv-vec2(0.5)));\n    \n    ruv = uvToRect(uv,vec2(0.6,0.1),vec2(0.9,0.4));\n    m += inUVRange(ruv);\n    \n    ruv = uvToRect(uv,vec2(0.6,0.6),vec2(0.9,0.9));\n    m += inUVRange(ruv)*S(0.51,0.5,length(ruv-vec2(0.5)));\n    \n    ruv = uvToRect(uv,vec2(0.1,0.6),vec2(0.4,0.9));\n    m += inUVRange(ruv);\n    \n    return m;\n}\n\nfloat pencilIconMask(vec2 uv)\n{\n    uv = uvToRect(uv, vec2(0.15,0.2),vec2(0.8,0.8));\n    \n    float m = 0.0;\n    float pt = 0.07; // pencil thicness\n    \n    uv -= vec2(0.2,0.7);\n    float d = (0.9*uv.x - uv.y);\n    m = S(0.5-pt,0.5-pt+0.01,d);\n    m = min(m,S(0.5+pt+0.01,0.5+pt,d));\n    \n    d = (uv.x + uv.y);\n    m -= S(0.7,0.71,d);\n    m -= S(0.07,0.06,uv.x);\n    m -= S(-0.45,-0.455,uv.y);\n    m -= min(S(0.55,0.56,d), S(0.60,0.59,d));\n    m = max(m,0.0);\n    \n    return m;\n}\n\nfloat chatIconMask(vec2 uv)\n{\n    uv = uvToRect(uv,vec2(0.1,0.1),vec2(0.9,0.9));\n    \n    float iconSize = 0.3;\n    \n    // Bubble\n    float m = S(iconSize+0.01,iconSize,length(uv-vec2(0.5,0.5)));\n    \n    // Bubble end\n    float x = 0.6;\n    vec2 buv = uv - vec2(0.2,0.1);\n    float be = S(0.5,0.51,x+0.3*buv.x-buv.y);\n    be += S(0.51,0.5,x+0.75*buv.x-buv.y);\n    be = 1.0 - min(1.0,be);\n    be *= S(0.51,0.5,uv.x);\n    m += be;\n    m = min(1.0,m);\n    \n    // Dots\n    vec2 duv = uvToRect(uv,vec2(0.4,0.45),vec2(0.6,0.55));\n    float dm = inUVRange(duv);\n    duv.x = fract(duv.x*3.0);\n    m -= S(0.31,0.3,length(duv-vec2(0.5)))*dm;\n    m = max(0.0,m);\n    \n    return m;\n}\n\nfloat inboxIconMask(vec2 uv)\n{\n    uv = uvToRect(uv,vec2(0.2,0.2),vec2(0.8,0.8));\n    \n    float m = 0.0;\n    \n    m = rectMask(uv,vec2(0.1,0.2),vec2(0.9,0.8));\n    \n    float lt = 0.01;\n    float d = (uv.x+uv.y)/2.0;\n    float lp = 0.45;\n    float dl = min(S(lp-lt,lp-lt+0.005,d),S(lp+lt+0.005,lp+lt,d));\n    d = (uv.x-uv.y);\n    lt *= 4.0;\n    lp = 0.06;\n    dl += min(S(lp,lp+0.01,d),S(lp+lt+0.01,lp+lt,d));\n    dl = min(1.0,dl);\n    dl *= S(0.415-0.001,0.415,uv.y);\n    \n    m -= dl;\n    m = max(0.0,m);\n    \n    return m;\n}\n\nfloat upvoteIconMask(vec2 uv)\n{\n    uv = uvToRect(uv,vec2(0.1),vec2(0.9));\n    \n   \tvec2 auv = uv - vec2(0.0,0.5);\n    float m = S(0.0,0.01,auv.x-auv.y);\n    auv = uv - vec2(0.0,1.0);\n    m = min(S(0.51,0.5,(auv.x+auv.y)),m);\n    m *= S(0.5,0.505,uv.y);\n    \n    m += rectMask(uv,vec2(0.3,0.0),vec2(0.7,0.6));\n    m = min(1.0,m);\n    \n    return m;\n}\n\nfloat commentsIconMask(vec2 uv)\n{\n    uv = uvToRect(uv,vec2(0.0,0.2),vec2(1.0,1.0));\n    \n    vec2 auv = uv - vec2(0.5,0.0);\n    float m = S(0.01,0.00,auv.x-auv.y);\n    auv = uv + vec2(0.5,0.0);\n    m = min(S(1.0,1.01,auv.x+auv.y),m);\n    m *= S(0.21,0.2,uv.y);\n    m += rectMask(uv,vec2(0.15,0.15),vec2(0.85,0.65));\n    m = min(m,1.0);\n    \n    return m;\n}\n\nvec3 drawRedditHeader(vec2 uv)\n{\n    float pihs = 0.35; // Profile icon header size\n    \n    float bgMask = 1.0;\n    \n    // Profile icon\n    vec2 profileIconUV = uvToRect(uv,vec2(0.05,0.5),vec2(pihs+0.05,1.0));\n    profileIconUV.x /= pihs;\n    float profileIconSize = 0.4;\n    float profileIconMask = S(profileIconSize+0.01,profileIconSize,length(profileIconUV-vec2(0.5)));\n    vec3 profileIconColor = hsv2rgb(vec3(rand(iDate.x),0.7,0.6));\n    vec3 profileIcon = profileIconColor*profileIconMask;\n    \n    bgMask -= profileIconMask;\n    \n   \t// Search bar\n    pihs -= 0.1;\n    vec2 searchBarUV = uvToRect(uv,vec2(pihs,0.5),vec2(1.0,1.0));\n    float searchBarMask = roundBoxMask(searchBarUV,vec2(0.1),0.005);\n    vec2 searchIconUV = uvToRect(searchBarUV,vec2(0.1),vec2(0.2,0.9));\n    searchBarMask -= max(searchIconMask(searchIconUV),0.0);\n    searchBarMask *= S(pihs,pihs+0.01,uv.x);\n    vec3 searchBarColor = vec3(0.2,0.2,0.2);\n    vec3 searchBar = searchBarColor*searchBarMask;\n    \n    bgMask -= searchBarMask;\n    \n    // Down panel\n    vec2 downPanelUV = uvToRect(uv,vec2(0.25,0.0),vec2(0.75,0.5));\n    vec2 leftUV = uvToRect(downPanelUV,vec2(0.0),vec2(0.5,1.0));\n    vec3 downPanel = vec3(0.0);\n    downPanel += rectMask(leftUV,vec2(0.25,0.42),vec2(0.75,0.58))*TEXT_COLOR;\n    downPanel += rectMask(leftUV,vec2(0.0,0.0),vec2(1.0,0.06))*HIGHLIGHT_COLOR;\n    vec2 rightUV = uvToRect(downPanelUV,vec2(0.5,0.0),vec2(1.0,1.0));\n    downPanel += rectMask(rightUV,vec2(0.25,0.42),vec2(0.75,0.58))*TEXT_COLOR;\n    \n    // Background\n    bgMask = max(bgMask,0.0);\n    float inHeader = inRect(uv,vec2(0.0),vec2(1.0));\n    \n    return profileIcon + searchBar + LIGHT_BG*bgMask*inHeader + downPanel;\n    \n}\n\nvec3 drawRedditFooter(vec2 uv)\n{\n    vec3 iconColor = vec3(0.65,0.65,0.65);\n    vec3 footerColor = vec3(0.0);\n    float bgMask = 1.0;\n    \n    // Reddit icon\n    vec2 iconUV = uvToRect(uv,vec2(0.0,0.0),vec2(0.2,1.0));\n    footerColor += redditIconMask(iconUV)*TEXT_COLOR;\n    \n    iconUV = uvToRect(uv,vec2(0.2,0.0),vec2(0.4,1.0));\n    footerColor += communityIconMask(iconUV)*TEXT_COLOR*0.4;\n    \n    iconUV = uvToRect(uv,vec2(0.4,0.0),vec2(0.6,1.0));\n    footerColor += pencilIconMask(iconUV)*TEXT_COLOR*0.4;\n    float d = length(iconUV-vec2(0.5,0.5));\n    float highlightMask = S(0.4,0.35,d);\n    highlightMask = max(0.0,highlightMask-S(0.35,0.3,d));\n    footerColor += highlightMask*HIGHLIGHT_COLOR;\n    \n    iconUV = uvToRect(uv,vec2(0.6,0.0),vec2(0.8,1.0));\n    footerColor += chatIconMask(iconUV)*TEXT_COLOR*0.4;\n    \n    iconUV = uvToRect(uv,vec2(0.8,0.0),vec2(1.0,1.0));\n    footerColor += inboxIconMask(iconUV)*TEXT_COLOR*0.4;\n    \n    bgMask = 1.0-min(min(footerColor.r,footerColor.g),footerColor.b);\n    bgMask *= inUVRange(uv);\n    return footerColor + bgMask*LIGHT_BG;\n}\n\nvec3 drawRedditCenter(vec2 uv , float t)\n{\n    vec2 suv = uv;\n    float inCenterRange = inUVRange(uv);\n    uv.y -= 0.2*max(t + (1.0+sin(t)),t);\n    uv.y *= 3.0;\n    float postID = floor(uv).y;\n    float rnd = rand(postID);\n    uv = fract(uv); \n    \n    vec2 postUV = uvToRect(uv,vec2(0.0,0.1),vec2(1.0,0.9));\n    float inPostRange = inUVRange(postUV);\n    \n    // Post header\n    vec3 headerColor = vec3(0.0);\n    \n    vec2 headerUV = uvToRect(postUV,vec2(0.0,0.7),vec2(1.0,1.0));\n    vec2 profileIconUV = uvToRect(headerUV,vec2(0.05,0.0),vec2(0.15,1.0));\n    float profileIconMask = S(0.35,0.3,length(profileIconUV-vec2(0.5,0.5)));\n    vec3 profileIconColor = hsv2rgb(vec3(rnd,0.7,0.6));\n    headerColor += profileIconMask*profileIconColor;\n    \n    vec2 titleUV = uvToRect(headerUV,vec2(0.15,0.0),vec2(0.9,1.0));\n    vec2 redditPageTitleUV = uvToRect(titleUV,vec2(0.0,0.4),vec2(1.0,1.0));\n    headerColor += rectMask(redditPageTitleUV,vec2(0.1,0.3),vec2(0.5+rand(postID)*0.2,0.6))*TEXT_COLOR;\n    \n    vec2 postedByUV = uvToRect(titleUV,vec2(0.0,0.0),vec2(1.0,0.4));\n    headerColor += rectMask(postedByUV,vec2(0.1,0.3),vec2(0.5+rand(fract(postID*10.0))*0.2,0.6))*LIGHT_TEXT_COLOR;\n    \n    vec2 optionsUV = uvToRect(headerUV,vec2(0.9,0.0),vec2(1.0,0.8));\n    headerColor += S(0.06,0.05,length(optionsUV-vec2(0.0,0.1)-vec2(0.5)))*LIGHT_TEXT_COLOR;\n    headerColor += S(0.06,0.05,length(optionsUV-vec2(0.0,0.3)-vec2(0.5)))*LIGHT_TEXT_COLOR;\n    headerColor += S(0.06,0.05,length(optionsUV-vec2(0.0,0.5)-vec2(0.5)))*LIGHT_TEXT_COLOR;\n    \n    // Post title\n    vec3 titleColor = vec3(0.0);\n    vec2 postTitleUV = uvToRect(postUV,vec2(0.0,0.3),vec2(1.0,0.7));\n    float postTitleMask = inUVRange(postTitleUV);\n    postTitleUV.y *= 2.0;\n    float titleLine = floor(postTitleUV).y;\n    postTitleUV = fract(postTitleUV);\n    titleColor += postTitleMask*rectMask(postTitleUV,vec2(0.05,0.3),vec2(0.5 + 0.5*rand(postID+titleLine),0.6))*TEXT_COLOR;\n    \n    // Post footer\n    vec3 footerColor = vec3(0.0);\n    vec2 postFooterUV = uvToRect(postUV,vec2(0.0,0.0),vec2(1.0,0.3));\n    \n    // Todo : make animation of upvote\n    vec3 voteupColor = fract(rnd*10.0) < 0.2 ? VOTEUP_COLOR : LIGHT_TEXT_COLOR;\n    vec2 voteUV = uvToRect(postFooterUV,vec2(0.05,0.05),vec2(0.3,0.95));\n    vec2 voteupUV = uvToRect(voteUV,vec2(0.0,0.0),vec2(0.3,1.0));\n    footerColor += upvoteIconMask(voteupUV)*voteupColor;\n    vec2 voteCountUV = uvToRect(voteUV,vec2(0.3,0.0),vec2(0.7,1.0));\n    footerColor += rectMask(voteCountUV,vec2(0.1,0.4),vec2(0.9,0.6))*voteupColor;\n    vec2 votedownUV = uvToRect(voteUV,vec2(0.7,0.0),vec2(1.0,1.0));\n    votedownUV = rotate(votedownUV,PI);\n    footerColor += upvoteIconMask(votedownUV)*LIGHT_TEXT_COLOR;\n    \n    vec2 commentUV = uvToRect(postFooterUV, vec2(0.55,0.05), vec2(0.75,0.95));\n    vec2 commentIconUV = uvToRect(commentUV, vec2(0.0,0.0), vec2(0.4,1.0));\n    footerColor += commentsIconMask(commentIconUV)*LIGHT_TEXT_COLOR;\n    vec2 commentNumberUV = uvToRect(commentUV, vec2(0.4,0.0), vec2(1.0,1.0));\n    footerColor += rectMask(commentNumberUV,vec2(0.1,0.4),vec2(0.9,0.6))*LIGHT_TEXT_COLOR;\n    \n    vec3 finalColor = headerColor + titleColor + footerColor;\n    float bgMask = 1.0-min(min(finalColor.r,finalColor.g),finalColor.b);\n    \n    return inCenterRange*inPostRange* (finalColor + bgMask*LIGHT_BG);\n}\n\nvec3 drawScreen(vec2 uv, float t)\n{\n    float hss = 0.15; // header screen size\n    float fss = 0.1; // footer screen size\n    \n    vec2 headerUV = uvToRect(uv,vec2(0.0,1.0-hss),vec2(1.0,1.0));\n    vec2 footerUV = uvToRect(uv, vec2(0.0,0.0),vec2(1.0,fss));\n    vec2 centerUV = uvToRect(uv, vec2(0.0,fss),vec2(1.0,1.0-hss));\n    \n    float transitionMask = S(fss,fss+0.05,uv.y);\n    transitionMask = min(S(1.0-hss,1.0-hss-0.05,uv.y),transitionMask);\n    \n    return drawRedditHeader(headerUV) + drawRedditFooter(footerUV) + transitionMask*drawRedditCenter(centerUV,t);\n}\n\nvec3 drawPhone(vec2 uv, float t)\n{\n    vec2 screenUV = uvToRect(uv,vec2(0.05,0.05),vec2(0.95,0.9));\n    vec3 screenColor = drawScreen(screenUV,t);\n    float screenMask = 1.0;\n    screenMask *= S(1.0,0.96,screenUV.x);\n    screenMask *= S(0.0,0.04,screenUV.x);\n    screenMask *= S(0.0,0.01,screenUV.y);\n    screenMask *= S(1.0,0.99,screenUV.y);\n    \n    vec3 phoneColor = hsv2rgb(vec3(rand(iDate.x),0.6,0.8));\n    float phoneMask = 1.0-inUVRange(screenUV);\n    phoneMask *= inUVRange(uv);\n    phoneMask *= S(1.0,0.96,uv.x);\n    phoneMask *= S(0.0,0.04,uv.x);\n    phoneMask *= S(0.0,0.01,uv.y);\n    phoneMask *= S(1.0,0.99,uv.y);\n    \n    vec2 phoneHeaderUV = uvToRect(uv,vec2(0.05,0.92),vec2(0.95,0.98));\n    vec2 speakerUV = uvToRect(phoneHeaderUV,vec2(0.6,0.0), vec2(0.9,1.0));\n    float speakerMask = inUVRange(speakerUV);\n    speakerUV *= vec2(8.0,3.0);\n    speakerUV = fract(speakerUV);\n    phoneColor -= speakerMask*S(0.33,0.3,length(speakerUV-vec2(0.5)))*vec3(1.0);\n    \n    vec2 cameraUV = uvToRect(phoneHeaderUV,vec2(0.05,0.0), vec2(0.25,1.0));\n    float cameraMask = inUVRange(cameraUV);\n    cameraUV.x *= 2.0;\n    cameraUV = fract(cameraUV);\n    phoneColor -= cameraMask*S(0.38,0.35,length(cameraUV-vec2(0.5)))*vec3(1.0);\n    \n    vec3 finalColor = screenMask*screenColor + phoneMask*phoneColor;\n    \n    return finalColor;\n}\n\n// https://www.shadertoy.com/view/XsjfDD\nvec3 drawBackground(vec2 fragCoord, float t)\n{\n    float rotX = 3.14+0.5*sin(0.1*t);\n    float rotY = 1.57;\n    vec2 uv = 2.5 * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xx;\n    vec3 camO = vec3(cos(rotX), cos(rotY), sin(rotX));\n    vec3 camD = normalize(vec3(0)-camO);\n    vec3 camR = normalize(cross(camD, vec3(0, 1, 0)));\n    vec3 camU = cross(camR,camD);\n   \tvec3 dir =  normalize(uv.x * camR + uv.y * camU + camD);\n    return texture(iChannel0, dir).rgb;\n}\n\nvec4 mn( vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 phoneUV = uvToRect(uv,vec2(0.25,0.1), vec2(0.53,0.9));\n    vec3 phoneColor = drawPhone(phoneUV,iTime);\n    float phoneMask = inUVRange(phoneUV);\n    \n    vec3 backgroundColor = drawBackground(fragCoord,iTime);\n    \n    vec3 col = phoneColor + (1.0-phoneMask)*backgroundColor;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    return fragColor;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(0.);\n\tint a = 3;\n    for(int i1 = 0;i1<a;i1++){\n    \tfor(int i2 = 0;i2<a;i2++){\n    \t\tfragColor += mn(vec4(0),fragCoord+vec2(float(i1),float(i2))/(float(a)));\n    \t}\n    }\n    fragColor /= float(a*a);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 458, 480, 480, 649], [651, 651, 680, 680, 730], [732, 732, 752, 752, 824], [826, 826, 846, 846, 943], [945, 945, 980, 980, 1103], [1105, 1159, 1197, 1197, 1272], [1274, 1274, 1315, 1315, 1491], [1493, 1493, 1519, 1519, 1564], [1566, 1600, 1640, 1640, 1687], [1689, 1689, 1745, 1745, 1789], [1791, 1791, 1822, 1822, 2261], [2263, 2263, 2294, 2294, 4047], [4049, 4049, 4083, 4083, 4580], [4582, 4582, 4613, 4613, 5064], [5066, 5066, 5095, 5095, 5741], [5743, 5743, 5773, 5773, 6271], [6273, 6273, 6304, 6304, 6623], [6625, 6625, 6658, 6658, 6982], [6984, 6984, 7016, 7016, 8685], [8687, 8687, 8719, 8719, 9771], [9773, 9773, 9815, 9815, 13099], [13101, 13101, 13136, 13136, 13670], [13672, 13672, 13706, 13706, 15006], [15008, 15049, 15095, 15095, 15520], [15522, 15522, 15568, 15568, 15978]], "test": "untested"}
{"id": "3lSfWW", "name": "GaboryPerlin", "author": "FabriceNeyret2", "description": "Gabory Perlin, replacing the smooth wavelet at grid vertices by a Gabor kernel (with random phase) at grid vertices, to better tune anisotropy and mainDirection(pos).\nPlay with parameters A ( anisotropy ) D (direction ) etc. ", "tags": ["perlinnoise", "displacement", "distortion", "flownoise", "filament", "divergencefree"], "likes": 8, "viewed": 473, "published": 3, "date": "1598893803", "time_retrieved": "2024-07-30T20:48:07.845783", "image_code": "// inspired from https://shadertoy.com/view/WtBBD1\n\nfloat A = .2, // Anisotropy. 1 = isotropic\n      D = 0., // favorite dir\n      K = 0.; // seed for random numbers\n//#define D atan((p).y,(p).x)\n\n//#define rot(a)       mat2( cos( a + vec4(0,11,33,0) ) )\n  #define hash(p,K)    fract(sin(dot(p+K, vec2(12.9898, 78.233))) * 43758.5453)\n//#define hash2(p) ( 2.* fract( sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123 ) - 1. )\n  #define hash2(p)   cos( A/2.*6.28*hash(p,K) + vec2(0,11) + D + V(p)*iTime ) // variant of random gradient + rotating (= lownoise)\n//#define l(i,j)     dot( hash2(I+vec2(i,j)) , F-vec2(i,j) )       // random wavelet at grid vertex I+vec2(i,j) \n  #define Gabor(v,x,f)   cos( 6.28*( 2.*dot(x,v) + f ) ) * exp(-.5*1.*dot(x,x) )\n  #define l(i,j)     Gabor( hash2(I+vec2(i,j)), F-vec2(i,j) , hash(I+vec2(i,j),2.))       // random wavelet at grid vertex I+vec2(i,j) \n  #define L(j,x)     mix( l(0,j), l(1,j), x )\n\n  #define V(p) 0.                                // flownoise rotation speed \n//#define V(p) 1.*( 2.*mod((p).x+(p).y,2.)- 1. ) // checkered rotation direction \n//#define V(p) length(p)\n//#define V(p) ( 8. - length(p) )\n\nfloat GaboryPerlin(vec2 p) {\n    vec2 I = floor(p), \n         F = fract(p), \n     //  U = F;\n     //  U = F*F*(3.-2.*F);                   // based Perlin noise\n         U = F*F*F*( F* ( F*6.-15.) + 10. );  // improved Perlin noise ( better derivatives )\n    return mix( L(0,U.x) , L(1,U.x) , U.y );  // smooth interpolation of corners random wavelets\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         S = 8. / R.yy,\n         U = ( 2.*u - R ) * S, I = floor(U);\n    \n    A = .5+.5*sin(iTime);   // anisotropy\n  //A = abs( length(I)*2.-1.);\n    D = atan(U.y,U.x);      // prefered direction\n  //A = 0.; D += 3.14/2.*sin(iTime);  // variant\n    \n#if 0\n    float v = GaboryPerlin( U );      // only 1 kernel\n#else\n    float v = 0., N = 4.;\n    for ( float i = 0.; i < 5.; i++, K+=.1 ) // sum N kernels\n        v += GaboryPerlin( U ); \n    v /= 2.*sqrt(N);\n#endif  \n    \n    O = vec4( .5 + .5 * v );          // see Perlin noise\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1164, 1164, 1192, 1192, 1517], [1519, 1519, 1557, 1557, 2121]], "test": "untested"}
{"id": "WtSBWW", "name": "shell parameterization push hole", "author": "FabriceNeyret2", "description": "Insert (push) hole in parameterization.\nmouse.y tunes hole radius\nMouse.x tunes post-hole distance back to normal\n", "tags": ["blackhole", "short", "parameterization"], "likes": 8, "viewed": 365, "published": 3, "date": "1598889288", "time_retrieved": "2024-07-30T20:48:08.795245", "image_code": "// Fork of \"push hole in parameterization\"  https://shadertoy.com/view/ltcBRj\n\n\n//#define S(x) clamp(1.2-abs(fract(x)-.5)/fwidth(x) , 0., 1. )\n#define S(x) smoothstep(1.5, 0., abs(fract(x)-.5)/fwidth(x) )\n//#define S(x) smoothstep(1.5, 0., abs(fract(x)-.5)/length(vec2(dFdx(x),dFdy(x))) )\n\nfloat D = .5,     // push distance\n      n = 3.;     // slope after push: \"back to normal\" invdistance\n      \nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy, M = iMouse.xy;\n    U = ( U+U - R ) / R.y;\n    \n    if (M!=vec2(0)) M /= R, D = M.y, n = 1./(.01+M.x); // mouse control\n    \n                  // --- pull original parameterization falling in this pixel\n    float l = length(U), c, l0=l;\n    U /= l;\n    // d' = f(d)        f(x) = (x^n+D^n)^(1/n)  \n    // d = f^-1(d')  f^-1(x) = (x^n-D^n)^(1/n)\n    l *= c = pow( abs(1.-pow(D/l,n)), 1./n );   // c = concentration\n    U *= l; \n\n                  // --- apply\n    vec4 T = 2.*texture(iChannel0, .5+.5*U*8.*R.y/R);\n\n    U *= 8.;     // draw grid parameterization\n    O = vec4( max( S(U.x) , S(U.y) ) , 0,0,0);\n    \n    O += T;\n    \n  //O *= max(0.,1.-1.*c); // green: concentration\n    O *= smoothstep( 1.5, 0., abs(l0-D)*6. );\n\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 400, 438, 438, 1195]], "test": "untested"}
{"id": "wt2fD1", "name": "shell parameterization inversion", "author": "FabriceNeyret2", "description": "good points:  works in 3D, conformal (preserve angles).\nbad points:    no canonical axis parallel to the shell. don't preserve lengths (but don't dream too much ;-) )", "tags": ["mapping", "conformal", "inversion"], "likes": 8, "viewed": 316, "published": 3, "date": "1598888305", "time_retrieved": "2024-07-30T20:48:09.666914", "image_code": "void mainImage( out vec4 O, in vec2 u )\n{\n   \n    vec2 R = iResolution.xy,\n         U = ( 2.* u - R ) / R.y, V;\n       \n\n    float l = length(U);\n    //U /= .5+.04*length(U);\n    \n    U *= .2/dot(U,U); // inversion\n // U = (U-.7) * mat2( cos( .1*iTime + vec4(0,11,33,0) ) ) + .7; // rotation\n // U.x /= 4.;        // stretch in one canonical direction\n\n    vec4 T = 1.5* texture(iChannel0,(.5+.5*U.yx)*8.); // mapped texture\n\n    U *= 16.;         // --- draw parttern\n    V = fract(U)*2.-1.;\n    float // v = length(V)-.5;              // draw dots pattern\n             v = min(abs(V.x),abs(V.y));    // draw grid pattern\n    O = vec4(smoothstep(2.,0.,abs(v)/fwidth(length(U))) ,0,0,0);\n    \n\n // O = mix(O,T,.7);\n    O += T;\n    \n    O *= smoothstep(.4,0.,abs(l-.7));       // show only in torus\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2fD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 799]], "test": "untested"}
{"id": "wtjBW1", "name": "[NERDDISCO] Lines", "author": "TimPietrusky", "description": "A very basic filter that converts everything into lines.", "tags": ["lines", "filter", "modv", "nerddisco"], "likes": 2, "viewed": 303, "published": 3, "date": "1598880509", "time_retrieved": "2024-07-30T20:48:10.646295", "image_code": "const bool vertical = false;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 lines;\n    \n    if (vertical) {\n        lines = texture(iChannel0, uv.xx);\n    } else {\n        lines = texture(iChannel0, uv.yy);\n    }\n\n    fragColor = vec4(lines);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 85, 85, 303]], "test": "untested"}
{"id": "wt2fWz", "name": "Quantum Weirdness", "author": "Dave_Hoskins", "description": "Folding space to create complex shapes.\nAs usual, there is no beginning or end to it. Best FULL SCREEN, if you can.\nDefines in Common tab.\n\nThanks to Kali and his inspiring \"Spaghetti Ink\" shader maths: https://www.shadertoy.com/view/WtfXzf", "tags": ["3d", "raymarching", "quantum", "weirdness"], "likes": 19, "viewed": 1037, "published": 3, "date": "1598879543", "time_retrieved": "2024-07-30T20:48:11.999677", "image_code": "// Quantum Weirdness\n// by Dave Hoskins. August 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tune:-\n// \"Part of the third Zeitgeist album \"Quantum Weirdness\" // May 2012 [Glitchy.Tonic.Records]\"\n// https://soundcloud.com/zeitgeist-aka-r-cake/zeitgeist-subquantum\n\n\n\n// This function checks a rough area around the light source to see if any partly obscures it,\n// reducing the lense flare accordingly, or let's say, guessingly!\n\nfloat obscurePartsOfLight(vec2 p)\n{\n    float a = 0.0, z;\n    float e = .03;\n    float d = length(sunPos - camera);\n    vec2 asp = vec2(iResolution.y/iResolution.x,1.0);\n   \tvec2 texUV = .5+.5*p*asp;\n   \tz = texture(iChannel0, texUV).w;\n    if (z > d) a +=.5;\n    \n    texUV = .5+.5*(p+vec2(e, e))*asp;\n   \tz = texture(iChannel0, texUV).w;\n    if (z > d) a +=.125;\n\n    texUV = .5+.5*(p+vec2(e, -e))*asp;\n   \tz = texture(iChannel0, texUV).w;\n    if (z > d) a +=.125;\n\n    texUV = .5+.5*(p+vec2(-e, -e))*asp;\n   \tz = texture(iChannel0, texUV).w;\n    if (z > d) a +=.125;\n    \n    texUV = .5+.5*(p+vec2(-e, e))*asp;\n   \tz = texture(iChannel0, texUV).w;\n    if (z > d) a +=.125;\n\n    return a;\n}    \n\n\n//---------------------------------------------------------------------------------\nvec3 lenseFlare(vec2 uv,vec3 dir)\n{\n\n    vec3 col = vec3(0);\n    sunLight = normalize(sunPos - camera);\n\n    mat3 inv = transpose(camMat);\n    vec3 cp = inv * (camera - sunPos);\n\n    if (cp.z < 0.0)\n    {\n    \tvec2 sun2d = zProj * cp.xy / cp.z;\n         if (sun2d.x < -1.0 || sun2d.x > 1. || sun2d.y < -1.0 || sun2d.y > 1.) return col;\n\n        float z = obscurePartsOfLight(sun2d);\n        if (z > 0.0)\n        {\n            vec2 uvT = uv - sun2d;\n            uvT = uvT*(length(uvT));\n            float bri = max(dot(dir, sunLight)*.2, 0.0);\n            bri = pow(bri, 3.)*5.*z;\n\n\n            // glare1\n            float glare1 = max(dot(dir,sunLight),0.0);\n            // glare2\n            float glare2 = max(1.7-length(uvT+sun2d*1.8)*2.0, 0.0);\n            //uvT = mix (uvT, uv, -2.3);\n            // glare3\n\t\t\tfloat glare3 = max(1.-pow(length(uvT+sun2d*4.)*3., 2.), 0.0);\n\n            col += bri * vec3(.5, .5, .5)  * pow(glare1, 18.5)*3.5;\n            col += bri * vec3(.5, .5, .2) * pow(glare2, 2.0)*5.;\n          \tcol += bri * vec3(.2,.5, .5) * pow(glare3, 4.0)*5.0;\n        }\n\t}\n    return max(vec3(0.0),col);\n}\n// https://lime-limelemon.blogspot.com/2016/03/aces-filmic-tone-mapping-curve.html\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n    //return -0.053173 + x*(2.170622 + x*(-2.132296 + x*(0.996822 + x*-0.176583)));\n}\n\n//---------------------------------------------------------------------------------\nvoid mainImage( out vec4 colOut, in vec2 fragCoord )\n{\n    \n    float mouseX = iMouse.x / iResolution.x;\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n \n\n           // Setup camera...\n\ttime = getTime(iTime, mouseX);\n     // Setup camera...\n    camera = getCamPos(time);\n\tvec3 lookat = getTarPos(time);\n    camMat = getCamMat(camera, lookat, 0.);\n    zProj = projectZ(uv);\n    vec3 setDir = normalize( vec3(uv, zProj));\n\tvec3 rd = camMat * setDir;\n\tsunPos = getLightPos(time);\n  \n    \n    // Init output...\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    col += lenseFlare(uv, rd);\n\n    col = clamp(col, 0.0, 1.0);\n    col = acesFilm(col);// Filmic filter AND some over-kill contrast. Yeah!!!! :)\n\tcol = col*col*(3.0-2.0*col);\n    \n\t// Finally some border vignette...\n    uv = fragCoord / iResolution.xy;\n    col *= .5+ .5*pow(100.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.6 );\t\n    col *= smoothstep(0.0, 4.0, iTime);\n    #ifdef OFF_LINE\n    col *= smoothstep(374.0, 360.0, iTime);\n    #endif\n\n    colOut = vec4(sqrt(col), 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24207, "src": "https://soundcloud.com/zeitgeist-aka-r-cake/zeitgeist-subquantum", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// Quantum Weirdness\n// by Dave Hoskins. August 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nmat2 rotm;\nfloat pix;\nfloat mist;\n\n//--------------------------------------------------------------------------------\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    d+=fract(time*.2);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//--------------------------------------------------------------------------------\nvec3 texCube(sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture(sam, p.yz).xyz;\n\tvec3 y = texture(sam, p.zx).xyz;\n\tvec3 z = texture(sam, p.xy).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//--------------------------------------------------------------------------------\nmat2 rot2D(float a) {\n    a=radians(a);\n\tfloat s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n//--------------------------------------------------------------------------------\n// With thanks to Kali...\n// https://www.shadertoy.com/view/WtfXzf\nvec2 de(vec3 p)\n{\n    p=abs(15.-mod(p+15.,30.));\n    float md=200.;\n    float s=1.2;\n    float sc=1., id = 0.;\n    vec3 pc;\n    \n    float turn  = sin(time*1.3)*2.3;\n\n    float rot=sin(time*.3)*220.;\n    for (float i = 0.0; i < 1.0; i+= 1.0/4.0)\n    {\n      \tp.xy=abs(p.xy); \n        p=p*s-4./sc;\n        sc*=s;\n        p.xz*=rotm;\n        p.yz*=rot2D(2.+rot);\n        float d=length(p.xz+sin(p.y*turn));\n        if (d<md)\n        {\n        \tmd=d;\n\t\t\tpc=p;\n            id = i;\n        }\n    }\n    float l=max(0.2,(pc.y*.01));\n    return vec2((md/sc)*l, id);\n}\n\n//--------------------------------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = .1;\n\tfloat h;\n\t\n    for (int i = 0; i < 15; i++)\n\t{\n        vec3 p =  ro + rd*t;\n\n\t\th = de(p).x;\n\t\tres = min(6.*h / t, res);\n\t\tt += h;\n\t}\n    //res += t*t*.08; // Dim over distance\n    return clamp(res, .1, 1.0);\n}\n\n//--------------------------------------------------------------------------------\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------------\nvec2 rayMarch(vec3 ro, vec3 rd, vec2 uv)\n{\n    float l = hash12(uv)*.5;\n    int i;\n    vec2 d2;\n    mist = 0.0;\n    \n    #ifdef OFF_LINE\n    for (i = 0; i < 800; i++)\n    #else\n    for (i = 0; i < 300; i++)\n    #endif\n    {\n        vec3 p = ro + rd * l;\n        d2 = de(p);\n        mist += smoothstep(.12,.03,d2.x);\n        \n        if (abs(d2.x) < .03 || l > 1000.0) break;\n        #ifdef OFF_LINE\n        l += d2.x*.5;\n        #else\n        l += d2.x*.85;\n        #endif\n\t}\n    mist = pow(mist, 3.) * .0001;\n    return vec2(l, d2.y);\n}\n\n\n//--------------------------------------------------------------------------------\nvec3 lighting(vec3 p, vec3 nor, vec3 rd, vec3 mat)\n{\n    sunLight = normalize(sunPos - p);\n    float sh = shadow(p+sunLight*0.2,  sunLight);\n    float c = max(dot(nor, sunLight), 0.0)+abs(nor.y)*sh*.5;\n    vec3 ref = reflect(rd, nor);\n\n    vec3 spec = texture(iChannel0, ref).xyz;\n    vec3 col = ((mat * c)+ pow(spec, vec3(3.0))*.2)*sh;\n     #ifndef OFF_LINE\n    col+= mist * vec3((cos(time*1.51)+.5)*.1, 0.01, (sin(time*1.37)+.5)*0.1)  * sh;\n    #else\n    col+= mist * vec3((cos(time*1.51)+.5)*.1, 0.01, (sin(time*1.37)+.5)*0.1) * .3 * sh;\n    #endif\n    return col;\n    \n}\n\n\n//--------------------------------------------------------------------------------\nvec3 normal(vec3 p, float ds)\n{\n    ds *= ds;\n\tfloat e = min(.4, pix * ds);\n\n    return normalize( vec3( de(p+vec3(e,0.0,0.0)).x - de(p-vec3(e,0.0,0.0)).x,\n                            de(p+vec3(0.0,e,0.0)).x - de(p-vec3(0.0,e,0.0)).x,\n                            de(p+vec3(0.0,0.0,e)).x - de(p-vec3(0.0,0.0,e)).x));\n}\n\n//----------------------------------------------------------------------------------------\nvec3 lightSource(vec3 spotLight, vec3 dir, float dis)\n{\n    float g = 0.0;\n    if (length(spotLight) < dis)\n    {\n\t\tg = pow(max(dot(normalize(spotLight), dir), 0.0), 2000.0);\n    }\n   \n    return vec3(g, g*.8, g*.7)*.8;\n}\n\n\n//--------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // Normalise coordinates to whatever resolution / ratio we have...\n    float mouseX = iMouse.x / iResolution.x;\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    pix = .1/iResolution.y;\n    \n    rotm=rot2D(-30.);\n    \n    /// Init output...\n    vec3 col = vec3(0.);\n    \n\n    // Setup camera...\n    time = getTime(iTime, mouseX);\n    camera = getCamPos(time);\n\tvec3 lookat = getTarPos(time);\n    \n    camMat = getCamMat(camera, lookat, 0.);\n    zProj = projectZ(uv);\n\n    vec3 setDir = normalize( vec3(uv, zProj));\n\tvec3 rd = camMat * setDir;\n    \n    //mat3 camMat = getCamMat(uv, camera, lookat,0.0, rd);\n    sunPos = getLightPos(time);\n    \n    vec2 dis = rayMarch(camera, rd, fragCoord);\n    if (dis.x < 1000.0)\n    {\n        vec3 p  = camera + rd * dis.x;\n        vec3 nor = normal(p, dis.x);\n        vec3 matA =  pal( dis.y*1.8, vec3(0.4,0.4,0.3),vec3(.4,.2,.2),vec3(.4, .9, .5),vec3(0.4, 0.1, 1.0) );\n        vec3 matB =  pal( dis.x, vec3(0.4,0.4,0.3),vec3(.4,.2,.2),vec3(.4, .9, .5),vec3(0.4, 0.1, 1.0) );\n        matA = mix(matA, matB, .5);\n        col = lighting(p, nor, rd, matA);\n        \n        \n        float fog = exp(-dis.x*.018);\n        col = mix(vec3(0,0,.1), col, fog);\n    }\n  \n/*\n    #ifndef OFF_LINE\n    col+= mist *vec3(0, .0, 0.1) * .5;\n    #else\n    col+= mist *vec3(.0, .0, 0.1) * .04;\n    #endif\n*/\n    \n    col += lightSource(sunPos - camera, rd, dis.x);\n  \n    col = clamp(col, 0.0, 1.0);\n\n    // Output to buffer\n    fragColour = vec4(col,dis.x);\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Quantum Weirdness\n// by Dave Hoskins. August 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// #define OFF_LINE\n// #define USE_TIME_MOUSE\n\nfloat time;\nvec3 camera;\nmat3 camMat;\nmat4 camMat4;\nvec3 sunLight;\nvec3 sunPos;\nfloat zProj;\nfloat fov = 1.;\n//--------------------------------------------------------------------------------\n\nmat3 getCamMat( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n//--------------------------------------------------------------------------------\nvec3 getCamPos(float t)\n{\n\n    vec3 p = vec3(28.0*sin(t*.31),\n                  28.0*cos(t*.32),\n                  28.0*cos(t*.30));\n    return p;\n}\n\nvec3 getTarPos(float t)\n{\n    vec3 p = vec3(80.0*cos(t*.51),\n                  80.0*sin(t*.6),\n                  80.0*sin(t*.66));\n    return p;\n}\n\n\n//--------------------------------------------------------------------------------\nvec3 getLightPos(float t)\n{\n\tt+=20.;\n    vec3 p = vec3(30.0*sin(t*1.3+5.),\n                  30.0*sin(t*.5),\n                  30.0*sin(t*1.4));\n    return p;\n}\n\n//--------------------------------------------------------------------------------\nfloat getTime(float iTime, float mx)\n{\n    float t = iTime*.1  +270.0;\n    #ifndef OFF_LINE\n    #ifdef  USE_TIME_MOUSE\n\tt += mx*5.0;\n    #endif\n    #endif\n    return t;\n}\nfloat projectZ(vec2 uv)\n{\n    return .75;\n   //return cos(length(uv*.75));\n}\n    \n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2fWz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[479, 479, 514, 514, 1171], [1178, 1262, 1297, 1297, 2382], [2383, 2466, 2495, 2495, 2783], [2785, 2869, 2923, 2923, 3935]], "test": "untested"}
{"id": "WtjBW1", "name": "27. Ray Marching for Dummies", "author": "altera0", "description": "Source : https://www.youtube.com/watch?v=PGtv-dBi2wE\nMy Game :  https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["raymarching"], "likes": 0, "viewed": 287, "published": 3, "date": "1598868383", "time_retrieved": "2024-07-30T20:48:12.800536", "image_code": "#define MAX_DIST 100.0\n#define MAX_STEP 100.0\n#define SURF_DIST 0.01\t\t// 이 범위 안이면 더 이상 할 필요 없이 충돌한 것으로 인정하기\n\nfloat GetDist( vec3 p ) {\n\n    vec4 sphere = vec4( 0 , 1.5 , 6 , 1 ); // XYZ + scale\n    \n    float sphereDist = length( p - sphere.xyz ) - sphere.w;\n    \n    float planDist = p.y;\n        \n\tfloat minDist = min ( planDist , sphereDist );\n    \n    return minDist;\n}\n\n\nfloat RayMarch( vec3 ro , vec3 rd ) {\n\tfloat dO = 0.0;\n\n    for ( float i = 0.0 ; i < MAX_STEP ; i++ ) {\n    \n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        \n        if ( dO > MAX_DIST || dS < SURF_DIST ) break;\n    }\n    \n    \n    // 거리를 리턴한다.\n    return dO;\n}\n\n\nvec3 GetNormal( vec3 p ) {\n    float d = GetDist(p);\n    \n    vec2 e = vec2( 0.01, 0.0 );\n    vec3 n = d - vec3(\n        \tGetDist( p - e.xyy ),\n        \tGetDist( p - e.yxy ),\n        \tGetDist( p - e.yyx )\n        );\n                       \n    return normalize( n );\n}\n\n\n\nfloat GetLight( vec3 p ) {\n    vec3 lightPos = vec3( 0, 5, 6 );\n    lightPos.zx += vec2( sin(iTime) , cos(iTime)  ) * 2.0;\n    \n    vec3 l = normalize( lightPos - p );\n\n    vec3 n = GetNormal(p);\n    \n    float diffuse = clamp( dot ( n , l ) , 0.0 , 1.0 ) ;\t// same as 1 * 1 * cos(t)\n\n    // Shdow\n    float d = RayMarch( p + n * SURF_DIST * 2.0 , l );\n    if ( d < length( lightPos - p )) diffuse *= 0.25;\n\n    \n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy ) /iResolution.y;\n\tvec3 col = vec3(0);\n\n    vec3 ro = vec3( 0 , 1 , 0 );\n    vec3 rd = normalize( vec3( uv.x , uv.y , 1) );\n    \n    float d = RayMarch( ro , rd );\n    vec3 intersectionPoint = ro + rd * d;\n\n    \n    float diffuse = GetLight( intersectionPoint );\n\n    col = vec3(diffuse);\n    \n     \n    fragColor = vec4(col,1.0);\n}\n\n/*\n\t1. 구성요소\n\n\t\t1. 카메라 IN ( UV, POS, Lookat, Zoom ) OUT( View Ray )\n\t\t2. Ray Intersection ( Ray ) => ( Distance )\n\t\t3. Material & Lighting ( Material, Distance , Light ) => PixelColor\n\n\t2. 심플한 카메라 모델을 만든다.\n\n\n\t3. 어떻게 InterSection을 판별해 내는가?\n\n\t\t1. lookAt으로 광선을 쏜다.\n\t\t2. 광선의 각 등분된 지점에서 오브젝트와의 거리를 체크한다.\n\t\t3. 체크된 거리중에서 가장 작은 것을 선택한다. ( 이게  오브젝트까지의 거리이다. )\n\t\t\n\t\t4. 이렇게 하면, 규칙이 없는 랜덤한 물체에 대해서는 일단은 판별이 어려운 점이 있긴하다.\n\t\t5. 하지만 일단은 이렇게 본다.\n\n\n\t\t6. [ 중요 ] 체크하는 방법이 각 오브젝트 마다 다르다. \n\n\t\t\t* 스피어, 사각형, 원통 등에 따라 다 다르다.\n\n\n\n\n\t3-1 . 체크 방법\n\n\t\t1. 카메라의 rd ( Ray Dirction )을 타고 내려가면서, 스피어의 중심점과 계속해서 비교를 한다.\n\n\n\n\t4. RayMarch( vec3 ro , vec3 rd )   만들기\n\n\t5. GetDist( vec p ) 만들기\n\n\t6. 노멀 만들기\n\n\t7. 라이팅의 개념을 넣는다.  \n\n\t\t* 라이트의 포지션 계산\n\t\t* 라이트 노멀에 대한 계산\n\t\t* 힛팅 포인트에서 e만큼 xyz 축으로 뺀다음. 노멀라이즈 한다.\n\n\n\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 182, 182, 421], [424, 424, 461, 461, 740], [743, 743, 769, 769, 1011], [1015, 1015, 1041, 1041, 1449], [1451, 1451, 1508, 1508, 1889]], "test": "untested"}
{"id": "3ljBD1", "name": "Spinning Torus", "author": "milesWaugh", "description": "Raymarched torus with fresnel reflectance, blinn-phong specular model, shadows, and reflections. 2.2 gamma corrected. ", "tags": ["raymarching", "torus", "shadows", "reflections", "fresnel", "blinnphongspecularity"], "likes": 9, "viewed": 521, "published": 3, "date": "1598850644", "time_retrieved": "2024-07-30T20:48:13.682179", "image_code": "#define s sin(iTime)\n#define c cos(iTime)\n#define dist 4.0\n\nfloat sd(vec3 pos, float d) {\n    vec3 p = pos - vec3(0, 0, d);\n    float py = p.y;\n    p.y = p.y * c - p.z * s;\n    p.z = p.z * c + py * s;\n    vec2 t = vec2(1.0, .4);\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ambient = vec3(0.4, 0.7, 1.0) / 5.0;\n    vec3 light = normalize(vec3(0.8, 0.5, -0.5));\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    int iters = 0;\n    float raylength = 0.0;\n    vec3 incoming = normalize(vec3(uv, 1));\n    float SDE = 1.0;\n    vec3 z = vec3(0.0);\n    \n    while(iters < 5000 && abs(raylength) < 100.0 && abs(SDE) > 0.00001) {\n        z = raylength * incoming;\n        SDE = sd(z, dist);\n        raylength += SDE;\n        iters++;\n    }\n    \n    vec3 col = ambient;\n    if(abs(SDE) <= 0.00001) {\n        vec3 inVec = incoming;\n        vec3 z1 = z;\n        raylength = 0.0;\n        incoming = normalize(vec3(uv.x + 0.0001, uv.y, 1));\n        SDE = 1.0;\n        z = vec3(0.0);\n        iters = 0;\n        \n        while(iters < 5000 && abs(raylength) < 100.0 && abs(SDE) > 0.00001) {\n            z = raylength * incoming;\n            SDE = sd(z, dist);\n            raylength += SDE;\n            iters++;\n        }\n        \n        vec3 z2 = z;\n        raylength = 0.0;\n        incoming = normalize(vec3(uv.x, uv.y + 0.0001, 1));\n        SDE = 1.0;\n        iters = 0;\n        while(iters < 5000 && abs(raylength) < 100.0 && abs(SDE) > 0.00001) {\n            z = raylength * incoming;\n            SDE = sd(z, dist);\n            raylength += SDE;\n            iters++;\n        }\n        \n        vec3 z3 = z;\n        raylength = 0.0001;\n        incoming = light;\n        SDE = 1.0;\n        z = vec3(0.0);\n        iters = 0;\n        while(iters < 5000 && abs(raylength) < 100.0 && abs(SDE) > 0.00001) {\n            z = raylength * incoming;\n            SDE = sd(z + z1, dist);\n            raylength += SDE;\n            iters++;\n        }\n        \n        vec3 a = z3 - z1;\n        vec3 b = z2 - z1;\n        vec3 color = vec3(1.5, 1.0, 0.5);\n        vec3 normal = normalize(vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x));\n        vec3 reflection = normal * 2.0 * dot(normal, inVec) - inVec;\n        raylength = 0.01;\n        incoming = -reflection;\n        SDE = 1.0;\n        z = vec3(0.0);\n        iters = 0;\n        while(iters < 5000 && abs(raylength) < 100.0 && abs(SDE) > 0.00001) {\n            z = raylength * incoming;\n            SDE = sd(z + z1, dist);\n            raylength += SDE;\n            iters++;\n        }\n        \n        vec3 diffuse = (vec3(max(dot(normal, light) * 5.0, 0.0) * color) + ambient) * 0.1;\n        vec3 specular = pow(max(dot(normalize(light - inVec), normal), 0.0), 200.1) * 9.0 + ambient;\n        if(abs(SDE) <= 0.00001) {\n            specular = ((1.0 * color) + ambient) * 0.1;\n        }\n        float fresnel = 0.05 + 0.95 * pow(1.0 + dot(inVec, normal), 5.0);\n        col = diffuse * (1.0 - fresnel) + specular * fresnel;\n    }\n\n    fragColor = vec4(pow(col.x, 0.4545), pow(col.y, 0.4545), pow(col.z, 0.4545), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 89, 89, 302], [304, 304, 359, 359, 3183]], "test": "untested"}
{"id": "WlBfWR", "name": "Disintegrate to Circles", "author": "hugoaboud", "description": "Simple 2D disintegration of an input texture to alpha using overlapping circle patterns.", "tags": ["2d", "circles", "disintegration"], "likes": 4, "viewed": 565, "published": 3, "date": "1598844836", "time_retrieved": "2024-07-30T20:48:14.532904", "image_code": "/*\n\tThis program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, version 3.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Shader properties */\n\nvec4 transp = vec4(0.0,0.0,0.0,0.0);\nvec4 color1 = vec4 (0.867, 0.675, 0.557, 1.0);\nvec4 color2 = vec4 (0.871, 0.843, 0.804, 1.0);\n\nfloat w = 0.008; // width of grid (UV coords)\nfloat shrinkSpeed = 0.7; // shrinking\nfloat lineSpeed = 0.2; // line scan\nfloat fadeSpeed = 1.0; // color fade\n\nfloat time = 0.0; // animation time\n\n/* Random */\n\n#define SEED 987654.321\n// Generates a random float from another 2D vector\n// seed must be a large number\n// output range: [0..1[\nfloat randFloat(in vec2 vec, in float seed)\n{\n    return fract(sin(vec.x*99.9+vec.y)*seed);\n}\n\n/* DisintegrateToCircles Shader\n\n\tThis shader uses a pattern from \"A Handbook of Ornament\", by Franz Sales Meyer (page 21, pattern 2).\n\tAfter filling the original 90° arcs for each block of the grid, the shader completes each circle\n\tby drawing arcs from the opposite end of the block.\n\tThe radiuses are shrunk in random rates, calculated by the original semicircle position on grid.\n\tThe color is faded from the original color to two different colors, which adds depth to the pattern,\n\tand a nice \"glow\" effect on the border of the disintegration.\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // To visualize the animation in Shadertoy, the time is updated to global time\n    // When using the shader, the time property should be animated extternally\n    time = iTime;\n    \n    // Calculate UV and get input color\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 img = texture(iChannel0, uv.xy);\n    \n    // Calculate height from aspect, for square grid\n    float h = w * (iResolution.x/iResolution.y);\n    \n    // Scale grid so that each square goes from 0..1   \n    uv.x /= w;\n    uv.y /= h;\n    \n    // Offset rows 3 and 4\n    if (int(uv.y)%4>1) uv.x += 2.0;\n    \n    // Calculate local coordinates in the block\n    // And grid coordinates\n    vec2 local = fract(uv);\n    int xg = int(uv.x);\n    int yg = int(uv.y);\n\n    // Line sweep position\n    float line = time * lineSpeed * (1.0/h);\n    \n    // Draw\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    // Above the line, just draw the image\n    if (yg/2 > int(line/2.0)) {\n        color = img;\n    }\n    // Below the line, draw pattern\n    else {\n        // Flip local coordinates according to pattern\n        int xp = xg%4;\n        int yp = yg%2;\n        if (yp == 0) {\n            if (xp == 0 || xp == 1) local.y = 1.0 - local.y;\n            if (xp == 1 || xp == 2) local.x = 1.0 - local.x;\n        }\n        else if (yp == 1) {\n            if (xp == 1 || xp == 2) local.x = 1.0 - local.x;\n            if (xp == 2 || xp == 3) local.y = 1.0 - local.y;\n        }\n\n        // Get random scale for each main semi-circle\n        float rscale = 0.0;\n        if (xp < 2) rscale = randFloat(vec2(xg,yg/2), SEED);\n        else rscale = randFloat(vec2(xg/2,yg), SEED);\n\n        // Get random scale of neighbour semi-circle\n        float nrscale = 0.0;\n        if (xp < 2) {\n            if (yp == 1) {\n                if ((yg/2)%2 == 0) nrscale = randFloat(vec2(xg/2+1,yg+1), SEED);\n                else nrscale = randFloat(vec2(xg/2-1,yg+1), SEED);\n            }\n            else {\n                if ((yg/2)%2 == 0) nrscale = randFloat(vec2(xg/2+1,yg-1), SEED);\n                else nrscale = randFloat(vec2(xg/2-1,yg-1), SEED);\n            }\n        }\n        else {\n            if (xp == 2) nrscale = randFloat(vec2(xg-1,yg/2), SEED);\n            else nrscale = randFloat(vec2(xg+1,yg/2), SEED);\n        }\n\n        // Clip scales to range [0,0.5[\n        rscale = rscale/2.0+0.5;\n        nrscale = nrscale/2.0+0.5;\n\n        // Calculate distance and neighbour distance to center\n        float dist = length(local);\n        float ndist = length(1.0-local);\n\n        // Animate radius\n        float radius = 1.0 - time * rscale * shrinkSpeed;\n        float nradius = 1.0 - time * nrscale * shrinkSpeed;\n\n        // Time offset for y position\n        float t = ((uv.y*h)/lineSpeed);\n        radius += t*rscale*shrinkSpeed;\n        nradius += t*nrscale*shrinkSpeed;\n        \n        // Color fade time\n        if (time > t) t = (time-t)*fadeSpeed;\n        else t = 0.0;\n        \n        // Draw circles\n        if (xp < 2) {\n            if (dist <= radius) color += mix(img, color1, t);\n            else if (ndist <= nradius) color += mix(img, color2, t);\n        }\n        else {\n            if (dist <= radius) color += mix(img, color2, t);\n            else if (ndist <= nradius) color += mix(img, color1, t);\n        }\n    }\n    \n    fragColor = color;\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBfWR.jpg", "access": "api", "license": "gpl-1.0-plus", "functions": [[982, 1088, 1133, 1133, 1181], [1738, 1738, 1795, 1957, 5106]], "test": "untested"}
{"id": "3ljBW1", "name": "Triple cubemap + high fov 🤔", "author": "xacer", "description": "Does it need a description", "tags": ["raymarching", "fov", "cubemaps"], "likes": 1, "viewed": 339, "published": 3, "date": "1598837434", "time_retrieved": "2024-07-30T20:48:15.298856", "image_code": "\n\n\nconst int MAXSTEPS = 400;\nconst float EPSILON = 0.001;\n\nvec3 cam = vec3(0.0, 0.0, 0.0);\nmat3 camMatrix = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n\nvec3 createRay (in vec2 uv) {\n\treturn normalize(vec3(uv, 1.0)) * camMatrix;\n}\n\nvoid kib (inout vec2 prev, in float d, in float id) {\n    if (prev.x > d) {\n    \tprev.x = d;\n        prev.y = id;\n    }\n}\n\nfloat sdSphere (in vec3 p, in vec3 c, in float r) {\n    return r - length(p - c);\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 map (in vec3 p) {\n    vec2 v = vec2(1.0 - sdBox(p, vec3(1.0)), 1.0);\n    return v;\n}\n\nconst vec3 xDir = vec3(0.00001, 0, 0);\nconst vec3 yDir = vec3(0, 0.00001, 0);\nconst vec3 zDir = vec3(0, 0, 0.00001);\nvec3 surfaceNormal (in vec3 pos) {\n    vec3 normal = vec3(\n        map(pos + xDir).x - map(pos - xDir).x,\n        map(pos + yDir).x - map(pos - yDir).x,\n        map(pos + zDir).x - map(pos - zDir).x\n    );\n    return normalize(normal);\n}\n\nvec3 ld = vec3(1.0, 0.0, 0.0);\n\nvec3 trace (in vec3 ro, in vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < MAXSTEPS; i ++) {\n    \tvec3 pos = ro + t * rd;\n        vec2 dist = map(pos);\n        if (dist.x < EPSILON) {\n        \tvec3 no = surfaceNormal(pos);\n            \n            float diffuse = max(-dot(no, ld), 0.0);\n            float specular = max(-dot(reflect(rd, no), ld), 0.0);\n            specular = pow(specular, 32.0);\n            \n            //float shade = diffuse * 0.7 + specular * 0.3;\n            float shade = 1.0;\n            vec3 tint = texture(iChannel0, pos).rgb;\n            \n            vec3 an = abs(no);\n            if (an.x > an.y && an.x > an.z) {\n           \t\ttint = texture(iChannel1, pos).rgb;\n            } else if (an.y > an.x && an.y > an.z) {\n            \ttint = texture(iChannel2, pos).rgb;\n            }\n            return shade * tint;\n            \n        }\n        t += dist.x;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    ld.x = -cos(iTime);\n    ld.z = -sin(iTime);\n    \n    float xyRot = (iMouse.x - iResolution.x / 2.0) / 90.0;\n    float zRot = (iMouse.y - iResolution.y / 2.0) / 90.0;\n   \tcamMatrix = mat3(1, 0, 0,\t0, cos(zRot), sin(zRot),0, -sin(zRot), cos(zRot)) * \n\t\t\tmat3(cos(xyRot), 0, sin(xyRot), 0, 1, 0, -sin(xyRot), 0, cos(xyRot));\n    \n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 20.0 * (fragCoord-(iResolution.xy/2.0))/max(iResolution.x, iResolution.y);\t\n    vec3 ray = createRay(uv);\n    \n    vec3 col = trace(cam, ray);\n    \n    // Output to screen\n    fragColor = vec4(col.rgb, 1.0);\n}\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 189, 189, 237], [239, 239, 292, 292, 360], [362, 362, 413, 413, 445], [447, 447, 478, 478, 569], [571, 571, 593, 593, 660], [779, 779, 813, 813, 1016], [1050, 1050, 1087, 1087, 1972], [1974, 1974, 2031, 2031, 2656]], "test": "untested"}
{"id": "WtjfWh", "name": "26. Voroni Noise", "author": "altera0", "description": "Source : https://www.youtube.com/watch?v=l-07BXzNdPw\nMy Game :  https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["voroninoise"], "likes": 5, "viewed": 401, "published": 3, "date": "1598836520", "time_retrieved": "2024-07-30T20:48:16.142600", "image_code": "#define S( a , b , t ) smoothstep( a , b , t )\n\nvec2 N22( vec2 p ) {\n\tvec3 a = fract( p.xyx * vec3( 123.34 , 234.34 , 345.65));\n    a += dot (a , a + 34.45 );\n    return fract( vec2( a.x * a.y , a.y * a.z ) );\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.0 * fragCoord - iResolution.xy ) /iResolution.y;\n\n    vec3 col = vec3(0);\n\n    float m = 0.0;\n    \n    float minDist = 100.0;\n    float cellIndex = 0.0;\n    \n    if ( false ) {\n\t    for ( float i = 0.0 ; i < 50.0 ; i++ ) {\n        \tvec2 n22 = N22( vec2(i , i )) ;\n    \t\tvec2 p = sin( n22 * iTime );\t\t\t// 하나의 UV 마다 50개 전체에 대해서 전부다 공을 만들어서 거리를 비교한다.\n        \n        \tfloat dist = length( uv - p );\n        \t//float dist = distance( uv , p );\n        \n        \tm += S( 0.015, 0.01 , dist );\n        \n        \tif ( dist < minDist ) {\n    \t    \tminDist = dist;\n\t            cellIndex = i;\n        \t}\n    \t} \n   \t\tcol = vec3( minDist );\n\n    } else {\n    \n    \tuv *= 3.0;\n        vec2 gv = fract(uv) - 0.5;\n        vec2 id = floor(uv);\n    \tvec2 cellId = vec2(0);\n        \n        \n        for ( float y = -1.0 ; y <= 1.0 ; y++ ) \n            for ( float x = -1.0 ; x <=1.0 ; x++ ) {\n\t            \n                vec2 offset = vec2( x , y );\n                vec2 n = N22( id + offset );\n                vec2 p = offset + sin( iTime * n ) * 0.3;\n                             \n                float dist = length( gv - p );\n                \n                col += S( 0.03, 0.01 , dist );\n                             \n                if ( dist < minDist ) {\n                \tminDist = dist;   \n                    cellId = id + offset;\n                }\n            \n            }\n       \t\tcol = col + vec3( minDist );\n\t\t    col.rg = cellId * 0.1;\n }\n    \n    \n    \n    \n    \n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n\n/*\n\t1. 기본 아이디어\n\t\t\n\t\t2D 공간에 랜덤하게 점을 찍고 가장 가까운 점들 끼리, 연결하여 색깔을 나타낸다.\n\n\t\t현재의 UV에서 가장 가까운 점까지의 거리의 값을 smoothStep()하면 그것이 [ 보르노이 패턴 선 ]이 된다.\n\n\t2. N22() 함수 만들기\n\n\t\t* Fract()와 곱하기의 조화\n\n\t3. 랜덤한 공 50개를 생성 ( for Loop )\n\n\t4. 가장 가까운 cell 인덱스를 찾는다.\n\n\t5. 이런식의 ( 모든 반복 )은 포인트가 많아 질수록 너무 많은 연산을 필요로 한다.\n\n\t\t* 따라서 이걸 바꾼다.\n\n\t6. 셀을 나누고,  ID와 GV만을 가지고, 주위 9개의 셀과의 연산만을 하도록 한다.\n\n\t\t* Universe에서 했던것과 같다.\n\n\t7. 셀에서 각지는 부분은 Sin() * 0.5를 해서 -0.5와 0.5 사이의 값으로 확실히 만들어 둔다.\n\n\t8. 맨해턴 디스턴스 부분이 있는데, 이건 별다른 의미가 없는 것 같다.\n\n\n*/\n\n/* 공통 아이디어 \n\n\t1. 1보다 작은 수가 필요할때 ==> Fract()\n\t2. 무빙이 필요할때 ==> Sin() cos()\n\t3. 랜덤 무빙이 필요할따. Fract(), sin(), Cos() 조합해서 사용\n\n\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjfWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 68, 68, 216], [218, 218, 275, 275, 1862]], "test": "untested"}
{"id": "Wl2fWh", "name": "Menger beat", "author": "illus0r", "description": "Mix by Ilya Birman: https://soundcloud.com/ilyabirman/studio-mix-synthopia", "tags": ["raymarching", "sound", "menger", "sponge"], "likes": 3, "viewed": 346, "published": 3, "date": "1598829166", "time_retrieved": "2024-07-30T20:48:16.926504", "image_code": "#define textureCube texture\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define iTime (iTime / 10.1)\n\n#define BEAT0 texture(iChannel0, vec2(0.25, 0.25) ).x\n#define BEAT1 texture(iChannel0, vec2(0.5, 0.25) ).x\n#define BEAT2 texture(iChannel0, vec2(0.75, 0.25) ).x\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 polarToDecart(vec2 polar) {\n    float alpha = polar.x;\n    float R = polar.y;\n    float x = sin(alpha) * R;\n    float y = cos(alpha) * R;\n    return vec2(x, y);\n}\n\nvec2 decartToPolar(vec2 decart) {\n    float alpha = atan(decart.x, decart.y);\n    float R = length(decart);\n    return vec2(alpha, R);\n}\n\n\nfloat Menger(vec3 p)\n{\n    int n = 0;\n    float scale = 0.33 + .3 * smoothstep(0., 1., BEAT2);//0.433333;\n    int iterations = int((BEAT0 + 0.2) * 5.);\n    p.xz *= Rot(/* -2. * PI * iMouse.x / iResolution.x +  */-BEAT0);\n    p.xy *= Rot(/*-2. * PI * iMouse.y / iResolution.y*/-BEAT1);\n   while (n < iterations) {\n        p /= scale;\n    p.xy *= Rot(/*-2. * PI * iMouse.y / iResolution.y*/BEAT1);\n    p.xz *= Rot(/* -2. * PI * iMouse.x / iResolution.x +  */BEAT0);\n        p.z = -abs(p.z);\n        p.y = abs(p.y);\n        p.x = abs(p.x);\n        p -= (vec3(2., 2., -2.));\n        if(p.x+p.z<0.) p.xz = -p.zx;\n        if(p.y+p.z>0.) p.yz = -p.zy;\n        p.y += 2.;\n        p.y = abs(p.y);\n        p.y -= 1.;\n        p.y = abs(p.y);\n        p.y -= 1.;\n        n++;\n    }\n    return sdBox(p, vec3(1)) * pow(scale, float(iterations));\n}\n\nfloat sdColumn(vec3 p, float width) {\n\t//p.y = mod(p.y, 1.);\n    float fractal = Menger(p);\n    return fractal;\n}\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    vec2 ar = decartToPolar(p.xz);\n    float a = ar.x, r = ar.y;\n    float astep = 2. * PI / 6.; // number of rays\n    a = mod(a, astep);\n    a -= astep / 2.;\n    a = abs(a);\n    p.xz = polarToDecart(vec2(a, r));\n    // float cyl = length(p.xz - vec2(0, 2)) - 0.2;\n    p.xz += vec2(1., .5);\n    p.xz *= Rot(iTime + p.y * 0.05);\n    float column = sdColumn(p, 2.5);\n    return vec2(column, RED);\n    // return cyl < column? vec2(cyl, BLACK) : vec2(column, IVORY);\n//   return vec2(max(DE(p), length(p.xz+vec2(1)) - 0.1), BLUE);\n//   return vec2(DE(p) + length(p) - 4., BLUE);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    int steps = 0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        steps++;\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, steps);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\n\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // ray origin\n    float camRadius = 2.;\n    vec3 ro = vec3(EPSILON, camRadius, 0);\n    ro.yz *= Rot(iTime);\n    // ro.xz *= Rot(iMouse.x / iResolution.x * PI * 2.);\n    float zoom = 1.100;\n\n    // ray direction\n    vec3 rd = getRayDir(uv, ro, vec3(0), 1.);\n\n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n    float steps = rm[2];\n\n    vec3 color;\n    color = vec3(1);\n    vec3 light = vec3(camRadius * cos(iTime * .2), 20, camRadius * sin(iTime * .2));\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \t// color = vec3( n * 0.5 + 0.5 );\n\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        // drop shadows\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color *=  0.;\n        // }\n\n        // smooth shadows\n        // float shadow = smoothstep(0.0, .15, rayMarchLight.z / PI);\n        // color += .1 + .9 * shadow;\n\n\n\n\n        // tex *= color_bw;\n        // color = tex;\n        // color += 0.6 + vec3( color_bw );\n        // coloring\n        if (d < MAX_DIST) {\n            if (info == IVORY) {\n                color = vec3(.4 * (dot(n, normalize(light - p))) + 1.);\n                // color *= vec3(0.832,0.800,0.849);\n            }\n            else if (info == BLUE) {\n                color *= vec3(0.810,0.256,0.397);\n            }\n           else if (info == RED) {\n                color = vec3(.4 * (dot(n, normalize(light - p))) + 1.);\n                // vec3 color1 = vec3(0.810,0.256,0.397);\n                // vec3 color2 = color1.zyx;\n                // color = mix(color1, color2, steps / 10.);\n                //color *= vec3(0.810,0.256,0.397);\n                vec3 beatColor = vec3(BEAT0, BEAT1, BEAT2);\n                beatColor = (beatColor - 0.4) * 8.;\n                color *= beatColor;\n                color /= steps / 10.;\n            }\n            else if (info == BLACK) {\n                color = vec3(0.);//vec3(.0 + 0.2 * (dot(n, normalize(light - p))) + 1.);\n                // color *= vec3(0.130,0.130,0.130);\n                // color *= 5. / length(p.xz);\n            }\n            // color = mix(color, colorBg, smoothstep(20., 28., d));\n        }\n    }\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 23827, "src": "https://soundcloud.com/ilyabirman/studio-mix-synthopia", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2fWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 410, 429, 429, 492], [494, 494, 525, 525, 612], [614, 614, 646, 646, 781], [783, 783, 816, 816, 919], [922, 922, 944, 944, 1754], [1756, 1756, 1793, 1816, 1869], [1871, 1950, 1972, 1972, 2549], [2638, 2638, 2671, 2671, 3051], [3053, 3053, 3077, 3077, 3295], [3299, 3299, 3353, 3353, 3580], [3582, 3582, 3632, 3632, 3823], [3826, 3826, 3882, 3882, 6602]], "test": "untested"}
{"id": "tlSBRD", "name": "25. The Universe 2", "author": "altera0", "description": "Source : https://www.youtube.com/watch?v=KGJUl8Teipk\ny Game :  https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["theuniverse"], "likes": 12, "viewed": 458, "published": 3, "date": "1598826265", "time_retrieved": "2024-07-30T20:48:17.690461", "image_code": "#define S(a, b, t) smoothstep( a, b, t )  \n\nfloat DistLine( vec2 p , vec2 a , vec2 b ) {\n\n    // Line ba에 Pa를 직교 투영한다.\n    \n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float t = clamp( dot( pa , ba ) / dot ( ba , ba ) , 0.0 , 1.0 );\n    \n    return length( pa - ba * t );\n        \n}\n\nfloat N21( vec2 p ) {\n\n    p = fract( p * vec2( 233.34 , 851.73));\n    p += dot( p, p+23.45);\n    return fract(p.x * p.y );\n}\n\nvec2 N22( vec2 p ) {\n\tfloat n = N21( p );\n    return vec2( n , N21( p + n ) );\n}\n\n\n\nvec2 GetPos( vec2 id , vec2 offset ) {\t// from id\n    \n    //vec2 n = N22( id + offset ) * iTime ;\n    vec2 n = N22( id + offset ) * iTime ;\n    \n    //float x = sin ( iTime * n.x );\n    //float y = cos ( iTime * n.y );\n    \n    return offset + sin( vec2(n) ) * 0.4;\t\t// 0.4, it is Important that balls is in grid cell.\n    \n}\n\nfloat Line( vec2 p , vec2 a , vec2 b ) {\n\tfloat d = DistLine( p , a, b );\t\t\t// distance (a - b ) from p.\n   \tfloat m = S( 0.03, 0.01 , d );\n    \n    // 이게 오묘한 식이다, p와의 거리가 아니라, ( a - b )의 거리를 말한다.\n    float d2 = length( a - b );\n    m *= S( 1.2, 0.8 , d2 ) * 0.5 + S( 0.05, 0.03, abs( d2 -0.75 ) );\n    \n    return m;\n}\n\n\nfloat  Layer( vec2 uv ) {\n\tfloat m = 0.0;\n    vec2 gv = fract(uv) - 0.5f;\t// center point to ( 0 , 0 ) local uv\n    vec2 id = floor(uv);\n    \n    \n    //vec2 p = N22( id ) - 0.5;\t// Random point based on each grid center.\n    \n    //vec2 p = GetPos( id );\n    //float d = length( p - gv );\n    \n\t\n    int i = 0;\t\t// index\n    vec2 p[9];\t\t// 9 cell\n    \n    for (float y = -1.0 ; y <= 1.0 ; y++ ) {\n        for ( float x = -1.0 ; x <= 1.0 ; x++ ) {\n        \tp[i++] = GetPos( id , vec2( x , y ));\n        }\n    }\n    \n    \n    float t = iTime * 10.0;\n    for ( int i = 0 ; i < 9 ; i++ ) {\n    \tm += Line( gv, p[4] , p[i] );\t// p[4] is mine\n        \n        vec2 j = ( p[i] - gv ) * 20.0;\n        float sparkle = 1.0 / dot(j,j);\n        \n        \n        \n        m += sparkle * ( sin(t + fract(p[i].x ) * 10.0 ) * 0.5 + 0.5 ) ;\n    }\n    \n    m += Line( gv, p[1] , p[3] );\t// p[4] is mine\n    m += Line( gv, p[1] , p[5] );\t// p[4] is mine\n    m += Line( gv, p[7] , p[3] );\t// p[4] is mine\n    m += Line( gv, p[7] , p[5] );\t// p[4] is mine\n    \n\n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy - 0.5;\n    \n    //float d = DistLine( uv , vec2(0) , vec2(1) );\n    //float m = S( 0.1, 0.05 , d );\n    \n    //m = N22( uv ).x;\n\n    float m = 0.0;\n    float t = iTime * 0.1;\n\n\t// rotation\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2( c , -s , s , c );\n    uv *= rot;\n    \n    mouse *= 5.0;\n    mouse *= rot;\n    \n    for ( float i = 0.0 ; i <= 1.0 ; i += 1.0/4.0) {\n        float z = fract(i + t );\n        float size = mix( 10.0 , 0.5 , z );\n        \n        float fadeIn = S( 0.0 , 0.5 , z );\n        float fadeOut = S( 1.0 , 0.8 , z );\n        float fade = fadeIn * fadeOut;\t\t\t// 이것도 오묘한 식이다. fade In과 Fade Out을 어떻게 적용하는지 잘 볼 것.\n        \n    \tm += Layer( uv * size +i * 20.0 - mouse ) * fade;\n    }\n    \n    \n\tvec3 baseColor = sin( t * 5.0 * vec3( 0.345, 0.456 , 0.657) ) * 0.4 + 0.6 ; // Important technic.\n    vec3 col = m * baseColor;\n    \n    //col.rg = gv;\n    //if ( gv.x > 0.49 || gv.y > 0.49) col = vec3(1.0 , 0.0 , 0.0 );\n    fragColor = vec4(col,1.0);\n}\n\n// 1. 라인과 점과의 거리 구하기\n// 2. Noise 함수의 정의\n//\t\t* N21( vec2 p ) : Sin() 대신에 Dot() 사용하는 노이즈\n// 3. 그리드 만들기 (  id , localuv )\n// 4. 그리드 안에서 랜덤 포인트 만들기\n//\t\t* local uv 와 Random Point를 조합하여 만든다.\n//\t\t* \n// 5. 랜덤 포인트 애니메이팅 시키기.\n//\t\t* GetPos( p )\n//\t\t* 이동 시키기 위해서는 sin() cos()을 이용한다.\n// 6. 움직이는 포인트들 사이에 선 그리기\n// \t\t* for문을 돌면서 인접한 9개의 셀에 있는 포인트와 각각 비교한다.\n// 7. 라인을 그린후 9개의 셀에서 서로 연결되지 않는 대각선 셀까리의 계산을 해준다.\n//\t\t* 1번 => 3,5번, 7번 => 3,5번 셀을 직접 연결해준다.\n\n// 8. 라인의 길이에 따라서 페이드 해준다. ( 가장 가까운 것만 연결된 것처럼 보이게 )\n//\t\tm *= S( 1.2, 0.8 , length( a - b ) );\n\n// 9. 스파클 시키기\n\n// 문제 : 잘보면 중간에 The 옆에 움직이지 않고 고정된 하나의 점이 있다.\n\n\n\n/// --------------------- 여기까지가 1부 -------- //////////////\n\n\n\n// 10. 라인 플레쉬 시키기\n//\t\t* m 값에 대한 조절\n//     // 이게 오묘한 식이다, p와의 거리가 아니라, ( a - b )의 거리를 말한다.\n//\t    float d2 = length( a - b );\n//\t    m *= S( 1.2, 0.8 , d2 ) * 0.5 + S( 0.05, 0.03, abs( d2 -0.75 ) );\n\n// 11. 레이어 만들기\n//\t\tfloat m = Layer( uv * 5 )\n\n// 12. Fade 적용하기\n//\t\t* fade = fadeIn * fadeOut;\n\n// 13. Twist 적용하기\n//\t\t* UV 를 로테이션 시킨다.\n//\t\t* mat2 행렬식의 사용법 보기.\n\n// 14. 마우스에 의한 UV 무브 정의해주기\n//\t\t* 마우스도 로테이션 시켜주어야 한다.\n\n\n// 15. 컬러 넣기\n//\tvec3 baseColor = sin( t * 5.0 * vec3( 0.345, 0.456 , 0.657) ) * 0.4 + 0.6 ;\n//    vec3 col = m * baseColor;\n//\t* 여기에서 0.4를 곱하고 0.6을 더해서, 최소 0.2 ~ 1.0 이상의 값이 되도록 만들어 준 수식을 유의 할 것.\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 88, 134, 305], [307, 307, 328, 328, 432], [434, 434, 454, 454, 514], [518, 518, 556, 616, 844], [846, 846, 886, 886, 1211], [1214, 1214, 1239, 1239, 2272], [2275, 2275, 2332, 2332, 3472]], "test": "untested"}
{"id": "wtSBRD", "name": "24. The Universe 1", "author": "altera0", "description": "Source : https://www.youtube.com/watch?v=3CycKKJiwis&t=247s\nMy Game :  https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["simpleonet"], "likes": 6, "viewed": 329, "published": 3, "date": "1598826246", "time_retrieved": "2024-07-30T20:48:18.465389", "image_code": "#define S(a, b, t) smoothstep( a, b, t )  \n\nfloat DistLine( vec2 p , vec2 a , vec2 b ) {\n\n    // Line ba에 Pa를 직교 투영한다.\n    \n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    \n    float t = clamp( dot( pa , ba ) / dot ( ba , ba ) , 0.0 , 1.0 );\n    \n    return length( pa - ba * t );\n        \n}\n\nfloat N21( vec2 p ) {\n\n    p = fract( p * vec2( 233.34 , 851.73));\n    p += dot( p, p+23.45);\n    return fract(p.x * p.y );\n}\n\nvec2 N22( vec2 p ) {\n\tfloat n = N21( p );\n    return vec2( n , N21( p + n ) );\n}\n\n\n\nvec2 GetPos( vec2 id , vec2 offset ) {\t// from id\n    \n    //vec2 n = N22( id + offset ) * iTime ;\n    vec2 n = N22( id + offset ) * iTime ;\n    \n    //float x = sin ( iTime * n.x );\n    //float y = cos ( iTime * n.y );\n    \n    return offset + sin( vec2(n) ) * 0.4;\t\t// 0.4, it is Important that balls is in grid cell.\n    \n}\n\nfloat Line( vec2 p , vec2 a , vec2 b ) {\n\tfloat d = DistLine( p , a, b );\n   \tfloat m = S( 0.03, 0.01 , d );\n    \n    m *= S( 1.2, 0.8 , length( a - b ) );\n    \n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n    \n    //float d = DistLine( uv , vec2(0) , vec2(1) );\n    //float m = S( 0.1, 0.05 , d );\n    float m;\n    \n    \n    //m = N22( uv ).x;\n    \n    uv *= 5.0;\n    vec2 gv = fract(uv) - 0.5f;\t// center point to ( 0 , 0 ) local uv\n    vec2 id = floor(uv);\n    \n    \n    //vec2 p = N22( id ) - 0.5;\t// Random point based on each grid center.\n    \n    //vec2 p = GetPos( id );\n    //float d = length( p - gv );\n    \n\t\n    int i = 0;\t\t// index\n    vec2 p[9];\t\t// 9 cell\n    \n    for (float y = -1.0 ; y <= 1.0 ; y++ ) {\n        for ( float x = -1.0 ; x <= 1.0 ; x++ ) {\n        \tp[i++] = GetPos( id , vec2( x , y ));\n        }\n    }\n    \n    \n    float t = iTime * 10.0;\n    for ( int i = 0 ; i < 9 ; i++ ) {\n    \tm += Line( gv, p[4] , p[i] );\t// p[4] is mine\n        \n        vec2 j = ( p[i] - gv ) * 10.0;\n        float sparkle = 1.0 / dot(j,j);\n        \n        \n        \n        m += sparkle * ( sin(t + p[i].x * 10.0 ) * 0.5 + 0.5 ) ;\n    }\n    \n    m += Line( gv, p[1] , p[3] );\t// p[4] is mine\n    m += Line( gv, p[1] , p[5] );\t// p[4] is mine\n    m += Line( gv, p[7] , p[3] );\t// p[4] is mine\n    m += Line( gv, p[7] , p[5] );\t// p[4] is mine\n    \n    \n   \n\n    vec3 col = vec3(m);\n    \n    //col.rg = gv;\n    if ( gv.x > 0.49 || gv.y > 0.49) col = vec3(1.0 , 0.0 , 0.0 );\n    fragColor = vec4(col,1.0);\n}\n\n// 1. 라인과 점과의 거리 구하기\n// 2. Noise 함수의 정의\n//\t\t* N21( vec2 p ) : Sin() 대신에 Dot() 사용하는 노이즈\n// 3. 그리드 만들기 (  id , localuv )\n// 4. 그리드 안에서 랜덤 포인트 만들기\n//\t\t* local uv 와 Random Point를 조합하여 만든다.\n//\t\t* \n// 5. 랜덤 포인트 애니메이팅 시키기.\n//\t\t* GetPos( p )\n//\t\t* 이동 시키기 위해서는 sin() cos()을 이용한다.\n// 6. 움직이는 포인트들 사이에 선 그리기\n// \t\t* for문을 돌면서 인접한 9개의 셀에 있는 포인트와 각각 비교한다.\n// 7. 라인을 그린후 9개의 셀에서 서로 연결되지 않는 대각선 셀까리의 계산을 해준다.\n//\t\t* 1번 => 3,5번, 7번 => 3,5번 셀을 직접 연결해준다.\n\n// 8. 라인의 길이에 따라서 페이드 해준다. ( 가장 가까운 것만 연결된 것처럼 보이게 )\n//\t\tm *= S( 1.2, 0.8 , length( a - b ) );\n\n// 9. 스파클 시키기\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 88, 134, 305], [307, 307, 328, 328, 432], [434, 434, 454, 454, 514], [518, 518, 556, 616, 844], [846, 846, 886, 886, 1022], [1025, 1025, 1082, 1082, 2456]], "test": "untested"}
{"id": "wlBBW1", "name": "closest graph (Voronoi Tracking)", "author": "FabriceNeyret2", "description": "Draw links between particles that are both in the closest 3-neighbor of each others.\nclick to see Voronoi domains and particle + Voronoi buffers.\n\nUsing Voronoï tracjing in one single buffer [url]https://shadertoy.com/view/wlcXRS[/url]\n", "tags": ["2d", "voronoi", "simulation", "particles", "voronoiparticlestracking"], "likes": 19, "viewed": 906, "published": 3, "date": "1598809062", "time_retrieved": "2024-07-30T20:48:19.359999", "image_code": "// ( previous try (private ): https://shadertoy.com/view/3lSBDR )\n// Fork of Voronoï tracking in 1-buffer https://shadertoy.com/view/wlcXRS\n// Fork of Gijs' https://shadertoy.com/view/WltSz7 that was rewording mine :-)\n\n// segment with disc ends: seamless distance to segment\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n\n// === Display\n\nvoid mainImage( out vec4 O, vec2 U ){\n    \n    O = vec4(0);\n    float d,D;\n    \n    // get the id's of the 4 particles that (should be) closest.\n    ivec4 ids = getClosestS(ivec2(U)), // the 4 ids are stored in .x, .y, .z, .w\n         ids0, ids1;\n    \n#if 1 // draw the particles\n    d = distance(U,getParticle(ids[0]).xy);\n    O.b += smoothstep(1.5,0.,d-3.);          // color it\n // O += .3/(d*d);                           \n#endif \n    \n#if 0 // --- draw voronoi outlines    \n    vec2  p1 = getParticle(ids[0]).xy, // get the position of the closest particle\n\t      p2 = getParticle(ids[1]).xy; // get the position of the second closest particle\n    float r = dot( U-(p1+p2)/2. , normalize(p2-p1) );//get the distance to voronoi edge\n    O += smoothstep(2.,0.,abs(r))*.3;\n#endif \n    \n#if 1 // --- draw lines between closest points\n    vec2[4] Pos;                           // particles location, and distance to P\n    for(int i = 0; i < 4; i++)\n        Pos[i] = getParticle(ids[i]).xy;   // [ we once new these during bufA... ]\n\n    ivec2[6] link; int Nlink=0;            // all couples of particles \"each-other closest\"\n    \n    for(int i = 0; i < 3; i++) {\n        ids0 = getClosestS(ivec2(Pos[i])); // check that the \"4-closest\" relation is reciprocal\n        for( int j = i+1; j < 4; j++) {\n            ids1 = getClosestS(ivec2(Pos[j]));   // does then both know each other ?\n            for (int k = 1; k < 4; k++)          // start at 1 because 0 is itself\n#if 1\n                if ( ids0[k] == ids[j] ) {       // i sees j\n                    for (int l=1; l<4; l++)      // start at 1 because 0 is itself\n                        if( ids1[l] == ids[i] )  // j sees i too\n                            { link[Nlink++] = ivec2(i,j); break; }\n                    break; \n                }\n#else\n                if ( ids0[k] == ids[j] || ids1[k] == ids[i] )  // i sees j or the reverse\n                    { link[Nlink++] = ivec2(i,j); break; }\n#endif\n        }\n    }\n    for(int i = 0; i < Nlink; i++) {       // now we can draw the links\n        ivec2 l = link[i];\n        d = line ( U, Pos[l.x], Pos[l.y] ), \n        D = distance(  Pos[l.x], Pos[l.y] ) ,\n        O.rgb += smoothstep( 1.5, 0., d) \n     //   * step(D, vec3(40,20,10)); \n          * min( .5*vec3(40,20,10) / D , 1.);\n     //   *  ( .6 + .6 * cos( .1*D  + vec3(0,23,21)  ) );\n    }\n#endif     \n    \n    if (iMouse.z>0.) {          // --- on click, draw the particle and voronoi buffers \n        O += .3*float(ids)/float(PARTICLES); // draw voronoi around closest \n        vec2 _m = U-ofs2-iResolution2; if (max(_m.x,_m.y)<0.) // display maps\n        O += (1.-O.a) * .5* texelFetch(iChannel0, ivec2(U), 0) \n                      / ( U.x < ofs2.x ? .2*R.x: float(PARTICLES) )\n             + vec4(0,0,.3,0);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Fork of my fork of Gijs' https://shadertoy.com/view/WltSz7 that was rewording mine :-)\n\n// The code is not optimized for speed; it turns out programming with integers can be slow on some GPU's.\n// The reason I still use them is readability of the code.\n\n//amount of particles\n//const int PARTICLES = 1000; \n#define PARTICLES int(R.x*R.y/800.) // 230 2300\n\n#define R iResolution.xy\n#define iResolution1 (R/4.)  // slot allocated for Particle Buffer \n#define iResolution2 (R/4.)  // slot allocated for Voronoi Buffer\n#define ofs2     vec2(iResolution1.x,0)\n\n// --- chose length of closest LIST\n//#define LIST xxxx    //  1 (not enough for repulsion & draw voronoi)\n//#define LIST xyyy    //  2\n//#define LIST xyzz    //  3\n  #define LIST xyzw    //  4\n\n// --- Particle Buffer part:\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\n// --- Voronoi Buffer part:\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\n\n//returns the ids of the four closest particles from the input\n//    if (xy != ivec2(clamp(vec2(xy),vec2(0),iResolution2)) ) return ivec4(0);\n#define getClosest(xy) /* xy: location within Voronoi Buffer */ \\\n    ivec4(texelFetch(iChannel0, ivec2(ofs2+vec2(xy)), 0).LIST) // was channel1\n\n#define getClosestS(pos) getClosest(ivec2(vec2(pos)/R *iResolution2))\n        \n//returns the location of the particle within the particle buffer corresponding with the input id \n#define locFromID(id) ivec2( (id) % int(iResolution1.x), (id) / int(iResolution1.x))\n\n//get the particle corresponding to the input id\n#define getParticle(id) texelFetch(iChannel0, locFromID(id), 0)\n\n\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n#define Nhash(h) hash(int((h)*41343.))", "buffer_a_code": "// Fork of my fork of Gijs' https://shadertoy.com/view/WltSz7 that was rewording mine :-)\n\nfloat distance2Particle(int id, vec2 W){ // screen coords\n    if( id < 0 ) return 1e20;\n    vec2 delta = getParticle(id).xy - W;\n    return dot( delta, delta );\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])  i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])  i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])  i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])  i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n    i = i.LIST; d = d.LIST;\n}\n\n// =========================================================\nvoid mainImage( out vec4 O, vec2 U ){\n    ivec2 I = ivec2(U);\n    if ( U+.5 == R ) O.xy = R; // store current resol to detect resol change\n    \n// === main Particle Buffer part\n  vec2 _m = U - iResolution1; \n  if (max(_m.x,_m.y)<0.) {\n        \n    //we only simulate PARTICLES amount of particles\n    int id = I.x + I.y*int(iResolution1.x);\n    if(id >= PARTICLES) return;\n    \n    vec4 prev = texelFetch( iChannel0, ivec2(U), 0 );\n    vec2  pos = prev.xy,              // screen coords\n          vel = prev.zw;              // velocity\n     \n    if(texelFetch(iChannel0, ivec2(R)-1,0).xy != R ) { // 1st run or resolution change\n        float  x = hash(id),  y = Nhash(x),  // --- pick a \"random\" starting position\n              vx = Nhash(y), vy = Nhash(vx);\n        pos = R * vec2( x, y);        // screen coordinates\n        vel = 2.* vec2(vx,vy) - 1. ;  // random velocity\n    }\n    pos += .1 * vel;                  // --- motion\n    pos = mod(pos,R);                 // wrap screen\n    \n    O = vec4(pos,vel);\n}\n\n// === main Voronoi Buffer part\n  _m = U - ofs2 - iResolution2; \n  if (U.x >= iResolution1.x && max(_m.x,_m.y) < 0.) {   \n    \n    //if(iFrame==0){ fragColor = vec4(0); return; }\n    ivec2 I = ivec2(U-ofs2);\n    vec2  W = (U-ofs2)/iResolution2 * R;\n    \n    ivec4 new = ivec4(-1);  //in this vector the four new closest particles' ids will be stored  \n    vec4  dis = vec4(1e20); //in this vector the distance to these particles will be stored \n    \n    //get all known closest particles from old self and neighbours\n    ivec4 old   = getClosest( I + ivec2( 0, 0) ),           \n          east  = getClosest( I + ivec2( 1, 0) ),\n\t      north = getClosest( I + ivec2( 0, 1) ),\n          west  = getClosest( I + ivec2(-1, 0) ),\n          south = getClosest( I + ivec2( 0,-1) );\n    //collect them in a array so we can loop over it\n    ivec4[5] candidates = ivec4[5](old, east, north, west, south); \n    \n    for(int i=0; i<5; i++)\n        for(int j=0; j<4; j++){\n            int id = candidates[i][j];\n            float dis2 = distance2Particle(id, W); // to screen\n            insertion_sort( new, dis, id, dis2 );\n        }\n    \n    for(int k = 0; k < 1; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            I.x + \n            I.y  * int(iResolution2.x) + \n            iFrame*int(iResolution2.x*iResolution2.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, W) );\n    }\n    \n    O = vec4(new);   \n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 277, 312, 312, 484]], "test": "untested"}
{"id": "wtSBzh", "name": "Waiting...", "author": "dean_the_coder", "description": "Just a sad little chap sitting on a wall.", "tags": ["procedural", "3d", "raymarching", "mood"], "likes": 16, "viewed": 369, "published": 3, "date": "1598808371", "time_retrieved": "2024-07-30T20:48:20.180803", "image_code": "// 'Waiting...'\n//\n// My first attempt at modelling a character.\n// Sort of a sad little wonkly wax chap...  With a butt...\n//\n// Concrete texture reused from my earlier shader:\n// https://www.shadertoy.com/view/WllfzB\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST 0.0015\n\n#define AA  // Comment out this line for a speed boost.\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n// Thanks iq.\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat fbm(vec3 p) {\n    return (texture(iChannel0, p * 0.01).r\n    + texture(iChannel0, p * 0.01978).r * 0.4848\n    + texture(iChannel0, p * 0.0391).r * 0.235\n    + texture(iChannel0, p * 0.07739).r * 0.114\n    + texture(iChannel0, p * 0.15307).r * 0.055\n    + texture(iChannel0, p * 0.30278).r * 0.027) / 1.9158;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 min2(vec2 a, vec2 b) { return a.x < b.x ? a : b; }\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    vec3 f = pa*l2 - ba*y;\n    float x2 = dot(f, f);\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat getConcreteMaterial(vec3 p, out vec3 mat) {\n    // Set rnd seed from id.\n    vec3 tp = p;\n    \n    // Mix a couple of shades of grey.\n    float baseColor = smoothstep(0.0, 0.5, noise(tp));\n    mat = mix(vec3(0.18, 0.17, 0.17), vec3(0.20, 0.19, 0.19), baseColor);\n\n    // Surface roughness.\n    float rough = noise(tp * 60.0) * 0.005 // Base\n         \t\t  + step(0.2, noise(tp * 26.666)) * 0.0033; // Pits/dents.\n    mat += rough * 24.0;\n    \n    // Fade surface roughness(/deflection) out with distance to prevent screen noise.\n    return rough;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nbool isEye = false;\nfloat nod = 0.0;\nfloat head(vec3 p) {\n    p.y += 0.9;\n    nod = pow(abs(sin(iTime * 0.4) * 0.5 + 0.5), 2.0);\n    p.yz *= rot(0.4 * nod - 0.3);\n    p.xz *= rot(sin(iTime) * 0.2 * (1.0 - pow(nod, 2.0)));\n    p.y -= 0.9;\n    \n    float rough = fbm(p);\n    float d = length(p) - 1.0 - mix(-0.5, 0.5, rough);\n    \n    float eye = length(p + vec3(0.025, 0.3, 0.825)) - rough * 0.4; // Left eye\n    eye = min(eye, length(p + vec3(-0.4, 0.2, 0.75)) - rough * 0.5); // Right eye\n\n    isEye = eye < d;\n    return min(d, eye);\n}\n\n// Map the scene using SDF functions.\nvec4 map(vec3 p) {\n    vec3 op = p;\n    \n    // Wall.\n    float wall = sdBox(p + vec3(0.0, 4.15, -0.1), vec3(12.0, 2.0, 1.0));\n    vec3 mat;\n    wall -= getConcreteMaterial(p, mat);\n    mat *= 0.2;\n    \n    // Head.\n    p.y += 0.08;\n    p.z += 0.45;\n    float headd = head(p);\n    float d = headd;\n    \n    // Torso.\n    float rough = fbm(p);\n    d = smin(d, sdCapsule(p, vec3(0.0, -0.5, 0.0), vec3(0.0, -1.8, 0.0), rough - 0.25), 0.1);\n    \n    // Arms.\n    p.x = abs(p.x - 0.1);\n    const vec3 shoulder = vec3(0.34, -1.2, -0.1);\n    const vec3 elbow = vec3(0.44, -1.5, -0.1);\n    float w = sign(op.x) > 0.0 ? 0.2 : 0.08;\n    float fbm5 = fbm(p * 5.0);\n    float upper = sdCapsule(p, shoulder, elbow, fbm5 * w);\n    float lower = sdCapsule(p, elbow, vec3(0.34, -1.8, -0.2), fbm5 * w);\n    d = smin(d, smin(upper, lower, 0.02), mix(0.1, 0.0, min(distance(p, shoulder) * 2.5, 1.0)));\n    \n    // Butt.\n    p.x = abs(op.x - 0.04);\n    d = smin(d, length(p + vec3(-0.06, 1.95, -0.24)) - fbm5 * 0.3, 0.02);\n    \n    // Thighs.\n    p.x = abs(op.x - 0.06);\n    vec3 hip = vec3(0.12, -1.98, 0.0); \n    vec3 knee = vec3(0.15, -1.98, -0.55); \n    d = smin(d, sdCapsule(p, hip, knee, fbm5 * 0.3), 0.07);\n    \n    // Shins.\n    vec3 ankleDelta = vec3(0.0, -0.32, 0.0);\n    mat2 swing = rot(-max(0.0, abs(0.6 * sin(iTime * 1.5+ sign(op.x) * 0.3))));\n    ankleDelta.yz *= swing;\n    vec3 ankle = knee + ankleDelta;\n    d = min(d, sdRoundCone(p, knee, ankle, fbm5 * 0.3, fbm5 * 0.1));\n    \n    // Feet.\n    vec3 toeDelta = vec3(0.02, -0.04, -0.1);\n    toeDelta.yz *= swing;\n    vec3 toe = ankle + toeDelta;\n    d = min(d, sdRoundCone(p, ankle, toe, fbm5 * 0.15, fbm5 * 0.1));\n    \n    if (d < wall) {\n        mat = vec3(0.3, 0.3, 0.35);\n    \tif (isEye && abs(d - headd) < 0.001) mat = vec3(0.001);\n    }\n    \n    d = min(d, op.y + 5.0);\n    \n    return vec4(min(d, wall), mat);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.005773;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float res = 1.0;\n    float t = 0.05;\n    for(float i = 0.0; i < 45.0; i++)\n    {\n        float h = map(p + rd * t).x;\n        if (h < MIN_DIST * t)\n            return 0.0; // Hit an object - Full shadow.\n        \n        res = min(res, 48.0 * h / t);\n        t += h;\n        \n        if (t > 20.0)\n            break; // Marched far enough - Stop.\n    }\n    \n    return res;\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n    return map(p + h * n).x / h;\n}\n\n// Subsurface scattering.\nfloat sss(vec3 p, vec3 ld, float h) {\n    return smoothstep(0.0, 1.0, map(p + h * ld).x / h);\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 back(vec2 uv) {\n    return vec3(fbm(vec3(0.0, uv * 20.0)) * 0.02) * (1.0 - uv.y * 2.0);\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, vec3 mat) {\n    vec3 sunCol = vec3(2.0, 1.6, 1.4);\n    vec3 sunPos = vec3(10.0, 5.0, -10.0);\n    vec3 sunDir = normalize(sunPos - p);\n    vec3 n = calcNormal(p);\n    float amb = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\n    \n    // Diffuse color.\n    float diff = max(0.0, dot(sunDir, n));\n    diff += sss(p, sunDir, 0.5);\n    \n    // Primary light (Sun).\n    float sha = calcShadow(p, sunPos) + 0.25;\n    vec3 lig = diff * sunCol * sha;\n\n    // Specular.\n    float spe = pow(max(0.0, dot(rd, reflect(normalize(sunPos - p), n))), 15.0);\n    lig += spe;\n\n    // Seconary light (Bounce light);\n    lig += max(0.0, dot(-sunDir, n)) * sunCol * 0.1 * amb;\n    \n    float fre = 1.0 + dot(rd, n);\n    const vec3 back = vec3(0.0);\n    return mix(mat.r == 0.001 ? vec3(spe) : mat * lig, back, fre);\n}\n\nvec4 march(vec3 ro, vec3 rd, out vec3 p) {\n    float d = 0.01, prevd = 1.0;\n    vec4 h;\n    for (float steps = 0.0; steps < 64.0; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n        \n        if (abs(h.x) < MIN_DIST)\n            break; // We've hit a surface - Stop.\n        if (d > 20.0) return vec4(1e7);\n        \n        d += h.x; // No hit, so keep marching.\n    }\n    \n    return h;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n  \tvec4 hit = march(ro, rd, p);\n    \n    if (hit.x > 1e6) return back(rd.xy);\n    \n    // Lighting.\n    return applyLighting(p, rd, hit.yzw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera.\n    float ft = smoothstep(0.0, 1.0, fract(iTime / 12.0));\n    float phase = mod(floor(iTime / 12.0), 3.0);\n    float dim = 1.0 - pow(abs(cos(iTime * 3.141 / 12.0)), 100.0);\n    \n    vec3 ro;\n    vec3 lookAt = vec3(0.0, -1.0, 0.0);\n    \n    if (phase == 0.0) {\n        ro = vec3(0.0, -0.5, mix(-8.0, -4.6, ft)); // -8.0 -4.6\n        ro.xz *= rot(mix(1.24, -0.3, ft)); // 1.24, -0.3\n    } else if (phase == 1.0) {\n        ro = vec3(0.0, mix(2.0, -2.0, ft), mix(-8.0, -4.2, ft)); // -3.9 -8.0\n        ro.xz *= rot(mix(-0.43, -0.2, ft)); // -0.2 -0.43\n    } else if (phase == 2.0) {\n        ro = vec3(0.0, -0.5, mix(-1.0, -4.23, ft)); // -1.0  -4.23\n        ro.xz *= rot(mix(2.19, 0.13, ft)); // 2.19 0.13\n        lookAt = vec3(0.0, -1.6, 0.0);\n    }\n    \n    vec3 col = vec3(0.0);\n#ifdef AA\n    for (float dx = 0.0; dx <= 1.0; dx++) {\n        for (float dy = 0.0; dy <= 1.0; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\n#else\n            vec2 coord = fragCoord;\n#endif\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\n            vec3 rd = getRayDir(ro, lookAt, uv);\n            col += getSceneColor(ro, rd);\n#ifdef AA\n        }\n    }\n    col /= 4.0;\n#endif\n    \n    // Output to screen.\n    col = vignette(pow(col * dim, vec3(0.4545)), fragCoord);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBzh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[505, 561, 582, 582, 858], [860, 874, 930, 930, 1030], [1032, 1032, 1071, 1071, 1174], [1176, 1176, 1195, 1195, 1491], [1493, 1493, 1512, 1512, 1588], [1590, 1590, 1617, 1617, 1645], [1647, 1647, 1676, 1676, 1771], [1773, 1773, 1823, 1823, 1939], [1941, 1941, 1991, 1991, 2112], [2114, 2114, 2177, 2241, 2844], [2846, 2846, 2895, 2924, 3398], [3400, 3400, 3447, 3447, 3652], [3691, 3691, 3711, 3711, 4191], [4193, 4231, 4249, 4249, 6096], [6098, 6098, 6123, 6123, 6316], [6318, 6318, 6359, 6359, 6783], [6785, 6813, 6848, 6848, 6883], [6885, 6911, 6948, 6948, 7006], [7094, 7094, 7135, 7135, 7276], [7278, 7278, 7298, 7298, 7372], [7374, 7374, 7421, 7421, 8236], [8238, 8238, 8280, 8280, 8638], [8640, 8640, 8678, 8695, 8851]], "test": "untested"}
{"id": "ttSBW1", "name": "Waving flag", "author": "carolhmj", "description": "P.S: Trans rights are human rights~", "tags": ["2d", "animation", "flag"], "likes": 1, "viewed": 288, "published": 3, "date": "1598807002", "time_retrieved": "2024-07-30T20:48:21.130264", "image_code": "vec3 floatCol(int r, int g, int b) {\n\treturn vec3( float(r)/255., float(g)/255., float(b)/255.);\n}\n\nvec4 makeFlag(vec2 p, float w, float h) {\n    float mask = 0.;\n    \n    float period = sign(p.y) * .008*cos(p.x*20.0 - iTime*5.);\n    \n    float hn = h + .015 + period;\n        \n    float wn = w + .015 + .008*cos(p.y*20.0 - iTime*5.);\n   \tmask += (1. - smoothstep(wn, wn+.000001, abs(p.x) )) * (1. - smoothstep(hn, hn+.000001, abs(p.y) ) );\n    mask *= clamp(sign(p.x + .2) + 1., 0., 1.);\n    \n    vec3 col1 = vec3(.33, .8, .98);\n    vec3 col2 = vec3(.96, .65, .72);\n    vec3 col3 = vec3(1., 1., 1.);\n    \n    float h1 = h - h/4. + period;\n    float stripe1Mask = smoothstep( h1, h1+.01, abs(p.y) );\n    vec3 flagCol = mix(col2, col1, stripe1Mask);\n    float h2 = h/4. + period;\n    float stripe2Mask = smoothstep( h2, h2+.01, abs(p.y) );\n    flagCol = mix(col3, flagCol, stripe2Mask);\n    \n    vec3 col = mix(vec3(0., 0., 0.), flagCol, mask);\n    \n    float poleMask = 0.0;\n    vec2 pp = p + vec2(w+.015, 0.);\n    float l = .014;\n    poleMask += (1. - smoothstep(l, l+.001, abs(pp.x) )) * (1. - smoothstep(h+.015+.008, h+.015+.008+.001, pp.y ) );\n    poleMask += floor(1.-poleMask) * smoothstep(l+.0001, l, length(pp-vec2(0., 0.17)));\n\n    vec3 brown = floatCol(117, 83, 63);\n    \n    col = mix(col, brown, poleMask);\n    //col = vec3(poleMask);\n    \n    return vec4(col, poleMask+mask);\n}\n\nvec3 makeSky(vec2 p) {\n\t// Make a sky gradient\n\tvec3 skyTop = floatCol(45, 250, 236);\n    vec3 skyBottom = floatCol(197, 240, 237);\n    \n   \t// Mix the two colors based on height\n    vec3 col = mix(skyBottom, skyTop, p.y);\n   \n    //Add sun\n    vec3 sunColor = floatCol(250, 244, 117);\n    float r = .1;\n    vec2 sp = p-vec2(.5,.25);\n    float sunMask = smoothstep(r+0.05, r, length(sp));\n    \n    col = mix(col, sunColor, sunMask);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 p = uv + vec2(.3, -.1);\n\n \tvec3 col = makeSky(uv);\n    vec4 flag = makeFlag(p, 0.2, 0.15);\n    col = mix(col, flag.xyz, flag.w);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 98], [100, 100, 141, 141, 1390], [1392, 1392, 1414, 1438, 1847], [1850, 1850, 1907, 1907, 2147]], "test": "untested"}
{"id": "wlBBWh", "name": "J J Flare", "author": "Jaromir", "description": "Attempt at creating a J. J. abrams style lensflare.", "tags": ["2d", "flare", "lensflare"], "likes": 11, "viewed": 616, "published": 3, "date": "1598806152", "time_retrieved": "2024-07-30T20:48:21.951070", "image_code": "//Created by Jaromir Mulders\n//www.jaromirmulders.nl\n\n#define M_PI 3.14159265359\n\nfloat hash21(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\tfloat a = hash21(i);\n\tfloat b = hash21(i + vec2(1.0, 0.0));\n\tfloat c = hash21(i + vec2(0.0, 1.0));\n\tfloat d = hash21(i + vec2(1.0, 1.0));\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\n\nfloat flareLine(vec2 p, vec2 width){\n\n  float sphere = length(p);\n  sphere = smoothstep(width.x,0.,sphere);    \n       \n  vec2 s = vec2(0.5,1.);\n    \n  float line = abs(p.y+smoothstep(s.x,s.y,cos(p.x)*0.2));\n  line+= abs(p.y-smoothstep(s.x,s.y,cos(p.x)*0.2));\n   \n  line = smoothstep(width.y,0.0,line);\n  line*= sphere;  \n    \n  return line;\n}\n\nfloat sinSphere(vec2 p, float scale, float offset){\n\n  float s = sin(length(p*scale)+offset);\n    \n  return smoothstep(0.98,0.7,s)-smoothstep(1.,0.6,s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    uv*=1.2;\n    \n    float sLen = length(uv);\n    float n = hash21(uv);\n    float n2 = noise(uv*15.+iTime*0.08);\n\t\n    float l1 = flareLine(uv + vec2(0.,0.),\n                         vec2(.9,0.03) + vec2(cos(iTime*0.265)) *vec2(0.11,0.01) );\n\tfloat l2 = flareLine(uv + vec2(-0.08,0.01),\n                         vec2(.5,0.013) + vec2(cos(iTime*0.287)) *vec2(0.12,0.005));\n\tfloat l3 = flareLine(uv + vec2(0.09,-0.011),\n                         vec2(.7,0.018) + vec2(cos(iTime*0.289)) *vec2(0.13,0.0023));\n    \n    float lCurve = cos(uv.x*M_PI*0.6)*0.2;\n    float lUv = abs(uv.y+lCurve);\n    lUv+= abs(uv.y -lCurve);\n    \n    float curveLine = length(lUv);\n    curveLine = smoothstep(0.8,0.,curveLine);\n    \n    vec2 sUv = uv*1.5;\n    float line = smoothstep(.15+n2*0.08,0.,abs(sUv.y));\n    float s = length(sUv);\n    float sphere = smoothstep(.8,-0.5,s);\n    float lAnim = fract(hash21(vec2(iTime*0.1)));\n    lAnim = max(0.9,lAnim);\n    float wSphere = smoothstep(.1+lAnim*0.03,-0.02,s);\n    float d = dot(abs(sUv.x*1.),abs(sUv.y*0.75));\n    float star = smoothstep(.07,-0.1,d)*5.;\n    float sSphere = line*star*sphere;\n    sSphere = pow(sSphere,2.);\n    \n    float bulb = length(uv*1.9+n2*-0.015);\n    bulb = bulb * smoothstep(1.,0.3,bulb);\n    bulb = smoothstep(0.3,.5,bulb);\n    \n    vec2 rUv = uv;\n    float emit = abs(sin(atan(rUv.y,rUv.x)*.7+.2));\n    emit+= abs(sin(atan(rUv.y,-rUv.x)*0.8+.1));\n    emit*=0.5;\n    emit*=smoothstep(.9,0.,sLen) - bulb*0.3 ;\n    emit = pow(emit,2.5);\n    emit = (emit*mix(n,1.,0.97))*0.9;\n\n\tfloat rRep = 1.5;\n    float rLen = length(uv*2.5);\n    float angle = atan(rUv.x,rUv.y);\n    float rAngle = sin(angle*rRep+n2*0.9+iTime*0.5);\n\tfloat rays = (abs(rAngle))*smoothstep(1.+n2*0.05,0.,rLen);\n    rays*= clamp(.1/rLen,0.,1.);\n    rays-=smoothstep(.8,0.,rLen)*2.;\n    float aId = floor(angle*rRep);\n    float rId = hash21(vec2(aId));\n\trays = clamp(rays* abs(sin(angle*0.3+0.1))*0.3,0.,1.) ;\n    \n    float r1 = sinSphere(uv+n2*0.1,0.9,0.0);\n    float r2 = sinSphere(uv+n2*-0.023,1.,0.0);\n    float r3 = sinSphere(uv+n2*0.05,1.1,0.0);\n    vec3 ripple = vec3(r1,r2,r3)*mix(sin(angle*0.7+iTime*0.23),1.,0.5);\n    \n    \n    vec3 col = vec3(0.);\n\n    col+=l1*vec3(0.1,0.1,.3);\n    col+=smoothstep(0.3,1.,l1)*vec3(1.)*0.3;\n    \n    col+=l2*vec3(0.2,0.5,0.6);\n    col+=smoothstep(0.3,1.,l2)*vec3(1.)*0.3;\n\n    col+=l3*vec3(1.5,0.3,1.);\n    col+=smoothstep(0.3,1.,l3)*vec3(1.)*0.3;\n\t\n    col+=vec3(sSphere*1.5)*vec3(.8,.05,0.)*2.;\n\tcol+=vec3(wSphere)*vec3(1.1);\n    \n    col+=ripple*0.075;\n    \n    col+=rays*vec3(.4,0.3,0.2)*100.;\n    col+=mix(vec3(0.34,0.5,0.6),vec3(.9,0.05,0.1),emit)*emit;\n    \n    col = pow(col,vec3(0.4545));\n    \n    fragColor = vec4(col,1.);\n    //fragColor = vec4(ripple,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 104, 104, 192], [194, 194, 215, 215, 509], [513, 513, 549, 549, 856], [858, 858, 909, 909, 1012], [1014, 1014, 1071, 1071, 3868]], "test": "untested"}
{"id": "wtSBW1", "name": "Old TV/CRT Shader", "author": "griffi", "description": ".", "tags": ["simple", "tv", "crt", "scanline"], "likes": 4, "viewed": 829, "published": 3, "date": "1598803678", "time_retrieved": "2024-07-30T20:48:22.831715", "image_code": "#define SEED 123400.\n#define HNOISE .0045\n#define BRIGHT 1.2\n#define PIXHEIGHT 4.\n\nprecision highp float;\n\nfloat rand(float s){\n\treturn fract(sin(s)*SEED);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    \n    vec2 vsmpl=vec2(uv.x+rand(iTime+uv.y)*HNOISE,uv.y);\n    vec4 video=texture(iChannel0,vsmpl);\n    \n    vec3 mask = vec3(int(clamp(mod(fragCoord.y,PIXHEIGHT),0.,1.)));\n    \n    vec3 rgb=vec3(.1);\n    int pp=int(mod(fragCoord.x,3.)); \n    rgb[pp]=1.;\n    \n    fragColor = vec4(video.xyz*rgb*mask*BRIGHT,1);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 127, 127, 157], [159, 159, 216, 216, 573]], "test": "untested"}
{"id": "ttBfDh", "name": "div-free flownoise displacement", "author": "FabriceNeyret2", "description": "use divergence-free flownoise to distort a base function ( here, radial gradient )\n\nclick for color vs N&B version", "tags": ["perlinnoise", "displacement", "distortion", "flownoise", "divergencefree"], "likes": 12, "viewed": 420, "published": 3, "date": "1598801898", "time_retrieved": "2024-07-30T20:48:23.821070", "image_code": "// variant of https://shadertoy.com/view/WtBBD1\n\n  #define hash(p)    fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n//#define hash2(p) ( 2.* fract( sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123 ) - 1. )\n  #define hash2(p)   cos( 6.28*hash(p) + vec2(0,11) + V(p)*iTime ) // variant of random gradient + rotating (= lownoise)\n  #define l(i,j)     dot( hash2(I+vec2(i,j)) , F-vec2(i,j) )       // random wavelet at grid vertex I+vec2(i,j) \n  #define L(j,x)     mix( l(0,j), l(1,j), x )\n\n  #define V(p) 2.                                // flownoise rotation speed \n//#define V(p) 2.*( 2.*mod((p).x+(p).y,2.)- 1. ) // checkered rotation direction \n//#define V(p) length(p)\n//#define V(p) ( 8. - length(p) )\n\nfloat Perlin(vec2 p) {                        // Perlin noise\n    vec2 I = floor(p), \n         F = fract(p), \n     //  U = F;\n     //  U = F*F*(3.-2.*F);                   // based Perlin noise\n         U = F*F*F*( F* ( F*6.-15.) + 10. );  // improved Perlin noise ( better derivatives )\n    return mix( L(0,U.x) , L(1,U.x) , U.y );  // smooth interpolation of corners random wavelets\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         S = 8. / R.yy,\n         U = ( 2.*u - R ) * S,\n         D;\n    float v = Perlin( U );                    \n // O = vec4( .5 + .5 * v ); return;          // see Perlin noise\n    \n                                              // --- divergence-free displacement noise\n // D = vec2( v - Perlin( U+vec2(0,S.y) ), Perlin( U+vec2(S.x,0) ) - v ) *2./ S;\n    D = vec2( -dFdy(v), dFdx(v) ) / S;        // using hardware derivatives\n    D += sin(iTime) * U; \n    O = iMouse.z <= 0. \n          ? vec4( .5 + .5* atan(D.y,D.x)/3.14 )  // see noise direction\n          : .6 + .6 * cos( atan(D.y,D.x)  + vec4(0,23,21,0)  ); // dir as hue\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[726, 726, 748, 787, 1112], [1114, 1114, 1152, 1152, 1813]], "test": "untested"}
{"id": "wtSBWh", "name": "Smooth kaleidoscope", "author": "mrange", "description": "License CC0: Smooth kaleidoscope\nKaleidoscope with smoothing\nI thought this might be useful to someone else so I shared this ugly barebones shared\n", "tags": ["kaleidoscope", "sabs"], "likes": 3, "viewed": 411, "published": 3, "date": "1598782361", "time_retrieved": "2024-07-30T20:48:24.941076", "image_code": "// License CC0: Smooth kaleidoscope\n// Kaleidoscope effects are cool but while the mirror effect ensure the curves are\n//  continuous the derivates are not. \n//  SABS has been a great tool whenever I needed an abs function that gave the illusion\n//   continuous derivates.\n//  I patched SABS into a kaleidoscope effect to get a smooth kaleidoscopic effect.\n\n// I thought this might be useful to someone else so I shared this ugly barebones shared\n\n#define TIME       iTime\n#define RESOLUTION iResolution\n\n#define PI         3.141592654\n#define TAU        (2.0*PI)\n\n// SABS by ollj, this has turned out extremely useful on many occassions\n//  https://www.shadertoy.com/view/Ws2SDK\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n\n// http://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat df(vec2 p) {\n  const float rep = 6.0;\n\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  \n  // mod the angular component to get an kaleidoscope effect\n  // modMirror ensure curves are continuous\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  // Apply smoothing on right side of screen to make derivate of curves continuous\n  //   Left side non-smoothed for comparison\n  if (p.x > 0.0) {\n    float sa = PI/rep - SABS(PI/rep - abs(hpp.y), 0.25);\n    hpp.y = sign(hpp.y)*sa;\n  }\n\n  hp = toRect(hpp);\n  hp.x -= 0.5;\n  \n  rot(hp, TIME);\n  float d1 = box(hp, 0.25*vec2(0.5, 0.75));\n\n  float d = d1;\n\n  d = abs(d) - 0.01;\n  \n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  float d = df(p);\n  \n  vec3 col = vec3(0.0);\n  float aa = 1.0/RESOLUTION.y;\n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -d));\n  col += vec3(0.0, 0.5, 0.5)*(0.5 + 0.5*sin(200.0*d));\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBWh.jpg", "access": "api", "license": "cc0-1.0", "functions": [[789, 820, 865, 865, 1019], [1021, 1021, 1054, 1054, 1139], [1141, 1141, 1163, 1163, 1207], [1209, 1209, 1230, 1230, 1271], [1273, 1324, 1351, 1351, 1427], [1429, 1429, 1447, 1447, 2057], [2059, 2059, 2111, 2111, 2429]], "test": "untested"}
{"id": "WlBBD1", "name": "cartoon water", "author": "FabriceNeyret2", "description": "cascade of normalized flownoise ", "tags": ["perlinnoise", "distortion", "flownoise"], "likes": 16, "viewed": 635, "published": 3, "date": "1598772711", "time_retrieved": "2024-07-30T20:48:25.851641", "image_code": "// variant of https://shadertoy.com/view/WtBBD1\n\n  #define hash(p)    fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n//#define hash2(p) ( 2.* fract( sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123 ) - 1. )\n  #define hash2(p)   cos( 6.28*hash(p) + vec2(0,11) + V(p)*iTime ) // variant of random gradient + rotating (= lownoise)\n  #define l(i,j)     dot( hash2(I+vec2(i,j)) , F-vec2(i,j) )       // random wavelet at grid vertex I+vec2(i,j) \n  #define L(j,x)     mix( l(0,j), l(1,j), x )\n\n  #define V(p) 2.                                // flownoise rotation speed \n//#define V(p) 2.*( 2.*mod((p).x+(p).y,2.)- 1. ) // checkered rotation direction \n//#define V(p) length(p)\n//#define V(p) ( 8. - length(p) )\n\nfloat Perlin(vec2 p) {                        // Perlin noise\n    vec2 I = floor(p), \n         F = fract(p), \n     //  U = F;\n         U = F*F*(3.-2.*F);                   // based Perlin noise\n     //  U = F*F*F*( F* ( F*6.-15.) + 10. );  // improved Perlin noise ( better derivatives )\n    return mix( L(0,U.x) , L(1,U.x) , U.y );  // smooth interpolation of corners random wavelets\n}\n\nfloat Uperlin(vec2 p) { \n    float v = Perlin(p); \n    return smoothstep(-1.,1.,v/fwidth(v));    // normalized field\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 2.* ( 2.*u - R ) /R.y;\n    O -= O;\n    float s=1.;\n    vec4 C = vec4(.8,.85,1,0);\n    for (int i=0; i<5; i++, s*=2., C*=C) \n        O += C * Uperlin(s *(U+9.) ) / s;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[726, 726, 748, 787, 1112], [1114, 1114, 1137, 1137, 1232], [1234, 1234, 1272, 1272, 1482]], "test": "untested"}
{"id": "3lBBD1", "name": "Generative material texture", "author": "hyranno", "description": "Generative material texture for physics based rendering.\nBased on fBM, cellular noise, warping.\nPseudo random generated by permuted congruential generator", "tags": ["texture", "material"], "likes": 3, "viewed": 288, "published": 3, "date": "1598771534", "time_retrieved": "2024-07-30T20:48:26.796116", "image_code": "/*\nby hyranno 2020/08/30\nGenerative material texture\nBased on fBM, cellular noise, warping\nPseudo random generated by permuted congruential generator\n*/\n\n#define MATERIAL 2\n/*\n0 : rough metal\n1 : scaled leather\n2 : wood\n*/\n\n\nconst float PI  = 3.141592653589793;\n\n/*\nhandling tetrahedron basis\nshould be uniform or const?\n*/\nmat3 TetrahedronBasis;\nmat3 InvTetrahedronBasis;\nvec3 TetrahedronCenter;\nvoid initTetrahedron(){\n  TetrahedronBasis = mat3(\n      cos(PI/6.0), sin(PI/6.0), 0,\n      cos(PI/6.0), -sin(PI/6.0), 0,\n      sqrt(1.0/3.0), 0, sqrt(2.0/3.0)\n  );\n  InvTetrahedronBasis = mat3(sqrt(1.0/3.0),sqrt(1.0/3.0),0, 1,-1,0, -sqrt(1.0/6.0),-sqrt(1.0/6.0),sqrt(3.0/2.0));\n  TetrahedronCenter = (TetrahedronBasis[0]+TetrahedronBasis[1]+TetrahedronBasis[2])/4.0;\n}\n//vec3 toTetrahedronCoord(vec3 p){ return InvTetrahedronBasis*p; }\n//vec3 fromTetrahedronCoord(vec3 p){ return TetrahedronBasis*p; }\n\n\nvec3[8] getBoundingCuboid(vec3 point){\n  vec3 ptf = floor(point), ptc = floor(point + vec3(1.0));\n  vec3[8] res;\n  res[0] = ptf;\n  res[1] = vec3(ptf.x, ptf.y, ptc.z);\n  res[2] = vec3(ptf.x, ptc.y, ptf.z);\n  res[3] = vec3(ptf.x, ptc.y, ptc.z);\n  res[4] = vec3(ptc.x, ptf.y, ptf.z);\n  res[5] = vec3(ptc.x, ptf.y, ptc.z);\n  res[6] = vec3(ptc.x, ptc.y, ptf.z);\n  res[7] = ptc;\n  return res;\n}\n\n\n/*\nvector rotation\n*/\nmat2 rotate2D(float angle){\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\nvec3 rotateAround(vec3 axis, float angle, vec3 p){\n  //Rodrigues' rotation formula\n  return p*cos(angle) + axis*dot(axis, p)*(1.0-cos(angle)) + cross(axis, p)*sin(angle);\n}\nvec3 rotateFromTo(vec3 f, vec3 t, vec3 p){\n  vec3 tmp = cross(f,t);\n  vec3 axis = normalize(tmp);\n  float angle = atan(length(tmp),dot(f,t));\n  vec3 res = rotateAround(axis, angle, p);\n  return (length(tmp)>0.0)? res : p;\n}\nvec3 tiltVec(vec3 v, float amp, float dir){\n  vec3 tmp = rotateAround(vec3(0,1,0), amp, vec3(1,0,0));\n  tmp = rotateAround(vec3(1,0,0), dir, tmp);\n  return rotateFromTo(vec3(1,0,0), v, tmp);\n}\n\n\n/*\nrandom generation\n */\n\nint rand_PCG(int seed){\n  const highp int increment = 0x4f6f4f3;\n  const highp int multiplier = 0x8934649*4+1;\n  highp int state = (seed + increment) & 0xffffffff;\n  highp int x;\n  int count;\n  state = (state * multiplier + increment) & 0xffffffff;\n  x = state;\n  state = (state * multiplier + increment) & 0xffffffff;\n  count = (x >> 28)&0x0f;  //32-log2(16)\n  x ^= (x >> 10)&0x3fffff;  //(32-(16-log2(16)))/2\n  int xs = (x >> 12)&0xffff;  //16-log2(16)\n  return ((xs >> count) | (xs << (16-count)))&0xffff;\n}\nint rand16(float f){\n  return rand_PCG(int(floor(f)));\n}\nfloat rand_uniform(vec3 v){\n  ivec3 sv = ivec3(floor(v));\n  int r = rand_PCG(rand_PCG(rand_PCG(sv.x)^sv.y)^sv.z);\n  return float(r+1) / float(0x10000);\n}\nfloat rand_exponential(vec3 v, float average){\n  //inversion method\n  return -average*log(1.0-rand_uniform(v));\n}\nvec2 rand_normal2(vec3 v){\n  //Box–Muller's method\n  float r1 = rand_uniform(v);\n  float r2 = rand_uniform(v.zxy);\n  float len = sqrt(-2.0*log(r1));\n  float angle = 2.0*PI*r2;\n  return len * vec2(cos(angle), sin(angle));\n}\nfloat rand_normal(vec3 v){\n  return rand_normal2(v).x;\n}\n\n\n\n/*\ncamera\n*/\nstruct Camera {\n  vec3 position;\n  vec3 target;\n  float roll;\n  vec2 angle;\n};\nCamera cam; //uniform\n\nvec3 uvToRayDirection(vec2 uv){\n  vec2 uvs = 2.0*uv - vec2(1.0);\n  vec3 defview = vec3(0.0, 0.0, 1.0);\n  vec3 view = normalize(cam.target-cam.position);\n  vec3 res = normalize( vec3(tan(cam.angle.x)*uvs.x, tan(cam.angle.y)*uvs.y, 1.0) );\n  res.xy = rotate2D(cam.roll)*res.xy;\n  res.yz = rotate2D(asin(view.y))*res.yz;\n  res.xz = rotate2D(atan(view.x, view.z))*res.xz;\n  return res;\n}\nfloat getPixelSize(vec3 point) {\n  float pixelAngle = cam.angle.x / iResolution.x;\n  return distance(cam.position, point) * tan(pixelAngle);\n}\n\n\n/*\nfBM noise generation\n */\nstruct ParamFBM {\n  float seed;\n  vec3 scale;\n  float attenuation;\n  float tilt;\n};\nstruct PartFBM {\n  float weightSum;\n  vec3 vec;\n  float scalar;\n};\nPartFBM newPartFBM(){\n  PartFBM res;\n  res.weightSum = 0.0;\n  res.vec = vec3(0.0);\n  res.scalar = 0.0;\n  return res;\n}\nPartFBM normalize(PartFBM src){\n  PartFBM res;\n  res.weightSum = src.weightSum/src.weightSum;\n  res.vec = src.vec/src.weightSum;\n  res.scalar = src.scalar/src.weightSum;\n  return res;\n}\n\nvoid partNoise(inout PartFBM res, vec3 pt, vec3 pti, ParamFBM param, float amp){\n  float angle = rand_uniform(pti*13.0) * 2.0*PI;\n  float mag = rand_normal(pti);\n  float r = distance(pt, pti);// / sqrt(2.0/3.0);\n  float weight = smoothstep(1.0,0.0, r*r);\n  float val = amp*weight*mag;\n  res.weightSum += weight;\n  res.vec += tiltVec(vec3(1,0,0)*val, param.tilt*mag, angle);\n  res.scalar += val;\n}\nvoid tetraNoise(inout PartFBM res, vec3 p, ParamFBM param, float freq, float amp){\n  float salt = float(rand16(freq + param.seed));\n  vec3 pt = InvTetrahedronBasis*(p/(freq*param.scale) + salt);\n  PartFBM part = newPartFBM();\n  vec3[8] pts = getBoundingCuboid(pt);\n  for (int i=min(0,iFrame); i<8; i++) {\n    partNoise(part, pt, pts[i], param, amp);\n  }\n  part = normalize(part);\n  res.vec += part.vec;\n  res.scalar += part.scalar;\n}\nPartFBM fbmNoise(vec3 point, ParamFBM param){\n  int maxOctave = int(ceil( log2(length(param.scale)/getPixelSize(point)) ));\n  float freq = 1.0;\n  float amp = 1.0;\n  PartFBM sum = newPartFBM();\n  for (int octave=0; octave <= maxOctave; octave++){\n    tetraNoise(sum, point, param, freq, amp);\n    freq /= 2.0;\n    amp /= param.attenuation;\n  }\n  return sum;\n}\n\n\n/*\ncellular noise generation\n */\nstruct CellParam{\n  vec3 shift;\n  vec3 seed;\n  vec3 scale;\n  float randomness;\n};\nstruct CellInfo{\n  vec3 center;\n  float rCenter;\n  float rBoundary;\n};\nvoid cellularNoiseSub(vec3 p, CellParam param, vec3 center, inout float r1, inout float r2, inout CellInfo res){\n  vec3 rands;\n  rands.x = rand_normal(center+param.seed.xxx);\n  rands.y = rand_uniform(center+param.seed.yyy);\n  rands.z = rand_uniform(center+param.seed.zzz);\n  vec3 randv = param.randomness*rands.x *tiltVec(vec3(1,0,0), rands.y*PI, rands.z*PI*2.0);\n  vec3 cellp = center+randv;\n  float r = distance(p, cellp);\n  r2 = (r2<r)? r2 : r;\n  res.center = (r1<r)? res.center : cellp;\n  r2 = (r1<r)? r2 : r1;\n  r1 = (r1<r)? r1 : r;\n}\nCellInfo cellularNoise(vec3 point, CellParam param){\n  vec3 p = point/param.scale + param.shift;\n  CellInfo res;\n  float r1=200.0, r2=200.0;\n  vec3[8] pts = getBoundingCuboid(InvTetrahedronBasis*p);\n  for (int i=min(0,iFrame); i<8; i++) {\n    cellularNoiseSub(p, param, TetrahedronBasis*pts[i], r1, r2, res);\n  }\n  res.center = (res.center-param.shift)*param.scale;\n  res.rCenter = r1;\n  res.rBoundary = (r2-r1)/2.0;\n  return res;\n}\n\n\n/*\ngrouth ring generation\n */\nstruct GrowthRingParam{\n  float scale;\n  vec3 center;\n  vec3 direction;\n  float sharpness;\n  float randomness;\n  ParamFBM pFBM;\n};\nfloat GrowthRingNoise(vec3 point, GrowthRingParam param) {\n  vec3 pt = point/param.scale - param.center;\n  vec3 p = rotateFromTo(param.direction, vec3(1,0,0), pt);\n  float r = length( p.yz );\n  r += param.randomness * fbmNoise(p, param.pFBM).scalar;\n  float v = fract(r);\n  float val = (v*v) * smoothstep(0.0, 1.0, param.sharpness*(1.0-v));\n  return val;\n}\n\n\n\nstruct DistanceToSurface {\n  int objectID;\n  float distance;\n};\n\nstruct Surface {\n  int objectID;\n  vec3 position;\n  vec3 albedo;\n  vec3 normal;\n  float metalness;\n  float roughness;\n  float occlusion;\n};\n\n/*\nray marching\n */\n\nDistanceToSurface findNearestSurface(vec3 point) {\n  DistanceToSurface res;\n  res.objectID = 1;\n  res.distance = distance(point, vec3(0.0)) - 5.0;\n  return res;\n}\nSurface getSurface(int objectID, vec3 point) {\n  Surface res;\n  res.objectID = 1;\n  res.position = point;\n  res.normal = normalize(point);\n  res.occlusion = 0.0;\n  float pixelSize = getPixelSize(res.position);\n  vec3 dp1 = pixelSize * rotateFromTo(vec3(1,0,0), res.normal, vec3(0,1,0));\n  vec3 dp2 = pixelSize * rotateFromTo(vec3(1,0,0), res.normal, vec3(0,0,1));\n  float height = 0.0;\n  float h1 = 0.0;\n  float h2 = 0.0;\n\n#if MATERIAL == 0\n  res.albedo = vec3(0.8, 0.8, 0.8);\n  res.metalness = 0.24;\n  res.roughness = 0.1;\n\n  ParamFBM pFBM;\n  pFBM.seed = 893.0;\n  pFBM.scale = vec3(1.0, 1.0, 1.0);\n  pFBM.attenuation = 2.0;\n  pFBM.tilt = 0.1;\n  vec3 fbmHue = normalize(vec3(1, -1, -1));\n  float fbmAlbedo = 0.004;\n  float fbmHeight = 0.006;\n  float fbmMetalness = -0.01;\n  float fbmRoughness = 0.01;\n\n#elif MATERIAL == 1\n  res.albedo = vec3(0.8, 0.8, 0.8);\n  res.metalness = 0.20;\n  res.roughness = 0.20;\n\n  ParamFBM pFBM;\n  pFBM.seed = 893.0;\n  pFBM.scale = vec3(0.05);\n  pFBM.attenuation = 4.0;\n  pFBM.tilt = 0.5 * PI/2.0;\n  vec3 fbmHue = normalize(vec3(1, 1, 1));\n  float fbmAlbedo = 0.1;\n  float fbmHeight = 0.003;\n  float fbmMetalness = 0.01;\n  float fbmRoughness = -0.02;\n\n#elif MATERIAL == 2\n  res.albedo = vec3(0.9, 0.8, 0.7);\n  res.metalness = 0.14;\n  res.roughness = 0.26;\n\n  ParamFBM pFBM;\n  pFBM.seed = 893.0;\n  pFBM.scale = vec3(1.0);\n  pFBM.attenuation = 2.0;\n  pFBM.tilt = 0.1;\n  vec3 fbmHue = normalize(vec3(1, 0, -0.2));\n  float fbmAlbedo = 0.004;\n  float fbmHeight = 0.014;\n  float fbmMetalness = -0.01;\n  float fbmRoughness = 0.01;\n#endif\n\n  h1 += fbmHeight * fbmNoise(point+dp1, pFBM).scalar;\n  h2 += fbmHeight * fbmNoise(point+dp2, pFBM).scalar;\n  PartFBM fbm = fbmNoise(point, pFBM);\n\n  height += fbmHeight * fbm.scalar;\n  res.albedo += fbmAlbedo * rotateFromTo(vec3(1,0,0), fbmHue, fbm.vec);\n  res.metalness += fbmMetalness * fbm.scalar;\n  res.roughness += fbmRoughness * fbm.scalar;\n\n#if MATERIAL == 1\n  CellParam pCell;\n  pCell.shift = vec3(8.93,10.9,4.643);\n  pCell.seed = vec3(634,546,763);\n  pCell.scale = vec3(0.7);\n  pCell.randomness = 0.027;\n  vec3 cellAlbedo = 0.4*normalize(vec3(-0.4,-1,-1));\n  float cellHeight = -0.07;\n  float cellMetalness = -0.04;\n  float cellRoughness = 0.04;\n\n  CellInfo cellNoise1 = cellularNoise(point+dp1, pCell);\n  h1 += cellHeight*(smoothstep(0.4, 0.0, cellNoise1.rBoundary*1.4) + smoothstep(0.0, 1.0, cellNoise1.rCenter));\n  CellInfo cellNoise2 = cellularNoise(point+dp2, pCell);\n  h2 += cellHeight*(smoothstep(0.4, 0.0, cellNoise2.rBoundary*1.4) + smoothstep(0.0, 1.0, cellNoise2.rCenter));\n  CellInfo cellNoise = cellularNoise(point, pCell);\n  float cellVal = smoothstep(0.4, 0.0, cellNoise.rBoundary*1.4) + smoothstep(0.0, 1.0, cellNoise.rCenter);\n\n  height += cellHeight * cellVal;\n  res.albedo += cellAlbedo * cellVal;\n  res.metalness += cellMetalness * cellVal;\n  res.roughness += cellRoughness * cellVal;\n#endif\n\n#if MATERIAL == 2\n  GrowthRingParam pGrowthRing;\n  pGrowthRing.scale = 0.8;\n  pGrowthRing.center = vec3(1.0, 0.0, 0.0);\n  pGrowthRing.direction = normalize(vec3(0.3, 1.0, 0.0));\n  pGrowthRing.sharpness = 4.0;\n  pGrowthRing.randomness = 0.1;\n  pGrowthRing.pFBM.seed = 763.0;\n  pGrowthRing.pFBM.scale = vec3(5.0, 1.0, 1.0);\n  pGrowthRing.pFBM.attenuation = 2.0;\n  pGrowthRing.pFBM.tilt = 0.0;\n  vec3 growthRingAlbedo = 2.0 * normalize(vec3(-0.3, -1, -3));\n  float growthRingMetalness = -0.01;\n  float growthRingRoughness = -0.01;\n\n  float growthRingVal = GrowthRingNoise(point, pGrowthRing);\n  res.albedo += growthRingAlbedo * growthRingVal;\n  res.metalness += growthRingMetalness * growthRingVal;\n  res.roughness += growthRingRoughness * growthRingVal;\n#endif\n\n  res.normal = normalize(cross(dp1 + (h1-height)*res.normal, dp2 + (h2-height)*res.normal));\n  res.albedo = clamp(res.albedo, 0.0, PI);\n  res.metalness = clamp(res.metalness, 0.0, 1.0);\n  res.roughness = clamp(res.roughness, 0.0, 1.0);\n  return res;\n}\n\nSurface raycast(vec3 origin, vec3 direction) {\n  const float e = 0.00001;\n  const float rayMaxLength = 100.0;\n  const int maxIteration = 50;\n  vec3 point = origin;\n  DistanceToSurface nearest = findNearestSurface(point);\n  for (int i=0; (i<maxIteration) && (distance(point, origin) < rayMaxLength) && (nearest.distance >= e); i++) {\n    point += direction * nearest.distance;\n    nearest = findNearestSurface(point);\n  }\n  Surface res = getSurface(nearest.objectID, point);\n  res.objectID = (nearest.distance < e)? res.objectID : -1;\n  return res;\n}\n\n\n/*\nphysics based rendering\n */\n\nfloat Vt_GGX(Surface suf, vec3 v){\n  return 0.5*(-1.0 + sqrt(1.0 + pow(suf.roughness,2.0)*(1.0/pow(dot(v,suf.normal),2.0)-1.0)));\n}\nvec3 applyDirectionalLight(Surface suf, vec3 light, vec3 lightDir, vec3 viewDir){\n  vec3 halfDir = normalize(lightDir+viewDir);\n  float F0 = suf.metalness; // Fresnel reflection rate\n  float F = F0 + (1.0-F0)*pow(1.0-dot(viewDir,halfDir), 5.0);\n  float G = 1.0/(1.0 + Vt_GGX(suf, lightDir) + Vt_GGX(suf, viewDir));\n  float D = pow(suf.roughness, 2.0) /PI /pow(pow(dot(suf.normal, halfDir),2.0) * (pow(suf.roughness,2.0)-1.0) +1.0, 2.0);\n  vec3 specular = vec3(1.0) * D*G*F / (4.0* dot(suf.normal, lightDir) * dot(suf.normal, viewDir));\n  vec3 diffuse = suf.albedo/PI;\n  vec3 color = (diffuse*(1.0-suf.metalness) + specular*suf.metalness) * dot(lightDir, suf.normal) * light;\n  return max(color, 0.0);\n}\n\nvec3 applyAmbientLight(Surface suf, vec3 light){\n  vec3 diffuse = suf.albedo/PI;\n  return (1.0-suf.occlusion) * diffuse * light;\n}\n\n\n\n/*\nmain\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  initTetrahedron();\n\n  float radius = 4.0*cos(iTime/5.0) + 12.0;\n  cam.position = vec3(radius*cos(iTime/2.0), 4.0, radius*sin(iTime/2.0));\n  cam.target = vec3(0.0, 0.0, 0.0);\n  cam.roll = 0.0/360.0 * 2.0*PI;\n  cam.angle.x = 2.0*PI * 50.0/360.0;\n  cam.angle.y = atan(tan(cam.angle.x)*(iResolution.y/iResolution.x));\n\n  vec2 uv = fragCoord/iResolution.xy;\n  vec3 rayDir = uvToRayDirection(uv);\n  Surface suf = raycast(cam.position, rayDir);\n\n  vec3 col = vec3(0.0);\n  col += (suf.objectID<0)? vec3(0.0) : applyDirectionalLight(suf, vec3(2.0), -vec3(0.0, -1.0, 0.0), -rayDir);\n  col += (suf.objectID<0)? vec3(0.0) : applyAmbientLight(suf, vec3(0.5));\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[397, 397, 420, 420, 766], [1293, 1315, 1342, 1342, 1408], [1409, 1409, 1459, 1491, 1581], [1582, 1582, 1624, 1624, 1805], [1806, 1806, 1849, 1849, 1998], [2538, 2538, 2558, 2558, 2594], [2595, 2595, 2622, 2622, 2748], [2749, 2749, 2795, 2816, 2862], [2863, 2863, 2889, 2915, 3087], [3088, 3088, 3114, 3114, 3144], [3263, 3263, 3294, 3294, 3646], [3647, 3647, 3679, 3679, 3789], [3971, 3971, 3992, 3992, 4089], [4090, 4090, 4121, 4121, 4275], [4277, 4277, 4357, 4357, 4673], [5108, 5108, 5153, 5153, 5466], [5655, 5655, 5767, 5767, 6194], [6791, 6791, 6849, 6849, 7147], [7378, 7378, 7428, 7428, 7540], [7541, 7541, 7587, 7587, 11435], [11437, 11437, 11483, 11483, 11986], [12021, 12021, 12055, 12055, 12152], [12153, 12153, 12234, 12234, 12855], [12857, 12857, 12905, 12905, 12987], [13004, 13004, 13061, 13061, 13743]], "test": "untested"}
{"id": "WtBBD1", "name": "can of worms", "author": "FabriceNeyret2", "description": "use divergence-free flownoise to distort a base function ( here, radial gradient )", "tags": ["perlinnoise", "displacement", "distortion", "flownoise", "filament", "divergencefree"], "likes": 9, "viewed": 448, "published": 3, "date": "1598770748", "time_retrieved": "2024-07-30T20:48:27.637865", "image_code": "  #define hash(p)    fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n//#define hash2(p) ( 2.* fract( sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123 ) - 1. )\n  #define hash2(p)   cos( 6.28*hash(p) + vec2(0,11) + V(p)*iTime ) // variant of random gradient + rotating (= lownoise)\n  #define l(i,j)     dot( hash2(I+vec2(i,j)) , F-vec2(i,j) )       // random wavelet at grid vertex I+vec2(i,j) \n  #define L(j,x)     mix( l(0,j), l(1,j), x )\n\n  #define V(p) 2.                                // flownoise rotation speed \n//#define V(p) 2.*( 2.*mod((p).x+(p).y,2.)- 1. ) // checkered rotation direction \n//#define V(p) length(p)\n//#define V(p) ( 8. - length(p) )\n\nfloat Perlin(vec2 p) {                        // Perlin noise\n    vec2 I = floor(p), \n         F = fract(p), \n     //  U = F;\n     //  U = F*F*(3.-2.*F);                   // based Perlin noise\n         U = F*F*F*( F* ( F*6.-15.) + 10. );  // improved Perlin noise ( better derivatives )\n    return mix( L(0,U.x) , L(1,U.x) , U.y );  // smooth interpolation of corners random wavelets\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         S = 8. / R.yy,\n         U = ( 2.*u - R ) * S,\n         D;\n    float v = Perlin( U );                    \n // O = vec4( .5 + .5 * v ); return;          // see Perlin noise\n    \n                                              // --- divergence-free displacement noise\n // D = vec2( v - Perlin( U+vec2(0,S.y) ), Perlin( U+vec2(S.x,0) ) - v ) *2./ S;\n    D = vec2( -dFdy(v), dFdx(v) ) / S;        // using hardware derivatives\n // O = vec4( .5 + .5 * D, 0, 0); return;     // see noise vector\n // O = vec4(.5+.5*atan(D.y,D.x)/3.14); return;// see noise direction\n // D += .5*U; O = vec4(.5+.5*atan(D.y,D.x)/3.14); return;// see noise direction\n    \n    v = length( U + 1.*D );                   // distorted distance\n // O = vec4( v / 10. );                      // see\n // O = vec4( v / max(2.,1.5*length(U)) );    // renormalize by distance\n    O = vec4( v / max(1.5,.5*dot(U,U)) );     // renormalize by distance then div by dist\n // O = vec4( .5 + .5 * sin(v) );             // distorted concentric circles\n // O = vec4( .01* v / fwidth(v) );\n    O *= vec4(1.3,.8,.5,0);                   // coloring\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[677, 677, 699, 738, 1063], [1065, 1065, 1103, 1103, 2242]], "test": "untested"}
{"id": "3lBBDh", "name": "landline", "author": "lennyjpg", "description": "alksdjfjasdf", "tags": ["line", "spiral", "phone", "cable"], "likes": 3, "viewed": 278, "published": 3, "date": "1598746293", "time_retrieved": "2024-07-30T20:48:28.399828", "image_code": "void mainImage( out vec4 O, in vec2 f )\n{\n    vec2 uv = f / iResolution.y,\n        u = vec2(fract(uv.x * 3. - iTime * .2), uv.y * 1.6 - .3);\n    if(u.y > .5){\n        u.x = abs(u.x - .5);\n    }\n    float k = length(u - .5),\n        e = smoothstep(k, k * .99, .5);\n    vec3 a = vec3(1.,0.,0.),\n        b = u.y > .5 ? vec3(1.) : vec3(0.,0.,.2);\n    O = vec4(mix(a,b,e),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 373]], "test": "untested"}
{"id": "3tSfRW", "name": "Cell system 2", "author": "michael0884", "description": "No really, what the heck", "tags": ["particles", "ca"], "likes": 31, "viewed": 1268, "published": 3, "date": "1598737478", "time_retrieved": "2024-07-30T20:48:29.357268", "image_code": "// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.56\n#define RAD R.x*0.6\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 3.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.03*iTime, -0.4)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo =sin(vec3(1,2,3)*3.*D*D);\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 4.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 8.);\n            colB += 4.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 8.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(2.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol=sin(vec4(1,2,3,4)*1.2*r);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n//i.e. diffusion \n#define distribution_size 1.7\n\n//slime mold sensors\n#define sense_num 12\n#define sense_ang 0.03\n#define sense_dis 15.\n//weird oscillation force\n#define sense_oscil 0.0\n#define oscil_scale 1.\n#define oscil_pow 0.\n#define sense_force 0.38\n//slime mold sensor distance power law dist = sense_dispow(rho, pw)\n#define distance_scale 0.0\n#define force_scale 1.\n#define acceleration 0.\n\n#define density_normalization_speed 0.13\n#define density_target 0.24\n#define vorticity_confinement 0.0\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n   \n//density*temp = pressure - i.e. ideal gas law\n#define Pressure(rho) 0.5*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, density_target, density_normalization_speed);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 1.0*Dir(2.*PI*hash11(floor(pos.x/10.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n     \n        F -= 1.0*M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component from slime force and leave rotation only\n        slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-vorticity_confinement*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor = C(pos - V0*dt);\n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy = pos/R;\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 440, 467, 467, 645], [685, 685, 716, 716, 750], [752, 752, 804, 804, 923], [925, 925, 960, 960, 984], [986, 986, 1017, 1017, 1104], [1106, 1106, 1127, 1127, 1220], [1222, 1222, 1244, 1244, 1340], [1343, 1343, 1363, 1363, 1558], [1561, 1561, 1596, 1596, 1781], [1820, 1820, 1852, 1852, 2020], [2022, 2022, 2067, 2067, 4822]], "test": "untested"}
{"id": "WlSfRw", "name": "Feather roots", "author": "michael0884", "description": "SPACE to restart\nRecommended to watch in 4x acceleration\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 97, "viewed": 2091, "published": 3, "date": "1598732237", "time_retrieved": "2024-07-30T20:48:30.310719", "image_code": "// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.56\n#define RAD R.x*0.4\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.0*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = vec3(0.5)*(D+0.07);//*texture(iChannel3, c.xy).xyz;\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= vec4(1.6)*r;//*texture(iChannel3, c.xy);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 1.4\n\n/* FIRE\n//mold stuff \n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 420.\n#define sense_oscil 0.1\n#define oscil_scale 1.\n#define oscil_pow 2.\n#define sense_force -0.35\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n*/\n\n#define sense_num 2\n#define sense_ang (0.15 + 0.13*sin(iTime))\n#define sense_dis 200.\n#define sense_oscil 0.0\n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force 0.5\n#define distance_scale 2.\n#define force_scale 0.5\n#define trailing 0.\n#define acceleration 0.0\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.0*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.1, 0.03);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= 0.6*M*dgrad;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (3. + sense_dis*pow(max(M - 0., 0.), distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n        slimeF -= 0.1*dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.0\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor = C(pos - V0*dt);\n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy = pos/R;\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 440, 467, 467, 645], [685, 685, 716, 716, 750], [752, 752, 804, 804, 923], [925, 925, 960, 960, 984], [986, 986, 1017, 1017, 1104], [1106, 1106, 1127, 1127, 1220], [1222, 1222, 1244, 1244, 1340], [1343, 1343, 1363, 1363, 1558], [1561, 1561, 1596, 1596, 1781], [1820, 1820, 1852, 1852, 2020], [2022, 2022, 2067, 2067, 4867]], "test": "untested"}
{"id": "3tBBWh", "name": "Day 16 of #raymarching challenge", "author": "illus0r", "description": "Day 16 of #raymarching challenge. Sierpinski tetrahedron studies.", "tags": ["raymarching", "fractal"], "likes": 3, "viewed": 269, "published": 3, "date": "1598732180", "time_retrieved": "2024-07-30T20:48:31.074676", "image_code": "#define textureCube texture\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define iTime (iTime / 10.1)\n\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 polarToDecart(vec2 polar) {\n    float alpha = polar.x;\n    float R = polar.y;\n    float x = sin(alpha) * R;\n    float y = cos(alpha) * R;\n    return vec2(x, y);\n}\n\nvec2 decartToPolar(vec2 decart) {\n    float alpha = atan(decart.x, decart.y);\n    float R = length(decart);\n    return vec2(alpha, R);\n}\n\nfloat DE(vec3 z)\n{\n    // FIXME\n    z.x += 5. * sin(iTime);\n    z.y += 5. * sin(iTime);\n    z.z += 5. * cos(iTime);\n    float r;\n    int n = 0;\n    float Scale = 1.1;\n    float Move = 10.;\n    while (n < 15) {\n        // z.xy *= Rot(0.3 * iTime);\n        z.yx *= Rot(iTime * .5);\n       if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\t\n        // z-=2.0 * min(0.0, 1.) * n1;\n       z = z*Scale - Move*(Scale-1.0);\n    //     vec3 n1 = vec3(0.4 * sin(iTime), 0.9, -0.1 * sin(iTime));\n    //    float t = dot(z,n1); if (t<0.0) { z-=5.0*t*n1; }\n    //     n1 = n1.zyx;\n    //    t = dot(z,n1); if (t<0.0) { z-=5.0*t*n1; }\n       n++;\n    }\n    return (length(z)) * pow(Scale, -float(n)) - 0.5;\n}\n\nfloat sdColumn(vec3 p, float width) {\n    // float box = sdBox(p, vec3(width, 10., width));\n    p *= 5.;\n    float fractal = DE(p) / 5.;\n    // float column = max(fractal, box);\n    // return column;\n    // return fractal + abs((p.x + p.z ) / 1.);\n    return fractal;\n}\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    vec2 ar = decartToPolar(p.xz);\n    float a = ar.x, r = ar.y;\n    float astep = 2. * PI / 8.; // number of rays\n    a = mod(a, astep);\n    a -= astep / 2.;\n    a = abs(a);\n    p.xz = polarToDecart(vec2(a, r));\n    // float cyl = length(p.xz - vec2(0, 2)) - 0.2;\n    p.xz *= Rot(iTime + p.y * 0.1);\n    float column = sdColumn(p, 2.5);\n    return vec2(column, RED);\n    // return cyl < column? vec2(cyl, BLACK) : vec2(column, IVORY);\n//   return vec2(max(DE(p), length(p.xz+vec2(1)) - 0.1), BLUE);\n//   return vec2(DE(p) + length(p) - 4., BLUE);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float minAngleToObstacle = 1e10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, minAngleToObstacle);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\n\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // ray origin\n    float camRadius = 7.;\n    vec3 ro = vec3(camRadius * sin(iTime * .0), 0, camRadius * cos(iTime * .0));\n    ro.xz *= Rot(iMouse.x / iResolution.x * PI * 2.);\n    float zoom = 1.100;\n\n    // ray direction\n    vec3 rd = getRayDir(uv, ro, vec3(0), 1.);\n\n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n\n    vec3 colorBg = vec3(.0);\n    vec3 color;\n    color = vec3(1);\n    // color = textureCube(iChannel0, rd).xyz;\n    vec3 light = vec3(camRadius * cos(iTime * .2), 20, camRadius * sin(iTime * .2));\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \t// color = vec3( n * 0.5 + 0.5 );\n\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        // drop shadows\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color *=  0.;\n        // }\n\n        // smooth shadows\n        float shadow = smoothstep(0.0, .15, rayMarchLight.z / PI);\n        color += .1 + .9 * shadow;\n\n        // reflection\n        // vec3 ref = reflect(rd, n);\n        // color += textureCube(iChannel0, ref).xyz;\n\n        // // refraction\n        // float e = 0.2;\n        // for (int i = 0; i < 2; i++) {\n        //     rd = refract(rd, n, 1. - e);\n        //     // rd = reflect(rd, n);\n        //     ro = p + rd * 0.05;\n        //     rm = rayMarch(ro, rd);\n        //     d = rm[0];\n        //     if (d > MAX_DIST) break;\n        //     p = ro + rd * d;\n        //     n = getNormal(p);\n\n        //     rd = refract(rd, -n, 1. + e);\n        //     // rd = reflect(rd, n);\n        //     ro = p + rd * 0.05;\n        //     rm = rayMarch(ro, rd);\n        //     d = rm[0];\n        //     if (d > MAX_DIST) break;\n        //     p = ro + rd * d;\n        //     n = getNormal(p);\n        // }\n        // color *= textureCube(iChannel0, rd).xyz;\n\n        // // reflection\n        // for (int i = 0; i < 2; i++) {\n        //     rd = reflect(rd, n);\n        //     ro = p + rd * 0.05;\n        //     rm = rayMarch(ro, rd);\n        //     d = rm[0];\n        //     if (d > MAX_DIST) break;\n        //     p = ro + rd * d;\n        //     n = getNormal(p);\n\n        //     rd = reflect(rd, n);\n        //     ro = p + rd * 0.05;\n        //     rm = rayMarch(ro, rd);\n        //     d = rm[0];\n        //     if (d > MAX_DIST) break;\n        //     p = ro + rd * d;\n        //     n = getNormal(p);\n        // }\n        // color = mix(textureCube(iChannel0, rd).xyz, color, 0.5);\n\n        //rm = rayMarch(p + ref * 0.1, ref);\n        // color = vec3(d);\n\n\n\n        // tex *= color_bw;\n        // color = tex;\n        // color += 0.6 + vec3( color_bw );\n        // coloring\n        if (d < MAX_DIST) {\n            if (info == IVORY) {\n                color = vec3(.4 * (dot(n, normalize(light - p))) + 1.);\n                // color *= vec3(0.832,0.800,0.849);\n            }\n            else if (info == BLUE) {\n                color *= vec3(0.810,0.256,0.397);\n            }\n           else if (info == RED) {\n                color = vec3(.4 * (dot(n, normalize(light - p))) + 1.);\n                color *= vec3(0.810,0.256,0.397);\n            }\n            else if (info == BLACK) {\n                color = vec3(0.);//vec3(.0 + 0.2 * (dot(n, normalize(light - p))) + 1.);\n                // color *= vec3(0.130,0.130,0.130);\n                // color *= 5. / length(p.xz);\n            }\n            // color = mix(color, colorBg, smoothstep(20., 28., d));\n        }\n    }\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 268, 268, 331], [333, 333, 364, 364, 451], [453, 453, 485, 485, 620], [622, 622, 655, 655, 758], [760, 760, 778, 791, 1535], [1537, 1537, 1574, 1628, 1806], [1808, 1887, 1909, 1909, 2459], [2548, 2548, 2581, 2581, 3055], [3057, 3057, 3081, 3081, 3299], [3303, 3303, 3357, 3357, 3584], [3586, 3586, 3636, 3636, 3827], [3830, 3830, 3886, 3886, 7859]], "test": "untested"}
{"id": "wljfWz", "name": "Basic Warped 2D Noise KurganCPC", "author": "kurganpsp", "description": "Basic Noise", "tags": ["2d"], "likes": 22, "viewed": 600, "published": 3, "date": "1598719315", "time_retrieved": "2024-07-30T20:48:31.844617", "image_code": "/*\tStandard Warped Noise\n\t---------------------\n\n\tLoosely based on the original by Shadertoy user \"jackdavenport.\"\n\thttps://www.shadertoy.com/view/Mt2SzR\n\n\tIn keeping with the concept of the original, this was also coded straight off the top of my head.\n\n*/\n\n// Virtually the same as your original function, just in more compact (and possibly less reliable) form.\nfloat smoothNoise(vec2 p) {\n\t\n\tvec2 f = fract(p); p-=f; f *= f*(3.-f-f); \n    \n    return dot(mat2(fract(sin(vec4(0, 1, 27, 28) + p.x+p.y*27.) * 1e5))*vec2(1.-f.y,f.y), vec2(1.-f.x, f.x));\n\n}\n\n// Also the same as the original, but with one less layer.\nfloat fractalNoise(vec2 p) {\n    \n    return smoothNoise(p)*0.5333 + smoothNoise(p*2.)*0.2667 + smoothNoise(p*4.)*0.1333 + smoothNoise(p*8.)*0.0667;\n    \n    // Similar version with fewer layers. The highlighting sample distance would need to be tweaked.\n    //return smoothNoise(p)*0.57 + smoothNoise(p*2.45)*0.28 + smoothNoise(p*6.)*0.15;\n    \n    // Even fewer layers, but the sample distance would need to be tweaked.\n    //return smoothNoise(p)*0.65 + smoothNoise(p*4.)*0.35;\n    \n}\n\n// Standard noise warping. Call the noise function, then feed a variation of the result\n// into itself. Rinse and repeat, etc. Completely made up on the spot, but keeping your \n// original concept in mind, which involved combining noise layers travelling in opposing\n// directions.\nfloat warpedNoise(vec2 p) {\n    \n    vec2 m = vec2(iTime, -iTime)*.5;//vec2(sin(iTime*0.5), cos(iTime*0.5));\n    float x = fractalNoise(p + m);\n    float y = fractalNoise(p + m.yx + x);\n    float z = fractalNoise(p - m - x + y);\n    return fractalNoise(p + vec2(x, y) + vec2(y, z) + vec2(z, x) + length(vec3(x, y, z))*0.25);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates. Using division by a scalar, namely \"iResolution.y,\" for aspect correctness.\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    // Take two noise function samples near one another.\n    float n = warpedNoise(uv * 6.);\n    float n2 = warpedNoise(uv * 6. + 0.02);\n    \n    // Highlighting - Effective, but not a substitute for bump mapping.\n    //\n    // Use a sample distance variation to produce some cheap and nasty highlighting. The process \n    // is vaguely related to directional derivative lighting, which in turn is mildly connected to \n    // Calculus from First Principles.\n    float bump = max(n2 - n, 0.)/.02*.7071;\n    float bump2 = max(n - n2, 0.)/.02*.7071;\n    \n    // Ramping the bump values up.\n    bump = bump*bump*.5 + pow(bump, 4.)*.5;\n    bump2 = bump2*bump2*.5 + pow(bump2, 4.)*.5;\n    \n    // Produce a color based on the original noise function, then add the highlights.\n\n    // Liquid glass, wax or ice, with sun glow?\n    //vec3 col = vec3(n*n)*(vec3(.25, .5, 1.)*bump*.2 + vec3(1., .4, .2)*bump2*.2 + .5);\n    // Fake jade.\n    //vec3 col = vec3(n*n*0.7, n, n*n*0.4)*n*n*(vec3(0.25, 0.5, 1.)*bump*.2 + vec3(1)*bump2*.2 + .75);\n    // Cheap fire palette.\n    //vec3 col = pow(vec3(1.5, 1, 1)*n, vec3(2, 5, 24))*.8 + vec3(0.25, 0.5, 1.)*(bump + bump2)*.05;\n    // Not sure. :)\n    vec3 col = n*n*(vec3(1, .7, .6)*vec3(bump, (bump + bump2)*.4, bump2)*.2 + .5);\n    // etc.\n        \n\tfragColor = vec4(sqrt(max(col, 0.)), 1.); // Rough gamma correction.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 364, 391, 391, 555], [557, 616, 644, 644, 1103], [1105, 1387, 1414, 1414, 1718], [1721, 1721, 1778, 1881, 3280]], "test": "untested"}
{"id": "3t2BDz", "name": "WoS approx. lighting with SDFs", "author": "toomuchvoltage", "description": "Walk-on-spheres approximate lighting with SDF luminares using Sawhney & Crane 2020 in http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf. It has bias but converges rather quickly.", "tags": ["volume", "lighting", "sampling", "direct", "approximate", "sdfs", "explicit", "wos", "walkonsphere"], "likes": 11, "viewed": 1062, "published": 3, "date": "1598712556", "time_retrieved": "2024-07-30T20:48:32.686367", "image_code": "/***********************************************************\n\n   I've been itching to try this out ever since I saw this: http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf\n   I know this is for geometry processing but I couldn't help myself... wanted to see how this would actually turn out in utility to direct lighting.\n   It has bias because we don't have the exact projected sampling area but converges rather quickly.\n   All your sdf and value noises are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvRaw = fragCoord/iResolution.xy;\n    vec4 fetchMC = texture(iChannel0, uvRaw);\n\tvec3 light = fetchMC.rgb/fetchMC.a;\n    light = max(light, 0.0);\n    light = light / (1.0 + light); // Reinhard\n    light = pow(light, vec3(1.0f/2.2)); // Gamma correction\n    fragColor = vec4 (light, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/***********************************************************\n\n   I've been itching to try this out ever since I saw this: http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf\n   I know this is for geometry processing but I couldn't help myself... wanted to see how this would actually turn out in utility to direct lighting.\n   It has bias because we don't have the exact projected sampling area but converges rather quickly.\n   All your sdf and value noises are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n\n#define DRAW_DISTANCE 100.0\n#define M_PI 3.1415926535\n\n#define BSDF_TRACING (uv.x > 0.0)\n#define EMISSIVITY vec3 (4.0)\n\n\n// *******************************************************\n// Change sceneLum(vec3 p) to try any of them out\n// They converge faster! though with bias. This is because we don't have the exact projected sampling area.\n// *******************************************************\n\nfloat sceneLumSphere (vec3 p) // Sphere\n{\n    return length(p) - 0.5;\n}\n\nfloat sceneLumBox (vec3 p) // Box\n{\n    vec3 q = abs(p) - vec3 (0.2);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sceneLumTorus (vec3 p) // Capped torus\n{\n    float ra = 1.0;\n    float rb = 0.1;\n    vec2 sc = vec2 (1.0, 0.025);\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sceneLumLink(vec3 p) // Link\n{\n    float le = 0.5;\n    float r1 = 0.5;\n    float r2 = 0.05;\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdOctahedron(vec3 p) // Octahedron\n{\n    float s = 0.5;\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n    if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n        else if( 3.0*p.z < m ) q = p.zxy;\n            else return m*0.57735027;\n\n            float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n        return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sceneLum(vec3 p)\n{\n    return sceneLumSphere (p); // <--- Change this to try different ones...\n}\n\n// *******************************************************\n// *******************************************************\n// *******************************************************\n\nfloat scene (vec3 p, out float mat)\n{\n    mat = 0.0;\n    float walls = p.y + 1.0;\n    walls = min (walls, -p.z + 1.0);\n    \n    float lamp = sceneLum(p);\n    \n    float sceneSDF = min (lamp, walls);\n    \n    if ( sceneSDF == lamp ) mat = 1.0;\n    else mat = 0.0;\n\n    return sceneSDF;\n}\n\nvec3 hash(vec3 p)  // replace this by something better\n{\n\tp = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n\tfloat xVal = -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n\tfloat yVal = -1.0+2.0*fract( p.x*p.z*(p.x+p.z) );\n\tfloat zVal = -1.0+2.0*fract( p.z*p.y*(p.z+p.y) );\n    return vec3(xVal, yVal, zVal);\n}\n\nvec3 randOnHemi (vec2 randVar, vec3 surfNorm)\n{\n    float phi = 2.0*M_PI*randVar.x;\n    float theta = acos (1.0 - randVar.y);\n    \n    vec3 tanVec = normalize (cross (surfNorm + vec3 (0.1), surfNorm));\n    vec3 biTanVec = cross (tanVec, surfNorm);\n    \n    vec3 x = sin(theta)*cos(phi)*tanVec;\n    vec3 y = sin(theta)*sin(phi)*biTanVec;\n    vec3 z = cos(theta)*surfNorm;\n    return normalize (x + y + z);\n}\n\nbool sphereMarchScene(vec3 startPt, vec3 dir, out vec3 hitPt, out vec3 hitNorm, out float hitMat)\n{\n    float i = 0.0;\n    float hitMatTmp;\n    vec3 samplePt = startPt;\n    for (i = 0.0; i != 120.0; i += 1.0)\n    {\n        float curDist = scene (samplePt, hitMat);\n        if ( curDist < 0.01 )\n        {\n            hitNorm.x = scene(samplePt + vec3(0.001, 0.0, 0.0), hitMatTmp) - scene(samplePt - vec3(0.001, 0.0, 0.0), hitMatTmp);\n            hitNorm.y = scene(samplePt + vec3(0.0, 0.001, 0.0), hitMatTmp) - scene(samplePt - vec3(0.0, 0.001, 0.0), hitMatTmp);\n            hitNorm.z = scene(samplePt + vec3(0.0, 0.0, 0.001), hitMatTmp) - scene(samplePt - vec3(0.0, 0.0, 0.001), hitMatTmp);\n            hitNorm = normalize (hitNorm);\n            hitPt = samplePt;\n            return true;\n        }\n        samplePt += curDist * dir;\n    }\n    return false;\n}\n\nbool wosLum(vec3 startPt, out vec3 hitPt, out vec3 hitNorm)\n{\n    float i = 0.0;\n    vec3 samplePt = startPt;\n    for (i = 0.0; i != 120.0; i += 1.0)\n    {\n        float curDist = sceneLum (samplePt);\n        if ( abs (curDist) < 0.01 )\n        {\n            hitNorm.x = sceneLum(samplePt + vec3(0.001, 0.0, 0.0)) - sceneLum(samplePt - vec3(0.001, 0.0, 0.0));\n            hitNorm.y = sceneLum(samplePt + vec3(0.0, 0.001, 0.0)) - sceneLum(samplePt - vec3(0.0, 0.001, 0.0));\n            hitNorm.z = sceneLum(samplePt + vec3(0.0, 0.0, 0.001)) - sceneLum(samplePt - vec3(0.0, 0.0, 0.001));\n            hitNorm = normalize (hitNorm);\n            hitPt = samplePt;\n            return true;\n        }\n        vec3 dir = normalize (textureLod (iChannel1, samplePt.xz * 3.0 + iTime * samplePt.zy * 3.0, 0.0).rgb * 2.0 - 1.0);\n        samplePt += curDist * dir;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvRaw = fragCoord/iResolution.xy;\n    vec2 uv = uvRaw * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n\tvec2 aa = textureLod(iChannel1, iTime * M_PI * uv, 0.0).rg * 2.0 - 1.0; // LDS jitter\n    aa *= 1.05;\n    uv += aa / iResolution.xy;\n    \n    vec4 mouseInfo = iMouse / iResolution.xxxx;\n    \n    vec3 curEye = vec3 (cos(mouseInfo.x * 2.0 - M_PI * 0.5), mouseInfo.y * 3.0, sin(mouseInfo.x * 2.0 - M_PI * 0.5)) * 2.0;\n    vec3 sampleLook = normalize (-curEye);\n    \n    vec3 side = cross (vec3 (0.0, -1.0, 0.0), sampleLook);\n    vec3 up = cross (side, sampleLook);\n    if ( dot (up, vec3 (0.0, 1.0, 0.0)) < 0.0 ) up = -up;\n    \n    const float drawDistSq = DRAW_DISTANCE*DRAW_DISTANCE;\n    vec3 sampleDir = normalize (sampleLook + side * uv.x + up * uv.y);\n    vec3 samplePt = curEye + sampleDir;\n\n    samplePt = curEye + sampleDir;\n    bool samplingLight = false;\n    vec3 hitNorm, hitNorm2;\n    vec3 hitPoint, hitPoint2;\n    float hitMat, hitMat2;\n    vec3 colorAccum = vec3 (0.0);\n\n    if ( sphereMarchScene (samplePt, sampleDir, hitPoint, hitNorm, hitMat) )\n    {\n        if ( hitMat == 1.0 )\n        {\n            colorAccum = EMISSIVITY;\n        }\n        else\n        {\n            if ( BSDF_TRACING )\n            {\n                vec2 randVar = (hash (hitPoint * 3.0 + vec3(iTime * 3.0)).xz + hash (hitPoint * 3.0 + vec3(iTime * 3.0)).yx + vec2 (1.0)) * 0.5;\n                sampleDir = randOnHemi (randVar, hitNorm);\n                hitPoint += hitNorm * 0.01;\n                if ( sphereMarchScene (hitPoint, sampleDir, hitPoint2, hitNorm2, hitMat2) && hitMat2 == 1.0 )\n                {\n                    colorAccum = 2.0 * max (dot (hitNorm, sampleDir), 0.0) * EMISSIVITY;\n                }\n            }\n            else\n            {\n                if ( wosLum (hitPoint, hitPoint2, hitNorm2) )\n                {\n                    vec3 lightSegment = hitPoint2 - hitPoint;\n                    vec3 Lo = normalize (lightSegment);\n                    float NddotLo = abs (dot (hitNorm, Lo));\n                    float LidotNl = abs (dot (hitNorm2, -Lo));\n                    float distSq = dot (lightSegment, lightSegment);\n                    float GeomTerm = (NddotLo * LidotNl) / distSq;\n                    colorAccum = GeomTerm * 0.75 * EMISSIVITY; // We don't have |A| so just make stuff up...\n                }\n            }\n        }\n    }\n\n    vec4 bufA = texture(iChannel0, uvRaw);\n    if ( mouseInfo.z > 0.0 )\n        bufA = vec4 (colorAccum, 1.0);\n    else\n        bufA += vec4 (colorAccum, 1.0);\n    fragColor = bufA;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2BDz.jpg", "access": "api", "license": "mit", "functions": [[2000, 2000, 2057, 2057, 2353]], "test": "untested"}
{"id": "WljfDz", "name": "Buggy pulsating galaxy", "author": "mrange", "description": "License CC0: Buggy pulsating galaxy\nRandom coding led to a nice (IMO) pulsating galaxy", "tags": ["2d", "fbm"], "likes": 9, "viewed": 506, "published": 3, "date": "1598700360", "time_retrieved": "2024-07-30T20:48:33.477252", "image_code": "// License CC0: Buggy pulsating galaxy\n// Random coding led to a nice (IMO) pulsating galaxy\n    \n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat noise1(vec2 p, vec2 o) {\n  float s = 1.0;\n\n  float a = cos(p.x);\n  float b = cos(p.y);\n\n  float c = cos((p.x+o.x)*sqrt(3.5));\n  float d = cos((p.y+o.y)*sqrt(1.5));\n\n  return a*b*c*d;\n}\n\nfloat galaxy(vec2 p, float a, float z) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*3.0 + a;\n  p = toRect(pp);\n  \n  p *= z;\n  \n  return noise1(p, -0.5*vec2(0.123, 0.213)*TIME);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat height(vec2 p, float m) {\n  float s = 0.0;\n  float a = 1.0;\n  float f = mix(0.0, 15.0, 1.0);\n  float d = 0.0;\n  rot(p, 0.075*TIME);\n  for (int i = 0; i < 3; ++i) {\n    float g = a*galaxy(p, 0.15*float(i) + -TIME*( + 0.1*float(i)), 0.9*f);\n    s += g;\n    a *= pmax(abs(s), 0.125, 0.25);\n    f *= pmax(abs(s), 0.250, 3.);\n    d += a;\n  }\n  \n  float h = (0.5 + 0.5*(s/d));\n  \n  h *= exp(-2.5*dot(p,p));\n  h += 0.25*pow(m, 15.0);\n  h *= 1.25*m;\n  \n  return h;\n}\n\nvec3 normal(vec2 p, float m) {\n  vec2 eps = vec2(4.0/RESOLUTION.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy, m) - height(p + eps.xy, m);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx, m) - height(p + eps.yx, m);\n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n \n  vec2 pp = toPolar(p);\n  float an = pp.y;\n  float r2 = pp.x*pp.x;\n \n  float a = PI*r2-TIME+0.125*sin(20.0*an-TIME);\n \n  float m = mix(0.5, 1.0, psin(a))*exp(-0.025*r2);\n  float h = height(p, m);\n  float th = tanh(h);\n  vec3 n = normal(p, m);\n\n  vec3 lp1 = vec3(-2.0, 0.5, 2.0);\n  vec3 lp2 = vec3(2.0, 0.5, 2.0);\n  float hh = h;\n  vec3 ld1 = normalize(lp1 - vec3(p.x, hh, p.y));\n  vec3 ld2 = normalize(lp2 - vec3(p.x, hh, p.y));\n\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n\n  vec3 baseCol = hsv2rgb(vec3(psin(0.25*a), mix(0.25, 0.5, psin(1.25*a)), mix(0.5, 1.5, psin(0.25*a))));\n\n  vec3 col = +vec3(0.0);\n  col += baseCol*h;\n  col -= 0.5*baseCol.zyx*pow(diff1, 10.0);\n  col -= 0.25*baseCol.yzx*pow(diff2, 5.0);\n  col += sqrt(baseCol)*pow(tanh(2.0*h), 1.0);\n\n  col = postProcess(col, q);\n  col = clamp(1.0 - col, 0.0, 1.0);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljfDz.jpg", "access": "api", "license": "cc0-1.0", "functions": [[218, 218, 240, 240, 284], [286, 286, 307, 307, 348], [350, 350, 383, 383, 468], [470, 470, 500, 500, 660], [662, 662, 702, 702, 836], [838, 838, 859, 859, 888], [890, 890, 929, 929, 1018], [1020, 1020, 1059, 1059, 1088], [1090, 1090, 1121, 1121, 1554], [1556, 1556, 1586, 1586, 1801], [1803, 1803, 1840, 1840, 2048], [2050, 2050, 2072, 2072, 2241], [2243, 2243, 2298, 2298, 3288]], "test": "untested"}
{"id": "Wt2fDR", "name": "Dune world", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wtjczh]surreal space caverns.[/url]\nUse the mouse to look around.", "tags": ["terrain", "planet", "landscape", "mountains", "desert", "dune"], "likes": 5, "viewed": 519, "published": 3, "date": "1598670875", "time_retrieved": "2024-07-30T20:48:34.275119", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON/8.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS/8; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(depth+1.0)) {\n\t\t\tif(iters < 2){\n                iters += 1;\n                eps *= 2.0;\n            }\n            else\n            return depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 10.0;\n    float t1 = iTime/2.0+10.0;\n\tvec3 eye = vec3(100.0*t1,-10,0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(surface_color((worldDir+iTime/50.0)*10.0).zxy, 0.0);\n\t\t//fragColor /= 8.0;\n        return;\n    }\n    \n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    //distance fog\n    //vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye)/(vec3(dist)+50.0)*100.0;\n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 2000.0);\n    //t = t%20000;\n    t = (t>>8|t*(-(t/2)%120)&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 sound(float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n    \tresult += sound1(time*factor)/(factor);\n        factor *= 1.1;\n    }\n    return result;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    return sound(time);\n}", "sound_inputs": [], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON/8.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (abs(dist) < eps*(depth+1.0)*2.0) {\n\t\t\tif(iters < 2){\n                iters += 1;\n                eps *= 2.0;\n            }\n            else\n            return depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n            viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n        }\n    \n    float speed = 10.0;\n    float t1 = iTime/2.0+10.0;\n\tvec3 eye = vec3(100.0*t1,-10,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = length(eye-dmap); //distance to point in last frame\n\n    float l1 = texture(iChannel0, vec2((fragCoord.x), (fragCoord.y))).w; //distance between points in consecutive frames\n    \n    float l2;\n    //if(l1 >= 1.0){ //how much does the depth change between frames?\n    //    l2 = max(log(l0)*2.0,0.0);\n    //}\n    //else{\n        l2 = pow(l0,.9);\n    //}\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l2, MAX_DIST);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    fragColor = vec4(p, (dist-l0));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.02;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec3 warp(vec3 a){\n    return (sin(a)+cos(a));\n}\n\nfloat planet_surface(vec3 p){\n    p /= 10.0;\n    //p /= 100.0;\n    p += warp(p.yzx/500.0)*500.0;\n    vec3 p1 = p/size;\n    p = (sin(p1.yzx+(length(sin(p/100.0))+sin(p1.yxz))))*size;\n    return length(p) + p.y - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,int iters) {\n    p /= scale;\n\n\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 2; k++){\n        if(k >= iters) break;\n        result += planet_surface(p*i)/(i*i);\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return (result-p.y*2.0)*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n    return sceneSDF(p,2);\n}\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*1000.0;\n    return sin(vec3(sceneSDF(p)*2.0+.5,sceneSDF(p)*2.0,sceneSDF(p*10.0)*2.0))/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2fDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 482, 573, 573, 1101], [1103, 1103, 1130, 1130, 1279], [1281, 1281, 1338, 1338, 2249]], "test": "untested"}
{"id": "Wt2BDR", "name": "zh6", "author": "lennyjpg", "description": "z", "tags": ["2d", "flat", "grid", "triangles", "flag", "blue", "pattern", "exp"], "likes": 2, "viewed": 256, "published": 3, "date": "1598665302", "time_retrieved": "2024-07-30T20:48:35.144794", "image_code": "void mainImage( out vec4 O, in vec2 f )\n{\n    vec2 uv = f / iResolution.x;\n    float t = iTime * 0.1;\n    //uv.x +=0.5;\n    //uv.x+=t;\n    float yy = exp(uv.y * 6.),\n        k = floor(yy)*2.0,\n        x = fract(uv.x*k*3.0);\n    vec2 u = vec2(x, fract(yy));\n    \n    u.y = abs(u.y-0.5);\n\n    float b = u.x + u.y*2.0,\n        a = uv.y * .1,\n        d = smoothstep(b + a , b - a, 1.);\n    vec3 blue = vec3(0., 120., 191.) / 255.;\n    O = vec4(mix(blue, vec3(1.), d),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2BDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 469]], "test": "untested"}
{"id": "3ljBDR", "name": "zh5", "author": "lennyjpg", "description": "z", "tags": ["2d", "flat", "grid", "triangles", "flag", "blue", "pattern", "exp"], "likes": 2, "viewed": 247, "published": 3, "date": "1598663995", "time_retrieved": "2024-07-30T20:48:35.959615", "image_code": "// Fork of \"zh4\" by lennyjpg. https://shadertoy.com/view/ttSfDz\n// 2020-08-29 00:50:19\n\nvoid mainImage( out vec4 O, in vec2 f )\n{\n    vec2 uv = f / iResolution.x;\n    float t = iTime * 0.1;\n    //uv.x +=0.5;\n    //uv.x+=t;\n    float yy = exp(uv.y * 5.),\n        k = floor(yy)*2.0,\n        x = fract(uv.x*k*2.0);\n    vec2 u = vec2(x, fract(yy));\n\n    float b = u.x + u.y,\n        a = uv.y * .1,\n        d = smoothstep(b + a , b - a, 1.);\n    vec3 blue = vec3(0., 120., 191.) / 255.;\n    O = vec4(mix(blue, vec3(1.), d),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 129, 129, 524]], "test": "untested"}
{"id": "3ljfWR", "name": "Refracting blob z", "author": "illus0r", "description": "Refracting blob z", "tags": ["refraction", "reymarching"], "likes": 1, "viewed": 296, "published": 3, "date": "1598659799", "time_retrieved": "2024-07-30T20:48:36.731551", "image_code": "#define textureCube texture\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define iTime (iTime / 3.1)\n\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h); }\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    float spheres = length(p) - 1.5;\n\n    // p = mod(p, 1.);\n    // p -= 0.5;\n    // float spheres = length(p) - .4;\n\n    for(int i = 0; i < 4; i++) {\n        vec3 ps = p;\n        // ps *= 2.;\n        ps += vec3( 1. * sin(iTime * 1.5 + 10. * float(i)), \n                    1. * sin(iTime * 2.5 + 10. * float(i) + 10.), \n                    1. * sin(iTime * 3.5 + 10. * float(i) + 2.) );\n        spheres = opSmoothUnion(spheres, length(ps) - .5, 1.5);\n    }\n    for(int i = 0; i < 4; i++) {\n        vec3 ps = p;\n        // ps *= 2.;\n        ps += vec3( 1. * sin(iTime * 1.7 + 20. * float(i)), \n                    1. * sin(iTime * 2.3 + 20. * float(i) + 10.), \n                    1. * sin(iTime * 3.1 + 20. * float(i) + 2.) );\n        spheres = opSmoothSubtraction(spheres, length(ps) - .5, 1.5);\n    }\n  return vec2(spheres, BLUE);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float minAngleToObstacle = 1e10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, minAngleToObstacle);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\n\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // ray origin\n    vec3 ro = vec3(4. * sin(iTime * .2), 0, 4. * cos(iTime * .2));\n    ro.xz *= Rot(iMouse.x / iResolution.x * PI * 2.);\n    float zoom = 1.100;\n\n    // ray direction\n    vec3 rd = getRayDir(uv, ro, vec3(0), 1.);\n\n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n\n    vec3 colorBg = vec3(.0);\n    vec3 color = textureCube(iChannel0, rd).xyz;\n    vec3 light = vec3(50, 20, 50);\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \tcolor = vec3( n * 0.5 + 0.5 );\n\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        // color = vec3(0. + .1 * dot(n, normalize(light - p)));\n        // drop shadows\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color *=  0.;\n        // }\n\n        // smooth shadows\n        // float shadow = smoothstep(0.0, .15, rayMarchLight.z / PI);\n        // color += .1 + .9 * shadow;\n\n        // reflection\n        // vec3 ref = reflect(rd, n);\n        // hiding sides of reflection on round\n        //color += 1. * smoothstep(.8, 1., dot(rd, ref));//pow(1. + clamp(dot(rd, ref), -1., 0.), .5);\n\n        // refraction\n        float e = 0.2;\n        for (int i = 0; i < 2; i++) {\n            rd = refract(rd, n, 1. - e);\n            // rd = reflect(rd, n);\n            ro = p + rd * 0.05;\n            rm = rayMarch(ro, rd);\n            d = rm[0];\n            if (d > MAX_DIST) break;\n            p = ro + rd * d;\n            n = getNormal(p);\n\n            rd = refract(rd, -n, 1. + e);\n            // rd = reflect(rd, n);\n            ro = p + rd * 0.05;\n            rm = rayMarch(ro, rd);\n            d = rm[0];\n            if (d > MAX_DIST) break;\n            p = ro + rd * d;\n            n = getNormal(p);\n        }\n        color *= textureCube(iChannel0, rd).xyz;\n\n        // // reflection\n        // for (int i = 0; i < 2; i++) {\n        //     rd = reflect(rd, n);\n        //     ro = p + rd * 0.05;\n        //     rm = rayMarch(ro, rd);\n        //     d = rm[0];\n        //     if (d > MAX_DIST) break;\n        //     p = ro + rd * d;\n        //     n = getNormal(p);\n\n        //     rd = reflect(rd, n);\n        //     ro = p + rd * 0.05;\n        //     rm = rayMarch(ro, rd);\n        //     d = rm[0];\n        //     if (d > MAX_DIST) break;\n        //     p = ro + rd * d;\n        //     n = getNormal(p);\n        // }\n        // color = mix(textureCube(iChannel0, rd).xyz, color, 0.5);\n\n        //rm = rayMarch(p + ref * 0.1, ref);\n        // color = vec3(d);\n\n\n\n        // tex *= color_bw;\n        // color = tex;\n    }\n    // color += 0.6 + vec3( color_bw );\n    // // coloring\n    // if (info == IVORY) {\n    //     color *= vec3(0.332,0.400,0.349);\n    // }\n    // else if (info == BLUE) {\n    //     color *= vec3(0.810,0.256,0.397);\n    // }\n    // else if (info == BLACK) {\n    //     color *= vec3(0.130,0.130,0.130);\n    // }\n    //color = mix(color, colorBg, smoothstep(20., 28., d));\n\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 233, 252, 252, 315], [317, 317, 348, 348, 435], [437, 437, 489, 489, 588], [590, 590, 648, 648, 748], [750, 829, 851, 851, 1687], [1770, 1770, 1803, 1803, 2277], [2279, 2279, 2303, 2303, 2521], [2525, 2525, 2579, 2579, 2806], [2808, 2808, 2858, 2858, 3049], [3052, 3052, 3108, 3108, 6576]], "test": "untested"}
{"id": "ttSfDz", "name": "zh4", "author": "lennyjpg", "description": "z", "tags": ["2d", "flat", "grid", "triangles", "flag", "blue", "pattern", "exp"], "likes": 1, "viewed": 244, "published": 3, "date": "1598659351", "time_retrieved": "2024-07-30T20:48:37.490522", "image_code": "void mainImage( out vec4 O, in vec2 f )\n{\n    vec2 uv = f / iResolution.x;\n    float t = iTime * 0.1;\n    //uv.x +=0.5;\n    //uv.x+=t;\n    float yy = exp(uv.y * 5.),\n        k = floor(yy),\n        x = fract(uv.x*k);\n    vec2 u = vec2(x, fract(yy));\n\n    float b = u.x + u.y,\n        a = uv.y * .1,\n        d = smoothstep(b + a , b - a, 1.);\n    vec3 blue = vec3(0., 120., 191.) / 255.;\n    O = vec4(mix(blue, vec3(1.), d),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 428]], "test": "untested"}
{"id": "tlBfWz", "name": "simpleGlow", "author": "brunodev09", "description": "Just a simple glow", "tags": ["glow"], "likes": 3, "viewed": 288, "published": 3, "date": "1598647350", "time_retrieved": "2024-07-30T20:48:38.324293", "image_code": "float generateCircle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv - p);\n    return smoothstep(r, r-blur, d);\n\t\n}\n\nvec2 repositionOriginToCenter(vec2 fragCoord) {\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\tuv -= vec2(1, 0.5);\n    return uv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = repositionOriginToCenter(fragCoord);\n    \n    vec3 originalMask = vec3(generateCircle(uv, vec2(-0.5 * sin(iTime), 0.5 * cos(iTime)), 0.3, 0.5));\n    vec3 mask2 = vec3(generateCircle(uv, vec2(-0.2 * sin(iTime), -0.6 * cos(iTime)), 0.3, 0.4));\n    vec3 mask3 = vec3(generateCircle(uv, vec2(-0.2 * -0.5*cos(iTime), -0.0 * sin(iTime * 2.0)), 0.3, 0.4));\n    vec3 mask4 = vec3(generateCircle(uv, vec2(-0.2 * sin(iTime), -0.5 * sin(iTime * 2.0)), 0.5 * cos(iTime), 0.4));\n    \n    vec3 colorBlend = vec3(0.0, 0.0, 1.0) * originalMask;\n    colorBlend += vec3(1.0, 0.0, -1.0) * mask2;\n    colorBlend += vec3(0.0, 1.0, 0.0) * mask3;\n    colorBlend += vec3(1.0, 1.0, 0.0) * mask4;\n    \n   \n    fragColor = vec4(colorBlend, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 60, 131], [133, 133, 180, 180, 305], [308, 308, 365, 365, 1101]], "test": "untested"}
{"id": "wtSfDR", "name": "Polar Weave Pattern - simple 3", "author": "FabriceNeyret2", "description": "asymmetrical variant\ngolfed variant of [url]https://shadertoy.com/view/wtBfRm[/url]\nreproducing another way the base pattern of [url]https://www.shadertoy.com/view/3ljfR1[/url]\n\n- s: change s = 2Pi / N by any N you like\n- D: without final .5 is nice too", "tags": ["2d", "repetition", "pattern", "polar", "short", "weave"], "likes": 6, "viewed": 304, "published": 3, "date": "1598642211", "time_retrieved": "2024-07-30T20:48:39.072293", "image_code": "// Variant of https://shadertoy.com/view/3l2fzw\n// Golfed variant of https://shadertoy.com/view/wtBfRm\n// Reproducing another way the base pattern of https://www.shadertoy.com/view/3ljfR1\n\n#define D(S) ( v = l * cos(a-s/2.) / cos(s/2.) -1.,             \\\n               m = r*abs(  sin(s/2.)                            \\\n                          - sqrt( l*l + 1. - 2.*l* cos( S v > 0. ? a-s : a ) ) \\\n                          - (.25*sin(iTime)-.05)*sign(v) ) -.07,\\\n               m = clamp(1.- R.y/4.* m, 0.,1.),                 \\\n               m * ( .2+fract(S A/s) ) )                       //\n            /* m * fract(S.5*A/s) )      */                    //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = u+u - R;\n    float s = 6.28 / 7., r = .5, m, T, v,\n          A = atan(U.y,U.x) + iTime/2.,\n          a = mod(A,s),\n          l = length(U) / R.y / r;\n    O += D( );  T = 1.-m;\n    O += D(-) * T;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSfDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ttSBWR", "name": "aie", "author": "kloumpt", "description": "ah", "tags": ["ui"], "likes": 3, "viewed": 337, "published": 3, "date": "1598641988", "time_retrieved": "2024-07-30T20:48:39.914042", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec3 col = texture(iChannel0, uv).rgb;\n    //col = 1.0 - col;\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.141592\n\nfloat scene(vec2 p, float t) {\n    \n    vec2 p_pol = vec2(length(p), atan(p.y, p.x));\n    p_pol.y *= 7.0;\n    \n    p_pol.y += iTime;\n    p_pol.x = 1.0 - abs(fract(p_pol.x - t / -4.0) * 6.0 - 1.0);\n    //p_pol.x -= 1000.0;\n    \n    //p = p_pol.x * vec2(cos(p_pol.y), sin(p_pol.y));\n    \n    p = p_pol.x * vec2(cos(p_pol.y), sin(p_pol.y));\n \tfloat val = 1000.0;\n    val = min(val, length(p - vec2(0.0, 1.0)) - 0.9);\n    val = min(val, length(p - vec2(cos(t * PI), sin(t * PI))) - 0.31312);\n    \n    \n    return val;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float t =  60.0 * iChannelTime[3] / 60.0;\n\tvec2 p = (uv * 2.0 - 1.0) * iResolution.xy / iResolution.yy;\n    \n    \n    vec3 val = vec3(\n        scene(p, t - 1.0 * abs(fract(t / 16.0) * 2.0 - 1.0)),\n        scene(p, t),\n        scene(p, t + 1.0 * abs(fract(t / 2.0) * 2.0 - 1.0))\n    );\n    \n    vec3 color_bb = texture(iChannel0, uv.xy - 4.0 * normalize(p) / iResolution.xy).rgb;\n    vec3 color_vd = texture(iChannel1, uv.xy).rgb;\n    vec3 color_mask = textureLod(iChannel2, uv.xy, 1.0).rgb;\n    \n    vec3 color = vec3(1.0, 1.0, 1.0);\n    \n    \n    \n    color *= smoothstep(0.0, 0.2, abs(fract(val / 16.0 - t / 2.0) * 2.0 - 1.0));\n    \n    color *= abs(fract(val / 2.0) * 2.0 - 1.0);\n    \n\n    color = mix(color, color_bb * mix(color_vd + 0.5, vec3(0.5, 1.0, 0.0), 0.5), 1.0 - smoothstep(-0.10, 0.3, color_vd.g- color_vd.r));\n    color = mix(color, color_bb, smoothstep(0.9, 1.0, length(color)));\n    \n    color = mix(color, vec3(cos(t * PI), sin(t * PI), cos(t * 2.0 * PI)), step(0.01, color_mask.r));\n    \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23816, "src": "https://soundcloud.com/sundown4soul/owane-love-juice", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec3 col = texture(iChannel0, uv).rgb;\n    //col = 1.0 - col;\n\n    fragColor = vec4(col, 1.0);\n}\n", "buffer_b_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color_vd = texture(iChannel0, uv.xy).rgb;\n    \n    float val = smoothstep(0.25, 0.3, 1.0 - smoothstep(color_vd.g - 0.125, color_vd.g, color_vd.r - color_vd.b + 0.7));\n    \n    fragColor = vec4(vec3(val), 1.0 );\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSBWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 199]], "test": "untested"}
{"id": "3ljfzm", "name": "BC: Shifting Coordinates", "author": "BackwardsCap", "description": "Shifting coordinates\n\nInspired by this tweet: https://twitter.com/KangarooPhysics/status/1299049072771371010", "tags": ["warping"], "likes": 3, "viewed": 287, "published": 3, "date": "1598630586", "time_retrieved": "2024-07-30T20:48:40.732853", "image_code": "#define CLEAN\n#define S 2.\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 R = iResolution.xy, p = (2.*f-R)/R.y*20.0;\n    vec2 d=iTime/S*floor(p.yx);\n    #ifdef CLEAN\n        bool b=mod(iTime,S*2.)-S>0.;\n        d*=vec2(!b,b);\n    #endif\n    c.rgb = vec3(pow(1.0-length(fract(p+d)-.5),10.*f.x/R.x));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 69, 69, 305]], "test": "untested"}
{"id": "3l2Bzw", "name": "2020 - 🤮 Revision", "author": "PixelPhil", "description": "So yeah... I made a shader on new year's eve 2020 and I think it deserved a small revision.", "tags": ["fire", "corona", "hell", "2020"], "likes": 19, "viewed": 589, "published": 3, "date": "1598614168", "time_retrieved": "2024-07-30T20:48:41.586570", "image_code": "//\n// 2020 - 🤮 Revision; by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// Note: This shader is a fairly standard 2D composition with two layers. The digits\n// are produced with bespoke signed distance functions (the fact that 2020 has only two diferent\n// digits made the process easier).\n//\n\n\n#define S(a,b,c) smoothstep(a,b,c)\n\n// outputs a colored shape with a black border from distance field (RGBA premultiplied)\nvec4 border(vec3 color, float dist)\n{\n    vec4 res;\n    \n    float aa = 30. / iResolution.x;\n    \n    res.a = S(0.25 + aa, 0.25, dist); \n    res.rgb = color *  S(0.2, 0.2 - aa, dist); \n    \n    return res;\n}\n\n// Blend a premultiplied rbga color onto rgb\nvec3 premulBlend(vec4 src, vec3 dst)\n{\n    return dst * (1.0 - src.a) + src.rgb;\n}\n\n// Blend a premultiplied rbga color onto rgba (accurate alpha handling)\nvec4 premulBlend(vec4 src, vec4 dst)\n{\n    vec4 res;\n    res.rgb = dst.rgb * (1.0 - src.a) + src.rgb;\n    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a); \n    \n    return res;\n}\n\n\n// Distance field to the digit 0\nfloat zeroDst(vec2 uv)\n{\n    float dist;\n    \n    uv.y -= 0.5;\n    \n    if (uv.y > 0.0) // upper part\n    {\n        uv.y = pow(uv.y, 1.8);\n    \tdist = length(uv);\n    }\n    else if (uv.y > -1.1) // middle part\n    {\n        dist = abs(uv.x);\n    }\n    else  // lower part\n    {\n        uv.y += 1.1;\n        uv.y = pow(-uv.y, 1.8);\n    \tdist = length(uv);\n    }\n    \n    return (abs(dist - 0.725) - 0.275);\n}\n\n// a box distance function\nfloat box(vec2 p, vec2 b )\n{\n\tvec2 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// Distance field to the digit 2\nfloat twoDst(vec2 uv)\n{\n    uv.y -= 0.5;\n    \n    float topBar = box((uv + vec2(0.725, 0.0)) * vec2(1.0, 1.4), vec2(0.275, 0.0));\n    \n    if (uv.y > 0.0) // Top 'curve'\n    {\n        uv.y = pow(uv.y, 1.8);\n    \tfloat dist = length(uv);\n        return max(-topBar, (abs(dist - 0.725) - 0.275));\n    }\n    else\n    {\n        float bottomBar = box((uv + vec2(0.0, 1.83)) * vec2(1.0, 1.4), vec2(0.95, 0.299));\n        \n        float two = min(topBar, bottomBar);\n        \n        if (uv.y > -1.8)\n        {    \n            float curve = (cos(uv.y * 2.0) - 1.0) * 0.7;\n            float x = 0.0 + uv.x - curve;\n            float mid = abs(uv.y + 0.4) * 0.7;\n            float x2 = 0.0 + uv.x - curve - mid * mid * 0.15 + 0.01;\n         \n            two = min(two, max(-x + 0.45, x2 -1.0));\n        }\n    \treturn two;\n    }\n\n}\n\n\n// Coordinate transform from global uv space to charcter space with poition and rotation\nvec2 letterUVs(vec2 uv, vec2 pos, float angle)\n{\n    float c = sin(angle);\n    float s = cos(angle);\n    float sc = 1.35;\n    uv -= pos;\n    return uv.x * vec2(s * sc, c) + uv.y * vec2(-c * sc, s);\n}\n\n\n// Borrowed from BigWIngs (random 1 -> 4)\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 104., 145., 24.))*vec4(657., 345., 879., 154.));\n}\n\n\n// Compute a randomized Bokeh spot inside a grid cell\nfloat embersSpot(vec2 uv, vec2 id, float decimation)\n{\n    float accum = 0.0;\n    \n    for (float x = -1.0; x <= 1.0; x += 1.0)\n    {\n        for (float y = -1.0; y <= 1.0; y += 1.0)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 cellId = id + offset;\n            vec4 rnd = N14(mod(cellId.x, 300.0) * 25.3 + mod(cellId.y, 300.0) * 6.67);\n    \n            vec2 cellUV = uv - offset + rnd.yz * 1.0;\n\n            float dst = length(cellUV);\n\n            //float radSeed = sin(iTime * 0.02 + rnd.x * 40.0);\n            //float rad =  (abs(radSeed) - decimation) / (1.0 - decimation);\n            \n      \t\tfloat rad = rnd.y * 0.5;\n\n            float intensity = S(rad, rad - 0.8, dst);\n            \n            accum += intensity;\n        }\n    }\n    \n    return accum;\n}\n\n// Computes a random layer of embers spots\nfloat emberLayer(vec2 uv, float decimation)\n{\n    vec2 id = floor(uv);\n    vec2 cellUV = (uv - id) - vec2(0.5, 0.5) ;\n\n    float intensity = embersSpot(cellUV, id, decimation);\n    \n    return intensity;\n}\n\n\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// https://iquilezles.org/articles/voronoise\nfloat VoroNoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0 + 63.0*pow(1.0-v,4.0);\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = hash3( p + g )*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += w*o.z;\n        wt += w;\n    }\n\n    return va/wt;\n}\n\n\n// Computes the fire background\nvec3 fire(vec2 uv)\n{\n    uv.x += sin(uv.y * 0.3 + iTime * 0.5)  + sin(uv.y * 0.8 + iTime * 1.23) * 0.25 - uv.y * 0.5;\n    \n    //accumulates several layers of bokeh\n    float fire = VoroNoise(uv * vec2(1.0, 0.3) - vec2(0.0, iTime), 0.0, 1.0) * 0.8;// * 0.2;\n    fire += VoroNoise(uv  * vec2(2.3, 1.68) - vec2(0.0, iTime * 3.0), 0.0, 1.0) * 0.5;\n    fire += VoroNoise(uv * vec2(4.3, 3.3) - vec2(0.0, iTime * 6.0), 0.0, 1.0) * 0.1;\n \n    \n    fire -= emberLayer(uv * vec2(1.0, 0.7) * 1.6 - vec2(0.0, iTime) , 1.0) * 0.5;\n    fire -= emberLayer(uv * vec2(1.0, 0.7) * 3.3 - vec2(0.0, iTime) , 1.0) * 0.25;\n    \n    //return vec3(fire);\n    \n    vec3 col = mix(vec3(2.0, 0.90, 0.55),  vec3(0.1, 0.0, 0.0), min(1.0, uv.y * 0.3 + fire));\n    \n    \n    return col;\n}\n\n\n\nfloat shadowsIntensity = 0.74;\nfloat shadowRadius = 1.1;\n\n\n\nvec3 reflection(vec3 normal, vec2 uv)\n{\n    uv.x = -uv.x;\n    uv += normal.xz * 3.0;\n    return fire(uv);\n}\n\n\nfloat flatPart = -0.06;\nfloat bevel = 0.065;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n\n\n// Character two with outline and shadow (premultiplied RGBA)\nvec4 twoCol(vec2 uvIn, vec3 col, vec2 pos, float angle)\n{\n    vec2 uv = letterUVs(uvIn, pos, angle);\n    \n    float dst = twoDst(uv);\n    float dstR = smax(flatPart, twoDst(letterUVs(uvIn + vec2(0.05, 0.0), pos, angle)), bevel);\n    float dstU =  smax(flatPart, twoDst(letterUVs(uvIn + vec2(0.0, 0.05), pos, angle)), bevel);\n    \n    float clampedDst = smax(flatPart, dst, bevel);\n    vec3 n = normalize(vec3(dstR - clampedDst, 0.01, dstU - clampedDst));\n    \n    //col = n * 0.5 + vec3(0.5); \n    col *= 0.4;\n    \n    col += reflection(n, uvIn) * 0.8;\n    \n    vec4 res = border(col, dst);\n    \n   \n    \n    uv.y += 0.14;\n    res.a = min(res.a +  S(shadowRadius, -1.0, twoDst(uv)) * shadowsIntensity, 1.0);\n    \n    return res;\n}\n\n\n\n\n// Character zero with outline and shadow (premultiplied RGBA)\nvec4 zeroCol(vec2 uvIn, vec3 col, vec2 pos, float angle)\n{\n    //uv = letterUVs(uv, pos, angle);\n    \n    \n    vec2 uv = letterUVs(uvIn, pos, angle);\n    \n    float dst = zeroDst(uv);\n    float dstR = smax(flatPart, zeroDst(letterUVs(uvIn + vec2(0.05, 0.0), pos, angle)), bevel);\n    float dstU =  smax(flatPart, zeroDst(letterUVs(uvIn + vec2(0.0, 0.05), pos, angle)), bevel);\n    \n    float clampedDst = smax(flatPart, dst, 0.01);\n    vec3 n = normalize(vec3(dstR - clampedDst, bevel, dstU - clampedDst));\n    \n   \n        //col = n * 0.5 + vec3(0.5); \n    col *= 0.4;\n    \n    if (dst < 0.21)\n    {   \n   \t col += reflection(n, uvIn) * 0.8;\n    }\n    \n    vec4 res = border(col, zeroDst(uv));\n    \n    \n    uv.y += 0.14;\n    res.a = min(res.a +  S(shadowRadius, -1.0, zeroDst(uv)) * shadowsIntensity, 1.0);\n    \n    return res;\n}\n\n\nvec3 red = vec3(0.9, 0.01, 0.16);\nvec3 yellow = vec3(0.96, 0.70, 0.19); // 248, 181, 51\nvec3 green = vec3(0.00, 0.63, 0.34);  //1, 162, 88\nvec3 blue = vec3(0.01, 0.57, 0.76);   //5, 142, 197\n\n// 2020 with colors and shadows (premultiplied rgba)\nvec4 yearCol(vec2 uv)\n{\n    float angle = sin(iTime) * 0.3;\n    \n    vec4 date = twoCol(uv, green, vec2(-2.5, 0.0), angle);\n    date = premulBlend(zeroCol(uv, green, vec2(-0.8, 0.0), angle), date);\n    date = premulBlend(twoCol(uv, green, vec2(0.8, 0.0), angle), date);\n    date = premulBlend(zeroCol(uv, green, vec2(2.5, 0.0), angle), date);\n    \n    return  date;\n}\n\n\n\nfloat corona(vec2 uv, float blur)\n{\n      \n    float angle = atan(-uv.x, -uv.y) / 6.2831 + 0.5;\n    \n    float copies = 9.0;\n    //float step = (1.0 / copies);\n    float quarter = floor(angle * copies + 0.5);\n    \n    float rot = -quarter * 6.2831 / copies;\n    \n    float s = sin(rot);\n    float c = cos(rot);\n    \n    uv *= mat2(c, s, -s, c);\n    \n    float dst = length(uv) - 0.4;\n    \n    \n    float dst2 = length((uv - vec2(0.0, 0.63)) * vec2(1.0, 1.2)) - 0.13;\n    \n    if (uv.y < 0.63)\n    {\n        dst = min(dst, abs(uv.x) - 0.06);// + 0.1, 0.1);\n    }\n    \n    dst = smin(dst, dst2, 0.1);\n    \n    return S(-0.01 - blur, 0.01 + blur , dst);\n}\n\n\n// Compute a randomized Bokeh spot inside a grid cell\nfloat coronaSpot(vec2 uv, vec2 id)\n{\n    float accum = 1.0;\n    \n    for (float x = -1.0; x <= 1.0; x += 1.0)\n    {\n        for (float y = -1.0; y <= 1.0; y += 1.0)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 cellId = id + offset;\n            vec4 rnd = N14(mod(cellId.x, 300.0) * 25.3 + mod(cellId.y, 300.0) * 6.67);\n    \n            float t = iTime;\n            \n            vec2 cellUV = uv - offset + rnd.yz * 1.0 + vec2(sin(t * (rnd.x + 0.3)), cos(t * (rnd.z + 0.2))) * 0.2;\n\n            \n            float rot = rnd.y * rnd.x * 456.0 + iTime * (0.3 * (rnd.y - 0.5)) ;\n            float c = cos(rot);\n            float s = sin(rot);\n            cellUV *= mat2(c,s,-s,c);\n\n            float dst = rnd.y;\n            \n            float intensity = corona(cellUV * (1.5 + dst), dst * 0.2);\n            \n            accum *= mix(intensity, 1.0, dst);\n        }\n    }\n    \n    return accum;\n}\n\n// Computes a random layer of embers spots\nfloat coronaLayer(vec2 uv)\n{\n    vec2 id = floor(uv);\n    vec2 cellUV = (uv - id) - vec2(0.5, 0.5) ;\n\n    return coronaSpot(cellUV, id);\n}\n\n\n\n\n// Final composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    uv *= 3.0;\n    \n    vec4 dateCol =  yearCol(uv); // 2020\n    \n    vec3 bg = fire(uv);\n    \n    \n    float corona = coronaLayer(uv * 1.1);\n    \n    \n    bg.rgb += mix(0.0,  corona, S(-2.0, 7.0, uv.y)) * 0.8;\n \n    \n    //add a bit of light\n    dateCol.rgb -= uv.y * 0.15 * dateCol.a;\n    bg.rgb -= uv.y * 0.03;\n    \n    // blend 2020 and BG\n    vec3 col = premulBlend(dateCol, bg);\n    \n    // Gamma correction to make the image warmer\n    float gamma = 0.8;\n    col.rgb = pow(col.rgb, vec3(gamma));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2Bzw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[441, 529, 566, 566, 736], [738, 783, 821, 821, 865], [867, 939, 977, 977, 1113], [1116, 1149, 1173, 1173, 1556], [1558, 1585, 1613, 1613, 1689], [1691, 1724, 1747, 1747, 2545], [2548, 2637, 2685, 2685, 2836], [2839, 2881, 2900, 2900, 2982], [2985, 3039, 3093, 3093, 3824], [3826, 3869, 3914, 3914, 4074], [4078, 4078, 4100, 4100, 4251], [4253, 4298, 4346, 4346, 4824], [4827, 4859, 4879, 4879, 5617], [5681, 5681, 5720, 5720, 5788], [5837, 5837, 5878, 5878, 5971], [5973, 5973, 6014, 6014, 6103], [6107, 6169, 6226, 6226, 6899], [6904, 6967, 7025, 7063, 7798], [7993, 8046, 8069, 8069, 8413], [8417, 8417, 8452, 8452, 9069], [9072, 9126, 9162, 9162, 10039], [10041, 10084, 10112, 10112, 10222], [10227, 10248, 10305, 10355, 10956]], "test": "untested"}
{"id": "tt2fRw", "name": "4D Julia Fractal Animation", "author": "xacer", "description": "Animated Julia fractal raymarcher, with hsb colors.", "tags": ["raymarching", "fractal", "julia", "animation"], "likes": 5, "viewed": 364, "published": 3, "date": "1598570269", "time_retrieved": "2024-07-30T20:48:42.507109", "image_code": "vec3 cameraPosition;\nmat3 cameraMatrix;\nvec4 offset;\nvoid qFold (inout vec4 a) {\n    a = vec4(a.x*a.x-a.y*a.y-a.z*a.z-a.w*a.w,2.0*a.x*a.y,2.0*a.x*a.z,2.0*a.x*a.w);\n}\nfloat map (vec3 pos) {\n    vec4 z = vec4(pos.xyz, 0.0);\n    float md2 = 1.0;\n    float radius2 = dot(z, z);\n    for (int i = 0; i < 25; i ++) {\n        qFold(z);\n        z += offset;\n        md2 *= 4.0 * radius2;\n        radius2 = dot(z, z);\n        if (radius2 > 4.0) break;\n    }\n    return 0.25 * sqrt(radius2 / md2) * log(radius2) - 0.001;\n}\nvec3 xDir = vec3(0.000001, 0, 0);\nvec3 yDir = vec3(0, 0.000001, 0);\nvec3 zDir = vec3(0, 0, 0.000001);\nvec3 surfaceNormal (vec3 pos) {\n    vec3 normal = vec3(\n        map(pos + xDir) - map(pos - xDir),\n        map(pos + yDir) - map(pos - yDir),\n        map(pos + zDir) - map(pos - zDir)\n    );\n    return normalize(normal);\n}\nvec3 lightDirection;\nfloat hue;\nvec3 tint;\nvec3 trace (vec3 origin, vec3 direction) {\n    float totalDistance = 0.0;\n    for (float steps = 0.0; steps < 100.0; steps ++) {\n        vec3 pos = origin + direction * totalDistance;\n        float distance = map(pos);\n        totalDistance += distance;\n        if (dot(pos, pos) > 25.0) break;\n        if (distance < 0.002) {\n            vec3 normal = surfaceNormal(pos);\n            float diffuse = max(-dot(normal, lightDirection), 0.0);\n            float specular = -dot(reflect(direction, normal), lightDirection);\n            specular = max(pow(specular, 5.0), 0.0);\n            float shade = diffuse * 0.7 + specular * 0.3;\n            return shade * tint;\n        }\n    }\n    return vec3(0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    cameraPosition = 1.8 * vec3(cos(iTime), 0, sin(iTime));\n\tcameraMatrix = mat3(cos(iTime+3.14/2.0), 0, -sin(iTime+3.14/2.0), 0, 1, 0, sin(iTime+3.14/2.0), 0, cos(iTime+3.14/2.0));\n\toffset = vec4(cos(iTime), sin(iTime), cos(iTime * 2.0 + 3.14), sin(iTime * 1.61 + 3.14)) * 0.6;\n    lightDirection = vec3(cos(iTime + 3.14), 0.0, sin(iTime + 3.14));\n    tint = vec3(cos(iTime / 20.0 * 3.1415 * 2.0) + 1.0, cos(iTime / 20.0 * 3.1415 * 2.0 + 2.0 * 3.1415 / 3.0) + 1.0, cos(iTime / 20.0 * 3.1415 * 2.0 + 4.0 * 3.1415 / 3.0) + 1.0) / 2.0;\n    hue = iTime / 20.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 1.0 - 2.0 * fragCoord/iResolution.xy;\n    vec3 ray = normalize(vec3(uv, 1.0)) * cameraMatrix;\n\n    // Time varying pixel color\n    vec3 col = trace(cameraPosition, ray);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2fRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 80, 80, 165], [166, 166, 188, 188, 511], [614, 614, 645, 645, 836], [880, 880, 922, 922, 1583], [1585, 1585, 1642, 1642, 2497]], "test": "untested"}
{"id": "Wt2fzm", "name": "Cosine Noise", "author": "xacer", "description": "Uses many cosine waves to generate a pseudo-random noise pattern. Inspired by the idea of a reverse Fourier series: if any image can be represented as cosine waves, then a random amount of random cosine waves will give you a random image.", "tags": ["procedural", "noise", "random"], "likes": 3, "viewed": 357, "published": 3, "date": "1598563347", "time_retrieved": "2024-07-30T20:48:43.315947", "image_code": "\n\n// Random numbers generated with external script\nvec2[10] cosFreqs = vec2[](\n    2.0 * vec2(0.552703259466216, 2.398672067606822), \n    2.0 * vec2(2.596438592672348, 1.7326873556477949),\n    2.0 * vec2(2.0663735123816878, 3.4705755615606906), \n    2.0 * vec2(1.9228225132683292, 3.7546182974940168), \n    2.0 * vec2(3.634548377431929, 3.2709100770764055), \n    2.0 * vec2(0.6124981915112584, 2.0756017953390256),\n    2.0 * vec2(0.6384711516322568, 1.2006440913071856),\n    2.0 * vec2(0.6755551774054765, 2.406119935703464), \n    2.0 * vec2(0.76554183838889, 2.783851124579087), \n    2.0 * vec2(2.206591797643341, 0.25993143348023295));\nvec2[10] cosOffsets = vec2[](\n    5.0 * vec2(1.6963525514584035, 0.4812831515911966), \n    5.0 * vec2(1.7907424867153168, 3.0717651144368574), \n    5.0 * vec2(3.2775063248816876, 2.6948721313849093), \n    5.0 * vec2(2.325938357994892, 0.3067102774744853), \n    5.0 * vec2(1.8504007333889605, 3.8717157411389054),\n    5.0 * vec2(0.2906125103589147, 1.522760608815588), \n    5.0 * vec2(2.3710837614955382, 0.24433000439312308), \n    5.0 * vec2(1.177456422522664, 0.45379907388705765),\n    5.0 * vec2(2.998746489267796, 1.925251271063462),\n    5.0 * vec2(3.98835907059256, 2.8298990848474204));\n\n\n// Square a number\nfloat sq (float v) {\n\treturn v * v;\n}\n\n// Generate the noise value of a single pixel\nfloat cosNoise (vec2 p) {\n    float val = 0.0;\n    float x = p.x;\n    float y = p.y;\n    for (int i = 0; i < 10; i ++) {\n    \tval += 0.8 * 0.1 * 0.5 * \n            (cos(x * cosFreqs[i].x * 20.0 + y * cosFreqs[i].y * 20.0 + cosOffsets[i].y) + \n             cos(y * cosFreqs[i].x * 20.0 - x * cosFreqs[i].y * 20.0 + cosOffsets[i].x) + 1.0);\n    }\n    return (sq(val + 0.5)) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n       \n    vec2 uv = 1.0 * fragCoord/iResolution.xy;\n    vec3 col = vec3(cosNoise(uv * 3.1415));\n    fragColor = vec4(col,1.0);\n}\n\n/*\nconst int MAXSTEPS = 100;\nconst float EPSILON = 0.00001;\n\nvec3 cam = vec3(0.0, -1.0, -3.0);\n\nvoid kib (inout float a, in float b) {\n\ta = min(a, b);\n}\n\nfloat sdBox (in vec3 p, in vec3 c1, in vec3 c2, in float r) {\n\treturn length(p - clamp(p, c1, c2)) - r;\n} \n\nfloat sdFloor (in vec3 p, in float h) {\n\treturn h - p.y;\n}\n\nfloat sdSphere (in vec3 p, in vec3 c, in float r) {\n\treturn length(p - c) - r;\n}\n\nfloat map (in vec3 p) {   \n    float dist = 100.0;\n    \n    kib(dist, sdFloor(p, 0.1));\n    kib(dist, sdSphere(p, vec3(0.0), 0.5));\n    kib(dist, sdBox(p, vec3(-2.0, -0.4, -0.2),vec3(-1.5,-0.2, 0),0.02));\n    \n    return dist;\n}\n\nvec3 xDir = vec3(0.000001, 0, 0);\nvec3 yDir = vec3(0, 0.000001, 0);\nvec3 zDir = vec3(0, 0, 0.000001);\n\nvec3 surfaceNormal (vec3 pos) {\n    vec3 normal = vec3(\n        map(pos + xDir) - map(pos - xDir),\n        map(pos + yDir) - map(pos - yDir),\n        map(pos + zDir) - map(pos - zDir)\n    );\n    return normalize(normal);\n}\n\nvec3 lightPos = vec3(0.0, -1.0, -1.5);\n\nvec3 trace (in vec3 ro, in vec3 rd) {\n\tfloat t = 0.0;\n    for (int i = 0; i < MAXSTEPS; i ++) {\n    \tvec3 pos = ro + rd * t;\n        float dist = map(pos);\n        if (dist < EPSILON) {\n            vec3 lightDir = normalize(pos - lightPos);\n            \n        \tvec3 normal = surfaceNormal(pos);\n            \n            float diffuse = max(-dot(normal, lightDir), 0.0);\n            float specular = dot(reflect(rd, normal), lightDir);\n            specular = pow(max(specular, 0.0), 100.0);\n            \n            vec3 tint = texture(iChannel1, pos.xy).rgb;              \n            return tint * (diffuse * 0.7 + specular * 0.3);\n        }\n        t += dist;\n    }\n\treturn vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 1.0 * fragCoord/iResolution.xy;\n    \n    /*\n    vec3 ray = normalize(vec3(uv.xy, 1.0));\n\n    // Time varying pixel color\n    vec3 col = trace(cam, ray);\n\t\n    // Output to screen\n    fragColor = vec4(col.rgb, 1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2fzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1232, 1251, 1271, 1271, 1288], [1290, 1336, 1361, 1361, 1716], [1718, 1718, 1775, 1775, 1906]], "test": "untested"}
{"id": "ttjfRD", "name": "Protected Void (sound)", "author": "ruojake", "description": "Procedural techno.", "tags": ["raymarching", "sound", "music", "audio"], "likes": 14, "viewed": 494, "published": 3, "date": "1598560164", "time_retrieved": "2024-07-30T20:48:44.166672", "image_code": "// Protected Void by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nvec3 hash32(in vec2 p)\n{\n\treturn fract(sin(p.xyx * 172.41 + dot(p, vec2(13.43, 14.05))) * 43212.513);\n}\n\nfloat hash12(in vec2 p)\n{\n\treturn fract(sin(172.41 + dot(p, vec2(13.43, 14.05))) * 43212.513);\n}\n\nvec3 hash31(in float v)\n{\n\treturn fract(sin(vec3(21.51, 32.21, 11.43) * v + 31.33) * 25234.312);\n}\n\nmat2 rot(in float a)\n{\n\tfloat s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat sqrL(in vec3 d)\n{\n    return dot(d, d);\n}\n\nvec2 box(in vec3 p, in float b)\n{\n  vec3 d = abs(p) - b;\n  return vec2(sqrL(max(d, 0.)), min(max(d.x, max(d.y, d.z)), 0.));\n}\n\nfloat size(in vec3 t, in vec3 id)\n{\n    float h = .0625 * floor(16. * fract(sin(t.x + dot(id, vec3(11.31, 12.07, 11.66))) * 42313.541));\n    h *= 2. - h;\n    float b = .375 - t.y * step(.07, h);\n    return fract(t.z + h) * b + .025;\n}\n\nvec2 minX(in vec2 a, in vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec3 sizeTiming(in float t)\n{\n    const float bdwn = 132. / 60. / 512.;\n    const float hlf = 132. / 120.;\n    return vec3(\n        floor(t * hlf),\n        sat(floor(fract(t * bdwn + .75) * 8.) - 6.) * .35625,\n        t * hlf\n    );\n}\n\nvec2 cubes(in vec3 p)\n{\n    float d = (1. - fract(iTime * 132. / 60.));\n    d *= d;\n    d = d * .3 + .9;\n    vec3 o = vec3(.75, -.75, 0.);\n    vec3 od = o * d;\n    vec3 t = sizeTiming(iTime);\n    \n    return minX(\n            minX(\n              minX(vec2(1000.), minX(box(p + od.y, size(t, o.yyy)),\n              minX(box(p + od.yzy, size(t, o.yzy)),\n              minX(box(p + od.yxy, size(t, o.yxy)),\n              minX(box(p + od.yyz, size(t, o.yyz)),\n              minX(box(p + od.yzz, size(t, o.yzz)),\n              box(p + od.yxz, size(t, o.yxz)))))))),\n\n              minX(box(p + od.yyx, size(t, o.yyx)),\n              minX(box(p + od.yzx, size(t, o.yzx)),\n              minX(box(p + od.yxx, size(t, o.yxx)),\n              minX(box(p + od.zyy, size(t, o.zyy)),\n              minX(box(p + od.zzy, size(t, o.zzy)),\n              minX(box(p + od.zxy, size(t, o.zxy)),\n              box(p + od.zyz, size(t, o.zyz))))))))\n              ),\n            minX(\n              minX(box(p + od.zxz, size(t, o.zxz)),\n              minX(box(p + od.zyx, size(t, o.zyx)),\n              minX(box(p + od.zzx, size(t, o.zzx)),\n              minX(box(p + od.zxx, size(t, o.zxx)),\n              minX(box(p + od.xyy, size(t, o.xyy)),\n              box(p + od.xzy, size(t, o.xzy))))))),\n\n              minX(box(p + od.xxy, size(t, o.xxy)),\n              minX(box(p + od.xyz, size(t, o.xyz)),\n              minX(box(p + od.xzz, size(t, o.xzz)),\n              minX(box(p + od.xxz, size(t, o.xxz)),\n              minX(box(p + od.xyx, size(t, o.xyx)),\n              minX(box(p + od.xzx, size(t, o.xzx)),\n              box(p + od.x, size(t, o.xxx)))))))))\n          ); \n}\n\nfloat scene(in vec3 p)\n{\n    const float pi = 3.1415;\n    \n    float a = iTime * 132. / 120.;\n    float b = sat(fract(a * .5) * 2. - 1.);\n    a = 1. - sat((1. - fract(a * .5)) * 2. - 1.);\n    \n\tp -= vec3(0,1,0);\n    \n    p.xy *= rot(a * pi);\n    p.xz *= rot(-b * pi);\n\tp.yz *= rot(iTime * .25);\n    \n    vec2 c = cubes(p);\n    \n    return min(sqrt(c.x) + c.y - .02, length(p) - .5);\n}\n\nvec3 normal(in vec3 p)\n{\n\tfloat d = scene(p);\n    vec2 e = vec2(.001, .0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nvec3 ray(in vec3 ro, vec3 lookAt, vec2 uv, float zoom)\n{\n\tvec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n\n    return normalize(uv.x * r + uv.y * u + f * zoom);\n}\n\nvec3 bg(in float y)\n{\n\ty = y * .5 + .5;\n    return vec3(.02, .025, .03) * y * y;\n}\n\nvec3 shake(in float v)\n{\n\tfloat i = floor(v);\n    float f = smoothstep(0., 1., v - i);\n    \n    return mix(hash31(i), hash31(i + 1.), f) * 2. - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float beat = iTime / 60. * 132.;\n    float md = sat(floor(fract(iTime * .034375) * 4.) - 2.);\n    float rs = iResolution.y / 20.;\n    vec2 lcoord = floor((fragCoord - iResolution.xy * .5) / rs + vec2(fract(-iTime * 132. / 3.75) * 2. - 1., 0.)) * rs;\n    vec2 coord = fragCoord - iResolution.xy * .5;\n    float h = hash12(lcoord + floor(iTime * 132. / 30.));\n    coord = mix(coord, lcoord, step(.95, h) * md);\n    \n    vec2 uv = coord / iResolution.y;\n    vec3 ro = vec3(0,1.5,-4);\n    vec3 tgt = vec3(0, 1, 0);\n    vec3 rd = ray(ro, tgt, uv, .75);\n    vec3 p = vec3(0);\n    float t = 0.;\n    \n    for(int i = 0; i < 50 && t <= 6.; i++)\n    {\n    \tp = ro + rd * t;\n        float d = scene(p);\n        t += d + .005;\n        if(abs(d) < .001) break;\n    }\n    \n    float dSphere = length(p - vec3(0,1,0));\n    if (dSphere > .5009) p += md * shake(h * fract(beat)) * .2;\n    \n    vec3 n = normal(p);\n    vec3 col = mix(bg(reflect(-ro, n).y),\n                   bg(rd.y).zyx * .5 * (1. - fract(beat) * md * (length(uv) * 3. - 2.2)),\n                   1. - sat(6. - t));\n    col *= sat(iTime * 132. / 960.);\n\n    if (dSphere < .501) col = vec3(1.);\n\t\n    col = pow(col, vec3(1./2.2));\n    \n    #ifdef FADE\n    col *= 1. - sat((iTime - 160.) * .05);\n    #endif\n    \n    col += (vec3(col.g * .75) - col) * -40. * md * sat(fract(h * 421.1) * 20. - 19.);\n    \n    fragColor = vec4(col + hash32(fragCoord + floor(fract(iTime) * 7200.)) * .0078 - .0039,1.0);\n}", "image_inputs": [], "sound_code": "float hash(float t)\n{\n\treturn fract(sin(t * 3123. + 5134.) * 4321.312) * 2. - 1.;\n}\n\nfloat noise(float t)\n{\n\tfloat i = floor(t);\n    float f = smoothstep(0., 1., t - i);\n    return mix(hash(i), hash(i+1.), f);\n}\n\nfloat fbm(float t)\n{\n\tfloat a = 1.;\n    float snd = 0.;\n    for(float i = 1.; i < 6.; i++)\n    {\n    \tsnd += noise(t * i) * a;\n        a *= .75;\n    }\n    return snd;\n}\n\nfloat sfract(float v, float k)\n{\n    v = fract(v);\n\treturn mix(v, 0., clamp(v * k - k + 1., 0., 1.));\n}\n\nfloat note(float n)\n{\n\treturn n >= 0. ? 440. * pow(2., n / 12.) : 440. / pow(2., -n / 12.);\n}\n\nfloat saw(float t, float f, float n, float hp)\n{\n    float a = 1.;\n    float p = 0.;\n    float snd = 0.;\n\tfor(float i = max(floor(hp), 1.); i < 40. && a > 1e-36; i++)\n    {\n    \tfloat h = sin(6.2831 * t * note(n) * i + p) / i * a;\n        snd += h;\n\t\ta *= f;\n        p += 3.1415;\n    }\n    return snd * .5;\n}\n\nvec2 syn(float n, float t, float f, float h)\n{\n    vec2 snd = vec2(0.);\n    n -= 17.;\n    for(float c = 0.; c < 2.; c++)\n    {\n        float nn = n;\n        for(float i = 0.; i < 5.; i += 1.)\n        {\n            float hash = hash(nn+c);\n            float ff = sfract(f*3., 50.); \n            float note = (floor(nn + h) + hash * .1 - .05);\n            snd.x += saw(t + fract(abs(hash) * 51123.) * 3.1415, \n                         f * .3 + ff * .2 + .5, \n                         note, floor(3. - f * 3.) * 3.) \n                * ff;\n            nn += 3.5;\n        }\n        snd = snd.yx;\n    }\n    return snd;\n}\n\nfloat bass(float t, float f, float n)\n{\n    const float tau = 6.2831;\n    f = 1. - f;\n\treturn sin(tau * t * note(-36. + n) + sin(tau * t * note(-24. + n)) + .25 * sin(tau * t * note(-5. + n))) * f * f;\n}\n\nfloat hh(float t, float f)\n{\n    f = 1. - f;\n    float h = hash(f * 100.) * .3 + hash(f * .1) * .7;\n\treturn f * f * f * f * f * h * abs(h);\n}\n\nfloat kick(float f)\n{\n\tf = 1. - f;\n    return (cos(4. * note(-21. + f * f * f * f * f * 3.))\n        + cos(5. * note(-16. + f * f * f * 2.)) * .4\n        + .5 * (.8 - f * f) * fbm(f * 70.))\n        * pow(f, .4);\n}\n\nfloat snare(float f)\n{\n\tf = 1. - f;\n    return smoothstep(-.7, .7, \n        (fbm(f * 140. + f * f * f * f * f * 50.) + fbm(f * 110. + f * f * 20.)) * .5 * f * f * f)\n        * 2. - 1.;\n}\n\nvec2 ride(float f)\n{\n\treturn (sin(f * 8000.) + 1.) * (1.25-f) * .1 * vec2(\n        (noise(f * 7900.) + noise(f * 4100. - 41.)),\n        (noise(f * 7900. - 51.) + noise(f * 4100. + 141.)));\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float tempo = 132.;\n    float beat = time / 60. * tempo;\n    float tick = beat * 4.;\n    float chord = beat * 4. / 3.;   \n    float sn = beat * .5 + .5 + floor(fract(beat * .25) * 2.) * .125;\n    float rd = beat * 2.;\n    float h = floor(fract(sin(floor(chord) * 15121.31)) * 5.);\n    float md = sat(floor(fract(beat / 64.) * 4.) - 2.);\n    float bdwn = 1. - sat(floor(fract(beat / 512. + .75) * 8.) - 6.);\n    \n    vec2 snd = sat(beat * .03125 - 2.) * .25 \n        * syn(h * -3. - md * 4., time, \n            1.-sfract(chord, 30.), \n            fract((h+md) * .5) * .5) * (sfract(beat, 40.) * .75 + .25) \n        + bdwn * sat(beat * .125 - 1.) * .15 * hh(time, fract(tick) * (floor(sfract(beat + .5, 20.) * 4. + 1.) * .5))\n        + bdwn * sat(beat * .125) * .55 * kick(fract(beat))\n        + sat(beat * .25 - .5) * .4 * bass(time, clamp(sfract(beat + .25, 30.), 0., .5) * 2., 0.+ md * 3.)\n        + sat(beat * .25 - .5) * .35 * bass(time, clamp(sfract(beat + .5, 30.), 0., .5) * 2., -2.)\n        + sat(beat * .125 - .5) * .15 * snare(clamp(fract(sn), 0., .125) * 8.)\n        + md * .1 * ride(sfract(rd, 20.));\n    \n    snd /= max(snd * snd * 1.05, 1.);\n    \n    #ifdef FADE\n    snd *= 1. - sat((time - 160.) * .05);\n    #endif\n    \n    return snd;\n}", "sound_inputs": [], "common_code": "// comment this out if you're using the shadertoy browser plugin\n// and you want an infinite loop\n#define FADE\n\n#define sat(x) clamp((x), 0., 1.)", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjfRD.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[115, 115, 139, 139, 218], [220, 220, 245, 245, 316], [318, 318, 343, 343, 416], [418, 418, 440, 440, 518], [520, 520, 543, 543, 567], [569, 569, 602, 602, 694], [696, 696, 731, 731, 930], [932, 932, 965, 965, 997], [999, 999, 1028, 1028, 1233], [1235, 1235, 1258, 1258, 2887], [2889, 2889, 2913, 2913, 3273], [3275, 3275, 3299, 3299, 3462], [3464, 3464, 3520, 3520, 3678], [3680, 3680, 3701, 3701, 3762], [3764, 3764, 3788, 3788, 3913], [3915, 3915, 3972, 3972, 5427]], "test": "untested"}
{"id": "tlsfzf", "name": "Code:002", "author": "Pidhorskyi", "description": "ZeroTwo from \"Darling in the Franxx\"", "tags": ["zerotwo"], "likes": 99, "viewed": 3485, "published": 3, "date": "1598555855", "time_retrieved": "2024-07-30T20:48:45.209883", "image_code": "vec4 render(float d, vec3 color, float w)\n{\n    float anti = fwidth(d) * w;\n    return vec4(color, smoothstep(anti, -anti, d));\n}\n\nvec4 render(float d, vec4 color)\n{\n    float anti = fwidth(d) * 1.0;\n    return vec4(color.rgb, color.a * smoothstep(anti, -anti, d));\n}\n\nvec4 render_stroked(float d, vec3 color, float stroke)\n{\n    float anti = fwidth(d) * 1.0;\n    vec4 strokeLayer = vec4(vec3(0.01), smoothstep(anti, -anti, d - stroke));\n    vec4 colorLayer = vec4(color, smoothstep(anti, -anti, d));\n    return vec4(mix(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\nvec4 render_stroked_masked(float d, vec3 color, float stroke, float stroke_mask)\n{\n    float anti = fwidth(d) * 1.0;\n    vec4 strokeLayer = vec4(vec3(0.01), smoothstep(anti, -anti, d));\n    float se = smoothstep(anti, -anti, stroke_mask);\n    vec4 colorLayer = vec4(color, smoothstep(anti, -anti, d + stroke));\n    return vec4(mix(mix(strokeLayer.rgb, colorLayer.rgb,  se), colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\nvoid render_layer(inout vec4 c, vec4 layer)\n{ \n    c.rgb = mix(c.rgb, layer.rgb, layer.a);\n}\n\nvoid render_layer_mul(inout vec4 c, vec4 layer)\n{ \n    c.rgb = mix(c.rgb, c.rgb * layer.rgb, layer.a);\n}\n\nfloat exact_intersection(float d1, float d2)\n{\n    float dmin = min(d1, d2);\n    float dmax = max(d1, d2);\n    return dmin < 0. ? dmax : dmin;\n}\n\nvec4 sdEye(vec2 p)\n{\n    p += vec2(0.52, -0.15);\n    vec2 plt = vec2(-0.035, -0.045); vec2 pmt = vec2(0.56, 0.31); vec2 prt = vec2(0.862, 0.0421);\n    vec2 plm = vec2(0.039, -0.3);                                vec2 prm = vec2(0.87, -0.088);\n    vec2 plb = vec2(0.31, -0.35); vec2 pmb = vec2(0.55, -0.35); vec2 prb = vec2(0.84, -0.25);\n    \n    float d1 = sdBezier(prt, pmt, plt, p);\n    float d2 = sdBezier(plt, plm, plb, p);\n    float d3 = sdBezier(plb, pmb, prb, p);\n    float d4 = sdBezier(prb, prm, prt, p);\n    \n    float d14 = exact_intersection(d1, d4);\n    float d23 = exact_intersection(d2, d3);\n    float dd = exact_intersection(d23, d14);\n    return vec4(dd, d1, d23, d2);\n}\n\n\nfloat sdPupil(vec2 p, float r, vec2 offset)\n{\n    return sdEllipse(vec2(0.2, 0.3) * r, p - offset);\n}\n\nfloat pow2(float x) { return x * x; }\n\nvec4 sdHair(vec2 p)\n{\n    float def1 = p.y + 1.5;\n    float def2 = p.y + 0.3;\n    \n    p.x += pow2(3.8 * max(0.1 - def1 * def1 * 0.15, 0.)) * sign(p.x) * smoothstep(0.40, 0.43, abs(p.x));\n    p.x -= pow2(2.5 * max(0.1 - def1 * def1 * 0.15, 0.)) * float(p.x < 0.);\n    p.x += pow2(1.5 * max(0.1 - def2 * def2 * 0.35, 0.)) * float(p.x < -0.46);\n    \n\tfloat d = sdUnevenCapsuleY( p, 0.73, 0.51, 2.1 );\n    \n    float dcut = 0.16 -p.y - p.x * 0.05;\n    float dsub = abs(p.x) - 0.41;\n    dsub = max(dsub, -dcut);\n    float d3 = max(d, -dsub);\n    return vec4(d3, d, dcut, dsub);\n}\n\nconst float f[]   = float[](0.4, 0.23, 0.1, 0.05);\nconst float off[] = float[](-0.4, 0.1, 0.5, 0.5);\nconst float amp[] = float[](8.0, 12.4, 22.4, 32.4);\nconst float bias[] = float[](0.4, 0.2, 0.2, 0.2);\nconst int n = 4;\nvec4 sdHairBands(vec2 p)   \n{\t\n    vec4 dh = sdHair(p);\n    float d = dh.x;\n    float dcut = 0.16 -p.y - p.x * 0.05;\n    \n    p += 0.2 * sin(p.x / 0.4) * (1.0-cos((p.y + 0.15) / 0.4));\n    \n    float db = -(0.2 - abs(dcut));\n    float dmod = -0.2;\n    float b1 = 0.0;\n    \n    for (int i = 0; i< n; ++i)\n    {\n    \tb1 = -amp[i] * (max(mod(p.x + off[i], f[i]), f[i] / 2. ) -5./4.*f[i] + max(mod(-p.x - off[i], f[i]), f[i]/2. ));\n    \tb1 = -pow(max(b1, 0.0), 2.5) + bias[i];\n    \tdmod = max(dmod, -b1);\n    }\n\n    float k = 4.0;\n    dmod = tanh(k * dmod) / k;\n    db += dmod;\n    \n    db += 0.1 * max(1.0 - 5.0 * p.x * p.x, 0.) - 0.1;\n    db *= 0.5;\n    db = max(db, dh.y);\n    \n    d = min(db, max(d, -0.1));\n        \n    return vec4(d, dh.y, dh.z, dh.w);\n}\n \n#define LayerF(d, color) render_layer(fragColor, render(d, color, 1.))\n#define LayerFM(d, color) render_layer_mul(fragColor, render(d, color, 1.))\n#define LayerFMW(d, color, w) render_layer_mul(fragColor, render(d, color, w))\n#define LayerS(d, color, stroke) render_layer(fragColor, render_stroked(d, color, stroke))\n#define LayerSM(d, color, stroke, mask) render_layer(fragColor, render_stroked_masked(d, color, stroke, mask))\n\nstruct Params\n{\n    float size;\n    float pixSize;\n    float yaw;\n    float lj;\n    float wj;\n    float wc;\n    float th;\n    float trh;\n    float radius;\n    float m;\n    float stroke;\n};\n\nfloat make_head(inout vec4 fragColor, Params p, vec2 uv)\n{\n    float a = sdfTriangleDist(p.wj, p.th, (uv + vec2(0.0, p.lj)));\n    float b = sdTrapezoid(p.wj, p.wc, p.trh, (uv + vec2(0.0, p.lj - p.th - p.trh)));\n    float c = sdfCircle(p.wc * 1.005, uv - vec2(0.0, p.m));\n    c = sdfIntersection(c, -uv.y + p.m);\n\n    float e = sdEgg(p.wc * 1.005, 0.04, (uv - vec2(0.0, p.m))  * vec2(1.0, -1.0)) ;\n    \n    float d = 1e6;\n    d = sdfUnion(a, b);\n    d = sdfUnion(d, c);\n    d = mix(d, e, 0.4 * smoothstep(0.1, p.wj, abs(uv.x)));\n    \n    d -= p.radius;\n    d += disp(uv, 20.0) * 0.001;  \n    \n    LayerS(d, vec3(0.757, 0.772, 0.796), p.stroke);\n    return d;\n}\n\n\nvoid make_hair_back(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv = rotate(uv, -0.09);\n    uv += vec2(0.02, -0.31);\n    uv *= 1.35;\n    float d = sdHair(uv * vec2(1.2, 1.0) + vec2(0.01, 0.12)).y;\n\n    LayerF(d, vec3(0.54, 0.37, 0.46));\n}\n  \nvoid make_hair_shadow(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv = rotate(uv, -0.09);\n    uv += vec2(0.02, -0.31);\n    uv *= 1.35;\n    float ds = sdHairBands(uv * vec2(1.02, 1.0) + vec2(-0.03, 0.05)).x;\n    LayerFMW(ds, vec3(0.752, 0.66, 0.69) * 0.9, 3.0);\n}\n\nvoid make_hair(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv = rotate(uv, -0.09);\n    uv += vec2(0.02, -0.31);\n    uv *= 1.35;\n    float def = max(-uv.x + 0.6 * uv.y - 0.45, 0.) * 2.0;\n    uv.x -= def * def;\n    float d = sdHairBands(uv).x;\n\n    d += disp(uv, 2.0) * 0.005;  \n    d += disp(uv, 20.0) * 0.001;  \n\n    LayerS(d, vec3(0.75, 0.67, 0.76), p.stroke * 1.5);\n    LayerF(d + 0.18, vec3(0.75, 0.84, 0.87));\n}\n\nvoid _make_hair2(inout vec4 fragColor, Params p, vec2 uv, float l)\n{\n    uv *= 1.35;\n    float def1 = uv.y + 1.5;\n    uv.x -= pow(2.5 * max(0.1 - def1 * def1 * 0.15, 0.), 2.0) * (1.0 - 0.6 * l);\n    uv /= 1.35;\n    float d = abs(0.33 - 0.02 * l + uv.x) - 0.03 * (1.0 + 0.5 * (1. - l ) + uv.y * (0.4 + 0.3 * (1.-l)));\n    \n    d = max(d, uv.y);\n    \n    float m = -(uv.y - 0.14 + l * 0.07 - uv.x * 0.6);\n    \n    m = mix(m, min(m, (uv.x + 0.33 - 0.02 * l)), uv.y < -0.75);\n\n    d += disp(uv, 2.0) * 0.005;  \n    d += disp(uv, 20.0) * 0.001;  \n\n    LayerSM(d, vec3(0.75, 0.67, 0.76), p.stroke * 0.5, m);\n}\n\nvoid make_hair2(inout vec4 fragColor, Params p, vec2 uv)\n{\n    float l = float(uv.x > 0.);\n    uv += vec2(0.045, -0.31);\n    uv = rotate(uv, -0.12 + 0.025 * l);\n    uv.x = -abs(uv.x);\n    // uv = mix(uv, uv * vec2(1.03, 0.99) - vec2(0.03, -0.005), l);\n    _make_hair2(fragColor, p, uv, l);\n}\n\nvoid make_band_and_horns(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv = rotate(uv, 0.06);\n    uv += vec2(0.05, -0.30);\n\tfloat d = sdUnevenCapsuleY(uv, 0.73, 0.32, 2.1 );\n    uv += vec2(-0.0, 0.09);\n\tfloat d2 = sdUnevenCapsuleY(uv, 1.0, 0.335, 2.1 );\n    d = max(d, -d2);\n    \n    float r = float(uv.x > 0.);\n    float ir = 1.0 - r;\n    uv.x = -abs(uv.x);\n\n    float a = sdfTriangleDist(0.05, 0.08 - 0.03 * r, rotate( uv + vec2(0.24, -0.16 - 0.038 * r), -0.4));\n    a = max(a, -uv.x + uv.y - 0.5);\n    d = min(d, a);\n\n    LayerS(d, vec3(0.72, 0.79, 0.88), p.stroke);\n    \n    vec2 p0 = vec2(-0.010, 0.07 - 0.02 * ir);\n\tfloat c = max(uv.y - 0.36, 0.) * (r * 0.5 + 0.5);\n    uv -= vec2(c * c * 1.25, 0.0);\n    float dh = sdTriangle(p0, p0 + vec2(-0.05 - 0.01 * ir, 0.3), p0 + vec2(0.03 * r, 0.13), uv + vec2(0.24, -0.16));\n    // dh = max(dh, -uv.x + uv.y - 0.5);\n    dh -= 0.005;\n\n    float dhs = max(dh, uv.x + uv.y * 0.5 + 0.07);\n    float dhh = max(dh, uv.x + uv.y * 0.18 + 0.195 + 0.012 * ir) + 0.004;\n    \n    LayerS(dh, vec3(0.52, 0.24, 0.34), p.stroke);\n    LayerF(dhs, vec3(0.28, 0.17, 0.27));\n    LayerF(dhh, vec3(0.69, 0.62, 0.72));\n}\n\nvoid make_neck(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv += vec2(0.0, p.lj);\n    uv += vec2(0.007, 0.1);\n    uv *= 2.6;\n\n    vec2 plt = vec2(-0.5,  0.34); vec2 prt = vec2(0.5,  0.34);\n    vec2 plm = vec2(-0.4, -0.0);  vec2 prm = vec2(0.4, -0.1);\n    vec2 plb = vec2(-0.45, -0.35); vec2 prb = vec2(0.52, -0.2);\n    \n    float d2 = sdBezier(plt, plm, plb, uv);\n    float d4 = sdBezier(prb, prm, prt, uv);\n    \n    float d24 = exact_intersection(d2, d4);\n    float d_caps = max(uv.y - 0.35, -0.34 - uv.y);\n    float dd = max(d24, d_caps);\n    \n    LayerS(dd, vec3(0.54, 0.46, 0.46), p.stroke * 2.6);\n}\n\nvoid make_mouth(inout vec4 fragColor, Params p, vec2 uv)\n{\n    float mm = sdEllipse(vec2(p.wj * 0.55, p.th * 0.13), opCheapBend(uv + p.yaw * vec2(0.005, 0.), 2.0) + vec2(0.0, p.lj - p.th - 0.01));\n    float mme = sdfCircle(0.02, uv + p.yaw * vec2(0.005, 0.) + vec2(-0.03, p.lj - p.th + 0.01));\n    mm += disp(uv, 20.0) * 0.002; \n    LayerSM(mm, vec3(0.70, 0.58, 0.6),  p.stroke * (1. + 2. * smoothstep(p.wj * 0.1, p.wj * 0.4, uv.x)), mme);\n}\n\nvoid make_nose(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv.x -= 0.005;\n    float nn1 = udBezier(vec2(0.01, p.m - p.th * 1.48), vec2(0.008, p.m - p.th * 1.38), vec2(0.017, p.m - p.th * 1.08), uv);\n    float nn2 = udBezier(vec2(0.007, p.m - p.th * 0.62), vec2(0.007, p.m - p.th * 0.75), vec2(0.017, p.m - p.th * 0.87), uv);\n    float nn3 = udBezier(vec2(0.01, p.m - p.th * 0.2), vec2(0.017, p.m + p.th * 0.1), vec2(0.04, p.m + p.th * 0.3), uv);\n    nn1 = min(nn1, nn2);\n    nn1 = min(nn1, nn3);\n    \n    vec2 p0 = vec2(0.001, p.m - p.th * 0.62);\n\tfloat c = max(uv.y - 0.36, 0.);\n    float def = dot(vec2(p.th * 0.25, 0.01), p0 - uv) - 0.0003;\n    def *= 1200.0;\n    def = max(1.0 - def * def, 0.);\n    uv.y -= def * 0.015;\n    float dh = sdTriangle(p0, p0 + vec2(-0.021, -p.th * 0.4), p0 + vec2(0.01, -p.th * 0.25), uv);\n\n    dh -= 0.008;\n\n    LayerFMW(dh, vec3(0.752, 0.66, 0.69), 1.5);\n    LayerS(nn1, vec3(0.), p.pixSize * 0.6);\n}\n\nvoid make_eye(inout vec4 fragColor, Params p, vec2 uv, float l)\n{\n    uv.x += p.wc * 0.8;\n    uv.y -= p.m;\n    uv += vec2(-0.05, 0.06);\n    uv *= 5.2;\n    vec4 d = sdEye(uv);\n    LayerF(d.x, vec3(0.73, 0.78, 0.83));\n    float w = (1.0 - (uv.x * uv.x / 0.5)) * 1.3;\n    LayerS(abs(d.y - 0.03 * w), vec3(0.08, 0.14, 0.18),  0.04 * w);\n    \n    float dh = max(d.w - 0.13 * (1.45 + 3.2 * uv.y), -d.w);\n    dh = max(dh, uv.y - uv.x * 0.9 - 0.65);\n    dh = max(dh, -uv.y + uv.x * 0.44 + 0.0);\n    LayerF(dh, vec3(0.59, 0.31, 0.44));\n    \n    float m = uv.y + 0.08;\n    LayerF(max(abs(d.z)- 0.015, m), vec3(0.08, 0.14, 0.18));\n    \n    float p1 = sdPupil(uv, 1.0, vec2(-0.05, 0.) * l);\n    float p2 = sdPupil(uv, 0.52, vec2(-0.05, 0.) * l + vec2(0.03, 0.) * (l - 0.5) + vec2(0.0, 0.03));\n    float p3 = sdPupil(uv, 0.15, vec2(-0.05, 0.) * l + vec2(0.05, 0.) * (l - 0.5) + vec2(0.0, 0.03));\n    float s1 = sdPupil(uv, 0.3, vec2(-0.05, 0.) * l + vec2(0.36, 0.) * (l - 0.5));\n    \n    LayerS(max(p1, d.x), vec3(0.26, 0.45, 0.45),  p.stroke * 5.2);\n    LayerS(max(p2, d.x), vec3(0.26, 0.45, 0.45),  p.stroke * 5.2);\n    LayerS(max(p3, d.x), vec3(0.08, 0.14, 0.18),  p.stroke * 5.2);\n    LayerF(max(s1, d.x), vec3(0.75, 0.84, 0.87));\n    {\n    \tvec2 _uv = uv + vec2(0.4, -0.38) + vec2(0.15, 0.02) * l - 0.1 * uv.x * l;\n    \tvec2 plt = vec2(0.1, 0.04); vec2 pmt = vec2(0.5, 0.2); vec2 prt = vec2(0.88, 0.05);\n    \tfloat du = udBezier(prt, pmt, plt, _uv);\n    \tLayerS(du, vec3(0.),  p.stroke * 3.);\n    }\n}\n\nvoid make_eyebrow(inout vec4 fragColor, Params p, vec2 uv, float l)\n{\n    uv.x += p.wc * 0.8;\n    uv.y -= p.m;\n    uv += vec2(-0.05, 0.06);\n    uv *= 5.2;\n\n  \tvec2 _uv = uv + vec2(0.4, -0.60) + vec2(0.15, 0.02) * l - 0.1 * uv.x * l;\n   \tvec2 plt = vec2(-0.01, -0.05); vec2 pmt = vec2(0.5, 0.02); vec2 prt = vec2(0.98, 0.18);\n   \tfloat du = udBezier(prt, pmt, plt, _uv) - 1.0 * min(dot3(_uv - vec2(-0.01, -0.05)) * dot2(_uv - vec2(0.98, 0.18)), 0.1);\n   \tLayerS(du, vec3(0.75, 0.67, 0.76),  p.stroke * 3.);\n}\n\nvoid make_eyes(inout vec4 fragColor, Params p, vec2 uv)\n{\n    float l = float(uv.x > 0.);\n    uv.x = -abs(uv.x);\n    uv = mix(uv, uv * vec2(1.03, 0.99) - vec2(0.03, -0.005), l);\n    make_eye(fragColor, p, uv, l);\n}\n\nvoid make_eyebrows(inout vec4 fragColor, Params p, vec2 uv)\n{\n    float l = float(uv.x > 0.);\n    uv.x = -abs(uv.x);\n    uv = mix(uv, uv * vec2(1.03, 0.99) - vec2(0.03, -0.005), l);\n    make_eyebrow(fragColor, p, uv, l);\n}\n\nvoid make_ear(inout vec4 fragColor, Params p, vec2 uv, float l, float headd)\n{\n    uv += vec2(0.38, 0.065) + vec2(-0.075, 0.02) *l;\n    uv = rotate(uv, -0.4);\n    float def1 = uv.x - uv.y + 0.0;\n    float def2 = uv.x + uv.y * 0.7 - 0.05;\n    float def3 = uv.x - uv.y + 0.0;\n    uv.x -= max(0.02 - def1 * def1, 0.);\n    uv.x -= pow(max(0.1 - def2 * def2 * 20.0, 0.), 2.);\n    float d = sdEllipse(vec2(0.05, 0.11), uv);\n    d = max(d, -headd + p.stroke);\n    LayerS(d, vec3(0.757, 0.772, 0.796), p.stroke);\n    vec2 uv2 = rotate(uv, -0.2);\n    uv2 += vec2(0.005, 0.026);\n    float d2 = sdEllipse(vec2(0.024, 0.045), uv2);\n    d2 = max(d2, -headd + p.stroke);\n    LayerS(d2, vec3(0.49, 0.46, 0.51), p.stroke);\n    {\n    \tvec2 _uv = uv;\n    \tvec2 plt = vec2(-0.015, 0.085); vec2 pmt = vec2(-0.0, 0.085); vec2 prt = vec2(0.005, 0.035);\n    \tfloat du = udBezier(prt, pmt, plt, _uv);\n    \tLayerS(du, vec3(0.),  p.stroke * 0.5);\n    }\n}\n\nvoid make_ears(inout vec4 fragColor, Params p, vec2 uv, float headd)\n{\n    float l = float(uv.x > 0.);\n    uv.x = -abs(uv.x);\n    make_ear(fragColor, p, uv, l, headd);\n}\n\nvoid make_body_shadow(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv += vec2(-0.045, 0.46);\n    uv = rotate(uv, -0.05);\n    uv += vec2(-0.01, 0.1);\n    float def = uv.y + uv.x * 0.2 - 0.06;\n    uv.y += pow(max(def, 0.), 2.) * 12.0;\n\tfloat d2 = sdUnevenCapsuleY(uv, 0.5, 0.26, 0.9 ) - 0.04;\n    LayerS(d2 + 0.01, vec3(0.31, 0.15, 0.16), p.stroke);\n}\n\nvoid make_body(inout vec4 fragColor, Params p, vec2 uv)\n{\n    uv += vec2(-0.045, 0.46);\n    uv = rotate(uv, -0.05);\n    float d = sdTrapezoid(0.14, 0.36, 0.11, uv) - 0.04;\n    \n    uv += vec2(-0.01, 0.1);\n    \n\tfloat dw = sdTrapezoid(0.18, 0.30, 0.11, uv) - 0.04;\n    float _dw = dw;\n    vec2 _uv = uv;\n    \n    float def = uv.y + uv.x * 0.2 - 0.06;\n    uv.y += pow(max(def, 0.), 2.) * 12.0;\n    uv.y += 0.25 - pow(abs(uv.x) * 1.2, 1.4);\n\tfloat d2 = sdUnevenCapsuleY(uv, 0.5, 0.26, 0.9 ) - 0.04;\n    \n    uv = _uv;\n    def = uv.y + (uv.x - 0.1) * 0.2 - 0.06;\n    uv.y += (min(max(uv.y + 0.7, 0.), 0.8) + 0.2) * (0.26 - min(pow(abs(uv.x + uv.y * 0.2 - 0.03) * 1.2, 1.4), 0.26)) * 1.2;\n    \n\tfloat d22 = sdUnevenCapsuleY(uv, 0.5, 0.26, 0.9 ) - 0.04;\n    float dd = max(d, d2);\n    dw = max(dw, d2);\n    dw = max(dw, -d);\n    float _dw_ = dw;\n    dw = max(dw, -min(abs(_uv.x + _uv.y * 0.1 + 0.03) -0.02, 0.1));\n    \n    uv = rotate(_uv, 0.03);\n    float def2 = pow(max(-uv.y + uv.x * 0.075 + 0.06, 0.), 3.1);\n    float k = 1.5;\n    def2 = (1. / (1. + exp(k * def2* 470.0)) - 0.5) / k;\n    uv.x += sign(uv.x) * def2;//min(pow(max(def2, 0.), 2.) * 10.0, 0.23);\n    uv.x += def2 *0.25;\n\tfloat d3 = sdUnevenCapsuleY(uv, 0.5, 0.26, 0.9 ) - 0.04;\n    d3 = min(d3, d2);\n    d3 = max(d3, -d);\n    d3 = max(d3, uv.y - 0.05);\n    \n    float d33 = max(d3, abs(_uv.x - 0.04) - _uv.y * (0.3 + 4.*max(uv.x, 0.))  - 0.55);\n    \n    LayerSM(d2, vec3(0.31, 0.15, 0.16), p.stroke * 2.0, -abs(_uv.x + 0.03) + 0.22);\n    LayerF(d22, vec3(0.48, 0.2, 0.21));\n    LayerS(d3, vec3(0.70, 0.77, 0.87) * 0.9, p.stroke);\n    LayerS(d33, vec3(0.70, 0.77, 0.87) * 0.7, p.stroke);\n    LayerS(_dw_ + 0.005, vec3(0.70, 0.77, 0.87), p.stroke);\n    LayerS(dw, vec3(0.70, 0.77, 0.87), p.stroke);\n}\n\nvoid make_background(inout vec4 c, vec2 uv)\n{\n    float R = 0.6;\n\tvec2 grid;\n    float uv_ys = uv.x / (1.5*R);\n    grid.y = fract(uv_ys);\n    float odd = mod(floor(uv_ys), 2.0);\n    grid.x = fract(uv.y / (SQRT3 * R) - odd*.5) - 0.5;\n    float d =  abs(grid.x);\n    d = mix(1e3, d, grid.y > 1./3.);\n    grid.x = abs(grid.x); \n    float dd1 = abs(dot(grid - vec2(0, 1./3.), normalize(vec2(1./ 3., 0.5))));\n    grid.y = 1.0 - grid.y + 1. + 1./3.; \n    float dd2 = abs(dot(grid - vec2(0, 4./3.), normalize(vec2(1./ 3., 0.5))));\n    d = min(dd1, d);\n    d = min(dd2, d);\n        \n    float anti = fwidth(d) * 1.0;\n    float sig = 0.00005;\n    float hex = 1. - exp(-d*d * 0.5 / sig) * 0.3;//smoothstep(-anti, anti, d - stroke);\n    vec3 bcol = vec3(0.3,0.4, 0.57) * (0.8 + 0.2*uv.y) *(1.1-0.1*length(uv));\n    \n    c = vec4(bcol * (hex * 0.5 + 0.5), 1.0); \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y * 2.0;\n    uv /= 1.4;\n    uv += vec2(0.3, 0.0);\n    \n    Params p;\n\tp.size = min(iResolution.x, iResolution.y);\n    p.pixSize = 1.0 / p.size;\n    p.yaw = 1.;\n    p.lj = 0.3;\n    p.wj = 0.21;\n    p.wc = 0.29;\n    p.th = 0.12;\n    p.trh = 0.15;\n    p.radius = 0.08;\n    p.stroke = p.pixSize * 1.5 + disp(uv, 40.0) * 0.001;\n    p.m = -p.lj + p.th + p.trh * 2. + p.radius / 2.0;\n    \n    make_background(fragColor, uv - vec2(0., 0.5));\n    \n    uv = rotate(uv, 0.13);\n    vec2 uv_nw = uv;\n    uv_nw.x -= 0.09 * p.yaw;\n    uv.x -= 0.1 * p.yaw * (cos(uv.x / 0.35)) * (cos(max(uv.y - p.m, 0.0) / 0.35));\n    \n    make_hair_back(fragColor, p, uv_nw);\n    make_body_shadow(fragColor, p, uv);\n    make_neck(fragColor, p, uv);\n    make_body(fragColor, p, uv);\n    float headd = make_head(fragColor, p, uv);\n    float d = disp(uv, 30.0) * 0.0015 * float(int(iTime * 12.0) % 2 == 0);\n    make_mouth(fragColor, p, uv + d);\n    make_nose(fragColor, p, uv_nw);\n    make_eyebrows(fragColor, p, uv_nw + d);\n    make_hair_shadow(fragColor, p, uv_nw);\n    float olds = p.stroke;\n    p.stroke = p.pixSize * 1.5 + d;\n    make_eyes(fragColor, p, uv_nw + d);\n    p.stroke = olds;\n    make_hair(fragColor, p, uv_nw);\n    make_ears(fragColor, p, uv_nw, headd);\n    make_hair2(fragColor, p, uv_nw);\n    make_band_and_horns(fragColor, p, uv_nw);\n    float n = noise(uv_nw * 200.0);\n    fragColor += n * 0.04;\n}\n", "image_inputs": [], "common_code": "#define SQRT3 1.732050807\n\n// 2D SDF functions from iq: https://iquilezles.org/articles/distfunctions2d\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot3(in vec2 v ) { return dot(v,v) * length(v); }\nfloat dot4(in vec2 v ) { return dot(v,v) * dot(v,v); }\n\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdfCircle(float r, vec2 p )\n{\n    return length(p) - r;\n}\n\nfloat sdEgg(in float ra, in float rb, in vec2 p)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(p) - r :\n            (k*(p.x+r)<p.y) ? length(p - vec2(0,k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nfloat sdParabola(in float k, in vec2 pos)\n{\n    pos.x = abs(pos.x);\n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n    float x = (h>0.0) ? \n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\n\n// unsigned distance to a quadratic bezier\nfloat udBezier(in vec2 A, in vec2 B, in vec2 C, in vec2 pos)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 A, in vec2 B, in vec2 C, in vec2 pos)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cross2(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt( res )*sign(sgn);\n}\n\n\nfloat sdEllipse(in vec2 ab,  in vec2 p)\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n// uneven capsule\nfloat sdUnevenCapsuleY( in vec2 p, in float ra, in float rb, in float h )\n{\n    p.y += h;\n\tp.x = abs(p.x);\n    \n    float b = (ra-rb)/h;\n    vec2  c = vec2(sqrt(1.0-b*b),b);\n    float k = cross2(c,p);\n    float m = dot(c,p);\n    float n = dot(p,p);\n    \n         if( k < 0.0   ) return sqrt(n)               - ra;\n    else if( k > c.x*h ) return sqrt(n+h*h-2.0*h*p.y) - rb;\n                         return m                     - ra;\n}\n\nvec2 opCheapBend(in vec2 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,s,-s,c);\n    return m*p;\n}\n\nfloat disp(vec2 p, float f)\n{\n    float d = 0.0;\n    for (int i = 0; i <4; ++i)\n    {\n \t\td += sin(f*p.x)*sin(f*p.y);\n        p *= 1.9;\n        d *= 2.0;\n    }\n    return d / 16.0;\n}\n\nfloat sdfLine(vec2 p0, vec2 p1, float width, vec2 coord)\n{\n    vec2 dir0 = p1 - p0;\n\tvec2 dir1 = coord - p0;\n\tfloat h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n\treturn (length(dir1 - dir0 * h) - width * 0.5);\n}\n\nfloat sdfTriangleDist(float width, float height, vec2 p)\n{\n    vec2 q = vec2(width, height);\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTriangle(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p)\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTrapezoid(in float r1, float r2, float he, in vec2 p)\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nfloat sdfUnion( const float a, const float b )\n{\n    return min(a, b);\n}\n\nfloat smoothUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat sdfDifference( const float a, const float b)\n{\n    return max(a, -b);\n}\n\nfloat sdfIntersection( const float a, const float b )\n{\n    return max(a, b);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nvec2 rotate(vec2 uv, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 m = mat2(c,s,-s,c);\n    return m * uv;\n}\n\nvec3 shadeDistance(float d) {\n    d *= .5;\n    float dist = d*120.;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 129], [131, 131, 165, 165, 267], [269, 269, 325, 325, 586], [588, 588, 670, 670, 1010], [1012, 1012, 1057, 1057, 1104], [1106, 1106, 1155, 1155, 1210], [1212, 1212, 1258, 1258, 1356], [1358, 1358, 1378, 1378, 2045], [2048, 2048, 2093, 2093, 2149], [2151, 2151, 2172, 2172, 2188], [2190, 2190, 2211, 2211, 2765], [2987, 2987, 3016, 3016, 3743], [4365, 4365, 4423, 4423, 5024], [5027, 5027, 5089, 5089, 5268], [5272, 5272, 5336, 5336, 5537], [5539, 5539, 5596, 5596, 5957], [5959, 5959, 6027, 6027, 6562], [6564, 6564, 6622, 6622, 6855], [6857, 6857, 6924, 6924, 8004], [8006, 8006, 8063, 8063, 8612], [8614, 8614, 8672, 8672, 9055], [9057, 9057, 9114, 9114, 9994], [9996, 9996, 10061, 10061, 11488], [11490, 11490, 11559, 11559, 11997], [11999, 11999, 12056, 12056, 12213], [12215, 12215, 12276, 12276, 12437], [12439, 12439, 12517, 12517, 13367], [13369, 13369, 13439, 13439, 13538], [13540, 13540, 13604, 13604, 13891], [13893, 13893, 13950, 13950, 15651], [15653, 15653, 15698, 15698, 16505], [16507, 16507, 16563, 16563, 18005]], "test": "untested"}
{"id": "3tSfzw", "name": "Bar Circular Equalizer", "author": "Gerard97", "description": "Custom Equalizer", "tags": ["music", "equalizer", "sfx"], "likes": 16, "viewed": 939, "published": 3, "date": "1598555401", "time_retrieved": "2024-07-30T20:48:45.992790", "image_code": "#define PI 3.14159265\n\nfloat rewrap(float r, float rep) {\n    \n    if (r < 0.) {\n        r = -r;\n    }\n    \n    r = mod(r*rep, PI);\n                  \n    return r/(PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x / iResolution.y;\n    \n    vec2 px = gl_FragCoord.xy / iResolution.xy;\n    \n    if (px.x < 0.15 && px.y < 0.15 * ar) {\n        \n        vec4 buffer = texture(iChannel1, px);\n        fragColor = vec4(0,0,buffer.r, 0);\n        return;\n    }\n    \n    const int size = 24;\n                    \n    px.y /= ar;\n    \n    vec2 pos = px-vec2(0.5, 0.5/ar);\n    \n    float len = length(pos);\n    \n\tvec3 color = vec3(0,0,0);\n    \n    float rep = 1.;\n    \n    float delta = rewrap(atan(pos.x, pos.y), rep);\n        \n    float div = 100./float(size);\n    \n    float modifier = sin(iTime*0.1);\n    \n    float index = float(int(mod(iTime*0.+delta+modifier, 1.) * 100. / div));\n    \n\tfloat f = texelFetch(iChannel0, ivec2(index/float(size)*512.,0), 0).x;\n    \n    float base = texelFetch(iChannel0, ivec2(0.*512.,0), 0).x;\n    \n    float cpi = smoothstep((0.1 + base*0.05), 0.15 + f * 0.01, len);\n       \n\tif (len < 0.15 + f * 0.1 && len > (0.1 + base*0.05) && mod(delta + modifier, 1./float(size)) < 0.035 && (delta) > 0.009)\n\t\tcolor = vec3(1.-delta, delta*0.3, delta);\n    \n    color *= cpi;\n    \n    if (len < 0.1 + base * 0.05 && len > 0.09 + base * 0.05)\n      color = vec3(1);\n    \n    float eq = texelFetch(iChannel1, ivec2(px.x*800.,px.y), 0).x;\n        \n    if (abs(px.y*ar-0.54+eq*0.1) < 0.008 && \n        px.x > 0.5-(0.1+base * 0.05-0.01) &&\n        px.x < 0.5+(0.1+base * 0.05-0.01)) {\n        color = vec3(eq,1.-eq,eq*eq);\n    }\n    \n\tfragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23800, "src": "https://soundcloud.com/nocopyrightsounds/jo-cohen-sex-whales-we-are-ncs-rellease", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 px = gl_FragCoord.xy / iResolution.xy;\n    float m = texture(iChannel0, px).r;\n    vec4 p = texture(iChannel1, px);\n    fragColor = vec4(m,p.g + 1., 0. ,1.0);\n    //fragColor = vec4(0,0.0,0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33794, "src": "https://soundcloud.com/nocopyrightsounds/jo-cohen-sex-whales-we-are-ncs-rellease", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 57, 57, 171], [173, 173, 230, 230, 1720]], "test": "untested"}
{"id": "WljBRm", "name": "Reflection of cubemap z", "author": "illus0r", "description": "Reflection of cubemap", "tags": ["cubemapreflectionraymarching"], "likes": 5, "viewed": 326, "published": 3, "date": "1598552984", "time_retrieved": "2024-07-30T20:48:46.740790", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d1+d2)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h); }\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    float spheres = length(p) - 1.5;\n    for(int i = 0; i < 4; i++) {\n        vec3 ps = p;\n        // ps *= 2.;\n        ps += vec3( 1. * sin(iTime * 1.5 + 10. * float(i)), \n                    1. * sin(iTime * 2.5 + 10. * float(i) + 10.), \n                    1. * sin(iTime * 3.5 + 10. * float(i) + 2.) );\n        spheres = opSmoothUnion(spheres, length(ps) - .5, 1.5);\n    }\n    for(int i = 0; i < 4; i++) {\n        vec3 ps = p;\n        // ps *= 2.;\n        ps += vec3( 1. * sin(iTime * 1.7 + 20. * float(i)), \n                    1. * sin(iTime * 2.3 + 20. * float(i) + 10.), \n                    1. * sin(iTime * 3.1 + 20. * float(i) + 2.) );\n        spheres = opSmoothSubtraction(spheres, length(ps) - .5, 1.5);\n    }\n  return vec2(spheres, BLUE);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float minAngleToObstacle = 1e10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        d += distToClosest.x;\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, minAngleToObstacle);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\n\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // ray origin\n    vec3 ro = vec3(5. * sin(iTime * .2), 0, 5. * cos(iTime * .2));\n    float zoom = 1.100;\n\n    // ray direction\n    vec3 rd = getRayDir(uv, ro, vec3(0), 1.);\n\n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n\n    float color_bw = 0.;\n    vec3 colorBg = vec3(.0);\n    vec3 color = texture(iChannel0, rd).xyz;\n    vec3 light = vec3(50, 20, 50);\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \tcolor = vec3( n * 0.5 + 0.5 );\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        color_bw = .5 + .5 * dot(n, normalize(light - p));\n        // drop shadows\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color_bw =  0.;\n        // }\n\n        // smooth shadows\n        float shadow = smoothstep(0.0, .15, rayMarchLight.z / PI);\n        color_bw *= .5 + .5 * shadow;\n\n        // reflection\n        vec3 ref = reflect(rd, n);\n        // hiding sides of reflection on round\n        color += 1. * pow(dot(rd, ref / 2.), 2.);\n\n        // rm = rayMarch(p + ref * 0.1, ref);\n        color += texture(iChannel0, ref).xyz;\n\n\n        // tex *= color_bw;\n        // color = tex;\n    }\n    // color += 0.6 + vec3( color_bw );\n    // // coloring\n    // if (info == IVORY) {\n    //     color *= vec3(0.332,0.400,0.349);\n    // }\n    // else if (info == BLUE) {\n    //     color *= vec3(0.810,0.256,0.397);\n    // }\n    // else if (info == BLACK) {\n    //     color *= vec3(0.130,0.130,0.130);\n    // }\n    //color = mix(color, colorBg, smoothstep(20., 28., d));\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 193, 193, 256], [258, 258, 289, 289, 376], [378, 378, 430, 430, 529], [531, 531, 589, 589, 689], [691, 770, 792, 792, 1547], [1630, 1630, 1663, 1663, 2132], [2134, 2134, 2158, 2158, 2376], [2380, 2380, 2434, 2434, 2661], [2663, 2663, 2713, 2713, 2904], [2907, 2907, 2963, 2963, 5052]], "test": "untested"}
{"id": "3l2fzw", "name": "Polar Weave Pattern - simple 2", "author": "FabriceNeyret2", "description": "golfed variant of [url]https://shadertoy.com/view/wtBfRm[/url]\nreproducing another way the base pattern of [url]https://www.shadertoy.com/view/3ljfR1[/url]\n\n- s: change s = 2Pi / N by any N you like\n- D: without final .5 is nice too", "tags": ["2d", "repetition", "pattern", "polar", "2tweets", "short", "weave"], "likes": 8, "viewed": 277, "published": 3, "date": "1598550461", "time_retrieved": "2024-07-30T20:48:47.597499", "image_code": "// golfed variant of https://shadertoy.com/view/wtBfRm\n// < 2 tweets if no time and injecting r.\n// reproducing another way the base pattern of https://www.shadertoy.com/view/3ljfR1\n\n#define D(S) ( m = r*abs(  sin(s/2.)                        \\\n                          - sqrt( l*l + 1. - 2.*l* cos( S l * cos(a-s/2.) > S cos(s/2.) ? a-s : a ) ) \\\n                        ) -.1,                              \\\n               m = clamp(1.- R.y/4.* m, 0.,1.),             \\\n               m * fract(S.5*A/s) )                        //\n            /* m * ( .2+fract(S A/s) ) ) */                //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = u+u - R;\n    float s = 6.28 / 8., r = .5, m, T,\n          A = atan(U.y,U.x) + iTime/2.,\n          a = mod(A,s),\n          l = length(U) / R.y / r;\n    O += D( );  T = 1.-m;\n    O += D(-) * T;}                                        /*\n\n\n\n\n\n// --- 293 chars\n\n#define D(S) ( m = abs(   sin(s/2.)                    \\\n                        - sqrt( l*l + 1. - 2.*l*cos( S l * cos(a-s/2.) > S cos(s/2.) ? a-s : a ) ) ),  \\\n               m = clamp(1.- R.y/4.* (r*m-.1), 0.,1.), \\\n               T * m * fract(S.5*A/s) )               //\n#define mainImage(O,u)                                 \\\n    vec2  R = iResolution.xy,                          \\\n          U = u+u - R;                                 \\\n    float s = 6.28 / 8., r = .5, m, T = 1.,            \\\n          A = atan(U.y,U.x) + iTime/2.,                \\\n          a = mod(A,s),                                \\\n          l = length(U) / R.y / r;                     \\\n    O += D();  T -= m;                                 \\\n    O += D(-)                                         /*\n\n\n\n\n\n// --- 311 chars\n\n#define D(S) ( U = l *cos( ( S( l * cos(a-s/2.) - r*cos(s/2.) ) > 0.? a-s : a ) + vec2(0,11) ),\\\n               U.x -= r,     m = abs( length(U) - r*sin(s/2.) ), \\\n               m = clamp(1.- R.y/4.* (m-.1), 0.,1.),             \\\n               T * m * fract(S.5*A/s) )                         //\n#define mainImage(O,u)                           \\\n    vec2  R = iResolution.xy,                    \\\n          U = u+u - R;                           \\\n    float s = 6.28 / 8., r = .5, m, T = 1.,      \\\n          A = atan(U.y,U.x) + iTime/2.,          \\\n          a = mod(A,s),                          \\\n          l = length(U) / R.y;                   \\\n    O += D();  T -= m;                           \\\n    O += D(-)                                   /*\n\n\n\n\n\n// --- 324 chars\n\n#define D(c) ( U = l *cos( ( l * cos(a-s/2.) c r*cos(s/2.) ? a-s : a ) + vec2(0,11) ),\\\n               d = abs( length(U-vec2(r,0) ) - r*sin(s/2.) ), \\\n               m = clamp(1.- R.y/4.* (d-.1),0.,1.),           \\\n               T * m * A )                                   //\n#define mainImage(O,u)                           \\\n    vec2  R = iResolution.xy,                    \\\n          U = u+u - R;                           \\\n    float s = 6.28 / 8., r = .5, d, m, T = 1.,   \\\n          A = atan(U.y,U.x) + iTime/2.,          \\\n          a = mod(A,s),                          \\\n          l = length(U) / R.y;                   \\\n    A = fract(.5*A/s);                           \\\n    O += D(>);                                   \\\n    A = 1.-A;  T = 1.-m;                         \\\n    O += D(<)                                   /*\n\n\n\n\n\n// --- 331 chars\n\n#define D(c) ( U = l *cos( a+ ( c ? -s : 0. ) + vec2(0,11) ), \\\n               d = abs( length(U-vec2(r,0)) - r*sin(s/2.) ),  \\\n               m = clamp(1.- R.y/4.* (d-.1),0.,1.),           \\\n               T * m * A )                                   //\n#define mainImage(O,u)                           \\\n    vec2  R = iResolution.xy,                    \\\n          U = u+u - R;                           \\\n    float s = 6.28 / 8., r = .5, d, m, T = 1.,   \\\n          A = atan(U.y,U.x) + iTime/2.,          \\\n          a = mod(A,s),                          \\\n          l = length(U) / R.y,                   \\\n          L = l * cos(a-s/2.) / cos(s/2.);       \\\n    A = fract(.5*A/s);                           \\\n    O += D(L>r);                                 \\\n    A = 1.-A;  T = 1.-m;                         \\\n    O += D(L<r)                                 /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2fzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtjfRw", "name": "Trippy 2 By MareeBree", "author": "mareebree", "description": "trippy", "tags": ["trippy"], "likes": 7, "viewed": 1396, "published": 3, "date": "1598547167", "time_retrieved": "2024-07-30T20:48:48.448224", "image_code": "#define S(x,y,z) smoothstep(x,y,z)\n#define PI (3.1415)\n\n// UTIL FUNCTIONS //////////////////////////////////////\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 inverseColor(vec3 col)\n{\n    return vec3(1.0-col.r,1.0-col.g,1.0-col.b);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float c){\n    vec2 co = vec2(c,c);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat xor(float a,float b)\n{\n    return a*(1.0-b)+b*(1.0-a);\n}\n\nvec3 xor(vec3 a,vec3 b)\n{\n    return vec3(xor(a.x,b.x),xor(a.y,b.y),xor(a.z,b.z));\n}\n\n// -------------b\n// |\t\t\t|\n// |\t\t\t|\n// a-------------\nfloat inRect(vec2 x ,vec2 a, vec2 b)\n{\n    return x.x > a.x && x.x < b.x && x.y > a.y && x.y < b.y ? 1.0 : 0.0;\n}\n\n////////////////////////////////////////\n\n// Wraps uv around tunnel\n// https://www.shadertoy.com/view/4djBRm\nvec2 tunnel(vec2 uv, float size, float time)\n{\n    vec2 p  = -1.0 + (2.0 * uv);\n    float a = atan(p.y, p.x);\n    float r = sqrt(dot(p, p));\n    return vec2(a / PI, time + (size / r));\n}\n\nvec2 rotate(vec2 uv, float angle)\n{\n    uv -= 0.5;\n    mat2 mat = mat2(vec2(cos(angle), sin(angle)),vec2(-sin(angle), cos(angle)));\n    return mat*uv + 0.5;\n}\n\nfloat diamondMask(vec2 uv,float ds,float lb)\n{\n    vec2 iuv = vec2(1.0-uv.x,1.0-uv.y); // inverse uv\n    \n    float db1 = S(0.5+ds,0.5+ds-lb,(iuv.x+uv.y)/2.0);\n    float db2 = S(0.5+ds,0.5+ds-lb,(uv.x+iuv.y)/2.0);\n    float db3 = S(0.5+ds,0.5+ds-lb,(uv.x+uv.y)/2.0);\n    float db4 = S(0.5+ds,0.5+ds-lb,(iuv.x+iuv.y)/2.0);\n    return min(min(min(db1,db2),db3),db4);\n}\n\nfloat shapeMask(vec2 uv,float layer,float t)\n{\n    // Rotation\n    float rotAngle = 3.0*sin(t*0.5 + 2.0*PI*rand(layer));\n    rotAngle = min(PI/2.0,rotAngle);\n    rotAngle = max(0.0,rotAngle);\n    \n    uv = rotate(uv,rotAngle);\n    \n    // Some variables\n   \tfloat lt = 0.1; // line thickness\n    float lt2 = lt/2.0;\n    float lb = 0.01; // line blur\n    \n    // Vertical line\n    float vl = S(0.5-lt2-lb,0.5-lt2,uv.x);\n    vl = min(vl,S(0.5+lt2,0.5+lt2-lb,uv.x));\n    \n    // Horizontal line\n    float lta = lt2; // line thickness with AR\n    float lba = lb;\n    float hl = S(0.5-lta-lba,0.5-lta,uv.y);\n    hl = min(hl,S(0.5+lta,0.5+lta-lba,uv.y));\n    \n    float c = max(hl,vl); // Cross\n    \n    // Center shape\n    float bds = 0.2; // big diamond size\n    float sds = bds-lt; // small diamond size\n    float bd = diamondMask(uv,bds,lb); // Big diamond\n    float sd = diamondMask(uv,sds,lb); // Small diamoind\n    float cs = clamp(bd-sd,0.0,1.0); // center shape\n    \n    float rs = 0.25;//center size\n    vec4 cr = vec4(rs,rs,1.0-rs,1.0-rs);  // center rect (a,b)\n    float inCenter = inRect(uv,cr.xy,cr.zw);\n    \n    float m = mix(c+cs,cs,inCenter);\n    \n    m = clamp(m,0.0,1.0);\n    \n    return m;\n}\n\nvec3 shapeColor(vec2 uv,float t,float layer)\n{\n    vec3 hsv = vec3(rand(layer)+ 0.3*sin(0.1*t),0.7/(layer/2.0),0.8+0.3*sin(t));\n    return hsv2rgb(hsv);\n}\n\nvec3 drawLayer(vec2 uv,vec2 suv,float layer, float opacity,float t)\n{\n    float mask = shapeMask(uv,layer,t);\n    vec3 color = shapeColor(suv*layer,t,layer);\n    return color*mask*opacity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Sound data\n    int tx = int(0.8*512.0);\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x;\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    vec2 suv = fragCoord/iResolution.xy; // screen uv\n\n    \n    vec2 guv = suv;\n    float t = 0.3*iTime;\n   \tguv = rotate(guv,0.5*atan(sin(.5*t),suv.x+suv.y));\n    guv.x += 0.05*sin(0.3*iTime);\n    guv.y += 0.05*cos(0.3*iTime);\n    \n    float dc = sqrt(length(guv-vec2(0.5,0.5))); // distance to center\n    \n    guv = tunnel(guv,0.1*(1.0+sin(t)),0.2*t-0.5*(1.0+sin(t)));\n    \n    vec2 uv = 5.0*guv;\n    vec2 id = floor(uv);\n    uv = fract(uv);\n    \n    vec3 col = vec3(0.0);\n    \n    \n    for(float i=1.0;i<=4.0;i++)\n    {\n        vec2 layerUV = fract(uv + rand(i));\n        layerUV = fract(layerUV+0.1*iTime*rand(i));\n        //col = xor(col,inverseColor(col)*drawLayer(layerUV,suv,i,2.0/i,iTime));\n        col += inverseColor(col)*drawLayer(layerUV,suv,i,2.0/i,iTime);\n    }\n\t\n    vec3 icol = inverseColor(col);\n    float bgMask = S(0.8,0.85,max(max(icol.r,icol.g),icol.b));\n   \tvec3 bgColor = hsv2rgb(vec3(0.7+0.2*sin(t*0.1 + 0.1*wave),0.9,0.8));\n    \n    \n    float fadeEffect = (1.0+sin(0.2*t))/2.0;\n    fadeEffect = min(3.0*fadeEffect,1.0);\n    \n    float distanceShadow = clamp(2.0*dc,0.0,1.0);\n    col = mix(bgMask*bgColor,bgMask*bgColor+col,fadeEffect)*distanceShadow;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23808, "src": "https://soundcloud.com/rainbowtripmusic/psychedelicmushroomstripexperience", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 252, 274, 274, 443], [445, 445, 474, 474, 524], [526, 526, 546, 546, 618], [620, 620, 640, 640, 737], [739, 739, 767, 767, 801], [803, 803, 828, 828, 887], [889, 943, 981, 981, 1056], [1100, 1167, 1213, 1213, 1353], [1355, 1355, 1390, 1390, 1513], [1515, 1515, 1561, 1561, 1881], [1883, 1883, 1929, 1945, 3088], [3090, 3090, 3136, 3136, 3244], [3246, 3246, 3315, 3315, 3436], [3438, 3438, 3495, 3513, 4880]], "test": "untested"}
{"id": "wtBfRm", "name": "Polar Weave Pattern - simple", "author": "FabriceNeyret2", "description": "reproducing another way the base pattern of [url]https://www.shadertoy.com/view/3ljfR1[/url]\n\nchange s = 2Pi / N by any N you like\n\n( golfed here: [url]https://www.shadertoy.com/view/3l2fzw [/url] )", "tags": ["2d", "repetition", "pattern", "polar", "short", "weave"], "likes": 18, "viewed": 393, "published": 3, "date": "1598545718", "time_retrieved": "2024-07-30T20:48:49.197222", "image_code": "// reproducing another way the base pattern of https://www.shadertoy.com/view/3ljfR1\n\n#define D U = l *cos(a + vec2(0,11)) ;                                         \\\n          d = abs( length(U-vec2(r,0)) - r*sin(s/2.)); /* dist in ribbon    */ \\\n          m = clamp(1.- R.y/4.* (d-.1),0.,1.);         /* antialiased mask  */ \\\n          O += T * m * min( 1.+.5*cos(2e2*d), 1.);     /* pattern in ribbon */ \\\n       /*        *( .7 + .3* cos(atan(U.y,U.x-r)) );    */                     \\\n          T *=   1.-m                                  /* for blending      */\n              \nvoid mainImage( out vec4 O,  vec2 u )\n{\n    O -= O;\n    vec2  R = iResolution.xy,\n          U = 2.*u - R;\n    float s = 6.28/8., r=.5, d, m, T = 1.,\n          a = mod( atan(U.y,U.x) + iTime/2. , s ), // wrap all to main 1/8 pie slice\n          l = length(U) / R.y,                     // \n          L = l * cos(a-s/2.) / cos(s/2.);         // line between 2 disks center\n                \n    a -= L > r ? s : 0.;               // at crossing, decide which pie win (i.e. is on top)\n    D;                                 // draw ribbon \n\n    a += L > r ? s : -s;               // same for background slice\n    D;\n // O.b += float(L<r);  O.r -= M;      // for debug\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 585, 624, 624, 1251]], "test": "untested"}
{"id": "wlBfzm", "name": "Voodoo Academy - Weaving bones", "author": "xenn", "description": "propagation duration will vary. give it time", "tags": ["particles", "ca"], "likes": 18, "viewed": 487, "published": 3, "date": "1598539801", "time_retrieved": "2024-07-30T20:48:49.952203", "image_code": "// Fork of \"Voodoo Academy - Weaving bones\" by xenn. https://shadertoy.com/view/Wtlfzl\n// 2020-08-27 14:46:25\n\n// Fork of \"My virtual slime molds\" by michael0884. https://shadertoy.com/view/WtBcDG\n// 2020-07-24 21:29:48\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.7, 0.7);\n    vec3 col1 = vec3(0., 0.92, 1.);\n    // Output to screen\n    col.xyz += 0.1*a;\n    col.xyz += 0.5 - 0.5*cos(0.251*010.0*vec3(0.36131*sin(iTime*0.51),0.22+cos(iTime*0.61),0.1606+cos(iTime*(0.51)))*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5)));\n    col.w=1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 002.5\n\n#define fluid_rho 0.02\n\n\n//mold stuff \n#define sense_ang 0.24687326\n#define sense_dis 150.5*cos(time*0.41)*0.01+6.\n#define sense_force 00.274352\n#define trailing 01000.0*sin(time*02.0141)\n#define acceleration 0.01\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 0.5*rho.x + 0.*rho.y; //gas\n    return 0.052*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 01.10\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= sin(0.0000*P.M.x*vec2(0,1));\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.01*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 249, 249, 427], [429, 429, 465, 465, 515], [517, 517, 533, 533, 561], [563, 563, 608, 608, 1781]], "test": "untested"}
{"id": "3tBfRw", "name": "vertex color interp vs bilinear", "author": "danielsturk", "description": "Difference between bilinear interpolation of color and the effect you get from vertex colors with a triangulated quad", "tags": ["filtering"], "likes": 0, "viewed": 187, "published": 3, "date": "1598535191", "time_retrieved": "2024-07-30T20:48:50.822875", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 x0y0 = vec3(1,0,0);\n    vec3 x1y0 = vec3(0,1,0);\n    vec3 x0y1 = vec3(0,0,1);\n    vec3 x1y1 = vec3(.5,.5,.5);\n    \n    vec3 x0 = mix(x0y0, x0y1, uv.y);\n    vec3 x1 = mix(x1y0, x1y1, uv.y);\n    vec3 bilinear = mix(x0, x1, uv.x);\n    \n    vec3 triangular;\n    if(uv.x + uv.y < 1.) {\n    \ttriangular = x0y1 * uv.y + x1y0 * uv.x + x0y0 * (1. - uv.x - uv.y);\n    } else {\n    \ttriangular = x1y0 * (1. - uv.y) + x0y1 * (1. - uv.x) + x1y1 * (uv.x + uv.y - 1.);\n    }\n\n    fragColor = vec4(fract(iTime) < .5 ? bilinear : triangular,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 639]], "test": "untested"}
{"id": "wlBBRm", "name": "Lit Cell", "author": "dr2", "description": "Seeking illumination", "tags": ["shadow", "light"], "likes": 15, "viewed": 358, "published": 3, "date": "1598528184", "time_retrieved": "2024-07-30T20:48:51.645675", "image_code": "// \"Lit Cell\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noiseff (float p);\nfloat Hashfv3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nfloat tCur, dstFar, wRad, bFac;\nint idObj;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec2 SphGrid (vec3 p)\n{\n  vec3 q;\n  vec2 a, sc, nSeg;\n  float dMin, d1, d2, r;\n  nSeg = vec2 (21., 23.);\n  sc = sin (0.07 * 2. * pi / nSeg + vec2 (0., 0.5 * pi));\n  q = p.yxz;\n  q.yz = Rot2D (q.yz, 0.1 * tCur);\n  r = length (q.yz);\n  a = 2. * pi * (floor (nSeg * atan (q.zx, - vec2 (q.y, r)) / (2. * pi)) + 0.5) / nSeg;\n  q.yz = Rot2D (q.yz, a.x);\n  d1 = dot (vec2 (q.y, abs (q.z)), sc);\n  q.yz = Rot2D (vec2 (r, q.x), a.y);\n  d2 = dot (vec2 (q.y, abs (q.z)), sc);\n  return vec2 (d1, d2);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 d2;\n  float dMin, d, wThk;\n  dMin = dstFar;\n  wThk = 0.15;\n  d2 = SphGrid (p);\n  d = SmoothMin (d2.x, d2.y, 0.02);\n  d = SmoothMax (abs (PrSphDf (p, wRad)) - wThk, d, 0.02);\n  DMIN (1);\n  d = PrSphDf (p, 0.15 * wRad);\n  DMIN (2);\n  q = p;\n  q.xz = abs (q.xz) - 15.;\n  q.y -= -9.;\n  d = PrSphDf (q, 1.);\n  DMIN (3);\n  d = abs (PrBoxDf (p, vec3 (16., 10., 16.) + 0.1)) - 0.1;\n  DMIN (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SphGridShad (vec3 p)\n{\n  vec2 d2;\n  d2 = SphGrid (p);\n  return SmoothMin (d2.x, d2.y, 0.01);\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 sp, ss;\n  if (2. * floor (0.5 * floor (p.y)) != floor (p.y)) p.x += 0.5;\n  sp = smoothstep (0.03, 0.07, abs (fract (p + 0.5) - 0.5));\n  p = fract (p) - 0.5;\n  ss = 0.3 * smoothstep (0.4, 0.5, abs (p.xy)) * sign (p.xy);\n  if (abs (p.x) < abs (p.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, sp.x * sp.y, ss.y);\n}\n\nvec4 ShStagGrid3d (vec3 p, vec3 vn)\n{\n  vec3 rg;\n  if (abs (vn.x) > 0.99) {\n    rg = ShStagGrid (p.zy);\n    rg.xz *= sign (vn.x);\n    if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n    else vn.xz = Rot2D (vn.xz, rg.x);\n  } else if (abs (vn.y) > 0.99) {\n    rg = ShStagGrid (p.zx);\n    rg.xz *= sign (vn.y);\n    if (rg.x == 0.) vn.yx = Rot2D (vn.yx, rg.z);\n    else vn.yz = Rot2D (vn.yz, rg.x);\n  } else if (abs (vn.z) > 0.99) {\n    rg = ShStagGrid (p.xy);\n    rg.xz *= sign (vn.z);\n    if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n    else vn.zx = Rot2D (vn.zx, rg.x);\n  }\n  return vec4 (vn, rg.y);\n}\n\nvec4 BallHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, rg4, db4;\n  vec3 col, vn, roo, ltDir;\n  float dstObj, nDotL, cFac;\n  roo = ro;\n  wRad = 2.;\n  bFac = 0.96 + 0.04 * Noiseff (32. * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    ltDir = - normalize (ro);\n    if (idObj == 1) col4 = vec4 (0.8, 0.7, 0.6, 0.2);\n    else if (idObj == 2) col4 = vec4 (vec3 (1., 1., 0.7) * bFac, -1.);\n    else if (idObj == 3) col4 = vec4 (vec3 (0.8, 0.8, 0.8) * bFac, 0.1);\n    else if (idObj == 4) {\n      col4 = vec4 (0.3, 0.3, 0.3, 0.05);\n      rg4 = ShStagGrid3d (0.5 * ro, vn);\n      vn = rg4.xyz;\n      col4.rgb *= 0.9 + 0.1 * rg4.w;\n      if (rg4.w == 1. && min (abs (ro.x), abs (ro.z)) > 15.9) col4.rgb *= 0.7;\n      vn = VaryNf (8. * ro, vn, 1.);\n    }\n    if (idObj == 3 || idObj == 4) col4 *= 0.8 + 0.2 * step (0.001, SphGridShad (ltDir));\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, ltDir), 0.);\n      col = bFac * (col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * nDotL * nDotL) +\n         col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n    } else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n  }\n  cFac = (idObj == 1 || idObj == 2) ? 0.02 : 0.06;\n  for (float r = float (VAR_ZERO); r <= 14.; r ++) {\n    db4 = BallHit (roo, rd, wRad + 0.2 * (14. - r + Hashfv3 (rd + 2. * tCur)));\n    vn = db4.yzw;\n    vn = VaryNf (64. * vn, vn, 0.3);\n    if (db4.x < dstFar) col = mix (col, bFac * vec3 (1., 1., 0.8),\n       cFac * step (0.001, SphGridShad (vn)));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, sr, asp;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.01 * pi * tCur;\n    el -= 0.08 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -9.);\n  zmFac = 2.;\n  dstFar = 60.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBRm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[591, 591, 614, 614, 1081], [1083, 1083, 1105, 1105, 1525], [1527, 1527, 1560, 1560, 1744], [1746, 1746, 1767, 1767, 2022], [2024, 2024, 2052, 2052, 2124], [2126, 2126, 2152, 2152, 2479], [2481, 2481, 2518, 2518, 3079], [3081, 3081, 3125, 3125, 3326], [3328, 3328, 3363, 3363, 4900], [4944, 4944, 5000, 5000, 6133], [6135, 6135, 6167, 6167, 6267], [6269, 6269, 6302, 6302, 6329], [6331, 6331, 6376, 6376, 6479], [6481, 6481, 6526, 6526, 6564], [6566, 6566, 6602, 6602, 6808], [6810, 6810, 6840, 6840, 6953], [6987, 6987, 7011, 7011, 7076], [7078, 7078, 7102, 7102, 7155], [7157, 7157, 7181, 7181, 7293], [7295, 7295, 7320, 7320, 7466], [7468, 7468, 7493, 7493, 7679], [7681, 7681, 7710, 7710, 7922], [7924, 7924, 7963, 7963, 8143]], "test": "untested"}
{"id": "3tSBR1", "name": "Cave exploration WASD+Arrow Keys", "author": "vipiao", "description": "Explore the caves. Use W, A, S, D, LSHIFT, SPACE keys to move. Press arrow keys to rotate the camera. To increase/decrease the speed, hold the C/V buttons. The mouse can also be used to rotate. Click and drag to change the camera orientation.", "tags": ["procedural", "3d", "raymarching", "terrain", "cave", "generation"], "likes": 8, "viewed": 928, "published": 3, "date": "1598499573", "time_retrieved": "2024-07-30T20:48:52.591147", "image_code": "\nGET_CUBE_SIZE\n\nfloat DEBUG_MARKER = 0.;\nbool DEBUG_BOOL = false;\nbool DEBUG_CALLING_NORMAL = false;\nvec3 DEBUG_COLOR_MARKER = vec3(-1);\n\nfloat getDensityBufB(vec3 pos){\n    int cubeSize = getCubeSize();\n    \n    vec3 mPos = mod(pos, float(cubeSize));\n    \n    ivec3 iMPos = ivec3(mPos);\n    int flatCoord = iMPos.x + iMPos.y * cubeSize + iMPos.z * cubeSize * cubeSize;\n    ivec2 twoDCoord = ivec2(flatCoord % int(iResolution.x), flatCoord / int(iResolution.x));\n    \n    vec4 samp = texelFetch(iChannel1, twoDCoord, 0);\n    \n    float s000, s100, s010, s110, s001, s101, s011, s111;\n    \n    /* Unpack data.*/\n    unPack(samp.x, s000, s100);\n    unPack(samp.y, s010, s110);\n    unPack(samp.z, s001, s101);\n    unPack(samp.w, s011, s111);\n    float shift = 0.;\n    s000 -= 0.5+shift; s100 -= 0.5+shift; s010 -= 0.5+shift; s110 -= 0.5+shift;\n    s001 -= 0.5+shift; s101 -= 0.5+shift; s011 -= 0.5+shift; s111 -= 0.5+shift;\n    \n    vec3 frac = fract(mPos);\n    float h = mix(\n    \tmix( /* x=0*/\n        \tmix(s000, s001, frac.z), /* x=0, y=0, z=[0,1]*/\n        \tmix(s010, s011, frac.z), /* x=0, y=1, z=[0,1]*/\n            frac.y\n        ),\n    \tmix(/* x=1*/\n        \tmix(s100, s101, frac.z), /* x=1, y=0, z=[0,1]*/\n        \tmix(s110, s111, frac.z), /* x=1, y=1, z=[0,1]*/\n            frac.y\n        ),\n        frac.x\n    );\n    \n    return h;\n}\nfloat getDensityBufC(vec3 pos){\n    int cubeSize = getCubeSize();\n    \n    vec3 mPos = mod(pos, float(cubeSize));\n    \n    ivec3 iMPos = ivec3(mPos);\n    int flatCoord = iMPos.x + iMPos.y * cubeSize + iMPos.z * cubeSize * cubeSize;\n    ivec2 twoDCoord = ivec2(flatCoord % int(iResolution.x), flatCoord / int(iResolution.x));\n    \n    vec4 samp = texelFetch(iChannel2, twoDCoord, 0);\n    \n    float s000, s100, s010, s110, s001, s101, s011, s111;\n    \n    /* Unpack data.*/\n    unPack(samp.x, s000, s100);\n    unPack(samp.y, s010, s110);\n    unPack(samp.z, s001, s101);\n    unPack(samp.w, s011, s111);\n    float shift = 0.;\n    s000 -= 0.5+shift; s100 -= 0.5+shift; s010 -= 0.5+shift; s110 -= 0.5+shift;\n    s001 -= 0.5+shift; s101 -= 0.5+shift; s011 -= 0.5+shift; s111 -= 0.5+shift;\n    \n    vec3 frac = fract(mPos);\n    float h = mix(\n    \tmix( /* x=0*/\n        \tmix(s000, s001, frac.z), /* x=0, y=0, z=[0,1]*/\n        \tmix(s010, s011, frac.z), /* x=0, y=1, z=[0,1]*/\n            frac.y\n        ),\n    \tmix(/* x=1*/\n        \tmix(s100, s101, frac.z), /* x=1, y=0, z=[0,1]*/\n        \tmix(s110, s111, frac.z), /* x=1, y=1, z=[0,1]*/\n            frac.y\n        ),\n        frac.x\n    );\n    \n    return h;\n}\nfloat getLayeredDensityBufC(vec3 pos, float resolution){\n    int numIte = int(ceil(resolution));\n    float scale = 1.;\n    float density = 0.;\n    for(int i=0;i<numIte;i++){\n        //if(threshold - density > scale*0.05){\n        //\tbreak;\n        //}\n        float factor = min(resolution - float(i), 1.);\n        float d = getDensityBufC(pos * scale);\n        d = d/scale * factor;\n    \tdensity += d;\n        scale *= 8.;\n    }\n    return density;\n}\n\n// Cave sd.\nfloat sdCave(in vec3 pos, float resolution){\n    float density = getDensityBufB(pos);\n    const float caveWidth = 0.02;\n    float nextDist = density - caveWidth;\n    \n    /* Add noise.*/\n    if(abs(nextDist)-0.002 < 0.006){\n    \tfloat noise = getLayeredDensityBufC(pos*16., resolution);\n    \tnextDist += noise*0.01;\n    }\n    \n    nextDist = abs(nextDist)-0.002;\n    \n    return nextDist*20.;\n}\nvoid sdCaveNormal(in vec3 pos, float diff, float resolution, inout vec3 normal, inout float sd){\n    DEBUG_CALLING_NORMAL = true;\n\tsd = sdCave(pos, resolution);\n    vec2 e = vec2(diff, 0.);\n    normal = normalize(sd - vec3(\n    \tsdCave(pos - e.xyy, resolution),\n    \tsdCave(pos - e.yxy, resolution),\n    \tsdCave(pos - e.yyx, resolution)\n    ));\n    DEBUG_CALLING_NORMAL = false;\n}\n\n// Cave gradient.\nfloat sdCaveGradient(in vec3 pos){\n    float density = getDensityBufB(pos);\n    float nextDist = density;\n    \n    return nextDist;\n}\nvoid sdCaveGradientNormal(in vec3 pos, float diff, inout vec3 normal, inout float sd){\n    DEBUG_CALLING_NORMAL = true;\n\tsd = sdCaveGradient(pos);\n    vec2 e = vec2(diff, 0.);\n    normal = normalize(sd - vec3(\n    \tsdCaveGradient(pos - e.xyy),\n    \tsdCaveGradient(pos - e.yxy),\n    \tsdCaveGradient(pos - e.yyx)\n    ));\n    DEBUG_CALLING_NORMAL = false;\n}\n\n// March\n# define INTERSECTED 0\n# define TOO_FAR 1\n# define TOO_MANY_STEPS 2\nvoid marchWorld(\n    inout vec3 pos, inout vec3 dir,\n    out float dist, in float maxDist, in float minDist,\n    out int numSteps, in int maxNumSteps,\n    out vec4 color, out vec3 normal, out int returnCode\n){\n    dist = 0.;\n    float prevDist = dist;\n    numSteps = 0;\n    color = vec4(0);\n    vec3 prevPos = pos;\n    float prevSd;\n    float sd = 0.;\n    \n    //\n    const float res = 2.;\n    \n    // Trace.\n    for(int i=0; i<maxNumSteps; i++) {\n        //\n        numSteps++;\n        \n        // Calc sd.\n        prevSd = sd;\n        \n        //float sdSphere = sdSphere(/*in vec3 pos=*/pos, /*in vec3 center=*/vec3(0), /*in float radius=*/1.);\n        //float sdDensity = sdDensity(/*in vec3 pos=*/pos, /*in float resolution=*/res);\n        float sdCave = sdCave(/*in vec3 pos=*/pos, /*in float resolution=*/res);\n\n        //sd = sdDensity;\n        sd = sdCave;\n        \n        if(dist + sd > maxDist){\n        \tsd = maxDist-dist;\n            dist += sd;\n            pos += dir*sd;\n            \n            color = vec4(0);\n            normal = vec3(0);\n            \n            returnCode = TOO_FAR;\n        \treturn;\n        }\n        if(sd <= minDist + dist*0.001){\n            \n            //if(i==2) DEBUG_MARKER = 1.;\n            //if(sd < 0.0) DEBUG_MARKER = 1.;\n            \n            // Linearly interpolate position.\n            float fac = (minDist + dist*0.001 - sd) / (prevSd - sd);\n            pos = mix(pos, prevPos, fac);\n            \n            //sdDensityNormal(\n            //    /*in vec3 pos=*/pos, /*float diff=*/max(dist*3./iResolution.x, 0.002), /*float resolution=*/res+1.,\n            //    /*inout vec3 normal=*/normal, /*inout float sd=*/sd\n            //);\n            sdCaveNormal(\n                /*in vec3 pos=*/pos, /*float diff=*/max(dist*3./iResolution.x, 0.002), /*float resolution=*/res+0.5,\n                /*inout vec3 normal=*/normal, /*inout float sd=*/sd\n            );\n            \n            color = vec4(155., 155., 154., 0.)/255.;\n            \n            float f = clamp(getLayeredDensityBufC(pos*5., 1.)*20.-5., 0., 1.);\n            color = mix(color, vec4(255, 215, 0, 32)/255., f);\n            //color = mix(color, vec4(100, 255, 0, 92)/255., f);\n            \n            vec3 towardsMiddle;\n            float sdTowardsMiddle;\n            //sdCaveCenterNormal(pos, 0.004, /*out vec3 normal=*/towardsMiddle, /*inout float sd=*/sd);\n            sdCaveGradientNormal(\n                /*in vec3 pos=*/pos, /*float diff=*/0.1,\n                /*inout vec3 normal=*/towardsMiddle, /*inout float sd=*/sdTowardsMiddle\n            );\n            towardsMiddle = normalize(-towardsMiddle);\n            float grassFactor = min(pow(dot(towardsMiddle, normal)+0.1, 8.), 1.);\n            color = mix(color, vec4(146., 116., 32., 0)/255., grassFactor);\n            \n            //float noise = getLayeredDensityBufC(pos, 1.);\n            //color.r += noise*1.;\n\n            returnCode = INTERSECTED;\n            return;\n            \n            //if(sd < 0.){\n            //\tcolor = vec3(1,0,0);\n            //}\n            \n            //color=vec3(1,1,0);\n\n            \n        }\n        \n        //\n        prevDist = dist;\n        dist += sd;\n        prevPos = pos;\n        pos += dir*sd;\n       \t\n    }\n    returnCode = TOO_MANY_STEPS;\n    return;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    vec3 forward = normalize(texelFetch(iChannel0, ivec2(CAMERA_DIRECTION_FORWARD, 0), 0).xyz);\n    vec3 right = normalize(texelFetch(iChannel0, ivec2(CAMERA_DIRECTION_RIGHT, 0), 0).xyz);\n    vec3 up = cross(right, forward);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 camPos = vec3(cameraPos.x, cameraPos.y, cameraPos.z);\n    vec3 viewDir = normalize(forward*0.3 + right * uv.x + up * uv.y);\n    \n    // Light cone.\n    float coneFactor = max(pow(min(dot(viewDir, forward) + 0.15, 1.), 16.), 0.);\n    coneFactor = (coneFactor*0.6 + 0.4);\n    \n    //\n    vec3 pos = camPos;\n    vec3 dir = viewDir;\n    float dist = 0.;\n    float maxDist = 50.;\n    float minDist = 0.002;\n    int numSteps;\n    int maxNumSteps = int(75. * coneFactor);\n    vec4 color;\n    vec3 normal;\n    int returnCode;\n    marchWorld(\n        /*inout vec3 pos=*/pos, /*inout vec3 dir=*/dir,\n        /*out float dist=*/dist, /*in float maxDist=*/maxDist, /*in float minDist=*/minDist,\n        /*out int numSteps=*/numSteps, /*in int maxNumSteps=*/maxNumSteps,\n        /*out vec3 color=*/color, /*out vec3 normal=*/normal, /*out int returnCode=*/returnCode\n    );\n    \n    //vec3 lightDir = normalize(vec3(5.,-1,3.));\n    vec3 lightDir = viewDir;\n    \n    // Ambient occlusion.\n    vec3 occlusionColor = vec3(0.,0.,0.);\n    float occlusionFactor = float(numSteps)/log(dist+10.) * max(dot(-viewDir, normal), 0.);\n    occlusionFactor = max(1.-occlusionFactor*0.025, 0.);\n    \n    float diff = max(dot(-lightDir, normal), 0.)*0.75;\n    \n    vec3 reflectDir = reflect(lightDir, normal); // reflect(I, N) = I - 2.0 * dot(N, I) * N.\n    float spec = pow(max(dot(reflectDir, -viewDir), 0.0), 8.) * 0.25;\n    \n    float ambient = 0.125*occlusionFactor;\n    \n    color = mix(\n        (color*diff + color*spec)*coneFactor + color*ambient,\n        color, color.w\n    );\n    \n    // Mist.\n    //vec3 mistColor = vec3(0.5,0.6,0.9);\n    vec4 mistColor = vec4(0., 0., 0., 0);\n    float mistFactor = max(float(numSteps)/float(maxNumSteps), float(dist)/float(maxDist));\n    mistFactor = pow(mistFactor, 1.);\n    color = mix(color, mistColor, mistFactor);\n    \n    // The sun.\n    float d = dist/maxDist * 2.*max(mistFactor*mistFactor*mistFactor-0.5, 0.)*min(pow(max(dot(dir, -lightDir), 0.), 1024.), 1.);\n    color = min(color + vec4(d), 1.);\n    \n    //color.r = float(numSteps);\n    //if(numSteps == 3){\n    //\tcolor.r = 1.;\n    //}\n    //color.r += DEBUG_MARKER;\n    if(DEBUG_COLOR_MARKER != vec3(-1)){\n    \t//color += DEBUG_COLOR_MARKER;\n    }\n    \n    // Output to screen\n    fragColor = vec4(color.xyz,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//#define iResolution vec3(640,370,1) \n\n// Math.\n# define PI 3.1415926538\n\n// Input.\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_SPACE  = 32;\nconst int KEY_W  = 87;\nconst int KEY_A = 65;\nconst int KEY_S  = 83;\nconst int KEY_D  = 68;\nconst int KEY_C  = 67;\nconst int KEY_V  = 86;\nconst int KEY_Q  = 81;\nconst int KEY_E  = 69;\nconst int KEY_R  = 82;\nconst int KEY_1  = 49;\nconst int KEY_2  = 50;\nconst int KEY_3  = 51;\n\n# define MAP_WIDTH 30.\nconst int CAMERA_POS = 0;\nconst int CAMERA_SENSITIVITY = 1;\nconst int CAMERA_DIRECTION_FORWARD = 2;\nconst int CAMERA_DIRECTION_RIGHT = 3;\nconst int CHANGE_SEED = 4;\nconst int SCREEN_RESOLUTION = 5;\nconst int DO_BUFFER_UPDATE = 6;\nconst int MOVEMENT_MODE = 7;\nconst int MOUSE_TEMP = 8;\nconst int MOUSE_PREVIOUS = 9;\n\nconst int MOVEMENT_MODE_AUTO = 0;\nconst int MOVEMENT_MODE_FREE = 1;\n    \n// Auto parameters.\n# define AUTO_MOVEMENT_SPEED 0.04\n# define START_TIME 40.\n\n//\n# define ALTERNATIVE_CAVE\n\n//\nfloat sigmoid(float x) { return 2./(1. + exp(-x)) - 1.; }\n\n// --Hash function--\n/*\nInspired by Adam Smith.\nsource: https://groups.google.com/forum/#!msg/proceduralcontent/AuvxuA1xqmE/T8t88r2rfUcJ\n*/\n# define PRECISION 3\n// 2^32-1\n# define LARGEST_UINT 4294967295u\n# define LARGEST_UINT_AS_FLOAT 4294967295.\n// 2^31-1 = 2147483647\n# define LARGEST_INT 2147483647\n# define LARGEST_INT_AS_FLOAT 2147483647.\n# define SMALLEST_INT -2147483648\n# define SMALLEST_INT_AS_FLOAT -2147483648.\n// 2^32 = 4294967296\n# define LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT 4294967296.\n\nint rotate (int x, int b) {\n    return (x << b) ^ (x >> (32-b));\n}\n\nint pcg (int a) {\n    int b = a;\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d), 5);\n    }\n    return a^b;\n}\n\nfloat pcgUnit (int a) {\n    return (float(pcg(a))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\nint pcg (int a, int b) {\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d), 5);\n    }\n    return a^b;\n}\n\nfloat pcgUnit (int a, int b) {\n    return (float(pcg(a,b))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\nint pcg (int a, int b, int c) {\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c) + (c^0xcabba6e5), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d) + (c^0x0b5e55ed), 5);\n        c = rotate((a^0x5eaf00d5) + (b^0xdecea5ed) + (c^0xba5eba11), 16);\n    }\n    // https://www.dcode.fr/words-containing\n    return a^b^c;\n}\n\nfloat pcgUnit (int a, int b, int c) {\n    return (float(pcg(a,b,c))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\n// --Noise functions--\nfloat boxNoise(vec3 pos, int seed){\n\tivec3 ind = ivec3(floor(pos));\n    \n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    //return mix(mix(mix( pcgUnit(ind.x+0, ind.y+0, ind.z+0), pcgUnit(ind.x+1, ind.y+0, ind.z+0), u.x),\n    //               mix( pcgUnit(ind.x+0, ind.y+1, ind.z+0), pcgUnit(ind.x+1, ind.y+1, ind.z+0), u.x), u.y),\n    //           mix(mix( pcgUnit(ind.x+0, ind.y+0, ind.z+1), pcgUnit(ind.x+1, ind.y+0, ind.z+1), u.x),\n    //               mix( pcgUnit(ind.x+0, ind.y+1, ind.z+1), pcgUnit(ind.x+1, ind.y+1, ind.z+1), u.x), u.y), u.z);\n    \n    // Optimized version.\n    // 15485863 and 179424673 are primes.\n    ivec2 yS = ivec2(ind.y*15485863, (ind.y+1)*15485863);\n    ivec2 zS = ivec2(ind.z*179424673, (ind.z+1)*179424673);\n    return mix(mix(mix( pcgUnit(ind.x + yS.x + zS.x, seed), pcgUnit(ind.x+1 + yS.x + zS.x, seed), u.x),\n                   mix( pcgUnit(ind.x + yS.y + zS.x, seed), pcgUnit(ind.x+1 + yS.y + zS.x, seed), u.x), u.y),\n               mix(mix( pcgUnit(ind.x + yS.x + zS.y, seed), pcgUnit(ind.x+1 + yS.x + zS.y, seed), u.x),\n                   mix( pcgUnit(ind.x + yS.y + zS.y, seed), pcgUnit(ind.x+1 + yS.y + zS.y, seed), u.x), u.y), u.z);\n}\nfloat boxNoise(vec3 pos){\n    return boxNoise(pos, 0);\n}\n\nfloat layeredBoxNoise(vec3 pos, int numLayers, int seed){\n    seed = pcg(seed);\n\tfloat result = 0.;\n    float scale = 1.;\n    float denominator = 0.;\n    for (int i = 0; i < numLayers; i++) {\n        result += scale * boxNoise(pos, ++seed);\n        denominator += scale;\n        pos *= 2.;\n        pos += PI*0.;\n        scale *= 0.5;\n    }\n    return result/denominator;\n}\n\nfloat perlinNoise(vec3 pos, int seed, int tileSize){\n    ivec3 ind = ivec3(floor(pos));\n    \n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    f = f;\n    \n    // 2038074743 and 179424673 are primes.\n    //ivec2 yS = ivec2(ind.y*15485863, (ind.y+1)*15485863);\n    //ivec2 zS = ivec2(ind.z*179424673, (ind.z+1)*179424673);\n    // 7907 and 7919 are primes.\n    ivec3 modInd = ivec3(mod(vec3(ind), float(tileSize)));\n    ivec3 modIndP = ivec3(mod(vec3(ind+1), float(tileSize)));\n    modInd.y *= 7907;\n    modIndP.y *= 7907;\n    modInd.z *= 7919;\n    modIndP.z *= 7919;\n    \n    float nf = 2./float(0x3ff);\n    \n    int x0y0z0H = pcg(modInd.x + modInd.y + modInd.z, seed);\n    float x0y0z0 = dot(\n        vec3(\n            (float(0x000003ff & x0y0z0H)*nf-1.),\n            (float((0x000ffc00 & x0y0z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y0z0H) >> 20)*nf-1.)\n        ),\n        f\n    );\n    \n    int x1y0z0H = pcg(modIndP.x + modInd.y + modInd.z, seed);\n    float x1y0z0 = dot(\n        vec3(\n            (float(0x000003ff & x1y0z0H)*nf-1.),\n            (float((0x000ffc00 & x1y0z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y0z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y, f.z)\n    );\n    \n    int x0y1z0H = pcg(modInd.x + modIndP.y + modInd.z, seed);\n    float x0y1z0 = dot(\n        vec3(\n            (float(0x000003ff & x0y1z0H)*nf-1.),\n            (float((0x000ffc00 & x0y1z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y1z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y-1., f.z)\n    );\n    \n    int x1y1z0H = pcg(modIndP.x + modIndP.y + modInd.z, seed);\n    float x1y1z0 = dot(\n        vec3(\n            (float(0x000003ff & x1y1z0H)*nf-1.),\n            (float((0x000ffc00 & x1y1z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y1z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y-1., f.z)\n    );\n    \n    int x0y0z1H = pcg(modInd.x + modInd.y + modIndP.z, seed);\n    float x0y0z1 = dot(\n        vec3(\n            (float(0x000003ff & x0y0z1H)*nf-1.),\n            (float((0x000ffc00 & x0y0z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y0z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y, f.z-1.)\n    );\n    \n    int x1y0z1H = pcg(modIndP.x + modInd.y + modIndP.z, seed);\n    float x1y0z1 = dot(\n        vec3(\n            (float(0x000003ff & x1y0z1H)*nf-1.),\n            (float((0x000ffc00 & x1y0z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y0z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y, f.z-1.)\n    );\n    \n    int x0y1z1H = pcg(modInd.x + modIndP.y + modIndP.z, seed);\n    float x0y1z1 = dot(\n        vec3(\n            (float(0x000003ff & x0y1z1H)*nf-1.),\n            (float((0x000ffc00 & x0y1z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y1z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y-1., f.z-1.)\n    );\n    \n    int x1y1z1H = pcg(modIndP.x + modIndP.y + modIndP.z, seed);\n    float x1y1z1 = dot(\n        vec3(\n            (float(0x000003ff & x1y1z1H)*nf-1.),\n            (float((0x000ffc00 & x1y1z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y1z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y-1., f.z-1.)\n    );\n    \n    return mix(mix(mix( x0y0z0, x1y0z0, u.x),\n                   mix( x0y1z0, x1y1z0, u.x), u.y),\n               mix(mix( x0y0z1, x1y0z1, u.x),\n                   mix( x0y1z1, x1y1z1, u.x), u.y), u.z);\n}\n\nfloat layeredPerlinNoise(vec3 pos, int numLayers, int seed, int tileSize){\n    seed = pcg(seed);\n\tfloat result = 0.;\n    float scale = 1.;\n    float denominator = 0.;\n    for (int i = 0; i < numLayers; i++) {\n        result += scale * perlinNoise(pos, ++seed, tileSize);\n        tileSize *= 2;\n        denominator += scale;\n        pos *= 2.;\n        pos += PI*0.;\n        scale *= 0.5;\n    }\n    return result/denominator;\n}\n\n// --Signed distance functions. (SDF)--\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n   \treturn length(pos-center) - radius;\n}\nvoid sdSphereNormal(in vec3 pos, in vec3 center, in float radius, inout vec3 normal, inout float sd){\n\tsd = sdSphere(pos, center, radius);\n    vec2 e = vec2(0.01, 0.);\n    normal = normalize(sd - vec3(\n    \tsdSphere(pos - e.xyy, center, radius),\n    \tsdSphere(pos - e.yxy, center, radius),\n    \tsdSphere(pos - e.yyx, center, radius)\n    ));\n}\n\nconst float shiftExponent = 4096.;\nconst int shiftNum = 12;\nconst int shiftMask = 0xfff;\nfloat pack(float v1, float v2){\n    return floor(clamp(v1, 0., 1.)*shiftExponent) + floor(clamp(v2, 0., 1.)*shiftExponent)*shiftExponent;\n}\nvoid unPack(in float data, out float v1, out float v2){\n    v1 = float(int(data) & shiftMask)/shiftExponent;\n    v2 = float((int(data) >> shiftNum) & shiftMask)/shiftExponent;\n}\n\n// Density functions.\n# define GET_CUBE_SIZE \\\nint getCubeSize(){\\\n\tint maximum =  int(pow(iResolution.x * iResolution.y, 1./3.));\\\n    return min(70, maximum);\\\n}\\\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_a_code": "\n// This buffer is used to store global variables, like camera position and such.\n\nGET_CUBE_SIZE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // Mouse previous.\n    vec4 mousePrevious = texelFetch(iChannel0, ivec2(MOUSE_TEMP,0), 0);\n    if(ivec2(fragCoord) == ivec2(MOUSE_PREVIOUS,0)){\n        prevColor = mousePrevious;\n    }\n    if(ivec2(fragCoord) == ivec2(MOUSE_TEMP,0)){\n        prevColor = iMouse;\n    }\n    \n    \n    // Change movement mode.\n    int movementMode = int(texelFetch(iChannel2, ivec2(MOVEMENT_MODE,0), 0).x);\n    if(ivec2(fragCoord) == ivec2(MOVEMENT_MODE,0)){\n        bool key1IsDown = texelFetch(iChannel2, ivec2(KEY_1,0), 0).x > 0.5;\n    \tbool key2IsDown = texelFetch(iChannel2, ivec2(KEY_2,0), 0).x > 0.5;\n        if(key1IsDown){\n        \tprevColor.r = 0.;\n            movementMode = 0;\n        } else if(key2IsDown){\n        \tprevColor.r = 1.;\n            movementMode = 1;\n        }\n    }\n    \n    // Accelerate.\n    float sensitivity = texelFetch(iChannel0, ivec2(CAMERA_SENSITIVITY, 0), 0).x;\n    if(ivec2(fragCoord) == ivec2(CAMERA_SENSITIVITY,0)){\n        if(sensitivity == 0.){\n            sensitivity = 0.02;\n            prevColor.r = 0.02;\n        }\n        if(texelFetch( iChannel2, ivec2(KEY_C,0), 0 ).x > 0.5 && prevColor.r < 100.){\n            prevColor.r *= 1.05;\n        }\n        if(texelFetch( iChannel2, ivec2(KEY_V,0), 0 ).x > 0.5 && prevColor.r > 0.0001){\n            prevColor.r /= 1.05;\n        }\n    }\n    \n    // Rotate.\n    vec3 forward = texelFetch(iChannel0, ivec2(CAMERA_DIRECTION_FORWARD, 0), 0).xyz;\n    if(length(forward) == 0.){\n        forward = vec3(0,0,-1);\n    }\n    forward = normalize(forward);\n    //vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 right = texelFetch(iChannel0, ivec2(CAMERA_DIRECTION_RIGHT, 0), 0).xyz;\n    if(length(right) == 0.){\n        right = vec3(1,0,0);\n    }\n    right = normalize(right);\n    vec3 up = cross(right, forward);\n    if(\n        ivec2(fragCoord) == ivec2(CAMERA_DIRECTION_FORWARD,0) ||\n        ivec2(fragCoord) == ivec2(CAMERA_DIRECTION_RIGHT,0)\n    ){\n        bool arrowRight = texelFetch( iChannel2, ivec2(KEY_RIGHT,0), 0 ).x > 0.5;\n        bool arrowLeft = texelFetch( iChannel2, ivec2(KEY_LEFT,0), 0 ).x > 0.5;\n        bool arrowUp = texelFetch( iChannel2, ivec2(KEY_UP,0), 0 ).x > 0.5;\n        bool arrowDown = texelFetch( iChannel2, ivec2(KEY_DOWN,0), 0 ).x > 0.5;\n        float rotationSpeed = 0.04;\n        \n        // Arrow key movement.\n        if(arrowRight){\n            forward = normalize(forward + right*rotationSpeed);\n        }\n        if(arrowLeft){\n            forward = normalize(forward - right*rotationSpeed);\n        }\n        if(arrowUp){\n            forward = normalize(forward + up*rotationSpeed);\n        }\n        if(arrowDown){\n            forward = normalize(forward - up*rotationSpeed);\n        }\n        \n        // Mouse movement.\n        if(mousePrevious.z > 0.){\n        \tforward = normalize(forward + up * (iMouse.y - mousePrevious.y)*0.003);\n        \tforward = normalize(forward + right * (iMouse.x - mousePrevious.x)*0.003);\n        }\n        \n        //\n    \tvec3 up = cross(right, forward);\n    \tvec3 right = cross(forward, up);\n        if(ivec2(fragCoord) == ivec2(CAMERA_DIRECTION_FORWARD,0)){\n        \tprevColor.xyz = normalize(forward);\n        }else{\n        \tprevColor.xyz = normalize(right);\n        }\n    }\n    \n    // Translate.\n    if(ivec2(fragCoord) == ivec2(CAMERA_POS,0)){\n        bool dDown = texelFetch( iChannel2, ivec2(KEY_D,0), 0 ).x > 0.5;\n        bool aDown = texelFetch( iChannel2, ivec2(KEY_A,0), 0 ).x > 0.5;\n        bool spaceDown = texelFetch( iChannel2, ivec2(KEY_SPACE,0), 0 ).x > 0.5;\n        bool shiftDown = texelFetch( iChannel2, ivec2(KEY_SHIFT,0), 0 ).x > 0.5;\n        bool wDown = texelFetch( iChannel2, ivec2(KEY_W,0), 0 ).x > 0.5;\n        bool sDown = texelFetch( iChannel2, ivec2(KEY_S,0), 0 ).x > 0.5;\n        \n        if(wDown){\n            prevColor.xyz += forward*sensitivity;\n        }\n        if(sDown){\n            prevColor.xyz -= forward*sensitivity;\n        }\n        if(dDown){\n            prevColor.xyz += right*sensitivity;\n        }\n        if(aDown){\n            prevColor.xyz -= right*sensitivity;\n        }\n        if(spaceDown){\n            prevColor.xyz += up*sensitivity;\n        }\n        if(shiftDown){\n            prevColor.xyz -= up*sensitivity;\n        }\n        if(false || iTime < 0.1){\n            //prevColor.xyz = vec3(-1.1, -7.99, -5.1); // 70.\n            //prevColor.xyz = vec3(-1.1, -7. - float(getCubeSize())*0., -5.1); // 61.\n            //prevColor.xyz = vec3(-1.1, -5., -5.1); // 40.\n            // g: y = -x * 2 / 21 - 25 / 21\n            prevColor.xyz = vec3(-1.1, -2./21.*float(getCubeSize()) - 25./21., -5.1); // Adaptable.\n        }\n    }\n    \n    // Check for screen resolution change.\n    if(ivec2(fragCoord) == ivec2(SCREEN_RESOLUTION,0)){\n        prevColor.xy = iResolution.xy;\n    }else if(ivec2(fragCoord) == ivec2(DO_BUFFER_UPDATE,0)){\n        bool qIsDown = texelFetch( iChannel2, ivec2(KEY_Q, 0), 0 ).x > 0.5;\n        bool eIsDown = texelFetch( iChannel2, ivec2(KEY_E, 0), 0 ).x > 0.5;\n        if(\n            texelFetch( iChannel0, ivec2(SCREEN_RESOLUTION, 0), 0 ).xy != iResolution.xy || qIsDown || eIsDown\n        ){\n        \tprevColor.x = 1.;\n        }else{\n        \tprevColor.x = 0.;\n        }\n    }\n    \n    // Change seed.\n    if(ivec2(fragCoord) == ivec2(CHANGE_SEED,0)){\n\t    bool qIsDown = texelFetch(iChannel2, ivec2(KEY_Q,0), 0).x > 0.5;\n    \tbool eIsDown = texelFetch(iChannel2, ivec2(KEY_E,0), 0).x > 0.5;\n        if(qIsDown){\n        \tprevColor.r += 0.1;\n        }\n        if(eIsDown){\n        \tprevColor.r -= 0.1;\n        }\n    }\n    \n    //\n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This buffer is only changed on screen resolution change. When that happens, the mountain heightmap texture is refreshed once.\n\nGET_CUBE_SIZE\n\nfloat getDensity(vec3 pos, int seed, int size){\n    return layeredPerlinNoise(/*vec3 pos=*/pos*float(size), /*int numLayers=*/3, /*int seed=*/seed, /*int tileSize=*/size);\n}\nfloat getDensityCave(in vec3 pos){\n    float densityA = getDensity(pos, 0, 1);\n    float densityB = getDensity(pos, 1, 1);\n    float densityC = getDensity(pos, 2, 1);\n    \n    float density;\n    if(densityA > densityC){\n    \tdensity = max(densityA, densityB) - min(densityC, densityB);\n    } else {\n    \tdensity = max(densityC, densityB) - min(densityA, densityB);\n    }\n    \n    return density;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(texelFetch( iChannel0, ivec2(DO_BUFFER_UPDATE,0), 0 ).x > 0.5){\n        \n        // Only run once every time the screen resolution or seed is changed.\n        ivec2 iFragCoord = ivec2(fragCoord);\n        int flatCoord = iFragCoord.x + iFragCoord.y * int(iResolution.x);\n        int cubeSize = getCubeSize();\n        ivec3 cubeCoords = ivec3(\n        \tflatCoord % cubeSize,\n            (flatCoord / cubeSize) % cubeSize,\n            flatCoord / cubeSize / cubeSize\n        );\n        vec3 fCubeCoords = vec3(cubeCoords) / float(cubeSize);\n        vec2 e = vec2(0, 1./float(cubeSize));\n        vec3 positions[8] = vec3[](\n        \tfCubeCoords + e.xxx, fCubeCoords + e.yxx, fCubeCoords + e.xyx, fCubeCoords + e.yyx,\n            fCubeCoords + e.xxy, fCubeCoords + e.yxy, fCubeCoords + e.xyy, fCubeCoords + e.yyy\n        );\n        float noise[8];\n        for(int i=0; i<8; i++){\n            noise[i] = getDensityCave(positions[i]);\n        }\n        prevColor = vec4(\n        \tpack(noise[0]+0.5, noise[1]+0.5),\n        \tpack(noise[2]+0.5, noise[3]+0.5),\n        \tpack(noise[4]+0.5, noise[5]+0.5),\n        \tpack(noise[6]+0.5, noise[7]+0.5)\n        );\n        //prevColor = vec4(\n        //\tnoise[0],\n        //\tnoise[1],\n        //\tnoise[2],\n        //\tnoise[3]\n        //);\n        \n    }\n    \n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This buffer is only changed on screen resolution change. When that happens, the mountain heightmap texture is refreshed once.\n\nGET_CUBE_SIZE\n\nfloat getDensity(vec3 pos, int seed, int size){\n    return layeredPerlinNoise(/*vec3 pos=*/pos*float(size), /*int numLayers=*/3, /*int seed=*/seed, /*int tileSize=*/size);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    if(texelFetch( iChannel0, ivec2(DO_BUFFER_UPDATE,0), 0 ).x > 0.5){\n        \n        // Only run once every time the screen resolution or seed is changed.\n        ivec2 iFragCoord = ivec2(fragCoord);\n        int flatCoord = iFragCoord.x + iFragCoord.y * int(iResolution.x);\n        int cubeSize = getCubeSize();\n        ivec3 cubeCoords = ivec3(\n        \tflatCoord % cubeSize,\n            (flatCoord / cubeSize) % cubeSize,\n            flatCoord / cubeSize / cubeSize\n        );\n        vec3 fCubeCoords = vec3(cubeCoords) / float(cubeSize);\n        vec2 e = vec2(0, 1./float(cubeSize));\n        vec3 positions[8] = vec3[](\n        \tfCubeCoords + e.xxx, fCubeCoords + e.yxx, fCubeCoords + e.xyx, fCubeCoords + e.yyx,\n            fCubeCoords + e.xxy, fCubeCoords + e.yxy, fCubeCoords + e.xyy, fCubeCoords + e.yyy\n        );\n        float noise[8];\n        for(int i=0; i<8; i++){\n            noise[i] = getDensity(positions[i], 1, 10);\n        }\n        prevColor = vec4(\n        \tpack(noise[0]+0.5, noise[1]+0.5),\n        \tpack(noise[2]+0.5, noise[3]+0.5),\n        \tpack(noise[4]+0.5, noise[5]+0.5),\n        \tpack(noise[6]+0.5, noise[7]+0.5)\n        );\n    }\n    \n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 169, 169, 1341], [1342, 1342, 1373, 1373, 2545], [2546, 2546, 2602, 2602, 2997], [2999, 3011, 3055, 3055, 3405], [3406, 3406, 3502, 3502, 3786], [3788, 3806, 3840, 3840, 3939], [3940, 3940, 4026, 4026, 4294], [4373, 4373, 4582, 4582, 7670], [7671, 7671, 7728, 7728, 10452]], "test": "untested"}
{"id": "tljfzW", "name": "defaultshell", "author": "lennyjpg", "description": "sdfdfdsf", "tags": ["sdfdfdf"], "likes": 3, "viewed": 313, "published": 3, "date": "1598474127", "time_retrieved": "2024-07-30T20:48:53.491739", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 0.5 - fragCoord.xy/iResolution.x;\n    vec2 u = uv;\n    u.y-= 0.1;\n    float t = iTime * -0.1;\n    if(u.x < .0){\n        u.y = .5 - u.y;\n    }\n    vec3 a = vec3(255., 255., 225. );\n    a *= 1.0 - uv.y;\n    vec3 rot = vec3(255., .0, 91. );\n    float d = length(u)*4.0;\n    float c = fract(t + d );\n    \n    vec3 q = mix(a,rot,c)/255.0;\n    if(uv.x > uv.y){\n        q *= vec3(50.,100.,220.)/255.;\n    }\n    if(uv.x > uv.y){\n       float cc = length(uv-vec2(.5,.5));        \n       // float cc = (uv.x  + uv.y) - .84;\n        q += smoothstep(cc, cc * 1.02, .2);\n    }\n    fragColor = vec4(q,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 666]], "test": "untested"}
{"id": "tl2fzD", "name": "Lucky buggy galaxy", "author": "mrange", "description": "License CC0: Lucky buggy galaxy\nWhen trying to create a galaxy for the: once upon a time... space I mistakenly put in s when I meant sqrt(0.5) and it turned out quite cool IMHO.\n So I thought I share my mistake\n", "tags": ["2d", "fbm"], "likes": 8, "viewed": 536, "published": 3, "date": "1598471006", "time_retrieved": "2024-07-30T20:48:54.351441", "image_code": "// License CC0: Lucky buggy galaxy\n//  When trying to create a galaxy for the: once upon a time... space\n//\tI mistakenly put in s when I meant sqrt(0.5) and it turned out quite cool IMHO.\n//  So I thought I share my mistake\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat noise1(vec2 p) {\n  // Randomly coded \"noise\" function\n  float a = cos(p.x);\n  float b = cos(p.y);\n\n  float c = cos(p.x*sqrt(3.5));\n  float d = cos(p.y*sqrt(1.5));\n\n  return a*b*c*d;\n}\n\nfloat galaxy(vec2 p, float a, float z) {\n  // Apply angular distort, there are probably better ways to do this\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*3.0 + a;\n  p = toRect(pp);\n  p *= z;\n  return noise1(p);\n}\n\nfloat height(vec2 p) {\n  // FBM with a twist (ie bug)\n  float s = 0.0;\n  float a = 1.0;\n  float f = 15.0;\n  float d = 0.0;\n  rot(p, 0.075*TIME);\n  for (int i = 0; i < 4; ++i) {\n    float g = a*galaxy(p, 0.15*float(i) + -TIME*( + 0.1*float(i)), f);\n    s += g;\n    a *= 0.5;\n    f *= s; // This is a bug that happens to look cool, intended to be sqrt(0.5) (boring), s much more fun\n    d += a;\n  }\n  \n  return 0.5 + 0.5*(s/d)*exp(-5.5*dot(p, p));\n}\n\nvec3 normal(vec2 p) {\n  vec2 eps = vec2(4.0/RESOLUTION.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy) - height(p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx) - height(p + eps.yx);\n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n \n  vec3 lp1 = vec3(-2.0, 0.5, 2.0);\n  vec3 ld1 = normalize(lp1 - vec3(p.x, 0.0, p.y));\n  vec3 lp2 = vec3(2.0, 0.5, 2.0);\n  vec3 ld2 = normalize(lp2 - vec3(p.x, 0.0, p.y));\n\n  float h = height(p);\n  float th = tanh(h);\n  vec3 n = normal(p);\n  \n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += vec3(0.5, 0.5, 0.75)*h;\n  col += 0.5*pow(diff1, 10.0);\n  col += 0.25*pow(diff2, 5.0);\n  col += vec3(1.0)*pow(sin(PI/2.0*th), 5.0);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fzD.jpg", "access": "api", "license": "cc0-1.0", "functions": [[345, 345, 367, 367, 411], [413, 413, 434, 434, 475], [477, 477, 510, 510, 595], [597, 597, 619, 656, 786], [788, 788, 828, 898, 996], [998, 998, 1020, 1051, 1445], [1447, 1447, 1468, 1468, 1671], [1673, 1673, 1710, 1710, 1918], [1920, 1920, 1975, 1975, 2622]], "test": "untested"}
{"id": "wljXW1", "name": "SlimePlay", "author": "PsyPhi", "description": "Slime chains", "tags": ["particles", "slime"], "likes": 11, "viewed": 576, "published": 3, "date": "1598465070", "time_retrieved": "2024-07-30T20:48:55.239068", "image_code": "/*\n\tlots o' particles (Image)\n\t2016 stb\n\n\tDrawing from Buf B...\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tfragColor = abs(texture(iChannel0, uv)*2.-1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\tlots o' particles (Buf A)\n\t2016 stb\n\n\tThis shader updates the particles.\n\n\tNo attempt is made to preserve particles upon contact, so only a few will remain after a while :(\n*/\n\nconst float ParticleDensity = 1.; // 0.0-1.0\n\nfloat sensorLen = 0.025;\nfloat sensorAng = 0.5;\nfloat rotAng = 0.5;\n\nmat2 rotate(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nvec2 sense (vec2 _uv, vec2 _pDir)\n{\n\n    //float r = plot(uv,cPos.xy,size);   //Draws location of part\n\n    vec2 sensorL = _uv+(rotate(-sensorAng)*_pDir)*sensorLen; // location of sensor A\n    vec2 sensorC = _uv+_pDir*sensorLen;\n    vec2 sensorR = _uv+(rotate(sensorAng)*_pDir)*sensorLen;\n\n    float senseL = texture(iChannel1, sensorL).a;\n    float senseC = texture(iChannel1, sensorC).a;\n    float senseR = texture(iChannel1, sensorR).a;\n\n    if(senseC > senseL && senseC > senseR)\n    {\n\n    }\n\n    else if (senseC < senseL && senseC < senseR)\n    {\n      float randNum = texture(iChannel3, vec2(0.5,sin(iTime))).x; //add uv to the sin to get a better random\n      randNum = round(randNum)*2.-1.;\n      _pDir *= rotate(rotAng*randNum);\n      // _pDir = vec2(-0.5,-0.5);// for debug\n    }\n\n\n    else \n    {\n        _pDir *= rotate(rotAng*sign(senseL-senseR));\n    }\n    \n    return _pDir;\n\n}\n\n\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    vec3 MOD3 = vec3(443.8975, 397.2973, 491.1871);\n    vec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 px = 1. / res;\n    vec2 uv = fragCoord.xy / res;\n    \n    vec4 buf[9];\n    buf[0] = texture(iChannel0, uv);\n    buf[1] = texture(iChannel0, fract(uv-vec2(px.x, 0.)));\n    buf[2] = texture(iChannel0, fract(uv-vec2(-px.x, 0.)));\n    buf[3] = texture(iChannel0, fract(uv-vec2(0., px.y)));\n    buf[4] = texture(iChannel0, fract(uv-vec2(0., -px.y)));\n    buf[5] = texture(iChannel0, fract(uv-vec2(px.x, px.y)));\n    buf[6] = texture(iChannel0, fract(uv-vec2(-px.x, px.y)));\n    buf[7] = texture(iChannel0, fract(uv-vec2(px.x, -px.y)));\n    buf[8] = texture(iChannel0, fract(uv-vec2(-px.x, -px.y)));\n    \n    // this cell's particle direction & position, if any\n    vec2 pDir = buf[0].rg;\n    vec2 pPos = buf[0].ba;\n    \n    \n    // update this cell's particle position\n    pPos = mod(pPos+pDir, res);\n    \n    \n    // clear the current cell if its particle leaves it\n    if(floor(pPos)!=floor(fragCoord)) {\n        pDir = vec2(0.);\n        pPos = vec2(0.);\n    }\n    \n    // add up any incoming particles\n    float ct = 0.;\n    vec2 pDirAdd = vec2(0.);\n    vec2 pPosAdd = vec2(0.);\n    for(int i=1; i<9; i++) {\n        vec2 pPosI = buf[i].ba;\n        pPosI = mod(pPosI+buf[i].rg, res);\n        if(floor(pPosI)==floor(fragCoord)) {\n            pDirAdd += buf[i].rg;\n            pPosAdd += pPosI;\n            ct ++;\n        }\n    }\n    \n    // if particles were added up, average and transfer them to the current cell\n    if(ct>0.) {\n        pDir = normalize(pDirAdd / ct);\n        \n        \n        \n        \n        //pDir = mix(pDir, texture(iChannel1, uv).rg*2.-1., 0.1 );  //trail follow\n        \n        pDir = sense(uv,pDir); //direction follow\n        \n        \n        pPos = pPosAdd / ct;\n        \n        if(texture(iChannel2, vec2(32./256., .5)).r>.5){\n            pDir = vec2(\n                    hash12(mod(uv+iTime/100.-4., 100.)),\n            \t\thash12(mod(uv-iTime/100.-8., 100.))\n\t\t\t\t)-.5;\n        }\n        \n        if(texture(iChannel2, vec2(37./256., .5)).r>.5){\n            pDir = vec2(-1., 0.);\n        }\n        if(texture(iChannel2, vec2(39./256., .5)).r>.5){\n            pDir = vec2(1., 0.);\n        }\n        if(texture(iChannel2, vec2(38./256., .5)).r>.5){\n            pDir = vec2(0., 1.);\n        }\n        if(texture(iChannel2, vec2(40./256., .5)).r>.5){\n            pDir = vec2(0., -1.);\n        }\n    }\n    \n    // first frame particle setup\n    if(iFrame==0 || (iMouse.z >0. && distance(iMouse.xy, fragCoord)<20.) )\n        if(ParticleDensity>hash12(fragCoord/res)) {\n            vec2 randXY =\n                vec2(\n                    hash12(mod(uv+iTime/100.-4., 100.)),\n            \t\thash12(mod(uv-iTime/100.-8., 100.))\n\t\t\t\t);\n            \n            pDir = normalize(randXY-.5);\n            pPos = fragCoord;\n        }\n    \n    fragColor = vec4(pDir, pPos);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n\tlots o' particles (Buf B)\n\t2016 stb\n\n\tThis shader predraws the particles for the Image shader.\n*/\n\nconst float FadeAmt = 0.99; // 0.0-1.0\n\nvec3 hs(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 p = vec3(1.5/iResolution.xy, 0.);\n    \n    vec4 pDot, pTrail;\n    vec2 pDir = texture(iChannel0, uv).rg;\n    \n    pDot = texture(iChannel0, uv)*.5+.5;\n    pTrail = texture(iChannel1, uv);\n    pTrail += texture(iChannel1, uv+p.xz);\n    pTrail += texture(iChannel1, uv-p.xz);\n    pTrail += texture(iChannel1, uv+p.zy);\n    pTrail += texture(iChannel1, uv-p.zy);\n    pTrail*=.2;\n    \n    // make this cell white if it has a nonzero vector length\n    if(length(pDir)>0.){\n       \tpTrail = pDot;\n    }\n    \n    \n    // trail effect\n    pTrail = mix(pDot, pTrail,FadeAmt);\n    //pTrail.rgb = hs(pTrail.rgb, -.1);\n    \n\tfragColor = max(vec4(0.), min(vec4(1.),pTrail));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljXW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 125, 125, 222]], "test": "untested"}
{"id": "tt2BzW", "name": "[TWITCH] Landmass z-morph", "author": "evvvvil", "description": "Landmass z-morph - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["mix", "terrain", "demoscene", "glow", "transition", "organic", "world", "dark", "morphing", "mountain", "lazer", "cathedral", "monument"], "likes": 30, "viewed": 1975, "published": 3, "date": "1598452487", "time_retrieved": "2024-07-30T20:48:55.996044", "image_code": "// Landmass z-morph - Result of an improvised live coding session on Twitch\n// Thankx to zblll, 5jeesus, stobeee and others for the ideas\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,mixer,g;vec3 np,modP,op,po,no,al,ld;\nfloat bo(vec3 p,vec3 r) {p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin( float d1, float d2, float k ){  float h = max(k-abs(d1-d2),0.0);return min(d1,d2)-h*h*0.25/k; }\nfloat smax( float d1, float d2, float k ){  float h = max(k-abs(-d1-d2),0.0);return max(-d1,d2)+h*h*0.25/k; }\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25;\n                       f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 fbAngular( vec3 p )\n{\n    float mMix=mix(2.,1.,clamp(mixer,.5,1.)*2.-1.);//MATERIAL ID MIXER\n    vec2 h,t=vec2(bo(p,vec3(21,.5,.5)),mMix); \n    h=vec2(bo(p,vec3(20.8,.3,.7)),2.+mMix); \n    h.x=min(h.x,bo(p,vec3(20.6,.9,.1)));\n    t=t.x<h.x?t:h;\n    h=vec2(bo(p,vec3(20.8,.7,.3)),1); \n    p.x=mod(p.x,3.)-1.5;\n    h.x=min(h.x,length(p.xy)-.15+abs(p.z)*.1);\n    t=t.x<h.x?t:h;\n    return t;\n}\nvec2 mp( vec3 p )\n{   \n    op=modP=p; //SCENE 1 ANGULAR SCENE\n    mixer=clamp(sin(tt*.65+p.z*.1),-.5,.5)+.5; //OVERALL SCENE MIXER \n    modP.z=mod(modP.z+tt*2.,40.)-20.; \n    np=modP; \n    for(int i=0;i<5;i++){\n        np.xz=abs(np.xz)-vec2(3.5,2);\n        np.xz*=r2(.785);\n        np.yz*=r2(-sin(-p.y*.1 )*.1);\n    }  \n    vec2 h,scene1=fbAngular(np);  \n    np.xz+=1.2;\n    np.xy*=r2(.785*2.);  \n    h=fbAngular(np*1.5); h.x/=1.5;\n    scene1=scene1.x<h.x?scene1:h;  \n    np.xz*=r2(-.785*2.);\n    np.x+=4.;\n    h=fbAngular(abs(np*.5)-vec3(0,0,5)); h.x/=.5;\n    scene1=scene1.x<h.x?scene1:h;\n    scene1.x*=0.8;  //SCENE 2 ORGANIC SCENE    \n    float tnoi=texNoise((p.xz+vec2(0,tt*2.))*.02).r*1.5; \n    float tDisp=sin((p.z+tt*2.)*.5+p.x*.2);\n    p.y+=tDisp;\n    vec2 scene2 =vec2(p.y+5.+tnoi*5.,1.); //TERRAIN  \n    scene2.x=smin(scene2.x,length(abs(modP.xz+tnoi*2.)-vec2(3.5,2))-2.+tnoi*2.+sin(p.y*.3)+sin(p.y*2.*p.x)*0.03,5.); //VERTICAL CYLINDERS\n    vec3 cylP=modP+vec3(0,5,0); cylP.x=abs(cylP.x)-8.+tDisp;\n    scene2.x=smin(scene2.x,length(cylP.xy+tnoi*2.)-2.+tnoi*2.+sin(p.y*.3)+sin(p.y*2.*p.x)*0.017,5.);//HORIZONTAL CYLINDERS\n    scene2.x=smax(length(modP+vec3(0,6,0)+tnoi*3.)-4.,scene2.x,5.);  //HOLE IN MIDDLE OF TERRAIN\n    //scene2.x=smax(length(modP+vec3(0,12,0))-3.4+tnoi,scene2.x,2.); //Dig hole where blue sphere with tentacle is, removed to optimize shader as design impact is minimal\n    scene2.x*=0.5;\n    h=vec2(length(np.yz+vec2(-.3,0.)),6);\n    h.x=min(h.x,max(length(cos(p*.5+sin(op.z*.2)+vec3(0,tt,tt))),abs(p.x)-3.));\n    modP.xz*=r2(sin(p.y*.2+tt));  \n    h.x=min(h.x,length(abs(modP.xz)-.5)-max(0.,.5-abs(p.y+10.)*.1));  \n    h.x=smin(h.x,length(modP+vec3(0,12,0))-3.+tnoi,1.5);\n    scene2.x=min(scene2.x,h.x);  \n    g+=0.1/(0.1+h.x*h.x*(40.-39.*sin(op.z*.7)));  \n    vec2 t=mix(scene1,scene2,vec2(mixer,0.));  \n    return t;\n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n    vec2 h,t=vec2(.1);\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x);\n        if(h.x<.0001||t.x>60.) break;\n        t.x+=h.x;t.y=h.y;\n    }\n    if(t.x>60.) t.y=0.;  \n    return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=23.6+mod(iTime,62.82);\n    vec3 ro=mix(vec3(12.,5.,-9.),vec3(0.,-2.,-10.),ceil(sin(tt*.4))),\n         cw=normalize(vec3(0,-2.,0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n         rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;\n    z=tr(ro,rd);t=z.x;  \n    float timeMixer=clamp(sin(tt*.65),-.5,.5)+.5;\n    ld=normalize(vec3(.3,.2,.5));\n    vec3 sun=vec3(pow(clamp(dot(ld,rd),0.,1.),32.))*mix(vec3(.7,.4,0.),vec3(0.2),timeMixer);  \n    co=fo=sun+(mix(vec3(.6,.3,.3),vec3(.1,.15,.2),timeMixer)-length(uv)*.1-rd.y*.2);\n    if(z.y>0.){ \n        po=ro+rd*t; \n        no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n        al=vec3(1);\n        if(z.y>=1.) al=mix(vec3(.1,.2,.4),vec3(1),2.-z.y);\n        if(z.y>=3.) al=mix(vec3(0),vec3(1),4.-z.y);   \n        float dif=max(0.0,dot(no,ld)),    \n              fr=pow(1.+dot(no,rd),4.),    \n              spo=exp2(1.+25.*texNoise(.05*vec2(np.y,dot(np.xz,vec2(.7)))).r),\n              sp=pow(max(dot(reflect(-ld,no),-rd),0.),spo);\n        co=mix(sp*.5+al*(a(.05)*a(.1)+.2)*(dif+s(2.)),fo,min(fr,.5));\n        co=mix(fo,co,exp(-.00005*t*t*t));\n    }\n    fragColor = vec4(pow(co+g*.2*mix(vec3(.7,.2,.1),vec3(.1,.2,.7),timeMixer),vec3(.45)),1);\n} ", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2BzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[328, 328, 353, 353, 394], [395, 395, 412, 412, 455], [456, 456, 498, 498, 563], [564, 564, 606, 606, 673], [674, 674, 697, 697, 917], [918, 918, 944, 944, 1313], [1314, 1314, 1333, 1333, 3167], [3168, 3168, 3197, 3197, 3385], [3475, 3475, 3532, 3532, 4883]], "test": "untested"}
{"id": "ttSfRW", "name": "Vorticity confinement v1", "author": "michael0884", "description": "Based on the density gradient, thus the holes", "tags": ["particles", "ca"], "likes": 13, "viewed": 663, "published": 3, "date": "1598447454", "time_retrieved": "2024-07-30T20:48:57.144971", "image_code": "// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.56\n#define RAD R.x*0.6\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 16.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.03*iTime, -0.4)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo =sin(vec3(1,2,3)*3.*D*D);\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 4.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 8.);\n            colB += 4.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 8.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(2.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float momentum = 10.*length(DECODE(T(pos).y))*r;\n        float div = 10.*(d_r.z*v_r.x - d_l.z*v_l.x + d_u.z*v_u.y - d_d.z*v_d.y);\n        float curl = 5.*(d_r.z*v_r.y - d_l.z*v_l.y - d_u.z*v_u.x + d_d.z*v_d.x);\n    \tcurl = sign(curl)*sqrt(abs(curl));\n    \t\n    \tcol=sin(vec4(1,2,3,4)*1.*r)*(1. + 0.3*texture(iChannel3,c.xy));\n    \tcol.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n//i.e. diffusion \n#define distribution_size 1.3\n\n//slime mold sensors\n#define sense_num 12\n#define sense_ang 0.2\n#define sense_dis 10.\n//weird oscillation force\n#define sense_oscil 0.0\n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force 0.0\n//slime mold sensor distance power law dist = sense_dispow(rho, pw)\n#define distance_scale 0.\n#define force_scale 2.\n#define acceleration 0.0\n\n#define density_normalization_speed 0.\n#define density_target 0.24\n#define vorticity_confinement 1.0\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n   \n//density*temp = pressure - i.e. ideal gas law\n#define Pressure(rho) 1.0*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, density_target, density_normalization_speed);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.5*Dir(2.*PI*hash11(floor(pos.x/7.) + R.x*floor(pos.y/7.)));\n        M = density_target + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n     \n        F -= 1.0*M*p + M*vorticity_confinement*curl*Rot(-PI*0.5)*dgrad;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component from slime force and leave rotation only\n        slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*sin(2.*iTime)*Rot(PI*0.5)*dx*GS(dx/3.);\n        }\n        \n        vec2 dx = pos - R*0.5;\n        F += 0.1*Rot(PI*0.5)*dx*GS(dx/8.);\n      \n        //integrate velocity\n        V += F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor = C(pos - V0*dt);\n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy = pos/R;\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSfRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 440, 467, 467, 645], [685, 685, 716, 716, 750], [752, 752, 804, 804, 923], [925, 925, 960, 960, 984], [986, 986, 1017, 1017, 1104], [1106, 1106, 1127, 1127, 1220], [1222, 1222, 1244, 1244, 1340], [1343, 1343, 1363, 1363, 1559], [1562, 1562, 1597, 1597, 1782], [1821, 1821, 1853, 1853, 2021], [2023, 2023, 2068, 2068, 5001]], "test": "untested"}
{"id": "3ljfR1", "name": "Polar Weave Pattern", "author": "Shane", "description": "A simple polar weave pattern.", "tags": ["2d", "repetition", "pattern", "polar", "weave"], "likes": 46, "viewed": 796, "published": 3, "date": "1598443725", "time_retrieved": "2024-07-30T20:48:58.203143", "image_code": "/*\n\n\tPolar Weave Pattern\n\t-------------------\n\n\tOne of my favorite nerd related hobbies is to recreate a simple \n    pattern I've come across on the internet. If I really feel like \n    geeking out, I'll render the exact pattern using several different \n    approaches. :)\n\t\n    Anyway, this particular pattern and its derivatives are all over \n    the net, and although I couldn't find any, there are probably \n    examples on here too. There are several ways to produce it. In this \n    case, I'm minimizing rendering calls by using a single pass repeat \n    polar approach, which means no neighboring cells need be considered. \n\n    It took me longer to put together than I anticipated, but the idea \n    is pretty simple: Partition space into repeat polar cells, then \n    render two circular arcs on each cell edge with radii such that \n    their edges completely overlap. This will result in what look like \n    a bunch of overlapping circles. The final step is to flip the \n    bottom half of each cell to produce a weave.\n\n\n\n    Related examples:\n\n    // When Fabrice first posted these, I wasted way too much\n    // time playing around with the code. :)\n    rosace 3c - FabriceNeyret2\n    https://www.shadertoy.com/view/Ms3SzB\n\n    // Related in the sense that it uses polar coordinates only,\n    // but it's really cool, so I included it anyway. :)\n    Rose - Dave_Hoskins\n    https://www.shadertoy.com/view/ldBGDh\n\n    // An unlisted bare bones polar coordinate example, for \n\t// anyone who's not quite sure how the polar thing works.\n    Polar Repetition - Shane\n\thttps://www.shadertoy.com/view/wdtGDM\n\n\n*/\n\n// Display the radial cell boundaries on the background.\n//#define SHOW_CELLS\n\n// Adds the weave effect: If you comment in the SHOW_CELLS define\n// above, then scroll down to the WEAVE define, you'll see that it \n// involves a very simple trick.\n#define WEAVE\n\n// Random ordering. I prefer the ordered look, but the option\n// is here to show it can be done. The pattern changes every two\n// seconds. By the way, this can occasionally produce discontinous\n// results when using odd cell numbers... which I'll fix later. \n//#define RANDOM_ORDER\n\n// Number of cells: Integers between 4 and 10 work. Beyond that,\n// some tweaking will be necessary. Interestingly, odd numbers will\n// produce a single weave, whereas even numbers will produce two\n// separate interlocked weaves.\n#define CELL_NUM 8.\n\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// Hacky globals, put in as an afterthought. Struct containers are tidier, but \n// sometimes they can be even less readable. In addition, WebGL can throw all\n// kinds of errors when you're trying to used them inside raymarching loops,\n// which can be extra annoying.\n//\n// Anyway, there's an alternate cell variable and edge width. The vec2 is a \n// global local cell coordinate variable, which is kind of a contradiction \n// in terms. :)\nfloat gDir, gEw;\nvec2 gP;\n\nvec4 dist(vec2 p){\n    \n    // Rotation performed here.\n    p *= r2(-iTime/4.);\n    \n\t\n    // Polar angle.\n    float a = atan(p.y, p.x);\n    \n    // Number of cells.\n    const float aNum = CELL_NUM;\n    \n    // Partitioning the angle into \"aNum\" cells.\n    float ia = floor(a/6.2831853*aNum);\n \n    // Used to generate a random number for each cell, and consequently,\n    // a random rendering order.\n    float svIA = ia;\n    \n    // Variable to determine alternate cells... Only useful for even cell numbers.\n    float dir = mod(ia, 2.)<.5? -1. : 1.;\n    \n    \n    // Centering and converting back to radians... If you do this often enough,\n    // it'll become second nature.\n    ia = (ia + .5)/aNum*6.2831853;\n    \n    // Converting the radial centers to their positions.\n    p *= r2(ia);\n    // Above is equivalent to:\n    //p = vec2(p.x*cos(ia) + p.y*sin(ia), p.y*cos(ia) - p.x*sin(ia));\n\n    // Hacky global coordinate save.\n    gP = p;\n    \n    \n    // Producing the objects: In this case, two circles at the mid edges of each cell.\n\n    \n    // Setting the radial distance: We achive this by setting one of the polar \n    // coordinates to this value, which effectively moves the points out a bit along \n    // the radial line. If you didn't perform this, all objects would be superimposed \n    // on one another in the center. Repeat radial coordinates are possible too.\n    const float rad = .265;\n  \n    #ifdef WEAVE\n    // This is the trick you use to turn circles into a weave. It's very simple, but it\n    // took me a while to figure out. Simply reverse the rendering order of the circles\n    // on the bottom half of each cell. Just remember that the X and Y vector positions\n    // (selected members, or whatever they're called) represent the polar coordinates of \n    // the cell. The don't literally mean X and Y... I've been doing this stuff for years \n    // and I still make that mistake. :) Anyway, the easiest way to see how it works is\n    // to comment the line out, then comment it back in again.\n    //\n    // The halfway point on the cell edge occurs at the apothem, which is the radial\n    // distance multiplied by the cosine expression below... and I knew this because \n    // I'm a good guesser. :D Seriously though, look at the geometry of a regular \n    // polygon, and the following should make sense.\n    if(p.x<rad*cos(3.14159/aNum)) p.y = -p.y;  \n    #endif\n  \n    \n    // Far left and right sides of the cells. Each point is rotated back half a \n    // cell, then edged out by the radial distance... Polar coordinate stuff... You get \n    // used to it after a while... Kind of. :D\n    vec2 p1 = p*r2(-3.14159/aNum) - vec2(rad, 0);\n    vec2 p2 = p*r2(3.14159/aNum) - vec2(rad, 0);\n\n    \n    \n    // The arc radius should be half the cell width, or half the side length of the  \n    // regular polygon that the pattern is based on... I think this is right, but I was \n    // in a hurry, so if you have time, I'd double check it. It seems to work visually \n    // though, so that's a good sign. :)\n    float offs = rad*sin(3.14159/aNum);\n    \n    \n    // Two circles. We're rendering one over the other, so we need a distance for each.\n    vec2 d = vec2(length(p1), length(p2)) - offs;\n\n    // The polar angle for respective positions on each circle. If you're doing stuff\n    // with circles, you'll want angles. In this case, they're being used to light up\n    // different parts of the circles.\n    vec2 ang = vec2(atan(p1.y, p1.x), atan(p2.y, p2.x));\n    \n    // Turning circles into arcs -- It's a standard CSG move. The centeral arc line\n    // will occur at the original outer circle radius. Because of the absolute \n    // function, the width will be double, so you just halve what you want it to be.\n    const float ew = rad/2.; // Arc width. \n    d = abs(d) - ew/2.; // Arc.\n    \n    \n    #ifdef RANDOM_ORDER\n    // Random rendering order, arranged to change every two seconds.\n    if(fract(sin(svIA + floor(iTime/2. + 37.)*.083)*45758.5453)<.5) {\n        d = d.yx;\n        ang = ang.yx;\n    }\n    #endif\n\n    // Save the alternate cell and edge width for use outside the function.\n    gDir = dir;\n    gEw = ew;\n    \n    \n    // Returning the two arc distances and their respective angles.\n    return vec4(d, ang);\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float iRes = iResolution.y; // min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/iRes;\n \n   \n    // Scaling... Trivial in this case.\n    vec2 p = uv;\n    \n     // Falloff factor: Sometimes,  we might have to use \"fwidth(d),\" \n    // a numeric solution, or use a constant.\n    float sf = 2.5/iRes; \n    \n    // Taking two samples.\n    //\n    // Drop shadow fields and angles.\n    vec4 dSh = dist(p - normalize(vec2(-1.5, -1))*.03);\n    // Distance fields and angles.\n    vec4 d = dist(p);\n    \n    // Distance field angles.\n    vec2 ang = d.zw;\n    \n\n    // RENDERING \n    \n    // Producing two line patterns.\n    //\n    // Multiple dark lines for that cliche record look. The expression, \n    // \"abs(fract(x*N - shift) - .5),\" is a repeat triangle formula of sorts and \n    // useful when you want to produce repeat edge lines... There are heaps of \n    // other ways to produce concentric lines, but I find it's the most reliable.\n    //\n    const float lnN = 8.; // Number of concentric pattern lines.\n    vec2 pat = abs(fract(d.xy/gEw*lnN - .5) - .5)*2. - .07;\n    pat = smoothstep(0., sf/gEw*lnN, pat);\n    // The darkish outer arc lines.\n    vec2 pat2 = abs(fract(d.xy/gEw/2. - .5) - .5)*2. - 1./lnN;\n    pat2 = smoothstep(0., sf/gEw/2., pat2);\n    \n    // Lighting: Using the respective arc angles to add or take away light from\n    // the surface. The light and darker sections add to the illusion. The numbers\n    // themselves are a bit of science mixed in with trial and error.\n    vec2 shad;\n\tshad.x = clamp((cos(ang.x*1.8))*1.35, 0., 1.);\n\tshad.y = clamp((1. - cos(ang.y*1.6))*1.25, 1., 2.);\n    shad = shad*.5 + .5;\n  \n    \n    // Background: Very simple, but you can make it more elaborate.\n    vec3 bg = mix(vec3(1, .9, .5), vec3(1, .85, .8), uv.y*.5 + .5)*(1. - length(uv)*.35);\n    \n    \n    #ifdef SHOW_CELLS \n    // Display the radial cell boundaries on the background. Seeing each \n    // individual cell pattern can be helpful for debug purposes.\n    float ln = min(abs(r2(-3.14159/CELL_NUM)*gP).y, abs(r2(3.14159/CELL_NUM)*gP).y);\n    bg = mix(bg, bg*1.7, 1. - smoothstep(0., sf*CELL_NUM/6.2831, ln*CELL_NUM/6.2831 - .003));\n    bg = mix(bg, bg/12., 1. - smoothstep(0., sf*CELL_NUM/6.2831, ln*CELL_NUM/6.2831 - .0007));\n    // Alternate cell shading for even cell numbers. When the number is odd, alternate\n    // cell coloring doesn't really make sense.\n    if(mod(CELL_NUM, 2.)<.5 && gDir<0.) bg = mix(bg, bg.zzz, .25);\n    else bg = bg = mix(bg, bg.xxx, .25);\n    #endif \n    \n     \n    // Setting the scene color to that of the background.\n    vec3 col = bg;\n    \n    // Drop shadows and arc edge shadows for that fake ambient occlusion look\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., min(dSh.x, dSh.y)))*.25);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., min(d.x, d.y)))*.25);\n    \n    // The ring colors. We're using the same color for each, but different colors\n    // are possible.\n    vec3 col1 = vec3(.62, .6, .58);\n    vec3 col2 = col1;\n    \n    /*\n    // If using different ring colors, alternate cells need to be swapped, but\n    /// we're not, so it doesn't matter.\n    if(gDir<0.) {\n        vec3 tmp = col1; col1 = col2; col2 = tmp;\n    }\n    */\n    \n    // Applying the dark lines, edges lines and shading to each arc.\n    col1 *= (pat2.x*.3 + .7)*pat.x*shad.x;\n    col2 *= (pat2.y*.3 + .7)*pat.y*shad.y;\n    // Colored stripes, if you prefer.\n    //col1 *= mix(vec3(1), bg*vec3(1.1, 1, .9), 1. - pat2.x)*pat.x*shad.x;\n    //col2 *= mix(vec3(1), bg*vec3(1.1, 1, .9), 1. - pat2.y)*pat.y*shad.y;\n\n    \n    \n    // Rendering the bottom arc. Dark lines and color.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d.x));\n    col = mix(col, col1, 1. - smoothstep(0., sf, d.x + .0035));\n    \n    // Laying down some shadowing from the top arc onto the bottom one.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(d.y, d.x)))*.25);\n    \n    // Rendering the top arc. Dark lines and color.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d.y));\n    col = mix(col, col2, 1. - smoothstep(0., sf, d.y + .0035));\n    \n    \n    // Extra sutble gradient coloring.\n    //col = mix(col.yxz, col, uv.y*.5 + .5);\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2417, 2450, 2470, 2470, 2528], [2996, 2996, 3014, 3051, 7264], [7267, 7267, 7321, 7369, 11658]], "test": "untested"}
{"id": "wlSBzD", "name": "Spectrum Response Functions", "author": "BigWIngs", "description": "See comments for details!", "tags": ["spectrum", "light", "perception"], "likes": 45, "viewed": 2200, "published": 3, "date": "1598415838", "time_retrieved": "2024-07-30T20:48:59.051873", "image_code": "// \"Spectrum Response Functions\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// Two versions of a spectrum function: one using smoothsteps and the other\n// using best-fit 9th degree polynomials which isn't as accurate, but should\n// be significantly faster. \n// Function inputs range from 0 to 1, \n// which corresponds to roughly 380 to 720 nanometers\n//\n// I figured perhaps it could be useful to someone!\n\n#define S smoothstep\n\nvec3 Spectrum(float x) {\n    // https://www.shadertoy.com/view/wlSBzD\n\tfloat r, g, b;\n    \n    r = x<.16 ? S(0., .16, x)*.169 :\n    \tx<.22 ? S(.22, .16, x)*.134+.035 :\n    \tx<.41 ? S(.22, .41, x)*.098+.035 :\n    \tx<.64 ? S(.41,.64,x)*.851+.133 :\n    \t\t\tS(1., .64, x)*.984;\n    \n    g = x<.05 ? 0. :\n    \tx<.15 ? S(.05, .15, x)*.047 :\n    \tx<.45 ? S(.15, .45, x)*.882+.047 :\n    \tx<.70 ? S(.70, .45, x)*.796+.133 :\n    \t\t\tS(1.0, .70, x)*.133;\n    \n    b = x<.18 ? S(0.0, .18, x)*.5 :\n    \tx<.22 ? S(.22, .18, x)*.1+.4 :\n    \tx<.35 ? S(.22, .35, x)*.059+.4 :\n    \tx<.54 ? S(.54, .35, x)*.334+.125 :\n    \tx<.60 ? S(.54, .60, x)*.169+.125 :\n    \tx<.69 ? S(.69, .60, x)*.243+.051 :\n    \tx<.72 ? S(.69, .72, x)*.043+.051 :\n    \tx<.89 ? S(.89, .72, x)*.094 : 0.;\n    \n    return vec3(r,g,b);\n}\n\nvec3 SpectrumPoly(float x) {\n    // https://www.shadertoy.com/view/wlSBzD\n    return (vec3( 1.220023e0,-1.933277e0, 1.623776e0)\n          +(vec3(-2.965000e1, 6.806567e1,-3.606269e1)\n          +(vec3( 5.451365e2,-7.921759e2, 6.966892e2)\n          +(vec3(-4.121053e3, 4.432167e3,-4.463157e3)\n          +(vec3( 1.501655e4,-1.264621e4, 1.375260e4)\n          +(vec3(-2.904744e4, 1.969591e4,-2.330431e4)\n          +(vec3( 3.068214e4,-1.698411e4, 2.229810e4)\n          +(vec3(-1.675434e4, 7.594470e3,-1.131826e4)\n          + vec3( 3.707437e3,-1.366175e3, 2.372779e3)\n            *x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0);\n    vec3 spectrum = mod(iTime, 2.)<1. ? Spectrum(uv.x) : SpectrumPoly(uv.x);\n    \n    col = spectrum*S(.3, .7, uv.y);\n    col += S(.01, .0, abs(spectrum-uv.y*2.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSBzD.jpg", "access": "api", "license": "mit", "functions": [[1648, 1648, 1672, 1717, 2434], [2436, 2436, 2464, 2509, 3037], [3039, 3039, 3096, 3096, 3362]], "test": "untested"}
{"id": "wlBBzD", "name": "wexercise2", "author": "wei", "description": "exercise", "tags": ["exercise"], "likes": 0, "viewed": 177, "published": 3, "date": "1598406858", "time_retrieved": "2024-07-30T20:48:59.959447", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n\tfloat l = length(uv-p);\n    float f = smoothstep(r,r-blur, l);\n    return f;\n}\n\nvec3 Smiley(vec2 uv, vec2 p, float size, float blur) {\n    uv -= p;\n    uv/=size;\n    float f = Circle(uv, vec2(0.,0.), 0.5, blur);\n    float eye = Circle(uv, vec2(0.2,0.2), 0.1, blur);\n\tf -= eye;\n    float eye2 = Circle(uv, vec2(-0.2,0.2), 0.1, blur);\n    f -= eye2;\n    \n    float mouth = Circle(uv, vec2(0.,0.01), 0.4, blur);\n    mouth -= Circle(uv, vec2(0.,0.12), 0.4, blur);\n    f -= mouth;\n    vec3 color = vec3(1.0, 1.0, 0.)*f;\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n   \t \t\tlog(iSampleRate);\n    uv.x += sin(iTime);\n    float x = uv.x;\n    float m=0.;\n   // m = sin(iTime+x*8.)*.1;\n    float y = uv.y-m;\n    float blur =0.01;\n   // blur =abs(sin(uv.x+iTime))*0.4;\n    // Time varying pixel color\n    vec3 f = vec3(0.);\n    f+= Smiley(vec2(x,y), vec2(0.), 0.8, blur); \n    \n    fragColor = vec4(f,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 132], [134, 134, 188, 188, 588], [591, 591, 648, 698, 1132]], "test": "untested"}
{"id": "WlBfzD", "name": "Atmospheric Scattering", "author": "CobaltXII", "description": "Atmospheric scattering based on Sebastian Lague's tutorial\nhttps://www.youtube.com/watch?v=DxfEbulyFcY", "tags": ["planet", "scattering", "atmospheric", "gas"], "likes": 38, "viewed": 1282, "published": 3, "date": "1598405426", "time_retrieved": "2024-07-30T20:49:00.715425", "image_code": "// Sun settings.\nconst float sunIntensity = 1.0;\n\n// Planet settings.\nconst vec3 planetPosition = vec3(0.0, 0.0, 3.0);\nconst float planetRadius = 1.5;\nconst vec3 planetColor = vec3(0.8);\n\n// Atmosphere settings.\nconst float atmosphereSize = 0.2;\nconst float densityFalloff = 3.0;\nconst vec3 wavelengths = vec3(750.0, 530.0, 400.0);\nconst float scatteringStrength = 15.0;\n\n// Atmosphere calculations.\nconst float atmosphereRadius = planetRadius + atmosphereSize;\nconst vec3 scatteringCoefficients = pow(400.0 / wavelengths, vec3(4.0)) * scatteringStrength;\n\n// Quality settings.\nconst int inScatterPoints = 20;\nconst int outScatterPoints = 20;\n\n// Globals.\nvec3 sunDirection;\n\n// Intersection of a ray with a sphere. Returns both intersection times as a\n// vector where x is the nearest intersection and y is the farthest\n// intersection.\nvec2 rayIntersectSphere(in vec3 ro, in vec3 rd, in vec3 ce, float ra) {\n\tvec3 oc = ro - ce;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - ra * ra;\n\tfloat h = b * b - c;\n\tif (h < 0.0) {\n\t\treturn vec2(-1.0);\n\t}\n\th = sqrt(h);\n\treturn vec2(-b - h, -b + h);\n}\n\n// The density at a position above the surface but below the atmosphere's edge.\nfloat densityAtPoint(in vec3 p) {\n\t// Get the elevation of the point above the surface of the planet.\n\tfloat elevation = length(p - planetPosition) - planetRadius;\n\n\t// Scale the elevation so that a point directly on the surface of the\n\t// planet would have a value of 0, and a point directly on the edge of the\n\t// atmosphere would have a value of 1.\n\tfloat elevationScalar = elevation / atmosphereSize;\n\n\t// Use some math to determine the density.\n\treturn exp(-elevationScalar * densityFalloff) * (1.0 - elevationScalar);\n}\n\n// Calculate the average density of the atmosphere along a given finite ray\n// multiplied by the ray's length. This is referred to as the optical depth of\n// the ray.\nfloat opticalDepth(in vec3 ro, in vec3 rd, float rl) {\n\tvec3 p = ro;\n\tfloat dt = rl / float(outScatterPoints - 1);\n\tfloat accumulatedDensity = 0.0;\n\tfor (int i = 0; i < outScatterPoints; i++) {\n\t\taccumulatedDensity += densityAtPoint(p) * dt;\n\t\tp += rd * dt;\n\t}\n\treturn accumulatedDensity;\n}\n\n// Accumulated light along a given finite ray (referred to as the light-ray).\nvec3 accumulateLight(in vec3 ro, in vec3 rd, float rl) {\n\tvec3 p = ro;\n\tfloat dt = rl / float(inScatterPoints - 1);\n\tvec3 accumulatedLight = vec3(0.0);\n\tfor (int i = 0; i < inScatterPoints; i++) {\n\t\t// Cast a ray from the current point to the sun. Store the length of\n\t\t// this ray.\n\t\tfloat sunRayLength = rayIntersectSphere(p, sunDirection, planetPosition, atmosphereRadius).y;\n\n\t\t// Calculate the optical depth of the sun-ray.\n\t\tfloat sunRayOpticalDepth = opticalDepth(p, sunDirection, sunRayLength);\n\n\t\t// Calculate the optical depth of the ray from the current point to the\n\t\t// origin of the light-ray.\n\t\tfloat viewRayOpticalDepth = opticalDepth(p, -rd, dt * float(i));\n\n\t\t// Use some math to calculate the transmission.\n\t\tvec3 transmission = exp(-(sunRayOpticalDepth + viewRayOpticalDepth) * scatteringCoefficients);\n\n\t\t// Get the density at the current point.\n\t\tfloat density = densityAtPoint(p);\n\t\t\n\t\t// Accumulate light.\n\t\taccumulatedLight += density * transmission * scatteringCoefficients * dt;\n\t\tp += rd * dt;\n\t}\n\t\n\treturn accumulatedLight;\n}\n\n// // Convert from polar coordinates to Cartesian coordinates.\n// vec3 polarToCartesian(vec2 polar) {\n// \treturn vec3(cos(p.x) * cos(p.y), sin(p.x) * cos(p.y), sin(p.y));\n// }\n\n// Main image.\nvoid mainImage(out vec4 rgba, in vec2 fragCoord) {\n    // Use the mouse to determine the sun's position.\n\tsunDirection = normalize(vec3((2.0 * iMouse.xy - iResolution.xy) / iResolution.y * 5.0, 1.0));\n\n    // Set up the camera.\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 ro = vec3(0.0, 0.0, -3.0);\n\tvec3 rd = normalize(vec3(uv, 2.0));\n\t\n    // The color of this fragment.\n\tvec3 rgb;\n\t\n\t// Raycast to the planet.\n\tvec2 planetIntersection = rayIntersectSphere(ro, rd, planetPosition, planetRadius);\n\tif (planetIntersection.x > 0.0) {\n\t\t// The planet was hit by the ray. Calculate the normal.\n\t\tvec3 p = ro + rd * planetIntersection.x;\n\t\tvec3 n = normalize(p - planetPosition);\n\t\t\n\t\t// Diffuse lighting.\n\t\tfloat diffuse = max(0., dot(n, sunDirection)) * sunIntensity;\n\t\t\n        // Coloring.\n\t\trgb = vec3(planetColor * diffuse);\t \n\t} else {\n\t\t// The planet was not hit by the ray. Do sun lighting.\n        float angle = max(0.0, dot(sunDirection, rd));\n        float sun = pow(angle, 150.0);\n        float aura = pow(angle, 800.0);\n\t\trgb = vec3(sun + aura);\n\t}\n\t\n    // Raycast to the atmosphere.\n\tvec2 atmosphereIntersection = rayIntersectSphere(ro, rd, planetPosition, atmosphereRadius);\n\tif (atmosphereIntersection.x > 0.) {\n\t  \t// Calculate the distance passed through the atmosphere by the ray,\n\t\t// taking into account the planet (which may obstruct the ray).\n\t\tfloat distanceThroughAtmosphere;\n\t\tif (planetIntersection.x > 0.0) {\n\t\t\t// Hits the planet.\n\t\t\tdistanceThroughAtmosphere = planetIntersection.x - atmosphereIntersection.x;\n\t\t} else {\n\t\t\t// Does not hit the planet.\n\t\t\tdistanceThroughAtmosphere = atmosphereIntersection.y - atmosphereIntersection.x;\n\t\t}\n\t\t\n        // Accumulate light along the finite ray starting where the ray first\n        // interescted with the atmosphere and ending where the ray either\n        // intersected the planet or exited the atmosphere.\n\t\tvec3 p = ro + rd * atmosphereIntersection.x;\n\t\tvec3 light = accumulateLight(p, rd, distanceThroughAtmosphere) * 1.2;\n\t\t\n        // Mix the lighting with the color.\n\t\trgb = rgb * (1.0 - light) + light;\n\t}\n\t\n    // Output the color.\n\trgba = vec4(rgb, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[676, 838, 909, 909, 1095], [1097, 1177, 1210, 1278, 1702], [1704, 1871, 1925, 1925, 2161], [2163, 2241, 2297, 2297, 3295], [3474, 3489, 3539, 3593, 5658]], "test": "untested"}
{"id": "wlBfzW", "name": "two bubble rings", "author": "cyperus", "description": "Parametric procedural 3d-object, allowing smooth transitions between spheres, tori, torusknots, based on julia fractal.\nhttps://www.youtube.com/user/cyperquantus\nhttps://www.shadertoy.com/view/3stSR8 Stephane Cuillerdier - Aiekick/2019 (twitter:@aiekick)", "tags": ["julia", "torus", "sphere", "knot"], "likes": 15, "viewed": 743, "published": 3, "date": "1598396806", "time_retrieved": "2024-07-30T20:49:01.635964", "image_code": "// Created by Patrik Colling - cyperus/2020 (https://www.youtube.com/user/cyperquantus)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Parametric procedural 3d-object allowing smooth transitions between \n// spheres, tori, torusknots.\n//\n\n#define AA\n\n#define PI 3.14159265359\n// Time modulation\n#define PIiTime PI * iTime\n#define sinTime02 sin(0.2*iTime)\n#define sinTime03 sin(0.3*iTime)\n#define sinTime05 sin(0.5*iTime)\n#define sinTime07 sin(0.7*iTime)\n\n// complex number transformations\n// z_out = za*zb\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);\n    }\n// z*e^ia\nvec2 crot(vec2 z, float a){\n    return cmul(z, vec2(cos(a),sin(a)));\n    }\n// z_out = z^q\nvec2 cpowq(vec2 z, float q){\n    float r = pow(length(z), q); float a=q* atan(z.y,z.x); return vec2(r*cos(a),r*sin(a));\n    }\n// z_out = (z*e^ia)^p-x0    \nvec2 ctfr(vec2 z,float x0, float p, float a){\n\treturn cpowq( cmul(z, vec2(cos(-a),sin(-a))),p) - vec2(x0, 0.);\n    }\n\n// came\nmat3 camerabase(vec3 co, vec3 ct, vec3 cup){\n    // co\t: camera origin point in worldspace\n    // cup\t: camera up direction vector in worldspace\n    // ct\t: camera target point in worldspace\n\tvec3 cw = normalize(ct - co);\t\t// camera ponting direction\n\tvec3 cu = normalize(cross(cup, cw));// camera left right\n\tvec3 cv = normalize(cross(cw, cu));\t// camera down up\n    return mat3(cu,cv,cw); // return camera orhtogonal basis as matrix\n}\n\nvec3 cameraraydirection(vec2 uv, mat3 cam, float f){\n    // uv : Viewport coordinates\n    // cam : camera orhtogonal basis\n    // f : focal length zoom-in: abs(f) ==> 0., zoom-out: abs(f) ==> +inf.\n    return normalize(cam * vec3(f*uv,1.)); \n}\n\nvec4 df(vec3 p)\n{\t///// MetaTorus-transformation\n    \n    // component swizzling: openGL => math coordinatesystem notation.\n    p = p.zxy; //(z, x, y) => (x, y, z)\n    \n    //// (torus,sphere,2spheres)-transformation\n    // cylindrical coordinate system\n    float au = atan(p.y, p.x); // [-PI, +PI]\n    float rxy = length(p.xy); // [0., +inf]\n    // 3D => 2D-space: radial half plane in cylindrical coordinate system == half complex plane\n    vec2 z = vec2(rxy, p.z);\n    // julia, half complex plane => complex plane\n\tfloat shift0 = 1.4+(1.0+sinTime05); // [-inf, +inf]\n    z = cmul(z,z)- vec2(shift0, 0.); // realaxis-translation, fraction == 2 \n    \n    //// juliafractal-transformation\n\t/// julia fractal iteration 0\n    const float fracu1 = 3.0; // int in [1,2,3,..]\n    const float fracv1 = 2.0; // int in [1,2,3,..]\n    const float twist1 = 0.0; // int in [...,-1,0,+1,...]\n    // shiftX modulation with FourierSerie F(fracu1 * au)\n    float shift1\t= 2.0 * sinTime02 \t\t\t\t\t\t\t\t\t\t\t\t// 0. order \n        \t\t\t+ 0.5 * cos(1. * (fracu1 * au) + (0.5 * PIiTime) );\t\t\t\t// 1. order\n            \t\t//+ 0.25 * cos(2. * (fracu1 * au) + (0.5 +0.01 * PIiTime) ); \t// 2. order\n    // torsionX must meet knot condition.\n    float torsion1 = au * twist1 / fracv1 - 0.25 * PIiTime;\n    z = ctfr(z, shift1, fracv1,  torsion1); // realaxis-translation,fraction,rotation\n\t/// julia fractal iteration 1\n    const float fracu2 = 7.0;\n    const float fracv2 = 3.0;\n    const float twist2 = 5.0;    \n    float shift2 = 0.5 +1.4 * sinTime03 + 0.5 * cos(fracu2 * au +0.0- 0.02 * PIiTime);\n    float torsion2 = au * twist2 / fracv2 + 0.05 * PIiTime;\n    z = ctfr(z, shift2, fracv2, torsion2);\n    \n\t/// estimated ray-step-length\n\tfloat d = log(length(z)); // :( but it works!\n\treturn vec4(d , z, au * fracu1 * fracu2);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0.0 );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    // antialeasing\n    for( int i=0; i<1; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .92), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n    //// Pixel2Viewport-space\n    vec2 o = rook[n];\n    vec2 uv = (2.*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else //AA\n\tvec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n#endif //AA\n      \n    // mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    //// camera, Viewport2World-space\n    m *= 0.49*PI; float aa = m.x; float ab = -m.y;\n    vec3 co = 4.*vec3( cos(ab)*sin(aa),sin(ab),cos(ab)*cos(aa)); // camera origin\n\tconst vec3 cup = vec3(0,1,0);\t    // camera up direction in Worldspace\n\tconst vec3 ct = vec3(0,0,0);\t    // camera target point in Worldspace\n\tmat3 cam = camerabase(co,ct,cup);   // cameradirection = cam[0];\n \n    const float f = 0.6;\n    vec3 rd =  cameraraydirection(uv,cam, f);\n    \n\t// ray marching\n    const float rayDistMax = 14.;\t// maximal ray distance length\n    const float rayiMax = 300.;\t\t// maximal ray marching iterations\n    const float rayF = 0.02;\t\t// ray step multiplier\n    const float rayEpsi = 0.0001;\n\tfloat rayStep = 1.; // ray step length\n    float rayDist = 0.; // ray distance length\n\tfor (float i=0.; i<rayiMax; i++){\n\t\tvec3 p = co + rd *rayDist; // point in 3D worldspace\t        \n\t\tif (abs(rayStep)<rayEpsi || rayDist>rayDistMax) break;\n\t\trayStep = df(p).x;\n\t\trayDist += rayStep * rayF;\t\n\t}\n    \n\t//// World2Color-space\n    const vec3 ld = vec3(0.,1.,.5); // ligth direction\n    const vec3 lc = vec3(0.4); // ligth color\n    vec3 col;\n    vec3 sky = GetSky(rd, ld, lc);\n\t\n\tif (rayDist<rayDistMax)  // intersection with object\n\t{\n        vec3 p = co + rd * rayDist;\t     \n\t\tvec3 n = nor(p, 0.001);\t// compute normale\n\t\tvec4 mat = df(p);\n        // uv-coords\n        vec2 mat_uv;\n        mat_uv.x = atan(mat[2],mat[1])/PI;\n        mat_uv.y = mat[3]/PI;\n        // texture color\n        const float smoothness = 0.05; // TODO: (2) Calculation inside df()?\n\t\tcol.rgb = vec3(smoothstep(-smoothness,smoothness,cos(PI*mat_uv.x)*cos(PI*mat_uv.y)));                             \n\t\t// lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.16).x);\n        float spe = pow(clamp( dot( rd, ld ), 0.0, 1.0 ),16.0);\n        float sss = df(p - n*0.001).x/0.01;\n        // shading\t\n        dif *= softshadow( p, ld, 0.1, 1. );\n        vec3 brdf = vec3(0.0);\n        brdf += 0.5*dif*vec3(1.00,0.90,0.60);\n        brdf += 0.5*spe*vec3(0.8,0.60,0.20)*dif;\n        brdf += 0.3*amb*vec3(0.40,0.60,0.40)*occ;\n        brdf += 0.4;\n        col.rgb *= brdf;\n        // fog\n        col.rgb = mix( col.rgb, sky, 1.0-exp( -0.02*rayDist*rayDist ) ); \n\t}\n\telse\n\t{// no intersection => background\n\t\tcol.rgb = sky;\n\t}\n    \n    tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    // gamma correction\n\tfragColor = vec4( sqrt(0.4*tot), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBfzW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[500, 551, 578, 578, 622], [623, 633, 660, 660, 707], [708, 723, 751, 751, 848], [849, 878, 923, 923, 994], [996, 1004, 1048, 1194, 1440], [1442, 1442, 1494, 1639, 1685], [1687, 1687, 1704, 1810, 3482], [3484, 3484, 3516, 3516, 3695], [3697, 3713, 3787, 3787, 4026], [4028, 4044, 4086, 4086, 4404], [4484, 4602, 4659, 4659, 4947]], "test": "untested"}
{"id": "Wl2fzR", "name": "23. Value Noise", "author": "altera0", "description": "source : https://www.youtube.com/watch?v=zXsWftRdsvU\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["valuenoise"], "likes": 1, "viewed": 250, "published": 3, "date": "1598396086", "time_retrieved": "2024-07-30T20:49:02.439815", "image_code": "/*\n\nQuestion And Answer. !\n\nMrSerozka\n4 months ago\nOn my PC that noise eventually become more vague until just gray screen.\n(when I open your shadertoy too). Why is that?\n\n\nThe Art of Code\n4 months ago\nIt could be that your graphics card doesn't have a very precise sine implementation for the random function. Try a different noise function. You could take one from a ShaderToy called 'hash without sine'\n\n*/\n\nfloat N21( vec2 p ) {\n   //float c = fract( sin (p.x*100.0 + p.y * 6574.0) * 5647.0 );\n    \n   float c = fract( sin (p.x*190.0 + p.y * 65.0) * 56.0 );\n   return c;\n}\n\nfloat SmoothNoise( vec2 uv ) {\n    \n    vec2 lv = fract(uv ); // level\n    //lv = smoothstep( 0.0 , 1.0 , lv );\t\t// smoothstep lv\n    lv = lv * lv * ( 3.0 - 2.0 * lv );\n    \n    vec2 id = floor(uv ); // id\n    \n    \n    float bl = N21( id );\n    float br = N21( id + vec2( 1 , 0 ) );\n    float b = mix( bl , br , lv.x );\n    \n    \n    float tl = N21( id + vec2( 0 , 1 ));\n    float tr = N21( id + vec2( 1 , 1 ));\n    float t = mix( tl , tr , lv.x );\n    \n    \n    float c = mix( b , t , lv.y );\n    \n \n    return c;\n}\n\n \nfloat SmoothNoise2( vec2 uv ) {\n  \tfloat c = 0.0;\n    \n    c += SmoothNoise( uv * 4.0  ) * 1.0;\n    c += SmoothNoise( uv * 8.0  ) * 0.5;\n    c += SmoothNoise( uv * 16.0 ) * 0.25;\n    c += SmoothNoise( uv * 32.0 ) * 0.125;\n    c += SmoothNoise( uv * 64.0 ) * 0.0625;\n    \n    c /= 2.0;   \n    return c;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    uv += iTime * 1.0;\n    float c = SmoothNoise2( uv );\n    \n    \n    vec3 col = vec3(c);\n    //col.rg = id * 0.1;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2fzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[411, 411, 432, 497, 576], [578, 578, 608, 608, 1095], [1099, 1099, 1130, 1130, 1402], [1406, 1406, 1463, 1463, 1659]], "test": "untested"}
{"id": "Wt2fzR", "name": "22. Mandelbrot Fractal Explain", "author": "altera0", "description": "Source : https://www.youtube.com/watch?v=6IWXkV82oyY\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["simpleonet"], "likes": 1, "viewed": 283, "published": 3, "date": "1598394182", "time_retrieved": "2024-07-30T20:49:03.336418", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy )/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float zoom = pow( 10.0 , -m.x * 2.0 );\n    \n    vec2 c = uv * zoom * 5.0 - vec2(0.65 , 0.0);\n    \n    vec2 z = vec2(0);\n    float iter = 0.0;\n    const float max_iter = 100.0;\n    \n    \n    float k = 2.0 + 2.0* sin(iTime );\n    \n    for ( float i = 0.0; i < max_iter ; i++ ) {\n        \n\t\tz = vec2( z.x * z.x - z.y * z.y , k * z.x * z.y ) + c;\n        \n        if ( length(z) > 2.0 ) break;\n        \n        iter++;\n        \n    }\n    \n    \n\n    float f = iter / max_iter;\n    \n    vec3 col = vec3(f);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2fzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 706]], "test": "untested"}
{"id": "wlSBzW", "name": "Border Ripple effect", "author": "Darkimage", "description": "Simple ripple effect that stops at borders, not optimized.", "tags": ["2d", "distancefield", "rippleeffect"], "likes": 2, "viewed": 367, "published": 3, "date": "1598393078", "time_retrieved": "2024-07-30T20:49:04.099378", "image_code": "//Created by Luca Faggion \n\nconst float maxsize = 1.1;\nconst float offset = 0.05;\nconst float speed = 1.5;\nconst vec2 uvoffset = vec2(0.2,0.2);\nconst bool useDisplacement = true;\nconst bool useMouse = true;\n\n\n//All df function taken from the df master iq\n//https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat displacement(float d1, vec3 p, sampler2D channel, float strength, float tile)\n{\n    float d2 = texture(iChannel0, p.xy*tile).x * strength;\n    return d1+d2;\n}\n\nfloat scene(vec2 uv) {\n    vec3 uvs = vec3(uv,0.);\n    vec3 sphereuvs = vec3(uv - uvoffset,0.);\n    if(useMouse){\n    \tvec2 mouseuv = iMouse.xy/iResolution.yy - vec2((iResolution.x/iResolution.y)/2.,0.5);\n        sphereuvs = vec3(uv - mouseuv,0.);\n    }\n\tfloat scene = 0.;\n    float sphere = sdSphere(sphereuvs, maxsize*(sin(iTime*speed)/2.+0.5));\n    float sphere2 = sdSphere(sphereuvs, maxsize*(sin(iTime*speed)/2.+0.5) + offset);\n    float box = sdRoundBox(uvs, vec3(0.79,0.41,1.0), 0.05);\n    if(useDisplacement){\n    \tsphere2 = displacement(sphere2, uvs, iChannel0, 0.1, 0.7);\n    \tsphere = displacement(sphere, uvs, iChannel0, 0.1, 0.7);\n        box = displacement(box, uvs, iChannel0, 0.04, 01.2);\n    }\n    scene = sphere;\n    scene = opIntersection(scene,box);\n    scene = opSubtraction(scene,sphere2);\n\treturn scene;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) with 1-1 ration (square)\n    vec2 uv = (fragCoord/iResolution.yy) - vec2((iResolution.x/iResolution.y)/2.,0.5);\n    \n    //Render the dfs\n    float render = scene(uv);\n    \n    //Hard Edge Visualization https://www.ronja-tutorials.com/2018/11/10/2d-sdf-basics.html#visualisation\n    float distanceChange = fwidth(render) * 5.; //change the multiply to soften the edges\n    float antialiasedCutoff = smoothstep(distanceChange, -distanceChange, render);\n    \n    //Final output\n    float scenecolor = antialiasedCutoff;\n    fragColor = vec4(scenecolor,scenecolor,scenecolor,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 303, 338, 338, 362], [364, 364, 409, 409, 500], [502, 502, 539, 539, 561], [563, 563, 606, 606, 628], [630, 630, 674, 674, 695], [697, 697, 782, 782, 861], [863, 863, 885, 885, 1691], [1694, 1694, 1751, 1826, 2381]], "test": "untested"}
{"id": "3lBfRD", "name": "#857 - Daily Experiments", "author": "sixclones", "description": "One more day.", "tags": ["3d", "raymarching", "experiments", "daily"], "likes": 5, "viewed": 254, "published": 3, "date": "1598383644", "time_retrieved": "2024-07-30T20:49:04.853362", "image_code": "// Inspired by: https://www.youtube.com/watch?v=-adHIyjIYgk\n// From BigWIngs: https://www.shadertoy.com/user/BigWIngs\n\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t 1.25 * iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define EPS 0.001\n#define STEPS 128.0\n#define DIST 0.01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\nvec2 rotate2d(vec2 uv, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c) * uv;\n}\n\nfloat circleSDF(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat gyroidSDF(vec3 p, float s, float th) {\n  p *= s;\n  return abs(dot(sin(t + p), cos(-t + p.zxy))) / s - th;\n}\n\nfloat sceneSDF(vec3 p) {\n  vec3 _p = p;\n\n  float circle = circleSDF(p, 3.0);\n\n  p.y += t + cos(t);\n  p.z += t + sin(t);\n  float gyroid = gyroidSDF(p, 2.5, 0.025);\n\n  return max(circle, 0.5 * gyroid);\n}\n\nvec3 computeNormal(vec3 p) {\n  float center = sceneSDF(p);\n  vec3 offset = vec3(0.0, EPS, 0.0);\n\n  return normalize(vec3(\n    center - sceneSDF(p + offset.yxx),\n    center - sceneSDF(p + offset.xyx),\n    center - sceneSDF(p + offset.xxy)\n  ));\n}\n\nvec3 computeSurface(vec3 pos, float f) {\n  vec3 normal = computeNormal(pos);\n\n  vec3 lightPos = vec3(1.0, 2.0, 3.0);\n  vec3 lightColor = vec3(0.3922, 0.6157, 0.8275);\n  float light = max(0.0, dot(normal, lightPos));\n\n  vec3 ambient = vec3(0.1255, 0.0039, 0.0667);\n\n  float fog = 5.0 / pow(f, 2.0);\n\n  return fog * light * lightColor + ambient;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 color = vec3(0.8235, 0.9608, 0.9373);\n\n  vec3 rd = normalize((vec3(uv, 1.0)));\n  vec3 ro = vec3(0.0, 0.0, -7.5);\n\n  float angle = -0.5 * QP;\n  rd.yz = rotate2d(rd.yz, angle);\n  ro.yz = rotate2d(ro.yz, angle);\n\n  float f = 10.0 / STEPS;\n  for (float i = 0.0; i < STEPS; i++) {\n    vec3 pos = ro + f * rd;\n    float scene = sceneSDF(pos);\n    if (scene < DIST) {\n      color = computeSurface(pos, f);\n      break;\n    }\n    f += scene;\n  }\n\n  fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[424, 424, 498, 498, 570], [572, 572, 621, 621, 677], [679, 679, 712, 712, 787], [789, 789, 823, 823, 849], [851, 851, 895, 895, 964], [966, 966, 990, 990, 1167], [1169, 1169, 1197, 1197, 1414], [1416, 1416, 1456, 1456, 1761], [1763, 1763, 1818, 1818, 2386]], "test": "untested"}
{"id": "wtBBz1", "name": "Drawing Symbols", "author": "BackwardsCap", "description": "Draw by clicking\nHold shift to subtract", "tags": ["symbols"], "likes": 8, "viewed": 355, "published": 3, "date": "1598363920", "time_retrieved": "2024-07-30T20:49:05.764925", "image_code": "//#define GRID\n\nvoid mainImage(out vec4 c, in vec2 f)\n{\n    \n    c=S0(f/R);\n    \n#ifdef GRID\n    f = (2.*f-R)/R.y*res;\n    f=fract(f);\n    if(f.x<.01||f.y<.01)\n        c.rgb+=.1;\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Ancient Symbols\n//by Sam Gates (BackwardsCap)\n\n//Code is gross; I will optimize it at a later date\n#define R iResolution.xy\n#define PI 3.1415927\n#define m vec2(5.+2.*4.,10.)\n#define SS(U) smoothstep(PX, 0., U)\n\n//#define MORPH\n\n//Any advice on fixing the inconsistency on the connecting edges when you resize the screen would be very welcome\n#define PX 30./R.y\n\n\nfloat rand (vec2 p)\n{\n\n    p=floor(p);\n\tp/=res;    \n    vec2 r = ((p*R.y)+R)/2.;\n    r=r/R;\n    if(r.y>.99||r.y<-0.01 || r.x>.99 || r.x<-0.01)return 0.;\n    return S0(r+.01).x;\n}\n\nmat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\n//https://www.shadertoy.com/view/4llXD7\nfloat B(vec2 p, vec2 b, vec4 r)\n{\n    r.xy = p.x>0.0?r.xy : r.zw;\n    r.x = p.y>0.0 ? r.x : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return SS(min(max(q.x,q.y),0.0)+length(max(q,0.0))-r.x);\n}\n\nbool removed(float h, vec2 p)\n{\n    vec2 lp = mod(p,m);\n    \n    return h==0.;\n}\n\n\nfloat C(vec2 p){return SS(length(p-.5)-.4);}\n\nfloat CL(vec2 p, float a)\n{\n    vec2 bp = (p-.5);\n    bp*=rot(PI/4.*a);\n    bp.x+=.5;\n    return B(bp, vec2(.6,.345), vec4(.3));\n}\n\nfloat CE(vec2 p, vec2 o)\n{\n    return B((p+o)*rot(PI/4.), vec2(.5), vec4(0));\n}\n\nfloat EL(vec2 p, float t)\n{\n    vec2 b = vec2(.5,.4-PX);\n    p-=vec2(.5,.5);\n    p*=rot(PI/2.*t);\n    p.x+=PX;\n    vec4 r = vec4(b.x-b.x/2.,b.x-b.x/2.,0,0);\n    return B(p, b, r);\n}\n\nfloat D(vec2 p, float r)\n{\n    p-=.5;\n    p*=rot(PI/2.*r);\n    p+=.13;\n    float b1 = B(p,vec2(.5),vec4(.5,0,0,0));\n    p+=.77;\n    float b2 = B(p,vec2(.5),vec4(0,0,0,.025));\n    return b1-b2;\n}\n\n\nfloat T(vec2 p, float r)\n{\n    p-=.5;\n    p*=rot(PI/2.*r);\n    return B(p,vec2(.4-PX,.6), vec4(0));\n}\n\nfloat render(vec2 p, float h)\n{\n    bool neighbors[9];\n    int ul=6,u=7,ur=8,l=3,me=4,r=5,dl=0,d=1,dr=2;\n    int n=0;\n\n    float o = 0.;\n    float of = 1.;\n    for(float y=-of;y<=of;y+=of)\n    {\n        for(float x=-of;x<=of;x+=of){\n\n            int i = int(ceil(x+1.)+ceil(y+1.)*3.);\n\n            vec2 pos = floor(p+vec2(x,y));\n\n            neighbors[i]= !removed(rand(pos),pos);\n\n            if(i!=me&&neighbors[i])\n            {\n                n++;\n            }\n        }\n    }\n    \n    p=fract(p);\n\t\n    if(neighbors[me])\n    {\n        if(n==0) return C(fract(p));\n\t\t\n        if(neighbors[u]&&neighbors[d]){\n\n            float o = T(p,0.);\n            if(neighbors[l])o+=EL(p+vec2(.175,0),0.);\n            if(neighbors[r])o+=EL(p-vec2(.175,0),2.);\n            return o;\n        }\n        if(neighbors[l]&&neighbors[r])\n        {\n            float o = T(p,1.);\n            if(neighbors[u])o+=EL(p-vec2(0,.25),1.);\n            if(neighbors[d])o+=EL(p+vec2(0,.25),3.);\n            return o;\n        }\n\n\n        if(neighbors[u]&&!neighbors[d]&&!neighbors[l]&&!neighbors[r])\n        {\n            float o = EL(p-vec2(0,.3),1.);\n\n            if(neighbors[dl]) o+=CL(p-vec2(.175),7.);\n            if(neighbors[dr]) o+=CL(p-vec2(-.175,.175),5.);\n\n            return o;\n        }\n\n        if(neighbors[d]&&!neighbors[u]&&!neighbors[l]&&!neighbors[r])\n        {\n            float o = EL(p+vec2(0,.3),3.);\n\n            if(neighbors[ul]) o+=CL(p+vec2(-.175,.175),1.);\n            if(neighbors[ur]) o+=CL(p+vec2(.175),3.);\n\n            return o;\n        }\n\n        if(neighbors[l]&&!neighbors[r]&&!neighbors[d]&&!neighbors[u])\n        {\n            float o = EL(p+vec2(.3,0),0.);\n\n            if(neighbors[ur]) o+=CL(p+vec2(.175,.175),3.);\n            if(neighbors[dr]) o+=CL(p-vec2(-.175,.175),5.);\n\n            return o;\n        }\n\n        if(neighbors[r]&&!neighbors[l]&&!neighbors[d]&&!neighbors[u])\n        {\n            float o = EL(p-vec2(.3,0),2.);\n\n            if(neighbors[ul]) o+=CL(p+vec2(-.175,.175),1.);\n            if(neighbors[dl]) o+=CL(p-vec2(.175),7.);\n\n            return o;\n        }\n        float j = 0.0;\n        if(!neighbors[u]&&neighbors[r]&&!neighbors[l]&&neighbors[d])j+= D(p,3.);\n        if(neighbors[u]&&neighbors[r]&&!neighbors[l]&&!neighbors[d])j+= D(p,2.);\n        if(!neighbors[u]&&!neighbors[r]&&neighbors[l]&&neighbors[d])j+= D(p,0.);\n        if(neighbors[u]&&!neighbors[r]&&neighbors[l]&&!neighbors[d])j+= D(p,1.);\n        if(neighbors[ul]&&!neighbors[l]&&!neighbors[u]) j+=CL(p+vec2(-.175,.175),1.);\n        if(neighbors[dl]&&!neighbors[l]&&!neighbors[d]) j+=CL(p-vec2(.175),7.);\n        if(neighbors[ur]&&!neighbors[r]&&!neighbors[u]) j+=CL(p+vec2(.175,.175),3.);\n        if(neighbors[dr]&&!neighbors[r]&&!neighbors[d]) j+=CL(p-vec2(-.175,.175),5.);\n        \n\n        return  j;\n    }else{\n        float o = 0.0;\n        if(!neighbors[ul]&&neighbors[u]&&neighbors[l])o+= CE(p,vec2(.07,-1.15));\n        if(!neighbors[ur]&&neighbors[u]&&neighbors[r])o+= CE(p, vec2(-1.11));\n        if(!neighbors[dl]&&neighbors[d]&&neighbors[l])o+= CE(p,vec2(.11));\n        if(!neighbors[dr]&&neighbors[d]&&neighbors[r])o+= CE(p,vec2(-1.11,.11));\n        return o;\n    }\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n\n    vec2 p = (2.0*f-R)/R.y*res;\n    float hash = rand(p);\n    vec3 col = vec3(1);\n    c.rgb=vec3(clamp(render(p,hash),0.,1.));\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/* Memory / Drawing */\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 p = (2.*f-R)/R.y * res;\n    vec2 id = floor(p);\n    float v = S0(f/R).r;\n    vec2 m = (2.*iMouse.xy-R)/R.y*res;\n    if(iMouse.z>0. && floor(m)==id){\n        v=holdingShift?0.:1.;\n    }\n    c.rgb = vec3(v);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define S0(U) texture(iChannel0, U)\n#define S1(U) texture(iChannel1, U)\n#define holdingShift (S1(vec2(16.5)/256.).x>0.)\n#define res 5.0", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 55, 55, 187]], "test": "untested"}
{"id": "3ljBzh", "name": "castle45", "author": "lennyjpg", "description": "asdfasdf", "tags": ["adfasdf"], "likes": 3, "viewed": 267, "published": 3, "date": "1598354001", "time_retrieved": "2024-07-30T20:49:06.659533", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.x;\n    float t = iTime * .1;\n    //float cc = length(uv-0.5)*0.8;\n    uv.x += t;\n    vec2 u = uv;\n    u *= 7.0; \n    u *= floor(u.y + 1.);\n    u.x += step(1.,mod(u.y,2.))*.5; // x offset\n   // float g = rand(vec2(floor(u.x),floor(u.y)));\n   // g+=sin(uv.x*20.0+t*10.0)*0.2;\n    u = fract(u);\n    float h = .35;\n    if(u.y < h){\n        u.y = h;  \n    }\n    vec2 off = vec2(0.5,h);\n    float d = length(u - off);  \n    float r = smoothstep(d , d*1.1, .45);\n    float k = r;\n    if(uv.y > .38){\n        float q = fract(uv.x*5.0+uv.y*3.0) - uv.y * 6. + 2.3;\n        k = step(q,0.0);\n    }\n    //k=min(k,step(cc,0.5));\n    vec3 colorA = vec3(1.,.9,.8),\n     colorB = vec3(.05,0.,.1),\n     colorC = mix(colorA, colorB, k);\n    fragColor = vec4(colorC, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 151, 151, 944]], "test": "untested"}
{"id": "Wt2BR1", "name": "Emergence of life", "author": "michael0884", "description": "No really, what the heck", "tags": ["particles", "ca"], "likes": 195, "viewed": 10552, "published": 3, "date": "1598321080", "time_retrieved": "2024-07-30T20:49:07.761586", "image_code": "// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.56\n#define RAD R.x*0.6\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 16.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.03*iTime, -0.4)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo =sin(vec3(1,2,3)*3.*D*D);\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 4.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 8.);\n            colB += 4.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 8.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(2.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol=sin(vec4(1,2,3,4)*25.*r*r*r);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n//i.e. diffusion \n#define distribution_size 1.7\n\n//slime mold sensors\n#define sense_num 12\n#define sense_ang 0.2\n#define sense_dis 40.\n//weird oscillation force\n#define sense_oscil 0.0 \n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force 0.11\n//slime mold sensor distance power law dist = sense_dispow(rho, pw)\n#define distance_scale 0.\n#define force_scale 2.\n#define acceleration 0.\n\n#define density_normalization_speed 0.25\n#define density_target 0.24\n#define vorticity_confinement 0.0\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n   \n//density*temp = pressure - i.e. ideal gas law\n#define Pressure(rho) 0.9*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, density_target, density_normalization_speed);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n     \n        F -= 1.0*M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component from slime force and leave rotation only\n        slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-vorticity_confinement*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor = C(pos - V0*dt);\n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy = pos/R;\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2BR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 440, 467, 467, 645], [685, 685, 716, 716, 750], [752, 752, 804, 804, 923], [925, 925, 960, 960, 984], [986, 986, 1017, 1017, 1104], [1106, 1106, 1127, 1127, 1220], [1222, 1222, 1244, 1244, 1340], [1343, 1343, 1363, 1363, 1559], [1562, 1562, 1597, 1597, 1782], [1821, 1821, 1853, 1853, 2021], [2023, 2023, 2068, 2068, 4827]], "test": "untested"}
{"id": "3ljBR1", "name": "raymarched infinite cubes", "author": "xacer", "description": "Hello world of raymarching.\nTips would be appreciated, as I'm not very experienced with ShaderToy", "tags": ["raymarching", "infinite"], "likes": 5, "viewed": 337, "published": 3, "date": "1598319509", "time_retrieved": "2024-07-30T20:49:08.614306", "image_code": "// First program\n\n\nvec3 cameraPosition = vec3(0.0);\nmat3 cameraMatrix = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\nfloat distanceEstimator(vec3 z) {\n    vec3 oz = mod(z, 4.0) - 2.0;\n    return length(oz - clamp(oz, -1.0, 1.0)) - .2;\n}\n\nvec3 xDir = vec3(0.0001, 0, 0);\nvec3 yDir = vec3(0, 0.0001, 0);\nvec3 zDir = vec3(0, 0, 0.0001);\nvec3 lightDirection = normalize(vec3(0.5, 0.5, -1.0));\n\nvec3 surfaceNormal (vec3 pos) {\n    vec3 normal = vec3(\n        distanceEstimator(pos + xDir) - distanceEstimator(pos - xDir),\n        distanceEstimator(pos + yDir) - distanceEstimator(pos - yDir),\n        distanceEstimator(pos + zDir) - distanceEstimator(pos - zDir)\n    );\n    return normalize(normal);\n}\n\nvec3 trace (vec3 origin, vec3 direction) {\n    float totalDistance = 0.0;\n\n    for (float steps = 0.0; steps < 400.0; steps ++) {\n        vec3 pos = origin + direction * totalDistance;\n        float distance = distanceEstimator(pos);\n        totalDistance += distance;\n        if (distance < 0.001) {\n            vec3 normal = surfaceNormal(pos);\n            float diffuse = max(dot(normal, lightDirection), 0.0);\n            float specular = dot(reflect(direction, normal), lightDirection);\n\t\t\t\n            vec3 texPos = (mod(pos, 4.0) - 2.0);\n            \n            vec2 texPos2 = texPos.xy;\n            \n            if (abs(normal.x) > abs(normal.y) && abs(normal.x) > abs(normal.z)) {\n            \ttexPos2 = texPos.yz;\n            } else if (abs(normal.y) > abs(normal.z)) {\n            \ttexPos2 = texPos.xz;\n            } else {\n            \ttexPos2 = texPos.xy;\n            }\n            \n            specular = pow(max(specular, 0.0), 200.0);\n\n            float shade = 0.6 * diffuse + 0.4 * specular + 0.1;            \n            vec3 tint = texture(iChannel1, texPos2).rgb;\n            float m = mod(floor(pos.x/4.0) + floor(pos.y/4.0) + floor(pos.z/4.0), 4.0);\n            if (m == 0.0) {\n            \ttint = texture(iChannel0, texPos2).rgb;\n            } else if (m == 1.0) {\n            \ttint = texture(iChannel1, texPos2).rgb;\n            } else if (m == 2.0) {\n            \ttint = texture(iChannel2, texPos2).rgb;\n            } else {\n            \ttint = texture(iChannel3, texPos2).rgb;\n            }\n            return shade * tint;\n\n\n        }\n    }\n    return 0.2 * vec3(232.0, 159.0, 14.0) / 255.0;\n}\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 1.0 - 2.0 * fragCoord/iResolution.xy;\n\t\n    vec3 ray = normalize(vec3(uv.xy, 1.0));\n    \n    vec3 res = trace(cameraPosition + vec3(0, 0, iTime), ray);\n\n    // Output to screen\n    fragColor = vec4(res.rgb,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 138, 138, 224], [378, 378, 409, 409, 684], [686, 686, 728, 728, 2308], [2316, 2316, 2373, 2424, 2652]], "test": "untested"}
{"id": "Wt2fzh", "name": "Line creatures", "author": "michael0884", "description": "SPACE to restart\nRecommended to watch in 4x acceleration\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 37, "viewed": 1143, "published": 3, "date": "1598317961", "time_retrieved": "2024-07-30T20:49:09.562770", "image_code": "// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.56\n#define RAD R.x*0.6\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 2.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.03*iTime, -0.3)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo =vec3(D+0.01);\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 4.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 8.);\n            colB += 4.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 8.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(2.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol=vec4( 2.*r);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 1.4\n\n/* FIRE\n//mold stuff \n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 420.\n#define sense_oscil 0.1\n#define oscil_scale 1.\n#define oscil_pow 2.\n#define sense_force -0.35\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n*/\n\n#define sense_num 12\n#define sense_ang 0.07\n#define sense_dis 15.\n#define sense_oscil 0.0\n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force 0.8\n#define distance_scale 1.\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.3*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.25, 0.34);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= 0.5*M*dgrad;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n        slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor = C(pos - V0*dt);\n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy = pos/R;\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2fzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 440, 467, 467, 645], [685, 685, 716, 716, 750], [752, 752, 804, 804, 923], [925, 925, 960, 960, 984], [986, 986, 1017, 1017, 1104], [1106, 1106, 1127, 1127, 1220], [1222, 1222, 1244, 1244, 1340], [1343, 1343, 1363, 1363, 1558], [1561, 1561, 1596, 1596, 1781], [1820, 1820, 1852, 1852, 2020], [2022, 2022, 2067, 2067, 4798]], "test": "untested"}
{"id": "3tjfzh", "name": "Slime mold advection", "author": "michael0884", "description": "SPACE to restart\nRecommended to watch in 4x acceleration\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 45, "viewed": 1096, "published": 3, "date": "1598315091", "time_retrieved": "2024-07-30T20:49:10.496274", "image_code": "// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.56\n#define RAD R.x*0.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.0*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = 0.5*(D+0.07)*texture(iChannel3, c.xy).xyz;\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= 1.7*r*texture(iChannel3, c.xy + pos/R);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 1.4\n\n/* FIRE\n//mold stuff \n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 420.\n#define sense_oscil 0.1\n#define oscil_scale 1.\n#define oscil_pow 2.\n#define sense_force -0.35\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n*/\n\n#define sense_num 12\n#define sense_ang 0.2\n#define sense_dis 11.\n#define sense_oscil 0.0\n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force 0.2\n#define distance_scale 1.\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.09\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.3*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.2, 0.05);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n       // slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor.xy = C(pos - V0*dt).xy - V0*dt/R;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy =vec2(0.);\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 440, 467, 467, 645], [685, 685, 716, 716, 750], [752, 752, 804, 804, 923], [925, 925, 960, 960, 984], [986, 986, 1017, 1017, 1104], [1106, 1106, 1127, 1127, 1220], [1222, 1222, 1244, 1244, 1340], [1343, 1343, 1363, 1363, 1558], [1561, 1561, 1596, 1596, 1781], [1820, 1820, 1852, 1852, 2020], [2022, 2022, 2067, 2067, 4857]], "test": "untested"}
{"id": "3l2fRh", "name": "Simple Music Equalizer", "author": "Gerard97", "description": "Testing Music Input", "tags": ["music", "equalizer", "sfx"], "likes": 6, "viewed": 755, "published": 3, "date": "1598311105", "time_retrieved": "2024-07-30T20:49:11.254248", "image_code": "vec3 interpool(vec3 p0, vec3 p1, vec3 p2, float t) {\n    t = clamp(t, 0., 1.);\n    float oneMinusT = 1. - t;\n    \n    return\n        oneMinusT * oneMinusT * p0 +\n        2. * oneMinusT * t * p1 +\n        t * t * p2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 px = gl_FragCoord.xy / iResolution.xy;\n    \n    const int size = 32;\n    \n    const float inv = 1. / float(size);\n    \n    float sfx[size];   \n        \n    vec3 colors[size];\n        \n    for (int i = 0; i < size; ++i) {\n        \n        float scale = 0.75;\n        \n        sfx[i] = texelFetch(iChannel0, ivec2(int(float(i)/float(size)*512.),0), 0).x * scale;\n        //sfx[i] = texture(iChannel0, vec2(float(i)*inv, 0)).x * scale;\n                \n        /*colors[i] = vec3(cos(1. - px.x + iTime) * 0.5 +0.5, \n                         1. - cos(iTime)*sin(iTime)* 0.5 +0.5, \n                         sin(1. - px.x + iTime) * 0.5 +0.5);*/\n                \n        colors[i] = interpool(vec3(0,0,1), vec3(0.2,1,0.2), vec3(1,0.2,0), sfx[i]/0.75);\n    }\n    \n    \n    \n\tint index = int(px.x / inv);\n               \n    float height = sfx[index];\n    \n    if (px.y > height || mod(px.x, inv) < 0.008 || mod(px.y, inv) < 0.008) {\n    \tfragColor = vec4(vec3(0,0,0), 1);    \n    }\n    else {\n        //Use % to hide first and last bar\n        fragColor = vec4(colors[index], 1) * float((bool(index % (size-1))));\n    }\n    \n    if (abs(texelFetch(iChannel0, ivec2(int(px.x*512.),1), 0).x * 0.25 - (px.y - 0.75)) < 0.01) {\n        fragColor.xyz += vec3(1);   \n    }\n}", "image_inputs": [{"id": 28705, "src": "https://soundcloud.com/iamtchami/tchami-x-janet-jackson-go-deep?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2fRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 217]], "test": "untested"}
{"id": "3ljBRh", "name": "Wavey texture pattern", "author": "ChocolatePinecone", "description": "A little wave effect on top of a texture", "tags": ["wave", "texture"], "likes": 2, "viewed": 309, "published": 3, "date": "1598303250", "time_retrieved": "2024-07-30T20:49:12.153844", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying texture pos\n    float offset = 0.1 * sin(iTime * 1.5 + uv.x);\n    offset += 0.05 * sin(iTime * 7.5 + uv.x);\n    uv.y += offset;\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 397]], "test": "untested"}
{"id": "tlBfz1", "name": "Parallax Nightsky", "author": "hugoaboud", "description": "Linear gradient background and 3 star layers, moving in parallax.", "tags": ["parallax", "sky", "stars", "night"], "likes": 16, "viewed": 1320, "published": 3, "date": "1598302070", "time_retrieved": "2024-07-30T20:49:13.157160", "image_code": "/**\n\tParallax Stars\n\tshader by @hugoaboud\n\t\n\tLicense: GPL-3.0\n**/\n\n/**\n\tProperties\n**/\n\n// Background Gradient\nvec4 _TopColor = vec4(0.24,0.27,0.41,1);\nvec4 _BottomColor = vec4(0.07,0.11,0.21,1);\n\n// Star colors\nvec4 _Star1Color = vec4(1,0.94,0.72,0.7);\nvec4 _Star2Color = vec4(0.18,0.03,0.41,0.7);\nvec4 _Star3Color = vec4(0.63,0.50,0.81,0.7);\n\n// Star grid\nfloat _Grid = 40.0;\nfloat _Size = 0.15;\n\n// Parallax Speed\nvec2 _Speed = vec2(0, 3);\n\n/**\n\tUtilities\n**/\n\n// Generates a random 2D vector from another 2D vector\n// seed must be a large number\n// output range: ([0..1[,[0..1[)\nvec2 randVector(in vec2 vec, in float seed)\n{\n    return vec2(fract(sin(vec.x*999.9+vec.y)*seed),fract(sin(vec.y*999.9+vec.x)*seed));\n}\n\n/**\n\tStar shader\n**/\n\n// Draw star grid\nvoid drawStars(inout vec4 fragColor, in vec4 color, in vec2 uv, in float grid, in float size, in vec2 speed, in float seed)\n{\n    uv += iTime * speed;\n    \n    // Split UV into local grid\n    vec2 local = mod(uv,grid)/grid;\n    \n    // Random vector for each grid cell\n    vec2 randv = randVector(floor(uv/grid), seed)-0.5;\n    float len = length(randv);\n    \n    // If center + random vector lies inside cell\n    // Draw circle\n    if (len < 0.5) {\n        // Draw circle on local grid\n        float radius = 1.0-distance(local, vec2(0.5,0.5)+randv)/(size*(0.5-len));\n        if (radius > 0.0) fragColor += color*radius;\n    }\n}\n\n/**\n\tMain frag shader\n**/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Background\n    fragColor = mix(_TopColor, _BottomColor, fragCoord.y/iResolution.y);\n    \n    // Stars\n    drawStars(fragColor, _Star1Color, fragCoord, _Grid, _Size, _Speed, 123456.789);\n   \tdrawStars(fragColor, _Star2Color, fragCoord, _Grid*2.0/3.0, _Size, _Speed/1.2, 345678.912);\n    drawStars(fragColor, _Star3Color, fragCoord, _Grid/2.0, _Size*3.0/4.0, _Speed/1.6, 567891.234);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBfz1.jpg", "access": "api", "license": "gpl-3.0", "functions": [[464, 583, 628, 628, 718], [742, 760, 885, 885, 1389], [1418, 1418, 1474, 1496, 1869]], "test": "untested"}
{"id": "tlSBzh", "name": "Icosahedron experiments", "author": "illus0r", "description": "IcosSym by https://www.shadertoy.com/view/MdXfWS", "tags": ["geometry"], "likes": 8, "viewed": 291, "published": 3, "date": "1598288157", "time_retrieved": "2024-07-30T20:49:14.190397", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n#define RAY 1.\n#define BLUE 2.\n#define BLACK 3.\n#define BG 4.\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n} // TODO replace with Rot\n\nfloat sdSphere(vec3 p, float radius) { return length(p) - radius; }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\nfloat rnd( float x ) { return fract(10000. * sin(x * 1000.));}\n\nfloat sdTorus(vec3 p, float smallRadius, float largeRadius) {\n    return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n\nvec3 IcosSym (vec3 p)\n{\n  float dihedIcos = 0.5 * acos (sqrt (5.) / 3.);\n  float a, w;\n  w = 2. * PI / 3.;\n  p.z = abs (p.z);\n  p.yz = Rot2D (p.yz, - dihedIcos);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 4; k ++) {\n    p.zy = Rot2D (p.zy, - dihedIcos);\n    p.y = - abs (p.y);\n    p.zy = Rot2D (p.zy, dihedIcos);\n    if (k < 3) p.xy = Rot2D (p.xy, - w);\n  }\n  p.z = - p.z;\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.x -= 2. * p.x * step (0., p.x);\n  return p;\n}\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nfloat rayTexSpeed = 0.2;\n\nvec2 getDist(vec3 p) {\n    \n    \n       float rayLen = 0.8;\n    float ballScale = 1.;\n    float sphereSize = 0.5;\n    float sphereShift = sin(iTime * 5.);\n     float boxRotation = .5 + .5 * sin(iTime) - 1.;\n    float boxGlitch = 0.1;\n    float rayAmp = 0.3;\n    float rayFreq = 2.5;\n\n  vec3 pplan = p;\n  pplan.x += iTime * 40.;\n  pplan.z -=  pow((sin(pplan.x) + sin(pplan.y)) / 2., 50.) * 10.;\n    vec2 plane = vec2(pplan.z + 50., BG);\n    plane.x *= 0.1;\n\n  p.xz *= Rot(iTime / 2.);\n  p = IcosSym (p);\n\n  vec3 psph = p / ballScale;\n  psph.z += 1.;\n  psph.x += .8 * (.5 + .5 * sphereShift) * sin(PI / 3.);\n  psph.y -= .8 * (.5 + .5 * sphereShift) * sin(PI / 6.);\n  vec2 sph = vec2((length(psph) - sphereSize) * ballScale, BLUE);\n\n  vec3 pbox = p * 2. / ballScale;\n  pbox.yx *= Rot(PI / 4.);\n  pbox.xz *= Rot(PI / 4.);\n  pbox.x += boxRotation;\n  vec2 box = vec2(sdBox(pbox, vec3(2)) * ballScale / 2., BLACK);\n  box.x += boxGlitch * rnd(pbox.x + pbox.y + iTime);\n    \n\nvec3 pray = p / rayLen;\n      pray.x += .8 * (.5 + .5 * sphereShift) * sin(PI / 3.);\n      pray.y -= .8 * (.5 + .5 * sphereShift) * sin(PI / 6.);\n    pray.xy *= Rot(pray.z * rayFreq);\n    pray.x += rayAmp;\n    //vec2 ray = vec2(length(pray.xy) - .015 * (.2 + .5 * sin(pray.z + iTime * 10.)), BLUE);\n\tvec2 ray = vec2(sdBox(pray, vec2(0.1 * (.5 + .5 * rayLen) + 0.02 * pray.z, 10.).xxy) * rayLen / 2., RAY);\n\n    vec2 res = sph.x < box.x ? sph : box;\n    res = res.x < ray.x ? res : ray;\n    res = res.x < plane.x ? res : plane;\n    return res;\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float minAngleToObstacle = 1e10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        d += distToClosest.x;\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, minAngleToObstacle);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\n\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // ray origin\n    vec3 ro = vec3(EPSILON, 0.01 * sin(iTime), 6.0001);\n    float zoom = 1.100;\n\n    // ray direction\n    vec3 rd = getRayDir(uv, ro, vec3(0), 1.);\n\n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n\n    float color_bw = 0.;\n    vec3 colorBg = vec3(length(0.5 + 0.5 * sin(uv * 40. + vec2(-iTime * 50., 0)))) * 0.2 + 0.2;\n    vec3 color = vec3(0);\n    vec3 light = vec3(50, 20, 50);\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \t//color = vec3( n + 1.0 );\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        color_bw = .5 + .5 * dot(n, normalize(light - p));\n        // drop shadeos\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .5, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color_bw =  0.;\n        // }\n\n        // smooth shadows\n        //float shadow = smoothstep(0.0, .1, rayMarchLight.z / PI);\n        //color_bw *= .5 + .5 * shadow;\n\n\n        // tex *= color_bw;\n        // color = tex;\n    }\n    color += 0.6 + vec3( color_bw );\n    // coloring\n    if (info == RAY) {\n        color *= vec3(fract(length(p * 10.) - iTime * 10. * rayTexSpeed));\n    }\n    else if (info == BLUE) {\n        color *= vec3(0.810,0.256,0.397);\n    }\n    else if (info == BLACK) {\n        color *= vec3(0.130,0.130,0.130);\n    }\n    else if (info == BG) {\n        color *= vec3(0.230,0.230,0.230);\n    }\n    color = mix(color, colorBg, smoothstep(150., 158., d));\n\n\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 172, 172, 235], [237, 237, 267, 267, 325], [352, 352, 390, 390, 419], [420, 420, 451, 451, 534], [535, 535, 557, 557, 597], [599, 599, 660, 660, 734], [737, 737, 760, 760, 1261], [1369, 1369, 1391, 1391, 2880], [2965, 2965, 2998, 2998, 3467], [3469, 3469, 3493, 3493, 3711], [3715, 3715, 3769, 3769, 3996], [3998, 3998, 4048, 4048, 4239], [4242, 4242, 4298, 4298, 6250]], "test": "untested"}
{"id": "wtSBzR", "name": "sector test", "author": "eldn", "description": "绘制扇形", "tags": ["shockwave", "sector"], "likes": 2, "viewed": 420, "published": 3, "date": "1598280335", "time_retrieved": "2024-07-30T20:49:15.159805", "image_code": "\nconst float PI = 3.141592653;\n\nfloat sector(vec2 c, vec2 p, float r, float sa, float alpha){\n    float bl = 0.1;\n    float l  = abs(distance(p, c ));\n    float t  = smoothstep(r-bl, r + bl, l); \n    vec2  uv = p - c;\n    //float a = atan(uv.y, uv.x);\n    //if (a < 0.0) a += 2.0*PI;\n    float a = PI - atan(uv.y, -uv.x);\n    t  = a >= sa         ? t : 1.0;\n    t  = a <= sa + alpha ? t : 1.0;\n    return t;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     float time = iTime * 0.3 + iMouse.x*0.01;\n     vec4 white = vec4(1.0,1.0,1.0,1.0);\n     vec4 black = vec4(0.0,0.0,0.0,1.0);\n  \t\n     //vec2 uv = fragCoord/iResolution.xy;\n     vec2 p  = (fragCoord.xy * 2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n  \n     //float t = sector(vec2(0.0), p, 0.9, 0.0, mod(time, 2.0*PI));\n      float t = sector(vec2(0.0), p, 0.9, radians(190.0), radians(90.0));\n    // white*(1−t)+black*t\n     fragColor = mix(white,black,t);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 93, 93, 409], [413, 413, 470, 470, 947]], "test": "untested"}
{"id": "WtSBR1", "name": "Interlocked arms 1 animated", "author": "FabriceNeyret2", "description": "simplified version of the classical 4 interlocked arms. animated variant\n[url]https://www.google.com/search?q=4+interlocked+arms&tbm=isch[/url]\n\nUsing 4-rotation symmetry folding seems more costly, but 2-rotation is ok.", "tags": ["raymarching", "symmetry", "reproduction"], "likes": 6, "viewed": 297, "published": 3, "date": "1598270181", "time_retrieved": "2024-07-30T20:49:16.111262", "image_code": "// animated variant of https://shadertoy.com/view/tlSfRz\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                    \n#define P(q)    t = min(t, abs(q.x)+3.),  /* invisible cell wall to fix sign() discont */ \\\n                r = sign(q.x)*q - vec3(3,0,-3)*vec3(.7+.3*sin(T)),                                           \\\n                t = min(t, max( 1.-r.z, length(r.xy) - .4 )),  /* arm */                  \\\n                t = min(t, length( vec2(length(r.yz) - 1., abs(abs(r.x)-.4)-.2)) - .2 ) // 4 rings \"fingers\" \n  \nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=10., d;\n    vec3  R = iResolution, T=R-R,\n          D = normalize(vec3( U+U, -10.*R.y ) - R ),  // ray direction\n          p = 50./R, q,r;                             // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p, \n        q.yz *= rot(.6),                              // rotations\n        q.xz *= rot(-.3*iTime),\n        \n        T=3.*iTime+vec3(1.57,0,0),P( q ),                 // P(-q ),            // shape with 4 rotations \n        T=3.*iTime+vec3(0,0,1.57),P(vec3(-q.z,q.y, q.x)), // P(vec3( q.z,q.y,-q.x)), \n        \n        p += t*D;                                     // step forward = dist to obj\n\n    O *= vec4(.8,.8,1.,1);                             // coloring\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[531, 531, 567, 567, 1317]], "test": "untested"}
{"id": "wt2fzz", "name": "Nautilus Interior", "author": "dr2", "description": "Where Captain Nemo commands and watches dolphins (mouseable)", "tags": ["ocean", "dolphin", "submarine", "verne", "fiction"], "likes": 17, "viewed": 409, "published": 3, "date": "1598256558", "time_retrieved": "2024-07-30T20:49:17.141507", "image_code": "// \"Nautilus Interior\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0    // = 1 for optional antialiasing\n\n#define FISH  1  // optional fish (dolphins)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 vuPos, sunDir, ltDir, qHit, bSize;\nfloat tCur, dstFar, winRad, tunRad, whlAng, wvBase;\n#if FISH\nvec3 fishPos;\nfloat fishAngI;\n#endif\nint idObj, idObjEx;\nconst int idWal = 1, idWalB = 2, idTun = 3, idLad = 4, idWin = 5, idGlas = 6, idWEnd = 7, idNut = 8,\n   idPipe = 9, idPer = 10, idScrn = 11, idWhl = 12, idWhlB = 13, idWhlS = 14, idWhlD = 15, idComp = 16,\n   idLev = 17, idDial = 18, idBras = 19, idBox = 20, idFlot = 21, idLit = 22;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = (id);  qHit = q; }\n\nvec2 SphGrid (vec3 p)\n{\n  vec3 q;\n  vec2 a, sc, nSeg;\n  float dMin, d1, d2, r;\n  nSeg = vec2 (12., 15.);\n  sc = sin (0.07 * 2. * pi / nSeg + vec2 (0., 0.5 * pi));\n  q = p;\n  r = length (q.yz);\n  a = 2. * pi * (floor (nSeg * atan (q.zx, - vec2 (q.y, r)) / (2. * pi)) + 0.5) / nSeg;\n  q.yz = Rot2D (q.yz, a.x);\n  d1 = dot (vec2 (q.y, abs (q.z)), sc);\n  q.yz = Rot2D (vec2 (r, q.x), a.y);\n  d2 = dot (vec2 (q.y, abs (q.z)), sc);\n  return vec2 (d1, d2);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pp, qq;\n  vec2 d2;\n  float dMin, d, wThk, zOff, s, dw, r;\n  dMin = dstFar;\n  wThk = 0.07;\n  zOff = -2.;\n  pp = p;\n  pp.x = abs (pp.x) - bSize.x;\n  q = pp;\n  d2 = SphGrid (q);\n  d2.x = max (d2.x, 0.3 * winRad - length (q.yz)); \n  d = SmoothMin (d2.x, d2.y, 0.02);\n  d = max (SmoothMax (abs (PrSphDf (q, winRad)) - wThk, d, 0.02), -0.01 - q.x);\n  DMINQ (idWin);\n  d = max (abs (PrSphDf (q, winRad + 0.5 * wThk)) - 0.25 * wThk, -0.01 - pp.x);\n  DMINQ (idGlas);\n  q = pp;\n  q.x -= -0.05;\n  d = PrCylAnDf (q.yzx, winRad - wThk + 0.2, 0.2, 0.05);\n  q.yz = Rot2D (q.yz, 2. * pi * floor (12. * atan (q.z, - q.y) / (2. * pi) + 0.5) / 12.);\n  q.xy -= vec2 (-0.1, - winRad - 0.1);\n  d = max (d, - PrCylDf (q.yzx, 0.13, 0.1));\n  DMINQ (idWEnd);\n  d = max (abs (q.z) - 0.5 * min (abs (q.z) - sqrt3 * abs (q.y), 0.) - 0.1, abs (q.x - 0.05) - 0.05);\n  DMINQ (idNut);\n  q = p;\n  dw = winRad - length (q.yz);\n  q.z -= zOff;\n  s = length (q.zx - vec2 (clamp (q.z, - bSize.z, bSize.z), 0.)) - bSize.x - 0.1;\n  d = abs (max (s, abs (q.y) - bSize.y)) - 0.02;\n  qq.y = q.y + bSize.y;\n  qq.z = abs (q.z) - bSize.z - bSize.x + tunRad + 0.05;\n  r = length (vec2 (q.x, qq.z));\n  d = max (dw, max (d, min (tunRad + 0.05 - r, 0.2 - abs (qq.y + 0.1))));\n  DMINQ (idWal);\n  q.y = qq.y + 0.9;\n  q.z = qq.z;\n  d = min (max (abs (r - tunRad) - 0.05, abs (q.y) - 1.), q.y + 0.9);\n  DMINQ (idTun);\n  d = abs (s + 0.08) - 0.04;\n  q = p;\n  q.y = mod (q.y + 1., 2.) - 1.;\n  q.z -= zOff;\n  if (d < bSize.z - abs (q.z)) {\n    q.z = mod (q.z + 1., 2.) - 1.;\n  } else {\n    q.z = abs (q.z) - bSize.z;\n    q.zx = Rot2D (q.zx, pi / 12.);\n    q.z = 0.85 * dot (q.zx, sin (2. * pi * (floor (12. * atan (q.x, - q.z) / (2. * pi)) +\n       0.5) / 12. + vec2 (0., 0.5 * pi)));\n  }\n  d = max (dw + 0.34, SmoothMax (d, 0.05 - length (max (abs (q.yz) - 0.85, 0.)), 0.03));\n  DMINQ (idWalB);\n  q = p;\n  q.z -= zOff;\n  q.xz = abs (q.xz) - vec2 (bSize.x - 0.25, bSize.z + 0.8);\n  d = PrCylDf (q.xzy, 0.1 + 0.03 * smoothstep (0.87, 0.9, abs (mod (q.y + 1., 2.) - 1.)), bSize.y);\n  DMINQ (idPipe);\n  q.xy -= vec2 (-0.15, -2.);\n  d = PrCylDf (q.yzx, 0.3, 0.05);\n  DMINQ (idPipe);\n  q = p;\n  q.z = abs (q.z - zOff) - bSize.z - bSize.x + 0.4;\n  d = max (abs (q.y) - bSize.y - 2., PrCylDf (vec3 (q.x, mod (q.y + 0.5, 1.) - 0.5, q.z).yzx,\n     0.09, 0.7));\n  d = min (d, PrCylDf (vec3 (abs (q.x) - 0.7, q.yz).xzy, 0.11, bSize.y + 2.));\n  DMINQ (idLad);\n  q = p;\n  q.yz -= vec2 (bSize.y - 1.6, 3.);\n  d = PrCylDf (q.xzy, 0.15, 1.6);\n  DMINQ (idPer);\n  q.y -= -2.2;\n  d = min (PrCapsDf (vec3 (q.x, abs (q.y) - 0.6, q.z).yzx, 0.05, 1.2),\n     PrCapsDf (vec3 (abs (q.x) - 1.2, q.yz).xzy, 0.05, 0.6));\n  DMINQ (idPer);\n  d = PrBoxDf (q, vec3 (1.2, 0.6, 0.03));\n  DMINQ ((q.z < 0.) ? idScrn : idPer);\n  q = p;\n  q.yz -= vec2 (-1.2, 1.5);\n  d = PrCylDf (q, 0.1, 0.2);\n  DMINQ (idWhl);\n  q.xy = Rot2D (q.xy, whlAng);\n  d = min (PrCylAnDf (q, 1.1, 0.1, 0.1), PrCylDf (q + vec3 (0., 0., -0.3), 0.2, 0.5));\n  DMINQ (idWhl);\n  q.xy = Rot2D (q.xy, 2. * pi * floor (12. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 12.);\n  q.x += 0.8;\n  d = PrCapsDf (q.yzx, 0.05, 0.8);\n  DMINQ (idWhlS);\n  q = p;\n  q.yz -= vec2 (- bSize.y + 2.3, 2.55);\n  d = PrRoundBoxDf (q, vec3 (0.3, 2.3, 0.3), 0.05);\n  q.y -= 2.2;\n  d = min (d, PrRoundBoxDf (q, vec3 (1.2, 0.1, 0.3), 0.05));\n  DMINQ (idWhlB);\n  q.x = abs (q.x) - 1.1;\n  q.y -= 0.2;\n  d = PrCylDf (q.xzy, 0.12, 0.1);\n  DMINQ (idBras);\n  q = p;\n  q.yz -= vec2 (- bSize.y + 1.4, 2.55);\n  d = PrCylDf (q.yzx, 0.1, 0.65);\n  q.x = abs (q.x) - 0.5;\n  d = min (d, PrCylDf (q.yzx, 0.7, 0.1));\n  DMINQ (idWhlD);\n  q = p;\n  q.x = abs (q.x) - 2.;\n  q.y -= - bSize.y + 0.5;\n  q.z = (q.z > 0.) ? q.z - 6. : abs (q.z + 8.) - 2.;\n  d = PrRoundBoxDf (q, vec3 (0.5, 0.5, 1.), 0.05);\n  DMINQ (idBox);\n  q.xy -= vec2 (bSize.x - 2.1, bSize.y - 2.);\n  q.z = abs (q.z) - 0.15;\n  d = PrCylDf (q.xzy, 0.05, 4.);\n  DMINQ (idPipe);\n  q.y = abs (q.y - 3.5) - 0.5;\n  d = PrRoundBoxDf (q, vec3 (0.1, 0.25, 0.5), 0.05);\n  DMINQ (idBox);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (2., - bSize.y + 0.7, 0.1);\n  q.x = abs (q.x);\n  d = max (- min (min (max (q.x - 0.07, abs (q.z) - 0.6), 0.), 0.18 - q.x),\n     length (vec2 (q.y - min (q.y, 0.5), q.z)) - 0.7);\n  d = min (min (d, PrCylDf (q.yzx, 0.1, 0.25)), PrCapsDf (q.xzy, 0.06, 2.));\n  DMINQ (idLev);\n  q = p;\n  q.yz -= vec2 (-0.35, 2.65);\n  r = length (q.xz);\n  d = max (abs (r - 0.55) - 0.05, abs (q.y) - 0.1);\n  DMINQ (idBras);\n  d = max (r - 0.5, abs (q.y + 0.02) - 0.08);\n  DMINQ (idComp);\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (bSize.x - 0.05, -1., 4.);\n  d = PrCylDf (q.yzx, 0.35, 0.05);\n  DMINQ (idDial);\n  q.y -= -2.;\n  d = PrCylDf (q.xzy, 0.05, 2.);\n  DMINQ (idPipe);\n  q = p;\n  q = abs (vec3 (q.x, q.y + 4., q.z - zOff))- vec3 (bSize.x - 0.25, 0.5,  bSize.z - 1.7);\n  q.z = abs (q.z) - 1.2;\n  d = PrCapsDf (q, 0.4, 0.5);\n  DMINQ (idFlot);\n  q = p;\n  q.xz = abs (vec2 (q.x, q.z - zOff));\n  q -= vec3 (bSize.x, bSize.y - 1., 4.);\n  q.z = abs (q.z) - 2.;\n  d = PrCapsDf (q, 0.2, 0.5);\n  DMINQ (idLit);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    d = 0.01 + float (j) / 20.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.6 + 0.4 * clamp (1. - 2. * ao, 0., 1.);\n}\n\nvec4 ObjCol (vec3 ro)\n{\n  vec4 col4;\n  vec3 w;\n  float a, s;\n  if (idObj <= idLad) {\n    if (idObj == idWal) {\n      col4 = vec4 (0.7, 0.8, 0.7, 0.1);\n      if (ro.y < - bSize.y + 0.1) {\n        col4 *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (8. * ro.x, 1.));\n        w.xz = max (abs (ro.xz) - vec2 (1.6, 2.6), 0.);\n        if (length (w.xz) < 0.5) col4 = vec4 (0.5, 0.2, 0., 0.1) *\n           (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (8. * ro.z, 1.)));\n      } else if (ro.y > bSize.y - 0.1) {\n        col4 *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (4. * ro.z, 1.));\n        col4 = mix (vec4 (0.8, 0.3, 0.3, 0.1), col4, step (0.2, length (vec2 (abs (ro.x) - 2.,\n           mod (ro.z + 1., 2.) - 1.))));\n        col4 = mix (vec4 (1., 1., 0.8, -1.), col4, smoothstep (0.03, 0.05, abs (abs (ro.x) - 3.)));\n        col4 = mix (vec4 (0., 0.5, 0., -1.), col4, step (0.07, abs (length (vec2 (abs (ro.z + 2.) - bSize.z -\n           bSize.x + tunRad + 0.05, ro.x)) - tunRad)));\n      } else col4 = mix (vec4 (0.3, 1., 0.3, 0.), col4, smoothstep (0.05, 0.1, \n         max (abs (abs (ro.x) - 2.3), abs (ro.y) - 0.7)));\n    } else if (idObj == idWalB) {\n      col4 = vec4 (0.6, 0.7, 0.6, 0.1) * (0.8 + 0.2 * smoothstep (0.05, 0.1,\n         length (abs (qHit.yz) - 1.)));\n    } else if (idObj == idTun) {\n      col4 = mix (vec4 (0.3, 0.7, 0.3, -1.), vec4 (0., 0.4, 0., 0.), \n         step (0., max (length (qHit.xz) - tunRad, 0.5 - qHit.y)));\n    } else if (idObj == idLad) {\n      col4 = vec4 (0.5, 0.5, 0.55, 0.1);\n    }\n  } else if (idObj <= idPipe) {\n    if (idObj == idWin) {\n      col4 = vec4 (0.7, 0.8, 0.7, 0.2) * (0.5 + 0.5 * step (0.02, abs (length (qHit) - winRad)));\n    } else if (idObj == idWEnd) {\n      col4 = vec4 (0.5, 0.55, 0.1, 0.2) * (0.5 + 0.5 * step (abs (ro.x), bSize.x - 0.1));\n    } else if (idObj == idNut) {\n      col4 = vec4 (0.4, 0.4, 0.5, 0.2);\n    } else if (idObj == idPipe) {\n      col4 = vec4 (0.3, 0.3, 0.3, 0.05);\n    }\n  } else if (idObj <= idWhlS) {\n    if (idObj == idPer) {\n      col4 = vec4 (0.4, 0.4, 0.42, 0.1);\n    } else if (idObj == idWhl) {\n      col4 = vec4 (0.7, 0.5, 0.2, 0.1) * (0.5 + 0.5 * step (0., min (abs (length (qHit.xy) - 1.1) - 0.02,\n         length (qHit.xy) - 0.11)));\n      col4 = mix (vec4 (0.4, 0.4, 0.8, 0.3), col4, step (0.05, length (vec2 (qHit.x, qHit.y - 1.1))));\n    } else if (idObj == idWhlB) {\n      col4 = mix (vec4 (0.8, 0.8, 0.8, -1.), vec4 (0.7, 0.5, 0.2, 0.05),\n         smoothstep (0.01, 0.02, abs (abs (qHit.z) - 0.15)));\n    } else if (idObj == idWhlS) {\n      col4 = vec4 (0.7, 0.5, 0.2, 0.1) * (0.5 + 0.5 * step (0.05, abs (qHit.x + 0.7)));\n    }\n  } else if (idObj <= idDial) {\n    if (idObj == idWhlD) {\n      col4 = vec4 (0.7, 0.5, 0.2, 0.1) * (0.5 + 0.5 * step (0., min (abs (qHit.x) - 0.04,\n         length (qHit.yz) - 0.105)));\n    } else if (idObj == idComp) {\n      if (qHit.y > 0.) {\n        col4 = vec4 (1., 1., 1., 0.1);\n        qHit.xz = Rot2D (qHit.xz, -0.5 * whlAng);\n        col4 = mix (vec4 (0.8, 0.2, 0.2, 0.1), col4, step (0.05, length (vec2 (qHit.x, qHit.z - 0.4))));\n        s = min (abs (qHit.x), abs (qHit.z));\n        qHit.xz = Rot2D (qHit.xz, 2. * pi * floor (36. * atan (qHit.z, - qHit.x) /\n           (2. * pi) + 0.5) / 36.);\n        if (abs (qHit.x + 0.45) < 0.02) s = min (s, abs (qHit.z));\n        col4 *= (0.1 + 0.9 * smoothstep (0.003, 0.008, s));\n      } else col4 = vec4 (0.7, 0.7, 0., 0.2);\n    } else if (idObj == idLev) {\n      col4 = (length (qHit.xz) > 0.07) ? vec4 (0.7, 0.5, 0.2, 0.05) : vec4 (0.3, 0.4, 0.1, 0.05);\n      col4 *= 0.5 + 0.5 * step (0., min (1.7 - qHit.y, length (qHit.yz) - 0.11));\n    } else if (idObj == idDial) {\n      if (length (qHit.yz) < 0.27) {\n        if (ro.z < 0.) {\n          s = 1.;\n          a = atan (qHit.z, - qHit.y) / (2. * pi);\n          if (abs (a) > 0.12) {\n            s = abs (qHit.z);\n            qHit.yz = Rot2D (qHit.yz, 2. * pi * floor (16. * a + 0.5) / 16.);\n            if (abs (qHit.y + 0.25) < 0.02) s = min (s, abs (qHit.z));\n          }\n        } else {\n          s = abs (dot (sign (Rot2D (qHit.yz, - pi * tCur)), vec2 (0.5)));\n        }\n        col4 = vec4 (1., 1., 1., 0.1) * (0.1 + 0.9 * smoothstep (0.01, 0.02, s));\n      } else col4 = vec4 (0.7, 0.7, 0., 0.2);\n    }\n  } else if (idObj <= idLit) {\n    if (idObj == idBras) {\n      col4 = vec4 (0.7, 0.7, 0., 0.2);\n      qHit.xz = abs (qHit.xz);\n      if (abs (length (qHit.xz) - 0.55) < 0.04) col4 *= 0.5 +\n         0.5 * smoothstep (0.005, 0.01, min (qHit.x, qHit.z));\n    } else if (idObj == idBox) {\n      if (abs (ro.x) < 3.) col4 = vec4 (0.3, 0.5, 0.4, 0.) * (0.5 + \n         0.5 * smoothstep (0.02, 0.03, abs (abs (qHit.x) - 0.1) - 0.01));\n      else col4 = vec4 (0.5, 0.7, 0.6, 0.1) * (0.5 + 0.5 * smoothstep (0.02, 0.03, abs (qHit.y)));\n    } else if (idObj == idFlot) {\n      col4 = vec4 (0.7, 0.3, 0.1, 0.) * (0.5 + 0.5 * smoothstep (0.02, 0.03,\n         abs (abs (qHit.z) - 0.3) - 0.05));\n    } else if (idObj == idLit) {\n      col4 = vec4 (vec3 (1., 1., 0.8) * (0.93 + 0.07 * cos (32. * pi * qHit.y)), -1.);\n    }\n  }\n  return col4;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4;\n  vec2 q, t, tw;\n  float wAmp, h;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.05 * p + vec2 (0., 0.05 * tCur);\n  wAmp = 1.;\n  h = wvBase;\n  tw = 0.1 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 5; j ++) {\n    q *= 2. * qRot;\n    t4 = q.xyxy + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    t4 = abs (sin (t4));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wAmp *= 0.5;\n  }\n  return 0.4 * h * (1. - smoothstep (0.5, 1.2, length (p - vuPos.xz) / dstFar));\n}\n\nfloat WaveRay (vec3 ro, vec3 rd, float u)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  ro.y *= u;\n  rd.y *= u;\n  s = 0.;\n  sLo = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + s * rd;\n    h = p.y - u * WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 1.3 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > u * WaveHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),\n     WaveHt (p.xz + e.yx)), e.x)).xzy;\n}\n\n#if FISH\n\nfloat FishDf (vec3 p)\n{\n  vec3 q;\n  float dMin, dBodyF, dBodyB, dMouth, dFinT, dFinP, dFinD, dEye;\n  p.x = abs (p.x);\n  p.z -= 2.;\n  p.yz = Rot2D (p.yz, 0.2 * fishAngI);\n  q = p;\n  q.z -= -0.6;\n  dBodyF = PrEllipsDf (q, vec3 (0.7, 0.8, 2.4));\n  q = p;\n  q.z -= -1.2;\n  q.yz = Rot2D (q.yz, fishAngI);\n  q.z -= -1.6;\n  dBodyB = PrEllipsDf (q, vec3 (0.35, 0.5, 2.5));\n  q.z -= -2.2;\n  q.yz = Rot2D (q.yz, 2. * fishAngI);\n  q.xz -= vec2 (0.5, -0.5);\n  q.xz = Rot2D (q.xz, 0.4);\n  dFinT = PrEllipsDf (q, vec3 (0.8, 0.07, 0.4));\n  q = p;\n  q.yz -= vec2 (-0.3, 1.7);\n  q.yz = Rot2D (q.yz, 0.1);\n  q.y = abs (q.y) - 0.04;\n  dMouth = PrEllipsDf (q, vec3 (0.25, 0.12, 0.6));\n  q = p;\n  q.yz -= vec2 (0.7, -1.);\n  q.yz = Rot2D (q.yz, 0.6);\n  dFinD = PrEllipsDf (q, vec3 (0.05, 1., 0.35));\n  q = p;\n  q.xy = Rot2D (q.xy, 0.8);\n  q.xz -= vec2 (0.7, -0.1);\n  q.xz = Rot2D (q.xz, 0.6);\n  dFinP = PrEllipsDf (q, vec3 (0.9, 0.04, 0.3));\n  q = p;\n  q -= vec3 (0.4, -0.1, 1.1);\n  dEye = PrSphDf (q, 0.1);\n  idObjEx = 1;\n  dMin = SmoothMin (dBodyF, dBodyB, 0.3);\n  dMin = SmoothMin (SmoothMin (dMin, dFinT, 0.1), dMouth, 0.15);\n  dMin = SmoothMin (SmoothMin (dMin, dFinD, 0.02), dFinP, 0.02);\n  if (dEye < dMin) {\n    idObjEx = 2;\n    dMin = dEye;\n  }\n  return 0.9 * dMin;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  p.x = abs (abs (p.x) - 18.) - 4.;\n  return FishDf (p - fishPos);\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\n#endif\n\nvec3 SkyGrndCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float sd, a, f, ff, fd;\n  a = atan (rd.z, rd.x) + 0.001 * tCur * sign (rd.x);\n  if (rd.y < 0.01 * Fbm1 (64. * a) - 0.005) {\n    col = mix (vec3 (0.2, 0.35, 0.2), vec3 (0.3, 0.35, 0.35), 0.5 +\n       0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) *\n       (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y)));\n  } else {\n    q = 0.01 * (ro.xz + vec2 (0., 8.) * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = 0.7 * (0.7 + 0.5 * ff) * (vec3 (1.) - vec3 (0.2, 0.2, 0.1) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix ((vec3 (0.7, 0.7, 0.75)), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n    sd = pow (max (dot (rd, sunDir), 0.), 256.);\n    col += (0.1 * sd + 0.3 * pow (sd, 4.)) * vec3 (1., 1., 0.3);\n  }\n  return col;\n}\n\nvec3 SeaFloorCol (vec3 rd)\n{\n  return mix (vec3 (0.05, 0.17, 0.12), vec3 (0., 0.15, 0.2), \n     smoothstep (0.4, 0.7, Fbm2 (2. * rd.xz / rd.y)));\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 2.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return vec3 (0.1, 0.3, 0.4) * (0.2 + 0.4 * (rd.y + 1.)) * (1. + 0.3 * gd);\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vnw, rdd, rdo, colUw, ltDirF;\n  float dstObj, dstWat, eta, atFac; \n  bool unWat, hitWat;\n  eta = 1.33;\n  atFac = 3.;\n  rdo = rd;\n  unWat = (ro.y < WaveHt (ro.xz));\n  dstWat = WaveRay (ro, rd, (! unWat ? 1. : -1.));\n#if FISH\n  if (idObj == idGlas) {\n    fishAngI = 0.1 * sin (pi * tCur);\n    dstObj = ExObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ExObjNf (ro);\n      if (idObjEx == 1) col4 = vec4 (vec3 (0.7, 0.7, 0.8) * (1. -\n         0.2 * smoothstep (-0.5, -0.3, vn.y)), 0.1);\n      else if (idObjEx == 2) col4 = vec4 (0.3, 1., 0.3, -1.);\n      if (col4.a >= 0.) {\n        ltDirF = normalize (vec3 (0., 1., 0.5));\n        col = col4.rgb * (0.3 + 0.7 * max (dot (vn, ltDirF), 0.) +\n           col4.a * pow (max (dot (reflect (rd, vn), ltDirF), 0.), 32.));\n      } else col = col4.rgb * (0.7 - 0.3 * dot (vn, rd));\n    }\n  } else dstObj = dstFar;\n#else\n  dstObj = dstFar;\n#endif\n  hitWat = (dstWat < min (dstObj, dstFar));\n  if (hitWat) {\n    ro += dstWat * rd;\n    vnw = WaveNf (ro, dstWat);\n    if (! unWat) {\n      rd = refract (rd, vnw, 1. / eta);\n    } else {\n      vnw *= -1.;\n      rdd = refract (rd, vnw, eta);\n      rd = (length (rdd) > 0.) ? rdd : reflect (rd, vnw);\n    }\n  }\n  if (dstObj >= dstFar) col = (hitWat == unWat) ? SkyGrndCol (ro, rd) : SeaFloorCol (rd);\n  if (! unWat) {\n    if (hitWat) col = mix (col, 0.8 * SkyGrndCol (ro, reflect (rdo, vnw)),\n       pow (1. - abs (dot (rdo, vnw)), 5.));\n  } else {\n    colUw = UnwCol (rd);\n    if (dstObj < dstFar) col = mix (colUw, col, min (1., exp (- atFac * dstObj / dstFar)));\n    else if (dstWat < dstFar) col = (rd.y > 0.) ? mix (colUw, col,\n       exp (- atFac * dstWat / dstFar)) : colUw;\n    else col = colUw;\n  }\n\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDirL[5];\n  vec2 vf;\n  float dstObj, nDotL, dSum, sSum, ao, wd;\n  bool isMet, exVu;\n  bSize = vec3 (4.5, 5.1, 10.);\n  winRad = 2.5;\n  tunRad = 1.55;\n  dstObj = ObjRay (ro, rd);\n  exVu = (dstObj < dstFar && (idObj == idScrn || idObj == idGlas));\n  if (dstObj < dstFar && ! exVu) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro);\n    vf = vec2 (0.);\n    if (idObj == idWal || idObj == idWalB || idObj == idWin || idObj == idWEnd || idObj == idTun ||\n       idObj == idBox) {\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idNut || idObj == idPipe) {\n      vf = vec2 (128., 0.2);\n    } else if (idObj == idWhl || idObj == idWhlS || idObj == idWhlD) {\n      vf = vec2 (128., 0.1);\n    } else if (idObj == idWhlB || idObj == idLev) {\n      vf = vec2 (64., 0.2);\n    }\n    wd = smoothstep (-0.7, 0.7, wvBase);\n    if (col4.a >= 0.) {\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      ltDirL[0] = normalize (bSize * vec3 (1., 0.7, 1.));\n      ltDirL[1] = normalize (bSize * vec3 (-1., 0.7, 1.));\n      ltDirL[2] = normalize (bSize * vec3 (1., 0.7, -1.));\n      ltDirL[3] = normalize (bSize * vec3 (-1., 0.7, -1.));\n      ltDirL[4] = ltDir;\n      dSum = 0.;\n      sSum = 0.;\n      isMet = (idObj == idWal || idObj == idWalB || idObj == idComp || idObj == idDial);\n      for (int k = 0; k < 5; k ++) {\n        nDotL = max (dot (vn, ltDirL[k]), 0.);\n        if (isMet) nDotL *= nDotL;\n        dSum += ((k < 5) ? 0.7 : 1.) * nDotL;\n        sSum += ((k < 5) ? 0.7 : 1.) * pow (max (dot (normalize (ltDirL[k] - rd), vn), 0.), 64.);\n      }\n      ao = ObjAO (ro, vn);\n      col = ao * col4.rgb * (0.2 + 0.4 * dSum) + step (0.95, ao) * col4.a * sSum;\n      col *= mix (vec3 (1.), vec3 (0.6, 0.8, 1.), wd);\n    } else col = col4.rgb * (0.7 - 0.3 * dot (vn, rd)) * (1. - 0.5 * wd);\n  }\n  if (exVu) {\n    if (idObj == idGlas) {\n      ro += dstObj * rd;\n    } else {\n      ro = vec3 (0., 3., 3.);\n      rd = normalize (vec3 (qHit.xy, 2.));\n    }\n    col = ExShowScene (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2.5 * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = mod (0.03 * tCur, 2.);\n    az += 0.5 * pi * SmoothBump (0.25, 0.75, 0.15, mod (t, 1.)) * sign (t - 1.);\n    el += 0.1 * abs (az);\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -4.5);\n  ro.z *= 1. + abs (cos (az));\n  vuPos = ro;\n  zmFac = 3. + 1.5 * abs (sin (az));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.5, 0.5, -1.));\n  sunDir = normalize (vec3 (1., 1., -1.));\n  whlAng = 0.2 * pi * sin (0.05 * pi * tCur);\n  wvBase = 2. + 7. * sin (0.03 * pi * tCur);\n#if FISH\n  fishPos = vec3 (0., wvBase - 8., mod (45. + 2. * tCur, 90.) - 45.);\n#endif\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a +\n       0.5) * pi)) / zmFac;\n    uvv.x = 2. * tan (0.5 * atan (uvv.x / asp)) * asp;\n    rd = vuMat * normalize (vec3 (uvv, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2fzz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1456, 1456, 1479, 1479, 1907], [1909, 1909, 1931, 1931, 6947], [6949, 6949, 6982, 6982, 7166], [7168, 7168, 7189, 7189, 7446], [7448, 7448, 7480, 7480, 7685], [7687, 7687, 7710, 7710, 12765], [12767, 12767, 12790, 12790, 13401], [13403, 13403, 13446, 13446, 13983], [13985, 13985, 14016, 14016, 14179], [16056, 16056, 16092, 16092, 17058], [17060, 17060, 17088, 17088, 17207], [17209, 17209, 17232, 17232, 17585], [17587, 17587, 17624, 17624, 19390], [19392, 19392, 19427, 19427, 21489], [21491, 21491, 21547, 21547, 23106], [23108, 23108, 23140, 23140, 23240], [23242, 23242, 23275, 23275, 23364], [23366, 23366, 23412, 23412, 23459], [23461, 23461, 23494, 23494, 23521], [23523, 23523, 23565, 23565, 23616], [23618, 23618, 23671, 23671, 23732], [23734, 23734, 23777, 23777, 23841], [23843, 23843, 23878, 23878, 23940], [23942, 23942, 23987, 23987, 24090], [24092, 24092, 24137, 24137, 24175], [24177, 24177, 24234, 24234, 24317], [24319, 24319, 24355, 24355, 24561], [24563, 24563, 24593, 24593, 24706], [24740, 24740, 24764, 24764, 24817], [24819, 24819, 24843, 24843, 24955], [24957, 24957, 24982, 24982, 25128], [25130, 25130, 25155, 25155, 25341], [25343, 25343, 25365, 25365, 25519], [25521, 25521, 25542, 25542, 25697], [25699, 25699, 25728, 25728, 25940], [25942, 25942, 25981, 25981, 26161]], "test": "untested"}
{"id": "wljfzz", "name": "Space fungus 2", "author": "FabriceNeyret2", "description": "transparent variant of [url]https://shadertoy.com/view/lsSBWh[/url]", "tags": ["raymarching", "notgyroid"], "likes": 25, "viewed": 499, "published": 3, "date": "1598254526", "time_retrieved": "2024-07-30T20:49:18.107923", "image_code": "// transparent variant of https://shadertoy.com/view/lsSBWh\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = .1*iTime, a,b, n=0.,s,N=0.;\n    mat2  R = mat2( sin(t+1.57*vec4(1,2,0,1)) );\n    vec3  q = iResolution,\n          D = normalize(vec3( U+U-q.xy, -q.y) +.1 ),\n          p = 15./q; \n\n    for ( O+=.5-O; n<2e2 ; n++ )\n        q = p,\n        q.xz *= R,\n        q.yz *= R,\n        t = max( length(q) - 9.,                         // Sphere\n                 abs(a=cos(b=3.*dot(sin(q),D/D)))/9. ),  // EggCarton\n        t < .01 ? s = 4.*max( 0., 1.-.2*N-.005*n ),\n                  O.r -= s* b/30., O.g -= s* a, \n                  t=.3, N++ : t, \n        p += t/3.*D;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljfzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 97, 97, 672]], "test": "untested"}
{"id": "wl2fRz", "name": "TS Kawase Blur", "author": "tigershan1130", "description": "4Tap Kawase Blur Test", "tags": ["blurkawase"], "likes": 3, "viewed": 369, "published": 3, "date": "1598253651", "time_retrieved": "2024-07-30T20:49:19.144152", "image_code": "const float BlurRadius =1.0;\n\nvec3 getTexture(vec2 uv){\n\treturn texture(iChannel0, uv).rgb;\n}\n\nvec3 KawaseBlur(vec2 uv, vec2 texelSize, vec2 scaleFactor)\n{\n    vec3 res = vec3(0,0,0);\n    vec2 invScaleFactor = vec2(1.0 / scaleFactor.x, 1.0 / scaleFactor.y);\n     vec2 pixelOffset = 1.0 / (scaleFactor) * BlurRadius;\n    \n    \n    vec2 downScaleUV = floor(uv * scaleFactor) * invScaleFactor;\n    \n    \n    //return getTexture(downScaleUV);\n    \n   \n    /*\n    vec2 uv00 = downScaleUV + vec2(pixelOffset + 0.5, pixelOffset + 0.5) * texelSize;\n    vec2 uv01 = downScaleUV + vec2(-pixelOffset - 0.5, pixelOffset + 0.5) * texelSize;\n    vec2 uv10 = downScaleUV + vec2(-pixelOffset + 0.5, -pixelOffset - 0.5) * texelSize;\n    vec2 uv11 = downScaleUV + vec2(pixelOffset - 0.5, -pixelOffset - 0.5) * texelSize;\n    \n    res += getTexture(uv00);\n    res += getTexture(uv01);\n    res += getTexture(uv10);\n    res += getTexture(uv11);\n    \n    \n    return res * 0.25;\n*/\n    \n    \n    vec2 uv00 = downScaleUV + vec2(pixelOffset.x + 0.5 *invScaleFactor.x , pixelOffset.y + 0.5*invScaleFactor.y) * texelSize;\n    vec2 uv01 = downScaleUV + vec2(-pixelOffset.x - 0.5*invScaleFactor.x, pixelOffset.y + 0.5*invScaleFactor.y) * texelSize;\n    vec2 uv10 = downScaleUV + vec2(-pixelOffset.x + 0.5*invScaleFactor.x, -pixelOffset.y - 0.5*invScaleFactor.y) * texelSize;\n    vec2 uv11 = downScaleUV + vec2(pixelOffset.x - 0.5*invScaleFactor.x, -pixelOffset.y - 0.5*invScaleFactor.y) * texelSize;\n    \n    res += getTexture(uv00);\n    res += getTexture(uv01);\n    res += getTexture(uv10);\n    res += getTexture(uv11);\n    \n    \n    return res * 0.25;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 scaleFactor = vec2(1.0, 1.0);\n    \n    // pixel offset is the blur radius\n    // pixel offset =  1 / (RTDownScaling + BlurRadius);\n    \n    vec2 texelSize = vec2(1.0, 1.0);\n    vec2 uv = fragCoord/ iResolution.xy;\n    \n    // hack for iteration count,we should just sample smaller texture\n    vec3 col = KawaseBlur(uv, texelSize, iResolution.xy /scaleFactor);\n    col += KawaseBlur(uv, texelSize, iResolution.xy /(scaleFactor* 2.0));\n    col += KawaseBlur(uv, texelSize, iResolution.xy /(scaleFactor* 3.0));\n    col += KawaseBlur(uv, texelSize, iResolution.xy /(scaleFactor* 4.0));\n    // Output to screen\n    fragColor = vec4(col * 0.25,1.0);\n}\n\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2fRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 55, 55, 93], [95, 95, 155, 155, 1627], [1630, 1630, 1687, 1687, 2348]], "test": "untested"}
{"id": "ttjBzz", "name": "Interlocked arms 2 animated", "author": "FabriceNeyret2", "description": "simplified version of the classical 4 interlocked arms.  animated 6-arms variant\n[url]https://www.google.com/search?q=4+interlocked+arms&tbm=isch[/url]\n\nUsing 4-rotation symmetry folding seems more costly, but 2-rotation is ok.", "tags": ["raymarching", "symmetry", "reproduction"], "likes": 6, "viewed": 359, "published": 3, "date": "1598248314", "time_retrieved": "2024-07-30T20:49:20.176393", "image_code": "// animated variant of https://shadertoy.com/view/ttBBzz\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                    \n#define P(q)    t = min(t, abs(q.x)+5.),  /* invisible cell wall to fix sign() discont */ \\\n                r = sign(q.x)*q - vec3(3,0,-1.7)*(.6+2.5*min(T,1.-T)),                    \\\n                t = min(t, max( 1.-r.z, length(r.xy) - .4 )),  /* arm */                  \\\n                t = min(t, length( vec2(length(r.yz) - 1., abs(abs(r.x)-.4)-.2)) - .2 ) // 4 rings \"fingers\" \n  \nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=10.,T=fract(iTime), d;\n    vec3  R = iResolution, \n          D = normalize(vec3( U+U, -10.*R.y ) - R ),  // ray direction\n          p = 40./R, q,r;                             // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p, \n        q.yz *= rot(.6),                              // rotations\n        q.xz *= rot(-.3*iTime),\n        \n        P( q ),                 // P(-q),             // shape with 6 rotations \n        q.xz *= rot(2.1), P(q), // P(-q), \n        q.xz *= rot(2.1), P(q), // P(-q), \n        \n        p += t*D;                                     // step forward = dist to obj\n\n    O *= vec4(.8,.8,1,1);                             // coloring\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjBzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[512, 512, 548, 548, 1280]], "test": "untested"}
{"id": "tt2BRz", "name": "Gaussian Blur Ts", "author": "tigershan1130", "description": "Gaussian Blur Test", "tags": ["blur", "gaussianblur"], "likes": 2, "viewed": 344, "published": 3, "date": "1598246754", "time_retrieved": "2024-07-30T20:49:21.153779", "image_code": "#define textureLoaded(s) (textureSize(s,0).x>1)\n\nconst float weights[25] = float[25]\n    (\n      0.01, 0.02, 0.04, 0.02, 0.01,\n      0.02, 0.04, 0.08, 0.04, 0.02,\n      0.04, 0.08, 0.16, 0.08, 0.04,\n      0.02, 0.04, 0.08, 0.04, 0.02,\n      0.01, 0.02, 0.04, 0.02, 0.01 \n    );\n\nconst float offsets[5] = float[5](-2.0, -1.0, 0.0, 1.0, 2.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 res = vec3(0,0,0);\n    \n    float BlurRadius = sin(iTime) * 3.0; // blur fades in and out\n    \n    // Half of the screen's uv so it is at its illusional center\n    vec2 uv = fragCoord * 0.5;\n\n    for(int i = 0; i < 5; ++i)\n    {\n    \tfloat v = uv.y + offsets[i] * BlurRadius;\n        \n        int temp = i * 5;\n        \n        for(int j = 0; j < 5; ++j)\n        {\n\n            float u = uv.x + offsets[j] * BlurRadius;\n            vec2 uvShifted = uv + vec2(u,v);\n            \n            \n            float weight = weights[temp+j];\n            vec3 col = texture(iChannel0, uvShifted / iResolution.xy).rgb;\n            \n            res += col * weight;\n        }               \n    }\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(res,1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2BRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[342, 342, 399, 399, 1167]], "test": "untested"}
{"id": "ttjfRz", "name": "Volumetric Nebula Visualizer", "author": "Zi7ar21", "description": "Could be made more interesting...", "tags": ["audio", "visualizer", "volumetrics", "visualize", "uamee", "hardbass"], "likes": 3, "viewed": 496, "published": 3, "date": "1598244397", "time_retrieved": "2024-07-30T20:49:22.040409", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = (texture(iChannel0, uv).rgb+texture(iChannel1, uv).rgb+texture(iChannel2, uv).rgb+texture(iChannel3, uv).rgb)/4.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"Volumetric Nebula\" by Zi7ar21. https://shadertoy.com/view/ttfBDX\n// 2020-08-24 04:39:10\n\n// Fork of \"My Nebula\" by Zi7ar21. https://shadertoy.com/view/ttfBDN\n// 2020-08-19 23:12:29\n\n// Zi7ar21's In Progress Nebula Ray Marcher --- August 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttfBDN\n// Fork of \"My Very First Working Raymarcher\" by Zi7ar21. [2020-07-06 23:50:09]\n// https://shadertoy.com/view/WlBcDz\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 16\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 32.0\n\n// fBm Number of Octaves (Detail)\n#define NUM_OCTAVES 8\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.5\n\n// If you march less rays, the nebula will appear darker. Bump this up to make it brighter again,\n// Beware there will be more noise\n#define DENSITY 2.0\n\n// Oof ugly mess below watch out lol\n\n// ##### NOISE #####\n\n/*// White Noise\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\n// Convert Noise to 3D\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}*/\n\n// Noise for Dithering\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noised(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// fBm Noise\nfloat fbm(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < NUM_OCTAVES; ++i){\n\t\tv += a * texture(iChannel1, (x+vec3(1.0, 1.0, 0.0))/16.0).x;\n\t\tx = x * 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat nebulanoise(vec3 raypos){\n\tfloat density = clamp(fbm(raypos)-(-float(texture(iChannel0, vec2(0.0)))*-0.75), 0.0, 1.0)/pow(distance(vec3(0.0), raypos),4.0);\n\treturn density;\n}\n\n// ##### RAYMARCHING #####\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n\tfloat distorigin=0.0;\n\tfloat density=0.0;\n    vec3 raypos = camerapos;\n\tvec3 raydirmod = (raydir+(raydir*(noised(coord+((sin(float(iFrame%60))+3.14)*sqrt(coord.x*coord.x+coord.y*coord.y))))*STEP_SIZE))*STEP_SIZE;\n    for(int i=0; i<MAX_MARCHES; i++) {\n    \traypos = raypos + raydirmod;\n        float densityadd = nebulanoise(raypos)*DENSITY;\n        density = density+densityadd;\n        distorigin = raypos.z-camerapos.z;\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return density;\n}\n\n// ##### RENDERING #####\n\n// ACES Tone Curve\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n// Render the Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// Dumb rotation matrix hecking Michael begged me to add\n\tfloat xrot = 0.0;\n\tfloat yrot = 0.0;\n\tfloat zrot = float(texture(iChannel0, vec2(0.0)))*2.0;\n\t// Camera Orientation (Cursed)\n\tvec3 xdir = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\tvec3 ydir = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\tvec3 zdir = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n\tfloat FOV = 3.0;\n\tvec3 camerapos = vec3(0.0, 0.0, (texture(iChannel0, vec2(0.0)).x*0.25)-2.0);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (((fragCoord - 0.5*iResolution.xy)/iResolution.x));\n\tvec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n\tfloat raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n    // Pixel Color\n    vec3 col = vec3(raymarched);\n\t\n\t// Apply Tone Map\n    col = vec3(acesFilm(col*vec3(0.5, 0.75, 1.0)));\n\n    // Output to Screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25321, "src": "https://soundcloud.com/uamee/glock-vs-makarov-go-akimbo", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = (texture(iChannel0, uv).rgb+texture(iChannel1, uv).rgb+texture(iChannel2, uv).rgb)/3.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = (texture(iChannel0, uv).rgb+texture(iChannel1, uv).rgb+texture(iChannel2, uv).rgb)/3.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = (texture(iChannel0, uv).rgb+texture(iChannel1, uv).rgb+texture(iChannel2, uv).rgb)/3.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjfRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 106, 367]], "test": "untested"}
{"id": "tl2BRz", "name": "GIMP Spherize", "author": "pschroen", "description": "This is a port to GLSL of the GEGL Spherize image processing operation.\n\nGEGL Spherize:\n  [url]http://gegl.org/operations/gegl-spherize.html[/url]\n  [url]https://docs.gimp.org/2.10/en/gimp-filter-spherize.html[/url]\n", "tags": ["texture", "spherize", "gimp"], "likes": 1, "viewed": 376, "published": 3, "date": "1598242980", "time_retrieved": "2024-07-30T20:49:22.798382", "image_code": "/**\n * This is a port to GLSL of the GEGL Spherize image processing operation.\n *\n * Author: pschroen\n *\n * GEGL Spherize:\n *   http://gegl.org/operations/gegl-spherize.html\n *   https://docs.gimp.org/2.10/en/gimp-filter-spherize.html\n *\n * GEGL is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * GEGL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with GEGL; if not, see <https://www.gnu.org/licenses/>.\n *\n * Copyright (C) 2017 Ell\n */\n\n#define G_PI    3.1415926535897932384626433832795028841971693993751\n#define G_PI_2  1.5707963267948966192313216916397514420985846996876\n#define EPSILON 1e-10\n\nvec4 spherize(sampler2D image, vec2 uv, vec2 center, vec2 direction, float angle_of_view, float curvature, float amount)\n{\n    direction = 2.0 * direction;\n\n    float coangle_of_view_2 = max(180.0 - angle_of_view, 0.01) * G_PI / 360.0;\n    float focal_length      = tan(coangle_of_view_2);\n    float curvature_sign    = curvature > 0.0 ? 1.0 : -1.0;\n    float cap_angle_2       = abs(curvature) * coangle_of_view_2;\n    float cap_radius        = 1.0 / sin(cap_angle_2);\n    float cap_depth         = curvature_sign * cap_radius * cos(cap_angle_2);\n    float factor            = abs(amount);\n\n    float f     = focal_length;\n    float f2    = f * f;\n    float r     = cap_radius;\n    float r_inv = 1.0 / r;\n    float r2    = r * r;\n    float p     = cap_depth;\n    float f_p   = f + p;\n    float f_p2  = f_p * f_p;\n    float f_pf  = f_p * f;\n    float a     = cap_angle_2;\n    float a_inv = 1.0 / a;\n    float sgn   = curvature_sign;\n\n    bool perspective = angle_of_view > EPSILON;\n    bool inverse     = amount < 0.0;\n\n    float x = direction.x * (uv.x - center.x);\n    float y = direction.y * (uv.y - center.y);\n\n    float d2 = x * x + y * y;\n\n    if (d2 > EPSILON && d2 < 1.0 - EPSILON) {\n        float d = sqrt(d2);\n        float src_d = d;\n\n        if (!inverse) {\n            float d2_f2 = d2 + f2;\n\n            if (perspective)\n                src_d = (f_pf - sgn * sqrt(d2_f2 * r2 - f_p2 * d2)) * d / d2_f2;\n\n            src_d = (G_PI_2 - acos(src_d * r_inv)) * a_inv;\n        } else {\n            src_d = r * cos(G_PI_2 - src_d * a);\n\n            if (perspective)\n                src_d = f * src_d / (f_p - sgn * sqrt(r2 - src_d * src_d));\n        }\n\n        if (factor < 1.0)\n            src_d = d + (src_d - d) * factor;\n\n        uv.x = direction.x > 0.0 ? center.x + src_d * x / (direction.x * d) : uv.x;\n        uv.y = direction.y > 0.0 ? center.y + src_d * y / (direction.y * d) : uv.y;\n    }\n\n    return texture(image, uv);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    fragColor = spherize(iChannel0, uv, vec2(0.5, 0.5), vec2(1.0, 1.0), 0.0, 1.0, 1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2BRz.jpg", "access": "api", "license": "lgpl-3.0-plus", "functions": [[1074, 1074, 1196, 1196, 3014], [3016, 3016, 3071, 3071, 3204]], "test": "untested"}
{"id": "wljfzR", "name": "djpTestShader", "author": "dengjingping", "description": "asdf", "tags": ["some"], "likes": 0, "viewed": 224, "published": 3, "date": "1598236894", "time_retrieved": "2024-07-30T20:49:23.680025", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//写入纹理\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy/2.0f;\n    vec4 shapeColor = vec4(1,0,0,1);\n    vec4 backColor = vec4(0.2,0.3,0.5,1);\n    float shapeRadius = 70.0f;\n   \tfragColor = distance(center,fragCoord)<shapeRadius?shapeColor:backColor;\n\n}", "buffer_a_inputs": [], "common_code": "vec4 someFunction()\n{\n    return vec4(1,0,0,1);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 303]], "test": "untested"}
{"id": "wtjBzR", "name": "Moonmoon", "author": "DarkWyvren", "description": "yes", "tags": ["raymarch", "moon"], "likes": 1, "viewed": 274, "published": 3, "date": "1598232560", "time_retrieved": "2024-07-30T20:49:24.733210", "image_code": "const float EPSILON = 0.0005;\nconst int max_iter = 230;\nconst float MAXDIST = 70.0;\nconst float PI = 3.141592;\nfloat k = 0.1;\nfloat constDIV = 0.9;\nfloat moondist = 3.0;\nfloat asspace= 0.1;\nfloat asspacesc= 10.;\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\nfloat contrast(float x, float neg,float mul){\n\treturn max(0.0,mul*(x-neg));\n}\t\nfloat hash( uvec2 q )\n{\n    q *= uvec2(M1, M2); \n    \n    uint n = (q.x ^ q.y) * M1;\n    \n    return float(n) * (1.0/float(0xffffffffU));\n}\n\nvec3 hash3(uvec2 q )\n{\n    return vec3(hash(q),hash(q+uvec2(13.032)),hash(q+uvec2(2.12)));\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sphereSDF(vec3 pos, float r){\n\treturn length(pos)-r;\n}\n\nfloat boxSDF( vec3 pos, vec3 bounds )\n{\n  vec3 d = abs(pos) - bounds;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat boxSDF( vec2 pos, vec2 bounds )\n{\n  vec2 d = abs(pos) - bounds;\n  return length(max(d,0.0))\n         + min(max(d.x,d.y),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat roundEdge(float sdf,float rad){\n\treturn sdf+rad;\n}\n\nfloat sub(float sdf,float sdf2){\n\treturn max(-sdf,sdf2);\n}\nfloat Ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat add(float sdf,float sdf2){\n\treturn min(sdf,sdf2);\n}\nfloat Sadd(float sdf,float sdf2){\n\treturn smin(sdf,sdf2,k);\n}\n\nvec3 opRep( in vec3 p, in vec3 peroid)\n{\n    vec3 q = mod(p-0.5*peroid,peroid)-0.5*peroid;\n    return q;\n}\nvec2 opRep( in vec2 p, in vec2 peroid)\n{\n    vec2 q = mod(p-0.5*peroid,peroid)-0.5*peroid;\n    return q;\n}\n\nvec2 cartToSphere(vec3 cart){\n\treturn vec2(acos(cart.z),atan(cart.y,cart.x));\n}\n\nvec3 SphereToCart(vec2 sph){\n\treturn vec3(sin(sph.x)*cos(sph.y),sin(sph.x)*sin(sph.y),cos(sph.x));\n}\n\n\n\n\nvec4 getBG(vec3 dir){\n    return vec4(vec3(contrast(texture(iChannel0,10.*cartToSphere(dir)).x,0.56,5.0)),1.0);\n\n}\n\nfloat getSmoothnoise(vec3 thing){\n    vec3 thingrot = (rotationMatrix(vec3(1.,0.,0.),PI*0.5)*vec4(thing,0.0)).xyz;\n    vec2 thing2 = cartToSphere(normalize(thingrot));\n    //thing2*=10.0;\n\treturn clamp((vec4(1.9)//texture(iChannel0,thing2)*0.125\n           +texture(iChannel0,thing2*0.5)*0.05\n          //+texture(iChannel0,thing2*0.25)*0.5\n          +texture(iChannel2,thing2*0.125)*0.1\n                 -texture(iChannel3,thing2.xy*2.0)*0.3\n          ).r*0.8,-10.0,10.0);\n}\nfloat getpebblenoise(vec3 thing,float r){\n    vec3 thingrot = (rotationMatrix(vec3(1.,0.,0.),PI*0.5)*vec4(thing,0.0)).xyz;\n    vec2 thing2 = cartToSphere(normalize(thingrot));\n    //thing2*=10.0;\n\treturn clamp((vec4(1.0)//texture(iChannel0,thing2)*0.125\n\n                 -texture(iChannel3,thing2.xy*0.04+vec2(r))*2.\n          ).r*0.8,-10.0,10.0);\n}\nfloat asteroidSDF(vec3 pos, float r){\n\treturn length(pos)-r-getpebblenoise(pos,r*33.0)*r;\n}\n\nfloat moonSDF(vec3 raypos, vec3 pos, float scale\t){\n    float sdf = sphereSDF(raypos-pos,scale);\n    sdf-=0.025*max(0.85,getSmoothnoise(raypos-pos));\n    return sdf;\n}\n\nfloat getcrossSDF(vec3 pos, float scale\t){\n    \n    vec2 gridid = floor(pos.xz*asspacesc);\n    float t = length(gridid*asspace);\n    vec3 grididnoise = hash3(uvec2(gridid));\n    float moon = add(moonSDF(pos,vec3(0.0),scale),moonSDF(pos,vec3(moondist*sin(iTime),0.0,moondist*cos(iTime)),scale*0.6));;\n \n        return moon;\n}\n\nfloat getmoonBinarySDF(vec3 pos, float scale\t){\n   // float t = length(pos);\n   // vec2 gridid = floor(pos.xz/asspace);\n    float moon = add(moonSDF(pos,vec3(0.0),scale),moonSDF(pos,vec3(moondist*sin(iTime),0.0,moondist*cos(iTime)),scale*0.6));;\n \n    \n   // moon = add((texture(iChannel0,gridid*0.5).r*0.2+abs((t-49.0)*0.05))/scale+sphereSDF(vec3(mod(pos.x,asspace),pos.y,mod(pos.z,asspace))-vec3(asspace*0.5),0.1),moon);\n    return moon;\n}\n\nvec3 getNormal(vec3 pos, float scale){\n\treturn normalize(vec3(getcrossSDF(pos+vec3(EPSILON,0,0),scale)-getcrossSDF(pos-vec3(EPSILON,0,0),scale),  \n               \tgetcrossSDF(pos+vec3(0,EPSILON,0),scale)-getcrossSDF(pos-vec3(0,EPSILON,0),scale),  \n                getcrossSDF(pos+vec3(0,0,EPSILON),scale)-getcrossSDF(pos-vec3(0,0,EPSILON),scale)  \n               ));\n}\n\nfloat getDist(vec3 rayPos, vec3 raydir){\n    float totalDist = 0.0;\n    float sdfRN = 0.0;\n\tfor(int i = 0;i<max_iter;i++){\n    \tsdfRN = max(0.0,getcrossSDF(rayPos,1.0))*constDIV;\n        \n        rayPos += sdfRN*raydir;\n        totalDist += sdfRN;\n        if(sdfRN<EPSILON*2.0){\n            return totalDist;\n        \tbreak;\n        }\n        \n        if(sdfRN>MAXDIST){\n            return float(MAXDIST);\n        \tbreak;\n        }\n    }\n    return float(MAXDIST);\n\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = getmoonBinarySDF(ro + rd*t,0.7);\n        if( h<EPSILON )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat hardshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = getmoonBinarySDF(ro + rd*t,1.0);\n        if( h<EPSILON )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\nfloat getLightIntense(vec3 normal,vec3 lightdir,vec3 viewdir,float spec,float expo,float diff){\n\tvec3 ref = reflect(viewdir,normal);\n\treturn spec*pow(clamp(dot(ref,lightdir),0.0,1.0),expo) + max(0.0,dot(normal,lightdir)*diff);\n}\n\nvec4 getBuf(vec2 auv, float blur){\n    vec4 ttt = vec4(0.0);\n    for(int i =-5;i<5;i++){\n    \tttt+=texture(iChannel1,auv+vec2(blur*float(i),0.));\n    }\n   ttt.g=ttt.r;\n    ttt.b=ttt.r;\n    return ttt*0.1;\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 auv = fragCoord/iResolution.xy;\n    vec2 uv = 1.0*(fragCoord/iResolution.y - vec2(0.5*iResolution.x/iResolution.y,0.5));\n\tvec3 col;\n    vec3 camray ;\n     vec3 rayPos;\n    vec3 raydir;\n    camray = normalize(vec3(uv,-10.0));\n    vec3 light = normalize(SphereToCart(vec2(iTime*0.1+33.5,0.0)));\n    vec3 lookPos = vec3(0,0,0);//vec3(15.0*sin(iTime),-20.0*cos(0.25*iTime)*sin(iTime),0);\n    vec2 screenraypos = 2.0*(vec2(iMouse.x,iMouse.y)/iResolution.xy  - vec2(0,0.5)) ;\n    screenraypos*=0.04;\n    screenraypos.y+=0.03;\n    \n        rayPos = 50.0*SphereToCart(screenraypos);\n\t\t\n        mat4 camProj  = viewMatrix(rayPos, lookPos,vec3(0,1,0));\n        raydir = normalize((camProj * vec4(camray, 0.0)).xyz);\n     float cast1 = getDist(rayPos,raydir);\n    if(cast1>MAXDIST-EPSILON*2.0){\n    \tfragColor = getBG(raydir); //inital cast\n    }else{\n        vec3 norm= getNormal(rayPos+raydir*cast1, 1.0);\n        vec3 raypos2 = rayPos+raydir*cast1;\n        vec3 Light = max(vec3(0.0),getLightIntense(norm,light,raydir,0.1,2.0,0.9));\n \n        Light*=softshadow(raypos2,light,0.005,20.,9.0);\n        Light*=hardshadow(raypos2,light,0.005,1.,19.0);\n        Light+=getLightIntense(norm,-normalize(raypos2),raydir,0.1,2.0,0.9)*0.1*(dot(normalize(raypos2),light)*0.5+0.5);\n        if(length(raypos2)>1.4){\n        \tLight*=texture(iChannel2,cartToSphere(norm)).xyz;\n        }\n        Light*=4.0;\n        Light = log(Light+vec3(1.0));\n        fragColor = vec4(Light,1.0);\n    }\n    vec4 buffertex = getBuf(auv,0.005);\n    fragColor = mix(fragColor,buffertex,buffertex.a);\n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 342, 342, 374], [376, 376, 399, 399, 515], [517, 517, 539, 539, 609], [611, 611, 656, 656, 1284], [1285, 1285, 1334, 1334, 1521], [1523, 1523, 1564, 1564, 1648], [1650, 1650, 1685, 1685, 1710], [1712, 1712, 1751, 1751, 1908], [1909, 1909, 1948, 1948, 2096], [2098, 2098, 2135, 2135, 2154], [2156, 2156, 2188, 2188, 2214], [2215, 2215, 2258, 2258, 2359], [2361, 2361, 2393, 2393, 2418], [2419, 2419, 2452, 2452, 2480], [2482, 2482, 2522, 2522, 2588], [2589, 2589, 2629, 2629, 2695], [2697, 2697, 2726, 2726, 2776], [2778, 2778, 2806, 2806, 2878], [2883, 2883, 2904, 2904, 2997], [2999, 2999, 3032, 3032, 3474], [3475, 3475, 3516, 3516, 3825], [3826, 3826, 3863, 3863, 3917], [3919, 3919, 3970, 3970, 4086], [4088, 4088, 4130, 4130, 4412], [4414, 4414, 4461, 4533, 4855], [4857, 4857, 4895, 4895, 5225], [5227, 5227, 5267, 5267, 5694], [5696, 5696, 5773, 5773, 6005], [6007, 6007, 6084, 6084, 6316], [6317, 6317, 6412, 6412, 6545], [6547, 6547, 6581, 6581, 6753], [6757, 6757, 6814, 6814, 8387]], "test": "untested"}
{"id": "3t2fzz", "name": "float/vec2/vec3/vec4 generics", "author": "ttg", "description": "Allows single function definitions accepting vec2, vec3, vec4, (and float if needed).", "tags": ["glsl", "macro", "generics"], "likes": 8, "viewed": 1178, "published": 3, "date": "1598228292", "time_retrieved": "2024-07-30T20:49:25.611860", "image_code": "/*\n\nUser-defined GLSL generics\nCreated by Theron Tarigo, 2020\nhttps://www.shadertoy.com/view/3t2fzz\n\nAllows single function definitions accepting vec2, vec3, vec4, (and float if needed).\n\n\n*/\n                                                                                                                                                                                                                                                                #define XXX /*\n\n\n    SEE COMMON TAB\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n*/\n\n////// BEGIN text encoding https://www.shadertoy.com/view/Wd2SDt\nconst struct CCDS_T {\n  uint\n    skipstart, rewind, reverse, record, stop, play, pause, fastforward, skipend, note4, note8, noteb16, notebb16, _flat, natural, sharp,\n    leftarrow, uparrow, rightarrow, downarrow, leftright, updown, upleft, upright, downright, downleft, ccw, cw, star, smiley, mute, loud,\n    _,   em,  dq,  ha,  ds,  mo,  am,  sq,  lp,  rp,  as,  pl,  cm,  hm,  pe,  sl,\n    _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  co,  sc,  lt,  eq,  gt,  qm,\n    at,   A,   B,   C,   D,   E,   F,   G,   H,   I,   J,   K,   L,   M,   N,   O,\n     P,   Q,   R,   S,   T,   U,   V,   W,   X,   Y,   Z,  lb,  bs,  rb,  up,  un,\n    bt,   a,   b,   c,   d,   e,   f,   g,   h,   i,   j,   k,   l,   m,   n,   o,\n     p,   q,   r,   s,   t,   u,   v,   w,   x,   y,   z,  lc,  ba,  rc,  ti, _U0,\n   alp, bet, gam, del, eps, the, lam,  mu,  xi,  pi, rho, sig, tau, phi, psi, ome,\n   Gam, Del, The, Lam,  Pi, Sig, Phi, Psi, Ome, inf,flor,ring,intg,pdrv, nab,sqrt,\n   _U1, iem, cen, pou, cur, yen, bba, sec, dia, cop, fem, lda, not, _U2, reg, mac,\n   deg, pms, su2, su3, acu, mic, pil, mid, ced, su1, mas, rda, v14, v12, v34, iqm,\n    AG,  AA,  AC,  AT,  AD,  AR,  AE,  CC,  EG,  EA,  EC,  ED,  IG,  IA,  IC,  ID,\n   Eth,  NT,  OG,  OA,  OC,  OT,  OD, mul,  OS,  UG,  UA,  UC,  UD,  YA, Tho, Sha,\n    aG,  aA,  aC,  aT,  aD,  aR,  ae,  cC,  eG,  eA,  eC,  eD,  iG,  iA,  iC,  iD,\n   eth,  nT,  oG,  oA,  oC,  oT,  oD, div,  oS,  uG,  uA,  uC,  uD,  yA, yho,  yD,  \n  _nul;\n} CCDS = CCDS_T(\n  0x00u,0x01u,0x02u,0x03u,0x04u,0x05u,0x06u,0x07u,0x08u,0x09u,0x0au,0x0bu,0x0cu,0x0du,0x0eu,0x0fu,\n  0x10u,0x11u,0x12u,0x13u,0x14u,0x15u,0x16u,0x17u,0x18u,0x19u,0x1au,0x1bu,0x1cu,0x1du,0x1eu,0x1fu,\n  0x20u,0x21u,0x22u,0x23u,0x24u,0x25u,0x26u,0x27u,0x28u,0x29u,0x2au,0x2bu,0x2cu,0x2du,0x2eu,0x2fu,\n  0x30u,0x31u,0x32u,0x33u,0x34u,0x35u,0x36u,0x37u,0x38u,0x39u,0x3au,0x3bu,0x3cu,0x3du,0x3eu,0x3fu,\n  0x40u,0x41u,0x42u,0x43u,0x44u,0x45u,0x46u,0x47u,0x48u,0x49u,0x4au,0x4bu,0x4cu,0x4du,0x4eu,0x4fu,\n  0x50u,0x51u,0x52u,0x53u,0x54u,0x55u,0x56u,0x57u,0x58u,0x59u,0x5au,0x5bu,0x5cu,0x5du,0x5eu,0x5fu,\n  0x60u,0x61u,0x62u,0x63u,0x64u,0x65u,0x66u,0x67u,0x68u,0x69u,0x6au,0x6bu,0x6cu,0x6du,0x6eu,0x6fu,\n  0x70u,0x71u,0x72u,0x73u,0x74u,0x75u,0x76u,0x77u,0x78u,0x79u,0x7au,0x7bu,0x7cu,0x7du,0x7eu,0x7fu,\n  0x80u,0x81u,0x82u,0x83u,0x84u,0x85u,0x86u,0x87u,0x88u,0x89u,0x8au,0x8bu,0x8cu,0x8du,0x8eu,0x8fu,\n  0x90u,0x91u,0x92u,0x93u,0x94u,0x95u,0x96u,0x97u,0x98u,0x99u,0x9au,0x9bu,0x9cu,0x9du,0x9eu,0x9fu,\n  0xa0u,0xa1u,0xa2u,0xa3u,0xa4u,0xa5u,0xa6u,0xa7u,0xa8u,0xa9u,0xaau,0xabu,0xacu,0xadu,0xaeu,0xafu,\n  0xb0u,0xb1u,0xb2u,0xb3u,0xb4u,0xb5u,0xb6u,0xb7u,0xb8u,0xb9u,0xbau,0xbbu,0xbcu,0xbdu,0xbeu,0xbfu,\n  0xc0u,0xc1u,0xc2u,0xc3u,0xc4u,0xc5u,0xc6u,0xc7u,0xc8u,0xc9u,0xcau,0xcbu,0xccu,0xcdu,0xceu,0xcfu,\n  0xd0u,0xd1u,0xd2u,0xd3u,0xd4u,0xd5u,0xd6u,0xd7u,0xd8u,0xd9u,0xdau,0xdbu,0xdcu,0xddu,0xdeu,0xdfu,\n  0xe0u,0xe1u,0xe2u,0xe3u,0xe4u,0xe5u,0xe6u,0xe7u,0xe8u,0xe9u,0xeau,0xebu,0xecu,0xedu,0xeeu,0xefu,\n  0xf0u,0xf1u,0xf2u,0xf3u,0xf4u,0xf5u,0xf6u,0xf7u,0xf8u,0xf9u,0xfau,0xfbu,0xfcu,0xfdu,0xfeu,0xffu,\n0x7fu);\n\n#define U4CHAR4(a,b,c,d) ((CCDS.a)+(CCDS.b<<8)+(CCDS.c<<16)+(CCDS.d<<24))\n\n#define STRING16(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af) )\n\n#define STRING32(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf) )\n\n#define STRING64(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf,\\\n  c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,ca,cb,cc,cd,ce,cf,\\\n  d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,da,db,dc,dd,de,df)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf),\\\n      U4CHAR4(c0,c1,c2,c3),U4CHAR4(c4,c5,c6,c7),U4CHAR4(c8,c9,ca,cb),U4CHAR4(cc,cd,ce,cf),\\\n      U4CHAR4(d0,d1,d2,d3),U4CHAR4(d4,d5,d6,d7),U4CHAR4(d8,d9,da,db),U4CHAR4(dc,dd,de,df))\n\n#define STRING80(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf,\\\n  c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,ca,cb,cc,cd,ce,cf,\\\n  d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,da,db,dc,dd,de,df,\\\n  e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,ea,eb,ec,ed,ee,ef)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf),\\\n      U4CHAR4(c0,c1,c2,c3),U4CHAR4(c4,c5,c6,c7),U4CHAR4(c8,c9,ca,cb),U4CHAR4(cc,cd,ce,cf),\\\n      U4CHAR4(d0,d1,d2,d3),U4CHAR4(d4,d5,d6,d7),U4CHAR4(d8,d9,da,db),U4CHAR4(dc,dd,de,df),\\\n      U4CHAR4(e0,e1,e2,e3),U4CHAR4(e4,e5,e6,e7),U4CHAR4(e8,e9,ea,eb),U4CHAR4(ec,ed,ee,ef))\n\n#define DEF_DRAW_STRING(N) \\\nfloat draw_string (sampler2D sampler,                    \\\n                   in vec2 uv, const uint[1+N] string) { \\\n  int i = int(uv.x);                                     \\\n  int strlen = min(int(string[0]),N*4);                  \\\n  if (uv.x<0.||i>=strlen) return 0.;                     \\\n  int code = int( (string[i/4+1]>>((i%4)*8)) &0xFFu);    \\\n  if (uv.y<0.||uv.y>1.) return 0.;                       \\\n  uv.x=fract(uv.x)/2.+.25; uv.y=1.-uv.y;                 \\\n  uv+=vec2(code%16,15-code/16);                          \\\n  return texture(sampler, uv/16.).r;                   }\nDEF_DRAW_STRING(8)\nDEF_DRAW_STRING(16)\nDEF_DRAW_STRING(20)\n////// END text encoding\n\n/*\nDefine new generics, example:\n  T project(T a, T b) {     ...\n  float lensq(T x)          ...\nT  -> float, vec2,  vec3,  vec4\nTI ->  int, ivec2, ivec3, ivec4\nTU -> uint, uvec2, uvec3, uvec4\nTB -> bool, bvec2, bvec3, bvec4\n*/\n\nconst uint[] line1 = STRING32(32, D,e,f,i,n,e,_,n,e,w,_,g,e,n,e,r,i,c,s,cm,_,e,x,a,m,p,l,e,co,_,_,_);\nconst uint[] line2 = STRING32(32, _,_,T,_,p,r,o,j,e,c,t,lp,T,_,a,cm,_,T,_,b,rp,_,lc,_,_,_,_,_,pe,pe,pe,_);\nconst uint[] line3 = STRING32(32, _,_,f,l,o,a,t,_,l,e,n,s,q,lp,T,_,x,rp,_,lc,_,_,_,_,_,_,_,_,pe,pe,pe,_);\nconst uint[] line4 = STRING32(32, T,_,_,rightarrow,_,f,l,o,a,t,cm,_,v,e,c,_2,cm,_,_,v,e,c,_3,cm,_,_,v,e,c,_4,_,_);\nconst uint[] line5 = STRING32(32, T,I,_,rightarrow,_,_,i,n,t,cm,_,i,v,e,c,_2,cm,_,i,v,e,c,_3,cm,_,i,v,e,c,_4,_,_);\nconst uint[] line6 = STRING32(32, T,U,_,rightarrow,_,u,i,n,t,cm,_,u,v,e,c,_2,cm,_,u,v,e,c,_3,cm,_,u,v,e,c,_4,_,_);\nconst uint[] line7 = STRING32(32, T,B,_,rightarrow,_,b,o,o,l,cm,_,b,v,e,c,_2,cm,_,b,v,e,c,_3,cm,_,b,v,e,c,_4,_,_);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y=1.-uv.y; // Left-handed coordinate system is most natural for Latin text layout\n    fragColor = vec4(vec3(0.),1.0);\n    vec2 grid = vec2(34,10);\n    fragColor+=draw_string(iChannel0,uv*grid-vec2(1,1.0), line1);\n    fragColor+=draw_string(iChannel0,uv*grid-vec2(1,2.5), line2);\n    fragColor+=draw_string(iChannel0,uv*grid-vec2(1,4.0), line3);\n    fragColor+=draw_string(iChannel0,uv*grid-vec2(1,5.5), line4);\n    fragColor+=draw_string(iChannel0,uv*grid-vec2(1,6.5), line5);\n    fragColor+=draw_string(iChannel0,uv*grid-vec2(1,7.5), line6);\n    fragColor+=draw_string(iChannel0,uv*grid-vec2(1,8.5), line7);\n\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Beginning of example usage of generics\n\n#define GENFUNS      \\\n                     \\\nfloat lensq(T x)   { \\\n  return dot(x,x);   \\\n}                    \\\n                     \\\nT square(T x) {      \\\n  return x*x;        \\\n}                    \\\n// end of GENFUNS\n\n#define GENVECFUNS            \\\n                              \\\nT project(T a, T b) {         \\\n  return dot(a,b)/dot(b,b)*b; \\\n}                             \\\n// end of GENVECFUNS\n\n// End of generics example usage\n    \n\n// User-defined GLSL generics example by ttg\n// https://www.shadertoy.com/view/3t2fzz\n#undef T\n#undef TI\n#undef TU\n#undef TB\n#define T float\n#define TI  int\n#define TU uint\n#define TB bool\nGENFUNS\n#undef T\n#undef TI\n#undef TU\n#undef TB\n#define T   vec2\n#define TI ivec2\n#define TU uvec2\n#define TB bvec2\nGENFUNS\nGENVECFUNS\n#undef T\n#undef TI\n#undef TU\n#undef TB\n#define T   vec3\n#define TI ivec3\n#define TU uvec3\n#define TB bvec3\nGENFUNS\nGENVECFUNS\n#undef T\n#undef TI\n#undef TU\n#undef TB\n#define T   vec4\n#define TI ivec4\n#define TU uvec4\n#define TB bvec4\nGENFUNS\nGENVECFUNS\n#undef T\n#undef TI\n#undef TU\n#undef TB\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2fzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[7385, 7385, 7442, 7442, 8101]], "test": "untested"}
{"id": "WtjBRz", "name": "Spinner 1", "author": "michalwa", "description": "A glowing orb loading spinner", "tags": ["animation", "glow", "loading", "spinner"], "likes": 7, "viewed": 442, "published": 3, "date": "1598220192", "time_retrieved": "2024-07-30T20:49:26.583262", "image_code": "#define NUM_BALLS 3\n#define BLENDING 30.0\n#define FALLOFF 20.0\n#define SIZE 100.0\n#define GLOW 200.0\n\nfloat smin(float a, float b, float k)\n{\n    float res = exp2(-k * a) + exp2(-k * b);\n    return -log2(res) / k;\n}\n\nfloat glow(float dist)\n{\n    return max(SIZE - dist, 0.0) / FALLOFF;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy / 2.0;\n    \n    // { X freq, X phase, Y freq, Y phase, radius }\n    const float waves[NUM_BALLS * 5] = float[](\n        1.23, 4.56, 3.21, 5.43, 50.0,\n        3.45, 1.26, 3.45, 2.15, 50.0,\n        2.14, 2.52, 1.25, 3.64, 50.0\n    );\n    \n    const vec3 colors[NUM_BALLS] = vec3[](\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n    \n    \n    vec2 balls[NUM_BALLS];\n    for(int i = 0; i < NUM_BALLS; i++)\n    {\n        balls[i] = center + vec2(\n            cos(iTime * waves[i * 5]     + waves[i * 5 + 1]),\n            sin(iTime * waves[i * 5 + 2] + waves[i * 5 + 3])) * waves[i * 5 + 4];\n    }\n    \n    float minDist = distance(fragCoord, balls[0]);\n    vec3 finalColor = colors[0] * clamp(1.0 - minDist / GLOW, 0.0, 1.0);\n    \n       for(int i = 1; i < NUM_BALLS; i++)\n    {\n        float dist = distance(fragCoord, balls[i]);\n        minDist = smin(minDist, dist, 1.0 / BLENDING);\n        \n        finalColor += colors[i] * clamp(1.0 - dist / GLOW, 0.0, 1.0);\n    }\n    \n    fragColor = vec4(finalColor * glow(minDist), 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjBRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 141, 141, 215], [217, 217, 241, 241, 287]], "test": "untested"}
{"id": "wllfDf", "name": "21. Making A Heart in Shade Toy", "author": "altera0", "description": "Source :   https://www.youtube.com/watch?v=dXyPOLf2MbU  \nMy Onet Game : https://play.google.com/store/apps/details?id=com.SimpleBox.EnglishWordConnect", "tags": ["makingaheart"], "likes": 0, "viewed": 244, "published": 3, "date": "1598217561", "time_retrieved": "2024-07-30T20:49:27.482857", "image_code": "float SmoothMax( float a , float b , float k) {\n\tfloat h = clamp( ( b - a ) / k + 0.5, 0.0 , 1.0 );\n    \n    ///float smax = a * h + ( 1.0 - h ) * b - h * 0.5; \n    \n    float smax = mix( a , b , h ) + h * ( 1.0 - h ) * k * 0.5;\n    \n    return smax;\n}\n\n\nfloat ShapeHeart( vec2 uv , float radius , float blur ) {\n    \n   \n    uv.y = uv.y - SmoothMax( sqrt( abs( uv.x ) ) * 0.5 , blur, 0.1);\n    \n    \n    float c;\n    \n    float d = length(uv);\n    c = smoothstep( radius + blur , radius - blur , d );\n\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5f * iResolution.xy ) /iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    float radius = 0.25;\n    float blur = radius * m.y;\n\n    uv.y *= 1.25;\n    uv.y += 0.1;\n    uv.x *= 0.7;\n\n    \n    float c = ShapeHeart( uv , radius , blur );\n    \n    col = vec3( 1.0 , 0.1 , 0.1 ) * vec3(c);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 252], [255, 255, 312, 312, 518], [520, 520, 577, 577, 972]], "test": "untested"}
{"id": "tllfDf", "name": "20. Function Smoothing Explained", "author": "altera0", "description": "Source :  https://www.youtube.com/watch?v=YJ4iyff7zbk \nMy Onet Game : https://play.google.com/store/apps/details?id=com.SimpleBox.EnglishWordConnect", "tags": ["functionsmoothing"], "likes": 0, "viewed": 271, "published": 3, "date": "1598211723", "time_retrieved": "2024-07-30T20:49:28.537039", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n\t\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    uv.x = (uv.x + 0.5 * aspectRatio ) * 2.0;\n    uv.y = uv.y + 0.5;// / aspectRatio ;\n    \n\n    float k = (( ( iMouse.xy / iResolution.xy ) ) * 5.0).x; \n    \n    vec3 col = vec3(0);\n    \n    //k = 0.0;\n    \n    float a = sqrt(uv.x);\n    float b = ( 2.0 - uv.x ) * ( 2.0- uv.x );\n    //float minValue = min( a , b );\n    float h2 = max( 0.0 , min( 1.0 , (b-a)/k + 0.5));\n    float m = h2 * ( 1.0 - h2 ) * k;\n    float l = h2 * a + ( 1.0 - h2 ) * b - m *0.5;\n\n    \n    \n    col =vec3(1) -  vec3( step( l , uv.y) )* vec3( 0.8 , 0.2 , 0.1 );\n        \n    \n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 840]], "test": "untested"}
{"id": "WllfzB", "name": "Concrete++", "author": "dean_the_coder", "description": "I wanted a procedural 3D texture for future projects, written in a way which can be easily shared.\nThanks to @Shane, there's no need for any texture channels to be used.\nSee getConcreteMaterial() for the texture code.  The corridor, etc is just a demo.\n\n", "tags": ["raymarching", "sdf", "texture", "material", "concrete"], "likes": 10, "viewed": 776, "published": 3, "date": "1598207431", "time_retrieved": "2024-07-30T20:49:29.361833", "image_code": "// 'Concrete++'\n//\n// I wanted a procedural 3D concrete texture for future projects, written in a way which\n// can be easily shared.\n// See getConcreteMaterial() for the texture code.\n//\n// Thanks to @Shane, there's no need for any texture channels to be used.\n//\n// The corridor, etc is just a demo so I can see how it all looks in a 3D scene.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST 0.0015\n\n#define AA  // Comment out this line for a speed boost.\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 opRep(vec2 p, vec2 c) {\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat opRep(inout float p, float size, float c1, float c2) {\n    float w2 = size * 0.5;\n    float pp = p - w2;\n    float idx = clamp(floor(pp / size), c1, c2);\n    p = pp - size * idx - w2;\n    return fract(idx * 12532.56);\n}\n\nfloat opRep(inout vec2 p, vec2 size, vec2 c1, vec2 c2) {\n    vec2 w2 = size * 0.5;\n    vec2 pp = p - w2;\n    vec2 idx = clamp(floor(pp / size), c1, c2);\n    p = pp - size * idx - w2;\n    return dot(fract(idx * 12532.56), vec2(421.0, 965.0));\n}\n\nvec4 min4(vec4 a, vec4 b) { return a.x < b.x ? a : b; }\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\n// Call to create a concrete-like 3D texture.\n//\n// p:   [in]  point in 3D space.\n// mat: [out] material rgb\n// id:  [in]  arbitary ID used as a rnd seed.\n// dist:[in]  distance from ray origin (Used to fade out surface displacement, avoiding rendering artifacts).\n// returns: surface noise value to apply to a SDF function.\nfloat getConcreteMaterial(vec3 p, out vec3 mat, float id, float dist) {\n    // Set rnd seed from id.\n    vec3 tp = p + vec3(0.32, 0.40, 1.2) * mod(id, 10.0);\n    \n    // Mix a couple of shades of grey.\n    float baseColor = smoothstep(0.0, 0.5, noise(tp));\n    mat = mix(vec3(0.18, 0.17, 0.17), vec3(0.20, 0.19, 0.19), baseColor);\n\n    // Surface roughness.\n    dist = 1.0 - smoothstep(0.0, 1.0, dist / 14.0);\n    float rough = noise(tp * 60.0) * 0.005 // Base\n         \t\t  + step(0.2, noise(tp * 26.666)) * 0.0033; // Pits/dents.\n    mat += rough * 24.0;\n    \n    // Fade surface roughness(/deflection) out with distance to prevent screen noise.\n    return rough * dist;\n}\n\n// A rectangular concrete 'wall panel', with a small hole in each corner.\n//\n// p: point in 3D space.\n// r: dimensions (halved)\n// id: arbitary ID used as a rnd seed.\n// dist: distance from ray origin (Used to fade out surface displacement, avoiding rendering artifacts).\n// returns (distance, material rgb)\nvec4 sdConcretePanel(vec3 p, vec3 r, float id, float dist) {\n    // Tilt each panel a small amount.\n    mat2 tilt = rot((fract(sin(id) * 43758.5453) - 0.5) * 0.03);\n    p.xz *= tilt;\n    p.yz *= tilt;\n    \n    float d = sdBox(p, r - 0.04) - 0.04;\n    \n    // Mounting holes.\n    vec3 pp = p;\n    pp.xy = abs(p.xy) - r.xy * 0.8;\n    float hole = sdCappedCylinder(pp + vec3(0.0, 0.0, r.z * 1.5), r.x * 0.03, r.z * 1.0);\n    d = max(d, -hole);\n    \n    // Apply material.\n    vec3 mat;\n    d -= getConcreteMaterial(p, mat, id, dist);\n    return vec4(d, mat);\n}\n\n// Concrete paving slab.\n//\n// p: point in 3D space.\n// r: dimensions (halved)\n// id: arbitary ID used as a rnd seed.\n// dist: distance from ray origin (Used to fade out surface displacement, avoiding rendering artifacts).\n// returns (distance, material rgb)\nvec4 sdSlab(vec3 p, vec3 r, float id, float dist) {\n    // Tilt each slab a small amount.\n    mat2 tilt = rot((fract(sin(id) * 43758.5453) - 0.5) * 0.05);\n    p.xz *= tilt;\n    p.yz *= tilt;\n\n    float d = sdBox(p, r - 0.04) - 0.04;\n    \n    // Apply material.\n    vec3 mat;\n    d -= getConcreteMaterial(p, mat, id, dist);\n    return vec4(d, mat);\n}\n\n// Map the scene using SDF functions.\nvec4 map(vec3 p, vec3 ro) {\n    vec3 r = vec3(1.0, 2.0, 0.05);\n    \n    vec4 d = vec4(1e10);\n    \n    float dist = distance(p, ro);\n    \n    // Left wall.\n    vec3 pp = p;\n    pp.xz *= rot(3.141 / 2.0);\n    pp.z -= 5.0;\n    float id = opRep(pp.xy, r.xy * 2.0, vec2(-15.0, -2.0), vec2(10.0, 1.0));\n    d = min4(d, sdConcretePanel(pp, r, id, dist));\n    \n    // Far wall.\n    pp = p;\n    id = opRep(pp.xy, r.xy * 2.0, vec2(-5.0, -2.0), vec2(5.0, 1.0));\n    d = min4(d, sdConcretePanel(pp - vec3(0.0, 0.0, 33.0), r, id, dist));\n    \n    // Columns.\n    pp = p - vec3(8.0, 0.0, 0.0);\n    id = opRep(pp.z, 5.0, -4.0, 3.0);\n    d = min4(d, sdSlab(pp, vec3(2.0, 8.0, 1.0), 1.0, dist));\n    \n    // Floor.\n    pp = p;\n    pp.yz *= rot(3.141 / 2.0);\n    pp.z -= 5.0;\n    r = vec3(3.0, 3.0, 0.1);\n    id = opRep(pp.xy, r.xy * 2.0, vec2(-5.0, -5.0), vec2(6.0, 6.0));\n    d = min4(d, sdSlab(pp, r, id, dist));\n    \n    // Ceiling.\n    d = min4(d, sdSlab(p - vec3(1.0, 10.0, 0.0), vec3(10.0, 3.0, 50.0), 1.0, dist));\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 p, vec3 ro) {\n    vec2 e = vec2(1.0, -1.0) * 0.005773;\n    return normalize(e.xyy * map(p + e.xyy, ro).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx, ro).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy, ro).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx, ro).x);\n}\n\nfloat calcShadow(vec3 p, vec3 ro, vec3 lightPos) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float res = 1.0;\n    float t = 0.05;\n    for(float i = 0.0; i < 45.0; i++)\n    {\n        float h = map(p + rd * t, ro).x;\n        if (h < MIN_DIST * t)\n            return 0.0; // Hit an object - Full shadow.\n        \n        res = min(res, 48.0 * h / t);\n        t += h;\n        \n        if (t > 20.0)\n            break; // Marched far enough - Stop.\n    }\n    \n    return res;\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 ro, vec3 n, float h) {\n    return map(p + h * n, ro).x / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, vec3 ro, vec3 mat) {\n    vec3 sunCol = vec3(2.0, 1.6, 1.4);\n    vec3 sunPos = vec3(100.0, 50.0, -10.0);\n    vec3 sunDir = normalize(sunPos - p);\n    vec3 n = calcNormal(p, ro);\n    float amb = dot(vec3(ao(p, ro, n, 0.2), ao(p, ro, n, 0.5), ao(p, ro, n, 2.0)), vec3(0.2, 0.3, 0.5));\n    \n    // Diffuse color.\n    float diff = max(0.0, dot(sunDir, n));\n    \n    // Primary light (Sun).\n    float sha = calcShadow(p, ro, sunPos) + 0.25;\n    vec3 lig = diff * sunCol * sha;\n\n    // Specular.\n    lig += pow(max(0.0, dot(rd, reflect(normalize(sunPos - p), n))), 15.0);\n\n    // Seconary light (Bounce light);\n    lig += max(0.0, dot(-sunDir, n)) * sunCol * 0.1 * amb;\n    \n    return mat * lig;\n}\n\nvec4 march(vec3 ro, vec3 rd, out vec3 p) {\n    float d = 0.01, prevd = 1.0;\n    vec4 details;\n    for (float steps = 0.0; steps < 64.0; steps++) {\n        p = ro + rd * d;\n        details = map(p, ro);\n        \n        if (abs(details.x) < MIN_DIST)\n            break; // We've hit a surface - Stop.\n        if (d > 35.0) return vec4(1e7, 0.0, 0.0, 0.0);\n        \n        d += details.x; // No hit, so keep marching.\n    }\n    \n    return details;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n  \tvec4 details = march(ro, rd, p);\n        \n    // Materials and lighting.\n    return applyLighting(p, rd, ro, details.yzw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera.\n    float ft = smoothstep(0.0, 1.0, fract(iTime / 9.5));\n    float phase = mod(floor(iTime / 9.5), 3.0);\n    float dim = 1.0 - pow(abs(cos(iTime * 3.141 / 9.5)), 100.0);\n    \n    vec3 ro;\n    vec3 lookAt;\n    \n    if (phase == 0.0) {\n        ro = vec3(mix(22.0, 9.0, ft), 0.0, 8.0);\n        lookAt = vec3(6.0, 0.0, mix(5.0, 13.0, ft));\n    } else if (phase == 1.0) {\n        ro = vec3(0.0, 0.0, mix(-9.0, 4.5, ft));\n        lookAt = vec3(0.0, mix(-10.0, 0.0, ft), mix(0.0, 8.0, ft));\n    } else if (phase == 2.0) {\n        ro = vec3(-1.0, 0.0, mix(-4.0, 0.0, ft));\n        lookAt = vec3(-5.0, mix(-1.0, 1.0, ft), ro.z + mix(0.0, 5.0, ft));\n    }\n\n    vec3 col = vec3(0.0);\n#ifdef AA\n    for (float dx = 0.0; dx <= 1.0; dx++) {\n        for (float dy = 0.0; dy <= 1.0; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\n#else\n            vec2 coord = fragCoord;\n#endif\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\n            vec3 rd = getRayDir(ro, lookAt, uv);\n            col += getSceneColor(ro, rd);\n#ifdef AA\n        }\n    }\n    col /= 4.0;\n#endif\n    \n    col *= dim;\n    \n    // Output to screen.\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllfzB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[631, 687, 708, 708, 984], [986, 986, 1005, 1005, 1081], [1083, 1083, 1111, 1111, 1155], [1157, 1157, 1217, 1217, 1382], [1384, 1384, 1440, 1440, 1627], [1629, 1629, 1656, 1656, 1684], [1686, 1686, 1715, 1715, 1810], [1812, 1812, 1862, 1862, 1974], [1976, 1976, 2023, 2023, 2228], [2230, 2555, 2626, 2655, 3228], [3230, 3538, 3598, 3637, 4095], [4097, 4356, 4407, 4445, 4705], [4707, 4745, 4772, 4772, 5769], [5771, 5771, 5805, 5805, 6014], [6016, 6016, 6066, 6066, 6494], [6496, 6524, 6568, 6568, 6607], [6695, 6695, 6736, 6736, 6877], [6879, 6879, 6935, 6935, 7606], [7608, 7608, 7650, 7650, 8057], [8059, 8059, 8097, 8114, 8254]], "test": "untested"}
{"id": "ttBBzz", "name": "Interlocked arms 2", "author": "FabriceNeyret2", "description": "simplified version of the classical 4 interlocked arms.   6-arms variant\n[url]https://www.google.com/search?q=4+interlocked+arms&tbm=isch[/url]\n\nUsing 4-rotation symmetry folding seems more costly, but 2-rotation is ok.", "tags": ["raymarching", "symmetry", "reproduction"], "likes": 8, "viewed": 321, "published": 3, "date": "1598204111", "time_retrieved": "2024-07-30T20:49:30.265418", "image_code": "// 6-fold variant of https://shadertoy.com/view/tlSfRz\n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                    \n#define P(q)    t = min(t, abs(q.x)+5.),  /* invisible cell wall to fix sign() discont */ \\\n                r = sign(q.x)*q - vec3(3,0,-1.7),                                         \\\n                t = min(t, max( 1.-r.z, length(r.xy) - .4 )),  /* arm */                  \\\n                t = min(t, length( vec2(length(r.yz) - 1., abs(abs(r.x)-.4)-.2)) - .2 ) // 4 rings \"fingers\" \n  \nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=10.,d;\n    vec3  R = iResolution, \n          D = normalize(vec3( U+U, -10.*R.y ) - R ),  // ray direction\n          p = 40./R, q,r;                             // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p, \n        q.yz *= rot(.6),                              // rotations\n        q.xz *= rot(-.3*iTime),\n        \n        P( q ),                 // P(-q),             // shape with 6 rotations \n        q.xz *= rot(2.1), P(q), // P(-q), \n        q.xz *= rot(2.1), P(q), // P(-q), \n        \n        p += t*D;                                     // step forward = dist to obj\n\n    O *= vec4(1,.8,.8,1);                             // coloring\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBBzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[510, 510, 546, 546, 1262]], "test": "untested"}
{"id": "tlSfRz", "name": "Interlocked arms", "author": "FabriceNeyret2", "description": "simplified version of the classical 4 interlocked arms. \n[url]https://www.google.com/search?q=4+interlocked+arms&tbm=isch[/url]\n\nUsing 4-rotation symmetry folding seems more costly, but 2-rotation is ok.", "tags": ["raymarching", "symmetry", "reproduction"], "likes": 8, "viewed": 288, "published": 3, "date": "1598201929", "time_retrieved": "2024-07-30T20:49:31.031370", "image_code": "#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                    \n#define P(q)    t = min(t, abs(q.x)+3.),  /* invisible cell wall to fix sign() discont */ \\\n                r = sign(q.x)*q - vec3(3,0,-3),                                           \\\n                t = min(t, max( 1.-r.z, length(r.xy) - .4 )),  /* arm */                  \\\n                t = min(t, length( vec2(length(r.yz) - 1., abs(abs(r.x)-.4)-.2)) - .2 ) // 4 rings \"fingers\" \n  \nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=10., d;\n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -10.*R.y ) - R ),  // ray direction\n          p = 50./R, q,r;                             // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p, \n        q.yz *= rot(.6),                              // rotations\n        q.xz *= rot(-.3*iTime),\n        \n        P( q ),                 // P(-q ),            // shape with 4 rotations \n        P(vec3(-q.z,q.y, q.x)), // P(vec3( q.z,q.y,-q.x)), \n        \n        p += t*D;                                     // step forward = dist to obj\n\n    O *= vec4(1,.8,.8,1);                             // coloring\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSfRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[454, 454, 490, 490, 1180]], "test": "untested"}
{"id": "ttSfzR", "name": "pixel-sorty uv-based render", "author": "thefox231", "description": "it looks really funny, i love it\nuncomment `// #define yaxis` only if you have a really beefy gpu, else itll lag the heck outta ur pc", "tags": ["uv", "weird", "pixelsorting"], "likes": 7, "viewed": 546, "published": 3, "date": "1598193713", "time_retrieved": "2024-07-30T20:49:31.956895", "image_code": "// #define yaxis\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float mDist = 9999.9;\n    vec2 mUv = fragCoord.xy / iResolution.xy;\n    \n    for (int x = 0; x < int(fragCoord.x); x++) {\n        #ifdef yaxis\n        for (int y = 0; y < int(fragCoord.y); y++) {\n        #else\n        int y = int(fragCoord.y);\n        #endif\n            vec2 uv = vec2(x, y) / iResolution.xy;\n\t\t\tvec2 trueUv = fragCoord.xy / iResolution.xy;\n            \n            vec3 colTex = texture(iChannel0, uv).rgb;\n            vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n            vec3 distVec = abs(colTex - col);\n            float dist = (distVec.r + distVec.g + distVec.b) / 3.0;\n\n            if (dist < mDist) {\n                mUv = uv;\n                mDist = dist;\n            }\n\t\t#ifdef yaxis\n        }\n        #endif\n    }\n    \n    vec3 col = texture(iChannel0, mUv).rgb;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3lBfzz", "name": "Blunderbuss", "author": "z0rg", "description": "a simple 2d animation", "tags": ["2d", "blunderbuss"], "likes": 16, "viewed": 470, "published": 3, "date": "1598180979", "time_retrieved": "2024-07-30T20:49:32.819589", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n\nfloat sat(float a)\n{\n    return clamp(a, 0.,1.);\n}\n\nfloat lenny(vec2 v)\n{\n    vec2 a = abs(v);\n    return a.x+a.y;\n}\n\n\n// Thanks iq :) Box - exact   (https://www.youtube.com/watch?v=62-pRVZuS5c)\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat cir(vec2 p, float r)\n{\n    float an = atan(p.y, p.x);\n    float rad = \n        \n        sin(an*5.)*.5;\n    return length(p)-r;\n}\nfloat loz(vec2 p, float r)\n{\n    return lenny(p)-r;\n}\n\nfloat add(float a, float b)\n{\n    return min(a, b);\n}\nfloat sub(float a, float b)\n{\n    return max(a, -b);\n}\nconst float PI = 3.141592653;\nfloat spd = 12.;\nfloat chara(vec2 uv)\n{\n    //float spd = 15.;\n    uv -= vec2(0.,.1715);\n    vec2 uvB = (uv)*r2d(sin(iTime*spd*2.)*.02);\n    float body = sdBox(uvB, vec2(.008,.01));\n    vec2 lLeg = vec2(0.002+0.002*sin(-iTime*spd),-.01-((cos(-iTime*spd)))*0.001);\n    float leftLeg = sdBox(uv-lLeg, vec2(.001,.01));\n    leftLeg = add(leftLeg, sdBox(uv- lLeg-vec2(0.001,-.01), vec2(.002, 0.001)));\n    \n    vec2 rLeg = vec2(0.002+0.002*sin(-iTime*spd+PI),-.01-((cos(-iTime*spd+PI)))*0.001)-vec2(0.003,0.);\n    float rightLeg = sdBox(uv-rLeg, vec2(.001,.01));\n    rightLeg = add(rightLeg, sdBox(uv- rLeg-vec2(0.001,-.01), vec2(.002, 0.001)));\n    uvB -= vec2(0.,.01);\n    float ears = loz(vec2(abs(uvB.x)*3.-.0145, uvB.y), 0.01);\n    \n    return add(add(body, ears), add(leftLeg, rightLeg));\n}\n\nfloat tree(vec2 uv, float n)\n{\n    uv -= vec2(0.,.27);\n    float t = sub(loz(uv,.03), uv.y);\n    uv += vec2(0.,.03+0.005*sin(n));\n    t = add(t, sub(loz(uv, .04), uv.y));\n    uv += vec2(0.,.035+0.005*sin(n*2.+1.2));\n    t = add(t, sub(loz(uv, .05), uv.y));\n    uv += vec2(0.,.03);\n    t = add(t, sub(loz(uv, .06+0.005*sin(n+.3)), uv.y));\n    t = add(t, sdBox(uv, vec2(0.01, 0.05)));\n    return t;\n}\n\n\nvec3 lerp4(vec3 grad[4], float i)\n{\n    float idx = sat(i)*3.0;\n    int prevIdx = int(idx);\n    int nextIdx = min(prevIdx+1, 3);\n    vec3 prev = grad[prevIdx];\n    vec3 next = grad[nextIdx];\n    float lrp = idx - float(prevIdx);\n    return mix(prev, next, smoothstep(0.,1.,lrp));\n}\n\n\n\nvec3 rdrWind(vec2 uv)\n{\n    float halo = abs(uv.y-.2-sin(uv.x*4.)*.02);\n\treturn .3*(sin(uv.x*2.-iTime)*.5+.5)*texture(iChannel1, vec2(-iTime*.01, 0.)+uv*vec2(.05,20.)).xxx*(1.-sat(halo*25.));\n}\n\n\nvec3 rdr(vec2 uv)\n{\n    vec2 uvSky = uv*r2d(iTime*.1);\n    float sharp = iResolution.x*2.;\n    vec3 gradient[4];\n    gradient[0] = vec3(9,5,75)/255.;\n    gradient[1] = vec3(182,97,17)/255.;\n    gradient[2] = vec3(91,217,222)/255.;\n    gradient[3] = vec3(0,164,255)/255.;\n    \n    float an = abs(atan(uvSky.y, uvSky.x))-.2;\n    vec3 col = pow(lerp4(gradient, an*.4+.1*distance(vec2(0.,1.), uv)), vec3(1./1.))*smoothstep(0.,1.,1.-sat(cir(uv, .2)*5.));\n\n    float stars = (texture(iChannel1, uvSky*8.).x+texture(iChannel1, uvSky*8.*r2d(.1)).x)/2.;\n    float rate = .80;\n\tcol += vec3(texture(iChannel1, uv*5.).x*.5+.5,.8,.9)*sat(sat(stars - rate)/(1.-rate)-.1);\n    \n    col = mix(col, vec3(0.), 1.-sat(cir(uv, .15)*sharp));\n\n    col = mix(col, vec3(0.), 1.-sat(chara(uv)*sharp));\n    vec2 eyeP = uv-vec2(0.002,.175);\n    mat2 rot = r2d(sin(iTime*spd*2.)*.05);\n    float eyes = add(cir((eyeP*rot-vec2(0.005,0.)), 0.001), cir((eyeP*rot)-vec2(0.0025,0.), 0.001));\n    col = mix(col, vec3(255,188,0)/255., 1.-sat(eyes*sharp));\n    \n    float tre = tree((uvSky-vec2(0.,.08))*2., 5.);\n    col = mix(col, col*.2, 1.-sat(tre*sharp));  \n    float tree2 = tree((uvSky*r2d(1.)-vec2(0.,.08))*2., 1.);\n    col = mix(col, col*.2, 1.-sat(tree2*sharp));  \n        float tree3 = tree((uvSky*r2d(5.)-vec2(0.,.1))*3., 5.);\n    col = mix(col, col*.2, 1.-sat(tree3*sharp));     \n    \n    \n    float fog = sin(10.*an+iTime+length(uv))*.2+(sin(iTime-length(uv)*25.)*.2+.1)+.3;\n    col = mix(col, col*.2, fog); \n    col += (vec3(255,245,130)/255.)*smoothstep(0.,1.,1.-sat(cir(uvSky-vec2(-.5,0.), .1)*2.));\n    \n    float snd = texelFetch(iChannel0, ivec2(int(an*5.), 0), 0).x;\n    col += rdrWind(vec2(an, length(uv)));\n    col += mix(vec3(1.),.5+0.5*cos(iTime+uv.xyx+vec3(0,2,4)), snd)*.5*sat(abs(uv.x)*5.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\tuv *= .3;\n    uv -= vec2(0.,-.2);\n    \n    vec3 col = rdr(uv);\n    \n    if (iFrame > 5)\n    \tcol *= sat(iTime/2.);\n    //col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23770, "src": "https://soundcloud.com/henrikjose/henrik-jose-blunderbuss", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfzz.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 415, 415, 490], [492, 492, 512, 512, 542], [544, 544, 565, 565, 608], [611, 687, 724, 724, 804], [806, 806, 834, 834, 940], [941, 941, 969, 969, 994], [996, 996, 1025, 1025, 1049], [1050, 1050, 1079, 1079, 1104], [1152, 1152, 1174, 1197, 1926], [1928, 1928, 1958, 1958, 2326], [2329, 2329, 2364, 2364, 2610], [2614, 2614, 2637, 2637, 2807], [2810, 2810, 2829, 2829, 4608], [4610, 4610, 4667, 4667, 4918]], "test": "untested"}
{"id": "WtBfzR", "name": "Generative tiles z", "author": "illus0r", "description": "Generative tiles z", "tags": ["raymarchingfractalarchitecture"], "likes": 6, "viewed": 374, "published": 3, "date": "1598146337", "time_retrieved": "2024-07-30T20:49:33.864794", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float radius) { return length(p) - radius; }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\n\n\nfloat sdTorus(vec3 p, float smallRadius, float largeRadius) {\n    return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    p.y -= 0.5;\n    vec2 plane = vec2(p.y+0.5, IVORY);\n    float step = 1.5;\n    p.x += iTime;\n    p.z -= iTime;\n    \n    vec3 pFrame = p;\n    pFrame.xz -= step / 2.;\n    pFrame.xz = mod(pFrame.xz, step) - step / 2.;\n    pFrame.xz *= Rot(PI / 4.);\n    pFrame.xz = abs(pFrame.xz);\n    pFrame.xz *= Rot(PI / 4.);\n    pFrame.xy *= Rot(PI / 4.);\n    float frame = sdBox(pFrame, vec2(0.074, step / 2.).xxy);\n    \n    vec2 id = floor(p.xz / step);\n    p.xz = mod(p.xz, step) - step / 2.;\n    //p.xz *= Rot(iTime / 4.);\n    vec3 pBox = p;\n    // pBox.xz /= 100.;// * (.5 + .5 * sin(iTime));\n    //vec3 pTiles = p;\n    float t = iTime;\n    t = floor(t) + smoothstep(0.4, 0.6, fract(t));\n\tp.y += sin(id.x + id.y * 2. + t / 10.);\n    float box = sdBox(pBox, vec2(0.05, step / 2.).yxy);\n    //p.yz *= Rot(PI / 2.);\n    float scale = 0.7;\n    vec2 torus = vec2(sdTorus(p, .4, 1.5), BLUE);\n    for (int i = 0; i < 7; i++) {\n\t\tp.xz = abs(p.xz);\n        p.xz -= 1.;\n        p /= scale;\n        p.yz *= Rot(PI / 2.);\n\t    p.xy *= Rot(PI / 4.);\n        vec2 newTorus = vec2(sdTorus(p, .4, 1.5) * pow(scale, float(i+1)), BLUE);\n        torus = torus.x < newTorus.x? torus : newTorus;\n    }\n    torus = box < torus.x ? torus : vec2(box, 0);\n    vec2 fractalAndPlane = torus.x < plane.x? torus : plane;\n    //torus.x -=  - 0.03;\n    return fractalAndPlane.x < frame ? fractalAndPlane : vec2(frame, BLACK);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float minAngleToObstacle = 1e10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        d += distToClosest.x;\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, minAngleToObstacle);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\n\n\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // ray origin\n    vec3 ro = vec3(-3, 5, 3);\n    float zoom = 1.100;\n    \n    // ray direction\n    vec3 rd = getRayDir(uv, ro, vec3(0), 0.75);\n    \n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n    \n    float color_bw = 0.;\n    vec3 colorBg = vec3(0.233,0.715,0.920);\n    vec3 color = vec3(0);\n    vec3 light = vec3(50);\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \t//color = vec3( n + 1.0 );\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        color_bw = 0.5 + .5 * dot(n, normalize(light - p));\n        // drop shadeos\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .5, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color_bw =  0.;\n        // }\n\n        // smooth shadows\n        float shadow = smoothstep(0.0, .1, rayMarchLight.z / PI);\n        color_bw *= .7 + .3 * shadow;\n        \n\n        // tex *= color_bw;\n        // color = tex;\n    }\n    color += 0.6 + vec3( color_bw );\n    // coloring\n    if (info == IVORY) {\n        color *= vec3(0.433,0.457,0.545);\n    }\n    else if (info == BLUE) {\n        color *= vec3(0.655,0.129,0.054);\n    }\n    else if (info == BLACK) {\n        color *= vec3(0.130,0.130,0.130);\n    }\n    color = mix(color, colorBg, smoothstep(20., 28., d));\n    \n    \n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 160, 160, 223], [225, 225, 263, 263, 292], [293, 293, 324, 324, 407], [410, 410, 471, 471, 545], [549, 628, 650, 650, 2038], [2123, 2123, 2156, 2156, 2625], [2627, 2627, 2651, 2651, 2869], [2874, 2874, 2928, 2928, 3155], [3157, 3157, 3207, 3207, 3398], [3401, 3401, 3457, 3457, 5250]], "test": "untested"}
{"id": "WlSBzR", "name": "大龙猫 - Quicky#043", "author": "totetmatt", "description": "-T'a du jungle la? \n  - Ouai ya tarzan et jane qui viennent d'atterrir par la 1er liane du matin", "tags": ["quicky"], "likes": 3, "viewed": 598, "published": 3, "date": "1598134287", "time_retrieved": "2024-07-30T20:49:34.746437", "image_code": "/*\nFunction from IQ website and http://mercury.sexy/\nBased on Flopine last stream\n*/\n#define ITER 64.\n#define PI 3.141592\n#define beat iTime\n#define acc 2.\n#define ttime (floor(beat)+pow(fract(beat),.5))\n#define pal(x) palette( x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) )\nstruct obj{\n    float d;\n    int mat;\n    vec3 col;\n};\nvec3 palette(float t,vec3 a,vec3 b,vec3 c,vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 iri(vec3 c, vec3 n, vec3 rd, vec3 col){\n    float fresnel = max(1.-dot(n,rd),0.);\n    c += pal(fresnel+length(col));\n     \n    return c;\n}\nvoid mo(inout vec2 p,vec2 d){\n  p = abs(p)-d;\n  if(p.y>p.x) p = p.yx;\n}\nfloat box(vec3 p, vec3 c,float sm){\n    return length(max(abs(p)-c, 0.))-(sm);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\nobj liane(vec3 p){\n\n  p.yz*=r(PI/2.+sin(iTime+(p.z*.3)*.5)*.1);\n\n     p.xz *=r(+p.y*.1+cos(p.y*.1+iTime*.15));\npModPolar(p.xz,10.);\n  p.x-=sin(ttime+p.y*.4+atan(p.x,p.y)*2.)*.5+.5;\n  p-=vec3(1.51,.0,.0);\n   p.xz *=r(sin(p.y*2.+iTime));\n   \n   pModPolar(p.xz,3.);\n\n    float cd = box(p,vec3(.2,20.2,.2),.0);\n    if(sin(p.z*10.+p.y*.9+iTime*3.)>=.9){\n     return obj(cd,1,vec3(.5,0.5,-0.0));\n    }else\n    return obj(cd,2,vec3(0.1,0.9,0.3));\n}\nobj fig(vec3 p){\n     p.z-=7.;\n     p.xy *=r(iTime);\n     pModPolar(p.xy,3.);\n     p.yz *=r(-iTime);\n     mo(p.xy,vec2(4.9));\n     mo(p.yz,vec2(0.5));\n    float cd = box(p,vec3(.5,.7,.1),.1);\n    cd = abs(cd)-.1;\n    return obj(cd,1,vec3(-0.50,.9,-.1)*.2);\n}\nobj mino(obj a, obj b){\n    if(a.d < b.d) return a;\n    return b;\n}\n\nobj SDF(vec3 p) {return mino(liane(p),fig(p));}\n\n\nvec3 norm(vec3 p){\n    vec2 eps = vec2(.0001,0.);\n    return normalize(SDF(p).d - vec3(   SDF(p-eps.xyy).d,\n                                        SDF(p-eps.yxy).d,\n                                        SDF(p-eps.yyx).d) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n     \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n     \n    vec3 ro =vec3(0.,0.,-7.),\n    p = ro,\n    rd = normalize(vec3(uv,1.)),\n    col = vec3(0);\n   \n     \n    obj O ;\n    bool hit = false;\n    float shad;\n    float t=0.;\n    for(float i=0.;i < ITER; i++) {\n        p = ro + t*rd;\n        O = SDF(p);\n        if(O.d< 0.01) {\n            hit = true;\n            shad = i / ITER;\n            break;\n        }\n        t+=O.d;\n    }\n    \n    if(hit) {\n        vec3 n = norm(p);\n        if(O.mat == 1) col = iri(O.col,n, rd, vec3(.0,.34,.60)); \n   \n        if(O.mat == 2) col =  O.col*(1.-shad);\n    \n    }\n\n    fragColor = vec4(clamp((col),0.,1.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 414, 414, 457], [460, 460, 476, 476, 534], [536, 536, 580, 580, 679], [680, 680, 709, 709, 751], [752, 752, 787, 787, 832], [834, 834, 884, 884, 1146], [1148, 1148, 1166, 1166, 1589], [1590, 1590, 1606, 1606, 1848], [1849, 1849, 1872, 1872, 1916], [1918, 1918, 1935, 1935, 1965], [1968, 1968, 1986, 1986, 2196], [2198, 2198, 2253, 2253, 2923]], "test": "untested"}
{"id": "3tSfRR", "name": "Practice Positioning", "author": "t420babe", "description": "A shader to practice position and color", "tags": ["gradient", "green", "practice"], "likes": 0, "viewed": 270, "published": 3, "date": "1598129002", "time_retrieved": "2024-07-30T20:49:35.669967", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(1.0);\n  \tvec2 pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    pos.y -= 1.0;\n    float wrap_time = abs(sin(iTime)) * 2.0;\n    float f = pos.y + wrap_time;\n  \tcolor *= f * color - f * vec3(0.5235, 0.23451, 0.4348);\n    \n \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 375]], "test": "untested"}
{"id": "wllBWs", "name": "My First Clouds", "author": "MilkyDeveloper", "description": "😅 A very simple implementation of clouds without volumetrics or raymarching or any of that because this is meant to be used for a Minecraft Bedrock Shader. Noise based on https://www.shadertoy.com/view/tlB3zK.", "tags": ["simple", "clouds", "fbm", "sky", "worley"], "likes": 1, "viewed": 896, "published": 3, "date": "1598113886", "time_retrieved": "2024-07-30T20:49:36.468831", "image_code": "// MIT License :D\n\n\n//noise function from iq: https://www.shadertoy.com/view/Msf3WH\n\nvec2 hash( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nconst mat2 m2 = mat2(1.6,  1.2, -1.2,  1.6);\n\nfloat fbm4(vec2 p) {\n    float amp = 0.5;\n    float h = 0.0;\n    for (int i = 0; i < 4; i++) {\n        float n = noise(p);\n        h += amp * n;\n        amp *= 0.5;\n        p = m2 * p ;\n    }\n    \n\treturn  0.5 + 0.5*h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 sky = vec3(135./255., 206./255., 235./255.); // Just googled this lmao\n    vec3 col = vec3(0.0);\n\n    // layer1\n    vec3 cloudCol = vec3(1.);\n    uv += 10.0;\n    \n    float speed      = 1.0;\n    float brightness = 0.75;\n    float cover      = 0.3;\n    \n    float zoom = 1.25; // Multiplier of UV, a higher number is for \"zooming out\"\n    \n\tfloat n1 = fbm4(uv*zoom+(iTime*(speed/30.))); // +iTime is for moving left, -iTime is for moving right\n    col = mix( sky, cloudCol, smoothstep(cover, brightness, n1));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBWs.jpg", "access": "api", "license": "mit", "functions": [[85, 85, 107, 107, 222], [224, 224, 250, 250, 729], [777, 777, 797, 797, 997], [999, 999, 1056, 1106, 1780]], "test": "untested"}
{"id": "tllBWs", "name": "Planes in Space (extra dreamy)", "author": "fforw", "description": "Variant of https://www.shadertoy.com/view/wtlBWl", "tags": ["noise", "colors", "space"], "likes": 1, "viewed": 276, "published": 3, "date": "1598113874", "time_retrieved": "2024-07-30T20:49:37.324543", "image_code": "const float minBlur = 0.0003;\nconst float maxBlur = 40.0;\nconst float planeDistance = 1.0;\nconst vec2 off = vec2(-0.5,-0.5);\n\n////////////////////////////////////////////////////// NOISE CODE //////////////////////////////////////////////////////\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n//////////////////////////////////////////////////// NOISE CODE END ////////////////////////////////////////////////////\n\nvec4 plane(float currHeight, float height, vec3 color, vec2 uv, float time , float planeScale, vec2 off)\n{\n    float screenRatio = iResolution.x/iResolution.y;\n\n    float blur = maxBlur - minBlur;\n\n    float deltaZ = (currHeight - height);\n\n    float edge = abs(deltaZ) * blur / planeDistance;\n\n    float scale = (0.006 * planeScale/deltaZ);\n\n    float n1 = 0.2 + 0.8 * smoothstep(0.5-edge,.5+edge,noise(vec3(((uv.x - 0.5) * screenRatio) * scale + off.x, (uv.y - 0.5) * scale + off.y, time)));\n\n    return vec4(color, n1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float screenRatio = iResolution.x/iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float height = planeDistance + 0.002 + sin(iTime) * 0.001;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 planeColor = plane(height, planeDistance, col, uv, iTime * 0.4, 1.0, vec2(iTime * 2.0,0));\n\n    // Time varying pixel color\n    vec3 col2 = 0.2 + 0.5*sin(iTime+uv.xyx+vec3(1,0,4));\n    vec4 plane2Color = plane(height, planeDistance * 0.998, col2, uv, iTime * 0.35, 2.0, vec2(iTime,0));\n\n    fragColor = vec4(planeColor.xyz,1.0) * planeColor.w + (1.0 - planeColor.w) * (\n    vec4(plane2Color.xyz,1.0) * plane2Color.w + (1.0 - plane2Color.w) * texture(iChannel0, uv)\n    );\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "////////////////////////////////////////////////////// NOISE CODE //////////////////////////////////////////////////////\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n//////////////////////////////////////////////////// NOISE CODE END ////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float screenRatio = iResolution.x/iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n\n    float starNoise = smoothstep(0.97,1.0,noise(vec3(uv.x * screenRatio * 100.0, uv.y * 100.0, 0.0)));\n    fragColor = vec4(starNoise,starNoise,starNoise,1.0);;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 270, 270, 315], [316, 316, 336, 336, 381], [382, 382, 400, 400, 439], [441, 441, 461, 461, 952], [1075, 1075, 1181, 1181, 1599], [1601, 1601, 1658, 1658, 2439]], "test": "untested"}
{"id": "ttsBWl", "name": " Procgen Planet mod", "author": "evgenys", "description": "\"Procgen Planet\" shader mod with the reference 3D Perlin noise function to avoid noise artifacts.", "tags": ["procedural", "noise", "fbm", "planet", "domainwarping", "procgen"], "likes": 13, "viewed": 949, "published": 3, "date": "1598100358", "time_retrieved": "2024-07-30T20:49:38.187237", "image_code": "// This is a fork of Procgen Planet from https://www.shadertoy.com/view/tltXWM .\n// The problem of Procgen Planet is that there are visible noise artifacts\n// (white dots randomly appearing).\n//\n// This fork uses the reference Perlin 3D function from https://mrl.nyu.edu/~perlin/noise/\n// which fixes the white flashes.\n//\n\nint[] perm = int[](\n    151,160,137,91,90,15,\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n    151\n);\nint perm1plus(int i, int k) { return int(mod(float(perm[i]) + float(k), 256.)); }\n\nfloat Fade(float t) { return t * t * t * (t * (t * 6. - 15.) + 10.); }\n\nfloat Grad(int hash, float x, float y, float z) {\n    int h = hash & 15;\n    float u = h < 8 ? x : y;\n    float v = h < 4 ? y : (h == 12 || h == 14 ? x : z);\n    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n}\n\nfloat Noise3D(vec3 val) {\n    vec3 v1 = floor(val);\n    vec3 v2 = fract(val);\n    int X = int(mod(v1.x, 256.));\n    int Y = int(mod(v1.y, 256.));\n    int Z = int(mod(v1.z, 256.));\n    float x = v2.x;\n    float y = v2.y;\n    float z = v2.z;\n    float u = Fade(x);\n    float v = Fade(y);\n    float w = Fade(z);\n    int A  = perm1plus(X, Y);\n    int B  = perm1plus(X+1, Y);\n    int AA = perm1plus(A, Z);\n    int BA = perm1plus(B, Z);\n    int AB = perm1plus(A+1, Z);\n    int BB = perm1plus(B+1, Z);\n\n    return mix(mix(mix(Grad(perm[AA  ], x, y   , z  ),  Grad(perm[BA  ], x-1., y   , z  ), u),\n                   mix(Grad(perm[AB  ], x, y-1., z  ),  Grad(perm[BB  ], x-1., y-1., z  ), u),\n                   v),\n               mix(mix(Grad(perm[AA+1], x, y   , z-1.), Grad(perm[BA+1], x-1., y   , z-1.), u),\n                   mix(Grad(perm[AB+1], x, y-1., z-1.), Grad(perm[BB+1], x-1., y-1., z-1.), u),\n                   v),\n               w);\n}\n\n// Noise functions and most of the implementation based on\n// https://www.shadertoy.com/view/4dS3Wd by Morgan McGuire @morgan3d!\n\n// see also\n// https://iquilezles.org/articles/warp\n// https://thebookofshaders.com/13/\n// for informations on fbm, noise, ...\n\n// please check out stuff like: https://www.shadertoy.com/view/lsGGDd\n// for more advanced planet lighting/clouds/...\n\n// Looking for a blue planet? Colors:\n// vec3 col_top = vec3(0.0, 0.5, 0.0);\n// vec3 col_bot = vec3(0.0, 1.0, 1.0);\n// vec3 col_mid1 = vec3(0.0, 1.0, 0.0);\n// vec3 col_mid2 = vec3(0.0, 0.0, 1.0);\n// vec3 col_mid3 = vec3(0.0, 0.0, 1.0);\n\n\n// number of octaves of fbm\n#define NUM_NOISE_OCTAVES 10\n// size of the planet\n#define PLANET_SIZE\t\t0.75\n// uncomment to use a simple sharpen filter\n// #define SHARPEN\n// simple and fast smoothing of outside border\n#define SMOOTH\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Noise functions:\n//////////////////////////////////////////////////////////////////////////////////////\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\t//v += a * noise(x);\n        v += a * (Noise3D(x) * .5 + .5);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\n//////////////////////////////////////////////////////////////////////////////////////\n\nconst float pi          = 3.1415926535;\nconst float inf         = 9999999.9;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) { return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\n// returns max of a single vec3\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nvec3 getColorForCoord(vec2 fragCoord) {\n    // (intermediate) results of fbm\n    vec3 q = vec3(0.0);\n    vec3 r = vec3(0.0);\n\tfloat v = 0.0;\n    vec3 color = vec3(0.0);\n\n    // planet rotation\n    float theta = iTime * 0.15;  \n    mat3 rot = mat3(\n        cos(theta), 0, sin(theta),\t// column 1\n        0, 1, 0,\t                // column 2\n        -sin(theta), 0, cos(theta)\t// column 3\n    );\n\n    // Ray-sphere\n    const float verticalFieldOfView = 25.0 * pi / 180.0;\n\n    // position of viewpoint (P) and ray of vision (w)\n    vec3 P = vec3(0.0, 0.0, 5.0);\n    vec3 w = normalize(vec3(fragCoord.xy - iResolution.xy * 0.5, (iResolution.y) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n    // calculate intersect with sphere (along the \"line\" of w from P)\n    float t = intersectSphere(vec3(0, 0, 0), PLANET_SIZE, P, w);\n    \n    // calculate color for sphere/background\n    if (t < inf) {\n        // calculate point of intersection on the sphere\n        vec3 X = P + w*t;\n\n        // apply rotation matrix\n        X = rot*X;\n\n        // calculate fbm noise (3 steps)\n        q = vec3(fbm(X + 0.025*iTime), fbm(X), fbm(X));\n        r = vec3(fbm(X + 1.0*q + 0.01*iTime), fbm(X + q), fbm(X + q));\n        v = fbm(X + 5.0*r + iTime*0.005);\n    } else {\n        // ray missed the sphere\n\t\treturn vec3(0.0);\n    }\n    \n    // convert noise value into color\n    // three colors: top - mid - bottom (mid being constructed by three colors)\n    vec3 col_top = vec3(1.0, 1.0, 1.0);\n    vec3 col_bot = vec3(0.0, 0.0, 0.0);\n    vec3 col_mid1 = vec3(0.1, 0.2, 0.0);\n    vec3 col_mid2 = vec3(0.7, 0.4, 0.3);\n    vec3 col_mid3 = vec3(1.0, 0.4, 0.2);\n\n    // mix mid color based on intermediate results\n    vec3 col_mid = mix(col_mid1, col_mid2, clamp(r, 0.0, 1.0));\n    col_mid = mix(col_mid, col_mid3, clamp(q, 0.0, 1.0));\n    col_mid = col_mid;\n\n    // calculate pos (scaling betwen top and bot color) from v\n    float pos = v * 2.0 - 1.0;\n    color = mix(col_mid, col_top, clamp(pos, 0.0, 1.0));\n    color = mix(color, col_bot, clamp(-pos, 0.0, 1.0));\n\n    // clamp color to scale the highest r/g/b to 1.0\n    color = color / max3(color);\n      \n    // create output color, increase light > 0.5 (and add a bit to dark areas)\n    color = (clamp((0.4 * pow(v,3.) + pow(v,2.) + 0.5*v), 0.0, 1.0) * 0.9 + 0.1) * color;\n    \n    // apply diffuse lighting  \n    float diffuse = max(0.0, dot(P + w*t, vec3(1.0, sqrt(0.5), 1.0)));\n    float ambient = 0.1;\n    color *= clamp((diffuse + ambient), 0.0, 1.0);\n    \n#ifdef SMOOTH\n    // apply a smoothing to the outside\n    //color *= (P + w*t).z * 2.0;\n    color *= (P + w*t).z * 1.0;\n#endif    \n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n#ifdef SHARPEN \n    // use a simple sharpen filter (you could improve that immensely!\n    fragColor.rgb =\n        getColorForCoord(fragCoord) * 3. -\n        getColorForCoord(fragCoord + vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord + vec2(0.0, 1.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(0.0, 1.0)) * 0.5;\n#else\n    // just use a single pass\n    fragColor.rgb = getColorForCoord(fragCoord);\n#endif\n    // gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsBWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1349, 1349, 1378, 1378, 1430], [1432, 1432, 1453, 1453, 1502], [1504, 1504, 1553, 1553, 1725], [1727, 1727, 1752, 1752, 2671], [3715, 3789, 3810, 3810, 3877], [3879, 3879, 3900, 3900, 4483], [4485, 4485, 4504, 4504, 4723], [4995, 4995, 5018, 5018, 5034], [5035, 5035, 5065, 5065, 5096], [5098, 5173, 5229, 5229, 5503], [5505, 5537, 5558, 5558, 5596], [5598, 5598, 5637, 5674, 8246], [8248, 8248, 8304, 8304, 8868]], "test": "untested"}
{"id": "wtlBWl", "name": "Planar Shapes", "author": "fforw", "description": "Colorful planes with holes WIP", "tags": ["noise", "blur", "colors"], "likes": 0, "viewed": 275, "published": 3, "date": "1598095511", "time_retrieved": "2024-07-30T20:49:39.026992", "image_code": "const float minBlur = 0.0003;\nconst float maxBlur = 40.0;\nconst float planeDistance = 1.0;\nconst vec2 off = vec2(-0.5,-0.5);\n\n////////////////////////////////////////////////////// NOISE CODE //////////////////////////////////////////////////////\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n//////////////////////////////////////////////////// NOISE CODE END ////////////////////////////////////////////////////\n\nvec4 plane(float currHeight, float height, vec3 color, vec2 uv, float time , float planeScale, vec2 off)\n{\n    float screenRatio = iResolution.x/iResolution.y;\n\n    float blur = maxBlur - minBlur;\n\n    float deltaZ = (currHeight - height);\n\n    float edge = abs(deltaZ) * blur / planeDistance;\n\n    float scale = (0.006 * planeScale/deltaZ);\n\n    float n1 = smoothstep(0.5-edge,.5+edge,noise(vec3(((uv.x - 0.5) * screenRatio) * scale + off.x, (uv.y - 0.5) * scale + off.y, time)));\n\n    return vec4(color, n1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float screenRatio = iResolution.x/iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float height = planeDistance + 0.002 + sin(iTime) * 0.001;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 planeColor = plane(height, planeDistance, col, uv, iTime * 0.4, 1.0, vec2(iTime * 2.0,0));\n\n    // Time varying pixel color\n    vec3 col2 = 0.2 + 0.5*sin(iTime+uv.xyx+vec3(1,0,4));\n    vec4 plane2Color = plane(height, planeDistance * 0.998, col2, uv, iTime * 0.35, 2.0, vec2(iTime,0));\n\n    fragColor = vec4(planeColor.xyz,1.0) * planeColor.w + (1.0 - planeColor.w) * (\n    vec4(plane2Color.xyz,1.0) * plane2Color.w + (1.0 - plane2Color.w) * texture(iChannel0, uv)\n    );\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 270, 270, 315], [316, 316, 336, 336, 381], [382, 382, 400, 400, 439], [441, 441, 461, 461, 952], [1075, 1075, 1181, 1181, 1587], [1589, 1589, 1646, 1646, 2427]], "test": "untested"}
{"id": "3lsBzr", "name": "Waves v.7", "author": "pli", "description": "More random boat moves.", "tags": ["learning"], "likes": 5, "viewed": 365, "published": 3, "date": "1598087005", "time_retrieved": "2024-07-30T20:49:39.945536", "image_code": "// raymarching and lighting from https://www.shadertoy.com/view/MltcDB\n\n#define SKY_COLOR vec3(0.0, 0.18, 0.2)\n\n#define BASE_COLOR vec3(0.4, 0.6, 0.6)\n#define BOAT_COLOR vec3(1., 0.57, 0.0)\n#define HEAD_COLOR vec3(.7, .6, .4)\n\n#define SHARK_COLOR vec3(.5, .5, .5)\n\n#define SHADOW_COLOR vec3(1.0)\n\n\n#define BOAT_INITIAL_X -0.25\n#define BOAT_INITIAL_Z -0.3\n\n\n#define X_WAVE_SPACE 0.05\n#define Z_WAVE_SPACE 0.05\n\n#define WAVE_SMOOTH 0.01\n#define BOAT_SMOOTH 0.03\n\n\n\n#define STEPS 64.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\n\nfloat distSphere(vec3 p, vec3 center, float radius) {\n\treturn length(p-center) - radius;   \n}\n\n\nvec3 coordsFromGrid(vec3 grid) {\n    return grid / 10.;\n}\n\nvec3 gridFromCoords(vec3 coords) {\n    return coords * 10.;\n}\n\nfloat waveDephthAt(vec3 coords) {\n    return 0.10 \n        + 0.03 * cos(0.5 * coords.x + 1.2 * sin(0.5*coords.z + iTime) + 5.*iTime) \n        + 0.002 * cos(cos(2.*coords.x) + sin(2.*coords.z) + 4. * iTime)\n        ;   \n}\n\n\nfloat boatYAt(vec3 coords) {\n    return 0.01 + waveDephthAt(coords);   \n}\n\n\nfloat distWaves(vec3 pos) {\n     vec3 grid = gridFromCoords(pos);\n    vec3 nGrid = vec3(grid.x, 0., grid.z);\n    vec3 coords = coordsFromGrid(vec3(nGrid.x, 0., nGrid.z));            \n\n    float seaHeight = waveDephthAt(vec3(nGrid.x, 0., nGrid.z));\n    float dist = distSphere(pos, coords, seaHeight);\n\n\treturn dist;\n}\n\nvec3 transformedFlotterPosition(vec3 position) {\n    position.xz = rot(0.35 * cos(iTime)) * position.xz;\n    vec3 translation = vec3(BOAT_INITIAL_X + 0.1 * cos(0.5*iTime) + 0.05 * cos(0.95*iTime), 0., BOAT_INITIAL_Z + 0.1 * cos(0.8*iTime)); \n    vec3 transformedFlotterPosition = position + translation;\n\treturn transformedFlotterPosition;\n}\n\nfloat distBoat(vec3 pos, out vec3 headPosition) {\n\n    vec3 position = transformedFlotterPosition(vec3(0., 0., 0.));\n    vec3 p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    float distBoat = distSphere(pos, p, 0.05);\n\n    position = transformedFlotterPosition(vec3(0.05, 0., 0.));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.1, 0., 0.));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.15, 0., 0.));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    \n    position = transformedFlotterPosition(vec3(0.0, 0., 0.05));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.15, 0., 0.05));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n\n\n    position = transformedFlotterPosition(vec3(0.0, 0., 0.1));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.05, 0., 0.1));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.1, 0., 0.1));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.15, 0., 0.1));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    headPosition = transformedFlotterPosition(vec3(0.05, 0., 0.05));\n\n    \n\treturn distBoat;\n}\n\nfloat distHead(vec3 pos, vec3 headPosition) {\n    vec3 p = vec3(headPosition.x, boatYAt(gridFromCoords(vec3(headPosition.x - 0.05, headPosition.y, headPosition.z))) + 0.05, headPosition.z);\n\n    float headDist = distSphere(pos, p, 0.02);\n\n    return headDist;\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  float d = sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n    \n\treturn d;\n}\n\n\nfloat distScene(vec3 pos, out vec3 colorVariation, out float shineVariation){\n    // pos.xz = rot(1.5 * sin(0.25 * iTime)) * pos.xz;\n    pos.y += 0.35;\n    \n    colorVariation = vec3(1.);\n\n    // waves\n\n    float dist = distWaves(pos);\n    colorVariation = BASE_COLOR;\n    shineVariation = 1.;\n    \n    \n\t// boat\n    vec3 headPosition;\n\tfloat boatDist = distBoat(pos, headPosition);\n    if (boatDist < dist) {\n        dist = boatDist;\n   \t \tcolorVariation = BOAT_COLOR;\n        shineVariation = .6;\n    }\n    \n    \n    // head \n    float headDist = distHead(pos, headPosition);\n    if (headDist < dist) {\n     \tdist = headDist;\n   \t \tcolorVariation = HEAD_COLOR;\n\t\tshineVariation = .0;\n    }\n\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    vec3 c;\n    float s;\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c, s) - distScene(p - vec3(EPSN, 0., 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., EPSN, 0.), c, s) - distScene(p - vec3(0., EPSN, 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., 0., EPSN), c, s) - distScene(p - vec3(0., 0., EPSN), c, s))));\n}\n\n\nvec3 render(vec2 uv){\n\tvec3 col = BASE_COLOR;\n    \n    //camera\n    vec3 eye = vec3(0., 1., 5.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n  \tray.yz = rot(0.08) * ray.yz;\n   \teye.yz = rot(0.12) * eye.yz;\n    \n    \n    // moon\n    vec2 moonPosition = vec2(0.19, 0.20);\n    if (length(moonPosition - uv) < 0.12) {\n   \t \treturn vec3(0.9);\n    }\n\n\n   \t//raymarch to the scene\n    vec3 pos = eye;\n    vec3 colorVariation;\n    float shineVariation;\n    float s, prevDist, totalDist = 0.;\n    float maxDist = 5.8;\n        \n    float dist = distScene(pos, colorVariation, shineVariation);\n    for(float s = 0.; s < STEPS; s++){\n        prevDist = dist;\n    \tdist = distScene(pos, colorVariation, shineVariation);\n        if(abs(dist) < EPS || totalDist > maxDist){\n            break;\n        }\n        pos += ray * dist;\n        totalDist += dist;\n    }\n    \n    if(totalDist > maxDist) {\n        return SKY_COLOR;\n    }\n\n    \n    vec3 normal = getNormal(pos);\n    vec3 light = normalize(vec3(1., 1., -3));\n    light.yz = rot(0.3) * light.yz;\n    col = colorVariation * (1. + dot(normal, light));\n    \n    \n    // raymarch back toward the light to compute the shadows\n    light = normalize(vec3(1., 1.3, -3)); // tweak light to avoid the waves casting shadows on themselves\n\n    float shadow = 1.;\n    totalDist = 0.01;\n    dist = 0.0;\n\tfloat sv;\n    vec3 cv;\n    for(float s = 0.; s < STEPS; s++){\n        dist = distScene(pos + light * totalDist, cv, sv);\n        totalDist += dist;\n        shadow = min( shadow, 10.0*dist/totalDist );\n        if(shadow < 0.001 || totalDist > maxDist){\n            break;\n        }\n    }\n    shadow = clamp(shadow, 0., 1.);\n    col = col * (0.5 + 0.5*shadow);\n    \n    \n    //white highlight\n    if (shadow > 0.9) { // we don't want highlights in the shade, notably from the boat\n\t\tlight = normalize(vec3(1., 0.5, -3)); // tweak light to get higher shine\n        float shine = 10.;\n        vec3 refl = reflect(normalize(pos - light), normal);\n        float spec = pow(clamp(dot(normalize(eye - pos), refl), 0., 1.), shine);\n        spec = smoothstep(0.25, 0.45, spec - 0.4);\n        col = mix(col, vec3(1.), (shineVariation -  0.8 * colorVariation) * spec);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[539, 539, 557, 557, 606], [608, 608, 651, 651, 759], [762, 762, 815, 815, 855], [858, 858, 890, 890, 915], [917, 917, 951, 951, 978], [980, 980, 1013, 1013, 1200], [1203, 1203, 1231, 1231, 1276], [1279, 1279, 1306, 1306, 1596], [1598, 1598, 1646, 1646, 1939], [1941, 1941, 1990, 1990, 4200], [4202, 4202, 4247, 4247, 4463], [4466, 4466, 4491, 4491, 4510], [4511, 4511, 4536, 4536, 4555], [4556, 4556, 4592, 4592, 4620], [4622, 4622, 4674, 4674, 5190], [5193, 5193, 5270, 5325, 5909], [5911, 5911, 5934, 5934, 6272], [6275, 6275, 6296, 6296, 8489], [8491, 8491, 8548, 8548, 8676]], "test": "untested"}
{"id": "3llBDs", "name": "PUMA auxetic pattern", "author": "yasuo", "description": "Nothing cool about this.\ndesign resource:\nhttps://design.mit.edu/projects/puma-auxetic-recurve-midsole", "tags": ["reproduction"], "likes": 9, "viewed": 368, "published": 3, "date": "1598084564", "time_retrieved": "2024-07-30T20:49:40.822192", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions2d\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) 1.0-smoothstep(b,antialiasing(1.0),d)\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat auxeticDistance(vec2 p) {\n\tfloat d = length(p+vec2(0.15,0.0))-0.1;\n    float d2 = length(p+vec2(-0.15,0.0))-0.1;\n    d = min(d,d2);\n    d2 = sdBox(p,vec2(0.1,0.05));\n    d = opSmoothUnion(d,d2,0.05);\n    return abs(d)-0.02;\n}\n\nvec3 auxeticPattern(vec2 p, vec3 col, vec3 rhcol){\n    p.y-=iTime*0.1;\n    float smoothval = -0.015;\n    vec2 pref = p;\n    float scale = 3.0;\n    p*=scale;\n    \n    p.x = mod(p.x,0.75)-0.375;\n    p.y = mod(p.y,0.7)-0.35;\n    \n    float d = auxeticDistance(p);\n    col = mix(col, rhcol,S(d,smoothval));\n    \n    p = pref;\n\tp*=scale;\n    \n    p.y += 0.35;\n    p.x = mod(p.x,0.75)-0.375;\n    p.y = mod(p.y,0.7)-0.35;\n    d = auxeticDistance(p*Rot(radians(90.0)));\n    col = mix(col, rhcol,S(d,smoothval));\n    \n\tp = pref;\n\tp*=scale;\n    \n    p.x += 0.37;\n    p.y += 0.35;\n    p.x = mod(p.x,0.75)-0.375;\n    p.y = mod(p.y,0.7)-0.35;\n\td = auxeticDistance(p);\n    col = mix(col, rhcol,S(d,smoothval));\n    \n\tp = pref;\n\tp*=scale;\n    \n\tp.x += 0.37;\n    p.y += 0.7;\n    p.x = mod(p.x,0.75)-0.375;\n    p.y = mod(p.y,0.7)-0.35;\n\td = auxeticDistance(p*Rot(radians(90.0)));\n    col = mix(col, rhcol,S(d,smoothval));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(126.0/255.0,0.0/255.0,67.0/255.0);\n\tvec3 baseCol = vec3(1.0);\n\n    col = auxeticPattern(uv,col,baseCol);\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 246, 283, 283, 367], [369, 369, 421, 421, 520], [523, 523, 554, 554, 754], [756, 756, 806, 806, 1683], [1685, 1685, 1742, 1742, 1968]], "test": "untested"}
{"id": "WtXfDs", "name": "Face Generator ", "author": "Pidhorskyi", "description": "GAN, trained on FFHQ dataset at resolution 32x32.\n\nStyleGAN inspired, but heavily tweaked to run in Shadertoy.\n\nThe first layer is dense, but the rest are convolutional. Low quality due to the low layer and channel number, and data size limitations.", "tags": ["neuralnetwork", "faces", "gan"], "likes": 146, "viewed": 4204, "published": 3, "date": "1598050531", "time_retrieved": "2024-07-30T20:49:42.060880", "image_code": "// The MIT License\n// Copyright © 2020 Stanislav Pidhorskyi\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// FFHQ generator. Trained on FFHQ downsampled to 32x32\n\n// Generator network:\n// input: z - sampled from normal distibution, 32\n// dense layer, in: 32, out: 64\n// reshape to 4, 4, 4\n// upscale 2x\n// conv2d, kernel 3x3, in channels 4, out channels 4\n// relu\n// upscale 2x\n// conv2d, kernel 3x3, in channels 4, out channels 4\n// relu\n// upscale 2x\n// conv2d, kernel 3x3, in channels 4, out channels 4\n// relu\n// conv2d, kernel 1x1, in channels 4, out channels 3\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragCoord.y = iResolution.y - fragCoord.y;\n\n    if (_skip(fragCoord, iResolution, 5))\n    {\n        fragColor = vec4(0.3);\n    \treturn;\n    }\n \n    vec4 x = conv2d(ivec2(fragCoord), iChannel0, w3, 2);\n\n    //relu\n    x = max(x, 0.2 * x);\n    \n    //to rgb, 1x1 convolution\n    for (int c = 0; c < 3; ++c)\n    {\t\n        fragColor[c] = dot(x, to_rgb[c]);\n    }\n    fragColor.rgb += to_rgb_bias;\n    fragColor.rgb = fragColor.rgb * 0.5 + vec3(0.5);\n    fragColor.a = 1.0;\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// The MIT License\n// Copyright © 2020 Stanislav Pidhorskyi\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Taken from https://www.shadertoy.com/view/MlVSzw\n// Changed to interpolate between two random values each second\nfloat gaussian_rand(vec2 n, float z)\n{\n\tfloat t = fract( iTime );\n\tint t_d = int(iTime) * 13;\n\tfloat x1 = hash1(n + 0.07*(float(t_d) + z) );\n\tfloat x2 = hash1(n + 0.07*(float(t_d + 13) + z) );\n    float x = mix(x1, x2, t);\n    \n\treturn inv_error_function(x*2.0-1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 l_coord, g_coord;\n    if (skip(fragCoord, iResolution, 2, l_coord, g_coord))\n    {\n        fragColor = vec4(0.0);\n    \treturn;\n    }\n\n    int zsize = min(ZSIZE, int(iResolution.x));\n    \n    float[ZSIZE] z;\n    float l = 0.;\n    for (int i = 0; i < zsize; ++i)\n    {\n        float x = gaussian_rand(vec2(g_coord), float(i) / float(ZSIZE)) * 1.0;\n        z[i] += x;\n        l += x * x;\n    }\n    l = sqrt(l / float(ZSIZE));\n    for (int i = 0; i < zsize; ++i)\n    {\n        z[i] *= 0.6 / l;\n    }  \n    \n    vec4 w[ZSIZE];\n    switch (l_coord.x + 4 * l_coord.y)\n    {\n\t\tcase 0: w = w_0_0; break;\n\t\tcase 1: w = w_0_1; break;\n\t\tcase 2: w = w_0_2; break;\n\t\tcase 3: w = w_0_3; break;\n\t\tcase 4: w = w_1_0; break;\n\t\tcase 5: w = w_1_1; break;\n\t\tcase 6: w = w_1_2; break;\n\t\tcase 7: w = w_1_3; break;\n\t\tcase 8: w = w_2_0; break;\n\t\tcase 9: w = w_2_1; break;\n\t\tcase 10: w = w_2_2; break;\n\t\tcase 11: w = w_2_3; break;\n\t\tcase 12: w = w_3_0; break;\n\t\tcase 13: w = w_3_1; break;\n\t\tcase 14: w = w_3_2; break;\n\t\tcase 15: w = w_3_3; break;\n    }\n    \n    vec4 x = bias[l_coord.x + 4 * l_coord.y];\n    for (int i = 0; i < zsize; ++i)\n    {\n        x += z[i] * w[i];\n    }\n        \n    //relu\n    fragColor = max(x, 0.2 * x);\n}\n", "buffer_b_inputs": [], "buffer_c_code": "// The MIT License\n// Copyright © 2020 Stanislav Pidhorskyi\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (_skip(fragCoord, iResolution, 3))\n    {\n        fragColor = vec4(0.0);\n    \treturn;\n    }\n\n    vec4 x = conv2d(ivec2(fragCoord), iChannel0, w1, 2);\n\n    //relu\n    fragColor = max(x, 0.2 * x);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// The MIT License\n// Copyright © 2020 Stanislav Pidhorskyi\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    if (_skip(fragCoord, iResolution, 4))\n    {\n        fragColor = vec4(0.0);\n    \treturn;\n    }\n\n    vec4 x = conv2d(ivec2(fragCoord), iChannel0, w2, 2);\n\n    //relu\n    fragColor = max(x, 0.2 * x);\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The MIT License\n// Copyright © 2020 Stanislav Pidhorskyi\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define ZSIZE 32 \n\nvec4 conv2d(in ivec2 in_coord, in sampler2D b, in vec4[9 * 4] w, int upscale)\n{\n    vec4 x = vec4(0.0);\n    for (int c = 0; c < 4; ++c)\n    {\n        float _x = 0.0;\n    \tfor (int j = 0; j < 3; ++j)\n        {\n    \t\tfor (int i = 0; i < 3; ++i)\n            {\n                ivec2 coord = in_coord + ivec2(j-1, i-1);\n            \t_x += dot(w[9 * c + j + i * 3], texelFetch(b, coord / upscale, 0));\n        \t}\n        }\n        x[c] = _x;\n    }\n    return x;\n}\n\nbool skip(in vec2 fragCoord, in vec3 resolution, int l, out ivec2 l_coord, out ivec2 g_coord)\n{\n    int r = int(pow(2., float(l)));\n    ivec2 f = ivec2(fragCoord);\n    int st = (r + r / 4);\n    g_coord = (f / st);\n    l_coord = f - g_coord * st;\n    return any(greaterThanEqual(l_coord, ivec2(r))) || any(greaterThan(g_coord * 40, ivec2(resolution.xy)));\n}\n\nbool _skip(inout vec2 fragCoord, in vec3 resolution, int l)\n{\n    ivec2 l_coord, g_coord;\n    return skip(fragCoord, resolution, l, l_coord, g_coord);\n}\n\nfloat hash1( vec2 p )\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);  \n}\n\n// Taken from https://www.shadertoy.com/view/MlVSzw\nconst float ALPHA = 0.14;\nconst float INV_ALPHA = 1.0 / ALPHA;\nconst float PI = 3.1415926535;\nconst float K = 2.0 / (PI * ALPHA);\n\nfloat inv_error_function(float x)\n{\n\tfloat y = log(1.0 - x*x);\n\tfloat z = K + 0.5 * y;\n\treturn sqrt(sqrt(z*z - y * INV_ALPHA) - z) * sign(x);\n}\n\n// Data\nconst vec4 w1[9 * 4] = vec4[](\n\tvec4(0.8538966774940491, -0.08800840377807617, -1.343640685081482, -0.2705347239971161),\n\tvec4(0.7074190378189087, -1.0973454713821411, -1.212476134300232, -0.6456915140151978),\n\tvec4(-0.18453127145767212, -0.07982335984706879, 0.26035210490226746, 0.959284245967865),\n\tvec4(0.8664763569831848, -0.697947084903717, -0.36425262689590454, -0.187509685754776),\n\tvec4(0.7366101145744324, -0.5838256478309631, 0.06948559731245041, 0.8645942807197571),\n\tvec4(0.6713154315948486, -0.5652173757553101, -0.31137746572494507, -0.2971823513507843),\n\tvec4(0.19874908030033112, -0.6458950638771057, -0.39804524183273315, -0.03233889490365982),\n\tvec4(1.238080382347107, -0.7171850204467773, -1.2270748615264893, -0.23851504921913147),\n\tvec4(0.5642578601837158, -1.0293302536010742, 0.2483142912387848, 0.6388093829154968),\n\tvec4(0.3112407326698303, -0.18187880516052246, 0.26125267148017883, -0.19077740609645844),\n\tvec4(0.8642761707305908, -0.5279910564422607, 0.9014730453491211, -1.236079454421997),\n\tvec4(0.21490970253944397, 0.64165860414505, -0.030292658135294914, -1.1004130840301514),\n\tvec4(0.057459037750959396, 0.18353410065174103, 0.4022194445133209, 0.08158791810274124),\n\tvec4(0.18248943984508514, 0.1201392188668251, 0.3541594445705414, -0.04874883592128754),\n\tvec4(-0.07297255843877792, 0.20909099280834198, 0.23968420922756195, -0.08748604357242584),\n\tvec4(-0.059444859623909, -0.7477058172225952, 1.1617847681045532, -0.33271679282188416),\n\tvec4(0.043855275958776474, 0.20971854031085968, 0.9981794953346252, -0.24410563707351685),\n\tvec4(0.802903413772583, -0.8863973617553711, 0.48771053552627563, -0.790242075920105),\n\tvec4(-0.30910149216651917, 0.11594898253679276, 0.2547944486141205, 0.0783194899559021),\n\tvec4(-0.6838433146476746, 0.6189290881156921, 0.25526610016822815, 0.14890258014202118),\n\tvec4(-0.13486172258853912, 0.279658704996109, -0.41928040981292725, 0.03290124237537384),\n\tvec4(-0.0572408065199852, 0.9028134942054749, -0.0810995027422905, -0.5210384726524353),\n\tvec4(0.29812848567962646, 1.0452799797058105, 0.0420125275850296, 1.0979832410812378),\n\tvec4(-0.10884926468133926, 0.5059928894042969, 0.12133071571588516, -0.24800297617912292),\n\tvec4(-0.36506766080856323, 0.06626701354980469, -0.4171594977378845, 0.28025496006011963),\n\tvec4(0.18511535227298737, 0.06064489856362343, -0.19685690104961395, 0.43153631687164307),\n\tvec4(-0.42545583844184875, 0.500962495803833, -0.35241058468818665, -0.27171435952186584),\n\tvec4(-0.20922042429447174, 0.015606669709086418, -0.07149160653352737, 0.7740588784217834),\n\tvec4(0.8992548584938049, -0.9141151309013367, 0.33024612069129944, 0.9195030331611633),\n\tvec4(-0.26311004161834717, -1.09807550907135, 0.5794845819473267, -0.31478387117385864),\n\tvec4(-0.18012073636054993, -0.9282574653625488, 0.3136879801750183, 0.17570443451404572),\n\tvec4(-0.843617856502533, -0.42918717861175537, -0.06691273301839828, 0.04859764128923416),\n\tvec4(1.3930708169937134, 0.03210531920194626, 0.2765769362449646, 0.23969003558158875),\n\tvec4(-0.3470709025859833, 0.586692214012146, 0.12065782397985458, 0.2090672254562378),\n\tvec4(-0.6248922944068909, -0.27937376499176025, 0.5944815874099731, 0.3969078063964844),\n\tvec4(-0.5838775634765625, 0.13091878592967987, 0.24891197681427002, 0.20240852236747742)\n);\nconst vec4 w2[9 * 4] = vec4[](\n\tvec4(-0.4284055233001709, -0.0606326200067997, -0.11047090590000153, -0.4212177097797394),\n\tvec4(-0.6690335869789124, 0.18738315999507904, 0.011928491294384003, 0.08799975365400314),\n\tvec4(-0.039279963821172714, 0.3010399341583252, -0.09393402934074402, 0.5851781964302063),\n\tvec4(0.4444112777709961, 0.6462287902832031, 0.046257972717285156, -0.3540789783000946),\n\tvec4(-0.21932566165924072, 0.45646587014198303, 0.7783144116401672, 0.7369889616966248),\n\tvec4(0.2818216383457184, -0.2835276126861572, 0.05367343872785568, 0.8850934505462646),\n\tvec4(-0.22412657737731934, 0.07773076742887497, -0.09435565769672394, 0.13788343966007233),\n\tvec4(0.22048820555210114, 0.3751506209373474, -0.04559710621833801, 0.031535010784864426),\n\tvec4(-0.3584699332714081, 0.001662898575887084, 0.06636244803667068, -0.4071216285228729),\n\tvec4(-0.3307264447212219, 0.1289454996585846, -0.099984310567379, -0.5650073885917664),\n\tvec4(-1.1502515077590942, -0.4867381453514099, -0.3149884045124054, 0.09590381383895874),\n\tvec4(-0.2923692464828491, 0.36018672585487366, 0.20671199262142181, 0.9320275187492371),\n\tvec4(-0.5692124962806702, 0.48664796352386475, 0.12812039256095886, -0.6346831321716309),\n\tvec4(-0.5706071853637695, 0.2554296553134918, -1.3952956199645996, 0.268179714679718),\n\tvec4(-0.1874639093875885, -0.5101688504219055, 0.13696633279323578, 1.589318871498108),\n\tvec4(0.38503026962280273, 0.33924418687820435, -0.2712552845478058, 0.3992575705051422),\n\tvec4(-0.9779213666915894, 0.250043660402298, 0.6672332286834717, 0.19163328409194946),\n\tvec4(0.4281635582447052, -0.07971522957086563, -0.20927710831165314, -0.5881822109222412),\n\tvec4(-0.08869341015815735, -0.061439380049705505, -0.09971027076244354, -0.35285237431526184),\n\tvec4(1.5808079242706299, -0.5144229531288147, 0.04732300341129303, 0.17377905547618866),\n\tvec4(-0.5867772698402405, -0.4466691017150879, 0.02900991402566433, 0.3253863751888275),\n\tvec4(1.7582828998565674, 0.7609666585922241, -0.37399619817733765, -0.3778935968875885),\n\tvec4(0.7875674366950989, -0.4082276523113251, -0.44232892990112305, 0.7833184003829956),\n\tvec4(1.7476645708084106, -0.28738319873809814, -0.4720272719860077, 1.1367768049240112),\n\tvec4(0.0540478341281414, -0.10339085012674332, 0.3033350706100464, -0.6721228957176208),\n\tvec4(1.0714802742004395, -0.09091299027204514, -0.40288835763931274, -0.3251018524169922),\n\tvec4(-0.4586676359176636, -0.23630069196224213, 0.3933032155036926, 0.06477842479944229),\n\tvec4(0.2646084427833557, -0.08327849209308624, 0.020180102437734604, 0.09328574687242508),\n\tvec4(2.143254280090332, -1.3186366558074951, 0.0545647032558918, 0.44532153010368347),\n\tvec4(-0.4858269691467285, -1.0399596691131592, 0.02025378867983818, -0.5930817723274231),\n\tvec4(0.712217390537262, -0.7533854246139526, -0.19484330713748932, 0.5521233081817627),\n\tvec4(2.008989095687866, -0.4940784275531769, 0.8526914119720459, 0.2104238122701645),\n\tvec4(1.2004508972167969, -0.7628940343856812, -0.34393641352653503, 0.491794228553772),\n\tvec4(1.0749295949935913, -0.1828589290380478, 0.25058701634407043, -0.24704574048519135),\n\tvec4(0.13965429365634918, -1.201771855354309, -0.23934024572372437, 0.1095033511519432),\n\tvec4(0.1777932494878769, -0.3433765470981598, 0.26323363184928894, 0.15941672027111053)\n);\nconst vec4 w3[9 * 4] = vec4[](\n\tvec4(0.3157793879508972, -0.709317684173584, 0.9905568361282349, -0.6485129594802856),\n\tvec4(0.010784421116113663, -0.8837623000144958, 1.2183514833450317, -0.834160327911377),\n\tvec4(0.2635725438594818, -0.406433641910553, 0.24956408143043518, -0.4522375166416168),\n\tvec4(0.021466702222824097, -0.7119984030723572, 0.9508382081985474, -0.8559297323226929),\n\tvec4(0.030064990743994713, -0.5038153529167175, 1.1024670600891113, -1.0756263732910156),\n\tvec4(0.04950116574764252, -0.8740060329437256, 0.8710198998451233, -0.9115540385246277),\n\tvec4(0.32262423634529114, -0.9106343984603882, 0.5644004344940186, -0.8419252038002014),\n\tvec4(0.3544318377971649, -0.757886528968811, 0.9049853086471558, -0.9548203945159912),\n\tvec4(0.023111091926693916, -0.7904314994812012, 0.8683055639266968, -0.7136849761009216),\n\tvec4(0.09297364205121994, -0.8339471817016602, 0.8296329379081726, -0.7902381420135498),\n\tvec4(0.3710455000400543, -1.1967096328735352, 0.983550488948822, -0.6946354508399963),\n\tvec4(0.05279070511460304, -0.6926487684249878, 0.41953539848327637, -0.5568503141403198),\n\tvec4(0.3505319654941559, -0.8012325167655945, 0.7644035220146179, -0.5540218353271484),\n\tvec4(0.8407868146896362, -2.062694787979126, 0.7013273239135742, -0.9792234301567078),\n\tvec4(0.2774963974952698, -0.7287704348564148, 0.34006640315055847, -0.4598105251789093),\n\tvec4(0.10614731907844543, -0.9500561952590942, 0.8224796652793884, -1.0426573753356934),\n\tvec4(0.6323619484901428, -0.521845817565918, 0.5289312601089478, -0.47211727499961853),\n\tvec4(-0.07432731240987778, -0.9894551634788513, 0.8690764904022217, -0.8100162148475647),\n\tvec4(-0.4138519763946533, 0.45091164112091064, 0.7180584073066711, 0.10031453520059586),\n\tvec4(0.03995395824313164, -0.10284631699323654, -1.051991581916809, 0.02596469223499298),\n\tvec4(0.004670828115195036, 0.45939764380455017, -0.312214195728302, 0.2166433185338974),\n\tvec4(-0.1759304255247116, 0.06274715811014175, -0.9501687288284302, -0.050756726413965225),\n\tvec4(-0.04523920640349388, 1.0498292446136475, -1.3961001634597778, 1.5284348726272583),\n\tvec4(0.05794418975710869, -0.2079864740371704, -0.8036617636680603, -0.11410152167081833),\n\tvec4(0.15181657671928406, 0.26387110352516174, -0.9465373754501343, 0.5230768322944641),\n\tvec4(-0.15346701443195343, -0.1055513471364975, -0.7926580309867859, -0.21636483073234558),\n\tvec4(-0.45818179845809937, 0.5250605940818787, 0.08766815066337585, 0.3221625089645386),\n\tvec4(-0.03665131703019142, -0.38135117292404175, -0.28538405895233154, -0.09189021587371826),\n\tvec4(0.5568697452545166, -0.9415125250816345, 0.42301619052886963, -0.25097596645355225),\n\tvec4(-0.33513617515563965, -0.37566104531288147, 0.3311464190483093, -0.2475101351737976),\n\tvec4(0.4537820816040039, -0.5930057168006897, 0.509360134601593, -0.13725364208221436),\n\tvec4(0.9140933156013489, -1.861647605895996, -0.14781054854393005, -0.2013268619775772),\n\tvec4(0.3355884552001953, -0.38476863503456116, -0.0869496688246727, 0.07307088375091553),\n\tvec4(-0.20789670944213867, -0.29524070024490356, 0.5819962620735168, -0.5544427037239075),\n\tvec4(0.4015480577945709, -0.06238926202058792, 0.1673804372549057, 0.09514600038528442),\n\tvec4(0.08193689584732056, -0.5550370812416077, 0.2584555745124817, -0.34954455494880676)\n);\nconst vec4 to_rgb[3] = vec4[](\n\tvec4(0.04956958815455437, -0.054536428302526474, 0.0252359788864851, 0.018266206607222557),\n\tvec4(0.04649809002876282, -0.059660181403160095, 0.025534354150295258, 0.034223150461912155),\n\tvec4(0.04224415123462677, -0.05699027329683304, 0.029045673087239265, 0.03792824223637581)\n);\nconst vec3 to_rgb_bias = vec3(0.1263452172279358, -0.2852652966976166, -0.4914747178554535);\nconst vec4 w_0_0[32] = vec4[](\n\tvec4(-0.033170223236083984, -0.3334859013557434, -0.6015621423721313, -0.631832480430603),\n\tvec4(-0.04332781583070755, 0.02502209134399891, -0.39929530024528503, -0.05812649428844452),\n\tvec4(-0.3530454635620117, 0.3867090344429016, 0.02249608002603054, 0.07297223061323166),\n\tvec4(-0.5442796945571899, -0.23431997001171112, 0.5477864742279053, 0.24479852616786957),\n\tvec4(0.41780927777290344, 0.20536993443965912, 0.1140819638967514, 0.30679208040237427),\n\tvec4(0.31563815474510193, 0.5172950625419617, -0.7097467184066772, -0.18371789157390594),\n\tvec4(0.1454942375421524, 0.17749683558940887, -0.0488801971077919, -0.14519038796424866),\n\tvec4(0.09770847856998444, -0.22994296252727509, 0.6728823184967041, 0.48461487889289856),\n\tvec4(0.11085475236177444, -0.10479927062988281, -0.2167598009109497, -0.4865240454673767),\n\tvec4(0.04758758842945099, -0.387176513671875, 0.2911570966243744, -0.13348981738090515),\n\tvec4(-0.04342746362090111, 0.3555528521537781, -0.5462194085121155, 0.0374593660235405),\n\tvec4(0.051350850611925125, 0.08547219634056091, 0.3942941427230835, 0.12983070313930511),\n\tvec4(-0.19634386897087097, -0.5619758367538452, -0.2826230227947235, 0.08738300204277039),\n\tvec4(-0.13336506485939026, 0.38920721411705017, 0.004497379530221224, 0.10797503590583801),\n\tvec4(-0.2747681438922882, 0.33606478571891785, -0.04274526610970497, 0.06768592447042465),\n\tvec4(-0.8255285620689392, 0.8083309531211853, -0.18213461339473724, -0.24359813332557678),\n\tvec4(-0.14335383474826813, 0.16559234261512756, -0.08065386861562729, -0.10626953095197678),\n\tvec4(-0.3321602940559387, 0.3416193425655365, -0.3162483274936676, 0.3013427257537842),\n\tvec4(-0.17610609531402588, 0.35675933957099915, -0.17298674583435059, 0.11544289439916611),\n\tvec4(-0.13075318932533264, -0.8329300880432129, 0.06046294793486595, -0.2547319233417511),\n\tvec4(0.17369355261325836, 0.18537560105323792, 0.23667702078819275, -0.3013394773006439),\n\tvec4(-0.23782581090927124, 0.11055468767881393, 0.07163367420434952, 0.5990631580352783),\n\tvec4(0.5031487941741943, -0.1680048257112503, 0.44841164350509644, 0.3340984582901001),\n\tvec4(-0.5596635937690735, -0.2936471700668335, 0.1838470697402954, 0.38819968700408936),\n\tvec4(0.5387517809867859, -0.5478320121765137, 0.10009052604436874, 0.12222785502672195),\n\tvec4(-0.21695105731487274, 0.3735494017601013, -0.523076057434082, 0.01942858099937439),\n\tvec4(0.21642480790615082, -0.659875214099884, 0.32254257798194885, 0.34461840987205505),\n\tvec4(-0.06969035416841507, 0.5190779566764832, -0.014875916764140129, 0.02799905277788639),\n\tvec4(0.02185906283557415, -0.020864812657237053, -0.032487619668245316, -0.3668511211872101),\n\tvec4(0.703324556350708, 0.33352047204971313, 0.07896551489830017, -0.0424870103597641),\n\tvec4(-0.10688632726669312, 0.3791502118110657, 0.1490907222032547, 0.36489298939704895),\n\tvec4(-0.2830473780632019, 0.10385929048061371, 0.08560332655906677, -0.005273264832794666)\n);\nconst vec4 w_0_1[32] = vec4[](\n\tvec4(0.13757477700710297, -0.2653031647205353, -0.4205164313316345, -0.6744050979614258),\n\tvec4(-0.22045978903770447, -0.039200007915496826, -0.24502824246883392, 0.15502865612506866),\n\tvec4(-0.3117561340332031, -0.05469484627246857, 0.3408004641532898, 0.021004963666200638),\n\tvec4(-0.4509764313697815, 0.5868337750434875, 0.3306752145290375, -0.1580604910850525),\n\tvec4(-0.19098852574825287, 0.06484048813581467, 0.10578817874193192, 0.34611621499061584),\n\tvec4(0.3620632290840149, -0.04373938590288162, -0.3426678478717804, -0.04159100353717804),\n\tvec4(0.3300960659980774, -0.30662283301353455, -0.17535804212093353, -0.10623013973236084),\n\tvec4(0.041121646761894226, 0.19263413548469543, 0.2689878046512604, -0.024112755432724953),\n\tvec4(0.02210073173046112, -0.2259177267551422, -0.4544140100479126, -0.1569940745830536),\n\tvec4(0.03367890790104866, 0.0939977690577507, -0.045926641672849655, -0.30481287837028503),\n\tvec4(-0.147662952542305, 0.14868542551994324, -0.5198937058448792, -0.29961445927619934),\n\tvec4(0.12928178906440735, 0.03395218402147293, 0.2161690592765808, -0.18993400037288666),\n\tvec4(0.05385485664010048, -0.02460050955414772, -0.13923780620098114, -0.12016361206769943),\n\tvec4(-0.13569316267967224, -0.10491254180669785, 0.008554914966225624, 0.28513720631599426),\n\tvec4(-0.06921055167913437, -0.1413317769765854, -0.20131929218769073, 0.12007291615009308),\n\tvec4(-0.7073650360107422, 0.10223596543073654, 0.09296609461307526, 0.04641672223806381),\n\tvec4(-0.2101677507162094, 0.1336846649646759, -0.14067420363426208, -0.22720448672771454),\n\tvec4(-0.23748070001602173, 0.0626850426197052, 0.05225338414311409, 0.23496362566947937),\n\tvec4(-0.24533487856388092, -0.20304474234580994, -0.050556376576423645, -0.03338346257805824),\n\tvec4(-0.09991072118282318, -0.07136005163192749, -0.3099145293235779, -0.358328253030777),\n\tvec4(0.0283685140311718, 0.18133613467216492, 0.317143976688385, -0.08565431088209152),\n\tvec4(-0.19738802313804626, 0.1654442399740219, 0.26127609610557556, 0.38439589738845825),\n\tvec4(0.42921707034111023, 0.05764571949839592, 0.5134604573249817, 0.5489647388458252),\n\tvec4(-0.11903348565101624, -0.17151179909706116, 0.0771496519446373, 0.3577778935432434),\n\tvec4(0.03864274546504021, 0.1955648958683014, -0.3193054795265198, 0.2611522376537323),\n\tvec4(0.05200674384832382, -0.1314079761505127, -0.12937533855438232, -0.21210195124149323),\n\tvec4(0.04717855900526047, -0.5155675411224365, -0.04725765064358711, 0.2997440695762634),\n\tvec4(0.3309492766857147, -0.18898281455039978, -0.06977088749408722, 0.15437066555023193),\n\tvec4(0.15307828783988953, -0.4198700487613678, 0.16210070252418518, -0.26491183042526245),\n\tvec4(0.5880010724067688, 0.3385653793811798, -0.09438857436180115, 0.23862585425376892),\n\tvec4(-0.07970176637172699, 0.41034823656082153, 0.4517008066177368, 0.31173914670944214),\n\tvec4(-0.6686015129089355, 0.30869439244270325, -0.04307129979133606, 0.16304448246955872)\n);\nconst vec4 w_0_2[32] = vec4[](\n\tvec4(0.26021432876586914, 0.021091986447572708, -0.7366957068443298, -0.8159341216087341),\n\tvec4(-0.06654087454080582, 0.11258509010076523, -0.20936812460422516, -0.048246655613183975),\n\tvec4(-0.09336604177951813, 0.21461212635040283, -0.06944725662469864, 0.12031858414411545),\n\tvec4(-0.28141871094703674, 0.12425645440816879, 0.16934025287628174, -0.015042634680867195),\n\tvec4(-0.2575063109397888, 0.1943322718143463, 0.019697172567248344, 0.163289874792099),\n\tvec4(0.312242329120636, 0.1203916072845459, -0.3386983871459961, -0.022360850125551224),\n\tvec4(0.3303869366645813, -0.3029318153858185, 0.17856819927692413, 0.05934477597475052),\n\tvec4(-0.04351701959967613, 0.05217853933572769, 0.3915172815322876, 0.11125443130731583),\n\tvec4(0.0557154044508934, -0.46337395906448364, -0.3454085886478424, -0.2640712857246399),\n\tvec4(0.045658502727746964, -0.15738070011138916, 0.04783933609724045, -0.2725526690483093),\n\tvec4(-0.2759438157081604, 0.3164140582084656, -0.5239084959030151, -0.3310115337371826),\n\tvec4(0.02951192483305931, 0.04388942942023277, 0.13895511627197266, -0.2325933575630188),\n\tvec4(0.009629881009459496, -0.26956436038017273, -0.030911395326256752, -0.17853662371635437),\n\tvec4(-0.028164459392428398, -0.261741042137146, 0.007483394350856543, 0.3480369746685028),\n\tvec4(-0.0395614318549633, -0.06765442341566086, -0.4152754247188568, -0.02643493190407753),\n\tvec4(-0.890344500541687, 0.4914000928401947, 0.06103450804948807, -0.05846993997693062),\n\tvec4(-0.07409527897834778, 0.06998758763074875, -0.08714628219604492, -0.25346270203590393),\n\tvec4(-0.12112481147050858, 0.08695392310619354, 0.04272259399294853, 0.17246076464653015),\n\tvec4(-0.17094983160495758, -0.08815789222717285, -0.19020859897136688, -0.0982276126742363),\n\tvec4(-0.2296009659767151, -0.24942825734615326, -0.11695076525211334, -0.36371007561683655),\n\tvec4(0.1663845181465149, 0.06620542705059052, -0.07950863987207413, -0.16779787838459015),\n\tvec4(-0.15376390516757965, 0.2532544732093811, 0.30249249935150146, 0.381902813911438),\n\tvec4(0.5466929078102112, -0.49271637201309204, 0.7947457432746887, 0.7182272672653198),\n\tvec4(-0.21531644463539124, -0.29824569821357727, -0.16926255822181702, 0.4796637296676636),\n\tvec4(0.11614552140235901, -0.0005631870008073747, -0.4258716404438019, 0.3076316714286804),\n\tvec4(-0.046386636793613434, -0.06896964460611343, -0.2299472689628601, -0.07054924219846725),\n\tvec4(-0.29016220569610596, -0.41295427083969116, 0.13479411602020264, 0.3059900999069214),\n\tvec4(0.45195913314819336, -0.212265282869339, -0.02389470301568508, 0.10200776159763336),\n\tvec4(-0.11993178725242615, -0.2172035425901413, 0.26052337884902954, -0.1676444262266159),\n\tvec4(0.514790415763855, 0.25693008303642273, 0.06964738667011261, 0.2373041957616806),\n\tvec4(-0.01041046530008316, 0.548072338104248, -0.017479047179222107, 0.22793470323085785),\n\tvec4(-0.4394930899143219, 0.2967594861984253, -0.04865764454007149, -0.15891031920909882)\n);\nconst vec4 w_0_3[32] = vec4[](\n\tvec4(-0.12434606999158859, -0.16767391562461853, -0.4179287552833557, -0.6875959038734436),\n\tvec4(-0.23054425418376923, 0.23397015035152435, -0.06530950218439102, 0.11221639066934586),\n\tvec4(0.18891598284244537, 0.1600509136915207, 0.21571588516235352, -0.007403383497148752),\n\tvec4(-0.60359126329422, 0.3930931091308594, 0.19573543965816498, 0.19747060537338257),\n\tvec4(-0.35637158155441284, 0.6104933619499207, -0.06905743479728699, 0.32388758659362793),\n\tvec4(0.188085675239563, -0.004878531210124493, -0.22638250887393951, -0.027052976191043854),\n\tvec4(-0.00668049743399024, 0.12432117015123367, 0.2746044099330902, 0.13482990860939026),\n\tvec4(0.1609419733285904, -0.015463589690625668, 0.14890238642692566, -0.02417917549610138),\n\tvec4(-0.11474836617708206, -0.2500782012939453, -0.16820627450942993, -0.3028409779071808),\n\tvec4(-0.11175643652677536, 0.14786721765995026, 0.004224710166454315, -0.3789080083370209),\n\tvec4(0.27553078532218933, -0.11892484128475189, -0.6473550200462341, -0.21315547823905945),\n\tvec4(0.07444695383310318, 0.055079855024814606, 0.04812154173851013, -0.13855555653572083),\n\tvec4(-0.40913519263267517, -0.083900086581707, -0.2315419465303421, -0.17395256459712982),\n\tvec4(-0.12041556090116501, -0.08752832561731339, -0.08241730183362961, 0.2225014567375183),\n\tvec4(-0.11803588271141052, -0.11079524457454681, -0.10828015953302383, 0.07112814486026764),\n\tvec4(-1.3011399507522583, 0.405746191740036, 0.20576122403144836, 0.19815433025360107),\n\tvec4(-0.07929570972919464, 0.13174788653850555, -0.04640917107462883, -0.1602725088596344),\n\tvec4(-0.4553426504135132, 0.13355839252471924, -0.27167022228240967, 0.43823274970054626),\n\tvec4(-0.6730266809463501, 0.020675165578722954, -0.2975863814353943, 0.20263418555259705),\n\tvec4(0.15567201375961304, -0.25621703267097473, -0.3720215857028961, -0.5807803869247437),\n\tvec4(0.09071150422096252, -0.7415137887001038, 0.07992885261774063, -0.33459028601646423),\n\tvec4(-0.08824057877063751, 0.1331131011247635, 0.06174361705780029, 0.6584446430206299),\n\tvec4(0.1574830263853073, -0.08205971121788025, 0.4630609154701233, 0.7742915153503418),\n\tvec4(-0.20213136076927185, -0.3419342041015625, -0.16770339012145996, 0.2921125590801239),\n\tvec4(0.1408485323190689, -0.05168144777417183, -0.14713212847709656, -0.022007493302226067),\n\tvec4(-0.5014960169792175, 0.43378159403800964, -0.4514639973640442, -0.0224906038492918),\n\tvec4(0.12677989900112152, -0.6020253300666809, 0.17912453413009644, 0.2029801458120346),\n\tvec4(0.0026966738514602184, 0.12611842155456543, 0.09029370546340942, 0.15538416802883148),\n\tvec4(-0.3451380431652069, -0.37549111247062683, 0.1874445080757141, -0.4233231246471405),\n\tvec4(0.48988035321235657, 0.33542492985725403, 0.13287316262722015, -0.031580742448568344),\n\tvec4(0.07845441997051239, 0.2768207788467407, 0.1234520971775055, 0.1165447011590004),\n\tvec4(-0.011147946119308472, -0.15881295502185822, 0.04801348224282265, -0.12605933845043182)\n);\nconst vec4 w_1_0[32] = vec4[](\n\tvec4(-0.4799179434776306, -0.27337539196014404, -0.3638092875480652, 0.04515276104211807),\n\tvec4(-0.18402869999408722, -0.04662862420082092, -0.1477830857038498, -0.00937035121023655),\n\tvec4(-0.2451489120721817, 0.5080276727676392, 0.2239784300327301, -0.21531277894973755),\n\tvec4(-0.1518886536359787, -0.181665301322937, 0.7061646580696106, -0.06405077874660492),\n\tvec4(-0.1064792275428772, 0.4371660649776459, 0.0805235356092453, 0.2344837635755539),\n\tvec4(0.25840356945991516, 0.3371994197368622, -0.3388455808162689, 0.2201394885778427),\n\tvec4(0.06001155078411102, 0.18571020662784576, -0.1427430659532547, -0.11703088134527206),\n\tvec4(0.8531196117401123, -0.2835153341293335, 0.6153947114944458, 0.010402573272585869),\n\tvec4(-0.27600857615470886, 0.0018666571704670787, -0.5578995943069458, -0.26447322964668274),\n\tvec4(-0.10667823255062103, -0.3192199766635895, 0.08663283288478851, 0.017606452107429504),\n\tvec4(-0.0217626690864563, 0.20379284024238586, 0.015419228933751583, 0.2059445083141327),\n\tvec4(0.1976812779903412, 0.032973356544971466, 0.4815809726715088, 0.04881591722369194),\n\tvec4(0.3263010084629059, -0.7629849910736084, 0.011535481549799442, -0.15660935640335083),\n\tvec4(-0.20588913559913635, 0.5217878222465515, -0.1617313027381897, -0.18010631203651428),\n\tvec4(0.022023821249604225, 0.10779455304145813, 0.11843478679656982, -0.11717505007982254),\n\tvec4(-0.2032206803560257, 0.3099841773509979, -0.20874154567718506, -0.502119243144989),\n\tvec4(-0.22008273005485535, 0.17490777373313904, -0.03838246688246727, 0.027094298973679543),\n\tvec4(-0.07586909830570221, 0.2629033625125885, 0.04224057123064995, 0.09064509719610214),\n\tvec4(0.36966559290885925, 0.1617589294910431, -0.03959212079644203, -0.16218551993370056),\n\tvec4(-0.267731249332428, -0.5424261689186096, -0.33597472310066223, -0.3441687226295471),\n\tvec4(-0.039906587451696396, 0.35035037994384766, -0.17944376170635223, -0.11999022215604782),\n\tvec4(0.47378048300743103, 0.028498291969299316, 0.1678454726934433, -0.08195533603429794),\n\tvec4(0.7715818881988525, -0.2879593074321747, 0.11718212813138962, -0.03685566782951355),\n\tvec4(0.07176901400089264, -0.43738290667533875, 0.45850449800491333, -0.25510621070861816),\n\tvec4(-0.0415697917342186, -0.24291838705539703, 0.13031171262264252, 0.2869492769241333),\n\tvec4(0.058450669050216675, 0.07803931087255478, 0.11698313802480698, 0.13990357518196106),\n\tvec4(-0.1371607780456543, -0.33705171942710876, -0.10514941066503525, -0.1673133671283722),\n\tvec4(0.016750529408454895, 0.34610745310783386, -0.0017467787256464362, 0.1049293577671051),\n\tvec4(0.13468439877033234, -0.020647121593356133, -0.46681544184684753, -0.4933967888355255),\n\tvec4(0.39934495091438293, 0.2560552954673767, -0.17680610716342926, 0.2297155112028122),\n\tvec4(0.32936564087867737, 0.18468424677848816, 0.4629433751106262, 0.30299413204193115),\n\tvec4(-0.5458417534828186, 0.20080682635307312, 0.009167877957224846, -0.02257341332733631)\n);\nconst vec4 w_1_1[32] = vec4[](\n\tvec4(-0.7158597707748413, -0.00777872558683157, 0.4045867621898651, -0.20302949845790863),\n\tvec4(-0.010225067846477032, 0.17382623255252838, 0.2949126362800598, -0.1682666540145874),\n\tvec4(0.21027520298957825, -0.10986413061618805, -0.25731703639030457, -0.52921462059021),\n\tvec4(-0.02263741008937359, 0.2090199887752533, -0.009954743087291718, -0.17349185049533844),\n\tvec4(0.4934879541397095, 0.11400317400693893, 0.667018473148346, -0.077134869992733),\n\tvec4(-0.011601083911955357, 0.10375414788722992, 0.17230048775672913, 0.29181918501853943),\n\tvec4(0.1103111132979393, -0.10026241093873978, -0.3203062117099762, -0.17815792560577393),\n\tvec4(-0.011774263344705105, 0.21611247956752777, -0.9405052661895752, 0.32808127999305725),\n\tvec4(-0.2624439001083374, -0.0547892265021801, -0.46498721837997437, -0.17081379890441895),\n\tvec4(-0.24983340501785278, -0.13468776643276215, -0.6160114407539368, -0.037088677287101746),\n\tvec4(-0.4161376953125, 0.205970898270607, -0.14448480308055878, 0.26437610387802124),\n\tvec4(0.1300218105316162, 0.15260115265846252, 0.15879367291927338, -0.040558621287345886),\n\tvec4(-0.01875418983399868, -0.0774516686797142, -0.26492032408714294, -0.20330439507961273),\n\tvec4(0.06247904524207115, -0.3593265414237976, -0.20511509478092194, -0.1980258822441101),\n\tvec4(-0.06240386515855789, 0.14110226929187775, 0.6080037355422974, 0.05889187380671501),\n\tvec4(-0.07243146002292633, 0.07072458416223526, 0.4747849404811859, 0.04687539488077164),\n\tvec4(-0.36752617359161377, 0.05018913000822067, -0.13519588112831116, 0.023868467658758163),\n\tvec4(-0.026631144806742668, 0.06693889200687408, 0.04623716324567795, -0.20890793204307556),\n\tvec4(0.06808658689260483, -0.3349999785423279, 0.06722559779882431, -0.08459484577178955),\n\tvec4(-0.4232594966888428, -0.1772671341896057, -0.7500607371330261, -0.5696889758110046),\n\tvec4(-0.027364181354641914, 0.21070460975170135, 0.30886468291282654, -0.2699989676475525),\n\tvec4(0.5862935185432434, -0.24241964519023895, 0.21773852407932281, -0.12779875099658966),\n\tvec4(0.7796692252159119, -0.0004837611922994256, -0.31821882724761963, -0.12966249883174896),\n\tvec4(0.4444774389266968, -0.1135329082608223, -0.06604177504777908, -0.10700441896915436),\n\tvec4(0.09024551510810852, 0.20459339022636414, -0.22924967110157013, 0.23351988196372986),\n\tvec4(-0.04719673469662666, -0.15508964657783508, -0.3626312017440796, -0.06965255737304688),\n\tvec4(0.34956714510917664, -0.0813491940498352, -0.39906346797943115, -0.37322407960891724),\n\tvec4(0.31745049357414246, -0.24176368117332458, 0.0399712398648262, 0.017857952043414116),\n\tvec4(-0.12139750272035599, -0.06086896359920502, -0.5410635471343994, -0.40225014090538025),\n\tvec4(0.06712750345468521, 0.38923579454421997, -0.2826898694038391, 0.4646482765674591),\n\tvec4(0.23791749775409698, 0.31395453214645386, 0.8856003284454346, 0.27175626158714294),\n\tvec4(0.07812926173210144, 0.12559908628463745, -0.2980044186115265, -0.06685638427734375)\n);\nconst vec4 w_1_2[32] = vec4[](\n\tvec4(-0.8727299571037292, 0.21567024290561676, -0.37589704990386963, -0.05206231772899628),\n\tvec4(-0.09191228449344635, 0.23494891822338104, 0.09990178793668747, -0.13241122663021088),\n\tvec4(0.060200512409210205, 0.09853154420852661, -0.29447564482688904, -0.19820277392864227),\n\tvec4(0.0782603919506073, -0.04124055802822113, 0.03673553094267845, -0.2764609754085541),\n\tvec4(0.4378052353858948, -0.06705202907323837, 0.4755958914756775, -0.08496386557817459),\n\tvec4(0.013944178819656372, 0.23858532309532166, 0.1700410097837448, 0.2826675474643707),\n\tvec4(0.20761628448963165, -0.06619995087385178, 0.015246252529323101, -0.14542348682880402),\n\tvec4(0.14117226004600525, 0.0636378601193428, -0.1874215304851532, 0.3030829131603241),\n\tvec4(-0.27632710337638855, -0.2974514961242676, -0.21295066177845, -0.16636180877685547),\n\tvec4(-0.23401768505573273, -0.30598708987236023, -0.3670589029788971, -0.056760720908641815),\n\tvec4(-0.3750673532485962, 0.24392347037792206, 0.3435346782207489, 0.2445273995399475),\n\tvec4(-0.06247497722506523, 0.0733964815735817, -0.33832812309265137, 0.01911732740700245),\n\tvec4(-0.04063493758440018, -0.23126888275146484, 0.11826343834400177, -0.3199117183685303),\n\tvec4(0.10861238092184067, -0.2475602626800537, -0.3800469934940338, -0.21218587458133698),\n\tvec4(-0.09929470717906952, 0.04767444357275963, -0.3002566695213318, -0.10287053883075714),\n\tvec4(0.06150641292333603, 0.021956797689199448, 0.6978182792663574, -0.042060986161231995),\n\tvec4(-0.23114478588104248, 0.06271859258413315, -0.11314541846513748, 0.06808612495660782),\n\tvec4(0.007141479756683111, 0.22826305031776428, 0.5058119297027588, -0.22268971800804138),\n\tvec4(0.0756366029381752, -0.23863531649112701, 0.5167058706283569, -0.2096678465604782),\n\tvec4(-0.6188251972198486, -0.188776895403862, -0.41749241948127747, -0.4639454782009125),\n\tvec4(-0.06749965995550156, 0.20469491183757782, 0.06792260706424713, -0.15773014724254608),\n\tvec4(0.5760741829872131, 0.016277147457003593, 0.2716256082057953, -0.3370109796524048),\n\tvec4(0.913455069065094, -0.3783446252346039, 0.31152355670928955, -0.27485862374305725),\n\tvec4(0.39409103989601135, -0.19848205149173737, -0.6117805242538452, -0.12860697507858276),\n\tvec4(-0.004689268302172422, 0.08087706565856934, -0.42381981015205383, 0.2896530330181122),\n\tvec4(-0.019604580476880074, -0.16175033152103424, -0.07739182561635971, 0.05343358591198921),\n\tvec4(0.2973743975162506, -0.24000030755996704, -0.07731179893016815, -0.2677474021911621),\n\tvec4(0.46128082275390625, -0.35749971866607666, -0.4977744221687317, 0.0060924626886844635),\n\tvec4(-0.2336275279521942, 0.09385903924703598, -0.37581291794776917, -0.204405277967453),\n\tvec4(0.08499473333358765, 0.28268787264823914, 0.2617141902446747, 0.4001944363117218),\n\tvec4(0.29159611463546753, 0.2218303084373474, 0.49731868505477905, 0.2605641782283783),\n\tvec4(0.24301016330718994, -0.07568599283695221, 0.19414259493350983, -0.04725690931081772)\n);\nconst vec4 w_1_3[32] = vec4[](\n\tvec4(-0.5130273103713989, 0.18404287099838257, -0.5246836543083191, -0.20452746748924255),\n\tvec4(0.08536548912525177, 0.18950414657592773, -0.014084842056035995, -0.15650926530361176),\n\tvec4(0.15688501298427582, 0.3919186592102051, -0.24062176048755646, -0.1558382362127304),\n\tvec4(-0.06864296644926071, 0.40461209416389465, 0.07404903322458267, -0.00479175103828311),\n\tvec4(0.011593093164265156, 0.6688195466995239, 0.17032118141651154, 0.6430578827857971),\n\tvec4(0.001033215899951756, -0.04532763734459877, -0.10605896264314651, 0.1747758686542511),\n\tvec4(-0.17752781510353088, 0.07092541456222534, 0.2897545397281647, 0.06435076147317886),\n\tvec4(0.3762454092502594, -0.12914828956127167, 0.253282368183136, 0.05725027620792389),\n\tvec4(-0.2788848876953125, 0.050956446677446365, -0.1144796758890152, -0.20909643173217773),\n\tvec4(-0.4629996716976166, 0.2674219608306885, -0.12882201373577118, -0.026220163330435753),\n\tvec4(-0.2616989314556122, 0.025488868355751038, -0.20666345953941345, 0.27769795060157776),\n\tvec4(0.30474260449409485, 0.054306358098983765, -0.15285499393939972, -0.26761943101882935),\n\tvec4(-0.3227623701095581, 0.007628312800079584, -0.05744188651442528, -0.12906213104724884),\n\tvec4(0.16527843475341797, -0.37660637497901917, 0.0975160002708435, -0.18636482954025269),\n\tvec4(-0.07385396212339401, 0.03811557963490486, 0.11707748472690582, 0.08563345670700073),\n\tvec4(-0.7650389671325684, 0.27442243695259094, 0.5302064418792725, -0.11289862543344498),\n\tvec4(-0.09127838164567947, 0.17596818506717682, 0.17662860453128815, 0.21293674409389496),\n\tvec4(0.10753834247589111, 0.01991875469684601, -0.024260520935058594, -0.23014973104000092),\n\tvec4(-0.33728763461112976, -0.011132040992379189, 0.025332093238830566, -0.05565975606441498),\n\tvec4(-0.28557267785072327, -0.20942014455795288, -0.3858959972858429, -0.30152177810668945),\n\tvec4(0.06090756133198738, -0.4851592183113098, -0.32849961519241333, -0.49723759293556213),\n\tvec4(0.454045832157135, -0.1351245790719986, -0.09226396679878235, -0.20730821788311005),\n\tvec4(0.6893830299377441, -0.1591685712337494, 0.274712473154068, -0.21489013731479645),\n\tvec4(0.2158961147069931, -0.38166543841362, -0.06598411500453949, -0.1797410398721695),\n\tvec4(0.028306273743510246, 0.03484606742858887, -0.09601923078298569, 0.10258243978023529),\n\tvec4(-0.10511412471532822, 0.26482343673706055, 0.05051809176802635, 0.25008952617645264),\n\tvec4(0.03436761349439621, -0.38747909665107727, -0.20366773009300232, -0.22400367259979248),\n\tvec4(0.2544729709625244, 0.10356337577104568, 0.22590845823287964, 0.3044789135456085),\n\tvec4(-0.27959421277046204, -0.29743823409080505, 0.023919256404042244, -0.6474483609199524),\n\tvec4(-0.019204609096050262, 0.4293573796749115, 0.15873686969280243, 0.254209965467453),\n\tvec4(0.050106462091207504, 0.3007656931877136, -0.028192607685923576, 0.42470583319664),\n\tvec4(0.12967327237129211, 0.12259166687726974, -0.27119532227516174, -0.32587113976478577)\n);\nconst vec4 w_2_0[32] = vec4[](\n\tvec4(0.018601207062602043, -0.41473326086997986, 0.045916635543107986, -0.2103792428970337),\n\tvec4(0.31636369228363037, -0.20569846034049988, 0.20722386240959167, 0.2417849451303482),\n\tvec4(-0.5558471083641052, 0.4780957102775574, -0.1143437996506691, -0.049739938229322433),\n\tvec4(-0.647606372833252, -0.06173814460635185, 0.4322130084037781, 0.11671390384435654),\n\tvec4(0.6222584843635559, 0.43532681465148926, 0.19903048872947693, 0.20901620388031006),\n\tvec4(0.4671867787837982, 0.40061086416244507, -0.13852016627788544, 0.19192606210708618),\n\tvec4(-0.12319395691156387, 0.09747352451086044, 0.29644593596458435, 0.2228231132030487),\n\tvec4(-0.36277416348457336, 0.13097836077213287, -0.16029459238052368, 0.38891950249671936),\n\tvec4(0.08626943081617355, 0.10145118087530136, 0.2052253782749176, -0.0543472021818161),\n\tvec4(-0.11439979821443558, -0.36068999767303467, 0.08061949908733368, -0.07298720628023148),\n\tvec4(-0.07491213828325272, 0.2783474922180176, -0.18084964156150818, 0.23795808851718903),\n\tvec4(-0.19156961143016815, -0.12205559760332108, 0.8047174215316772, 0.42338788509368896),\n\tvec4(-0.1488274186849594, -0.6115649342536926, -0.2606993317604065, 0.3821869194507599),\n\tvec4(-0.22514687478542328, 0.5064855813980103, -0.3967207670211792, -0.38804054260253906),\n\tvec4(-0.3010759949684143, -0.11958141624927521, 0.1831902116537094, 0.29571184515953064),\n\tvec4(-0.4478868842124939, 0.48020708560943604, -0.5516210198402405, -0.576605498790741),\n\tvec4(-0.06791022419929504, 0.20880910754203796, -0.2122248411178589, -0.12341266870498657),\n\tvec4(-0.3816778361797333, 0.2770390808582306, -0.30215877294540405, 0.42095112800598145),\n\tvec4(-0.016741005703806877, 0.509563148021698, -0.3743124306201935, 0.05452162027359009),\n\tvec4(-0.15436536073684692, -0.5171710848808289, -0.05333375930786133, 0.11970264464616776),\n\tvec4(0.09205804020166397, 0.3712007999420166, 0.5841801166534424, 0.22402407228946686),\n\tvec4(-0.09131045639514923, 0.057082485407590866, -0.4905332624912262, 0.45200639963150024),\n\tvec4(0.30601561069488525, -0.26653575897216797, 0.08289005607366562, 0.3738481402397156),\n\tvec4(-0.6368108987808228, -0.6772019863128662, -0.09612540900707245, 0.18147672712802887),\n\tvec4(0.6120992302894592, -0.37081748247146606, 0.32037562131881714, -0.023385915905237198),\n\tvec4(-0.20187684893608093, 0.2595590054988861, -0.5364540815353394, -0.26874420046806335),\n\tvec4(-0.015781743451952934, -0.08550042659044266, -0.3645828068256378, -0.1004100888967514),\n\tvec4(-0.02264329418540001, 0.3486504554748535, -0.15812505781650543, -0.2487436681985855),\n\tvec4(-0.33864203095436096, 0.10174740105867386, -0.16914990544319153, 0.11251875758171082),\n\tvec4(0.38832151889801025, 0.31307849287986755, 0.36483797430992126, 0.3867745101451874),\n\tvec4(0.03138537332415581, 0.180335134267807, 0.07729413360357285, 0.26101914048194885),\n\tvec4(-0.025279859080910683, 0.0495789460837841, 0.16632825136184692, 0.08802802115678787)\n);\nconst vec4 w_2_1[32] = vec4[](\n\tvec4(-0.2737208604812622, -0.21763455867767334, 0.24196048080921173, -0.3524816036224365),\n\tvec4(-0.20771655440330505, 0.1703009307384491, -0.11378158628940582, 0.1960759162902832),\n\tvec4(-0.047286540269851685, -0.17994867265224457, 0.06278280168771744, 0.14283831417560577),\n\tvec4(0.01686302199959755, 0.21677348017692566, -0.10159847140312195, -0.30489709973335266),\n\tvec4(0.1907654106616974, -0.14901722967624664, 0.04729536548256874, 0.364472359418869),\n\tvec4(0.2446061372756958, -0.06644933670759201, 0.3488011956214905, 0.22247076034545898),\n\tvec4(-0.02456253580749035, 0.05452460050582886, 0.09111549705266953, 0.04824705049395561),\n\tvec4(0.022511964663863182, 0.36161550879478455, 0.1584072709083557, 0.4412776529788971),\n\tvec4(-0.1849367916584015, -0.06691668182611465, -0.34919920563697815, 0.052902668714523315),\n\tvec4(0.13673855364322662, -0.24724236130714417, 0.2702397108078003, -0.22348392009735107),\n\tvec4(0.2397686243057251, 0.14458820223808289, 0.2911008596420288, 0.037216003984212875),\n\tvec4(0.16205613315105438, 0.1009991392493248, 0.6204801201820374, 0.11335313320159912),\n\tvec4(-0.12317227572202682, -0.04732510447502136, -0.09278231114149094, 0.13098526000976562),\n\tvec4(-0.3431791663169861, -0.2214399129152298, -0.18123172223567963, -0.4590066075325012),\n\tvec4(0.0276027861982584, -0.008310848847031593, 0.07534404844045639, 0.3294362425804138),\n\tvec4(-0.012336988933384418, 0.034757424145936966, -0.5572577714920044, -0.058098599314689636),\n\tvec4(-0.13070601224899292, 0.11881179362535477, 0.3266357183456421, -0.28591230511665344),\n\tvec4(-0.3060476779937744, 0.321750670671463, -0.3849348723888397, -0.0620521642267704),\n\tvec4(0.05030734837055206, -0.2711825668811798, -0.9380037188529968, -0.10960806161165237),\n\tvec4(-0.556753396987915, -0.17171069979667664, -0.03429923579096794, -0.18739961087703705),\n\tvec4(-0.11825675517320633, 0.12565168738365173, 0.20211853086948395, 0.33675602078437805),\n\tvec4(0.11951204389333725, -0.13683655858039856, -0.01692276820540428, 0.09560199826955795),\n\tvec4(0.0657692700624466, 0.2125205248594284, -0.6089935302734375, 0.46052178740501404),\n\tvec4(0.03336253762245178, -0.09758325666189194, -0.018494321033358574, 0.376591295003891),\n\tvec4(0.16071845591068268, 0.1799294501543045, 0.3318322002887726, 0.04463391751050949),\n\tvec4(0.06520872563123703, -0.16506482660770416, -0.08943647891283035, -0.32505619525909424),\n\tvec4(-0.3389951288700104, -0.032935675233602524, -0.16094155609607697, 0.019675159826874733),\n\tvec4(0.29943954944610596, -0.37275025248527527, 0.01603631302714348, 0.057121641933918),\n\tvec4(-0.48435062170028687, 0.09849342703819275, 0.6285395622253418, 0.08341281116008759),\n\tvec4(0.39070093631744385, 0.3238602876663208, 0.5222282409667969, 0.5797969102859497),\n\tvec4(0.3724393844604492, 0.0017359682824462652, 0.2686236500740051, 0.3468661606311798),\n\tvec4(0.0788629800081253, 0.12884819507598877, -0.27676764130592346, 0.2375200092792511)\n);\nconst vec4 w_2_2[32] = vec4[](\n\tvec4(-0.09083900600671768, -0.03436143696308136, -0.010253646411001682, -0.2538769841194153),\n\tvec4(-0.07597954571247101, 0.09487072378396988, 0.3246866762638092, 0.3893001079559326),\n\tvec4(-0.5048752427101135, 0.44321125745773315, -0.4923749566078186, 0.6251081228256226),\n\tvec4(-0.4696123003959656, 0.252377986907959, -0.1304328292608261, -0.06132042035460472),\n\tvec4(-0.010297540575265884, 0.33586394786834717, -0.05479728430509567, -0.07642267644405365),\n\tvec4(0.2813761830329895, 0.07926914095878601, 0.27263322472572327, 0.015914086252450943),\n\tvec4(0.17652162909507751, -0.28039586544036865, 0.5533201098442078, 0.05450042337179184),\n\tvec4(0.07645071297883987, 0.005896959453821182, -0.007082079071551561, 0.4837227761745453),\n\tvec4(-0.16049718856811523, -0.12022138386964798, -0.16990751028060913, -0.18455389142036438),\n\tvec4(0.1699824035167694, -0.3796590268611908, -0.021827835589647293, -0.3145080804824829),\n\tvec4(0.24033892154693604, -0.03856869414448738, 0.241796612739563, 0.044951096177101135),\n\tvec4(0.1173672005534172, 0.12331268936395645, 0.06657026708126068, 0.344142347574234),\n\tvec4(-0.18714414536952972, -0.16369366645812988, 0.04559106007218361, -0.21609024703502655),\n\tvec4(-0.2774907946586609, -0.1459052711725235, -0.43860647082328796, -0.2890629470348358),\n\tvec4(-0.035422589629888535, 0.027100319042801857, -0.3260411024093628, 0.3885059058666229),\n\tvec4(-0.08766910433769226, 0.09819084405899048, -0.21131770312786102, -0.3235485553741455),\n\tvec4(0.16064098477363586, -0.0335710309445858, 0.045106157660484314, -0.2877141833305359),\n\tvec4(-0.2532411813735962, 0.15201625227928162, 0.19050967693328857, 0.27877360582351685),\n\tvec4(-0.14640693366527557, -0.189289852976799, -0.07588312029838562, -0.08265378326177597),\n\tvec4(-0.575516939163208, -0.18065305054187775, -0.25743868947029114, -0.30987632274627686),\n\tvec4(-0.15142247080802917, 0.13529132306575775, 0.13218176364898682, 0.3606337308883667),\n\tvec4(-0.17720748484134674, 0.019835812970995903, -0.1845952570438385, 0.447518914937973),\n\tvec4(0.061285264790058136, -0.16758345067501068, -0.2925735414028168, 0.20500688254833221),\n\tvec4(-0.21096061170101166, -0.0327313207089901, -0.6074069142341614, 0.5571749210357666),\n\tvec4(0.025941725820302963, 0.24479533731937408, 0.01622847095131874, -0.024185722693800926),\n\tvec4(0.021242456510663033, 0.15449488162994385, -0.3640671670436859, -0.4321761131286621),\n\tvec4(-0.3343014419078827, -0.03435175120830536, -0.48503294587135315, -0.14945003390312195),\n\tvec4(0.304019570350647, -0.09228600561618805, -0.5072930455207825, 0.1506909281015396),\n\tvec4(-0.24422669410705566, 0.051141638308763504, 0.07403036952018738, -0.03622252494096756),\n\tvec4(0.3832234740257263, 0.28199902176856995, 0.5500917434692383, 0.266115665435791),\n\tvec4(0.3368910849094391, 0.19642168283462524, 0.14275896549224854, 0.03142676129937172),\n\tvec4(0.18191273510456085, -0.09865880757570267, 0.18268807232379913, 0.32421377301216125)\n);\nconst vec4 w_2_3[32] = vec4[](\n\tvec4(-0.10535348206758499, 0.1353377401828766, -0.010799378156661987, -0.21228577196598053),\n\tvec4(0.04596361517906189, 0.2422359734773636, 0.2414679229259491, 0.01620003953576088),\n\tvec4(-0.307056725025177, 0.1478644758462906, 0.33245545625686646, 0.1801929771900177),\n\tvec4(-0.32803359627723694, 0.6270191669464111, -0.01332456711679697, 0.03760332614183426),\n\tvec4(-0.08460568636655807, 0.17588399350643158, 0.4180290997028351, 0.7674119472503662),\n\tvec4(0.17221692204475403, -0.12261030077934265, -0.05904315784573555, -0.08159001171588898),\n\tvec4(-0.2320430427789688, -0.2584429383277893, 0.2729819118976593, 0.14527851343154907),\n\tvec4(0.38028690218925476, 0.21646301448345184, 0.02925153635442257, 0.029453985393047333),\n\tvec4(-0.05852620676159859, -0.09883187711238861, 0.09309956431388855, -0.04073930159211159),\n\tvec4(-0.19524826109409332, 0.10211645811796188, 0.258828341960907, 0.10610412806272507),\n\tvec4(0.2595818042755127, -0.5132203698158264, 0.061009012162685394, 0.47924670577049255),\n\tvec4(0.6068280935287476, 0.16779044270515442, 0.10227327793836594, 0.2653036117553711),\n\tvec4(-0.3284819722175598, -0.13352976739406586, 0.2533598244190216, 0.09416817128658295),\n\tvec4(-0.13375870883464813, -0.1617247313261032, -0.4167962074279785, -0.3794688880443573),\n\tvec4(0.2571951746940613, 0.15461966395378113, 0.1745569258928299, 0.36414504051208496),\n\tvec4(-1.0696965456008911, 0.16334642469882965, -0.0488865040242672, -0.2532796561717987),\n\tvec4(0.24861067533493042, 0.197090744972229, 0.21139229834079742, 0.2633504867553711),\n\tvec4(-0.3990919888019562, 0.255205899477005, -0.5966312289237976, 0.09490682184696198),\n\tvec4(-0.4951583445072174, 0.4092043340206146, -0.21972107887268066, -0.23245634138584137),\n\tvec4(-0.06223174184560776, -0.7737266421318054, -0.02317054010927677, -0.19826123118400574),\n\tvec4(-0.0223102904856205, -0.7605137228965759, 0.08208303898572922, 0.06739374995231628),\n\tvec4(-0.37647512555122375, 0.1924852877855301, -0.19588004052639008, 0.4048490524291992),\n\tvec4(-0.3089450001716614, 0.056049808859825134, -0.11901150643825531, 0.1941937953233719),\n\tvec4(-0.1896928995847702, 0.011678438633680344, -0.49616721272468567, 0.05996403098106384),\n\tvec4(0.16805176436901093, -0.006640863139182329, -0.07065433263778687, -0.101331427693367),\n\tvec4(0.08248262107372284, 0.32309550046920776, -0.36004146933555603, -0.2868354618549347),\n\tvec4(-0.3669343888759613, -0.4648476243019104, -0.038881655782461166, -0.15280701220035553),\n\tvec4(0.47505098581314087, 0.16812124848365784, 0.2033618986606598, 0.31009718775749207),\n\tvec4(-0.329129159450531, -0.311128705739975, -0.053552787750959396, -0.2968076169490814),\n\tvec4(0.20147418975830078, 0.03855856508016586, 0.5874634981155396, 0.39544305205345154),\n\tvec4(0.10312782973051071, 0.19244062900543213, 0.3540077209472656, 0.4162082374095917),\n\tvec4(-0.44292521476745605, 0.006508379243314266, 0.22523069381713867, 0.3014708161354065)\n);\nconst vec4 w_3_0[32] = vec4[](\n\tvec4(-0.16593079268932343, 0.011023611761629581, -0.6203848123550415, -0.07952906936407089),\n\tvec4(0.22862842679023743, -0.41006672382354736, 0.11840001493692398, -0.05410953611135483),\n\tvec4(0.17272353172302246, -0.057455528527498245, 0.20193922519683838, -0.033412691205739975),\n\tvec4(-0.6528134346008301, 0.06339332461357117, 0.8856126070022583, 0.10267794877290726),\n\tvec4(0.18207475543022156, 0.44046056270599365, -0.3693094551563263, 0.15894313156604767),\n\tvec4(0.11119735240936279, 0.15203595161437988, -0.33525535464286804, 0.18926556408405304),\n\tvec4(0.11655578762292862, -0.006755404639989138, 0.07536941021680832, -0.29938411712646484),\n\tvec4(0.42571327090263367, -0.8102591037750244, 0.8530365824699402, 0.4024356007575989),\n\tvec4(0.12379640340805054, -0.1354416161775589, -0.12484697997570038, -0.06881734728813171),\n\tvec4(0.1846289187669754, -0.3606402277946472, -0.067730613052845, -0.20048463344573975),\n\tvec4(0.013061793521046638, 0.48583337664604187, 0.10124396532773972, 0.12084196507930756),\n\tvec4(0.7829976677894592, -0.1197369173169136, 0.4749193787574768, -0.40055975317955017),\n\tvec4(-0.3636549115180969, -1.0273774862289429, 0.5598539710044861, 0.21349653601646423),\n\tvec4(-0.35775309801101685, 0.3717177212238312, -0.2689809501171112, -0.11238135397434235),\n\tvec4(0.40181663632392883, -0.3858954906463623, 0.23541979491710663, 0.01449527032673359),\n\tvec4(-0.578259289264679, 0.35421523451805115, -0.3250252604484558, -0.3180219531059265),\n\tvec4(-0.24907895922660828, 0.2457318753004074, -0.3176252841949463, -0.02028321847319603),\n\tvec4(-0.10443122684955597, 0.14596156775951385, 0.28753146529197693, 0.18792793154716492),\n\tvec4(0.3037973940372467, 0.09419937431812286, 0.2742288112640381, 0.13375574350357056),\n\tvec4(0.549403190612793, -0.7169246673583984, -0.2221887707710266, -0.48125433921813965),\n\tvec4(0.1686045527458191, 0.35321760177612305, 0.1714124232530594, -0.044337786734104156),\n\tvec4(0.410940945148468, -0.06061774119734764, 0.6076441407203674, 0.2524493336677551),\n\tvec4(0.3895823359489441, -0.520643949508667, 0.07510769367218018, -0.48858481645584106),\n\tvec4(-0.055524591356515884, -0.9395156502723694, 0.4552344083786011, 0.01372410450130701),\n\tvec4(0.1854124516248703, 0.05522921681404114, -0.032573066651821136, -0.0565396323800087),\n\tvec4(-0.4347803294658661, 0.25217628479003906, -0.1982603371143341, -0.038775213062763214),\n\tvec4(0.40487784147262573, -0.14517804980278015, -0.11829813569784164, -0.1571483016014099),\n\tvec4(-0.043579112738370895, 0.30608415603637695, -0.3354586064815521, 0.012479009106755257),\n\tvec4(0.41355979442596436, -0.47499024868011475, -0.05242983624339104, -0.3414689600467682),\n\tvec4(0.7438462972640991, 0.17382942140102386, 0.1919778436422348, 0.1340930014848709),\n\tvec4(-0.281838983297348, 0.15833735466003418, -0.05560712516307831, 0.09316573292016983),\n\tvec4(-0.18701565265655518, -0.12215474992990494, 0.09492576867341995, 0.24398431181907654)\n);\nconst vec4 w_3_1[32] = vec4[](\n\tvec4(-0.49054858088493347, -0.41573578119277954, -0.20208823680877686, -0.2206457555294037),\n\tvec4(0.11506766080856323, 0.054407618939876556, 0.021706901490688324, -0.01484587136656046),\n\tvec4(0.17627310752868652, -0.3140197992324829, 0.44018492102622986, 0.09118625521659851),\n\tvec4(-0.14531010389328003, 0.10589763522148132, 0.2678365409374237, -0.10603035241365433),\n\tvec4(0.4162050187587738, -0.22318007051944733, 0.5177480578422546, 0.236203134059906),\n\tvec4(0.4526307284832001, 0.08452659845352173, -0.1710953265428543, -0.04980192333459854),\n\tvec4(0.25857698917388916, -0.19942288100719452, 0.20927104353904724, -0.20815657079219818),\n\tvec4(0.4969581663608551, 0.6752855181694031, -0.6702291965484619, 0.46246248483657837),\n\tvec4(0.025323472917079926, 0.11953320354223251, -0.16981178522109985, -0.17383067309856415),\n\tvec4(-0.10512296855449677, -0.05924813449382782, -0.6011344194412231, -0.4037921726703644),\n\tvec4(-0.02235584147274494, 0.30965226888656616, -0.6881632804870605, -0.4392685294151306),\n\tvec4(0.2012031525373459, -0.10081717371940613, 0.2413966953754425, -0.24184289574623108),\n\tvec4(0.43448716402053833, 0.09092488884925842, -0.13823042809963226, -0.17424044013023376),\n\tvec4(-0.6434321999549866, -0.2895045578479767, 0.03667225316166878, -0.1616242378950119),\n\tvec4(0.19814260303974152, -0.25583893060684204, 0.33792632818222046, 0.175745889544487),\n\tvec4(-0.1210428923368454, -0.05711197853088379, 0.06512726098299026, 0.013361603952944279),\n\tvec4(-0.32670095562934875, 0.24140562117099762, -0.37452268600463867, -0.2698633372783661),\n\tvec4(-0.23172315955162048, 0.18447649478912354, 0.3493810296058655, 0.16678906977176666),\n\tvec4(0.07158010452985764, -0.0852038785815239, -0.3295048773288727, 0.2112497091293335),\n\tvec4(-0.21689316630363464, -0.17675629258155823, -0.5910121202468872, -0.6174558997154236),\n\tvec4(0.46701911091804504, -0.17767783999443054, 0.6405462026596069, 0.16706188023090363),\n\tvec4(0.08282548189163208, -0.10042070597410202, -0.04316491261124611, -0.10650275647640228),\n\tvec4(0.41264116764068604, 0.2720673084259033, 0.1291828453540802, -0.36942481994628906),\n\tvec4(0.39140456914901733, -0.2081170380115509, 0.4656791687011719, -0.006133852060884237),\n\tvec4(-0.03378085419535637, 0.32558125257492065, -0.14779755473136902, -0.16352008283138275),\n\tvec4(-0.137075737118721, 0.0878094732761383, -0.2618068754673004, -0.4761379659175873),\n\tvec4(0.07545141875743866, 0.009421437047421932, -0.18379957973957062, -0.3601852059364319),\n\tvec4(0.12976385653018951, -0.23330554366111755, 0.10383184254169464, -0.20123982429504395),\n\tvec4(0.34874671697616577, -0.13183753192424774, 0.14632071554660797, -0.05375584587454796),\n\tvec4(0.6000800728797913, 0.4552956223487854, -0.07685375213623047, 0.37667539715766907),\n\tvec4(0.6068502068519592, -0.2955847382545471, 0.5931979417800903, 0.25421738624572754),\n\tvec4(0.10680199414491653, 0.2750597596168518, -0.004347018897533417, 0.07315332442522049)\n);\nconst vec4 w_3_2[32] = vec4[](\n\tvec4(-0.10146989673376083, -0.13725876808166504, -0.3709656596183777, -0.3842264413833618),\n\tvec4(0.4397093653678894, 0.053314611315727234, 0.250995010137558, -0.3358314633369446),\n\tvec4(0.44617828726768494, 0.2807195484638214, 0.2869078814983368, 0.17152999341487885),\n\tvec4(-0.4061581790447235, 0.26502493023872375, 0.45501935482025146, 0.3394899368286133),\n\tvec4(0.05309148132801056, -0.15148791670799255, 0.32493308186531067, 0.4688971936702728),\n\tvec4(0.06805730611085892, 0.0987987294793129, -0.06402746587991714, 0.057229045778512955),\n\tvec4(0.34229934215545654, -0.27565163373947144, -0.13649997115135193, -0.512467622756958),\n\tvec4(0.3569662868976593, -0.020619980990886688, 0.08573608100414276, 0.6886309385299683),\n\tvec4(-0.1348860114812851, -0.2578936517238617, 0.14159423112869263, -0.022437717765569687),\n\tvec4(-0.11725527048110962, -0.28024768829345703, -0.10393692553043365, -0.3045971393585205),\n\tvec4(-0.3075277507305145, -0.07147372514009476, -0.2845972776412964, 0.04326416552066803),\n\tvec4(0.38724803924560547, 0.15017345547676086, 0.20947964489459991, 0.08921916037797928),\n\tvec4(-0.13759486377239227, -0.4413367509841919, 0.3195410370826721, 0.2196791172027588),\n\tvec4(-0.22904561460018158, -0.2487860918045044, -0.1590280383825302, -0.1926998347043991),\n\tvec4(0.37506070733070374, -0.2117646187543869, 0.09563998878002167, 0.25391337275505066),\n\tvec4(-0.6377441883087158, 0.3971923589706421, -0.01814602129161358, -0.31762534379959106),\n\tvec4(-0.2703308165073395, 0.13292796909809113, -0.4253491759300232, -0.02011185884475708),\n\tvec4(0.10366165637969971, 0.22175787389278412, 0.4309168756008148, -0.12864889204502106),\n\tvec4(-0.11654245853424072, -0.14003781974315643, 0.39736464619636536, -0.04961385205388069),\n\tvec4(-0.2802361845970154, -0.5625867247581482, -0.3712545335292816, -0.3831569254398346),\n\tvec4(0.4578334391117096, -0.1729832887649536, -0.012746100313961506, 0.2791539430618286),\n\tvec4(0.40104591846466064, -0.2812899649143219, 0.7385886907577515, 0.13267360627651215),\n\tvec4(0.2658110558986664, -0.1430371254682541, 0.17424210906028748, -0.4464452564716339),\n\tvec4(0.4257237911224365, -0.000703355937730521, -0.06760037690401077, 0.044922977685928345),\n\tvec4(-0.33146557211875916, 0.2578269839286804, 0.09825132042169571, 0.2204243689775467),\n\tvec4(-0.4438104033470154, 0.4134370982646942, -0.20387624204158783, -0.07976935058832169),\n\tvec4(-0.05200659856200218, -0.0037501435726881027, -0.11876796931028366, -0.3554566204547882),\n\tvec4(0.4491429328918457, 0.06471654772758484, -0.28969287872314453, -0.0641021654009819),\n\tvec4(0.17894937098026276, -0.027965592220425606, 0.0046852887608110905, -0.04849855974316597),\n\tvec4(0.3201087415218353, 0.04398660734295845, 0.5755544304847717, 0.5556678771972656),\n\tvec4(0.15749825537204742, 0.2638905942440033, -0.1620505154132843, 0.215947687625885),\n\tvec4(0.5352358818054199, -0.1991308331489563, 0.19624608755111694, -0.24242639541625977)\n);\nconst vec4 w_3_3[32] = vec4[](\n\tvec4(-0.4370824098587036, 0.4787365198135376, -0.3661738932132721, -0.036764245480298996),\n\tvec4(0.3303346633911133, -0.15259939432144165, 0.19418084621429443, -0.18083785474300385),\n\tvec4(0.464304655790329, -0.6315142512321472, -0.232139453291893, -0.39835500717163086),\n\tvec4(0.10452291369438171, 0.14769607782363892, 0.271398663520813, 0.19223541021347046),\n\tvec4(0.4320681095123291, 0.12863771617412567, 0.023752959445118904, 0.21690179407596588),\n\tvec4(-0.2093338817358017, -0.16513192653656006, -0.2552860677242279, 0.1748950332403183),\n\tvec4(-0.017331445589661598, -0.5955259203910828, 0.493236780166626, 0.09526949375867844),\n\tvec4(-0.03628915548324585, 0.08956816047430038, 0.15957556664943695, 0.28059715032577515),\n\tvec4(0.013062693178653717, 0.153009295463562, -0.2705475986003876, -0.43243587017059326),\n\tvec4(-0.2712739408016205, 0.2874261140823364, -0.15562604367733002, -0.1644214689731598),\n\tvec4(0.42828598618507385, 0.07293826341629028, -0.440135657787323, -0.4138001501560211),\n\tvec4(0.8640583753585815, 0.5256885886192322, -0.3901989758014679, -0.8574315905570984),\n\tvec4(0.02731309086084366, -0.2167167216539383, 0.23701609671115875, 0.08917877078056335),\n\tvec4(-0.38043802976608276, -0.168742835521698, 0.1633913367986679, -0.13552123308181763),\n\tvec4(0.4221978783607483, 0.2658209502696991, 0.10550803691148758, -0.0075392574071884155),\n\tvec4(-0.9813312292098999, -0.22759287059307098, 0.30616259574890137, 0.03056900016963482),\n\tvec4(0.04242473840713501, 0.340482234954834, 0.21348731219768524, 0.1947861611843109),\n\tvec4(-0.2015904039144516, -0.07509837299585342, 0.5174529552459717, 0.21613560616970062),\n\tvec4(-0.5252804160118103, 0.41959288716316223, 0.15695662796497345, 0.4950896203517914),\n\tvec4(0.3280889093875885, -0.671566903591156, -0.5407716035842896, -0.8713679313659668),\n\tvec4(0.6513949632644653, -0.6938477158546448, 0.25933316349983215, -0.3261485695838928),\n\tvec4(0.41737961769104004, -0.2615545690059662, 0.5539501309394836, 0.591865599155426),\n\tvec4(0.10602609813213348, -0.6722841858863831, 0.7515464425086975, 0.21223624050617218),\n\tvec4(-0.24968676269054413, -0.6647537350654602, 0.039713554084300995, 0.06814827024936676),\n\tvec4(0.15061157941818237, 0.030192913487553596, -0.06776216626167297, 0.0969197228550911),\n\tvec4(-0.34417957067489624, 0.5789183974266052, -0.14003531634807587, 0.037830110639333725),\n\tvec4(0.4928510785102844, -0.4772508144378662, -0.1898738294839859, -0.4616145193576813),\n\tvec4(0.4778641164302826, 0.3959154188632965, 0.13328616321086884, -0.10286036133766174),\n\tvec4(-0.1276767998933792, -0.5187817811965942, 0.3053467273712158, -0.2608300447463989),\n\tvec4(0.4591118097305298, 0.5068616271018982, 0.16558586061000824, 0.012246576137840748),\n\tvec4(0.07589557766914368, 0.208505317568779, -0.10281681269407272, 0.22053037583827972),\n\tvec4(-0.029098404571413994, -0.2920481264591217, 0.053177595138549805, 0.001978958724066615)\n);\nconst vec4 bias[16] = vec4[](\n\tvec4(3.952667474746704, 4.549496173858643, 1.718981146812439, 3.7654049396514893),\n\tvec4(3.0262725353240967, 4.047941207885742, 2.4286460876464844, 4.244609355926514),\n\tvec4(3.5216100215911865, 4.095845699310303, 1.936773657798767, 3.82847261428833),\n\tvec4(4.470250129699707, 4.0579729080200195, 1.0022233724594116, 3.614830732345581),\n\tvec4(4.2238945960998535, 4.089755535125732, 2.484673500061035, 4.1648478507995605),\n\tvec4(2.9738776683807373, 3.7312822341918945, 6.193190574645996, 3.5141007900238037),\n\tvec4(2.46651029586792, 4.221577167510986, 4.643576622009277, 3.477309465408325),\n\tvec4(4.061845302581787, 3.264030933380127, 1.545353889465332, 4.556429386138916),\n\tvec4(4.100044250488281, 4.066854953765869, 2.3797767162323, 3.7055728435516357),\n\tvec4(1.9443563222885132, 3.2982265949249268, 2.6000728607177734, 2.3070950508117676),\n\tvec4(2.7780423164367676, 2.781252145767212, 4.066622257232666, 2.14840030670166),\n\tvec4(4.572075366973877, 3.0989444255828857, 1.719638705253601, 3.910543203353882),\n\tvec4(4.135692596435547, 4.68929386138916, 1.8788901567459106, 3.808687448501587),\n\tvec4(2.778428077697754, 2.042759656906128, 3.8968565464019775, 4.365801811218262),\n\tvec4(2.470492124557495, 2.306689739227295, 2.4713199138641357, 3.860605001449585),\n\tvec4(4.566259860992432, 3.9037649631500244, 1.35781729221344, 4.099223613739014)\n);\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXfDs.jpg", "access": "api", "license": "mit", "functions": [[1554, 1554, 1611, 1611, 2091]], "test": "untested"}
{"id": "wtXfDs", "name": "Game of life in two colors", "author": "vipiao", "description": "Game of life with a special rule added. If two parents are present, they may reproduce. See \"Buf A\" to change the settings.\nThe red life has the extra rule added, the green life does not have any extra rules.", "tags": ["2d", "gameoflife", "simluation"], "likes": 1, "viewed": 301, "published": 3, "date": "1598049274", "time_retrieved": "2024-07-30T20:49:42.830821", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// -SETTINGS-\n\n// The initial density of the life.\n# define INIT_DENSITY 0.1\n// Usually two parents is not enought to reproduce according to the vanilla rules.\n// Set the below define to \"0.\" if you want vanilla rules.\n// If the below define is higher, the walkers will be able to colonize.\n# define TWO_PARENT_REPRODUCE_CHANCE 0.0002\n\n// Noise function found at https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)); }\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 pC = texelFetch(iChannel0, ivec2(fragCoord), 0); // Previous color.\n    \n    if(iTime < 1.){ // Initialize with random noise.\n        float prob = float(hash(uvec2(fragCoord))) / 4294967295.;\n        bool alive = prob < INIT_DENSITY;\n    \tfragColor = vec4( alive, alive, 0, 1.0);\n        return;\n    }\n    \n    ivec2 myC = ivec2(fragCoord);\n    \n    // Game of life logic.\n    // Red logic.\n    bool redAlive;\n    int numNeighborsRed =\n\t\tint(texelFetch(iChannel0, myC + ivec2(-1, 1), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 0, 1), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 1, 1), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2(-1,0), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 1,0), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2(-1,-1), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 0,-1), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 1,-1), 0).x > 0.5)\n    ;\n    if(pC.x > 0.5){ // Is alive.\n        if(numNeighborsRed < 2){\n        \tredAlive = false;\n        } else if (numNeighborsRed < 4){\n        \tredAlive = true;\n        } else {\n        \tredAlive = false;\n        }\n    } else { // Is dead.\n    \tif(numNeighborsRed  == 3){\n        \tredAlive = true;\n        } else {\n        \tredAlive = false;\n        }\n        // Special rule.\n        float prob = float(hash(uvec2(fragCoord) + uvec2(iTime*60.))) / 4294967295.;\n        if(numNeighborsRed == 2 && prob < TWO_PARENT_REPRODUCE_CHANCE){\n        \tredAlive = true;\n        }\n    }\n    // Green logic.\n    bool greenAlive;\n    int numNeighborsGreen =\n\t\tint(texelFetch(iChannel0, myC + ivec2(-1, 1), 0).y > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 0, 1), 0).y > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 1, 1), 0).y > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2(-1,0), 0).y > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 1,0), 0).y > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2(-1,-1), 0).y > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 0,-1), 0).y > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 1,-1), 0).y > 0.5)\n    ;\n    if(pC.y > 0.5){ // Is alive.\n        if(numNeighborsGreen < 2){\n        \tgreenAlive = false;\n        } else if (numNeighborsGreen < 4){\n        \tgreenAlive = true;\n        } else {\n        \tgreenAlive = false;\n        }\n    } else { // Is dead.\n    \tif(numNeighborsGreen  == 3){\n        \tgreenAlive = true;\n        } else {\n        \tgreenAlive = false;\n        }\n    }\n    \n    fragColor = vec4(float(redAlive), float(greenAlive), 0.0, 1.0);\n}\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXfDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 168]], "test": "untested"}
{"id": "ttfBDs", "name": "Game of life with colonization!", "author": "vipiao", "description": "Game of life with a special rule added. If two parents are present, they may reproduce. See \"Buf A\" to change the settings.", "tags": ["2d", "gameoflife", "simluation"], "likes": 2, "viewed": 368, "published": 3, "date": "1598046689", "time_retrieved": "2024-07-30T20:49:43.597771", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// -SETTINGS-\n\n// The initial density of the life.\n# define INIT_DENSITY 0.03\n// Usually two parents is not enought to reproduce according to the vanilla rules.\n// Set the below define to \"0.\" if you want vanilla rules.\n// If the below define is higher, the walkers will be able to colonize.\n# define TWO_PARENT_REPRODUCE_CHANCE 0.0002\n\n// Noise function found at https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)); }\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 pC = texelFetch(iChannel0, ivec2(fragCoord), 0); // Previous color.\n    \n    if(iTime < 1.){ // Initialize with random noise.\n        float prob = float(hash(uvec2(fragCoord))) / 4294967295.;\n        bool alive = prob < INIT_DENSITY;\n    \tfragColor = vec4( alive, alive, alive, 1.0);\n        return;\n    }\n    \n    // Game of life logic.\n    ivec2 myC = ivec2(fragCoord);\n    bool alive;\n    int numNeighbors =\n\t\tint(texelFetch(iChannel0, myC + ivec2(-1, 1), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 0, 1), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 1, 1), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2(-1,0), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 1,0), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2(-1,-1), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 0,-1), 0).x > 0.5) +\n\t\tint(texelFetch(iChannel0, myC + ivec2( 1,-1), 0).x > 0.5)\n    ;\n    if(pC.x > 0.5){ // Is alive.\n        if(numNeighbors < 2){\n        \talive = false;\n        } else if (numNeighbors < 4){\n        \talive = true;\n        } else {\n        \talive = false;\n        }\n    } else { // Is dead.\n    \tif(numNeighbors  == 3){\n        \talive = true;\n        } else {\n        \talive = false;\n        }\n        // Special rule.\n        float prob = float(hash(uvec2(fragCoord) + uvec2(iTime*60.))) / 4294967295.;\n        if(numNeighbors == 2 && prob < TWO_PARENT_REPRODUCE_CHANCE){\n        \talive = true;\n        }\n    }\n    if(alive){\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }else{\n    \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 168]], "test": "untested"}
{"id": "3tsfDf", "name": "WaveTable", "author": "PsyPhi", "description": "Edited from rory618's https://www.shadertoy.com/view/4tdXR8. The idea is to use a limiting shape to create different cymatics.\n\nMouse X change view, Mouse Y change frequency. R resets, W turns off the generation of new waves, E removes restriction.\n", "tags": ["wave"], "likes": 4, "viewed": 409, "published": 3, "date": "1598045103", "time_retrieved": "2024-07-30T20:49:44.601088", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 w = texture(iChannel0, fragCoord.xy / iResolution.xy).xy;\n\tfragColor = vec4(w.x,-w.x,w.y*w.y*2.,1.);\n    fragColor = mix(fragColor,texture(iChannel1, fragCoord.xy / iResolution.xy),1.-iMouse.x/iResolution.x);\n    //fragColor = texture(iChannel2, fragCoord.xy / iResolution.xy); //views wavetable limits\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n    fragColor += .05;\n    fragColor /= (1.01+5.*abs(texture(iChannel0,fragCoord/iResolution.xy).y));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float KEY_R  = 82.5/256.0;\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_E  = 69.5/256.0;\n\nbool keyIsDown( float key ) {\n    return texture( iChannel1, vec2(key,0.25) ).x > .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    vec2 l = texture(iChannel0, (fragCoord-vec2(2.5,0))/iResolution.xy).xy;\n    vec2 r = texture(iChannel0, (fragCoord+vec2(2.5,0))/iResolution.xy).xy;\n    vec2 u = texture(iChannel0, (fragCoord-vec2(0,2.5))/iResolution.xy).xy;\n    vec2 d = texture(iChannel0, (fragCoord+vec2(0,2.5))/iResolution.xy).xy;\n    vec2 ur = texture(iChannel0, (fragCoord-vec2(2.5, 2.5))/iResolution.xy).xy;\n    vec2 ul = texture(iChannel0, (fragCoord-vec2(-2.5, 2.5))/iResolution.xy).xy;\n    vec2 dr = texture(iChannel0, (fragCoord-vec2(2.5, -2.5))/iResolution.xy).xy;\n    vec2 dl = texture(iChannel0, (fragCoord-vec2(-2.5, -2.5))/iResolution.xy).xy;\n    \n    vec2 t = texture(iChannel0, fragCoord/iResolution.xy).xy; //Contains last frame\n        \n    t = mix(t,(l+r+u+d)/4.,.01); // mixes lastframe with the 4 px around it.\n    t = mix(t,(ur+ul+dr+dl)/4.,.0075); // mixes lastframe with the 4 px around it.\n        \n\tfloat DL = l.x-t.x;  //diffrences left with the last frame?\n\tfloat DR = r.x-t.x;\n\tfloat DU = u.x-t.x;\n\tfloat DD = d.x-t.x;\n    float DUR = ur.x-t.x;\n    float DUL = ul.x-t.x;\n    float DDR = dr.x-t.x;\n    float DDL = dl.x-t.x;\n    \n    t.y += (DL+DR+DU+DD+DUR+DUL+DDR+DDL)/8.; //adds the diffrenced frames?\n    t.x += t.y;\n    //t.y *= .999;\t\t\t//reduces frame for FB loop\n    \n    float f = iMouse.y/40.;\t\t//Gets mouse y for frequency\n    if(iResolution.y < 285.){\n        f = 10.;\n    }\n    \n    if (keyIsDown(KEY_W) == false) { //Adds in new wave      \n    \tt = mix(t, vec2(sin(iTime*f), cos(iTime*f)), .5*exp(-.2*length(fragCoord-iResolution.xy/2.)));\n    }\n    \n    vec2 border = texture(iChannel2, fragCoord/iResolution.xy).xy; //adds in the custom border shape\n    \n    if(fragCoord.x<1. || fragCoord.y<1. || fragCoord.x>iResolution.x-1. || fragCoord.y>iResolution.y-1. || (border.x == 1.0 && keyIsDown(KEY_E)==false)){\n        t*=0.;\n    }\n    \n    if ( keyIsDown(KEY_R)) {\n        t *= 0.;\n    }\n    \n    \n    fragColor = vec4(t.x,t.y,0,1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat circle = step(0.25,distance(vec2(0.5),fragCoord/iResolution.xy));\n    fragColor = vec4(circle,circle,circle,1.0);\n}", "buffer_c_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 371]], "test": "untested"}
{"id": "wlffWs", "name": "Cos(x) as doubling formula", "author": "iq", "description": "Computing cos(x) as a series of angle doublings. Yellow, GLSL cos(x). Red, our cos(x). This is how I remember CPUs compute cos(x). More info, perhaps, here: [url]http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.302.9075&rep=rep1&type=pdf[/url]", "tags": ["cos", "cosine", "gpu"], "likes": 19, "viewed": 893, "published": 3, "date": "1598044744", "time_retrieved": "2024-07-30T20:49:45.572491", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing cos(x) like the CPUs do (iirc), using\n// the fact that cos(x) ≈ 1-x²/2 as initial guess\n// and cos(2x) = 2cos²(x)-1 to refine. Brought up\n// to me again partially by Walter Hacket IV.\n\n// Yellow, GLSL cos(x)\n// Red, doubling-formula cos(x)\n\n// 0: basic form,        6 iterations\n// 1: partial symmetrys, 3 iterations\n// 2: full symmetry,     2 iterations\n// 3: full symmetry,     2 iterations optimized\n// 4: full symmetry,     4 iterations optimized\n#define VERSION 0\n\nconst float kTau  = 6.2831853071;\nconst float kTau2 = 6.2831853071*0.5;\nconst float kTau4 = 6.2831853071*0.25;\nconst float kTau8 = 6.2831853071*0.125;\n\n#if VERSION==0\nfloat mcos( float x )\n{\n    x = mod(x,kTau);\n    \n    x /= 64.0;       // x = 𝛼/64\n    x = 0.5*x*x-1.0; // cos( x) ≈ 1-x²/2\n\n    x = 2.0*x*x-1.0; // cos(2x) = 2cos²(x)-1\n    x = 2.0*x*x-1.0; // cos(2x) = 2cos²(x)-1\n    x = 2.0*x*x-1.0; // cos(2x) = 2cos²(x)-1\n    x = 2.0*x*x-1.0; // cos(2x) = 2cos²(x)-1\n    x = 2.0*x*x-1.0; // cos(2x) = 2cos²(x)-1\n    x = 2.0*x*x-1.0; // cos(2x) = 2cos²(x)-1\n    \n    return x;\n}\n#endif\n\n#if VERSION==1\nfloat mcos( float x )\n{\n    x = mod(x,kTau);\n    \n    bool negx = x>kTau2; if( negx ) x = x-kTau2;\n    bool negy = x>kTau4; if( negy ) x = kTau2-x;\n    \n    x /= 8.0;        // x = 𝛼/8\n    x = 0.5*x*x-1.0; // cos( x) ≈ 1-x²/2\n    x = 2.0*x*x-1.0; // cos(2x) = 2cos²(x)-1\n    x = 2.0*x*x-1.0; // cos(2x) = 2cos²(x)-1\n    x = 2.0*x*x-1.0; // cos(2x) = 2cos²(x)-1\n\n    return (negx^^negy) ? -x : x;\n}\n#endif\n\n#if VERSION==2\nfloat mcos( float x )\n{\n    x = mod(x,kTau);\n    \n    bool negx = x>kTau2; if( negx ) x = x-kTau2;\n    bool negy = x>kTau4; if( negy ) x = kTau2-x;\n    bool negz = x>kTau8; if( negz ) x = kTau4-x;\n    \n    x /= 4.0;        // x = 𝛼/4\n    x = 0.5*x*x-1.0; // cos( x) ≈ 1-x²/2\n    x = 2.0*x*x-1.0; // cos(2x) = 2cos²(x)-1\n    x = 2.0*x*x-1.0; // cos(2x) = 2cos²(x)-1\n\n    if( negz )        x = sqrt(1.0-x*x);\n    if( negx ^^ negy) x = -x;\n    \n    return x;\n}\n#endif\n\n#if VERSION==3\nfloat mcos( float x )\n{\n    x = mod(x,kTau);\n    \n    bool negx = x>kTau2; if( negx ) x = x-kTau2;\n    bool negy = x>kTau4; if( negy ) x = kTau2-x;\n    bool negz = x>kTau8; if( negz ) x = kTau4-x;\n    \n    x = x*x;              // MUL\n    x = x*(1.0/32.0)-1.0; // MAD\n    x = x*x;              // MUL\n    x = x*x-x;            // MAD\n    x = 8.0*x+1.0;        // MAD\n\n    if( negz )        x = sqrt(1.0-x*x);\n    if( negx ^^ negy) x = -x;\n    \n    return x;\n}\n#endif\n\n#if VERSION==4\nfloat mcos( float x )\n{\n    x = mod(x,kTau);\n    \n    bool negx = x>kTau2; if( negx ) x = x-kTau2;\n    bool negy = x>kTau4; if( negy ) x = kTau2-x;\n    bool negz = x>kTau8; if( negz ) x = kTau4-x;\n    \n    x = x*x;               // MUL\n    x = x*(1.0/512.0)-1.0; // MAD\n    x = x*x;               // MUL\n    x = x*x-x;             // MAD\n    x = 8.0*x+1.0;         // MAD\n    x = x*x;               // MUL\n    x = x*x-x;             // MAD\n    x = 8.0*x+1.0;         // MAD\n\n    if( negz )        x = sqrt(1.0-x*x);\n    if( negx ^^ negy) x = -x;\n    \n    return x;\n}\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2  p = fragCoord/iResolution.y;\n    float px = 1.0/iResolution.y;\n\n    vec3 col = vec3( 0.2 );\n    \n    // cos, yellow\n    float y = 0.5+0.4*cos( 7.0*p.x );\n    float dy = dFdx(y)/px;\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0 - smoothstep( 0.0, 2.0*px, abs(p.y-y)/sqrt(1.0+dy*dy)) );\n        \n    // mcos, red\n    if( cos(iTime*kTau)>0.0 )\n    {\n    y = 0.5+0.4*mcos( 7.0*p.x );\n    dy = dFdx(y)/px;\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0 - smoothstep( 0.0, 2.0*px, abs(p.y-y)/sqrt(1.0+dy*dy) ) );\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffWs.jpg", "access": "api", "license": "mit", "functions": [[4161, 4161, 4218, 4218, 4776]], "test": "untested"}
{"id": "ttXBDs", "name": "Jupiter 2.0", "author": "michael0884", "description": "SPACE to restart\nRecommended to watch in 4x acceleration\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 17, "viewed": 630, "published": 3, "date": "1598043508", "time_retrieved": "2024-07-30T20:49:46.796219", "image_code": "// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n#define heightmap\n\nconst vec3 msat = vec3(.3,.3,.3);\nconst float msdiv = .12;\nvec3 saturate( vec3 v ) {\n  // https://www.shadertoy.com/view/Wtt3R8\n  float sv = dot(v,msat);\n  vec3 hs = v/sv*msdiv;\n  float ls = (1.-exp(-sv))*.9;\n  float s = 1.-exp(-sv*sv/10.);\n  vec3 hs2 = mix(hs,vec3(1),s);\n  return ls*hs2/mix(msdiv,1.,s);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.56\n#define RAD R.x*0.8\n\nvec3 toS(vec3 x)\n{\n    return vec3(atan(x.y,x.x), atan(x.z, length(x.xy)), length(x)); \n}\n\nvec3 toN(vec3 x)\n{\n    return x.z*vec3(cos(x.x)*sin(x.y), sin(x.x)*sin(x.y), cos(x.y));\n}\n    \nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 color(vec3 pos)\n{\n    vec3 sc = toS(pos);\n    vec2 uv = 3.*sc.xy*R/vec2(2.*PI, PI)+ R*0.5;\n\n    vec4 v = C(uv);\n    return texture(iChannel3, 3.*v.xy).xyz + 0.5*texture(iChannel2, 100.*v.xy).xyz;\n}\n\n\nfloat rho(vec3 pos)\n{\n    vec3 sc = toS(pos);\n     vec3 c =color(pos);\n    vec2 uv = 3.*sc.xy*R/vec2(2.*PI, PI) + R*0.5;\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(uv);\n   \n    return v.z + 0.*c.b;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float r = rho(pos);\n  \tfloat de = 1e5;\n    de = min(de, sdSphere(pos, 0.5*R.x+r*1.));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 0.2\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > 3.*R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(1. - 0.01*iTime, 0.)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4( 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n    angles.x += PI*0.1;\n        vec3 cam_pos = vec3(fp.xy , 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = c;\n\n            vec4 N0 = calcNormal(X.xyz, 20.*X.w)*vec4(1.,1.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colB = 0.12+ vec3(1.)*clamp(dot(n, normalize(vec3(1.))), 0., 1.);\n            colB += 2.0*pow(max(dot(rd, normalize(vec3(1.))), 0.), 3.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB;\n        }\n        else\n        {    \n            //background\n            col = vec4(0,0,0,1.);\n        }\n    col.xyz = saturate(1.3*col.xyz);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= 4.*r*texture(iChannel3, 3.*c.xy);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 1.15\n\n/* FIRE\n//mold stuff \n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 420.\n#define sense_oscil 0.1\n#define oscil_scale 1.\n#define oscil_pow 2.\n#define sense_force -0.35\n#define distance_scale 0.2\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n*/\n\n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 5.\n#define sense_oscil 0.0\n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force 0.\n#define distance_scale 0.\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.3*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/10.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/10.);\n        V += 0.3*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= 0.5*M*Rot(-3.*curl)*dgrad ;\n        F += vec2(1.,0.)*0.000*(V.x - 0.01);\n\n        float ang = atan(V.y, V.x);\n        float dang = sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n        slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/4.);\n        }\n        \n        //integrate velocity\n        V += F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor = C(pos - V0*dt);\n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy = pos/R;\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 522, 565, 745], [747, 747, 774, 774, 952], [992, 992, 1010, 1010, 1081], [1083, 1083, 1101, 1101, 1172], [1178, 1178, 1209, 1209, 1243], [1245, 1245, 1297, 1297, 1416], [1418, 1418, 1453, 1453, 1477], [1479, 1479, 1510, 1510, 1597], [1599, 1599, 1621, 1621, 1801], [1804, 1804, 1825, 1825, 2026], [2029, 2029, 2049, 2049, 2156], [2159, 2159, 2194, 2194, 2379], [2419, 2419, 2451, 2451, 2622], [2624, 2624, 2669, 2669, 5120]], "test": "untested"}
{"id": "wtXBWs", "name": "Stars to sphere morphing z", "author": "illus0r", "description": "Stars to sphere morphing", "tags": ["raymarching"], "likes": 3, "viewed": 287, "published": 3, "date": "1598038288", "time_retrieved": "2024-07-30T20:49:47.560176", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float radius) { return length(p) - radius; }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\n\n\n\n\nfloat sdCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRay (vec3 p) {\n  p.y -= 0.6;\n  p.x = -abs(p.x);\n  p.x -= 1.;\n  p.xy *= Rot(PI / 16.);\n  p.xz *= Rot(PI / 4.);\n  return sdBox(p, vec3(.81, .8, .8));\n}\n\n\nfloat sdStar(vec3 p) {\n  float r1, r2, r3, r4;\n  r1 = r2 = r3 = r4 = 1e10;\n  r1 = sdRay(p);\n  //p.x = abs(p.x);\n  //p.xy *= Rot(PI / 3.);\n  //p.xy *= Rot(PI / 3.);\n  //p.x = abs(p.x);\n  vec3 p2 = p;\n  p2.xy *= Rot(1.9106329);\n  r2 = sdRay(p2);\n  //p.xz *= Rot(1.9106329);\n  vec3 p3 = p;\n  p3.xz *= Rot(2. * PI / 3.);\n  p3.xy *= Rot(1.9106329);\n  r3 = sdRay(p3);\n  vec3 p4 = p;\n  p4.xz *= Rot(- 2. * PI / 3.);\n  p4.xy *= Rot(1.9106329);\n  r4 = sdRay(p4);\n  return min(min(r1, r2),min(r3, r4));\n}\n\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\nvec2 getDist(vec3 p) {\n  p.y += 0.2;\n  p.xz *= Rot(iTime);\n  float sphere = (length(p) - 1.5) * .5;\n  float fractal = sdStar(p);\n  float scale = 0.7;\n  vec3 shift = vec3(0, -1.5, 0);\n\n  for (int i = 0; i < 1; i ++) {\n    //p.xy *= Rot(PI / 3.);\n    //p.x = abs(p.x);\n    //p.xy *= Rot(PI / 3.);\n    //p.x = abs(p.x);\n    //p /= scale;\n    //p.xy *= Rot(PI / 3.);\n    //p.xz *= Rot(PI / (4. + 2. * sin(iTime))); // normally PI / 2.\n    //p += shift;\n    //fractal = min(fractal, sdStar(p) * pow(scale, (float(i + 1))));\n\n      float r0, r1, r2, r3, r4;\n      r0 = sdStar(p);\n      r1 = r2 = r3 = r4 = 1e10;\n\n      vec3 p1 = p;\n      p1 += shift;\n      p1 /= scale;\n      p1.xz *= Rot(PI / 3.);\n      r1 = sdStar(p1);\n      //p.x = abs(p.x);\n      //p.xy *= Rot(PI / 3.);\n      //p.xy *= Rot(PI / 3.);\n      //p.x = abs(p.x);\n      vec3 p2 = p;\n      p2.xy *= Rot(1.9106329);\n      p2 += shift;\n      p2 /= scale;\n      r2 = sdStar(p2);\n      //p.xz *= Rot(1.9106329);\n      vec3 p3 = p;\n      p3.xz *= Rot(2. * PI / 3.);\n      p3.xy *= Rot(1.9106329);\n      p3 += shift;\n      p3 /= scale;\n      r3 = sdStar(p3);\n      vec3 p4 = p;\n      p4.xz *= Rot(- 2. * PI / 3.);\n      p4.xy *= Rot(1.9106329);\n      p4 += shift;\n      p4 /= scale;\n      r4 = sdStar(p4);\n      fractal = min(min(min(r0, r1 * scale), r2 * scale),min(r3 * scale, r4 * scale));\n  }\n  return vec2(mix(fractal, sphere, 0.5 + 0.5 * sin(iTime * 1.)), 0.6);\n  //return vec2(sdStar(p), 0.6);\n}\n\n\n\n\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float distToClosestLight = 9999999.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        d += distToClosest.x;\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec2(d, info);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    // ray origin\n    vec3 ro = vec3(0, 0., -5.5);\n    float zoom = 1.100;\n    \n    // ray direction\n    vec3 rd = normalize(vec3(uv, zoom));\n    \n    vec2 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n    \n    float color_bw = 0.;\n    vec3 color = vec3(0.);\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(ro + rd * d);\n        n.zy *= Rot(iTime);\n    \tcolor = vec3( n + 1.0 );\n        color *= info;\n        //color_bw += 0.5 + dot(n, normalize(vec3(1,1,0))) / 2.;\n    }\n    //color = vec3( color_bw );\n    \n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 110, 110, 173], [175, 175, 213, 213, 242], [243, 243, 274, 274, 357], [362, 362, 408, 408, 515], [517, 517, 539, 539, 674], [677, 677, 699, 699, 1171], [1255, 1255, 1277, 1277, 2710], [2799, 2799, 2832, 2832, 3205], [3207, 3207, 3231, 3231, 3449], [3451, 3451, 3508, 3508, 4176]], "test": "untested"}
{"id": "WtXfWs", "name": "Fluid surface", "author": "michael0884", "description": "SPACE to restart\nRecommended to watch in 4x acceleration\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 24, "viewed": 1156, "published": 3, "date": "1598031986", "time_retrieved": "2024-07-30T20:49:48.582443", "image_code": "// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.56\n#define RAD R.x*0.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 3.*tanh(0.5*rho(pos));  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.05*iTime, -0.3)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = texture(iChannel3, c.xy).xyz;\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = 0.6*(vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 4.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 6.);\n            colB += 4.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 6.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.2*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(0.8*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= 4.*r*texture(iChannel3, c.xy);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 1.15\n\n/* FIRE\n//mold stuff \n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 420.\n#define sense_oscil 0.1\n#define oscil_scale 1.\n#define oscil_pow 2.\n#define sense_force -0.35\n#define distance_scale 0.2\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n*/\n\n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 5.\n#define sense_oscil 0.0\n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force 0.\n#define distance_scale 0.\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.3*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= 0.5*M*Rot(-2.5*curl)*dgrad ;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang = sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n        slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/4.);\n        }\n        \n        //integrate velocity\n        V += F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor = C(pos - V0*dt);\n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy = pos/R;\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXfWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[438, 438, 465, 465, 643], [683, 683, 714, 714, 748], [750, 750, 802, 802, 921], [923, 923, 958, 958, 982], [984, 984, 1015, 1015, 1102], [1104, 1104, 1125, 1125, 1218], [1220, 1220, 1242, 1242, 1338], [1341, 1341, 1361, 1361, 1566], [1569, 1569, 1604, 1604, 1789], [1828, 1828, 1860, 1860, 2028], [2030, 2030, 2075, 2075, 4848]], "test": "untested"}
{"id": "WtffDS", "name": "Reflective Block Wall", "author": "Shane", "description": "Using a basic multiple bounce template to render a simple reflective block wall.", "tags": ["reflection", "wall", "template", "block"], "likes": 28, "viewed": 892, "published": 3, "date": "1598021603", "time_retrieved": "2024-07-30T20:49:49.710429", "image_code": "/*\n\n\tReflective Block Wall\n\t---------------------\n\n\tThis is a reflective block wall that I coded up a while ago in order to\n\ttest multipass reflections. At the time, it was a little on the slow side,\n\tbut the real problem was compile time. However, I've noticed lately that \n    it runs and compiles fine. I've also employed some weird tricks that IQ \n    figured out to help the compiler out.\n\n    The distance field itself and resultant visuals are nothing exciting, but \n    it's simple to use and provides the basis for a lot of the stock imagery \n    you may have seen around. The stock imagery tends to be path traced by \n    skillful artists using things like Blender, but you get the general idea. \n    By the way, I intend to produce something along those lines at some stage.\n\n\tBy the way, I'm only using one bounce in this example, because more don't \n    really improve things enough to warrant the extra calculations. However, \n    this is a working, albeit run of the mill, multipass template. I have a \n    few reflective\\refractive examples that I'll post at some stage also.\n\n   \n    Other examples:\n\n\t// Simple and pretty.\n    Infinite Pinballs - BradyInstead\n\thttps://www.shadertoy.com/view/3ssfW8\n\n    // Elegant op art style -- I have things along these lines \n    // that I might post later.\n    Reflection of a stripy room - bencoder\n    https://www.shadertoy.com/view/wtyXRG\n\n*/\n\n// Far plane, or max ray distance.\n#define FAR 40.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n\n// Ray passes: For this example, just one intersection and one reflection.\n#define PASSES 2\n\n// Global block scale.\n#define GSCALE vec2(1./6.)*vec2(2, 1)\n\n// Block arrangement: Adjusts the cell offset for each row to give three different patterns.\n// 0 - No offset, 1 - Half cell offset, 2 - Quarter cell offset.\n#define ARRANGEMENT 1\n\n// Display the trimmings.\n#define SHOW_TRIMMINGS\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(1)); \n    n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D tex, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(tex, fract(p/4. + .5)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(iChannel1, p), vec3(.299, .587, .114)); }\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n// Hacked in at the last minute to differentiate between the block and\n// the metallic trimmings.\nfloat blockPartID;\n\nvec4 blocks(vec3 q){\n\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = GSCALE;//vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block central postions.\n    //const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    #if ARRANGEMENT == 0\n    // No X offset.\n    vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n    #elif ARRANGEMENT == 1\n    // Offset by half a cell width to produce a conventional brick pattern.\n    vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(1, -.5), vec2(0, -.5));\n    #else\n    // Offset by quarter a cell width to produce a staggered pattern.\n    vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5 + .5/2., -.5), vec2(-.5 + .5/2., -.5));\n    #endif\n    \n    float height = 0.; // Block height initialization.\n    \n    blockPartID = 0.; // Block part ID initialization.\n    \n    // Height scale.\n    const float hs = .125;\n\n\n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;// -  ps4[0]/2.;\n        \n        #if ARRANGEMENT == 2\n        // Moving each row a quarter of a cell width to produce a staggered pattern.\n        //cntr.x -= mod(floor((q.y/s.y - cntr.y)), 2.)/4.;\n        cntr.x -= floor((q.y/s.y - cntr.y))/4.;\n        #endif\n        \n        // Local coordinates.\n        p = q.xy;\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        // Correct positional individual tile ID.\n        vec2 idi = (ip + cntr)*s;\n        \n        p -= idi; // New local position.\n\n  \n        // Face block. \n        float h1 = hm(idi);\n        h1 = floor(h1*7.999)/7.; // Discreet heights.\n        h1 *= hs;\n        float face1 = sBoxS(p, dim/2. - .02*dim.x, .02);\n        float face1Ext = opExtrusion(face1, (-q.z - h1), h1, .005); \n\n        \n        #ifdef SHOW_TRIMMINGS\n        \n        // Cylinder center.\n        float face2Ext = opExtrusion(length(p) - .016, (-q.z - h1 - .008), h1 + .008, .005);\n        \n        // Trimming.\n        vec2 tr = vec2(face1 + .005/2., (-q.z - h1*2. - .005));\n        face2Ext = min(face2Ext, length(tr) - .005);\n        \n        // Face warp... I didn't like it, but I might revisit at some stage.\n        //face1Ext += -max(face1, -.02)*.4 + face1*.2;\n        \n        // Cell object ID.\n        float blPtID = face1Ext < face2Ext? 0. : 1.;\n        \n        // Minimum distance.\n        face1Ext = min(face1Ext, face2Ext);\n        #else\n        float blPtID = 0.;\n        #endif\n        \n        \n        \n        vec4 di = vec4(face1Ext, idi, h1);\n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box height. \n        if(di.x<d){\n            d = di.x;\n            id = di.yz;\n            height = di.w;\n            \n            blockPartID = blPtID;\n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, height);\n}\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    \n    // Reflecting the wall opposite to give the light something to relect off of.\n    p.z =  abs(p.z - .25) - .75;\n    \n    // Wall behind the pylons to stop the light getting through.\n    float wall = -p.z  + .01;\n    \n \n    // Blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n\n \n    // Overall object ID.\n    objID = wall<d4.x? 1. : 0.;\n    \n    // Combining the wall with the extruded blocks.\n    return min(wall, d4.x);\n \n}\n\n\n// Basic raymarcher.\nfloat trace(vec3 ro, vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(d*d<DELTA*DELTA || t>FAR) break; // Alternative: .001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.5 : d*.9; // Slower, but more accuracy.\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        //if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = 0; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n/*\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\nfloat fBm(vec3 p){\n    \n    return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n    \n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 3.;\n    p.x += iTime/2.;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c*c); // Bluish tinge.\n    \n    return mix(p, p.xzy, n3D2*.4); // Mixing in a bit of purple.\n\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\n    // Ray origin.\n\tvec3 ro = vec3(iTime/4. - .5*.3*cos(iTime/2.)*0., -.5*.2*sin(iTime/2.)*0., -.0); \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(.02, .01, .1);//vec3(0, -.25, iTime);  \n \n    // Light positioning.\n \tvec3 lp = ro + vec3(-.5, 1, .25); // Put near the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0);\n    \n   \n    \n    float alpha = 1.;\n    \n    for(int j = 0; j<PASSES; j++){\n        \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        // Used for refractions, but not here.    \n        //float distanceFactor = 1.;\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd);\n\n        // Saving the object ID, block ID and cell object (block part) ID.\n        float svObjID = objID;\n        vec3 svGID = gID;\n        float svBPID = blockPartID;\n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n\n            // Surface normal.\n            vec3 sn = getNormal(sp);// *distanceFactor; // For refractions.\n            \n            // Texture size factor.\n            float sz0 = 2.;\n           \n            /* \n            // Integrating bump mapping -- Not used here. It's possible\n            // to bump map on a pass by pass basis to save cycles.\n            vec3 smSn = sn;\n            sn = texBump(iChannel0, sp*sz0, sn, .0007);///(1. + t/FAR)\n            vec3 reflection = reflect(rd, normalize(mix(smSn, sn, .35)));\n            */\n            \n            // The reflective ray, which tends to be very helpful when\n            // calculating reflections. :)\n            vec3 reflection = reflect(rd, sn);\n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            if(j == 0) gSh = softShadow(sp, lp, sn, 12.);\n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            float sh = min(gSh + ao*.25, 1.); // Adding a touch of light to the shadow.\n            \n\n            float att = 1./(1. + lDist*lDist*.025); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 32.);\n            float fre = clamp(1. + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n            \n            dif = pow(dif, 4.)*2.; // Ramping up the diffuse.\n\n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n\n      \n            // Object color.\n            vec3 oCol;\n            \n             \n            if(svObjID == 0.) {\n\n                // Block coloring.\n                vec3 tx = tex3D(iChannel0, sp*sz0, sn);\n                vec3 tx2 = getTex(iChannel1, svGID.xy);\n                tx = smoothstep(0., .5, tx);\n                tx2 = smoothstep(0., .5, tx2);\n                \n                if(svBPID == 1.) {\n                    // Trimming coloring and reflective power.\n                    oCol = tx*vec3(1, .9, .7);\n                    objRef = .35;\n                    \n                }\n                else {\n                    // Face coloring and reflective power.\n                    oCol = tx2*tx*2.5;\n                \tobjRef = .25;\n                }\n                \n                /*\n                // Edge coloring, but has been replaced by trimming.\n                // Needs to match the box function inside the distance field.\n                const vec2 scale = GSCALE;\n                float fdf = sBoxS(sp.xy - svGID.xy, scale/2. - .02*scale, .02);\n                 \n                // The ring that surrounds the face edges.\n                const float th = .0025;\n                float fdfR = max(abs(fdf + th/2.), abs((sp.z + svGID.z*2.) - 1.)) - th;// \n                oCol = mix(oCol, vec3(0), (1. - smoothstep(0., .01, fdfR))*.25);\n                */\n                \n            }\n            else {\n                // Dark wall behind the tiny gaps in the blocks. \n                oCol = vec3(0);\n                objRef = .0;\n            }\n\n            colL = oCol*(dif + .125 + vec3(1, .5, .3)*spe*4. + vec3(1, .4, .2)*pow(freS, 4.)*0.);\n            \n            // Optional environmental mapping. Not used.\n            //vec3 envCol = envMap(reflect(rd, sn)).zyx;\n            //colL += colL*envCol*3.;\n            \n            colL *= sh*ao*att;\n\n            // Used for refraction, but not used here.\n            //if(distanceFactor<0.)  colL *= exp(-colL*t*5.);\n            \n            \n            // Set the unit direction ray to the new reflected direction, and bump the \n            // ray off of the hit point by a fraction of the normal distance. Anyone who's\n            // been doing this for a while knows that you need to do this to stop self\n            // intersection with the current launch surface from occurring... It used to \n            // bring me unstuck all the time. I'd spend hours trying to figure out why my\n            // reflections weren't working. :)\n            rd = reflection;\n            sp += sn*DELTA*1.1;\n\n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        float td = length(sp - cam); \n        vec3 fogCol = vec3(0);\n        colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n      \n        // This is a more subtle way to blend layers. \n        col = mix(col, colL, 1./float(1 + j)*alpha);\n        // In you face additive blend. Sometimes, I prefer this.\n        //col += colL*alpha;\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break.\n        if(objRef < .001 || t >= FAR) break;\n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n    }\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtffDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2003, 2036, 2058, 2058, 2116], [2118, 2146, 2167, 2167, 2230], [2233, 2313, 2359, 2359, 2969], [2972, 3219, 3254, 3631, 3737], [3739, 3803, 3823, 3823, 3883], [3885, 3912, 3982, 4035, 4140], [4279, 4307, 4354, 4354, 4439], [7857, 7880, 7898, 7990, 8367], [8370, 8391, 8421, 8470, 8962], [8965, 9156, 9208, 9325, 10642], [10645, 10797, 10832, 10832, 11218], [14373, 14373, 14429, 14462, 22043]], "test": "untested"}
{"id": "3tfBWs", "name": "2D Ring planet", "author": "z0rg", "description": "I love space :)", "tags": ["2d", "planet", "scifi"], "likes": 9, "viewed": 362, "published": 3, "date": "1598012647", "time_retrieved": "2024-07-30T20:49:50.733692", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\n\nfloat cir(vec2 p,float r)\n{\n  return length(p)-r;\n}\n\nfloat sub(float a, float b)\n{\n  return max(a,-b);\n}\n\nvec3 rdr(vec2 uv)\n{\n  uv*= r2d(1.);\n  vec3 col;\n\n  float stars= texture(iChannel0,uv*2.).x;\n  col = vec3(stars)*float(stars>.97);\n  vec2 ruv = uv*vec2(.8,3.7);\n  vec2 rp = ruv-vec2(0.,.08);\n  float ring = sub(cir(ruv, .6),cir(rp,.35));\n\n\n  float ringOp = mix(.2,1.,sat(abs(uv.x*(sat(uv.y*10.)+.3))-.3));\n  float back = sub(ring, uv.y);\n  float front = sub(ring,-uv.y);\n  float ringPatt = sat(.5*sin(2.+200.*length(rp))+sin(1.+300.*length(rp)));\n  col = mix(col,vec3(ringOp),(1.-sat(back*200.))*ringPatt);\n  float planet = cir(uv,.3);\n  col = mix(col,vec3(.45,.34,.56)*(.3+1.-sat(length(2.*uv-vec2(-.1,.1)*5.))),1.-sat(planet*200.));\n  col = mix(col,vec3(ringOp),(1.-sat(front*200.))*ringPatt);\n  return col;\n}\nvec3 grid(vec2 uv)\n{\n  vec2 r = clamp(mod(uv,vec2(.25))-vec2(.001),vec2(0.),vec2(1.));\n  return vec3(.5)*(1.-sat(200.*(min(r.x,r.y))))*(.5+.5*sin(uv.y*500.))\n  *(.5+.5*sin(uv.x*500.))*(sat(length(uv)-.4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.xx;\n\n  uv *=vec2(-1.,1.)*2.3;\n  uv -= vec2(.15, -0.07);\n  vec3 col = rdr(uv);\n  float sz = 0.1;\n\n  vec3 col2 = rdr(vec2(float(int(uv.x/sz)),float(int(uv.y/sz)))*sz);\n\n col= mix(col,col2, sat(length(uv)*float(length(uv) < 1.)));\n  col+= 1.2*vec3(.34,.56,.87)*sat(1.-length(1.*uv-vec2(-.1,.1)*2.));\ncol+= .5*vec3(.34,.56,.87).zyx*sat(1.-length(3.*uv-vec2(-.1,.1)*2.));\n\ncol += texture(iChannel0,uv+iTime*50.).xxx*.1;\ncol += grid(uv);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfBWs.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 415, 415, 490], [492, 492, 512, 512, 539], [541, 541, 568, 568, 592], [594, 594, 623, 623, 645], [647, 647, 666, 666, 1356], [1357, 1357, 1377, 1377, 1564], [1566, 1566, 1623, 1623, 2146]], "test": "untested"}
{"id": "wllBW2", "name": "18. Mandelbrot fractal", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=kY7liQVPQSc\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect\n", "tags": ["simplebuff"], "likes": 0, "viewed": 271, "published": 3, "date": "1597976387", "time_retrieved": "2024-07-30T20:49:51.501638", "image_code": "vec2 rot(vec2 p, vec2 pivot, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\tp -= pivot;\n\tp = vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n\tp += pivot;\n\n\treturn p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy )/iResolution.y;\n\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    float angle = mix( -3.1415 , 3.1415 , m.x );\n    float scale = mix( 3.0f , 0.1f , m.y );\n    \n    \n    vec2 c = /* _Area.xy + */ (uv ) *scale;\n    c = rot(c, vec2(0), angle);\n    \n    \n\n    vec2 z;\n\t\t\t\t\n    float iter;\n    for (iter = 0.0; iter < 255.0; iter++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n\n        if (length(z) > 2.0)\n            break;\n    }\n\t\t\t\t\n    \n    // Output to screen\n    fragColor = vec4( vec3(iter / 255.0f) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 179], [182, 182, 239, 289, 875]], "test": "untested"}
{"id": "tlsfWf", "name": "17. Using Polar Coordinates _ Op", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=r1UOB8NVE8I\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect\n\nI understand it ! ", "tags": ["usingpolarcoordinates"], "likes": 2, "viewed": 279, "published": 3, "date": "1597971453", "time_retrieved": "2024-07-30T20:49:52.394252", "image_code": "void mainImage( out vec4 O, vec2 u )\n{ \n    vec2  R = iResolution.xy,\n          U = u - .5 *R;\n    \n    float l = length(U)/R.y,\n          a = atan(U.x , U.y ),\n          s = 8.*( a/6.2831  + iTime*.1 + l*2. );\n    \n    float m = min( fract(s) , fract(1.-s) ),\n          v = m * .3 + .1 - l;\n\n    O = vec4(smoothstep( -.7, .7 , v/fwidth(v) ) );\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 347]], "test": "untested"}
{"id": "ttsBW2", "name": "19. Calculating Ray-Sphere", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=HFPlKQGChpE\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect\n", "tags": ["simplebuff"], "likes": 1, "viewed": 270, "published": 3, "date": "1597969970", "time_retrieved": "2024-07-30T20:49:53.539190", "image_code": "float remap01( float a , float b , float t ) {\n\treturn ( t - a ) / ( b - a );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - 0.5 * iResolution.xy ) / iResolution.y;\n\n    \n    vec3 col =vec3(0);\n    \n    \n    vec3 ro = vec3(0);\n    vec3 rd = normalize( vec3( uv.x , uv.y , 1 ) );\n    \n    vec3 s = vec3( 0 , 0 , 3);\n    \n    float radius = 1.0;\n    float t = dot( s - ro , rd );\n    vec3 p = ro + rd * t ;\n    \n    \n    float y = length( s - p );\n    \n    if ( y < radius ) {\n    \tfloat x = sqrt( radius * radius - y * y  );\n    \tfloat t1 = t - x ;\n    \tfloat t2 = t + x;\n        \n        float c = remap01(s.z , s.z  - radius, t1 );\n        col = vec3(c);\n    }\n    \n    \n    \n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 82], [84, 84, 141, 141, 760]], "test": "untested"}
{"id": "WlsBW2", "name": "rounded pixels 2", "author": "sympou", "description": "another attempt !\n", "tags": ["roundpixels"], "likes": 12, "viewed": 358, "published": 3, "date": "1597967304", "time_retrieved": "2024-07-30T20:49:54.400886", "image_code": "//thanks FabriceNeyret2 for optimisations !\n\nfloat pixSize = 15.;\n\n#define lum(pix) dot( pix, vec4(.3,.59,.11,0) )  //luminance\n#define T(x,y)   texture( iChannel0, uv2 + vec2(x,y) )        \n\nvoid mainImage( out vec4 O,  vec2 u ) {\n\n    vec2 R = iResolution.xy,\n         U = u / pixSize,\n       div = pixSize / R,\n       uv2 = floor(U)*div,\n      diff = fract(U);\n\t\n    //checkerboard pattern : half of the pixels are not changed\n    if (fract( dot(floor(U),vec2(.5)) ) < .5) \n        { O = T(0,0); return; }\n\n    // neighbors\n\tvec4[4] pix = vec4[4]( T( 0,     div.y),\n                           T( div.x, 0    ),\n                           T( 0,    -div.y),\n                           T(-div.x, 0    ) );\n    \n    //where is the biggest contrast ?   \n    int comp = int (  abs( lum(pix[0]) - lum(pix[2]) )\n                    > abs( lum(pix[1]) - lum(pix[3]) ) );\n    vec2   d = abs(diff-.5) - vec2(1-comp,comp); // offset = 0,1 or 1,0\n    ivec2  v = ivec2( vec2(3.5,2.5) - diff*2. );\n   \n    O = dot(d,d) < .5 \n        ? pix[ v[comp] ]                                 // 2 circles on the borders\n        : mix( pix[comp+2], pix[comp] , diff[1-comp] );  // a gradient in between        \n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wtlBWf", "name": "color palette forcer", "author": "thefox231", "description": "i specifically made it easily editable\nmouse to control dither threshold", "tags": ["post", "color", "palette"], "likes": 1, "viewed": 373, "published": 3, "date": "1597964706", "time_retrieved": "2024-07-30T20:49:55.259591", "image_code": "#define ditherThreshold iMouse.x / iResolution.x\n\n// https://coolors.co/\nconst int colorsSize = 7;\nvec3 colors[colorsSize] = vec3[](\n    // trans\n    vec3(91, 206, 250),\n    vec3(245, 169, 184),\n    vec3(255, 255, 255),\n    // enby\n    vec3(240, 183, 25),\n    vec3(252, 236, 217),\n    vec3(181, 84, 192),\n    vec3(56, 41, 36)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    for (int i = 0; i < colorsSize; i++) {\n        colors[i] = colors[i] / 255.;\n        //colors[i] = colors[i] * (sin(iTime + float(i)) * 0.5 + 1.0);\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 col = texture(iChannel0, uv).rgb;\n    \n    // comparasion\n    float mDist[colorsSize];\n    float minDist = 9999.9;\n    int mIndex = 0;\n    int mOldIndex;\n    \n    for (int i = 0; i < colorsSize; i++) {\n        vec3 compareCol = colors[i];\n        \n        vec3 distVec = abs(col - compareCol);\n        float dist = (distVec.r + distVec.g + distVec.b) / 3.0;\n        \n        mDist[i] = dist;\n        if (dist < minDist) {\n            mOldIndex = mIndex; // terrible\n            mIndex = i;\n            minDist = dist;\n        }\n    }\n    \n    // dithering (worst possible way to do it)\n    \n    vec3 col1 = colors[mIndex];\n    vec3 col2 = colors[mOldIndex];\n    float dist1 = mDist[mIndex];\n    float dist2 = mDist[mOldIndex];\n    \n    col = col1;\n    if ((dist2 - dist1) <= ditherThreshold && mod(fragCoord.x + fragCoord.y, 2.) == 0.) col = col2;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[330, 330, 385, 385, 1480]], "test": "untested"}
{"id": "wtsBDX", "name": "Cube experiments z", "author": "illus0r", "description": "Cube experiments z", "tags": ["raymarching"], "likes": 3, "viewed": 275, "published": 3, "date": "1597956527", "time_retrieved": "2024-07-30T20:49:56.040502", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float radius) { return length(p) - radius; }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\n\n\n\n\nfloat sdCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\nvec2 getDist(vec3 p) {\n    \n    //p.x += -0.8;\n    p.xz *= Rot(iTime * 2.);\n    float scale = 0.4 + 0.1 * sin(iTime);\n\tvec2 box = vec2(1e10, 1.);\n    \n    for (float i = 0.; i < 5.; i++) {\n        vec2 box2 = vec2( sdBox(p, vec3(1)) * pow(scale, i), 0.5 + i / 5. );\n        box = box.x < box2.x ? box : box2;\n        p = abs(p);\n        p -= 1.;\n\t    p.xz *= Rot(iTime);\n        p /= scale;\n    }\n    \n    return box;\n}\n\n\n\n\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float distToClosestLight = 9999999.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        d += distToClosest.x;\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec2(d, info);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    // ray origin\n    vec3 ro = vec3(0, 0., -5.5);\n    float zoom = 1.100;\n    \n    // ray direction\n    vec3 rd = normalize(vec3(uv, zoom));\n    \n    vec2 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n    \n    float color_bw = 0.;\n    vec3 color = vec3(0.);\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(ro + rd * d);\n        n.zy *= Rot(iTime);\n    \tcolor = vec3( n + 1.0 );\n        color *= info;\n        //color_bw += 0.5 + dot(n, normalize(vec3(1,1,0))) / 2.;\n    }\n    //color = vec3( color_bw );\n    \n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsBDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 110, 110, 173], [175, 175, 213, 213, 242], [243, 243, 274, 274, 357], [362, 362, 408, 408, 515], [598, 598, 620, 644, 1017], [1106, 1106, 1139, 1139, 1512], [1514, 1514, 1538, 1538, 1756], [1758, 1758, 1815, 1815, 2483]], "test": "untested"}
{"id": "WtlfDf", "name": "GAN. Neural network. MNIST", "author": "Pidhorskyi", "description": "MNIST generator. Trained on digit \"3\"\n\nz - normal 32\ndense layer, in: 32, out: 64\nreshape to 4, 4, 4\nupscale 2x\nconv2d, k3x3, in 4, out 4\nrelu\nupscale 2x\nconv2d, k3x3, in 4, out 4\nrelu\nupscale 2x\nconv2d, k3x3, in 4, out 4\nrelu\nconv2d 1x1, in 4, out 1", "tags": ["neuralnetwork", "cnn", "gan"], "likes": 30, "viewed": 1281, "published": 3, "date": "1597949499", "time_retrieved": "2024-07-30T20:49:57.378924", "image_code": "// The MIT License\n// Copyright © 2020 Stanislav Pidhorskyi\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// MNIST generator. Trained on digit \"3\"\n\n// Generator network:\n// input: z - sampled from normal distibution, 32\n// dense layer, in: 32, out: 64\n// reshape to 4, 4, 4\n// upscale 2x\n// conv2d, kernel 3x3, in channels 4, out channels 4\n// relu\n// upscale 2x\n// conv2d, kernel 3x3, in channels 4, out channels 4\n// relu\n// upscale 2x\n// conv2d, kernel 3x3, in channels 4, out channels 4\n// relu\n// conv2d, kernel 1x1, in channels 4, out channels 1\n\nconst vec4 w[9 * 4] = vec4[](\n\tvec4(-0.024494990706443787, 0.13797150552272797, -0.4518258273601532, -1.0707980394363403),\n\tvec4(0.3303457200527191, -0.05810055136680603, -0.32043275237083435, -0.6846339106559753),\n\tvec4(-0.0862407460808754, 0.35923194885253906, -0.03228416293859482, -0.38374972343444824),\n\tvec4(0.20959722995758057, 0.16346868872642517, -0.09902563691139221, -0.8471614718437195),\n\tvec4(-0.21756859123706818, 0.05122293904423714, -0.03655684366822243, -0.4245859682559967),\n\tvec4(-0.4408448338508606, 0.20764416456222534, -0.5653907060623169, -0.7930201888084412),\n\tvec4(0.23111091554164886, -0.036927320063114166, -0.7440452575683594, -0.7955689430236816),\n\tvec4(-0.23199181258678436, 0.20291434228420258, -0.05158574879169464, -1.1556941270828247),\n\tvec4(0.1413290798664093, -0.10961094498634338, -0.5548838973045349, -0.8571651577949524),\n\tvec4(0.11625737696886063, 0.19126850366592407, -0.4459626078605652, -0.29835256934165955),\n\tvec4(0.2143522948026657, 0.08210130780935287, -0.4131932258605957, -0.7998138666152954),\n\tvec4(0.2107246071100235, -0.029145551845431328, -0.7155445218086243, -1.2794129848480225),\n\tvec4(-0.13504835963249207, -0.07993811368942261, -0.5405737161636353, -0.43502768874168396),\n\tvec4(0.27811408042907715, 0.07959428429603577, -0.44538602232933044, -0.6937538981437683),\n\tvec4(0.005557582713663578, -0.4853628873825073, -0.6425027847290039, -0.6175607442855835),\n\tvec4(0.1145184189081192, 0.3352356255054474, -0.10300403088331223, -0.8240402340888977),\n\tvec4(0.3449415862560272, -0.24279482662677765, -0.6074551343917847, -0.6195687651634216),\n\tvec4(0.010662197135388851, -0.29678788781166077, 0.053943052887916565, 0.08415284007787704),\n\tvec4(0.011185652576386929, 0.1603759080171585, 0.00435921223834157, -0.2829529643058777),\n\tvec4(-0.08160797506570816, -0.15574781596660614, 0.26531320810317993, 0.21747258305549622),\n\tvec4(-0.042008791118860245, 0.30044421553611755, 0.33261990547180176, 0.906450629234314),\n\tvec4(-0.10267450660467148, 0.2044444978237152, 0.3103695511817932, 0.2981647253036499),\n\tvec4(-0.21138626337051392, 0.17790208756923676, 0.4167972505092621, 0.7291038036346436),\n\tvec4(-0.3782545030117035, 0.23314841091632843, 0.4160531461238861, 0.5941839814186096),\n\tvec4(-0.03573038429021835, -0.22596265375614166, -0.025361360982060432, 0.146229550242424),\n\tvec4(-0.27535924315452576, -0.014716265723109245, 0.32668349146842957, 0.12027578800916672),\n\tvec4(0.15577393770217896, 0.2156430184841156, 0.05770532786846161, 0.09310895949602127),\n\tvec4(-0.0929451659321785, 0.16986797749996185, -0.06222357600927353, -0.09984632581472397),\n\tvec4(0.18723906576633453, -0.022518593817949295, -0.4249107539653778, -0.4154057204723358),\n\tvec4(-0.052339665591716766, -0.1076534166932106, -0.17764200270175934, -1.0057419538497925),\n\tvec4(0.3960712254047394, -0.22007837891578674, -0.2751689851284027, -0.7713678479194641),\n\tvec4(0.04963929206132889, 0.020937848836183548, -0.44171684980392456, -1.08183753490448),\n\tvec4(0.2802867591381073, -0.28723862767219543, -0.7151980400085449, -1.19139564037323),\n\tvec4(0.08218887448310852, 0.3119456171989441, -0.39301425218582153, -0.3798830509185791),\n\tvec4(0.1573500633239746, 0.18470726907253265, -0.22834360599517822, -0.6026148796081543),\n\tvec4(-0.19978363811969757, 0.07486321032047272, -0.467891663312912, -0.6961656212806702)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragCoord.y = iResolution.y - fragCoord.y;\n    if (any(greaterThan(ivec2(fragCoord), ivec2(iResolution))))\n    {\n        fragColor = vec4(0.5);\n    \treturn;\n    }\n    \n    vec4 x = conv2d(ivec2(fragCoord), iChannel0, w, 2);\n\n    //relu\n    x = max(x, 0.2 * x);\n    \n    //to grayscale, 1x1 convolution\n\tfragColor = vec4(vec3(dot(x, vec4(-0.03209521621465683, 0.02390575408935547, 0.014942913316190243, 0.0484737791121006))-0.00017798514454625547), 1.0);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The MIT License\n// Copyright © 2020 Stanislav Pidhorskyi\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nvec4 conv2d(in ivec2 in_coord, in sampler2D b, in vec4[9 * 4] w, int upscale)\n{\n    vec4 x = vec4(0.0);\n    for (int c = 0; c < 4; ++c)\n    {\n        float _x = 0.0;\n    \tfor (int j = 0; j < 3; ++j)\n        {\n    \t\tfor (int i = 0; i < 3; ++i)\n            {\n                ivec2 coord = in_coord + ivec2(j-1, i-1);\n            \t_x += dot(w[9 * c + j + i * 3], texelFetch(b, coord / upscale, 0));\n        \t}\n        }\n        x[c] = _x;\n    }\n    return x;\n}\n\nfloat hash1( vec2 p )\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);  \n}\n\n// Taken from https://www.shadertoy.com/view/MlVSzw\nconst float ALPHA = 0.14;\nconst float INV_ALPHA = 1.0 / ALPHA;\nconst float PI = 3.1415926535;\nconst float K = 2.0 / (PI * ALPHA);\n\nfloat inv_error_function(float x)\n{\n\tfloat y = log(1.0 - x*x);\n\tfloat z = K + 0.5 * y;\n\treturn sqrt(sqrt(z*z - y * INV_ALPHA) - z) * sign(x);\n}\n", "buffer_b_code": "// The MIT License\n// Copyright © 2020 Stanislav Pidhorskyi\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Taken from https://www.shadertoy.com/view/MlVSzw\n// Changed to interpolate between two random values each second\nfloat gaussian_rand(vec2 n, float z)\n{\n\tfloat t = fract( iTime );\n\tint t_d = int(iTime) * 13;\n\tfloat x1 = hash1(n + 0.07*(float(t_d) + z) );\n\tfloat x2 = hash1(n + 0.07*(float(t_d + 13) + z) );\n    float x = mix(x1, x2, t);\n    \n\treturn inv_error_function(x*2.0-1.0);\n}\n\nconst vec4 w_0_0[32] = vec4[](\n\tvec4(-0.1590566635131836, -0.5021960139274597, -0.4277639091014862, -0.43616193532943726),\n\tvec4(-0.15154382586479187, 0.04471784457564354, -1.2752418518066406, -0.09376390278339386),\n\tvec4(0.750472366809845, 0.469832181930542, 0.44161170721054077, 0.788251519203186),\n\tvec4(-0.45544448494911194, 0.3957505226135254, -0.02520221471786499, -0.037016429007053375),\n\tvec4(0.27623721957206726, 0.41806212067604065, 0.49545273184776306, 0.6899088621139526),\n\tvec4(-0.05116809904575348, 0.4243479073047638, -0.604637086391449, -0.35702022910118103),\n\tvec4(-0.3182663321495056, 0.43976616859436035, -0.9798646569252014, -0.15389947593212128),\n\tvec4(0.29869964718818665, -0.3761482834815979, 0.9083136916160583, 0.42377904057502747),\n\tvec4(0.18716038763523102, -0.3372034430503845, 0.5076086521148682, 0.10384543985128403),\n\tvec4(-0.2737763524055481, -0.4953456521034241, -0.5989372730255127, -0.51519775390625),\n\tvec4(-0.28342288732528687, 0.37946996092796326, 0.541082501411438, 0.39417633414268494),\n\tvec4(-0.08906742185354233, 0.09714087098836899, 0.8566194176673889, 0.5973350405693054),\n\tvec4(-0.049692295491695404, 0.16002844274044037, -0.19287967681884766, 0.006604136899113655),\n\tvec4(0.04745132103562355, 0.32734572887420654, 0.4333111345767975, 0.7089936137199402),\n\tvec4(0.09314285218715668, 0.11071575433015823, 0.5308773517608643, 0.19533753395080566),\n\tvec4(0.07915385067462921, 0.23661856353282928, 0.8664178848266602, 0.7026163339614868),\n\tvec4(0.5259741544723511, 0.06506937742233276, 0.5431975722312927, 0.11426530033349991),\n\tvec4(-0.09959147125482559, -0.28292468190193176, -0.38522419333457947, 0.013060705736279488),\n\tvec4(-0.062322456389665604, -0.27935993671417236, -0.27467334270477295, 0.4239206314086914),\n\tvec4(0.26718419790267944, 0.06539510935544968, 0.3127536475658417, 0.7211378216743469),\n\tvec4(0.14728164672851562, 0.5116693377494812, -0.5998504757881165, 0.07366514950990677),\n\tvec4(0.33818933367729187, -0.5219213366508484, 0.10899797827005386, 0.10620450228452682),\n\tvec4(0.6377818584442139, -0.03502208739519119, -0.45821282267570496, 0.3615579903125763),\n\tvec4(0.5186376571655273, -0.013185598887503147, -0.2719672620296478, -0.07560396194458008),\n\tvec4(0.09509029984474182, 0.0997760072350502, 0.3562479317188263, 0.00021680683130398393),\n\tvec4(0.5917308926582336, 0.6773434281349182, 1.0771459341049194, 0.493394672870636),\n\tvec4(-0.3875308334827423, 0.25707367062568665, -0.07677183300256729, 0.15729911625385284),\n\tvec4(-0.10672695189714432, -0.1292557567358017, -0.8119608163833618, 0.26007404923439026),\n\tvec4(-0.08785924315452576, 0.664703905582428, 0.39785099029541016, 0.5589789152145386),\n\tvec4(0.5179884433746338, -0.2685443162918091, -0.24220001697540283, 0.18265071511268616),\n\tvec4(0.21149353682994843, -0.05284777656197548, 0.8628952503204346, 0.4690861105918884),\n\tvec4(-0.06070591136813164, -0.07083897292613983, 0.463905394077301, 0.28737378120422363)\n);\nconst vec4 w_0_1[32] = vec4[](\n\tvec4(0.03768563270568848, 0.2358575314283371, 0.22141939401626587, 0.2828547954559326),\n\tvec4(0.023568058386445045, 0.08001212775707245, 0.6358357667922974, 0.3129892349243164),\n\tvec4(-0.20035256445407867, 0.4996199607849121, 0.21438027918338776, -0.30510151386260986),\n\tvec4(0.2653166949748993, -0.3770287334918976, -0.759270191192627, -0.14344654977321625),\n\tvec4(-0.04286928102374077, 0.09204138815402985, 0.09354589879512787, -0.2500513195991516),\n\tvec4(0.02496272139251232, -0.04317903518676758, 0.24562816321849823, -0.051975104957818985),\n\tvec4(0.25326424837112427, -0.19396787881851196, -0.5681780576705933, -0.2827106714248657),\n\tvec4(-0.19127678871154785, 0.3105286955833435, 0.010038978420197964, -0.14228487014770508),\n\tvec4(-0.37705597281455994, 0.5690345168113708, 0.5397822260856628, -0.02011512592434883),\n\tvec4(-0.2069547474384308, -0.5433833003044128, 0.10755788534879684, -0.28604447841644287),\n\tvec4(0.24241790175437927, 0.040643949061632156, -0.16300296783447266, 0.28349757194519043),\n\tvec4(-0.19918420910835266, 0.5646910071372986, -0.16280867159366608, 0.4186258614063263),\n\tvec4(-0.011682386510074139, 0.10150972008705139, -0.3166264295578003, -0.42808035016059875),\n\tvec4(0.14054571092128754, -0.09340908378362656, 0.09253130108118057, 0.019480714574456215),\n\tvec4(0.2576080560684204, -0.1942325234413147, -0.19892555475234985, -0.019885456189513206),\n\tvec4(-0.03679873049259186, 0.4737693667411804, 0.07256805151700974, -0.14449983835220337),\n\tvec4(-0.0296693816781044, 0.14375773072242737, 0.12419942766427994, 0.09031782299280167),\n\tvec4(-0.014391355216503143, 0.3665737509727478, 0.3150497376918793, 0.287080854177475),\n\tvec4(0.12563015520572662, 0.1427423059940338, -0.006214842200279236, 0.39323699474334717),\n\tvec4(-0.11445960402488708, 0.3243297040462494, -0.04801180586218834, 0.1935771107673645),\n\tvec4(0.12801051139831543, 0.1056651845574379, -0.5353137850761414, -0.07139680534601212),\n\tvec4(-0.3630661070346832, 0.6509271264076233, 0.8109779953956604, 0.3517182767391205),\n\tvec4(-0.20560821890830994, 0.061256635934114456, 0.6285147666931152, 0.23801183700561523),\n\tvec4(-0.1331963688135147, 0.08887538313865662, -0.2033906728029251, 0.42399677634239197),\n\tvec4(0.32377952337265015, 0.053425274789333344, -0.7998282313346863, -0.03523313254117966),\n\tvec4(-0.11717870086431503, 0.12577161192893982, -0.03184845298528671, -0.012179006822407246),\n\tvec4(0.10023988038301468, 0.07698525488376617, -0.6207481026649475, -0.258748859167099),\n\tvec4(-0.14429473876953125, 0.5445274710655212, 0.13321805000305176, 0.10089632123708725),\n\tvec4(0.10350744426250458, -0.020811162889003754, -0.15262895822525024, 0.27512893080711365),\n\tvec4(-0.23068179190158844, 0.06395527720451355, 0.4242856800556183, 0.17700205743312836),\n\tvec4(-0.06795381754636765, 0.2217789590358734, 0.14772938191890717, 0.019626306369900703),\n\tvec4(-0.04112919047474861, 0.21472883224487305, 0.07185245305299759, -0.16610848903656006)\n);\nconst vec4 w_0_2[32] = vec4[](\n\tvec4(0.12264005839824677, 0.1723552644252777, 0.16994430124759674, -0.09587568789720535),\n\tvec4(0.031068721786141396, 0.5256946682929993, -0.19031740725040436, 0.030129453167319298),\n\tvec4(0.01758963242173195, -0.5563656687736511, 0.11343216896057129, 0.01020977832376957),\n\tvec4(-0.10689517855644226, -0.3807793855667114, -0.22774191200733185, -0.3021765351295471),\n\tvec4(0.0565493069589138, -0.2801869213581085, 0.02656884863972664, 0.0648408904671669),\n\tvec4(-0.1538909524679184, 0.161497563123703, 0.31121107935905457, -0.07735774666070938),\n\tvec4(-0.07191795855760574, 0.03671929985284805, 0.15496325492858887, -0.3100883960723877),\n\tvec4(0.2561672329902649, -0.042245056480169296, -0.2644369304180145, 0.49598732590675354),\n\tvec4(0.22914889454841614, 0.07020684331655502, 0.11868545413017273, 0.2818916141986847),\n\tvec4(-0.046860989183187485, 0.20577062666416168, -0.02443312667310238, 0.2618388831615448),\n\tvec4(-0.07164118438959122, 0.21471050381660461, -0.08231714367866516, 0.013092541135847569),\n\tvec4(0.16303780674934387, -0.23869718611240387, 0.20205973088741302, 0.29110482335090637),\n\tvec4(-0.06713253259658813, -0.27316340804100037, -0.3589109778404236, -0.11532660573720932),\n\tvec4(0.011386927217245102, -0.10707589983940125, -0.18067488074302673, -0.11607693880796432),\n\tvec4(-0.06796937435865402, -0.1683814376592636, 0.11615752428770065, -0.11370772123336792),\n\tvec4(0.10914196819067001, -0.6186458468437195, -0.42634567618370056, -0.4222683906555176),\n\tvec4(0.12347748130559921, -0.2004953771829605, -0.10447603464126587, 0.1787954568862915),\n\tvec4(0.018161237239837646, 0.033928282558918, 0.20766276121139526, 0.03792887553572655),\n\tvec4(0.151887908577919, 0.40635785460472107, 0.10726156085729599, 0.16922463476657867),\n\tvec4(0.23758162558078766, -0.04291451722383499, -0.16060645878314972, 0.39129844307899475),\n\tvec4(-0.08709336072206497, -0.34173068404197693, 0.1798238754272461, -0.34102514386177063),\n\tvec4(0.3263760209083557, 0.36782366037368774, -0.05588117241859436, 0.472768634557724),\n\tvec4(0.08564422279596329, -0.03258544206619263, 0.4810045659542084, 0.28652894496917725),\n\tvec4(0.09790477901697159, -0.0466894656419754, 0.2631482779979706, 0.2928105294704437),\n\tvec4(-0.025266796350479126, -0.20894184708595276, -0.11419994384050369, -0.1553364098072052),\n\tvec4(-0.03977661579847336, -0.38682442903518677, 0.5550965070724487, 0.2451978176832199),\n\tvec4(-0.09307195246219635, 0.06734520196914673, -0.06157355010509491, -0.27072039246559143),\n\tvec4(0.025041403248906136, -0.03704635426402092, 0.16519226133823395, -0.1509017050266266),\n\tvec4(-0.045022185891866684, -0.09749555587768555, -0.1668729931116104, -0.02649002894759178),\n\tvec4(0.12601792812347412, -0.09819814562797546, 0.010109364986419678, 0.30249789357185364),\n\tvec4(-0.01602400839328766, -0.21897664666175842, -0.1823798418045044, 0.046226866543293),\n\tvec4(0.0755472406744957, -0.048976633697748184, -0.45397093892097473, -0.23501616716384888)\n);\nconst vec4 w_0_3[32] = vec4[](\n\tvec4(0.3201548457145691, 0.26078763604164124, -0.13467510044574738, -0.03148556128144264),\n\tvec4(-0.2317265421152115, -0.24935029447078705, -0.14350804686546326, -0.33931273221969604),\n\tvec4(-0.08679474890232086, 0.14799273014068604, -0.12726569175720215, 0.4534680247306824),\n\tvec4(-0.30733245611190796, 0.3333093225955963, 0.6490986347198486, -0.0008350649732165039),\n\tvec4(0.1731061488389969, 0.19018588960170746, 0.26064932346343994, -0.0030637134332209826),\n\tvec4(-0.26856186985969543, 0.01565539464354515, 0.0529329776763916, -0.2982034683227539),\n\tvec4(-0.2330063134431839, 0.2753232717514038, 0.3947252333164215, 0.01761787198483944),\n\tvec4(0.31557074189186096, -0.176773801445961, -0.22279106080532074, 0.024613099172711372),\n\tvec4(0.6527596116065979, 0.12761762738227844, -0.4355176091194153, 0.03373508155345917),\n\tvec4(0.2052089273929596, 0.22415804862976074, 0.46464651823043823, -0.6383856534957886),\n\tvec4(-0.3640221357345581, -0.2814507782459259, 0.08574042469263077, -0.05839001014828682),\n\tvec4(0.12156885117292404, -0.11899822950363159, -0.022246891632676125, 0.24988164007663727),\n\tvec4(-0.3362874984741211, 0.19587604701519012, -0.3077727258205414, 0.6672902703285217),\n\tvec4(0.07791795581579208, -0.02461179345846176, 0.0843987837433815, 0.19162867963314056),\n\tvec4(-0.08333668112754822, 0.009920891374349594, 0.026832329109311104, 0.3930005729198456),\n\tvec4(0.2083783894777298, 0.4032011032104492, -0.4255424737930298, 0.15676462650299072),\n\tvec4(0.22607119381427765, 0.15632304549217224, -0.14953936636447906, 0.035726968199014664),\n\tvec4(-0.16841107606887817, 0.01923513412475586, -0.2039567232131958, 0.21217215061187744),\n\tvec4(0.030977802351117134, -0.006640662904828787, 0.052491459995508194, -0.05110544338822365),\n\tvec4(0.1819079965353012, -0.10462086647748947, 0.06286725401878357, 0.1309201419353485),\n\tvec4(-0.3057117462158203, 0.5439427495002747, 0.15835489332675934, 0.08601650595664978),\n\tvec4(0.5233323574066162, -0.05381389707326889, -0.26072144508361816, -0.26655149459838867),\n\tvec4(0.45426151156425476, 0.23048704862594604, 0.2579905390739441, -0.10941603779792786),\n\tvec4(0.24212118983268738, -0.010442224331200123, -0.15449225902557373, -0.021774861961603165),\n\tvec4(-0.14669080078601837, 0.16105405986309052, -0.16815724968910217, 0.5225178003311157),\n\tvec4(-0.20791710913181305, -0.2742340564727783, 0.3760432004928589, 0.2237548977136612),\n\tvec4(-0.15224291384220123, 0.054582539945840836, -0.04027048498392105, 0.19197633862495422),\n\tvec4(-0.22527077794075012, 0.3056376874446869, -0.12589898705482483, 0.4711044132709503),\n\tvec4(-0.36231768131256104, 0.0067705740220844746, 0.2573856711387634, -0.14199677109718323),\n\tvec4(0.36336204409599304, 0.013881934806704521, -0.09666081517934799, -0.13403326272964478),\n\tvec4(-0.04667593538761139, -0.108597032725811, -0.25366640090942383, 0.4008557200431824),\n\tvec4(0.23258881270885468, -0.0815948098897934, -0.5934779644012451, 0.35148653388023376)\n);\nconst vec4 w_1_0[32] = vec4[](\n\tvec4(-0.003984305541962385, -0.22005940973758698, -0.051394082605838776, 0.150032639503479),\n\tvec4(-0.06451297551393509, -0.4489639401435852, -0.05579672008752823, -0.32528573274612427),\n\tvec4(-0.13134749233722687, -0.17164194583892822, -0.07178667187690735, 0.10731813311576843),\n\tvec4(0.06994354724884033, 0.08523077517747879, 0.19433186948299408, -0.1013825535774231),\n\tvec4(-0.1520397812128067, -0.1679026335477829, -0.060212038457393646, -0.15828953683376312),\n\tvec4(-0.4138939678668976, -0.5800039172172546, 0.18983659148216248, -0.08503779023885727),\n\tvec4(0.08346876502037048, -0.24327868223190308, -0.12089693546295166, 0.31839802861213684),\n\tvec4(0.21305425465106964, 0.09008735418319702, -0.10063556581735611, 0.10334385931491852),\n\tvec4(-0.08598330616950989, -0.022115368396043777, 0.06253080070018768, -0.37294092774391174),\n\tvec4(-0.3249571919441223, -0.25540652871131897, 0.23514418303966522, 0.09627766907215118),\n\tvec4(-0.019481748342514038, -0.05582680180668831, 0.15559470653533936, -0.07441762089729309),\n\tvec4(0.29168012738227844, 0.1394253820180893, 0.11462689191102982, 0.08653183281421661),\n\tvec4(0.4428896903991699, -0.0806661993265152, -0.17358694970607758, -0.050808630883693695),\n\tvec4(0.06741220504045486, 0.05088556930422783, -0.051825154572725296, -0.31255510449409485),\n\tvec4(-0.1068405732512474, 0.3414520025253296, 0.0513533391058445, -0.5482545495033264),\n\tvec4(0.2652144730091095, 0.05894884839653969, 0.12518034875392914, -0.4813738763332367),\n\tvec4(-0.1527036875486374, 0.07284880429506302, -0.07636655122041702, -0.29002007842063904),\n\tvec4(-0.11695458739995956, -0.22456000745296478, 0.20327520370483398, -0.32134395837783813),\n\tvec4(0.15828177332878113, 0.047519244253635406, -0.06777691096067429, -0.11037404090166092),\n\tvec4(0.336382657289505, 0.051254671066999435, -0.33207881450653076, 0.19371601939201355),\n\tvec4(-0.0637936219573021, -0.3879295885562897, -0.02587977983057499, -0.0381869338452816),\n\tvec4(-0.09277893602848053, -0.20575620234012604, -0.25321727991104126, 0.14306625723838806),\n\tvec4(-0.5040841698646545, -0.04247967153787613, -0.1910063624382019, -0.02398849092423916),\n\tvec4(-0.32630252838134766, -0.07017751038074493, -0.0594436340034008, 0.14629130065441132),\n\tvec4(0.07236210256814957, 0.33601114153862, 0.13377991318702698, -0.34488001465797424),\n\tvec4(-0.057518281042575836, 0.282319575548172, -0.22143468260765076, 0.2906454801559448),\n\tvec4(0.1526384949684143, -0.19897539913654327, 0.23380343616008759, 0.06432823091745377),\n\tvec4(0.18707047402858734, -0.388979971408844, -0.10221625864505768, 0.535622239112854),\n\tvec4(0.07400059700012207, -0.1321428120136261, -0.05883714184165001, -0.3275545537471771),\n\tvec4(-0.2437584400177002, 0.005285740364342928, -0.10031095892190933, -0.24133846163749695),\n\tvec4(0.016890840604901314, 0.11554751545190811, 0.10778998583555222, -0.2208975851535797),\n\tvec4(0.37604817748069763, 0.14654572308063507, -0.08478109538555145, -0.3575321137905121)\n);\nconst vec4 w_1_1[32] = vec4[](\n\tvec4(-0.016818903386592865, -0.11775892972946167, 0.19876211881637573, -0.06586802750825882),\n\tvec4(0.004128538072109222, -0.038595814257860184, 0.11963725090026855, -0.1375395506620407),\n\tvec4(-0.15665724873542786, 0.005611978005617857, 0.2163609117269516, -0.06620018929243088),\n\tvec4(0.11318908631801605, 0.18617644906044006, -0.22502920031547546, -0.005768646020442247),\n\tvec4(0.07503341138362885, -0.03470402956008911, -0.034856654703617096, -0.05791230872273445),\n\tvec4(0.06172891706228256, -0.17324811220169067, 0.03274235129356384, 0.09673433005809784),\n\tvec4(-0.05865475907921791, -0.19513657689094543, -0.13876184821128845, 0.06165575981140137),\n\tvec4(-0.05282553657889366, 0.19158349931240082, -0.17005108296871185, -0.016929827630519867),\n\tvec4(-0.03609051927924156, 0.019970761612057686, 0.19786784052848816, 0.04871537536382675),\n\tvec4(0.19251124560832977, 0.0039548310451209545, -0.09405531734228134, -0.001047004945576191),\n\tvec4(0.08314834535121918, 0.013269037008285522, -0.38166576623916626, 0.20899856090545654),\n\tvec4(-0.08022283017635345, 0.1844652146100998, -0.10192491859197617, 0.036682143807411194),\n\tvec4(-0.1401911973953247, 0.1782982051372528, 0.05468438193202019, 0.025780295953154564),\n\tvec4(0.060037825256586075, -0.07509312778711319, -0.05674857273697853, -0.09948688745498657),\n\tvec4(-0.012730788439512253, -0.13734063506126404, -0.07536016404628754, 0.17678695917129517),\n\tvec4(0.07995326817035675, 0.19560198485851288, 0.20580576360225677, -0.17740657925605774),\n\tvec4(0.08005606383085251, 0.17689219117164612, -0.03401912748813629, -0.0661250501871109),\n\tvec4(-0.12101380527019501, 0.032407794147729874, 0.13204342126846313, 0.09773391485214233),\n\tvec4(-0.008187619037926197, -0.2560423016548157, -0.21499080955982208, -0.15630246698856354),\n\tvec4(-0.11320735514163971, 0.03431636095046997, -0.07626856118440628, -0.22829747200012207),\n\tvec4(-0.1844458431005478, -0.1043071374297142, 0.1449616700410843, -0.08775843679904938),\n\tvec4(0.03411222621798515, 0.01036191824823618, 0.13634316623210907, -0.2642385959625244),\n\tvec4(0.034319858998060226, -0.17610087990760803, 0.22633659839630127, -0.1307985931634903),\n\tvec4(-0.18594999611377716, 0.021975597366690636, 0.11558009684085846, 0.003938847687095404),\n\tvec4(-0.045211173593997955, 0.20238010585308075, -0.2915041744709015, 0.20133918523788452),\n\tvec4(-0.16088485717773438, -0.12062156200408936, -0.0756864920258522, 0.13603827357292175),\n\tvec4(-0.14083078503608704, -0.0778469666838646, -0.05687316507101059, 0.08344036340713501),\n\tvec4(-0.10672488063573837, -0.06122426688671112, 0.2379014939069748, -0.2592267394065857),\n\tvec4(0.001505597378127277, 0.004157340154051781, -0.05635439231991768, -0.10089552402496338),\n\tvec4(0.02812204696238041, 0.0762660950422287, 0.1902070939540863, -0.060542963445186615),\n\tvec4(0.008855655789375305, 0.10784165561199188, 0.024972226470708847, 0.01716204546391964),\n\tvec4(0.07650542259216309, 0.11814010143280029, 0.09957368671894073, -0.12369631975889206)\n);\nconst vec4 w_1_2[32] = vec4[](\n\tvec4(-0.06306642293930054, -0.04882287606596947, 0.2119809240102768, -0.2899257242679596),\n\tvec4(0.16200675070285797, 0.1721247285604477, -0.16908381879329681, -0.16736800968647003),\n\tvec4(-0.07121975719928741, -0.21264080703258514, -0.048330578953027725, 0.24278569221496582),\n\tvec4(-0.057432182133197784, -0.03431050479412079, -0.15951284766197205, 0.13850107789039612),\n\tvec4(-0.0005748254479840398, -0.05268735811114311, 0.0417407788336277, -0.03793734684586525),\n\tvec4(0.013824989087879658, 0.12544873356819153, 0.09067398309707642, -0.1877375990152359),\n\tvec4(-0.23116490244865417, -0.0907830223441124, 0.1861753761768341, 0.07626382261514664),\n\tvec4(0.06924239546060562, -0.20545855164527893, -0.019904108718037605, 0.16530387103557587),\n\tvec4(0.024649927392601967, -0.1604888141155243, 0.12869764864444733, -0.042776431888341904),\n\tvec4(0.05612974613904953, 0.014173534698784351, 0.13269343972206116, -0.08439420908689499),\n\tvec4(0.060340799391269684, 0.21883848309516907, -0.1257607340812683, 0.03529106080532074),\n\tvec4(-0.08212311565876007, -0.3190198242664337, 0.10627803951501846, 0.2652808129787445),\n\tvec4(-0.06360890716314316, -0.13914740085601807, -0.35046741366386414, 0.4316207766532898),\n\tvec4(0.0013354227412492037, 0.14219093322753906, -0.0807642862200737, 0.02596600539982319),\n\tvec4(-0.12067173421382904, 0.04894403740763664, 0.09671276062726974, -0.008419041521847248),\n\tvec4(0.20872357487678528, 0.008731070905923843, -0.38862183690071106, -0.07374607026576996),\n\tvec4(0.11372969299554825, -0.09966906160116196, -0.16565541923046112, -0.02340202033519745),\n\tvec4(-0.04140159487724304, -0.01992080919444561, 0.10356315225362778, -0.0002799257345031947),\n\tvec4(-0.030673574656248093, 0.1743699312210083, 0.05978095531463623, -0.04107816889882088),\n\tvec4(-0.022418759763240814, -0.1622961461544037, -0.022091872990131378, 0.14828920364379883),\n\tvec4(-0.05388862267136574, -0.009325163438916206, 0.0314488522708416, -0.1310362070798874),\n\tvec4(0.005525405053049326, -0.1511414647102356, 0.053089551627635956, -0.015736594796180725),\n\tvec4(-0.13166028261184692, -0.10151808708906174, 0.36865201592445374, -0.1620541363954544),\n\tvec4(0.08019089698791504, -0.13716627657413483, 0.10551665723323822, -0.25530436635017395),\n\tvec4(-0.014864247292280197, -0.028945978730916977, -0.18687871098518372, 0.20357836782932281),\n\tvec4(-0.2326490730047226, -0.22201690077781677, 0.3167042136192322, 0.2930571436882019),\n\tvec4(-0.062316473573446274, 0.04652729257941246, -0.0016768173081800342, 0.09513294696807861),\n\tvec4(-0.2470557689666748, -0.18254315853118896, 0.13324762880802155, 0.25628718733787537),\n\tvec4(0.06190533563494682, 0.12852467596530914, -0.32838499546051025, 0.07711439579725266),\n\tvec4(0.14241094887256622, -0.12048772722482681, -0.0036719203926622868, -0.2135106772184372),\n\tvec4(0.06214151903986931, 0.009826183319091797, -0.21234379708766937, 0.15209296345710754),\n\tvec4(0.08630838990211487, 0.028908992186188698, -0.24714794754981995, 0.06792408972978592)\n);\nconst vec4 w_1_3[32] = vec4[](\n\tvec4(-0.13461218774318695, -0.13856962323188782, 0.10885892063379288, -0.24111445248126984),\n\tvec4(0.41284266114234924, 0.16624607145786285, -0.008031787350773811, -0.14769239723682404),\n\tvec4(0.008275727741420269, -0.06800831854343414, -0.07093749195337296, 0.06619898229837418),\n\tvec4(-0.1973574459552765, 0.354815274477005, 0.015503233298659325, 0.4755982458591461),\n\tvec4(-0.037353720515966415, -0.04382682591676712, -0.0963473916053772, -0.03503485769033432),\n\tvec4(0.3283511698246002, 0.07275354862213135, 0.21706560254096985, -0.20284739136695862),\n\tvec4(-0.20817197859287262, 0.050557613372802734, 0.12436837702989578, 0.39393916726112366),\n\tvec4(-0.08805230259895325, -0.22892142832279205, -0.4667803645133972, -0.13681985437870026),\n\tvec4(-0.02249031700193882, -0.44681763648986816, -0.3118624687194824, -0.3227095603942871),\n\tvec4(0.13753490149974823, 0.06841844320297241, -0.16520637273788452, -0.17212353646755219),\n\tvec4(0.13364697992801666, 0.14854973554611206, 0.13013850152492523, 0.06131885200738907),\n\tvec4(-0.40296438336372375, -0.11696350574493408, -0.03383586183190346, 0.09265248477458954),\n\tvec4(0.057781826704740524, 0.008059915155172348, -0.2626621723175049, 0.3080351948738098),\n\tvec4(-0.01958601549267769, -0.06057276204228401, 0.019632581621408463, 0.07483164221048355),\n\tvec4(-0.12820273637771606, -0.035335905849933624, 0.1886269897222519, 0.08369749039411545),\n\tvec4(0.16095967590808868, -0.048332296311855316, -0.4196721315383911, -0.17032209038734436),\n\tvec4(0.006608540657907724, -0.04573073238134384, -0.08166492730379105, -0.22444744408130646),\n\tvec4(-0.049751657992601395, -0.09310907870531082, 0.15166273713111877, -0.20006148517131805),\n\tvec4(-0.2211397886276245, 0.024957476183772087, 0.20925475656986237, 0.035733677446842194),\n\tvec4(-0.37787577509880066, -0.056722767651081085, -0.26660341024398804, 0.23202760517597198),\n\tvec4(-0.077707439661026, 0.15720497071743011, 0.07139615714550018, 0.18662941455841064),\n\tvec4(-0.1390601396560669, -0.3198604881763458, -0.21001273393630981, -0.16831763088703156),\n\tvec4(-0.3148173689842224, -0.21584507822990417, 0.25162312388420105, -0.10427771508693695),\n\tvec4(-0.139240562915802, 0.06026329845190048, 0.00943498220294714, -0.18337270617485046),\n\tvec4(-0.22553987801074982, -0.05947478488087654, 0.08260677009820938, 0.12060500681400299),\n\tvec4(-0.31736037135124207, 0.0052801501005887985, 0.2834917902946472, 0.3191983699798584),\n\tvec4(-0.0609438456594944, -0.07235870510339737, -0.1330283135175705, 0.26045575737953186),\n\tvec4(-0.3935278058052063, -0.11954072117805481, 0.1237032413482666, 0.3136592507362366),\n\tvec4(0.12201575189828873, 0.3676286041736603, 0.018910758197307587, 0.3663623332977295),\n\tvec4(0.034480541944503784, 0.052996378391981125, -0.1842728704214096, -0.33504289388656616),\n\tvec4(-0.013097337447106838, -0.02850419096648693, -0.09669064730405807, -0.02118457667529583),\n\tvec4(0.14709928631782532, -0.259784996509552, -0.37543874979019165, -0.013480729423463345)\n);\nconst vec4 w_2_0[32] = vec4[](\n\tvec4(0.1992364078760147, -0.36584416031837463, -0.1202065572142601, -0.04566206410527229),\n\tvec4(-0.01032915897667408, -0.16241975128650665, 0.4567893147468567, -0.6812141537666321),\n\tvec4(0.04615094140172005, -0.12089424580335617, -0.14013059437274933, -0.12407711148262024),\n\tvec4(0.07552088797092438, 0.10913092643022537, 0.17795772850513458, 0.31657537817955017),\n\tvec4(0.4704809784889221, 0.16431252658367157, -0.3171205520629883, -0.3153987228870392),\n\tvec4(0.03593237325549126, 0.17476385831832886, -0.057017095386981964, -0.6308591961860657),\n\tvec4(0.20638039708137512, -0.3896448612213135, -0.17458446323871613, 0.10838792473077774),\n\tvec4(-0.029171865433454514, 0.18682529032230377, -0.03721354529261589, 0.4165984094142914),\n\tvec4(-0.03143198415637016, -0.1424310803413391, -0.49480122327804565, 0.3299446105957031),\n\tvec4(0.157069593667984, 0.44016706943511963, 0.1630510538816452, 0.0321849063038826),\n\tvec4(0.11901549994945526, 0.4143039584159851, 0.1748751997947693, -0.3832660913467407),\n\tvec4(-0.5875659584999084, -0.5810091495513916, 0.09697075188159943, 0.49935129284858704),\n\tvec4(-0.23670995235443115, -0.4601552188396454, 0.14622852206230164, 0.011321180500090122),\n\tvec4(-0.059949830174446106, 0.05677497386932373, 0.011474129743874073, -0.07081788778305054),\n\tvec4(-0.3072408139705658, -0.1157105565071106, 0.031246790662407875, 0.25306686758995056),\n\tvec4(-0.22408372163772583, -0.5057352185249329, -0.17557239532470703, 0.19891896843910217),\n\tvec4(-0.04213743656873703, 0.14377714693546295, 0.09310042858123779, -0.01622145064175129),\n\tvec4(-0.16320592164993286, 0.11276885122060776, 0.2289169877767563, 0.3021681308746338),\n\tvec4(-0.2448159158229828, 0.32284262776374817, 0.2991633415222168, -0.26889896392822266),\n\tvec4(-0.1281103938817978, 0.06006329879164696, -0.13098391890525818, -0.017153987661004066),\n\tvec4(0.4700583815574646, 0.2753625810146332, -0.35623618960380554, -0.4422573149204254),\n\tvec4(0.23210588097572327, -0.07166878134012222, -0.10800740122795105, 0.09173191338777542),\n\tvec4(0.1390874683856964, 0.08140815049409866, -0.4322858154773712, -0.11685139685869217),\n\tvec4(0.5840433835983276, 0.6428394913673401, -0.5056056380271912, -0.375965416431427),\n\tvec4(-0.4792940020561218, 0.19054856896400452, 0.2641714811325073, 0.17445066571235657),\n\tvec4(-0.004486969672143459, 0.08016037940979004, -0.6059610247612, 0.10352952033281326),\n\tvec4(-0.19493162631988525, -0.252158522605896, 0.058824971318244934, 0.05978089198470116),\n\tvec4(-0.01968895085155964, -0.4323548674583435, 0.11550351977348328, -0.2786887586116791),\n\tvec4(0.05327378958463669, 0.3707730770111084, 0.09786324948072433, -0.34352174401283264),\n\tvec4(-0.006900958716869354, 0.10810843110084534, -0.1601565033197403, -0.06287776678800583),\n\tvec4(-0.17749828100204468, 0.034783583134412766, 0.039122819900512695, -0.14177151024341583),\n\tvec4(-0.26178744435310364, -0.3908667266368866, -0.25726550817489624, 0.015771040692925453)\n);\nconst vec4 w_2_1[32] = vec4[](\n\tvec4(-0.04986263066530228, -0.03207996487617493, 0.1955241858959198, -0.06141860783100128),\n\tvec4(0.019674601033329964, 0.08983612805604935, 0.05910550802946091, -0.14442719519138336),\n\tvec4(0.1566271185874939, -0.17171610891819, -0.014957849867641926, 0.11244700103998184),\n\tvec4(-0.15439803898334503, 0.20463219285011292, -0.1364133059978485, 0.09940531104803085),\n\tvec4(0.1258685439825058, -0.05013704299926758, -0.003260419936850667, -0.03364041447639465),\n\tvec4(0.13227331638336182, -0.20219890773296356, 0.06446822732686996, -0.11101192235946655),\n\tvec4(-0.08762212842702866, 0.1429888755083084, 0.101824089884758, 0.10918483138084412),\n\tvec4(0.06391368061304092, -0.0780087262392044, -0.19214896857738495, -0.006097325123846531),\n\tvec4(0.16295932233333588, -0.3007747232913971, 0.18305109441280365, 0.015730760991573334),\n\tvec4(0.17358437180519104, -0.16663549840450287, -0.2231963723897934, 0.07994619756937027),\n\tvec4(-0.17105212807655334, -0.03397149592638016, -0.16070103645324707, -0.06447833776473999),\n\tvec4(-0.2602529227733612, -0.07344717532396317, 0.05216861143708229, 0.15255464613437653),\n\tvec4(-0.10800853371620178, 0.07436419278383255, -0.10040931403636932, 0.11977943778038025),\n\tvec4(0.060571715235710144, 0.23095887899398804, -0.15886752307415009, 0.19624346494674683),\n\tvec4(-0.2178598940372467, 0.060495827347040176, 0.1413147896528244, -0.005594964139163494),\n\tvec4(0.07554149627685547, 0.12372793257236481, 0.08883853256702423, -0.0441264882683754),\n\tvec4(0.05828651040792465, -0.05512993410229683, -0.1211676076054573, -0.11855985969305038),\n\tvec4(0.01164333987981081, -0.21318326890468597, -0.06538895517587662, 0.003996219485998154),\n\tvec4(0.01200198195874691, 0.17240513861179352, -0.12644045054912567, -0.04338628426194191),\n\tvec4(-0.06744344532489777, 0.0948866531252861, 0.05269083380699158, -0.1556132733821869),\n\tvec4(0.09176753461360931, 0.0692308098077774, 0.3136712908744812, -0.3619723320007324),\n\tvec4(0.4029712677001953, -0.18818464875221252, -0.27261245250701904, 0.09354649484157562),\n\tvec4(0.1013704463839531, -0.20823444426059723, 0.12037685513496399, 0.03811148926615715),\n\tvec4(0.17451734840869904, -0.1157778650522232, 0.3282945156097412, -0.4986439645290375),\n\tvec4(-0.2375224083662033, 0.18042916059494019, 0.01727617159485817, -0.038126107305288315),\n\tvec4(-0.005753438454121351, -0.19851432740688324, 0.03941422700881958, 0.11983799189329147),\n\tvec4(-0.11650366336107254, 0.16800807416439056, 0.34228017926216125, -0.0332280658185482),\n\tvec4(-0.11673261225223541, -0.01617126725614071, -0.017071610316634178, 0.29523977637290955),\n\tvec4(0.15274575352668762, 0.12254403531551361, -0.08225100487470627, -0.24412968754768372),\n\tvec4(0.08871088176965714, -0.17455345392227173, 0.20953981578350067, -0.29800182580947876),\n\tvec4(-0.058791741728782654, -0.013991993851959705, -0.049215544015169144, 0.048204947263002396),\n\tvec4(-0.036532096564769745, 0.22667038440704346, 0.11504765599966049, 0.10564370453357697)\n);\nconst vec4 w_2_2[32] = vec4[](\n\tvec4(0.03624720498919487, 0.10372069478034973, 0.007722996175289154, -0.023222684860229492),\n\tvec4(0.1981651932001114, 0.061805009841918945, -0.016703512519598007, -0.2155744582414627),\n\tvec4(-0.011469604447484016, -0.23020601272583008, -0.1562168300151825, 0.17893730103969574),\n\tvec4(-0.06566818058490753, 0.2505017817020416, 0.16565091907978058, -0.054380279034376144),\n\tvec4(-0.07950127124786377, -0.20623521506786346, -0.0425395704805851, -0.03048434481024742),\n\tvec4(0.08791006356477737, 0.09429589658975601, -0.061075691133737564, -0.1360003501176834),\n\tvec4(-0.09905418753623962, -0.1713968813419342, 0.2595149278640747, -0.18324781954288483),\n\tvec4(-0.027432022616267204, 0.01496001798659563, -0.06382996588945389, 0.09676482528448105),\n\tvec4(-0.07750873267650604, -0.30549049377441406, -0.12531588971614838, 0.01669152081012726),\n\tvec4(0.06273508816957474, 0.1525670439004898, -0.01712283119559288, -0.1253606379032135),\n\tvec4(0.028219623491168022, 0.19780196249485016, 0.050887905061244965, -0.020651403814554214),\n\tvec4(-0.13717801868915558, 0.1299336701631546, -0.02680322714149952, 0.23437604308128357),\n\tvec4(0.0785832479596138, -0.01779460348188877, -0.0038819152396172285, 0.049070533365011215),\n\tvec4(-0.017059486359357834, -0.1485111117362976, 0.18907830119132996, -0.15887528657913208),\n\tvec4(-0.042950987815856934, 0.07342053204774857, -0.04886136204004288, 0.19390037655830383),\n\tvec4(0.05038554221391678, -0.10862819850444794, 0.06502377986907959, -0.31569528579711914),\n\tvec4(0.06753766536712646, 0.142051562666893, -0.27284255623817444, 0.1974770724773407),\n\tvec4(0.06466604024171829, 0.2113308161497116, 0.11658260971307755, 0.08148641884326935),\n\tvec4(-0.001457058941014111, 0.0073308562859892845, 0.0024035584647208452, 0.009176897816359997),\n\tvec4(-0.16196246445178986, 0.047376297414302826, -0.1117488220334053, 0.19275501370429993),\n\tvec4(-0.05686568841338158, 0.03085430897772312, 0.1364172250032425, -0.0726894959807396),\n\tvec4(-0.005833927541971207, -0.21239416301250458, -0.20921720564365387, 0.013262917287647724),\n\tvec4(-0.132618248462677, -0.05027291923761368, -0.14376027882099152, 0.2100895494222641),\n\tvec4(-0.10693397372961044, -0.08719758689403534, -0.3221452832221985, 0.34893348813056946),\n\tvec4(-0.03911299258470535, 0.136546790599823, 0.03810778260231018, 0.19726397097110748),\n\tvec4(-0.23714767396450043, -0.17164137959480286, -0.14080360531806946, 0.36643466353416443),\n\tvec4(-0.11864571273326874, -0.16374829411506653, 0.34904152154922485, -0.2556561827659607),\n\tvec4(-0.03462114930152893, 0.21081756055355072, 0.1725935935974121, 0.08124525099992752),\n\tvec4(-0.01819748803973198, -0.05644216015934944, -0.14144212007522583, -0.05052203685045242),\n\tvec4(0.027539052069187164, 0.11921476572751999, -0.3941335678100586, 0.19419735670089722),\n\tvec4(0.012735034339129925, 0.030942050740122795, -0.06855185329914093, 0.12043071538209915),\n\tvec4(-0.029845718294382095, -0.13847796618938446, 0.11080098897218704, -0.19236421585083008)\n);\nconst vec4 w_2_3[32] = vec4[](\n\tvec4(0.30721232295036316, -0.03315644711256027, 0.2292037308216095, -0.13352076709270477),\n\tvec4(0.04358905926346779, -0.2967434823513031, -0.19598644971847534, -0.13494528830051422),\n\tvec4(0.08412415534257889, -0.13008011877536774, 0.07138513028621674, -0.07446464151144028),\n\tvec4(-0.23205043375492096, -0.06418014317750931, -0.5210235714912415, 0.2810670733451843),\n\tvec4(0.038157764822244644, 0.13539138436317444, 0.13904237747192383, -0.09932757169008255),\n\tvec4(0.3345869779586792, -0.08024733513593674, 0.3572407066822052, -0.4305819571018219),\n\tvec4(0.032931603491306305, -0.19331355392932892, -0.44568708539009094, 0.2931808829307556),\n\tvec4(-0.09876513481140137, -0.08915238827466965, 0.08958056569099426, 0.27359434962272644),\n\tvec4(0.21860559284687042, -0.046340685337781906, 0.3768015205860138, 0.16823172569274902),\n\tvec4(0.08312080800533295, -0.14844463765621185, 0.3307477831840515, 0.10016236454248428),\n\tvec4(-0.12486854195594788, -0.06311739981174469, -0.221451073884964, -0.03933575749397278),\n\tvec4(0.00992301944643259, -0.11869504302740097, 0.12634621560573578, 0.30690571665763855),\n\tvec4(-0.23714140057563782, -0.5944175720214844, -0.5572437047958374, 0.4548048973083496),\n\tvec4(-0.2135176807641983, 0.15217581391334534, -0.3690529465675354, 0.09404361993074417),\n\tvec4(0.03422434255480766, 0.09719783067703247, 0.14746707677841187, -0.1420074850320816),\n\tvec4(-0.04591640457510948, 0.11225271224975586, -0.1428079456090927, -0.054005566984415054),\n\tvec4(0.07443001121282578, 0.04550161212682724, 0.3818856477737427, -0.2656731903553009),\n\tvec4(0.18221761286258698, -0.22404813766479492, -0.1463591754436493, -0.08177153021097183),\n\tvec4(-0.10866422951221466, 0.2564455568790436, 0.02144773118197918, -0.08600611984729767),\n\tvec4(-0.14656664431095123, 0.21976730227470398, 0.15479540824890137, 0.19767598807811737),\n\tvec4(0.1388176530599594, 0.11401818692684174, -0.2067488133907318, -0.2494778335094452),\n\tvec4(0.07347866147756577, 0.07941149175167084, 0.465982586145401, 0.03428351506590843),\n\tvec4(0.2787203788757324, 0.32678353786468506, 0.6992921233177185, -0.20532569289207458),\n\tvec4(0.1243465468287468, 0.45687782764434814, 0.6078088283538818, -0.3920132517814636),\n\tvec4(-0.10728514939546585, 0.010360945016145706, -0.23784644901752472, -0.08766656368970871),\n\tvec4(0.03685241937637329, 0.2848016321659088, 0.3728099465370178, -0.0902014896273613),\n\tvec4(-0.12036159634590149, -0.14735187590122223, -0.5638999342918396, 0.39603763818740845),\n\tvec4(0.10088371485471725, -0.3296734094619751, -0.19921760261058807, 0.22020117938518524),\n\tvec4(-0.2859652638435364, 0.21800504624843597, -0.08464507013559341, -0.1026502177119255),\n\tvec4(0.14573386311531067, 0.12381931394338608, 0.768682599067688, -0.2544141709804535),\n\tvec4(-0.16585300862789154, -0.015804940834641457, 0.05513124540448189, 0.011920259334146976),\n\tvec4(-0.1677895486354828, -0.10047989338636398, -0.30272090435028076, 0.22764775156974792)\n);\nconst vec4 w_3_0[32] = vec4[](\n\tvec4(0.03176278993487358, 0.07801412045955658, 0.010964120738208294, -0.3822769522666931),\n\tvec4(0.5480724573135376, 0.5896784067153931, -0.1496720016002655, -0.21611367166042328),\n\tvec4(-0.2767803966999054, -0.2502748668193817, 0.1389758586883545, -0.7106463313102722),\n\tvec4(0.13954123854637146, -0.09041395038366318, -0.23952820897102356, 1.099831461906433),\n\tvec4(-0.04009999334812164, -0.03826417401432991, -0.3139183819293976, 0.05566851794719696),\n\tvec4(0.1979173719882965, 0.4134758412837982, 0.01899685524404049, -0.7470617294311523),\n\tvec4(-0.05531369522213936, 0.008606930263340473, -0.054003968834877014, -0.01788758672773838),\n\tvec4(-0.37143364548683167, -0.34931686520576477, 0.24251987040042877, -0.14069385826587677),\n\tvec4(-0.27677640318870544, -0.17626266181468964, 0.34985801577568054, -0.616336464881897),\n\tvec4(0.038899343460798264, 0.1794857680797577, 0.0381942018866539, 0.100968137383461),\n\tvec4(0.3787463903427124, 0.4295707643032074, -0.42011094093322754, 0.7579509615898132),\n\tvec4(-0.2537994384765625, -0.18518364429473877, 0.20885546505451202, 0.2925631105899811),\n\tvec4(-0.3289203643798828, -0.3053520619869232, 0.20436517894268036, -0.6833435297012329),\n\tvec4(-0.23646926879882812, -0.39187198877334595, -0.08943632990121841, 0.09441051632165909),\n\tvec4(-0.03838440403342247, -0.16300617158412933, 0.16174133121967316, 0.13432244956493378),\n\tvec4(0.11236834526062012, -0.3657267689704895, -0.0058582196943461895, 0.1648707240819931),\n\tvec4(0.02138168178498745, -0.03241175040602684, -0.006450738292187452, 0.17788471281528473),\n\tvec4(-0.10157720744609833, 0.003115433966740966, 0.4887700080871582, -0.5561015009880066),\n\tvec4(0.05721383914351463, 0.17294633388519287, 0.029213573783636093, -0.33972740173339844),\n\tvec4(-0.19630885124206543, -0.2176065295934677, -0.0789634957909584, -0.07688610255718231),\n\tvec4(-0.054229486733675, -0.13319653272628784, -0.04569559916853905, -0.743774950504303),\n\tvec4(-0.0531352162361145, 0.1672227531671524, 0.027568262070417404, -0.568670392036438),\n\tvec4(0.11565385013818741, 0.10313629359006882, -0.2894570529460907, 0.08192063868045807),\n\tvec4(0.0794294998049736, -0.011014207266271114, -0.1765064299106598, -0.41323181986808777),\n\tvec4(-0.14122578501701355, -0.3775023818016052, 0.12886856496334076, 0.4276558458805084),\n\tvec4(-0.40199369192123413, -0.13422594964504242, -0.06828305870294571, -0.09092824906110764),\n\tvec4(-0.035173360258340836, -0.22229686379432678, 0.11432415246963501, 0.053886644542217255),\n\tvec4(-0.21891778707504272, -0.2185964435338974, -0.27393442392349243, -0.27161145210266113),\n\tvec4(0.27548351883888245, 0.36531907320022583, -0.07098689675331116, -0.08931900560855865),\n\tvec4(0.09676289558410645, 0.13589049875736237, 0.14762789011001587, -0.2746075689792633),\n\tvec4(0.17779716849327087, -0.17468389868736267, -0.34513601660728455, 0.3393612504005432),\n\tvec4(-0.27299734950065613, -0.5311522483825684, -0.1307571977376938, 0.16479915380477905)\n);\nconst vec4 w_3_1[32] = vec4[](\n\tvec4(0.00806204229593277, 0.2978309094905853, 0.027917033061385155, -0.21918118000030518),\n\tvec4(0.2012423723936081, 0.2861233949661255, -0.14552219212055206, -0.30301740765571594),\n\tvec4(0.15848225355148315, -0.008035288192331791, -0.20095546543598175, 0.12238147854804993),\n\tvec4(-0.4133993983268738, -0.19731405377388, 0.43146073818206787, -0.1387116014957428),\n\tvec4(-0.16939201951026917, 0.1508246213197708, 0.13685335218906403, -0.13750067353248596),\n\tvec4(0.12607908248901367, 0.43911027908325195, -0.12882272899150848, -0.12014075368642807),\n\tvec4(-0.19811205565929413, 0.22997121512889862, 0.23269085586071014, -0.27519670128822327),\n\tvec4(0.13139869272708893, -0.16207528114318848, -0.16346310079097748, -0.0476783886551857),\n\tvec4(0.1257881224155426, 0.1387762427330017, 0.035648513585329056, -0.12062476575374603),\n\tvec4(-0.10481883585453033, 0.07256222516298294, -0.05525338649749756, -0.09672362357378006),\n\tvec4(-0.11549555510282516, -0.0869242250919342, 0.09672074019908905, -0.21139392256736755),\n\tvec4(0.2573812007904053, -0.14252212643623352, 0.08179658651351929, 0.01678401604294777),\n\tvec4(0.33365094661712646, -0.2649020254611969, -0.36130842566490173, 0.07212461531162262),\n\tvec4(-0.1755961775779724, -0.04263463616371155, 0.19791442155838013, 0.1603594422340393),\n\tvec4(-0.049747344106435776, -0.10422559827566147, 0.00042772546294145286, 0.2415054589509964),\n\tvec4(0.03749062120914459, -0.15148332715034485, 0.264436811208725, -0.07126950472593307),\n\tvec4(0.14279985427856445, -0.0535280704498291, -0.17500071227550507, 0.06389081478118896),\n\tvec4(0.0956399068236351, 0.20494158565998077, -0.10767155885696411, -0.2557304799556732),\n\tvec4(0.11417032033205032, 0.22513119876384735, -0.23704566061496735, 0.11079108715057373),\n\tvec4(0.23730415105819702, -0.023779120296239853, -0.3729061782360077, 0.30263498425483704),\n\tvec4(-0.130824014544487, 0.2763434052467346, -0.012263133190572262, -0.030443107709288597),\n\tvec4(0.30342739820480347, 0.4425470232963562, -0.45980408787727356, -0.11698773503303528),\n\tvec4(-0.01740313693881035, 0.26912933588027954, -0.05150832235813141, 0.1536964625120163),\n\tvec4(-0.10814674198627472, 0.1368774175643921, -0.13116919994354248, 0.24391406774520874),\n\tvec4(-0.03369401395320892, -0.44432586431503296, 0.20288370549678802, 0.24067558348178864),\n\tvec4(0.035036925226449966, 0.13383382558822632, -0.14003825187683105, 0.3061456084251404),\n\tvec4(-0.14449958503246307, -0.22481375932693481, 0.36841607093811035, -0.0020447680726647377),\n\tvec4(0.212208554148674, -0.023873642086982727, -0.0865849107503891, -0.06487374752759933),\n\tvec4(0.024161048233509064, 0.22368833422660828, -0.29119300842285156, 0.1487007588148117),\n\tvec4(0.17377310991287231, 0.021288741379976273, -0.1959770917892456, 0.08839697390794754),\n\tvec4(0.09363894164562225, -0.3167833089828491, 0.06491920351982117, 0.08637373149394989),\n\tvec4(0.07252329587936401, -0.42581111192703247, 0.3066307604312897, 0.14577323198318481)\n);\nconst vec4 w_3_2[32] = vec4[](\n\tvec4(0.2651999592781067, -0.46786952018737793, -0.19415752589702606, 0.5941985249519348),\n\tvec4(0.28653135895729065, -0.24522286653518677, -0.07418983429670334, 0.10728880017995834),\n\tvec4(-0.09185238182544708, 0.1615697741508484, 0.03621398285031319, -0.32712090015411377),\n\tvec4(-0.17245309054851532, -0.02042520046234131, 0.2956840693950653, -0.029818864539265633),\n\tvec4(0.04515129700303078, 0.01324200164526701, -0.11755670607089996, -0.01423580665141344),\n\tvec4(0.38542836904525757, -0.40104371309280396, -0.3004266619682312, 0.3112175166606903),\n\tvec4(0.2671709358692169, -0.5235385298728943, 0.11006423085927963, 0.07598800212144852),\n\tvec4(-0.31684085726737976, 0.41673439741134644, 0.08325605094432831, -0.053779516369104385),\n\tvec4(0.007038028445094824, 0.05662975087761879, -0.1561034619808197, -0.006349047180265188),\n\tvec4(0.10173109173774719, -0.18832628428936005, -0.09537889808416367, 0.35337117314338684),\n\tvec4(-0.06806474924087524, 0.2579475939273834, 0.2208346426486969, -0.18860311806201935),\n\tvec4(-0.333798348903656, 0.30247825384140015, 0.08439747244119644, -0.03650582954287529),\n\tvec4(-0.12209638953208923, 0.19329482316970825, 0.38750407099723816, -0.40382739901542664),\n\tvec4(-0.09589063376188278, 0.054211389273405075, 0.10455113649368286, -0.24127905070781708),\n\tvec4(0.05434510484337807, -0.10431376099586487, -0.04772680997848511, 0.08803273737430573),\n\tvec4(-0.03160993754863739, 0.03332262486219406, 0.044866546988487244, -0.12061530351638794),\n\tvec4(-0.18396227061748505, 0.3515459895133972, -0.11643204838037491, -0.018918709829449654),\n\tvec4(-0.04537532478570938, -0.07451041042804718, 0.14321014285087585, 0.1801796406507492),\n\tvec4(0.027773156762123108, 0.07043368369340897, -0.15240447223186493, -0.10994218289852142),\n\tvec4(-0.08901859074831009, 0.1806013584136963, -0.2013159841299057, -0.012975339777767658),\n\tvec4(0.3611210584640503, -0.44256117939949036, -0.14103098213672638, 0.09498492628335953),\n\tvec4(-0.07510381191968918, 0.12954974174499512, -0.3145976662635803, 0.05603555217385292),\n\tvec4(0.1380222737789154, -0.2907073199748993, -0.46726033091545105, 0.3989110589027405),\n\tvec4(0.05744658038020134, 0.09936750680208206, -0.5444962978363037, 0.3448418080806732),\n\tvec4(-0.30919837951660156, 0.5014883279800415, 0.29150262475013733, -0.5448916554450989),\n\tvec4(-0.14322106540203094, 0.16560150682926178, -0.1972460299730301, -0.17250041663646698),\n\tvec4(0.18227751553058624, -0.2843083143234253, 0.2030966430902481, -0.18157044053077698),\n\tvec4(-0.09220076352357864, -0.15670163929462433, 0.2675425112247467, -0.04786502942442894),\n\tvec4(0.10996478796005249, 0.06230802461504936, -0.22754201292991638, -0.21295876801013947),\n\tvec4(0.03483578935265541, 0.09345663338899612, -0.4218439757823944, 0.42336949706077576),\n\tvec4(-0.30511438846588135, 0.4028008282184601, 0.13699521124362946, -0.16035756468772888),\n\tvec4(-0.21267083287239075, 0.2844616770744324, 0.21829143166542053, -0.4827711284160614)\n);\nconst vec4 w_3_3[32] = vec4[](\n\tvec4(0.09415245056152344, -0.6413965821266174, -0.5818097591400146, -0.009886679239571095),\n\tvec4(0.27325671911239624, -0.30566057562828064, -0.20158067345619202, -0.3980613052845001),\n\tvec4(-0.14180642366409302, 0.5529016852378845, 0.45291683077812195, -0.24759361147880554),\n\tvec4(-0.1131259873509407, 0.07331874966621399, 0.046382009983062744, 0.08810003846883774),\n\tvec4(0.22848932445049286, -0.01095341145992279, 0.0052216206677258015, 0.04530124366283417),\n\tvec4(0.3093678653240204, -0.602479875087738, -0.4745784401893616, -0.09519542753696442),\n\tvec4(-0.1820077747106552, -0.21273042261600494, -0.42287272214889526, 0.0923628956079483),\n\tvec4(0.09706181287765503, 0.09623923897743225, 0.08715104311704636, 0.2627018690109253),\n\tvec4(0.13778206706047058, 0.11234612762928009, 0.052642516791820526, 0.008749308995902538),\n\tvec4(0.14538279175758362, -0.4344633221626282, -0.28411129117012024, 0.09213455021381378),\n\tvec4(0.019009895622730255, -0.060397226363420486, -0.08454679697751999, 0.018059073016047478),\n\tvec4(0.1345575451850891, -0.01370787899941206, 0.22047659754753113, 0.16474664211273193),\n\tvec4(-0.3611393868923187, 0.4979702830314636, 0.27595868706703186, -0.11101465672254562),\n\tvec4(0.010356562212109566, 0.12384112179279327, 0.039950840175151825, 0.17580650746822357),\n\tvec4(-0.21082265675067902, -0.014381824061274529, 0.005150046199560165, 0.10440221428871155),\n\tvec4(0.14874857664108276, 0.07170547544956207, -0.09485261887311935, 0.03413328900933266),\n\tvec4(0.2510507106781006, 0.07897259294986725, 0.3187093436717987, -0.15929362177848816),\n\tvec4(0.03875860199332237, -0.3380793035030365, -0.30892372131347656, -0.07880137860774994),\n\tvec4(-0.0055709886364638805, -0.014792559668421745, 0.03330414742231369, 0.13510358333587646),\n\tvec4(-0.05126781761646271, 0.2770839035511017, 0.26101961731910706, 0.29042813181877136),\n\tvec4(-0.03056250512599945, -0.15769164264202118, -0.3163934648036957, -0.031510721892118454),\n\tvec4(0.17858199775218964, 0.08022905886173248, 0.1518215537071228, 0.12117048352956772),\n\tvec4(0.13605311512947083, -0.2435491532087326, 0.010121599771082401, 0.10061980038881302),\n\tvec4(0.37455418705940247, 0.09850635379552841, 0.35178694128990173, -0.12013938277959824),\n\tvec4(-0.05769352987408638, 0.3538443446159363, 0.4799193739891052, -0.07158714532852173),\n\tvec4(-0.027881179004907608, 0.37765249609947205, 0.4502217173576355, 0.17684634029865265),\n\tvec4(-0.2386263608932495, 0.008771571330726147, -0.2812706530094147, 0.20706969499588013),\n\tvec4(-0.48676007986068726, -0.08329819142818451, -0.1973377764225006, 0.1530698835849762),\n\tvec4(0.00030411520856432617, 0.43384310603141785, 0.33438190817832947, 0.011827693320810795),\n\tvec4(0.2958633601665497, -0.15778391063213348, 0.11365091800689697, -0.07872623205184937),\n\tvec4(-0.011683009564876556, 0.1587677299976349, 0.2744302451610565, 0.14729729294776917),\n\tvec4(0.04832712560892105, 0.25843364000320435, 0.18444110453128815, 0.17748703062534332)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (any(greaterThan(ivec2(fragCoord), ivec2(iResolution) / 8)))\n    {\n        fragColor = vec4(0.0);\n    \treturn;\n    }\n\n    ivec2 coord = ivec2(fragCoord) / 4;\n    ivec2 l_coord = ivec2(fragCoord) - coord * 4;\n    float[32] z;\n    float l = 0.;\n    for (int i = 0; i < 32; ++i)\n    {\n        float x = gaussian_rand(vec2(coord), float(i) / 32.0) * 1.0;\n        z[i] += x;\n        l += x * x;\n    }\n    l = sqrt(l / 32.);\n    for (int i = 0; i < 32; ++i)\n    {\n        z[i] *= 0.6 / l;\n    }  \n    \n    const vec4 bias[16] = vec4[](\n        vec4(2.516317367553711, 4.091951847076416, -1.2629380226135254, 0.055948834866285324),\n        vec4(1.9612396955490112, 0.6930579543113708, -1.7799102067947388, -1.7437413930892944),\n        vec4(1.6796865463256836, 0.6754928231239319, 0.24819274246692657, 1.4787700176239014),\n        vec4(-0.4272494316101074, 2.6933646202087402, 1.6800161600112915, 1.8662147521972656),\n        vec4(2.791278839111328, 1.0264359712600708, 1.186079740524292, 0.6806027889251709),\n        vec4(1.3023269176483154, -1.030786156654358, 1.3736965656280518, 0.9625260233879089),\n        vec4(1.2855913639068604, -0.693211555480957, 2.158813238143921, 2.4634315967559814),\n        vec4(-0.527617335319519, 1.904981255531311, 0.16934987902641296, 3.5328447818756104),\n        vec4(2.204158067703247, 0.12237805128097534, -0.28105342388153076, -0.5251049399375916),\n        vec4(1.9852488040924072, 0.1210814043879509, 2.8370490074157715, 1.6929080486297607),\n        vec4(1.324993371963501, -2.041128396987915, 1.6835962533950806, 1.899329662322998),\n        vec4(1.07040274143219, 1.7914677858352661, -0.3829791247844696, 2.914555072784424),\n        vec4(1.863815426826477, 0.6083082556724548, 1.323843002319336, -0.2632712423801422),\n        vec4(2.478917360305786, -1.6671037673950195, 2.452317237854004, 0.8725726008415222),\n        vec4(2.2621471881866455, -0.7129921317100525, 1.273683786392212, 0.14456059038639069),\n        vec4(0.008779820054769516, 3.6924099922180176, 2.6283764839172363, 1.945906400680542)\n    );\n    vec4 w[32];\n    switch (l_coord.x + 4 * l_coord.y)\n    {\n\t\tcase 0: w = w_0_0; break;\n\t\tcase 1: w = w_0_1; break;\n\t\tcase 2: w = w_0_2; break;\n\t\tcase 3: w = w_0_3; break;\n\t\tcase 4: w = w_1_0; break;\n\t\tcase 5: w = w_1_1; break;\n\t\tcase 6: w = w_1_2; break;\n\t\tcase 7: w = w_1_3; break;\n\t\tcase 8: w = w_2_0; break;\n\t\tcase 9: w = w_2_1; break;\n\t\tcase 10: w = w_2_2; break;\n\t\tcase 11: w = w_2_3; break;\n\t\tcase 12: w = w_3_0; break;\n\t\tcase 13: w = w_3_1; break;\n\t\tcase 14: w = w_3_2; break;\n\t\tcase 15: w = w_3_3; break;\n    }\n    \n    vec4 x = bias[l_coord.x + 4 * l_coord.y];\n    for (int i = 0; i < 32; ++i)\n    {\n        x += z[i] * w[i];\n    }\n        \n    //relu\n    fragColor = max(x, 0.2 * x);\n}\n", "buffer_b_inputs": [], "buffer_c_code": "// The MIT License\n// Copyright © 2020 Stanislav Pidhorskyi\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nconst vec4 w[9 * 4] = vec4[](\n\tvec4(0.7314838171005249, 0.3665813207626343, -0.14218595623970032, 0.4035870432853699),\n\tvec4(-0.07915392518043518, 0.11021564155817032, 0.26088958978652954, 0.0010459711775183678),\n\tvec4(0.0890863686800003, 0.34533312916755676, 0.17841173708438873, 0.20121882855892181),\n\tvec4(-0.23732443153858185, -0.06496301293373108, 0.22535452246665955, -0.449898898601532),\n\tvec4(0.5398059487342834, 0.6309844255447388, -0.2423064261674881, 0.23937420547008514),\n\tvec4(0.40364542603492737, 0.09075973927974701, -0.017637744545936584, 0.005848166532814503),\n\tvec4(0.3746280074119568, 0.19922073185443878, 0.2512343227863312, 0.343985915184021),\n\tvec4(0.04972020164132118, -0.16728049516677856, 0.12559489905834198, 0.06292801350355148),\n\tvec4(0.3637622594833374, 0.3233804702758789, 0.20572982728481293, 0.6307104229927063),\n\tvec4(1.115000605583191, -0.031030364334583282, 0.06338723003864288, -0.0958206057548523),\n\tvec4(-0.0067107705399394035, 0.009595195762813091, 0.39705389738082886, -0.5610653758049011),\n\tvec4(-0.5916792154312134, -0.010768525302410126, 0.19720008969306946, 0.29398655891418457),\n\tvec4(-0.15114125609397888, 0.5530768036842346, -0.18097800016403198, -0.21676801145076752),\n\tvec4(-0.14847485721111298, -0.02297191321849823, -0.5556602478027344, 0.30958080291748047),\n\tvec4(0.12015020102262497, -0.18268883228302002, 0.054288286715745926, 0.29658180475234985),\n\tvec4(0.30017027258872986, -0.3174821734428406, 0.4163985848426819, -0.42301076650619507),\n\tvec4(0.5657683610916138, -0.6614758968353271, 0.754993736743927, 0.052050910890102386),\n\tvec4(-0.18218010663986206, -0.5924255847930908, -0.3701733648777008, -0.264606773853302),\n\tvec4(-0.20913012325763702, 0.11283711344003677, 0.4263107478618622, 0.2582653760910034),\n\tvec4(0.1921171098947525, 0.4682196080684662, 0.14814500510692596, -0.09310765564441681),\n\tvec4(-0.27984267473220825, -0.18721385300159454, 0.21188601851463318, -0.29757195711135864),\n\tvec4(0.03512084484100342, 0.5171375870704651, -0.01049406360834837, 0.45188307762145996),\n\tvec4(0.10604209452867508, 0.7008545398712158, -0.25532084703445435, -0.04474527761340141),\n\tvec4(-0.25493788719177246, 0.43902337551116943, 0.38752707839012146, 0.48984935879707336),\n\tvec4(-0.5552518963813782, 0.286674827337265, -0.3904719948768616, -0.4096262454986572),\n\tvec4(0.2587150037288666, 0.43396008014678955, -0.06027710437774658, 0.22926881909370422),\n\tvec4(0.36278972029685974, 0.08614841103553772, -0.25359249114990234, -0.3610832393169403),\n\tvec4(-0.031318388879299164, 0.5573079586029053, 0.006370693910866976, -0.051469504833221436),\n\tvec4(-0.410996675491333, 0.3142929971218109, 0.3321583867073059, -0.24940307438373566),\n\tvec4(-0.44733917713165283, 0.21342231333255768, 0.5004261136054993, -0.10127855092287064),\n\tvec4(-0.06273140013217926, -0.4436887800693512, -0.6176273822784424, -0.13444505631923676),\n\tvec4(0.11271310597658157, 0.06779816001653671, -0.04435407370328903, 0.17149049043655396),\n\tvec4(0.6235064268112183, 0.47808095812797546, -0.8288723826408386, -0.1440172791481018),\n\tvec4(0.12113814800977707, -0.04525353014469147, 0.6592318415641785, 0.20397908985614777),\n\tvec4(0.04740845784544945, 0.08277342468500137, 0.23410671949386597, -0.17221781611442566),\n\tvec4(0.5905765295028687, 0.013431565836071968, 0.3999502956867218, 0.3604603111743927)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    if (any(greaterThan(ivec2(fragCoord), ivec2(iResolution) / 4)))\n    {\n        fragColor = vec4(0.0);\n    \treturn;\n    }\n    \n    vec4 x = conv2d(ivec2(fragCoord), iChannel0, w, 2);\n\n    //relu\n    fragColor = max(x, 0.2 * x);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// The MIT License\n// Copyright © 2020 Stanislav Pidhorskyi\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nconst vec4 w[9 * 4] = vec4[](\n\tvec4(-0.13996462523937225, -0.12269645929336548, -0.1253887563943863, -0.1613534390926361),\n\tvec4(0.21700088679790497, 0.1977873146533966, -0.2780013084411621, 0.0675923079252243),\n\tvec4(0.045366887003183365, 0.2135722041130066, -0.4169507920742035, -0.1886170208454132),\n\tvec4(0.14591144025325775, 0.007843190804123878, 0.00917157344520092, 0.13710831105709076),\n\tvec4(0.15425853431224823, 0.11548613756895065, -1.2115508317947388, -0.13187527656555176),\n\tvec4(0.04108324646949768, 0.04059400409460068, -0.5939873456954956, 0.4512542188167572),\n\tvec4(0.2063584178686142, 0.08150607347488403, -0.1310281604528427, -0.14855606853961945),\n\tvec4(0.6938522458076477, 0.2182619273662567, -0.5145301222801208, 0.08347949385643005),\n\tvec4(0.4437715709209442, -0.12848061323165894, -0.022120453417301178, -0.37769636511802673),\n\tvec4(0.04175868257880211, 0.5877113342285156, 0.07236295938491821, -0.18753372132778168),\n\tvec4(-0.1445549726486206, -0.012479310855269432, -0.1688397228717804, -0.05991165339946747),\n\tvec4(0.20923766493797302, -0.20360170304775238, -0.002433291170746088, 0.05777491629123688),\n\tvec4(0.08580930531024933, 0.050850749015808105, -0.1904154270887375, 0.2583092749118805),\n\tvec4(-0.03351575508713722, 0.14681272208690643, -0.8134183883666992, 0.563785970211029),\n\tvec4(0.03474821522831917, 0.1274099051952362, -0.07784903049468994, 0.08821961283683777),\n\tvec4(0.13779951632022858, 0.06900846213102341, -0.3270118534564972, -0.18143513798713684),\n\tvec4(0.07350029796361923, -0.5103210210800171, -0.7193100452423096, 0.09673753380775452),\n\tvec4(-0.13675542175769806, -0.015804750844836235, -0.11629554629325867, -0.08321330696344376),\n\tvec4(-0.35051146149635315, -0.3971123993396759, 0.24421851336956024, 0.12098050862550735),\n\tvec4(0.4440203011035919, -0.18733492493629456, 0.8728824853897095, -0.19414378702640533),\n\tvec4(-0.4515223503112793, -0.4285551905632019, 0.09520091116428375, -0.29598939418792725),\n\tvec4(-0.6451318264007568, -0.05725274607539177, 0.9755538105964661, 0.22404077649116516),\n\tvec4(0.12286899238824844, 0.05183937028050423, 1.1705127954483032, -0.2448687106370926),\n\tvec4(-0.2884620726108551, 0.4327135682106018, 0.9686296582221985, -0.36224761605262756),\n\tvec4(0.4327496886253357, 0.4655965268611908, 0.5933034420013428, 0.4009057879447937),\n\tvec4(0.1390472799539566, 0.5979978442192078, 0.9462890625, 0.0658508911728859),\n\tvec4(0.19703184068202972, 0.29460886120796204, 0.7708656191825867, 0.3518095016479492),\n\tvec4(0.006709598004817963, -0.26805004477500916, -0.5171812772750854, 0.16357235610485077),\n\tvec4(-0.1994154006242752, -0.2735080420970917, -0.6218754053115845, 0.3266620635986328),\n\tvec4(0.4863409101963043, 0.03156531974673271, -0.6381992101669312, -0.16518115997314453),\n\tvec4(-0.17546910047531128, -0.2898574769496918, 0.5262640118598938, -0.4519956111907959),\n\tvec4(-0.1561717987060547, -0.042108096182346344, -0.03941618278622627, -0.5442832708358765),\n\tvec4(0.6873056888580322, 0.1838499903678894, -0.15385141968727112, -0.4910029172897339),\n\tvec4(-0.3459209203720093, 0.13057756423950195, 0.7772271633148193, -0.11909498274326324),\n\tvec4(-0.06532849371433258, 0.6047795414924622, 0.19598856568336487, -0.04578939825296402),\n\tvec4(0.09571918845176697, 0.2761630117893219, -0.43151864409446716, -0.3092068135738373)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    if (any(greaterThan(ivec2(fragCoord), ivec2(iResolution) / 2)))\n    {\n        fragColor = vec4(0.0);\n    \treturn;\n    }\n    \n    vec4 x = conv2d(ivec2(fragCoord), iChannel0, w, 2);\n\n    //relu\n    fragColor = max(x, 0.2 * x);\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlfDf.jpg", "access": "api", "license": "mit", "functions": [[4869, 4869, 4926, 4926, 5390]], "test": "untested"}
{"id": "wtfBDf", "name": "Warped Extruded Skewed Grid", "author": "Shane", "description": "A warped extruded skewed dual tile grid, rendered in an early 2000s demoscene style. :)", "tags": ["grid", "demo", "square", "quad", "extruded", "dystopian", "skewed"], "likes": 392, "viewed": 19587, "published": 3, "date": "1597929249", "time_retrieved": "2024-07-30T20:49:58.397201", "image_code": "/*\n\n    Warped Extruded Skewed Grid\n    ---------------------------\n\n    This is a warped extruded skewed grid, rendered in an early 2000s demoscene \n    style. In particular, the grid cell centers have been skewed into position, \n    then two different sized nonskewed squares have been constructed around them\n    to form a pinwheel arrangement.\n\n\tI've been putting up a bunch of tech-like examples lately, so to break the\n\tmonotony for myself, I decided to code something artsy and more reminiscent \n    of a cliche 2000s demo scene. A lot of 2000s demos were rendered in a grungey \n    dystopian graphic art style, so I kind of went with that. On the technical \n    side, it's a demonstration of grid construction consisting of two different \n    kinds of tiles rendered in a staggered fashion. There's nothing in here \n    that's particularly difficult to implement.\n\n\tOne of the many things I've always admired about demo coders in general is \n    their ability to identify the most visually enticing effects that can be\n    produced with the least amount of effort on whatever machine they're running \n    on.\n\n\tI've attempted to emulate that philosophy by employing a few simple \n    techniques that demoscoders take for granted. These include things like\n    rendering minor details outside the main loop and concentrating on the cheap \n    aspects that have the largest visual impact, like color palettes and camera \n    motion.\n\n    Decent color palettes and textures usually account for a large part of the \n    the final image, and they cost virtually nothing. Camera movements can add \n    interest to a scene, and in the grand scheme of things are very cheap to \n    implement. Warping space can be a little fiddly, especially when positioning \n    lights and so forth, but it's also cheap and interesting, so I've made use\n    of that too.\n\n    The only thing here that I'd consider new is the grid arrangement. I like it \n    because it's a completely ordered grid that looks randomized in height map \n    form, which makes it visually interesting and relatively cheap to produce. \n    Having said that, there are still 8 taps and some skewing involved, so it's \n    probably not the kind of scene that a slow system would be happy with.\n\n    The frame rate in window form was surprisingly better than I'd expected. \n    Having said that, I'm on a pretty quick machine, and it doesn't like running \n    in fullscreen, so it's all relative. There are at least two things that could\n    improve performance. One is face and height buffer storage and the other is\n    using a pinwheel (or pythagorean) arrangement for five (or possibly three) \n    taps, but that would be at the expense of readability, so I'm going to leave \n    it alone.\n\n    By the way, for anyone interested in just the grid code, I'll put up a much\n\tsimpler example later.\n\n\n\n    More interesting tilings:\n\n    // Tiling on steroids. Very cool.\n    Wythoffian Tiling Generator - mla\n    https://www.shadertoy.com/view/wlGSWc\n    //\n    Based on:\n    // \n\tWythoff Uniform Tilings + Duals - fizzer\n\thttps://www.shadertoy.com/view/3tyXWw\n    //\n    Tilings - knighty\n    https://www.shadertoy.com/view/4sf3zX\n\n\n*/\n\n\n#define SKEW_GRID\n\n// Snap the pylons to discreet height units. It looks neater, but I wanted \n// haphazored heights, so it's off by default.\n//#define QUANTIZE_HEIGHTS\n\n// Flattening the grid in order to discern the 2D face pattern more clearly.\n//#define FLAT_GRID\n\n// Grid positioning independant of the camera path.\n//#define PTH_INDPNT_GRD\n\n// Grayscale, for that artsy look. Technically, a touch of color has been \n// left in, but the palette has a gray feel.\n//#define GRAYSCALE\n\n// Reverse the color palette.\n//#define REVERSE_PALETTE\n\n// Max ray distance: If deliberately set this up close for artistic effect (and to\n// save a few cycles), but you'd normally set this higher to put the horizon further away.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the floor object from the pylons.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// vec3 to float.\nfloat hash31(vec3 p){\n    return fract(sin(dot(p, vec3(12.989, 78.233, 57.263)))*43758.5453);\n}\n\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    \n    //return vec2(0);\n    return vec2(3.*sin(z*.1) + .5*cos(z*.4), 0);\n}\n\n\n// 2D texture function.\n//\nvec3 getTex(in vec2 p){\n    \n    // Stretching things out so that the image fills up the window.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, p/8.).xyz;\n    //vec3 tx = textureLod(iChannel0, p, 0.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n    \n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;    \n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){\n\n    return inverse(mat2(1, -s.y, -s.x, 1))*p;\n}\n\n\n// A dual face extruded block grid with additional skewing. This particular one\n// is rendered in a pinwheel arrangement.\n//\n// The idea is very simple: Produce a skewed grid full of packed objects.\n// That is, use the center pixel of each object within the cell to obtain a height \n// value (read in from a height map), then render a pylon at that height.\n \n// Global local coordinates. It's lazy putting them here, but I'll tidy this up later.\nvec2 gP;\n\n\nvec4 blocks(vec3 q){\n\n    \n    // Scale... Kind of redundant here, but sometimes there's a distinction\n    // between scale and dimension.\n\tconst vec2 scale = vec2(1./5.);\n\n    // Block dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = scale;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n    \n    #ifdef SKEW_GRID\n    // Skewing half way along X, and Y.\n    const vec2 sk = vec2(-.5, .5);\n    #else\n    const vec2 sk = vec2(0);\n    #endif\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    // Height scale.\n    #ifdef FLAT_GRID\n    const float hs = 0.; // Zero height pylons for the flat grid.\n    #else\n    const float hs = .4;\n    #endif\n    \n    float height = 0.; // Pylon height.\n\n\n    // Local cell coordinate copy.\n    gP = vec2(0);\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2. -  ps4[0]/2.;\n        \n        // Skewed local coordinates.\n        p = skewXY(q.xz, sk);\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        \n        // Unskewing the rectangular cell ID.\n\t    idi = unskewXY(idi*s, sk); \n        \n \n        // The larger grid cell face.\n        //\n        vec2 idi1 = idi; // Block's central position, and ID.\n        float h1 = hm(idi1);\n        #ifdef QUANTIZE_HEIGHTS\n        h1 = floor(h1*20.999)/20.; // Discreet height units.\n        #endif\n        h1 *= hs; // Scale the height.\n        \n        // Larger face and height extrusion.\n        float face1 = sBoxS(p, 2./5.*dim - .02*scale.x, .015);\n        //float face1 = length(p) - 2./5.*dim.x;\n        float face1Ext = opExtrusion(face1, q.y + h1, h1, .006); \n    \n        \n        // The second, smaller face.\n        //\n        //vec2 offs = vec2(3./5., -1./5.)*dim;\n        vec2 offs = unskewXY(dim*.5, sk);\n        vec2 idi2 = idi + offs;  // Block's central position, and ID.\n        float h2 = hm(idi2);\n        #ifdef QUANTIZE_HEIGHTS\n        h2 = floor(h2*20.999)/20.; // Discreet height units.\n        #endif\n        h2 *= hs; // Scale the height.\n     \n        // Smaller face and height extrusion.\n        float face2 = sBoxS(p - offs, 1./5.*dim - .02*scale.x, .015);\n        //float face2 = length(p - offs) - 1./5.*dim.x;\n        float face2Ext = opExtrusion(face2, q.y + h2, h2, .006);\n         \n        // Pointed face tips, for an obelisque look, but I wasn't feeling it. :)\n        //face1Ext += face1*.25;\n        //face2Ext += face2*.25;\n        \n        vec4 di = face1Ext<face2Ext? vec4(face1Ext, idi1, h1) : vec4(face2Ext, idi2, h2);\n   \n        \n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di.x<d){\n            d = di.x;\n            id = di.yz;\n            height = di.w;\n            \n            // Setting the local coordinates: This is hacky, but I needed a \n            // copy for the rendering portion, so put this in at the last minute.\n            gP = p;\n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and pylong height.\n    return vec4(d, id, height);\n}\n\nfloat getTwist(float z){ return z*.08; }\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// Speaking of lazy, here's some global glow variables. :D\n// Glow: XYZ is for color (unused), and W is for individual \n// blocks.\nvec4 gGlow = vec4(0);\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Wrap the scene around the path. This mutates the geometry,\n    // but it's easier to implement. By the way, it's possible to\n    // snap the geometry around the path, and I've done that in\n    // other examples.\n    p.xy -= path(p.z);\n    \n    // Twist the geometry along Z. It's cheap and visually effective.\n    // Demosceners having been doing this for as long as I can remember.\n    p.xy *= rot2(getTwist(p.z));\n\n    \n    // Turning one plane into two. It's an old trick.\n    p.y = abs(p.y) - 1.25;\n  \n    // There are gaps between the pylons, so a floor needs to go in\n    // to stop light from getting though.\n    float fl = -p.y + .01;\n    \n    #ifdef PTH_INDPNT_GRD\n    // Keep the blocks independent of the camera movement, but still \n    // twisting with warped space.\n    p.xy += path(p.z);\n    #endif\n    \n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n    // Only alowing certain blocks to glow. We're including some \n    // animation in there as well.\n    float rnd = hash21(gID.xy);\n    //\n    // Standard blinking lights animation.\n    gGlow.w = smoothstep(.992, .997, sin(rnd*6.2831 + iTime/4.)*.5 + .5);\n    //gGlow.w = rnd>.05? 0. : 1.; // Static version.\n \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded blocks.\n    return min(fl, d4.x);\n \n}\n\n  \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n     \n    // Zero out the glow.\n    gGlow = vec4(0);\n    \n    // Random dithering -- This is on the hacky side, but we're trying to cheap out \n    // on the glow by calculating it inside the raymarching loop instead of it's \n    // own one. If the the jump off point was too close to the closest object in the\n    // scene, you wouldn't do this.\n    t = hash31(ro.zxy + rd.yzx)*.25;\n    \n    for(int i = 0; i<128; i++){\n    \n        d = map(ro + rd*t); // Distance function.\n        \n        // Adding in the glow. There'd be better and worse ways to do it.\n        float ad = abs(d + (hash31(ro + rd) - .5)*.05);\n        const float dst = .25;\n        if(ad<dst){\n            gGlow.xyz += gGlow.w*(dst - ad)*(dst - ad)/(1. + t);\n        }\n \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(1. + t*.05) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += i<32? d*.4 : d*.7; \n        //t += d*.5; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p){\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = 0; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n/*\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 6.;\n    p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c*c); // Bluish tinge.\n    \n    return mix(p, p.xzy, n3D2*.4); // Mixing in a bit of purple.\n\n}\n*/ \n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*1.5); // Camera position, doubling as the ray origin.\n    ro.xy += path(ro.z); \n    vec2 roTwist = vec2(0, 0);\n    roTwist *= rot2(-getTwist(ro.z));\n    ro.xy += roTwist;\n    \n\tvec3 lk = vec3(0, 0, ro.z + .25); // \"Look At\" position.\n    lk.xy += path(lk.z); \n    vec2 lkTwist = vec2(0, -.1); // Only twist horizontal and vertcal.\n    lkTwist *= rot2(-getTwist(lk.z));\n    lk.xy += lkTwist;\n    \n\tvec3 lp = vec3(0, 0, ro.z + 3.); // Light.\n    lp.xy += path(lp.z);\n    vec2 lpTwist = vec2(0, -.3); // Only twist horizontal and vertcal.\n    lpTwist *= rot2(-getTwist(lp.z));\n    lp.xy += lpTwist;\n    \n\n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    float a = getTwist(ro.z);\n    // Swiveling the camera about the XY-plane.\n    a += (path(ro.z).x - path(lk.z).x)/(ro.z - lk.z)/4.;\n\tvec3 fw = normalize(lk - ro);\n\t//vec3 up = normalize(vec3(-fw.x, 0, -fw.z));\n\tvec3 up = vec3(sin(a), cos(a), 0);\n\t//vec3 up = vec3(0, 1, 0);\n    vec3 cu = normalize(cross(up, fw));\n\tvec3 cv = cross(fw, cu);   \n    \n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*cu + uv.y*cv + fw/FOV);\t\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID, object ID and local coordinates.\n    vec3 svGID = gID;\n    float svObjID = objID;\n    vec2 svP = gP; \n    \n    vec3 svGlow = gGlow.xyz;\n   \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp);\n        \n          \n        // Texel color. \n\t    vec3 texCol;   \n        \n        // Transforming the texture coordinates according to the camera path\n        // and Z warping.\n        vec3 txP = sp;\n        txP.xy -= path(txP.z);\n        txP.xy *= rot2(getTwist(txP.z));\n        #ifdef PTH_INDPNT_GRD\n        txP.xy += path(txP.z);\n        #endif\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(svGID.xy);\n            \n            // Ramping the shade up a bit.\n            texCol = smoothstep(-.5, 1., tx)*vec3(1, .8, 1.8);\n            \n            \n            // Very fake, but very cheap, bump mapping. Render some equispaced horizontal\n            // dark lines, and some light adjacent ones. As you can see, it gives the\n            // impression of horizontally segmented grooves on the pylons.\n            const float lvls = 8.;\n            \n            // Vertical lines... A bit too much for this example, but useful for a fake\n            // voxel setup.\n            //float vLn = min(abs(txP.x - svGID.x), abs(txP.z - svGID.y));\n            \n            // Horizontal lines (planes, technically) around the pylons.\n            float yDist = (1.25 + abs(txP.y) + svGID.z*2.);\n            float hLn = abs(mod(yDist  + .5/lvls, 1./lvls) - .5/lvls);\n            float hLn2 = abs(mod(yDist + .5/lvls - .008, 1./lvls) - .5/lvls);\n            \n            // Omitting the top and bottom planes... I was in a hurry, and it seems to\n            // work, but there'd be better ways to do this. \n            if(yDist - 2.5<.25/lvls) hLn = 1e5;\n            if(yDist - 2.5<.25/lvls) hLn2 = 1e5;\n            \n            // Rendering the dark and light lines using 2D layering techniques.\n            texCol = mix(texCol, texCol*2., 1. - smoothstep(0., .003, hLn2 - .0035));\n       \t\ttexCol = mix(texCol, texCol/2.5, 1. - smoothstep(0., .003, hLn - .0035));\n       \t\t \n            \n            // Render a dot on the face center of each extruded block for whatever reason...\n            // They were there as markers to begin with, so I got used to them. :)\n            float fDot = length(txP.xz - svGID.xy) - .0086;\n            texCol = mix(texCol, texCol*2., 1. - smoothstep(0., .005, fDot - .0035));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, fDot));\n  \n\n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // there are very slight gaps, so it's still necessary.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 3./(1. + lDist*lDist*.5);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff *= diff*1.35; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 4.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\t//float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\t//float freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff + ao*.25 + vec3(1, .4, .2)*fre*.25 + vec3(1, .4, .2)*spec*4.);\n        \n       \n        // Fake environmental lighting: Interesting, but I couldn't justify it, both\n        // from a visual and logical standpoint.\n        //vec3 cTex = envMap(reflect(rd, sn)); // Be sure to uncomment the function above.\n        //col += col*cTex.zyx*4.;\n\n    \n        // Shading.\n        col *= ao*sh*atten;\n\t\n\t}\n\n    \n    // Applying the glow -- You perform this outside the hit logic block. The reason\n    // I mention this is that I make this mistake all the time and spend ages trying\n    // to figure out why it's not working. :) As for how you apply it, that's up to\n    // you. I made the following up, and I'd imagine there'd be nicer ways to apply \n    // it, but it'll do.\n    svGlow.xyz *= mix(vec3(4, 1, 2), vec3(4, 2, 1), min(svGlow.xyz*3.5, 1.25));\n    col *= .25 + svGlow.xyz*8.;\n   \n    // Some colorful fog: Like the above, it's been tweaked to produce something\n    // colorful that, hopefully, helps the scene. The cool thing about fog is that\n    // it's about as cheap an operation as you could hope for, but has virtually\n    // no impact on the frame rate. With that in mind, it's definitely worth taking\n    // the time to get it looking the way you'd like it to look.\n    vec3 fog =  mix(vec3(4, 1, 2), vec3(4, 2, 1), rd.y*.5 + .5);\n    fog = mix(fog, fog.zyx, smoothstep(0., .35, uv.y - .35));\n    col = mix(col, fog/1.5, smoothstep(0., .99, t*t/FAR/FAR));\n    \n    \n    #ifdef GRAYSCALE\n    // Grayscale... or almost grayscale. :)\n    col = mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .75);\n    #endif \n \n    \n    #ifdef REVERSE_PALETTE\n    col = col.zyx; // A more calming blue, for those who don't like fiery things.\n    #endif\n\n    \n    /*\n    // Uncomment this block if you'd like to see the 2D pattern on its own.\n    uv = fragCoord/iResolution.y;\n    vec4 d = blocks(vec3(uv*2. + iTime/4., 0.));\n    //vec2 offs = inCentRad(gV[0], gV[1], gV[2]).xy;\n    vec3 oCol = smoothstep(-.05, .5, getTex(d.yz));\n    float quadD = sBoxS(gP, 3./5.*vec2(1./5.) - .04, .015);\n    #ifdef SKEW_GRID\n    // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(-.5, .5);//;\n    #else\n    const vec2 sk = vec2(0);\n    #endif\n    gP -= unskewXY(vec2(1./2.), sk)/5.;\n    quadD = min(quadD, sBoxS(gP, 3./10.*vec2(1./5.) - .04/2., .015));\n    float sf = 1./iResolution.y;\n    col = mix(vec3(.1), vec3(0), 1. - smoothstep(0., sf, quadD));\n    col = mix(col, oCol, 1. - smoothstep(0., sf, quadD + .006));\n    */      \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfBDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4016, 4049, 4071, 4071, 4129], [4132, 4160, 4181, 4181, 4244], [4246, 4264, 4285, 4285, 4359], [4362, 4465, 4487, 4515, 4566], [4569, 4596, 4619, 4741, 4891], [4893, 4957, 4977, 4977, 5026], [5029, 5056, 5126, 5183, 5292], [5431, 5459, 5506, 5506, 5591], [5593, 5656, 5684, 5684, 5728], [5730, 5795, 5825, 5825, 5874], [9944, 9944, 9968, 9968, 9984], [10218, 10241, 10259, 10483, 11647], [11652, 11673, 11709, 11758, 12904], [13703, 13894, 13946, 14063, 15344], [15347, 15499, 15535, 15535, 15779], [16959, 16959, 17015, 17048, 25561]], "test": "untested"}
{"id": "WllBDX", "name": "strange_shader_001", "author": "catafest", "description": "I just tested with sound , video , math functions and I got this result ... \nMaybe you can do it better.", "tags": ["video", "audio", "graph", "strange"], "likes": 2, "viewed": 319, "published": 3, "date": "1597926205", "time_retrieved": "2024-07-30T20:49:59.204044", "image_code": "mat4 rotation_by_Z( in float angle ) {\n    return mat4(    cos(angle),     -sin(angle),    0,  0,\n                    sin(angle),     cos(angle),     0,  0,\n                            0,              0,      1,  0,\n                            0,              0,      0,  1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.xyz = iResolution;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    // a rotation eye view\n    vec3 eye = vec3 ((rotation_by_Z(iTime) * vec4(0.01, 0.1, 0.0, 1.0)).xyz);\n    vec2 v = (eye.xy*fragColor.xy)*fragColor.y, r;\n\n    fragColor *= texture(iChannel0, v*iTime);\n    vec3 oricol = texture( iChannel0, vec2(q.x,q.y)).xyz;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);\n    // Time varying pixel color\n    vec3 col = sin(1.0-(uv.xyx))/cos((eye.xyx/uv.xyx)+(oricol.xyz/uv.yxy));\n    \n    //vec3 col = ((uv.yxy-(sin(oricol.xyz))/(eye.xyx)+uv.xyx));\n\tcol*=1.0-0.5*vec3(clamp((mod(fragCoord.x, 112.0)),0.0,1.0));\n    col*=1.0-0.5*vec3(clamp((mod(fragCoord.y, 12.0)),0.0,1.0));\n    vec3 ori = texture( iChannel1, vec2(q.x,q.y) ).xyz;\n    // Output to screen\n    fragColor = vec4(col*ori,1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllBDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 277], [279, 279, 336, 336, 1186]], "test": "untested"}
{"id": "ttffDf", "name": "motion blur 3", "author": "FabriceNeyret2", "description": "Combine 2 motion blur technique: multisampling in time + relaxation with previous frame\nAlternate 3 modes: time relaxation only, multisampling only, both\nNB: here, blurring is exaggerated.", "tags": ["raymarching", "motionblur"], "likes": 15, "viewed": 490, "published": 3, "date": "1597910279", "time_retrieved": "2024-07-30T20:49:59.968999", "image_code": "void mainImage( out vec4 O, vec2 u ) { O = sqrt( T(u) ); }  // to sRGB", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define n          normalize\n#define d(a,b)     max( 0., dot(a,b) )\n#define hash(p,i)  fract(sin(dot(vec3(p,i), vec3(12.9898, 78.233, 1))) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n  O -= O;\n  vec2 R = iResolution.xy; \n  float T = 20.,                                     // multisampling\n       dt = .1,                                      // blur span\n        r = 1.,                                      // fading prev frames\n        t = mod(iTime, 3.);                          // render mode\n  if (t<1.) T = 1., dt = 0., r=.1;                   // 0: multisampling off, fading on \n                                                     // 1: multisampling on,  fading off          \n  else if (t>2.)  r=.1;                              // 2: multisampling on,  fading on          \n \n  for(float k=0.; k++ < T; ) {                       // add rays of different time\n    float i = 0., d = 1., \n          t = 10.*( iTime + dt*hash(u,k) ),          // jitter time\n          c = .3;                                    // sphere radium\n      \n    vec3 N, L = n(vec3(1,2,-1)),                     // set scene\n         D = n( vec3( 2.*u - R, R.y ) +.1 ), P = D-D,// ray dir and pos\n         C = vec3(0,0,2)+ cos(t)*vec3(1,0,0) + sin(t)*vec3(0,.5,.87); // sphere center\n\n    for(; i++ < 99. && d > 1e-3; P += d*D )          // ray march\n        d = length(P-C) - c;                         // distance to sphere surface\n    \n    N = n(P-C);                                      // normal\n    O += i>99. ?   vec4(0,.5,1,0)                    // noHit\n               : ( .1 + .8* d(N,L) *vec4(1,0,0,0) + .8* pow( d(N,n(L-D)), 40.) ) // Phong\n                 * 3.; // compensate overtransparency due to exaggerated blur\n  }\n  O = mix( T(u), O/T, r);                            // slow fading\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttffDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 58]], "test": "untested"}
{"id": "tlffDX", "name": "Pseudo 3d surface", "author": "michael0884", "description": "SPACE to restart", "tags": ["particles", "ca"], "likes": 23, "viewed": 510, "published": 3, "date": "1597884440", "time_retrieved": "2024-07-30T20:50:00.811746", "image_code": "// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.5\n#define RAD R.x*0.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nfloat DE(vec3 pos)\n{\n    float y = 4.*tanh(0.5*rho(pos));  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(0.5, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n            vec3 albedo = vec3(1,0.3,0.3) + sin(1.*vec3(1.,0.2,0.1)*D);\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(1.,1.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = 0.6*(vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*pow(max(dot(rd, normalize(vec3(-1,-0.5,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 4.);\n            col.xyz = 1.*albedo*colB + 0.3*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(1.3*col*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \n    \tcol.xyz = 2.*sin(0.8*vec3(1,1,1.2)*r);\n    #endif\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 1.1\n\n/* FIRE\n//mold stuff \n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 420.\n#define sense_oscil 0.1\n#define oscil_scale 1.\n#define oscil_pow 2.\n#define sense_force -0.35\n#define distance_scale 0.2\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n*/\n\n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 320.\n#define sense_oscil 0.1\n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force -0.2\n#define distance_scale 1.\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n\n\n//SPH pressure\n#define Pressure(rho) 0.5*rho\n#define fluid_rho 0.2\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        V = vec2(0.);\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the SPH force\n        vec2 F = vec2(0.);\n        vec3 avgV = vec3(0.);\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n            \n            float avgP = 0.5*M0*(Pressure(M) + Pressure(M0)); \n            F -= 0.5*GS(1.*dx)*avgP*dx;\n            avgV += M0*GS(1.*dx)*vec3(V0,1.);\n        }\n        avgV.xy /= avgV.z;\n\n        float ang = atan(V.y, V.x);\n        float dang = sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n        slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.6*dx*GS(dx/20.);\n        }\n        \n        //integrate velocity\n        V += F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 1.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlffDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 440, 467, 467, 645], [684, 684, 715, 715, 749], [751, 751, 803, 803, 922], [924, 924, 959, 959, 983], [985, 985, 1016, 1016, 1103], [1105, 1105, 1126, 1126, 1240], [1242, 1242, 1262, 1262, 1467], [1470, 1470, 1505, 1505, 1690], [1729, 1729, 1761, 1761, 1929], [1931, 1931, 1976, 1976, 3767]], "test": "untested"}
{"id": "tlfBDX", "name": "Fireballs", "author": "michael0884", "description": "SPACE to restart", "tags": ["particles", "ca"], "likes": 31, "viewed": 1239, "published": 3, "date": "1597883065", "time_retrieved": "2024-07-30T20:50:01.594652", "image_code": "// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.5\n#define RAD R.x*0.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nfloat DE(vec3 pos)\n{\n    float y = 4.*tanh(0.5*rho(pos));  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(0.5, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n            vec3 albedo = vec3(1,0.3,0.3) + sin(1.*vec3(1.,0.2,0.1)*D);\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(1.,1.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = 0.6*(vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*pow(max(dot(rd, normalize(vec3(-1,-0.5,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 4.);\n            col.xyz = 1.*albedo*colB + 0.3*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(1.3*col*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \n    \tcol.xyz = 3.*sin(0.1*vec3(3,0.9,0.4)*r);\n    #endif\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 1.1\n\n/* FIRE\n//mold stuff \n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 420.\n#define sense_oscil 0.1\n#define oscil_scale 1.\n#define oscil_pow 2.\n#define sense_force -0.35\n#define distance_scale 0.2\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n*/\n\n#define sense_num 6\n#define sense_ang 1.\n#define sense_dis 150.\n#define sense_oscil 0.1\n#define oscil_scale 1.\n#define oscil_pow 1.\n#define sense_force -0.35\n#define distance_scale 0.2\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n\n\n//SPH pressure\n#define Pressure(rho) 0.5*rho\n#define fluid_rho 0.2\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        V = vec2(0.);\n        M = 0.3*GS(-pos/R);\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the SPH force\n        vec2 F = vec2(0.);\n        vec3 avgV = vec3(0.);\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n            \n            float avgP = 0.5*M0*(Pressure(M) + Pressure(M0)); \n            F -= 0.5*GS(1.*dx)*avgP*dx;\n            avgV += M0*GS(1.*dx)*vec3(V0,1.);\n        }\n        avgV.xy /= avgV.z;\n\n        float ang = atan(V.y, V.x);\n        float dang = sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n        slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.6*dx*GS(dx/20.);\n        }\n        \n        //integrate velocity\n        V += F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 1.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius*radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfBDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 343, 370, 370, 548], [587, 587, 618, 618, 652], [654, 654, 706, 706, 825], [827, 827, 862, 862, 886], [888, 888, 919, 919, 1006], [1008, 1008, 1029, 1029, 1143], [1145, 1145, 1165, 1165, 1370], [1373, 1373, 1408, 1408, 1593], [1632, 1632, 1664, 1664, 1832], [1834, 1834, 1879, 1879, 3672]], "test": "untested"}
{"id": "3lXfW2", "name": "RayMarchacer", "author": "DarkCat5501", "description": "teste para ray marching", "tags": ["vicentedev"], "likes": 0, "viewed": 251, "published": 3, "date": "1597880388", "time_retrieved": "2024-07-30T20:50:02.544114", "image_code": "#define MIN_DIST 0.001\n#define MAX_DIST 100.0\n#define MAX_STEPS 50\n#define MAX_REFLECION 3\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nstruct Ray{\n\tvec3 ro,rd;\n};\n\nfloat  remap01(float a,float b,float c)\n{\n    return (c-a)/b-a;\n}\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel0, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n \treturn mat2(c,-s,s,c);\n}\nfloat smin(float a,float b,float c)\n{\n    float h = clamp(.5+.5*(b-a)/c,0.,1.);\n    return mix(b,a,h) - c*h*(1.-h);\n}\nfloat Dtorus(vec3 pos,float r1,float r2)\n{\n    //pos.yz*=Rot(iTime);\n    float x = length(pos.xz)-r1;\n    float y =  pos.y;\n    float d = length(vec2(x,y))-r2;\n\treturn d;\n}\nfloat Dbox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat DRoundBox(vec3 p,vec3 s,float r)\n{\n    float d = length(p-vec3(clamp(p.x,-s.x+r,s.x-r),clamp(p.y,-s.y+r,s.y-r),clamp(p.z,-s.z+r,s.z-r)))-r;\n    return d;\n}\n\nfloat Dcylinder(vec3 p,vec3 a,vec3 b,float r)\n{\n\tvec3 ap = p-a;\n    vec3 ab = b-a;\n    float t = dot(ab,ap) / dot(ab,ab);\n    vec3 c = a + ab * t;\n    float d = length(p - c)-r;\n    float y = (abs(t*.5)-.5) * length(ab);\n    float i = min(max(d,y),0.0);\n    float e  = length(max(vec2(d,y),0.0));\n    return e+i;\n}\nfloat Dcapsule(vec3 p,vec3 a,vec3 b,float r)\n{\n\tvec3 ap = p-a;\n    vec3 ab = b-a;\n    float t = dot(ab,ap) / dot(ab,ab);\n    t = clamp(t,0.,1.);\n    vec3 c = a + ab * t;\n    return length(p - c)-r;\n\n}\nfloat Dsphere(vec3 pos,float r)\n{\n    vec3 m_pos = pos;\n    m_pos.xz *= Rot(iTime);\n\treturn length(m_pos) - r;\n}\nfloat Dplane(vec3 pos,vec3 normal,float h)\n{\n\treturn dot(pos,normalize(normal))-h;\n}\n\nfloat clouds(vec4 noise,vec3 pos,vec3 size)\n{\n\treturn 0.0;\n}\n\nfloat GetDist(vec3 p)\n{\n    //p.x = mod(p.x,3.0);\n    //p.y = mod(p.y,3.0);\n    //p.z = mod(p.z,3.0);\n    //vec3 pshe = p-vec3(1.5,1.5,1.5);\n       \n        \n    //float dsphere= Dsphere(pshe,0.6);\n    //float dtorus = Dtorus(p-vec3(0.0),1.,0.3);\n    //float dplane = Dplane(p,vec3(0,1,0),-1.0);\n    \n    vec3 boxpos = abs(p)-vec3(10.0,2.0,2.0);\n    \n    \n    \n    \n    \n    float dbox = Dbox(boxpos,vec3(0.5,0.5,0.5));\n    //float dcap = Dcapsule(boxpos,vec3(0.0,0.0,-2.0),vec3(0.0,0.0,2.0),0.3);\n    \n    //float d = smin(dsphere,dplane,2.9);\n    //d = max(-dcap,d);\n    \n    float d = DRoundBox(p-vec3(0.0,2.0,1.0),vec3(0.5),0.1);\n    //d= min(d,dplane);\n    d = min(d,dbox);\n    return d;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    vec2 e = vec2(.01, 0);\n    float d = GetDist(p);\n    vec3 n = vec3(\n    \td-GetDist(p-e.xyy),\n        d-GetDist(p-e.yxy),\n        d-GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat RayMarcher(vec3 pos,vec3 dir)\n{\n\tvec3 m_pos = pos;\n    float dist=0.0;\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        float d = GetDist(m_pos);\n        m_pos += dir*d;\n        dist+=d;\n        if( d<=MIN_DIST || abs(dist)>=MAX_DIST)break;\n        \n    }\n\treturn clamp(dist,0.0,MAX_DIST);\n}\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 sphere_colision(vec3 pos,float r,Ray ray)\n{\n    vec3 spro = vec3(pos-ray.ro);\n    float t = dot(spro,ray.rd);\n    vec3 p = ray.ro+ray.rd*t;\n    \n    float y = length(pos-p);\n    if(y>r) return vec3(1)*MAX_DIST;\n    float x = sqrt(r*r-y*y);\n    float t1 = t-x;\n    float t2 = t+x;\n    return vec3(t1,t,t2);\n}\n\nfloat RayTracer(vec3 ro,vec3 rd)\n{\n    Ray ray = Ray(ro,rd);\n    vec3 sphere = sphere_colision(vec3(0,0,0),1.,ray);\n    \n    \n    float d = sphere.x;\n\treturn d;\n}\n\nfloat GetLight(vec3 p,vec3 lightPos)\n{\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dt = dot(n, l);\n    float dif = clamp(dt,0.0,1.0)*1.0;\n    \n    \n    //float d = RayMarcher(p+n*MIN_DIST*3., l);\n    \n    //dif = dif - (float(d<length(lightPos-p)))*0.9*dif;\n    return dif;\n}\nfloat Reflect(vec3 p,vec3 dir)\n{\n    vec3 pp = p;\n    vec3 l = dir;\n    float d=0.0;\n    \n   \tfor(int i=0;i<MAX_REFLECION;i++){\n        \n        if(d>MAX_DIST)break;\n    \tvec3 n = GetNormal(pp);\n    \tl = reflect(l,n);\n    \tvec3 ponto = pp+n*MIN_DIST*3.;\n  \t\tfloat dS =  RayMarcher(ponto,l);\n       \tpp = ponto+l*dS;\n    \td+=dS;\n    }\n    \n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;\n\n    vec3 cam_pos= vec3(0.0,2.5,-7.0);\n    cam_pos.yz *= Rot(-mouse.y*3.14);\n    cam_pos.xz *= Rot(-mouse.x*6.28);\n    vec3 cam_dir = R(uv,cam_pos,vec3(0,0,0),0.7);\n    float dm = RayMarcher(cam_pos,cam_dir);\n    float dt = RayTracer(cam_pos,cam_dir);\n    float d= min(dt,dm);\n    vec3 pm = cam_pos+cam_dir*dm;\n    vec3 pt = cam_pos+cam_dir*dt;\n    \n   \tvec3 col = GetNormal(pm);\n    \n    col = pow(col, vec3(0.9545));//correção de gama\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXfW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 247, 247, 271], [432, 432, 451, 451, 522], [523, 523, 560, 560, 640], [641, 641, 683, 709, 813], [814, 814, 842, 842, 923], [925, 925, 965, 965, 1086], [1088, 1088, 1135, 1135, 1402], [1403, 1403, 1449, 1449, 1603], [1604, 1604, 1637, 1637, 1716], [1717, 1717, 1761, 1761, 1801], [1803, 1803, 1848, 1848, 1863], [1865, 1865, 1888, 2160, 2559], [2561, 2561, 2585, 2585, 2776], [2778, 2778, 2815, 2815, 3073], [3074, 3074, 3116, 3116, 3311], [3313, 3313, 3361, 3361, 3625], [3627, 3627, 3661, 3661, 3789], [3791, 3791, 3829, 3829, 4104], [4105, 4105, 4137, 4137, 4459], [4460, 4460, 4517, 4517, 5112]], "test": "untested"}
{"id": "ttfBDX", "name": "Volumetric Nebula with Rotation", "author": "Zi7ar21", "description": "Yeetus", "tags": ["volumetric", "nebula", "rotation", "rotationmatrix", "volumetricnebula"], "likes": 5, "viewed": 474, "published": 3, "date": "1597878972", "time_retrieved": "2024-07-30T20:50:03.615250", "image_code": "// Fork of \"My Nebula\" by Zi7ar21. https://shadertoy.com/view/ttfBDN\n// 2020-08-19 23:12:29\n\n// Zi7ar21's In Progress Nebula Ray Marcher --- August 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttfBDN\n// Fork of \"My Very First Working Raymarcher\" by Zi7ar21. [2020-07-06 23:50:09]\n// https://shadertoy.com/view/WlBcDz\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 96\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 16.0\n\n// fBm Number of Octaves (Detail)\n#define NUM_OCTAVES 6\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.1\n\n// If you march less rays, the nebula will appear darker. Bump this up to make it brighter again,\n// Beware there will be more noise\n#define DENSITY 1.0\n\n// Oof ugly mess below watch out lol\n\n// ##### NOISE #####\n\n// White Noise\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\n// Convert Noise to 3D\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// Noise for Dithering\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noised(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// fBm Noise\nfloat fbm(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < NUM_OCTAVES; ++i){\n\t\tv += a * noise(x);\n\t\tx = x * 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat nebulanoise(vec3 raypos){\n\tfloat density = clamp(fbm(raypos)-0.5, 0.0, 1.0)/pow(distance(vec3(0.0), raypos),4.0);\n\treturn density;\n}\n\n// ##### RAYMARCHING #####\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n\tfloat distorigin=0.0;\n\tfloat density=0.0;\n    vec3 raypos = camerapos;\n\tvec3 raydirmod = (raydir+(raydir*(noised(coord+((sin(float(iFrame%60))+3.14159265)*sqrt(coord.x*coord.x+coord.y*coord.y))))*STEP_SIZE))*STEP_SIZE;\n    for(int i=0; i<MAX_MARCHES; i++) {\n    \traypos = raypos + raydirmod;\n        float densityadd = nebulanoise(raypos)*DENSITY;\n        density = density+densityadd;\n        distorigin = raypos.z-camerapos.z;\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return density*0.15;\n}\n\n// ##### RENDERING #####\n\n// ACES Tone Curve\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\t// Dumb rotation matrix hecking Michael begged me to add\n\tfloat xrot = sin(-((iMouse.y/iResolution.y)-0.5)*3.14159265);\n\tfloat yrot = sin(((iMouse.x/iResolution.x)-0.5)*3.14159265);\n\tfloat zrot = 0.0;\n\t// Camera Orientation (Cursed)\n\tvec3 xdir = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\tvec3 ydir = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\tvec3 zdir = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n\tfloat FOV = 2.0;\n\tvec3 camerapos = vec3(-sin((iMouse.y/iResolution.y)-0.5)*3.14159265, 0.0, -3.0);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n\tfloat raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n    // Pixel Color\n    vec3 col = vec3(raymarched);\n\t\n\t// Apply Tone Map\n    col = vec3(acesFilm(col));\n\n    // Output to Screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfBDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1535, 1550, 1572, 1572, 1617], [1618, 1618, 1638, 1638, 1683], [1684, 1684, 1702, 1702, 1741], [1743, 1766, 1786, 1786, 2272], [2274, 2297, 2317, 2317, 2384], [2385, 2385, 2406, 2406, 2615], [2617, 2630, 2648, 2648, 2784], [2786, 2786, 2817, 2817, 2924], [2954, 2979, 3035, 3035, 3541], [3569, 3588, 3617, 3617, 3802], [3804, 3824, 3878, 3936, 4980]], "test": "untested"}
{"id": "ttsfWn", "name": "Random slime mold generator", "author": "michael0884", "description": "random slime mold generator\nSPACE to restart", "tags": ["particles", "ca"], "likes": 27, "viewed": 1759, "published": 3, "date": "1597874774", "time_retrieved": "2024-07-30T20:50:04.541774", "image_code": "// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.5\n#define RAD R.x*0.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nfloat DE(vec3 pos)\n{\n    float y = 4.*tanh(0.5*rho(pos));  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(0.5, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n            vec3 albedo = vec3(1,0.3,0.3) + sin(1.*vec3(1.,0.2,0.1)*D);\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(5.,5.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = 0.6*(vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*pow(max(dot(rd, normalize(vec3(-1,-0.5,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 4.);\n            col.xyz = 1.*albedo*colB + 0.3*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(1.3*col*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \n    \tcol.xyz =  3.*sin(0.2*vec3(1,2,3)*r);\n    #endif\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 1.2\n\n//mold stuff \n#define sense_num 6\n#define sense_ang random_gen(0.1, 1., 40.)\n#define sense_dis random_gen(4., 20., 10.)\n#define sense_oscil random_gen(0., 0.2, 20.)\n#define oscil_scale 0.5\n#define sense_force random_gen(-0.15, 0.05, 30.)\n#define distance_scale random_gen(0., 1.0, 70.)\n#define force_scale 1.5\n#define trailing 0.\n#define acceleration random_gen(0., 0.08, 50.)\n\n//SPH pressure\n#define Pressure(rho) 0.5*rho\n#define fluid_rho 0.2\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        V = vec2(0.);\n        M = 0.07*GS(-pos/R);\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the SPH force\n        vec2 F = vec2(0.);\n        vec3 avgV = vec3(0.);\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n            \n            float avgP = 0.5*M0*(Pressure(M) + Pressure(M0)); \n            F -= 0.5*GS(1.*dx)*avgP*dx;\n            avgV += M0*GS(1.*dx)*vec3(V0,1.);\n        }\n        avgV.xy /= avgV.z;\n\n        float ang = atan(V.y, V.x);\n        float dang = sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n        \tslimeF +=  sense_oscil*Rot(oscil_scale*(s0.z - M))*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n        slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.6*dx*GS(dx/20.);\n        }\n        \n        //integrate velocity\n        V += F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 1.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius*radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 255, 255, 433], [472, 472, 503, 503, 537], [539, 539, 591, 591, 710], [712, 712, 747, 747, 771], [773, 773, 804, 804, 891], [893, 893, 914, 914, 1028], [1030, 1030, 1050, 1050, 1255], [1258, 1258, 1293, 1293, 1478], [1517, 1517, 1549, 1549, 1717], [1719, 1719, 1764, 1764, 3554]], "test": "untested"}
{"id": "WlXBDf", "name": "Landau Ginzburg fluid", "author": "michael0884", "description": "Really weird system", "tags": ["particles", "ca"], "likes": 47, "viewed": 1239, "published": 3, "date": "1597861070", "time_retrieved": "2024-07-30T20:50:05.462311", "image_code": "// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.5\n#define RAD R.x*0.64\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nfloat DE(vec3 pos)\n{\n    float y = 3.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(uv.x*2., 0.3*uv.y - 0.4)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n            vec3 albedo = vec3(1,0.1,0.1);//sin(0.3*vec3(1,2,3)*D);\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = vec3(0.) + 1.*dot(n, normalize(vec3(1.)));\n            colB += 6.*pow(max(dot(rd, normalize(vec3(1.))), 0.), 20.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB;\n        }\n        else\n        {    \n            //background\n            col = 0.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(2.*pow(col,vec4(0.6)));\n    #else\n    \tfloat r = P(pos.xy).z;\n    \n    \tcol.xyz = sin(0.3*vec3(1,2,3)*r);\n    #endif\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\n#define distribution_size 0.7\n\n//mold stuff \n#define sense_num 12\n#define sense_ang 0.\n#define sense_dis 10.\n#define sense_speed 0.0\n\n#define sense_force 0.3\n#define angle_scale 0.\n#define distance_scale 1.\n#define force_scale 1.\n#define trailing 0.\n#define acceleration 0.\n\n//SPH pressure\n#define Pressure(rho) 0.5*rho\n#define fluid_rho 0.2\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        M = 0.3*GS(-pos/R);\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the SPH force\n        vec2 F = vec2(0.);\n        vec3 avgV = vec3(0.);\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n            \n            float avgP = 0.5*M0*(Pressure(M) + Pressure(M0)); \n            F -= 0.5*GS(1.*dx)*avgP*dx;\n            avgV += M0*GS(1.*dx)*vec3(V0,1.);\n        }\n        avgV.xy /= avgV.z;\n\n        float ang = atan(V.y, V.x);\n        float dang = 2.*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        loop(i, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n            float allign = exp(-sense_ang*distance(Dir(cang), Dir(ang))*distance(Dir(cang), Dir(ang)));\n        \tslimeF += allign*sense_force*((Rot(0.5*(s0.z - M))*s0.xy) + Dir(cang)); \n        }\n        //remove acceleration component\n        slimeF -= (1. - 0.0)*dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.6*dx*GS(dx/13.);\n        }\n       \t  \n        //integrate velocity\n        V += F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 1.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius*radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXBDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 255, 255, 433], [473, 473, 504, 504, 538], [540, 540, 592, 592, 711], [713, 713, 748, 748, 772], [774, 774, 805, 805, 892], [894, 894, 915, 915, 1029], [1031, 1031, 1051, 1051, 1246], [1249, 1249, 1284, 1284, 1469], [1508, 1508, 1540, 1540, 1708], [1710, 1710, 1755, 1755, 3440]], "test": "untested"}
{"id": "3lXBDf", "name": "pasoblig", "author": "kloumpt", "description": "bling bling", "tags": ["paso", "doble"], "likes": 1, "viewed": 696, "published": 3, "date": "1597857976", "time_retrieved": "2024-07-30T20:50:06.324008", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23762, "src": "https://soundcloud.com/user-777419262/bien-baladee", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "float scene(vec3 p, float t) {\n    float d = 1000.0;\n    \n    p = vec3(rot(p.xz, t), p.y).xzy;\n    p = vec3(rot(p.xy, t), p.z).xyz;\n    \n    d = min(d, sdBox(p, vec3(0.5) / (1.0 - cos(t / 4.0 * PI) * 0.5)));\n    \n    return d;\n}\n\nvec3 trace(vec2 uv, float t) {\n    vec3 p = vec3((uv.xy * 2.0 - 1.0)* iResolution.xy / iResolution.yy, -2.0);\n    vec3 d = normalize(vec3((uv.xy * 2.0 - 1.0)* iResolution.xy / iResolution.yy, 2.0));\n    \n    for (int i=0; i<16; i++) {\n    \tp += scene(p, t) * d;   \n    }\n    \n    vec3 color = texture(iChannel1, p.xy).rgb;\n    color*= step(-0.01, -scene(p, t));\n    \n    return color;\n}\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    float t = iTime / 60.0 * BPM;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color_bg = abs(fract(uv.xyy + t / 8.0) * 2.0 - 1.0);\n    color_bg = vec3(fract(color_bg.x / 1.312), fract(color_bg.y / 2.0  + color_bg.x / 2.0), fract(-color_bg.x * color_bg.y));\n    color_bg = texture(iChannel2, uv.xy / 10.0 + color_bg.xy).rgb;\n    \n    vec3 color = color_bg;\n    \n    vec3 color_scene = trace(uv, t);\n    \n    color = mix(color, color_scene, step(0.01,length(color_scene)));\n    \n    color_bg = texture(iChannel2, uv.xy).rgb;\n    color = clamp(color, color_bg - 16.0 / 255.0, color_bg + 16.0 / 255.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = iTime / 60.0 * BPM;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    vec3 color_st = texture(iChannel1, (uv.xy - 0.5) / 1.75 + 0.5 ).rgb;\n    color_st = texture(iChannel1, (uv.xy - 0.5) / 1.75 + 0.5 + 0.07 * rot(vec2(0.0, length(color_st)), t / 16.0)).rgb;\n    \n    \n    color_st = abs(fract(color_st * 4. - t / 4.0) * 2.0 - 1.0);\n    \n    color = mix(color, color_st * (1.0 - normalize(color)), step(color.b, color_st.b));\n    \n    \n    \n    fragColor = vec4(color,1.0);\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BPM 45.0\n\n\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n#define PI 3.141592\n\n\nvec2 rot(vec2 p, float r) {\n    return vec2(\n        cos(r * PI) * p.x - sin(r * PI) * p.y,\n        cos(r * PI) * p.y + sin(r * PI) * p.x \n    );\n}\n\n\n", "buffer_c_code": "float scene(vec3 p, float t) {\n    float d = 1000.0;\n    \n    d = min(d, sdBox(p - vec3(-2.0, 1.0 - pow(abs(fract(t / 16.0) * 2.0 - 1.0), 3.0), 0.0), vec3(0.5, 0.5, 0.125)));\n    d = min(d, sdBox(p - vec3(+2.0, 1.0 - pow(abs(fract(t / 4.0) * 2.0 - 1.0), 3.0), 0.0), vec3(0.5, 0.75, 0.125)));\n    d = min(d, sdBox(p - vec3(-1.0, 1.0 - pow(abs(fract(t * 1.0) * 2.0 - 1.0), 3.0), 0.0), vec3(0.25, 0.75, 0.125)));\n    d = min(d, sdBox(p - vec3(+1.0, 1.0 - pow(abs(fract(t * 2.0) * 2.0 - 1.0), 3.0), 0.0), vec3(0.125, 1.0, 0.125)));\n    \n    p = vec3(rot(p.xz, t), p.y).xzy;\n    p = vec3(rot(p.xy, t), p.z).xyz;\n    \n    d = min(d, sdBox(p, vec3(0.5) / (1.0 - cos(t / 4.0 * PI) * 0.5)));\n    \n    return d;\n}\n\nvec3 trace(vec2 uv, float t) {\n    vec3 p = vec3((uv.xy * 2.0 - 1.0)* iResolution.xy / iResolution.yy, -2.0);\n    vec3 d = normalize(vec3((uv.xy * 2.0 - 1.0)* iResolution.xy / iResolution.yy, 2.0));\n    \n    for (int i=0; i<4; i++) {\n    \tp += scene(p, t) * d;   \n    }\n    \n    vec3 color = texture(iChannel0, uv.xy).rgb;\n    color*= step(-0.01, -scene(p, t));\n    \n    return color;\n}\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    float t = iTime / 60.0 * BPM;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color_bg = abs(fract(uv.xyy - t / 8.0) * 2.0 - 1.0);\n    color_bg = vec3(fract(color_bg.x / 1.312), fract(color_bg.y / 2.0  + color_bg.x / 2.0), fract(-color_bg.x * color_bg.y));\n    color_bg = texture(iChannel1, uv.xy / 10.0 + color_bg.xy).rgb;\n    \n    vec3 color = color_bg;\n    \n    vec3 color_scene = trace(uv, t);\n    \n    color = mix(color, abs(fract(color_scene + 4.0 * color_scene * color - t / 4.0) * 2.0 - 1.0), step(0.01,length(color_scene)));\n    \n    color_bg = texture(iChannel1, uv.xy).rgb;\n    color = clamp(color_bg, color - 4.0 / 255.0, color + 4.0 / 255.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "buffer_c_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXBDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 174]], "test": "untested"}
{"id": "WtXBWf", "name": "[TWITCH] Venus Bebop", "author": "evvvvil", "description": "Venus Bebop - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["terrain", "demoscene", "glow", "organic", "city", "island", "world", "dark", "mountain", "other", "network", "cowboy", "bebop"], "likes": 19, "viewed": 831, "published": 3, "date": "1597849542", "time_retrieved": "2024-07-30T20:50:07.135837", "image_code": "// Venus Bebop - Result of an improvised live coding session on Twitch\n// Vaguely inspired by the floating islands on Venus in Cowboy Bebop\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,b,bb,g,gg,tnoi; vec3 np,bp,op,pp,po,no,al,ld;\nfloat bo(vec3 p,vec3 r){ p = abs(p) - r; return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin( float d1, float d2, float k ){  float h = max(k-abs(d1-d2),0.0);return min(d1,d2)-h*h*0.25/k; }\nfloat smax( float d1, float d2, float k ){  float h = max(k-abs(-d1-d2),0.0);return max(-d1,d2)+h*h*0.25/k; }\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25; //MERCURTY SDF LIBRARY IS HERE OFF COURSE: http://mercury.sexy/hg_sdf/\n                       f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nfloat cy(vec3 p,vec3 r){ return max(abs(length(p.xz)-r.x)-r.y,abs(p.y)-r.z);}\nvec2 tower( vec3 p,float flying)\n{\n    vec2 h,t=vec2(cy(p,vec3(.8,.2,1.2)),5);//BLUE CYL CUT\n    t.x=max(t.x,-(abs(abs(abs(p.y)-.4)-.2)-.1));\n    t.x=max(t.x,-(abs(p.z)-.2)); \n    h=vec2(cy(p,vec3(.5,.1,1.4)),6); //WHITE OUTTER\n    h.x=max(h.x,-(abs(p.z)-.4));\n    h.x=smin(h.x,length(abs(p)-vec3(0,1.5,1))-.4,.5);\n    h.x=smin(h.x,.6*length(abs(p.xz)-vec2(0,1))-.1+abs(p.y)*.02,.5);  \n    h.x=min(h.x,bo(p+vec3(.7,1,-2.2),vec3(2,4,1))); //FLOOR WHITE\n    t=t.x<h.x?t:h;    \n    if(flying>0.) {\n        h=vec2(bo(abs(p+vec3(.7,1,-2.))-vec3(1.6,1.-sin(tt)*2.,0),vec3(p.z*.1,p.z*.1,10)),6); //BLACK CUBES FLYING  \n        gg+=0.1/(0.1+h.x*h.x*40.);\n        t=t.x<h.x?t:h;\n    }  \n    h=vec2(cy(p,vec3(.8,.1,1.4)),3);//BLACK CYL  \n    h.x=min(h.x,bo(abs(p+vec3(.7,1,-2.))-vec3(2.,2,0),vec3(.1,2,1))); //BLACK EDGES FLOOR \n    h.x=max(h.x,-(abs(p.z)-.3));\n    t=t.x<h.x?t:h;\n    p.xy*=r2(-sin(p.y*.2)*.5);  \n    t=t.x<h.x?t:h;  \n    return t;\n}\nvec4 c=vec4(0,5,5,.2);\nvec2 mp( vec3 p)\n{\n    op=p;\n    p.x+=sin(op.z*.1+tt*.2)*2.;\n    p.z=mod(p.z+tt*2.,20.)-10.;\n    vec3 tp=p;\n    float disp=sin(p.x*.4)+cos(p.z*.2)*.5;\n    vec2 _uv=vec2(op.x,dot(op.yz+vec2(0,tt*2.),vec2(.5)));\n    tnoi=texNoise(_uv*.05).r;  \n    vec3 towp=2.1*(p-vec3(0,1.1,-1.));\n    for(int i=0;i<3;i++){\n        towp.xz=abs(towp.xz)-vec2(1.5,1);\n        towp.xz*=r2(.55);\n    }   \n    towp.xz-=1.;\n    vec2 h,t=tower(towp,0.);t.x/=2.5;  //FIRST ROUND OF TOWER KIFS\n    bp=towp; bp.xy*=r2(-.3-sin(p.y*.2+tt+op.z*.1)*.4);\n    h=vec2(.7*(length(bp.xz+vec2(-0,2.))-.1+p.y*.05)*.5,6);//LAZER\n    h.x=max(h.x,-p.y);\n    g+=0.1/(0.1+h.x*h.x*40.);   \n    t=t.x<h.x?t:h;   \n    towp.yz*=r2(.785*2.); \n    towp.xy-=vec2(1.,0.1);\n    h=tower(towp,1.);h.x/=2.5;  //SECOND ROUND OF TOWER KIFS\n    t=t.x<h.x?t:h;\n    h=vec2(length(tp)-7.+sin(p.z*.3)*1.5+tnoi*2.5,7);//TERRAIN  STARTS WITH SPHERE\n    h.x=smax(-p.y-.2+tnoi*2.,h.x,1.5);  //SMOOTH CUT SPHERE WITH PLANE\n    h.x=smax(length(tp-vec3(0,0,-1))-1.5+tnoi,h.x,1.5);   //SMOOTH SUBSTRACT SPHERE IN MIDDLE OF ISLAND\n    h.x=smin(h.x,p.y+7.+sin(op.x*.15+1.5)+sin(op.z*.3+tt*.6+3.14)*1.5+tnoi*3.,5.); //SMOOTH MIN ADD TERRAIN AT BOTTOM\n    h.x=smin(length(abs(tp.xz-vec2(2.-tnoi,-1))-4.+disp)-2.+tnoi+(abs(p.y)+5.+tnoi*2.)*0.2,h.x,1.5);//SMOOTH MIN ADD 4 SPIKEY MOUTAINS ON SIDE OF ISLAND\n    h.x=smin(length(abs(op.xy+vec2(0,1.5))-vec2(2.5+sin(op.z*.2+tt*.4)*1.,0.))-1.3+tnoi*2.+sin(op.z*10.+tt*20.)*.03+sin(op.z*.5+tt*2.)*.4,h.x,1.5);  //SMOOTH MIN ADD 2 INFINITE Z CYLINDERS\n    h.x*=0.6; pp=tp;\n    t=t.x<h.x?t:h;   \n    h=vec2(length(cos(p*.5+towp*.4+vec3(0,0,tt*2.))),6); //PARTICLES\n    h.x=max(h.x,length(p.xz)-7.);\n    g+=0.1/(0.1+h.x*h.x*200.);\n    t=t.x<h.x?t:h;\n    return t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n    vec2 h,t=vec2(0.1);\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x);\n        if(h.x<.0001||t.x>100.) break;\n        t.x+=h.x;t.y=h.y;\n    }  \n    if(t.x>100.) t.y=0.;\n    return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=mod(16.+iTime,62.82);\n    vec3 ro=mix(vec3(1),vec3(.3,1.5,1),ceil(sin(tt*.2)))*vec3(cos(tt*.4)*9.,3.-cos(tt*.4)*1.5,-15.),\n    cw=normalize(vec3(0,-6.+sin(tt*.4)*5.,0)-ro),\n    cu=normalize(cross(cw,vec3(0,1,0))),\n    cv=normalize(cross(cu,cw)),\n    rd=mat3(cu,cv,cw)*normalize(vec3(uv,.6)),co,fo;\n    v=vec2(abs(atan(rd.x,rd.z)),rd.y-tt*.02);\n    co=fo=vec3(.13,.1,.1)-length(uv)*.15-rd.y*.15+texNoise(v*.4).r*.3,\n    ld=normalize(vec3(-.2,.3,-.4));\n    z=tr(ro,rd);t=z.x;\n    if(z.y>0.){   \n        po=ro+rd*t;\n        no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n        al=mix(vec3(.1,.2,0.7),vec3(.1,.6,0.8),.5+.5*sin(pp.y*2.+1.));\n        float sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.);\n        if(z.y<5.) al=vec3(0);\n        if(z.y>5.) al=vec3(1);\n        if(z.y>6.) sp=0.,al=mix(vec3(1),vec3(.2,.4,.5),.5+.5*sin(min(-pp.y*.7+.7,2.)+.2+pp.x*.1))-tnoi*1.8;\n        float dif=max(0.,dot(no,ld)),\n        fr=pow(1.+dot(no,rd),4.);    \n        co=mix(sp+al*(a(.05)*a(.1)+.2)*(dif+s(3.)),fo,min(fr,.5));\n        co=mix(fo,co,exp(-.00002*t*t*t));\n    }\n    fragColor = vec4(pow(co+g*.2*vec3(.1,.2,.7)+gg*.2*vec3(.7,.2,.1),vec3(.55)),1);\n} ", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXBWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[339, 339, 363, 363, 410], [411, 411, 428, 428, 471], [472, 472, 514, 514, 579], [580, 580, 622, 622, 689], [690, 690, 713, 713, 1004], [1005, 1005, 1029, 1029, 1082], [1083, 1083, 1117, 1117, 2023], [2047, 2047, 2065, 2065, 3778], [3779, 3779, 3807, 3807, 3998], [4088, 4088, 4145, 4145, 5433]], "test": "untested"}
{"id": "WlffWX", "name": "Orange Chaos", "author": "MysteryPancake", "description": "Modification of code made by https://github.com/cxleb", "tags": ["fractal", "chaos"], "likes": 2, "viewed": 300, "published": 3, "date": "1597836988", "time_retrieved": "2024-07-30T20:50:07.912760", "image_code": "const float firstp = 0.1;\nconst int iterations = 10;\n\nfloat f(float x, float y, float t, float p) {\n\treturn cos( x * (x + t) / (y + p) + t );\n}\n\nfloat iterate(float x, float y, float t) {\n\tfloat p = firstp;\n\tfor (int i = 0; i < iterations; i++) {\n\t\tp = f(x, y, t, p);\n\t}\n\treturn p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat height = sin(iTime) * 0.5 + 1.5;\n\tvec2 uv = (fragCoord/iResolution.xy)*height;\n\tfloat p = iterate(uv.x-height, uv.y-height, cos(iTime));\n\tfragColor = vec4(1.0-p,0.0-p,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlffWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 99, 99, 143], [145, 145, 187, 187, 283], [285, 285, 340, 340, 526]], "test": "untested"}
{"id": "WtffWX", "name": "Caleb's Chaos", "author": "MysteryPancake", "description": "Shader port of code made by https://github.com/cxleb", "tags": ["fractal", "chaos"], "likes": 1, "viewed": 317, "published": 3, "date": "1597836776", "time_retrieved": "2024-07-30T20:50:08.684696", "image_code": "const vec2 size = vec2(16.0, 9.0);\nconst float firstp = 0.0001;\nconst int iterations = 100;\nconst float tend = 20.0;\nconst float tstep = 0.5;\n\nfloat f(float x, float y, float t, float p) {\n\treturn (sin(x * (x + t) / (y + p) + t) + 1.0) * 0.5;\n}\n\nfloat iterate(float x, float y, float t) {\n\tfloat p = firstp;\n\tfor (int i = 0; i < iterations; i++) {\n\t\tp = f(x, -y, t, p);\n\t}\n\treturn p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord / iResolution.xy - 0.5) * size;\n\tfloat t = mod(iTime * tstep, tend);\n\tfloat p = iterate(uv.x, uv.y, t);\n\tfragColor = vec4(p, p, p, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtffWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 188, 188, 244], [246, 246, 288, 288, 385], [387, 387, 442, 442, 603]], "test": "untested"}
{"id": "3tlfD2", "name": "16. Unity Shader Coding For Noob", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=JfC_ye23MvY\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect\n\nI Did It !", "tags": ["unityshader"], "likes": 1, "viewed": 242, "published": 3, "date": "1597800624", "time_retrieved": "2024-07-30T20:50:09.461619", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy ) /iResolution.y;\n\n\tfloat angle = iTime;\n    \n    vec2 p = vec2( cos( angle ) , sin(angle ) ) * 0.4f;\n    vec2 desort = uv - p;\n    float d = length( desort );\n    \n    float m = ( 0.07f , 0.0f , d );\n    \n    m *= 10.0f;\n    \n    \n    // Output to screen\n    fragColor = vec4(1.0 - m , 1.0 - m , 1.0 - m, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 469]], "test": "untested"}
{"id": "3lsBD2", "name": "17. Using Polar Coordinates", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=r1UOB8NVE8I\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect\n\nI understand it ! ", "tags": ["polarcoordinates"], "likes": 3, "viewed": 540, "published": 3, "date": "1597800160", "time_retrieved": "2024-07-30T20:50:10.224579", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy ) / iResolution.y;\n\t \n    // atan( uv.x , uv.y ) : -pi ~ pi so it have to remap 0 ~ 1 by diving 6.2813 + 0.5f\n    vec2 st = vec2( atan(uv.x , uv.y ) , length(uv) );\n    uv = vec2( st.x / 6.2831f + 0.5f + iTime * 0.1f + st.y * 2.0f , st.y );\n    \n    float x = uv.x * 8.0f;\n    float m = min( fract(x) , fract(1.0-x) ); // 0.0f ~ 0.5f : remember this expression\n    float c = smoothstep( 0.0f, 0.01f , m * 0.3f + 0.1f - uv.y );\t// zig zag partten\n    \n    \n    // Zig zag pattern\n    //float c = smoothstep( 0.0f, 0.1f , m - uv.y );\t// zig zag partten\n    \n    // Line pattern\n    //float c = smoothstep( 0.0f , 0.1f , m);\n    \n    \n    //fragColor = vec4(st.x / 6.2831f + 0.5f );\t// -pi ~ pi => Remap 0  ~ 1\n    fragColor = vec4(c );\t// -pi ~ pi => Remap 0  ~ 1\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 874]], "test": "untested"}
{"id": "ttsfDj", "name": "Yeetedly Slow Multipass Nebula", "author": "Zi7ar21", "description": "LoicVDB made the tile system and also fixed it to allow the image to add samples rather than the raw tiles, it fits in Buffer A!", "tags": ["raymarch", "dither", "volumetric", "volumetric", "raymarcher", "nebula", "slow", "multipass", "nonrealtime"], "likes": 11, "viewed": 576, "published": 3, "date": "1597796200", "time_retrieved": "2024-07-30T20:50:11.001501", "image_code": "// ^^^ Switch Between Buffer A and B ^^^\n// Buffer A is Rendering and Settings\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's In Progress Nebula Ray Marcher --- August 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttfBDN\n// Fork of \"My Nebula\" by Zi7ar21. https://shadertoy.com/view/ttfBDN\n// 2020-08-18 22:34:07\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- 2020-09-08 19:37:55\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ^^^ Switch Between Buffer A and B ^^^\n// This is for Rendering and Settings\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 64\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 6.5\n\n// fBm Number of Octaves (Detail)\n#define NUM_OCTAVES 8\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.1\n\n// If you march less rays, the nebula will appear darker. Bump this up to make it brighter again.\n#define DENSITY 0.1\n\n// Tiles, more means easier on the Hardware\n#define TILES 5\n// So kindly made by LoicVDB uwu\n\n// Amount of distortion to apply\n#define DISTORT_AMOUNT 2.5\n\n// Offset the 4D Noise, Basically a different Nebula\n#define W_OFFSET 0.5\n\n// Difference in offset between color channels\n#define W_DIFFERENCE 0.01\n\n// Oof ugly mess below watch out lol\n\n// ##### NOISE #####\n\n// Simplex 4D Noise\n// by Ian McEwan, Ashima Arts\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#simplex-noise\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n  return p;\n}\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,\n                        0.309016994374947451);\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\n// 2D Noise for Dithering\nfloat hash13(vec3 p3){\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// fBm Noise\nfloat fbm(vec4 x){\n    float v = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < NUM_OCTAVES; ++i){\n        v += a * snoise(x);\n        x = x * 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// 4D Nebula Function\nfloat distort(vec3 raypos, float variance){\n    float distort = 0.0;\n    distort = distort+(DISTORT_AMOUNT*fbm(vec4(raypos, variance)));\n    return distort;\n}\n\nfloat nebulanoise(vec3 raypos, float variance, float base){\n    float density = clamp((fbm(vec4((raypos)+distort(raypos, variance), base))-0.25)*8192.0, 0.0, 1.0)/(pow(distance(vec3(0.0), raypos),4.0)*2.0);\n    return density;\n}\n\n// ##### RAYMARCHING #####\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin=0.0;\n    float densityaddr=0.0;\n    float densityaddg=0.0;\n    float densityaddb=0.0;\n    vec3 density=vec3(0.0);\n    vec3 raypos = camerapos;\n    vec3 raydirmod = (raydir*(hash13(vec3(coord, iFrame))+1.0))*STEP_SIZE;\n    for(int i=0; i<MAX_MARCHES; i++) {\n        raypos = raypos + raydirmod;\n        densityaddr = nebulanoise(raypos/4.0,  W_OFFSET-W_DIFFERENCE, W_OFFSET)*DENSITY;\n        densityaddg = nebulanoise(raypos/4.0,  W_OFFSET, W_OFFSET)*DENSITY*0.5;\n        densityaddb = nebulanoise(raypos/4.0,  W_OFFSET+W_DIFFERENCE, W_OFFSET)*DENSITY*0.25;\n        density = vec3(density.r+densityaddr, density.g+densityaddg, density.b+densityaddb);\n        distorigin = raypos.z-camerapos.z;\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return density;\n}\n\n// ##### RENDERING #####\n\n// Render the Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // LoicVDB:I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n    \n    // LoicVDB's Hyper Epic Tiles Function\n    int index = int(fragCoord.x/iResolution.x*float(TILES))\n              + int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n    \n    // Camera Orientation\n    vec3 xdir = vec3(1.0,0.0,0.0);\n    vec3 ydir = vec3(0.0,1.0,0.0);\n    vec3 zdir = vec3(0.0,0.0,1.0);\n    float FOV = 1.0;\n    vec3 camerapos = vec3(0.0, 0.0, -8.0);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    vec2 uvd = fragCoord/iResolution.xy;\n    vec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n    vec3 raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n    // LoicVDB: add the color and increase the sample count\n    fragColor += vec4(raymarched, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Buffer A and B ^^^\n// This is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\nvec3 acesFilm(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0. ? vec3(0.) : texel.rgb / texel.a);\n    \n    // Output to screen\n    fragColor = vec4(acesFilm(color), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[929, 929, 985, 1035, 1142]], "test": "untested"}
{"id": "ttlfWj", "name": "4d SDF with rotation", "author": "palash", "description": "Projection of 4d objects with distance functions. \nCamera is moving in the U axis with sine motion. Use the mouse to rotate around XU and YU axes.\nObjects; Left: 4d Bounding box, Center: 4d cube, Right: 4d sphere.", "tags": ["sdf", "distance", "4d", "rotation"], "likes": 3, "viewed": 443, "published": 3, "date": "1597786603", "time_retrieved": "2024-07-30T20:50:11.783411", "image_code": "// Fork of \"Cylinder - distance\" by iq. https://shadertoy.com/view/wdXGDr\n// 2020-08-18 19:51:15\n\nfloat sdSphere( vec4 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec4 p, vec4 b )\n{\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z, q.w))),0.0);\n}\n\nfloat sdBoundingBox( vec4 p, vec4 b, float e )\n{\n       p = abs(p  )-b;\n  vec4 q = abs(p+e)-e;\n  return min(min(min(\n      length(max(vec4(p.x,q.y,q.z,q.w),0.0))+min(max(p.x,max(q.y,max(q.z, q.w))),0.0),\n      length(max(vec4(q.x,p.y,q.z,q.w),0.0))+min(max(q.x,max(p.y,max(q.z, q.w))),0.0)),\n      length(max(vec4(q.x,q.y,p.z,q.w),0.0))+min(max(q.x,max(q.y,max(p.z, q.w))),0.0)),\n      length(max(vec4(q.x,q.y,q.z,p.w),0.0))+min(max(q.x,max(q.y,max(q.z, p.w))),0.0));\n}\n\n\nfloat map( in vec4 pos )\n{\n    vec3 m = 3.14 * iMouse.xyz/iResolution.xyx;\n    pos = inverse(rotYU(pos, m.x)) * pos;\n    pos = inverse(rotZU(pos, m.y)) * pos;\n    //pos = rotXZ(pos, sin(iTime));\n    //pos = rotZU(pos, sin(iTime));\n    float d = 9999.;\n    d = min(d, sdBoundingBox(pos+vec4(0.8, 0,0,0), vec4(0.2, 0.2, 0.2, 0.2), 0.02 ));\n    d = min(d, sdBox(pos, vec4(0.2, 0.2, 0.2, 0.2) ));\n    d = min(d, sdSphere(pos-vec4(.8, 0,0,0), 0.2 ));\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec4 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( vec4(pos.xyz + e.xyy*eps, pos.w) ) + \n\t\t\t\t\t  e.yyx*map( vec4(pos.xyz + e.yyx*eps, pos.w) ) + \n\t\t\t\t\t  e.yxy*map( vec4(pos.xyz + e.yxy*eps, pos.w) ) + \n\t\t\t\t\t  e.xxx*map( vec4(pos.xyz + e.xxx*eps, pos.w) ) );\n}\n    \n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n    //an = 0.;\n\tvec3 ro = vec3( 1.0*sin(an)-0.4, 0.4, 1.0*cos(an)+0.2 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 3.0;\n        float t = 0.0;\n        float z = sin(iTime/2.)/5.;\n        vec4 pos = vec4(ro + t*rd, z);\n        for( int i=0; i<256; i++ )\n        {\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n            pos.xyz += h*rd;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "mat4 rotXY(in vec4 pos, in float a){\n    return mat4(\n    \tcos(a), sin(a), 0, 0,\n    \t-sin(a), cos(a), 0, 0,\n    \t0, 0, 1, 0,\n    \t0, 0, 0, 1\n    );\n}\n\nmat4 rotYZ(in vec4 pos, in float a){\n    return mat4(\n    \t1, 0, 0, 0,\n    \t0, cos(a), sin(a), 0,\n    \t0, -sin(a), cos(a), 0,\n    \t0, 0, 0, 1\n    );\n}\n\nmat4 rotXZ(in vec4 pos, in float a){\n    return mat4(\n    \tcos(a), 0, -sin(a), 0,\n    \t0, 1, 0, 0,\n    \tsin(a), 0, cos(a), 0,\n    \t0, 0, 0, 1\n    );\n}\n\n\nmat4 rotXU(in vec4 pos, in float a){\n    return mat4(\n    \tcos(a), 0, 0, sin(a),\n    \t0, 1, 0, 0,\n    \t0, 0, 1, 0,\n    \t-sin(a), 0, 0, cos(a)\n    );\n}\n\nmat4 rotYU(in vec4 pos, in float a){\n    return mat4(\n    \t1, 0, 0, 0,\n    \t0, cos(a), 0, -sin(a),\n    \t0, 0, 1, 0,\n    \t0, sin(a), 0, cos(a)\n    );\n}\n\nmat4 rotZU(in vec4 pos, in float a){\n    return mat4(\n    \t1, 0, 0, 0,\n    \t0, 1, 0, 0,\n    \t0, 0, cos(a), -sin(a),\n    \t0, 0, sin(a), cos(a)\n    );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 133, 133, 157], [159, 159, 190, 190, 287], [289, 289, 337, 337, 758], [761, 761, 787, 787, 1222], [1224, 1270, 1302, 1302, 1609]], "test": "untested"}
{"id": "3llBWj", "name": "BC: Circles", "author": "BackwardsCap", "description": "Sort of ford circles\n\nBased off of https://www.shadertoy.com/view/3sSyDG to gain better understanding of whats going on", "tags": ["fractal", "fordcircles"], "likes": 16, "viewed": 508, "published": 3, "date": "1597775708", "time_retrieved": "2024-07-30T20:50:12.552355", "image_code": "#define R iResolution.xy\n#define SS(U) smoothstep(0.,PX,U)\n#define T iTime/5.\n#define S ((1.+sin(T/2.))/4.+.5)\n#define PX (S*6.)/R.y\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 p = S*(2.*f-R)/R.y;\n    p+=vec2(cos(T),sin(T));\n    \n    float s = 1., l;\n    \n    for(int i=0;i<20;i++)\n    {\n        l = dot(p,p)/2.;\n        \n        s /= l;\n        p /= l;\n        \n        p.xy = p.yx;\n        \n        p.x = mod(p.x,2.)-1.;\n    }\n    \n    p/=s;\n    \n    c.rgb = vec3(SS(length(p)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 175, 175, 491]], "test": "untested"}
{"id": "WlsfDj", "name": "Terrain With Altitude Map", "author": "0xAA55", "description": "Using dynamically generated altitude map and K-value map. The K-map algorithm is the trick. Only a few loops can let the ray hits most of the terrain.", "tags": ["terrain", "raycast", "altitude"], "likes": 6, "viewed": 557, "published": 3, "date": "1597769486", "time_retrieved": "2024-07-30T20:50:13.508797", "image_code": "/*\n\nMIT LICENSE\n\nCopyright (c) 2020 0xAA55\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\n\n// Raycast to the map, returns 0 if not cast.\nint MapRaycast(in vec3 Orig, in vec3 Ray, in float MaxDist, out vec3 CastPos, out float CastDist, out float MinStepLen)\n{\n    float RayHorz = length(Ray.xz);\n    if(RayHorz <= Epsilon)\n    {\n        CastPos.y = Altitude(texture(iChannel0, Orig.xz / MapScale));\n        CastDist = Orig.y - CastPos.y;\n        return 1;\n    }\n    \n    float RayK = -Ray.y / RayHorz;\n    CastDist = 0.0;\n    MinStepLen = 100000.0;\n    \n    // Move the orig forward the ray direction and check if it's near enough to the terrain\n    for(int s = 0; s < MaxIterSteps; s++)\n    {\n        float StepLength = 0.0;\n        float Alt = Altitude(texture(iChannel0, Orig.xz / MapScale));\n    \tfloat MapK = texture(iChannel1, Orig.xz / MapScale).z * length(iResolution.xy) / MapScale;\n    \tfloat K = RayK + MapK;\n        \n        // The ray is going away from the map\n        if(RayK < 0.0 && -RayK > MapK)\n        {\n            return 0;\n        }\n        \n        // Calculate the step length to move the orig forward\n        if(K > Epsilon)\n        {\n            StepLength = (Orig.y - Alt) / RayHorz / K;\n            StepLength = max(StepLength * StepLengthModifier, MinDistThreshold);\n            MinStepLen = min(MinStepLen, StepLength);\n        }\n        else\n        {\n            // Infinite step length, the ray is parallel to the map plane and it would never cast to the terrain\n            return 0;\n        }\n        \n        // Do the move\n        Orig += Ray * StepLength;\n        CastDist += StepLength;\n        \n        // Check if near enough\n        if(Orig.y <= Alt + MinDistThreshold)\n        {\n\t\t\tif(StepLength <= MinDistThreshold) break;\n            else\n            {\n                StepLength *= -0.5;\n                Orig += Ray * StepLength;\n                CastDist += StepLength;\n            }\n        }\n        \n        // Check if far enough to give up\n        if(CastDist > MaxDist)\n        {\n            CastDist = MaxDist;\n            return 0;\n        }\n    }\n    \n    CastPos = Orig;\n    return 1;\n}\n\n// Get the normal from the altitude map\nvec3 GetNormal(in vec2 OrigXZ)\n{\n    float Alt1 = Altitude(texture(iChannel0, (OrigXZ - vec2(1.0, 0.0)) / MapScale));\n    float Alt2 = Altitude(texture(iChannel0, (OrigXZ + vec2(1.0, 0.0)) / MapScale));\n    float Alt3 = Altitude(texture(iChannel0, (OrigXZ - vec2(0.0, 1.0)) / MapScale));\n    float Alt4 = Altitude(texture(iChannel0, (OrigXZ + vec2(0.0, 1.0)) / MapScale));\n    return normalize(vec3(Alt1 - Alt2, 2.0, Alt3 - Alt4));\n}\n\n// Render the scene\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // The rotation of the camera\n    float PitchAngle = Pi * 0.33 + Pi * 0.05 * sin(Pi * 0.06 * iTime);\n    float YawAngle = Pi * 0.04 * iTime;\n    mat3 RayRotYaw = mat3\n    (\n        vec3(cos(YawAngle), 0.0, -sin(YawAngle)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(sin(YawAngle), 0.0, cos(YawAngle))\n    );\n    mat3 RayRotPitch = mat3\n    (\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(PitchAngle), -sin(PitchAngle)),\n        vec3(0.0, sin(PitchAngle), cos(PitchAngle))\n    );\n    \n    // Create rays from the screen pixels\n    vec3 StartRay = vec3(fragCoord / iResolution.xy - 0.5, 0.5);\n    StartRay.x *= iResolution.x / iResolution.y;\n    StartRay *= RayRotPitch;\n    StartRay *= RayRotYaw;\n    StartRay = normalize(StartRay);\n    \n    // Prepare raycast to the scene\n    vec3 Orig = vec3(5.0 + sin(iTime * Pi * 0.1) * 50.0, CameraAlt, 5.0 + cos(iTime * Pi * 0.1) * 50.0);\n    float CamPosAlt = Altitude(texture(iChannel0, Orig.xz / MapScale));\n    Orig.y = max(Orig.y, CamPosAlt + 5.0);\n    vec3 Ray = StartRay;\n    vec3 CastPos = Orig;\n    float CastDist = 0.0;\n    float MinStepLen;\n    vec3 Diffuse = FogColor;\n    vec3 Specular = vec3(0);\n    vec3 NLD = normalize(LightDir);\n    vec3 Color = FogColor;\n    \n    // Begin raycast to the scene\n    if(MapRaycast(Orig, Ray, MaxDOV, CastPos, CastDist, MinStepLen) != 0)\n    {\n        // Cast color\n        vec3 CastColor = texture(iChannel3, CastPos.xz / MapScale).xyz;\n        vec3 MetallicColor = texture(iChannel2, CastPos.xz / MapScale).xyz;\n\n        // Cast normal\n        vec3 Normal = GetNormal(CastPos.xz);\n        float NdL = dot(Normal, -NLD);\n        Diffuse = vec3(max(NdL, 0.0));\n        \n        vec3 Halfway = -normalize(Ray + NLD);\n        Specular = vec3(1.0) * min(pow(max(dot(Normal, Halfway), 0.0), TerrainShineness), 1.0);\n        \n        // Add some shadow\n        if(NdL > 0.0)\n        {\n            float Shadow = 0.0;\n            float ShadowDist;\n            vec3 ShadowCastPos;\n            if(MapRaycast(CastPos + (Normal - NLD) * 2.0 * MinDistThreshold, -NLD, MaxDOV, ShadowCastPos, ShadowDist, MinStepLen) != 0)\n            {\n                // Shadowed\n                Shadow = 1.0; // clamp(ShadowDist * 0.5 - MinDistThreshold * 1.5 + NdL * 10.0, 0.0, 1.0);\n            }\n            else\n            {\n                // Soft shadow\n                // I don't know how to implement soft shadow.\n                // So there's no soft shadow.\n                // Sorry.\n            }\n            Diffuse *= 1.0 - Shadow;\n            Specular *= 1.0 - Shadow;\n        }\n        // Add some fog\n        Color = mix((Diffuse + Ambient) * CastColor + Specular * MetallicColor, FogColor, CastDist / MaxDOV);\n    }\n    \n    fragColor = vec4(Color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\nMIT LICENSE\n\nCopyright (c) 2020 0xAA55\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\n\n// You can put your code here to do some additional shading for the input texture.\n// This buffer is the source of the altitude map\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n\nMIT LICENSE\n\nCopyright (c) 2020 0xAA55\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\n\n// Higher for precise map raycasting and more adaptive to the dynamic changing altitude map (e.g. Video as the altitude map)\n// Lower for more FPS. K-map generation is slower.\n// For the static altitude map (A texture, rather than a video), change SEARCH_RADIUS to 1\n#define SEARCH_RADIUS 6\n\nconst int SearchRadius = SEARCH_RADIUS;\n\n// K-map generation\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float MaxK = 0.5;\n    vec2 MaxKPos = fragCoord;\n    float ThisAlt = Altitude(texture(iChannel0, fragCoord / iResolution.xy));\n    \n    // First, calculate the K-value from nearby pixels\n    const int SR = SearchRadius;\n    for(int y = -SR; y <= SR; y++)\n    {\n    \tfor(int x = -SR; x <= SR; x++)\n        {\n            if(x == 0 && y == 0) continue;\n            vec2 xy = vec2(x, y);\n            vec2 CurPosition = (fragCoord + vec2(xy));\n            \n            float CurAltDiff = Altitude(texture(iChannel0, CurPosition / iResolution.xy)) - ThisAlt;\n            float CurDist = length(xy);\n            \n            // Ratio of height difference to distance, is the K-value\n            float K = CurAltDiff / CurDist;\n            if(K > MaxK)\n            {\n                MaxK = K;\n                MaxKPos = CurPosition;\n            }\n        }\n    }\n    \n    // Then, collect the previous K-value result from the nearby pixels, expand the highest ratio to all the map frame by frame.\n    for(int y = -SR; y <= SR; y++)\n    {\n    \tfor(int x = -SR; x <= SR; x++)\n        {\n            if(x == 0 && y == 0) continue;\n            vec2 xy = vec2(x, y);\n            vec2 CurPosition = (fragCoord + vec2(xy));\n            // Nearby pixel K-value and the corresponding coordinate\n            vec4 Data = texture(iChannel1, CurPosition / iResolution.xy);\n            \n            vec2 Position = Data.xy;\n            float AltDiff = Altitude(texture(iChannel0, Position / iResolution.xy)) - ThisAlt;\n            float Dist = distance(fragCoord, Position);\n            if(Dist > 0.5) // Not grabbing current data back from the nearby\n            {\n                float K = AltDiff / Dist;\n                if(K > MaxK)\n                {\n                    MaxK = K;\n                    MaxKPos = Position;\n                }\n            }\n        }\n    }\n    \n    // Output the K-value map\n    fragColor = vec4(MaxKPos, MaxK, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n\nMIT LICENSE\n\nCopyright (c) 2020 0xAA55\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\n\nconst float Pi = 3.14159265358979323846264;\nconst float Epsilon = 0.000001;\n\nconst float MinDistThreshold = 0.05; // The minimum distance value of how to determine if a ray hits the terrain\nconst float MapScale = 192.0; // Magnitude scaling\nconst float AltScale = 20.0; // Altitude scaling\nconst float StepLengthModifier = 0.75;\nconst int MaxIterSteps = 120; // Higher for quality, lower for FPS\nconst float MaxDOV = 300.0; // Max depth of view\nconst vec3 FogColor = vec3(0.8, 0.9, 1.0); // The color of the sky\nconst vec3 LightDir = vec3(0.5, -1.0, 0.5); // The direction of the light\nconst vec3 Ambient = vec3(0.08, 0.09, 0.1); // The ambient lighting for the shadow\nconst float TerrainShineness = 100.0;\nconst float CameraAlt = AltScale + 30.0;\n\nfloat Altitude(vec4 Sample)\n{\n    // If your map is very spiky, change the power value higher.\n    return AltScale * pow(length(Sample.rgb) / length(vec3(1)), 1.0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsfDj.jpg", "access": "api", "license": "mit", "functions": [[1072, 1118, 1239, 1239, 3123], [3125, 3165, 3197, 3197, 3598], [3600, 3620, 3677, 3711, 6420]], "test": "untested"}
{"id": "wlsfRs", "name": "Möller-Trumbore Intersection", "author": "piyushslayer", "description": "Trying out Möller-Trumbore analytical triangle intersection test for ray tracing. Apparently, this is supposed to be faster than the inside-outside or the barycentric coordinates intersection test. ", "tags": ["raytracing", "triangle", "intersection", "barycentric"], "likes": 9, "viewed": 535, "published": 3, "date": "1597758694", "time_retrieved": "2024-07-30T20:50:14.295693", "image_code": "#define EPS .000002\n\n#define AA 4\n\n// uncomment this to enable backface culling\n// #define CULL_BACKFACE\n\nconst vec3 cameraPosition = vec3(0., 2., 12.);\n\nstruct Ray\n{\n\tvec3 origin, direction;  \n};\n\nvec2 hash21(uint q)\n{\n\tuvec2 n = q * uvec2(1597334673U, 3812015801U);\n\tn = (n.x ^ n.y) * uvec2(1597334673U, 3812015801U);\n\treturn vec2(n) * (1. / float(0xffffffffU));\n}\n\nmat3 getCameraMatrix(vec3 origin, vec3 target)\n{\n    vec3 lookAt = normalize(target - origin);\n    vec3 right = normalize(cross(lookAt, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(right, lookAt));\n    return mat3(right, up, lookAt);\n}\n\nRay getCameraRay(vec2 uv)\n{\n    vec3 origin = cameraPosition;\n    vec3 target = vec3(0., 1., 0.);\n    mat3 camera = getCameraMatrix(origin, target);\n    vec3 direction = normalize(camera * vec3(uv, 2.));\n    return Ray(origin, direction);\n}\n\n/**\nTomas Möller & Ben Trumbore (1997) Fast, Minimum Storage Ray-Triangle Intersection,\nJournal of Graphics Tools\nhttps://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf\n*/\nvec3 rayTriangleIntersect(Ray ray, vec3 A, vec3 B, vec3 C)\n{\n\tvec3 result = vec3(-1.);\n    vec3 e1 = B - A; vec3 e2 = C - A;\n    vec3 dxe2 = cross(ray.direction, e2);\n    float det = dot(dxe2, e1);\n    // ray parallel to triangle plane\n\tif (abs(det) < EPS\n#ifdef CULL_BACKFACE\n\t// triangle facing away from camera (with vertices wound counter-clockwise)\n\t|| det < EPS\n#endif\n\t) return result;\n    float invDet = 1. / det;\n    vec3 t = ray.origin - A;\n    float u = dot(dxe2, t) * invDet;\n    vec3 txe1 = cross(t, e1);\n    float v = dot(txe1, ray.direction) * invDet;\n    if (u < 0. || v < 0. || u + v > 1.) return result;\n    float d = dot(txe1, e2) * invDet;\n    result = vec3(d, u, v);\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0.);\n    int aaSamples = AA * AA;\n    for (int i = 0; i < aaSamples; ++i)\n    {\n        // Find x & y subpixel jitter locations\n        float x = mod(float(i), float(AA));\n        float y = mod(float(i / AA), float(AA));\n        \n        // Subpixel jitter\n        vec2 jitter = (hash21(uint(i)) + vec2(x, y)) / float(AA);\n        \n        vec2 uv = (2. * (fragCoord + jitter) - iResolution.xy) / iResolution.y;\n        \n        Ray ray = getCameraRay(uv);\n        \n        float t = iTime * .75;\n        \n        vec3 tri = rayTriangleIntersect(ray, vec3(0., 4. * sin(t), 2. * cos(t)), \n                                             vec3(-3. * cos(t), -3. * sin(t), -2.), \n                                             vec3(3. * cos(t), -1., -6. * sin(t)));\n        \n        // Color the triangle using barycentric weights\n        if (tri.x > 0.)\n\t\t\tcol += vec3(tri.yz, 1. - tri.y - tri.z);\n    }\n    \n    fragColor = vec4(pow(col/float(aaSamples), vec3(.4545)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 219, 219, 366], [368, 368, 416, 416, 608], [610, 610, 637, 637, 850], [1759, 1759, 1814, 1814, 2803]], "test": "untested"}
{"id": "WtsfWj", "name": "Dimension buildup", "author": "ChocolatePinecone", "description": "A texture build up effect. Circular formation of reality", "tags": ["zoom", "build", "dimension", "construct"], "likes": 2, "viewed": 273, "published": 3, "date": "1597757751", "time_retrieved": "2024-07-30T20:50:15.059651", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time increase from 0 to 2\n    float time = mod(iTime * 0.5, 2.0);\n    \n    // Dynamic texture pixel offset\n    vec2 offset = vec2(0.5) - uv;\n    offset /= time;\n    offset *= length(offset);\n\n    // Getting texture pixel\n    vec2 texCoord = uv + offset;\n    vec4 col = texture(iChannel0, texCoord);\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 510]], "test": "untested"}
{"id": "wlXfD2", "name": "PB", "author": "kloumpt", "description": "PB", "tags": ["b", "p"], "likes": 3, "viewed": 278, "published": 3, "date": "1597751873", "time_retrieved": "2024-07-30T20:50:15.958248", "image_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    col*= mix(1.1, 0.975, step(2.0, mod(fragCoord.y, 4.0)));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23749, "src": "https://soundcloud.com/kabanrecords/depardaus-rends-largent-bootlik", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "float in_box(vec2 p) {\n    return (smoothstep(-0.04, 0.0, p.x) * (1.0 - smoothstep(1.0, 1.04, p.x))) * (smoothstep(-0.04, 0.0, p.y) * (1.0 - smoothstep(1.0, 1.04, p.y))); \n}\n\n\nfloat scene (vec3 p, float t) {\n    float d = 10000.0;\n    \n    d = min(d, 1.0 - length(p.xy) - (0.01 - 0.2 * max(0.0, .95 + cos(1.0 / 4.0 * t * 3.141592))) * texture(iChannel3, vec2(8.0 * atan(p.y, p.x) / 3.141592, p.z / 4.0)).r);\n    \n    \n    return d;\n}\n\n\nvec3 trace(vec2 p, float t) {\n    vec3 o = vec3(p.x, p.y, t / 4.0);\n    vec3 d = normalize(vec3(p, 4.0));\n    \n    \n    for (int i = 0; i < 32; i++) {\n     \to += d * scene(o, t);\n    }\n    \n    \n    vec3 col = texture(iChannel3, vec2(8.0 * atan(o.y, o.x) / 3.141592, o.z / 4.0)).rgb;\n    col *= max(0.0, 8.0 - (o.z - t / 4.0)) / 8.0;\n    \n \treturn col;   \n    \n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime * 127.0 / 60.0;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 tv_center = 1.0 * vec2(cos(1.0 / 19.11 * t * 3.141592), sin(1.0 / 13.12 * t * 3.141592));\n    \n    vec2 size = vec2(0.2, 0.2) * 1.0;\n    vec2 uv_tv = (uv - 0.5) / size;\n    uv_tv += 0.5;\n    \n        \n\n    float k = 1.0;\n    for (int i=0; i<2; i++) {\n\n        uv_tv -= 0.5;\n        uv_tv *= mix(vec2(1.0), 0.5 + 1.50 * length(uv_tv) * (1.0 - abs(uv_tv)), 0.0 + 0.9 * sin(k * t / 16.0 * 3.141592) / k);\n        uv_tv += 0.5;\n        \n        k*= 2.0;\n    }\n        \n    uv_tv -= tv_center;\n    \n    vec3 col_bg = trace(2.0 * (uv - 0.5) * iResolution.xy / iResolution.yy, t);\n    \n    vec3 col_top = fract(texture(iChannel3, uv_tv).rgb + texture(iChannel3, -2.0 * uv_tv).rgb);\n    col_top = mix(col_top, vec3(1.0), 0.5)  * vec3(1.4, 1.0, 0.0);\n        \n    vec2 uv_tv_geom = uv_tv;\n    \n    vec3 col_bot = texture(iChannel2, uv_tv_geom).rgb;\n    vec3 col_border = fract(texture(iChannel0, abs(fract(uv_tv + 0.3 * t / iChannelResolution[1].xy - 0.95) * 2.0 - 1.0)).rrr + texture(iChannel0, uv_tv).rrr);\n    vec3 col_tv = texture(iChannel0, abs(fract(uv_tv_geom - vec2(0.0, t / 16.0)) * 2.0 - 1.0)).rgb;\n\t\n    uv_tv_geom -= 0.5;\n    \n    vec3 col = col_bg;\n    col = mix(col, col_top, in_box(uv_tv_geom * 0.65 + 0.5) * smoothstep(-0.25, 0.0, 1.8 - length(uv_tv_geom * iResolution.yy / iResolution.yy)) * smoothstep(0.9 - 0.1 - 0.1 * abs(fract(t/8.0) * 2.0 - 1.0), 0.9 - 0.1 * abs(fract(t/4.0) * 2.0 - 1.0), abs(fract(-uv_tv_geom.x + uv_tv_geom.y) * 2.0 - 1.0)  ));\n    col = mix(col, col_bot, smoothstep(-0.04, 0.0,  0.75 - length(uv_tv_geom)));\n    col = mix(col, col_border, smoothstep(-0.04, 0.0,  0.7 - length(uv_tv_geom)));    \n    col = mix(col, col_tv, in_box(uv_tv));\n    \n    \n    col =  mix(col, uv_tv.xyy, in_box(uv_tv));\n    \n    col = max(vec3(0.0), min(vec3(1.0), col));\n    \n\n    fragColor = vec4(col, in_box(uv_tv));\n}", "buffer_b_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 cola = texture(iChannel0, uv).rgba;\n    vec3 col = cola.rgb;\n    \n    vec2 uv_tv = cola.xy;\n    \n    vec3 col_bg = texture(iChannel1, uv_tv).rgb;\n    vec3 col_bg_dist = texture(iChannel3, uv + 4.0 * normalize(uv - 0.5) / iResolution.xy).rgb;\n    vec3 col_tv = texture(iChannel2, vec2(1.0 - uv_tv.x, uv_tv.y)).rgb;\n    col_tv = mix(col_tv, col_bg, step(0.5, col_tv.g / (0.001 + col_tv.r + col_tv.b)));\n    \n    \n    col = mix(col, col_bg_dist, 1.0 - step(0.2, length(cola.rgb)));\n    \n    col = mix(col, col_tv, cola.a);\n\n    fragColor = vec4(col, 1.0);\n}", "buffer_c_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 236]], "test": "untested"}
{"id": "3lXfWj", "name": "displacement mapping technique", "author": "sympou", "description": "a trick i use to reduce iterations while rendering non-exact sdf.\nthe shape is contained inside a bounding sphere,\nand interpolation is used to get close to the surface.\nit takes max. 12 iterations, but it's not very precise.", "tags": ["displacementmapping"], "likes": 3, "viewed": 387, "published": 3, "date": "1597708548", "time_retrieved": "2024-07-30T20:50:16.741155", "image_code": "// this project is a mess !\n// it is an attempt to make raymarching work on my laptop with good fps\n// it kind of works, but i think i might be interested in simpler ideas\n\n// i used things from this shader by iq :\n// https://www.shadertoy.com/view/4d2XWV\n// and other things from Jamie Wong's article\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions\n// and also was inspired by this article\n// https://learnopengl.com/Advanced-Lighting/Parallax-Mapping\n\nconst int raySteps = 8;\nconst int precisionSteps = 4;\n\nconst vec3 lightDir = normalize(vec3(0.5,1.0,0.5));\n\nfloat iPlane( in vec3 ro, in vec3 rd ) {\n    return (-1.0 - ro.y)/rd.y;\n}\n\nfloat dot2(vec3 p) { return dot(p,p);}\n\nfloat getVal(vec3 p) {    \n      \n    //a collection of implicit surfaces.\n    \n    //the distances are not exact, therefore hasardous to draw with raymarching !\n    \n    //this is why i developed this weird\n    //displacement mapping technique.\n    \n    \n\t//return dot2(p)*1.4164 - max(p.x,max(p.y,p.z)) + min(p.x,min(p.y,p.z));\n    \n    //vec3 p2 = p*p.zxy; return max(dot2(p2) - 0.05, dot(p,p)-0.9999);\n\n    vec3 p1 = p*p.yzx; float d = dot(p,p)*0.7; return d*d*d - dot(p1,p1);\n    \n    //return .5 - cos(p.x*3.1415) - cos(p.y*3.1415) - cos(p.z*3.1415);\n    \n    //float d = dot2(p); return d*d - dot(p,vec3(p.xy,p.z*p.z)) + 0.2;\n    \n    //return dot2(p*p) - 0.333333;\n\n    //float d = dot2(p); vec3 p2 = p*p; vec3 c = p2*p2.yzx; return d*d*d - max( c.x, max(c.y, c.z ) )*4.0 - 0.0001;\n    \n\t//float d = dot2(p); return d*d - dot(abs(p.xyz*p.yzx),vec3(1));\n    \n    //float d = dot2(p); return d*d - abs(p.x*p.y*p.z)*5.1 - 0.0001;\n    \n\t//float d = dot(p,vec3(0.7)); float d2 = d*d; return d2*d2*d2 - dot(p,p.yzx)  - 0.0001;\n    \n    // float d = dot(p,p); vec3 c = p*p.yzx; return d*d - max( c.x, max(c.y, c.z ) );\n\n}\n\n//shape + floor, used to compute AO\nfloat scene(vec3 p) {    \n    return min(getVal(p),p.y+1.0);\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat h = b*b - dot( oc, oc ) + sph.w*sph.w;\n\tif( h<0.0 ) return vec2(-1.0);\n    float sh = sqrt( h );\n\treturn vec2(-sh,sh) - b;\n}\n\nconst float raySteps2 = 1.0/float(raySteps);\nfloat getDist(vec3 ro, vec3 rd, vec4 sph) {\n    \n    //do we hit the bounding sphere ?\n\tvec2 sphBound = sphIntersect( ro, rd, sph );\n    \n    if (sphBound.y == -1.0) { return -1.0; }\n\n    sphBound.x = max(0.0,sphBound.x);\n\n    //do we hit the 3D shape ?\n    //(we look at the shape at regular intervals)\n    vec3 ro2 = (sph.xyz - ro)/sph.w;    \n    float raySteps3 = (sphBound.y-sphBound.x)*raySteps2/sph.w;\n    \n    vec2 t   = vec2(sphBound.x/sph.w,      0.0);\n    vec2 val = vec2(getVal(ro2 - rd*t[0]), 0.0);\n    int i = 0;\n        \n    while (i<raySteps && val[0]>0.0) {\n    \n        t   = vec2(t[0] + raySteps3, t[0]);\n        val = vec2(getVal(ro2 - rd*t[0]), val[0]);\n          \n        i++;\n    }\n    \n    //no surface found\n    if (i == raySteps && val[0]>0.0) { return -1.0; }\n\t\n    //now we try to be more precise using linear interpolation\n    //between 2 points on the inside/outside of the shape\n\n    for (int j = 0; j<precisionSteps; j++) {\n                \n        float newT = mix(t[0],t[1],val[0]/(val[0]-val[1]));\n        \n        float newVal = getVal(ro2 - rd*newT);\n        int c = int(newVal>0.0);\n        \n        t[c]   = newT; \n        val[c] = newVal; \n                \n    }\n    return abs(mix(t[0],t[1],val[0]/(val[0]-val[1]))*sph.w); \n}\n\n\nbool shadowRay(vec3 ro, vec3 rd, vec4 sph) {\n    \n\tvec2 sphBound = sphIntersect( ro, rd, sph );\n    \n    if (sphBound.y < 0.0) { return true; }\n    \n    vec3 ro2 = (sph.xyz - ro)/sph.w;    \n    \n    sphBound.x = max(0.0,sphBound.x);\n    float t1 = sphBound.x/sph.w;\n    float raySteps3 = (sphBound.y-sphBound.x)*raySteps2/sph.w;\n        \n    int startInside = int(sphBound.x == 0.0);  //getVal(ro2 - rd*t1) < 0.;\n\n    t1 += raySteps3*float(startInside);\n    int i = startInside;\n\n    while (i < raySteps && getVal(ro2 - rd*t1) > 0.0 ) {\n        t1 += raySteps3;\n        i++;\n    }\n\n    if (i == raySteps) { return true; }\n    return false;\n        \n    \n}\n\nvec3 distance_field_normal(vec3 pos, float rad) {\n    vec2 eps = vec2(0.0001/rad,0.0);\n    pos /= rad;\n    float nx = getVal(pos + eps.xyy);\n    float ny = getVal(pos + eps.yxy);\n    float nz = getVal(pos + eps.yyx);\n    return normalize(getVal(pos)-vec3(nx, ny, nz));\n}\n\n\n//https://www.shadertoy.com/view/MtlBWB\nconst vec3 sq = 1./vec3(sqrt(2.),sqrt(3.),sqrt(4.));\nconst float eps = 0.125;\nconst vec3 eps2 = eps*vec3(2.,3.,4.);\nfloat ao2(vec3 p, vec3 n) {\n    \n    float c1 = float(abs(n.x) < abs(n.y) && abs(n.x) < abs(n.z));\n    float c2 = float(abs(n.y) < abs(n.z));\n    float c3 = c2 - c2*c1;\n    \n    vec3 t = vec3(c1, c3, 1. - c1 - c3);\n    vec3 u = cross(n, t);\n    vec3 v = cross(n, u);    \n    \n    vec3 epn = eps2[2]*n + p;\n    \n    float occ  = max(scene(p + eps*n),0.0);\n          occ += max(scene(p + eps*u),0.0);\n          occ += max(scene(p - eps*u),0.0);\n          occ += max(scene(p + eps*v),0.0);\n          occ += max(scene(p - eps*v),0.0);\n    \n    occ += (max(scene(epn + eps2.z*u),0.0)\n        +   max(scene(epn - eps2.z*u),0.0)\n        +   max(scene(epn + eps2.z*v),0.0)\n        +   max(scene(epn - eps2.z*v),0.0))*0.5;\n\n    occ += max(scene(p + eps2.x*n)*sq.x,0.0);\n    occ += max(scene(p + eps2.y*n)*sq.y,0.0);\n    occ += max(scene(epn         )*sq.z,0.0);\n\n    return max(1.0 - 1.0/(1.0+2.0*occ), 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    float time2 = iTime*0.25;\n    \n    //ray origin + direction\n\tvec3 ro = vec3(cos(-time2)*6.0, 0.9, sin(-time2)*6.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n    rd.xz = vec2(rd.x*sin(time2)+rd.z*cos(time2),rd.x*cos(time2)-rd.z*sin(time2));\n    \n    //output color\n    vec3 col = vec3(0.0);\n    \n    //closest point\n    float tmin = 1e10;\n    \n    vec3 normals;\n    vec3 objCol = vec3(0.0);\n    vec3 pos;\n\n    //floor\n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 ) {\n        tmin = t1;\n        objCol = vec3(3.0/t1);\n        normals = vec3(0.0,1.0,0.0);\n        pos = ro + tmin*rd;\n    }\n    \t\n    //sph : position of the object + size\n    vec4 sph = vec4(0.0, 0.5, 0.0, 2.0);\n    float dist = getDist( ro, rd, sph);\n    if (dist>0.0) {\n        tmin = min(tmin,dist);\n        objCol = vec3(0.01,0.36,0.64);\n        normals = distance_field_normal(sph.xyz - ro-rd*dist, sph.w);\n        pos = ro + tmin*rd ;\n    }\n    \n    //draw \n    float shadow = float(shadowRay( pos + normals*0.0001, lightDir, sph));\n    \n    float diffuse = max (dot(lightDir,normals),0.0);\n    diffuse = min(diffuse, shadow);\n    //diffuse = shadow;\n\n    vec3 reflectDir = reflect(-lightDir,-normals);\n    float specular = pow (max (dot (-rd, reflectDir), 0.0), 10.0)*0.25;\n    \n    float ao = ao2(pos/sph.w, normals);\n\n    col = ( objCol + specular )*( diffuse + 0.1 )*ao ;\n    \n    //col = vec3(ao);\n    //col = vec3(shadow);\n    \n    fragColor = vec4( sqrt(col.rgb), 1.0 );\n    //fragColor = vec4( col.rg, dist.y/float(raySteps), 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[589, 589, 629, 629, 662], [664, 664, 684, 684, 702], [704, 704, 726, 1109, 1826], [1828, 1864, 1885, 1885, 1926], [1928, 1928, 1986, 1986, 2169], [2216, 2216, 2259, 2302, 3481], [3484, 3484, 3528, 3528, 4139], [4141, 4141, 4190, 4190, 4411], [4570, 4570, 4597, 4597, 5471], [5475, 5475, 5532, 5532, 7117]], "test": "untested"}
{"id": "3tXfW2", "name": "Repared Menger z", "author": "illus0r", "description": "This article helped to overcome the annoying problem with glitchy surfaces. The problem was in `mod` operator, which made SDF discontinuous: http://connorahaskins.com/menger_sponge.html", "tags": ["raymarching"], "likes": 4, "viewed": 420, "published": 3, "date": "1597701361", "time_retrieved": "2024-07-30T20:50:17.512094", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define SURF_DIST .0001\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\n\nfloat random (float x) {\n    return fract(12345.67 * sin(x * 654.24));\n}\n\n\n\nfloat GetDist(vec3 p) {\n    \n\n\n    vec3 ps = p;\n    ps.y += iTime * -.4;\n    float sInterval = .2;\n    ps.xz += vec2(.1, 0.) * Rot(99.123 * random(floor((ps.y) / sInterval)));\n    //ps.xz *= 1. + 0.5 * random(floor((ps.y) / sInterval));\n    ps = mod(ps + sInterval / 2., sInterval) - sInterval / 2.;\n    float spheres = length(ps)-0.003;\n\n    p.y += iTime * 1.;\n    \n    p.xz = abs(p.xz);\n    p.xz *= Rot(p.y / 3.);\n    //p.xz *= Rot(sin(iTime / 10.));\n    p.xz += 0.69 * sin(iTime * 0.4 / vec2(1.7, 1.1));\n\n    \n\n    //p.z = abs(p.z);\n    //p.z += 0.1 * sin(iTime / 1.4);\n    //p.z -= 0.1 * sin(iTime);\n\n    float box = sdBox(p, vec3(4.4));\n    float box2 = sdBox(p, vec3(0.1, 0.1, 200000.));\n        \n    \n    float hole = 9999999990.;\n\n    float holiness = 1.258;//2. + 2. * (0.5 + 0.5 * sin(p.y + iTime));\n    float iterations = 5.;\n    for (float axes = 0.; axes <= 2.; axes++) {\n        p = p.zxy;\n\t    vec3 pm = p;\n   \t\tfor (float i = 1.; i <= iterations; i++) {\n            pm *= i;\n            pm += 1.;\n        \tpm.xy = mod(pm.xy, 2.);\n            pm -= 1.;\n\t\t    hole = min(hole, sdBox(pm, vec3(1./holiness/i, 1./holiness/i, 9999999999.)) / i);\n\t    }\n    }\n    \n    //hole /= 2. * iterations;\n    //hole *= 3.9;\n    \n    return min(spheres, max(0., -hole));\n    //return max(box, hole);\n    //return hole;\n}\n\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\n//float sdBox( in vec2 p, in vec2 b )\n//{\n//    vec2 d = abs(p)-b;\n//    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    //vec2 size = vec2(0.1, 0.1);\n    //uv = abs(uv);\n    //uv -= size;\n    //uv *= 10.;\n    \n    //uv = mod(uv + 0.2, 0.4);\n    //uv -= 0.2;\n    //uv *= Rot(3.1415 / 4.);\n    \n    //float col = 5. * sdBox(uv, size);\n    //col = fract(col);\n    \n    //fragColor = vec4(vec3(col), 1.0);\n\n    \n    ///////////////////////////////////////////////////\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    //vec3 ro = vec3(-0.0, -2.0, -0.0);\n    vec3 ro = vec3(.0, .0, .0);\n    vec3 camDir = vec3(0.001, 1., 0);\n    \n    //camDir.yz *= Rot(-m.y*3.14+1.);\n    //camDir.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, ro + camDir, 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \t//float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \t//col += dif;\n\t    //col = pow(col, vec3(.4545));\t// gamma correction\n        //col = n / 2. + 0.5;\n        //col *= n.x;\n        col = vec3(1.5 / d);\n    }\n    \n    \n    fragColor = vec4(vec3(col), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXfW2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[340, 340, 359, 359, 421], [423, 423, 445, 445, 539], [541, 541, 570, 570, 651], [655, 655, 679, 679, 727], [731, 731, 754, 754, 2050], [2057, 2057, 2091, 2091, 2302], [2304, 2304, 2328, 2328, 2518], [2520, 2520, 2570, 2570, 2761], [2894, 2894, 2951, 2951, 4080]], "test": "untested"}
{"id": "wllfWB", "name": "rounded pixels", "author": "sympou", "description": "an attempt to make pixels round !\n", "tags": ["circlepixels"], "likes": 17, "viewed": 445, "published": 3, "date": "1597675948", "time_retrieved": "2024-07-30T20:50:18.283032", "image_code": "const float pixSize = 20.0;\n\n//luminance\nfloat lum(in vec4 pix) { return dot(pix.rgb,vec3(0.3,0.59,0.11));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 div = iResolution.xy/pixSize;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = floor(uv*div)/div;\n    \n    vec2 diff = (uv-uv2)*div;\n    \n    vec4 pix = texture(iChannel0, uv2);\n    \n    if ( pow(diff.x - 0.5,2.0) + pow(diff.y - 0.5,2.0) > 0.25) {\n        \n        vec4 pmax;\n        vec4 pmin;\n        vec2 v2 = pixSize/iResolution.xy;\n\n        if (diff.x<0.5) { v2.x = -v2.x; }\n        if (diff.y<0.5) { v2.y = -v2.y; }\n\n        vec4 p1  = texture(iChannel0, uv2 + vec2( 0.0, v2.y ));\n        vec4 p2  = texture(iChannel0, uv2 + vec2( v2.x, 0.0 ));\n        vec4 p3  = texture(iChannel0, uv2 + vec2( v2.x, v2.y ));\n\n        if ( lum(p1) > lum(p2) ) {\n            pmax = p1;\n            pmin = p2;\n        } else {\n            pmax = p2;\n            pmin = p1;\n        }\n\n        if ( lum(p3) < lum(pmin) ) {\n            pmin = p3;\n        }\n\n        if ( lum(pix) > lum(pmax) ) {\n            pix = pmax;\n        } else if ( lum(pmin) > lum(pix) ) {\n            pix = pmin;\n        }        \n        \n    }\n    \n    fragColor = pix;\n    \n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 41, 65, 65, 107], [109, 109, 166, 166, 1223]], "test": "untested"}
{"id": "wlsfDS", "name": "Living fractal 2", "author": "Kanata", "description": "Continuously tweaked Julia set", "tags": ["julia"], "likes": 1, "viewed": 254, "published": 3, "date": "1597672792", "time_retrieved": "2024-07-30T20:50:19.055966", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 res = iResolution.xy,\n          z = ( u* 2. - res) / min(res.x, res.y);\n\n    float t = iTime;\n    float scale = 1.5;\n    z *= scale;\n    \n    int j = 0;\n    \n    vec2 a = vec2(0.35 + 0.1*sin(t), - 0.3 + 0.1*sin(t * 0.64));\n    vec2 w = z;\n    \n    for(int i = 0; i < 360; i++){\n        j++;\n        if(length(w) > 2.0){break;}\n        w = 1.1* cpow(w,2.+ .5*sin(t)) + a;\n    }\n \n    float b = float(j) / 360.0;\n\n    \n    O = vec4(vec3(b), 1.);\n}", "image_inputs": [], "common_code": "const float PI  = 3.141592653589793;\n\nvec3 hsvToRgb(float h, float s, float v) {\n    // h: -π - +π, s: 0.0 - 1.0, v: 0.0 - 1.0\n    h = (h + PI) / (2.* PI) * 360.;\n\n    float c = s; // float c = v * s;\n    float h2 = h / 60.0;\n    float x = c * (1.0 - abs(mod(h2, 2.0) - 1.0));\n    vec3 rgb = (v - c) * vec3(1.0, 1.0, 1.0);\n\n    if (0.0 <= h2 && h2 < 1.0) {\n        rgb += vec3(c, x, 0.0);\n    } else if (1.0 <= h2 && h2 < 2.0) {\n        rgb += vec3(x, c, 0.0);\n    } else if (2.0 <= h2 && h2 < 3.0) {\n        rgb += vec3(0.0, c, x);\n    } else if (3.0 <= h2 && h2 < 4.0) {\n        rgb += vec3(0.0, x, c);\n    } else if (4.0 <= h2 && h2 < 5.0) {\n        rgb += vec3(x, 0.0, c);\n    } else if (5.0 <= h2 && h2 < 6.0) {\n        rgb += vec3(c, 0.0, x);\n    }\n\n    return rgb;\n}\n// hsvToRgb borrowed from\n// https://qiita.com/sw1227/items/4be9b9f928724a389a85\n// (slightly modified by Kanata)\n\n//operations on complex numbers borrowed from\n//https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n\n#define re(a) vec2((a).x, 0.)\n#define im(a) vec2(0., (a).y)\n#define cmul(a,b) ( mat2(a, -(a).y, (a).x ) * (b) )\n#define conj(a)     vec2( (a).x, -(a).y)\n#define cinv(a)   ( conj(a) / dot(a, a) )\n#define cdiv(a,b) ( cmul(a, cinv(b)) )\n#define cexp(a)   ( exp((a).x)* vec2(cos((a).y), sin((a).y)) )\n#define clog(a)     vec2( log(length(a)), atan((a).y,(a).x) )\n#define arg(a)\t( atan(a.y, a.x) )\n#define cpow(a,n)   cexp( float(n)* clog(a) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 493]], "test": "untested"}
{"id": "wlsBW7", "name": "Mountainous Landscape", "author": "vipiao", "description": "Press 1, 2, 3 to change mode.\n1: Automatic camera.\n2: Control character. WASD to move. ARROW KEYS to turn. SHIFT to sprint. SPACE to jump.\n3: Fly freely. WASD to move. Same as 2, but SPACE/SHIFT control elevation. Hold C/V speed up/down.\nHold Q/E new seed", "tags": ["procedural", "3d", "raymarching", "terrain", "generation"], "likes": 15, "viewed": 774, "published": 3, "date": "1597638499", "time_retrieved": "2024-07-30T20:50:20.128099", "image_code": "\nMOUNTAIN_FUNCTIONS\n\n// Water.\nconst float WATER_HEIGHT = -0.3;\nfloat waterFunction(in vec3 pos, in float time){\n\tconst int size = 6;\n    const float f = 75.;\n    const float m = 0.0005;\n    const vec3 vecs[size] = vec3[](\n        vec3( f*1.,  f*2.,  m*0.2),\n        vec3(f*0.5, f*0.5,  m*0.1),\n        vec3(f*-1., f*0.2,  m*0.1),\n        vec3( f*0.,f*-0.5,  m*0.5),\n        vec3( f*2., f*-2., m*0.01),\n        vec3(f*-2.,  f*5., m*0.01)\n    );\n    float waveHeight = 0.;\n    for(int i=0; i<size; i++) {\n        // The speed of waves on water is independent on amplitude and wavelength.\n    \twaveHeight += sin(pos.x*vecs[i].x+pos.z*vecs[i].y+0.01*time*length(vecs[i].xy))*vecs[i].z;\n    }\n    return waveHeight + WATER_HEIGHT;\n}\n\nfloat sdWater(in vec3 pos){\n    const float maxWaveHeight = (.2+.1+.1+.5+.01+.01)*.05;\n    const float maxWaterHeight = maxWaveHeight + WATER_HEIGHT; // See waterFunction(.).\n    if(pos.y - maxWaterHeight > maxWaveHeight){\n    \treturn pos.y - maxWaterHeight;\n    }\n    \n    float waveHeight = waterFunction(pos, iTime);\n    \n\tfloat heightDiff = pos.y - waveHeight;\n    const float maxSlope = 1.;\n    float nextDist = heightDiff/sqrt(maxSlope*maxSlope + 1.);\n    \n    return max(nextDist, pos.y-maxWaterHeight);\n}\n\nvoid sdWaterNormal(in vec3 pos, inout vec3 normal, inout float sd){\n\tsd = sdWater(pos);\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    float df = max(sqrt(length(cameraPos-pos)), 1.)*0.01;\n    vec2 e = vec2(df, 0.);\n    normal = normalize(sd - vec3(\n    \tsdWater(pos - e.xyy),\n    \tsdWater(pos - e.yxy),\n    \tsdWater(pos - e.yyx)\n    ));\n}\n\n// Ray marching.\n# define INTERSECTED 0\n# define TOO_FAR 1\n# define TOO_MANY_STEPS 2\nfloat finalRes;\nvoid marchWorld(\n    inout vec3 pos, inout vec3 dir,\n    out float dist, in float maxDist, in float minDist,\n    out int numSteps, in int maxNumSteps,\n    out vec3 color, out vec3 normal, out int returnCode\n){\n    dist = 0.;\n    float prevDist = dist;\n    numSteps = 0;\n    color = vec3(0);\n    vec3 prevPos = pos;\n    float prevSd;\n    float sd = 0.;\n    // Trace.\n    for(int i=0; i<maxNumSteps; i++) {\n        //\n        numSteps++;\n        # define log16(x) log(x)/log(16.)\n\t\t//float res = clamp(50./(dist+0.0001), 1., 3.);\n\t\tfloat res = clamp(log16(1000./(dist+0.0000001)), 1., 3.);\n        float f = fract(res);\n        res = floor(res) + f*f*(3.-2.*f);\n        //float res = 3.;\n        finalRes = res;\n        \n        // Calc sd.\n        prevSd = sd;\n        float sdMount = sdMountain(/*in vec3=*/pos, res, /*differentiable=*/false);\n        float sdWater = sdWater(/*in vec3=*/pos);\n        sd = min(sdMount, sdWater);\n        \n        if(dist + sd > maxDist){\n        \tsd = maxDist-dist;\n            dist += sd;\n            pos += dir*sd;\n            \n            color = vec3(0);\n            normal = vec3(0);\n            \n            returnCode = TOO_FAR;\n        \treturn;\n        }\n        if(sd <= minDist + dist*0.001){\n            // Linearly interpolate position.\n            float fac = (minDist + dist*0.001 - sd) / (prevSd - sd);\n            pos = mix(pos, prevPos, fac);\n            \n            if(sdMount < sdWater){\n                // Mountain.\n                sdMountainNormal(\n                    /*in vec3 pos=*/pos, /*out vec3 normal=*/normal, /*out float sd=*/sd,\n                    /*in float resolution=*/res+1., /*in float df=*/max(3./iResolution.x*dist, 0.00003)\n                );\n                // Gray dark.\n                //color = vec3(110., 116., 120.)/255.;\n                color = vec3(155., 155., 154.)/255.;\n                // Gray light.\n                color = mix(color, vec3(199., 194., 187.)/255., min(pow(normal.y+0.5, 8.), 1.));\n                // Grass.\n                float grassFactor = min(pow(normal.y+0.3, 8.), 1.);\n                color = mix(color, vec3(146., 116., 32.)/255., grassFactor);\n                // Sand.\n                float sandFactor = min(pow(normal.y+0.2, 8.), 1.);\n                sandFactor *= clamp(-pos.y*10.-2., 0., 1.);\n                color = mix(color, vec3(219., 209., 180.)/255., sandFactor);\n                // Snow.\n                float snowFactor = min(pow(normal.y+0.2, 8.), 1.);\n                snowFactor *= clamp(pos.y*10.-8.+sin(pos.x*2.)*3.*0., 0., 1.);\n                color = mix(color, vec3(235., 235., 255.)/255., snowFactor);\n                \n                returnCode = INTERSECTED;\n            \treturn;\n            } else {\n                // Water.\n                sdWaterNormal(/*in vec3 pos=*/pos, /*out vec3 normal=*/normal, /*out float sd=*/sd);\n                dir = reflect(dir, normal);\n                prevDist = dist;\n                dist += sd;\n                prevPos = pos;\n                pos += dir*sd;\n                \n                float diff = sdMount - sdWater;\n                if(diff + cos(diff*200000. - iTime*8.)*0.00002 < 0.00003 - dist*0.001){\n                \tcolor = vec3(0.8,0.8,1)*2.;\n                    \n                    returnCode = INTERSECTED;\n            \t\treturn;\n                }\n                \n                continue;\n            }\n            \n            //if(sd < 0.){\n            //\tcolor = vec3(1,0,0);\n            //}\n            \n            //color=vec3(1,1,0);\n\n            \n        }\n        \n        //\n        prevDist = dist;\n        dist += sd;\n        prevPos = pos;\n        pos += dir*sd;\n       \t\n    }\n    returnCode = TOO_MANY_STEPS;\n    return;\n}\n\nvoid marchWorldShaddow(\n    inout vec3 pos, inout vec3 dir,\n    out float dist, in float maxDist, in float minDist,\n    out int numSteps, in int maxNumSteps, out float shaddowFactor,\n    out int returnCode\n){\n    dist = 0.;\n    float prevDist = dist;\n    numSteps = 0;\n    float sd = 0.;\n    shaddowFactor = 1.;\n    // Trace.\n    for(int i=0; i<maxNumSteps; i++) {\n        //\n        numSteps++;\n        # define log16(x) log(x)/log(16.)\n\t\tfloat res = clamp(log16(100./(dist+0.0000001)), 1., 3.);\n        \n        // Calc sd.\n        float sdMount = sdMountain(/*in vec3=*/pos, res, /*differentiable=*/false);\n        sd = sdMount;\n        \n        // Soft shaddows inspired by https://iquilezles.org/articles/rmshadows.\n        shaddowFactor = min(shaddowFactor, 100.*sd/(dist+1e-6));\n        \n        if(dist + sd > maxDist){\n            returnCode = TOO_FAR;\n        \treturn;\n        }\n        if(sd <= minDist + dist*0.001){\n            returnCode = INTERSECTED;\n            return;\n        }\n        \n        //\n        dist += sd;\n        pos += dir*sd;\n       \t\n    }\n    returnCode = TOO_MANY_STEPS;\n    return;\n}\n\n// Render.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    vec3 forward = normalize(texelFetch(iChannel0, ivec2(CAMERA_DIRECTION, 0), 0).xyz);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = cross(right, forward);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 camPos = vec3(cameraPos.x, cameraPos.y, cameraPos.z);\n    vec3 viewDir = normalize(forward*0.5 + right * uv.x + up * uv.y);\n    \n    vec3 pos = camPos;\n    vec3 dir = viewDir;\n    float dist = 0.;\n    float maxDist = 40.;\n    float minDist = 0.00001;\n    int numSteps;\n    int maxNumSteps = 200;\n    vec3 color;\n    vec3 normal;\n    int returnCode;\n    marchWorld(\n        /*inout vec3 pos=*/pos, /*inout vec3 dir=*/dir,\n        /*out float dist=*/dist, /*in float maxDist=*/maxDist, /*in float minDist=*/minDist,\n        /*out int numSteps=*/numSteps, /*in int maxNumSteps=*/maxNumSteps,\n        /*out vec3 color=*/color, /*out vec3 normal=*/normal, /*out int returnCode=*/returnCode\n    );\n    \n    vec3 lightDir = normalize(vec3(5.,-1,3.));\n    //float t = iTime*0.1 + 177.;\n    //vec3 lightDir = normalize(vec3(sin(t),cos(t),1.));\n    \n    float shaddowFactor;\n    if(returnCode == INTERSECTED){\n        vec3 shaddowPos = pos-lightDir*minDist*2.;\n        vec3 shaddowDir = -lightDir;\n        float shaddowDist;\n        float shaddowMaxDist = maxDist;\n        float shaddowMinDist = minDist;\n        int shaddowNumSteps;\n        int shaddowMaxNumSteps = maxNumSteps;\n        shaddowFactor;\n        int shaddowReturnCode;\n        marchWorldShaddow(\n            /*inout vec3 pos=*/shaddowPos, /*inout vec3 dir=*/shaddowDir,\n            /*out float dist=*/shaddowDist, /*in float maxDist=*/shaddowMaxDist, /*in float minDist=*/shaddowMinDist,\n            /*out int numSteps=*/shaddowNumSteps, /*in int maxNumSteps=*/shaddowMaxNumSteps, /*out float shaddowFactor=*/shaddowFactor,\n            /*out int returnCode=*/shaddowReturnCode\n        );\n        shaddowFactor *= max(shaddowDist / shaddowMaxDist, shaddowDist/shaddowMaxDist);\n    } else {\n    \tshaddowFactor = 1.;\n    }\n    \n    \n    // Ambient occlusion.\n    vec3 occlusionColor = vec3(0.,0.,0.);\n    float occlusionFactor = float(numSteps)/log(dist+10.) * max(dot(-viewDir, normal), 0.);\n    occlusionFactor = max(1.-occlusionFactor*0.025, 0.);\n    \n    float diff = max(dot(-lightDir, normal), 0.)*0.75;\n    \n    vec3 reflectDir = reflect(lightDir, normal); // reflect(I, N) = I - 2.0 * dot(N, I) * N.\n    float spec = pow(max(dot(reflectDir, -viewDir), 0.0), 8.) * 0.5;\n    \n    float ambient = 0.5*occlusionFactor;\n    \n    /*float sum = diff + spec + ambient;\n    if(sum > 1.){\n    \tdiff /= sum;\n    \tspec /= sum;\n    \tambient /= sum;\n    }*/\n    color = (color*diff*shaddowFactor + color*spec*shaddowFactor) + color*ambient;\n    \n    //float test = texelFetch( iChannel0, ivec2(DO_BUFFER_UPDATE,0), 0 ).x;\n    //color.r += test;\n    \n    // Mist.\n    vec3 mistColor = vec3(0.5,0.6,0.9);\n    float skyColorFactor = clamp(viewDir.y * 1., 0., 1.);\n    skyColorFactor = skyColorFactor*skyColorFactor*(3.-2.*skyColorFactor);\n    mistColor = mix(mistColor, vec3(0.3, 0.4, 0.9), skyColorFactor);\n    float mistFactor = max(float(numSteps)/float(maxNumSteps), float(dist)/float(maxDist));\n    mistFactor = pow(mistFactor, 1.);\n    color = mix(color, mistColor, mistFactor);\n    \n    // The sun.\n    float d = dist/maxDist * 2.*max(mistFactor*mistFactor*mistFactor-0.5, 0.)*min(pow(max(dot(dir, -lightDir), 0.), 1024.), 1.);\n    //float d = ;\n    color = min(color + vec3(d), 1.);\n    \n    /*float testF = 1073741824.;\n    int testI = int(testF);\n    if(testF == float(testI)){\n    \tcolor.g = 1.;\n    }*/\n    \n    /*float testF = texelFetch(iChannel0, ivec2(PRECISION_TEST, 0), 0).x;\n    if(int(testF) == PRECISION_NUMBER){\n    \tcolor.g = 1.;\n    }*/\n    \n    //color.r = ceil(finalRes-1.)/3.;\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// This buffer is used to store global variables, like camera position and such.\n\nMOUNTAIN_FUNCTIONS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // Change movement mode.\n    if(ivec2(fragCoord) == ivec2(MOVEMENT_MODE,0)){\n        bool key1IsDown = texelFetch(iChannel2, ivec2(KEY_1,0), 0).x > 0.5;\n        bool key2IsDown = texelFetch(iChannel2, ivec2(KEY_2,0), 0).x > 0.5;\n        bool key3IsDown = texelFetch(iChannel2, ivec2(KEY_3,0), 0).x > 0.5;\n        if(key1IsDown){\n        \tprevColor.r = MOVE_MODE_AUTO;\n        }else if(key2IsDown){\n        \tprevColor.r = MOVE_MODE_WALK;\n        }else if(key3IsDown){\n        \tprevColor.r = MOVE_MODE_FREE;\n        }\n    }\n    float movementMode = texelFetch(iChannel0, ivec2(MOVEMENT_MODE, 0), 0).x;\n    \n    // Accelerate.\n    float sensitivity = texelFetch(iChannel0, ivec2(CAMERA_SENSITIVITY, 0), 0).x;\n    if(ivec2(fragCoord) == ivec2(CAMERA_SENSITIVITY,0)){\n        if(sensitivity == 0.){\n            sensitivity = 0.1;\n            prevColor.r = 0.1;\n        }\n        if(texelFetch( iChannel2, ivec2(KEY_C,0), 0 ).x > 0.5 && prevColor.r < 0.15){\n            prevColor.r *= 1.05;\n        }\n        if(texelFetch( iChannel2, ivec2(KEY_V,0), 0 ).x > 0.5 && prevColor.r > 0.001/10.){\n            prevColor.r /= 1.05;\n        }\n    }\n    \n    // Rotate.\n    vec3 forward = texelFetch(iChannel0, ivec2(CAMERA_DIRECTION, 0), 0).xyz;\n    if(length(forward) == 0.){\n        forward = vec3(0,0,-1);\n    }\n    forward = normalize(forward);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = cross(right, forward);\n    if(ivec2(fragCoord) == ivec2(CAMERA_DIRECTION,0)){\n        if(movementMode == MOVE_MODE_AUTO){\n            forward = vec3(\n                -sin((iTime + START_TIME)*AUTO_MOVEMENT_SPEED + 0.2),\n                -0.1,\n                -cos((iTime + START_TIME)*AUTO_MOVEMENT_SPEED + 0.2)\n            );\n        }else{\n            bool arrowRight = texelFetch( iChannel2, ivec2(KEY_RIGHT,0), 0 ).x > 0.5;\n            bool arrowLeft = texelFetch( iChannel2, ivec2(KEY_LEFT,0), 0 ).x > 0.5;\n            bool arrowUp = texelFetch( iChannel2, ivec2(KEY_UP,0), 0 ).x > 0.5;\n            bool arrowDown = texelFetch( iChannel2, ivec2(KEY_DOWN,0), 0 ).x > 0.5;\n            const float rotationSpeed = 0.04;\n            if(arrowRight){\n                forward = normalize(forward + right*rotationSpeed);\n            }\n            if(arrowLeft){\n                forward = normalize(forward - right*rotationSpeed);\n            }\n            if(arrowUp){\n                forward = normalize(forward + up*rotationSpeed);\n            }\n            if(arrowDown){\n                forward = normalize(forward - up*rotationSpeed);\n            }\n        }\n    \tvec3 right = normalize(cross(forward, vec3(0,1,0)));\n    \tvec3 up = cross(right, forward);\n        prevColor.xyz = normalize(forward);\n    }\n    \n    // Calculate collision.\n    vec3 pos;\n    vec3 cameraPos;\n    vec3 normal;\n    float sd;\n    if(ivec2(fragCoord) == ivec2(CAMERA_POS,0) || ivec2(fragCoord) == ivec2(VELOCITY,0)){\n        cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n        pos = cameraPos - vec3(0, 0.001, 0);\n        normal;\n        sd;\n        sdMountainNormal(\n            /*in vec3 pos=*/pos, /*inout vec3 normal=*/normal, /*out float sd=*/sd,\n            /*in float resolution=*/3., /*in float df=*/0.00003\n        );\n    }\n    \n    // Translate.\n    if(ivec2(fragCoord) == ivec2(CAMERA_POS,0)){\n        bool dDown = texelFetch( iChannel2, ivec2(KEY_D,0), 0 ).x > 0.5;\n        bool aDown = texelFetch( iChannel2, ivec2(KEY_A,0), 0 ).x > 0.5;\n        bool spaceDown = texelFetch( iChannel2, ivec2(KEY_SPACE,0), 0 ).x > 0.5;\n        bool shiftDown = texelFetch( iChannel2, ivec2(KEY_SHIFT,0), 0 ).x > 0.5;\n        bool wDown = texelFetch( iChannel2, ivec2(KEY_W,0), 0 ).x > 0.5;\n        bool sDown = texelFetch( iChannel2, ivec2(KEY_S,0), 0 ).x > 0.5;\n        if(movementMode == MOVE_MODE_AUTO){\n            const float rad = 30.;\n            vec3 camPos = vec3(\n            \tcos((iTime + START_TIME)*AUTO_MOVEMENT_SPEED)*rad,\n                0.,\n                -sin((iTime + START_TIME)*AUTO_MOVEMENT_SPEED)*rad\n            );\n        \tprevColor.xyz = vec3(\n            \tcamPos.x,\n                //-sdMountain(camPos, 0., true)*3.+0.5,\n                1.269,\n                camPos.z\n            );\n        }else if(movementMode == MOVE_MODE_WALK){\n        \tvec3 velocity = texelFetch( iChannel0, ivec2(VELOCITY,0), 0 ).xyz;\n            prevColor.xyz += velocity;\n            if(sd < 0.){\n            \tprevColor.y += -sd - 0.00001;\n            }\n        } else if(movementMode == MOVE_MODE_FREE){\n            if(wDown){\n                prevColor.xyz += forward*sensitivity;\n            }\n            if(sDown){\n                prevColor.xyz -= forward*sensitivity;\n            }\n            if(dDown){\n                prevColor.xyz += right*sensitivity;\n            }\n            if(aDown){\n                prevColor.xyz -= right*sensitivity;\n            }\n            if(spaceDown){\n                prevColor.xyz += up*sensitivity;\n            }\n            if(shiftDown){\n                prevColor.xyz -= up*sensitivity;\n            }\n        }\n    }\n    \n    // Accelerate.\n    if(ivec2(fragCoord) == ivec2(VELOCITY,0)){\n        \n        if(movementMode == MOVE_MODE_WALK){\n            // Gravity.\n            //const float gravity = -0.000002;\n            const float gravity = -1.513888888888e-6 * 1.5; // 9.81m/s^2 * 1.5\n            prevColor.y += gravity;\n            \n        \t// Collision.\n            vec3 velocity = prevColor.xyz;\n            bool dDown = texelFetch( iChannel2, ivec2(KEY_D,0), 0 ).x > 0.5;\n            bool aDown = texelFetch( iChannel2, ivec2(KEY_A,0), 0 ).x > 0.5;\n            bool spaceDown = texelFetch( iChannel2, ivec2(KEY_SPACE,1), 0 ).x > 0.5;\n            bool shiftDown = texelFetch( iChannel2, ivec2(KEY_SHIFT,0), 0 ).x > 0.5;\n            bool wDown = texelFetch( iChannel2, ivec2(KEY_W,0), 0 ).x > 0.5;\n            bool sDown = texelFetch( iChannel2, ivec2(KEY_S,0), 0 ).x > 0.5;\n            vec3 flatForward = normalize(vec3(forward.x, 0, forward.z));\n            if(sd < 0. && dot(velocity, normal) < 0.){\n\t\t\t\t// Collision impulse.\n                //velocity = reflect(velocity, normal);\n                velocity.y = 0.;\n            }\n            if(sd < 0.0002){\n                float walkForce = 0.00001;\n                const float jumpForce = 0.00006;\n                if(shiftDown){\n                \twalkForce *= 2.;\n                }\n                // Walk force.\n                velocity.xz *= 0.8; // Walking friction.\n                vec3 walkForceVec = vec3(0);\n                if(wDown){\n                \twalkForceVec += flatForward*walkForce;\n                }\n                if(sDown){\n                    walkForceVec -= flatForward*walkForce;\n                }\n                if(dDown){\n                    walkForceVec += right*walkForce;\n                }\n                if(aDown){\n                    walkForceVec -= right*walkForce;\n                }\n            \tif(spaceDown){\n                    velocity.y = 0.;\n                    walkForceVec += up*jumpForce;\n                }\n                if(dot(normalize(walkForceVec), normal) > -0.75){\n\t                velocity += walkForceVec;\n                }\n            }\n            prevColor.xyz = velocity;\n        } else {\n        \tprevColor.xyz = vec3(0);\n        }\n    }\n    \n    // Check for screen resolution change.\n    if(ivec2(fragCoord) == ivec2(SCREEN_RESOLUTION,0)){\n        prevColor.xy = iResolution.xy;\n    }else if(ivec2(fragCoord) == ivec2(DO_BUFFER_UPDATE,0)){\n        bool qIsDown = texelFetch( iChannel2, ivec2(KEY_Q, 0), 0 ).x > 0.5;\n        bool eIsDown = texelFetch( iChannel2, ivec2(KEY_E, 0), 0 ).x > 0.5;\n        if(\n            texelFetch( iChannel0, ivec2(SCREEN_RESOLUTION, 0), 0 ).xy != iResolution.xy || qIsDown || eIsDown\n        ){\n        \tprevColor.x = 1.;\n        }else{\n        \tprevColor.x = 0.;\n        }\n    }\n    \n    // Check for screen resolution change.\n    if(ivec2(fragCoord) == ivec2(PRECISION_TEST,0)){\n        prevColor.x = PRECISION_NUMBER_F;\n        \n    }\n    \n    // Change seed.\n    bool qIsDown = texelFetch(iChannel2, ivec2(KEY_Q,0), 0).x > 0.5;\n    bool eIsDown = texelFetch(iChannel2, ivec2(KEY_E,0), 0).x > 0.5;\n    if(ivec2(fragCoord) == ivec2(CHANGE_SEED,0)){\n        if(qIsDown){\n        \tprevColor.r += 0.1;\n        }\n        if(eIsDown){\n        \tprevColor.r -= 0.1;\n        }\n    }\n    \n    //\n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Math.\n# define PI 3.1415926538\n\n// Input.\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_SPACE  = 32;\nconst int KEY_W  = 87;\nconst int KEY_A = 65;\nconst int KEY_S  = 83;\nconst int KEY_D  = 68;\nconst int KEY_C  = 67;\nconst int KEY_V  = 86;\nconst int KEY_Q  = 81;\nconst int KEY_E  = 69;\nconst int KEY_R  = 82;\nconst int KEY_1  = 49;\nconst int KEY_2  = 50;\nconst int KEY_3  = 51;\n\n# define MAP_WIDTH 30.\nconst int CAMERA_POS = 0;\nconst int CAMERA_SENSITIVITY = 1;\nconst int CAMERA_DIRECTION = 2;\nconst int CHANGE_SEED = 3;\nconst int SCREEN_RESOLUTION = 4;\nconst int DO_BUFFER_UPDATE = 5;\n# define PRECISION_NUMBER 16777216\n# define PRECISION_NUMBER_F 16777216.\nconst int PRECISION_TEST = 6;\nconst int MOVEMENT_MODE = 7;\n# define MOVE_MODE_AUTO 0.\n# define MOVE_MODE_WALK 1.\n# define MOVE_MODE_FREE 2.\nconst int VELOCITY = 8;\n//2^24 = 16777216\n    \n// Auto parameters.\n# define AUTO_MOVEMENT_SPEED 0.04\n# define START_TIME 40.\n\n// --Hash function--\n/*\nInspired by Adam Smith.\nsource: https://groups.google.com/forum/#!msg/proceduralcontent/AuvxuA1xqmE/T8t88r2rfUcJ\n*/\n# define PRECISION 3\n// 2^32-1\n# define LARGEST_UINT 4294967295u\n# define LARGEST_UINT_AS_FLOAT 4294967295.\n// 2^31-1 = 2147483647\n# define LARGEST_INT 2147483647\n# define LARGEST_INT_AS_FLOAT 2147483647.\n# define SMALLEST_INT -2147483648\n# define SMALLEST_INT_AS_FLOAT -2147483648.\n// 2^32 = 4294967296\n# define LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT 4294967296.\n\nint rotate (int x, int b) {\n    return (x << b) ^ (x >> (32-b));\n}\n\nint pcg (int a) {\n    int b = a;\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d), 5);\n    }\n    return a^b;\n}\n\nfloat pcgUnit (int a) {\n    return (float(pcg(a))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\nint pcg (int a, int b) {\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d), 5);\n    }\n    return a^b;\n}\n\nfloat pcgUnit (int a, int b) {\n    return (float(pcg(a,b))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\nint pcg (int a, int b, int c) {\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c) + (c^0xcabba6e5), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d) + (c^0x0b5e55ed), 5);\n        c = rotate((a^0x5eaf00d5) + (b^0xdecea5ed) + (c^0xba5eba11), 16);\n    }\n    // https://www.dcode.fr/words-containing\n    return a^b^c;\n}\n\nfloat pcgUnit (int a, int b, int c) {\n    return (float(pcg(a,b,c))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\n// --Noise functions--\nfloat boxNoise(vec3 pos, int seed){\n\tivec3 ind = ivec3(floor(pos));\n    \n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    //return mix(mix(mix( pcgUnit(ind.x+0, ind.y+0, ind.z+0), pcgUnit(ind.x+1, ind.y+0, ind.z+0), u.x),\n    //               mix( pcgUnit(ind.x+0, ind.y+1, ind.z+0), pcgUnit(ind.x+1, ind.y+1, ind.z+0), u.x), u.y),\n    //           mix(mix( pcgUnit(ind.x+0, ind.y+0, ind.z+1), pcgUnit(ind.x+1, ind.y+0, ind.z+1), u.x),\n    //               mix( pcgUnit(ind.x+0, ind.y+1, ind.z+1), pcgUnit(ind.x+1, ind.y+1, ind.z+1), u.x), u.y), u.z);\n    \n    // Optimized version.\n    // 15485863 and 179424673 are primes.\n    ivec2 yS = ivec2(ind.y*15485863, (ind.y+1)*15485863);\n    ivec2 zS = ivec2(ind.z*179424673, (ind.z+1)*179424673);\n    return mix(mix(mix( pcgUnit(ind.x + yS.x + zS.x, seed), pcgUnit(ind.x+1 + yS.x + zS.x, seed), u.x),\n                   mix( pcgUnit(ind.x + yS.y + zS.x, seed), pcgUnit(ind.x+1 + yS.y + zS.x, seed), u.x), u.y),\n               mix(mix( pcgUnit(ind.x + yS.x + zS.y, seed), pcgUnit(ind.x+1 + yS.x + zS.y, seed), u.x),\n                   mix( pcgUnit(ind.x + yS.y + zS.y, seed), pcgUnit(ind.x+1 + yS.y + zS.y, seed), u.x), u.y), u.z);\n}\nfloat boxNoise(vec3 pos){\n    return boxNoise(pos, 0);\n}\n\nfloat layeredBoxNoise(vec3 pos, int numLayers, int seed){\n    seed = pcg(seed);\n\tfloat result = 0.;\n    float scale = 1.;\n    float denominator = 0.;\n    for (int i = 0; i < numLayers; i++) {\n        result += scale * boxNoise(pos, ++seed);\n        denominator += scale;\n        pos *= 2.;\n        pos += PI*0.;\n        scale *= 0.5;\n    }\n    return result/denominator;\n}\n\nfloat perlinNoise(vec3 pos, int seed, int tileSize){\n    ivec3 ind = ivec3(floor(pos));\n    \n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    f = f;\n    \n    // 2038074743 and 179424673 are primes.\n    //ivec2 yS = ivec2(ind.y*15485863, (ind.y+1)*15485863);\n    //ivec2 zS = ivec2(ind.z*179424673, (ind.z+1)*179424673);\n    // 7907 and 7919 are primes.\n    ivec3 modInd = ivec3(mod(vec3(ind), float(tileSize)));\n    ivec3 modIndP = ivec3(mod(vec3(ind+1), float(tileSize)));\n    modInd.y *= 7907;\n    modIndP.y *= 7907;\n    modInd.z *= 7919;\n    modIndP.z *= 7919;\n    \n    float nf = 2./float(0x3ff);\n    \n    int x0y0z0H = pcg(modInd.x + modInd.y + modInd.z, seed);\n    float x0y0z0 = dot(\n        vec3(\n            (float(0x000003ff & x0y0z0H)*nf-1.),\n            (float((0x000ffc00 & x0y0z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y0z0H) >> 20)*nf-1.)\n        ),\n        f\n    );\n    \n    int x1y0z0H = pcg(modIndP.x + modInd.y + modInd.z, seed);\n    float x1y0z0 = dot(\n        vec3(\n            (float(0x000003ff & x1y0z0H)*nf-1.),\n            (float((0x000ffc00 & x1y0z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y0z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y, f.z)\n    );\n    \n    int x0y1z0H = pcg(modInd.x + modIndP.y + modInd.z, seed);\n    float x0y1z0 = dot(\n        vec3(\n            (float(0x000003ff & x0y1z0H)*nf-1.),\n            (float((0x000ffc00 & x0y1z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y1z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y-1., f.z)\n    );\n    \n    int x1y1z0H = pcg(modIndP.x + modIndP.y + modInd.z, seed);\n    float x1y1z0 = dot(\n        vec3(\n            (float(0x000003ff & x1y1z0H)*nf-1.),\n            (float((0x000ffc00 & x1y1z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y1z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y-1., f.z)\n    );\n    \n    int x0y0z1H = pcg(modInd.x + modInd.y + modIndP.z, seed);\n    float x0y0z1 = dot(\n        vec3(\n            (float(0x000003ff & x0y0z1H)*nf-1.),\n            (float((0x000ffc00 & x0y0z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y0z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y, f.z-1.)\n    );\n    \n    int x1y0z1H = pcg(modIndP.x + modInd.y + modIndP.z, seed);\n    float x1y0z1 = dot(\n        vec3(\n            (float(0x000003ff & x1y0z1H)*nf-1.),\n            (float((0x000ffc00 & x1y0z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y0z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y, f.z-1.)\n    );\n    \n    int x0y1z1H = pcg(modInd.x + modIndP.y + modIndP.z, seed);\n    float x0y1z1 = dot(\n        vec3(\n            (float(0x000003ff & x0y1z1H)*nf-1.),\n            (float((0x000ffc00 & x0y1z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y1z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y-1., f.z-1.)\n    );\n    \n    int x1y1z1H = pcg(modIndP.x + modIndP.y + modIndP.z, seed);\n    float x1y1z1 = dot(\n        vec3(\n            (float(0x000003ff & x1y1z1H)*nf-1.),\n            (float((0x000ffc00 & x1y1z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y1z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y-1., f.z-1.)\n    );\n    \n    return mix(mix(mix( x0y0z0, x1y0z0, u.x),\n                   mix( x0y1z0, x1y1z0, u.x), u.y),\n               mix(mix( x0y0z1, x1y0z1, u.x),\n                   mix( x0y1z1, x1y1z1, u.x), u.y), u.z);\n}\n\nfloat layeredPerlinNoise(vec3 pos, int numLayers, int seed, int tileSize){\n    seed = pcg(seed);\n\tfloat result = 0.;\n    float scale = 1.;\n    float denominator = 0.;\n    for (int i = 0; i < numLayers; i++) {\n        result += scale * perlinNoise(pos, ++seed, tileSize);\n        tileSize *= 2;\n        denominator += scale;\n        pos *= 2.;\n        pos += PI*0.;\n        scale *= 0.5;\n    }\n    return result/denominator;\n}\n\n// --Signed distance functions. (SDF)--\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n   \treturn length(pos-center) - radius;\n}\nvoid sdSphereNormal(in vec3 pos, in vec3 center, in float radius, inout vec3 normal, inout float sd){\n\tsd = sdSphere(pos, center, radius);\n    vec2 e = vec2(0.01, 0.);\n    normal = normalize(sd - vec3(\n    \tsdSphere(pos - e.xyy, center, radius),\n    \tsdSphere(pos - e.yxy, center, radius),\n    \tsdSphere(pos - e.yyx, center, radius)\n    ));\n}\n\n# define MOUNTAIN_FUNCTIONS \\\nbool DisCallingNormal = false;\\\n/* Mountain.*/\\\nfloat getMountainHeight(vec2 pos){\\\n    vec2 uv = pos/MAP_WIDTH;\\\n\tuv.x *= iResolution.y/iResolution.x;\\\n    /* Tile texture.*/\\\n    vec2 coordinate = uv.xy*iResolution.xy;\\\n    const float roundingMargin = 0.00001;\\\n    coordinate.y = mod(coordinate.y, iResolution.y-roundingMargin);\\\n    coordinate.x = mod(coordinate.x, iResolution.y-roundingMargin);\\\n    vec4 samp = texelFetch(iChannel1, ivec2(coordinate), 0);\\\n    vec2 frac = fract(coordinate);\\\n    float h = mix(\\\n    \tmix(samp.x, samp.y, frac.x),\\\n    \tmix(samp.z, samp.w, frac.x),\\\n        frac.y\\\n    );\\\n    \\\n    return h;\\\n}\\\nfloat sdMountain(in vec3 pos, float resolution, bool differentiable){\\\n    vec2 flatPos = pos.xz;\\\n    \\\n    /* Share.*/\\\n    vec2 share = vec2(\\\n        cos(flatPos.x),\\\n        cos(flatPos.y)\\\n    );\\\n    vec2 sharedPos = flatPos + pos.y*share*1.2;\\\n    \\\n    /**/\\\n    float height = 0.;\\\n    float scale = 1.;\\\n    float heightDiff;\\\n    int numIte = int(ceil(resolution));\\\n    /* Rotation.*/\\\n    const float rotSin = sin(2.*PI*(1./16.));\\\n    const float rotCos = cos(2.*PI*(1./16.));\\\n    const mat2 rotMat = mat2(rotCos, -rotSin, rotSin, rotCos);\\\n    /**/\\\n    for(int i=0;i<numIte;i++){\\\n        /* Rotate.*/\\\n        sharedPos = rotMat*sharedPos;\\\n        flatPos = rotMat*flatPos;\\\n        /**/\\\n        sharedPos = mix(sharedPos, flatPos, 0.5);\\\n        float factor = min(resolution - float(i), 1.);\\\n        float h = getMountainHeight(sharedPos * scale);\\\n        h = h/scale * factor;\\\n    \theight += h;\\\n        scale *= 16.;\\\n        heightDiff = pos.y - height;\\\n        if(!differentiable && heightDiff > 4./scale && i < numIte-1){\\\n        \theightDiff = heightDiff - 2./scale;\\\n            break;\\\n        }\\\n    }\\\n    \\\n    heightDiff = pos.y - height;\\\n    \\\n    const float maxSlope = 3.;\\\n    float nextDist = heightDiff/sqrt(maxSlope*maxSlope + 1.);\\\n    \\\n    return nextDist;\\\n}\\\nvoid sdMountainNormal(in vec3 pos, out vec3 normal, out float sd, in float resolution, in float df){\\\n    DisCallingNormal = true;\\\n\tsd = sdMountain(pos, resolution, /*differentiable=*/true);\\\n    /*float df = 0.002;*/\\\n    vec2 e = vec2(df, 0.);\\\n    normal = normalize(sd - vec3(\\\n    \tsdMountain(pos - e.xyy, resolution, /*differentiable=*/true),\\\n    \tsdMountain(pos - e.yxy, resolution, /*differentiable=*/true),\\\n    \tsdMountain(pos - e.yyx, resolution, /*differentiable=*/true)\\\n    ));\\\n    DisCallingNormal = false;\\\n}\n", "buffer_b_code": "#pragma optionNV(unroll none)\n// This buffer is only changed on screen resolution change. When that happens, the mountain heightmap texture is refreshed once.\n\nfloat getHeight(vec2 pos){\n    float seed = texelFetch( iChannel0, ivec2(CHANGE_SEED, 0), 0 ).x * 0.02;\n#if 0\n    return layeredPerlinNoise(/*vec3 pos=*/vec3(pos*5., seed), /*int numLayers=*/8, /*int seed=*/0, /*int tileSize=*/5)*4.;\n#else\n    const int size = 4;\n    const int numLayers = 8;\n    float noiseX = layeredPerlinNoise(/*vec3 pos=*/vec3(pos*float(size), seed), /*int numLayers=*/numLayers, /*int seed=*/0, /*int tileSize=*/size);\n    float noiseY = layeredPerlinNoise(/*vec3 pos=*/vec3(pos*float(size), seed), /*int numLayers=*/numLayers, /*int seed=*/1, /*int tileSize=*/size);\n    pos += vec2(noiseX, noiseY)*0.2;\n    return layeredPerlinNoise(/*vec3 pos=*/vec3(pos*float(size), seed), /*int numLayers=*/numLayers, /*int seed=*/2, /*int tileSize=*/size)*4.;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevColor = texelFetch(iChannel1, ivec2(fragCoord), 0).xyzw;\n    if(texelFetch( iChannel0, ivec2(DO_BUFFER_UPDATE,0), 0 ).x > 0.5){\n        // Only run once every time the screen resolution or seed is changed.\n        vec2 uv = (fragCoord-0.5*iResolution.xy);\n        uv.x /= iResolution.y;\n        uv.y /= iResolution.y;\n\t\t\n        // Generate mountain noise.\n        vec2 e = vec2(0, 1./iResolution.y);\n        float noise[4];\n        vec2 positions[4] = vec2[](\n        \tuv, uv + e.yx, uv + e.xy, uv + e.yy\n        );\n        for(int i=0; i<4; i++){\n            noise[i] = getHeight(positions[i]);\n        }\n        \n        //\n        prevColor = vec4(noise[0], noise[1], noise[2], noise[3]);\n        \n    }\n    \n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsBW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[730, 730, 757, 757, 1242], [1244, 1244, 1311, 1311, 1613], [1716, 1716, 1925, 1925, 5439], [5441, 5441, 5649, 5649, 6562], [6564, 6575, 6632, 6632, 10628]], "test": "untested"}
{"id": "3tlfDS", "name": "Boulders and hills", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/wljyWR]\"Swiss cheese caves\"[/url] fractal.\nUse the mouse to look around.\n", "tags": ["3d", "raymarching", "fractal", "terrain", "mountains"], "likes": 2, "viewed": 381, "published": 3, "date": "1597623033", "time_retrieved": "2024-07-30T20:50:20.911006", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(-15.0,0.0,30.0+iTime*10.0);\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        vec3 s1 = surface_color(worldDir*10.0+iTime/10.0).yzx;\n        fragColor = vec4(s1, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t>>(t/(2*2*2*2*2*2*2*2)+t/2*2*2*2*2*2))*(t>>(t/4096+((t/(4096)))))|(t>>(t/4+(t/(131072))))|t>>4;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x), (coord.y))).xyz;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}       \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.xz *= rot(iTime*.1);\n    float speed = 10.0;\n\tvec3 eye = vec3(-15.0,0.0,30.0+iTime*10.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    vec3 dmap = depth_map(fragCoord);\n    float l0 = length(eye-dmap);\n    float l1 = texture(iChannel0, vec2((fragCoord.x), (fragCoord.y))).w;\n    float l2;\n    \n    if(l0 > .9 && l1 > 0.0){\n        l2 = max(log(l0),0.0);\n    }\n    else{\n        l2 = l0;\n    }\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l2, MAX_DIST);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, (dist-l0)*.9);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nconst int MAX_MARCHING_STEPS = 100;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON/10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx*i/3.0+p1/i)+p1))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF1(vec3 p) {\n    p /= scale*2.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 3;k++){\n    \tresult = min(result, planet_surface(p*i,i)/(i));\n        i *= 3.0;\n    }\n    result -= p.y*3.0-500.0;\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n    float result = sceneSDF1(p);\n    float i = 3.0;\n    for(int k = 0; k < 3; k++){\n        //add bumps to the surface\n    \tresult -= sceneSDF1(p*i)/(i*9.0);\n        i *= 3.0;\n    }\n    return result*scale*200.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return vec3(.5)+sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))/3.0;\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 479, 570, 570, 936], [938, 938, 965, 965, 1114], [1116, 1116, 1173, 1173, 1889]], "test": "untested"}
{"id": "3lsBDS", "name": "SchwarzChristoffel tiling", "author": "cyperus", "description": "SchwarzChristoffel tiling\n\nbased on mla@[url]https://www.shadertoy.com/view/tsfyRj[/url]", "tags": ["complex", "conformal", "tiling", "schwarzchristoffel"], "likes": 10, "viewed": 507, "published": 3, "date": "1597622161", "time_retrieved": "2024-07-30T20:50:21.683940", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"SchwarzChristoffel tiling\"\n//\n// created by Colling Patrik (cyperus) in 2020-08-16\n//\n// based on code from\n// - \"The Schwarz-Christoffel mapping:\" by Matthew Arcus in 2020\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// FEATURES:\n// - inverse Mobius (use mouse)\n// - Schwarz-Christoffel\n// - square and hexagonal tiling with cyclic mirroring\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// const\nconst float PI = 3.14159265359,\n    PI_2 = PI/2., PI_3 = PI/3., PI_4 = PI/4., PI_6 = PI/6.,\n    SQRT2 = sqrt(2.), SQRT_2 = 1./SQRT2,  \n    SQRT3 = sqrt(3.), SQRT_3 = 1./SQRT3;\n\n// 1D\nfloat csteps(float x,float b) {\n    //centered step, step width b\n    return b*floor((x/b+0.5));\n}\n\nfloat signeveodd(float x) {\n    return sign(mod(x-0.5,2.)-1.);\n}\n\nfloat smoothpuls(float x,float b) {\n    return smoothstep(abs(b),0.,abs(x));\n}\n\n// complex\nvec2 cmul(vec2 z, vec2 w) {\n\treturn vec2(z.x*w.x-z.y*w.y,\n                z.x*w.y+z.y*w.x);\n}\nvec2 cinv(vec2 z) {\n\treturn z*vec2(1,-1)/dot(z,z);\n}\nvec2 cdiv(vec2 z, vec2 w) {\n\treturn cmul(z,cinv(w));\n}\nvec2 cpow(vec2 z, int n) {\n\tfloat r = length(z);\n\tfloat theta = atan(z.y,z.x);\n\treturn pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\nvec2 crot(vec2 z,float a) {\n\tfloat si = sin(a), co = cos(a);\n\treturn mat2(co,-si,si,co)*z;\n}\n\n// grid's\nvec2 recgrid2rec(in vec2 Z, out vec2 Z_id, out float  z_sr) {  \n    // maps a grid of unit-squares to one unit-square\n    // The unit-square is inside of the unit-circle\n    // with edge orientation pointing in x plus direction    \n    Z = crot(Z,PI_4);\t\t// F:orientation-offset of cell\n    Z/= SQRT_2;\t\t\t\t// F:scale cell\n    Z_id = 2.*floor(Z*.5+0.5);\t// global cell offset id (...,-4,-2,0,+2,+4,...)\n    vec2 Z_lo = Z-Z_id;\t\t\t// local cell coord's\n    Z = Z_lo;\t\t\t\t// mape grid-cell to unit-cell\n    z_sr = signeveodd(0.5*(Z_id.x+Z_id.y));// sense of rotation of local cell    \n    Z_id = vec2(signeveodd(Z_id.x*0.5),signeveodd(Z_id.y*0.5));//(...,-2,-1,0,+1,+2,...)\n    Z.x *= Z_id.x;//mirror x\n    Z.y *= Z_id.y;//mirror y\n    Z *= SQRT_2;\t\t\t// B:scale cell\n    return crot(Z,-PI_4);\t// B:orientation-offset of cell\n}\n\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id) {        \n    // maps a grid of unit-hexagons to one unit-hexagon\n    // with edge orientation pointing in x plus direction\n    // using cubic coordinates\n    // The unit-hexagon is inside of the unit-circle    \n    // ==> https://www.redblobgames.com/grids/hexagons/\n\t// ==> https://bl.ocks.org/patricksurry/0603b407fa0a0071b59366219c67abca\n\tconst mat2 M = mat2(SQRT_3,-1.,-SQRT_3,-1.),\n        iM = 0.5*mat2(SQRT3,-SQRT3,-1.,-1.);\n    Z = crot(Z,PI_6);\t\t// F:orientation-offset of cell     \n    Z = iM*Z/0.75;          // F:scale cell\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y);// plane: x+y+z=0\n    U_id = 2.*floor(U*0.5+0.5);\t\t// global cell offset id \n    vec3 U_lo = U-U_id;\t\t\t\t// local cell coord's\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) U_lo.x = -U_lo.y-U_lo.z;\n    if (aU_lo.y > aU_lo.z) U_lo.y = -U_lo.x-U_lo.z;\n    else U_lo.z = -U_lo.x-U_lo.y;\n    Z = U_lo.rb; \t\t\t// mape grid-zell to unit-zell\n    Z = M*Z*0.75; \t\t\t// B:scale of cell\n    return crot(Z,-PI_6);\t// B:orientation-offset of cell  \n}\n\nvec2 hex2tri(in vec2 Z, out float a_id, out float a_cy) {\n    // maps 6 triangles inside a unit-hexagon to one unit-triangle\n    // The unit-hexagon is inside of the unit-circle\n    // with edge orientation pointing in x plus direction    \n    Z = crot(Z,-PI_6); \t\t// orientation adaption  tri2hex ==> hexgrid2hex \n    Z = crot(Z,PI_3);\t\t// F:orientation-offset of simplex  \n    float a = atan(Z.y,Z.x);   \n    a_id = floor(a/PI_3+0.5);// triangle offset id ((-3),-2,-1,0,1,2,(3))\n    float a_lo = a-PI_3*a_id;\t\t\t// local coord's angle\n    a_cy = signeveodd(a/PI_3);\t\t\t// cycle even +1, odd -1\n    Z = crot(Z,PI_3*a_id);\t\t\t\t// mape grid-zell to unit-triangle\n    Z = (Z-vec2(SQRT_3,0.))*SQRT3; \t\t// translation,scale unit-triangle\n    Z.y *= a_cy;\t\t\t\t\t\t// y-mirror cyclic\n    return crot(Z,-PI_3);\t\t\t\t// B:orientation-offset of unit-triangle\n}\n\n//color\nvec3 h2rgb(float h) {\t\t// hue, saturation, value\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n    return rgb;\n}\n\n// inface: vec2 => bool\nbool inudisk(vec2 z){\n    // in unit disk\n\treturn (length(z)<1.);\n}\n\nbool inupoly(vec2 z,int k) {\n    const float PI = 3.14159265359;\n    // in unit polygon\n    k = abs(k);\t\t\t//poly-num-edges\n    bool m = true;\t\t//bit-mask    \n    if (k<3) {\n        m = false;\n    } else {   \n        float a = PI/float(k);\n        float h = cos(a);//\n        for (int i=0; i<k; i++) {\n            float a1 = 2.*a*float(i);\n            vec2 w = vec2(cos(a1),sin(a1));\n            if(dot(w,z)>h) m = false;\n        }\n    }\n    return m;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// This code is from Matthew Arcus, 2020. \"The Schwarz-Christoffel mapping:\"\n// https://www.shadertoy.com/view/tsfyRj\n////////////////////////////////////////////////////////////////////////////////\nfloat binomial(float a, int n) {\n    float s = 1.0;\n    for (int i = n; i >= 1; i--,a--) {\n        s *= float(a)/float(i);\n    }\n    return s;\n}\n\n// The Lanczos approximation, should only be good for z >= 0.5,\n// but we get the right answers anyway.\nfloat gamma(float z) {\n    const float[8] p = float[](\n        676.5203681218851,\n        -1259.1392167224028,\n        771.32342877765313,\n        -176.61502916214059,\n        12.507343278686905,\n        -0.13857109526572012,\n        9.9843695780195716e-6,\n        1.5056327351493116e-7\n    );\n    z -= 1.0;\n    float x = 0.99999999999980993; // Unnecessary precision\n    for (int i = 0; i < 8; i++) {\n        float pval = p[i];\n        x += pval/(z+float(i+1));\n    }\n    float t = z + 8.0 - 0.5;\n    return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// The Beta function\nfloat B(float a, float b) {\n    return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\n// Original Octave/Matlab code for main function:\n// w=z(inZ).*( 1-cn(1)*h+(-cn(2)+(K+1)*cn(1)^2)*h.^2+\n// (-cn(3)+(3*K+2)*(cn(1)*cn(2)-(K+1)/2*cn(1)^3))*h.^3+\n// (-cn(4)+(2*K+1)*(2*cn(1)*cn(3)+cn(2)^2-(4*K+3)*(cn(1)^2*cn(2)-(K+1)/3*cn(1)^4)))*h.^4+\n// (-cn(5)+(5*K+2)*(cn(1)*cn(4)+cn(2)*cn(3)+(5*K+3)*(-.5*cn(1)^2*cn(3)-.5*cn(1)*cn(2)^2+\n//   (5*K+4)*(cn(1)^3*cn(2)/6-(K+1)*cn(1)^5/24))))*h.^5./(1+h/C^K) );\n\nvec2 inversesc(vec2 z, int K) {\n    float cn[6];\n    for (int n = 1; n <= 5; n++) {\n        cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K); // Series Coefficients\n    }\n    float C = B(1.0/float(K),1.0-2.0/float(K))/float(K); // Scale factor\n    z *= C; // Scale polygon to have diameter 1\n    vec2 h = cpow(z,int(K));\n    float T1 = -cn[1];\n    float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n    float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n    float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n    float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n    vec2 X = vec2(1,0)+h/pow(C,float(K));\n    vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n    return w;\n}\n\nvec3 getcolor(vec2 z, int K) {\n    if (iMouse.x > 0.0) {\n        // Apply an inversion/Mobius transformation\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/min(iResolution.x,iResolution.y); \n        m /= dot(m,m); // m inverted in unit circle\n        z -= m;\n        z *= (dot(m,m)-1.0)/dot(z,z);\n        z += m;\n    }\n    // And a rotation (also a Mobius transformation)\n    z = crot(z,0.5*iTime);\n    float r = length(z);\n    float theta = atan(z.y,z.x);\n    vec3 col = h2rgb(theta/(2.0*PI));\n    // uv-lines\n    float A = 4.0;\n    float B = 2.0*float(K);\n    float a = -log(r)*A;\n    float ds = 0.07;\n    if (a <= 6.0+ds) {\n        a = fract(a);\n        float b = fract(theta/PI*B);\n        float d = min(min(a,1.0-a),min(b,1.0-b));\n        col *= mix(0.2,1.0,smoothstep(-ds,ds,d));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int K = (3+int(0.1*iTime)%2);\n    \n    vec2 z = 2.*(2.*fragCoord.xy - iResolution.xy)/min(iResolution.x,iResolution.y);\n\n    if (K==4) {\n    vec2 recgrid_id = vec2(0.); float recgrid_sr;\n    z = recgrid2rec(z, recgrid_id, recgrid_sr);\n    }\n \n    if (K==3) {\n      vec3 U_id = vec3(1.,1.,1.); float a_id = 1.; float a_cy = 0.;\n      z = hexgrid2hex(z, U_id);\n      z = hex2tri(z, a_id, a_cy);\n    }\n    \n    z = inversesc(z,K);\n\n    // color \n    vec3 col = getcolor(z,K);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(0.6*col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsBDS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[796, 802, 833, 867, 900], [902, 902, 929, 929, 966], [968, 968, 1003, 1003, 1046], [1048, 1059, 1086, 1086, 1152], [1153, 1153, 1172, 1172, 1205], [1206, 1206, 1233, 1233, 1260], [1261, 1261, 1287, 1287, 1423], [1424, 1424, 1451, 1451, 1516], [1518, 1528, 1589, 1759, 2349], [2351, 2351, 2395, 2735, 3432], [3434, 3434, 3491, 3673, 4277], [4279, 4287, 4308, 4335, 4493], [4495, 4519, 4540, 4560, 4586], [4588, 4588, 4616, 4616, 5040], [5042, 5322, 5354, 5354, 5466], [6127, 6148, 6175, 6175, 6220], [6632, 6632, 6663, 6663, 7674], [7676, 7676, 7706, 7706, 8486], [8488, 8488, 8545, 8545, 9091]], "test": "untested"}
{"id": "3llBDS", "name": "glitch3.frag", "author": "thefox231", "description": "the threequel", "tags": ["glitch"], "likes": 8, "viewed": 950, "published": 3, "date": "1597615781", "time_retrieved": "2024-07-30T20:50:22.455876", "image_code": "#define bmp 170.0\n\nvec2 uvp(vec2 uv) {\n\treturn clamp(uv, 0.0, 1.0);\n}\n\nfloat outCirc(float t) {\n    return sqrt(-t * t + 2.0 * t);\n}\n\nfloat rand(vec2 co) {\n\treturn fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col;\n    float amp;\n    \n    if (iMouse.z <= 0.0) {\n        amp = (1.0 - outCirc(fract(iTime/60.0*bmp)));\n    } else {\n        amp = iMouse.x/iResolution.x;\n    }\n    \n    //amp *= 0.5;\n    \n    for (int i = 0; i < 3; i++) {\n    \tvec2 uv = fragCoord / iResolution.xy;\n        uv += vec2(sin(iTime + float(i) + amp), cos(iTime + float(i) + amp)) * amp * 0.2;\n        vec3 texOrig = texture(iChannel0, uvp(uv)).rgb;\n        \n        uv.x += (rand(vec2(uv.y + float(i), iTime)) * 2.0 - 1.0) * amp * 0.8 * (texOrig[i] + 0.2);\n        uv.y += (rand(vec2(uv.x, iTime + float(i))) * 2.0 - 1.0) * amp * 0.1 * (texOrig[i] + 0.2);\n        \n        vec3 tex = texture(iChannel0, uvp(uv)).rgb;\n        \n        //tex += (rand(uv + iTime + float(i)) * 2.0 - 1.0) * amp * 0.1;\n        //tex += (rand(uv + iTime + tex[i] + float(i)) * 2.0 - 1.0) * amp * 0.2;\n        //tex += mix(1.0, rand(uv + tex[i] + float(i) * 253.6 + iTime) * tex.r * 5.0, amp);\n        tex += abs(tex[i] - texOrig[i]);\n        \n        tex *= rand(uv) * amp + 1.0;\n        \n        tex = fract(tex);\n        \n        col[i] = tex[i];\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 38, 38, 69], [71, 71, 95, 95, 132], [134, 134, 155, 155, 223], [225, 225, 280, 280, 1425]], "test": "untested"}
{"id": "WtlBDS", "name": "Menger z", "author": "illus0r", "description": "Menger z", "tags": ["raymarching"], "likes": 2, "viewed": 317, "published": 3, "date": "1597615745", "time_retrieved": "2024-07-30T20:50:23.326548", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 200\n#define MAX_DIST 5.\n#define SURF_DIST .0001\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\n\n\n\n\nfloat GetDist(vec3 p) {\n    \n    p.xz *= Rot(sin(iTime));\n\n    p.x = abs(p.x);\n    p.x += 0.1 * sin(iTime / 1.7);\n    //p.x -= 0.1 * sin(iTime);\n    \n\n    p.z = abs(p.z);\n    p.z += 0.1 * sin(iTime / 1.4);\n    //p.z -= 0.1 * sin(iTime);\n\n    float box = sdBox(p, vec3(iTime));\n    //p.y += iTime / 10.;\n    p.y += iTime * 1.;\n    \n    \n    float hole = 0.;\n\n    float holiness = 3.;//2. + 2. * (0.5 + 0.5 * sin(p.y + iTime));\n    float iterations = 3.;\n    for (float axes = 0.; axes <= 2.; axes++) {\n        p = p.zxy;\n\t    vec3 pm = p;\n   \t\tfor (float i = 1.; i <= iterations; i++) {\n        \tpm.xy = fract((pm.xy * 1. * i + 0.5)) - 0.5;\n\t\t    hole = min(hole, sdBox(pm, vec3(1./holiness/i, 1./holiness/i, iTime * 2.)));\n\t    }\n    }\n    \n    //hole /= 2. * iterations;\n    hole *= 3.9;\n    \n    return max(0., -hole);\n}\n\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0., 0.);\n    vec3 camDir = vec3(0.001, 1., 0);\n    \n    camDir.yz *= Rot(-m.y*3.14+1.);\n    camDir.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, ro + camDir, 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \t//float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \t//col += dif;\n        //col = n / 2. + 0.5;\n        //col *= n.x;\n        col = vec3(1.-smoothstep(0., 4., d));\n    }\n    \n    //col = pow(col, vec3(.4545));\t// gamma correction\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlBDS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[338, 338, 357, 357, 419], [421, 421, 443, 443, 537], [539, 539, 568, 568, 649], [656, 656, 679, 679, 1478], [1485, 1485, 1519, 1519, 1730], [1732, 1732, 1756, 1756, 1946], [1948, 1948, 1998, 1998, 2189], [2193, 2193, 2250, 2250, 2985]], "test": "untested"}
{"id": "3tfBzs", "name": "The Hole v2", "author": "BackwardsCap", "description": "A raymarched version of https://www.shadertoy.com/view/ttXfDM\n\nInspired by this tweet: https://twitter.com/PelletierAuger/status/1291072500521148419", "tags": ["raymarching", "hole"], "likes": 4, "viewed": 300, "published": 3, "date": "1597614356", "time_retrieved": "2024-07-30T20:50:24.092500", "image_code": "float edgesize = .02;\n\nfloat map(vec3 p)\n{\n    float a = (1.0+sin(iTime))/2.0;\n    float r = box(p-vec3(0,0,60),vec3(30,20,50));\n\tfloat offset=10.*min(0.,(((10.0+edgesize)-p.z)/20.));\n    float t = iTime/2.;\n    p.x+=cos(t)*offset;\n    p.y+=sin(t)*offset;\n    \n    vec3 hp = p;\n    hp.xy*=rot(iTime);\n    float h = hex(hp-vec3(0,0,60),vec2(.5,50));\n\n    float r2 = hex(p-vec3(0,0,50),vec2(1.,50));\n    p.xy=abs(p.xy);\n    r2 = min(r2, hex(p-vec3(2.,0,0),vec2(1.,50)));\n    r2 = min(r2, hex(p-vec3(1.5,1.7,0),vec2(1,50)));\n    r2 = min(r2, hex(p-vec3(-.8,1,0),vec2(1.,50)));\n    \n    r=max(r,-r2);\n    return min(r,h);\n}\n\n//ao and edge technique thanks to nusan\n//https://www.shadertoy.com/view/WtyXDt\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat ray(vec3 ro, vec3 rd, vec2 uv)\n{\n    float t = 0.;\n    \n    for(int i=0;i<200;i++)\n    {\n        vec3 p = ro+rd*t;\n        float s = map(p);\n        \n        if(s<1e-5)break;\n        t+=s;\n        if(t>MAX_DIST){t=-1.;break;}\n    }\n    return t;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0001,0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)));\n}\n\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    \n    vec2 uv = (2.*f-R)/R.y;\n    uv *= rot(mod((-iTime*.1), 3.1415927 * 2.0));\n    vec3 ro = vec3(0,0,0);\n    vec3 ta = vec3(0,0,10);\n    vec3 cf = normalize(ta-ro);\n    vec3 cu = normalize(cross(cf,vec3(0,1,0)));\n    vec3 cr = normalize(cross(cu,cf));\n    vec3 rd = normalize(uv.x*cu+uv.y*cr+2.*cf);\n    \n    float r = ray(ro,rd, f);\n    \n    vec3 col = vec3(1);\n    \n    float fog = 1.;\n    \n    if(r>0.)\n    {\n        vec3 p = ro+rd*r;\n        vec3 n = normal(p);    \n\t\t\n        float ao = getao(p,n,edgesize);\n        float ao2 = getao(p,n,-edgesize);\n        col-=(r-10.)/35.+smoothstep(1.,.9,ao*ao2)*10.;\n    }\n    \n    c.rgb=col;\n}", "image_inputs": [], "common_code": "#define MAX_DIST 100.0\n#define R iResolution.xy\n\nmat2 rot(float x)\n{\n    float s = sin(x);\n    float c = cos(x);\n    return mat2(c,-s,s,c);\n}\n\nfloat box(vec3 p, vec3 d)\n{\n  vec3 q = abs(p) - d;\n  return min(max(q.x,max(q.y,q.z)),0.0)+length(max(q,0.0));\n}\n\nfloat hex( vec3 p, vec2 h )\n{\n  vec3 k = vec3(-0.866, 0.5, 0.577);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  float x = length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x);\n  vec2 d = vec2(x, p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 42, 42, 619], [621, 701, 742, 742, 788], [790, 790, 828, 828, 1043], [1045, 1045, 1066, 1066, 1231], [1234, 1234, 1275, 1275, 1918]], "test": "untested"}
{"id": "tlXfDB", "name": "Raymarcher basic mode", "author": "str", "description": "Raymarching tut https://www.youtube.com/watch?v=PGtv-dBi2wE&t=285s", "tags": ["raymarching"], "likes": 0, "viewed": 240, "published": 3, "date": "1597609601", "time_retrieved": "2024-07-30T20:50:24.864436", "image_code": "#define SURFACE_DISTANCE_EPSILON 0.01\n#define MAX_STEPS 100\n#define MAX_DISTANCE 100.\n\nfloat getDistanceToScene(vec3 point) {\n    vec4 sphere = vec4(0, 1, 6, 1);\n    float distanceToSphere = length(point - sphere.xyz) - sphere.w;\n\n    float distanceToPlane = point.y;\n    float distance = min(distanceToSphere, distanceToPlane);\n\n    return distance;\n}\n\nvec3 getNormal(vec3 point) {\n  vec2 epsilon = vec2(.01, 0);\n  float distance = getDistanceToScene(point);\n\n  // swizzles\n  vec3 normal = distance - vec3(\n    getDistanceToScene(point - epsilon.xyy),\n    getDistanceToScene(point - epsilon.yxy),\n    getDistanceToScene(point - epsilon.yyx)\n  );\n\n  return normalize(normal);\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDistance) {\n    float distanceFromOrigin = 0.;\n\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 point = rayOrigin + distanceFromOrigin * rayDistance;\n        float distanceToScene = getDistanceToScene(point);\n\n        distanceFromOrigin += distanceToScene;\n\n        if (distanceToScene < SURFACE_DISTANCE_EPSILON || distanceFromOrigin > MAX_DISTANCE) {\n            break;\n        }\n    }\n    return distanceFromOrigin;\n}\n\nfloat getLight(vec3 point) {\n  vec3 lightPosition = vec3(0, 5, 6);\n  lightPosition.xz += vec2(sin(iTime), cos(iTime));\n\n  vec3 light = normalize(lightPosition - point);\n\n  vec3 normal = getNormal(point);\n\n  float diffuse = clamp(dot(normal, light), 0., 1.);\n\n  // calculate shadows\n  float distance = rayMarch(point + normal * SURFACE_DISTANCE_EPSILON * 2., light);\n  if (distance < length(lightPosition - point)) {\n    diffuse *= .1;\n  }\n\n  return diffuse;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    vec3 rayOrigin = vec3(0, 1, 0);\n    vec3 rayDistance = normalize(vec3(uv.x, uv.y, 1));\n\n    float distance = rayMarch(rayOrigin, rayDistance);\n\n    vec3 point = rayOrigin + rayDistance * distance;\n    float diffuseLight = getLight(point);\n\n    vec3 col = vec3(diffuseLight);\n    // vec3 col = getNormal(point);\n\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 125, 125, 352], [354, 354, 382, 382, 677], [679, 679, 729, 729, 1145], [1147, 1147, 1175, 1175, 1606], [1609, 1609, 1664, 1714, 2134]], "test": "untested"}
{"id": "Xssyzl", "name": "Piet Mondrian - Tableau2", "author": "luar", "description": "Piet Mondrian - Tableau2 with mouse interaction", "tags": ["2d", "color", "art", "shape"], "likes": 1, "viewed": 296, "published": 3, "date": "1597609087", "time_retrieved": "2024-07-30T20:50:25.627396", "image_code": "float random (in float x) {\n    return fract(sin(x)*1e4);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    vec2 mouseRatio = iMouse.xy / (iResolution.xy*2.0);\n    //float angle = radians(mod(iTime,360.0));\n    //vec2 mouseRatio = vec2(cos(iTime*0.5),sin(iTime*0.5));\n    vec3 bgcolor = vec3(248.0/255.0,241.0/255.0,225.0/255.0);\n    vec3 red = vec3(168.0/255.0,34.0/255.0,35.0/255.0);\n    vec3 yellow = vec3(254.0/255.0,195.0/255.0,45.0/255.0);\n    vec3 blue = vec3(0.0,93.0/255.0,151.0/255.0);\n    vec3 color = bgcolor;\n    \n    float lineW = 0.01;\n    float lineH = lineW*iResolution.x/iResolution.y;\n    float powValue = 1.89;\n    float divider = 4.0;\n    vec2 start = mouseRatio;\n\n    \n    float hiddenLine = floor(mod(iTime,divider));\n    \n    for (float j=0.0;j<divider;j+=1.0) {\n        if (j>=hiddenLine && j<hiddenLine+0.5) {\n            float startY = pow(start.y+mouseRatio.y*(j-1.0),powValue);\n            float colorY1 = startY;\n            float colorY2 = pow(start.y+mouseRatio.y*(j+1.0),powValue);\n            if (j>0.0) {\n                colorY1 += lineH;\n            }\n            if (j>divider-1.5) {\n                colorY2 = 1.0;\n            }\n            if (st.y>=colorY1 && st.y<=colorY2 && st.x<pow(start.x, powValue)) {\n                color=red;\n            }\n        }\n    }\n        \n    for (float i=0.0;i<divider;i+=1.0) {\n        float startX = pow(start.x+mouseRatio.x*i,powValue);\n        if (st.x>startX && st.x<startX+lineW) {\n            color=vec3(0.0);\n        }\n    }\n\tfor (float j=0.0;j<divider;j+=1.0) {\n        float startY = pow(start.y+mouseRatio.y*j,powValue);\n        if (st.y>startY && st.y<startY+lineH) {\n            color=vec3(0.0);\n        }\n        if (j>=hiddenLine && j<hiddenLine+0.5) {\n            float startX = pow(start.x*(divider-1.0),powValue)+lineW;\n            float endX = pow(start.x*(divider),powValue);\n            if (st.x>startX && st.x<endX) {\n                if (st.y>startY && st.y<startY+lineH) {\n                \tcolor=bgcolor;\n                }\n                float colorY1 =pow(start.y+mouseRatio.y*(j-1.0),powValue);\n                float colorY2 = pow(start.y+mouseRatio.y*(j+1.0),powValue);\n                if (j>0.0) {\n                \tcolorY1 += lineH;\n            \t}\n                if (j>divider-1.5) {\n                \tcolorY2 = 1.0;\n            \t}\n                if (st.y>colorY1 && st.y<colorY2) {\n                \tcolor=yellow;\n            \t}\n            }\n        }\n    }\n    \n    for (float i=0.0;i<divider;i+=1.0) {\n        if (i>=hiddenLine && i<hiddenLine+0.5) {\n            float startX = pow(start.x+mouseRatio.x*(i-1.0),powValue);\n            float colorX1 = startX;\n            float colorX2 = pow(start.x+mouseRatio.x*(i+1.0),powValue);\n            if (i>0.0) {\n                colorX1 += lineW;\n            }\n            if (i>divider-1.5) {\n                colorX2 = 1.0;\n            }\n            if (st.x>=colorX1 && st.x<=colorX2 && st.y<pow(start.y, powValue)) {\n                color=blue;\n            }\n        }\n    }\n\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xssyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 59], [62, 62, 119, 119, 3117]], "test": "untested"}
{"id": "tlffWB", "name": "Razor Blossom", "author": "ruojake", "description": "A quick doodle inspired by BigWings' torus knot tutorial", "tags": ["3d", "raymarching", "torus"], "likes": 6, "viewed": 308, "published": 3, "date": "1597608927", "time_retrieved": "2024-07-30T20:50:26.388361", "image_code": "// Razor Blossom by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#define sat(x) clamp(x, 0., 1.)\n\nfloat hash12(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(3.5341, 2.9413))) * 4321.123);\n}\n\nvec2 hash21(float v)\n{\n    vec2 p = vec2(v * 12.3 + 2., v + 11.31);\n\treturn fract(sin(p + dot(p, vec2(2.5341, 1.9413))) * 41321.123);\n}\n\nmat2 rot(float a)\n{\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat scene(vec3 p)\n{\n    p.y *= 2.;\n    vec2 h2 = hash21(floor(p.y - .5));\n    p.xz += h2 * 3.;\n    float s = fract(dot(floor(p.xz - .5), vec2(1)) * .5) * 4. - 1.;\n    float h = hash12(floor(p.xz) + h2.x);\n    p.y -= .5;\n    p = abs(fract(p) * 2. - 1.);\n    float a = atan(p.x, p.z) * s;\n    float x = length(p) - .75;\n    vec2 cp = vec2(x, p.y);\n    cp *= rot(a * 2. + iTime * (6. + h * 7.));\n    cp.y = abs(abs(cp.y) - .0625) - .025;\n    \n\treturn (max(abs(cp.x), abs(cp.y)) - .025) * .3;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat d = scene(p);\n    vec2 e = vec2(.001, .0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nvec3 ray(vec3 ro, vec3 lookAt, vec2 uv, float zoom)\n{\n\tvec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n\n    return normalize(uv.x * r + uv.y * u + f * zoom);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 v = vec3(.2, 0., .1) * iTime;\n    vec3 ro = vec3(0, .25, -2) + v;\n    vec3 tgt = vec3(-1) + v;\n    vec3 rd = ray(ro, tgt, uv, .7);\n    vec3 p;\n    float t = 0.;\n    \n    for(int i = 0; i < 200; i++)\n    {\n    \tp = ro + rd * t;\n        float d = scene(p) * (1. + rd.y * .5);\n        t += d;\n        if (abs(d) < .0001 || t > 10.) break;\n    }\n    \n    vec3 n = normal(p);\n    vec3 lDir = normalize(ro - p);\n    float l = dot(n, lDir) * .5 + .5;\n    l *= sat(2. - length(ro - p) * .4);\n    l *= sat(scene(p + n * .01) * 200.) * .5 + .5;\n    \n    vec3 col = mix(vec3(.05,.05,.3), vec3(.9, .4, .8), l);\n    col += l * l * l;\n    col *= sat(2. - t * .3);\n\n    col *= vec3(1., .97, .92);\n    \n    col = pow(col, vec3(1./2.2));\n    col *= 1. - smoothstep(.45, .7, length((uv * iResolution.y / iResolution.xy))) * .5;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlffWB.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[147, 147, 169, 169, 232], [234, 234, 256, 256, 369], [371, 371, 390, 390, 463], [465, 465, 486, 486, 957], [959, 959, 980, 980, 1143], [1145, 1145, 1198, 1198, 1356], [1358, 1358, 1415, 1415, 2338]], "test": "untested"}
{"id": "ttffDB", "name": "Color Amplification", "author": "laube", "description": "Amplifies color of the input video from buffer C.\n\nParameters are in Common.\n\nInspired by http://people.csail.mit.edu/mrub/PhDThesis/", "tags": ["color", "amplification"], "likes": 4, "viewed": 432, "published": 3, "date": "1597608794", "time_retrieved": "2024-07-30T20:50:27.158303", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 smoothed = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n\tvec3 raw = texture(iChannel1, fragCoord / iResolution.xy).xyz;\n    \n    vec3 diff = hsv_sub(raw, smoothed);\n    vec3 gain = GAIN;\n    \n    fragColor = vec4(1.);\n    fragColor.xyz = hsv2rgb(hsv_add(raw, diff * gain));\n    //fragColor.xyz = vec3(.5) + diff * gain;\n    //fragColor.xyz = hsv2rgb(raw);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Smoothing (slow)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 previous = texture(iChannel1, fragCoord / iResolution.xy).xyz;\n    vec3 next = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n    \n    // a = previous, b = next\n    // r = a * (1 - m) + b * m \n    //   = a + b * m - a * m \n    //   = a + (b - a) * m\n    // d = (b - a)\n    // r = a + d * m\n    \n    vec3 d = hsv_sub(next, previous);\n    fragColor.xyz = hsv_add(previous, d * vec3(SMOOTH_BASELINE));\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Smoothing (fast)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 previous = texture(iChannel1, fragCoord / iResolution.xy).xyz;\n    vec3 next = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n    \n    // a = previous, b = next\n    // r = a * (1 - m) + b * m \n    //   = a + b * m - a * m \n    //   = a + (b - a) * m\n    // d = (b - a)\n    // r = a + d * m\n    \n    vec3 d = hsv_sub(next, previous);\n    fragColor.xyz = hsv_add(previous, d * vec3(SMOOTH_RAW));\n}\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Sampling and RGB to HSV\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n = 0.;\n    vec3 rgb = vec3(0.);\n    \n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    float taspect = iChannelResolution[0].y / iChannelResolution[0].x;\n    \n    for (int x = -BLUR_INPUT_RADIUS; x < BLUR_INPUT_RADIUS + 1; x++) {\n        for (int y = -BLUR_INPUT_RADIUS; y < BLUR_INPUT_RADIUS + 1; y++) {\n            float f = 1. / (1. + length(vec2(x, y)) / 2.);\n    \t\tvec2 chOfs = vec2(x, y);\n            rgb += texture(\n                iChannel0, \n                vec2(\n                    .5 + uv.x * taspect + chOfs.x / iChannelResolution[0].x,\n                    .5 + uv.y +           chOfs.y / iChannelResolution[0].y\n                )\n            ).xyz * f;\n            n += f;\n        }\n    }\n    \n    fragColor.xyz = rgb2hsv(rgb / n);\n}\n", "buffer_c_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BLUR_INPUT_RADIUS 3         // Blurring of input to reduce noise\n#define SMOOTH_RAW .2\t\t\t\t// Exponential color smoothing constant for raw footage to reduce color noise. 1 -> no smoothing\n#define SMOOTH_BASELINE .1\t\t\t// Exponential color smoothing constant for baseline image. 1 -> no smoothing\n#define GAIN vec3(30., 20., 10.)\t// Hue, Saturation, Value amplification\n\nvec3 hsv_sub(vec3 a, vec3 b)\n{\n    vec3 res = vec3(0.);\n    res.yz = a.yz - b.yz;\n    \n    // h1 - h0 = 0\n    // h0.5 - h0.4 = 0.1\n  \t// h0.9 - h0.1 = -0.2\n  \t// h0.1 - h0.9 = 0.2\n    // h0.4 - h0.5 = -0.1\n    \n    float d1 = a.x - b.x;\n    \n    if (d1 < -0.5) {\n        res.x = d1 + 1.;\n    } else if (d1 > 0.5) {\n        res.x = d1 - 1.;\n    } else {\n        res.x = d1;\n    }\n    \n    return res;\n}\n\n\nvec3 hsv_add(vec3 a, vec3 b)\n{\n    vec3 res = a + b;\n    res.x = mod(res.x, 1.0);\n    return res;\n}\n\n// Taken from https://stackoverflow.com/a/17897228\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttffDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 432]], "test": "untested"}
{"id": "tlfBDS", "name": "15. Drive Home 6 - Rain Window", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=52TMliAWocY\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["drivehome"], "likes": 14, "viewed": 2662, "published": 3, "date": "1597607531", "time_retrieved": "2024-07-30T20:50:28.109759", "image_code": "\n#define S( a , b , t ) smoothstep( a , b , t )\n\nstruct Ray {\n\tvec3 ro;\t\t// Ray Origin\n    vec3 rd;\t\t// Ray Direction\n};\n\n    \n\n// Noise\nfloat Noise(float t) {\n    float n = fract( sin( t * 3456.) * 4547. ) ;\n    return n;\n}\n\n// Noise 1 Input and 4 Output\nvec4 Noise14(float t ) {\n    vec4 n = fract( sin( t * vec4(123. , 1024. , 3456. , 9564. ) ) * vec4( 6547., 345., 8799., 1564. ) );    \n    return n;\n}\n\n\n// RAY\nRay GetRay( vec2 uv , vec3 camPos , float camZoom , vec3 lookAt ) {\n \n    Ray ray;\n     \n    ray.ro = camPos;\n    \n    vec3 F = normalize( lookAt - camPos );\n    vec3 R = normalize( cross( vec3( 0 , 1 , 0 ) , F ) );\n    vec3 U = cross( F , R );\n    \n    vec3 center  = camPos + F * camZoom;\n    vec3 intersectionPoint = center + uv.x * R  + uv.y * U;\n    \n    // rd have to do normalized.\n    // because where GetClosestPoint() , dot ( target - ro , rd ) * rd.\n    ray.rd = normalize( intersectionPoint - camPos );\n    \n    return ray;\n}\n\n\n// \nvec3 GetClosestPoint( Ray ray , vec3 targetPos ) {\n   \n    // 이때 반드시, rd가 노멀라이즈 되어 있어야,\n    // dot( targetPos - ray.ro , ray.rd )가 정확하게 계산이 된다.\n    return ray.ro + max( 0.0f , dot( targetPos - ray.ro , ray.rd ) ) * ray.rd;\n}\n\n\n// \nfloat GetDistance( Ray ray , vec3 targetPos ) {\n\tfloat d = length( targetPos - GetClosestPoint( ray , targetPos ) );\n    return d;\n}\n\n\n// BOKE\nfloat Boke(  Ray ray , vec3 targetPos ,  float lightDiameter , float blur ) {\n    \n    //vec3 targetPos = vec3( -1.0f , 0.15f , z );\n    float d = GetDistance( ray , targetPos );\n    float expandLight = lightDiameter * length( targetPos );\n    //c += Boke( d , expandLight , bokeBlur ) * fade;\n         \n\tfloat c = S( expandLight , expandLight * ( 1.0f - blur ) , d );\n    c *= mix( 0.7f , 1.0f , S( expandLight * 0.8f , expandLight , d ) );\n    return c;\n}\n\n\n\n\n// Street Light\nvec3 StreetLight( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n    float c = 0.0f;\n    \n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    float side = step( ray.rd.x , 0.0f );\n    ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t\n        float ti = fract(t + i + side * s * 0.5f );\n        vec3 targetPos = vec3( 2.0f , 2.0f , 100.0f - ti * 100.0f );\n        c += Boke( ray , targetPos , lightDiameter , bokeBlur ) * ti * ti * ti;\n    }\n         \n    vec3 col = vec3( 1.0f , 0.7f , 0.3f) * c;\n    return col;\n}\n\n\n// Head Light\nvec3 HeadLights( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n\t\n    float headLightDelta = -0.25f;\n    float headLightDelta2 = headLightDelta* 1.2f;\n    \n    \n    time = time * 2.0f;\n    \n    float c = 0.0f;\n    float t = time * 0.1f;\n    float s = 1.0f / 15.0f; // in 1 sec, 100 count.\n    //float side = step( ray.rd.x , 0.0f );\n    //ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t \n        float n = Noise( i );\n\t\tif ( n > 0.1f ) continue;\n        \n        float ti = fract(t + i);\n        float z = 100.0f - ti * 100.0f;\n        float fade = ti * ti * ti * ti * ti;\n        float focus = S( 0.8f , 1.0f , ti );\n        float size = mix( lightDiameter , lightDiameter * 0.5f , focus );\n            \n        c += Boke( ray , vec3( -headLightDelta + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( +headLightDelta + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n\n        c += Boke( ray , vec3( -headLightDelta2 + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( +headLightDelta2 + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n      \n    \n    \t// refection\n        float reflection = 0.0f;\n        \n        reflection += Boke( ray , vec3( -headLightDelta2 + -1.0f , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        reflection += Boke( ray , vec3( +headLightDelta2 + -1.0f , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        \n        c += reflection * focus;\n    }\n         \n    //vec3 col = vec3( 1.0f , 1.7f , 0.3f) * c;\n    vec3 col = vec3( 0.9f , 0.9f , 1.0f) * c;\n    \n    return col;\n}\n\n\n// Tail Light\nvec3 TailLights( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n\t\n    float headLightDelta = -0.25f;\n    float headLightDelta2 = headLightDelta* 1.2f;\n    \n    \n    time = time * 0.1f;\n    \n    float c = 0.0f;\n    //float t = time * 0.1f;\n    float t = time;\n    \n    float s = 1.0f / 15.0f; // in 1 sec, 100 count.\n    //float side = step( ray.rd.x , 0.0f );\n    //ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t \n        float n = Noise( i );\t\t\t// 0 ~ 1\n\t\tif ( n > 0.5f ) continue;\t\t// 0 ~ 0.5\n        \n        \n        \n        float ti = fract(t + i);\n        float z = 100.0f - ti * 100.0f;\n        float fade = ti * ti * ti * ti * ti;\n        float focus = S( 0.8f , 1.0f , ti );\n        float size = mix( lightDiameter , lightDiameter * 0.5f , focus );\n        \n        float lane = step( 0.25f , n );\t// 0 , 1\n        float laneShift = S(0.99f, 0.96f , ti );\n        float carPos = 1.5f - lane * laneShift;\n            \n        float blink = step( 0.0 , sin( t * 10000.0)) * 7.0f * lane * step( 0.9f , ti );\n        \n        c += Boke( ray , vec3( carPos -headLightDelta , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( carPos +headLightDelta , 0.15f , z ) , size , bokeBlur ) * fade;\n\n        c += Boke( ray , vec3( carPos -headLightDelta2 , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( carPos +headLightDelta2 , 0.15f , z ) , size , bokeBlur ) * fade * (1.0f + blink);\n      \n    \n    \t// refection\n        float reflection = 0.0f;\n        \n        reflection += Boke( ray , vec3( carPos -headLightDelta2 , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        reflection += Boke( ray , vec3( carPos +headLightDelta2 , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        \n        c += reflection * focus;\n    }\n         \n    \n    vec3 col = vec3( 1.0f , 0.1f , 0.01f) * c;\n    \n    return col;\n}\n\n\n\n// Environment Light\nvec3 EnvironmentLight( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n    vec3 c = vec3(0);\n    \n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    float side = step( ray.rd.x , 0.0f );\n    ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    \n    vec3 col = vec3(0.);\n    \n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t\n        float ti = fract(t + i + side * s * 0.5f );\n        \n        vec4 n = Noise14( i + side * 100. );\n        float x = mix( 2.5f , 10.f , n.x );\n        float y = mix( 0.1f , 1.5f , n.y );\n        \n        float occulution = sin( ti * 6.28 * 10.0 ) * 0.5f + 0.5f; // 2 pie\n        float fade = ti * ti * ti;\n        fade = occulution;\n        \n        \n        vec3 targetPos = vec3( x , y , 50.0f - ti * 50.0f );\n        \n        col = n.wzy;\n        c += Boke( ray , targetPos , lightDiameter , bokeBlur ) * fade * col * 0.5f;\n    }\n         \n    //vec3 col = vec3( 1.0f , 0.7f , 0.3f) * c;\n    //return col;\n    return c;\n}\n\n// Rain Destort\nvec2 RainDestort(vec2 uv , float t) {\n    \n    t *= 1.0;\n    //uv *= 3.0;\n    vec2 aspectRatio = vec2( 3 , 1 );\n    \n    vec2 st = uv * aspectRatio;\n    st.y += t* 0.22f;\n    \n    vec2 id = floor(st);\t\t\t\t\t\t// offset\n    float n = fract( sin ( id.x * 716.34 ) * 768.34);\n    st.y += n;// offset\n    uv.y += n;\n\tid = floor(st);\n    \n    st = fract( st ) - 0.5f;\t// Center of cell => 0.0f reset\n    \n\t//id = floor(st);\n    t += fract( sin( id.x * 76.34 + id.y * 1453.7 ) *768.34) * 6.283f;\n    \n    // Draw Dot\n    float y = -sin( t + sin( t +  sin(t) * 0.5f )) * 0.43f;\n    vec2 p = vec2( 0. , y );\n    \n    vec2 offset1 = vec2( st - p ) / aspectRatio;\n    \n\tfloat d = length( offset1 );\n    float mask1 = S( 0.07f , 0.00f , d );\n    \n    \n    vec2 offset2 = vec2( (fract( uv * aspectRatio.x * vec2(1.0 , 2.0 ) ) - 0.5f)/vec2(1.0,2.0) );\n    d = length( offset2 );\t// Local UV in Local UV\n    \n    \n    //float mask2 = S( 0.2f , 0.06f , d ) * S( -0.1f , 0.1f ,st.y - p.y  ); // 이게 크다.\n    float mask2 = S( 0.3 *(0.5f - st.y) , 0.0f , d ) * S( -0.1f , 0.1f ,st.y - p.y  ); // 이게 크다.\n    \n    // Draw Line\n    //if ( st.x > 0.46f || st.y > 0.49f ) mask1 = 1.0;\n    \n    // every pixel has slightly different direction. \n    // So It can reflect background.\n    // It is important\n    return vec2( mask1 * 30. * offset1 + mask2 * 30. * offset2 );\n}\n\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5f * iResolution.xy) / min( iResolution.x, iResolution.y);\n\n    vec2 mouseUv = iMouse.xy / iResolution.xy;\n    //float m = length( mouseUv );\n    \n\n\tvec3 camPos = vec3( 0.5f , 0.2f , 0.0f );\n    vec3 lookAt = vec3( 0.5f , 0.2f , 1.0f );\n    float camZoom = 2.0f;\n    \n    \n    \n    float streetLightDiameter = 0.05f;\n    float headLightDiameter = 0.05f;\n    float bokeBlur = 0.1f;\n    \n    vec2 rainDestort;// = vec2(0);\n    rainDestort += RainDestort( uv * 5.0f , iTime ) *0.5f;\t// Rain layer 1\n    rainDestort += RainDestort( uv * 7.0f , iTime ) * 0.5f;\t// Rain layer 2\n\n    // destort uv\n    uv.x += sin(uv.y * sin(iTime) * 50.) * 0.005f;\n    uv.y += sin(uv.x * sin(iTime ) * 30. ) * 0.003f;\n    \n    \n    Ray ray = GetRay( uv - rainDestort , camPos , camZoom , lookAt );\n    \n\n\tvec3 col = StreetLight( ray , streetLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= HeadLights(ray , headLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= TailLights(ray , headLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= EnvironmentLight( ray , streetLightDiameter , bokeBlur, iTime + mouseUv.x );\n    \n    \n    // Back ground Gradient color\n    col+= ( ray.rd.y + 0.25f ) * vec3( 0.2f , 0.1f, 0.5f );\n    \n    //col = vec3(rainDestort , 0.0f );\n    \n    fragColor = vec4( col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 137, 159, 159, 224], [226, 256, 280, 280, 406], [409, 416, 483, 483, 953], [956, 960, 1010, 1155, 1236], [1239, 1243, 1290, 1290, 1375], [1378, 1386, 1463, 1518, 1843], [1848, 1864, 1944, 1944, 2477], [2480, 2494, 2573, 2573, 4128], [4131, 4145, 4224, 4224, 6068], [6072, 6093, 6178, 6178, 7099], [7101, 7117, 7154, 7154, 8476], [8479, 8487, 8544, 8544, 9874]], "test": "untested"}
{"id": "wlffDB", "name": "beLow", "author": "klemek", "description": "beLow logo, animated", "tags": ["logo"], "likes": 4, "viewed": 275, "published": 3, "date": "1597606945", "time_retrieved": "2024-07-30T20:50:28.884687", "image_code": "#define EPS 0.0001\n#define PI 3.141593\n\n// DESIGN\n\n#define bar_w 0.066\n#define bar_h 0.28\n\n// EFFECTS\n\n#define drift_on 1.0\n#define drift_st 4.0\n#define drift_ln 2.0\n#define drift_cyc 30.0\n#define drift_spd 0.5\n\n#define wave_on 1.0\n#define wave_st 14.0\n#define wave_ln 2.0\n#define wave_cyc 30.0\n#define wave_spd 0.5\n#define wave_spd2 10.0\n\n#define spin_on 1.0\n#define spin_st 24.0\n#define spin_ln 1.0\n#define spin_cyc 30.0\n#define spin_spd 1.0\n\n#define dst_on 1.0\n#define dst_ln 4.0\n#define dst_st 10.0\n#define dst_cnt 8.0\n#define dst_spd 0.25\n#define dst_dst 0.1\n\n#define col_on 1.0\n#define col_ln dst_ln\n#define col_st dst_st\n#define col_cyc dst_ln * dst_cnt\n#define col_spd dst_spd\n#define col_dst 0.1\n\n// TIME UTILS\n\n// 1.0 between t=0 and t1 then 0.0 until t2 -> t=0\nfloat timed_act(float it, float t1, float t2, float spd)\n{\n    return (1.0 - step(t1 * spd, mod(it * spd, t2 * spd)));\n}\n\n// 0.0-> 1.0 (smooth) between t=0 and t1 then 0.0 until t2 -> t=0\nfloat timed_step(float it, float t1, float t2, float spd)\n{\n    return timed_act(it, t1, t2, spd) * smoothstep(0.0, 1.0, mod(it * spd, t1 * spd));\n}\n\n// 0.0 -> 1.0 -> 0.0 (smooth) between t=0 and t1 until t2 -> t=0\nfloat timed_bump(float it, float t1, float t2, float spd)\n{\n    return timed_act(it, t1, t2, spd) \n        * smoothstep(0.0, 1.0, mod(it * spd * 2.0, t1 * spd * 2.0)) // ascend\n        * smoothstep(1.0, 0.0, mod(it * spd * 2.0, t1 * spd * 2.0)  - t1 * spd); // descend\n}\n\n// SHAPES UTILS\n\nfloat filled_rect(vec2 uv, vec2 p0, vec2 p1)\n{\n    float c = 1.0;\n    c *= step(min(p0.x, p1.x), uv.x);\n    c *= (1.0 - step(max(p0.x, p1.x), uv.x));\n   \tc *= step(min(p0.y, p1.y), uv.y);\n    c *= (1.0 - step(max(p0.y, p1.y), uv.y));\n    return clamp(c, 0.0, 1.0);\n}\n\nfloat rect(vec2 uv, vec2 p0, vec2 p1, float t)\n{\n    float c = 0.0;\n    vec2 thick = vec2(t * 0.5);\n    c += filled_rect(uv, p0 - thick, p1 + thick);\n    c -= filled_rect(uv, p0 + thick, p1 - thick);\n    return clamp(c, 0.0, 1.0);\n}\n\n// VECTOR SPACE UTILS\n\nvec2 distortion(vec2 uv, float it, vec2 d, float spd, float cycles)\n{\n    float v = 1.0;\n    float cycle_time = 1.0 / spd;\n    v *= timed_act(it, cycle_time, cycle_time * cycles, spd);\n    v *= smoothstep(mod(it * spd, 1.0) - 0.5, mod(it * spd, 1.0) - 0.5 + d.y, uv.y);\n    uv.x += d.x * v * (1.0 - v);\n    return uv;\n}\n\n// LOGO DEFINITION\n\nfloat logo_border(vec2 uv, float it)\n{\n    float c = 0.0;\n    \n    float t0 = spin_on * timed_step(it - spin_st, spin_ln, spin_cyc, spin_spd);\n    vec2 spin1 = t0 * vec2(0.04, -0.035);\n    vec2 spin2 = t0 * vec2(0.04, -0.04);\n    float spin = t0 * 0.04;\n    float spiny1 = t0 * 0.035;\n    \n    // slightly asymetric on purpose\n    c += rect(uv, vec2(-0.40, -0.37) + spin1, vec2(0.36, 0.41) + spin2, 0.018);\n    c += rect(uv, vec2(-0.36, -0.41) - spin1, vec2(0.40, 0.37) - spin2, 0.018);\n    return clamp(c, 0.0, 1.0);\n}\n\nfloat logo_bars(vec2 uv, float it)\n{\n    float c = 0.0;\n    \n    \n    vec2 p0u = vec2(-4.0 * bar_w, 0.0);\n    vec2 p0d = vec2(-3.0 * bar_w, -bar_h);\n    vec2 dx = vec2(bar_w * 2.0, 0.0);\n    vec2 dy = vec2(0.0, bar_h * 2.0);\n    vec2 bar = vec2(bar_w, bar_h);\n    \n    float t0 = drift_on * timed_step(it - drift_st, drift_ln, drift_cyc, drift_spd);\n    vec2 drift = vec2(0.0, -t0 * bar_h * 2.0);\n    \n    float t1 = wave_on * timed_bump(it - wave_st, wave_ln, wave_cyc, wave_spd);\n    \n    for (int i = 0; i < 4; i++) {\n        float fi = float(i);\n        vec2 wave_up = vec2(0.0, t1 * bar_h * (sin(fi * 0.5 + mod(it * wave_spd - wave_st, wave_ln * wave_spd) * wave_spd2) * 0.5 - 0.5));\n        vec2 wave_down = vec2(0.0, t1 * bar_h * (sin((fi + 0.5) * 0.5 + mod(it * wave_spd - wave_st, wave_ln * wave_spd) * wave_spd2) * 0.5 - 0.5));\n        \n        // upper bars\n        c += filled_rect(uv, p0u + dx * fi + drift, p0u + dx * fi + bar + drift + wave_up);\n        \n        // lower bars\n        c += filled_rect(uv, p0d + dx * fi + drift - wave_down, p0d + dx * fi + bar + drift);\n        \n        if (abs(t0) > EPS)\n        {\n            // upper bars clone when drift\n            c += filled_rect(uv, p0u + dx * fi + drift + dy, p0u + dx * fi + bar + drift + dy);\n            // lower bars clone when drift\n\t\t\tc += filled_rect(uv, p0d + dx * fi + drift + dy, p0d + dx * fi + bar + drift + dy);\n        }\n    }\n    // mask to crop out the outside\n    c *= filled_rect(uv, vec2(-4.0 * bar_w, -bar_h), vec2(4.0 * bar_w, bar_h));\n    return clamp(c, 0.0, 1.0);\n}\n\n\nfloat logo(vec2 uv, float it)\n{\n    float c = 0.0;\n    c += logo_border(uv, it);\n    c += logo_bars(uv, it);\n    return clamp(c, 0.0, 1.0);\n}\n\n// MAIN\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord  - .5 * iResolution.xy)/min(iResolution.x, iResolution.y);\n\n\tuv = distortion(uv, iTime - dst_st, vec2(dst_dst * dst_on), dst_spd, dst_cnt);\n    \n    vec3 c3 = vec3(logo(uv, iTime));\n    \n    float color_dist = col_on * 0.01 * timed_bump(iTime - col_st, col_ln, col_cyc, col_spd);\n    if (abs(color_dist) > EPS)\n    { \n        c3 = vec3(\n        \tc3.x,\n        \tlogo(uv + color_dist * vec2(1.0, 0.0), iTime),\n        \tlogo(uv + color_dist * vec2(0.0, 1.0), iTime)\n        );\n    }\n    \n    // click to add color\n    c3 += step(EPS, iMouse.z) * (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n    \n    fragColor = vec4(c3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[721, 772, 830, 830, 892], [894, 960, 1019, 1019, 1108], [1110, 1175, 1234, 1234, 1445], [1464, 1464, 1510, 1510, 1730], [1732, 1732, 1780, 1780, 1964], [1989, 1989, 2058, 2058, 2308], [2330, 2330, 2368, 2368, 2849], [2851, 2851, 2887, 2887, 4416], [4419, 4419, 4450, 4450, 4560], [4571, 4571, 4626, 4626, 5274]], "test": "untested"}
{"id": "tlXfWS", "name": "14. Drive Home 5 - Environment L", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=qWk_ubAKosE\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["drivehome"], "likes": 7, "viewed": 1236, "published": 3, "date": "1597588823", "time_retrieved": "2024-07-30T20:50:29.648644", "image_code": "\n#define S( a , b , t ) smoothstep( a , b , t )\n\nstruct Ray {\n\tvec3 ro;\t\t// Ray Origin\n    vec3 rd;\t\t// Ray Direction\n};\n\n    \n\n// Noise\nfloat Noise(float t) {\n    float n = fract( sin( t * 3456.) * 4547. ) ;\n    return n;\n}\n\n// Noise 1 Input and 4 Output\nvec4 Noise14(float t ) {\n    vec4 n = fract( sin( t * vec4(123. , 1024. , 3456. , 9564. ) ) * vec4( 6547., 345., 8799., 1564. ) );    \n    return n;\n}\n\n\n// RAY\nRay GetRay( vec2 uv , vec3 camPos , float camZoom , vec3 lookAt ) {\n \n    Ray ray;\n     \n    ray.ro = camPos;\n    \n    vec3 F = normalize( lookAt - camPos );\n    vec3 R = normalize( cross( vec3( 0 , 1 , 0 ) , F ) );\n    vec3 U = cross( F , R );\n    \n    vec3 center  = camPos + F * camZoom;\n    vec3 intersectionPoint = center + uv.x * R  + uv.y * U;\n    \n    // rd have to do normalized.\n    // because where GetClosestPoint() , dot ( target - ro , rd ) * rd.\n    ray.rd = normalize( intersectionPoint - camPos );\n    \n    return ray;\n}\n\n\n// \nvec3 GetClosestPoint( Ray ray , vec3 targetPos ) {\n   \n    // 이때 반드시, rd가 노멀라이즈 되어 있어야,\n    // dot( targetPos - ray.ro , ray.rd )가 정확하게 계산이 된다.\n    return ray.ro + max( 0.0f , dot( targetPos - ray.ro , ray.rd ) ) * ray.rd;\n}\n\n\n// \nfloat GetDistance( Ray ray , vec3 targetPos ) {\n\tfloat d = length( targetPos - GetClosestPoint( ray , targetPos ) );\n    return d;\n}\n\n\n// BOKE\nfloat Boke(  Ray ray , vec3 targetPos ,  float lightDiameter , float blur ) {\n    \n    //vec3 targetPos = vec3( -1.0f , 0.15f , z );\n    float d = GetDistance( ray , targetPos );\n    float expandLight = lightDiameter * length( targetPos );\n    //c += Boke( d , expandLight , bokeBlur ) * fade;\n         \n\tfloat c = S( expandLight , expandLight * ( 1.0f - blur ) , d );\n    c *= mix( 0.7f , 1.0f , S( expandLight * 0.8f , expandLight , d ) );\n    return c;\n}\n\n\n\n\n// Street Light\nvec3 StreetLight( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n    float c = 0.0f;\n    \n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    float side = step( ray.rd.x , 0.0f );\n    ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t\n        float ti = fract(t + i + side * s * 0.5f );\n        vec3 targetPos = vec3( 2.0f , 2.0f , 100.0f - ti * 100.0f );\n        c += Boke( ray , targetPos , lightDiameter , bokeBlur ) * ti * ti * ti;\n    }\n         \n    vec3 col = vec3( 1.0f , 0.7f , 0.3f) * c;\n    return col;\n}\n\n\n// Head Light\nvec3 HeadLights( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n\t\n    float headLightDelta = -0.25f;\n    float headLightDelta2 = headLightDelta* 1.2f;\n    \n    \n    time = time * 2.0f;\n    \n    float c = 0.0f;\n    float t = time * 0.1f;\n    float s = 1.0f / 15.0f; // in 1 sec, 100 count.\n    //float side = step( ray.rd.x , 0.0f );\n    //ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t \n        float n = Noise( i );\n\t\tif ( n > 0.1f ) continue;\n        \n        float ti = fract(t + i);\n        float z = 100.0f - ti * 100.0f;\n        float fade = ti * ti * ti * ti * ti;\n        float focus = S( 0.8f , 1.0f , ti );\n        float size = mix( lightDiameter , lightDiameter * 0.5f , focus );\n            \n        c += Boke( ray , vec3( -headLightDelta + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( +headLightDelta + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n\n        c += Boke( ray , vec3( -headLightDelta2 + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( +headLightDelta2 + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n      \n    \n    \t// refection\n        float reflection = 0.0f;\n        \n        reflection += Boke( ray , vec3( -headLightDelta2 + -1.0f , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        reflection += Boke( ray , vec3( +headLightDelta2 + -1.0f , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        \n        c += reflection * focus;\n    }\n         \n    //vec3 col = vec3( 1.0f , 1.7f , 0.3f) * c;\n    vec3 col = vec3( 0.9f , 0.9f , 1.0f) * c;\n    \n    return col;\n}\n\n\n// Tail Light\nvec3 TailLights( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n\t\n    float headLightDelta = -0.25f;\n    float headLightDelta2 = headLightDelta* 1.2f;\n    \n    \n    time = time * 0.1f;\n    \n    float c = 0.0f;\n    //float t = time * 0.1f;\n    float t = time;\n    \n    float s = 1.0f / 15.0f; // in 1 sec, 100 count.\n    //float side = step( ray.rd.x , 0.0f );\n    //ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t \n        float n = Noise( i );\t\t\t// 0 ~ 1\n\t\tif ( n > 0.5f ) continue;\t\t// 0 ~ 0.5\n        \n        \n        \n        float ti = fract(t + i);\n        float z = 100.0f - ti * 100.0f;\n        float fade = ti * ti * ti * ti * ti;\n        float focus = S( 0.8f , 1.0f , ti );\n        float size = mix( lightDiameter , lightDiameter * 0.5f , focus );\n        \n        float lane = step( 0.25f , n );\t// 0 , 1\n        float laneShift = S(0.99f, 0.96f , ti );\n        float carPos = 1.5f - lane * laneShift;\n            \n        float blink = step( 0.0 , sin( t * 10000.0)) * 7.0f * lane * step( 0.9f , ti );\n        \n        c += Boke( ray , vec3( carPos -headLightDelta , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( carPos +headLightDelta , 0.15f , z ) , size , bokeBlur ) * fade;\n\n        c += Boke( ray , vec3( carPos -headLightDelta2 , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( carPos +headLightDelta2 , 0.15f , z ) , size , bokeBlur ) * fade * (1.0f + blink);\n      \n    \n    \t// refection\n        float reflection = 0.0f;\n        \n        reflection += Boke( ray , vec3( carPos -headLightDelta2 , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        reflection += Boke( ray , vec3( carPos +headLightDelta2 , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        \n        c += reflection * focus;\n    }\n         \n    \n    vec3 col = vec3( 1.0f , 0.1f , 0.01f) * c;\n    \n    return col;\n}\n\n\n\n// Environment Light\nvec3 EnvironmentLight( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n    vec3 c = vec3(0);\n    \n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    float side = step( ray.rd.x , 0.0f );\n    ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    \n    vec3 col = vec3(0.);\n    \n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t\n        float ti = fract(t + i + side * s * 0.5f );\n        \n        vec4 n = Noise14( i + side * 100. );\n        float x = mix( 2.5f , 10.f , n.x );\n        float y = mix( 0.1f , 1.5f , n.y );\n        \n        float occulution = sin( ti * 6.28 * 10.0 ) * 0.5f + 0.5f; // 2 pie\n        float fade = ti * ti * ti;\n        fade = occulution;\n        \n        \n        vec3 targetPos = vec3( x , y , 50.0f - ti * 50.0f );\n        \n        col = n.wzy;\n        c += Boke( ray , targetPos , lightDiameter , bokeBlur ) * fade * col * 0.5f;\n    }\n         \n    //vec3 col = vec3( 1.0f , 0.7f , 0.3f) * c;\n    //return col;\n    return c;\n}\n\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5f * iResolution.xy) / min( iResolution.x, iResolution.y);\n\n    vec2 mouseUv = iMouse.xy / iResolution.xy;\n    //float m = length( mouseUv );\n    \n\n\tvec3 camPos = vec3( 0.5f , 0.2f , 0.0f );\n    vec3 lookAt = vec3( 0.5f , 0.2f , 1.0f );\n    float camZoom = 2.0f;\n    \n    \n    \n    float streetLightDiameter = 0.05f;\n    float headLightDiameter = 0.05f;\n    float bokeBlur = 0.1f;\n    \n    \n    Ray ray = GetRay( uv , camPos , camZoom , lookAt );\n    \n\n\tvec3 col = StreetLight( ray , streetLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= HeadLights(ray , headLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= TailLights(ray , headLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= EnvironmentLight( ray , streetLightDiameter , bokeBlur, iTime + mouseUv.x );\n    \n    \n    // Back ground Gradient color\n    col+= ( ray.rd.y + 0.25f ) * vec3( 0.2f , 0.1f, 0.5f );\n    \n    fragColor = vec4( col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 137, 159, 159, 224], [226, 256, 280, 280, 406], [409, 416, 483, 483, 953], [956, 960, 1010, 1155, 1236], [1239, 1243, 1290, 1290, 1375], [1378, 1386, 1463, 1518, 1843], [1848, 1864, 1944, 1944, 2477], [2480, 2494, 2573, 2573, 4128], [4131, 4145, 4224, 4224, 6068], [6072, 6093, 6178, 6178, 7099], [7102, 7110, 7167, 7167, 8125]], "test": "untested"}
{"id": "wlXfWS", "name": "#845 - Daily Experiments", "author": "sixclones", "description": "One more day.", "tags": ["3d", "raymarching", "experiments", "daily"], "likes": 7, "viewed": 1232, "published": 3, "date": "1597586319", "time_retrieved": "2024-07-30T20:50:30.419583", "image_code": "// =========\n// CONSTANTS\n// =========\n\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define EPS 0.001\n#define STEPS 64.0\n#define DIST 0.01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// ========\n// UTILS FN\n// ========\n\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\n  to be used with cos/sin\n  e.g.: `map01(sin(x), 0.0, 1.0)` */\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n// classical 2d rotation\nvec2 rotate2d(vec2 uv, float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n}\n\n// =====\n// SCENE\n// =====\n\n/* SDF of a torus from Inigo Quilez\n  https://iquilezles.org/articles/distfunctions\n*/\nfloat torusSDF(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n/* scene definition\n  mainly defining a torus and deform radius and thickness of it */\nfloat sceneSDF(vec3 p) {\n  vec3 _p = p; // save value of `p` before rotating it\n  \n  // some rotations\n  p.xy = rotate2d(p.xy, t);\n  float angle = P * S(0.25, 0.75, abs(2.0 * fract(t / P) - 1.0));\n  p.yz = rotate2d(p.yz, angle - QP);\n  \n  // combine cos/sin and `p` to deform the radius\n  float r = map01(sin(t\n    + 2.0 * (_p.x + _p.z)\n    + HP * cos(-t + p.y)\n    ), 1.25, 1.5); // radius\n  \n  // switch between `p.x` and `p.y` to deform thickness\n  float mixer = S(0.125, 0.875, abs(2.0 * fract(t / TP) - 1.0));\n  // combine cos/sin and `p` to deform the thickness\n  float t = map01(cos(-t\n    + 2.5 * mix(_p.x, _p.y, mixer)\n    + P * sin(-t\n      + 2.0 * _p.z\n      + TP * sin(t + 0.25 * (_p.x + _p.y + _p.z))\n    )), 0.55, 0.65); // thickness\n  \n  float torus = torusSDF(p, vec2(r, t));\n  \n  return torus;\n}\n\n// ======\n// RENDER\n// ======\n\n/* compute normales by an estimation of them, offseting the scene computation\n  more details reading here:\n  http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting */\nvec3 computeNormal(vec3 p) {\n  float center = sceneSDF(p);\n  vec3 offset = vec3(0.0, EPS, 0.0);\n\n  return normalize(vec3(\n    center - sceneSDF(p + offset.yxx),\n    center - sceneSDF(p + offset.xyx),\n    center - sceneSDF(p + offset.xxy)\n  ));\n}\n\n// =====\n// MAIN\n// =====\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n\n  vec3 color = vec3(0.07, 0.05, 0.08);\n\n  vec3 rd = normalize((vec3(uv, 1.0)));\n  vec3 ro = vec3(0.0, 0.0, -5.0);\n\n  // raymarching loop\n  float f = 10.0 / STEPS;\n  for (float i = 0.0; i < STEPS; i++) {\n    vec3 pos = ro + f * rd;\n    float scene = sceneSDF(pos);\n    if (scene < DIST) {\n      // use normales as color and switch the channels, instead of classical `.rgb` use `.brg` for a fresher render\n      color = 0.5 * computeNormal(pos).brg + 0.5;\n      break;\n    }\n    f += scene;\n  }\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 460, 534, 534, 606], [608, 748, 797, 797, 853], [855, 880, 913, 913, 968], [998, 1085, 1117, 1117, 1182], [1184, 1271, 1295, 1295, 2083], [2116, 2330, 2358, 2358, 2575], [2604, 2604, 2659, 2659, 3256]], "test": "untested"}
{"id": "wlfBWS", "name": "Abstract Fractal", "author": "propagant", "description": "Abstract Apollonian fractal with raymarching techniques", "tags": ["raymarching", "fractal", "apollonian"], "likes": 4, "viewed": 458, "published": 3, "date": "1597584890", "time_retrieved": "2024-07-30T20:50:31.183540", "image_code": "// Apollonian fractal formula by Matej Vanco, 2020\n\nstruct ray\n{\n\tvec3 o,d;\n\tfloat l;\n};\n\nvec4 fractal(vec3 p, vec2 par, vec3 color)\n{\n\tfloat s = par.x;\n\tfloat g = 45.;\n\tp.xy*=mat2(sin(g), -cos(g), cos(g), sin(g));\n\tfloat c = 1.5;\n\n\tfloat scale = 1.;\n\tvec3 cStorage = color;\n    \n\tfor (int i = 0; i < 13; i++)\n\t{\n\t\tp = -1. + 2.0 * fract(0.5 * p + 0.5);\n\n\t\tfloat r2 = dot(p, p);\n\n\t\tcolor += mix(0.8 - color, vec3(0.09,0.0,0.8) * pow(r2, 0.8), 0.8);\n\n\t\tfloat k = s / r2;\n\t\tp *= k;\n\t\tp.x *= par.y;\n\t\tscale *= k;\n\t}\n\treturn vec4(color * cStorage, 0.25 * abs(p.y) / scale);\n}\n\t\nvec4 geo(vec3 p)\n{\n\treturn fractal(p-vec3(0.22+sin(iTime * 0.2)*0.1,0.9,0.2),vec2(1.24,0.75),vec3(0.3,0.29,0.095));\t\n}\n\t\nvec4 march(ray r)\n{\n\tvec3 c = vec3(0.);\n\tfor(int i = 0; i < 64; i++)\n\t{\n\t\tvec3 p = r.o + r.d * r.l;\n\t\tvec4 g = geo(p);\n\t\tc = g.rgb;\n\t\tr.l += g.w;\n\t\tif(r.l>8.)\n\t\t\tbreak;\n\t}\n\treturn vec4(c, r.l);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy -0.5 * iResolution.xy ) / iResolution.y;\n\n    vec3 c = vec3(0.);\n\t\n\tray r = ray(vec3(0.), vec3(uv,1.), 0.);\n\tvec4 mm = march(r);\n\tvec3 p = r.o + r.d * mm.w;\n\tc = mm.rgb * mm.w;\n\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfBWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 134, 134, 570], [573, 573, 591, 591, 691], [694, 694, 713, 713, 889], [891, 891, 948, 948, 1183]], "test": "untested"}
{"id": "ttXBWS", "name": "Overhill flyer z", "author": "illus0r", "description": "Overhill flyer z", "tags": ["raymarching"], "likes": 8, "viewed": 386, "published": 3, "date": "1597576656", "time_retrieved": "2024-07-30T20:50:32.000357", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 20.\n#define SURF_DIST .001\n\n#define T iTime * 0.2\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 hash( vec3 p ) // replace this by something better. really. do\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\n\n\nvec3 colorInterpolation(vec3 col1, vec3 col2, vec3 col3, vec3 col4, float x) {\n\tvec3 color;\n    float N = 3.;\n    if (x < 1./N) {\n    \tcolor = mix(col1, col2, x * N);\n    }\n    else {\n        if (x < 2./N) {\n            color = mix(col2, col3, (x - 1./N) * N);\n        }\n        else {\n            color = mix(col3, col4, (x - 2./N) * N);\n        }\n    }\n    color = max(vec3(0), color);\n    return color;\n    \n}\n\n\n\nfloat GetDist(vec3 p) {\n    p.x += T * 10.;\n    p.z *= 0.6;\n    p.x *= 1.;\n    p.y *= .5;\n    float plane = dot(p, normalize(vec3(0.,1.,0.)));\n    float n = noise(p);\n    float n2 = noise(p * 2.)  * 0.5;\n    float n3 = noise(p * 8.)  * 0.05;\n    float n4 = noise(p * 16.)  * 0.005;\n    //float n5 = noise(p * 8.) * 0.0375;\n    n += n2 + n3 + n4;// + n5;\n    \n    return (plane + n) * 0.6;\n}\n\n\n\n\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST*(1.0+dO)) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv += 0.05 * noise(vec3(uv * 5., T));\n    \n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 hills;\n    \n    vec3 ro = vec3(0., 2., 0.);\n    //ro.yx *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, ro + vec3(1., -0.2, 0.), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \t//float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \t//col += dif; \n        //col = n;\n        //col = vec3(S(10., 0., d)); // dist\n        \n        vec3 col1 = vec3(39. /256.,35. /256.,48. /256.);\n\t    vec3 col2 = vec3(155./256.,101./256.,118./256.);\n\t\tvec3 col3 = vec3(215./256.,126./256.,118./256.);\n\t\tvec3 col4 = vec3(230./256.,176./256.,77./256.);\n\t    hills = colorInterpolation(col1, col2, col3, col4, clamp(0., 1., pow(d, 0.5) / 3. - 0.5));\n    }\n    \n    vec3 col1 = vec3(230./256.,176./256.,77./256.);\n    vec3 col2 = vec3(230./256.,176./256.,77./256.) * 1.0;\n    vec3 col3 = vec3(234./256.,235./256.,198./256.);\n    vec3 col4 = vec3(75./256.,177./256.,210./256.);\n    vec2 uvSky = uv;\n    uvSky += 0.1 * noise(vec3(uvSky, T));\n    vec3 sky = colorInterpolation(col1, col2, col3, col4, uvSky.y * 2.5);\n    vec2 uvCl = uv;\n    uvCl *=  vec2(3., 30.);\n    uvCl.x += iTime * 2.;\n    float clouds = 1. * (0.5 + 0.5 * noise(vec3(uvCl, T)));\n    //uvCl *= vec2(2.66, 2.7);\n    //clouds *= (1.5 + 3.5 * noise(vec3(uvCl, iTime * 2.)));\n    //clouds = min(1., clouds);\n    clouds = pow(clouds, 2.);\n    clouds *= smoothstep(0.1, 0.25, uv.y) - smoothstep(0.25, 0.5, uv.y);\n    sky = mix(sky, vec3(1), clouds);\n    vec3 col = mix(hills, sky, smoothstep(10., 20., d));\n    \n    //col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXBWS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[361, 361, 380, 380, 442], [444, 444, 466, 466, 560], [562, 562, 591, 591, 672], [674, 674, 743, 743, 912], [914, 914, 940, 952, 2118], [2122, 2122, 2200, 2200, 2534], [2538, 2538, 2561, 2561, 2928], [2938, 2938, 2972, 2972, 3192], [3194, 3194, 3218, 3218, 3408], [3410, 3410, 3460, 3460, 3651], [3655, 3655, 3712, 3712, 5543]], "test": "untested"}
{"id": "3tXBWS", "name": "The City At night", "author": "gilesruscoe", "description": "Late night VJ session", "tags": ["music", "lines", "audio", "glow", "glow", "dots"], "likes": 20, "viewed": 899, "published": 3, "date": "1597576471", "time_retrieved": "2024-07-30T20:50:32.765311", "image_code": "#define AA 6.0 / iResolution.y\n\nfloat hash21(vec2 v) {\n    return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b, float width)\n{\n    vec2 pa = uv - a;\n    vec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\t\n\treturn 1.0 - smoothstep(-AA, AA, length(pa - ba * h) - width);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.y / iResolution.x;\n    uv = uv * 2.0 - 1.0;\n    uv *= 1.0 + sin(iTime * 0.5) * 0.35;\n    \n    uv.y *= ar;\n\n    \n    vec3 comp = vec3(0.0);\n    float lines = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n       \tfloat ifloat = float(i);\n        vec2 seed = vec2(ifloat * 1.0, ifloat * 3.0);\n        vec2 pos = (vec2((hash21(seed) * 2.0 - 1.0) * 2.0,\n                         (hash21(seed*2.0) * 2.0 - 1.0)) * 0.5);\n        \n        float soundsample = texture( iChannel0, vec2(floor(abs(pos.x*0.5) * 32.0) / 32.0,0.0) ).x * 1.10;\n        if(soundsample < 0.55)\n            continue;\n\n        float burst = pow(soundsample, 5.0) * 20.0;\n        \n        pos.x += sin(iTime + ifloat) * 0.25;\n        pos.y += cos(iTime * 2.0 + ifloat) * 0.15;\n        float value = length(uv + pos) * 4.25;\n        \n        // circles\n        vec3 col = normalize(vec3(sin(pos.x*5.0) + 0.25, 0.1, sin(pos.y*10.0))) * 3.0;\n    \tcomp += clamp(col * smoothstep(value - AA, value + AA, 0.01 + burst * 0.02) * 0.155, vec3(0.0), vec3(1.0));\n        comp += clamp(col * smoothstep(value - 0.5, value + 0.5, 0.01 + burst * 0.075) * 0.01, vec3(0.0), vec3(1.0)) * 2.0;\n        \n        // Lines\n        float L = 0.0;\n        for(int j = 0; j < int(pow(soundsample, 3.0) * 15.8); j++)\n        {\n            float jfloat = float(j);\n            vec2 Lseed = vec2(jfloat, jfloat);\n            vec2 Lpos = (vec2((hash21(Lseed) * 2.0 - 1.0) * 2.0,\n                         (hash21(Lseed*2.0) * 2.0 - 1.0)) * 0.5);\n            Lpos.x += sin(iTime + jfloat) * 0.25;\n        \tLpos.y += cos(iTime * 2.0 + jfloat) * 0.15;\n            L = max(L, line(uv, -pos, -Lpos, 0.001));\n        }\n        lines += L;\n\n    }\n    comp *= 0.25;\n    comp += lines * 0.01;\n    vec3 bg = vec3(0.35*(uv.y * 0.5 + 0.5), 0.0, 0.15);\n    fragColor = vec4(bg + vec3(comp)*12.0, 1.0);\n}", "image_inputs": [{"id": 23837, "src": "https://soundcloud.com/clozee/evasion", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXBWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 54, 54, 126], [128, 128, 178, 178, 341], [344, 344, 401, 401, 2291]], "test": "untested"}
{"id": "3lXBDB", "name": "#847 - Daily Experiments", "author": "sixclones", "description": "One more day.", "tags": ["3d", "raymarching", "experiment", "daily"], "likes": 4, "viewed": 203, "published": 3, "date": "1597570058", "time_retrieved": "2024-07-30T20:50:33.654933", "image_code": "// =========\n// CONSTANTS\n// =========\n\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define EPS 0.001\n#define STEPS 64.0\n#define DIST 0.05\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// ========\n// UTILS FN\n// ========\n\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\n  to be used with cos/sin\n  e.g.: `map01(sin(x), 0.0, 1.0)` */\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n// classical 2d rotation\nvec2 rotate2d(vec2 uv, float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n}\n\n// =====\n// SCENE\n// =====\n\n/* scene definition\n  mainly defining a plane deformed to be a wave */\nfloat sceneSDF(vec3 p) {\n  // distance from the point `p` to the center of the XZ plane\n  float d = length(p.xz);\n    \n  // amplitude of the wave (height), smoothly decreased relatively to the center of the plane\n  float amp = S(25.0, 0.0, d);\n  \n  // offset of the frequency, based on the `z` coord of the plane\n  float offset = sin(-t + 0.1 * (p.z));\n  // frequency of the wave\n  float freq = map(\n    S(0.125, 0.875, abs(2.0 * fract((t + offset) / TP) - 1.0)),\n    0.0, 1.0, 0.4, 1.0\n  );\n   \n  /* main equation of the render\n\tcombination of some cos/sin based of `d`, `p.x` and `p.z`\n  */\n  float wave = amp * cos(-t\n    + freq * d\n    + sin(2.0 * t)\n    - 0.5 * cos(-2.0 * t + 0.25 * d)\n    + 0.5 * cos(t + 0.1 * TP * p.x)\n    + 0.25 * sin(-t + 0.125 * TP * p.z)\n  );\n  // sdf of a horizontal plane deformed by a wave\n  float plane = p.y + wave;\n  \n  return plane;\n}\n\n// ======\n// RENDER\n// ======\n\n/* compute normales by an estimation of them, offseting the scene computation\n  more details reading here:\n  http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting */\nvec3 computeNormal(vec3 p) {\n  float center = sceneSDF(p);\n  vec3 offset = vec3(0.0, EPS, 0.0);\n\n  return normalize(vec3(\n    center - sceneSDF(p + offset.yxx),\n    center - sceneSDF(p + offset.xyx),\n    center - sceneSDF(p + offset.xxy)\n  ));\n}\n\n/* compute surface of the object, combining normales, light, ambient etc. */\nvec3 computeSurface(vec3 pos, float f) {\n  vec3 normal = computeNormal(pos);\n\n  vec3 lightPos = vec3(2.5, -25.0, 25.0 * sin(t + 0.05 * (pos.x + pos.z)));\n  float light = max(0.0, dot(normal, lightPos));\n\n  vec3 ambient = vec3(0.2078, 0.2, 0.7725);\n\n  float fog = 5.0 / pow(f, 2.0);\n\n  return vec3(fog * light) + ambient;\n}\n\n// =====\n// MAIN\n// =====\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 color = vec3(0.0);\n\n  vec3 rd = normalize((vec3(uv, 1.0)));\n  vec3 ro = vec3(0.0, 0.0, -25.0);\n\n  // rotate camera\n  float angle = map01(sin(t + P * uv.y), 0.75, 1.25) * -QP;\n  rd.yz = rotate2d(rd.yz, angle);\n  ro.yz = rotate2d(ro.yz, angle);\n\n  // raymarching loop\n  float f = 10.0 / STEPS;\n  for (float i = 0.0; i < STEPS; i++) {\n    vec3 pos = ro + f * rd;\n    float scene = sceneSDF(pos);\n    if (scene < DIST) {\n      color = computeSurface(pos, f);\n      break;\n    }\n    f += scene;\n  }\n\n  fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXBDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 460, 534, 534, 606], [608, 748, 797, 797, 853], [855, 880, 913, 913, 968], [998, 1069, 1093, 1156, 1940], [1973, 2187, 2215, 2215, 2432], [2434, 2511, 2551, 2551, 2833], [2862, 2862, 2917, 2917, 3543]], "test": "untested"}
{"id": "WlffWB", "name": "Balls of various materials", "author": "kaneta", "description": "Lighting test\nMouse: Control camera", "tags": ["3d", "pbr"], "likes": 21, "viewed": 731, "published": 3, "date": "1597566984", "time_retrieved": "2024-07-30T20:50:34.420886", "image_code": "#define MAT_FLOOR 0.0\n#define MAT_SPHERE 1.0\n\nconst float pi = acos(-1.);\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 plane = vec2(p.y + 1.0, MAT_FLOOR);\n    p -=  vec3(0.0, -0.5, 0.0);\n    vec3 l = vec3(5.0, 0.0, 5.0);\n    vec3 q = p-clamp(round(p),-l,l);\n    vec2 d = vec2(length(q) - 0.49, MAT_SPHERE);\n    return opU(d, plane);\n}\n\nvec3 normal( vec3 pos, float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*(map( pos + e.xyy ).x) +\n\t\t\t\t\t  e.yyx*(map( pos + e.yyx ).x) +\n\t\t\t\t\t  e.yxy*(map( pos + e.yxy ).x) +\n\t\t\t\t\t  e.xxx*(map( pos + e.xxx ).x) );\n}\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (pi * denom * denom);\n}\n\nfloat gaSchlickG1(float cosTheta, float k)\n{\n\treturn cosTheta / (cosTheta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick(vec3 F0, float cosTheta)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 fresnelSchlickWithRoughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 skyColor(vec3 rd, float roughness)\n{\n    vec3 baseColor = mix(vec3(0.3,0.5,0.8)*0.8, vec3(0.3,0.5,0.8) * 0.5, rd.y);\n    baseColor = mix( baseColor, vec3(0.2,0.5,0.85)*0.5, 1.0 - pow(1.0-max(-rd.y,0.0), 1.5));\n    vec3 skyColor = baseColor;\n    skyColor = mix( skyColor, vec3(0.9,1.1,1.2) * 1.5, pow( 1.0-max(rd.y,0.0), 8.0 ) );\n    skyColor = mix( skyColor, vec3(0.2,0.5,0.85)*0.2, 1.0 - pow(1.0-max(-rd.y,0.0), 6.0));\n    \n    return mix(skyColor, baseColor, pow(roughness, 0.1)) * 10.0;\n}\n\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.01;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 128; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\nvec3 ambientLighting(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float aoRange)\n{\n    vec3 diffuseIrradiance = skyColor(N, 1.0);\n    vec3 diffuseAmbient = diffuseIrradiance * albedo * (1.0 - metalness);\n\n    vec3 R = reflect(-V, N);\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlickWithRoughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 specularIrradiance = skyColor(R, roughness);\n    vec3 specularAmbient = specularIrradiance * F;\n\n    float ambientOcclusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tambientOcclusion = min(exp2( -.8 * pow(ambientOcclusion, 2.0) ), 1.0) * min(1.0, 1.0+0.5*N.y);\n    diffuseAmbient *= ambientOcclusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), ambientOcclusion, roughness);\n\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 directLighting(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 lightColor)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n    float HdotL = max(0.0, dot(H, L));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick(F0, HdotL);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n    vec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\tvec3 diffuseBRDF = kd * albedo / pi;\n\t\n\tfloat shadow = shadow(pos + N * 0.01, L);\n    vec3 irradiance = lightColor * NdotL * shadow;\n\n\treturn (diffuseBRDF + specularBRDF) * irradiance;\n}\n\n\nvec3 sunDir = normalize(vec3(.3, .45, .5));\n\n#define repid(p, r) (floor((p + r*.5) / r))\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.0);\n    vec3 sky = skyColor(ray, 0.0);\n    vec3 albedo = vec3(1.0, 0.5, 0.1), emissive = vec3(0.0);\n    \n    vec2 id = repid(p.xz, vec2(1.0, 1.0)) / 10.0 + 0.5;\n    float metalness = 1.0 - max(id.y, 0.0);\n    float roughness = max(1.0 - id.x, 0.05);\n    albedo *= mix(0.4, 1.0, metalness);\n    \n    if (depth > 200.0) {\n        return sky;\n    } else if (mat.y == MAT_FLOOR) {\n        float checker = mod(floor(p.x) + floor(p.z), 2.0);\n        albedo = vec3(0.4) * checker + 0.05;\n        roughness = (0.2 + (1.0 - checker) * 0.45);\n        metalness = 0.0;\n    }\n    vec3 n = normal(p, 0.005);\n    \n    col += directLighting(p, albedo, metalness, roughness, n, -ray, normalize(sunDir), vec3(1.0, 0.98, 0.95) * 100.);\n    col += ambientLighting(p, albedo, metalness, roughness, n, -ray, depth / 30.0);\n    col += emissive;\n    \n    float fo = exp(-0.006*depth);\n    col = mix( sky, col, fo );\n\n    return col;\n}\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.1;\n    vec3 pos;\n    vec2 mat;\n    for (int i = 0; i < 128; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x < 0.001) {\n        \tbreak;\n        }\n        t += abs(mat.x);\n    }\n    return materialize(pos, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    float time2 = iTime * 3.0;\n    vec3 ro = vec3(cos(time2*0.1) * 15.0, 15.75 * iMouse.y / iResolution.y, sin(time2*0.1) * 15.0);\n    vec3 ta = vec3(0.0, -1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.0 + 8.5 * iMouse.x / iResolution.x));\n    return trace(ro, ray);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0.0);\n\n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 3; y++) {\n        for(int x = 0; x < 3; x++) {\n            vec2 off = vec2(float(x),float(y))/3.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \t//col += reinhard(render(xy), .12, 100.0)/9.;\n            col += acesFilm(render(xy) * .065)/9.;\n        }\n    }\n    \n    //col = render(p) * 0.1;\n    \n    //col = reinhard(col, .3, 100.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    vec2 p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 30.0;\n    vig = pow(vig, 0.1);\n    \n    fragColor = vec4(col * vig, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlffWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 103, 103, 136], [138, 138, 156, 156, 381], [383, 383, 419, 419, 629], [631, 631, 675, 675, 846], [848, 848, 892, 892, 941], [943, 943, 1006, 1006, 1117], [1119, 1119, 1165, 1165, 1222], [1224, 1224, 1300, 1300, 1384], [1386, 1386, 1427, 1427, 1882], [1884, 1884, 1932, 1932, 2019], [2021, 2021, 2057, 2057, 2390], [2392, 2392, 2502, 2502, 3233], [3235, 3235, 3354, 3354, 4019], [4112, 4112, 4171, 4171, 5105], [5107, 5107, 5137, 5137, 5401], [5403, 5403, 5445, 5445, 5623], [5625, 5625, 5652, 5652, 5711], [5713, 5713, 5742, 5742, 5946], [5948, 5948, 6002, 6002, 6144], [6146, 6146, 6167, 6167, 6473], [6475, 6475, 6532, 6622, 7310]], "test": "untested"}
{"id": "WlXfWS", "name": "Webby blobs", "author": "jarble", "description": "An edit of my \"tunnel of bones\" shader.", "tags": ["3d", "raymarching", "fractal", "recursion"], "likes": 3, "viewed": 274, "published": 3, "date": "1597534013", "time_retrieved": "2024-07-30T20:50:35.181850", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(inout vec3 p,float i){\n    \n    vec3 p1 = p/size-sin((p+p.yzx/i)/size)*i;\n    p = (sin((p1.yzx/i)))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    float result = 0.0;\n    for(float i = 1.0; i < 27.0; i *= 3.0){\n        p = p*i;\n    \tresult = max(result, planet_surface(p,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/30.0+vec3(.7);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*EPSILON)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    viewDir.yz *= rot(cos(iTime/5.0)/3.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/3.0);\n    \n    float speed = 1.0;\n    float t1 = iTime*speed;\n\tvec3 eye = vec3(-t1*9.0-15.0,t1*9.0-11.0,-t1*9.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 584, 627, 627, 741], [743, 743, 778, 778, 1029], [1031, 1031, 1054, 1054, 1081], [1083, 1083, 1111, 1111, 1242], [1245, 1666, 1757, 1757, 2083], [2098, 2352, 2417, 2417, 2549], [2551, 2640, 2669, 2669, 2979], [2981, 3473, 3613, 3613, 4223], [4225, 4595, 4680, 4680, 5095], [5097, 5424, 5473, 5508, 5639], [5641, 5641, 5698, 5698, 6922]], "test": "untested"}
{"id": "Wllfzl", "name": "Wall flyer z", "author": "illus0r", "description": "Wall flier", "tags": ["raymarching"], "likes": 4, "viewed": 299, "published": 3, "date": "1597525586", "time_retrieved": "2024-07-30T20:50:35.940821", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\n\n\nfloat GetDist(vec3 p) {\n    float move = -iTime;\n    \n    vec3 pl = p;\n    pl.y += move;\n    pl.xz *= Rot(pl.y);\n    float plane1 = dot(pl, normalize(vec3(0, 0,  1))) + 1.5;\n    float plane2 = dot(pl, normalize(vec3(0, 0,  -1))) + 1.5;\n    float planes = min(plane1, plane2);\n    planes *= 0.1;\n\n\tvec3 gp = p;\n    gp.x += iTime / 2.;\n    gp.y += move * 5.;\n    float gscale = 4.;//1. + 3. * (0.5 + 0.5 * sin(p.y / 1.));\n    float gyroid = dot(sin(gp * gscale), cos(gp.zxy * gscale)) - 1.4 - 0.2 * (S(-5., 0., p.y));\n    gyroid *= 0.1;\n\n    gp = p;\n    gp.x += iTime / 2.;\n    gp.y += move * 5.;\n    gscale = 7.;\n    float gyroid2 = dot(sin(gp * gscale), cos(gp.zxy * gscale)) - 0.5 - 1.2 * (S(-5., 0., p.y));\n    gyroid2 *= 0.1;\n\n    return max(-planes, gyroid+gyroid2);\n}\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0, 0);\n    \n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, ro + vec3(0.0001, 1, 0), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n        //col += n;\n    \t//col += vec3(S(80., 100., d));\n        float dif = dot(n, normalize(ro + vec3(0,0,0.5)))*.5+.5;\n    \tcol += dif;  \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    col = vec3(S(0., -10., d));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wllfzl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[340, 340, 359, 359, 421], [423, 423, 445, 445, 539], [541, 541, 570, 570, 651], [656, 656, 679, 679, 1428], [1433, 1433, 1467, 1467, 1678], [1680, 1680, 1704, 1704, 1894], [1896, 1896, 1946, 1946, 2137], [2141, 2141, 2198, 2198, 2913]], "test": "untested"}
{"id": "ttlfzs", "name": "Schwarz P surface", "author": "illus0r", "description": "Schwarz P surface", "tags": ["raymarching"], "likes": 3, "viewed": 285, "published": 3, "date": "1597525566", "time_retrieved": "2024-07-30T20:50:36.702784", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p) {\n    float box = sdBox(p, vec3(1));\n    \n    float scale = 5.5;\n    float surf = cos(p.x * scale) + cos(p.y * scale) + cos(p.z * scale) + 2. * sin(iTime);\n    surf = abs(surf) - 0.01;\n    surf *= 0.1;\n   \t\n    return max(box, surf);\n}\n\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol += dif;  \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlfzs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[339, 339, 358, 358, 420], [422, 422, 444, 444, 538], [540, 540, 569, 569, 650], [652, 652, 675, 675, 909], [916, 916, 950, 950, 1161], [1163, 1163, 1187, 1187, 1377], [1379, 1379, 1429, 1429, 1620], [1624, 1624, 1681, 1681, 2253]], "test": "untested"}
{"id": "tlsfzl", "name": "2D Liquid Paint", "author": "smkgames", "description": "2D Liquid", "tags": ["2d", "paint", "draw", "brush"], "likes": 4, "viewed": 950, "published": 3, "date": "1597513054", "time_retrieved": "2024-07-30T20:50:37.576448", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 test = texture(iChannel1, fragCoord.xy / iResolution.xy);\n    fragColor = vec4(distance(iMouse.xy, fragCoord) < 10.0 );\n    fragColor += texture(iChannel0, mix(fragCoord.xy / iResolution.xy,test.rg,0.01));\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 123]], "test": "untested"}
{"id": "tllfzl", "name": "Motilla Tea", "author": "xenn", "description": "yay", "tags": ["particles", "ca"], "likes": 12, "viewed": 512, "published": 3, "date": "1597508874", "time_retrieved": "2024-07-30T20:50:38.475045", "image_code": "// Fork of \"battle of end times\" by xenn. https://shadertoy.com/view/wlsBzl\n// 2020-08-15 16:25:19\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.7, 0.7);\n    vec3 col1 = vec3(0.5, 0.92, 1.);\n    // Output to screen\n    col.xyz += 0.1*a;\n    col.xyz += 0.5 - 0.5*cos(1.521*01.0*vec3(0.21+sin(iTime*0.521),0.31+cos(iTime*0.15),0.1+sin(iTime*(0.219)))*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5)));\n    col.w=01.50;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 02.5\n\n#define fluid_rho 0.02\n\n\n//mold stuff \n#define sense_ang 0.83464746\n#define sense_dis 03.30\n#define sense_force 0.052175\n#define trailing 01.0*sin(time*02.1141)\n#define acceleration 0.135932017\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 0.020542347503666*rho.x + 0.*rho.y; //gas\n    return 0.002*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 01.30\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= sin(-.0020*P.M.x*vec2(0,1));\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.01*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.0)?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllfzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 128, 128, 306], [308, 308, 344, 344, 394], [396, 396, 412, 412, 440], [442, 442, 487, 487, 1658]], "test": "untested"}
{"id": "3tlBRl", "name": "obelisk", "author": "lennyjpg", "description": "sdfgsdfgsdfg", "tags": ["lines", "angle", "white", "black", "corner"], "likes": 4, "viewed": 318, "published": 3, "date": "1597500672", "time_retrieved": "2024-07-30T20:50:39.239003", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 uv = U/iResolution.x;\n    uv = abs(uv-0.3);\n    vec2 u = U/17.3 + uv * .1 - iTime * 1.12345;\n    float d = sin( u[int(uv.x > uv.y)]*7.2 )\n              +.3 + uv.x*0.2,\n          a = 0.5;\n    float m = smoothstep(-a, a , d - 1.);\n    float b = length(uv);\n    O = vec4(m - b);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlBRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 325]], "test": "untested"}
{"id": "3lsfW7", "name": "Plyworld", "author": "ruojake", "description": "Plywood terrain", "tags": ["3d", "raymarching", "terrain"], "likes": 14, "viewed": 507, "published": 3, "date": "1597487906", "time_retrieved": "2024-07-30T20:50:40.004955", "image_code": "// Plyworld by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nvec2 hash21(float v)\n{\n    vec2 p = vec2(v * 12.3 + 2., v + 11.31);\n\treturn fract(sin(p + dot(p, vec2(2.5341, 1.9413))) * 41321.123);\n}\n\nfloat hash12(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(3.5341, 2.9413))) * 4321.123);\n}\n\nfloat hash13(vec3 p)\n{\n\treturn fract(sin(dot(p, vec3(3.5341, 2.9413, 3.1533))) * 4321.123);\n}\n\nvec2 hash22(vec2 p)\n{\n\treturn fract(sin(p + dot(p, vec2(2.5341, 1.9413))) * 41321.123);\n}\n\n#define sat(x) clamp((x), 0., 1.)\n#define LAYERS 60.\n\nfloat noise(vec2 p)\n{\n\tvec2 i = floor(p);\n    vec2 f = smoothstep(0., 1., p - i);\n    const vec2 o = vec2(1, 0);\n    \n    return mix(mix(hash12(i), hash12(i + o), f.x),\n               mix(hash12(i + o.yx), hash12(i + 1.), f.x),\n               f.y);\n}\n\nfloat noise(vec3 p)\n{\n\tvec3 i = floor(p);\n    vec3 f = smoothstep(0., 1., p - i);\n    const vec2 o = vec2(1, 0);\n    \n    return mix(\n        mix(\n            mix(hash13(i), hash13(i + o.xyy), f.x),\n            mix(hash13(i + o.yxy), hash13(i + o.xxy), f.x),\n            f.y),\n        mix(\n            mix(hash13(i + o.yyx), hash13(i + o.xyx), f.x),\n            mix(hash13(i + o.yxx), hash13(i + 1.), f.x),\n            f.y),\n        f.z);\n}\n\nfloat fbm(vec2 p)\n{\n    const float per = .45;\n    const float oct = 5.;\n    \n    float res = 0.;\n    float amp = .4;\n    \n\tfor(float i = 1.; i <= oct; i += 1.)\n    {\n    \tres += amp * noise(p);\n        p += p;\n        amp *= per;\n    }\n    return smoothstep(1., 0., res);\n}\n\nvec2 noise21(float v)\n{\n\tfloat i = floor(v);\n    float f = smoothstep(0., 1., v - i);\n    return mix(hash21(i), hash21(i + 1.), f);\n}\n\nfloat stairstep(float v, float s, float b)\n{\n\tfloat i = floor(v * s);\n    float f = v * s - i;\n    f = smoothstep(b - 1., b, f * b);\n    return mix(i, i + 1., f) / s;\n}\n\nfloat pattern(vec3 p)\n{\n    float i = floor(p.y * LAYERS + .5);\n    float f = fract(p.y * LAYERS);\n\tvec2 o = hash21(i * 31. + .4) * 2. - 1.;\n    vec2 xz = p.xz;\n    p.xz += noise(p.xz * 5. + i * 3.) * .125 - .0625;\n    p.xz += mix(sin(dot(xz * 1000., o)), sin(dot(xz * 1301., o)), hash12(xz * 900.)) * .002;\n    \n    return mix( \n        fract(sin(dot(p.xz * 20. * (1. + sin(i * 1312.41) * .2), o))),\n        (cos(f * 25.1327) * 2. + 1.) * sat(1. - 100. * fwidth(p.x)),\n        smoothstep(.24, .25, min(f, 1. - f)));\n}\n\nfloat scene(vec3 p)\n{\n\tfloat res = fbm(p.xz);\n    res *= 2.5 - res * res;\n    res = mix(stairstep(res, LAYERS, 30.), res, sat(length(fwidth(p)) * 75.));\n    return .45 * (p.y + res - 2.);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxDist, float k)\n{\n    float res = 1.;\n    float d = 0.;\n    float t = .01;\n    for(int i = 0; i < 30; ++i)\n    {\n        d = scene(ro + rd * t) * 2.;\n        res = min(res, k * d / t);\n        t += d;\n    \tif(abs(d) < .0001 || t >= maxDist)\n            break;\n        if (res < .001)\n        {\n        \tres = 0.;\n            break;\n        }\n    }\n    return res;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat d = scene(p);\n    vec2 e = vec2(.00001, .0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nvec3 ray(vec3 ro, vec3 lookAt, vec2 uv, float zoom)\n{\n\tvec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n\n    return normalize(uv.x * r + uv.y * u + f * zoom);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec2 m = clamp((iMouse.xy / iResolution.xy) * 2. - 1., vec2(-1.), vec2(1.));\n    if (m == vec2(-1.,-1.)) m = vec2(0.);\n    \n    vec3 v = vec3(0, 0, iTime * .1);\n    vec3 md = vec3(m.x * 2., m.y, -max(abs(m.x), abs(m.y) * .5));\n    \n    vec3 tgt = vec3(10., 1., 2.) + v + md;\n    vec3 ro = vec3(10.,1.5, 0.) + v;\n    \n    vec3 rd = ray(ro, tgt, uv, .8);\n    float t = 0.;\n    vec3 p;\n\n    for(float i = 0.; i < 60.; i++)\n    {\n    \tp = ro + rd * t;\n        float d = scene(p);\n        if (d < 0.) d /= (i * .75 + 1.);\n        \n        if (abs(d) < .00005) break;\n        t += d;\n    }\n\n    vec3 lDir = normalize(vec3(4,4,3));\n    vec3 n = normal(p);\n    float l = sat(dot(n,lDir));\n    l *= shadow(p + n * .01, lDir, 5., 1.5);\n    \n    vec3 col = mix(vec3(.95,.92,.76), vec3(.81,.72,.45), pattern(p));\n\t\n    col *= 1. + sin(floor(p.y * LAYERS) * 5123.23) * vec3(-.06,0.,.06);\n    col *= n.y * .6 + .4;\n    \n    col *= mix(vec3(.2,.25, .35), vec3(1.2,1.17,1.), l);\n    col = mix(mix(vec3(.96,.97,1.) * sat(1.3 - rd.y), vec3(.4,.4,.42), rd.y), col, sat(1.2 - t * .1));\n    \n    col *= 1. - smoothstep(.45, .7, length((uv * iResolution.y / iResolution.xy))) * .5;\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfW7.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[109, 109, 131, 131, 244], [246, 246, 268, 268, 331], [333, 333, 355, 355, 426], [428, 428, 449, 449, 517], [573, 573, 594, 594, 823], [825, 825, 846, 846, 1265], [1267, 1267, 1286, 1286, 1541], [1543, 1543, 1566, 1566, 1676], [1678, 1678, 1722, 1722, 1846], [1848, 1848, 1871, 1871, 2366], [2368, 2368, 2389, 2389, 2557], [2559, 2559, 2615, 2615, 2963], [2965, 2965, 2986, 2986, 3151], [3153, 3153, 3206, 3206, 3364], [3366, 3366, 3423, 3423, 4710]], "test": "untested"}
{"id": "WlsBzs", "name": "noise by chenxiyu", "author": "chenxiyu", "description": "noise from sin", "tags": ["2d"], "likes": 1, "viewed": 237, "published": 3, "date": "1597487376", "time_retrieved": "2024-07-30T20:50:40.767915", "image_code": "vec3 frequency(vec2 uv, float cycle, float tangle)\n{\n    float l = uv.x * cos(tangle) + uv.y * sin(tangle);\n    float c = 0.5 + 0.5 * cos(cycle * l);\n    return vec3(c,c,c);\n}\n\nfloat random(float val)\n{\n\treturn fract(sin(val * 12.9898) * 43756.5453123 );   \n}\n\n#define loops 100\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0,0,0);\n    \n    \n\tfloat wightSum = 0.0;\n    for(float i = 0.0; i < float(loops); i++)\n    {\n        float cycle = random(i) * 400.0;\n        float wight = (1.0/cycle) * 400.0;\n        wightSum += wight;\n        float tangle =  random(i * float(loops) + float(loops)) * 300.0;\n        col += frequency(uv, cycle, tangle);\n    }\n    col /= float(loops);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 175], [177, 177, 202, 202, 259], [280, 280, 337, 387, 891]], "test": "untested"}
{"id": "3tlfRs", "name": "Fast Noise - GPU Squares RNG", "author": "km", "description": "A GPU version of the Squares Random Noise Generator. The next step is to generate some terrain with it and try some raymarching.", "tags": ["procedural", "noise", "fast", "rng", "squaresrng", "statelessrng"], "likes": 6, "viewed": 881, "published": 3, "date": "1597480289", "time_retrieved": "2024-07-30T20:50:41.585728", "image_code": "// A webgl2 implementation of the Squares RNG\n// algorithm https://squaresrng.wixsite.com/rand\n//\n// Copyright (c) 2020 Bernard Widynski: original implementation in C\n// Copyright (c) 2020 Kyle Marshall: implementation in OpenGL ES 3   \n//                                                                          \n//  This code can be used under the terms of the GNU General Public License \n//  as published by the Free Software Foundation, either version 3 of the   \n//  License, or any later version. See the GPL license at URL               \n//  http://www.gnu.org/licenses\n//\n// Original source code is available here:\n// https://squaresrng.wixsite.com/rand\n//\n// I'm looking to use it as my go to noise function\n// It is simple and only uses mult/adds, bitshifts,\n// and bitwise ORs. With no state, it was trivially\n// parallelizable to the GPU.\n\nprecision highp float;\nprecision highp int;\n\n// provides 16 psuedo-random bits\n// conviently packaged in a float\n// in the [0,1] range.\nfloat squares16(uint ctr) {\n    const uint key = uint(0x7a1a912f);\n    const float two16 = 65536.0;\n\n    uint x, y, z;\n\n    // initialize\n    // ==================================\n    // Weyl sequence vars, y and z\n    y = ctr * key;\n    z = (ctr + uint(1)) * key;\n\n    // init the mixing var, x\n    x = y;\n\n    // begin the mixing rounds\n    // ===================================\n\n    // round 1\n    x = x*x + y; x = (x>>16) | (x<<16);\n\n    // round 2\n    x = x*x + z; x = (x>>16) | (x<<16);\n\n    // round 3\n    x = (x*x + y) >> 16;\n\n    return float(x)/two16;\n}\n\nfloat pixel_id(vec2 fragCoord) {\n    return dot(fragCoord.xy,\n               vec2(1, iResolution.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float id = pixel_id(fragCoord);\n    int cnt_pixels = int(iResolution.x * iResolution.y);\n\n    vec3 col = vec3(squares16(uint(id)+uint(iFrame*cnt_pixels)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlfRs.jpg", "access": "api", "license": "gpl-2.0-plus", "functions": [[897, 988, 1015, 1015, 1552], [1554, 1554, 1586, 1586, 1657], [1659, 1659, 1716, 1716, 1934]], "test": "untested"}
{"id": "3lsBRs", "name": "motility", "author": "xenn", "description": "yay", "tags": ["particles", "ca"], "likes": 9, "viewed": 379, "published": 3, "date": "1597479458", "time_retrieved": "2024-07-30T20:50:42.354672", "image_code": "\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.7, 0.7);\n    vec3 col1 = vec3(0., 0.92, 1.);\n    // Output to screen\n    col.xyz += 0.1*a;\n    col.xyz += 0.5 - 0.5*cos(0.51*010.0*vec3(0.36131+sin(iTime*0.51),0.22+cos(iTime*0.61),0.1606+cos(iTime*(0.51)))*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5)));\n    col.w=1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 002.5\n\n#define fluid_rho 0.02\n\n\n//mold stuff \n#define sense_ang 0.26\n#define sense_dis 01.3\n#define sense_force 00.3\n#define trailing 0100000.0*sin(time*01.141)\n#define acceleration 0.1\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 0.375777*rho.x + 0.*rho.y; //gas\n    return 0.002*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 01.30\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= sin(-0.0010*P.M.x*vec2(0,1));\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.01*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 129, 129, 307], [309, 309, 345, 345, 395], [397, 397, 413, 413, 441], [443, 443, 488, 488, 1660]], "test": "untested"}
{"id": "WtsBzl", "name": "Not a fireplace", "author": "xenn", "description": "but mesmerising all the same", "tags": ["particles", "ca"], "likes": 7, "viewed": 420, "published": 3, "date": "1597470931", "time_retrieved": "2024-07-30T20:50:43.243296", "image_code": "// Fork of \"parasight\" by xenn. https://shadertoy.com/view/wllfRf\n// 2020-08-15 05:39:03\n\n// Fork of \"dissonant divergence\" by xenn. https://shadertoy.com/view/wtXfR4\n// 2020-08-14 00:58:49\n\n// Fork of \"My virtual slime molds\" by michael0884. https://shadertoy.com/view/WtBcDG\n// 2020-07-24 21:29:48\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(2.0-3.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(0.3, 0.0, 0.7);\n    vec3 col1 = vec3(0., 0.2, 1.);\n    // Output to screen\n    col.xyz += 0.1*a;\n    col.xyz += 0.5 - 0.5*cos(0.5*(00010.0)*vec3(0.452*sin(iTime*0.11),0.2532*cos(iTime*0.2),0.42*cos(iTime*(00.3)))*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5)));\n    col.w=1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 002.0\n#define fluid_rho 0.2\n\n//mold stuff \n#define sense_ang 0.67862\n#define trailing 100.0*cos(time*01.21)\n#define sense_dis 03.20\n#define sense_force 0.17500\n#define acceleration 0.01/(time*0.2)\n\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 0.50*rho.x + 0.*rho.y; //gas\n    return(0.200)*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amnt\n#define dif 0.750\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= sin(-0.000300*P.M.x*vec2(0,1));\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.01*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 2.0 * sin(time*0.61))?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 498, 525, 525, 703], [705, 705, 741, 741, 791], [793, 793, 809, 809, 837], [839, 839, 884, 884, 2056]], "test": "untested"}
{"id": "3llfRl", "name": "Bending an SDF", "author": "blackle", "description": "a way to bend space that (kinda) preserves distances", "tags": ["sdf", "curve", "angle", "bend", "bending", "spacefolding", "kink"], "likes": 38, "viewed": 1330, "published": 3, "date": "1597469877", "time_retrieved": "2024-07-30T20:50:44.103995", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d, float k) {\n    vec3 q = abs(p)-d;\n    vec3 e = max(vec3(0), q);\n    return mix(super(e),length(e),k) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nvec2 kink(vec2 p, vec2 c, float k) {\n    p -= c;\n    //to polar coordinates\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    //warp angle with sigmoid function\n    ang -= ang/sqrt(1.+ang*ang)*(1.-k);\n    //to cartesian coordiantes\n    return vec2(sin(ang),cos(ang))*len + c;\n}\n\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n//smin modified to expose the \"h\" variable so we can use it to texture the place where the objects meet differently\nvec2 smin(float a, float b, float k) {\n    float h = max(0., k-abs(b-a))/k;\n    return vec2(min(a,b)-h*h*h*k/6., h);\n}\n\nvec3 local_coords;\nfloat edges;\nfloat scene(vec3 p) {\n    p.z -= 2.;\n    p.yz = kink(p.yz, vec2(0,-.4), mix(1.,.0,sin(iTime)*.5+.5));\n    local_coords = p;\n    \n    float warp = dot(sin(erot(p,vec3(1,0,0),.5)*20.),cos(p*15.));\n    warp += dot(sin(erot(p,vec3(0,1,0),.5)*40.),cos(p*35.))*.5;\n    warp = smoothstep(-.5,.5,warp);\n    \n    float bar = linedist(p,vec3(0,4,0),vec3(0,-4,0))-.1;\n    float bar2 = linedist(p,vec3(0.3,4,.15),vec3(-.2,-2,.15))-.035;\n    float knob = box(p-vec3(0,4,0),vec3(.35,.9,.2), warp)-.05;\n    float knob2 = box(p-vec3(.5,4,0),vec3(.35,.35,.5), warp)-.05;\n    vec3 bc = abs(p-vec3(0,-3,0))-vec3(0,.8,0);\n    float bob = mix(length(bc), super(bc),length(sin(bc*32.)*.5+.5)*.1)-.5;\n    float sm = .05+warp*warp*.05;\n    vec2 boxes = smin(knob,knob2,sm);\n    vec2 obj = smin(min(bar,bar2),min(boxes.x,bob),sm);\n    edges = max(boxes.y, obj.y);\n    return obj.x;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])) );\n}\n\n\nvec3 fancy_mapping(vec3 p) {\n    vec3 d1 = textureLod(iChannel0,p.xz*.5, 4.).xyz;\n    vec3 d2 = textureLod(iChannel0,p.yz*.5, 3.).xyz;\n    return textureLod(iChannel0,p.xy + d2.yz*3. + d1.xy*2.,1.).xyz;\n}\n\nfloat bayer(vec2 fragCoord) {\n    return texelFetch(iChannel1, ivec2(fragCoord) % 8, 0).x;\n}\n\n#define AO(p,n,k) smoothstep(-k,k,scene(p+n*k))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-10,0,0);\n\n   \tfloat yrot = 0.1;\n    float zrot = iTime*.25;\n    if (iMouse.z > 0.) {\n        yrot = -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 500 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p, init) > 50.) break;\n    }\n    vec3 lcrd = local_coords;\n    float ledg = edges;\n\tvec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    vec3 tex = fancy_mapping(lcrd*.8) + fancy_mapping(lcrd*.5) + fancy_mapping(lcrd*.3);\n    ledg = smoothstep(0.,.5,ledg);\n\n    float ao = AO(p,n,.1) * AO(p,n,.3) * AO(p,n,.7);\n    float specao = AO(p,r,.1) * AO(p,r,.3) * AO(p,r,.7);\n    float spec = length(sin(r*vec3(3,2,2))*0.4+0.6)/sqrt(3.);\n    float diff = length(sin(n*vec3(2,1,1))*0.4+0.6)/sqrt(3.);\n    float specex = mix(20.+sin(tex.x*14.)*12., 3., ledg);\n  \n    tex = smoothstep(0.,1.,tex*.25);\n    vec3 col = pow(spec, specex)*specao + mix(spec,diff,ledg*.5)*ao*tex;\n    float bg = pow(length(sin(cam*vec3(3,2,2))*0.4+0.6)/sqrt(3.), 10.);\n    bg = smoothstep(-0.05,1.5,bg);\n    fragColor.xyz = hit ? col : vec3(bg);\n    fragColor.xyz = sqrt(fragColor.xyz) + bayer(fragCoord)/128.;\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llfRl.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 215, 215, 247], [249, 249, 285, 285, 413], [415, 415, 451, 451, 705], [708, 708, 748, 748, 840], [842, 842, 880, 880, 944], [946, 1062, 1100, 1100, 1180], [1214, 1214, 1235, 1235, 2072], [2074, 2074, 2093, 2093, 2210], [2213, 2213, 2241, 2241, 2417], [2419, 2419, 2448, 2448, 2511], [2561, 2561, 2618, 2618, 4185]], "test": "untested"}
{"id": "tlfBzl", "name": "Experimental PBR material", "author": "BmB23", "description": "I had a sense that for rough materials, the blending between specular and diffuse had to be done per microfacet. This shader brute forces a solution. Try and increase the specular power or IOR to large values to see the darkening of the diffuse term.", "tags": ["raytracing", "sphere", "pbr"], "likes": 4, "viewed": 393, "published": 3, "date": "1597432498", "time_retrieved": "2024-07-30T20:50:44.951728", "image_code": "\nfloat IOR = 1.45;\nvec3 spherecolor = vec3(0.9);\nvec3 lightcolor = vec3(1.0);\nfloat roughness = 0.1;\nfloat specular = 0.5;\nbool spec = true;\nbool diff = true;\n\nvec3 env(vec3 v)\n{\n    vec3 cube = texture(iChannel0, rotate(v, vec3(0,1,0), iTime)).xyz;\n    cube = invtonemap(cube, 1.2)*0.7;\n    cube = gamma(cube, 2.2); //linearize texture\n    return cube;\n}\n\nfloat focal = 1.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    roughness = max(roughness, 0.02);\n    float eta = (1.0 - IOR) / (1.0 + IOR); eta = eta*eta;\n    float alpha = 1.0/(roughness*roughness);\n    spherecolor = gamma(spherecolor, 2.2);\n    \n    vec3 rayDir = vec3(uv, focal); rayDir = normalize(rayDir);\n    vec3 spherePos = vec3(0, 0, 2.5);\n    vec3 p = intersectSphere(rayDir, spherePos, 1.0);\n    vec3 n = normalize(p - spherePos);\n    vec3 v = -rayDir;\n    vec3 r = reflect(rayDir, n);\n    \n    //generate a bunch of random vectors\n\tvec3[256] randvecs;\n    for (int i = 0; i < 32; i++)\n    {\n        randvecs[i] = random(p*iTime, i);\n    }\n        \n    //diffuse\n    vec3 D = vec3(0);\n    float Dw = 0.0;\n    for(int i = 0; i < 16; i++)\n    {\n        vec3 l = randvecs[i];\n        l = dot(l,n) < 0.0 ? -l : l; //<0: below horizon, >0: above horizon\n        \n        float lambert = max(0.0, dot(n,l));\n        //\"lambert\" term is actually not lambertian emission, but\n        //the light being stretched out over a larger area as a function of\n        //angle to the light and should be applied to the entire incoming radiance\n        //lambertian emission is handled for free by filtering through the pixel grid\n        //since the area under the pixel also increases by the cosine of the angle\n        \n        //sum transmission for each micronormal\n        float T = 0.0;\n        float Tw = 0.0;\n        float E = 0.0;\n        float Ew = 0.0;\n        for(int j = 0; j < 8; j++)\n        {\n            vec3 mn = randvecs[j+16];\n            mn = dot(mn,n) < 0.0 ? -mn : mn;\n            mn = rotate(mn, cross(mn,n), acos(dot(mn,n)) * (1.0-roughness*roughness));\n            \n            float F = schlick(eta, dot(l,mn)); //fresnel on the specific micronormal\n            float pdf = gauss(dot(n,mn), roughness); //ndf for the micronormal\n            \n            T += (1.0 - F*specular);\n            Tw += 1.0;\n            \n            //and emission\n            E += max(dot(l,mn), 0.0) * dot(v,mn) * pdf;\n        \tEw += pdf;\n        }\n        T = T/Tw;\n        E = E/Ew;\n        \n        D += env(l) * T * spherecolor * E;\n        Dw += E;\n    }\n    D = D/Dw * (diff ? 1.0 : 0.0);\n    \n    //specular\n    vec3 R = vec3(0);\n    float Rw = 0.0;\n    for (int i = 0; i < 32; i++)\n    {\n        vec3 l = randvecs[i];\n        l = dot(l,n) < 0.0 ? -l : l;\n        l = rotate(l, cross(l,r), acos(dot(l,r)) * (1.0-roughness)) * 1.015;\n        \n        vec3 h = normalize(v + l);\n\t\tfloat blinn = dot(h,n);\n\t\tfloat micro = dot(h,l);\n        \n        float pdf = gauss(blinn, roughness);\n        R += env(l) * schlick(eta, micro) * pdf;\n        Rw += pdf;\n    }\n    R += env(r) * schlick(eta, dot(n,r)) * (1.0-roughness/roughness) * gauss(1.0, roughness);\n    Rw += (1.0-roughness/roughness) * gauss(1.0, roughness);\n    R = (R/Rw) * specular * (spec ? 1.0 : 0.0);\n    \n    //* keylight\n    vec3 l = normalize(vec3(cos(iTime+pi*0.2), -0.4, sin(iTime+pi*0.2)));\n    float lambert = max(0.0, dot(n,l));\n    vec3 h = normalize(v + l);\n    float blinn = dot(h,n);\n    float micro = dot(h,l);\n    \n    float E = 0.0;\n    float Ew = 0.0;\n    float T = 0.0;\n    float Tw = 0.0;\n    for(int i = 0; i < 16; i++)\n    {\n        vec3 mn = randvecs[i];\n        mn = dot(mn,n) < 0.0 ? -mn : mn;\n        mn = rotate(mn, cross(mn,n), acos(dot(mn,n)) * (1.0-roughness*roughness));\n\t\t\n        float F = schlick(eta, dot(l,mn));\n        float pdf = gauss(dot(n,mn), roughness);\n        \n        T += (1.0 - F*specular) * pdf;\n        Tw += pdf;\n        \n        E += max(dot(l,mn), 0.0) * dot(v,mn) * pdf;\n        Ew += pdf;\n    }\n    T = T/Tw;\n    E = E/Ew;\n    \n    float sigmoid = (1.0 / (1.0 + exp(dot(n,l)*-30.0)));\n    float Lspec = gauss(blinn, roughness) * fresnel(IOR, micro) * specular * (spec ? 1.0 : 0.0);\n    vec3 Ldif = T * spherecolor * E * (diff ? 1.0 : 0.0);\n    vec3 L = clamp(lightcolor * (Ldif + Lspec), 0.0, 1.0) * sigmoid;\n    //*/\n    \n    vec3 bg = texture(iChannel0, rotate(rayDir, vec3(0,1,0), iTime)).xyz;\n    bg = invtonemap(bg, 1.2)*0.7;\n    \n    if (p.z > 0.0) fragColor = vec4(gamma(L + D + R, 1.0/2.2), 1);\n    else fragColor = vec4(bg, 1);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi = 3.14159265359;\nfloat tau = 6.28318530718;\n\nvec3 intersectSphere(vec3 rayDir, vec3 spherePos, float r)\n{\n    //from wwwtyro\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayDir, -spherePos);\n    float c = dot(-spherePos, -spherePos) - r*r;\n    float d = b*b - 4.0*a*c;\n    float e;\n    if (d < 0.0) e = -1.0;\n    else e = (-b - sqrt(d)) / 2.0*a;\n    return rayDir * e;\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle)\n{\n \treturn v * cos(angle) + cross(axis, v) * sin(angle) + axis * dot(axis,v) * (1.0 - cos(angle));\n}\n\n// Random functions from Shadertoy/tlsXzf by vstelegin.\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n////\n\nvec3 random(vec3 p, int n)\n{\n    float u = random(vec4(p, n));\n    float v = random(vec4(n, p));\n    float yaw = tau * u;\n    float pitch = acos(2.0*v - 1.0);\n    return vec3(sin(pitch)*cos(yaw), cos(pitch), sin(pitch)*sin(yaw));\n}\n\nfloat phong(float cosangle, float alpha)\n{\n    //float norm = 0.0397436 * alpha + 0.0856832;\n    float norm = (alpha + 2.0) / tau;\n    return pow(cosangle, alpha) * norm;\n}\n\nfloat gauss(float cosangle, float sigma)\n{\n    float sqrt2pi = 2.50662827463;\n    float angle = acos(cosangle);\n    float a = angle/sigma;\n    float x = 1.0/(sigma*sqrt2pi);\n    return ( x * exp(-0.5 * (a*a)) );// / (x > 1.0 ? x : 1.0);\n}\n\nfloat snell(float angle, float eta)\n{\n    return sin(eta * sin(angle));\n}\n    \nfloat fresnel(float IOR, float cosangle_i)\n{\n    float n1 = 1.0003; float n2 = IOR;\n    float Rs, Rp, cosangle_t;\n    cosangle_t = snell(acos(cosangle_i), n1/n2);\n    cosangle_t = cos(cosangle_t);\n    Rs = (n1*cosangle_i - n2*cosangle_t) / (n1*cosangle_i + n2*cosangle_t);\n    Rp = (n1*cosangle_t - n2*cosangle_i) / (n1*cosangle_t + n2*cosangle_i);\n    Rs = abs(Rs); Rp = abs(Rp);\n    return (Rs*Rs + Rp*Rp) / 2.0;\n}\n\nfloat schlick(float F0, float cosangle)\n{\n    float a = 1.0 - cosangle;\n    return F0 + (1.0 - F0) * (a*a*a*a*a);\n        //exp2((-5.55473 * cosangle - 6.98316) * cosangle);\n}\n\nvec3 gamma(vec3 color, float power)\n{\n    return vec3(pow(color.x,power), pow(color.y,power), pow(color.z,power));\n}\n\nvec3 invtonemap(vec3 color, float power)\n{\n     return color / (power - color);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 178, 178, 355]], "test": "untested"}
{"id": "wlXBRl", "name": "13. Drive Home 4 - Tail Light", "author": "altera0", "description": "\nSource Link : https://www.youtube.com/watch?v=gKeT6T_bPEE\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["drivehome"], "likes": 5, "viewed": 339, "published": 3, "date": "1597426124", "time_retrieved": "2024-07-30T20:50:45.787494", "image_code": "\n#define S( a , b , t ) smoothstep( a , b , t )\n\nstruct Ray {\n\tvec3 ro;\t\t// Ray Origin\n    vec3 rd;\t\t// Ray Direction\n};\n\n// RAY\nRay GetRay( vec2 uv , vec3 camPos , float camZoom , vec3 lookAt ) {\n \n    Ray ray;\n     \n    ray.ro = camPos;\n    \n    vec3 F = normalize( lookAt - camPos );\n    vec3 R = normalize( cross( vec3( 0 , 1 , 0 ) , F ) );\n    vec3 U = cross( F , R );\n    \n    vec3 center  = camPos + F * camZoom;\n    vec3 intersectionPoint = center + uv.x * R  + uv.y * U;\n    \n    // rd have to do normalized.\n    // because where GetClosestPoint() , dot ( target - ro , rd ) * rd.\n    ray.rd = normalize( intersectionPoint - camPos );\n    \n    return ray;\n}\n\n\n// \nvec3 GetClosestPoint( Ray ray , vec3 targetPos ) {\n   \n    // 이때 반드시, rd가 노멀라이즈 되어 있어야,\n    // dot( targetPos - ray.ro , ray.rd )가 정확하게 계산이 된다.\n    return ray.ro + max( 0.0f , dot( targetPos - ray.ro , ray.rd ) ) * ray.rd;\n}\n\n\n// \nfloat GetDistance( Ray ray , vec3 targetPos ) {\n\tfloat d = length( targetPos - GetClosestPoint( ray , targetPos ) );\n    return d;\n}\n\n\n// BOKE \n/*\nfloat Boke( float d , float lightDiameter , float blur ) {\n    \n      \n\tfloat c = S( lightDiameter , lightDiameter * ( 1.0f - blur ) , d );\n    c *= mix( 0.7f , 1.0f , S( lightDiameter * 0.8f , lightDiameter , d ) );\n    return c;\n} */\n\n// BOKE\nfloat Boke(  Ray ray , vec3 targetPos ,  float lightDiameter , float blur ) {\n    \n    //vec3 targetPos = vec3( -1.0f , 0.15f , z );\n    float d = GetDistance( ray , targetPos );\n    float expandLight = lightDiameter * length( targetPos );\n    //c += Boke( d , expandLight , bokeBlur ) * fade;\n         \n\tfloat c = S( expandLight , expandLight * ( 1.0f - blur ) , d );\n    c *= mix( 0.7f , 1.0f , S( expandLight * 0.8f , expandLight , d ) );\n    return c;\n}\n\n\n\n\n// Noise\nfloat Noise(float t) {\n    float n = fract( sin( t * 8389.) * 3862. ) ;\n    return n;\n}\n\n// Street Light\nvec3 StreetLight( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n    float c = 0.0f;\n    \n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    float side = step( ray.rd.x , 0.0f );\n    ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t\n        float ti = fract(t + i + side * s * 0.5f );\n        vec3 targetPos = vec3( 2.0f , 2.0f , 100.0f - ti * 100.0f );\n        c += Boke( ray , targetPos , lightDiameter , bokeBlur ) * ti * ti * ti;\n    }\n         \n    vec3 col = vec3( 1.0f , 0.7f , 0.3f) * c;\n    return col;\n}\n\n\n// Head Light\nvec3 HeadLights( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n\t\n    float headLightDelta = -0.25f;\n    float headLightDelta2 = headLightDelta* 1.2f;\n    \n    \n    time = time * 2.0f;\n    \n    float c = 0.0f;\n    float t = time * 0.1f;\n    float s = 1.0f / 15.0f; // in 1 sec, 100 count.\n    //float side = step( ray.rd.x , 0.0f );\n    //ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t \n        float n = Noise( i );\n\t\tif ( n > 0.1f ) continue;\n        \n        float ti = fract(t + i);\n        float z = 100.0f - ti * 100.0f;\n        float fade = ti * ti * ti * ti * ti;\n        float focus = S( 0.8f , 1.0f , ti );\n        float size = mix( lightDiameter , lightDiameter * 0.5f , focus );\n            \n        c += Boke( ray , vec3( -headLightDelta + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( +headLightDelta + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n\n        c += Boke( ray , vec3( -headLightDelta2 + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( +headLightDelta2 + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n      \n    \n    \t// refection\n        float reflection = 0.0f;\n        \n        reflection += Boke( ray , vec3( -headLightDelta2 + -1.0f , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        reflection += Boke( ray , vec3( +headLightDelta2 + -1.0f , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        \n        c += reflection * focus;\n    }\n         \n    //vec3 col = vec3( 1.0f , 1.7f , 0.3f) * c;\n    vec3 col = vec3( 0.9f , 0.9f , 1.0f) * c;\n    \n    return col;\n}\n\n\n// Tail Light\nvec3 TailLights( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n\t\n    float headLightDelta = -0.25f;\n    float headLightDelta2 = headLightDelta* 1.2f;\n    \n    \n    time = time * 0.1f;\n    \n    float c = 0.0f;\n    //float t = time * 0.1f;\n    float t = time;\n    \n    float s = 1.0f / 15.0f; // in 1 sec, 100 count.\n    //float side = step( ray.rd.x , 0.0f );\n    //ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t \n        float n = Noise( i );\t\t\t// 0 ~ 1\n\t\tif ( n > 0.5f ) continue;\t\t// 0 ~ 0.5\n        \n        \n        \n        float ti = fract(t + i);\n        float z = 100.0f - ti * 100.0f;\n        float fade = ti * ti * ti * ti * ti;\n        float focus = S( 0.8f , 1.0f , ti );\n        float size = mix( lightDiameter , lightDiameter * 0.5f , focus );\n        \n        float lane = step( 0.25f , n );\t// 0 , 1\n        float laneShift = S(0.99f, 0.96f , ti );\n        float carPos = 1.5f - lane * laneShift;\n            \n        float blink = step( 0.0 , sin( t * 10000.0)) * 7.0f * lane * step( 0.9f , ti );\n        \n        c += Boke( ray , vec3( carPos -headLightDelta , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( carPos +headLightDelta , 0.15f , z ) , size , bokeBlur ) * fade;\n\n        c += Boke( ray , vec3( carPos -headLightDelta2 , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( carPos +headLightDelta2 , 0.15f , z ) , size , bokeBlur ) * fade * (1.0f + blink);\n      \n    \n    \t// refection\n        float reflection = 0.0f;\n        \n        reflection += Boke( ray , vec3( carPos -headLightDelta2 , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        reflection += Boke( ray , vec3( carPos +headLightDelta2 , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        \n        c += reflection * focus;\n    }\n         \n    \n    vec3 col = vec3( 1.0f , 0.1f , 0.01f) * c;\n    \n    return col;\n}\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5f * iResolution.xy) / min( iResolution.x, iResolution.y);\n\n    vec2 mouseUv = iMouse.xy / iResolution.xy;\n    //float m = length( mouseUv );\n    \n\n\tvec3 camPos = vec3( 0.5f , 0.2f , 0.0f );\n    vec3 lookAt = vec3( 0.5f , 0.2f , 1.0f );\n    float camZoom = 2.0f;\n    \n    \n    \n    float streetLightDiameter = 0.05f;\n    float headLightDiameter = 0.05f;\n    float bokeBlur = 0.1f;\n    \n    \n    Ray ray = GetRay( uv , camPos , camZoom , lookAt );\n\n\tvec3 col = StreetLight( ray , streetLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= HeadLights(ray , headLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= TailLights(ray , headLightDiameter , bokeBlur, iTime + mouseUv.x );\n    \n    \n    fragColor = vec4( col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXBRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 129, 196, 196, 666], [669, 673, 723, 868, 949], [952, 956, 1003, 1003, 1088], [1340, 1348, 1425, 1480, 1805], [1810, 1819, 1841, 1841, 1906], [1908, 1924, 2004, 2004, 2537], [2540, 2554, 2633, 2633, 4188], [4191, 4205, 4284, 4284, 6128], [6130, 6138, 6195, 6195, 6962]], "test": "untested"}
{"id": "3tXfzs", "name": "12. Drive Home 3 - Head Lights", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=gKeT6T_bPEE\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["drivehome"], "likes": 2, "viewed": 288, "published": 3, "date": "1597422434", "time_retrieved": "2024-07-30T20:50:46.555441", "image_code": "\n#define S( a , b , t ) smoothstep( a , b , t )\n\nstruct Ray {\n\tvec3 ro;\t\t// Ray Origin\n    vec3 rd;\t\t// Ray Direction\n};\n\n// RAY\nRay GetRay( vec2 uv , vec3 camPos , float camZoom , vec3 lookAt ) {\n \n    Ray ray;\n     \n    ray.ro = camPos;\n    \n    vec3 F = normalize( lookAt - camPos );\n    vec3 R = normalize( cross( vec3( 0 , 1 , 0 ) , F ) );\n    vec3 U = cross( F , R );\n    \n    vec3 center  = camPos + F * camZoom;\n    vec3 intersectionPoint = center + uv.x * R  + uv.y * U;\n    \n    // rd have to do normalized.\n    // because where GetClosestPoint() , dot ( target - ro , rd ) * rd.\n    ray.rd = normalize( intersectionPoint - camPos );\n    \n    return ray;\n}\n\n\n// \nvec3 GetClosestPoint( Ray ray , vec3 targetPos ) {\n   \n    // 이때 반드시, rd가 노멀라이즈 되어 있어야,\n    // dot( targetPos - ray.ro , ray.rd )가 정확하게 계산이 된다.\n    return ray.ro + max( 0.0f , dot( targetPos - ray.ro , ray.rd ) ) * ray.rd;\n}\n\n\n// \nfloat GetDistance( Ray ray , vec3 targetPos ) {\n\tfloat d = length( targetPos - GetClosestPoint( ray , targetPos ) );\n    return d;\n}\n\n\n// BOKE \n/*\nfloat Boke( float d , float lightDiameter , float blur ) {\n    \n      \n\tfloat c = S( lightDiameter , lightDiameter * ( 1.0f - blur ) , d );\n    c *= mix( 0.7f , 1.0f , S( lightDiameter * 0.8f , lightDiameter , d ) );\n    return c;\n} */\n\n// BOKE\nfloat Boke(  Ray ray , vec3 targetPos ,  float lightDiameter , float blur ) {\n    \n    //vec3 targetPos = vec3( -1.0f , 0.15f , z );\n    float d = GetDistance( ray , targetPos );\n    float expandLight = lightDiameter * length( targetPos );\n    //c += Boke( d , expandLight , bokeBlur ) * fade;\n         \n\tfloat c = S( expandLight , expandLight * ( 1.0f - blur ) , d );\n    c *= mix( 0.7f , 1.0f , S( expandLight * 0.8f , expandLight , d ) );\n    return c;\n}\n\n\n\n\n// Noise\nfloat Noise(float t) {\n    float n = fract( sin( t * 8389.) * 3862. ) ;\n    return n;\n}\n\n// Street Light\nvec3 StreetLight( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n    float c = 0.0f;\n    \n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    float side = step( ray.rd.x , 0.0f );\n    ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t\n        float ti = fract(t + i + side * s * 0.5f );\n        vec3 targetPos = vec3( 2.0f , 2.0f , 100.0f - ti * 100.0f );\n        c += Boke( ray , targetPos , lightDiameter , bokeBlur ) * ti * ti * ti;\n    }\n         \n    vec3 col = vec3( 1.0f , 0.7f , 0.3f) * c;\n    return col;\n}\n\n\n// Head Light\nvec3 HeadLights( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n\t\n    float headLightDelta = -0.25f;\n    float headLightDelta2 = headLightDelta* 1.2f;\n    \n    \n    float c = 0.0f;\n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    //float side = step( ray.rd.x , 0.0f );\n    //ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t \n        float n = Noise( i );\n\t\tif ( n > 0.5f ) continue;\n        \n        float ti = fract(t + i);\n        float z = 100.0f - ti * 100.0f;\n        float fade = ti * ti * ti * ti * ti;\n        float focus = S( 0.8f , 1.0f , ti );\n        float size = mix( lightDiameter , lightDiameter * 0.5f , focus );\n            \n        c += Boke( ray , vec3( -headLightDelta + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( +headLightDelta + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n\n        c += Boke( ray , vec3( -headLightDelta2 + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( +headLightDelta2 + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n      \n    \n    \t// refection\n        float reflection = 0.0f;\n        \n        reflection += Boke( ray , vec3( -headLightDelta2 + -1.0f , -0.15f , z ) , size * 2.0f , 1.0f ) * fade;\n        reflection += Boke( ray , vec3( +headLightDelta2 + -1.0f , -0.15f , z ) , size * 2.0f , 1.0f ) * fade;\n        \n        c += reflection * focus;\n    }\n         \n    //vec3 col = vec3( 1.0f , 1.7f , 0.3f) * c;\n    vec3 col = vec3( 0.9f , 0.9f , 1.0f) * c;\n    \n    return col;\n}\n\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5f * iResolution.xy) / min( iResolution.x, iResolution.y);\n\n    vec2 mouseUv = iMouse.xy / iResolution.xy;\n    //float m = length( mouseUv );\n    \n\n\tvec3 camPos = vec3( 0 , 0.2f , 0.0f );\n    vec3 lookAt = vec3( 0 , 0.2f , 1.0f );\n    float camZoom = 2.0f;\n    \n    \n    \n    float streetLightDiameter = 0.05f;\n    float headLightDiameter = 0.05f;\n    float bokeBlur = 0.1f;\n    \n    \n    Ray ray = GetRay( uv , camPos , camZoom , lookAt );\n\n\tvec3 col = StreetLight( ray , streetLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= HeadLights(ray , headLightDiameter , bokeBlur, iTime + mouseUv.x );\n    \n    \n    fragColor = vec4( col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXfzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 129, 196, 196, 666], [669, 673, 723, 868, 949], [952, 956, 1003, 1003, 1088], [1340, 1348, 1425, 1480, 1805], [1810, 1819, 1841, 1841, 1906], [1908, 1924, 2004, 2004, 2537], [2540, 2554, 2633, 2633, 4159], [4162, 4170, 4227, 4227, 4910]], "test": "untested"}
{"id": "WlXfzs", "name": "Noise landscape", "author": "illus0r", "description": "Foggy landscape", "tags": ["raymarchingnoiselandscape"], "likes": 5, "viewed": 384, "published": 3, "date": "1597418372", "time_retrieved": "2024-07-30T20:50:47.325382", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 hash( vec3 p ) // replace this by something better. really. do\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\nfloat GetDist(vec3 p) {\n    float plane = dot(p, normalize(vec3(0.,1.,0.)));\n    float n = noise(p);\n    float n2 = noise(p * 2.)  * 0.5;\n    float n3 = noise(p * 4.)  * 0.25;\n    float n4 = noise(p * 8.)  * 0.075;\n    float n5 = noise(p * 8.) * 0.0375;\n    n += n2 + n3 + n4 + n5;\n    \n    return (plane + n) * 0.1;\n}\n\n\n\n\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0. + iTime, 0.6, -3);\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, ro + vec3(1., 0., 0.), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \t//float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \t//col += dif; \n        //col = n * d;\n        col = vec3(S(10., 0., d));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXfzs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[339, 339, 358, 358, 420], [422, 422, 444, 444, 538], [540, 540, 569, 569, 650], [652, 652, 721, 721, 890], [892, 892, 918, 930, 2096], [2098, 2098, 2121, 2121, 2416], [2426, 2426, 2460, 2460, 2671], [2673, 2673, 2697, 2697, 2887], [2889, 2889, 2939, 2939, 3130], [3134, 3134, 3191, 3191, 3853]], "test": "untested"}
{"id": "WlffRs", "name": "Living fractal", "author": "Kanata", "description": "The equation for the Mandelbrot set is f(z) = z^2 + c. What if you tweaked it continuously?\nNote: the generalization f(z) = z^d + c generates the Multibrot set (see the link below)\nhttps://en.wikipedia.org/wiki/Multibrot_set\nHere I generalized  further.", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 287, "published": 3, "date": "1597414211", "time_retrieved": "2024-07-30T20:50:48.096321", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 res = iResolution.xy,\n          z = ( u* 2. - res) / min(res.x, res.y);\n\n    float t = iTime;\n    float scale = 1.5;\n    z *= scale;\n    \n    int j = 0;\n    vec2 w = vec2(0.,0.);\n    \n    for(int i = 0; i < 360; i++){\n        j++;\n        if(length(w) > 2.0){break;}\n        w = cpow(w,20.* abs(sin(t * 0.05)))\n            + cmul(cexp(vec2(sin(t* 0.9 + 0.3),t)), cpow(w,10.* abs(sin(t * 0.072 + 0.76))))\n            + z;\n    }\n \n    float b = float(j) / 360.0;\n\n    \n    O = vec4(vec3(b), 1.);\n}", "image_inputs": [], "common_code": "const float PI  = 3.141592653589793;\n\nvec3 hsvToRgb(float h, float s, float v) {\n    // h: -π - +π, s: 0.0 - 1.0, v: 0.0 - 1.0\n    h = (h + PI) / (2.* PI) * 360.;\n\n    float c = s; // float c = v * s;\n    float h2 = h / 60.0;\n    float x = c * (1.0 - abs(mod(h2, 2.0) - 1.0));\n    vec3 rgb = (v - c) * vec3(1.0, 1.0, 1.0);\n\n    if (0.0 <= h2 && h2 < 1.0) {\n        rgb += vec3(c, x, 0.0);\n    } else if (1.0 <= h2 && h2 < 2.0) {\n        rgb += vec3(x, c, 0.0);\n    } else if (2.0 <= h2 && h2 < 3.0) {\n        rgb += vec3(0.0, c, x);\n    } else if (3.0 <= h2 && h2 < 4.0) {\n        rgb += vec3(0.0, x, c);\n    } else if (4.0 <= h2 && h2 < 5.0) {\n        rgb += vec3(x, 0.0, c);\n    } else if (5.0 <= h2 && h2 < 6.0) {\n        rgb += vec3(c, 0.0, x);\n    }\n\n    return rgb;\n}\n// hsvToRgb borrowed from\n// https://qiita.com/sw1227/items/4be9b9f928724a389a85\n// (slightly modified by Kanata)\n\n//operations on complex numbers borrowed from\n//https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n\n#define re(a) vec2((a).x, 0.)\n#define im(a) vec2(0., (a).y)\n#define cmul(a,b) ( mat2(a, -(a).y, (a).x ) * (b) )\n#define conj(a)     vec2( (a).x, -(a).y)\n#define cinv(a)   ( conj(a) / dot(a, a) )\n#define cdiv(a,b) ( cmul(a, cinv(b)) )\n#define cexp(a)   ( exp((a).x)* vec2(cos((a).y), sin((a).y)) )\n#define clog(a)     vec2( log(length(a)), atan((a).y,(a).x) )\n#define arg(a)\t( atan(a.y, a.x) )\n#define cpow(a,n)   cexp( float(n)* clog(a) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlffRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 543]], "test": "untested"}
{"id": "WlfBRs", "name": "shifty plasma effect", "author": "thefox231", "description": "looks neat, i enjoy\nhttps://www.bidouille.org/prog/plasma", "tags": ["plasma"], "likes": 2, "viewed": 278, "published": 3, "date": "1597410146", "time_retrieved": "2024-07-30T20:50:48.866262", "image_code": "#define PI 3.1415926535897932384626433832795\n \n#define change (sin(iTime) * .5 + .5)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float v = 0.0;\n    vec2 u_k = vec2(8.0);\n    float time = iTime;\n    \n    vec2 c = (fragCoord.xy / iResolution.xy) * u_k - u_k/2.0;\n    \n    float off = mix(1.0, -1.0, change);\n    \n    v += sin((c.x * off + time));\n    v += sin((c.y * off + time)/2.0);\n    v += sin((c.x * -off + c.y * off + time)/2.0);\n    c += u_k / 2.0 * vec2(sin(time/3.0), cos(time/2.0));\n    v += sin(sqrt(c.x * c.x + c.y * c.y + 1.0) + time);\n    v = v / 2.0;\n    \n    float a = sin(v * mix(2.0, 2.4, change) * PI) * .5 + .5;\n    float b = cos(v * mix(2.0, 2.4, change) * PI) * .5 + .5;\n    \n    vec3 col1 = vec3(a - b - .2, a, a - b - .3);\n    vec3 col2 = vec3(b - a - .2, b - a - .3, b);\n    \n    fragColor = vec4(mix(col1, col2, change), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 141, 141, 867]], "test": "untested"}
{"id": "WtXBRl", "name": "Aperiodic Penrose Tiling", "author": "dr2", "description": "Penrose tiling with two rhombs, where tile color depends on rhomb shape and  orientation; click in upper/lower half to see corresponding atoms or  big/small coloring.\n", "tags": ["quasicrystal", "symmetry", "pentagon"], "likes": 20, "viewed": 900, "published": 3, "date": "1597388246", "time_retrieved": "2024-07-30T20:50:49.649169", "image_code": "// \"Aperiodic Penrose Tiling\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Based on an old program that used OpenGL to draw quads; that was much more \n efficient than the present pixel-based version and allowed much larger grids.\n Using de Bruijn's projection method [Math. Proc. A 84 (1981) 39,53]\n\n Projection method also used by knighty (https://www.shadertoy.com/view/XdtBzH) to\n produce a symmetric pattern, but not a full aperiodic tiling.\n An alternative (and faster) substitution method was used by tomkh\n (https://www.shadertoy.com/view/4t2XWG).\n There are other examples (search: penrose) that consider the related kite-and-dart tiles.\n*/\n\n#define BIG  0  // set =1 for larger grid - more work!!!\n\n#define VAR_ZERO min (nFrame, 0)\n\nmat3 VToRMat (vec3 v, float a);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\nfloat tCur;\nint nFrame;\nbool showPoly, rhomCol;\nconst float pi = 3.1415927;\n\nbool InTri (vec2 p, vec2 v0, vec2 v1, vec2 v2)\n{\n  vec3 s;\n  vec2 v10, v20, p0;\n  float d;\n  v10 = v1 - v0;\n  v20 = v2 - v0;\n  d = v20.y * v10.x - v20.x * v10.y;\n  p0 = p - v0;\n  s.xy = vec2 (v20.y * p0.x - v20.x * p0.y, - v10.y * p0.x + v10.x * p0.y);\n  s = abs (vec3 (s.xy, d - s.x - s.y) - 0.5 * d);\n  return (Maxv3 (s) < 0.5 * abs (d));\n}\n\nvec3 ShowScene (vec2 uv)\n{\n  vec3 col, vn, ltDir;\n  vec2 vp[5], csn[5], g, gg, mp, offset, up, vm, v[3];\n  float gam[5], gamSum, kCur[5], d, dm, di, rr, pScale, r1, r2, ic, f;\n  bool fatRom, done;\n#if BIG\n  const float kLimit = 7.;\n  pScale = 0.09;\n#else\n  const float kLimit = 4.;\n  pScale = 0.15;\n#endif\n  offset = Rot2D (vec2 (1.7, 0.), 0.05 * pi * tCur);\n  uv /= pScale;\n  uv -= offset;\n  r1 = 0.5 * sin (pi / 5.);\n  r2 = 0.5 * sin (2. * pi / 5.);\n  for (int k = 0; k < 5; k ++) csn[k] = sin (2. * pi * float (k) / 5. + vec2 (0.5 * pi, 0.));\n  gamSum = 0.;\n  for (int k = 0; k < 4; k ++) {\n    gam[k] = 0.1 * float (k + 1);\n    gamSum += gam[k];\n  }\n  gam[4] = - gamSum;\n  done = false;\n  ic = -1.;\n  for (int k1 = VAR_ZERO; k1 <= 3; k1 ++) {\n    for (int k2 = VAR_ZERO + 1; k2 <= 4; k2 ++) {\n      if (k2 >= k1 + 1) {\n        fatRom = (k2 - k1 == 1 || k2 - k1 == 4);\n        rr = fatRom ? r2 * r2 : r1 * r1;\n        ++ ic;\n        gg = - gam[k1] * csn[k2] + gam[k2] * csn[k1];\n        di = 1. / (csn[k1].x * csn[k2].y - csn[k2].x * csn[k1].y);\n        for (float kV1 = - kLimit + float (VAR_ZERO); kV1 <= kLimit; kV1 ++) {\n          kCur[k1] = kV1;\n          for (float kV2 = - kLimit + float (VAR_ZERO); kV2 <= kLimit; kV2 ++) {\n            kCur[k2] = kV2;\n            g = (gg + kV1 * csn[k2] - kV2 * csn[k1]).yx * vec2 (1., -1.);\n            for (int k = 0; k < 5; k ++) {\n              if (k != k1 && k != k2) {\n                d = dot (csn[k], g) * di + gam[k];\n                d += step (0., d);\n                kCur[k] = floor (abs (d)) * sign (d);\n              }\n            }\n            vp[0] = vec2 (0.);\n            for (int k = 0; k < 5; k ++) vp[0] += kCur[k] * csn[k];\n            vp[1] = vp[0] + csn[k1];\n            vp[2] = vp[0] + csn[k1] + csn[k2];\n            vp[3] = vp[0] + csn[k2];\n            mp = 0.25 * (vp[0] + vp[1] + vp[2] + vp[3]) - uv;\n            if (showPoly) done = (InTri (uv, vp[0], vp[1], vp[2]) ||\n               InTri (uv, vp[0], vp[3], vp[2]));\n            else done = (dot (mp, mp) < rr);\n            if (done) break;\n          }\n          if (done) break;\n        }\n      }\n      if (done) break;\n    }\n    if (done) break;\n  }\n  if (done) {\n    if (showPoly) {\n      dm = 99.;\n      vp[4] = vp[0];\n      for (int k = 0; k < 4; k ++) {\n        up = uv - vp[k];\n        v[0] = normalize (vp[k + 1] - vp[k]);\n        if (k == 0) v[1] = v[0];\n        else if (k == 1) v[2] = v[0];\n        f = dot (v[0], up);\n        d = dot (up, up) - f * f;\n        if (d < dm) {\n          dm = d;\n          vm = v[0];\n        }\n      }\n      dm = sqrt (dm);\n      if (rhomCol) col = HsvToRgb (vec3 (0.1 * ic, (fatRom ? 1. : 0.5), 1.));         \n      else col = fatRom ? vec3 (0., 1., 0.) : vec3 (1., 0., 0.);\n      col *= 0.4 + 0.6 * smoothstep (0.01, 0.03, dm);\n      vn = VToRMat (vec3 (vm, 0.), 0.12 * pi * sign (v[1].x * v[2].y - v[2].x * v[1].y) *\n         (1. - smoothstep (0., 0.15, dm))) * vec3 (0., 0., -1.);\n    } else {\n      col = vec3 (1., 1., (fatRom ? 0. : 0.5)) * (1. - smoothstep (0.9, 0.99, dot (mp, mp) / rr));\n      vn = - normalize (vec3 (mp, 0.7));\n    }\n    ltDir = normalize (vec3 (0.4, 0.6, -1.));\n    f = max (dot (vn, ltDir), 0.);\n    col = col * (0.2 + 0.8 * f * f + 0.5 * pow (max (0., dot (ltDir,\n       reflect (vec3 (0., 0., 1.), vn))), 32.));\n    col *= 0.1 + 0.9 * smoothstep (0.1, 0.9, Maxv3 (col));\n  } else col = vec3 (0.1, 0.1, 0.1);\n  return col;\n}\n\n#define AA   0 \n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 col;\n  vec2 canvas, uv, uvv;\n  float asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  nFrame = iFrame;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  rhomCol = true;\n  showPoly = true;\n  if (mPtr.z > 0.) {\n    if (mPtr.y > 0.) showPoly = false;\n    else rhomCol = false;\n  }\n  if (abs (uv.x) < 1.) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      col += (1. / naa) * ShowScene (uvv);\n    }\n  } else col = vec3 (0.82);\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.zyx * v.xzy;\n  b2 = - cs.y * v;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[1][2] = b1.x + b2.x;  m[2][1] = b1.x - b2.x;\n  m[2][0] = b1.y + b2.y;  m[0][2] = b1.y - b2.y;\n  m[0][1] = b1.z + b2.z;  m[1][0] = b1.z - b2.z;\n  return m;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXBRl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[989, 989, 1037, 1037, 1331], [1333, 1333, 1359, 1359, 4751], [4770, 4770, 4826, 4826, 5708], [5710, 5710, 5742, 5742, 6118], [6120, 6120, 6142, 6142, 6180], [6182, 6182, 6212, 6212, 6325], [6327, 6327, 6351, 6351, 6468]], "test": "untested"}
{"id": "tllfzf", "name": "Ray Marching experiments", "author": "illus0r", "description": "Experimenting with this code https://www.shadertoy.com/view/4tcGDr", "tags": ["raymarching"], "likes": 5, "viewed": 347, "published": 3, "date": "1597382112", "time_retrieved": "2024-07-30T20:50:50.414124", "image_code": "/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    \n    for (int i = 0; i < 6; i++) {\n        p = abs(p);\n        p += vec3(-0.8);\n        p = p * rotateY(iTime*.3);\n        p = p * rotateX(iTime*.7);\n        p = p * rotateZ(iTime*1.1);\n    }\n    return boxSDF(p, vec3(3.1 + .9 * sin(iTime * 3.)));\n}\n\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec2 mouse = iMouse.xy / 100.;\n    vec3 eye = vec3( 50. * sin(iTime), 50. * cos(iTime), 0.);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (estimateNormal(p) + vec3(1.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllfzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 440, 467, 467, 614], [616, 662, 689, 689, 836], [838, 884, 911, 911, 1058], [1060, 1151, 1197, 1197, 1229], [1231, 1315, 1357, 1357, 1389], [1391, 1480, 1527, 1527, 1560], [1562, 1670, 1703, 1703, 2133], [2135, 2222, 2256, 2256, 2284], [2286, 2403, 2448, 2517, 3123], [3139, 3393, 3458, 3458, 3590], [3595, 3922, 3971, 4006, 4137], [4139, 4379, 4403, 4403, 4657], [4660, 4749, 4778, 4778, 5088], [5090, 5582, 5722, 5722, 6312], [6315, 6685, 6770, 6770, 7570], [7574, 7995, 8086, 8086, 8392], [8394, 8394, 8451, 8451, 9401]], "test": "untested"}
{"id": "ttlfzf", "name": "Windy jungle", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/3t2cDm]\"sea cucumbers\"[/url] shader.\nUse the mouse to look around.\nYou can change the image resolution in the \"Common\" buffer.", "tags": ["forest", "recursion"], "likes": 3, "viewed": 381, "published": 3, "date": "1597381855", "time_retrieved": "2024-07-30T20:50:51.295766", "image_code": "float sceneSDF(vec3 a){\n    return sceneSDF(a,iTime);\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nbool is_edge(vec2 coord){\n    vec3 c1 = depth_map(coord);\n    for(int i = -5;i<6;i++){\n        for(int j = -5;j<6;j++){\n            if((length(c1-depth_map(coord+vec2(i,j)))) > 1.0){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(-35.0,1.0,iTime);\n    \n    vec3 p = depth_map(fragCoord);\n    //if(is_edge(fragCoord)){\n        //vec3 worldDir = normalize(p-eye);\n        //float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n        //p = eye+dist*worldDir;\n        //color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    //}\n    //anti-aliasing: this reduces the rendering speed\n    \n    //vec3 worldDir = normalize(p-eye);\n    //float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    //p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    vec3 color;\n    \n\n    color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}", "sound_inputs": [], "buffer_a_code": "\nfloat sceneSDF(vec3 a){\n    return sceneSDF(a,iTime);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n\tfragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0); //wobble\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0); //wobble\n    \n    float speed = 10.0;\n    vec3 eye = vec3(-35.0,1.0,iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float l0 = log(length(dmap-eye)+1.0)*2.0;\n    \n    if(l0< 10.0){\n        l0 = 0.0;\n    }\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 4.0\n\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    p += p.yzx;\n    p = cos(p/size1+sin(p/size1));\n    p = (sin(p/vec3(length((p/20.0)))))*size1;\n    return size-length(p)/1.83;\n}\n\nfloat sceneSDF(vec3 p,float t) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n    //try changing it to 1200.0\n\n    float result = vines(p,size1);\n    float i = 9.0;\n    for(int k = 0; k < 2; k++){\n    \tp = sin(p/i)*i-sin(p.yzx*i/(9.0)+t*9.0)/i;\n        //float i = 10.0;\n        //p /= 1.1;\n        result = min(result,vines((p-result*i/81.0)*i,size1)/(i*i));\n    \ti *= 9.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale*600.0;\n}", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlfzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 55], [57, 146, 175, 175, 485], [487, 979, 1119, 1119, 1729], [1731, 2101, 2186, 2186, 2533], [2535, 2535, 2563, 2563, 2711], [2713, 2713, 2740, 2740, 2889], [2891, 2891, 2916, 2916, 3152], [3154, 3154, 3245, 3245, 3569], [3573, 3573, 3630, 3630, 4518]], "test": "untested"}
{"id": "tlsBzf", "name": "climate changes", "author": "xenn", "description": "I dunno", "tags": ["particles", "ca"], "likes": 5, "viewed": 350, "published": 3, "date": "1597380168", "time_retrieved": "2024-07-30T20:50:52.201345", "image_code": "\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(2.0-3.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.7, 0.7);\n    vec3 col1 = vec3(0., 0.92, 1.);\n    // Output to screen\n    col.xyz += 0.1*a;\n    col.xyz += 0.5 - 0.5*cos(0.75*0010.0*vec3(0.2*sin(iTime*0.1),0.2*cos(iTime*0.1),0.42*cos(iTime*(00.1)))*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5)));\n    col.w=1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 2.5\n\n#define fluid_rho 0.2\n//mold stuff \n#define sense_ang 0.5+0.5\n//*sin(time*0.134)0\n#define sense_dis 2.0 \n#define sense_force 00000.5050\n#define trailing 50.0\n#define acceleration 00.005\n\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 0.235*rho.x + 0.*rho.y; //gas\n    return 0.02*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n//https://www.shadertoy.com/img/themes/dark/play.png\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 01.1\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= sin(0.002*P.M.x*vec2(0,1));\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.01*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > .010)?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 131, 131, 309], [311, 311, 347, 347, 397], [399, 399, 415, 415, 443], [445, 445, 490, 490, 1654]], "test": "untested"}
{"id": "ttsfRf", "name": "ring worm", "author": "xenn", "description": "interesting to look at", "tags": ["particles", "ca"], "likes": 1, "viewed": 206, "published": 3, "date": "1597371004", "time_retrieved": "2024-07-30T20:50:53.077004", "image_code": "// Fork of \"parasight\" by xenn. https://shadertoy.com/view/wllfRf\n// 2020-08-14 01:58:15\n\n// Fork of \"dissonant divergence\" by xenn. https://shadertoy.com/view/wtXfR4\n// 2020-08-14 00:58:49\n\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(2.0-3.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -01.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1.5, fluid_rho*9.5, rho.z));\n    vec3 col0 = vec3(1., 0.7, 0.7);\n    vec3 col1 = vec3(0.3, 0.92, 1.);\n    // Output to screen\n    col.xyz += 0.051*a;\n    col.xyz += 0.5 - 0.5*cos(0.725*0010.0*vec3(0.2*cos(iTime*0.21),0.2*cos(iTime*0.11),0.2*cos(iTime*(00.1)))*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(2.*pow(col.xyz,vec3(01.505)));\n    col.w=0.50;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 0.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 020.5\n\n#define fluid_rho 0.2\n//mold stuff \n#define sense_ang 0.61+0.5\n//*sin(time*0.134)\n#define sense_dis 2.0\n#define sense_force 000.5\n#define trailing 2000.0\n#define acceleration 0.051\n\n\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 0.005*rho.x + 0.*rho.y; //gas\n    return 0.02*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 01.2\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= sin(0.000*P.M.x*vec2(0,1));\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 01.1*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.5)?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < .1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(12.*pos.x/R.x), cos(12.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/01.5); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho*2.0;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 220, 220, 398], [400, 400, 436, 436, 486], [488, 488, 504, 504, 532], [534, 534, 579, 579, 1754]], "test": "untested"}
{"id": "ttlBRf", "name": "shadowbars", "author": "lennyjpg", "description": "sdfgsdfgsdfg", "tags": ["lines", "angle", "white", "black", "corner"], "likes": 0, "viewed": 290, "published": 3, "date": "1597367446", "time_retrieved": "2024-07-30T20:50:53.925734", "image_code": "/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    float t = iTime * 2.0;\n    vec2 u = uv * 20.0;\n    u = fragCoord.xy * 0.05 + uv * 0.1;\n    u -= t;\n    float k = fract(uv.x < uv.y ? u.x : u.y); \n    float d = k + 0.1 + uv.y * 0.8;\n    float f = floor(d);\n    float a = 0.05;\n    f = smoothstep(-a, a , d-1.0);\n    f = pow(f,1./2.2);\n    fragColor = vec4(f);\n}*/\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 uv = U/iResolution.x,\n          u = U/20. + uv * .1 - iTime * 2.;\n \n    float d = fract( u[int(uv.x > uv.y)] )\n              +.1 + uv.y*.8,\n          a = .05;\n    \n    O = vec4( smoothstep(-a, a , d-1. ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[418, 418, 456, 456, 673]], "test": "untested"}
{"id": "wllfRf", "name": "parasight", "author": "xenn", "description": "worms? what worms?\n\nwhatever warm worms would want,\n\nwell, without the wicked wandering ones wobbling away", "tags": ["particles", "ca"], "likes": 5, "viewed": 318, "published": 3, "date": "1597366880", "time_retrieved": "2024-07-30T20:50:54.701660", "image_code": "// Fork of \"dissonant divergence\" by xenn. https://shadertoy.com/view/wtXfR4\n// 2020-08-14 00:58:49\n\n// Fork of \"My virtual slime molds\" by michael0884. https://shadertoy.com/view/WtBcDG\n// 2020-07-24 21:29:48\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(2.0-3.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.7, 0.7);\n    vec3 col1 = vec3(0., 0.92, 1.);\n    // Output to screen\n    col.xyz += 0.1*a;\n    col.xyz += 0.5 - 0.5*cos(0.51*0010.0*vec3(0.52*sin(iTime*0.11),0.532*cos(iTime*0.12),0.42*cos(iTime*(00.13)))*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5)));\n    col.w=1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 02.5\n\n#define fluid_rho 0.00752\n\n\n//mold stuff \n#define sense_ang 0.862\n#define trailing 1.0*cos(time*01.21)\n#define sense_dis 04.0\n#define sense_force 0.500\n#define acceleration 0.01*(time*0.2)\n\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 0.15*rho.x + 0.*rho.y; //gas\n    return(0.052*cos(time*01.21))*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 01.30\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= sin(-0.000300*P.M.x*vec2(0,1));\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.01*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 2.0 * sin(time*0.61))?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 435, 435, 613], [615, 615, 651, 651, 701], [703, 703, 719, 719, 747], [749, 749, 794, 794, 1964]], "test": "untested"}
{"id": "ttlfRf", "name": "Rainbow stalactite caverns", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wtBcWm]\"Crazy distorted caves.\"[/url]", "tags": ["fractal", "cave", "stalactites"], "likes": 3, "viewed": 303, "published": 3, "date": "1597366574", "time_retrieved": "2024-07-30T20:50:55.469607", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = .05; \n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(inout vec3 p,float i){\n    p = p/size;\n    p = p-p.zyx*p;\n\n    p = (sin((p)/i+p))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p = sin(p/2000.0)*2000.0;\n    \n    float result = 0.0;\n    for(float i = 1.0; i < 9.0; i *= 3.0){\n        p /= scale*(10.0+.1*sin(p.yzx/5.0+p/10.0));\n    \tresult = max(result, -planet_surface(p,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return (sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))/4.0+vec3(.7));\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*800.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t>>(t/((t/4096)%5+(t/4096)%3)))|t>>4&t>>5|t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 16000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[549, 549, 592, 592, 688], [690, 690, 714, 714, 1016], [1019, 1019, 1047, 1047, 1167], [1170, 1591, 1682, 1682, 1994], [2009, 2263, 2328, 2328, 2460], [2462, 2551, 2580, 2580, 2890], [2892, 3384, 3524, 3524, 4134], [4136, 4506, 4591, 4591, 5006], [5008, 5335, 5384, 5419, 5550], [5552, 5552, 5609, 5609, 6772]], "test": "untested"}
{"id": "wlsfzX", "name": "Cubic Reconstruction Kernels", "author": "TinyTexel", "description": "The reconstruction kernels used for per-cell cubic interpolation on regular grids of values and partial derivatives:\nhttps://www.shadertoy.com/view/3tfBzX\n\nred:  kern_v\nblue: kern_d\n\nlight red:  kern_vD1\nlight blue: kern_dD1", "tags": ["filter", "filtering", "bicubic", "convolution", "cubic", "interpolation", "tricubic", "reconstruction"], "likes": 5, "viewed": 447, "published": 3, "date": "1597363213", "time_retrieved": "2024-07-30T20:50:56.237553", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nThe reconstruction kernels used for per-cell cubic interpolation on regular grids of values and partial derivatives:\nhttps://www.shadertoy.com/view/3tfBzX\n\nred:  kern_v\nblue: kern_d\n\nlight red:  kern_vD1\nlight blue: kern_dD1\n*/\n\nfloat kern_v(float x) { return 1.0-x*x*(3.0-2.0*abs(x)); }\nfloat kern_d(float x) { float o = abs(x)-1.0; return x*(o*o); }\n\nfloat kern_vD1(float x) { return x*(abs(x)*6.0-6.0); }\nfloat kern_dD1(float x) { return (abs(x)-1.0)*(abs(x)*3.0-1.0); }\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += 0.0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * vec2(0.5, 0.3);\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.5;\n    \n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    \n\tif(tex.x > -1.0 && tex.x < 1.0)\n    {\n        col = mix(col, vec3(1.0, 0.0, 0.0), Graph(kern_vD1(tex.x) - tex.y, 0.5)*0.25); \n        col = mix(col, vec3(0.0, 0.5, 1.0), Graph(kern_dD1(tex.x) - tex.y, 0.5)*0.25); \n\n        col = mix(col, vec3(0.0, 0.5, 1.0), Graph(kern_d(tex.x) - tex.y, 0.5));       \n        col = mix(col, vec3(1.0, 0.0, 0.0), Graph(kern_v(tex.x) - tex.y, 0.5));       \n    }\n    \n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}", "image_inputs": [], "common_code": "\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsfzX.jpg", "access": "api", "license": "cc0-1.0", "functions": [[303, 303, 326, 326, 361], [362, 362, 385, 385, 425], [427, 427, 452, 452, 481], [482, 482, 507, 507, 547], [549, 549, 597, 597, 1616]], "test": "untested"}
{"id": "3tfBzX", "name": "Cubic Reconstruction", "author": "TinyTexel", "description": "Per-cell cubic interpolation on a regular grid of values and partial derivatives.\nReference function (red) overlayed with bicubically resampled version (cyan).\nApproximation error results in chromatic aberration.", "tags": ["filter", "filtering", "bicubic", "convolution", "cubic", "interpolation", "tricubic", "reconstruction"], "likes": 16, "viewed": 671, "published": 3, "date": "1597363196", "time_retrieved": "2024-07-30T20:50:57.191004", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n\tPer-cell cubic interpolation on a regular grid of values and partial derivatives.\n*/\n\n#define DISPLAY 0\n/*\n\t0 - reference function (red) overlayed with bicubically resampled version (cyan)\n\t1 - analytic normals | abs(laplacian) of bicubic approximation\n*/\n\n/*\nDerivation:\n\nOn a cartesian grid (tri-/bi-)linear interpolation is a popular reconstruction scheme as \nit requires data to only be read from a minimal neighborhood of grid vertices.\n\nIn the following we show how to generalize (tri-/bi-)linear interpolation in the case that we\nhave (partial) derivatives available at each grid vertex (in addition to scalar function values).\n\nFirst, we will derive the 1d interpolation scheme formulated as a convolution.\nGeneralizing the 1d result to higher dimensions is then similarly straightforward as it is in the case of linear interpolation.\n\nLet's consider the interpolation on the interval [0,1] and in particular the kernel positioned at the origin.\nFor linear interpolation this kernel is 1-x, i.e. a degree 1 polynomial:\n\n1\n|◣\n|▩◣\n|▩▩◣\n|▩▩▩◣\n0------1\n\nAdding derivatives at 0 and 1 as additional constrains requires us to raise this degree to 3\n(assuming we don't want to use piecwise quadratic polynomials, which, let's just assume, we don't).\n\nNow one might expect that we have to use the derivatives to somehow parametrize the shape of the\nreconstruction kernel, making the whole procedure quite a bit more complicated then it is when working with scalar sample values.\n\nFortunately this is not the case. Since the sum of two polynomials of a given degree is a polynomial of the same degree,\nwe can derive two complementary kernels of which the scaled contributions are additively combined to the final recontrucion result: \none kernel, kern_v, that ensures that the function values are correct at the sample positions while not affecting the derivatives, \nand another kernel, kern_d, that does the exact opposite, i.e. taking care of the derivatives while not affecting the values.\n\nThe constraints for kern_v and kern_d are therefore:\n\nkern_v(0)  = 1,\nkern_v(1)  = 0,\n\nkern_v(0)' = 0,\nkern_v(1)' = 0,\n\nkern_d(0)  = 0,\nkern_d(1)  = 0,\n\nkern_d(0)' = 1,\nkern_d(1)' = 0.\n\nThe resulting cubic polynomials are then:\n\nkern_v(x) = 1-x²(3-2x),\nkern_d(x) = x(x-1)².\n\nkern_v:\n1\n|▩◣\n|▩▩◣\n|▩▩▩\n|▩▩▩◣\n|▩▩▩▩◣▂\n0---------1\t\n\nkern_d:\n1\n|\n|\n|  \n|  ◢◣\n|◢▩▩▩◣▂\n0---------1\n\n(A proper plot of these kernels can be found here: https://www.shadertoy.com/view/wlsfzX)\n\nUsually it's more convenient to work with kernel definitions that are valid on the interval [-1,1].\nGeneralizing the equations of kern_v and kern_d accordingly requires only minor modifications:\n\nkern_v(x) = 1-x²(3-2|x|),\nkern_d(x) = x(|x|-1)².\n\n\nFor example, the reconstrution on the interval [0,1] is now performed as follows:\n\nf(x) = value(0) * kern_v(x  ) + derivative(0) * kern_d(x  ) + \n       value(1) * kern_v(x-1) + derivative(1) * kern_d(x-1).\n\nHere are two observations regarding kern_v and kern_d:\n1. kern_v is the cubic s-curve commonly referred to as smoothstep (just flipped upside down here).\n2. kern_d is a linear ramp x windowed by an offset parabola (x-1)².\n   This is similar to the surfel definition used by perlin noise. \n   However, the original perlin noise used smoothstep as the windowing function, resulting in a degree 4 polynomial.\n\n\nAs mentioned earlier, generalizing cubic to bi-cubic interpolation is relatively straightforward.\nSince we now have to deal with two partial derivatives, we need one more kernel.\nLet's write down the constraints for the kernel trio positioned at the origin (we are working on the 2d interval [0,1]x[0,1] now):\n\nkern_v(0,0) = 1,\nkern_v(1,0) = 0,\nkern_v(0,1) = 0,\nkern_v(1,1) = 0,\n\nkern_v(0,0)'x = 0,\nkern_v(1,0)'x = 0,\nkern_v(0,1)'x = 0,\nkern_v(1,1)'x = 0,\n\nkern_v(0,0)'y = 0,\nkern_v(1,0)'y = 0,\nkern_v(0,1)'y = 0,\nkern_v(1,1)'y = 0,\n\n\nkern_dx(0,0) = 0,\nkern_dx(1,0) = 0,\nkern_dx(0,1) = 0,\nkern_dx(1,1) = 0,\n\nkern_dx(0,0)'x = 1,\nkern_dx(1,0)'x = 0,\nkern_dx(0,1)'x = 0,\nkern_dx(1,1)'x = 0,\n\nkern_dx(0,0)'y = 0,\nkern_dx(1,0)'y = 0,\nkern_dx(0,1)'y = 0,\nkern_dx(1,1)'y = 0,\n\n\nkern_dy(0,0) = 0,\nkern_dy(1,0) = 0,\nkern_dy(0,1) = 0,\nkern_dy(1,1) = 0,\n\nkern_dy(0,0)'x = 0,\nkern_dy(1,0)'x = 0,\nkern_dy(0,1)'x = 0,\nkern_dy(1,1)'x = 0,\n\nkern_dy(0,0)'y = 1,\nkern_dy(1,0)'y = 0,\nkern_dy(0,1)'y = 0,\nkern_dy(1,1)'y = 0,\n\n\nLuckily it is not necessary to actually solve the resulting system of equations to figure out the polynomials.\nInstead we can just use our 1d results as building blocks to easily satisfy all of the constrains listed above:\n\nkern_v (x, y) = kern_v(x) * kern_v(y),\nkern_dx(x, y) = kern_d(x) * kern_v(y),\nkern_dy(x, y) = kern_d(y) * kern_v(x).\n\n\nGeneralizing further to 3d we get:\n\nkern_v (x, y, z) = kern_v(x) * kern_v(y) * kern_v(z),\nkern_dx(x, y, z) = kern_d(x) * kern_v(y) * kern_v(z),\nkern_dy(x, y, z) = kern_v(x) * kern_d(y) * kern_v(z),\nkern_dz(x, y, z) = kern_v(x) * kern_v(y) * kern_d(z).\n\n\nWhat I originally did not consider was that we can, and usually want to, include higher order partial derivatives \nin the reconstruction process. The reason for that is that the kernels have higher polynomial degrees in the diagonal directions.\nTo get the complete set of kernels for a given dimension we simply include all possible combinations of kern_v and kern_d: \n\nIn 2d we only need to add one missing kernel, kern_d2xy:\n\nkern_v   (x, y) = kern_v(x) * kern_v(y),\nkern_dx  (x, y) = kern_d(x) * kern_v(y),\nkern_dy  (x, y) = kern_v(x) * kern_d(y),\nkern_d2xy(x, y) = kern_d(x) * kern_d(y).\n\n\nIn 3d, however, we missed quite a few combinations:\n\nkern_v    (x, y, z) = kern_v(x) * kern_v(y) * kern_v(z),\nkern_dx   (x, y, z) = kern_d(x) * kern_v(y) * kern_v(z),\nkern_dy   (x, y, z) = kern_v(x) * kern_d(y) * kern_v(z),\nkern_dz   (x, y, z) = kern_v(x) * kern_v(y) * kern_d(z),\n\nkern_d2xy (x, y, z) = kern_d(x) * kern_d(y) * kern_v(z),\nkern_d2xz (x, y, z) = kern_d(x) * kern_v(y) * kern_d(z),\nkern_d2yz (x, y, z) = kern_v(x) * kern_d(y) * kern_d(z),\nkern_d3xyz(x, y, z) = kern_d(x) * kern_d(y) * kern_d(z),\n\n\nWhether we truncate our set of kernels or use the complete one mostly boils down to a performance-quality trade-off.\n\n\nWe can extent our evaluation scheme to also compute the partial derivatives.\nFor that we need the derivatives of the 1d kernels:\n\nkern_v(x)' = x(|x|6-6),\nkern_d(x)' = (|x|-1)(|x|3-1).\n\nIn 1d this is all we need: simply perform another reconstruction using these kernels.\n\nFor the kernel composition in multiple dimensions applying the chain rule will lead us to the realization that differentiating \nany kernel in a given direction simplifies to replacing the respective 1d kernel in the multiplication chain with its derivative.\n\nIn 2d, the kernels used to reconstruct the x and y partial derivatives are therefore\n\nkern_v   (x, y)'x = kern_v(x)' * kern_v(y),\nkern_dx  (x, y)'x = kern_d(x)' * kern_v(y),\nkern_dy  (x, y)'x = kern_v(x)' * kern_d(y),\nkern_d2xy(x, y)'x = kern_d(x)' * kern_d(y),\n\nand \n\nkern_v   (x, y)'y = kern_v(x) * kern_v(y)',\nkern_dx  (x, y)'y = kern_d(x) * kern_v(y)',\nkern_dy  (x, y)'y = kern_v(x) * kern_d(y)',\nkern_d2xy(x, y)'y = kern_d(x) * kern_d(y)',\n\nand if we need the xy derivative also\n\nkern_v   (x, y)'x'y = kern_v(x)' * kern_v(y)',\nkern_dx  (x, y)'x'y = kern_d(x)' * kern_v(y)',\nkern_dy  (x, y)'x'y = kern_v(x)' * kern_d(y)',\nkern_d2xy(x, y)'x'y = kern_d(x)' * kern_d(y)'.\n\n\nThe kernel construction in 3d works analogously.\n\n\nRelated:\n\n- https://www.shadertoy.com/view/WtsBDH | \"Bicubic C2 cont. Interpolation\"  (practical application)\n- https://www.shadertoy.com/view/wtByDt | \"Single Sample Bicubic Sampling\"  (performance optimization via approximation)\n- https://www.shadertoy.com/view/wlsfzX | \"Cubic Reconstruction Kernels\"    (plot of kern_v and kern_d)\n- https://www.shadertoy.com/view/wtByDt | \"Single Sample Bicubic Sampling\"  (approximating the reconstruction with a single sample in 2d)\n- https://www.shadertoy.com/view/tdtyzj | \"Single Sample Tricubic Sampling\" (approximating the reconstruction with a single sample in 3d)\n\n*/\n\nfloat kern_v(float x) { return 1.0-x*x*(3.0-2.0*abs(x)); }\nfloat kern_d(float x) { float o = abs(x)-1.0; return x*(o*o); }\n\nfloat kern_vD1(float x) { return x*(abs(x)*6.0-6.0); }\nfloat kern_dD1(float x) { return (abs(x)-1.0)*(abs(x)*3.0-1.0); }\n\nfloat kern_vD2(float x) { return abs(x) * 12.0 - 6.0; }\nfloat kern_dD2(float x) { return x * 6.0 + (x > 0.0 ? -4.0 : 4.0); }\n\n\nvec4 kern(vec2 p)\n{\n    return vec4(kern_d(p.x) * kern_v(p.y),\n                kern_v(p.x) * kern_d(p.y),\n                kern_d(p.x) * kern_d(p.y),\n                kern_v(p.x) * kern_v(p.y));\n}\n\nmat4 kern4x4(vec2 p)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    mat4 m = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n    \n    return m;\n}\n\nvoid kern4x4(vec2 p, out mat4 mA, out mat4 mB)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    vec2 vD2 = vec2(kern_vD2(p.x), kern_vD2(p.y));\n    vec2 dD2 = vec2(kern_dD2(p.x), kern_dD2(p.y));\n    \n    mA = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n\n    mB = mat4\n    (\n        /*   kernDxx      |  kernDyy      |  kernDxxy       |  kernDxyy    */\n        vec4(dD2.x * v.y  ,  d.x * vD2.y  ,  dD2.x * vD1.y  ,  dD1.x * vD2.y),\n        vec4(vD2.x * d.y  ,  v.x * dD2.y  ,  vD2.x * dD1.y  ,  vD1.x * dD2.y),\n        vec4(dD2.x * d.y  ,  d.x * dD2.y  ,  dD2.x * dD1.y  ,  dD1.x * dD2.y),\n        vec4(vD2.x * v.y  ,  v.x * vD2.y  ,  vD2.x * vD1.y  ,  vD1.x * vD2.y)\n    );\n}\n\n\nfloat Map(vec2 uv)\n{\n    vec2 p = vec2(7.1, 4.3);\n    p += vec2(cos(iTime), sin(iTime*0.37));\n\n    p.x +=     cos((uv.x + uv.y*0.5 )*2.0 + iTime);\n    p.y += 4.0*cos((uv.y + uv.x*0.25) + iTime*0.627);\n    \n    float res = dot(uv-p, uv-p) - 8.0;\n\n     res += 16.0 * (sin(uv.x * Pi*0.5) * sin(uv.y * Pi*0.5));// add some ddxy heavy stuff\n    \n    return res;\n}\n\n#if 1\nvec4 Map2(vec2 uv)\n{\n    float o = 1.0/32.0;// using a power of 2 is good for retaining precision\n    \n    float v[4];\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n        v[i + 2 * j] = Map(uv + (vec2(i, j) - 0.5) * o);\n        \n    // | 2 | 3 |\n    // | 0 | 1 |\n    \n    float dx = ((v[3]+v[1]) - (v[2]+v[0])) / (2.0 * o);\n    float dy = ((v[2]+v[3]) - (v[0]+v[1])) / (2.0 * o);\n    \n    float ddxy = ((v[3] - v[1]) - \n                  (v[2] - v[0])) / (o*o);\n    \n    return vec4(dx, dy, ddxy, (v[0]+v[1]+v[2]+v[3])*0.25);\n}\n#else\nvec4 Map2(vec2 uv)\n{\n    float o = 1.0/64.0;\n    \n    float v[9];\n    for(int j = 0; j < 3; ++j)\n    for(int i = 0; i < 3; ++i)\n        v[i + 3 * j] = Map(uv + (vec2(i, j) - 1.0) * o);\n        \n    // | 6 | 7 | 8 |\n    // | 3 | 4 | 5 |\n    // | 0 | 1 | 2 |\n    \n    float dx = (v[5] - v[3]) / (2.0 * o);\n    float dy = (v[7] - v[1]) / (2.0 * o);\n    \n    float ddxy = ((v[8] - v[6]) - \n                  (v[2] - v[0])) / (4.0 * o*o);\n    \n    return vec4(dx, dy, ddxy, v[4]);\n}\n#endif\n\n\nfloat SampleBicubic(vec2 p)\n{\n    vec2 p0 = floor(p);\n    vec2 l  = p - p0;\n    \n    float f = 0.0;\n\tfor (float y = 0.0; y < 2.0; ++y)\n\tfor (float x = 0.0; x < 2.0; ++x)\n    {\n        vec4 n = Map2(p0 + vec2(x, y));\n        \n        f += dot(kern(l - vec2(x, y)), n);\n    }\n    \n    return f;\n}\n\nvec4 SampleBicubic2(vec2 p)\n{\n    vec2 p0 = floor(p);\n    vec2 l  = p - p0;\n    \n    vec4 r = vec4(0.0);\n\tfor (float y = 0.0; y < 2.0; ++y)\n\tfor (float x = 0.0; x < 2.0; ++x)\n    {\n        vec4 n = Map2(p0 + vec2(x, y));\n        \n        r += kern4x4(l - vec2(x, y)) * n;\n    }\n    \n    return r;\n}\n\nvec4 SampleBicubic3(vec2 p, out vec4 d2)\n{\n    vec2 p0 = floor(p);\n    vec2 l  = p - p0;\n    \n    vec4 r = vec4(0.0);\n\tfor (float y = 0.0; y < 2.0; ++y)\n\tfor (float x = 0.0; x < 2.0; ++x)\n    {\n        vec4 n = Map2(p0 + vec2(x, y));\n        \n        mat4 mA, mB;\n        kern4x4(l - vec2(x, y), /*out*/ mA, mB);\n        \n        r  += mA * n;\n        d2 += mB * n;\n    }\n    \n    return r;\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 uv = uv0 - 0.5;\n\tvec2 tex = (uv0 - vec2((iResolution.x-iResolution.y) * 0.5, 0.0)) / iResolution.yy;\n    \n    vec3 col = vec3(0.0);\n    \n    //vec2 p = uv0.xy*0.02;\n    float s = iResolution.x / 16.0;\n    vec2 p = uv0 / s;\n    \n#if DISPLAY == 0\n   \n    float base = 0.012;\n    \n   #if 1\n    vec2 grid0 = quintic(clamp01((abs(fract(p.xy + 0.5) - 0.5)-0.01)*0.75*s));\n    \n    base *= mix(0.5, 1.0, min(grid0.x, grid0.y));\n   #endif\n    \n    vec4 approx = SampleBicubic2(p);\n    {\n    \tvec4 c = approx;\n    \tfloat line = 1.0 - quintic(clamp01((abs(c.w / length(c.xy)) - 0.01)*0.5*s));\n    \tcol.gb = vec2(mix(c.w < 0.0 ? 0.0 : clamp01(1.0-c.w*0.25) * 0.25 + base, 1.0, line));\n    }\n    \n    vec4 ref = Map2(p);\n    {\n    \tvec4 c = ref;\n    \tfloat line = 1.0 - quintic(clamp01((abs(c.w / length(c.xy)) - 0.01)*0.5*s));\n    \tcol.r = mix(c.w < 0.0 ? 0.0 : clamp01(1.0-c.w*0.25) * 0.25 + base, 1.0, line);\n    }\n    \n    col = sRGB_EOTF(clamp01(col));\n    \n#else\n    \n    vec4 d2;\n    vec4 approx = SampleBicubic3(p, /*out*/ d2);\n    \n    if(uv0.x < iResolution.x*0.5)\n    {\n        col = normalize(vec3(-approx.xy*0.1, 1.0))*0.5+0.5;\n    }\n    else\n    {\n    \tcol = vec3(abs(d2.x + d2.y)*0.005);\n      //col = vec3(abs(d2.x + d2.y + d2.z + d2.w)*0.005);\n    }\n    \n#endif\n    \n\toutCol = vec4(col, 1.0);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.141593;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2 = Pi * 2.0;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 CosSin(float ang) {return vec2(cos(ang), sin(ang));}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat sRGB_EOTF(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nvec3 sRGB_EOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\nfloat cubic(float x) {return x*x*(3.-2.*x);}\nvec2  cubic(vec2  x) {return x*x*(3.-2.*x);}\nvec3  cubic(vec3  x) {return x*x*(3.-2.*x);}\nvec4  cubic(vec4  x) {return x*x*(3.-2.*x);}\n\nfloat quintic(float x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec2  quintic(vec2  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec3  quintic(vec3  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec4  quintic(vec4  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfBzX.jpg", "access": "api", "license": "cc0-1.0", "functions": [[8173, 8173, 8196, 8196, 8231], [8232, 8232, 8255, 8255, 8295], [8297, 8297, 8322, 8322, 8351], [8352, 8352, 8377, 8377, 8417], [8419, 8419, 8444, 8444, 8474], [8475, 8475, 8500, 8500, 8543], [8546, 8546, 8565, 8565, 8740], [8742, 8742, 8764, 8764, 9403], [9405, 9405, 9453, 9453, 10597], [10600, 10600, 10620, 10620, 10958], [12005, 12005, 12034, 12034, 12299], [12301, 12301, 12330, 12330, 12599], [12601, 12601, 12643, 12643, 12993], [12995, 12995, 13043, 13043, 14352]], "test": "untested"}
{"id": "wlsBz2", "name": "C2-interpolating cubic Kernel", "author": "TinyTexel", "description": "The red curve is the unique C2-interpolating convolution kernel build from equally sized cubic pieces. \nred  : function value\nblue : 1st derivative (scaled)\ngreen: 2nd derivative (scaled)\n(light grey: normalized sinc)", "tags": ["filter", "filtering", "convolution", "cubic", "interpolation", "continuous", "reconstruction", "c2"], "likes": 7, "viewed": 444, "published": 3, "date": "1597363180", "time_retrieved": "2024-07-30T20:50:57.966930", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n\nThe red curve is the unique C2-interpolating convolution kernel build from equally sized cubic pieces. \nThe discrete kernel we get by evaluating its derivative (blue) at all integers allows us to compute C1 continuous derivatives from a\ndiscrete signal with equidistant samples. Therefore a piecewise cubic C2 continuous signal can be reconstructed from a \ngiven set of sample values and derivatives if the derivatives where computed from the sample values using the blue kernel.\n    \nUniquely mapping function values to derivatives this way does however mean that we lose the ability to represent signals of \ntwice the usual Nyquist frequency (which freely choosing the derivatives otherwise enables us to do).\n    \nOne interesting computer graphics related application for this kernel is terrain rendering where C1 discontinuities \nin the gradient of the reconstructed height field can manifest itself as visual artifacts in the shading.\n\n\nI originally derived this kernel on my own but afterwards discovered that (unsurprisingly) I was not the first one to do so.\n     \nMatt Timmermans has a very elegant and compact derivation + demo here:\nhttps://github.com/mtimmerm/IPythonNotebooks/blob/master/NaturalCubicSplines.ipynb\n   \nOn stackexchange Matt links to another derivation from 1971: \nhttps://projecteuclid.org/download/pdf_1/euclid.bams/1183533186 - ON EQUIDISTANT CUBIC SPLINE INTERPOLATION by I.J.Schoenberg\n(https://math.stackexchange.com/questions/1627074/is-there-a-name-for-this-piecewise-cubic-interpolation-kernel) \n\nI actually used a very similar approach to that of Schoenberg namely expressing the result as \nthe weighted sum of an infinite number of cubic BSplines which are itself already C2 continuous. \nI however failed to find a way to determine the formulas for the first and second order derivatives directly. \nWhat I ended up doing was fitting a partial sum to a larger number of data points. \nLooking at the resulting derivatives it seemed very likely that they follow an exponential decay. So I used that as my model. \nI found the free parameters by fitting the necessary number of data points and \nretroactively proved that the result is valid everywhere.\n\n\nRelated:\n- https://www.shadertoy.com/view/WtsBDH | practical application\n\n*/\n\nvec3 Curves(float x)\n{\n    float sn = x < 0.0 ? -1.0 : 1.0;\n    \n    x = abs(x);\n    \n    float x0 = floor(x);\n    \n    x = fract(x);\n    \n    float sgn = fract(x0 * 0.5) == 0.0 ? 1.0 : -1.0;\n    \n    // the derivatives at the start and end of the segment\n    vec2 d = vec2(sgn, -sgn) * 3.0 * exp2(-vec2(x0, x0 + 1.0) * log2(2.0 + sqrt(3.0)));\n        \n    vec2 y = vec2(0.0);\n    \n    if(x0 == 0.0)\n    {\n        y.x = 1.0;\n        d.x = 0.0;\n    }\n    \n    float a = y.x;\n    float b = d.x;\n    float c = -2.0*d.x-d.y+3.0*(-y.x+y.y);\n    float e = d.x+d.y+2.0*(y.x-y.y);\n    \n    float f0 = (a + x * (b + x * (    c + x *      e)));\n    float f1 =           b + x * (2.0*c + x * (3.0*e));\n    float f2 =                    2.0*c + x * (6.0*e);\n    \n    return vec3(f0, sn * f1, f2);    \n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += 0.0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.y * 0.5;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.5;\n    \n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    \n    col = mix(col, vec3(0.0, 0.0, 0.0), Graph(sin(tex.x*Pi)/(tex.x*Pi) - tex.y, 3.0)*0.125);\n    \n    col = mix(col, vec3(0.0, 1.0, 0.0), Graph(Curves(tex.x).z*0.2 - tex.y, 0.5)*0.5);       \n    col = mix(col, vec3(0.0, 0.5, 1.0), Graph(Curves(tex.x).y*0.5 - tex.y, 0.5));       \n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(Curves(tex.x).x - tex.y, 0.5)); \n    \n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}", "image_inputs": [], "common_code": "\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsBz2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[2342, 2342, 2364, 2364, 3132], [3134, 3134, 3182, 3182, 4152]], "test": "untested"}
{"id": "WtsBzf", "name": "Aeriel Flux", "author": "iRyanBell", "description": "Based on Aeriel Machina https://fractalforums.org/share-a-fractal/22/df-mandelbox-variation/3547\n\nView on Cineshader @ https://www.cineshader.com/view/WtsBzf", "tags": ["cineshader"], "likes": 12, "viewed": 27486, "published": 3, "date": "1597338350", "time_retrieved": "2024-07-30T20:50:58.740862", "image_code": "float map(vec3 z0)\n{\n    float T = cos(iTime*0.002)+0.33;\n    float T2 = cos(iTime*0.015)+0.25;\n    vec4 z = vec4(z0,0.05);\n    \n    for (int n = 0; n < 8; n++) {\n        z.xyz=clamp(z.xyz, -T*T2, T*T2)*2.0-z.xyz;\n        z*=(T-0.25)/max(dot(z.xyz, z.xyz), 0.02*(T+T2));\n    }\n    return length(max(abs(z.xyz)-vec3(0.0,1.0,0.0),0.0))/z.w;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = sin(iTime*0.05)-1.0;\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0)*(1.0-T)*1024.0, 0.0);\n\tvec3 rayDir = vec3(0.0, 0.0, 0.001);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 10; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-7) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    float c = 1.0-pow(depth*0.0005, 0.75);\n    fragColor = vec4(c*2.0,c*0.125,c*0.125,1.0-depth*0.00001);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Aeriel Flux\",\n\t\"description\": \"Intersection plane into a mandelbox-like structure\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 340], [343, 343, 400, 400, 896]], "test": "untested"}
{"id": "WtsfRf", "name": "art 4 art 2 cos", "author": "zeichlicht", "description": ".... this shader has been modified ...  the original shader can be found here :::\n\nCreation by Silexars :::  https://www.shadertoy.com/view/XsXXDn \n", "tags": ["zeichlicht"], "likes": 3, "viewed": 337, "published": 3, "date": "1597336433", "time_retrieved": "2024-07-30T20:50:59.584604", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n//.... this shader has been modified ...  the original shader can be found here :::\n// Creation by Silexars :::  https://www.shadertoy.com/view/XsXXDn \n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.05;\n\t\tl=length(p);\n       // l*=l;\n\t\tuv+=p/l*cos(cos(z)+1.)*abs(cos(l*9.-z*2.));\n         l=pow(l,.001);\n\t\tc[i]=.01/length(abs(mod(uv,1.)-.5));\n\t}\n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[321, 321, 377, 377, 664]], "test": "untested"}
{"id": "wtXfRX", "name": "Real-time global illumination", "author": "nlight", "description": "Real-time global illumination via Monte Carlo path tracing with Spatiotemporal Variance-Guided Filtering.\n\nUse the mouse and WASD (or arrow keys) to move the camera.\n\nWork in progress.\n\n\"Raytracing is not slow, computers are.\" ~ Kajiya\n", "tags": ["gi", "pathtracing"], "likes": 52, "viewed": 2890, "published": 3, "date": "1597279816", "time_retrieved": "2024-07-30T20:51:00.668706", "image_code": "// Copyright 2020 Alexander Dzhoganov\n//\n// MIT License\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n/*\n *\n * Real-time global illumination via Monte Carlo path tracing\n * with Spatiotemporal Variance-Guided Filtering.\n *\n * >>>\n * >>> Use the mouse and WASD (or arrow keys) to move the camera.\n * >>>\n *\n * You can increase or decrease the quality (and performance) by changing\n * NUM_SAMPLES in Buffer A. HISTORY_BLEND_FACTOR in Buffer C controls the\n * trade-off between ghosting and noise.\n *\n * The code is pretty well commented and hopefully easy to read.\n * Various quality trade-offs were made due to the very thin gbuffer layout and\n * not enough buffers.\n *\n * > Spatiotemporal Variance-Guided Filtering:\n *\n * Dundr 2018, \"Progressive Spatiotemporal Variance-Guided Filtering\"\n * https://pdfs.semanticscholar.org/a81a/4eed7f303f7e7f3ca1914ccab66351ce662b.pdf\n *\n * NVIDIA 2017, \"Spatiotemporal Variance-Guided Filtering: Real-Time\n * Reconstruction for Path-Traced Global Illumination\"\n * https://cg.ivd.kit.edu/publications/2017/svgf/svgf_preprint.pdf\n *\n * Dammertz, Sewtz, Hanika, Lensch 2010, \"Edge-Avoiding À-Trous Wavelet\n * Transform for fast Global Illumination Filtering\"\n * https://jo.dreggn.org/home/2010_atrous.pdf\n *\n * > Pseudorandom number generation for Monte Carlo integration:\n *\n * GPU Gems 3, \"Efficient Random Number Generation and Application Using CUDA\"\n * https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-37-efficient-random-number-generation-and-application\n *\n * > Branchless construction of an orthonormal basis:\n *\n * Pixar 2017, \"Building an Orthonormal Basis, Revisited\"\n * https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n *\n */\n\n// different debug view modes\n#define DEBUG_MODE 0\n// 0 - debug off\n// 1 - albedo\n// 2 - normals\n// 3 - depth\n// 4 - irradiance\n// 5 - variance\n// 6 - age\n\nbool debugDrawGbuffer(GBuffer gbuf, out vec4 fragColor) {\n  switch (DEBUG_MODE) {\n  case 1: // albedo\n    fragColor = vec4(gbuf.albedo, 1.0);\n    break;\n  case 2: // normals\n    fragColor = vec4(vec3(gbuf.normal * 0.5 + 0.5), 1.0);\n    break;\n  case 3: // depth\n    fragColor = vec4(vec3(gbuf.depth * 0.01), 1.0);\n    break;\n  case 4: // radiance\n    fragColor = vec4(vec3(pow(gbuf.radiance, 1.0 / 2.2)), 1.0);\n    break;\n  case 5: // variance\n    fragColor = vec4(vec3(gbuf.variance), 1.0);\n    break;\n  case 6: // age\n    fragColor = vec4(vec3(gbuf.age), 1.0);\n    break;\n  }\n\n  return DEBUG_MODE != 0;\n}\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // fourth filtering pass (step size = 8)\n  GBuffer g = psvgf(iChannel0, ivec2(fragCoord), 8);\n\n  // if any debug mode is active draw it and bail\n  if (debugDrawGbuffer(g, fragColor)) {\n    return;\n  }\n\n  // calculate the final color value of the pixel\n  vec3 color = g.albedo * g.radiance;\n\n  // hack to avoid showing first frame artifacts\n  if (iFrame == 0) {\n    color = vec3(0.0);\n  }\n\n  // tonemapping\n  color = aces(color);\n\n  // gamma correction\n  color = pow(color, vec3(1.0 / 2.2));\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float MOUSE_SENSITIVITY = 0.15; // mouse sensitivity\nconst uint NUM_SAMPLES = 16u; // number of traced paths per pixel per frame\nconst uint MAX_BOUNCES = 2u;  // max number of bounces per path\n\n// Ray-sphere intersection.\nfloat intersectRaySphere(vec3 ro, vec3 rd, vec3 sp, float rsq) {\n  vec3 n = ro - sp;\n  float a = dot(rd, rd);\n  float b = 2.0 * dot(rd, n);\n  float c = dot(n, n) - rsq;\n  float d = b * b - 4.0 * a * c;\n  return d < 0.0 ? -1.0 : (-b - sqrt(d)) / 2.0 * a;\n}\n\n// Ray-plane intersection.\nfloat intersectRayPlane(vec3 ro, vec3 rd, vec3 n, vec3 p) {\n  const float eps = 0.0001;\n  float denom = dot(rd, n);\n  return abs(denom) < eps ? -1.0 : dot(p - ro, n) / denom;\n}\n\n// Ray-triangle intersection.\n// https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm\nfloat intersectRayTri(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2) {\n  const float eps = 0.0000001;\n\n  vec3 e1 = v1 - v0;\n  vec3 e2 = v2 - v0;\n  vec3 h = cross(rd, e2);\n  float a = dot(e1, h);\n  if (a > -eps && a < eps) {\n    return -1.0;\n  }\n\n  float f = 1.0 / a;\n  vec3 s = ro - v0;\n  float u = f * dot(s, h);\n  if (u < 0.0 || u > 1.0) {\n    return -1.0;\n  }\n\n  vec3 q = cross(s, e1);\n  float v = f * dot(rd, q);\n  if (v < 0.0 || u + v > 1.0) {\n    return -1.0;\n  }\n\n  float t = f * dot(e2, q);\n  if (t < eps) {\n    return -1.0;\n  }\n\n  return t;\n}\n\n// Efficient PRNG.\n// https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-37-efficient-random-number-generation-and-application\n\nuvec4 rngState;\n\nuint tausStep(uint z, uint S1, uint S2, uint S3, uint M) {\n  uint b = ((z << S1) ^ z) >> S2;\n  return ((z & M) << S3) ^ b;\n}\n\nuint lcgStep(uint z, uint A, uint C) { return A * z + C; }\n\n// Returns a random number [0..1].\nfloat random() {\n  const float c = 2.3283064365387e-10;\n  rngState.x = tausStep(rngState.x, 13u, 19u, 12u, 4294967294u);\n  rngState.y = tausStep(rngState.y, 2u, 25u, 4u, 4294967288u);\n  rngState.z = tausStep(rngState.z, 3u, 11u, 17u, 4294967280u);\n  rngState.w = lcgStep(rngState.w, 1664525u, 1013904223u);\n  return saturate(c * float(rngState.x ^ rngState.y ^ rngState.z ^ rngState.w));\n}\n\nfloat hash(vec2 p) {\n  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) *\n               (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\n// Seeds the random number generator.\nvoid seedRng(vec4 seed) {\n  seed.x = hash(seed.xy);\n  seed.y = hash(seed.yz);\n  seed.z = hash(seed.zw);\n  seed.w = hash(seed.wx);\n\n  rngState = floatBitsToUint(seed);\n  rngState ^= (rngState << 13);\n  rngState ^= (rngState >> 17);\n  rngState ^= (rngState << 5);\n}\n\n// Branchless construction of an orthonormal basis.\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid orthonormalBasis(const vec3 n, out vec3 b1, out vec3 b2) {\n  float s = n.z >= 0.0 ? 1.0 : -1.0;\n  float a = -1.0 / (s + n.z);\n  float b = n.x * n.y * a;\n  b1 = vec3(1.0 + s * n.x * n.x * a, s * b, -s * n.x);\n  b2 = vec3(b, s + n.y * n.y * a, -n.y);\n}\n\n// Returns a random cosine-weighted unit vector on a hemisphere centered around\n// n.\nvec3 unitVectorOnHemisphere(vec3 n) {\n  float r = random();\n  float angle = random() * (2.0 * PI);\n  float sr = sqrt(r);\n  vec2 p = vec2(sr * cos(angle), sr * sin(angle));\n  vec3 ph = vec3(p.xy, sqrt(1.0 - dot(p, p)));\n\n  vec3 b1, b2;\n  orthonormalBasis(n, b1, b2);\n  return b1 * ph.x + b2 * ph.y + n * ph.z;\n}\n\nstruct Sphere {\n  vec3 position;\n  float radius;\n  vec4 color; // rgb - albedo, a - emissive\n};\n\nstruct Tri {\n  vec3 v0;\n  vec3 v1;\n  vec3 v2;\n  vec4 color;\n};\n\nconst vec4 white = vec4(1.0, 1.0, 1.0, 0.0);\nconst vec4 red = vec4(0.9, 0.15, 0.15, 0.0);\nconst vec4 green = vec4(0.15, 0.8, 0.05, 0.0);\nconst vec4 blue = vec4(0.15, 0.3, 0.95, 0.0);\nconst vec4 pink = vec4(0.95, 0.71, 0.75, 0.0);\nconst vec4 orange = vec4(0.95, 0.85, 0.05, 0.0);\n\nconst Tri[] sceneTris = Tri[](\n    Tri(vec3(55.28, 0, 0), vec3(0, 0, 0), vec3(0, 0, 55.92), white),\n    Tri(vec3(55.28, 0, 0), vec3(0., 0, 55.92), vec3(54.96, 0, 55.92), white),\n    Tri(vec3(54.96, 0, 55.92), vec3(0., 0, 55.92), vec3(0, 54.88, 55.92),\n        white),\n    Tri(vec3(54.96, 0, 55.92), vec3(0, 54.88, 55.92), vec3(55.60, 54.88, 55.92),\n        white),\n    Tri(vec3(55.28, 0, 0), vec3(54.96, 0, 55.92), vec3(55.60, 54.88, 55.92),\n        red),\n    Tri(vec3(55.28, 0, 0), vec3(55.60, 54.88, 55.92), vec3(55.60, 54.88, 0),\n        red),\n    Tri(vec3(0, 0, 55.92), vec3(0, 0, 0), vec3(0, 54.88, 0), green),\n    Tri(vec3(0, 0, 55.92), vec3(0, 54.88, 0), vec3(0, 54.88, 55.92), green),\n    Tri(vec3(55.60, 54.88, 0), vec3(55.60, 54.88, 55.92), vec3(0, 54.88, 55.92),\n        white),\n    Tri(vec3(55.60, 54.88, 0), vec3(0, 54.88, 55.92), vec3(0, 54.88, 0),\n        white));\n\nconst Sphere[] sceneSpheres =\n    Sphere[](Sphere(vec3(42.0, 40.0, 30.5), 7.5, // red ball\n                    red),\n             Sphere(vec3(5.6, 15.0, 20.0), 5.5, // orange ball\n                    orange),\n             Sphere(vec3(40.0, 6.0, 35.0), 6.0, // pink ball\n                    pink),\n             Sphere(vec3(12.0, 32.0, 45.0), 5.5, // green ball\n                    green),\n             Sphere(vec3(22.0, 8.0, 25.0), 5.5, // blue ball\n                    blue),\n             Sphere(vec3(35.0, 22.0, 30.0), 8.0, // white ball 1\n                    vec4(1.0, 1.0, 1.0, 3.5)),\n             Sphere(vec3(15.0, 40.0, 50.0), 4.0, // white ball 2\n                    vec4(1.0, 1.0, 1.0, 2.5)));\n\n// Traces a ray (ro, rd) through the scene and returns the hit distance, normal\n// and color.\nfloat traceSceneRay(vec3 ro, vec3 rd, out vec3 normal, out vec4 color) {\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  float minT = 1e10;\n  color = vec4(1.0, 1.0, 1.0, 0.0);\n\n  for (int i = 0; i < sceneSpheres.length(); i++) {\n    Sphere sphere = sceneSpheres[i];\n    vec3 p = sphere.position;\n    float r2 = sphere.radius * sphere.radius;\n    float t = intersectRaySphere(ro, rd, p, r2);\n    if (t > 0.0 && t < minT) {\n      normal = (ro + rd * t) - p;\n      color = sphere.color;\n      minT = t;\n    }\n  }\n\n  for (int i = 0; i < sceneTris.length(); i++) {\n    Tri tri = sceneTris[i];\n    float t = intersectRayTri(ro, rd, tri.v0, tri.v1, tri.v2);\n    if (t > 0.0 && t < minT) {\n      normal = normalize(cross(tri.v1 - tri.v0, tri.v2 - tri.v0));\n      color = tri.color;\n      minT = t;\n    }\n  }\n\n  return minT;\n}\n\n// Traces multiple paths for a primary ray and returns the blended result.\nGBuffer tracePrimaryRay(vec3 ro, vec3 rd) {\n  GBuffer gbuf;\n\n  vec3 normal0;\n  vec4 color;\n  // get the depth, normal and color for this ray\n  float depth = traceSceneRay(ro, rd, normal0, color);\n  normal0 = normalize(normal0);\n\n  float emissive = color.a;\n\n  // fill the gbuffer with the material data\n  gbuf.albedo = color.rgb;\n  gbuf.depth = depth;\n  gbuf.normal = normal0;\n\n  // move the ray to the hit point\n  ro += rd * depth;\n  // slightly displace by the normal to prevent self-intersection\n  ro += normal0 * 0.00001;\n\n  vec3 ro0 = ro;\n\n  // radiance sum for this pixel\n  float radiance = 0.0;\n\n  // radiance squared sum for this pixel\n  // used later on for variance estimation\n  float radiance2 = 0.0;\n\n  for (uint q = UZERO; q < NUM_SAMPLES; q++) {\n    // get a random direction on the hemisphere around the normal\n    ro = ro0;\n    rd = unitVectorOnHemisphere(normal0);\n\n    // radiance sum for the current path\n    float r = 0.0;\n\n    // keep bouncing and gathering light\n    for (uint i = UZERO; i < MAX_BOUNCES; i++) {\n      vec3 normal;\n      depth = traceSceneRay(ro, rd, normal, color);\n      if (depth > 100.0) {\n        break;\n      }\n\n      // gather whatever we hit\n      r += color.a;\n\n      // calculate the ray for the next bounce\n      normal = normalize(normal);\n      ro += rd * depth;\n      ro += normal * 0.00001;\n      rd = unitVectorOnHemisphere(normal);\n    }\n\n    // add to the total radiance\n    radiance += r;\n    radiance2 += r * r;\n  }\n\n  radiance /= float(NUM_SAMPLES);\n  radiance2 /= float(NUM_SAMPLES);\n\n  // variance = sum(x^2) - sum(x)^2\n  gbuf.variance = radiance2 - radiance * radiance;\n  gbuf.radiance = radiance + emissive;\n\n  return gbuf;\n}\n\n#define KEY_A 65\n#define KEY_D 68\n#define KEY_S 83\n#define KEY_W 87\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\nbool isKeyDown(int key) {\n  return texelFetch(iChannel1, ivec2(key, 0), 0).x != 0.0;\n}\n\n// Updates the camera according to user inputs.\nvoid updateCamera(inout CameraData camera, mat4 cameraMatrix) {\n  if (iFrame == 0) {\n    camera.position = vec3(27.8, 27.3, -100.0);\n    camera.pitchYaw = vec2(0.0, PI);\n    camera.prevMouse = iMouse.xy;\n  }\n\n  vec3 camFwd = (cameraMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\n  vec3 camRight = (cameraMatrix * vec4(1.0, 0.0, 0.0, 0.0)).xyz;\n  float moveSpeed = 16.0 * iTimeDelta;\n\n  if (isKeyDown(KEY_W) || isKeyDown(KEY_UP)) {\n    camera.position += camFwd * moveSpeed;\n  }\n  if (isKeyDown(KEY_S) || isKeyDown(KEY_DOWN)) {\n    camera.position -= camFwd * moveSpeed;\n  }\n  if (isKeyDown(KEY_A) || isKeyDown(KEY_LEFT)) {\n    camera.position -= camRight * moveSpeed;\n  }\n  if (isKeyDown(KEY_D) || isKeyDown(KEY_RIGHT)) {\n    camera.position += camRight * moveSpeed;\n  }\n\n  vec2 mouseDelta = iMouse.xy - camera.prevMouse;\n  mouseDelta = clamp(mouseDelta, -7.0, 7.0);\n  mouseDelta.x *= -1.0;\n  camera.pitchYaw -= mouseDelta.yx * iTimeDelta * MOUSE_SENSITIVITY;\n  camera.pitchYaw.x = clamp(camera.pitchYaw.x, -PI, PI);\n  camera.prevMouse = iMouse.xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // seed the rng\n  seedRng(vec4(fragCoord.xy, iFrame, iTime));\n\n  // fetch the camera data\n  vec4 cameraDataRaw = texelFetch(iChannel0, ivec2(0, 0), 0);\n  CameraData camera = unpackCameraData(cameraDataRaw);\n  mat4 cameraMatrix = getInvViewMatrix(camera);\n\n  if (uint(fragCoord.x) == 0u && uint(fragCoord.y) == 0u) {\n    // update the camera and store the updated data\n    updateCamera(camera, cameraMatrix);\n    fragColor = packCameraData(camera);\n    return;\n  } else if (uint(fragCoord.x) == 1u && uint(fragCoord.y) == 0u) {\n    // store previous frame's camera (used later on)\n    fragColor = cameraDataRaw;\n    return;\n  }\n\n  // get the camera ray for this pixel\n  vec3 ro = camera.position;\n  vec3 rd = rayDirection(55.0, iResolution.xy, fragCoord);\n  rd = (cameraMatrix * vec4(rd, 0.0)).xyz;\n\n  // trace the ray\n  GBuffer gbuf = tracePrimaryRay(ro, rd);\n\n  // store the result\n  fragColor = packGBuffer(gbuf);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nconst float HISTORY_BLEND_FACTOR = 0.05;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // first filtering pass (step size = 1)\n  GBuffer g = psvgf(iChannel0, ivec2(fragCoord), 1);\n\n  // recreate the ray for this pixel from the camera data\n  CameraData camera = unpackCameraData(texelFetch(iChannel0, ivec2(0, 0), 0));\n  mat4 cameraMatrix = getInvViewMatrix(camera);\n  vec3 ro = camera.position;\n  vec3 rd = rayDirection(55.0, iResolution.xy, fragCoord);\n  rd = (cameraMatrix * vec4(rd, 0.0)).xyz;\n\n  // fetch the camera data from the previous frame\n  // we'll use it to reproject the pixel onto the history buffer\n  CameraData prevCamera =\n      unpackCameraData(texelFetch(iChannel0, ivec2(1, 0), 0));\n\n  // view matrix from previous frame\n  mat4 prevView = getViewMatrix(prevCamera);\n\n  // projection matrix from previous frame\n  mat4 prevProj = getProjMatrix(55.0, iResolution.xy, 1.0, 2.0);\n\n  // reconstruct world-space position from ray and depth\n  vec3 worldPos = ro + rd * g.depth;\n\n  // project world-space position to screen-space\n  vec3 projPos = project2Screen(prevView, prevProj, worldPos);\n\n  // fetch the reprojected pixel from history\n  GBuffer prevG = unpackGBuffer(\n      texelFetch(iChannel1, ivec2(projPos.xy * iResolution.xy), 0));\n\n  // bounds check\n  bvec4 inside = bvec4(projPos.x >= 0.0, projPos.y >= 0.0,\n                       projPos.x <= iResolution.x, projPos.y <= iResolution.y);\n\n  // if in bounds and not the first frame blend between the current frame and\n  // history buffer (section 4.2 from \"Progressive Spatiotemporal\n  // Variance-Guided Filtering\")\n  if (all(inside) && iFrame != 0) {\n    const float disocclusionFrames = 10.0;\n    const float disocclusionFactor = 5.0;\n\n    float disocclusion = abs(g.depth - prevG.depth);\n    if (disocclusion < disocclusionFactor) {\n      // increment the pixel's age\n      g.age = saturate(prevG.age + 1.0 / disocclusionFrames);\n\n      // r = blending factor\n      float r = max(HISTORY_BLEND_FACTOR, saturate(1.0 - g.age));\n\n      // mix the radiance and variance according to r\n      g.radiance = mix(prevG.radiance, g.radiance, r);\n      g.variance = mix(prevG.variance, g.variance, r);\n    } else {\n      // discard history value on disocclusion\n      g.age = 0.0;\n    }\n  } else {\n    g.age = 0.0;\n  }\n\n  fragColor = packGBuffer(g);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Second filtering pass (step size = 2)\n// See the psvgf() function in Common.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  GBuffer g = psvgf(iChannel0, ivec2(fragCoord), 2);\n  fragColor = packGBuffer(g);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Third filtering pass (step size = 4).\n// See the psvgf() function in Common.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  GBuffer g = psvgf(iChannel0, ivec2(fragCoord), 4);\n  fragColor = packGBuffer(g);\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// hack to prevent loop unrolling\n#define UZERO uint(min(0, iFrame))\n\n#ifndef saturate\n#define saturate(X) clamp(X, 0.0, 1.0)\n#endif\n\n#define PI 3.14159265359\n\n// [0..1] float to byte\nuint f2b(float value) { return uint(saturate(value) * 255.0) & 0xFFu; }\n// byte to [0..1] float\nfloat b2f(uint value) { return float(value & 0xFFu) * (1.0 / 255.0); }\n\n// 128-bit gbuffer\n//\n// albedo r (8), albedo g (8), albedo b (8), unused (8)\n// normal x (8), normal y (8), normal z (8), age (8)\n// depth (16), variance (16)\n// radiance (32)\n//\nstruct GBuffer {\n  vec3 albedo;\n  float radiance;\n  vec3 normal;\n  float depth;\n  float variance;\n  float age;\n};\n\n// Pack the GBuffer struct into a vec4.\nvec4 packGBuffer(GBuffer gbuf) {\n  uvec4 p;\n  p.x = f2b(gbuf.albedo.r) | f2b(gbuf.albedo.g) << 8 | f2b(gbuf.albedo.b) << 16;\n  vec3 normal = (gbuf.normal + 1.0) * 0.5;\n  p.y = f2b(normal.x) | f2b(normal.y) << 8 | f2b(normal.z) << 16 |\n        f2b(gbuf.age) << 24;\n  p.z = packHalf2x16(vec2(gbuf.depth, gbuf.variance));\n  p.w = floatBitsToUint(gbuf.radiance);\n  return uintBitsToFloat(p);\n}\n\n// Unpack the GBuffer struct from a vec4.\nGBuffer unpackGBuffer(vec4 packed) {\n  uvec4 p = floatBitsToUint(packed);\n\n  GBuffer gbuf;\n  gbuf.albedo.r = b2f(p.x);\n  gbuf.albedo.g = b2f(p.x >> 8);\n  gbuf.albedo.b = b2f(p.x >> 16);\n  gbuf.normal.x = b2f(p.y);\n  gbuf.normal.y = b2f(p.y >> 8);\n  gbuf.normal.z = b2f(p.y >> 16);\n  gbuf.normal = normalize(gbuf.normal * 2.0 - 1.0);\n  gbuf.age = b2f(p.y >> 24);\n  vec2 tmp = unpackHalf2x16(p.z);\n  gbuf.depth = tmp.x;\n  gbuf.variance = tmp.y;\n  gbuf.radiance = uintBitsToFloat(p.w);\n  return gbuf;\n}\n\n// Sample a gbuffer texture.\nGBuffer sampleGBuffer(sampler2D tex, ivec2 uv) {\n  return unpackGBuffer(texelFetch(tex, uv, 0));\n}\n\n// Creates a 4x4 rotation matrix given an axis and and an angle.\nmat4 rotationMatrix(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n      oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,\n      oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,\n      oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n      oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s,\n      oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\n// Camera parameters.\nstruct CameraData {\n  vec3 position;\n  vec2 pitchYaw;\n  vec2 prevMouse;\n};\n\n// Pack the CameraData struct into a vec4.\nvec4 packCameraData(CameraData camera) {\n  uvec4 packed;\n  packed.x = packHalf2x16(camera.position.xy);\n  packed.y = packHalf2x16(vec2(camera.position.z));\n  packed.z = packHalf2x16(camera.pitchYaw);\n  packed.w = packHalf2x16(camera.prevMouse);\n  return uintBitsToFloat(packed);\n}\n\n// Unpack the CameraData struct from a vec4.\nCameraData unpackCameraData(vec4 packed) {\n  uvec4 p = floatBitsToUint(packed);\n\n  CameraData camera;\n  camera.position.xy = unpackHalf2x16(p.x);\n  camera.position.z = unpackHalf2x16(p.y).x;\n  camera.pitchYaw = unpackHalf2x16(p.z);\n  camera.prevMouse = unpackHalf2x16(p.w);\n  return camera;\n}\n\n// Returns the inverse view matrix for a camera.\nmat4 getInvViewMatrix(CameraData camera) {\n  mat4 pitch = rotationMatrix(vec3(1.0, 0.0, 0.0), camera.pitchYaw.x);\n  mat4 yaw = rotationMatrix(vec3(0.0, 1.0, 0.0), camera.pitchYaw.y);\n  mat4 translate = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,\n                        0.0, camera.position, 1.0);\n\n  return yaw * pitch * translate;\n}\n\n// Returns the view matrix for a camera.\nmat4 getViewMatrix(CameraData camera) {\n  mat4 pitch = rotationMatrix(vec3(1.0, 0.0, 0.0), -camera.pitchYaw.x);\n  mat4 yaw = rotationMatrix(vec3(0.0, 1.0, 0.0), -camera.pitchYaw.y);\n  mat4 translate = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,\n                        0.0, -camera.position, 1.0);\n\n  return pitch * yaw * translate;\n}\n\n// Returns a perspective projection matrix.\nmat4 getProjMatrix(float fov, vec2 size, float near, float far) {\n  float fn = far + near;\n  float f_n = far - near;\n  float r = size.x / size.y;\n  float t = -1.0 / tan(radians(fov) * 0.5);\n\n  return mat4(t / r, 0.0, 0.0, 0.0, 0.0, t, 0.0, 0.0, 0.0, 0.0, fn / f_n, 1.0,\n              0.0, 0.0, (2.0 * far * near) / f_n, 0.0);\n}\n\n// Calculates the ray direction in view space for a pixel given the camera's\n// field of view and the screen size in pixels.\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {\n  vec2 xy = fragCoord - size * 0.5;\n  float z = size.y / tan(radians(fov) * 0.5);\n  return normalize(vec3(xy, -z));\n}\n\n// Projects a world-space position to screen-space given camera view and\n// projection matrices.\nvec3 project2Screen(const mat4 view, const mat4 proj, vec3 v) {\n  vec4 p = proj * (view * vec4(v, 1.0));\n  p /= p.w;\n  p.xy += 0.5;\n  p.z *= 2.0;\n  p.z -= 1.0;\n  return p.xyz;\n}\n\n// Normal-weighting function (4.4.1)\nfloat normalWeight(vec3 normal0, vec3 normal1) {\n  const float exponent = 64.0;\n  return pow(max(0.0, dot(normal0, normal1)), exponent);\n}\n\n// Depth-weighting function (4.4.2)\nfloat depthWeight(float depth0, float depth1, vec2 grad, vec2 offset) {\n  // paper uses eps = 0.005 for a normalized depth buffer\n  // ours is not but 0.1 seems to work fine\n  const float eps = 0.1;\n  return exp((-abs(depth0 - depth1)) / (abs(dot(grad, offset)) + eps));\n}\n\n// Luminance-weighting function (4.4.3)\nfloat luminanceWeight(float lum0, float lum1, float variance) {\n  const float strictness = 4.0;\n  const float eps = 0.01;\n  return exp((-abs(lum0 - lum1)) / (strictness * variance + eps));\n}\n\n// 3x3 kernel from \"Progressive Spatiotemporal Variance-Guided Filtering\"\n// different kernels could potentially give better results\nconst float psvgfKernel[] =\n    float[](0.0625, 0.125, 0.0625, 0.125, 0.25, 0.125, 0.0625, 0.125, 0.0625);\n\nfloat psvgfWeight(GBuffer g, GBuffer s, vec2 dgrad, ivec2 offset,\n                  int stepSize) {\n  // calculate the normal, depth and luminance weights\n  float nw = normalWeight(g.normal, s.normal);\n  float dw = depthWeight(g.depth, s.depth, dgrad, vec2(offset));\n  float lw = luminanceWeight(g.radiance, s.radiance, g.variance);\n\n  // combine them with the kernel value\n  return saturate(nw * dw * lw) *\n         psvgfKernel[(offset.x / stepSize + 1) + (offset.y / stepSize + 1) * 3];\n}\n\n// The next function implements the filtering method described in the two papers\n// linked below.\n//\n// \"Progressive Spatiotemporal Variance-Guided Filtering\"\n// https://pdfs.semanticscholar.org/a81a/4eed7f303f7e7f3ca1914ccab66351ce662b.pdf\n//\n// \"Edge-Avoiding À-Trous Wavelet Transform for fast Global Illumination\n// Filtering\" https://jo.dreggn.org/home/2010_atrous.pdf\n//\nGBuffer psvgf(sampler2D buf, ivec2 uv, int stepSize) {\n  GBuffer g = sampleGBuffer(buf, uv);\n\n  // depth-gradient estimation from screen-space derivatives\n  vec2 dgrad = vec2(dFdx(g.depth), dFdy(g.depth));\n\n  ivec3 d = ivec3(-1, 0, 1) * stepSize;\n\n  vec4 s00 = texelFetch(buf, uv + d.xx, 0);\n  vec4 s01 = texelFetch(buf, uv + d.xy, 0);\n  vec4 s02 = texelFetch(buf, uv + d.xz, 0);\n  vec4 s10 = texelFetch(buf, uv + d.yx, 0);\n  vec4 s12 = texelFetch(buf, uv + d.yz, 0);\n  vec4 s20 = texelFetch(buf, uv + d.zx, 0);\n  vec4 s21 = texelFetch(buf, uv + d.zy, 0);\n  vec4 s22 = texelFetch(buf, uv + d.zz, 0);\n\n  // blur the variance\n  float variance = 0.0;\n  variance += unpackHalf2x16(floatBitsToUint(s00.z)).y * psvgfKernel[0];\n  variance += unpackHalf2x16(floatBitsToUint(s01.z)).y * psvgfKernel[1];\n  variance += unpackHalf2x16(floatBitsToUint(s02.z)).y * psvgfKernel[2];\n  variance += unpackHalf2x16(floatBitsToUint(s10.z)).y * psvgfKernel[3];\n  variance += g.variance * psvgfKernel[4];\n  variance += unpackHalf2x16(floatBitsToUint(s12.z)).y * psvgfKernel[5];\n  variance += unpackHalf2x16(floatBitsToUint(s20.z)).y * psvgfKernel[6];\n  variance += unpackHalf2x16(floatBitsToUint(s21.z)).y * psvgfKernel[7];\n  variance += unpackHalf2x16(floatBitsToUint(s22.z)).y * psvgfKernel[8];\n  g.variance = variance;\n\n  // filtered radiance\n  float radiance = 0.0;\n\n  // weights sum\n  float wsum = 0.0;\n\n  GBuffer s = unpackGBuffer(s00);\n  float w = psvgfWeight(g, s, dgrad, d.xx, stepSize);\n  radiance += s.radiance * w;\n  wsum += w;\n\n  s = unpackGBuffer(s01);\n  w = psvgfWeight(g, s, dgrad, d.xy, stepSize);\n  radiance += s.radiance * w;\n  wsum += w;\n\n  s = unpackGBuffer(s02);\n  w = psvgfWeight(g, s, dgrad, d.xz, stepSize);\n  radiance += s.radiance * w;\n  wsum += w;\n\n  s = unpackGBuffer(s10);\n  w = psvgfWeight(g, s, dgrad, d.yx, stepSize);\n  radiance += s.radiance * w;\n  wsum += w;\n\n  radiance += g.radiance * psvgfKernel[4];\n  wsum += psvgfKernel[4];\n\n  s = unpackGBuffer(s12);\n  w = psvgfWeight(g, s, dgrad, d.yz, stepSize);\n  radiance += s.radiance * w;\n  wsum += w;\n\n  s = unpackGBuffer(s20);\n  w = psvgfWeight(g, s, dgrad, d.zx, stepSize);\n  radiance += s.radiance * w;\n  wsum += w;\n\n  s = unpackGBuffer(s21);\n  w = psvgfWeight(g, s, dgrad, d.zy, stepSize);\n  radiance += s.radiance * w;\n  wsum += w;\n\n  s = unpackGBuffer(s22);\n  w = psvgfWeight(g, s, dgrad, d.zz, stepSize);\n  radiance += s.radiance * w;\n  wsum += w;\n\n  // scale total radiance by the sum of the weights\n  g.radiance = radiance / wsum;\n\n  return g;\n}\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXfRX.jpg", "access": "api", "license": "mit", "functions": [[2896, 2896, 2953, 2953, 3502], [3504, 3635, 3654, 3654, 3845], [3847, 3847, 3902, 3945, 4430]], "test": "untested"}
{"id": "tlfBRX", "name": "Fluid Pastel", "author": "rikmazz", "description": "Simple shader with some kind of fractal noise simulating a fluid-like motion. Also, I love flat colors.\nMouse x coordinate controls the speed of the motion. Mouse y coordinate controls the \"crispness\" of the wave.", "tags": ["fractal", "noise", "beginner", "fluid", "pastel"], "likes": 3, "viewed": 437, "published": 3, "date": "1597276135", "time_retrieved": "2024-07-30T20:51:01.560322", "image_code": "float plot(in vec2 _st, in float _blur, in float _f) {\n    float pct = step(-1.552, _st.y) - smoothstep(_f, _f+_blur/2., _st.y);\n    return pct;\n}\n\nfloat rand(in float _x) {\n    return fract(10000.*sin(_x));\n}\n\nfloat rand_step(in float _x) {\n    return rand(floor(_x));\n}\n\nfloat rand_interp_lin(in float _x) {\n    return mix(rand_step(_x-1.), rand_step(_x), fract(_x));\n}\n\nfloat noise(in float _x) {\n    return mix(rand_step(_x-1.), rand_step(_x), smoothstep(0.,1.,fract(_x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float blur = 0.01;\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\t\n    //rescale space coordinates\n    st.x = (st.x-0.812)*4.;\n    st.y *= 2.;\n    st.y -= 0.460;\n    \n    float timemul = iMouse.x/iResolution.x;\n    \n    float speed = 0.851*timemul;\n    float speed2 = 0.362*timemul;\n    float speed3 = 1.460*timemul;\n    float f = noise((st.x+iTime*speed));\n    float f2 = 0.5*noise(st.x/0.5);\n    float f3 = 0.25*noise((st.x+iTime*speed2)/0.25);\n    float f4 = 0.125*noise((st.x+iTime*speed3)/0.125);\n    vec3 color =vec3(255, 94, 87)/255.;\n    \n    vec3 bg_color = vec3(15, 188, 249)/255.;\n    float my = iMouse.y/iResolution.y;\n    float pct = plot(st, blur, (1.*f+(my+0.1)*f2+(my)*f3+(my)*f4)/(1.680)) ;\n\n    fragColor = pct*vec4(color,1.0) + (1.-pct)*vec4(bg_color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfBRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 146], [148, 148, 173, 173, 209], [211, 211, 241, 241, 271], [273, 273, 309, 309, 371], [373, 373, 399, 399, 479], [481, 481, 538, 538, 1357]], "test": "untested"}
{"id": "WtfBzf", "name": "Pseudo Random Bars", "author": "rikmazz", "description": "Basic excercise to experiment with randomness.", "tags": ["beginner", "random", "bars", "minimal"], "likes": 3, "viewed": 281, "published": 3, "date": "1597265857", "time_retrieved": "2024-07-30T20:51:02.343229", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.585);\n}\n\nfloat speed = 20.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 sc_f = vec2(300,floor(iMouse.y/10.));\n    \n    float aux = (iMouse.x/iResolution.x);\n\tfloat prob = (aux+0.1)/(1.1);\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    \n    st = st * sc_f;\n    \n    st.x += step(1., mod(st.y, 2.))*iTime*speed;\n    st.x += (1.-step(1., mod(st.y, 2.)))*-iTime*speed;\n    \n    vec2 icoord = floor(st);\n    vec2 fcoord = fract(st);\n\n    vec3 color = vec3(0.);\n    float rand1 = random(icoord)*random(icoord);\n    float rand2 = pow(random(icoord),5.);\n    color = step(1., mod(st.y, 2.))* vec3(floor(rand1+prob)) + (1.-step(1., mod(st.y, 2.)))*vec3(floor(rand2+prob));\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 70, 70, 173], [195, 195, 250, 250, 928]], "test": "untested"}
{"id": "WtXBzf", "name": "Pattern In Motion", "author": "rikmazz", "description": "Simple pattern looping animation for practicing glsl basics. ", "tags": ["beginner", "glsl", "motion", "pattern"], "likes": 3, "viewed": 375, "published": 3, "date": "1597264903", "time_retrieved": "2024-07-30T20:51:03.119154", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nfloat circle_outline(in vec2 _st, in float _radius, in float _thk, in float _blur){\n    vec2 dist = _st-vec2(0.5);\n    float pct = smoothstep(_radius-_thk/2.-(_blur),\n                         _radius-_thk/2.,\n                         dot(dist,dist)*5.128) - \n        \t\tsmoothstep(_radius+_thk/2.,\n                         _radius+_thk/2.+(_blur),\n                         dot(dist,dist)*5.128);\n\treturn pct;\n}\n\nfloat sc_f = 6.;\nfloat radius = 0.476;\nfloat thk = 0.006;\nfloat blur = 0.058;\n\nfloat speed = 0.448;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st *= sc_f;\n    \n    float time = speed * iTime;\n    st.x += step(1., mod(st.y, 2.))*2.*smoothstep(0.,1.,(fract(time)*step(0.,sin(time*PI))));\n    st.x += (1.-step(1., mod(st.y, 2.)))*-2.*smoothstep(0.,1.,(fract(time)*step(0.,sin(time*PI))));\n    st.y += step(1., mod(st.x, 2.))*2.*smoothstep(0., 1.,(fract(time)*step(0.,sin(time*PI-PI))));\n    st.y += (1.-step(1., mod(st.x, 2.)))*-2.*smoothstep(0., 1.,(fract(time)*step(0.,sin(time*PI-PI))));\n    st = fract(st);\n    \n    float pct = circle_outline(st, radius, thk, blur);\n\n    vec3 color = vec3(0.684,0.700,0.168);\n    vec3 bg_color = vec3(0.062,0.065,0.051);\n\n    fragColor = vec4(color,1.0) * pct + vec4(bg_color,1.0) * (1.-pct);\n    // gl_FragColor = vec4(st.x, st.y, 0.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 155, 155, 481], [584, 584, 641, 641, 1464]], "test": "untested"}
{"id": "WlXfRf", "name": "greenscreen-test-7318512", "author": "griffi", "description": "my first greenscreen shader", "tags": ["greenscreen"], "likes": 3, "viewed": 262, "published": 3, "date": "1597261245", "time_retrieved": "2024-07-30T20:51:03.884109", "image_code": "#define SENS .05\n\nfloat greenLvl(vec4 c){\n    float xs=c.x+c.z;\n    return (c.y-xs);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    vec4 c=vec4(texture(iChannel0,uv));\n    vec4 sc=c*vec4(texture(iChannel0,uv+.075));\n    \n    float g=greenLvl(c);\n    \n    if(g>=SENS||greenLvl(c+sc)>=SENS){\n        c=texture(iChannel1,uv);\n    }\n   \t\n    fragColor = c;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 41, 41, 86], [88, 88, 145, 145, 415]], "test": "untested"}
{"id": "3tXfRX", "name": "11. Drive Home 2 - Street Lights", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=tdwXMtnuuXg\nMy Onet Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["drivehome"], "likes": 2, "viewed": 277, "published": 3, "date": "1597254144", "time_retrieved": "2024-07-30T20:51:04.728850", "image_code": "\n#define S( a , b , t ) smoothstep( a , b , t )\n\nstruct Ray {\n\tvec3 ro;\t\t// Ray Origin\n    vec3 rd;\t\t// Ray Direction\n};\n\n// RAY\nRay GetRay( vec2 uv , vec3 camPos , float camZoom , vec3 lookAt ) {\n \n    Ray ray;\n     \n    ray.ro = camPos;\n    \n    vec3 F = normalize( lookAt - camPos );\n    vec3 R = normalize( cross( vec3( 0 , 1 , 0 ) , F ) );\n    vec3 U = cross( F , R );\n    \n    vec3 center  = camPos + F * camZoom;\n    vec3 intersectionPoint = center + uv.x * R  + uv.y * U;\n    \n    // rd have to do normalized.\n    // because where GetClosestPoint() , dot ( target - ro , rd ) * rd.\n    ray.rd = normalize( intersectionPoint - camPos );\n    \n    return ray;\n}\n\n\n// \nvec3 GetClosestPoint( Ray ray , vec3 targetPos ) {\n   \n    // 이때 반드시, rd가 노멀라이즈 되어 있어야,\n    // dot( targetPos - ray.ro , ray.rd )가 정확하게 계산이 된다.\n    return ray.ro + max( 0.0f , dot( targetPos - ray.ro , ray.rd ) ) * ray.rd;\n}\n\n\n// \nfloat GetDistance( Ray ray , vec3 targetPos ) {\n\tfloat d = length( targetPos - GetClosestPoint( ray , targetPos ) );\n    return d;\n}\n\n\n// BOKE\nfloat Boke( float d , float lightDiameter , float blur ) {\n\t\n      \n\tfloat c = S( lightDiameter , lightDiameter * ( 1.0f - blur ) , d );\n    c *= mix( 0.7f , 1.0f , S( lightDiameter * 0.8f , lightDiameter , d ) );\n    return c;\n}\n\nfloat Noise(float t) {\n    float n;\n\n    n = sin( t + 2379. ) ;\n    \n    return n;\n}\n\n// Street Light\nfloat StreetLight( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n    float c = 0.0f;\n    \n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    float side = step( ray.rd.x , 0.0f );\n    ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t\n        float ti = fract(t + i + side * s * 0.5f );\n        vec3 targetPos = vec3( 2.0f , 2.0f , 100.0f - ti * 100.0f );\n    \tfloat d = GetDistance( ray , targetPos );\n    \t\n        //lightDiameter *= length( targetPos );\n\n        float expandLight = lightDiameter * length( targetPos );\n        c += Boke( d , expandLight , bokeBlur ) * ti * ti * ti;\n    }\n    \n    return c;\n}\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5f * iResolution.xy) / min( iResolution.x, iResolution.y);\n    \n\n\tvec3 camPos = vec3( 0 , 0.2f , 0.0f );\n    vec3 lookAt = vec3( 0 , 0.2f , 1.0f );\n    float camZoom = 2.0f;\n    \n    \n    float lightDiameter = 0.05f;\n    float bokeBlur = 0.1f;\n    \n    \n    Ray ray = GetRay( uv , camPos , camZoom , lookAt );\n\n\tfloat c = StreetLight( ray , lightDiameter , bokeBlur, iTime );\n    \n    \n    \n    vec3 col = vec3( 1.0f , 0.7f , 0.3f) * c;\n    fragColor = vec4( col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 129, 196, 196, 666], [669, 673, 723, 868, 949], [952, 956, 1003, 1003, 1088], [1091, 1099, 1157, 1157, 1328], [1330, 1330, 1352, 1352, 1414], [1416, 1432, 1513, 1513, 2144], [2146, 2154, 2211, 2211, 2717]], "test": "untested"}
{"id": "WtfBzX", "name": "[TWITCH] DNA tracer", "author": "evvvvil", "description": "DNA tracer - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["demoscene", "landscape", "beam", "glow", "organic", "helix", "race", "dna", "flash", "dark", "network", "fly"], "likes": 24, "viewed": 1170, "published": 3, "date": "1597252618", "time_retrieved": "2024-07-30T20:51:05.495799", "image_code": "// DNA tracer - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tnoi,tt,b,bb,anim,animInv,g,gg;vec3 np,bp,pp,op,po,no,al,ld;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r; return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin( float d1, float d2, float k ){  float h = max(k-abs(d1-d2),0.0);return min(d1,d2)-h*h*0.25/k; }\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25; //MERCURTY SDF LIBRARY IS HERE OFF COURSE: http://mercury.sexy/hg_sdf/\n     f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 fb( vec3 p,float size )\n{\n  vec2 h,t=vec2(bo(p,vec3(4)),5);  \n  t.x=abs(t.x)-.55;\n  t.x=max(t.x,abs(p.y)-1.);  \n  t.x=smin(t.x,0.4*length(abs(p.yz+tnoi*1.8)-vec2(0,4.*size))-.6*size,1.);\n  h=vec2(bo(p,vec3(4)),3);  \n  h.x=abs(h.x)-.3;\n  h.x=max(h.x,abs(p.y)-1.5);    \n  t=t.x<h.x?t:h;  \n  h=vec2(bo(p,vec3(3.5)),6);  \n  h.x=abs(h.x)-.7;\n  h.x=max(h.x,abs(p.y)-.5);  \n  h.x=max(h.x,abs(abs(abs(p.z)-2.)-1.)-.5);  \n  h.x=max(h.x,abs(abs(abs(p.x)-2.)-1.)-.5);  \n  t=t.x<h.x?t:h;  \n  h=vec2(.6*length(p.yz)-.1+.0*sin(p.x)*.1,6);\n  pp=op; pp.z=mod(pp.z-tt*20.+35.,100.)-50.;\n  g+=0.1/(0.1+h.x*h.x*(40.-39.9*sin(pp.z*.05+.2*sin(pp.x*.3))));\n  t=t.x<h.x?t:h;\n  return t;\n}\nvec2 mp( vec3 p )\n{\n    np=bp=p;\n    op=p;\n    np.xy*=r2(sin(p.z*.15)*.3);  \n    np.z=mod(np.z+tt*5.,24.)-12.; \n    anim = sin(tt*.5+op.z*.03);\n    animInv = cos(tt*.5+op.z*.03);\n    vec2 h,t=vec2(1000);\n    for(int i=0;i<6;i++){\n        np.xz=abs(np.xz)-vec2(4,6);\n        np.xy*=r2(.17);\n    } \n    tnoi=texNoise(vec2(np.x,dot(np.xz,vec2(.5)))*vec2(.15,.3)).r;\n    t=fb(np,1.); \n    np.xz*=r2(.785*sin(np.z*.2));  \n    h=fb(np.xzy,.9);  \n    t=t.x<h.x?t:h; \n    h=fb((np+vec3(4,-4.5,2.))*3.,0.3);h.x/=3.;\n    t=t.x<h.x?t:h;\n    np.xz*=r2(-.785); \n    h=fb((np+vec3(0,-5,1))*5.,0.0);h.x/=5.;\n    t=t.x<h.x?t:h;\n    bp=p-vec3(0,20,0);\n    bp.xy*=r2(-animInv*2.5+tt);\n    b=sin(bp.z*15.)*0.03;\n    h=vec2(length(abs(bp.xy)-vec2(4,0))-.2-b,3);h.x*=0.8;\n    t=t.x<h.x?t:h;\n    bp.z=mod(bp.z-tt*20.,100.)-50.;\n    h=vec2(length(bp.yz)-.1+abs(bp.x)*.03,6);\n    gg+=0.1/(0.1+h.x*h.x*40.);\n    t=t.x<h.x?t:h;\n    pp=bp; bp.z=mod(bp.z+tt*30.,10.)-5.;\n    h=vec2(length(abs(abs(bp.xy)-vec2(1,0))-vec2(.5,0))-.1+abs(pp.z)*.02,6);\n    h.x=max(h.x,pp.z);\n    g+=0.1/(0.1+h.x*h.x*(4.-3.9*animInv));\n    t=t.x<h.x?t:h;\n    t.x*=0.8; return t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n  vec2 h,t=vec2(0.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.0001||t.x>100.) break;\n    t.x+=h.x;t.y=h.y;\n  }  \n  if(t.x>100.) t.y=0.;\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.82);\n  vec3 ro=mix(vec3(1),vec3(-1,2,2),ceil(sin(tt)))*vec3(cos(tt*.4+1.)*10.,14.-cos(tt*.5)*5.,-10.),\n  cw=normalize(vec3(0,10,0)-ro),\n  cu=normalize(cross(cw,vec3(0,1,0))),\n  cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;  \n  co=fo=vec3(.1,.12,.13)-length(uv)*.15;\n  ld=normalize(vec3(-.1,.5,.3));\n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n    al=mix(vec3(.4,.1,.2),vec3(.1,.2,.4),sin(np*.5)*.5+.5)+tnoi;\n    if(z.y<5.)al=vec3(0);\n    if(z.y>5.)al=vec3(1);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);\n    co=mix(al*(a(.05)*a(.1)+.2)*(dif+s(2.)),fo,min(fr,.5));\n    co=mix(fo,co,exp(-.000005*t*t*t));\n  }  \n  fragColor = vec4(pow(co+g*.2*vec3(.1,.2,.7)+gg*.2,vec3(.45)),1);\n} ", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfBzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 305, 305, 347], [348, 348, 365, 365, 408], [409, 409, 451, 451, 516], [517, 517, 540, 540, 813], [814, 814, 844, 844, 1484], [1485, 1485, 1504, 1504, 2615], [2616, 2616, 2644, 2644, 2813], [2903, 2903, 2960, 2960, 3899]], "test": "untested"}
{"id": "tllfR2", "name": "10. Driving Home - Basic Setup", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=eKtsY7hYTPg\n\nMy Onet Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["drivinghome"], "likes": 0, "viewed": 280, "published": 3, "date": "1597245863", "time_retrieved": "2024-07-30T20:51:06.360488", "image_code": "#define S( a , b , t ) smoothstep( a , b , t )\n\nstruct Ray {\n\tvec3 ro;\t\t// Ray Origin\n    vec3 rd;\t\t// Ray Directionhttps://www.shadertoy.com/new\n};\n    \n// RAY\nRay GetRay( vec2 uv , vec3 camPos , float camZoom , vec3 lookAt ) {\n \n    Ray ray;\n    \n    ray.ro = camPos;\n    \n    vec3 F = normalize( lookAt - camPos );\n    vec3 R = normalize( cross( vec3( 0 , 1 , 0 ) , F ) );\n    vec3 U = cross( F , R );\n    \n    vec3 center  = camPos + F * camZoom;\n    vec3 intersectionPoint = center + uv.x * R  + uv.y * U;\n    \n    // rd have to do normalized.\n    // because where GetClosestPoint() , dot ( target - ro , rd ) * rd.\n    ray.rd = normalize( intersectionPoint - camPos );\n    \n    return ray;\n}\n\n\n\n\n// \nvec3 GetClosestPoint( Ray ray , vec3 targetPos ) {\n   return ray.ro + max( 0.0f , dot( targetPos - ray.ro , ray.rd ) ) * ray.rd;\n}\n\n\n\n// \nfloat GetDistance( Ray ray , vec3 targetPos ) {\n\tfloat d = length( targetPos - GetClosestPoint( ray , targetPos ) );\n    return d;\n}\n\n\n// BOKE\nfloat Boke( float d , float lightDiameter , float blur ) {\n\tfloat c = S( lightDiameter , lightDiameter * ( 1.0f - blur ) , d );\n\tc *= mix( 0.5f , 1.0f , S( lightDiameter * 0.8f , lightDiameter , d ) );\n    return c;\n}\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5f * iResolution.xy) / max( iResolution.x, iResolution.y);\n    \n\n\tvec3 camPos = vec3( 0 , 0.1f , 0 );\n    vec3 lookAt = vec3( 0 , 0.1f , 1.0f );\n    float camZoom = 1.0f;\n    vec3 targetPos = vec3( 0 , 0 , 5.0f );\n    \n    float lightDiameter = 0.2f;\n        \n    float bokeBlur = 0.1f;\n    float bokeRate = 0.1f;\n    \n    \n    Ray ray = GetRay( uv , camPos , camZoom , lookAt );\n    float d = GetDistance( ray , targetPos );\n\n    \n    float c = Boke( d , lightDiameter , bokeBlur );\n    \n    vec3 col = vec3( 0.7f , 1.3f, 0.3f ) * c;\n\n    // Output to screen\n    fragColor = vec4( col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllfR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 161, 228, 228, 697], [702, 706, 756, 756, 836], [840, 844, 891, 891, 976], [979, 987, 1045, 1045, 1204], [1206, 1214, 1271, 1271, 1900]], "test": "untested"}
{"id": "ttsfR2", "name": "simple tiling", "author": "cyperus", "description": "triangular, hexagonal, rectangular tiling", "tags": ["2d", "tiling"], "likes": 8, "viewed": 505, "published": 3, "date": "1597233226", "time_retrieved": "2024-07-30T20:51:07.246120", "image_code": "// triangular, hexagonal, rectangular tiling\n// \n// Colling Patrik, 2020\n//\n\n// const\nconst float PI = 3.14159265359,\n    PI_2 = PI/2., PI_3 = PI/3., PI_4 = PI/4., PI_6 = PI/6.,\n    SQRT2 = sqrt(2.), SQRT_2 = 1./SQRT2,  \n    SQRT3 = sqrt(3.), SQRT_3 = 1./SQRT3;\n\n// 1D-transformations: float => float\nfloat csteps(float x,float b){\n    //centered step, step width b\n    return b*floor((x/b+0.5));\n    }\nfloat signeveodd(float x){\n    return sign(mod(x-0.5,2.)-1.);\n    }\nfloat smoothpuls(float x,float b){\n    return smoothstep(abs(b),0.,abs(x));\n    }\n    \n// 2D-transformations: vec2 => vec2\nvec2 rot2(vec2 x,float a){\n    float si = sin(a), co = cos(a);\n    return mat2(co,-si,si,co)*x;\n    }\n\nvec2 recgrid2rec(in vec2 Z, out vec2 Z_id, out float  z_sr){  \n    // maps a grid of unit-squares to one unit-square\n    // The unit-square is inside of the unit-circle\n    Z /= SQRT_2;\t// F:scale grid\n    Z_id = floor(0.5*(Z+1.));// global cell offset id (...,-2,-1,0,+1,+2,...)\n    Z = Z-2.*Z_id;// local cell coord's\n    Z *= SQRT_2; // B:scale cell    \n    // symmetries\n    z_sr = signeveodd((Z_id.x+Z_id.y));// sense of rotation of local cell\n    Z.x *= signeveodd(Z_id.x);//mirror x\n    Z.y *= signeveodd(Z_id.y);//mirror y\n    return Z;\n    }\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id, out vec3 U_lo){\n    // maps a hexagonalgrid of unit-hexagons to one unit-hexagon\n    // the unit-hexagon is inside of the unit-circle   \n    // with edge orientation pointing up\n    // using cubic hexagonal coordinates U_id, U_lo\n    // ==> https://www.redblobgames.com/grids/hexagons/\n\t// ==> https://bl.ocks.org/patricksurry/0603b407fa0a0071b59366219c67abca\n    // matrix: unitvectors eu,ev -> ex(red),ez(blue)\n    const mat2 iM = mat2(SQRT3, -SQRT3, -1., -1.)*2./3., M = inverse(iM);\n    Z = iM*Z; // F: cartesian -> 2d-cubic-hex grid-coord's\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y); // 3d-cubic-hex grid-coord's, plane: x+y+z = 0    \n    U_id = floor(0.5*(U+1.)); // global 3d-cubic-hex grid-cell offset id \n    U_lo = U-2.*U_id; // local 3d-cubic-hex cell coord's\n    // correction triangles\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) {\n        U_lo.x = -U_lo.y-U_lo.z;\n        U_id.x = -U_id.y-U_id.z;}\n    if (aU_lo.y > aU_lo.z) {\n        U_lo.y = -U_lo.x-U_lo.z;\n        U_id.y = -U_id.x-U_id.z;}\n    else {\n        U_lo.z = -U_lo.x-U_lo.y;\n        U_id.z = -U_id.x-U_id.y;}\n    return M*U_lo.rb ; // B: local 2d-cubic-hex cell -> local-cartesian cell coord's\n    }\nvec2 hex2tri(in vec2 Z, out float a_id, out float a_cy){\n    // maps 6 triangles inside a unit-hexagon to one unit-triangle\n    // The unit-hexagon is inside of the unit-circle\n    // with edge orientation pointing in x plus direction    \n    Z = rot2(Z,-PI_6); \t\t// orientation adaption  tri2hex ==> hexgrid2hex \n    Z = rot2(Z,PI_3);\t\t// F:orientation-offset of simplex  \n    float a = atan(Z.y,Z.x);   \n    a_id = floor(a/PI_3+0.5);// triangle offset id ((-3),-2,-1,0,1,2,(3))\n    float a_lo = a-PI_3*a_id;\t\t\t// local coord's angle\n    a_cy = signeveodd(a/PI_3);\t\t\t// cycle even +1, odd -1\n    Z = rot2(Z,PI_3*a_id);\t\t\t\t// mape grid-zell to unit-triangle\n    Z = (Z-vec2(SQRT_3,0.))*SQRT3; \t\t// translation,scale unit-triangle\n    Z.y *= a_cy;\t\t\t\t\t\t// y-mirror cyclic\n    return rot2(Z,-PI_3);\t\t\t\t// B:orientation-offset of unit-triangle\n    }\n\n// 2D-transformation-matrix: vec2 => mat2\nmat2 mat2rot(float a){\n    float si = sin(a), co = cos(a);\n    return mat2(co,-si,si,co);\n    }\n\n// inface: vec2 => bool\nbool inudisk(vec2 z){\n    // in unit disk\n\treturn (length(z)<1.);\n    }\nbool inuarrow(vec2 z){\n    // in unit arrow\n    // line\n    bool br = (z.x>-1.) && (z.x<0.9) && (abs(z.y)<0.01); \n    // arrow\n    float lr = length(z-vec2(1.,0.));\n    bool ba\t= (lr<0.2) && (z.x-1.<0.0) && (abs(z.y)<0.3*lr);\n    return br || ba;\n    }\nbool inupoly(vec2 z,int k){\n    const float PI = 3.14159265359;\n    // in unit polygon\n    k = abs(k);\t\t\t//poly-num-edges\n    bool m = true;\t\t//bit-mask    \n    if (k<3) m = false;\n    else{   \n    \tfloat a = PI/float(k);\n    \tfloat h = cos(a);//\n    \tfor (int i=0; i<k; i++){\n        \tfloat a1 = 2.*a*float(i);\n        \tvec2 w = vec2(cos(a1),sin(a1));\n        \tif(dot(w,z)>h) m = false;\n        }\n    }\n    return m;\n    }\n\n// texture: vec2 => vec4\nvec4 texCh2(vec2 z){\n    z = 0.5*(z-1.);//centered texture\n    vec4 tex = textureLod(iChannel2,z,1.0);//color\n    //if (abs(2.*z.x+1.)>1. || abs(2.*z.y+1.)>1.) tex.a = 0.0;//alpha square\n    return tex;\n    }\nvec4 texUnitPolyCh2(vec2 z,int k){\n    return vec4(texCh2(z).xyz,float(inupoly(z,k)));\n    }\nvec4 texUnitGrid(vec2 z){\n    const float b = 0.02;\n    vec3 col = vec3(0.5);\n    if (abs(z.y) < b)  col = 0.8*vec3(1.,0.,0.);\n    if (abs(z.x) < b)  col = 0.8*vec3(0.,1.,0.);\n    return vec4(col,smoothpuls(fract(z.x),b) + smoothpuls(fract(z.y),b));\n    }\nvec4 texUnitCircle(vec2 z){\n    const float b = 0.02; float dr = length(z)-1.;\n    return vec4(vec3(0.9), smoothpuls(dr,b));\n    }\nvec4 texCartesianBase(vec2 z){\n    // pixel_color\n    bool m1 = false, m2 = false;\n    vec3 col = vec3(0.,0.,0.);\n    //color replace condition\t\t\tupdate alpha-bit   color\n    m1 = inuarrow(z);\t\t\t\t\tif(m1){m2 = m2||m1;col=vec3(1.0,0.,0.);}//x\n    m1 = inuarrow(mat2(0.,-1.,1.,0.)*z);if(m1){m2 = m2||m1;col=vec3(0.,1.0,0.);}//y\n    m1 = inudisk(17.*z);\t\t\t\tif(m1){m2 = m2||m1;col=vec3(0.,0.0,1.0);}//z\n    return vec4(col,float(m2));\n    }\nvec4 texHexCubicBase(vec2 z){\n    const float A = sqrt(3.);\n    bool m1 = false, m2 = false;\n    vec3 col = vec3(0.,0.,0.);\n    m1 = inuarrow(.5*mat2(A,1.,-1.,A)*z);\tif(m1){m2 = m2||m1;col=vec3(1.,0.,0.);}//r\n    m1 = inuarrow(mat2(0.,-1.,1.,0.)*z);\tif(m1){m2 = m2||m1;col=vec3(0.,1.,0.);}//g\n    m1 = inuarrow(.5*mat2(-A,1.,-1.,-A)*z);\tif(m1){m2 = m2||m1;col=vec3(0.,0.,1.);}//b\n    m1 = inudisk(30.*z);\t\t\t\t\tif(m1){m2 = m2||m1;col=vec3(1.,1.,0.);}//origin\n    return vec4(col,float(m2));\n    }\n\n// main ////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 O, vec2 uv ){\n    // animation\n    float v = iTime/5.;\n    // transformation pipeline index: tid\n    //Atid: non 0\n    //Btid:,rec 1\t,recgrid2rec 2\t\t\t\t\t\t,recgrid2rec-anim 3\n    //Ctid:,hex 4\t,hexgrid2hex 5\n    //Dtid:,tri 6\t,hex2tri 7\t\t,gridhex2hex2tri 8\t,hexgrid2hex2tri-anim 9\n    \n    //sequences\n    int tid = int(floor(v-9.*floor(v/9.))+1.); // periodic 9 step's +1\n    //int tid = int(floor(v-3.*floor(v/3.))+1.);\t// Btid       \n    //int tid = int(floor(v-2.*floor(v/2.))+3.+1.);\t// Ctid    \n    //int tid = int(floor(v-4.*floor(v/4.))+5.+1.);\t// Dtid\n    //int tid = 2;\n\n\n    // 2Dtransformations\n    // pixel <== viewport\n    vec2 Z = 2.*(2.*uv- iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec2 Z0 = Z; //save for viewport texture\n    \n    \n    vec2 rec_id = vec2(0.);\tfloat rec_cy = 1.;\n    if (tid == 2 || tid == 3){\n        Z = rot2(Z,PI_4);\t\t// F:orientation-offset of grid\n        Z = recgrid2rec(Z,rec_id,rec_cy);\n        Z = rot2(Z,-PI_4);\t\t// B:orientation-offset of cell        \n        }\n    \n\tvec3 hex_id = vec3(0.);\tvec3 hex_lo = vec3(0.); float hex_cy = 1.;\n    if (tid == 5 || tid == 8 || tid == 9){\n        Z = rot2(Z,PI_6); // F:orientation-offset of grid \n        Z = hexgrid2hex(Z, hex_id, hex_lo);\n        Z = rot2(Z,-PI_6);// B:orientation-offset of cell         \n        }\n    \n    float a_id = 0., a_cy = 1.;   \n    if(tid == 7 || tid == 8 || tid == 9){\n        Z = hex2tri(Z, a_id, a_cy);\n        }\n\n\n    // color \n    vec4 tex =vec4(1.);// init alpha = 1.;\n    vec3 col =vec3(0.3,0.3,0.3);//background\n    vec3 P = vec3(1.,1.,1.);//color pattern vector \n    \n    //rec 1, recgrid2rec 2,recgrid2rec-anim 3,    \n    if (tid == 1 || tid == 2 || tid == 3){   \n        // animation\n        vec2 Za = Z; // save\n            if (tid == 3){\n                Z = SQRT2*rot2(Z,2.*PI*v);\t\t// inner circle \n                P *= (0.2*rec_cy+0.8);\t\t\t// modulate pattern vector\n            }\n        // unit-rectangular-texture  \n        Z = rot2(Z,PI_4); \t\t\t// unit-cell pointy in x-direction given\n        tex = texUnitPolyCh2(Z,4); \tcol = mix(col,P*tex.xyz, tex.a);        \n        tex = texUnitCircle(Z); \tcol = mix(col,tex.xyz,tex.a);\n        tex = texUnitCircle(SQRT2*Z);\n        tex.xy *= rec_id/2.;tex.z=0.;col = mix(col,tex.xyz,tex.a);\n        tex = texCartesianBase(Z);\tcol = mix(col,tex.xyz,tex.a); \n        }\n    \n    //hex 4, hexgrid2hex 5,\n    if (tid == 4 || tid == 5 ){\n        // animation\n        //unit-hexagon-texture\n        Z = rot2(Z,PI_6); \t\t\t// unit-cell pointy in x-direction given\n        tex = texUnitPolyCh2(Z,6); \tcol = mix(col,tex.xyz,tex.a);\n        tex = texUnitCircle(Z);     col = mix(col,tex.xyz,tex.a);        \n        tex = texUnitCircle(2./sqrt(3.)*Z);\n        tex.xyz *= hex_id/2.;       col = mix(col,tex.xyz,tex.a);\n        tex = texHexCubicBase(Z);\tcol = mix(col,tex.xyz,tex.a);\n        }\n    \n    //tri 6, hex2tri 7,hexgrid2hex2tri 8,hexgrid2hex2tri-anim 9,\n    if (tid == 6 || tid == 7 || tid == 8 || tid == 9){   \n\t// animation\n        if (tid >= 7 || tid == 8){\n            //float d = a_id/PI_3+3.;d/=6.;\n            // ((-3.),-2.,-1,0,+1,+2,(+3)) ==> (0,1,2,3,4,5)\n            float d = (a_id/PI_3+3.);if(d>5.)d=0.0;d/=5.;\n            P *= (0.2+d*0.8);}// modulate pattern vector\n        //if (tid == 8){}\n    \tif (tid == 9){\n            //P *= 0.3*a_cy+0.7;\n        \tZ = 2.*rot2(Z,2.*PI*v);// inner circle\n    \t}\n        // unit-triangle-texture    \n        Z = rot2(Z,PI_3); \t\t\t// unit-cell pointy in x-direction given\n        tex = texUnitPolyCh2(Z,3);\tcol = mix(col,P*tex.xyz, tex.a);\n        tex = texCartesianBase(Z); \tcol = mix(col,tex.xyz,tex.a);\n        tex = texUnitCircle(Z);\t\tcol = mix(col,tex.xyz,tex.a);  \n        }  \n\n    // viewport-texture\n    //tex = texCh2(Z); col = mix(col,tex.xyz,tex.a);// TEST:texture\n    tex = texUnitGrid(Z0); col = mix(col,tex.xyz,tex.a);\n    // return color\n    \n    O = vec4(col,1.);\n    }\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 301, 331, 365, 402], [403, 403, 429, 429, 470], [471, 471, 505, 505, 552], [558, 594, 620, 620, 695], [697, 697, 757, 865, 1247], [1248, 1248, 1306, 1703, 2493], [2494, 2494, 2550, 2732, 3340], [3342, 3384, 3406, 3406, 3479], [3481, 3505, 3526, 3546, 3576], [3577, 3577, 3599, 3632, 3829], [3830, 3830, 3857, 3857, 4253], [4255, 4280, 4300, 4300, 4488], [4489, 4489, 4523, 4523, 4581], [4582, 4582, 4607, 4607, 4837], [4838, 4838, 4865, 4865, 4968], [4969, 4969, 4999, 5018, 5404], [5405, 5405, 5434, 5434, 5899], [5901, 5986, 6024, 6041, 9921]], "test": "untested"}
{"id": "wllfRj", "name": "P.Gerdes & Tchokwe sand drawing7", "author": "FabriceNeyret2", "description": "pseudo3D variant of [url]https://shadertoy.com/view/WlffzB[/url]\n\nReference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]\n", "tags": ["tiles", "short", "truchets"], "likes": 8, "viewed": 332, "published": 3, "date": "1597213034", "time_retrieved": "2024-07-30T20:51:08.112803", "image_code": "// pseudo3D variant of https://shadertoy.com/view/WlffzB\n\n#define S(v) smoothstep( 9./R.y , 0. , v )           // AA draw\n#define s(v) ( .5 + .5* cos(3.14*v/.1) )             // strip pattern \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(.5,0,0,0);\n    mat2 M = mat2(1,-1,1,1);                         // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / R.y + iTime,\n         I = floor( U * M ),                         // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414, f, S;     // quad center to edge domain\n    \n  //O -= S( length(F) - .1 );                        // dots\n\n    float i = I.y + 10.*I.x +99.,                    // edge id (float)\n          r = fract(4e4*sin(i));                     // rand(id)\n    O = r < .5\n        ? f = abs( abs(F) - .353 ),\n          S = S(f-.1), F = S * s(f),                 //  X at edge\n          mix( O,   F.x + F.y \n                  - ( F.yx*(.5+.5*cos(6.28*f/.71))) [int(4.*r)]  // random crossing order\n                 + O.yyxw ,\n               max(S.x,S.y) )\n        :(                           \n          r = abs( length(F) - .353 ),               // )( at edge\n          mix( O, s(r) + O.yyxy, S(r-.1) ) );\n\n // O -= .4*( .5+.5*cos(6.3*r + vec4(0,2,-2,0)) );   // coloring ( debug )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 232, 232, 1289]], "test": "untested"}
{"id": "wlsBRj", "name": "Rainbow branches", "author": "jarble", "description": "Another edit of my \"strange branches\" shader.", "tags": ["3d", "raymarching", "fractal", "recursion"], "likes": 3, "viewed": 282, "published": 3, "date": "1597208260", "time_retrieved": "2024-07-30T20:51:08.879752", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*1000.0;\n    p += animate(p);\n    return sin(vec3(vines(p,6.0),vines(p,4.0),vines(p,3.0)))/5.0+vec3(.5);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p),\n    L = normalize(lightPos - p),\n    V = normalize(eye - p),\n    R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    float t1 = iTime;\n    vec3 eye = vec3(t1,0.0,t1);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 7.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define multiplier 9.0\n#define iterations 2\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0,\nMAX_DIST = 500.0,\nEPSILON = 0.01,\nsize = 1000.0;\n\n\nconst float scale = 0.01; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    return size-length((sin(p)-cos(p.yzx))*size1)/2.0;\n}\n\nvec3 animate(vec3 p){\n    vec3 a = p.zxy/10.0;\n    return (sin(a)+cos(a))*10.0;\n}\n\nfloat sceneSDF1(vec3 p) {\n    p /= scale*1000.0;\n    \n    float\n        size1 = 1000.0,\n    \tresult = vines(p,size1),\n    \ti = multiplier;\n    for(int j = 0; j < iterations; j++){\n        \tp += animate(p);\n\n        size1 += length(sin(p.yzx+result/i)*i*i)/4.0;\n        p += p-sin(result/i/i+p);\n        result = min(result,vines(p,size1)/(i));\n        i *= multiplier;\n    }\n    return -result*scale;\n}\n\n\nfloat sceneSDF(vec3 p){\n    float result = sceneSDF1(p);\n    //float multiplier = 9.0;\n    for(float i = multiplier; i < multiplier*multiplier; i*= multiplier){\n        //add bumps to the surface\n        p = p.yzx;\n        float distort = 1.5;\n        float r1 = sceneSDF1(p*i*distort)/i/distort;\n    \tresult += r1*r1;\n    }\n    return result;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 209], [211, 632, 723, 723, 1029], [1044, 1298, 1363, 1363, 1495], [1497, 1586, 1615, 1615, 1925], [1927, 2419, 2559, 2559, 3154], [3156, 3526, 3611, 3611, 3958], [3960, 4287, 4336, 4371, 4502], [4504, 4504, 4561, 4561, 5576]], "test": "untested"}
{"id": "WllBz2", "name": "Strange branches", "author": "jarble", "description": "This fractal is based on a modified version of my [url=https://www.shadertoy.com/view/tlBcDh]\"alien megacity\"[/url].\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "recursion"], "likes": 5, "viewed": 299, "published": 3, "date": "1597197667", "time_retrieved": "2024-07-30T20:51:09.829213", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define multiplier 9.0\n#define iterations 2\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0,\nMAX_DIST = 500.0,\nEPSILON = 0.01,\nsize = 1000.0;\n\n\nconst float scale = 0.01; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    return size-length((sin(p)-cos(p.yzx))*size1)/2.0;\n}\n\n\nfloat sceneSDF1(vec3 p) {\n    p /= scale*1000.0;\n\n    \n    float\n        size1 = 1000.0,\n    \tresult = vines(p,size1),\n    \ti = multiplier;\n    for(int j = 0; j < iterations; j++){\n        size1 += length(sin(p.yzx+result/i)*i*i)/4.0;\n        p += p-sin(result/i/i+p);\n        result = min(result,vines(p,size1)/(i));\n        i *= multiplier;\n    }\n    return -result*scale;\n}\n\nfloat sceneSDF(vec3 p){\n    float result = sceneSDF1(p);\n    //float multiplier = 9.0;\n    for(float i = multiplier; i < multiplier*multiplier; i*= multiplier){\n        //add bumps to the surface\n        p = p.yzx;\n        float r1 = sceneSDF1(p*i*i)/i;\n    \tresult -= r1*r1/9.0;\n    }\n    return result;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(vines(p,6.0),vines(p,4.0),vines(p,3.0)))/5.0+vec3(.5);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p),\n    L = normalize(lightPos - p),\n    V = normalize(eye - p),\n    R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n            viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n        }\n        \n        \n    float t1 = iTime + 10.0;\n    vec3 eye = vec3(t1,0.0,t1);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    vec3 p = depth_map(fragCoord);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 7.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define multiplier 9.0\n#define iterations 2\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0,\nMAX_DIST = 500.0,\nEPSILON = 0.01,\nsize = 1000.0;\n\n\nconst float scale = 0.01; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    return size-length((sin(p)-cos(p.yzx))*size1)/2.0;\n}\n\n\nfloat sceneSDF1(vec3 p) {\n    p /= scale*1000.0;\n\n    \n    float\n        size1 = 1000.0,\n    \tresult = vines(p,size1),\n    \ti = multiplier;\n    for(int j = 0; j < iterations; j++){\n        size1 += length(sin(p.yzx+result/i)*i*i)/4.0;\n        p += p-sin(result/i/i+p);\n        result = min(result,vines(p,size1)/(i));\n        i *= multiplier;\n    }\n    return -result*scale;\n}\n\nfloat sceneSDF(vec3 p){\n    float result = sceneSDF1(p);\n    //float multiplier = 9.0;\n    for(float i = multiplier; i < multiplier*multiplier; i*= multiplier){\n        //add bumps to the surface\n        p = p.yzx;\n        float r1 = sceneSDF1(p*i*i)/i;\n    \tresult -= r1*r1/9.0;\n    }\n    return result;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(vines(p,6.0),vines(p,4.0),vines(p,3.0)))/5.0+vec3(.5);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p),\n    L = normalize(lightPos - p),\n    V = normalize(eye - p),\n    R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 dmap = depth_map(fragCoord);\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n            viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n        }\n    float t1 = iTime + 10.0;\n    vec3 eye = vec3(t1,0.0,t1);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float l0 = length(dmap.xyz-eye);\n    //if(abs(sceneSDF(dmap.xyz) - sceneSDF(eye+l0*worldDir)) > .25 || sceneSDF(eye+l0*worldDir) < EPSILON){\n        l0 = log(1.0+l0)*2.0;\n    //}\n    \n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[587, 587, 619, 619, 676], [679, 679, 704, 704, 1055], [1057, 1057, 1080, 1080, 1363], [1365, 1365, 1393, 1393, 1470], [1472, 1893, 1984, 1984, 2290], [2305, 2559, 2624, 2624, 2756], [2758, 2847, 2876, 2876, 3186], [3188, 3680, 3820, 3820, 4415], [4417, 4787, 4872, 4872, 5219], [5221, 5548, 5597, 5632, 5763], [5765, 5765, 5792, 5792, 5941], [5943, 5943, 6000, 6000, 7074]], "test": "untested"}
{"id": "wtfBz2", "name": "Convolution Theorem", "author": "wyatt", "description": "Frequency space repetition of an image made by multiplying signals together. \nhttps://en.wikipedia.org/wiki/Convolution_theorem", "tags": ["fourier"], "likes": 8, "viewed": 482, "published": 3, "date": "1597171813", "time_retrieved": "2024-07-30T20:51:10.595165", "image_code": "// Fork of \"Fourier Kifs\" by wyatt. https://shadertoy.com/view/wllfzB\n// 2020-08-13 05:16:27\n\n// Fork of \"Convolution DFT\" by wyatt. https://shadertoy.com/view/tsSfzc\n// 2020-08-11 18:39:44\n\nMain {\n    float l = length(A(mod(R/R.y*(U-0.4*R),R)).xy);\n\tQ = sin(vec4(5.*l)*(1.+.2*vec4(1,2,3,4)));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 a (vec2 U ) {\n    if (length(U-0.2*R)>50.) return vec2(0);\n\n\treturn vec2(A(U).x,0);\n}\nMain {\n\tQ = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R;\n    for (float i = 0.; i < R.y; i++) {\n        Q.xy += a(vec2(U.x,i))*e(-(w.y-pi)*i)/sqrt(R.y);\n    }\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R (iResolution.xy)\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define pi 3.14159265359\nmat2 e (float t) {\n    float c = cos(t),s = sin(t);\n\treturn mat2(c,-s,s,c);\n}\n#define Main void mainImage( out vec4 Q, in vec2 U )", "buffer_b_code": "Main {\n\tQ = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R;\n    for (float i = 0.; i < R.x; i++) {\n        Q.xy += A(vec2(i,U.y)).xy*e(-(w.x-pi)*i)/sqrt(R.x);\n    }\n    float d = 2.;\n    float n = max(2.+1.*sin(.666*iTime),1.);\n        \n    for(float i = 1.; i < 5.; i++){\n        vec2 w = vec2(0);\n        \n        for (float j = 0.; j < 15.; j++) {\n            if (j >= n) break;\n            float a = d*dot(U-0.5*R,vec2(0,1)*e(j*6.2/n+iTime*sqrt(i)));\n        \tw += vec2(0,1)*e(a);\n        }  \n        Q.xy = mat2(Q.xy,-Q.y,Q.x)*w;\n        d*=.35+.5/n;\n        Q*=.35+.5/n;\n    }\n    if (length(U-0.5*R)>0.5*R.y) Q*=0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R;\n    for (float i = 0.; i < R.x; i++) {\n        Q.xy += A(vec2(i,U.y)).xy*e(w.x*i)/sqrt(R.x);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R;\n    for (float i = 0.; i < R.y; i++) {\n        Q.xy += A(vec2(U.x,i)).xy*e(w.y*i)/sqrt(R.y);\n   }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tlXBz2", "name": "P.Gerdes & Tchokwe sand drawing6", "author": "FabriceNeyret2", "description": "For not mid-radius, closer to the spirit of sand drawings. tough part: handle large radius range.\n\nReference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]\n", "tags": ["tiles", "short", "truchets"], "likes": 10, "viewed": 385, "published": 3, "date": "1597170635", "time_retrieved": "2024-07-30T20:51:11.360120", "image_code": "// variant of https://shadertoy.com/view/tlXBRS\n\n#define S(v) smoothstep( 9./R.y , 0. , v )           // AA draw\n#define s(v) cos(6.28*v/.09)                         // strip pattern \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(1);\n    mat2 M = mat2(1,-1,1,1);                         // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / R.y + iTime,\n         I = floor( U * M ),                         // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414, f;        // quad center to edge domain\n    \n    O -= S( length(F) - .1 );                        // dots\n\n    float i = I.y + 10.*I.x +99., j,                 // edge id (float)\n          r = fract(4e4*sin(i)),                     // rand(id)\n          t = 2.*fract(iTime/4.),\n          k = .4+ 1.2* min(t,2.-t);\n    I = mod(floor(U),2.); if (I.x==I.y) k = 2.-k;    // for not mid-radius, closer to the spirit of sand drawings    \n    \n    O.gb -= r < .5\n        ? f = abs( abs(F) - .353*k ),\n          F = S( f -.1 ) * s(f),                     //  X at edge\n          F.x + F.y \n          - ( F.yx * S(f-.1) ) [int(4.*r)]           //   random crossing order\n        :(                           \n          i = abs( length(F) - .353*k ),             // )( at edge\n          j = k<1. && r>=.5                          // handle overlapping of neighbor large radius \n                ? abs( length(.71*sign(F+1e-5)-F) - .353*(2.-k) ) \n                : 1.,\n          S( i -.1 ) * s(i)\n        + S( j -.1 ) * s(j) );\n            \n\n  //O -= .4*( .5+.5*cos(6.3*r + vec4(0,2,-2,0)) );   // coloring ( debug )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 223, 223, 1610]], "test": "untested"}
{"id": "wtXBz2", "name": "Double ended truchet hex tiling", "author": "mrange", "description": "License CC0: Double ended truchet hextiling\nDecided to experiment a bit with double ended truchet with triangle tiles stacked inside hex tiles.\nInspired by work done by BigWings and Shane", "tags": ["2d", "truchet", "hex", "double"], "likes": 5, "viewed": 351, "published": 3, "date": "1597169080", "time_retrieved": "2024-07-30T20:51:12.122083", "image_code": "// License CC0: Double ended truchet hextiling\n//  Decided to experiment a bit with double ended truchet with triangle tiles stacked inside hext iles.\n//  Inspired by work done by BigWings and Shane\n    \n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ORT(p)          vec2((p).y, -(p).x)\n\nconst vec2 sz       = vec2(1.0, sqrt(3.0));\nconst vec2 hsz      = 0.5*sz;\nconst float is3     = 1.0/sqrt(3.0);\nconst vec2 cdir     = normalize(vec2(1.0, is3));\nconst vec2 flipy    = vec2(1.0, -1.0);\n\nconst vec2 coords[6] = vec2[6](\n  is3*cdir*1.0/3.0,\n  is3*cdir*2.0/3.0,\n  vec2(0.5, is3/6.0),\n  vec2(0.5, -is3/6.0),\n  is3*cdir*2.0/3.0*flipy,\n  is3*cdir*1.0/3.0*flipy\n  );\n\nconst vec2 dcoords[6] = vec2[6](\n  ORT(cdir),\n  ORT(cdir),\n  vec2(-1.0, 0.0),\n  vec2(-1.0, 0.0),\n  ORT(-cdir*flipy),\n  ORT(-cdir*flipy)\n  );\n\nconst int noCorners = 15;\nconst int corners[15*6] = int[15*6](\n  0, 1, 2, 3, 4, 5, \n  0, 1, 2, 4, 3, 5, \n  0, 1, 2, 5, 3, 4, \n  0, 2, 1, 3, 4, 5, \n  0, 2, 1, 4, 3, 5, \n  0, 2, 1, 5, 3, 4, \n  0, 3, 1, 2, 4, 5, \n  0, 3, 1, 4, 2, 5, \n  0, 3, 1, 5, 2, 4, \n  0, 4, 1, 2, 3, 5, \n  0, 4, 1, 3, 2, 5, \n  0, 4, 1, 5, 2, 3, \n  0, 5, 1, 2, 3, 4, \n  0, 5, 1, 3, 2, 4, \n  0, 5, 1, 4, 2, 3\n  );\n\nfloat hash(vec3 r)  { \n  return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); \n}\n\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = mix(p2, p1, vec2(dot(p1, p1) < dot(p2, p2)));\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)/2.0;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  vec3 colb = back.xyz;\n  vec3 colf = front.xyz;\n  vec3 xyz = mix(colb, colf.xyz, front.w);\n  return xyz;\n}\n\nfloat dot2(vec2 v) { return dot(v,v); }\n    \n// IQ Bezier: https://www.shadertoy.com/view/MlKcDD\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    \n  const float sqrt3 = sqrt(3.0);\n  vec2 a = B - A;\n  vec2 b = A - 2.0*B + C;\n  vec2 c = a * 2.0;\n  vec2 d = A - pos;\n\n  float kk = 1.0/dot(b,b);\n  float kx = kk * dot(a,b);\n  float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n  float kz = kk * dot(d,a);      \n\n  float res = 0.0;\n\n  float p = ky - kx*kx;\n  float p3 = p*p*p;\n  float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n  float h = q*q + 4.0*p3;\n\n  if(h>=0.0) {   // 1 root\n      h = sqrt(h);\n      vec2 x = (vec2(h,-h)-q)/2.0;\n      vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n      float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n      res = dot2(d+(c+b*t)*t);\n  } else {   // 3 roots\n      float z = sqrt(-p);\n      float v = acos(q/(p*z*2.0))/3.0;\n      float m = cos(v);\n      float n = sin(v)*sqrt3;\n      vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n      res = min(dot2(d+(c+b*t.x)*t.x), dot2(d+(c+b*t.y)*t.y));\n      // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n      // res = min(res,dot2(d+(c+b*t.z)*t.z));\n  }\n  \n  return sqrt(res);\n}\n\nfloat bezier2(vec2 p, float f, vec2 p0, vec2 dp0, vec2 p1, vec2 dp1) {\n  float dist = length(p0 - p1);\n  float hdist = 0.5*f*dist;\n  vec2 mp0 = p0 + hdist*dp0;\n  vec2 mp1 = p1 + hdist*dp1;\n  vec2 jp = (mp0 + mp1)*0.5;\n  float d0 = bezier(p, p0, mp0, jp);\n  float d1 = bezier(p, p1, mp1, jp);\n  \n  float d = d0;\n  d = min(d, d1);\n  return d;\n}\n\nvec3 color(vec2 p, float s, float aa, vec3 col) {\n  vec2 hp = p/s;\n  vec2 hn = hextile(hp);\n  \n  vec2 pp = toPolar(hp);\n  float pn = mod1(pp.y, TAU/6.0);\n  vec2 tp = toRect(pp);\n\n  pn = mod(pn+3.0, 6.0);\n  vec3 nn = vec3(hn, pn);\n\n  float r = hash(nn);\n  int sel = int(float(noCorners)*r);\n  int off = sel*6;\n\n  const vec3 scol = vec3(0.25);\n  const vec3 bcol = vec3(1.0);\n  const float sw = 0.05;\n\n  for (int i = 0; i < 3; ++i) {\n    int c0 = corners[off + i*2 + 0];\n    int c1 = corners[off + i*2 + 1];\n    \n    int c = max(c0, c1) - min(c0, c1);\n    \n    vec2 p0 = coords[c0];\n    vec2 p1 = coords[c1];\n\n    vec2 dp0 = dcoords[c0];\n    vec2 dp1 = dcoords[c1];\n    \n    float mi = 0.5;    \n    float mx = 0.5;    \n    \n    float rr = fract(r*27.0*float(i+1));\n    switch(c) {\n      case 1:\n        mx = 1.75;\n        break;\n      case 2:\n        mx = .95;\n        break;\n      case 3:\n        mx = 1.5;\n        break;\n      case 4:\n        mx = 0.75;\n        break;\n      case 5:\n        mx = 1.95;\n        break;\n      default:\n        break;\n    }\n    \n    float f = mix(mi, mx, rr);\n    \n    float dd = (bezier2(tp, f, p0, dp0, p1, dp1)-0.01)*s;\n    \n    vec4 sc = vec4(scol, smoothstep(-sw, sw, -dd));\n    vec4 bc = vec4(bcol, smoothstep(-aa, aa, -dd));\n\n    col = alphaBlend(col, sc);\n    col = alphaBlend(col, bc);\n  }\n  \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float s = 0.45;\n  float aa = 2.0/RESOLUTION.y;\n  vec3 n;\n  vec3 col = vec3(0.0);\n  p += TIME*0.1;\n  col = color(p, s, aa, col);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXBz2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1282, 1282, 1303, 1303, 1391], [1393, 1393, 1421, 1520, 1760], [1762, 1762, 1784, 1784, 1828], [1830, 1830, 1851, 1851, 1892], [1894, 1926, 1965, 1965, 2090], [2092, 2092, 2132, 2132, 2240], [2242, 2242, 2262, 2262, 2281], [2287, 2339, 2387, 2387, 3419], [3421, 3421, 3491, 3491, 3763], [3765, 3765, 3814, 3814, 5110], [5112, 5112, 5141, 5141, 5288], [5290, 5290, 5342, 5342, 5504]], "test": "untested"}
{"id": "wtffzj", "name": "Lazy circles", "author": "kostik1337", "description": " ", "tags": ["2d", "aberration"], "likes": 7, "viewed": 341, "published": 3, "date": "1597162197", "time_retrieved": "2024-07-30T20:51:12.883048", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x /= iResolution.y / iResolution.x;\n    fragColor = vec4(\n        texture(iChannel0, fragCoord/iResolution.xy).r,\n        texture(iChannel0, fragCoord/iResolution.xy - uv*0.005).g,\n        texture(iChannel0, fragCoord/iResolution.xy - uv*0.01).b,\n        1.0\n    );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define t iTime\n#define PI 3.14159265\n#define STEPS 30.0\n\nfloat hash(float x) {return fract(sin(x)*3145.23);}\n\nvec2 frag_to_uv(vec2 frag) {\n  vec2 uv = frag / iResolution.xy - 0.5;\n  uv.x /= iResolution.y / iResolution.x;\n  return uv;\n}\n\nfloat abs_circle_inv(vec2 p) {\n    float circle = abs(length(p) - 0.1);\n    return 1./circle;\n}\n\nfloat map(vec2 p) {\n  float f = 0.;\n  float I = 4.;\n  for (float i=0.;i<I;++i) {\n    f += abs_circle_inv(p + vec2(0.4 * hash(2.*i) * sin(t*hash(i)),\n                                 0.3 * hash(2.*i+.5) * cos(t*1.4*hash(i+.5))));\n  }\n    \n  f += abs_circle_inv(p - frag_to_uv(iMouse.xy));\n  return I/f;\n}\n\nfloat pixel(vec2 uv) {\n  float c = 0.;\n  float I = STEPS;\n  for(float i=0.; i<I; ++i) {\n    float div = 5.;\n    vec2 uv2 = uv;\n    uv2 -= uv * 0.1 * i / I;\n    float m = map(uv2);\n    m = abs(mod(m, 0.05));\n    float x = 0.037;\n    c += smoothstep(x, x+2./iResolution.y, m);\n  }\n  return 2.*c / I;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = frag_to_uv(fragCoord);\n  fragColor = vec4(vec3(sqrt(pixel(uv))),1.);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtffzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 378]], "test": "untested"}
{"id": "ttfBzj", "name": "FlatBand-FIR filter", "author": "TinyTexel", "description": "A low-pass filter with maximally flat pass or stop band that falls off to zero approaching the Nyquist frequency.\nThe discrete kernel of a given size can be computed using a simple recursive procedure.\nDerivation and relevant code are in Buffer A.", "tags": ["fft", "filter", "nyquist", "fourier", "lowpass", "butterworth"], "likes": 9, "viewed": 693, "published": 3, "date": "1597158257", "time_retrieved": "2024-07-30T20:51:13.970142", "image_code": "/*\nA low-pass filter with maximally flat pass or stop band that falls off to zero approaching the Nyquist frequency.\nThe discrete kernel of a given size can be computed using a simple recursive procedure.\nI am not totally sure but I believe this is a Butterworth filter: https://en.wikipedia.org/wiki/Butterworth_filter\n\nEDIT: As iq pointed out discrete Butterworth filters seem to be IIR filters, so maybe they are not directly related to this one.\n\nDerivation and relevant code are in Buffer A.\n*/\n\n//2D Signal Inspector template by nimitz 2018 (twitter: @stormoid)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, (q-vec2(0.5,0.)), 0.).xy;\n        // dft = texelFetch(iChannel1, ivec2(fragCoord-vec2(iResolution.x*0.5,0.)-0.5)*2, 0).xy;\n        \n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n\n        if(amp <= 0.0001) col = vec3(1.0, 0.0, 0.0)*0.25;\n    }\t\n    else\n#endif\n    {\n        float n = textureLod(iChannel0, q, 0.).r;\n        //n= n*0.5+0.5;\n        n = clamp01(n);\n        col = pow(vec3(n), vec3(1.0/2.2));\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n\nA low-pass filter with maximally flat pass or stop band that falls off to zero approaching the Nyquist frequency.\nThe discrete kernel of a given size can be computed using a simple recursive procedure.\n\nDerivation:\n\nSo I was interested in constructing discrete filters that completely remove pixel sized featutes.\nPixel sized features result from the highest possible fequency content, i.e. from cos((x + phase) * pi). \nWhen sampled, this cosine can only produce a pattern of a constant value with alternating sign, i.e s*(.., 1, -1, 1, -1, 1, ...).\nThe factor s is -sec(a * pi):\n\nFullSimplify[Solve[Cos[(i) Pi] == s Cos[((i + 1) + a) Pi], s], Assumptions -> i \\[Element] Integers]\n{{s -> -Sec[a \\[Pi]]}}\n\nSignal content at this frequency, i.e. the Nyquist frequency, therefore can not be correctly represented/reconstructed and \nis generally the result of aliasing (the only exception being the perfectly pixel aligned cosine).\n\nConceptually the most straighforward way to remove these frequency from an image would be to zero out the left most column and \nthe bottom most row of its discrete Fourier transform.\nHowever, the fact that this frequency only produces one unique pattern allows us to derive simple constraines for our\ndiscrete filter kernels that ensure that their frequency responses perfectly fall off to zero at the Nyquist frequency.\n\nLet us considere the simplest case, i.e. a kernel of the of the form (a, 1-2a, a).\nSolving a simple linear equation tells us which choice for 'a' results in a filter that removes pixel sized features completely:\n\nSolve[{-1, 1, -1}.{a, 1 - 2 a, a} == 0, a]\n{{a -> 1/4}}\n\n('.' is Mathematica's dot product)\n\nThe kernel is therefore (1/4, 1/2, 1/4).\n\nThe 2d version can then constructed via the outer product:\n(1/4, 1/2, 1/4) x (1/4, 1/2, 1/4) = ((1/16, 1/8, 1/16),\n\t\t\t\t\t\t\t\t\t (1/ 8, 1/4, 1/ 8),\n\t\t\t\t\t\t\t\t\t (1/16, 1/8, 1/16))\n\n\nIncreasing the filter size from 3 to 5 gives us one more degrees of freedom that we can than use to flatten the pass band:\n\nkern[a_, b_] := {b, a, 1 - 2 (a + b), a, b}\n\nSolve[{1, -1, 1, -1, 1}.kern[a, b] == 0, {a, b}]\n{{a -> 1/4}}\n\nkern5[b_] := kern[1/4, b]\n\nSo 'a' is still strictly constrained to be 1/4, but we can choose 'b' freely.\n\nNext we construct a continuous kernel by interpolating our kernel weights using the normalized sinc function:\n\nsinc[x_] := Sin[x Pi]/(x Pi)\nkern5C[x_, b_] := kern5[b].Table[sinc[x - i], {i, -2, 2}]\n\nThis allows us to perform a (continuous) Fourier transform:\n\nkern5Cfo[x_, b_] = FullSimplify[FourierTransform[kern5C[w, b], w, x]]\n((1 - 4 b + Cos[x] + 4 b Cos[2 x]) (Sign[\\[Pi] - x] + Sign[\\[Pi] + x]))/(4 Sqrt[2 \\[Pi]])\n\nEvery odd derivative of this function already goes to 0 as x->0, so we are only concerned with zeroing out the even derivatives there.\nWith the right choice for 'b' we can zero out the 2nd derivative of kern5Cfo for x->0:\n\nSolve[{Limit[D[kern5Cfo[x, b], {x, 2}], x -> 0] == 0}, {b}]\n{{b -> -(1/16)}}\n\nThe kernel of size 5 is therefore (-1/16, 1/4, 5/8, 1/4, -1/16).\n\n\nFurther increasing the kernel size and zeroing out more even-degree derivatives is straightforward.\n\nThere most certrainly is an elegant, formal way of figuring out how the weights can be computed from the kernel size alone.\nBut what I ended up doing was deriving the kernels up to size 13 using the approach detailed above.\nI then stared at the weights of those kernels until I came up with a recursive formula that can compute them:\n\n\tconst uint r = size / 2u;\n\n\tfloat kern[r];\n\n    float sgn = (uint(r) & 1u) == 0u ? -1.0 : 1.0;\n    \n    kern[r] = 1.0/exp2(float(r) * 2.0) * sgn;\n    \n    float sum = kern[r];\n    float n = 0.0;\n    for(int i = r-1; i > 0; --i, ++n)\n    {\n        kern[i] = kern[i+1] * -((float(r) * 2.0 - n) / (n + 1.0));\n        \n        sum += kern[i];\n    }\n    \n    kern[0] = 1.0 - 2.0 * sum;\n\nI did not actually prove that this formula is correct for larger filter sizes but judging from the results it looks very likely that it is.\n\n\nEDIT:\n\nIt turns out that omitting the negative signs from the filter weights and adapting the central weight accordingly \nresults in the stop band being maximally flat instead of the pass band.\nSo if your goal is to gracefully remove as much high frequency content as possible with a kernel of a given size then\npicking the respective one from the class of kernels presented here is probably not a bad idea. \n\nYou can use the FLATTEN_STOP_BAND define to switch to this filter type.\n\n\nThese are the first few kernels:\n\nflat stop band:\n3: 1.0/2.0, 1.0/4.0\n5: 3.0/8.0, 1.0/4.0, 1.0/16.0\n7: 5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0\n9: 35.0/128.0, 7.0/32.0, 7.0/64.0, 1.0/32.0, 1.0/256.0\n\nflat pass band:\n3: 1.0/2.0, 1.0/4.0\n5: 5.0/8.0, 1.0/4.0, -1.0/16.0\n7: 11.0/16.0, 15.0/64.0, -3.0/32.0, 1.0/64.0\n9: 93.0/128.0, 7.0/32.0, -7.0/64.0, 1.0/32.0, -1.0/256.0\n\n*/\n\n\n#define SIGNAL_TYPE 0\n/*\n\t0: white noise\n\t1: texture\n\t2: simple pattern\n\t3: simple pattern clamped to [0,1]\n*/\n\n// #if 0 shows unaltered signal\n#if 1\n\n    #define ADD_ERROR_TO_SIGNAL\n\n    #define APPLY_FILTER\n\n#endif\n\nconst int FILTER_RADIUS = 3;\n\n    //#define FLATTEN_STOP_BAND\n\n    //#define APPLY_AS_HIGH_PASS_FILTER\n\n\n\n#ifdef APPLY_AS_HIGH_PASS_FILTER\n\t#undef ADD_ERROR_TO_SIGNAL\n#endif\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n\nfloat Float01(uint x) { return float(x)      * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nfloat Map(uvec2 uv)\n{\n    uint size = uint(SIZE);\n    \n    if(uv.x > size*4u) uv.x += size;\n    if(uv.y > size*4u) uv.y += size;\n        \n    if(uv.x >= size) uv.x -= size;\n    if(uv.y >= size) uv.y -= size;\n    \n    vec2 tc = vec2(uv);\n    \n    float signal = 0.0;\n    \n    \n   #if SIGNAL_TYPE == 0\n    \n    signal = Float01(WeylHash(uv));\n    \n   #elif SIGNAL_TYPE == 1\n    \n    signal = pow(texelFetch(iChannel0, ivec2(uv), 0).r, 2.2);\n    \n   #elif SIGNAL_TYPE == 2 || SIGNAL_TYPE == 3\n    \n    signal += cos(tc.x*Pi*0.25);\n    signal += cos(tc.y*Pi*0.125);\n    \n    //vec2 tc2 = tc - SIZE*0.5;\n    //tc2 = cmul(tc2, cossin(iTime));\n    //signal = max(abs(tc2.x), abs(tc2.y)) < SIZE/4.0 ? 1.0 : 0.0;\n    \n    #if 1\n    signal += cos(tc.x*Pi*0.5 + tc.y*Pi*0.25);\n    signal += cos(tc.x*Pi*0.5 - tc.y*Pi*0.25);\n    #endif\n    \n    #if 0\n    signal += cos(tc.y*Pi*0.5 + tc.x*Pi*0.25);\n    signal += cos(tc.y*Pi*0.5 - tc.x*Pi*0.25);\n    #endif\n    \n    #if SIGNAL_TYPE == 3\n    signal = clamp01(signal);\n    #endif\n    \n   #endif\n    \n    \n   #ifdef ADD_ERROR_TO_SIGNAL\n\n    float error = 0.0;\n    error += cos((tc.x) * Pi + tc.y*(SIZE-floor((sin(iTime)*0.5+0.5)*SIZE*0.5)*2.0)/SIZE * Pi);\n    error += cos((tc.y) * Pi + tc.x*(SIZE-floor((sin(iTime*0.6173)*0.5+0.5)*SIZE*0.5)*2.0)/SIZE * Pi);\n    \n    signal += error;// add pixel sized error\n    \n    /*\n\t// checker board shenanigans\n    bool m = ((uv.x ^ uv.y) & 1u) == 1u;\n\n    #if 0\n    float s = 0.0;\n    signal *= 1.0 - 4.0 * s;\n    signal += pow(texelFetch(iChannel0, ivec2(uv) + ivec2( 1, 1), 0).r, 2.2) * s;\n    signal += pow(texelFetch(iChannel0, ivec2(uv) + ivec2(-1, 1), 0).r, 2.2) * s;\n    signal += pow(texelFetch(iChannel0, ivec2(uv) + ivec2( 1,-1), 0).r, 2.2) * s;\n    signal += pow(texelFetch(iChannel0, ivec2(uv) + ivec2(-1,-1), 0).r, 2.2) * s;\n    #endif\n    \n    if(m) signal *= 0.0; else signal *= 2.0;\n    */\n        \n   #endif\n    \n    return signal;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    \n    uvec2 uv = uvec2(fragCoord - 0.5);\n    \n    \n#ifndef APPLY_FILTER\n    \n    float v = Map(uv);\n    \n    fragColor = vec4(v, 0.0, 0.0, 0.0);\n    \n    return;\n    \n#else\n    \n  #if 0\n    // ===================================================================================================================================\n    const int r = FILTER_RADIUS;\n    \n    float kern[r+1];\n    \n   #ifdef FLATTEN_STOP_BAND\n    kern[r] = 1.0/exp2(float(r) * 2.0);\n   #else\n    float sgn = (uint(r) & 1u) == 0u ? -1.0 : 1.0;\n\n    kern[r] = 1.0/exp2(float(r) * 2.0) * sgn;\n   #endif\n    \n    float sum = kern[r];\n    float n = 0.0;\n    for(int i = r-1; i > 0; --i, ++n)\n    {\n       #ifdef FLATTEN_STOP_BAND\n        kern[i] = kern[i+1] *  ((float(r) * 2.0 - n) / (n + 1.0));\n       #else\n        kern[i] = kern[i+1] * -((float(r) * 2.0 - n) / (n + 1.0));\n       #endif\n        \n        sum += kern[i];\n    }\n    \n    kern[0] = 1.0 - 2.0 * sum;\n    // ===================================================================================================================================\n  #elif 0\n\n    const int r = 1;\n    \n    float kern[r+1];\n    \n    kern[0] = 1.0/2.0;\n    kern[1] = 1.0/4.0;\n    \n  #elif 0\n\n    const int r = 2;\n    \n    float kern[r+1];\n    \n   #ifdef FLATTEN_STOP_BAND\n    kern[0] = 3.0/8.0; kern[1] = 1.0/4.0; kern[2] =  1.0/16.0;\n   #else\n    kern[0] = 5.0/8.0; kern[1] = 1.0/4.0; kern[2] = -1.0/16.0;\n   #endif\n    \n    //kern[0] = mix(3.0/8.0, 5.0/8.0, sin(iTime)*0.5+0.5); kern[1] = 1.0/4.0; kern[2] = -sin(iTime)/16.0;\n\n  #elif 1\n\n    const int r = 3;\n    \n    float kern[r+1];\n    \n   #ifdef FLATTEN_STOP_BAND\n    kern[0] =  5.0/16.0; kern[1] = 15.0/64.0; kern[2] =  3.0/32.0; kern[3] =  1.0/64.0;\n   #else\n    kern[0] = 11.0/16.0; kern[1] = 15.0/64.0; kern[2] = -3.0/32.0; kern[3] =  1.0/64.0;\n   #endif\n    \n   #if 0\n    kern[0] = 1.0/2.0; kern[1] = 9.0/32.0; kern[2] = 0.0; kern[3] = -1.0/32.0;\n   #endif\n    \n  #elif 0\n\n    const int r = 4;\n    \n    float kern[r+1];\n\n   #ifdef FLATTEN_STOP_BAND\n    kern[0] = 35.0/128.0; kern[1] = 7.0/32.0; kern[2] =  7.0/64.0; kern[3] = 1.0/32.0; kern[4] =  1.0/256.0;\n   #else\n    kern[0] = 93.0/128.0; kern[1] = 7.0/32.0; kern[2] = -7.0/64.0; kern[3] = 1.0/32.0; kern[4] = -1.0/256.0;\n   #endif\n    \n   #if 0\n    kern[0] = 55.0/128.0; kern[1] = 9.0/32.0; kern[2] = 3.0/64.0; kern[3] = -1.0/32.0; kern[4] = -3.0/256.0;\n   #endif\n    \n  #elif 0\n    \n    const int r = 5;\n    \n    float kern[r+1];\n        \n   #ifdef FLATTEN_STOP_BAND\n    kern[0] =  63.0/256.0;  kern[1] = 105.0/512.0; kern[2] =  15.0/128.0;\n    kern[3] =  45.0/1024.0; kern[4] =   5.0/512.0; kern[5] =   1.0/1024.0;\n   #else    \n    kern[0] = 193.0/256.0;  kern[1] = 105.0/512.0; kern[2] = -15.0/128.0;\n    kern[3] =  45.0/1024.0; kern[4] =  -5.0/512.0; kern[5] =   1.0/1024.0;\n   #endif\n    \n   #if 0\n    kern[0] =   1.0/2.0;   kern[1] = 75.0/256.0; kern[2] = 0.0;\n    kern[3] = -25.0/512.0; kern[4] =  0.0;       kern[5] = 3.0/512.0;\n   #endif\n    \n  #elif 0\n    \n    const int r = 6;\n    \n    float kern[r+1];\n    \n   #ifdef FLATTEN_STOP_BAND\n    kern[0] = 231.0/1024.0; kern[1] = 99.0/512.0;  kern[2] =  495.0/4096.0; kern[3] = 55.0/1024.0;\n    kern[4] =  33.0/2048.0; kern[5] =  3.0/1024.0; kern[6] =    1.0/4096.0;\n   #else \n    kern[0] = 793.0/1024.0; kern[1] = 99.0/512.0;  kern[2] = -495.0/4096.0; kern[3] = 55.0/1024.0;\n    kern[4] = -33.0/2048.0; kern[5] =  3.0/1024.0; kern[6] =   -1.0/4096.0;\n   #endif\n    \n   #if 0\n    kern[0] = 231.0/512.0;  kern[1] = 75.0/256.0; kern[2] = 75.0/2048.0; kern[3] =-25.0/512.0;\n    kern[4] = -15.0/1024.0; kern[5] =  3.0/512.0; kern[6] =  5.0/2048.0;\n   #endif\n    \n  #endif\n\n    float v = 0.0;\n    //uv*=2u;\n    for(int y = -r; y <= r; ++y)\n    for(int x = -r; x <= r; ++x)\n    {\n        float v0 = Map(uv + uvec2(x, y));\n\n        v += v0 * (kern[abs(x)] * kern[abs(y)]);\n    }\n    \n   #ifdef APPLY_AS_HIGH_PASS_FILTER\n    v = (Map(uv) - v) * 0.5 + 0.5;\n   #endif\n    \n   #if 0\n    // more radially symmetric versions of flat pass-band kernels for r=2 & r=3\n    {\n        float kern0[] = float[](1.0/ 2.0,  1.0/ 4.0,      0.0,      0.0);\n        float kern1[] = float[](3.0/ 8.0,  1.0/ 4.0, 1.0/16.0,      0.0);\n        float kern2[] = float[](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);\n\n        float lp0 = 0.0;\n        float lp1 = 0.0;\n        float lp2 = 0.0;\n\n        int r = 3;\n        for(int y = -r; y <= r; ++y)\n        for(int x = -r; x <= r; ++x)\n        {\n            float v0 = Map(uv + uvec2(x, y));\n\n            lp0 += v0 * (kern0[abs(x)] * kern0[abs(y)]);\n            lp1 += v0 * (kern1[abs(x)] * kern1[abs(y)]);\n            lp2 += v0 * (kern2[abs(x)] * kern2[abs(y)]);\n        }\n\n        v = lp0;\n        v = lp0 * 2.0 - lp1;// r = 2\n        v = lp0 * 3.0 - lp1 * 3.0 + lp2;// r = 3\n    }\n   #endif\n    \n    fragColor = vec4(v, 0.0, 0.0, 0.0);\n    \n#endif\n    \n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//2D Signal Inspector template by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) {fragColor = vec4(20.0); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n  #define SHOW_FOURIER\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\nconst float globalScale = 1.;\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfBzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WlfBzB", "name": "Gerdes Tchokwe Lusona Pattern", "author": "Shane", "description": "A weaved reimagining of Fabrice's Gerdes Tchokwe sand drawing example, rendered in a faux 3D isometric hand drawn style.", "tags": ["truchet", "draw", "pattern", "tile", "sand", "faux", "gerdes", "lusona", "tchokwe"], "likes": 30, "viewed": 622, "published": 3, "date": "1597153871", "time_retrieved": "2024-07-30T20:51:15.014350", "image_code": "/*\n\n    Gerdes Tchokwe Sand Pattern\n    ---------------------------\n\n\tThis is a very basic African influenced Lusona pattern rendered in a \n\tpseudo 3D isometric fashion in the style of oldschool scrollers.\n\tFabrice Neyret often posts interesting snippets of code with visually\n\tsatisfying results. In fact, some are a little too interesting, because \n    one minute I'll be working on something I'm supposed to be doing, then\n\tthe next minute I'm coding up a basic Angolan Tchokwe Lusona pattern. :D\n\n\tThis particular pattern represents a very small subsection of a larger \n    body of work by mathematician and author Paulus Gerdes. In case it needs \n    to be said, African inspired mathematics as it pertains to Sona sand \n    drawings is not my area of expertise. :)\n\n    Algorithmically, the base pattern here is pretty simple to make: Create \n    a square or diamond grid, then randomly render crosses or opposite sided \n    arcs on each shared edge or vertex. From my perspective, the basic design \n    is just a standard two tiled Truchet pattern with some edge constraints. \n    In particular, you force any arc tile to have either a horizontal or \n    vertical orientation on an alternate checkered basis. Use the SHOW_GRID\n    define to show the individual tiles that make up the pattern.\n\n    Since Fabrice has already covered the algorithmic side of things, I \n\tdecided to focus on the rendering. I've mentioned before that I sometimes \n    enjoy producing pseudo 3D effects more than real ones, since faux 3D \n\teffects often requires finesse and inventiveness. This is just simple \n\tlayering effects that most Photoshop artists take for granted -- Drop \n    shadows, bevels, highlights, etc. For the cross tiles (a line on top of \n    another line), I went to the trouble to render Bezier curves to put a \n    little kink at the cross-over points to enhance the illusion. It's a \n    subtle difference that added a chunk of code, but I think it makes all \n    the difference.\n\n    As mentioned, this is the most basic of patterns. There are a wide range \n    of others out there. Fabrice has created a few extentions that are worth \n    looking at. In addition, a proper 3D version of this would be relatively \n    simple, as too would a Wang tile variation. I'm not positive, but I'm \n    pretty sure it'd be possible to create a multiscale version as well. With \n    restrictions on the line lengths, animation flow might be possible, but \n    I'll save variations for another time. :)\n\n\n    Links:\n\n    // Based on the imagery from the following.\n    P.Gerdes & Tchokwe sand drawing - FabriceNeyret2\n    https://www.shadertoy.com/view/wtsfWM\n\n    // A nice variation.\n    P.Gerdes & Tchokwe sand drawing5 - FabriceNeyret2\n    https://www.shadertoy.com/view/3llfRS\n\n\n\tInspiration from Angolan traditional designs - Paulus Gerdes\n\thttps://plus.maths.org/content/new-designs-africa\n\n    Lusona - Wikipedia\n    https://en.wikipedia.org/wiki/Lusona\n\n*/\n\n// Display the individual cell tiles. Note that in this particular case,\n// the entire coordinate system has been rotated by 45 degrees to look\n// like a diamond grid, but this still a square grid.\n//#define SHOW_GRID\n\n// Makes for a neater pattern, but looks less convincing.\n//#define STRAIGHT_LINES\n\n// This takes out the edge constrainst, which results in a standard\n// two-tiled random Truchet pattern.\n//#define RANDOM_TRUCHET\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(57.609, 27.483)))*43758.5453); }\n\n\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.*B + C;\n    vec2 c = a * 2.;\n    vec2 d = A - pos;\n\n    // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b, b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.*dot(a, a) + dot(d, b))/3.;\n    float kz = kk * dot(d, a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.*kx*kx - 3.*ky) + kz;\n    float h = q*q + 4.*p3;\n\n    if(h >= 0.) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q)/2.;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n        float t = uv.x + uv.y - kx;\n        t = clamp(t, 0., 1.);\n\n        // 1 root.\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.))/3.;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m)*z - kx;\n        t = clamp(t, 0., 1.);\n\n        // 3 roots.\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos, qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos, qos);\n        res = min(res, dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos, qos);\n        res = min(res, dis);\n\n        res = sqrt(res);\n    }\n    \n    return res;\n}\n\n\n// This is a standard distance field setup for one, two or more\n// Truchet tiles with some minor additions. The tiles used are\n// overlapping crossed lines and the common double arc tile.\n//\n// There are two distance field value holders for line one or\n// line two in order to render one over the other, and two for\n// each arc, even though one would suffice, since there's no \n// overlap. The only other difference is that we're constructing\n// Bezier lines for the wavy line kinks instead of standard \n// straight ones.\n//\n// There is also a place holder for the central dots that you can\n// see and a final position to identify whether we've returned\n// a cross tile or a double arced one.\n//\nvec4 distField(vec2 p){\n\n    \n    // Offset field position for the central dots. See below.\n    vec2 q = p - .5;\n    \n   \n    // Standard square grid ID and local position.\n    vec2 ip = floor(p) + .5;\n    p -= ip;\n    \n    // Vertice and edge postions... Probably overkill for such a simple example,\n    // but it's a good habit to get into when dealing with more complex setups.\n    const vec2[4] v = vec2[4](vec2(-.5, .5), vec2(.5),  vec2(.5, -.5),  vec2(-.5));\n    const vec2[4] e = vec2[4](vec2(0, .5), vec2(.5, 0),  vec2(0, -.5),  vec2(-.5, 0));\n    \n    \n    \n    // Distance field place holder.\n    vec4 d = vec4(1e5);\n  \n    // Edge width.\n    float ew = .13;\n    \n   \n    // Using the cell ID for some unique random numbers.\n    float rnd = hash21(ip);\n    float rnd2 = hash21(ip + .37);\n    #ifdef RANDOM_TRUCHET\n    float rnd3 = hash21(ip + .73);\n    #endif\n    \n    // Checkered arrangement: The black and white chessboard arrangement comes up\n    // in so many different situations that it's worth committing to memory. In this\n    // case we are aligning all double arc tiles either horizontally or vertically,\n    // depending upon which checker we're on.\n    float check = mod(ip.x + ip.y, 2.);\n    \n    \n    // Render overlapping lined crosses on half the tiles. You could change the\n    // percentage, if you wanted.\n    if(rnd<.5){\n        \n        // X and Y nudge factors to produce the Bezier kinks.\n        #ifdef STRAIGHT_LINES\n        // No kind for the straight lines.\n        const vec2 ndgX = vec2(0);\n        vec2 ndgY = vec2(0);\n        #else\n        // Kink the horizontal lines up and the vertical lines\n        // to the left. If the tiles get rotated, they will switch\n        // to down and right, which makes sense.\n        const vec2 ndgX = vec2(-.075, 0);\n        vec2 ndgY = vec2(0, .075);\n        #endif\n        \n        // Randomly rotate some of the tiles: This has the effect of putting\n        // the top line on the bottom. The nudge factor has to be reversed\n        // to keep the line kinks pointing in the right direction.\n        if(rnd2<.5) {\n            p = rot2(3.14159/2.)*p;\n            ndgY *= -1.;\n        }  \n        \n         \n        // Rendering the Bezier lines, which aren't much different to normal lines, except there's\n        // an additional anchor point to give it a curved appearance. IQ wrote the Bezier algorithm\n        // itself, which wouldn't have been easy.\n        //\n        // Bottome line.... All of these join together at their end points.\n        d.x = min(d.x, sdBezier(p, e[2]*1., e[2] + vec2(0, .1), e[2] + vec2(0, .25) + ndgX/3.) - ew);\n        d.x = min(d.x, sdBezier(p, e[0] - vec2(0, .25) + ndgX/3., e[0] - vec2(0, .1), e[0]*1.) - ew);\n        d.x = min(d.x, sdBezier(p, e[0] - vec2(0, .25) + ndgX/3., ndgY, e[2] + vec2(0, .25) + ndgX/3.) - ew);\n        \n        // Top line.\n        d.y = min(d.y, sdBezier(p, e[3]*1., e[3] + vec2(.1, 0), e[3] + vec2(.25, 0) + ndgY/3.) - ew);\n        d.y = min(d.y, sdBezier(p, e[1] - vec2(.25, 0) + ndgY/3., e[1] - vec2(.1, 0), e[1]*1.) - ew);\n        d.y = min(d.y, sdBezier(p, e[1] - vec2(.25, 0) + ndgY/3., ndgY, e[3] + vec2(.25, 0) + ndgY/3.) - ew);\n        \n        // Tile ID: Zero for a cross.\n        d.w = 0.;\n    }\n    else {\n        \n        // The line here is the only difference between Paulus Gerdes's Tchokew inspired sand pattern\n        // arrangement and a regular double tiled Truchet pattern... If you look at the comments on\n        // Fabrice Neyret's original Shadertoy pattern you'll see that I'm kind of convinced of that,\n        // but I'm not positive... Either way, it's a pretty pattern, so whatever. :D\n        //\n        // As you can see, I've provided an option to randomly rotate tiles as well, which will \n        // produce the common double tiled pattern that you've probably seen all over the place.\n        //\n        #ifdef RANDOM_TRUCHET\n        if(rnd3<.5) p = rot2(3.14159/2.)*p; // Random rotation.\n        #else\n        if(check<.5) p = rot2(3.14159/2.)*p; // Checker pattern constained rotation.\n        #endif \n        \n        // The two quarter arcs: You could put an arc in each of \"d.x\" and \"d.y,\" however,\n        // we're joining both together in the top layer, just in case there's overlap.\n        //d.x = abs(length(p - v[0]) - .5) - ew;\n        //d.y = abs(length(p - v[2]) - .5) - ew;\n        \n        d.y = abs(length(p - v[0]) - .5) - ew;\n        d.y = min(d.y, abs(length(p - v[2]) - .5) - ew);\n        \n        // Tile ID: One for regular double arcs.\n        d.w = 1.; \n        \n    }\n    \n\n    // The distance field for the central black dots.\n    vec2 ip2 = floor(q) + .5;\n    q -= ip2;\n    if(mod(ip2.x + ip2.y, 2.)<.5){\n        d.z = min(d.z, length(q));\n        d.z -= ew*.8;\n\t}\n\n    \n    // Return the tile one and two, the central dots and ID.\n    return d;\n}\n\n\n// The grid cell borders.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p) + .5;\n    p = abs(p - ip);\n\n    return abs(max(p.x, p.y) - .5) - .015;\n   \n}\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n  \n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // The pattern is resolution based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd; \n\n    return hatch;\n    \n}\n\n// Translating the camera about the XY plane.\nvec2 getCamTrans(float t){ return vec2(sin(t/8.)/16., t/1.); }\n\n// Rotating the camera about the XY plane.\nmat2 getCamRot(float t){\n    \n    //return rot2(0.);\n    return rot2(cos(t/4.)/16.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    \n    // Scaling, rotation and translation.\n    float gSc = 7.5;\n\t// Rotating and moving the canvas. A 2D \"to\" and \"from\" setup would be better, but this\n    // will do for the purpose of the demonstration.\n    vec2 cam = getCamTrans(iTime); // Translation.\n    mat2 camRot = getCamRot(iTime); // Rotation.\n    // Extra 45 degred rotation to give a diamond grid appearance.\n    vec2 p = rot2(3.14159/4.)*(uv*gSc)*camRot + rot2(3.14159/4.)*cam;    \n    \n    \n    // Transformed coordinate copy.\n    vec2 oP = p;\n\n     \n    // Four samples for various things. In this case, it's shadows, highlights,\n    // a pattern field, and the base distance field.\n    vec4 dSh = distField(p - vec2(-2, -1)*.07);\n    vec4 dHi = distField(p + vec2(-2, -1)*.04);\n    vec4 dp = distField(p*6.);\n    vec4 d = distField(p);\n    \n    \n    \n    float sf = 1./iRes*gSc;\n    \n    vec3 col = vec3(1, .9, .95);//vec3(.8, .6, .4);//vec3(1, .9, .95);//\n\n    vec3 lCol = vec3(1, .05, .1);//vec3(1, .05, .1);//vec3(1, .8, .6)/8.;//\n    \n    \n    \n    float pat = smoothstep(0., sf*6., min(dp.x, dp.y))*.5 + .5;\n\n    \n    #ifdef SHOW_GRID\n    // Display the individual cell tiles.\n    float grid = gridField(p);\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, max(grid, -(d.z - .25)))));\n    col = mix(col, col*1.5, (1. - smoothstep(0., sf*2., grid - .01)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid)));\n    #endif\n    \n    vec2 iq = floor(p) + .5;\n    vec2 q = p - iq;\n\n    vec2 sh = max(.5 - d.xy/.15, 0.);\n    vec2 shHi = max(.5 - dHi.xy/.15, 0.);\n    \n    \n    // Thickening the base distance (the extruded walls).\n    d -= .03;\n  \n    // If it's a cross (overlapping line) tile, darken the shadow on the\n    // bottom and add high a highlight to the top line at the crossover point.\n    // It's a subtle effect, but it helps create the illusion.\n    if(d.w < .001){\n        sh.y *= max(1.5 - dot(q, q)*1.5, 1.);\n        shHi.y *= max(1.5 - dot(q, q)*1.5, 1.);\n        \n        sh.x *= min(.5 + dot(q, q)*4., 1.5);\n        shHi.x *= min(.5 + dot(q, q)*4., 1.5);\n    }\n      \n    \n    // Subtle effect to give the ground some shadowy perturbation.\n    col = mix(col, vec3(.3, .1, .2), (1. - smoothstep(0., sf*15., min(dSh.x, dSh.y) - .03))*.25);\n    \n    // Applying the bottom layer of the cell tile. In order is a shadow, fake AO, dark\n    // edge, extruded base layer, top dark edge, and upper hilighted layer. There's a few\n    // layers here, but it's still extremely cheap compared to raymarching.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., min(dSh.x, dSh.y) - .03*iRes/450.))*.55);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., min(d.x, d.y) - .03))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x - .03)));\n    col = mix(col, lCol*sh.x, (1. - smoothstep(0., sf, d.x)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, dHi.x - .015))*.95);\n    col = mix(col, lCol*shHi.x*5.*pat, (1. - smoothstep(0., sf, dHi.x + .015)));\n\n    // A cheap environmental glaze.\n    col = mix(col, col.xzy*pat*1.5, (1. - smoothstep(0., sf*3., dHi.x + .12)));\n  \n    // Applying the intividual top layers of the cell tile.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(max(d.x, d.y - .15), dSh.y)))*.55);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(d.x - .03, d.y - .03*iRes/450.)))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.y - .03)));\n    col = mix(col, lCol*sh.y, (1. - smoothstep(0., sf, d.y)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, dHi.y - .015))*.95);\n    col = mix(col, lCol*shHi.y*5.*pat, (1. - smoothstep(0., sf, dHi.y + .015)));\n    \n    // A cheap environmental glaze.\n    col = mix(col, col.xzy*pat*1.5, (1. - smoothstep(0., sf*3., dHi.y + .12)));\n    \n    \n    // Putting some hacky patches on the center of the cell edges to account\n    // for some rendering overlay issues. It's one of the downsides to rendering\n    // layers on a grid. :)\n    q = oP;\n    iq = floor(q) + .5;\n    q -= iq;\n    q = abs(q) - .5;\n    float sq = max(abs(q.x + .5), abs(q.y));\n    sq = min(sq, max(abs(q.x), abs(q.y + .5))) - .25;\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, max(sq, min(dHi.x, dHi.x)) - .015)));\n    col = mix(col, lCol*shHi.x*5.*pat, (1. - smoothstep(0., sf, max(sq, min(dHi.x, dHi.x)) + .015)));\n   \n \n    // The dark central circles.\n    col = mix(col, col*1.4, (1. - smoothstep(0., sf*8., dHi.z - .03)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.z)));\n    \n         \n    // Post processing.\n    //col = mix(col, col.xzy, dot(col, vec3(.299, .587, .114))/8.);\n    col *= vec3(.8, .75, .6);\n \n\n    \n    // Cheap hatch overlay to give it a very cheap hand drawn look.\n    float hatch = doHatch(rot2(-3.14159/4.)*oP/gSc, iResolution.y);\n    col *= hatch*.4 + .75;\n     \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfBzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3401, 3434, 3456, 3456, 3514], [3517, 3545, 3566, 3566, 3629], [3633, 3817, 3866, 4062, 5526], [11086, 11112, 11136, 11136, 11241], [11243, 11320, 11353, 11405, 11820], [11822, 11868, 11894, 11894, 11930], [11932, 11975, 11999, 12027, 12061], [12063, 12063, 12117, 12160, 17137]], "test": "untested"}
{"id": "tlfBRj", "name": "Study rain postprocess", "author": "MrDevin", "description": "https://www.shadertoy.com/view/ltffzl", "tags": ["study"], "likes": 4, "viewed": 301, "published": 3, "date": "1597143562", "time_retrieved": "2024-07-30T20:51:15.979769", "image_code": "\n#define S(a, b, t) smoothstep(a, b, t)\n\n\nvec3 N13(float p) {\n    //  from DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nfloat N(float t) {\n    return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n\treturn S(0., b, t)*S(1., b, t);\n}\n\n\nvec2 DropLayer2(vec2 uv, float t) {\n    vec2 UV = uv;\n    \n    uv.y += t*0.75;\n    vec2 a = vec2(6., 1.);\n    vec2 grid = a*2.;\n    vec2 id = floor(uv*grid);\n    \n    float colShift = N(id.x); \n    uv.y += colShift;\n    \n    id = floor(uv*grid);\n    vec3 n = N13(id.x*35.2+id.y*2376.1);\n    vec2 st = fract(uv*grid)-vec2(.5, 0);\n    \n    float x = n.x-.5;\n    \n    float y = UV.y*20.;\n    float wiggle = sin(y+sin(y));\n    x += wiggle*(.5-abs(x))*(n.z-.5);\n    x *= .7;\n    float ti = fract(t+n.z);\n    y = (Saw(.85, ti)-.5)*.9+.5;\n    vec2 p = vec2(x, y);\n    \n    float d = length((st-p)*a.yx);\n    \n    float mainDrop = S(.4, .0, d);\n    \n    float r = sqrt(S(1., y, st.y));\n    float cd = abs(st.x-x);\n    float trail = S(.23*r, .15*r*r, cd);\n    float trailFront = S(-.02, .02, st.y-y);\n    trail *= trailFront*r*r;\n    \n    y = UV.y;\n    float trail2 = S(.2*r, .0, cd);\n    float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\n    y = fract(y*10.)+(st.y-.5);\n    float dd = length(st-vec2(x, y));\n    droplets = S(.3, 0., dd);\n    float m = mainDrop+droplets*r*trailFront;\n    \n    //m += st.x>a.y*.45 || st.y>a.x*.165 ? 1.2 : 0.;\n    return vec2(m, trail);\n}\n\nfloat StaticDrops(vec2 uv, float t) {\n\tuv *= 10.;\n    \n    vec2 id = floor(uv);\n    uv = fract(uv)-.5;\n    vec3 n = N13(id.x*107.45+id.y*3543.654);\n    vec2 p = (n.xy-.5)*.7;\n    float d = length(uv-p);\n    \n    float fade = Saw(.025, fract(t+n.z));\n    float c = S(.3, 0., d)*fract(n.z*10.)*fade;\n    return c;\n}\n\nvec2 Drops(vec2 uv, float t, float l0, float l1, float l2) {\n    float s = StaticDrops(uv, t)*l0; \n    vec2 m1 = DropLayer2(uv, t)*l1;\n    vec2 m2 = DropLayer2(uv*1.85, t)*l2;\n    \n    float c = s+m1.x+m2.x;\n    c = S(.3, 1., c);\n    \n    return vec2(c, max(m1.y*l0, m2.y*l1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //格式化uv，（-0.5~0.5大概范围)，除去屏幕比例影响\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    \n    //正常UV，用于对背景图进行采样\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    \n    \n    float T = iTime;\n    \n    \n    float t = T*.2;\n    \n    \n    float rainAmount = sin(T*.05)*.3+.7;\n    \n    float maxBlur = mix(3., 6., rainAmount);\n    float minBlur = 2.;\n    \n    \n    \n    float staticDrops = S(-.5, 1., rainAmount)*2.;\n    //float layer1 = S(.25, .75, rainAmount);\n    //float layer2 = S(.0, .5, rainAmount);\n    \n    //float staticDrops = 0.0;\n    float layer1 = 0.0;\n    float layer2 = 0.0;\n    \n    \n    vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\n\n    \n    \n    \t//vec2 e = vec2(.001, 0.);\n    \t//float cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;\n    \t//float cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;\n    \t//vec2 n = vec2(cx-c.x, cy-c.x);\t\t// expensive normals\n\n    \n    \n\n    \n    //float focus = mix(maxBlur-c.y, minBlur, S(.1, .2, c.x));\n    //vec3 col = textureLod(iChannel0, UV+n, focus).rgb;\n    \n   \n\n    \n    \n    vec3 col = vec3(c,0.0f);\n    //vec3 col = vec3(0.0f);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 61, 87, 259], [262, 262, 280, 280, 326], [328, 328, 357, 357, 392], [395, 395, 430, 430, 1582], [1584, 1584, 1621, 1621, 1897], [1899, 1899, 1959, 1959, 2178], [2180, 2180, 2237, 2309, 3442]], "test": "untested"}
{"id": "wtXBRj", "name": "AA Voxel Pac-Man", "author": "Nrx", "description": "Mix of [url=https://www.shadertoy.com/view/Wl2cDt]Basic 2 pass AA[/url] and [url=https://www.shadertoy.com/view/ltGyWz]Voxel Pac-Man[/url].\n\nUse the mouse to rotate when in 3D.", "tags": ["voxel", "pacman", "aa"], "likes": 17, "viewed": 413, "published": 3, "date": "1597140024", "time_retrieved": "2024-07-30T20:51:16.856425", "image_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Render the scene normally\n\tfragColor = Render (fragCoord, iResolution.xy, iTime, iMouse.xy);\n\n\t// Mix with the scene shifted by half a pixel\n\t// Notes:\n\t// - Linear filtering has to be used to fetch the color\n\t// - A value of 0.8 for the mix returns the actual average of the 5 sampling points,\n\t//   while 0.5 acts more like a Gaussian filter\n\tfragColor = mix (fragColor, texture (iChannel0, (fragCoord + 0.5) / iResolution.xy), 0.5);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Render the scene shifted by half a pixel\n\tfragColor = Render (fragCoord - 0.5, iResolution.xy, iTime, iMouse.xy);\n}", "buffer_a_inputs": [], "common_code": "// Giant Voxel Pac-Man (from https://www.shadertoy.com/view/ltGyWz)\n\n// Parameters\n#define VOXEL_RESOLUTION\t1.0\n#define CAMERA_FOCAL_LENGTH\t8.0\n#define DELTA\t\t\t\t0.01\n#define RAY_LENGTH_MAX\t\t500.0\n#define RAY_STEP_MAX\t\t100.0\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define SHADOW_LENGTH\t\t150.0\n#define SHADOW_POWER\t\t3.0\n#define FADE_POWER\t\t\t0.7\n#define BACKGROUND\t\t\t0.7\n#define GLOW\t\t\t\t0.4\n#define GAMMA\t\t\t\t0.8\n\n//#define GROUND\n\n// Math constants\n#define PI\t\t3.14159265359\n#define SQRT3\t1.73205080757\n\n// Global variables\nfloat time;\nfloat glowCounter;\n\n// PRNG (from https://www.shadertoy.com/view/4djSRW)\nfloat rand (in vec3 seed) {\n\tseed = fract (seed * vec3 (5.3983, 5.4427, 6.9371));\n\tseed += dot (seed.yzx, seed.xyz + vec3 (21.5351, 14.3137, 15.3219));\n\treturn fract (seed.x * seed.y * seed.z * 95.4337);\n}\n\n// Distance to the voxel\nfloat distVoxel (in vec3 p) {\n\n\t// Update the glow counter\n\t++glowCounter;\n\n\t// Rounded box\n\tconst float voxelRadius = 0.25;\n\treturn length (max (abs (p) - 0.5 + voxelRadius, 0.0)) - voxelRadius;\n}\n\n// Distance to the scene and color of the closest point\nvec2 distScene (in vec3 p, out vec3 P) {\n\n\t// Update the glow counter\n\t++glowCounter;\n\n\t// Scaling\n\tp *= VOXEL_RESOLUTION;\n\n\t// Velocity, period of the waves, spacing of the gums\n\tfloat v = VOXEL_RESOLUTION * floor (time * 100.0 / VOXEL_RESOLUTION);\n\tconst float k1 = 0.05;\n\tconst float k2 = 60.0;\n\n\t// Giant Pac-Man\n\tfloat body = length (p);\n\tfloat eyes = 6.0 - length (vec3 (abs (p.x) - 12.5, p.y - 19.5, p.z - 20.0));\n\tfloat mouthAngle = PI * (0.075 + 0.065 * cos (2.0 * v * PI / k2));\n\tfloat mouthTop = dot (p, vec3 (0.0, -cos (mouthAngle), sin (mouthAngle))) - 2.0;\n\tmouthAngle *= 2.5;\n\tfloat mouthBottom = dot (p, vec3 (0.0, cos (mouthAngle), sin (mouthAngle)));\n\tfloat pacMan = max (max (body - 32.0, eyes), min (mouthTop, mouthBottom));\n\tvec2 d = vec2 (pacMan, pacMan > 29.0 - body ? 0.13 : 1.0);\n\tP = p;\n\n\t// Gums\n\tvec3 q = vec3 (p.xy, mod (p.z + v, k2) - k2 * 0.5);\n\tfloat gum = max (length (q) - 6.0, -p.z);\n\tif (gum < d.x) {\n\t\td = vec2 (gum, 0.35);\n\t\tP = q;\n\t}\n\n\t// Ground\n\t#ifdef GROUND\n\tq = vec3 (p.xy, p.z + v);\n\tfloat ground = (q.y + 50.0 + 14.0 * cos (q.x * k1) * cos (q.z * k1)) * 0.7;\n\tif (ground < d.x) {\n\t\td = vec2 (ground, 0.55);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// Ghost\n\tv = VOXEL_RESOLUTION * floor ((110.0 + 40.0 * cos (time * 3.0)) / VOXEL_RESOLUTION);\n\tq = vec3 (p.xy, p.z + v);\n\tbody = length (vec3 (q.x, max (q.y - 4.0, 0.0), q.z));\n\teyes = 8.0 - length (vec3 (abs (q.x) - 12.0, q.y - 10.0, q.z - 22.0));\n\tfloat bottom = (q.y + 28.0 + 4.0 * cos (p.x * 0.4) * cos (p.z * 0.4)) * 0.7;\n\tfloat ghost = max (max (body - 28.0, eyes), -bottom);\n\tif (ghost < d.x) {\n\t\td = vec2 (ghost, ghost > 25.0 - body ? 0.76 : 1.0);\n\t\tP = q;\n\t}\n\n\t// Scaling\n\td.x /= VOXEL_RESOLUTION;\n\treturn d;\n}\n\n// Distance to the (voxelized?) scene\nvec4 dist (inout vec3 p, in vec3 ray, in float voxelized, in float rayLengthMax) {\n\tvec3 P = p;\n\tvec2 d = vec2 (1e10, 0.0);\n\tfloat rayLength = 0.0;\n\tfloat rayLengthInVoxel = 0.0;\n\tfloat rayLengthCheckVoxel = 0.0;\n\tvec3 raySign = sign (ray);\n\tvec3 rayDeltaVoxel = raySign / ray;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tif (rayLength < rayLengthInVoxel) {\n\t\t\td.x = distVoxel (fract (p + 0.5) - 0.5);\n\t\t\tif (d.x < DELTA) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (rayLength < rayLengthCheckVoxel) {\n\t\t\tvec3 rayDelta = (0.5 - raySign * (fract (p + 0.5) - 0.5)) * rayDeltaVoxel;\n\t\t\tfloat dNext = min (rayDelta.x, min (rayDelta.y, rayDelta.z));\n\t\t\td = distScene (floor (p + 0.5), P);\n\t\t\tif (d.x < 0.0) {\n\t\t\t\trayDelta = rayDeltaVoxel - rayDelta;\n\t\t\t\td.x = max (rayLengthInVoxel - rayLength, DELTA - min (rayDelta.x, min (rayDelta.y, rayDelta.z)));\n\t\t\t\trayLengthInVoxel = rayLength + dNext;\n\t\t\t} else {\n\t\t\t\td.x = DELTA + dNext;\n\t\t\t}\n\t\t} else {\n\t\t\td = distScene (p, P);\n\t\t\tif (voxelized > 0.5) {\n\t\t\t\tif (d.x < SQRT3 * 0.5) {\n\t\t\t\t\trayLengthCheckVoxel = rayLength + abs (d.x) + SQRT3 * 0.5;\n\t\t\t\t\td.x = max (rayLengthInVoxel - rayLength + DELTA, d.x - SQRT3 * 0.5);\n\t\t\t\t}\n\t\t\t} else if (d.x < DELTA) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trayLength += d.x;\n\t\tif (rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\t\tp += d.x * ray;\n\t}\n\treturn vec4 (d, rayLength, rand (P));\n}\n\n// Normal at a given point\nvec3 normal (in vec3 p, in float voxelized) {\n\tvec2 h = vec2 (DELTA, -DELTA);\n\tvec3 n;\n\tif (voxelized > 0.5) {\n\t\tp = fract (p + 0.5) - 0.5;\n\t\tn = h.xxx * distVoxel (p + h.xxx) +\n\t\t\th.xyy * distVoxel (p + h.xyy) +\n\t\t\th.yxy * distVoxel (p + h.yxy) +\n\t\t\th.yyx * distVoxel (p + h.yyx);\n\t} else {\n\t\tn = h.xxx * distScene (p + h.xxx, n).x +\n\t\t\th.xyy * distScene (p + h.xyy, n).x +\n\t\t\th.yxy * distScene (p + h.yxy, n).x +\n\t\t\th.yyx * distScene (p + h.yyx, n).x;\n\t}\n\treturn normalize (n);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\n// Main function\nvec4 Render (in vec2 fragCoord, in vec2 iResolution, in float iTime, in vec2 iMouse) {\n\n\t// Make the time global\n\ttime = iTime;\n\n\t// Get the fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution) / iResolution.y;\n\n\t// Define the rendering mode\n\tfloat modeTiming = iTime * 0.234;\n\tfloat modeAngle = PI * cos (iTime * 0.2);\n\tmodeAngle = dot (frag - vec2 (cos (iTime * 2.0), 0.0), vec2 (cos (modeAngle), sin (modeAngle)));\n\tfloat modeVoxel = step (0.5, fract (modeTiming / (4.0 * PI)));\n\tmodeTiming = cos (modeTiming);\n\tfloat mode3D = smoothstep (0.8, 0.5, modeTiming);\n\tfloat modeSwitch = smoothstep (0.995, 1.0, modeTiming) + smoothstep (0.02, 0.0, abs (modeAngle)) * modeVoxel;\n\tmodeVoxel = 1.0 + (step (0.0, modeAngle) - 1.0) * modeVoxel;\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 (frag, mix (12.0, CAMERA_FOCAL_LENGTH, mode3D)));\n\n\t// Compute the orientation of the camera\n\tfloat yawAngle = PI * (1.2 + 0.2 * cos (iTime * 0.5));\n\tfloat pitchAngle = PI * (0.1 * cos (iTime * 0.3) - 0.05);\n\n\tyawAngle += 4.0 * PI * iMouse.x / iResolution.x;\n\tpitchAngle += PI * 0.3 * (1.0 - iMouse.y / iResolution.y);\n\n\tyawAngle = mix (PI * 1.5, yawAngle, mode3D);\n\tpitchAngle *= mode3D;\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 cameraOrientation;\n\tcameraOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\tcameraOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\tcameraOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\tray = cameraOrientation * ray;\n\n\t// Compute the origin of the ray\n\tfloat cameraDist = mix (400.0, 200.0 + 80.0 * cos (iTime * 0.8), mode3D);\n\tvec3 origin = (vec3 (0.0, 0.0, 80.0 * sin (iTime * 0.2) - 20.0) - cameraOrientation [2] * cameraDist) / VOXEL_RESOLUTION;\n\n\t// Compute the distance to the scene\n\tglowCounter = 0.0;\n\tvec4 d = dist (origin, ray, modeVoxel, RAY_LENGTH_MAX / VOXEL_RESOLUTION);\n\n\t// Set the background color\n\tvec3 finalColor = hsv2rgb (vec3 (0.53 - 0.1 * ray.y + 0.1 * modeVoxel, 1.0, mode3D * BACKGROUND));\n\tvec3 glowColor = GLOW * vec3 (1.0, 0.3, 0.0) * glowCounter / RAY_STEP_MAX;\n\tif (d.x < DELTA) {\n\n\t\t// Set the object color\n\t\tvec3 color = d.y != 1.0 ? hsv2rgb (vec3 (d.y + 0.1 * d.w * modeVoxel, 0.5 + 0.5 * modeVoxel, 1.0)) : vec3 (0.0);\n\n\t\t// Lighting\n\t\tvec3 l = normalize (mix (vec3 (1.0, 0.0, 0.0), vec3 (1.25 + cos (iTime * 0.2), 1.0, 1.0), mode3D));\n\t\tif (modeVoxel > 0.5) {\n\t\t\tvec3 n = normal (floor (origin + 0.5), 0.0);\n\t\t\tfloat diffuse = max (0.0, dot (n, l));\n\t\t\tfloat specular = pow (max (0.0, dot (reflect (ray, n), l)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tcolor = (AMBIENT + diffuse) * color + specular;\n\t\t}\n\t\tvec3 n = normal (origin, modeVoxel);\n\t\tfloat diffuse = dot (n, l);\n\t\tfloat specular;\n\t\tif (diffuse < 0.0) {\n\t\t\tdiffuse = 0.0;\n\t\t\tspecular = 0.0;\n\t\t} else {\n\t\t\tspecular = pow (max (0.0, dot (reflect (ray, n), l)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\torigin += n * DELTA * 2.0;\n\t\t\tvec4 shadow = dist (origin, l, modeVoxel, SHADOW_LENGTH / VOXEL_RESOLUTION);\n\t\t\tif (shadow.x < DELTA) {\n\t\t\t\tshadow.z = pow (min (1.0, shadow.z * VOXEL_RESOLUTION / SHADOW_LENGTH), SHADOW_POWER);\n\t\t\t\tdiffuse *= shadow.z;\n\t\t\t\tspecular *= shadow.z;\n\t\t\t}\n\t\t}\n\t\tcolor = (AMBIENT + diffuse) * color + specular;\n\n\t\t// Fading\n\t\tfloat fade = pow (max (0.0, 1.0 - d.z * VOXEL_RESOLUTION / RAY_LENGTH_MAX), FADE_POWER);\n\t\tfinalColor = mix (finalColor, color, fade);\n\t}\n\n\t// Set the fragment color\n\tfinalColor = mix (pow (finalColor, vec3 (GAMMA)) + glowColor, vec3 (1.0), modeSwitch);\n\treturn vec4 (finalColor, 1.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 86, 498]], "test": "untested"}
{"id": "WtXfR2", "name": "Nautilus Submerging", "author": "dr2", "description": "One more page for the Nautilus Book (mouseable)", "tags": ["wave", "ocean", "reflect", "refract", "submarine", "verne"], "likes": 20, "viewed": 509, "published": 3, "date": "1597130268", "time_retrieved": "2024-07-30T20:51:17.918585", "image_code": "// \"Nautilus Submerging\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 vuPos, sunDir;\nfloat dstFar, tCur, sbLen, sbDepth, prpRot;\nint idObj;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4;\n  vec2 q, t, tw;\n  float wAmp, h;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.05 * p + vec2 (0., 0.025 * tCur);\n  wAmp = 1.;\n  h = 0.;\n  tw = 0.1 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 5; j ++) {\n    q *= 2. * qRot;\n    t4 = q.xyxy + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    t4 = abs (sin (t4));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wAmp *= 0.5;\n  }\n  return 0.4 * h * (1. - smoothstep (0.5, 1.2, length (p - vuPos.xz)/ dstFar));\n}\n\nfloat WaveRay (vec3 ro, vec3 rd, float u)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  ro.y *= u;\n  rd.y *= u;\n  s = 0.;\n  sLo = 0.;\n  for (int j = 0; j < 60; j ++) {\n    p = ro + s * rd;\n    h = p.y - u * WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 1.3 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > u * WaveHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),\n     WaveHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  p.y -= sbDepth;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float d, dHit;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjCol (vec3 p, vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p.y -= sbDepth;\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (0.4, 0.3, 0.2, -1.);\n  }\n  return col4;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  int idObjP;\n  idObjP = idObj;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  idObj = idObjP;\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyGrndCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float sd, a, f, ff, fd;\n  a = atan (rd.z, rd.x) + 0.005 * tCur;\n  if (rd.y < 0.01 * Fbm1 (64. * a) - 0.005) {\n    col = mix (vec3 (0.2, 0.35, 0.2), vec3 (0.3, 0.35, 0.35), 0.5 +\n       0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) *\n       (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y)));\n  } else {\n    q = 0.01 * (ro.xz + vec2 (0., 8.) * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = 0.7 * (0.7 + 0.5 * ff) * (vec3 (1.) - vec3 (0.2, 0.2, 0.1) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix ((vec3 (0.7, 0.7, 0.75)), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n    sd = pow (max (dot (rd, sunDir), 0.), 256.);\n    col += (0.1 * sd + 0.3 * pow (sd, 4.)) * vec3 (1., 1., 0.3);\n  }\n  return col;\n}\n\nvec3 SeaFloorCol (vec3 rd)\n{\n  return mix (vec3 (0.05, 0.17, 0.12), vec3 (0., 0.15, 0.2), \n     smoothstep (0.4, 0.7, Fbm2 (2. * rd.xz / rd.y)));\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 2.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return vec3 (0.1, 0.3, 0.4) * (0.2 + 0.4 * (rd.y + 1.)) * (1. + 0.1 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roc, row, vnw, rdo, rdd, colUw;\n  float dstObj, dstWat, dstDom, sh, foamFac, eta, atFac, s, h;\n  bool hitWat, unWat;\n  eta = 1.33;\n  atFac = 5.;\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  dstDom = 5.;\n  roc = ro + dstDom * rd;\n  rdo = rd;\n  dstObj = ObjRay (ro, rd);\n  unWat = (roc.y < WaveHt (roc.xz));\n  dstWat = dstDom + WaveRay (roc, rd, (! unWat ? 1. : -1.));\n  hitWat = (dstWat < min (dstObj, dstFar));\n  if (hitWat) {\n    ro += dstWat * rd;\n    row = ro;\n    vnw = WaveNf (ro, dstWat);\n    if (! unWat) {\n      rd = refract (rd, vnw, 1. / eta);\n    } else {\n      vnw *= -1.;\n      rdd = refract (rd, vnw, eta);\n      rd = (length (rdd) > 0.) ? rdd : reflect (rd, vnw);\n    }\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro, vn);\n    sh = ObjSShadow (ro, sunDir);\n    h = WaveHt (ro.xz) - ro.y;\n    if (col4.a >= 0.) {\n      col = col4.rgb * (0.2 + 0.2 * max (dot (vn, - normalize (vec3 (sunDir.xz, 0.).xzy)), 0.) +\n         0.8 * sh * max (0., max (dot (vn, sunDir), 0.))) + \n         col4.a * step (0.95, sh) * vec3 (1., 0.9, 0.5) * pow (max (0.,\n         dot (sunDir, reflect (rd, vn))), 32.);\n      if (unWat) col += 0.2 * step (0.95, sh) * TurbLt (0.02 * ro, abs (vn), 0.2 * tCur) *\n         (1. - smoothstep (0.5, 0.8, dstObj / dstFar)) * smoothstep (-0.2, -0.1, vn.y);\n      else col *= 0.6 + 0.4 * (1. - smoothstep (1., 4., h));\n    } else col = col4.rgb;\n    col *= mix (vec3 (1.), vec3 (0.7, 0.9, 1.), (unWat ? 1. : smoothstep (0., 0.1, h)));\n  } else {\n    col = (hitWat == unWat) ? SkyGrndCol (ro, rd) : SeaFloorCol (rd);\n  }\n  if (! unWat) {\n    if (hitWat) {\n      col = mix (col, 0.8 * SkyGrndCol (row, reflect (rdo, vnw)), pow (1. - abs (dot (rdo, vnw)), 5.));\n      s = Fbm3 (128. * row);\n      foamFac = pow (smoothstep (0., 1., WaveHt (row.xz) - 0.6) + 0.008 * s, 8.);\n      col = mix (col, vec3 (1.), foamFac);\n    }\n  } else {\n    colUw = UnwCol (rd);\n    if (dstObj < dstFar) {\n      col = mix (colUw, col, min (1., exp (1. - atFac * dstObj / dstFar)));\n    } else if (dstWat < dstFar) {\n      col = (rd.y > 0.) ? mix (colUw, col, exp (- atFac * dstWat / dstFar)) : colUw;\n    } else col = colUw;\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, svn;\n  vec2 canvas, uv;\n  float el, az, zmFac, pr, cr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  pr = 0.95;\n  cr = length (uv);\n  if (cr < pr) {\n    az = 0.5 * pi;\n    el = 0.05 * pi;\n    if (mPtr.z > 0.) {\n      az += 2. * pi * mPtr.x;\n      el += pi * mPtr.y;\n    }\n    az += 0.01 * tCur;\n    el += 0.2 * pi * (SmoothBump (0.25, 0.75, 0.2, mod (0.012 * tCur, 1.)) - 0.5);\n    el = clamp (el, -0.3 * pi, 0.3 * pi);\n    zmFac = 3.2;\n    vuMat = StdVuMat (el, az);\n    ro = vuMat * vec3 (0., 0., -40.);\n    rd = vuMat * normalize (vec3 (uv, zmFac));\n    sbDepth = -4. + 4. * sin (0.05 * pi * tCur);\n    ro.y += sbDepth;\n    vuPos = ro;\n    sunDir = normalize (vec3 (-0.5, 1., 0.2));\n    dstFar = 300.;\n    col = ShowScene (ro, rd);\n  } else {\n    cr -= pr + 0.1;\n    svn = normalize (vec3 (0.6 * normalize (uv) * SmoothBump (0., 0.04, 0.01,\n       abs (abs (cr) - 0.1)) * sign (cr), -1.));\n    svn = VaryNf (256. * vec3 (uv, 1.), svn, 0.5);\n    col = vec3 (0.6, 0.5, 0.1) * (0.2 + 0.8 * max (dot (svn, normalize (vec3 (1., 1., -1.))), 0.));\n    col = mix (col * (0.1 + 0.9 * smoothstep (0., 0.005, abs (length (Rot2D (uv, 2. * pi *\n       (floor (12. * atan (uv.y, - uv.x) / (2. * pi) + 0.5) / 12.)) + vec2 (pr + 0.1, 0.)) - 0.03))),\n       vec3 (0.2, 0.2, 0.) * Fbm2 (256. * uv), step (0.1, cr));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXfR2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[971, 971, 994, 994, 1601], [1603, 1603, 1646, 1646, 2169], [2171, 2171, 2202, 2202, 2365], [2367, 2367, 2389, 2389, 5288], [5290, 5290, 5323, 5323, 5499], [5501, 5501, 5522, 5522, 5770], [5772, 5772, 5803, 5803, 8287], [8289, 8289, 8326, 8326, 8597], [8599, 8599, 8635, 8635, 9587], [9589, 9589, 9617, 9617, 9736], [9738, 9738, 9778, 9778, 10238], [10240, 10240, 10263, 10263, 10616], [10618, 10618, 10653, 10653, 12948], [12950, 12950, 13003, 13003, 14510], [14512, 14512, 14545, 14545, 14634], [14636, 14636, 14682, 14682, 14729], [14731, 14731, 14764, 14764, 14791], [14793, 14793, 14835, 14835, 14886], [14888, 14888, 14947, 14947, 15078], [15080, 15080, 15133, 15133, 15194], [15196, 15196, 15226, 15226, 15339], [15341, 15341, 15377, 15377, 15583], [15585, 15585, 15642, 15642, 15725], [15759, 15759, 15783, 15783, 15836], [15838, 15838, 15862, 15862, 15974], [15976, 15976, 16000, 16000, 16119], [16121, 16121, 16146, 16146, 16292], [16294, 16294, 16319, 16319, 16505], [16507, 16507, 16532, 16532, 16757], [16759, 16759, 16781, 16781, 16935], [16937, 16937, 16958, 16958, 17113], [17115, 17115, 17136, 17136, 17291], [17293, 17293, 17322, 17322, 17534], [17536, 17536, 17575, 17575, 17755]], "test": "untested"}
{"id": "WlfBzj", "name": "I'm a little field of color", "author": "darknoon", "description": "Just a gaussian * sine moving around ", "tags": ["particles", "gaussian"], "likes": 6, "viewed": 301, "published": 3, "date": "1597115608", "time_retrieved": "2024-07-30T20:51:18.778286", "image_code": "#define R iResolution\n#define N 6\n#define duration 13.0\n\nfloat sit(float x, float q) {\n    return cos(3.14159*q*x)*exp2(-0.5*x*x);\n}\n\nfloat sinc(float x, float q) {\n    return cos(3.14159*x)/(3.14159*x);\n}\n\n\nvec4 hash4( vec3 p )\n{\n    vec4 q = vec4( dot(p,vec3(127.1,311.7,256.8)), \n\t\t\t\t   dot(p,vec3(269.5,183.3,012.5)), \n\t\t\t\t   dot(p,vec3(419.2,371.9,167.1)),\n                   dot(p,vec3(269.5,183.3,918.1))\n                 );\n\treturn fract(sin(q)*43758.5453);\n}\n\n\nvec4 noise24(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    vec4 h0 = hash4(p.xyy);\n    vec4 h1 = hash4(p.xyy + vec3(1.,0.,0.));\n    \n    return mix(h0, h1, smoothstep(0., 1., f.x));\n}\n\nvec3 a = vec3(0.5, 0.5, 0.5);\nvec3 b = vec3(0.5, 0.5, 0.5);\nvec3 c = vec3(1.0, 1.0, 1.0);\nvec3 d = vec3(0.00, 0.33, 0.67);\n\n// isquilez color mapper\nvec3 colorMap(float t) {\n\treturn (a + b * cos(2. * 3.141 * (c * t + d)));\n}\n\n\nvoid mainImage(out vec4 color, in vec2 fc)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fc/R.xy;\n    uv -= 0.5;\n    uv.x *= R.x / R.y;\n\n    // Time varying pixel color\n    vec3 col = 0.05 * (colorMap(0.1*iTime) - 0.5);\n    \n    float str = 3. / float(N);\n    \n    for (int i=0; i<N; i++) {\n        float phase = float(i) * 356.4878;\n        vec4 n = noise24(vec2(iTime / duration + phase, float(i)));\n        vec2 p = n.xy - 0.5;\n        float k = sin(8.*n.z);\n        float r = 4.*length(uv - p);\n        vec3 pcolor = colorMap(n.w + 0.8*r);\n    \tcol += k * str * sit(r, 1.5)*pcolor;\n    }\n    \n\n    // Output to screen\n    col = smoothstep(-1.0, 1.0, col);\n    \n    // Blue noise dither\n    vec2 offset = fract(sin(iTime * vec2(1231.25, 53823.0))*43758.5453);\n    vec2 tc = fc / iChannelResolution[0].xy + offset;\n    col += 6. / 256. * (texture(iChannel0, tc).rgb - 0.5);\n\n    color.rgb = col;\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfBzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 86, 86, 132], [134, 134, 164, 164, 205], [208, 208, 230, 230, 467], [470, 470, 492, 492, 672], [798, 823, 847, 847, 898], [901, 901, 945, 995, 1820]], "test": "untested"}
{"id": "ttXfDM", "name": "The Hole", "author": "BackwardsCap", "description": "It feels a little off but its pretty close to what I was going for.\n\nInspired by this tweet: https://twitter.com/PelletierAuger/status/1291072500521148419", "tags": ["hole"], "likes": 4, "viewed": 322, "published": 3, "date": "1597112552", "time_retrieved": "2024-07-30T20:51:19.646963", "image_code": "#define R iResolution.xy\n#define px 3./R.y\n#define tau 6.2831853\n\nfloat line(vec2 s, vec2 d, vec2 p)\n{\n    vec2 p1 = p-s,\n    \t p2 = p-d;\n    \n    float u = dot(p1,p2);\n    float v = dot(p2,p2);\n    float z = u/v;\n    float h = clamp(z,0.,1.);\n                    \n    return smoothstep(0.,px,length(p1-p2*h));\n}\n\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 p = (2.*f-R.xy)/R.y;\n    float iter = 50., t = iTime/4.0;\n    vec2 rot = vec2(sin(t),cos(t)), lp;\n    p+=dot(p*rot,rot.yx)/10.;\n    vec3 col = vec3(1);\n    \n    for(float i=0.;i<iter;i++)\n    {\n        float k = i/iter;\n        \n    \tlp = vec2(sin(k*tau), cos(k*tau))/2.;\n        \n    \tcol *= line(lp, (lp+rot)*100., p);\n    }\n    \n    float cv = length(p)-.5;\n    col+=smoothstep(0.0,px,cv);\n    if(cv<0.) col*=smoothstep(0.,1.,(length(p+rot)-.4));\n    col=clamp(col,0.,1.);\n    c.rgb = col*smoothstep(0.,px,max(cv, -cv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXfDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 102, 102, 312], [315, 315, 356, 356, 891]], "test": "untested"}
{"id": "wdsBWB", "name": "exclamation-colored!", "author": "ichi_raven", "description": "exclamation", "tags": ["art"], "likes": 0, "viewed": 265, "published": 3, "date": "1597108815", "time_retrieved": "2024-07-30T20:51:20.495694", "image_code": "bool box(vec2 st, vec2 ul, vec2 dr)\n{\n    return\n    st.x > ul.x\n    && st.x < dr.x\n    && st.y > ul.y\n    && st.y < dr.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy)\n        \t\t/ min(iResolution.x, iResolution.y);\n\n\n    if(box(uv, vec2(-0.15, -0.2), vec2(0.15, 0.8))\n        || box(uv, vec2(-0.15, -0.7), vec2(0.15, -0.4)))\n        fragColor = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)),1.0);\n    else\n        fragColor = vec4(1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 124], [126, 126, 183, 233, 549]], "test": "untested"}
{"id": "tlsfzB", "name": "3D hyperjump to a star", "author": "Leria", "description": "The effect is done with 3D ray marching. But it can be done also in 2D I think.\nOnly the noise is moving through a tube, the camera is at the \"extremity\" of the tube (cylinder) and doesn't move\nIt's an animation without user interaction !", "tags": ["noise", "raymarch", "star", "shockwave"], "likes": 11, "viewed": 688, "published": 3, "date": "1597104868", "time_retrieved": "2024-07-30T20:51:21.352404", "image_code": "\n//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define THICK\t\t\t\t2.\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nature of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t0\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nfloat anim = 0.;\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1./4.); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*5.5;\n   \ts = 2./pow(stretching,vec3(.25));\n    #endif    \n    \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 5.), m.pos); \n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    \n    for(int s = 10; s <110; s++)\n    {               \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        float d = length(center)-RADIUS-.5-jit*k;\n        float size = length(center)/RADIUS;\n\n        if(sdf_rounded_cylinder( center, 1.20, 0.2, 5. ) < 0.)\n        {\n            \n            #if COLOR            \n            #if ANIM      \n            \tanim = iTime/5.;\n            \n            #endif\n            \n            \n            float n = fbm( ( \n                (p)/( clamp(0., RADIUS+1., length(center)) + cos(PI-Psnoise(p/(30.)) )- 1./size*anim) //shockwave stuff\n            \t\t\t) )  ;; ;\n            // 1./size is the speed of the wave propgation \n            /////////////////////\n\n            float mask = smoothstep(0.,\n                                   \t70.*RADIUS,\n                                    RADIUS/length(center));\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                               \t  0.,\n                                  1.) *n);\n                        \n           if(length(p-cam.pos) >(dist_center+m.radius) \n              )//|| (k*dens  < -9.9))\n        \t{\n         \tbreak;\n        \t}\n            //How colors (rgb) are absorbed at point p in the current iteration\n            //k is the step size          \n             vec3 rgb_t = exp(-vec3(\n                \t\tk * 25. * f(p.x) * dens, \n                      \tk * 10. * dens,\n              \t      \tk * 15. * f(p.z) * dens ));    \n                \n    \t\t//blending\n   \t\t\tc += t_acc*vec3(1.)*(1.-rgb_t);\n                        t_acc *= (rgb_t);           \n\n            #endif\n        }\n\n        //if it will never be in the shape anymore, return;        \n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n        \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(0.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * vec2(iResolution.x/2., iResolution.y/4.)/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n\n", "image_inputs": [], "common_code": "#define PI \t\t\t\t\t3.1415926\n\n//most of it, come from iq\n\n\nfloat sdf_rounded_cylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1382, 1382, 1407, 1420, 1794], [1796, 1796, 1821, 1834, 2172], [2174, 2174, 2193, 2193, 2286], [2288, 2307, 2383, 2383, 2430], [2432, 2432, 2464, 2464, 2484], [2486, 2486, 2520, 2520, 2542], [2629, 2629, 2670, 2670, 2706], [2708, 2708, 2794, 2794, 2829], [2831, 2831, 2855, 2855, 2903], [2905, 2905, 2945, 2945, 3249], [3251, 3251, 3275, 3275, 3338], [3341, 3341, 3393, 3393, 5932], [5935, 5935, 5992, 5992, 6652]], "test": "untested"}
{"id": "wllfzB", "name": "Fourier Kifs", "author": "wyatt", "description": "I seriously have no idea what's going on here - I just copy-pasted some code from rory", "tags": ["fourier"], "likes": 12, "viewed": 322, "published": 3, "date": "1597101214", "time_retrieved": "2024-07-30T20:51:22.211108", "image_code": "// Fork of \"Convolution DFT\" by wyatt. https://shadertoy.com/view/tsSfzc\n// 2020-08-10 22:56:40\n\nMain {\n    float l = length(A(mod(R/R.y*(U-0.5*R),R)).xy);\n\tQ = 0.5+0.5*sin(log(1.+10.*l)+vec4(1,2,3,4));\n\tif (iMouse.z>0.&&iMouse.x>U.x)Q = B(U);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R (iResolution.xy)\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define pi 3.14159265359\nmat2 e (float t) {\n    float c = cos(t),s = sin(t);\n\treturn mat2(c,-s,s,c);\n}\n#define Main void mainImage( out vec4 Q, in vec2 U )", "buffer_b_code": "Main {\n\tQ = vec4(0);\n    Q.xy = vec2(0,exp(-1e-4*dot(U-0.5*R,U-0.5*R)));\n    float d = 2.;\n    float n = max(4.+4.*sin(.666*iTime),3.);\n        \n    for(float i = 1.; i < 8.; i++){\n        vec2 w = vec2(0);\n        \n        for (float j = 0.; j < 15.; j++) {\n            if (j >= n) break;\n            float a = d*dot(U-0.5*R,vec2(0,1)*e(j*6.2/n+iTime*sqrt(i)));\n        \tw += vec2(0,1)*e(a);\n        }  \n        Q.xy = mat2(Q.xy,-Q.y,Q.x)*w;\n        d*=.35+.5/n;\n        Q*=.35+.5/n;\n    }\n    if (length(U-0.5*R)>0.5*R.y) Q*=0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R;\n    for (float i = 0.; i < R.x; i++) {\n        Q.xy += A(vec2(i,U.y)).xy*e(w.x*i)/sqrt(R.x);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R;\n    for (float i = 0.; i < R.y; i++) {\n        Q.xy += A(vec2(U.x,i)).xy*e(w.y*i)/sqrt(R.y);\n   }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ttsyzf", "name": "Volumetric Render for Practice", "author": "specialsaucewc", "description": "A volumetric renderer with sdf and value noise following Christopher Wallis Blog\nhttps://wallisc.github.io/rendering/2020/05/02/Volumetric-Rendering-Part-1.html", "tags": ["sdf", "volumetric", "valuenoise", "student"], "likes": 3, "viewed": 423, "published": 3, "date": "1597090758", "time_retrieved": "2024-07-30T20:51:23.248335", "image_code": "// Base code by Christopher Wallis\n// https://www.shadertoy.com/view/tdffzn\n    \n\nOrbLightDescription GetLight(int lightIndex)\n{\n    float theta = iTime * 0.7 + float(lightIndex) * PI * 2.0 / float(NUM_LIGHTS);\n    float radius = 25.5;\n    \n    OrbLightDescription orbLight;\n    orbLight.Position = vec3(radius * cos(theta), 5.0 + sin(theta * 2.0) * 2.5, radius * sin(theta));\n    orbLight.LightColor = GetLightColor(lightIndex) * LIGHT_INTENSITY;\n    orbLight.Radius = 1.0f;\n\n    return orbLight;\n}\n\nMaterial GetMaterial(int materialID, vec3 position)\n{\n    Material materials[NUM_MATERIALS];\n\tmaterials[CHECKER_FLOOR_MATERIAL_ID] = NormalMaterial(vec3(0.6, 0.6, 0.7), 0);\n    materials[DEBUG_MATERIAL_ID] = NormalMaterial(vec3(0.6, 0.6, 0.7), 0);\n    \n    for (int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++) {\n        materials[LAMP_MATERIAL_ID + lightIndex] = NormalMaterial(GetLight(lightIndex).LightColor, MATERIAL_IS_LIGHT_SOURCE);\n    }\n    \n    Material mat;\n    if(materialID < int(NUM_MATERIALS))\n    {\n        mat = materials[materialID];\n    }\n    else\n    {\n        // Should never get hit\n   \t\treturn materials[0];\n    }\n    \n    if(materialID == CHECKER_FLOOR_MATERIAL_ID)\n    {\n        vec2 uv = position.xz / 13.0;\n        uv = vec2(uv.x < 0.0 ? abs(uv.x) + 1.0 : uv.x, uv.y < 0.0 ? abs(uv.y) + 1.0 : uv.y);\n        if((int(uv.x) % 2 == 0 && int(uv.y) % 2 == 0) || (int(uv.x) % 2 == 1 && int(uv.y) % 2 == 1))\n        {\n            mat.albedo = vec3(1, 1, 1) * 0.7;\n        }\n    }\n\n    return mat;    \n}\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nfloat PlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planeOrigin, vec3 planeNormal, out vec3 normal) \n{ \n    float t = -1.0f;\n    normal = planeNormal;\n    float denom = dot(-planeNormal, rayDirection); \n    if (denom > EPSILON) { \n        vec3 rayToPlane = planeOrigin - rayOrigin; \n        return dot(rayToPlane, -planeNormal) / denom; \n    } \n \n    return t; \n} \n\n\nfloat SphereIntersection(\n    in vec3 rayOrigin, \n    in vec3 rayDirection, \n    in vec3 sphereCenter, \n    in float sphereRadius, \n    out vec3 normal)\n{\n      vec3 eMinusC = rayOrigin - sphereCenter;\n      float dDotD = dot(rayDirection, rayDirection);\n\n      float discriminant = dot(rayDirection, (eMinusC)) * dot(rayDirection, (eMinusC))\n         - dDotD * (dot(eMinusC, eMinusC) - sphereRadius * sphereRadius);\n\n      // If the ray doesn't intersect\n      if (discriminant < 0.0) \n         return -1.0;\n\n      float firstIntersect = (dot(-rayDirection, eMinusC) - sqrt(discriminant))\n             / dDotD;\n      \n      float t = firstIntersect;\n    \n      // If the ray is inside the sphere\n      if (firstIntersect < EPSILON) {\n         t = (dot(-rayDirection, eMinusC) + sqrt(discriminant))\n             / dDotD;\n      }\n    \n      normal = normalize(rayOrigin + rayDirection * t - sphereCenter);\n      return t;\n}\n\n\nvoid UpdateIfIntersected(\n    inout float t,\n    in float intersectionT, \n    in vec3 intersectionNormal,\n    in int intersectionMaterialID,\n    out vec3 normal,\n    out int materialID\n\t)\n{    \n    if(intersectionT > EPSILON && intersectionT < t)\n    {\n\t\tnormal = intersectionNormal;\n        materialID = intersectionMaterialID;\n        t = intersectionT;\n    }\n}\n\n\nfloat IntersectOpaqueScene(in vec3 rayOrigin, in vec3 rayDirection, out int materialID, out vec3 normal)\n{\n    float intersectionT = LARGE_NUMBER;\n    vec3 intersectionNormal = vec3(0, 0, 0);\n\n    float t = LARGE_NUMBER;\n    normal = vec3(0, 0, 0);\n    materialID = INVALID_MATERIAL_ID;\n\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        UpdateIfIntersected(\n            t,\n            SphereIntersection(rayOrigin, rayDirection, GetLight(lightIndex).Position, GetLight(lightIndex).Radius, intersectionNormal),\n            intersectionNormal,\n            LAMP_MATERIAL_ID + lightIndex,\n            normal,\n            materialID);\n    }\n\n    \n    UpdateIfIntersected(\n        t,\n        PlaneIntersection(rayOrigin, rayDirection, vec3(0, 0, 0), vec3(0, 1, 0), intersectionNormal),\n        intersectionNormal,\n        CHECKER_FLOOR_MATERIAL_ID,\n        normal,\n        materialID);\n\n    \n    return t;\n}\n\n\nfloat SdVolume(vec3 p) {\n    float t = iTime;\n    vec4 center = vec4(0, 7, 0, 11);\n    vec4 wisp = vec4(13., 8.*sin(t) + 16., 2., 6.5);\n    float offset = 8.*sin(t*.75);\n    vec4 roam = vec4(offset, 6.*sin(t*1.5)+14., offset, 9.);\n    \n    float d = SdSphere(p, center.xyz, center.a);\n    float dt = SdSphere(p, wisp.xyz, wisp.w);\n    d = SdSmoothUnion(d, dt, BLEND_STRENGTH);\n    float dr = SdSphere(p, roam.xyz, roam.w);\n    d = SdSmoothUnion(d, dr, BLEND_STRENGTH);\n    \n    vec3 fbmCoord = (p + 2. * vec3(iTime, 0., iTime)) / NOISE;\n    d += NOISE_HEIGHT * fbm(fbmCoord);\n    \n    dt = SdPlane(p + vec3(0., .1, 0.));\n    d = SdSmoothUnion(d, dt, BLEND_STRENGTH * GROUND_STICK);\n    \n    return d;\n}\n\nfloat IntersectVolumetric(in vec3 rayOrigin, in vec3 rayDirection, in float maxDist, out int materialID, out vec3 normal) {\n    materialID = INVALID_MATERIAL_ID;\n\n    float dO = 0.;\n    vec3 p = vec3(0.);\n    for (int i=0; i<MAX_STEPS; i++) {\n        p = rayOrigin + dO*rayDirection;\n        float ds = SdVolume(p);\n        dO += ds;\n        if (ds < SURFACE_DIST || dO > maxDist) break;\n    }\n    \n    return dO;\n}\n\nfloat VolumeLightVisibility(in vec3 rO, in vec3 rDir, in float maxT, in int numSteps, in float marchSize) {\n\tfloat t = 0.;\n    float lightVis = 1.;\n    for(int i=0;i<numSteps;i++) {\n    \tt += marchSize;\n        if (t > maxT) break;\n        \n        vec3 p = rO + t*rDir;\n        if (SdVolume(p) < 0.) {\n            lightVis *= BeerLambert(VOLUMETRIC_ABSORPTION, marchSize);\n        }\n    }\n    return lightVis;\n}\n\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDir, Material material, inout vec3 color)\n{\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        vec3 lightDir = (GetLight(lightIndex).Position - position);\n        float lightDist = length(lightDir);\n        lightDir = normalize(lightDir);\n\n        // Manually tuned light falloff for what looked best\n        vec3 lightColor = GetLight(lightIndex).LightColor\n            * GetLightAttenuation(lightDist);\n        \n        #if CAST_SHADOW_ON_OPAQUE\n        if (!IsColorInsignificant(lightColor)) {\n        \tlightColor *= VolumeLightVisibility(position, lightDir, lightDist, MAX_SHADOWMARCH_STEPS, .6);\n        }\n        #endif\n\n        color += lightColor * pow(max(dot(reflectionDir, lightDir), 0.0), 4.0);\n        color += lightColor * Diffuse(normal, lightDir, material.albedo);\n    \n    }\t\n    color += AMBIENT_LIGHT * material.albedo;\n}\n\nfloat FogDensity(vec3 p, float sdfValue) {\n\tfloat sdfMultiplier = sdfValue < 0.\n        ? min(abs(sdfValue), 1.)\n        : 0.;\n    float density = abs(fbm(p/6.)+.5);\n    return sdfMultiplier * density;\n}\n\nvec3 Render( in vec3 rayOrigin, in vec3 rayDir)\n{    \n    vec3 vColor = vec3(0.);\n    vec3 oColor = vec3(0.);\n    float fDepth = SCENE_MAX_T;\n    float oVisibility = 1.;\n    const float marchSize = .6;\n    \n    vec3 normal, vnormal;\n    int vmaterialId = INVALID_MATERIAL_ID;\n    int materialId = INVALID_MATERIAL_ID;\n    \n    float oDepth = IntersectOpaqueScene(rayOrigin, rayDir, materialId, normal);\n    \n    //we hit the ground or light, do lighting after volumetric\n    if (materialId != INVALID_MATERIAL_ID) {\n        fDepth = oDepth;\n    }\n    \n    float vDepth = IntersectVolumetric(rayOrigin, rayDir, fDepth, vmaterialId, vnormal);\n    \n    if (vDepth > 0.) {\n        //raymarch through volume\n        for (int i=0;i<MAX_VOLUME_STEPS;i++) {\n        \tvDepth += marchSize;\n            \n            if (vDepth > oDepth)\n                break;\n            \n            vec3 p = rayOrigin + rayDir * vDepth;\n            float sdfValue = SdVolume(p);\n            bool inVolume = sdfValue < 0.;\n            if (inVolume) {\n            \tfloat prevOVisibility = oVisibility;\n                //reduce visibility by volume density and absorption\n                oVisibility *= BeerLambert(VOLUMETRIC_ABSORPTION * FogDensity(p, sdfValue), marchSize);\n                //stop if results are negligable\n                if (oVisibility < MIN_OPACITY) break;\n                float marchAbsorption = prevOVisibility - oVisibility;\n                \n                //raymarch each light for its contribution at p\n                for(int lightIndex=0;lightIndex<NUM_LIGHTS;lightIndex++) {\n                \tvec3 lightDir = GetLight(lightIndex).Position - p;\n                    float lightDist = length(lightDir);\n                    lightDir = normalize(lightDir);\n                    vec3 lightCol = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDist);\n                    //raymarch to light only if value is noticable\n                    if (!IsColorInsignificant(lightCol)) {\n                        lightCol *= VolumeLightVisibility(p, lightDir, lightDist, MAX_LIGHTMARCH_STEPS, marchSize*1.4);\n                    }\n                    \n                    vColor += marchAbsorption * VOLUMETRIC_ALBEDO * lightCol;\n                }\n                //Add ambient volume color\n                vColor += marchAbsorption * VOLUMETRIC_ALBEDO * AMBIENT_LIGHT;\n            }\n        }\n    }\n    \n    //we hit opaque obj\n    if( materialId != INVALID_MATERIAL_ID )\n    {\n        vec3 position = rayOrigin + oDepth*rayDir;\n        Material material = GetMaterial(materialId, position);\n\t\tif(IsLightSource(material))\n        {\n            oColor = min(material.albedo, vec3(1.0));\n        }       \n        else {\n        \tvec3 reflectionDir = reflect( rayDir, normal);\n        \tCalculateLighting(position, normal, reflectionDir, material, oColor);\n        }\n    }\n    return min(vColor, 1.) + oVisibility * oColor; \n}\n\nfloat GetCameraPositionYOffset()\n{\n    return 250.0 * (iMouse.y / iResolution.y);\n}\n\nfloat GetRotationFactor()\n{\n    if(iMouse.x <= 0.0)\n    {\n        // Default value when shader is initially loaded up\n        return 0.65f;\n    }\n    \n    return iMouse.x / iResolution.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x /  iResolution.y; \n    float lensWidth = Camera.LensHeight * aspectRatio;\n    \n    vec3 CameraPosition = Camera.Position + GetCameraPositionYOffset();\n    \n    vec3 NonNormalizedCameraView = Camera.LookAt - CameraPosition;\n    float ViewLength = length(NonNormalizedCameraView);\n    vec3 CameraView = NonNormalizedCameraView / ViewLength;\n\n    vec3 lensPoint = CameraPosition;\n    \n    // Pivot the camera around the look at point\n    {\n        float rotationFactor = GetRotationFactor();\n        mat3 viewMatrix = GetViewMatrix(rotationFactor);\n        CameraView = CameraView * viewMatrix;\n        lensPoint = Camera.LookAt - CameraView * ViewLength;\n    }\n    \n    // Technically this could be calculated offline but I like \n    // being able to iterate quickly\n    vec3 CameraRight = cross(CameraView, vec3(0, 1, 0));    \n    vec3 CameraUp = cross(CameraRight, CameraView);\n\n    vec3 focalPoint = lensPoint - Camera.FocalDistance * CameraView;\n    lensPoint += CameraRight * (uv.x * 2.0 - 1.0) * lensWidth / 2.0;\n    lensPoint += CameraUp * (uv.y * 2.0 - 1.0) * Camera.LensHeight / 2.0;\n    \n    vec3 rayOrigin = focalPoint;\n    vec3 rayDirection = normalize(lensPoint - focalPoint);\n    \n    vec3 color = Render(rayOrigin, rayDirection);\n    \n    #if USE_BLUE_NOISE\n    if (Luminance(color) > NOISE_THRESHOLD) {\n        float noise = (texture(iChannel0, uv).r -.5) * NOISE_JITTER;\n        color += noise;\n    }\n    #endif\n    \n    color = LinearToSRGB(color);\n    fragColor=vec4( color, 1.0 );\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159\n#define LARGE_NUMBER 1e20\n#define EPSILON 0.0001\n#define SCENE_MAX_T 900.0\n\n//features\n#define CAST_SHADOW_ON_OPAQUE 1\n#define USE_BLUE_NOISE 0\n\n//lighting\n#define NUM_LIGHTS 3\n#define LIGHT_ATTENUATION 1.65\n#define LIGHT_INTENSITY 15.\n#define AMBIENT_LIGHT vec3(.028, .016, .016)\n#define VOLUMETRIC_ALBEDO vec3(.9)\n#define VOLUMETRIC_ABSORPTION .25\n#define MIN_OPACITY .05\n#define NOISE_JITTER .02\n#define NOISE_THRESHOLD .03\n\n//volume shape\n#define BLEND_STRENGTH 1.75\n#define GROUND_STICK 13.\n#define NUM_OCTAVES 4\n#define NOISE 3.\n#define NOISE_HEIGHT 5.\n\n//raymarch\n#define MAX_STEPS 40\n#define MAX_VOLUME_STEPS 40\n#define MAX_SHADOWMARCH_STEPS 25\n#define MAX_LIGHTMARCH_STEPS 25\n#define SURFACE_DIST .03\n\n//materials\n#define INVALID_MATERIAL_ID int(-1)\n#define CHECKER_FLOOR_MATERIAL_ID 0\n#define LAMP_MATERIAL_ID 2\n#define DEBUG_MATERIAL_ID 1\n#define NUM_MATERIALS (LAMP_MATERIAL_ID + NUM_LIGHTS + 1)\n#define MATERIAL_IS_LIGHT_SOURCE 0x1\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 emissive;\n    int flags;\n};\n\nstruct CameraDescription\n{\n    vec3 Position;\n    vec3 LookAt;    \n\n    float LensHeight;\n    float FocalDistance;\n};\n    \nstruct OrbLightDescription\n{\n    vec3 Position;\n    float Radius;\n    vec3 LightColor;\n};\n    \nCameraDescription Camera = CameraDescription(\n    vec3(0, 70, 165),\n    vec3(0, 5, 0),\n    2.0,\n    7.0\n);\n    \nvec3 GetLightColor(int lightIndex) {\n    switch(lightIndex % NUM_LIGHTS)\n    {\n        case 0: return vec3(1., 0., 1.);\n        case 1: return vec3(0., 1., 0.);\n        case 2: return vec3(1.0, .5, 0.02);\n        case 3: return vec3(0., 0., 1.);\n    }\n    return vec3(1., 0., 0.);\n}\n\nfloat GetLightAttenuation(float distanceToLight)\n{\n    return 1. / pow(distanceToLight, LIGHT_ATTENUATION);\n}\n\nMaterial NormalMaterial(vec3 albedo, int flags)\n{\n    return Material(albedo, vec3(0), flags);\n}\n\nbool IsLightSource(in Material m)\n{\n    return (m.flags & MATERIAL_IS_LIGHT_SOURCE) != 0;\n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nfloat Luminance(vec3 color)\n{\n    return (color.r * 0.3) + (color.g * 0.59) + (color.b * 0.11);\n}\n\nbool IsColorInsignificant(vec3 color)\n{\n    const float minValue = 0.009;\n    return Luminance(color) < minValue;\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// --------------------------------------------//\n//               Noise Functions\n// --------------------------------------------//\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\nfloat fbm( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat SdSmoothUnion( float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat SdPlane( vec3 p ) {\n    return p.y;\n}\n\nfloat SdSphere( vec3 p, vec3 origin, float s ) {\n  p = p - origin;\n  return length(p)-s;\n}\n\nmat3 GetViewMatrix(float xRotationFactor)\n{ \n   float xRotation = ((1.0 - xRotationFactor) - 0.5) * PI * 0.4 + PI * 0.25;\n   return mat3( cos(xRotation), 0.0, sin(xRotation),\n                0.0,           1.0, 0.0,    \n                -sin(xRotation),0.0, cos(xRotation));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 128, 128, 499], [1534, 1673, 1787, 1787, 2048], [2052, 2052, 2206, 2206, 2974], [2977, 2977, 3166, 3166, 3340], [3343, 3343, 3449, 3449, 4276], [4279, 4279, 4303, 4303, 4981], [4983, 4983, 5106, 5106, 5398], [5400, 5400, 5507, 5507, 5812], [5814, 5814, 5879, 5879, 5967], [5969, 5969, 6078, 6078, 6905], [6907, 6907, 6949, 6949, 7110], [7112, 7112, 7161, 7161, 10028], [10030, 10030, 10064, 10064, 10113], [10115, 10115, 10142, 10142, 10304], [10306, 10306, 10363, 10363, 11952]], "test": "untested"}
{"id": "tlsBzS", "name": "Golfing Box Filter - 169 chars", "author": "GregRostami", "description": "Golfing my previous Brute Force Box Filter.\n[url]https://www.shadertoy.com/view/tlffzS[/url]\nI removed one of the two \"for\" loops.\nPlease help me make it smaller ... Thank you.", "tags": ["2d", "onetweet", "golfing"], "likes": 5, "viewed": 375, "published": 3, "date": "1597086862", "time_retrieved": "2024-07-30T20:51:24.126985", "image_code": "// Golfing \"Brute Force Box Filter\" by removing a for loop\n// Hard coded to super sample a pixel 100 times!\n// 163 chars - Fabrice removed 11 chars by MAGIC!\nvoid mainImage(out vec4 O, vec2 U)\n{\n    O*=0.;\n    for( vec2 R = iResolution.xy, u;\n       O.a++ < 1e2;\n       O += max( u = fract(3.*u + .3*iTime), u.x-u) .y / 1e2 )\n    u *= R.y / dot( u = U-.5*R + fract(O.a/vec2(10,100)), u );\n}\n/*\n            \n            \n// 160 chars - My original shader         \n#define mainImage(O,U)                                                            \\\n        for (vec2 R = iResolution.xy, u; O.a++ < 1e2;                             \\\n             u /= dot(u = ((U + vec2( fract(O.a*.1), O.a/1e2) ) - .5*R)/R.y, u))  \\\n                O += max(u=fract(3.*u + .3*iTime),u.x-u).y / 1e2\n*/", "image_inputs": [{"id": 23711, "src": "https://soundcloud.com/farooq-saeed-khan/inception-theme-hans-zimmer", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 158, 194, 194, 390]], "test": "untested"}
{"id": "tllfRS", "name": "Electronic board by MareeBree", "author": "mareebree", "description": "Electronic board\n", "tags": ["digital"], "likes": 6, "viewed": 294, "published": 3, "date": "1597085668", "time_retrieved": "2024-07-30T20:51:25.003642", "image_code": "#define S(x,y,z) smoothstep(x,y,z)\n#define AR (iResolution.x/iResolution.y)\n\n#define pUP 0\n#define pEND 1\n#define pLEFT 2\n#define pRIGHT 3\n#define pFLEFT 4\n#define pFRIGHT 5\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat dist(vec2 uv,vec2 x)\n{\n\treturn length(uv-x*vec2(1.0,1.0/AR));\n}\n\nvec3 circle(vec2 uv,float r, float lt)\n{\n    float lb = 0.005; // line blur\n    float d = dist(uv,vec2(0.5));\n    return vec3(min(S(r-lb-lt,r-lt,d),S(r+lb+lt,r+lt,d)));\n}\n\nvec3 lineUp(vec2 uv, float lt /*line thickness*/)\n{\n    float lb = 0.005; // line blur\n    return vec3(min(S(0.5-lb-lt,0.5-lt,uv.x),S(0.5+lb+lt,0.5+lt,uv.x)));\n}\n\nvec3 lineLeft(vec2 uv, float lt)\n{\n    vec3 colUp = lineUp(uv,lt);\n    float lb = 0.005; // line blur\n    \n    lt += 0.001;\n    vec3 colDiag = vec3(min(S(1.0-lb-lt,1.0-lt,uv.x+uv.y),S(1.0+lb+lt,1.0+lt,uv.x+uv.y)));\n    \n    return mix(colUp,colDiag,S(0.5,0.51,uv.y));\n}\n\nvec3 lineFromLeft(vec2 uv, float lt)\n{\n    uv.y = 1.0-uv.y;\n    return lineLeft(uv,lt);\n}\n\nvec3 lineRight(vec2 uv, float lt)\n{\n    uv.x = 1.0-uv.x;\n    return lineLeft(uv,lt);\n}\n\nvec3 lineFromRight(vec2 uv, float lt)\n{\n\tuv.y = 1.0-uv.y;\n    return lineRight(uv,lt);\n}\n\nvec3 lineEnd(vec2 uv, float lt, float lp /* line percent*/)\n{\n    lp /= AR;\n    vec3 lineCol = lineUp(uv,lt);\n    \n    float circleR = 0.1;\n    vec2 circleUV = uv;\n    circleUV.y += 0.5*(1.0/AR);\n    circleUV.y -= circleR+lt;\n    circleUV.y -= lp;\n    vec3 circleCol = circle(circleUV,circleR,lt);\n    \n    return mix(lineCol,circleCol,S(lp-0.01,lp,uv.y));\n}\n\nint calcType(vec2 id)\n{\n    float r = rand(id);\n    \n    if(r > 0.5) return pUP;\n    else if(r > 0.3) return pEND;\n    else if(r > 0.15) return pFLEFT;\n    else return pFRIGHT;\n}\n\nint getType2(vec2 id)\n{\n    return calcType(id);\n}\n\nint getType1(vec2 id)\n{\n    int upType = getType2(id+vec2(0.0,1.0));\n    int ulType = getType2(id+vec2(-1.0,1.0));\n    int urType = getType2(id+vec2(1.0,1.0));\n    \n    int type = calcType(id);\n    \n    if(ulType == pFRIGHT) return pLEFT;\n    if(urType == pFLEFT)  return pRIGHT;\n    if(upType == pFLEFT || upType == pFRIGHT) return pUP;\n    if(upType == pUP && type == pUP) return pUP;\n    \n\treturn type;\n}\n\nint getType0(vec2 id)\n{\n    int upType = getType1(id+vec2(0.0,1.0));\n    int ulType = getType1(id+vec2(-1.0,1.0));\n    int urType = getType1(id+vec2(1.0,1.0));\n    \n    int type = calcType(id);\n    \n    if(ulType == pFRIGHT) return pLEFT;\n    if(urType == pFLEFT)  return pRIGHT;\n    if(upType == pFLEFT || upType == pFRIGHT) return pUP;\n    if(upType == pUP && type == pUP) return pUP;\n    \n\treturn type;\n}\n\nint getType(vec2 id)\n{\n    int upType = getType0(id+vec2(0.0,1.0));\n    int ulType = getType0(id+vec2(-1.0,1.0));\n    int urType = getType0(id+vec2(1.0,1.0));\n    \n    int type = calcType(id);\n    \n    if(ulType == pFRIGHT) return pLEFT;\n    if(urType == pFLEFT)  return pRIGHT;\n    if(upType == pFLEFT || upType == pFRIGHT) return pUP;\n    if(upType == pUP && type == pUP) return pUP;\n    \n\treturn type;\n}\n\nvec3 getColor(vec2 id)\n{\n    int type = getType(id);\n    while(type != pEND)\n    {\n        id.y+=1.0;\n        if(type==pRIGHT) id.x += 1.0;\n        else if(type==pLEFT) id.x -= 1.0;\n        type = getType(id);\n    }\n    \n    float r = fract(rand(id)*231.0);\n    r = 0.5*r + 0.1;\n    \n    \n    vec3 hsvColor = vec3(r,0.7,0.9);\n    return hsv2rgb(hsvColor);\n}\n\nvec3 linesLayer(vec2 uv,vec2 id)\n{\n    vec3 col = vec3(0.0);\n    \n    int type = getType(id);\n    \n    float lt = 0.03;\n    \n    if(type==pUP) col = lineUp(uv,lt);\n    else if(type==pEND) col = lineEnd(uv,lt,0.5);\n    else if(type==pLEFT) col = lineLeft(uv,lt);\n   \telse if(type==pRIGHT) col = lineRight(uv,lt);\n   \telse if(type==pFRIGHT) col = lineFromRight(uv,lt);\n   \telse if(type==pFLEFT) col = lineFromLeft(uv,lt);\n    \n    col *= getColor(id);\n        \n   \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.15*iTime;\n    vec2 globalUV = fragCoord/iResolution.xy;\n    globalUV.y /= AR;\n    globalUV.x += 0.2*globalUV.y;\n    vec2 uv = globalUV;\n\n    uv.y -= t;\n    \n    uv *= vec2(10.0+2.5*globalUV.y,16.0);\n    \n    vec2 id = floor(uv);\n    uv = fract(uv);\n    \n    float rnd = rand(id);\n    \n    vec3 col = vec3(0.0);\n    \n\tcol = linesLayer(uv,id);\n        \n    vec3 bgMask = vec3(1.0)-col;\n    \n    bgMask *= abs(sin(1.2*6.18*globalUV.x));\n    bgMask = clamp(bgMask,0.7,0.85);\n    \n    for(float y = 0.1;y<1.0;y+=0.2)\n    \tbgMask *= max(S(0.03,0.1,uv.y-y),S(0.1,0.05,uv.y-y));\n       \n    vec3 bgColor = hsv2rgb(vec3(0.3,0.7,0.4));\n    bgColor -= vec3(0.1 + 0.05*sin(id.x));\n    \n    col += bgMask*bgColor;    \n    \n    //if(uv.x > 0.98 || uv.y > 0.98) col.r = 1.0;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 313, 335, 335, 504], [506, 506, 526, 526, 598], [600, 600, 628, 628, 669], [671, 671, 711, 711, 841], [843, 843, 894, 894, 1004], [1006, 1006, 1040, 1040, 1275], [1277, 1277, 1315, 1315, 1366], [1368, 1368, 1403, 1403, 1454], [1456, 1456, 1495, 1495, 1544], [1546, 1546, 1607, 1607, 1904], [1906, 1906, 1929, 1929, 2084], [2086, 2086, 2109, 2109, 2136], [2138, 2138, 2161, 2161, 2545], [2547, 2547, 2570, 2570, 2954], [2956, 2956, 2978, 2978, 3362], [3364, 3364, 3388, 3388, 3721], [3723, 3723, 3757, 3757, 4199], [4201, 4201, 4258, 4258, 5072]], "test": "untested"}
{"id": "wtsBzS", "name": "Double Ended Truchet Experiment", "author": "mrange", "description": "License CC0: Double Ended Truchet Experiment\nBeen looking at some double ended truchets by BigWings and Shane. After some experiments I got something I felt was interesting enough to share.", "tags": ["truchet"], "likes": 16, "viewed": 383, "published": 3, "date": "1597084518", "time_retrieved": "2024-07-30T20:51:25.872319", "image_code": "// License CC0: Double Ended Truchet Experiment\n// Been looking at some double ended truchets by BigWings and Shane. \n// After some experiments I got something I felt was interesting enough to share.\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\nconst vec2 coords[8] = vec2[8](\n  0.5*vec2(-1.0, -0.5),\n  0.5*vec2(-1.0, +0.5),\n  0.5*vec2(-0.5, +1.0),\n  0.5*vec2(+0.5, +1.0),\n  0.5*vec2(+1.0, +0.5),\n  0.5*vec2(+1.0, -0.5),\n  0.5*vec2(+0.5, -1.0),\n  0.5*vec2(-0.5, -1.0)\n  );\n\nconst vec2 dcoords[8] = vec2[8](\n  vec2(+1.0, +0.0),\n  vec2(+1.0, +0.0),\n  vec2(+0.0, -1.0),\n  vec2(+0.0, -1.0),\n  vec2(-1.0, +0.0),\n  vec2(-1.0, +0.0),\n  vec2(+0.0, +1.0),\n  vec2(+0.0, +1.0)\n  );\n\nconst int noCorners = 105;\n// Using symmetries and reflections should be possible to reduce this \n//  array alot, but that is hard ;)\nconst int corners[105*8] = int[105*8](\n  0, 1, 2, 3, 4, 5, 6, 7, \n  0, 1, 2, 3, 4, 6, 5, 7, \n  0, 1, 2, 3, 4, 7, 5, 6, \n  0, 1, 2, 4, 3, 5, 6, 7, \n  0, 1, 2, 4, 3, 6, 5, 7, \n  0, 1, 2, 4, 3, 7, 5, 6, \n  0, 1, 2, 5, 3, 4, 6, 7, \n  0, 1, 2, 5, 3, 6, 4, 7, \n  0, 1, 2, 5, 3, 7, 4, 6, \n  0, 1, 2, 6, 3, 4, 5, 7, \n  0, 1, 2, 6, 3, 5, 4, 7, \n  0, 1, 2, 6, 3, 7, 4, 5, \n  0, 1, 2, 7, 3, 4, 5, 6, \n  0, 1, 2, 7, 3, 5, 4, 6, \n  0, 1, 2, 7, 3, 6, 4, 5, \n  0, 2, 1, 3, 4, 5, 6, 7, \n  0, 2, 1, 3, 4, 6, 5, 7, \n  0, 2, 1, 3, 4, 7, 5, 6, \n  0, 2, 1, 4, 3, 5, 6, 7, \n  0, 2, 1, 4, 3, 6, 5, 7, \n  0, 2, 1, 4, 3, 7, 5, 6, \n  0, 2, 1, 5, 3, 4, 6, 7, \n  0, 2, 1, 5, 3, 6, 4, 7, \n  0, 2, 1, 5, 3, 7, 4, 6, \n  0, 2, 1, 6, 3, 4, 5, 7, \n  0, 2, 1, 6, 3, 5, 4, 7, \n  0, 2, 1, 6, 3, 7, 4, 5, \n  0, 2, 1, 7, 3, 4, 5, 6, \n  0, 2, 1, 7, 3, 5, 4, 6, \n  0, 2, 1, 7, 3, 6, 4, 5, \n  0, 3, 1, 2, 4, 5, 6, 7, \n  0, 3, 1, 2, 4, 6, 5, 7, \n  0, 3, 1, 2, 4, 7, 5, 6, \n  0, 3, 1, 4, 2, 5, 6, 7, \n  0, 3, 1, 4, 2, 6, 5, 7, \n  0, 3, 1, 4, 2, 7, 5, 6, \n  0, 3, 1, 5, 2, 4, 6, 7, \n  0, 3, 1, 5, 2, 6, 4, 7, \n  0, 3, 1, 5, 2, 7, 4, 6, \n  0, 3, 1, 6, 2, 4, 5, 7, \n  0, 3, 1, 6, 2, 5, 4, 7, \n  0, 3, 1, 6, 2, 7, 4, 5, \n  0, 3, 1, 7, 2, 4, 5, 6, \n  0, 3, 1, 7, 2, 5, 4, 6, \n  0, 3, 1, 7, 2, 6, 4, 5, \n  0, 4, 1, 2, 3, 5, 6, 7, \n  0, 4, 1, 2, 3, 6, 5, 7, \n  0, 4, 1, 2, 3, 7, 5, 6, \n  0, 4, 1, 3, 2, 5, 6, 7, \n  0, 4, 1, 3, 2, 6, 5, 7, \n  0, 4, 1, 3, 2, 7, 5, 6, \n  0, 4, 1, 5, 2, 3, 6, 7, \n  0, 4, 1, 5, 2, 6, 3, 7, \n  0, 4, 1, 5, 2, 7, 3, 6, \n  0, 4, 1, 6, 2, 3, 5, 7, \n  0, 4, 1, 6, 2, 5, 3, 7, \n  0, 4, 1, 6, 2, 7, 3, 5, \n  0, 4, 1, 7, 2, 3, 5, 6, \n  0, 4, 1, 7, 2, 5, 3, 6, \n  0, 4, 1, 7, 2, 6, 3, 5, \n  0, 5, 1, 2, 3, 4, 6, 7, \n  0, 5, 1, 2, 3, 6, 4, 7, \n  0, 5, 1, 2, 3, 7, 4, 6, \n  0, 5, 1, 3, 2, 4, 6, 7, \n  0, 5, 1, 3, 2, 6, 4, 7, \n  0, 5, 1, 3, 2, 7, 4, 6, \n  0, 5, 1, 4, 2, 3, 6, 7, \n  0, 5, 1, 4, 2, 6, 3, 7, \n  0, 5, 1, 4, 2, 7, 3, 6, \n  0, 5, 1, 6, 2, 3, 4, 7, \n  0, 5, 1, 6, 2, 4, 3, 7, \n  0, 5, 1, 6, 2, 7, 3, 4, \n  0, 5, 1, 7, 2, 3, 4, 6, \n  0, 5, 1, 7, 2, 4, 3, 6, \n  0, 5, 1, 7, 2, 6, 3, 4, \n  0, 6, 1, 2, 3, 4, 5, 7, \n  0, 6, 1, 2, 3, 5, 4, 7, \n  0, 6, 1, 2, 3, 7, 4, 5, \n  0, 6, 1, 3, 2, 4, 5, 7, \n  0, 6, 1, 3, 2, 5, 4, 7, \n  0, 6, 1, 3, 2, 7, 4, 5, \n  0, 6, 1, 4, 2, 3, 5, 7, \n  0, 6, 1, 4, 2, 5, 3, 7, \n  0, 6, 1, 4, 2, 7, 3, 5, \n  0, 6, 1, 5, 2, 3, 4, 7, \n  0, 6, 1, 5, 2, 4, 3, 7, \n  0, 6, 1, 5, 2, 7, 3, 4, \n  0, 6, 1, 7, 2, 3, 4, 5, \n  0, 6, 1, 7, 2, 4, 3, 5, \n  0, 6, 1, 7, 2, 5, 3, 4, \n  0, 7, 1, 2, 3, 4, 5, 6, \n  0, 7, 1, 2, 3, 5, 4, 6, \n  0, 7, 1, 2, 3, 6, 4, 5, \n  0, 7, 1, 3, 2, 4, 5, 6, \n  0, 7, 1, 3, 2, 5, 4, 6, \n  0, 7, 1, 3, 2, 6, 4, 5, \n  0, 7, 1, 4, 2, 3, 5, 6, \n  0, 7, 1, 4, 2, 5, 3, 6, \n  0, 7, 1, 4, 2, 6, 3, 5, \n  0, 7, 1, 5, 2, 3, 4, 6, \n  0, 7, 1, 5, 2, 4, 3, 6, \n  0, 7, 1, 5, 2, 6, 3, 4, \n  0, 7, 1, 6, 2, 3, 4, 5, \n  0, 7, 1, 6, 2, 4, 3, 5, \n  0, 7, 1, 6, 2, 5, 3, 4\n  );\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat dot2(vec2 v) { return dot(v,v); }\n    \nvec3 alphaBlend(vec3 back, vec4 front) {\n  vec3 colb = back.xyz;\n  vec3 colf = front.xyz;\n  vec3 xyz = mix(colb, colf.xyz, front.w);\n  return xyz;\n}\n\n// IQ Bezier: https://www.shadertoy.com/view/MlKcDD\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    \n  const float sqrt3 = sqrt(3.0);\n  vec2 a = B - A;\n  vec2 b = A - 2.0*B + C;\n  vec2 c = a * 2.0;\n  vec2 d = A - pos;\n\n  float kk = 1.0/dot(b,b);\n  float kx = kk * dot(a,b);\n  float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n  float kz = kk * dot(d,a);      \n\n  float res = 0.0;\n\n  float p = ky - kx*kx;\n  float p3 = p*p*p;\n  float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n  float h = q*q + 4.0*p3;\n\n  if(h>=0.0) {   // 1 root\n      h = sqrt(h);\n      vec2 x = (vec2(h,-h)-q)/2.0;\n      vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n      float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n      res = dot2(d+(c+b*t)*t);\n  } else {   // 3 roots\n      float z = sqrt(-p);\n      float v = acos(q/(p*z*2.0))/3.0;\n      float m = cos(v);\n      float n = sin(v)*sqrt3;\n      vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n      res = min(dot2(d+(c+b*t.x)*t.x), dot2(d+(c+b*t.y)*t.y));\n      // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n      // res = min(res,dot2(d+(c+b*t.z)*t.z));\n  }\n  \n  return sqrt(res);\n}\n\nfloat bezier2(vec2 p, float f, vec2 off, vec2 p0, vec2 dp0, vec2 p1, vec2 dp1) {\n  float dist = length(p0 - p1);\n  float hdist = 0.5*f*dist;\n  vec2 mp0 = p0 + hdist*dp0;\n  vec2 mp1 = p1 + hdist*dp1;\n  vec2 jp = (mp0 + mp1)*0.5+off;\n  float d0 = bezier(p, p0, mp0, jp);\n  float d1 = bezier(p, p1, mp1, jp);\n  \n  float d = d0;\n  d = min(d, d1);\n  return d;\n}\n\nvec3 color(vec2 p, float s, float aa, vec3 col) {\n  p /= s;\n  vec2 cp = p;\n  vec2 cn = mod2_1(cp);\n  float rr = hash(cn);\n  int sel = int(float(noCorners)*rr);\n  int off = sel*8;\n  \n  const vec3 scol = vec3(0.25);\n  const vec3 bcol = vec3(1.0);\n  const float sw = 0.05;\n  \n  for (int i = 0; i < 4; ++i) {\n    int c0 = corners[off + i*2 + 0];\n    int c1 = corners[off + i*2 + 1];    \n    int odd = min(c0, c1) & 1;\n    \n    float r = fract(rr*13.0*float(i+1));\n    \n    int l = abs(c0 - c1) + odd*8;\n    float f = 0.71;\n    vec2 off = vec2(0.0, 0.0);\n\n    vec2 p0 = coords[c0];\n    vec2 p1 = coords[c1];\n    \n    vec2 dp0 = dcoords[c0];\n    vec2 dp1 = dcoords[c1];\n\n    vec2 dp = mix(dp0, dp1, r);\n\n    switch(l) {\n    // Mid shape\n    case 1:\n    case 15:\n      f = mix(0.75, 2.5, r);\n      break;\n    // L - shape\n    case 2:\n    case 6:\n    case 10:\n    case 14:\n      f = r > 0.5 ? 0.35 : 1.25;\n      break;\n    // Big corner shape\n    case 3:\n    case 13:\n      f = mix(0.5, 1.0, r);\n      break;\n    // Cross line\n    case 4:\n    case 12:\n      f = r>0.5 ? 0.5 : 1.5;\n      break;\n    // Straight line\n    case 5:\n    case 11:\n      f = 1.5;\n      off = (r > 0.5 ? 1.0 : -1.0)*0.15*vec2(dp0.y, -dp0.x);\n      break;\n    // Small corner shape\n    case 7:\n    case 9:\n      f = r>0.5 ? 0.75 : 2.75;\n      break;\n    default:\n      f = 0.5;\n      break;\n    }\n    \n    float dd = (bezier2(cp, f, off, p0, dp0, p1, dp1)-0.025)*s;\n    \n    vec4 sc = vec4(scol, smoothstep(-sw, sw, -dd));\n    vec4 bc = vec4(bcol, smoothstep(-aa, aa, -dd));\n\n    col = alphaBlend(col, sc);\n    col = alphaBlend(col, bc);\n  }\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n \n  p += vec2(0.5, sqrt(0.5))*TIME*0.1;\n \n  float aa = 2.0/RESOLUTION.y;\n  float s = 0.25;\n\n  vec3 col = vec3(0.1);\n  col = color(p, s, aa, col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsBzS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[3776, 3776, 3803, 3803, 3872], [3874, 3874, 3895, 3895, 3965], [3967, 3967, 3988, 3988, 4017], [4019, 4019, 4039, 4039, 4058], [4064, 4064, 4104, 4104, 4212], [4214, 4266, 4314, 4314, 5346], [5348, 5348, 5428, 5428, 5704], [5706, 5706, 5755, 5755, 7331], [7333, 7333, 7385, 7385, 7663]], "test": "untested"}
{"id": "3llfRS", "name": "P.Gerdes & Tchokwe sand drawing5", "author": "FabriceNeyret2", "description": "not drawing isolated circles ( [url]https://shadertoy.com/view/tlXBRS[/url] variant)\nClick for dots.\n\nReference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]", "tags": ["tiles", "short", "truchets"], "likes": 18, "viewed": 409, "published": 3, "date": "1597083627", "time_retrieved": "2024-07-30T20:51:26.751967", "image_code": "// variant of https://shadertoy.com/view/tlXBRS\n\n#define S(v) smoothstep( 9./R.y , 0. , v )           // AA draw\n#define s(v) cos(6.28*v/.09)                         // strip pattern \n#define h(i) fract(4e4*sin(i))\n#define H(i) int(2.*h(i))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(1);\n    mat2 M = mat2(1,-1,1,1);                         // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / 360. + iTime,\n         I = floor( U * M ),                         // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414, f;        // quad center to edge domain\n    \n    if (iMouse.z>0.) O -= S( length(F) - .1 );       // dots\n\n    float i = I.x + 10.*I.y +99.,                    // edge id (float)\n          r = h(i);                                  // rand(id)\n    \n    O -= r < .5\n        ? f = abs( abs(F) - .2 ),\n          F = S( f -.1 ) * s(f),                     //  X at edge\n          F.x + F.y \n          - ( F.yx * S(f-.1) ) [int(4.*r)]           //   random crossing order\n        : (                                          // )( at edge\n            f = sign(F+1e-5),\n            H(i)+H(i-f.x)+H(i-10.*f.y-f.x)+H(i-10.*f.y) < 4 // don't draw isolated circles\n              ? i = abs( length(F) - .2 ),\n                S( i -.1 ) * s(i) \n              : 0. \n           ); \n  //O -= .4*( .5+.5*cos(6.3*r + vec4(0,2,-2,0)) );   // coloring ( debug )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 280, 280, 1406]], "test": "untested"}
{"id": "wllBzS", "name": "glitter", "author": "jdan", "description": "drag the mouse to simulate glitter\n\n(weak copy of https://twitter.com/mayli/status/994234781138206720)", "tags": ["mouse", "glitter"], "likes": 2, "viewed": 296, "published": 3, "date": "1597082514", "time_retrieved": "2024-07-30T20:51:27.523903", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float res = 300.0;\n    vec2 uv = round(fragCoord/iResolution.xy * res) / res;\n\n    vec4 m = iMouse / iResolution.xxxx;\n    \n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float normal = rand(uv) * 3.141592;\n    float source = (m.x + m.y) * 3.141592;\n    \n    float brightness = cos(normal - source);\n    \n    float v = 0.5*rand(uv) + 0.5*brightness;\n    \n    vec3 col = vec3(5.0 / 6.0, 1.0, clamp(v, 0.5, 1.0));\n    \n    \n    // Output to screen\n    fragColor = vec4(hsv2rgb(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [193, 193, 213, 213, 281], [283, 283, 340, 390, 935]], "test": "untested"}
{"id": "ttsfRS", "name": "9. Simple Camera Model", "author": "altera0", "description": "Source : https://www.youtube.com/watch?v=PBxuVlp7nuM\n\nMy Connection Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["simplecameramodel"], "likes": 0, "viewed": 265, "published": 3, "date": "1597081570", "time_retrieved": "2024-07-30T20:51:28.286863", "image_code": "// Get Distance To The Ray Rd\nfloat DistanceLine( vec3 ro , vec3 rd , vec3 p ) {\n    float h = length( cross( ( p - ro ) , rd ) ) / length(rd);\n    return h;\n}\n\n// Draw Circle\nfloat DrawCircle(vec3 ro , vec3 rd , vec3 p, float radius ) {\n    float h = DistanceLine( ro , rd , p );\n    h = smoothstep ( radius , radius - 0.001f , h );\n    return h;\n}\n\n// Cube \nfloat CircleCube( vec2 uv , vec3 camPos , float zoom, vec3 objectCenter, float len ) {\n    \n    vec3 lookAt = objectCenter - camPos;\n    \n    vec3 F = normalize( lookAt );\n\n    vec3 R = normalize( cross( vec3(0.0f,1.0f,0.0f), F  ) );\n    vec3 U = normalize( cross( F , R ) );\n\t\n    vec3 nearPlanCenter = camPos + F * zoom;\t// ( - ) \n    vec3 intersectionPoint = nearPlanCenter + uv.x * R + uv.y * U;\n    \n    vec3 rd = intersectionPoint - camPos;\n    \n    float h = 0.0f;\n    float hDiv2 = len/2.0f;\n    \n    // left bottom\n    h += DrawCircle( camPos , rd , objectCenter + vec3( -hDiv2 , -hDiv2 , -hDiv2 ) , 0.1f );\n    h += DrawCircle( camPos , rd , objectCenter + vec3( -hDiv2 , -hDiv2 , +hDiv2 ) , 0.1f );\n    \n    // left top\n    h += DrawCircle( camPos , rd , objectCenter + vec3( -hDiv2 , +hDiv2 , -hDiv2 ) , 0.1f );\n    h += DrawCircle( camPos , rd , objectCenter + vec3( -hDiv2 , +hDiv2 , +hDiv2 ) , 0.1f );\n    \n\t// right bottom\n    h += DrawCircle( camPos , rd , objectCenter + vec3( +hDiv2 , -hDiv2 , -hDiv2 ) , 0.1f );\n    h += DrawCircle( camPos , rd , objectCenter + vec3( +hDiv2 , -hDiv2 , +hDiv2 ) , 0.1f );\n    \n    // right top\n    h += DrawCircle( camPos , rd , objectCenter + vec3( +hDiv2 , +hDiv2 , -hDiv2 ) , 0.1f );\n    h += DrawCircle( camPos , rd , objectCenter + vec3( +hDiv2 , +hDiv2 , +hDiv2 ) , 0.1f );\n    \n    return h;\n}\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\n     \n    \n    // variables\n\tfloat zoom = 2.0f;\n    \n    vec3 camPos = vec3( cos(iTime) * 4.0f - sin (iTime) * 4.0f , 4.0f , cos(iTime) * 4.0f + sin(iTime) * 4.0f );\t\t// ro\n    vec3 objectCenter = vec3 (0.0f, 0.0f , 10.0f ); \t// center of Object\n    \n    float cubeLength = 2.0f;\n    \n    \n    \n    float h = CircleCube( uv, camPos , zoom , objectCenter, cubeLength );\n    \n    vec3 col = vec3(h);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 80, 80, 159], [161, 176, 237, 237, 349], [351, 360, 446, 446, 1713], [1715, 1723, 1780, 1780, 2315]], "test": "untested"}
{"id": "tlsfRS", "name": "warhol-izer ;-)", "author": "flockaroo", "description": "warholified jcvd\nmove mouse for some more weirdness (...less warhol-y then)\n...and do enable mipmaps if you change source (needed for smooth contours)!", "tags": ["experiment", "effect", "warhol"], "likes": 8, "viewed": 456, "published": 3, "date": "1597079572", "time_retrieved": "2024-07-30T20:51:29.155540", "image_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// warholizer - some weird halftone-ish experiment\n\n// ...slightly golfed down - guess theres still much potential to get it even smaller\n\n#define R (iResolution.xy)\n#define R0 vec2(textureSize(iChannel0,0))\n\nvoid mainImage( out vec4 c, vec2 p )\n{\n    float s=0.,f=1.,n=iMouse.x/R.x*64.;\n    float m=floor(iMouse.y/R.y*5.+1.);\n    if (iMouse.x<1.) { n=2.; m=floor(mod(iTime*.5,3.)+1.); }\n    vec2 q=floor(p/(R/m));\n    p=mod(p*m,R);\n    vec4 dc=vec4(0);\n    for(float i=3.;i>=0.;i-=1.)\n    {\n        c=textureLod(iChannel0,p/R,i+n/15.+log2(R0.x/800.));\n        dc+=f*mix(c,vec4(-.1),dot(c.xyz,vec3(-1,2,-1)));\n        s+=f;\n        f*=.35;\n    }\n    dc/=s;\n    vec4 tc=abs(fract(dc*dc*n+.13*(q.x+m*q.y))*2.-1.);\n    vec4 fw=fwidth(tc)*1.;\n    c=1.-smoothstep(dc-fw,dc+fw,tc);\n}\n\n", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfRS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[345, 345, 383, 383, 913]], "test": "untested"}
{"id": "wtlfRS", "name": "8. The Simplest 3D", "author": "altera0", "description": "Source : https://www.youtube.com/watch?v=dKA5ZVALOhs&t=48s\nWord Onet : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["simplest"], "likes": 0, "viewed": 220, "published": 3, "date": "1597076970", "time_retrieved": "2024-07-30T20:51:30.024218", "image_code": "\n// Get Distance To The Ray Rd\nfloat DistanceLine( vec3 ro , vec3 rd , vec3 p ) {\n    float h = length( cross( ( p - ro ) , rd ) ) / length(rd);\n    return h;\n}\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n\t\n    \n    // variables\n\tvec3 camPos = vec3( 0.0f , 0.0f , -5.5f );\t\t\t// ro\n    vec3 rd = normalize( vec3(uv,0.0f) - camPos);\t\t// ray dirction\n    vec3 objectCenter = vec3 (0.0f, 0.0f , 5.0f ); \t// center of Object\n    float objectRadius = 0.2f;\n    \n    objectCenter = vec3(0.0f, 0.0f, 10.0f) + vec3( cos(iTime) * 1.0f , 0.0f , sin(iTime)* 1.0f );\n    \n    float h = DistanceLine( camPos , rd , objectCenter );\n    h = smoothstep( objectRadius ,objectRadius - 0.01f , h );\n\n    \n\n    vec3 col = vec3(h);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 31, 81, 81, 160], [162, 170, 227, 227, 879]], "test": "untested"}
{"id": "WtsfzS", "name": "[Twitch] Rainbow Trip", "author": "scry", "description": "https://www.twitch.tv/videos/705843458 :)\nBuilt in KodeLife", "tags": ["3d", "raymarch", "trippy", "feedback", "stream", "twitch"], "likes": 4, "viewed": 432, "published": 3, "date": "1597043740", "time_retrieved": "2024-07-30T20:51:30.918826", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define time iTime*0.5\nmat2 r2d(float a) {\n    return mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n\n//https://iquilezles.org/articles/distfunctions\n//vec3 opRepLim( in vec3 p, in float c, in vec3 l, in sdf3d primitive )\nvec3 opRepLim(vec3 p, float c, vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\nfloat map(vec3 p) {\n    float s = 2.+sin(time*0.1);\n    s = 0.9;\n    p = opRepLim(p,-9.9,vec3(3.));\n    float d = length(p)-s;\n    //d = opRepLim(p, d, p);\n    return d;\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<210;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p);\n        if (dS < 0.) {\n            dS += 1.5;\n        }\n        dO += dS;\n        ii += 0.3;\n        if (dO > 1000. || dS< 0.001) {\n            break;\n        }\n    }\n    return vec2(dO,ii);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tv = fragCoord.xy/iResolution.xy;\n    //tv.x *= iResolution.x/iResolution.y;\n    //tv.x -= (iResolution.x/iResolution.y)*0.5;\n    vec2 uv = -1. + 2. * tv;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 vuv = vec2(uv.x, tv.y*2.);\n    //uv = vuv;\n    uv = abs(uv);\n    float c = length(uv);\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.5,0.5,-5.*(sin(time*0.3)*0.5+0.45));\n    //ro = vec3(0,0,-15.);\n    \n    vec3 rd = normalize(vec3(uv,0.5));\n    vec2 M = iMouse.xy*4.;\n    M += vec2(time*2.5,time*(sin(time*0.01)*0.5));\n    //M *= 2.;\n    //M = vec2(3.14*0.5);\n    //M = mouse.xy*4.;\n    ro.xy *= r2d(M.x);\n    rd.xy *= r2d(M.x);\n    ro.yz *= r2d(M.y);\n    rd.yz *= r2d(M.y);\n    //ro.yz += (vec2(sin(time),cos(time))*0.5+0.5)-2.;\n    //ro.xy += (vec2(sin(time),cos(time))*0.5+0.5)*2.;\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    uv = p.xy;\n    c = length(uv);\n    //vec2 tv = inData.v_texcoord;\n    tv += sin(uv)*0.0005;\n    tv -= 0.5;\n    vec2 rtv = tv *r2d(3.14159*0.5 + sin((uv.x*0.00005 + uv.y*0.00005)-c*0.001+time));\n    tv = mix(tv,rtv,0.015);\n    tv *= 0.99+(sin(time)*0.5+0.5)*0.03;\n    tv *= 0.88+((1.+(d.y*0.1))*0.79)*0.1;\n    tv *= 0.995;\n    tv += 0.5;\n    vec3 bak = texture(iChannel0, tv).rgb;\n    //col += sin(c*20+time*5.+spectrum.x*50*sin(uv.x*20.*uv.y*2.));\n    //col += bak*1.99;\n    if (d.x > 1000.) {\n        col = bak;\n        col = fract(col+0.0001);\n    }else {\n        col -= sin(p*0.05);\n    }\n    //col -= d.y*0.01;\n    //col = rgb2hsv(vec3(col));\n    //col = hsv2rgb(vec3(col)+0.005);\n    col = rgb2hsv(vec3(col.r,col.g,col.b));\n    col = hsv2rgb(vec3(col.r,col.g,col.g)+0.001+d.y*0.001);\n    //col = hsv2rgb(vec3((col.r+col.b+col.g)*.9,0.5,1.));\n    col = fract(col);\n    //col += 1.-(d.y*0.49);\n    fragColor = vec4(col,1.);\n    //fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 279]], "test": "untested"}
{"id": "WssXDM", "name": "Gunbara_ripple1", "author": "Gunbara", "description": "blah", "tags": ["test", "gunbara"], "likes": 1, "viewed": 253, "published": 3, "date": "1597035263", "time_retrieved": "2024-07-30T20:51:31.764565", "image_code": "// Metadata I gave to shadertoy.com\n//\tName: Gunbara_ripple1\n//\tTags: Gunbara, test\n//\tDescription: blah\n//\n// Formatting note:\n//\tWhitespace regex: \"/\t|([\t ]+$)/\"\n\n// See:\n//\thttps://vvvv.org/documentation/wave-simulation\n//\thttp://www.falstad.com/ripple/\n//\thttp://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch08.html\n//\thttps://bitbucket.org/timday/qtlab/src/5fec2348003d2935cc6cc767abaa5ea211a9d738/experiment/waves-qml-shader/waves.qml?at=default&fileviewer=file-view-default\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Color scheme: linear mapping\n/*\t{\n\t\tfloat intensity = curHeight(fragCoord);\n\t\tfragColor = vec4(intensity*0.5 + 0.5);\n\t} // */\n\n\t// Color scheme: logarithmic mapping\n\t{\n\t\t// Semi arbitrary values that look good\n\t\tconst float minLogRange = -8.0;\n\t\tconst float maxLogRange =  1.0;\n\t\tconst float lowestNonZero = 0.0; //exp2(minLogRange);\n\t\tfloat intensity =\n\t\t\t(\n\t\t\t\tlog2(\n\t\t\t\t\tabs(curHeight(fragCoord)) + lowestNonZero\n\t\t\t\t) - minLogRange\n\t\t\t)\n\t\t\t/ (maxLogRange-minLogRange)\n\t\t;\n\t\t//fragColor = vec4(intensity);\n\t\tif (curHeight(fragCoord) > 0.0) {  // we used absolute value in the log2(), show the original sign\n\t\t\tfragColor = intensity * vec4(1.0, 0.0, 1.0, 1.0);\n\t\t} else {\n\t\t\tfragColor = intensity * vec4(0.0, 1.0, 0.0, 1.0);\n\t\t}\n\t} // */\n\n\t// Color scheme check: highlight aliasing (out of range values) in final output image\n/*\t{\n\t\tfragColor.g =\n\t\t\t0.5*step(0.0,\n\t\t\t\tmin(min(fragColor.r, fragColor.g), fragColor.b)\n\t\t\t) +\n\t\t\t0.5*step(1.0,\n\t\t\t\tmax(max(fragColor.r, fragColor.g), fragColor.b)\n\t\t\t)\n\t\t;\n\t\t\t//fragColor.rb = vec2(0.0);\n\t} // */\n\n\t// Draw the wall\n\tif (isInside_doubleSlitWall(iResolution.xy, fragCoord)) {\n\t\tfragColor = vec4(1.0, 0.0, 1.0, 1.0);\n\t}\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t#define nextCurHeight fragColor.r\n\t#define nextLastHeight fragColor.g\n\n\t// Just save a copy of the previous height\n\tnextLastHeight = curHeight(fragCoord);\n\n\n\t////////////////////////////////////////\n\t// Initial values\n\t////////////////////////////////////////\n\n\tif (isFirstFrame) {\n\t\tnextCurHeight\n\t\t\t= 0.0\n\t\t\t\t//Shadertoy note: pixel coordinate = fragCoord-vec2(0.5)\n\t\t\t//\t+ 1.0*step(length(fragCoord - vec2(0.5, 0.5)), 0.99)  // single pixel at position 0,0\n\t\t\t//\t+ 1.0*step(length(fragCoord - vec2(3.5, 3.5)), 0.99)  // single pixel at position 3,3\n\t\t\t//\t+ 1.0*step(length(fragCoord - vec2(10.0, 5.0)), 1.00)  // small circle at position 9.5,4.5\n\t\t\t//\t+ 1.0*step(length(fragCoord - vec2(50.5, 30.5)), 3.00)\n\t\t\t\t+ 1.0*step(length(fragCoord - vec2(200.0, 100.0)), 10.00)\n\t\t\t\t\t+ -1.0*step(length(fragCoord - vec2(iResolution.x-200.0, 100.0)), 10.00)\n\t\t\t//\t+ 1.0*step(length(fragCoord - vec2(400.0, 200.0)), 50.00)\n\t\t;\n\t\tnextLastHeight = nextCurHeight;\n\t\treturn;\n\t}\n\n\n\t////////////////////////////////////////////////////////////\n\n\tconst float dampening = 1e-3; //1.0/32.0; //1e-2; // semi-arbitrary value, range = [0,1)\n\n\n\t////////////////////////////////////////\n\t// Blur\n\t////////////////////////////////////////\n\n/*\tnextCurHeight = (\n\t\t(\n\t\t\t+ curHeight(fragCoord + vec2(-1.0,  0.0))\n\t\t\t+ curHeight(fragCoord + vec2( 1.0,  0.0))\n\t\t\t+ curHeight(fragCoord + vec2( 0.0, -1.0))\n\t\t\t+ curHeight(fragCoord + vec2( 0.0,  1.0))\n\t\t) / 4.0\n\t) * (1.0-dampening); // */\n\n\n\t////////////////////////////////////////\n\t// Ripple\n\t////////////////////////////////////////\n\n\t////////////////////\n\n\t// Ripple (orig long lost algo from my high school days)\n/*\tnextCurHeight = (\n\t\t+ (\n\t\t\t+ curHeight(fragCoord + vec2(-1.0,  0.0))\n\t\t\t+ curHeight(fragCoord + vec2( 1.0,  0.0))\n\t\t\t+ curHeight(fragCoord + vec2( 0.0, -1.0))\n\t\t\t+ curHeight(fragCoord + vec2( 0.0,  1.0))\n\t\t) / 2.0\n\t\t- lastHeight(fragCoord + vec2( 0.0,  0.0))\n\t) * (1.0-dampening); // */\n\n\n\t////////////////////\n\n\t// Ripple (old 2019-03-05 - each color channel got it's own blur & wave height calcs)\n\tfloat directionToStaticEquilibrium = (\n\t\t+ curHeight(fragCoord + vec2(-1.0,  0.0))\n\t\t+ curHeight(fragCoord + vec2( 1.0,  0.0))\n\t\t+ curHeight(fragCoord + vec2( 0.0, -1.0))\n\t\t+ curHeight(fragCoord + vec2( 0.0,  1.0))\n\t) / 4.0\n\t- curHeight(fragCoord + vec2( 0.0,  0.0))\n\t;\n\tfloat curVelocity =\n\t\t+ curHeight (fragCoord + vec2( 0.0,  0.0))\n\t\t- lastHeight(fragCoord + vec2( 0.0,  0.0))\n\t;\n\tnextCurHeight = (\n\t\t+ curHeight (fragCoord + vec2( 0.0,  0.0))  // current position\n\t\t+ (1.0-0.01-0.0*dampening)* curVelocity  // velocity\n\t\t+ (1.0-0.00-0.0*dampening)* directionToStaticEquilibrium  // acceleration\n\t) ; //* (1.0-dampening); // */\n\n\n\t////////////////////\n\t// \"Solid\" objects\n\t////////////////////\n\n\t// Solid object (double slit)\n\tif (isInside_doubleSlitWall(iResolution.xy, fragCoord)) {\n\t\tnextCurHeight = 0.0;\n\t}\n\n\n\t////////////////////////////////////////////////////////////\n\n\t////////////////////////////////////////\n\t// Mouse clicks\n\t////////////////////////////////////////\n\n\tif (mouseButton1bool && (length(iMouse.xy-fragCoord) < 5.0)) {\n\t\t// old 2019-03-05 - each color channel got it's own blur & wave height calcs\n\t\t//fragColor = vec4(0.0, 1.0, -1.0, 1.0);\n\n\t\tnextCurHeight = (\n\t\t\t//1.0\n\t\t\t//step(fract(iTime*5.0), 0.5)\n\t\t\tstep(fract(float(iFrame)/20.0), 0.5)\n/* TODO - this works but is flakey\t\t\tstep(fract(\n\t\t\t\tiTime / (0.4 + 1.6 * fract(iTime/10.0))\n\t\t\t), 0.5)  // a \"chirp\" - PWM oscillator whose frequency changes linearly with time */\n\t\t)*2.0-1.0;\n\n\t\t//nextLastHeight = nextCurHeight;\n\t}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////\n// Behavior controls\n////////////////////////////////////////\n\n////////////////////////////////////////\n// Names for buffers & channels\n////////////////////////////////////////\n\n//#define D_channelVal(D_channel, D_pos) texture(D_channel, (D_pos)/iResolution.xy)\n//\t#define D_channelVal(D_channel, D_pos) texture(D_channel, mod(D_pos,iResolution.xy)/iResolution.xy)\n\t// ^ This is the same as above (without the mod()) when the channel's \"wrap\" parameter is set to \"repeat\" in each area\n\t//\t(shadertoy.com was defaulting to \"clamp\" for renderbuffers)\n#define D_channelVal(D_channel, D_pos) texelFetch(D_channel, ivec2(mod(D_pos,iResolution.xy)), 0)\n\n#define curHeight(D_pos)  D_channelVal(iChannel0, D_pos).r\n#define lastHeight(D_pos) D_channelVal(iChannel0, D_pos).g  // stored in same buffer as curHeight()\n\n\n\t////////////////////\n\t// buffer render buffer ordering tests\n\t////////////////////\n\n\t// using a different buffer than curHeight() seems to cause some weird artifacts\n\t//#define lastHeight(D_pos) D_channelVal(iChannel1, D_pos).r\n\n\t// looks like those artifacts are indeed caused by lastHeight(...) being set to current instead of previous values\n\t//\t-> artifacts can be perfectly reproduced with this:\n\t//\t#define lastHeight(D_pos) curHeight(D_pos)\n\n\n////////////////////////////////////////\n// General Shadertoy macros\n////////////////////////////////////////\n\n#define isFirstFrame (iFrame == 0)\n\n// iMouse.z seem to return a random but positive number if the button is pressed\n#define mouseButton1 step(0.0, iMouse.z)\n#define mouseButton2 step(0.0, iMouse.w)\n#define mouseButton1bool (mouseButton1 == 1.0)\n#define mouseButton2bool (mouseButton2 == 1.0)\n\n\n////////////////////////////////////////\n// Utils\n////////////////////////////////////////\n\nbool isInside_doubleSlitWall(\n\tvec2 iResolution,  // grr - Shadertoy doesn't make this available as a global var for things in the common code\n\tvec2 fragCoord\n) {\n\tif ((iResolution.x*0.5-0.0 < fragCoord.x) && (fragCoord.x < iResolution.x*0.5+1.0)\n\t\t&& (false\n\t\t\t\t// 2 holes - 4 pixels wide and 4 pixels apart\n\t\t\t|| (iResolution.y*0.0+0.0 < fragCoord.y) && (fragCoord.y < iResolution.y*0.5-9.0)\n\t\t\t|| (iResolution.y*0.5-3.0 < fragCoord.y) && (fragCoord.y < iResolution.y*0.5+3.0)\n\t\t\t|| (iResolution.y*0.5+9.0 < fragCoord.y) && (fragCoord.y < iResolution.y*1.0-0.0) // */\n\n\t\t\t\t// 4 holes - 2 pixels wide and 2 pixels apart\n\t\t\t/*|| (iResolution.y*0.0+0.0 < fragCoord.y) && (fragCoord.y < iResolution.y*0.5-7.0)\n\t\t\t|| (iResolution.y*0.5-5.0 < fragCoord.y) && (fragCoord.y < iResolution.y*0.5-3.0)\n\t\t\t|| (iResolution.y*0.5-1.0 < fragCoord.y) && (fragCoord.y < iResolution.y*0.5+1.0)\n\t\t\t|| (iResolution.y*0.5+3.0 < fragCoord.y) && (fragCoord.y < iResolution.y*0.5+5.0)\n\t\t\t|| (iResolution.y*0.5+7.0 < fragCoord.y) && (fragCoord.y < iResolution.y*1.0-0.0) // */\n\t\t)\n\t) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 552, 721, 1722]], "test": "untested"}
{"id": "ttffRB", "name": "Creamsicle", "author": "t420babe", "description": "A modified voronoi function complete inspired by Chapter 12 of The Book of Shaders\n(https://thebookofshaders.com/edit.php#12/2d-voronoi.frag)", "tags": ["voronoi", "lines", "random", "orange", "creamsicle"], "likes": 2, "viewed": 277, "published": 3, "date": "1597012717", "time_retrieved": "2024-07-30T20:51:32.632245", "image_code": "#define PI 3.14159265359\n\n// From https://thebookofshaders.com/12/\nvec2 random( vec2 p ) {\n      return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// From https://thebookofshaders.com/edit.php#12/2d-voronoi.frag\nvec3 voronoi(in vec2 pos) {\n  vec2 n = floor(pos);\n  vec2 f = fract(pos);\n\n  vec2 mg, mr;\n  float md = 8.0;\n  for (int j = -1; j <=1; j++) {\n    for (int i = -1; i <= 1; i++) {\n      vec2 g = vec2(float(i), float(j));\n      vec2 o = random(n + g);\n      o = 0.5 + 0.5 * sin(iTime + 6.2831 * o);\n\n      vec2 r = g + o - f;\n      float d = dot(r, r);\n\n      if (d < md ) {\n        md = d;\n        mr = r;\n        mg = g;\n      }\n    }\n  }\n\n  return  vec3(mr, mg.x);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = fragCoord / iResolution.xy;\n\n    float y = smoothstep(0.2,0.5,pos.x) - smoothstep(0.5,0.8,pos.x);\n    pos.y += random(pos).y;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    vec3 c = voronoi(pos);\n    color = c.x * (1.5 + 1.0 * sin(164.0 * c.x)) * vec3(1.0);\n\n\n    fragColor = vec4(1.0, color.x + 0.1, color.y + 0.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttffRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 67, 90, 90, 185], [187, 252, 279, 279, 717], [721, 721, 778, 778, 1114]], "test": "untested"}
{"id": "tlffzS", "name": "Brute Force Box Filter", "author": "GregRostami", "description": "Brute force anti-aliasing using a box-filter.\nEnjoy in Full-Screen!\nHere's the golfed version of this shader:\n[url]https://www.shadertoy.com/view/tlsBzS[/url]", "tags": ["2d", "supersampling"], "likes": 4, "viewed": 556, "published": 3, "date": "1597007524", "time_retrieved": "2024-07-30T20:51:33.396202", "image_code": "// Brute Force Box Filter - Each pixel is super sampled 256 times!\n// This shader has been optimized for speed.\n// The golfed version of this shader has been optimized for size.\n// If you know about implementing a Gausian filter in Shadertoy, please help!\n\nvoid mainImage(out vec4 O,vec2 U)\n{\n    O-=O;\n    vec2 R = iResolution.xy, u, a = (U - .5*R)/R.y;\n        \n    float A = 16.,   //The A variable determines the level of Anti-Aliasing\n          s = 1./A,\n          t = .3 * iTime,\n          x, y;\n    \n        for (y=0.; y < 1.; y += s)\n            for (x=0.; x < 1.; x += s)\n                u = a + vec2(x,y)/R.y,\n                \n                u /= dot(u,u),\n                O += max( u=fract(3.*u + t), u.x-u ).y;\n            \n        O /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlffzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 292, 292, 756]], "test": "untested"}
{"id": "ttffzS", "name": "pulse_orbit", "author": "slackmage", "description": "pulse orbit", "tags": ["orbit"], "likes": 1, "viewed": 242, "published": 3, "date": "1597006999", "time_retrieved": "2024-07-30T20:51:34.160160", "image_code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 2;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-43;\n#define EPSILON_NRM (0.1 / iResolution.x)\n#define AA\n\n// sea\nconst int ITER_GEOMETRY = 6;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 1.6;\nconst float SEA_CHOPPY = 5.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 1.16;\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*2.6;\n#define SEA_TIME (.001 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*343758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.2 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 4.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = (max(e.y,0.0)*0.8+0.2)*8.2;\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 0.1;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 2.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.0000001;\n        choppy = mix(choppy,1.0,2.0);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 1.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.3; amp *= 1.22;\n        choppy = mix(choppy,2.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 2.0);\n    fresnel = pow(fresnel,3.0) * 0.5;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 12.18 * atten;\n    \n    color += vec3(specular(n,l,eye,10.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvec3 getPixel(in vec2 coord, float time) {    \n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 4.0 - 2.0;\n    uv.x *= iResolution.x / iResolution.y;    \n        \n    // ray\n    vec3 ang = vec3(sin(time*2.0)*0.1,sin(time)*2.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*1.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    return mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.02,dir.y),2.2));\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.3 + iMouse.x*0.01;\n\t\n#ifdef AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n        \tvec2 uv = fragCoord+vec2(i,j)/2.0;\n    \t\tcolor += getPixel(uv, time);\n        }\n    }\n    color /= 2.5;\n#else\n    vec3 color = getPixel(fragCoord, time);\n#endif\n    \n    // post\n\tfragColor = vec4(pow(color,vec3(4.65)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttffzS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[681, 689, 715, 715, 1061], [1062, 1062, 1084, 1084, 1165], [1166, 1166, 1192, 1192, 1493], [1495, 1507, 1545, 1545, 1587], [1588, 1588, 1634, 1634, 1734], [1736, 1743, 1769, 1769, 1878], [1880, 1887, 1928, 1928, 2099], [2101, 2101, 2120, 2120, 2569], [2571, 2571, 2599, 2599, 3043], [3045, 3045, 3108, 3108, 3603], [3605, 3616, 3651, 3651, 3842], [3844, 3844, 3900, 3900, 4412], [4414, 4414, 4456, 4456, 5162], [5164, 5172, 5229, 5229, 5625]], "test": "untested"}
{"id": "WtffzB", "name": "Library by MareeBree", "author": "mareebree", "description": "My first shader on shadertoy", "tags": ["library"], "likes": 6, "viewed": 309, "published": 3, "date": "1597004965", "time_retrieved": "2024-07-30T20:51:34.931098", "image_code": "#define eNISTA 0\n#define eFIOKA 1\n#define eKNJIGE 2\n\n#define BROWN vec3(0.647,0.325,0.094)\n#define GOLD vec3(1.0,0.843,0.0)\n\n#define LOCAL_UV_SIZE \tvec2(4.0,6.0)\n#define LOCAL_UV_OFFSET vec2(0.05*iTime,0.5*iTime)\n\n#define ASPECT_RATIO iResolution.x/iResolution.y\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// -------------b\n// |\t\t\t|\n// |\t\t\t|\n// a-------------\nbool inRect(vec2 x ,vec2 a, vec2 b)\n{\n    return x.x > a.x && x.x < b.x && x.y > a.y && x.y < b.y;\n}\n\nfloat aspectDist(vec2 x,vec2 y)\n{\n    return length((x-y)*vec2(ASPECT_RATIO,1.0));\n}\n\nvec2 localUVSpace(vec2 uv)\n{\n    uv += LOCAL_UV_OFFSET;\n    uv *= LOCAL_UV_SIZE;\n    uv = fract(uv);\n    return uv;\n}\n\nvec2 localUVIndex(vec2 uv)\n{\n    uv += LOCAL_UV_OFFSET;\n    vec2 uvRatio = 1.0/LOCAL_UV_SIZE;\n    return floor(uv/uvRatio);\n}\n\nint getItem(vec2 index)\n{\n    float r = rand(index/1000.0);\n    if(r > 0.7) \t\t\treturn eFIOKA;\n    else if(r > 0.1) \t\treturn eKNJIGE;\n    else \t\t\t\t\treturn eNISTA;\n}\n\nvec3 drawFioka(vec2 uv, vec2 uvIndex)\n{\n    float fs = 0.2;\n    float fd = 0.15;\n    \n    vec3 col = BROWN;\n    vec2 edge_col = smoothstep(0.85,0.98,uv);\n    col -= max(edge_col.x,edge_col.y);\n    edge_col = smoothstep(0.80,0.98,vec2(1.0)-uv);\n    edge_col += smoothstep(0.85,0.98,vec2(1.0)-uv);\n    col -= max(edge_col.x,edge_col.y);\n    col = max(col,0.4*BROWN);\n    col = max(col,smoothstep(1.0-fs,1.0-fs+fd,uv.x)*BROWN);\n    col = max(col,smoothstep(fs,fs-fd,uv.x)*BROWN);\n    col = max(col,smoothstep(1.0-fs,1.0-fs+fd,uv.y)*BROWN);\n    col = max(col,smoothstep(fs,fs-fd,uv.y)*BROWN);\n    col = max(col,0.6*BROWN);\n    \n    float handleSize = 0.1;\n    vec3 handleColor = 0.6*BROWN;\n    float handleDist = aspectDist(uv,vec2(0.5));\n    handleColor *= smoothstep(0.15,0.11,handleDist);\n    col -= handleColor;\n\n    vec2 reflectionOffset = uvIndex*vec2(0.01,0.02);\n    reflectionOffset.x = clamp(-0.03,0.03,reflectionOffset.x);\n    reflectionOffset.y = clamp(-0.03,0.03,reflectionOffset.y);\n\n    vec2 reflectionPos = vec2(0.5) + reflectionOffset;\n    float reflectionDist = aspectDist(uv,reflectionPos);\n    col += smoothstep(0.04,0.001,reflectionDist);    \n\t\n    return col;\n}\n\nvec3 drawKnjige(vec2 uv,vec2 uvIndex)\n{\n    int numBooks = 6;\n    \n    vec2 bookUV = uv;\n\tbookUV.x = fract(uv.x*float(numBooks));\n    int bookIndex = int(uv/(1.0/float(numBooks)));\n    \n    float r = rand(vec2(bookIndex,uvIndex.x + uvIndex.y/2.0));\n    vec3 bookColorHSV = vec3(r,0.8,0.6);\n    vec3 bookColor = hsv2rgb(bookColorHSV);\n    \n    float bookMask = sin(3.14*bookUV.x);\n    \n    float trakaPos = bookUV.y+0.05*bookMask-0.05*r;\n   \t\n    float t = smoothstep(0.13,0.14,trakaPos);\n    float traka = min(t,smoothstep(0.20,0.19,trakaPos));\n    \n    traka *= bookMask*0.4;\n    vec3 trakaColor = GOLD*0.4;\n    \n    vec3 col = bookColor*bookMask + traka*trakaColor;\n    col += smoothstep(0.2,0.1,bookMask)*0.6*BROWN;\n    col += vec3(traka)*bookMask;\n    \n    col = clamp(col,0.0,1.0);\n    return col;\n}\n\nvec3 drawPolica(vec2 uv, vec2 uvIndex)\n{\n    float fs = 0.15; // Frame size\n    float fd = 0.10; // Frame depth\n    \n    vec3 col = vec3(0.0);\n\tcol = max(col,smoothstep(1.0-fs,1.0-fs+fd,uv.x)*BROWN);\n    col = max(col,smoothstep(fs,fs-fd,uv.x)*BROWN);\n    col = max(col,smoothstep(1.0-fs,1.0-fs+fd,uv.y)*BROWN);\n    col = max(col,smoothstep(fs,fs-fd,uv.y)*BROWN);\n    col = max(col,0.5*BROWN);\n    \n    bool shouldDrawBooks = inRect(uv,vec2(fs),vec2(1.0-fs));\n    vec2 booksUV = uv;\n    booksUV -= vec2(fs);\n    booksUV /= 1.0-2.0*fs;\n    col = mix(col,drawKnjige(booksUV,uvIndex),float(shouldDrawBooks));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= (1.3 + 0.3*sin(iTime))*iResolution.x/800.0;\n    uv.x += 0.03*uv.y*(-uv.x);\n    \n    vec2 localUV = localUVSpace(uv);\n    vec2 localIndex = localUVIndex(uv);\n    vec3 col = vec3(0);\n    \n    int item = getItem(localIndex);\n    if(item == eFIOKA)\n    {\n\t   col = drawFioka(localUV,localIndex);\n    }\n    else if(item == eKNJIGE)\n    {\n        col = drawPolica(localUV,localIndex);\n    }\n\telse\n    {\n       col = BROWN;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtffzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 402, 424, 424, 593], [595, 674, 694, 694, 766], [768, 822, 859, 859, 922], [924, 924, 957, 957, 1008], [1010, 1010, 1038, 1038, 1127], [1129, 1129, 1157, 1157, 1254], [1256, 1256, 1281, 1281, 1419], [1421, 1421, 1460, 1460, 2599], [2601, 2601, 2640, 2640, 3405], [3407, 3407, 3447, 3447, 4035], [4037, 4037, 4094, 4094, 4658]], "test": "untested"}
{"id": "ttXfzS", "name": "Chaos Abuser", "author": "t420babe", "description": "Inspiration from chapters 9 and 10 of The Book of Shaders \nhttps://thebookofshaders.com/09\nhttps://thebookofshaders.com/10", "tags": ["colors", "patterns", "truchet"], "likes": 1, "viewed": 278, "published": 3, "date": "1597004260", "time_retrieved": "2024-07-30T20:51:35.703034", "image_code": "#define PI 3.14159265358979323846\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n// From https://thebookofshaders.com/edit.php#10/ikeda-00.frag\nfloat random(vec2 pos) {\n  return fract(sin(dot(pos.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// https://thebookofshaders.com/09/\nvec2 truchet_pattern(in vec2 _pos, in float _index) {\n  _index = fract(((_index - 0.5) * 2.0));\n  if (_index > 0.75) {\n    _pos = vec2(4.0) - _pos;\n  } else if (_index > 0.5) {\n    _pos = vec2(4.0 - _pos.x, _pos.x);\n  } else if (_index > 0.25) {\n    _pos = 4.0 - vec2(1.0 - _pos.y, _pos.y);\n  }\n  return _pos;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 color = vec3(0.0);\n  float keep_time = sin(2.0 * PI * iTime);\n\n  float A = 10.0;\n  float w = 0.5;\n  float phi = 0.0;\n  float wrap_time = abs(A * sin(w * iTime + phi));\n    \n  // [-1, 1]\n  vec2 pos = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n\n  pos *= 2.0;\n  vec2 ipos = floor(pos);             // get the integer coords\n  vec2 fpos = fract(pos);             // get the fractional coords\n\n  vec2 tile = truchet_pattern(fpos, random(ipos)) * vec2(wrap_time);\n  tile.x = cos(tile.y) * sin(tile.x);\n  tile.y = log(tile.y) * log(tile.x);\n\n  float maze_color = 0.0;\n  maze_color =\n    smoothstep(tile.x - 0.3, tile.x, tile.y) -\n    smoothstep(tile.x, tile.x + 0.3, tile.y);\n\n\n\n  if (wrap_time < 0.25 * A) {\n    color = vec3(maze_color - 0.5, maze_color / 0.2, maze_color * 0.7);\n  } else if (wrap_time < 0.5 * A) {\n    color = vec3(maze_color + 0.5, maze_color / 0.2, maze_color * 0.7);\n  } else if (wrap_time < 1.0 * A) {\n    color = vec3(maze_color / 0.5, maze_color - 0.2, maze_color / 0.7);\n  }\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 148, 172, 172, 247], [249, 285, 338, 338, 596], [599, 599, 656, 656, 1701]], "test": "untested"}
{"id": "ttXBzS", "name": "Excessive Glitch", "author": "t420babe", "description": "glitchy bright shader made experimenting with chapter 10 in The Book of Shaders\n(https://thebookofshaders.com/10)", "tags": ["brighcolors", "spazz"], "likes": 2, "viewed": 264, "published": 3, "date": "1597002849", "time_retrieved": "2024-07-30T20:51:36.466992", "image_code": "#define PI 3.14159265359\n\n\n// https://thebookofshaders.com/edit.php#10/ikeda-00.frag\nfloat random(in float x) {\n\treturn fract(sin(x) * 1e1);\n}\n\n// https://thebookofshaders.com/edit.php#10/ikeda-00.frag\nfloat random(in vec2 pos) {\n\treturn fract(sin(dot(pos.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// https://thebookofshaders.com/edit.php#10/ikeda-00.frag\nfloat random_series(float x, float freq, float t) {\n\treturn step(0.8, random(floor(x * freq) - floor(t)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// [-1, 1]\n\tvec2 pos = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n\n\tfloat i_time = 0.01;\n\tvec3 color = vec3(0.0);\n\tfloat cols = 1.0;\n\tfloat freq = random(floor(sin(iTime * PI)));\n\tfloat t = i_time * freq  - tan(iTime * PI * 0.9);\n\n\t/*\n\t\t if (fract(pos.y * cols * 0.3) < 0.5) {\n\t\t t *= -1.0;\n\t\t }\n\t */\n\n\tfreq -= random(exp(pos.y * pos.y * pos.y));\n\n\tfloat offset_value = 0.025;\n\tcolor = vec3(\n\t\t\trandom_series(pos.x, freq * 65.0, t + offset_value),\n\t\t\trandom_series(pos.x, freq * 65.0, t),\n\t\t\trandom_series(pos.x, freq * 65.0, t - offset_value)\n\t\t\t);\n\n\tvec3 rgb = vec3(1.0 - color.x, color.y, 0.5);\n\n\t// Output to screen\n\tfragColor = vec4(rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 85, 111, 111, 142], [144, 202, 229, 229, 301], [303, 361, 412, 412, 469], [471, 471, 528, 540, 1187]], "test": "untested"}
{"id": "ttfBzS", "name": "Melting", "author": "t420babe", "description": "Trippy random tangent, log, sqrt.\nInspiration from chapter 10 of The Book of Shaders \nhttps://thebookofshaders.com/10/", "tags": ["colors", "tan"], "likes": 0, "viewed": 333, "published": 3, "date": "1597002807", "time_retrieved": "2024-07-30T20:51:37.237931", "image_code": "// Inspiration from https://thebookofshaders.com/edit.php#10/ikeda-00.frag\nfloat random(vec2 pos, float mod_time) {\n  float A = 30.0;\n  float w = 0.0200;\n  float phi = 0.0;\n  float wrap_time = A * cos(w * mod_time + phi);\n  wrap_time = -abs(wrap_time);\n  float arg0 = 12.9898;\n  float arg1 = 780.2333 / 10000.0 * log(mod_time);\n  float arg2 = 143758.5453123 / (10.0 * wrap_time);\n  return fract(sin(dot(pos.xy, vec2(arg0, arg1))) * arg2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 pos = fragCoord.xy / iResolution.xy;\n  pos.x *= 0.25;\n  pos.y *= 0.05;\n\n  vec3 color = vec3(0.0);\n  float time_limit = 160.0;\n  float mod_time = mod(iTime, time_limit);\n\n\n  float rnd = random( pos, mod_time ) * 0.4;\n  //color = vec3(cos(rnd), sin(rnd), atan(rnd));\n  color = vec3(tan(rnd), log(rnd), 1.0 - sqrt(rnd));\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 75, 115, 115, 440], [442, 442, 498, 498, 858]], "test": "untested"}
{"id": "ttffRS", "name": "Are You In My Circle", "author": "t420babe", "description": "Originated from playing with functions from chapter 6 and 7 of The Book of Shaders (https://thebookofshaders.com/06/, https://thebookofshaders.com/07/)", "tags": ["distancefield", "colors", "circle", "trippy", "spirals", "siezure"], "likes": 2, "viewed": 355, "published": 3, "date": "1596999245", "time_retrieved": "2024-07-30T20:51:37.998896", "image_code": "// From http://thebookofshaders.com/edit.php?log=200809173941\nvec3 hsb2rgb(in vec3 c) {\n\tvec3 abs_rgb = abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0;\n\tvec3 rgb = clamp(abs_rgb, 0.0, 1.0);\n\trgb = rgb * rgb * (3.0 - 2.0 * rgb);\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// Inspiration from http://thebookofshaders.com/edit.php?log=200809183022\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\t// [-1, 1]\n\tvec2 pos = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n\tvec3 color = vec3(0.0);\n\n\tfloat center = 0.0;\n\tfloat radius = 1.0;\n\n\tradius = abs(sin(iTime * 1.0)) * radius;\n\n\tfloat pct = distance(pos, vec2(center));\n\tpct /= distance(pos,vec2(0.0)) + distance(pos,vec2(0.6));\n\tfloat threshold_flag = step(pct, radius);\n\n\tif (threshold_flag == 1.0){\n\t\tvec3 tmp = vec3(pct * threshold_flag);\n\t\tcolor = hsb2rgb(tmp * 26.0);\n\t} else {\n\t\tpct = pow(distance(pos,vec2(0.4)),distance(pos,vec2(0.6)));\n\t\tthreshold_flag = step(pct, 15.0);\n\t\tvec3 tmp = vec3(pct * threshold_flag);\n\t\tcolor = hsb2rgb(tmp * 26.0);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttffRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 87, 87, 281], [283, 357, 414, 427, 1065]], "test": "untested"}
{"id": "wlXfRS", "name": "Twisted Distance Fields", "author": "t420babe", "description": "\nOriginated from playing with functions from chapter 6, 7, and 8 of The Book of Shaders \nhttps://thebookofshaders.com/06/\nhttps://thebookofshaders.com/07/\nhttps://thebookofshaders.com/08/\nhttp://thebookofshaders.com/edit.php?log=200809180254\n", "tags": ["pulse", "distancefield", "colors", "shapes"], "likes": 0, "viewed": 251, "published": 3, "date": "1596997728", "time_retrieved": "2024-07-30T20:51:38.771829", "image_code": "#define PI 3.14159265359\n\n// Inspiration from http://thebookofshaders.com/edit.php?log=200809173941\nvec3 twisted_hsb2rgb(in vec3 color) {\n\tfloat color_multiplier = mod(iTime, 10.0) / 10.0 + 5.0;\n\tvec3 c = vec3(5.0, 8.0, 6.0) * color_multiplier;\n\tvec3 abs_rgb = abs(mod(color.x * 15.0 + c, 8.0) - 1.0) - 1.0;\n\tvec3 rgb = clamp(abs_rgb, 0.0, 1.0);\n\trgb = rgb * rgb * (3.0 - 2.0 * rgb);\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// https://thebookofshaders.com/08/\nfloat random(vec2 pos) {\n\treturn fract(sin(dot(pos.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// Inspiration from http://thebookofshaders.com/edit.php?log=200809180254\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// [0, 1]\n\tvec2 pos = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n\n\tpos *= iResolution.x / iResolution.y;\n\tvec3 color = vec3(0.0);\n\tfloat d = 0.0;\n\tfloat rate = 1.0;\n\tvec2 dim_bounds = vec2(1.0, 400.0);\n\tfloat test = random(dim_bounds);\n\tfloat dim = 1.0;\n\tfloat switch_inc = 3.0 * PI;\n\n\n\t// Distance field\n\tfloat current_time = abs(sin(iTime * rate));\n\tif (mod(iTime, switch_inc) < PI) {\n\t\td = length(abs(pos) - 0.3) * current_time;\n\t} else if (mod(iTime, switch_inc) > PI && mod(iTime, switch_inc) < 2.0 * PI) {\n\t\td = length( min(abs(pos)- 0.5, 0.2) ) * current_time;\n\t} else {\n\t\td = length(max(abs(pos) - 0.0001, 0.3)) * current_time;\n\t}\n\n\tcolor = twisted_hsb2rgb(vec3(smoothstep(0.3, 0.4, d) * smoothstep(0.6, 0.5, d)) );\n\n\t// Output to screen\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 100, 137, 137, 425], [427, 463, 487, 487, 559], [561, 635, 692, 703, 1479]], "test": "untested"}
{"id": "wtXfRS", "name": "Twisted Medallion", "author": "t420babe", "description": "Originated from playing with functions from chapter 6 of The Book of Shaders (https://thebookofshaders.com/06/)", "tags": ["pulse", "colors", "polarshapes", "medallion"], "likes": 1, "viewed": 264, "published": 3, "date": "1596996104", "time_retrieved": "2024-07-30T20:51:39.543766", "image_code": "#define PI 3.14159265359\n\n// Inspiration from http://thebookofshaders.com/edit.php?log=200809173941\nvec3 twisted_hsb2rgb(in vec3 color) {\n  float change_rate = 2.0;\n  float color_multiplier = abs(sin(iTime * change_rate)) + 1.0;\n  vec3 c = vec3(9.0, 5.0, 2.0) * color_multiplier;\n  vec3 rgb_abs = abs(mod(color.x * 5.0 + c, 5.0) - 5.0) - 1.0;\n  vec3 rgb = clamp(rgb_abs, 0.0, 1.0);\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  return color.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  // [-1, 1]\n  vec2 position = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n\n  vec3 color = vec3(0.0);\n\n  float center = 0.0;\n  float scale = 1.0;    \n\n  // Polar coordinates\n  float r = length(position) * scale;\n  float theta = atan(position.y, position.x);\n\n  float w0 = 500.0;\n  float w1 = 10.0;\n  float m = -200.0;\n  float vary_radius = 0.5;\n\n  float f = smoothstep(-0.5, 1.0, cos(theta * w0)) * m + vary_radius;\n\n  float thickness = 0.3;\n  color = twisted_hsb2rgb(vec3(1.0 - smoothstep(f, f + thickness, r)));\n\n  // Output to screen\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 100, 137, 137, 467], [469, 469, 526, 540, 1105]], "test": "untested"}
{"id": "wtsBzM", "name": "Sanctum", "author": "dean_the_coder", "description": "Another scene featuring 'god rays'.\nImproving their quality hurts my GPU too much - I might have to spend some time thinking of a more efficient technique.", "tags": ["3d", "raymarching", "light", "godrays", "ruins"], "likes": 43, "viewed": 1288, "published": 3, "date": "1596993137", "time_retrieved": "2024-07-30T20:51:40.308720", "image_code": "// 'Sanctum'\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq and a bunch of others\n// for sharing their knowledge!\n\n#define MIN_DIST .0015\n\n#define MISS_ID   .5\n#define FLOOR_ID  1.5\n#define WALL_ID   2.5\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\nvec2 cappedMod(vec2 p, float c, vec2 rr) {\n    return p - c * clamp(round(p / c), -rr, rr);\n}\n\nmat2 rot(float a) {\n    float c = cos(a),\n          s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, q.y), 0.);\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h,r);\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdFlower(vec2 xy, float r, float a, float peaks) {\n    return length(xy) - r + a * sin(atan(xy.y * 2.34 / xy.x) * peaks);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro),\n         right = normalize(cross(vec3(0, 1, 0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdArch(vec3 p, const float plinthDepth) {\n    // Main wall.\n    vec3 s = vec3(2, 3, .4);\n    const float gapWidth = .5;\n    float holeOffset = (s.x + gapWidth) / 2.;\n    vec3 pp = p;\n    pp.x = abs(pp.x);\n    pp.y -= s.y;\n    float d = sdBox(pp, s);\n\n    // Arch holes.\n    d = max(d, -length(pp.xy - vec2(0, 1.5)) + gapWidth);\n    d = max(d, -length(pp.xy - vec2(holeOffset, 1)) + gapWidth);\n\n    // Arch gaps.\n    pp.y += s.y;\n    d = max(d, -sdBox(pp.xy, vec2(gapWidth, s.y + 1.5)));\n    d = max(d, -sdBox(pp.xy - vec2(holeOffset, 0), vec2(gapWidth, s.y + 1.)));\n\n    // Support decoration.\n    d = min(d, sdBox(pp - vec3(s.x / 3. - .035, s.y + .75, 0.), vec3(.15, .05, s.z + .05)) - .05);\n\n    // Short wall.\n    pp.z = abs(pp.z) + .7;\n    pp.y -= .6;\n    d = min(d, sdCylinder(pp.yxz, 1., s.x - gapWidth / 2.));\n\n    // Plinth.\n    d = min(d, sdBox(p - vec3(0, .2, 0), vec3(s.x - gapWidth / 2., .1, s.z + plinthDepth)) - .1);\n\n    // Backing wall.\n    pp = p;\n    s *= vec3(1.18, 1, .25);\n    pp -= vec3(0, s.y, 3);\n    d = min(d, sdBox(pp, s));\n\n    // Backing roof.\n    float hole = .6,\n          bar = .03;\n    pp.y -= 1.;\n    pp.xy = cappedMod(pp.xy, hole + bar * 2., vec2(1));\n    d = max(d, -sdBox(pp, vec3(hole / 2., hole / 2., .5)));\n\n    return d;\n}\n\nvec2 map(vec3 p) {\n    float surface = texture(iChannel0, (p.xy + p.yz + p.xz) * .1).r * .01,\n\n    // 'Collapse'.\n          collapse = sdFlower(p.xy - vec2(1, 11), 5., .2, 8.);\n    collapse = max(collapse, 10. - p.z);\n    collapse = min(collapse, sdFlower(p.xy - vec2(.9, 10), 3., .2, 4.));\n\n    // 'Fold space' to duplicate the arches.\n    for (int i = 0; i < 9; i++) {\n        p.xz *= rot(-.1);\n        p.x -= 1.04;\n        p.x = abs(p.x);\n    }\n\n    // Top arches.\n    float d = sdArch(p - vec3(0, 5.7, 10), 0.);\n    d = max(d, -collapse);\n\n    // Bottom arches.\n    d = min(d, sdArch(p - vec3(0, 0, 10), 1.));\n    d -= surface;\n\n    return min2(vec2(abs(p.y), FLOOR_ID), vec2(d, WALL_ID));\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1., -1.) * .5773 * .0001;\n    return normalize(e.xyy * map(p + e.xyy).x +\n\t\t\t\t\t e.yyx * map(p + e.yyx).x +\n\t\t\t\t\t e.yxy * map(p + e.yxy).x +\n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcAO(vec3 p, vec3 n, float d) {\n    return clamp(map(p + n * d).x / d, 0., 1.);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    vec3 rd = normalize(lightPos - p);\n\n    float res = 1.,\n          t = .1;\n    for(float i = 0.; i < 30.; i++)\n    {\n        float h = map(p + rd * t).x;\n        if (h < .03)\n            return 0.; // Hit an object - Full shadow.\n\n        res = min(res, 8. * h / t);\n        t += h;\n\n        if (t > 20.)\n            break; // Marched far enough - Stop.\n    }\n\n    return res;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n    return col;\n}\n\nvec3 sunPos = vec3(10, 8, 20),\n     sunCol = vec3(2, 1.9, 1.5);\n\nvec3 getMaterial(vec3 p, vec3 rd, float id) {\n    if (id == MISS_ID)\n        return vec3(0);\n\n    vec3 sunDir = normalize(sunPos - p),\n         n = calcNormal(p);\n\n    vec3 mat;\n    if (id == FLOOR_ID) {\n        mat = vec3(texture(iChannel0, p.xz * .01).r);\n    } else if (id == WALL_ID) {\n        mat = texture(iChannel0, (n.xy + n.yz) * .05).rgb;\n    }\n\n    // Diffuse color.\n    float diff = max(0., dot(sunDir, n)),\n\n    // Fake ambient occlusion.\n          occ = min(1., .2 + calcAO(p, n, 1.) * calcAO(p, n, .4));\n\n    // Shadows.\n    float sha = calcShadow(p, sunPos);\n\n    // Primary light (Sun).\n    vec3 lig = diff * sha * sunCol;\n\n    // Seconary light (Sky);\n    lig += max(0., .5 + .5 * n.y) * vec3(.7, .8, 1) * .2 * occ;\n\n    // Third light - Ambient.\n    lig += max(0., dot(sunDir * vec3(-1., 0., -1.), n)) * sunCol * .02 * occ;\n\n    return mat * lig;\n}\n\nvoid march(vec3 ro, vec3 rd, out vec3 p, out vec2 h) {\n    float d = .01;\n    for (float steps = 0.; steps < 96.; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n\n        if (abs(h.x) < MIN_DIST) return; // We've hit a surface - Stop.\n        d += h.x * .9; // No hit, so keep marching.\n    }\n\n    h.y = MISS_ID;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    // Camera.\n    float ft = fract(iTime / 8.),\n          phase = mod(floor(iTime / 8.), 3.);\n\n    vec3 ro,\n         lookAt = vec3(0, 6, 12);\n\n    if (phase == 0.) {\n        ro = vec3(5. - ft, 1.5, -5.);\n        lookAt.x -= ft;\n        sunPos.x *= mix(.82, 1.62, ft);\n        sunPos.y *= mix(2.375, .90, ft);\n    } else if (phase == 1.) {\n        ro = vec3(-5. + ft, 1.5, 2.);\n        lookAt = vec3(0, 3, 12);\n        sunPos.x *= mix(.02, 1.99, ft);\n        sunPos.y *= mix(.375, .90, ft);\n    } else if (phase == 2.) {\n        ro = vec3(mix(-5., -.0625, ft), 4.7, 5.);\n        sunPos.y *= 1.625;\n    }\n\n    vec3 rd = getRayDir(ro, lookAt, uv);\n\n    // Raymarch.\n    vec2 h = vec2(1e7, MISS_ID);\n    vec3 p;\n\tmarch(ro, rd, p, h);\n\n    // Materials and lighting.\n    vec3 col = getMaterial(p, rd, h.y);\n\n    // Volumetric lighting ('God rays')\n    const float maxSteps = 35.;\n    float dp = distance(ro, p);\n    vec3 beamStep = rd * dp / maxSteps;\n    float illum = 0.;\n    float jit = hash(uv) * .6;\n    for (float i = 0.; i < maxSteps; i++) {\n        vec3 sp = ro + beamStep * (i + jit); // Jitter so smooth sampling point. (Thanks BigWings!)\n        illum += smoothstep(0., 1., calcShadow(sp, sunPos));\n    }\n\n    illum /= maxSteps;\n    col = mix(col, sunCol, pow(illum, .7));\n\n    // Fog.\n    col = mix(vec3(1), col, vec3(exp(-pow(dp / 50., 3.) * 5.)));\n\n    // Output to screen.\n    col = vignette(pow(col, vec3(.4545)), fragCoord);\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 232, 232, 296], [298, 298, 340, 340, 391], [393, 393, 412, 412, 488], [490, 490, 519, 519, 612], [614, 614, 643, 643, 726], [728, 728, 772, 772, 881], [883, 883, 939, 939, 1012], [1014, 1014, 1061, 1061, 1260], [1262, 1262, 1289, 1289, 1321], [1323, 1323, 1370, 1388, 2592], [2594, 2594, 2612, 2612, 3289], [3291, 3291, 3316, 3316, 3509], [3511, 3511, 3550, 3550, 3600], [3602, 3602, 3643, 3643, 4025], [4113, 4113, 4154, 4154, 4289], [4356, 4356, 4401, 4401, 5223], [5225, 5225, 5279, 5279, 5547], [5549, 5549, 5601, 5601, 7137]], "test": "untested"}
{"id": "tlXBRS", "name": "P.Gerdes & Tchokwe sand drawing4", "author": "FabriceNeyret2", "description": "another decorated strip variant of [url]https://shadertoy.com/view/wtsfWM[/url]\n\nReference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]\n", "tags": ["tiles", "short", "truchets"], "likes": 4, "viewed": 331, "published": 3, "date": "1596992532", "time_retrieved": "2024-07-30T20:51:41.070684", "image_code": "// variant of https://shadertoy.com/view/WlffzB\n// cf alternate drawing (closer to spirit) here: https://www.shadertoy.com/view/tlXBz2\n\n#define S(v) smoothstep( 9./R.y , 0. , v )           // AA draw\n#define s(v) cos(6.28*v/.09)                         // strip pattern \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(1);\n    mat2 M = mat2(1,-1,1,1);                         // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / R.y + iTime,\n         I = floor( U * M ),                         // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414, f;        // quad center to edge domain\n    \n    O -= S( length(F) - .1 );                        // dots\n\n    float i = I.y + 10.*I.x +99.,                    // edge id (float)\n          r = fract(4e4*sin(i)),                     // rand(id)\n          t = 2.*fract(iTime/4.),\n          k = .353*(1.+4.*min(t,2.-t));\n    O.gb -= r < .5\n        ? f = abs( abs(F) - .353*k ),\n          F = S( f -.1 ) * s(f),                     //  X at edge\n          F.x + F.y \n          - ( F.yx * S(f-.1) ) [int(4.*r)]           //   random crossing order\n        :(                           \n          i = abs( length(F) - .353*k ),             // )( at edge\n          S( i -.1 ) * s(i) );\n\n // O -= .4*( .5+.5*cos(6.3*r + vec4(0,2,-2,0)) );   // coloring ( debug )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 310, 310, 1347]], "test": "untested"}
{"id": "WlffzB", "name": "P.Gerdes & Tchokwe sand drawing3", "author": "FabriceNeyret2", "description": "decorated strip variant of [url]https://shadertoy.com/view/wtsfWM[/url]\n\nReference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]\n", "tags": ["tiles", "short", "truchets"], "likes": 11, "viewed": 306, "published": 3, "date": "1596991390", "time_retrieved": "2024-07-30T20:51:41.838630", "image_code": "// decorated strip variant of https://shadertoy.com/view/wtsfWM\n\n#define S(v) smoothstep( 9./R.y , 0. , v )           // AA draw\n#define s(v) cos(6.28*v/.09)                         // strip pattern \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(1);\n    mat2 M = mat2(1,-1,1,1);                         // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / R.y + iTime,\n         I = floor( U * M ),                         // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414, f;        // quad center to edge domain\n    \n    O -= S( length(F) - .1 );                        // dots\n\n    float i = I.y + 10.*I.x +99.,                    // edge id (float)\n          r = fract(4e4*sin(i));                     // rand(id)\n    O -= r < .5\n        ? f = abs( abs(F) - .353 ),\n          F = S( f -.1 ) * s(f),                     //  X at edge\n          F.x + F.y \n          - ( F.yx * S(f-.1) ) [int(4.*r)]           //   random crossing order\n        :(                           \n          r = abs( length(F) - .353 ),               // )( at edge\n          S( r -.1 ) * s(r) );\n\n // O -= .4*( .5+.5*cos(6.3*r + vec4(0,2,-2,0)) );   // coloring ( debug )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlffzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 239, 239, 1197]], "test": "untested"}
{"id": "3lffzS", "name": "flesh onoinss", "author": "zikbakguru", "description": "humans have flesh\nonions also have flesh\nI thin ¯\\_(ツ)_/¯", "tags": ["2d", "zoom", "rainbow"], "likes": 18, "viewed": 528, "published": 3, "date": "1596981410", "time_retrieved": "2024-07-30T20:51:42.616550", "image_code": "//#define SHOWMOUSE\n//#define SHOWDITHER\n#define DITHERING\n#define DOWNSCALE\n#define PI 3.14\n\n#define GRID_UV_ZOOM 10.0\n#define GRID_NOISE_ZOOM 2.0\n#define GRID_NUM vec2(8.0)\n#define BLUR_SPREAD 32.0\n#define VIGNETTE\n\n// dithering : colour precision\n#define COL_LEVELS 4.0\n\nfloat sampleDither (vec2 uv, vec2 resolution)\n{\n    vec2 screencoord = (uv * resolution);\n    return texture(iChannel1, fract(screencoord / vec2(8.0))).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenuv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    // downscale the screen\n    #ifdef DOWNSCALE\n    \tvec2 downscaleResolution = floor(iResolution.xy * 0.25);\n    \tvec2 uvScale = downscaleResolution; // vec2(downscaleFactor) / iResolution.xy;\n    \tvec2 uv = floor(screenuv * uvScale) / uvScale;\n    \n    \t#ifdef DITHERING\n    \t\tfloat screenDither = sampleDither(uv, downscaleResolution);\n   \t\t#endif\n   \t#else\n    \tvec2 uv = screenuv;\n    \tfloat screenDither = 0.5;\n    #endif\n    \n    // get screen texture\n    col = texture(iChannel0, uv).rgb;\n    \n    // calculate blur\n    vec3 colblur = vec3(0.0);\n    \n    vec2 PIXEL_SZ = 1.0 / iResolution.xy;\n    const float HALF_ITERATION = 4.0;\n    const float ITERATION_WEIGHT = 0.5 / HALF_ITERATION;\n    const vec2 BLUR_OFF = vec2(BLUR_SPREAD, 0.0);\n    for (float i=-HALF_ITERATION; i<HALF_ITERATION; i+=1.0)\n    {\n        float iterationIndex = i + screenDither;\n        vec2 uvoff = PIXEL_SZ * BLUR_OFF * iterationIndex;\n        vec3 screencolh = texture(iChannel0, uv + uvoff.xy).rgb;\n        vec3 screencolv = texture(iChannel0, uv + uvoff.yx).rgb;\n        \n        colblur += (screencolh + screencolv) * ITERATION_WEIGHT * 0.5;\n    }\n\n    // apply blur as glow\n    const vec2 BLUR_SHARPNESS = vec2(2.0, 4.0);\n    const float BLUR_STRENGTH = 0.85;\n    colblur.r = pow(1.0 - pow(1.0 - colblur.r, BLUR_SHARPNESS.x), BLUR_SHARPNESS.y);\n    colblur.g = pow(1.0 - pow(1.0 - colblur.g, BLUR_SHARPNESS.x), BLUR_SHARPNESS.y);\n    colblur.b = pow(1.0 - pow(1.0 - colblur.b, BLUR_SHARPNESS.x), BLUR_SHARPNESS.y);\n    col += colblur * BLUR_STRENGTH;\n    col = clamp(col, 0.0, 1.0);\n    \n    // Limit colours\n    #ifdef DITHERING\n        const float COL_LEVELS_INV = 1.0 / COL_LEVELS;\n        vec3 colDiv = (floor(col * COL_LEVELS) * COL_LEVELS_INV);\n        vec3 colFrac = fract(col * COL_LEVELS);\n        col = colDiv + floor(max(screenDither - colFrac, 0.0) + 0.5) * COL_LEVELS_INV;\n        col = clamp(col, 0.0, 1.0);\n    #endif\n    \n    // Apply vignette\n    #ifdef VIGNETTE\n    \tconst vec3 vignettetint = vec3(0.2, 0.25, 0.4);\n    \tfloat centerDist = length(0.5 - uv);\n    \t\n    \tcol *= mix(vec3(1.0), vignettetint, smoothstep(0.5, 0.75, centerDist));\n    #endif\n    \n    // output to screen\n    fragColor = vec4(col,1.0);\n    \n    #ifdef SHOWDITHER\n    \tfragColor = vec4(vec3(screenDither),1.0);\n    #endif\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define SHOWMOUSE\n//#define SHOWDITHER\n#define MOTIONBLUR\n#define PI 3.14\n\n#define GRID_UV_ZOOM 10.0\n#define GRID_NOISE_ZOOM 2.0\n#define GRID_NUM vec2(8.0)\n\n// Noise & rand function from\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n)\n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n////\n\n// HSV to RGB conversion function from\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n////\n\nfloat getGridContent (vec2 p)\n{\n    const float noiseTreshold = 0.4;\n    float val = noise(p * GRID_NOISE_ZOOM);\n    val = clamp(ceil(val - noiseTreshold), 0.0, 1.0);\n    \n   \treturn val;\n}\n\nfloat sampleDither (vec2 uv)\n{\n    vec2 screenuv = uv * iResolution.xy;\n    return texture(iChannel0, fract(screenuv / vec2(8.0))).r;\n}\n\nfloat dither (vec2 uv, float v1, float v2, float treshold)\n{\n    float dither = sampleDither(uv);\n    if (dither < treshold)\n    \treturn v1; //mix(v1, v2, ceil(max(dither - treshold, 0.0)));\n   \treturn v2;\n}\n\nvec3 sampleGrid (vec2 uv)\n{\n    vec3 col = vec3(1.0);\n    \n\t// get grid UV\n    vec2 gridUV = floor(uv * GRID_NUM) / GRID_NUM;\n    vec2 gridLocalUV = fract(uv * GRID_NUM);\n    \n    // get grid contents\n    float grid = getGridContent(gridUV);\n    col = vec3(grid);\n    return col;\n}\n\nvec3 sampleScreen (vec2 uv, float t)\n{\n    vec3 col = vec3(0.0);\n    \n    // aspect ratio/factor\n    vec2 uvAspectFactor = vec2(iResolution.xy / iResolution.x);\n    \n    float time = t * 2.0;\n    float timeInt = floor(time);\n    float timeFrac = fract(time);\n    \n    const float iterations = 7.0;\n    const float iterationsInv = 1.0 / iterations;\n    const vec2 iterationUVOff = vec2(420.0, 512.0);\n    const float iterationZoomStep = (1.0 / iterations) * 2.0;\n    const float iterationHalf = iterations * 0.5;\n    \n    const float animWeight = 8.0;\n    float iterationAnimT = pow(1.0 - pow(1.0 - timeFrac, animWeight), animWeight);\n    float iterationZoom = iterationAnimT;\n    float iterationZoomOff = iterationZoom * iterationZoomStep;\n    float iterationZoomShadeOff = iterationZoom * iterationsInv;\n    \n    for (float i=0.0; i<=iterations; i+=1.0)\n    {\n        float layerTime = time;\n        float layerInterp = i * iterationsInv;\n        float layerInterpZoom = clamp((1.0 - layerInterp) - iterationZoomShadeOff, 0.0, 1.0);\n        \n        float layerNumCentered = i - iterationHalf;\n        float layerZoom = (layerNumCentered * iterationZoomStep + iterationZoomOff);\n        float layerAngle = layerTime * 0.1 + cos(layerTime) * PI * 0.1 * (1.0 + (layerInterpZoom - 0.5));\n        \n        float layerIndexOff = (i - timeInt);\n        \n        vec2 layerGridOff = iterationUVOff * layerIndexOff;\n        vec3 layerTint = hsv2rgb(vec3(layerIndexOff * 0.1, 1.0, 1.0));\n        \n        // transform grid\n        vec2 layerUV = uv;// * uvAspectFactor;\n        layerUV -= 0.5;\n        layerUV *= uvAspectFactor;\n        layerUV *= mat2(cos(layerAngle), -sin(layerAngle),\n                       \tsin(layerAngle), cos(layerAngle));\n        layerUV *= 1.0 / uvAspectFactor;\n            \n        layerUV *= (1.0 + iterationZoomStep - layerZoom);\n        layerUV += 0.5;\n        layerUV *= uvAspectFactor * GRID_UV_ZOOM;\n        layerUV += vec2(layerTime + cos(layerTime * PI * 0.15 + PI) * 4.0, layerTime + sin(layerTime * 0.5 * PI));\n        layerUV += layerGridOff;\n        \n        // visualize grid\n        float layerAlpha = mix(1.0, 1.0 - iterationZoom, max(layerInterp + iterationZoomShadeOff - 1.0, 0.0) / iterationsInv); // (1.0 - (min(layerShadeInterp, 0.0) / iterationsInv));\n        float layerShadeInterp = layerInterpZoom; // clamp((1.0 - layerInterp) - iterationZoomShadeOff, 0.0, 1.0);\n        float layerShade = 1.0 - layerShadeInterp; //(1.0 - abs(layerShadeInterp * 2.0 - 1.0));\n        float layerMask = sampleGrid(layerUV).r;\n        layerTint *= layerShade; //vec3(sin(layerInterp * PI * 2.0 + PI * 0.75), sin(layerInterp + PI * 0.5), sin(layerInterp * PI * 2.0 + PI));\n        \n        col = mix(col, layerTint, layerMask * layerAlpha); // dither(uv, 1.0, 0.0, layerMask * layerAlpha));\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    #ifdef MOTIONBLUR\n    \tfloat screenDither = sampleDither(uv);\n    \tconst float iteration = 4.0;\n    \tconst float iterationInv = 1.0 / (iteration + 1.0);\n    \tconst float motionblurFactor = 0.03;\n    \tfor (float i=0.0; i<=iteration; i+=1.0)\n        {\n            float timeoffset = (i + screenDither) * iterationInv * motionblurFactor;\n            vec3 currentFrame = sampleScreen(uv, iTime - timeoffset);\n        \tcol += currentFrame * iterationInv;\n        }\n    \t// col = sampleScreen(uv, iTime);\n    #else\n    \tcol = sampleScreen(uv, iTime);\n    #endif\n    \n    /*\n\t// fix aspect ratio\n    vec2 uvAspectFactor = vec2(iResolution.xy / iResolution.x);\n    uv *= 1.0;\n    \n    float time = iTime * 2.0;\n    float timeInt = floor(time);\n    float timeFrac = fract(time);\n    \n    const float iterations = 7.0;\n    const float iterationsInv = 1.0 / iterations;\n    const vec2 iterationUVOff = vec2(420.0, 512.0);\n    const float iterationZoomStep = (1.0 / iterations) * 2.0;\n    const float iterationHalf = iterations * 0.5;\n    \n    const float animWeight = 8.0;\n    float iterationAnimT = pow(1.0 - pow(1.0 - timeFrac, animWeight), animWeight);\n    float iterationZoom = iterationAnimT;\n    float iterationZoomOff = iterationZoom * iterationZoomStep;\n    float iterationZoomShadeOff = iterationZoom * iterationsInv;\n    \n    for (float i=0.0; i<=iterations; i+=1.0)\n    {\n        float layerTime = time;\n        float layerInterp = i * iterationsInv;\n        float layerInterpZoom = clamp((1.0 - layerInterp) - iterationZoomShadeOff, 0.0, 1.0);\n        \n        float layerNumCentered = i - iterationHalf;\n        float layerZoom = (layerNumCentered * iterationZoomStep + iterationZoomOff);\n        float layerAngle = layerTime * 0.1 + cos(layerTime) * PI * 0.1 * (1.0 + (layerInterpZoom - 0.5));\n        \n        float layerIndexOff = (i - timeInt);\n        \n        vec2 layerGridOff = iterationUVOff * layerIndexOff;\n        vec3 layerTint = hsv2rgb(vec3(layerIndexOff * 0.1, 1.0, 1.0));\n        \n        // transform grid\n        vec2 layerUV = uv;// * uvAspectFactor;\n        layerUV -= 0.5;\n        layerUV *= uvAspectFactor;\n        layerUV *= mat2(cos(layerAngle), -sin(layerAngle),\n                       \tsin(layerAngle), cos(layerAngle));\n        layerUV *= 1.0 / uvAspectFactor;\n            \n        layerUV *= (1.0 + iterationZoomStep - layerZoom);\n        layerUV += 0.5;\n        layerUV *= uvAspectFactor * GRID_UV_ZOOM;\n        layerUV += vec2(layerTime + cos(layerTime * PI * 0.15 + PI) * 4.0, layerTime + sin(layerTime * 0.5 * PI));\n        layerUV += layerGridOff;\n        \n        // visualize grid\n        float layerAlpha = mix(1.0, 1.0 - iterationZoom, max(layerInterp + iterationZoomShadeOff - 1.0, 0.0) / iterationsInv); // (1.0 - (min(layerShadeInterp, 0.0) / iterationsInv));\n        float layerShadeInterp = layerInterpZoom; // clamp((1.0 - layerInterp) - iterationZoomShadeOff, 0.0, 1.0);\n        float layerShade = 1.0 - layerShadeInterp; //(1.0 - abs(layerShadeInterp * 2.0 - 1.0));\n        float layerMask = sampleGrid(layerUV).r;\n        layerTint *= layerShade; //vec3(sin(layerInterp * PI * 2.0 + PI * 0.75), sin(layerInterp + PI * 0.5), sin(layerInterp * PI * 2.0 + PI));\n        \n        col = mix(col, layerTint, layerMask * layerAlpha); // dither(uv, 1.0, 0.0, layerMask * layerAlpha));\n    }\n\t*/\n    // output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lffzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 274, 321, 321, 430], [432, 432, 489, 489, 2872]], "test": "untested"}
{"id": "3tfBRB", "name": "SimpleFractal", "author": "yuzelesss", "description": "rectangle fractal that depends on time", "tags": ["fractal"], "likes": 0, "viewed": 218, "published": 3, "date": "1596973829", "time_retrieved": "2024-07-30T20:51:43.381504", "image_code": "void mainImage(out vec4 pxColor, in vec2 pxCoord)\n{\n    vec2 uv = pxCoord / iResolution.xy;\n    \n    vec4 texColor = vec4(1, 1, 1, 1);\n    texColor.r = abs(sin(uv.x));\n    texColor.g = abs(sin(uv.y));\n    texColor.b = 0.0;\n    \n    texColor.r *= tan(texColor.r * iTime);\n    texColor.g *= tan(texColor.g * iTime);\n    texColor.b *= tan(texColor.b * iTime);\n    \n    pxColor = texColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfBRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 387]], "test": "untested"}
{"id": "3tfBRS", "name": "Deep in the Gibson", "author": "toomuchvoltage", "description": "Deep in the Gibson O.o ...\nThis one is experimenting with self directing agents... had been dying to do something like this.\nStart with resolutions higher than or equal to 800x450. Otherwise, will bug out at full screen.", "tags": ["sdf", "sphere", "marching", "blending", "alpha", "gibson", "hacker"], "likes": 4, "viewed": 542, "published": 3, "date": "1596970757", "time_retrieved": "2024-07-30T20:51:44.436683", "image_code": "/***********************************************************\n\n   Deep in the Gibson O.o ...\n   This one is experimenting with self directing agents... had been dying to do something like this.\n   White noise is modified iq noise : https://www.shadertoy.com/view/Msf3WH\n   All your sdf are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n\nfloat hash3(vec3 p)\n{\n    p *= 60.0;\n    p = 50.0*fract( p*0.3183099 + vec3(0.71,0.113, 0.563));\n    return fract(p.x*p.y*(p.x+p.y) + p.x*p.z*(p.x+p.z) + p.y*p.z*(p.y+p.z));\n}\n\nfloat sdBox( vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opRep( in vec3 p, in vec3 c, in vec3 d)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdBox( q, d );\n}\n\nfloat scene(vec3 p)\n{\n    float retVal =  opRep (p, vec3 (2.0), vec3 (1.0));\n    float retVal1 = max (retVal, -p.x + 1.0);\n    float retVal2 = max (retVal, p.x + 1.0);\n    float retVal3 = max (retVal, -p.y + 1.0);\n    float retVal4 = max (retVal, p.y + 1.0);\n    return min (min (retVal3, retVal4), min (retVal1, retVal2));\n}\n\nvec3 sceneNorm (vec3 p)\n{\n    float gradD = 0.01;\n    float gradX = scene (p + vec3 ( gradD, 0.0, 0.0)) - scene (p - vec3 ( gradD, 0.0, 0.0));\n    float gradY = scene (p + vec3 ( 0.0, gradD, 0.0)) - scene (p - vec3 ( 0.0, gradD, 0.0));\n    float gradZ = scene (p + vec3 ( 0.0, 0.0, gradD)) - scene (p - vec3 ( 0.0, 0.0, gradD));\n\n    return normalize (vec3 (gradX, gradY, gradZ));\n}\n\nvec4 fetchTexture (vec2 uvCoord, vec2 textureRes)\n{\n    vec2 fetchCoord = uvCoord * textureRes;\n    vec2 fetchFract = fract (fetchCoord);\n    vec4 fetch00 = texelFetch (iChannel0, ivec2 (fetchCoord.xy), 0);\n    vec4 fetch10 = texelFetch (iChannel0, ivec2 (fetchCoord.xy) + ivec2 (1, 0), 0);\n    vec4 fetch01 = texelFetch (iChannel0, ivec2 (fetchCoord.xy) + ivec2 (0, 1), 0);\n    vec4 fetch11 = texelFetch (iChannel0, ivec2 (fetchCoord.xy) + ivec2 (1, 1), 0);\n    \n    return mix (mix (fetch00, fetch10, fetchFract.x), mix (fetch01, fetch11, fetchFract.x), fetchFract.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    vec2 textureRes = min (vec2 (800.0, 450.0), iChannelResolution[0].xy);\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 eye = vec3 (0.0, 0.0, -iTime);\n    vec3 look = normalize (vec3 (0.0, 0.0, -1.0));\n    \n    vec3 side = normalize (cross (vec3 (cos(iTime * 0.1), sin(iTime * 0.1), 0.0), look));\n    vec3 up = cross (side, look);\n    if ( dot (up, vec3 (cos(iTime * 0.1), sin(iTime * 0.1), 0.0)) < 0.0 ) up = -up;\n    \n    vec3 sampleDir = normalize (look + side * uv.x + up * uv.y);\n    vec3 samplePt = eye + sampleDir;\n    vec3 colorAccum = vec3 (0.0);\n\n    samplePt = eye + sampleDir;\n    \n    const float drawDistSq = 10000.0;\n\n    for (float jj = 0.0; jj != 60.0; jj += 1.0)\n    {\n        vec3 samplePtToEye = samplePt - eye;\n        float curDist = scene (samplePt);\n        if (abs(curDist) < 0.01 )\n        {\n\t        vec3 sceneNorm = abs (sceneNorm (samplePt));\n            vec3 colorFetch = vec3 (0.0);\n            if ( sceneNorm.x > 0.75 )\n            \tcolorFetch = fetchTexture (fract (samplePt.yz * 0.15), textureRes).rgb;\n            else if ( sceneNorm.y > 0.75 )\n            \tcolorFetch = fetchTexture (fract (samplePt.xz * 0.15), textureRes).rgb;\n            else\n            \tcolorFetch = fetchTexture (fract (samplePt.xy * 0.15), textureRes).rgb;\n            colorFetch /= max (length (samplePtToEye) * 0.1, 1.0);\n            colorAccum += colorFetch;\n            samplePt += sampleDir * 5.0;\n        }\n        samplePt += curDist*sampleDir;\n        if ( dot (samplePtToEye,samplePtToEye) > drawDistSq )\n            break ;\n    }\n\n    fragColor.rgb = colorAccum;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/***********************************************************\n\n   Deep in the Gibson O.o ...\n   This one is experimenting with self directing agents... had been dying to do something like this.\n   White noise is modified iq noise : https://www.shadertoy.com/view/Msf3WH\n   All your sdf are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\nvec2 hash(float p)\n{\n    p *= 60.0;\n    vec2 p1 = 50.0*fract( vec2 (p)*0.3183099 + vec2(0.71,0.113));\n    vec2 p2 = 60.0*fract( vec2 (p)*0.4140551 + vec2(-0.45,0.51));\n    return vec2 (fract(p1.x*p1.y*(p1.x+p1.y)), fract(p2.x*p2.y*(p2.x+p2.y)));\n}\n\nvec2 hash2(vec2 p)\n{\n    p *= 60.0;\n    vec2 p1 = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    vec2 p2 = 60.0*fract( p*0.4140551 + vec2(-0.45,0.51));\n    return vec2 (fract(p1.x*p1.y*(p1.x+p1.y)), fract(p2.x*p2.y*(p2.x+p2.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool timeToTurn = (iFrame % 40 == 0);\n    vec2 iRes = min (vec2 (800.0, 450.0), iChannelResolution[0].xy);\n    if ( fragCoord.x >= iRes.x || fragCoord.y >= iRes.y ) discard;\n    vec2 uv = fragCoord/iRes.xy;\n    vec2 pixelSize = 1.0/iRes.xy;\n    if ( iFrame == 0 )\n    {\n        float pixelRad = length (pixelSize) * 0.5;\n        fragColor = vec4 (0.0);\n        for (int i = 0; i != 600; i++)\n        {\n            vec2 pixelRand = hash (float(i));\n\t    \tif ( length ( uv - pixelRand ) < pixelRad )\n            {\n                fragColor = vec4 (hash2( pixelRand ), 1.0, 0.0);\n            }\n\t\t}\n    }\n    else\n    {\n        vec4 neighFetch;\n        vec2 uv_minus_x = fragCoord.xy - vec2 (1.0, 0.0);\n        if ( uv_minus_x.x < 0.0 ) uv_minus_x.x = iRes.x - 1.0;\n        neighFetch = texelFetch (iChannel0, ivec2 (uv_minus_x), 0);\n        if ( neighFetch.b == 0.95 && neighFetch.g < 0.25 )\n        {\n            if ( timeToTurn )\n            {\n                float changeOfDir = hash2 (uv + vec2 (iTime * 5.0)).x;\n                neighFetch.g = 0.5 + changeOfDir * 0.5;\n            }            \n            fragColor = vec4 (neighFetch.rg, 1.0, 0.0);\n            return ;\n        }\n        vec2 uv_plus_x = fragCoord.xy + vec2 (1.0, 0.0);\n        if ( uv_plus_x.x > iRes.x - 1.0 ) uv_plus_x.x = 0.0;\n        neighFetch = texelFetch (iChannel0, ivec2 (uv_plus_x), 0);\n        if ( neighFetch.b == 0.95 && neighFetch.g >= 0.25 && neighFetch.g < 0.5 )\n        {\n            if ( timeToTurn )\n            {\n                float changeOfDir = hash2 (uv + vec2 (iTime * 5.0)).x;\n                neighFetch.g = 0.5 + changeOfDir * 0.5;\n            }\n            fragColor = vec4 (neighFetch.rg, 1.0, 0.0);\n            return ;\n        }\n        vec2 uv_minus_y = fragCoord.xy - vec2 (0.0, 1.0);\n        if ( uv_minus_y.y < 0.0 ) uv_minus_y.y = iRes.y - 1.0;\n        neighFetch = texelFetch (iChannel0, ivec2 (uv_minus_y), 0);\n        if ( neighFetch.b == 0.95 && neighFetch.g >= 0.5 && neighFetch.g < 0.75 )\n        {\n            if ( timeToTurn )\n            {\n                float changeOfDir = hash2 (uv + vec2 (iTime * 5.0)).x;\n                neighFetch.g = changeOfDir * 0.5;\n            }\n            fragColor = vec4 (neighFetch.rg, 1.0, 0.0);\n            return ;\n        }\n        vec2 uv_plus_y = fragCoord.xy + vec2 (0.0, 1.0);\n        if ( uv_plus_y.y > iRes.y - 1.0 ) uv_plus_y.y = 0.0;\n        neighFetch = texelFetch (iChannel0, ivec2 (uv_plus_y), 0);\n        if ( neighFetch.b == 0.95 && neighFetch.g >= 0.75 )\n        {\n            if ( timeToTurn )\n            {\n                float changeOfDir = hash2 (uv + vec2 (iTime * 5.0)).x;\n                neighFetch.g = changeOfDir * 0.5;\n            }\n            fragColor = vec4 (neighFetch.rg, 1.0, 0.0);\n            return ;\n        }\n\n        vec4 prevFetch = texelFetch (iChannel0, ivec2 (fragCoord.xy), 0);\n        prevFetch.b *= 0.95;\n        if ( prevFetch.b < 0.05 ) prevFetch = vec4 (0.0);\n        fragColor = prevFetch;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/***********************************************************\n\n   Deep in the Gibson O.o ...\n   This one is experimenting with self directing agents... had been dying to do something like this.\n   White noise is modified iq noise : https://www.shadertoy.com/view/Msf3WH\n   All your sdf are belong to iq ;) : https://iquilezles.org/articles/distfunctions\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n\nvec4 readImage(ivec2 uv, ivec2 screenRes)\n{\n    if ( uv.x < 0 ) uv.x = screenRes.x - 1;\n    else if ( uv.x > screenRes.x - 1) uv.x = 0;\n\n    if ( uv.y < 0 ) uv.y = screenRes.y - 1;\n    else if ( uv.y > screenRes.y - 1) uv.y = 0;\n\n    vec4 mapRead = texelFetch (iChannel0, uv, 0);\n    \n    if ( mapRead.x < 0.5 )\n    {\n        return vec4 (0.0, mapRead.b * 0.5, mapRead.b, 1.0);\n    }\n    else\n    {\n        return vec4 (mapRead.b, mapRead.b * 0.5, mapRead.b, 1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iRes = min (ivec2 (800, 450), ivec2 (iChannelResolution[0].xy));\n    if ( int(fragCoord.x) >= iRes.x || int(fragCoord.y) >= iRes.y ) discard;\n    vec4 centRead = readImage (ivec2 (fragCoord), iRes);\n    vec4 totalRead = vec4 (0.0);\n    for (int i = -2; i != 3; i++)\n        for (int j = -2; j != 3; j++)\n            totalRead += readImage (ivec2 (fragCoord) + ivec2 (i, j), iRes);\n    fragColor = centRead + totalRead * 0.13;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfBRS.jpg", "access": "api", "license": "mit", "functions": [[1801, 1801, 1822, 1822, 1976], [1978, 1978, 2008, 2008, 2099], [2101, 2101, 2148, 2148, 2211], [2213, 2213, 2234, 2234, 2538], [2540, 2540, 2565, 2565, 2922], [2924, 2924, 2975, 2975, 3496], [3498, 3498, 3555, 3555, 5204]], "test": "untested"}
{"id": "WtffzS", "name": "Necker Cube 2", "author": "dr2", "description": "Another dynamic generalization of the Necker Cube (mouse restores sanity)", "tags": ["illusion", "paradox"], "likes": 5, "viewed": 309, "published": 3, "date": "1596968188", "time_retrieved": "2024-07-30T20:51:45.203633", "image_code": "// \"Necker Cube 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\n\nvec4 sLen;\nvec3 ltDir, vuDir;\nfloat tCur, dstFar, eWid;\nbool isBg, doFg;\nconst float pi = 3.1415927;\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  if (isBg) {\n    dMin = min (dMin, PrCapsDf ((abs (p) - sLen.wyz).yzx, eWid, sLen.x));\n    dMin = min (dMin, PrCapsDf ((abs (p) - sLen.xwz).xzy, eWid, sLen.y));\n    dMin = min (dMin, PrCapsDf ((abs (p) - sLen.xyw), eWid, sLen.z));\n  } else {\n    dMin = min (dMin, PrCylDf ((p - (sLen.xwz - 10. * vuDir)).xzy, eWid, sLen.y - eWid));\n    dMin = min (dMin, PrCylDf ((p - (sLen.xyw * vec3 (1., -1., 1.) - 10. * vuDir)), eWid, sLen.z - eWid));\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, col, vn;\n  vec2 s;\n  float dstObj, dstObjF, nDotL;\n  sLen = vec4 (vec3 (3., 2., 4.), 0.);\n  eWid = 0.3;\n  isBg = true;\n  roo = ro;\n  col = vec3 (0.61, 0.6, 0.6);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = (Minv3 (max (abs (ro) - sLen.xyz + eWid, 0.)) > 0.) ?\n       vec4 (0.9, 0.9, 1., 0.3) : vec4 (0., 0.9, 0.6, 0.2);\n    if (doFg) {\n      isBg = false;\n      ro = roo;\n      dstObjF = ObjRay (ro, rd);\n      if (dstObjF < dstObj) {\n        ro += dstObjF * rd;\n        vn = ObjNf (ro);\n        col4 = vec4 (0., 0.9, 0.6, 0.2);\n      }\n    }\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.3 + 0.7 * nDotL * nDotL) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, col, vx, vy;\n  vec2 canvas, uv, uvv, mSize, fgLim;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  az = 0.3 * pi - 0.05 * pi * sin (0.1 * pi * tCur);\n  el = -0.07 * pi - 0.02 * pi * cos (0.1 * pi * tCur);\n  ro = vec3 (0., 0., -12.);\n  ro.yz = Rot2D (ro.yz, - el);\n  ro.xz = Rot2D (ro.xz, - az);\n  vuDir = normalize (- ro);\n  mSize = vec2 (0.7, 0.5);\n  fgLim = abs (uv) - mSize;\n  doFg = (max (fgLim.x, fgLim.y) < 0.);\n  if (mPtr.z > 0.) doFg = false;\n  vx = normalize (vec3 (vuDir.z, 0., - vuDir.x));\n  vy = vec3 (0., 1., 0.) - vuDir.y * vuDir;\n  zmFac = 0.22;\n  dstFar = 40.;\n  ltDir = normalize (vec3 (-1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    col += (1. / naa) * ShowScene (ro + vec3 (uvv.x * vx + uvv.y * vy) / zmFac, vuDir);\n  }\n  uv *= vec2 (canvas.y / canvas.x, 1.);\n  uv *= uv;\n  uv *= uv;\n  col *= 1. - 0.3 * smoothstep (0.5, 1., dot (uv, uv));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtffzS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[361, 361, 383, 383, 875], [877, 877, 910, 910, 1087], [1089, 1089, 1110, 1110, 1360], [1362, 1362, 1397, 1397, 2226], [2270, 2270, 2326, 2326, 3640], [3642, 3642, 3684, 3684, 3735], [3737, 3737, 3780, 3780, 3844], [3846, 3846, 3868, 3868, 3906], [3908, 3908, 3938, 3938, 4051]], "test": "untested"}
{"id": "3sVXRR", "name": "2D clouds experiment", "author": "Zombye", "description": "Started on this quite a while ago but never got around to actually finishing it.\nWanted a good approximation of volumetric clouds for cases where those would be too expensive or simply unnecessary.\nThere's definitely a lot of room for improvement.", "tags": ["clouds"], "likes": 13, "viewed": 1203, "published": 3, "date": "1596966831", "time_retrieved": "2024-07-30T20:51:46.001499", "image_code": "const float fieldOfView = 60.0;\n\nconst float lightAngle = 70.0;\n\nconst uint raySteps = 10u;\nconst uint noiseIterations = 7u;\n\nconst float cloudsFrequency = 1.0;\nconst float cloudsThickness = 0.15;\nconst float cloudsAltitude = 1.0;\n\nfloat GetCloudNoise(vec2 position, float e0) {\n    position *= cloudsFrequency;\n    position /= iChannelResolution[0].xy;\n    float noise = 0.0, weightSum = 0.0;\n    for (uint i = 0u; i < noiseIterations; ++i) {\n        float iterationWeight = exp2(-float(i));\n        vec2 noisePosition = position * exp2(float(i)) + 0.1 * iTime / iChannelResolution[0].xy;\n        noise += texture(iChannel0, noisePosition).r * iterationWeight;\n        weightSum += iterationWeight;\n    } noise /= weightSum;\n    return smoothstep(e0, 1.0, noise);\n}\n\nvoid PlanarClouds(\n    vec3 viewPosition,\n    vec3 viewDirection,\n    vec3 lightDirection,\n    float rand,\n    out float scattering,\n    out float transmittance\n) {\n    scattering = 0.0;\n    transmittance = 1.0;\n    \n    //--// Find current point on cloud\n    \n    float tPlane = (cloudsAltitude - viewPosition.z) / viewDirection.z;\n    if (tPlane < 0.0) { return; }\n    vec2 cloudPosition = viewPosition.xy + viewDirection.xy * tPlane;\n    \n    //--// Set up self-shadowing raymarch\n    \n    float rayLength3D = cloudsThickness / lightDirection.z;\n    vec3 rayVector3D = rayLength3D * lightDirection;\n    \n    vec2 rayStep  = lightDirection.xy * cloudsThickness / lightDirection.z;\n         rayStep -= viewDirection.xy  * cloudsThickness / viewDirection.z;\n         rayStep /= float(raySteps);\n    vec2 rayPosition = cloudPosition + rayStep * rand;\n    \n    //--// Self-shadowing raymarch\n    \n    float e0 = 0.5 / (0.5 * cloudsThickness / (cloudsAltitude * viewDirection.z) + (1.0 - 0.5 * cloudsThickness / cloudsAltitude));\n    \n    float lightOpticalDepth = 0.0;\n    for (uint i = 0u; i < raySteps; ++i, rayPosition += rayStep) {\n        float cloudNoise = GetCloudNoise(rayPosition, e0);\n        lightOpticalDepth += max(cloudNoise, 0.0);\n    }\n    lightOpticalDepth *= 4.0 * cloudsFrequency / cloudsThickness * rayLength3D / float(raySteps);\n    \n    float cloudNoise = GetCloudNoise(cloudPosition, e0);\n    float cloudOpticalDepth = 4.0 * cloudsFrequency * cloudNoise / abs(viewDirection.z);\n        \n    transmittance = exp(-cloudOpticalDepth);\n    scattering = exp(-lightOpticalDepth) * (1.0 - transmittance);\n}\n\nmat3 GetRotationMatrix(vec3 unitAxis, float angle) {\n\tfloat cosine = cos(angle);\n\n\tvec3 axis = unitAxis * sin(angle);\n\tvec3 tmp = unitAxis - unitAxis * cosine;\n\n\treturn mat3(\n\t\tunitAxis.x * tmp.x + cosine, unitAxis.x * tmp.y - axis.z, unitAxis.x * tmp.z + axis.y,\n\t\tunitAxis.y * tmp.x + axis.z, unitAxis.y * tmp.y + cosine, unitAxis.y * tmp.z - axis.x,\n\t\tunitAxis.z * tmp.x - axis.y, unitAxis.z * tmp.y + axis.x, unitAxis.z * tmp.z + cosine\n\t);\n}\nvec3 LinearToSrgb(vec3 color) {\n\treturn mix(1.055 * pow(color, vec3(1.0 / 2.4)) - 0.055, color * 12.92, step(color, vec3(0.0031308)));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float zrot =  radians(360.0) * iMouse.x / iResolution.x;\n    float xrot = -radians(90.0) * ((iMouse.x + iMouse.y) < 1.5 ? 0.2 : (iMouse.y / iResolution.y)) - radians(90.0);\n    mat3 viewRot = GetRotationMatrix(vec3(0.0, 0.0, 1.0), zrot)\n                 * GetRotationMatrix(vec3(1.0, 0.0, 0.0), xrot);\n    vec3 viewDirection;\n    viewDirection.xy = (2.0 * fragCoord - iResolution.xy) * tan(radians(fieldOfView) / 2.0) / iResolution.y;\n    viewDirection.z = -1.0;\n    viewDirection = viewRot * normalize(viewDirection);\n    vec3 viewPosition = vec3(0.0);\n    \n    vec3 lightDirection = vec3(vec2(cos(iTime + 2.0), sin(iTime + 2.0)) * sin(radians(lightAngle)), cos(radians(lightAngle)));\n    \n    // sky\n    const vec3 rlHor = vec3(0.3, 0.4, 0.5), rlUp = vec3(0.1, 0.2, 0.4);\n    const vec3 mieHor = vec3(0.2), mieUp = vec3(0.05);\n    float phaseRl = pow(dot(viewDirection, lightDirection), 2.0) * 0.5 + 1.0;\n    float phaseMie = pow((dot(viewDirection, lightDirection) + 1.0) * 0.55, 16.0) * 0.5 + 1.0;\n    fragColor.rgb  = phaseRl * mix(rlUp, rlHor, pow(1.0 - max(viewDirection.z, 0.0), 4.0));\n    fragColor.rgb += phaseMie * mix(mieUp, mieHor, pow(1.0 - max(viewDirection.z, 0.0), 4.0));\n    \n    // clouds\n    vec2 noise = texture(iChannel0, fragCoord / iChannelResolution[0].xy).xy;\n    \n    float cloudsScattering; float cloudsTransmittance;\n    PlanarClouds(viewPosition, viewDirection, lightDirection, noise.x, cloudsScattering, cloudsTransmittance);\n    \n    // fade distant clouds\n    cloudsScattering *= exp(-0.05 / abs(viewDirection.z));\n    cloudsTransmittance = mix(1.0, cloudsTransmittance, exp(-0.05 / abs(viewDirection.z)));\n    \n    fragColor.rgb = fragColor.rgb * cloudsTransmittance + phaseMie * cloudsScattering;\n    \n    // basic tonemap\n    fragColor.rgb *= inversesqrt(fragColor.rgb * fragColor.rgb + 1.0);\n    \n    // convert to srgb & dither\n    fragColor.rgb = LinearToSrgb(fragColor.rgb);\n    fragColor.rgb += (noise.x - noise.y) / 255.0;\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVXRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 278, 278, 766], [768, 768, 932, 932, 2388], [2390, 2390, 2442, 2442, 2836], [2837, 2837, 2868, 2868, 2973], [2974, 2974, 3029, 3029, 5023]], "test": "untested"}
{"id": "3tXBRS", "name": "P.Gerdes & Tchokwe sand drawing2", "author": "FabriceNeyret2", "description": "colored variant of [url]https://shadertoy.com/view/wtsfWM[/url]\n\nReference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]\n", "tags": ["tiles", "short", "truchets", "ethnomathematics"], "likes": 9, "viewed": 311, "published": 3, "date": "1596949670", "time_retrieved": "2024-07-30T20:51:46.776428", "image_code": "// colored variant of https://shadertoy.com/view/wtsfWM\n\n#define S(v) smoothstep( 9./R.y , 0. , v )          // AA draw\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(1);\n    mat2 M = mat2(1,-1,1,1);                        // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / R.y + iTime,\n         I = floor( U * M ),                        // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414, f;       // quad center to edge domain\n    \n    O -= .3* S( length(F) - .1 );                   // dots\n\n    float r = fract(4e4*sin(I.y + 10.*I.x +99.));   // rand( edge id )\n    r < .5\n      ?  f = S( abs( F = abs(F) - .35 ) -.01 ),     //  X at edge\n         O -= f.x + f.y,                            //    line\n         f = S(F), O.gb -= .3 - .3* abs(f.x-f.y)    //    area\n      :(                                            // )( at edge\n         O -= S( abs( r = length(F) - .35 ) -.01 ), //    line\n         O.gb -= .3*S(r) );                         //    area\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 159, 159, 1010]], "test": "untested"}
{"id": "tlsfD7", "name": "brick to leaf", "author": "3SvBop3F", "description": "brick texture deformed to look live leaves", "tags": ["leaf", "brick", "bricks", "leaves"], "likes": 2, "viewed": 308, "published": 3, "date": "1596944233", "time_retrieved": "2024-07-30T20:51:47.549361", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // regular uv\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    // square, centered uv\n    float max_res_dim = max(iResolution.x, iResolution.y);\n    vec2 uvsq_offset = (1.-(iResolution.xy/max_res_dim))/2.;\n\n    vec2 uvsq = (        // special case screen-is-uv-but-square-uv-space\n        gl_FragCoord.xy  // width/height\n        / max_res_dim    // of max width/height\n    ) + uvsq_offset;     // plus half the w/h margin\n\t\t\t\t\t     // is centered\n    \n    uv = uvsq;\n    \n    \n    uv = abs((uv * 2.) - 1.); // mao 0_1 to n1_0_1\n\n\t// petal-like deform\n    uv.x = pow(uv.x, uv.y);\n    uv.y = pow(uv.y, uv.x);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(\n        texture(iChannel0, uv) * vec4(col, 1.0)\n    );\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 79, 871]], "test": "untested"}
{"id": "wtsBD7", "name": "jagged uv step", "author": "3SvBop3F", "description": "none", "tags": ["jagged", "stair"], "likes": 1, "viewed": 273, "published": 3, "date": "1596940151", "time_retrieved": "2024-07-30T20:51:48.322294", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // regular uv\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    // square, centered uv\n    float max_res_dim = max(iResolution.x, iResolution.y);\n    vec2 uvsq_offset = (1.-(iResolution.xy/max_res_dim))/2.;\n\n    vec2 uvsq = (        // special case screen-is-uv-but-square-uv-space\n        gl_FragCoord.xy  // width/height\n        / max_res_dim    // of max width/height\n    ) + uvsq_offset;     // plus half the w/h margin\n\t\t\t\t\t     // is centered\n    \n    //uv = uvsq;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = mix(\n        vec4(col, 1.),\n        vec4(vec3(1.) - (col*0.5), 1.),\n               \n        float(\n            (uv.y)*10.>(round((-uv.x+1.-0.06)*10.) + 0.5)\n       )\n               \n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 79, 861]], "test": "untested"}
{"id": "wlsfW7", "name": "for my website", "author": "nisargpatel", "description": "Cool gradient shader for my website", "tags": ["gradient"], "likes": 4, "viewed": 434, "published": 3, "date": "1596930268", "time_retrieved": "2024-07-30T20:51:49.082263", "image_code": "#define POINTS 32 // try between 2 and 256, gets slow fast\n#define PI 3.1415926536\n#define TAU (2.0 * PI)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float bias = 0.0001;\n    float power = 15.0;\n    // mouse x controls bias, mouse y controls power\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n    bias = iMouse.z <= 0.0 ? bias : pow(10.0, (-0.5 + mouse.x) * 10.0);\n\tpower = iMouse.z <= 0.0 ? power : 0.5 + mouse.y * 9.5;\n    \n    float cN = 0.0;\n    // array used to store contributions in first loop\n    float contribution[POINTS];\n    \n    for (int i = 0; i < POINTS; i++)\n    {\n        float f = float(i) / float(POINTS) * TAU;\n\t    vec2 pos = 0.5 + 0.35 * vec2(cos(iTime * 1.0 + f), sin(iTime * 0.8*4.0 + f * 2.0));\n\t\tpos = uv - pos;\n        float dist = length(pos);\n        // calculate contribution\n    \tfloat c = 1.0 / (bias + pow(dist, power));\n        contribution[i] = c;\n        // sum total contribution\n        cN += c;\n    }\n    \n    // normalize contributions and weigh colors\n    vec3 col = vec3(0, 0, 0);\n    cN = 1.0 / cN;\n    for (int i = 0; i < POINTS; i++)\n    {\n        float f = float(i) / float(POINTS) * TAU + iTime * 0.1;\n\t    vec3 pcol = 0.5 + 0.5 * cos(vec3(f * 2.0, f, f * 4.0));\n        col += contribution[i] * cN * pcol;\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsfW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 164, 164, 1353]], "test": "untested"}
{"id": "wtsfDM", "name": "The Weatherman", "author": "nlight", "description": "The weatherman is hard at work (also has bad handwriting). Press 1, 2 or 3 to change the weather.", "tags": ["raymarching", "sdf"], "likes": 36, "viewed": 756, "published": 3, "date": "1596923547", "time_retrieved": "2024-07-30T20:51:50.220220", "image_code": "// Copyright 2020 Alexander Dzhoganov\n//\n// MIT License\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n// and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\n *\n * Just another raymarched SDF that I spent way too much time on.\n * Press 1, 2 or 3 to change the weather.\n *\n * List of features:\n * \n * - Approximate line-segment lights\n * - Physically-based metallic/roughness materials\n * - Glossy reflections\n * - Procedural volumetric clouds\n * - Soft-shadows\n * - Ambient occlusion\n * - Temporal AA\n *\n * Some of the lighting math is probably wrong. I have included references and links to papers\n * and articles so if you are trying to reimplement something in your own renderer it'd be prudent to double check there.\n * The code is mostly well-commented but even where it isn't I have tried to keep it as clean and readable as possible.\n * Some things have been butchered to keep compile times down and might be hard to parse, apologies for that :(\n *\n * Thanks to everyone making so much cool stuff and publishing it for us all to learn from.\n * A lot of ideas and code have been borrowed from other shaders on this site and it has been\n * immensely helpful. Special thanks to Inigo Quilez for all the articles and code.\n * \n * Incomplete list of techniques used in making this:\n *\n * - Cook-Torrance lighting model\n * Joey de Vries, https://learnopengl.com/PBR/Theory\n *\n * - SDFs for various shapes by Inigo Quilez\n * https://iquilezles.org/articles/distfunctions\n * https://www.shadertoy.com/view/Xds3zN\n *\n * - SDF soft-shadows by Inigo Quilez\n * https://iquilezles.org/articles/rmshadows\n * https://www.shadertoy.com/view/lsKcDD\n *\n * - Ambient occlusion by Inigo Quilez\n * https://www.shadertoy.com/view/XttSz2\n *\n * - Tetrahedron normals technique by Inigo Quilez\n * https://iquilezles.org/articles/normalsSDF\n *\n * - Real-time line-segment lights\n * https://www.elopezr.com/rendering-line-lights/\n * https://www.shadertoy.com/view/tl2GD3\n *\n * - Procedural volumetric clouds\n * Haggstrom 2018, \"Real-time rendering of volumetric clouds\"\n * http://www.diva-portal.org/smash/get/diva2:1223894/FULLTEXT01.pdf\n *\n * - Temporal anti-aliasing\n * Lei Yang, Shiqiu Liu, Marco Salvi 2020, \"A Survey of Temporal Antialiasing\n * Techniques\" - http://behindthepixels.io/assets/files/TemporalAA.pdf\n *\n * More links and references in the code comments.\n * All the code is under the MIT license unless explicitly specified otherwise in the comments.\n * \n */\n\n// The code below just does the final HDR to LDR tonemapping.\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n  color = aces(color);\n  color = pow(color, vec3(1.0 / 2.2));\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#ifndef saturate\n#define saturate(X) clamp(X, 0.0, 1.0)\n#endif\n\n// Hack to prevent loop unrolling.\n#define ZERO float(min(0, iFrame))\n#define UZERO uint(min(0, iFrame))\n\n// Various noise functions\n//\n// Simplex noise from https://github.com/ashima/webgl-noise\n// Copyright © 2011 Ashima Arts\n//\n// Worley noise from https://github.com/Erkaman/glsl-worley\n// Copyright © Stefan Gustavson\n//\n// Value noise with gradients from https://www.shadertoy.com/view/XdXBRH\n// Copyright © 2017 Inigo Quilez\n//\n// All noise functions are licensed under the MIT License\n//\n\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\nfloat hash(float n) { return fract(sin(n) * 753.5453123); }\nvec2 hash(vec2 x) {\n  const vec2 k = vec2(0.3183099, 0.3678794);\n  x = x * k + k.yx;\n  return -1.0 + 2.0 * fract(16.0 * k * fract(x.x * x.y * (x.x + x.y)));\n}\nvec2 hash22(vec2 p) {\n  p = mod(p, 5.0);\n  float n = sin(dot(p, vec2(41.0, 289.0)));\n  return fract(vec2(8.0, 1.0) * 262144.0 * n);\n}\n\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626,\n                      0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod289(i);\n  vec3 p =\n      permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(\n      0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i);\n  vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +\n                           vec4(0.0, i1.y, i2.y, 1.0)) +\n                   i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  // Normalise gradients\n  vec4 norm =\n      taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m =\n      max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return 42.0 *\n         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n\n// 2D value noise with derivatives\n// https://iquilezles.org/articles/gradientnoise\nvec3 noised(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n\n  vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n  vec2 du = 30.0 * f * f * (f * (f - 2.0) + 1.0);\n\n  vec2 ga = hash(i + vec2(0.0, 0.0));\n  vec2 gb = hash(i + vec2(1.0, 0.0));\n  vec2 gc = hash(i + vec2(0.0, 1.0));\n  vec2 gd = hash(i + vec2(1.0, 1.0));\n\n  float va = dot(ga, f - vec2(0.0, 0.0));\n  float vb = dot(gb, f - vec2(1.0, 0.0));\n  float vc = dot(gc, f - vec2(0.0, 1.0));\n  float vd = dot(gd, f - vec2(1.0, 1.0));\n\n  return vec3(va + u.x * (vb - va) + u.y * (vc - va) +\n                  u.x * u.y * (va - vb - vc + vd), // value\n              ga + u.x * (gb - ga) + u.y * (gc - ga) +\n                  u.x * u.y * (ga - gb - gc + gd) + // derivatives\n                  du * (u.yx * (va - vb - vc + vd) + vec2(vb, vc) - va));\n}\n\nfloat fbm(vec2 p, uint octaves) {\n  float a = 1.0;\n  float n = 0.0;\n  for (uint i = 0u; i < octaves; i++) {\n    n += snoise(p) * a;\n    p *= 2.0;\n    a *= 0.5;\n  }\n\n  return n;\n}\n\nfloat fbm(vec3 p, uint octaves) {\n  float a = 1.0;\n  float n = 0.0;\n  for (uint i = 0u; i < octaves; i++) {\n    n += snoise(p) * a;\n    p *= 2.0;\n    a *= 0.5;\n  }\n\n  return n;\n}\n\nfloat worley(vec2 P) {\n  const float K = 0.142857142857;\n  const float K2 = 0.0714285714285;\n  const float jitter = 0.8;\n  vec2 Pi = mod289(floor(P));\n  vec2 Pf = fract(P);\n  vec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n  vec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n  vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n  p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n  vec4 ox = mod(p, 7.0) * K + K2;\n  vec4 oy = mod(floor(p * K), 7.0) * K + K2;\n  vec4 dx = Pfx + jitter * ox;\n  vec4 dy = Pfy + jitter * oy;\n  vec4 d = dx * dx + dy * dy;\n  d.xy = (d.x < d.y) ? d.xy : d.yx;\n  d.xz = (d.x < d.z) ? d.xz : d.zx;\n  d.xw = (d.x < d.w) ? d.xw : d.wx;\n  d.y = min(d.y, d.z);\n  d.y = min(d.y, d.w);\n  return sqrt(d.xy).x;\n}\n\nvec3 worley_dist(vec3 x, vec3 y, vec3 z) { return x * x + y * y + z * z; }\n\nfloat worley(vec3 P) {\n  const float jitter = 0.8;\n  float K = 0.142857142857;     // 1/7\n  float Ko = 0.428571428571;    // 1/2-K/2\n  float K2 = 0.020408163265306; // 1/(7*7)\n  float Kz = 0.166666666667;    // 1/6\n  float Kzo = 0.416666666667;   // 1/2-1/6*2\n\n  vec3 Pi = mod(floor(P), 289.0);\n  vec3 Pf = fract(P) - 0.5;\n\n  vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n  vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n  vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n  vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n  vec3 p1 = permute(p + Pi.y - 1.0);\n  vec3 p2 = permute(p + Pi.y);\n  vec3 p3 = permute(p + Pi.y + 1.0);\n\n  vec3 p11 = permute(p1 + Pi.z - 1.0);\n  vec3 p12 = permute(p1 + Pi.z);\n  vec3 p13 = permute(p1 + Pi.z + 1.0);\n\n  vec3 p21 = permute(p2 + Pi.z - 1.0);\n  vec3 p22 = permute(p2 + Pi.z);\n  vec3 p23 = permute(p2 + Pi.z + 1.0);\n\n  vec3 p31 = permute(p3 + Pi.z - 1.0);\n  vec3 p32 = permute(p3 + Pi.z);\n  vec3 p33 = permute(p3 + Pi.z + 1.0);\n\n  vec3 ox11 = fract(p11 * K) - Ko;\n  vec3 oy11 = mod(floor(p11 * K), 7.0) * K - Ko;\n  vec3 oz11 = floor(p11 * K2) * Kz - Kzo; // p11 < 289 guaranteed\n\n  vec3 ox12 = fract(p12 * K) - Ko;\n  vec3 oy12 = mod(floor(p12 * K), 7.0) * K - Ko;\n  vec3 oz12 = floor(p12 * K2) * Kz - Kzo;\n\n  vec3 ox13 = fract(p13 * K) - Ko;\n  vec3 oy13 = mod(floor(p13 * K), 7.0) * K - Ko;\n  vec3 oz13 = floor(p13 * K2) * Kz - Kzo;\n\n  vec3 ox21 = fract(p21 * K) - Ko;\n  vec3 oy21 = mod(floor(p21 * K), 7.0) * K - Ko;\n  vec3 oz21 = floor(p21 * K2) * Kz - Kzo;\n\n  vec3 ox22 = fract(p22 * K) - Ko;\n  vec3 oy22 = mod(floor(p22 * K), 7.0) * K - Ko;\n  vec3 oz22 = floor(p22 * K2) * Kz - Kzo;\n\n  vec3 ox23 = fract(p23 * K) - Ko;\n  vec3 oy23 = mod(floor(p23 * K), 7.0) * K - Ko;\n  vec3 oz23 = floor(p23 * K2) * Kz - Kzo;\n\n  vec3 ox31 = fract(p31 * K) - Ko;\n  vec3 oy31 = mod(floor(p31 * K), 7.0) * K - Ko;\n  vec3 oz31 = floor(p31 * K2) * Kz - Kzo;\n\n  vec3 ox32 = fract(p32 * K) - Ko;\n  vec3 oy32 = mod(floor(p32 * K), 7.0) * K - Ko;\n  vec3 oz32 = floor(p32 * K2) * Kz - Kzo;\n\n  vec3 ox33 = fract(p33 * K) - Ko;\n  vec3 oy33 = mod(floor(p33 * K), 7.0) * K - Ko;\n  vec3 oz33 = floor(p33 * K2) * Kz - Kzo;\n\n  vec3 dx11 = Pfx + jitter * ox11;\n  vec3 dy11 = Pfy.x + jitter * oy11;\n  vec3 dz11 = Pfz.x + jitter * oz11;\n\n  vec3 dx12 = Pfx + jitter * ox12;\n  vec3 dy12 = Pfy.x + jitter * oy12;\n  vec3 dz12 = Pfz.y + jitter * oz12;\n\n  vec3 dx13 = Pfx + jitter * ox13;\n  vec3 dy13 = Pfy.x + jitter * oy13;\n  vec3 dz13 = Pfz.z + jitter * oz13;\n\n  vec3 dx21 = Pfx + jitter * ox21;\n  vec3 dy21 = Pfy.y + jitter * oy21;\n  vec3 dz21 = Pfz.x + jitter * oz21;\n\n  vec3 dx22 = Pfx + jitter * ox22;\n  vec3 dy22 = Pfy.y + jitter * oy22;\n  vec3 dz22 = Pfz.y + jitter * oz22;\n\n  vec3 dx23 = Pfx + jitter * ox23;\n  vec3 dy23 = Pfy.y + jitter * oy23;\n  vec3 dz23 = Pfz.z + jitter * oz23;\n\n  vec3 dx31 = Pfx + jitter * ox31;\n  vec3 dy31 = Pfy.z + jitter * oy31;\n  vec3 dz31 = Pfz.x + jitter * oz31;\n\n  vec3 dx32 = Pfx + jitter * ox32;\n  vec3 dy32 = Pfy.z + jitter * oy32;\n  vec3 dz32 = Pfz.y + jitter * oz32;\n\n  vec3 dx33 = Pfx + jitter * ox33;\n  vec3 dy33 = Pfy.z + jitter * oy33;\n  vec3 dz33 = Pfz.z + jitter * oz33;\n\n  vec3 d11 = worley_dist(dx11, dy11, dz11);\n  vec3 d12 = worley_dist(dx12, dy12, dz12);\n  vec3 d13 = worley_dist(dx13, dy13, dz13);\n  vec3 d21 = worley_dist(dx21, dy21, dz21);\n  vec3 d22 = worley_dist(dx22, dy22, dz22);\n  vec3 d23 = worley_dist(dx23, dy23, dz23);\n  vec3 d31 = worley_dist(dx31, dy31, dz31);\n  vec3 d32 = worley_dist(dx32, dy32, dz32);\n  vec3 d33 = worley_dist(dx33, dy33, dz33);\n\n  vec3 d1a = min(d11, d12);\n  d12 = max(d11, d12);\n  d11 = min(d1a, d13); // Smallest now not in d12 or d13\n  d13 = max(d1a, d13);\n  d12 = min(d12, d13); // 2nd smallest now not in d13\n  vec3 d2a = min(d21, d22);\n  d22 = max(d21, d22);\n  d21 = min(d2a, d23); // Smallest now not in d22 or d23\n  d23 = max(d2a, d23);\n  d22 = min(d22, d23); // 2nd smallest now not in d23\n  vec3 d3a = min(d31, d32);\n  d32 = max(d31, d32);\n  d31 = min(d3a, d33); // Smallest now not in d32 or d33\n  d33 = max(d3a, d33);\n  d32 = min(d32, d33); // 2nd smallest now not in d33\n  vec3 da = min(d11, d21);\n  d21 = max(d11, d21);\n  d11 = min(da, d31); // Smallest now in d11\n  d31 = max(da, d31); // 2nd smallest now not in d31\n  d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n  d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n  d12 = min(d12, d21);                        // 2nd smallest now not in d21\n  d12 = min(d12, d22);                        // nor in d22\n  d12 = min(d12, d31);                        // nor in d31\n  d12 = min(d12, d32);                        // nor in d32\n  d11.yz = min(d11.yz, d12.xy);               // nor in d12.yz\n  d11.y = min(d11.y, d12.z);                  // Only two more to go\n  d11.y = min(d11.y, d11.z);                  // Done! (Phew!)\n  return sqrt(d11.x);                         // F1\n}\n\nfloat fbm_worley(vec3 p, uint octaves) {\n  float a = 1.0;\n  float n = 0.0;\n  for (uint i = 0u; i < octaves; i++) {\n    n += worley(p) * a;\n    p *= 2.0;\n    a *= 0.5;\n  }\n\n  return n;\n}\n\n// Hybrid multi-fractal noise from Musgrave, \"Procedural Fractal Terrains\"\n// https://www.classes.cs.uchicago.edu/archive/2015/fall/23700-1/final-project/MusgraveTerrain00.pdf\nfloat hmf(vec2 p, uint iters) {\n  const float ex[6] =\n      float[6](0.803851, 0.6461764, 0.5194296, 0.4175439, 0.3356431, 0.2698071);\n  float n = 1.0;\n  float w = n;\n\n  for (uint i = 0u; i < iters; i++) {\n    p *= 1.95;\n    w *= (1.0 - abs(snoise(p))) * ex[i];\n    n += w;\n  }\n\n  return n;\n}\n\n// Ray-AABB intersection test\nvec2 intersectRayBox(vec3 ro, vec3 rd, vec3 bmin, vec3 bmax) {\n  vec3 tMin = (bmin - ro) / rd;\n  vec3 tMax = (bmax - ro) / rd;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\n// Point-AABB intersection test\nfloat pointInsideBox(vec3 p, vec3 bmin, vec3 bmax) {\n  vec3 s = step(bmin, p) - step(bmax, p);\n  return s.x * s.y * s.z;\n}\n\n// Generate points on a hemisphere\n// i is the index of the current point\n// n is the total number of points\nvec3 forwardSF(float i, float n) {\n  const float PI = 3.141592653589793238;\n  const float PHI = 1.618033988749894848;\n  float phi = 2.0 * PI * fract(i / PHI);\n  float zi = 1.0 - (2.0 * i + 1.0) / n;\n  float sinTheta = sqrt(1.0 - zi * zi);\n  return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, zi);\n}\n\n// Remaps value V from range L0-H0 to range LN-HN\nfloat remap(float v, float l0, float h0, float ln, float hn) {\n  return ln + (v - l0) * (hn - ln) / (h0 - l0);\n}\n\n// Unpacks a 4-component vector of floats in range [0..1] from a 32-bit uint.\n// Can use unpackUnorm4x8() instead if available.\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/unpackUnorm.xhtml\nvec4 unpackUint4x8(uint x) {\n  return vec4(uvec4(x, x >> 8, x >> 16, x >> 24) & 0xFFu) / 255.0;\n}\n\n// Packs a 4-component vector of floats in range [0..1] into a 32-bit uint.\n// Can use packUnorm4x8() instead if available.\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/unpackUnorm.xhtml\nuint packUint4x8(vec4 v) {\n  uint x = 0u;\n  v = saturate(v) * 255.0;\n  x |= uint(v.x);\n  x |= uint(v.y) << 8;\n  x |= uint(v.z) << 16;\n  x |= uint(v.w) << 24;\n  return x;\n}\n\n//\n// Various 2D and 3D SDF modelling functions from\n// https://iquilezles.org/articles/distfunctions\n// https://iquilezles.org/articles/distfunctions2d\n// Code and examples at https://www.shadertoy.com/view/Xds3zN\n//\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n//\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat dot2(in vec3 v) { return dot(v, v); }\nfloat ndot(in vec2 a, in vec2 b) { return a.x * b.x - a.y * b.y; }\n\nfloat sdSphere(vec3 p, float s) { return length(p) - s; }\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdBoundingBox(vec3 p, vec3 b, float e) {\n  p = abs(p) - b;\n  vec3 q = abs(p + e) - e;\n  return min(min(length(max(vec3(p.x, q.y, q.z), 0.0)) +\n                     min(max(p.x, max(q.y, q.z)), 0.0),\n                 length(max(vec3(q.x, p.y, q.z), 0.0)) +\n                     min(max(q.x, max(p.y, q.z)), 0.0)),\n             length(max(vec3(q.x, q.y, p.z), 0.0)) +\n                 min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat sdQTorus(vec3 p, vec2 t) {\n  p -= vec3(t.x, 0.0, 0.0);\n  return max(sdBox(p + vec3(t.x, 0.0, t.x), vec3(t.x)), sdTorus(p, t));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n  return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\n}\n\nfloat sdLink(vec3 p, float le, float r1, float r2) {\n  vec3 q = vec3(p.x, max(abs(p.y) - le, 0.0), p.z);\n  return length(vec2(length(q.xy) - r1, q.z)) - r2;\n}\n\nfloat sdCone(in vec3 p, in vec2 c, float h) {\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n  // n must be normalized\n  return dot(p, n) + h;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h) {\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;\n  vec2 d = vec2(length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) *\n                    sign(p.y - h.x),\n                p.z - h.y);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n  vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec3 q = vec3(m * p.xy, p.z);\n  return q;\n}\n\nfloat sdCircle(vec2 p, float r) { return length(p) - r; }\n\nfloat sdBox(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdUnevenCapsule(vec2 p, float r1, float r2, float h) {\n  p.x = abs(p.x);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(p, vec2(-b, a));\n  if (k < 0.0)\n    return length(p) - r1;\n  if (k > a * h)\n    return length(p - vec2(0.0, h)) - r2;\n  return dot(p, vec2(a, b)) - r1;\n}\n\nfloat sdHexagram(in vec2 p, in float r) {\n  const vec4 k = vec4(-0.5, 0.8660254038, 0.5773502692, 1.7320508076);\n  p = abs(p);\n  p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n  p -= 2.0 * min(dot(k.yx, p), 0.0) * k.yx;\n  p -= vec2(clamp(p.x, r * k.z, r * k.w), r);\n  return length(p) * sign(p.y);\n}\n\nfloat sdHexagon(in vec2 p, in float r) {\n  const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n  p = abs(p);\n  p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n  p -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n  return length(p) * sign(p.y);\n}\n\nconst uint handwritingSDF[] = uint[](\n    213760u, 1125122048u, 3u, 286265872u, 4369u, 0u, 286331152u, 273u,\n    1125196304u, 323310932u, 609576530u, 1262352u, 19009536u, 36831232u,\n    148801u, 22508544u, 2454800u, 1982857216u, 37u, 1145259330u, 38028373u,\n    1145185074u, 1413825604u, 78916u, 1985242672u, 898140296u, 1469684085u,\n    3569203u, 342245888u, 628363264u, 2390097u, 22639616u, 4687120u,\n    2555510784u, 268435510u, 2290509940u, 628656264u, 2289325940u, 2290649224u,\n    153720u, 2574686289u, 913868937u, 2326366870u, 39364421u, 647591200u,\n    1201025024u, 21469522u, 22643728u, 39355408u, 2859732992u, 805306695u,\n    2274912150u, 897021815u, 2289396118u, 2004392328u, 158071u, 2054596689u,\n    860111957u, 2843039911u, 628799575u, 917284673u, 1504203264u, 342472786u,\n    22578192u, 57238272u, 2308317184u, 1375732312u, 1147762328u, 1395934260u,\n    1145407879u, 1145411668u, 158068u, 2037815361u, 805306643u, 2806138774u,\n    916244567u, 917289315u, 1790538768u, 915970131u, 22578193u, 343429632u,\n    2006401280u, 1947206249u, 291014009u, 1947205632u, 288786280u, 270964545u,\n    227699u, 2037819457u, 805306371u, 2519811990u, 1487583319u, 917150342u,\n    2055767600u, 1753647172u, 22578195u, 629620736u, 1703502592u, 2251293561u,\n    21468760u, 2251292672u, 3638599u, 2529072u, 293219u, 2054662225u,\n    842211876u, 2537637782u, 2038929495u, 917006504u, 2305201985u, 2305132612u,\n    22578230u, 1201025024u, 1399424289u, 2555450760u, 860194902u, 2287014451u,\n    39351349u, 2529072u, 858028386u, 2305271891u, 1181116006u, 2556643222u,\n    2556794966u, 916997785u, 2287307107u, 2537916485u, 22578264u, 1485115392u,\n    1111988034u, 2036540807u, 2004322661u, 2019767911u, 57173333u, 2528816u,\n    1986431330u, 3110578295u, 1201248665u, 1753634710u, 2537916772u, 915883130u,\n    2538961524u, 1965393990u, 21529977u, 1769144320u, 539330916u, 1485129622u,\n    2290649477u, 2307278728u, 343578760u, 3577376u, 2576984418u, 2842143129u,\n    895907720u, 1184458646u, 1948551523u, 915882584u, 2844297878u, 1377142615u,\n    21530264u, 2019688448u, 268659078u, 1184323717u, 1145395078u, 2006402116u,\n    629765735u, 3642912u, 1449630034u, 2555876950u, 824390726u, 1201166230u,\n    1662286179u, 1184387655u, 2522245015u, 806717272u, 21534870u, 2554396672u,\n    83864u, 1166567539u, 17900935u, 897082129u, 915882803u, 3642912u,\n    574003537u, 2287506722u, 805306405u, 1770342294u, 822376804u, 1721258275u,\n    2233611384u, 269846377u, 21543284u, 2519728128u, 9866u, 1684576338u,\n    286331768u, 39351569u, 1216684032u, 4691489u, 2529361u, 2555938064u,\n    841027877u, 2573420438u, 227686u, 1989693696u, 1929380440u, 2463593u,\n    21538897u, 2501902336u, 5242u, 1950852929u, 1413830009u, 3573300u,\n    1769213952u, 4756770u, 2529345u, 2555937808u, 1716868166u, 2807187350u,\n    223609u, 2543341824u, 1375732039u, 2459512u, 21534256u, 1947205632u, 600u,\n    2234947120u, 2290649241u, 1341271u, 1751318528u, 21529874u, 2529088u,\n    2539156480u, 2290649208u, 2519812246u, 223592u, 2274902272u, 1073741862u,\n    2459511u, 21525520u, 1375731712u, 54u, 1680172320u, 1717986918u, 152918u,\n    1464926208u, 4613138u, 1336624u, 1967547136u, 1432774519u, 1678788197u,\n    153173u, 1717972992u, 536870932u, 1332309u, 3494400u);\n\nfloat sampleHandwriting(uvec2 uvp) {\n  uint index = uvp.x / 8u + uvp.y * 16u;\n  uint mask = handwritingSDF[index];\n  return float((mask >> ((uvp.x & 0x7u) * 4u)) & 0xFu) * (1.0 / 15.0);\n}\n\nfloat handwritingTexture(vec2 uv) {\n  const uvec2 tt = uvec2(1u, 0u);\n  const vec2 size = vec2(127.0, 15.0);\n  const vec2 texelSize = vec2(1.0) / vec2(128.0, 16.0);\n  vec2 f = fract(uv * size);\n  uvec2 uvp = uvec2(abs(mod(uv, 1.0)) * size);\n\n  // bilinear filtering\n  float tl = sampleHandwriting(uvp);\n  float tr = sampleHandwriting(uvp + tt.xy);\n  float bl = sampleHandwriting(uvp + tt.yx);\n  float br = sampleHandwriting(uvp + tt.xx);\n  return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n}\n", "buffer_a_code": "// Generates the terrain heightmap on the first frame and caches it. The\n// heightmap itself is just a combination of different noises. Note the usage of\n// hybrid multi-fractal noise from Musgrave, \"Procedural Fractal\n// Terrains\". You can get the paper from here:\n// https://www.classes.cs.uchicago.edu/archive/2015/fall/23700-1/final-project/MusgraveTerrain00.pdf\n//\n// Also noteworthy is the slight domain distortion of the input UVs. You can\n// find more info about that at https://iquilezles.org/articles/warp\n\n// Because the alpha channel of this is otherwise unused, we use it to store\n// and update some persistent state with keyboard inputs.\n//\n\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n\nbool isKeyPressed(int key) {\n  return texelFetch(iChannel1, ivec2(key, 1), 0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / vec2(textureSize(iChannel0, 0));\n\n  // The code below deals with the persistent state (called global_State in the main code).\n  // The state consists of 4x uint8's packed in a uint and converted to 0..1 floats on read.\n  // The fields are described in the Buffer C shader.\n  vec4 pixel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n  if (all(equal(ivec2(fragCoord), ivec2(0)))) {\n    vec4 state = unpackUint4x8(floatBitsToUint(pixel.a));\n    if (iFrame == 0 || state.z < 0.1 || state.z > 0.7) {\n      state = vec4(0.4, 0.0, 0.4, 0.0);\n    }\n\n    state.xy = saturate(mix(state.xy, state.zw, 0.05));\n    \n    if (isKeyPressed(KEY_1)) {\n      state.zw = vec2(0.15, 0.0);\n    }\n\n    if (isKeyPressed(KEY_2)) {\n      state.zw = vec2(0.45, 0.1);\n    }\n\n    if (isKeyPressed(KEY_3)) {\n      state.zw = vec2(0.7, 1.0);\n    }\n\n    pixel.a = uintBitsToFloat(packUint4x8(state));\n    fragColor = vec4(0.0, 0.0, 0.0, pixel.a);\n    return;\n  }\n\n  // Hack to get the terrain buffer to redraw when the screen is resized.\n  if (dot(iResolution.xy, iResolution.xy) == pixel.a) {\n    fragColor = pixel;\n    return;\n  }\n    \n  // Terrain generation routine\n  // Several hybrid multi-fractal noises combined with some FBMs of Simplex noise\n  // and some Worley noise for good measure.\n  // I haven't tweaked this a lot but the initial results came out ok so eh.\n  uv += 14.0;\n\n  float h = 0.475;\n  uv.x += fbm(uv * 0.5, 5u) * 0.03;\n  uv.y += fbm(uv * 0.5 + vec2(117.0, 19.0), 5u) * 0.02;\n\n  h += hmf(uv * 0.9, 5u) * 0.25;\n  h *= clamp(hmf(uv * 1.1 + vec2(81.0, 63.0), 5u) - 0.5, 0.0, 1.0);\n  h -= (fbm(uv * 3.0, 4u) + 0.15) * 0.1;\n  h -= worley(uv * 4.0) * 0.2;\n  h += (1.0 - abs(fbm(uv * 8.0, 5u))) * 0.05;\n  h += fbm(uv * 48.0, 2u) * 0.01;\n\n  h = h * pow(abs(h), 0.11);\n\n  // free gradients, hooray\n  vec2 grad = vec2(dFdx(h), dFdy(h));\n\n  fragColor = vec4(h, grad, dot(iResolution.xy, iResolution.xy));\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Here we generate the 3D texture used for the clouds. The output buffer is\n// unfortunately 2D so we slice it up and pick the correct slice during\n// sampling. This is not ideal as we lose on some nice free filtering. In a\n// production renderer the output buffer here would be a 3D texture.\n\n// The generation consists of combining several FBMs of Simplex (or\n// Perlin) and Worley noises and is described by Haggstrom 2018, \"Real-time\n// rendering of volumetric clouds\". You can get the paper from\n// http://www.diva-portal.org/smash/get/diva2:1223894/FULLTEXT01.pdf\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 resolution = min(iResolution.xy, vec2(1024.0));\n\n  float sliceSize = iResolution.x < 500.0 ? 32.0 : 128.0;\n  float numSlices = floor(min(resolution.x, resolution.y) / sliceSize);\n  float totalSlices = numSlices * numSlices;\n\n  vec2 curSlice = floor(fragCoord / sliceSize);\n  if (curSlice.x > numSlices || curSlice.y > numSlices) {\n    return;\n  }\n\n  vec2 curOffset = fract(fragCoord / sliceSize) * sliceSize;\n  curOffset.x -= iTime * 1.5;\n  curOffset.y += sin(iTime * 0.1) * 2.0;\n\n  float curZ = (curSlice.x + curSlice.y * numSlices) / totalSlices;\n\n  vec3 p = vec3(curOffset, curZ * sliceSize * 0.25);\n  if (iResolution.x < 500.0) {\n    p *= 4.0;\n  }\n    \n  float s = (fbm(p * 0.025, 4u) + 1.0);\n  float w = 1.0 - fbm_worley(p * 0.025, 4u);\n\n  float n1 = saturate((s + w) * 0.5);\n  float n2 = saturate(1.0 - fbm_worley(p * 0.1, 3u) + 0.5);\n  float n3 = saturate(1.0 - fbm_worley(p * 0.2, 3u) + 0.5);\n  float n4 = saturate(1.0 - fbm_worley(p * 0.4, 3u) + 0.5);\n  fragColor = vec4(n1, n2, n3, n4);\n}\n", "buffer_b_inputs": [], "buffer_c_code": "#define ENABLE_CLOUDS 1\n#define ENABLE_SHADOWS 1\n#define ENABLE_AMBIENT_OCCLUSION 1\n#define ENABLE_REFLECTIONS 1\n\n#define DEBUG 0 // Set to 1 to enable the debug visualization.\n\n// Only one of these can be active at a time.\n#define DEBUG_ALBEDO 0\n#define DEBUG_NORMALS 1\n#define DEBUG_MATERIALS 0\n\n/*\n * Shading and lighting calculations\n */\n\n// The code below implements the Cook-Torrance microfacet\n// lighting model for line-segment lights.\n// Most of the implementation is taken from from Joey de Vries's excellent\n// https://learnopengl.com/PBR/Theory so check it out for the full explanation.\n// The line-segment lights are borrowed from:\n// https://www.elopezr.com/rendering-line-lights/\n//\n// All lighting calculations are in world space.\n\n// This struct stores the necessary information to light a non-reflective\n// surface. The fields are purposefully laid out in a packed 128-bit order.\n// No field should cross a 16 byte boundary otherwise the compiler will either need to\n// emit extra code for each access or add padding between the fields and waste cache space.\nstruct SurfaceData {\n  vec3 albedo;     // surface albedo RGB (diffuse color)\n  float metallic;  // metallic factor\n  vec3 position;   // world-space position\n  float roughness; // roughness factor\n  vec3 normal;     // world-space normal\n  float emissive;  // emissive intensity (multiplied by the albedo)\n  vec3 viewDir;    // normalized world-space view direction\n};\n\n// Additional data needed for lighting reflective surfaces\nstruct ReflectiveSurfaceData {\n  vec3 f0;         // reflectance at normal incidence (fresnel coefficient)\n  float roughness; // extra roughness value for calculating reflections\n  float strength;  // reflection strength\n};\n\n// This struct describes a single light source.\n// In our case the lights are geometrically represented as lines so we store\n// the start and end points instead of a single position.\n// If castShadows is false then the light won't be considered for shadowing\n// calculations. While physically incorrect this allows us to use extra lights\n// to fake environment illumination.\nstruct LightData {\n  vec3 start;       // world-space start of the line segment\n  vec3 end;         // world-space end of the line segment\n  vec3 color;       // light color\n  float intensity;  // light intensity\n  bool castShadows; // whether the light casts shadows\n};\n\n// The parameters of all the lights in the scene\nconst LightData SCENE_LIGHTS[] =\n    LightData[](LightData(vec3(-5.75, 3.65, 1.0),  // line-segment start\n                          vec3(-3.0, 3.65, -1.25), // line-segment end\n                          vec3(1.0),               // color\n                          30.0,                   // intensity\n                          true                     // cast shadows?\n                          ),\n                LightData(vec3(-8.0, 6.0, 12.0), // line-segment start\n                          vec3(8.0, 6.0, 12.0),  // line-segment end\n                          vec3(1.0),             // color\n                          30.0,                  // intensity\n                          false                  // cast shadows?\n                          ),\n                LightData(vec3(8.0, 5.0, -6.0), // line-segment start\n                          vec3(8.0, 5.0, 6.0),  // line-segment end\n                          vec3(1.0),            // color\n                          20.0,                 // intensity\n                          false                 // cast shadows?\n                          ));\n\n// The camera parameters\nconst vec3 CAMERA_POSITION = vec3(4.0, 9.5, 22.0);\nconst vec3 CAMERA_LOOK_AT = vec3(-3.1, 0.25, 0.0);\nconst float CAMERA_FOV = 37.0;\n\n// The AABB of the cloud volume\nconst vec3 CLOUDS_MIN = vec3(-2.0, 0.0, -2.0);\nconst vec3 CLOUDS_MAX = vec3(2.0, 3.0, 2.0);\n\nconst float PI = 3.14159265359;\n\n// Shlick's approximation of the fresnel term (the ratio between specular and\n// diffuse reflection).\n// cosTheta is the angle between the view direction and the light direction.\n// f0 is the surface reflectance at normal (zero degree) incidence.\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nvec3 fresnelSchlick(float cosTheta, vec3 f0) {\n  return f0 + (1.0 - f0) * pow(max(0.0, 1.0 - cosTheta), 5.0);\n}\n\n// The math behind the next three functions is described in \"Microfacet Models\n// for Refraction through Rough Surfaces\".\n// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf.\n\n// Trowbridge-Reitz/GGX normal distribution function\nfloat distributionGgx(vec3 n, vec3 h, float roughness) {\n  float a = roughness * roughness;\n  float a2 = a * a;\n  float ndoth = max(dot(n, h), 0.0);\n  float ndothSq = ndoth * ndoth;\n\n  float num = a2;\n  float denom = (ndothSq * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n  return num / denom;\n}\n\nfloat geomSchlickGgx(float ndotv, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r * r) / 8.0;\n  float num = ndotv;\n  float denom = ndotv * (1.0 - k) + k;\n  return num / denom;\n}\n\nfloat geomSmith(vec3 n, vec3 v, vec3 l, float roughness) {\n  float ndotv = max(dot(n, v), 0.0);\n  float ndotl = max(dot(n, l), 0.0);\n  float ggx2 = geomSchlickGgx(ndotv, roughness);\n  float ggx1 = geomSchlickGgx(ndotl, roughness);\n  return ggx1 * ggx2;\n}\n\n// Calculates the most representative diffuse point for a line-segment light\n// given a world position.\nvec3 diffuseMRP(vec3 p, vec3 lineStart, vec3 lineEnd) {\n  float a = length(lineStart - p);\n  float b = length(lineEnd - p);\n  float t = saturate(a / (b + a));\n  return lineStart + (lineEnd - lineStart) * t;\n}\n\n// Calculates the most represenative specular point for a line-segment light\n// given a world position and the reflection vector between the view direction\n// and surface normal.\nvec3 specularMRP(vec3 p, vec3 lineStart, vec3 lineEnd, vec3 r) {\n  vec3 pa = lineStart - p;\n  vec3 ab = lineEnd - lineStart;\n\n  float t_num = dot(r, pa) * dot(ab, r) - dot(ab, pa);\n  float t_denom = dot(ab, ab) - dot(ab, r) * dot(ab, r);\n  float t = saturate(t_num / t_denom);\n  return lineStart + ab * t;\n}\n\n// Physically correct inverse-square falloff\n// https://en.wikipedia.org/wiki/Inverse-square_law\nfloat invSqFalloff(vec3 p, vec3 lightPos) {\n  vec3 d = lightPos - p;\n  return 1.0 / dot(d, d);\n}\n\n// Calculates the direct illumination on a surface by a single line-segment\n// light according to the Cook-Torrance model.\n// https://learnopengl.com/PBR/Theory does a great job of explaining this\n// function line by line so I won't bother. One noteworthy difference is the\n// almost trivial change to use approximate line-segment lights instead of point lights.\nvec3 light(const SurfaceData surf, const LightData lightData) {\n  vec3 f0 = vec3(0.04);\n  f0 = mix(f0, surf.albedo, surf.metallic);\n\n  vec3 specMRP = specularMRP(surf.position, lightData.start, lightData.end,\n                             reflect(surf.viewDir, surf.normal));\n\n  vec3 l = normalize(specMRP - surf.position);\n  vec3 h = normalize(surf.viewDir + l);\n  vec3 f = fresnelSchlick(max(dot(h, surf.viewDir), 0.0), f0);\n  float ndf = distributionGgx(surf.normal, h, surf.roughness);\n  float g = geomSmith(surf.normal, surf.viewDir, l, surf.roughness);\n  vec3 num = ndf * g * f;\n  float ndotv = max(dot(surf.normal, surf.viewDir), 0.0);\n  float denom = 4.0 * ndotv * max(dot(surf.normal, l), 0.0);\n  vec3 specular = num / max(1e-10, denom);\n\n  vec3 kS = f;\n  vec3 kD = vec3(1.0) - kS;\n  kD *= 1.0 - surf.metallic;\n\n  vec3 diffMRP = diffuseMRP(surf.position, lightData.start, lightData.end);\n\n  float ndotl = max(dot(surf.normal, normalize(diffMRP - surf.position)), 0.0);\n  vec3 radiance = lightData.color * lightData.intensity * ndotl;\n\n  vec3 color =\n      (kD * surf.albedo / PI) * radiance * invSqFalloff(surf.position, diffMRP);\n  color += specular * radiance * invSqFalloff(surf.position, specMRP);\n  return color;\n}\n\n// Stores the persistent global state.\n// x - current cloud coverage\n// y - current cloud density\n// z - target cloud coverage\n// w - target cloud density\nvec4 global_State;\n\n// Procedural clouds based on Haggstrom 2018, \"Real-time rendering of volumetric\n// clouds\". You can get the paper from\n// http://www.diva-portal.org/smash/get/diva2:1223894/FULLTEXT01.pdf\n\n// Sample the 3D clouds texture which is actually a 2D texture so we have to do\n// some math on each sample and we lose out on filtering. Unfortunate.\nvec4 cloudsTexture(vec3 p) {\n  float sliceSize = iResolution.x < 500.0 ? 32.0 : 128.0;\n  vec2 texSize = vec2(textureSize(iChannel2, 0));\n  float numSlices = floor(min(1024.0, min(texSize.x, texSize.y)) / sliceSize);\n  float sliceIndex = floor(p.y * (numSlices * numSlices));\n  float sliceY = floor(sliceIndex / numSlices);\n  float sliceX = floor(sliceIndex - sliceY * numSlices);\n  vec2 uv = (vec2(sliceX, sliceY) + p.xz) * (sliceSize / texSize);\n  return texelFetch(iChannel2, ivec2(uv * texSize), 0);\n}\n\n// Shape-altering height-function from the paper\nfloat cloudsHeight(float ph, float gc) {\n  const float stopHeight = 1.12;\n\n  float height = saturate(remap(ph, 0.0, 0.07, 0.0, 1.0));\n  height *= saturate(remap(ph, stopHeight * 0.2, stopHeight, 1.0, 0.0));\n  height = pow(height, saturate(remap(ph, 0.65, 0.95, 1.0, (1.0 - 0.25 * gc))));\n  return height;\n}\n\n// Density-altering height-function from the paper\nfloat cloudsDensity(float ph) {\n  float density = ph;\n  density *= saturate(remap(ph, 0.0, 0.2, 0.0, 1.0));\n  density *= 32.0;\n  density *= mix(1.0, saturate(remap(pow(ph, 0.5), 0.4, 0.95, 1.0, 0.2)), 0.25);\n  density *= saturate(remap(ph, 0.9, 1.0, 1.0, 0.0));\n  return density;\n}\n\n// Returns the density of the clouds volume at point P as a vec2 (sigmaS, sigmaE).\nvec2 sampleClouds(vec3 p) {\n  // Transform p to \"cloud space\" [0..1] in all directions\n  p -= CLOUDS_MIN;\n  p /= CLOUDS_MAX - CLOUDS_MIN;\n\n  // Sample the clouds texture.\n  vec4 n = cloudsTexture(p.xzy);\n\n  // Combine the 4 channels into a density value.\n  float sn =\n      remap(n.r, dot(n.gba, vec3(0.625, 0.25, 0.125)) - 1.0, 1.0, 0.0, 1.0);\n\n  // ph is the percentage height in cloud space [0..1]\n  float ph = saturate(p.y * 1.4 - 0.6);\n  float sn2 = sn;\n    \n  // Read the global cloud coverage from the pertsistent state.\n  float gc = global_State.x;\n\n  // Function 11 from the paper\n  sn *= cloudsHeight(ph, gc);\n  float wm = max(0.8, saturate(gc - 0.5) * 2.0);\n  sn = saturate(remap(sn, 1.0 - gc * wm, 1.0, 0.0, 1.0));\n  sn *= cloudsDensity(ph);\n\n  return vec2(sn, max(0.000001, global_State.y * 1.25 + sn));\n}\n\n// Traces a shadow ray through the volume, returns the shadowing amount [0..1].\nfloat traceVolumeShadow(vec3 worldPos, vec3 lightDir, float stepSize) {\n  const float numSteps = 6.0;\n\n  float shadow = 1.0;\n  for (float t = ZERO; t < numSteps; t += 1.0) {\n    worldPos += lightDir * stepSize;\n    shadow *= exp(-sampleClouds(worldPos).y * stepSize);\n  }\n\n  return shadow;\n}\n\n// Rayleight scattering phase function\n// https://en.wikipedia.org/wiki/Rayleigh_scattering\nfloat rayleighScattering(vec3 inDir, vec3 outDir) {\n  float cosAngle = dot(inDir, outDir) / (length(inDir) * length(outDir));\n  float nom = 3.0f * (1.0f + cosAngle * cosAngle);\n  float denom = 16.0f * 3.141592f;\n  return nom / denom;\n}\n\n// Traces a ray through the volume and returns computed scattering and extinction.\n// Scattering is a combination of in- and out-scattering where the\n// out-scattering is computed iteratively by calling traceVolumeShadow() at each step,\n// the in-scattering is simulated via a phase function. I've chosen to only add Rayleigh scattering\n// as it's cheap to compute. Check the paper for a more sophisticated scattering algorithm.\nvec4 traceVolume(vec3 ro, vec3 rd, float maxDist, const LightData lightData,\n                 float jitter) {\n  const uint numSteps = 32u;\n  // Multiply the light intensity by this value as an artistic choice,\n  // otherwise the clouds look too dark for the scene lighting.\n   \n  const float intensityMultiplier = 4.0;\n  float stepSize = maxDist / float(numSteps);\n\n  // Extinction factor. Start from one and decrease it at each step by \n  // a function of the computed cloud density at that position.\n  float extinction = 1.0;\n  vec3 scattering = vec3(0.0);\n  rd *= stepSize;\n    \n  // Add some jitter to smooth out discretization artifacts.\n  // If numSteps is high enough this probably won't be necessary.\n  ro += rd * jitter;\n\n  for (uint t = UZERO; t < numSteps; t++) {\n    vec2 density = sampleClouds(ro);\n\n    if (density.x > 0.001) {\n      // Compute the most representative point on the line-segment\n      // to use as the light position.\n      vec3 lightPos = diffuseMRP(ro, lightData.start, lightData.end);\n        \n      // Compute the light direction.\n      vec3 lightDir = normalize(lightPos - ro);\n\n      float e = exp(-density.y * stepSize);\n\n      // S is the scattering contribution for the current step\n      vec3 S = lightData.color * lightData.intensity * intensityMultiplier;\n        \n      // Multiply by the current density.\n      S *= density.x;\n        \n      // Apply light falloff.\n      S *= invSqFalloff(ro, lightPos);\n        \n      // Compute in-scattering.\n      S *= rayleighScattering(-lightDir, -rd);\n        \n      // Compute out-scattering.\n      S *= traceVolumeShadow(ro, lightDir, 0.1);\n        \n      // Final scattering calculation.\n      S = (S - S * e) / density.y;\n\n      // Add to total scattering scaled by the current extinction.\n      scattering += extinction * S;\n      \n      // Scale the current extinction by the computed extinction for this step.\n      extinction *= e;\n    }\n\n    // Optimization to skip some steps if the extinction gets too low.\n    if (extinction < 0.001) {\n      break;\n    }\n\n    ro += rd;\n  }\n\n  // Artistic choice to multiply the scattering by a constant tint color.\n  scattering *= vec3(1.2, 1.2, 1.25) * 0.92;\n  return vec4(scattering, max(0.0, extinction));\n}\n\n// SDF and material definitions\n\n#define MISSING_MATERIAL 0u\n#define BOX_MATERIAL 1u\n#define COFFEE_CUP_MATERIAL 2u\n#define PAPER_MATERIAL 3u\n#define PENCIL_BODY_A_MATERIAL 4u\n#define PENCIL_BODY_B_MATERIAL 5u\n#define PENCIL_TIP_MATERIAL 6u\n#define LAMP_MATERIAL 7u\n#define LAMP_EMISSIVE_MATERIAL 8u\n#define FLOOR_MATERIAL 9u\n#define WALL_A_MATERIAL 10u\n#define WALL_B_MATERIAL 11u\n#define CRT_DEVICE_MATERIAL 12u\n#define CRT_SCREEN_MATERIAL 13u\n#define TERRAIN_MATERIAL 14u\n#define TERRAIN_WATER_MATERIAL 15u\n#define BUTTONS_BODY_MATERIAL 16u\n#define BUTTONS_1_MATERIAL 17u\n#define BUTTONS_2_MATERIAL 18u\n#define BUTTONS_3_MATERIAL 19u\n\nvoid sdCup(vec3 p, inout float minT, inout uint materialId) {\n  // coffee cup - made up of a rounded cylinder subtracted by another smaller\n  // rounded cylinder and a deformed capped torus for the handle\n  vec3 pCup =\n      mat3(-0.65364, 0.0, -0.75680, 0.0, 1.00, 0.0, 0.75680, 0.0, -0.65364) *\n      (p + vec3(5.75, -1.0, -4.25));\n  float tmp = sdRoundedCylinder(pCup, 0.4, 0.05, 0.95);\n\n  if (tmp > 4.0) {\n    return;\n  }\n\n  vec3 pCloud =\n      mat3(1.0, 0.0, 0.0, 0.0, 0.0008, 1.0, 0.0, -1.0, 0.0008) *\n      opBend(mat3(1.0, 0.0, 0.0, 0.0, 0.0008, -1.0, 0.0, 1.0, 0.0008) *\n                 (pCup + vec3(0.0, 0.0, 0.92)),\n             0.6);\n  const float c = 0.3;\n  const vec3 l = vec3(0.0, 2.0, 0.0);\n\n  if (tmp < 0.01) {\n    tmp = max(\n        tmp,\n        -max(sdPlane(pCloud, vec3(0.0, 0.0, 1.0), -0.13),\n             min(sdBox(pCloud + vec3(0.0, -0.04, 0.1), vec3(0.4, 0.15, 0.3)),\n                 min(sdSphere(pCloud + vec3(0.1, -0.275, 0.05), 0.265),\n                     min(sdSphere(pCloud + vec3(-0.16, -0.26, 0.05), 0.25),\n                         min(sdSphere(pCloud + vec3(-0.325, -0.06, 0.05), 0.25),\n                             sdSphere(pCloud + vec3(0.325, -0.06, 0.05),\n                                      0.25)))))));\n\n    tmp = min(\n        tmp, max(-sdPlane(pCloud, vec3(0.0, 0.0, 1.0), -0.12),\n                 min(sdBox(opBend(pCloud + vec3(0.0, -0.025, -0.15), 4.0),\n                           vec3(0.12, 0.015, 0.05)),\n                     min(sdSphere(pCloud + vec3(0.16, -0.2, -0.15), 0.045),\n                         sdSphere(pCloud + vec3(-0.16, -0.2, -0.15), 0.045)))));\n  }\n\n  tmp = opSmoothSubtraction(\n      sdRoundedCylinder(pCup + vec3(0.0, -0.05, 0.0), 0.37, 0.025, 0.925), tmp,\n      0.05);\n\n  tmp = opSmoothUnion(\n      tmp,\n      sdCappedTorus(\n          mat3(0.0008, 1.0, 0.0, -1.0, 0.0008, 0.0, 0.0, 0.0, 1.0) *\n              (vec3(1.0, 1.25, 1.0) *\n               ((pCup - clamp(pCup, -0.09, 0.08) + vec3(-0.65, -0.05, 0.0)))),\n          vec2(0.95, 0.05), 0.65, 0.05),\n      0.1);\n  if (tmp < minT) {\n    materialId = COFFEE_CUP_MATERIAL;\n    minT = tmp;\n  }\n}\n\nvoid sdPencil(vec3 p, inout float minT, inout uint materialId) {\n  // pencil - a hex prism and a cone, a smaller slightly offset cone is used\n  // for the smaller metallic part of the tip\n  vec3 pPencil =\n      mat3(0.0707, 0.0, 0.9975, 0.0, 1.0, 0.0, -0.9975, 0.0, 0.0707) *\n      (p + vec3(3.25, 0.043 - 0.0925, -5.98));\n  float tmp = sdHexPrism(pPencil, vec2(0.04, 1.25));\n\n  if (tmp > 0.2) {\n    return;\n  }\n\n  if (tmp < minT) {\n    materialId = PENCIL_BODY_A_MATERIAL;\n    minT = tmp;\n  }\n\n  pPencil = (mat3(1.0, 0.0, 0.0, 0.0, 0.0707, -0.9975, 0.0, 0.9975, 0.0707) *\n             mat3(0.0008, 0.0, -1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0008)) *\n            (p + vec3(4.71, 0.025 - 0.0925, -5.89));\n  tmp = min(tmp, sdCone(pPencil, vec2(0.39, 1.95), 0.22));\n  tmp = max(tmp, sdPlane(pPencil, normalize(vec3(1.0, 1.0, 0.0)), 0.03));\n  if (tmp < minT) {\n    minT = tmp;\n    materialId = PENCIL_BODY_B_MATERIAL;\n  }\n\n  tmp = min(tmp, sdCone(pPencil, vec2(0.39, 1.95), 0.1) - 0.0000001);\n  tmp = max(tmp, sdPlane(pPencil, normalize(vec3(1.0, 1.0, 0.0)), 0.03));\n  if (tmp < minT) {\n    minT = tmp;\n    materialId = PENCIL_TIP_MATERIAL;\n  }\n}\n\nvoid sdLamp(vec3 p, inout float minT, inout uint materialId, bool shadowRay) {\n  // lamp - several 1/4ths of a torus connected by 90 degree flips\n\n  if (distance(p, vec3(-6.0, 2.0, 0.0)) > 6.0) {\n    return;\n  }\n\n  vec3 pLamp = mat3(0.7648, 0.0, 0.6442, 0.0, 1.0, 0.0, -0.6442, 0.0, 0.7648) *\n               (p + vec3(4.5, 0.0, 0.0));\n\n  const vec3 oo = vec3(1.0, -1.0, 0.0);\n  float tmp =\n      max(sdPlane(pLamp, vec3(0.0, 0.95, 0.0), -0.75),\n          sdLink(oo.yyx * (pLamp + vec3(-0.0025, -1.2, 0.0)), 0.505, 0.6, 0.099));\n  tmp = opSmoothUnion(tmp, sdBox(pLamp, vec3(1.25, 0.125, 1.25)) - 0.025, 0.1);\n\n  const vec2 sz = vec2(1.0, 0.1);\n\n  tmp = min(tmp, sdQTorus(oo.yxy * (pLamp + vec3(0.597, -0.742, 0.0)).zxy, sz));\n  tmp = min(tmp, sdQTorus(oo.yyx * (pLamp + vec3(0.595, -1.74, 1.0)).xyz, sz));\n  tmp = min(tmp, sdQTorus(oo.xyx * (pLamp + vec3(1.55, -1.74, 2.0)).yzx, sz));\n  tmp = min(tmp, sdQTorus(oo.xyy * (pLamp + vec3(2.55, -2.7, 2.0)).zxy, sz));\n  tmp = min(tmp, sdQTorus(oo.yxx * (pLamp + vec3(1.55, -3.7, 0.0)).zyx, sz));\n\n  if (tmp < minT) {\n    materialId = LAMP_MATERIAL;\n    minT = tmp;\n  }\n\n  if (!shadowRay) {\n    tmp = sdCappedCylinder(oo.yxx * (pLamp + vec3(-0.2, -3.7, 0.01)).yxz, 0.1,\n                           1.75) +\n          0.012;\n    if (tmp < minT) {\n      materialId = LAMP_EMISSIVE_MATERIAL;\n      minT = tmp;\n    }\n  }\n}\n\nvoid sdCrtDevice(vec3 p, inout float minT, inout uint materialId) {\n  // crt device\n  vec3 pDevice = p + vec3(10.0, -3.0, 3.0);\n  float tmp = sdBox(pDevice, vec3(3.0, 3.0, 2.0));\n\n  if (tmp > 7.5) {\n    return;\n  }\n\n  tmp = max(-sdBox(pDevice + vec3(0.0, 0.0, -3.3), vec3(2.7)), tmp);\n  if (tmp < minT) {\n    materialId = CRT_DEVICE_MATERIAL;\n    minT = tmp;\n  }\n\n  tmp = min(sdBox(pDevice + vec3(0.0, 0.0, -1.0), vec3(2.3, 2.3, 0.5)) - 0.4,\n            tmp);\n  if (tmp < minT) {\n    materialId = CRT_SCREEN_MATERIAL;\n    minT = tmp;\n  }\n}\n\nvoid sdTerrainBox(vec3 p, inout float minT, inout uint materialId) {\n  const vec3 boxSize = (CLOUDS_MAX - CLOUDS_MIN) * 0.5;\n\n  float tmp = sdBoundingBox(p - vec3(0.0, 1.5, 0.0), boxSize, 0.05);\n  if (tmp < minT) {\n    materialId = BOX_MATERIAL;\n    minT = tmp;\n  }\n}\n\nvoid sdTerrain(vec3 p, inout float minT, inout uint materialId) {\n  // miniature terrain\n  const vec3 cMin = CLOUDS_MIN;\n  const vec3 cMax = CLOUDS_MAX;\n  const vec3 boxSize = (cMax - cMin) * 0.5;\n\n  if (abs(p.x) > 3.5 || abs(p.z) > 3.5) {\n    return;\n  }\n\n  ivec2 uv = ivec2(((p.xz - cMin.xz) / (cMax.xz - cMin.xz)) *\n                   vec2(textureSize(iChannel3, 0)));\n  float tmp = p.y - texelFetch(iChannel3, uv, 0).r;\n\n  tmp =\n      max(tmp, sdBox(p - vec3(0.0, 1.0, 0.0), vec3(boxSize.x, 1.0, boxSize.z)));\n\n  if (tmp < minT) {\n    materialId = TERRAIN_MATERIAL;\n    minT = tmp;\n  }\n\n  tmp = sdBox(p - vec3(0.0, 0.375, 0.0),\n              vec3(boxSize.x - 0.01, 0.3, boxSize.z - 0.01));\n  if (tmp < minT) {\n    materialId = TERRAIN_WATER_MATERIAL;\n    minT = tmp;\n  }\n}\n\nvoid sdRoom(vec3 p, inout float minT, inout uint materialId) {\n  // floor\n  float tmp = sdPlane(p + vec3(0.0, 0.124, 0.0), vec3(0.0, 1.0, 0.0), -0.12);\n\n  // tmp = max(tmp, sdPlane(p, vec3(0.0, 0.0, -1.0), -3.45));\n  if (tmp < minT) {\n    materialId = FLOOR_MATERIAL;\n    minT = tmp;\n  }\n\n  // wall\n  tmp = sdPlane(p, vec3(0.0, 0.0, 1.0), 5.5);\n  if (tmp < minT) {\n    materialId = WALL_B_MATERIAL;\n    minT = opSmoothUnion(tmp, minT, 0.01);\n  }\n\n  tmp = sdBox(p + vec3(0.0, -2.0, 5.15), vec3(20.0, 0.5, 0.05));\n  if (tmp < minT) {\n    materialId = WALL_A_MATERIAL;\n    minT = tmp;\n  }\n}\n\nvoid sdPaper(vec3 p, inout float minT, inout uint materialId) {\n  // paper - just a very thin box\n  vec3 pPaper = mat3(0.7648, 0.0, 0.6442, 0.0, 1.0, 0.0, -0.6442, 0.0, 0.7648) *\n                (p + vec3(3.5, 0.0, -6.0));\n  float tmp = sdBox(pPaper, vec3(2.1, 0.001, 2.97));\n  if (tmp < minT) {\n    materialId = PAPER_MATERIAL;\n    minT = tmp;\n  }\n}\n\nuint getActiveButton() {\n  return global_State.z < 0.2 ? 1u : (global_State.w < 0.1 ? 2u : 3u);\n}\n\nvoid sdButtons(vec3 p, inout float minT, inout uint materialId) {\n  vec3 pButtons =\n      mat3(0.9950, 0.0, -0.0998, 0.0, 1.0000, 0.0, 0.0998, 0.0, 0.9950) *\n      (p + vec3(-0.15, 0.0, -5.0));\n  float tmp = sdBox(pButtons, vec3(1.9, 0.25, 0.65));\n\n  if (tmp > 0.4) {\n    return;\n  }\n\n  if (tmp < minT) {\n    materialId = BUTTONS_BODY_MATERIAL;\n    minT = tmp;\n  }\n\n  uint activeButton = getActiveButton();\n\n  float yOffset = float(activeButton == 1u) * 0.03;\n  tmp = sdRoundBox(pButtons + vec3(1.25, -0.15 + yOffset, 0.0),\n                   vec3(0.45, 0.15, 0.45), 0.035);\n  if (tmp < minT) {\n    materialId = BUTTONS_1_MATERIAL;\n    minT = tmp;\n  }\n\n  yOffset = float(activeButton == 2u) * 0.03;\n  tmp = sdRoundBox(pButtons + vec3(0.0, -0.15 + yOffset, 0.0),\n                   vec3(0.45, 0.15, 0.45), 0.035);\n  if (tmp < minT) {\n    materialId = BUTTONS_2_MATERIAL;\n    minT = tmp;\n  }\n\n  yOffset = float(activeButton == 3u) * 0.03;\n  tmp = sdRoundBox(pButtons + vec3(-1.25, -0.15 + yOffset, 0.0),\n                   vec3(0.45, 0.15, 0.45), 0.035);\n  if (tmp < minT) {\n    materialId = BUTTONS_3_MATERIAL;\n    minT = tmp;\n  }\n}\n\n// The signed distance function representing the static geometry in the scene.\n// Takes a world space position and returns the signed distance to the closest\n// surface as well as its material ID. The shadowRay boolean is a hack\n// to skip the rendering of the rather solid geometry enclosing the light\n// source for shadow rays (or the whole scene will be in shadow).\nfloat sceneSDF(vec3 p, out uint materialId, bool shadowRay) {\n  float minT = 1e7;\n  materialId = MISSING_MATERIAL;\n  sdRoom(p, minT, materialId);\n\n  // A pseudo-kdtree check. Use some hardcoded planes to split the scene so\n  // approximately the same amount of pixels lie on each side of the plane.\n  // The checks have trivial cost compared to calculating the objects\n  // so this is a huge performance win (assuming the compiler actually emits a branch).\n  // Unfortunately, positioning the planes so they don't mess up the distance field\n  // is not straightforward as the problem is both scene and view- dependent.\n  // A more sophisticated approach would somehow account for the split planes in the raymarching algorithm.\n\n  float d = dot(vec4(p, 1.0), vec4(0.0, 0.0, 1.0, -3.1));\n  float d2 = dot(vec4(p, 1.0), vec4(1.0, 0.0, 0.0, 2.5));\n  float d3 = dot(vec4(p, 1.0), vec4(0.0, 1.0, 0.0, -0.5));\n\n  if (d3 < 0.0) {\n    sdPaper(p, minT, materialId);\n\n    if (d > 0.0) {\n      sdPencil(p, minT, materialId);\n      sdButtons(p, minT, materialId);\n    }\n  }\n\n  if (d > 0.0) {\n    if (d2 < 0.0) {\n      sdCup(p, minT, materialId);\n    }\n  } else {\n    if (d2 > 0.0) {\n      sdTerrain(p, minT, materialId);\n    } else {\n      sdLamp(p, minT, materialId, shadowRay);\n      sdCrtDevice(p, minT, materialId);\n    }\n  }\n\n  if (d2 > 0.0) {\n    sdTerrainBox(p, minT, materialId);\n  }\n\n  return minT;\n}\n\n\n// Material definition for the piece of paper\nvoid paperMaterial(inout SurfaceData surfData) {\n  const vec3 paperSize = vec3(2.1, 0.0, 2.97);\n\n  vec3 offset = mat3(0.7648, 0.0, 0.6442, 0.0, 1.0, 0.0, -0.6442, 0.0, 0.7648) *\n                    (surfData.position + vec3(3.5, 0.0, -6.0)) -\n                paperSize * 0.5;\n  // get UVs in the local space of tha paper\n  vec2 uv =\n      vec2(dot(offset, vec3(1.0, 0.0, 0.0)), dot(offset, vec3(0.0, 0.0, 1.0)));\n\n  uv /= paperSize.xz;\n\t\n  // draw the horizontal lines\n  float lines = smoothstep(0.0, 0.01, mod(uv.y, 0.05));\n  surfData.albedo = mix(vec3(0.25, 0.25, 0.8), vec3(1.0), 0.75 + 0.25 * lines);\n\n  uv += vec2(0.75, 1.03);\n  if (uv.y > 0.1) {\n    uv.y -= 0.1;\n  } else {\n    uv.x += 0.1;\n    uv.x *= step(0.185, uv.x);\n    uv.x *= 1.0 - step(0.315, uv.x);\n  }\n\n  uv.y *= 128.0 / 22.0;\n  uv *= 2.0;\n\n  // sample the handwriting texture\n  float sdf = 0.0;\n  if (uv.x > 0.0 && uv.y > 0.0 && uv.x < 1.0 && uv.y < 1.0) {\n    sdf = handwritingTexture(uv);\n    sdf = smoothstep(0.35, 0.65, sdf);\n    sdf = saturate(sdf);\n  }\n\n  surfData.albedo *= 1.0 - sdf;\n  surfData.metallic = mix(0.0, 0.15, sdf);\n  surfData.roughness = mix(0.99, 0.4, sdf);\n}\n\n// The material of the CRT screen\nvoid crtScreenMaterial(inout SurfaceData surfData) {\n  const vec3 deviceOffset = vec3(10.0, -3.0, 3.0);\n\n  vec2 uv = vec2(dot(surfData.position + deviceOffset, vec3(1.0, 0.0, 0.0)),\n                 dot(surfData.position + deviceOffset, vec3(0.0, 1.0, 0.0)));\n\n  const float radius = 6.0;\n  const float angle = 1.75;\n\n  float vignette = 1.0 - sqrt(pow(uv.x, 2.0) + pow(uv.y, 2.0));\n  float d = 0.0;\n\n  float time = iTime * 0.02;\n  uv *= 0.3;\n  uv *= mat2(cos(time), -sin(time), sin(time), cos(time));\n\n  float dist = length(uv);\n  float percent = (radius - dist) / radius;\n  float theta = percent * percent * (angle * 8.0);\n  float s = sin(theta);\n  float c = cos(theta);\n  uv = vec2(dot(uv, vec2(c, -s)), dot(uv, vec2(s, c)));\n  uv += 0.5;\n\n  d += abs(fbm(uv * 2.0, 5u) + 0.7) * (1.0 - smoothstep(0.0, 0.75, dist));\n\n  surfData.albedo = mix(vec3(0.156), vec3(0.0, 1.0, 0.2), saturate(d * 0.8)) *\n                    saturate(vignette + 2.5);\n  surfData.metallic = 0.0;\n  surfData.roughness = 0.01;\n  surfData.emissive = 0.25;\n}\n\n// The miniature terrain material\nvoid terrainMaterial(inout SurfaceData surfData) {\n  float h = max(0.0, surfData.position.y - 0.75);\n\n  vec3 albedo;\n  if (h < 0.5) {\n    albedo = mix(vec3(0.1, 0.2, 0.15), vec3(0.53, 0.64, 0.48),\n                 smoothstep(0.1, 1.0, h * 2.0));\n  } else {\n    albedo = vec3(0.9);\n  }\n\n  surfData.albedo = albedo;\n  surfData.roughness = 0.95;\n}\n\n// Miniature terrain water material\nvoid terrainWaterMaterial(inout SurfaceData surfData) {\n  const vec3 colorA = vec3(0.4, 0.6, 0.86);\n  const vec3 colorB = vec3(0.25, 0.25, 0.55);\n\n  float fresnel =\n      pow((1.0 - saturate(dot(surfData.normal, surfData.viewDir))), 0.3);\n\n  surfData.albedo = mix(colorA, colorB, fresnel);\n\n  if (dot(surfData.normal, vec3(0.0, 1.0, 0.0)) > 0.95) {\n    vec3 n = noised(surfData.position.xz * 36.0 + vec2(iTime * 0.3, 0.0));\n    surfData.normal = normalize(vec3(n.y, 2.0, n.z));\n  }\n\n  surfData.roughness = 0.3;\n}\n\n// The materials of the change weather buttons\nvoid buttonsMaterial(inout SurfaceData surfData, uint buttonId) {\n  bool isActive = buttonId == getActiveButton();\n  vec3 offset =\n      mat3(0.9950, 0.0, -0.0998, 0.0, 1.0000, 0.0, 0.0998, 0.0, 0.9950) *\n      (surfData.position + vec3(-0.15, 0.0, -5.0));\n  offset.x -= buttonId == 1u ? -1.25 : (buttonId == 2u ? 0.0 : 1.25);\n  vec2 uv = vec2(dot(offset, vec3(1.0, 0.0, 0.0)),\n                 dot(offset, vec3(0.0, 0.0, -1.0))) *\n            (1.0 / 0.9);\n\n  // The icons are just 2D SDFs in UV space.\n  float icon = 1e20;\n  if (buttonId == 1u) {\n    icon = max(-sdHexagon(uv, 0.25), sdHexagram(uv, 0.19));\n    icon = min(icon, sdCircle(uv, 0.2));\n  } else {\n    uv += buttonId == 2u ? vec2(-0.1, 0.15) : vec2(0.0, -0.1);\n\n    icon = sdCircle(uv + vec2(0.2, 0.1), 0.1);\n    icon = min(sdCircle(uv + vec2(-0.2, 0.1), 0.1), icon);\n    icon = min(sdCircle(uv + vec2(0.15, -0.05), 0.125), icon);\n    icon = min(sdCircle(uv + vec2(0.0, -0.075), 0.15), icon);\n    icon = min(sdCircle(uv + vec2(-0.15, -0.05), 0.1), icon);\n    icon = min(sdBox(uv + vec2(0.0, 0.1), vec2(0.2, 0.1)), icon);\n\n    if (buttonId == 2u) {\n      uv += vec2(0.15, -0.175);\n      float tmp = max(-sdHexagon(uv, 0.25), sdHexagram(uv, 0.19));\n      tmp = min(tmp, sdCircle(uv, 0.2));\n      icon = min(icon, max(-icon, tmp));\n    } else {\n      icon = min(sdUnevenCapsule(uv + vec2(0.0, 0.45), 0.03, 0.005, 0.1), icon);\n      icon =\n          min(sdUnevenCapsule(uv + vec2(0.15, 0.375), 0.03, 0.005, 0.1), icon);\n      icon =\n          min(sdUnevenCapsule(uv + vec2(-0.15, 0.36), 0.03, 0.005, 0.1), icon);\n    }\n  }\n\n  float darken = pow(1.0 - dot(uv, uv), 1.7);\n  surfData.albedo =\n      mix(vec3(0.35), vec3(0.9), smoothstep(0.0, 0.02, abs(icon))) *\n      saturate(darken + 0.5);\n  surfData.roughness = 0.9;\n  surfData.emissive = isActive ? 0.45 * saturate(darken + 0.25) : 0.0;\n}\n\n// Fills the surface data struct given a material ID.\n// The more complex materials have been moved into their own functions to\n// keep the code cleaner. Note this has no effect on the emitted assembly as\n// function calls don't exist neither does a stack so everything is always\n// inlined by the compiler regardless.\nvoid fillSurfaceData(uint materialId, inout SurfaceData surfData) {\n  switch (materialId) {\n  case MISSING_MATERIAL:\n    surfData.albedo = vec3(1.0, 0.0, 1.0);\n    break;\n  case BOX_MATERIAL:\n    surfData.albedo = vec3(1.0);\n    surfData.roughness = 0.9;\n    break;\n  case COFFEE_CUP_MATERIAL:\n    surfData.albedo = vec3(1.0);\n    surfData.roughness = 0.23;\n    break;\n  case PAPER_MATERIAL:\n    paperMaterial(surfData);\n    break;\n  case PENCIL_BODY_A_MATERIAL:\n    surfData.albedo = vec3(214.0, 148.0, 8.0) / 255.0;\n    surfData.roughness = 0.5;\n    break;\n  case PENCIL_BODY_B_MATERIAL:\n    surfData.albedo = vec3(252.0, 215.0, 163.0) / 255.0;\n    surfData.roughness = 0.9;\n    break;\n  case PENCIL_TIP_MATERIAL:\n    surfData.albedo = vec3(0.25);\n    surfData.metallic = 0.3;\n    surfData.roughness = 0.1;\n    break;\n  case LAMP_MATERIAL:\n    surfData.albedo = vec3(0.955, 0.637, 0.538);\n    surfData.metallic = 0.7;\n    surfData.roughness = 0.65;\n    break;\n  case LAMP_EMISSIVE_MATERIAL:\n    surfData.albedo = SCENE_LIGHTS[0].color;\n    surfData.emissive = SCENE_LIGHTS[0].intensity * 0.05;\n    break;\n  case FLOOR_MATERIAL:\n    surfData.albedo =\n        textureLod(iChannel1, mod(surfData.position.xz * 0.25, 1.0), 0.0).rgb;\n        \n    // albedo from sRGB to linear space\n    surfData.albedo = pow(surfData.albedo, vec3(2.2));\n    surfData.metallic = 0.0;\n    surfData.roughness = 0.5;\n    break;\n  case WALL_A_MATERIAL:\n    surfData.albedo = vec3(1.0);\n    surfData.metallic = 0.3;\n    surfData.roughness = 0.5;\n    break;\n  case WALL_B_MATERIAL:\n    surfData.albedo = vec3(0.5);\n    surfData.metallic = 0.45;\n    surfData.roughness = 0.8;\n    break;\n  case CRT_DEVICE_MATERIAL:\n    surfData.albedo = vec3(0.05);\n    surfData.metallic = 0.75;\n    surfData.roughness = 0.9;\n    break;\n  case BUTTONS_BODY_MATERIAL:\n    surfData.albedo = vec3(1.0);\n    surfData.metallic = 0.0;\n    surfData.roughness = 0.35;\n    break;\n  case CRT_SCREEN_MATERIAL:\n    crtScreenMaterial(surfData);\n    break;\n  case TERRAIN_MATERIAL:\n    terrainMaterial(surfData);\n    break;\n  case TERRAIN_WATER_MATERIAL:\n    terrainWaterMaterial(surfData);\n    break;\n  case BUTTONS_1_MATERIAL:\n  case BUTTONS_2_MATERIAL:\n  case BUTTONS_3_MATERIAL:\n    buttonsMaterial(surfData, materialId - BUTTONS_1_MATERIAL + 1u);\n    break;\n  }\n}\n\n// Fills the ReflectiveSurfaceData for a material with enabled reflections\nvoid fillReflectiveSurfaceData(uint materialId,\n                               inout ReflectiveSurfaceData reflData) {\n  switch (materialId) {\n  default:\n    reflData.strength = 0.0;\n    break;\n  case COFFEE_CUP_MATERIAL:\n    reflData.f0 = vec3(0.01);\n    reflData.roughness = 0.85;\n    reflData.strength = 0.75;\n    break;\n  case CRT_SCREEN_MATERIAL:\n    reflData.f0 = vec3(0.08);\n    reflData.roughness = 0.0;\n    reflData.strength = 0.1;\n    break;\n  }\n}\n\n// Approximates the surface normal at a given world point via the tetrahedron\n// normals technique described in detail here:\n// https://iquilezles.org/articles/normalsSDF\n// Gives comparable results to central differences but it saves us a\n// bunch of calls to sceneSDF(), great!\nvec3 getSceneNormal(vec3 p) {\n  const float h = 0.005;\n\n  uint materialId;\n  vec3 n = vec3(0.0);\n  for (uint i = UZERO; i < 4u; i++) {\n    vec3 e =\n        0.5773 *\n        (2.0 * vec3((((i + 3u) >> 1) & 1u), ((i >> 1) & 1u), (i & 1u)) - 1.0);\n    n += e * sceneSDF(p + e * h, materialId, false);\n  }\n\n  return normalize(n);\n}\n\n// Core raymarching routine. Pretty standard stuff, steps through a ray in\n// world space by sampling the distance field for a fixed number of steps.\n// Returns the distance to the closest surface as well as its material ID.\nfloat traceSceneRay(vec3 ro, vec3 rd, out uint materialId) {\n  const uint numSteps = 48u;\n  const float eps = 0.0002;\n\n  float t = 0.0;\n  for (uint i = UZERO; i < numSteps; i++) {\n    float dist = sceneSDF(ro + rd * t, materialId, false);\n    if (dist < eps) {\n      break;\n    }\n\n    t += dist;\n  }\n\n  return t;\n}\n\n// SDF soft shadows\n// https://iquilezles.org/articles/rmshadows\nfloat traceShadowRay(vec3 worldPos, vec3 normal, vec3 lightPos) {\n  const uint numSteps = 48u;\n  const float bias = 0.002;\n  const float k = 13.0;\n\n  vec3 p = worldPos;\n  p += normal * bias;\n\n  vec3 lightDir = lightPos - worldPos;\n  float ld = length(lightDir);\n  lightDir /= ld;\n\n  uint materialId;\n  float t = 0.0;\n  float ph = 1e20;\n  float shadow = 1.0;\n  for (uint i = UZERO; i < numSteps; i++) {\n    float dist = sceneSDF(p + lightDir * t, materialId, true);\n    float distSq = dist * dist;\n    float y = distSq / (2.0 * ph);\n    float d = sqrt(distSq - y * y);\n\n    shadow = min(shadow, (k * d) / max(0.0, t - y));\n    t += dist;\n    if (shadow < 0.01 || t >= ld) {\n      break;\n    }\n  }\n\n  if (pointInsideBox(worldPos, CLOUDS_MIN, CLOUDS_MAX) != 0.0) {\n    float cloudsShadow = traceVolumeShadow(worldPos, lightDir, 0.25);\n    shadow = min(shadow, cloudsShadow);\n  }\n\n  return max(0.01, shadow);\n}\n\n// Ambient occlusion technique\n// from https://www.shadertoy.com/view/XttSz2\nfloat traceAORay(vec3 worldPos, vec3 normal) {\n  const float numSteps = 16.0;\n  const float k = 0.5;\n  const float b = 0.02;\n  const float n = 6.0;\n  const float m = 3.25;\n\n  uint materialId;\n  float ao = 0.0;\n  for (float i = ZERO; i < numSteps; i += 1.0) {\n    vec3 ap = forwardSF(i, numSteps);\n    float h = hash(i);\n    ap *= sign(dot(ap, normal)) * h * k;\n    float dist = sceneSDF(worldPos + (normal * b + ap), materialId, true);\n    ao += saturate(dist * n);\n  }\n\n  return saturate(ao * (m / numSteps));\n}\n\n#define PRIMARY_PASS 0u\n#define REFLECTIONS_PASS 1u\n#define GLASS_REFLECTIONS_PASS 2u\n\n// This function calculates the color of a pixel given a camera ray.\n// ro and rd are the ray origin and direction in world space.\n// jitter contains two channels of blue noise\nvec3 tracePrimaryRay(vec3 ro, vec3 rd, vec2 jitter) {\n#if ENABLE_CLOUDS\n  SurfaceData cSurfData;\n  vec4 cloudsColor = vec4(0.0, 0.0, 0.0, 1.0);\n  // compute the intersection with the clouds volume\n  vec2 tClouds = intersectRayBox(ro, rd, CLOUDS_MIN, CLOUDS_MAX);\n\n  // if x < y then the ray intersects the AABB\n  if (tClouds.x < tClouds.y) {\n    // world-space intersection point\n    cSurfData.position = ro + rd * tClouds.x;\n\n    // Calculating the normal of a point on an AABB:\n    // https://blog.johnnovak.net/2016/10/22/the-nim-raytracer-project-part-4-calculating-box-normals/\n    cSurfData.normal = normalize(trunc(\n        ((cSurfData.position - ((CLOUDS_MIN + CLOUDS_MAX) * 0.5)) * 1.0001) /\n        ((CLOUDS_MAX - CLOUDS_MIN) * 0.5)));\n\n    cSurfData.viewDir = -rd;\n    cSurfData.roughness = 0.05;\n\n    float maxDist = tClouds.y - tClouds.x;\n    // Trace the ray through the clouds volume to determine the color\n    // which we blend with the background color later.\n    cloudsColor =\n        traceVolume(cSurfData.position, rd, maxDist, SCENE_LIGHTS[0], jitter.x);\n  }\n#endif\n\n  // Temporary storage for the algorithm in the next loop.\n  SurfaceData surfData;\n  ReflectiveSurfaceData reflData;\n  vec3 color = vec3(0.0);\n  float depth = 0.0;\n\n  // The reason the next loop exists is so we don't inline everything three\n  // times for reflection rays. The code might be a little hard to follow\n  // because of this technicality.\n\n  for (uint pass = UZERO; pass < 3u; pass++) {\n    // For the third and final pass we calculate the reflection rays\n    // from the glass surrounding the cloud volume.\n    if (pass == GLASS_REFLECTIONS_PASS) {\n#if ENABLE_CLOUDS\n      if (tClouds.x >= tClouds.y || tClouds.x >= depth) {\n        continue;\n      }\n\n      surfData = cSurfData;\n      rd = reflect(-cSurfData.viewDir, cSurfData.normal);\n      ro = cSurfData.position + rd * 0.001;\n\n      // f0 for glass is around 0.08 according to\n      // https://refractiveindex.info/\n      reflData.f0 = vec3(0.08);\n      reflData.roughness = 0.0;\n      reflData.strength = 0.2;\n#else\n      continue;\n#endif\n    }\n\n    // Trace the ray through the scene and determine the\n    // view-space depth and material ID.\n    uint materialId;\n    float d = traceSceneRay(ro, rd, materialId);\n    if (d > 40.0 || (pass == REFLECTIONS_PASS && reflData.strength == 0.0)) {\n      continue;\n    }\n\n    if (pass == PRIMARY_PASS) {\n      depth = d;\n    }\n\n    // We have the depth so we can calculate the world position and normal.\n    surfData.position = ro + rd * d;\n    surfData.viewDir = -rd;\n    surfData.normal = getSceneNormal(surfData.position);\n\n    // Fill the surface data struct with the material's properties.\n    fillSurfaceData(materialId, surfData);\n\n    // If any debug visualization is on we return here.\n#if DEBUG && DEBUG_ALBEDO\n    return surfData.albedo;\n#endif\n\n#if DEBUG && DEBUG_NORMALS\n    return surfData.normal * 0.5 + 0.5;\n#endif\n\n#if DEBUG && DEBUG_MATERIALS\n    return vec3(surfData.metallic, surfData.roughness, surfData.emissive);\n#endif\n\n    // Compute the light contribution per light and sum all of them.\n    vec3 tmpColor = vec3(0.0);\n\n    for (uint i = UZERO; i < uint(SCENE_LIGHTS.length()); i++) {\n      LightData lightData = SCENE_LIGHTS[i];\n      vec3 lightContrib = light(surfData, lightData);\n\n#if ENABLE_SHADOWS\n      if (pass == PRIMARY_PASS && lightData.castShadows) {\n        lightContrib *= traceShadowRay(surfData.position, surfData.normal,\n                                       (lightData.start + lightData.end) * 0.5);\n      }\n#endif\n\n      tmpColor += lightContrib;\n    }\n\n    // Add the emissive component if any.\n    tmpColor += surfData.albedo * surfData.emissive;\n\n    // If this is the first pass we compute ambient occlusion,\n    // alphablend the final color with the cloud color and\n    // setup the necessary data for the reflections pass\n    // if the material is reflective.\n    // If not we skip to the 3rd pass (glass reflections).\n    if (pass == PRIMARY_PASS) {\n      color += tmpColor;\n\n#if ENABLE_AMBIENT_OCCLUSION\n      float ao = traceAORay(surfData.position, surfData.normal);\n      color *= pow(vec3(ao), vec3(1.0, 1.1, 1.1));\n#endif\n\n#if ENABLE_CLOUDS\n      // If this pixel contains the cloud volume\n      // alphablend its contribution with the scene color.\n      if (tClouds.x < tClouds.y && tClouds.x < d) {\n        color = color * cloudsColor.a + cloudsColor.rgb;\n      }\n#endif\n\n#if ENABLE_REFLECTIONS\n      // Fill the reflection data for this material.\n      fillReflectiveSurfaceData(materialId, reflData);\n        \n      // If the material is not reflective just bail here.\n      if (reflData.strength == 0.0) {\n        continue;\n      }\n\n      // Compute the reflection direction.\n      rd = reflect(-surfData.viewDir, surfData.normal);\n      \n      // Reflection origin with a small bias to save on some very small ray steps.\n      ro = surfData.position + rd * 0.001;\n\n      // Perturb the ray directions for surfaces with glossy reflections.\n      if (reflData.roughness != 0.0) {\n        // Compute basis vectors by crossing the ray direction with an arbitrary vector.\n        vec3 tangent = cross(rd, vec3(0.0, 1.0, 0.0));\n        vec3 binormal = cross(rd, tangent);\n        // offset = random value * roughness\n        vec2 offset = jitter * reflData.roughness * 0.1;\n        // perturb the ray\n        rd += tangent * offset.x + binormal * offset.y;\n        rd = normalize(rd);\n      }\n#endif\n    } else {\n#if ENABLE_REFLECTIONS\n      // Calculate the angle between the surface normal and the view direction.\n      float ndotv = max(0.0, dot(surfData.normal, surfData.viewDir));\n      // Compute fresnel factor based on f0 and angle.\n      vec3 f = fresnelSchlick(ndotv, reflData.f0);\n      // Additively blend the reflection with the current color.\n      color += tmpColor * f * reflData.strength;\n#endif\n    }\n  }\n\n  // Set the pixel to bright magenta if any of the components are NaN so you\n  // can catch mistakes in lighting code quickly. In production code you'd set\n  // the color to something neutral for the scene.\n  if (any(isnan(color))) {\n    color = vec3(1.0, 0.0, 1.0);\n  }\n\n  return color;\n}\n\n// Calculates the ray direction in view space for a pixel given the camera's\n// field of view and the screen size in pixels.\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldOfView) / 2.0);\n  return normalize(vec3(xy, -z));\n}\n\n// Calculates the camera (inverse view) matrix given a target position, the\n// camera position and a reference direction.\nmat3 cameraMatrix(vec3 eye, vec3 center, vec3 up) {\n  // Based on gluLookAt man page\n  vec3 f = normalize(center - eye);\n  vec3 s = normalize(cross(f, up));\n  vec3 u = cross(s, f);\n  return mat3(s, u, -f);\n}\n\n\n// Shader entry point\n// Calculates the ray direction for the current pixel. Calls the primary ray\n// tracing routine and blends the result with the TAA history buffer.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Read the persistent state from 0,0 of the terrain texture.\n  global_State =\n      unpackUint4x8(floatBitsToUint(texelFetch(iChannel3, ivec2(0), 0).a));\n\n  vec2 resolution = iResolution.xy;\n\n  vec2 uv = fragCoord;\n\n  // We do temporal anti-aliasing by jittering the input UVs and\n  // blending the current pixel with its value from history. This gets us\n  // really nice antialiasing for static objects. Due to the nature of the\n  // scene we can get away with not doing any history validation and\n  // reconciliation. Check out this paper for a survey\n  // of more sophisticated techniques for dealing with TAA artifacts:\n  // http://behindthepixels.io/assets/files/TemporalAA.pdf.\n\n#if !DEBUG\n  uv += saturate(texelFetch(iChannel0,\n                            ivec2(uvec2(uv) % 1024u + uvec2(iFrame, 23u) % 64u),\n                            0)\n                     .rg);\n#endif\n\n  // the ray origin is the world space position of the camera\n  vec3 ro = CAMERA_POSITION;\n\n  // get a ray direction in view space based on the current pixel UVs\n  vec3 rd = rayDirection(CAMERA_FOV, resolution.xy, uv);\n\n  // calculate the camera (i.e. inverse view) matrix for this frame\n  mat3 camera =\n      cameraMatrix(CAMERA_POSITION, CAMERA_LOOK_AT, vec3(0.0, 1.0, 0.0));\n\n  // transform the ray direction from view space to world space\n  rd = camera * rd;\n\n  // sample the blue noise texture for jitter values used later on\n  vec2 jitter =\n      texelFetch(iChannel0,\n                 ivec2(uvec2(uv) % 1024u + uvec2(73u, iFrame) % 128u), 0)\n          .rg;\n\n  // trace a ray and output the color for this pixel\n  vec3 color = tracePrimaryRay(ro, rd, jitter);\n  fragColor = vec4(color, 1.0);\n}\n", "buffer_c_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n  vec4 color = texelFetch(iChannel1, ivec2(fragCoord), 0);\n  fragColor = mix(color, prevColor, iFrame == 0 ? 0.0 : 0.97);\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsfDM.jpg", "access": "api", "license": "mit", "functions": [[3483, 3614, 3633, 3633, 3824], [3826, 3826, 3881, 3881, 4040]], "test": "untested"}
{"id": "wtsfWM", "name": "P.Gerdes & Tchokwe sand drawing", "author": "FabriceNeyret2", "description": "reference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]\n\nSee also variants: [url]https://www.shadertoy.com/results?query=Tchokwe[/url]\n", "tags": ["tiles", "short", "reproduction", "truchets", "ethnomathematics"], "likes": 11, "viewed": 364, "published": 3, "date": "1596917115", "time_retrieved": "2024-07-30T20:51:51.044017", "image_code": "// see also variants: https://www.shadertoy.com/results?query=Tchokwe\n\n#define S(v) smoothstep( 9./R.y , 0. , v )          // AA draw\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(1);\n    mat2 M = mat2(1,-1,1,1);                        // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / R.y + iTime,\n         I = floor( U * M ),                        // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414;          // quad center to edge domain\n    \n    O -= S( length(F) - .1 );                       // dots\n\n    float i = I.y + 10.*I.x +99.,                   // edge id (float)\n          r = fract(4e4*sin(i));                    // rand(id)\n    O -= r < .5\n        ? F = S( abs( abs(F) - .35 ) -.01 ),        //  X at edge\n          F.x + F.y \n        : S(  abs( length(F) - .35 ) -.01 );        // )( at edge\n\n // O -= .4*( .5+.5*cos(6.3*r + vec4(0,2,-2,0)) );  // coloring ( debug )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsfWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 173, 173, 937]], "test": "untested"}
{"id": "ttlfWM", "name": "flame_wall", "author": "slackmage", "description": "flame wall", "tags": ["fire"], "likes": 4, "viewed": 347, "published": 3, "date": "1596913035", "time_retrieved": "2024-07-30T20:51:51.805980", "image_code": "float noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(0.1,.5,1.), vec4(.4,-12.,.0,13.));\n\treturn d + (noise(p+vec3(.0,iTime*9.,.2)) + noise(p*0.)*.1)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(400.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.03;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 4.);\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\n\t\n\tfragColor = mix(vec4(0.), col, pow(glow*2.,4.));\n\t//fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlfWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 279], [281, 281, 313, 313, 350], [352, 352, 373, 373, 508], [510, 510, 531, 531, 579], [581, 581, 616, 616, 894], [896, 896, 953, 953, 1404]], "test": "untested"}
{"id": "wlsBWM", "name": "rainbow_storm", "author": "slackmage", "description": "rainbow storm", "tags": ["tunnel"], "likes": 11, "viewed": 386, "published": 3, "date": "1596912968", "time_retrieved": "2024-07-30T20:51:52.575921", "image_code": "// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarialy rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*1.01);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 1.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*3.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.9 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime)*0.5,sin(iTime*1.)*0.,0);\n        \n    float dspAmp = .85;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*2.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsBWM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1132, 1132, 1153, 1153, 1205], [1317, 1317, 1336, 1336, 1353], [1354, 1354, 1406, 1406, 1450], [1490, 1490, 1509, 1509, 1560], [1562, 1562, 1580, 1580, 2107], [2109, 2109, 2160, 2160, 3194], [3196, 3196, 3218, 3218, 3333], [3335, 3408, 3454, 3454, 3800], [3802, 3802, 3859, 3859, 4956]], "test": "untested"}
{"id": "tlsBWM", "name": "oreo_network", "author": "slackmage", "description": "oreo network", "tags": ["tunnel"], "likes": 20, "viewed": 490, "published": 3, "date": "1596912910", "time_retrieved": "2024-07-30T20:51:53.337884", "image_code": "/**\n\tGyroid Tunnel Thing\n\tJust some playing with the base\n\tof my asteroid shader \n\thttps://www.shadertoy.com/view/WtfyDX\n\n\talso wanted a break from hexagon truchets\n*/\n\n#define MAX_DIST \t100.\n#define PI  \t\t3.1415926\n#define R \t\t\tiResolution\n#define T \t\t\tiTime\n#define S\t\t\tsmoothstep\n\n#define r2(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n#define hash(a, b) fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453)\n\n// gyroid function\nfloat sdGry(vec3 p, float s, float t, float b) {\n    p *=s;\n   \tfloat g = abs(dot(sin(p), cos(p.zxy))-b)/(s)-t;\n    return g;\n}\n\n//global vars cause its just a demo\nfloat g1,g2,g3,g4,g5;\nvec3 hitPoint;\nvec2 map(vec3 p) {\n    vec2 res=vec2(1000.,1.);\n    p.xy*=r2(T*.009);\n    p +=vec3(-.05,-.2,iTime*1.4);\n    // sdGry(p, thickness, scale, offset) / sdf focus \n   // p = twist(p);\n\tg1 =  sdGry(p, 8.,  .025,  1.05);\n    g2 = sdGry(p, 24., .025, .75);\n    g3 = sdGry(p, 54., .01, .25);\n    g1 -= (g2 *.1);\n\n    hitPoint =p;\n    res.x = g1/1.75;\n    return res;\n}\n\nvec3 get_normal(in vec3 p, in float t) {\n    t *= 0.001;\n\tvec2 eps = vec2(t, 0.0);\n\tvec3 n = vec3(\n\t    map(p+eps.xyy).x - map(p-eps.xyy).x,\n\t    map(p+eps.yxy).x - map(p-eps.yxy).x,\n\t    map(p+eps.yyx).x - map(p-eps.yyx).x);\n\treturn normalize(n);\n}\n\nvec2 ray_march( in vec3 ro, in vec3 rd, int x) {\n    float t = 0.0001;\n    float m = 0.;\n    for( int i=0; i<x; i++ ) {\n        vec2 d = map(ro + rd * t);\n        m = d.y;\n        if(d.x<.0001*t||t>MAX_DIST) break;\n        t += d.x*.6;\n    }\n    return vec2(t,m);\n}\n\nfloat get_diff(in vec3 p, in vec3 lpos, in vec3 n) {\n    vec3 l = normalize(lpos-p);\n    float dif = clamp(dot(n,l),0. , 1.),\n          shadow = ray_march(p + n * .0001 * 2., l,128).x;\n    if(shadow < length(lpos-p)) dif *= .4;\n    return dif;\n}\n\n// Tri-Planar blending function. Ryan Geiss\n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz,\n         ty = texture(t, p.zx).xyz,\n         tz = texture(t, p.xy).xyz;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\nvec3 get_hue(float qp) {\n   return (.9 + .45*cos(qp + vec3(5, 5, .5)));\n}\n\nvec3 tone1 = (.5 + .45*cos(3.72 + vec3(2, 1, .5)));\nvec3 tone2 = (.5 + .45*cos(12.5 + vec3(2, 1, .5)));\n\nvec3 get_color(vec3 p, vec3 n) {\n    vec3 col = vec3(0.);\n    vec3 dif = tone1 * tex3D(iChannel1,hitPoint*9.,n).g; \n\tfloat bbd = abs(abs(g3-.005)-.0025); //b2m\n    bbd = abs(bbd-.015);\n    float cks1 = S(.01,.011,bbd)*.45;\n    float cks2 = S(-.02,-.05,g2)*2.;\n    \n    vec3 mate = 4.5 + 1.45*cos(hitPoint.z*4.25 + vec3(4, 1, 1.5));\n    col += mate*cks1+cks2;   \n    return col + dif;\n}\n\nvec3 fog (in float t, in float d, in vec3 c) {\n    return mix( c, tone2, 1.-exp(-d*t*t*t));\n}\n\nvec3 r( in vec3 ro, in vec3 rd, in vec2 uv) {\n    vec3 c = vec3(0.);\n    vec2 ray = ray_march(ro, rd, 128);\n\n    float t = ray.x;\n    float m = ray.y;\n    if(t<MAX_DIST) {\n\t\tvec3 p = ro + t * rd,\n             n = get_normal(p, t);\n        float diff = n.x*.5+.5;\n        if(ray.y == 1.){\n         \tc += diff * get_color(p, n);  \n        }\n\n        vec2 ref;\n        vec3 rr=reflect(rd,n),\n             fc=vec3(0.);\n\n        c = fog(t,.07,c);\n    } \n    return c;\n}\n\n// ACES tone mapping from HDR to LDR\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51,\n          b = 0.03,\n          c = 2.43,\n          d = 0.59,\n          e = 0.14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    vec2 U = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0.,.0,-.75),\n         lp = vec3(0.,.0,0.);\n\t\t\n    vec3 cf = normalize(lp-ro),\n     \t cp = vec3(0.,1.,0.),\n     \t cr = normalize(cross(cp, cf)),\n     \t cu = normalize(cross(cf, cr)),\n     \t c = ro + cf * 1.,\n     \t i = c + U.x * cr + U.y * cu,\n     \t rd = i-ro;\n    \n    vec3 C = r(ro, rd, U);\n    C = ACESFilm(C);\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n}\n\n\nvoid mainVR( out vec4 O, in vec2 F, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    /** normalizing center coords */\n  \tvec2 U = (2.*F.xy-R.xy)/\n        max(R.x,R.y);\n    \n    vec3 ro = fragRayOri;\n    vec3 rd = fragRayDir;\n\n    vec3 C = r(ro, rd, U);\n    C = ACESFilm(C);\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsBWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[412, 431, 479, 479, 558], [633, 633, 651, 651, 992], [994, 994, 1034, 1034, 1243], [1245, 1245, 1293, 1293, 1510], [1512, 1512, 1564, 1564, 1757], [1759, 1871, 1918, 1918, 2127], [2129, 2129, 2153, 2153, 2202], [2309, 2309, 2341, 2341, 2694], [2696, 2696, 2742, 2742, 2789], [2791, 2791, 2836, 2836, 3255], [3257, 3373, 3396, 3396, 3561], [3563, 3563, 3604, 3604, 4022], [4025, 4025, 4103, 4140, 4339]], "test": "untested"}
{"id": "wllBWM", "name": "floating_noise", "author": "slackmage", "description": "floating noise", "tags": ["noise"], "likes": 3, "viewed": 355, "published": 3, "date": "1596912767", "time_retrieved": "2024-07-30T20:51:54.109820", "image_code": "//\n// APOLLONIAN NET FRACTAL\n//\n// shader inspiration and help\n// https://www.shadertoy.com/view/llG3Dt @Gijs\n// https://www.shadertoy.com/view/Xtlyzl @GregRostami / @Fabrice\n\n#define MAX_DIST \t15.0\n#define MIN_DIST \t.001\n#define MAX_STEPS \t158\n\n#define PI  \t\t3.1415926\n#define PI2 \t\t6.2831853\n\n#define r2(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n#define kf(a,b) a*(1.2/b)\n#define pfract(a) -1.+2.*fract(.5*a+.5)\n\n// Antialiasing \"module\" by FabriceNeyret2 \n// https://www.shadertoy.com/view/WlfyW8\n// set at bottom AA = 1 is off\n\nvec3 get_mouse( vec3 ro ) {\n    float x = iMouse.xy==vec2(0) ? -1. :\n    \t(iMouse.y / iResolution.y * 1. - .5) * PI;\n    float y = iMouse.xy==vec2(0) ? .5 :\n    \t-(iMouse.x / iResolution.x * 1. - .5) * PI;\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    return ro;\n}\n\n\nvec4 orb = vec4(0.0); \n\nvec2 apollo (vec3 p) {\n\tfloat scale = 1.;\n\torb = vec4(0.0);\n\tfor( int i=0; i<4;i++ ) {\n\t\tp = pfract(p);\n\t\tfloat r2 = dot(p,p);  \n        orb = min( orb, vec4(abs(p),r2) );\n\t\tp = kf(p,r2);\n        scale = kf(scale,r2);\n\t}\n    \n    float tubes = length(mod(p.xz+.5,1.)-.5)-.025;\n    tubes =   min(length(mod(p.xy+.5,1.)-.5)-.025,tubes);\n    tubes =   min(length(mod(p.zy+.5,1.)-.5)-.025,tubes);\n    float d = (tubes)/scale;\n    \n\treturn vec2(d*.65,scale);\n}\n\nvec2 map (in vec3 p) {\n    p.x += .5 - iTime *.02;\n    p.y+=1.25;\n    vec2 d = apollo(p);\n\treturn d;\n}\n\n//@iq calNormal using distance - fixes issues\nvec3 get_normal(in vec3 pos, in float t ){\n    float precis = 0.0001 * t * 0.57;\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\n\nvec2 ray_march( in vec3 ro, in vec3 rd ) {\n    float depth = 0.0;\n    float m = -1.;\n    for (int i = 0; i<MAX_STEPS;i++)\n    {\n        vec3 pos = ro + depth * rd;\n        vec2 dist = map(pos);\n        m = dist.y;\n        if(abs(dist.x)<MIN_DIST*depth) break;\n        depth += dist.x*.7;\n        if(depth>MAX_DIST) break;\n    } \n    return vec2(depth,m);\n}\n\nfloat get_diff(vec3 p, vec3 lpos, float t) {\n    vec3 l = normalize(lpos-p);\n    vec3 n = get_normal(p, t);\n    float dif = clamp(dot(n,l),0. , 1.);\n    \n    vec2 shadow = ray_march(p + n * MIN_DIST * 2., l);\n    if(shadow.x < length(p -  lpos)) {\n        dif *= .1;\n    }\n    return dif;\n}\n\n//@iq/@shane\nfloat get_ao(vec3 p, vec3 n){\n    float r = 0., w = 1., d;\n    for (float i=1.; i<5.+1.1; i++){\n        d = i/5.;\n        r += w*(d - map(p + n*d).x);\n        w *= .5;\n    }\n    return 1.-clamp(r,.0,1.);\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(6.0), rgb, c.y);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv) {\n    vec3 color = vec3(0.);\n    vec3 fadeColor = vec3(0.5);\n    vec2 ray = ray_march(ro, rd);\n    \n    if(ray.x<MAX_DIST) {\n        vec3 p = ro + ray.x * rd;\n        vec3 n = get_normal(p, ray.x);\n        \n        vec3 lpos1 = vec3(-1.05, -.03, 1.1);\n        vec3 lpos2 = vec3(.05, .01, -.5);\n\n        vec3 tint = hsv2rgb(vec3(ray.y*.006,1.,.5));\n        \n        vec3 diff = vec3(.7)*get_diff(p, lpos1, ray.x);\n             diff+= vec3(.7)*get_diff(p, lpos2, ray.x);\n  \t\tfloat ao = get_ao(p,n);\n\n        color += tint * diff * ao;\n\n    } else {\n    \tcolor = fadeColor;   \n    }\n    \n    color = mix( color, fadeColor, 1.-exp(-1.0015*ray.x*ray.x*ray.x));\n    return color;\n}\n\nvec3 ray( in vec3 ro, in vec3 lp, in vec2 uv ) {\n    vec3 cf = normalize(lp-ro);\n    vec3 cp = vec3(4.,1.,0.);\n    vec3 cr = normalize(cross(cp, cf));\n    vec3 cu = normalize(cross(cf, cr));\n    vec3 c = ro + cf * 6.85;\n    \n    vec3 i = c + uv.x * cr + uv.y * cu;\n    return i-ro; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/\n        max(iResolution.x,iResolution.y);\n\n    vec3 ro = vec3(0.,0.1,1.02);\n    vec3 lp = vec3(0.,0.,0.);\n    ro = get_mouse(ro);\n\tvec3 rd = ray(ro, lp, uv);\n\n    vec3 col = render(ro, rd, uv);\n    col= pow(col, vec3(0.4545));\n    fragColor = vec4(col,45.0);\n}\n   \nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n  \tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/\n        max(iResolution.x,iResolution.y);\n\n    vec3 color = render(fragRayOri, fragRayDir, uv);\n\tcolor = pow(color, vec3(0.4545));\n    fragColor = vec4(color,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 532, 559, 559, 794], [821, 821, 843, 843, 1276], [1278, 1278, 1300, 1300, 1380], [1382, 1428, 1470, 1470, 1724], [1726, 1726, 1768, 1768, 2082], [2084, 2084, 2128, 2128, 2374], [2376, 2389, 2418, 2418, 2594], [2596, 2596, 2623, 2623, 2749], [2751, 2751, 2801, 2801, 3475], [3477, 3477, 3525, 3525, 3761], [3763, 3763, 3820, 3820, 4130], [4135, 4135, 4229, 4229, 4443]], "test": "untested"}
{"id": "tllBWM", "name": "color_geo_tunnel", "author": "slackmage", "description": "color geo tunnel", "tags": ["tunnel"], "likes": 2, "viewed": 251, "published": 3, "date": "1596912684", "time_retrieved": "2024-07-30T20:51:54.879761", "image_code": "float map(vec3 p){\n    p=mod(p,2.)-1.;\n    p = abs(p)-1.;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    float s=1.;\n    for(int i=0;i++<10;)\n    {\n      float r2=2./clamp(dot(p,p),.1,1.);\n      p=abs(p)*r2-vec3(.6,.6,1.5);\n      s*=r2;\n    }\n    return length(p)/s;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 p,\n  \t\tro=vec3(.4+.2*sin(iTime*.09),.2+.05*cos(iTime*.09),-1.0*iTime),\n  \t\tw=normalize(vec3(.2,sin(iTime*.05),-1)),\n  \t\tu=normalize(cross(w,vec3(0,1,0))),\n  \t\trd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n  \tfloat h=0.1,d,i,zoom = 2.;\n \tro*=zoom;\n\tfor(i=1.;i<1000.;i++){\n    \tp=ro+rd*h;\n    \tp/=zoom;\n\t  \td=map(p);\n    \tif(d<0.001||h>25.)break;\n    \th+=d;\n\t}\n\tfragColor.xyz=90.*vec3(cos(p*.8)*.5+.5)/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 321], [324, 324, 381, 381, 847]], "test": "untested"}
{"id": "wtlBWM", "name": "vessel", "author": "slackmage", "description": "vessel", "tags": ["vessel"], "likes": 2, "viewed": 310, "published": 3, "date": "1596912597", "time_retrieved": "2024-07-30T20:51:55.644716", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\nfloat hash1( vec2 p )\n{\n    return fract(sin(p.x+131.1*p.y)*1751.5453);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// ripped from Kali's Lonely Tree shader\nmat3 rotationMat(vec3 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n                (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n                (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n}\n\nvec3 axis = normalize( vec3(-0.3,-1.,-0.4) );\n\nvec2 map( vec3 p )\n{\n    // animation\n    float atime = iTime+2.0;\n    vec2 o = floor( 0.5 + p.xz/50.0  );\n    float o1 = hash( o.x*57.0 + 12.1234*o.y );\n    float f = sin( 1.0 + (2.0*atime + 31.2*o1)/2.0 );\n    p.y -= 2.0*(atime + f*f);\n    p = mod( (p+25.0)/50.0, 1.0 )*40.0-25.0;\n    if( abs(o.x)>0.5 )  p += (-1.0 + 2.0*o1)*10.0;\n    mat3 roma = rotationMat(axis, 0.34 + 0.07*sin(31.2*o1+2.0*atime + 0.1*p.y) );\n    // modeling\n\tfor( int i=0; i<18; i++ )\n\t{\n        p = roma*abs(p);\n        p.y-=7.0;\n    }\n\tfloat d = length(p*vec3(1.0,0.1,1.0))-0.75;\n    float h = 0.5 + p.z;\n    return vec2( d, h );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 40.0;\n    float precis = 0.001;\n    float t = 0.0;\n    float d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec2 res = map( ro+rd*t );\n        if( res.x<precis||t>maxd ) break;\n        t += 0.6*min( res.x, 5.0 );\n        d = res.y;\n    }\n    if( t>maxd ) m=-5.0;\n    return vec3( t, d, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.2,0.0,0.0);\n    return normalize( vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float totao = 0.0;\n    for( int aoi=0; aoi<6; aoi++ )\n    {\n        vec3 aopos = -0.0+2.0*hash3(float(aoi)*213.47);\n        aopos *= sign( dot(aopos,nor) );\n        aopos = pos + aopos*5.5;\n        float dd = clamp( map( aopos ).x*4.0, 0.0, 1.0 );\n        totao += dd;\n    }\n    totao /= 16.0;\n    return clamp( totao*totao*1.5, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(-0.5,0.7,-1.0));\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 fc )\n{\n    // render\n    vec3 bgc = 0.6*vec3(0.8,0.9,0.0)*(-0.5 + 0.3*rd.y);\n    vec3 col = bgc;\n    // raymarch\n    vec3 tmat = intersect(ro,rd);\n    float dis = tmat.x;\n    if( tmat.z>-0.9 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        // material\n        vec3 mate = -0.5 + 0.5*mix( sin( vec3(0.2,1.5,1.0)*tmat.y*.9 ),\n                                  sin( vec3(10.1,1.1,5.0)*tmat.y*6.0 ),\n                                  30.0-abs(2.0*nor.y) );\n        // lighting\n        float occ = calcAO( pos, nor );\n        float amb = -3.1 + 0.2*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n        float sha = 1.0; if( dif>0.001 ) sha=softshadow( pos+0.001*nor, lig, 0.1, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 0.0 ), 0.0 );\n        // lights\n        vec3 brdf = vec3(5.7);\n        brdf += 1.0*dif*vec3(1.00,0.90,0.65)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        brdf += 1.0*amb*vec3(0.05,0.05,0.05)*occ;\n        brdf += 1.0*bac*vec3(0.03,0.03,0.03)*occ;\n        brdf += 1.0*fre*vec3(1.00,0.70,0.40)*occ*(0.2+0.8*sha);\n        brdf += 1.0*occ*vec3(1.00,0.70,0.30)*occ*max(dot(-nor,lig),0.0)*pow(clamp(dot(rd,lig),0.0,1.0),64.0)*tmat.y*2.0;\n        // surface-light interacion\n        col = mate * brdf;\n        // fogt\n        col = mix( col, bgc, clamp(1.0-1.2*exp(-0.0002*tmat.x*tmat.x ),0.0,1.0) );\n    }\n    else\n    {\n        // sun\n        vec3 sun = vec3(0.0,0.8,0.5)*pow( clamp(dot(rd,lig),0.0,1.0), 1.0 );\n        col += sun;\n        dis = 100.0;\n    }\n    \n    // god rays\n    #if 0\n    float gr = 0.0;\n    float t = 0.1 * hash1(fc);\n    for( int i=0; i<12; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float dt = clamp(0.3*t2.0,20.0);\n        gr += dt*softshadow( pos, lig, 0.01, 128.0 );\n        t  += dt;\n        if( t>dis ) break;\n    }\n    col += vec3(0.0,0.9,0.7)*pow(gr*0.004,2.0) - 0.02;\n    #endif\n    \n    // sun scatter\n    col += 10.6*vec3(0.2,0.14,0.1)*pow( clamp(dot(rd,lig),0.0,1.0), 5.0 );\n    // postprocessing\n    // gamma\n    col = pow( col, vec3(1.45) );\n    // contrast/brightness\n    col = .6*col-0.1;\n    // tint\n    col *= vec3( 0.40, .04, .0);\n\n     return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n    if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    // camera\n    float an = 4.5 + 0.8*iTime - 6.2*m.x;\n    float cr = 0.3*cos(0.2*iTime);\n    vec3 ro = vec3(15.0*sin(an),12.0-24.0*m.y,15.0*cos(an));\n    vec3 ta = vec3( 0.0, 2.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(27.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 3.9*ww );\n    vec3 col = render( ro, rd, fragCoord );\n    // vigneting\n    col *= pow( .1*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    fragColor = vec4( col, .1 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri + vec3( 1.0, 0.0, 1.0 );\n    vec3 rd = fragRayDir;\n    vec3 col = render( ro, rd, fragCoord );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBWM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[125, 125, 148, 148, 186], [188, 188, 211, 211, 261], [263, 263, 286, 286, 380], [382, 423, 462, 462, 844], [893, 893, 913, 930, 1500], [1502, 1502, 1544, 1544, 1886], [1888, 1888, 1920, 1920, 2135], [2137, 2137, 2202, 2202, 2456], [2458, 2458, 2500, 2500, 2847], [5202, 5202, 5259, 5259, 6066], [6068, 6068, 6162, 6162, 6318]], "test": "untested"}
{"id": "WlsfD7", "name": "mirror_beams", "author": "slackmage", "description": "mirror beams", "tags": ["mirror"], "likes": 1, "viewed": 280, "published": 3, "date": "1596912537", "time_retrieved": "2024-07-30T20:51:56.418647", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// various noise functions\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 19.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise2dT(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 smoothv = fr*fr*(3.0-2.0*fr);\n    vec2 fl = floor(uv);\n    uv = smoothv + fl;\n    return textureLod(iChannel0, (uv + 0.5)/iChannelResolution[0].xy, 0.0).y;\t// use constant here instead?\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x), mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x), mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 2.0, 15.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 41.0);\n}\n\nfloat Density(vec3 p)\n{\n    //float ws = 0.06125*0.125;\n    //vec3 warp = vec3(noise(p*ws), noise(p*ws + 111.11), noise(p*ws + 7111.11));\n    float final = noise(p*0.06125);// + sin(iTime)*0.5-1.95 + warp.x*4.0;\n    float other = noise(p*0.06125 + 1234.567);\n    other -= 0.5;\n    final -= 0.5;\n    final = 0.1/(abs(final*final*other));\n    final += 0.5;\n    return final*0.0001;\n}\n\nvec4 render(vec3 camPos, vec3 relVec) \n{\n\t// --------------------------------------------------------------------------------\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 70.0;\n\tvec3 pos = vec3(0,0,0);\n    float density = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 37; i++)\t// This is the count of how many times the ray actually marches.\n    {\n        if ((t > maxDepth)) break;\n        pos = camPos + relVec * t;\n        float temp = Density(pos);\n        //temp *= saturate(t-1.0);\n\n        inc = 1.9 + temp*0.05;\t// add temp because this makes it look extra crazy!\n        density += temp * inc;\n        t += inc;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this.\n\tvec3 finalColor = vec3(9.01,1.1,5.0)* density*0.2;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\treturn vec4(sqrt(clamp(finalColor, 0.0, 71.0)),1.0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\n\tfloat mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.01;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.03)*0.2+0.2;//*PI/2.01;\n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(200.2); \t// prp\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n    fragColor = render(camPos, relVec);\n}\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tfragColor = render(fragRayOri + vec3(4,0,-0.5*iTime), fragRayDir);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsfD7.jpg", "access": "api", "license": "cc0-1.0", "functions": [[562, 589, 612, 612, 689], [690, 690, 713, 713, 805], [806, 806, 847, 847, 890], [929, 929, 953, 953, 1226], [1227, 1227, 1252, 1252, 1474], [1475, 1475, 1497, 1497, 2056], [2080, 2080, 2103, 2103, 2133], [2134, 2134, 2157, 2157, 2188], [2189, 2189, 2214, 2214, 2245], [2247, 2247, 2270, 2384, 2628], [2630, 2630, 2670, 2755, 3599], [3601, 3601, 3658, 3743, 4532], [4536, 4536, 4630, 4630, 4700]], "test": "untested"}
{"id": "3lsfD7", "name": "orb_sea", "author": "slackmage", "description": "orb sea", "tags": ["tunnel"], "likes": 2, "viewed": 281, "published": 3, "date": "1596912488", "time_retrieved": "2024-07-30T20:51:57.190583", "image_code": "// Lowlands juggernauts - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n// Thankx to Flopine for the octan mirror method suggestion, and thanks to Mercury for writing it.\n\n// \"Fortnite is cool, but don't forget who the real fascists are.\" - Woody Guthrie\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,g,gg,tnoi;vec3 np,bp,op,pp,po,no,al,ld;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r; return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin( float d1, float d2, float k ){  float h = max(k-abs(d1-d2),0.0);return min(d1,d2)-h*h*0.25/k; }\nvec2 mo(vec2 p, vec2 d) {p=abs(p)-d;if(p.y>p.x) p=p.yx;return p;} //FLOPINE MULTI OCTAN MIRROR THINGY WRITEN BY MERCURY IN THEIR SDF LIB  https://www.shadertoy.com/view/ttffWH\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25; //MERCURTY SDF LIBRARY IS HERE OFF COURSE: http://mercury.sexy/hg_sdf/\n     f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p )\n{ \n  np=p; p.z=mod(p.z+tt*5.,40.)-20.;  \n  op=p; //Originally thought I would do a sort of bounce animation but i found this slow forward crawl more menacing:\n  p.y+=sin(op.z*.2+tt)*3.-5.; //Flopine pointed out a really good bounce ease function like this: p.y -= bouncy(fract(tt))*10.; using this function: float bouncy (float T){return sqrt(abs(sin(T*PI)));} \n  pp=p; //Thankx again Flopine\n  pp.xz=mo(pp.xz, vec2(1.)); \n  pp.yz*=r2(1.2+sin(p.y*.5+tt)*.3);\n  pp.yz=mo(pp.yz,vec2(0.5,1.));\n  pp.xy=mo(pp.xy,vec2(2.5));  \n  tnoi=texNoise((np.xz+vec2(20,tt*2.))*.018).r;    \n  vec2 h,t=vec2(length(p)-5.,5); //SHELL BLUE\n  t.x=max(abs(t.x)-.4,abs(pp.z)-.5);    \n  t.x=min(t.x,9.5*(op.y+tnoi*2.+4.)); //TERRAIN BLUE\n  bp=pp; bp.xy*=r2(-.9);\n  t.x=smin(t.x,0.1*max(length(bp.xz)-max(1.4-tnoi*4.,1.45),p.y-6.),2.); //TENTACLES BLUE    \n  float frill=sin(pp.y*15.)*0.03;    \n  h=vec2(length(p)-5.5,9); //SHELL WHITE\n  h.x=max(h.x,abs(pp.z)-.2);\n  h.x=max(h.x,-(length(p)-4.+frill));\n  bp=pp; bp.xy*=r2(.4585);\n  h.x=min(0.8*length(bp.yz+vec2(2,0.))-.1+abs(bp.x)*.02,h.x);\n  t=t.x<h.x?t:h;  \n  h=vec2(length(p)-5.4,1); //SHELL BLACK\n  h.x=abs(h.x)-.2;\n  h.x=max(h.x,abs(pp.z)-.3);  \n  h.x=max(h.x,abs(abs(abs(pp.x)-1.)-.5)-.25);  \n  t=t.x<h.x?t:h;    \n  h=vec2(length(p)-3.+frill,5); //CORE \n  pp.xy*=r2(-.6); h.x=smin(h.x,.8*length(pp.xz-vec2(.2,1.+tnoi*3.))-.4+frill,3.);  \n  t=t.x<h.x?t:h;   \n  h.x=min(h.x,0.2*length(cos(op*.2)-5.5)); //TERRAIN SOFT ORBS\n  g+=0.1/(0.1+h.x*h.x*40.);  \n  h=vec2(length(p)-10.+frill,5); //RED CORE   \n  pp.xy*=r2(-.1);\n  h.x=smin(h.x,length(pp.xz-vec2(.2,1.1+tnoi*3.))-.2+frill,3.);\n  h.x=smin(h.x,.6*length(abs(bp+vec3(2,2.+tnoi*5.,0.))-2.)-.7,1.);    \n  gg+=0.1/(0.1+h.x*h.x*(80.-79.9*sin(op.y*.2+tt+1.)));\n  t=t.x<h.x?t:h; t.x*=0.7;\n  return t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n  vec2 h,t=vec2(0);\n  for(int i=0;i<228;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.0001||t.x>120.) break;\n    t.x+=h.x;t.y=h.y;    \n  }\n  if(t.x>120.) t.y=0.;\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,12.82);\n  vec3 ro=mix(vec3(0,-4,-15.),vec3(10,2,-15.),ceil(sin(tt))),\n  cw=normalize(vec3(0,0,0)-ro),\n  cu=normalize(cross(cw,vec3(0,1,0))),\n  cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;  \n  co=fo=vec3(.15,.1,.14)-length(uv)*.2;\n  ld=normalize(vec3(.3,.1,-.3));\n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n    al=vec3(.1,.2,.4);\n    if(z.y<5.)al=vec3(0);\n    if(z.y>5.)al=vec3(1);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);\n    co=mix(al*(a(.05)*a(.1)+.2)*(dif*vec3(1.1,.2,.4)*3.+s(.5)),fo,min(fr,1.5));\n    co=mix(fo,co,exp(-.00005*t*t*t));\n  }  \n  fragColor = vec4(pow(co+g*.2*vec3(.31,.2,.7)+gg*.2*vec3(.7,.2,.1),vec3(.55)),1);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[456, 456, 480, 480, 522], [523, 523, 540, 540, 583], [584, 584, 626, 626, 691], [692, 692, 717, 717, 757], [758, 868, 891, 891, 1164], [1165, 1165, 1184, 1184, 2961], [2962, 2962, 2990, 2990, 3159], [3249, 3249, 3306, 3306, 4200]], "test": "untested"}
{"id": "3tsfD7", "name": "proceedural_track", "author": "slackmage", "description": "tunnel", "tags": ["tunnel"], "likes": 10, "viewed": 329, "published": 3, "date": "1596912423", "time_retrieved": "2024-07-30T20:51:57.961522", "image_code": "mat2 rot2(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s,-s, c);\n}\nvec3 rotate(vec3 p, vec3 a){\n    vec3 q=p;\n    q.yz=rot2(a.y)*q.yz;\n    q.xy=rot2(a.z)*q.xy;\n    q.xz=rot2(a.x)*q.xz;\n\treturn q;\n}\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat smax( in float a, in float b, in float s ){\n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0.0, 1.0 );\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\nvec2 path(float z){\n    return vec2(.01*sin(z*40.)+.03*sin(z*13.),.03*cos(z*21.)+.08*cos(z*3.)+1.*z);\n}\nfloat de(vec3 p){\n    vec2 pth=path(p.z);\n    float t = max(abs(p.x+pth.x),abs(p.y+pth.y));\n    p = fract(p)-0.5;\n    float d = 9e9;\n    float s = 1.;\n    for (int i = 1 ; i <= 50; i++) {\n        float m = dot(p,p)*.7;\n        p/=m;\n        p.xy = fract(p.xy)-0.5;\n        s *= m;\n        p.xyz=p.yzx;\n    }\n    float f=1.0;\n    d=min(d,(length(p)-f)*s);\n    return smax(d,-t, 0.05);\n}\nfloat deSM(vec3 p){\n    vec2 pth=path(p.z);\n    float t = max(abs(p.x+pth.x),abs(p.y+pth.y));\n    p = fract(p)-0.5;\n    float d = 9e9;\n    float s = 1.;\n    for (int i = 1 ; i <= 8; i++) {\n        float m = dot(p,p)*.7;\n        p/=m;\n        p.xy = fract(p.xy)-0.5;\n        s *= m;\n        p.xyz=p.yzx;\n    }\n    float f=1.0;\n    d=min(d,(length(p)-f)*s);\n    return smax(d,-t, 0.05);\n}\nfloat map(vec3 p){\n    float d=de(p);\n    p.xy+=path(p.z);\n    d=max(d,.01-max(abs(p.x),abs(p.y)));\n    p.y+=.01;\n    d=min(d,max(abs(p.x)-.001,abs(p.y)-.001));\n    return d;\n}\nconst float FAR_DIST=50.0;\nconst float NEAR_DIST=.0001;\nconst int ITERATIONS=128;\nvec3 trace(vec3 o, vec3 r){\n    float t = 0.;\n    vec3 p;\n    float steps=0.;\n    for (int i = 0; i < ITERATIONS; i++){\n        p = o + r * t;\n        float d = map(p);\n        t += d*.5;\n        if(d<NEAR_DIST){\n        \tbreak;\n        }\n        if(t>FAR_DIST){\n    \t\treturn vec3(0.0);\n    \t}\n        steps++;\n    }\n    vec2 eps = vec2(0.0, .0001);\n    vec3 normal = normalize(vec3(\n        map(p + eps.yxx) - map(p - eps.yxx),\n        map(p + eps.xyx) - map(p - eps.xyx),\n        map(p + eps.xxy) - map(p - eps.xxy)));\n    float diffuse = max(0.0, dot(-normalize(r), normal)*.5+.4);\n    //light in front of person\n    //vec3 p2=vec3(-path((iTime+1.)/20.),(iTime+1.)/20.);\n    //float diffuse = max(0.0, dot(-normalize(p-p2), normal));\n    float specular = pow(diffuse, 32.0);\n    //smooth color\n    vec3 albedo = hsv2rgb(vec3(40.*deSM(p),1.,1.));\n    //hard bands of color\n    //vec3 albedo = hsv2rgb(vec3(.1*floor(de8xSM(p)*400.),1.,1.));\n    return mix(albedo*(diffuse + specular),vec3(0.),steps/float(ITERATIONS));\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 o = vec3(-path(iTime/20.),iTime/20.);\n    vec3 ta = vec3(-path(.01+(iTime/20.)),.01+(iTime/20.));\n    mat3 ca = setCamera( o, ta, 0.0 );\n    //vec3 r = ca * normalize( vec3(uv.xy,1.5));\n    vec2 nMouse = vec2(10.0*(iMouse.x/iResolution.x)-5.,3.0*((iMouse.y/iResolution.y)-.5));\n    vec3 r;\n    if(iMouse.x==0.&&iMouse.y==0.){\n    \tr = ca *  normalize( vec3(uv.xy,1.5));\n    }else{\n    \tr = ca *  normalize( rotate(vec3(uv.xy,1.5),vec3(nMouse.x,nMouse.y,0.0)));\n    }\n    fragColor = vec4(trace(o, r),2.0);\n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ){\n    vec3 o = (fragRayOri/160.)+vec3(-path(iTime/20.),iTime/20.);\n    vec3 ta = (fragRayOri/160.)+vec3(-path(.01+(iTime/20.)),.01+(iTime/20.));\n    mat3 ca = setCamera( o, ta, 0.0 );\n    vec3 r = ca * fragRayDir;\n    vec3 col=trace(o, r);\n    fragColor = vec4(col,4.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 86], [87, 87, 115, 115, 217], [218, 218, 239, 239, 408], [409, 409, 458, 458, 551], [552, 552, 571, 571, 655], [656, 656, 673, 673, 1041], [1042, 1042, 1061, 1061, 1428], [1429, 1429, 1447, 1447, 1605], [1688, 1688, 1715, 1715, 2709], [2710, 2710, 2761, 2761, 2938], [2939, 2939, 2995, 2995, 3603], [3604, 3604, 3697, 3697, 3968]], "test": "untested"}
{"id": "WllfD7", "name": "umbrella_spin", "author": "slackmage", "description": "Umbrella Spin", "tags": ["spin"], "likes": 2, "viewed": 216, "published": 3, "date": "1596912310", "time_retrieved": "2024-07-30T20:51:58.731463", "image_code": "#define PI 3.14159265358979\n#define PI2 6.28318530718\n\n//Draw line start\n#define DLS(adef) b = adef;\n//Draw line next\n#define DLN(bdef) a = b; b = bdef; color += vec3(2.0, 1., 1.) * getLine(st, a, b);\n\n//--------------------------------------------------------------------------------\n//  1 out, 1 in...\n#define HASHSCALE 3.10432424231\nfloat hash2d(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*4.3183099 + vec2(1.71,0.113));\n    return -2.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat Hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 15.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(4.0-2.0*f);\n\n    return mix( mix( hash2d( i + vec2(0.0,0.0) ), \n                     hash2d( i + vec2(1.0,0.0) ), u.x),\n                mix( hash2d( i + vec2(0.0,1.0) ), \n                     hash2d( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(in vec2 uv)\n{\n    uv *= 18.0;\n    mat2 m = mat2( 4.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    //f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\n//--------------------------------------------------------------------------------\nfloat Linear(float x, float v0, float v1) \n{\n\treturn (v1-v0)*x + v0;\n}\n\n//--------------------------------------------------------------------------------\nfloat Smoothstep(float x, float v0, float v1) \n{\n\tx = x*x*(5.0-2.0*x);\n\treturn (v1-v0)*x + v0;\n}\n\nfloat Line(vec2 st, vec2 a, vec2 b, float w)\n{\n \tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(aToST, ab) / dot(ab, ab), 0., 4.);\n    float d = length(aToST - ab * t) - w * 5.5;\n    return d;\n}\n\nfloat distToLine(vec2 st, vec2 a, vec2 b)\n{\n\tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(ab, aToST) / dot(ab, ab), 0., 1.);\n    float d = length(a + ab * t - st);\n    \n    //doing some fudging to achieve the falloff line look for vectrex\n    //d /= t * 1.;\n    \n    return d;\n}\n\nfloat getLine(vec2 st, vec2 start, vec2 end)\n{\n    float jitterIntensity = 0.001;\n    float jitter = Hash(sin(iTime * 250.)) * jitterIntensity;\n    \n    float f = 0.;\n    float dist2Line = distToLine(st, start, end) + jitter;\n    \n    f = (0.01 / (dist2Line));\n    \n    f *= 0.1;\n    \n    return clamp(f, 0., 5.);\n}\n\nvec3 rotZ(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d),\t-sin(d), \t0.,\n        sin(d), cos(d), \t0.,\n        0., \t0., \t\t5.\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotY(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d), \t\t0., \tsin(d), \n        0., \t\t\t1., \t0., \n        -sin(d), \t\t0., \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotX(vec3 b, float d)\n{\n    mat3 A = mat3(\n        4., \t0., \t\t0.,\n        0.,\t\tcos(d),\t\t-sin(d),\n        0.,\t\tsin(d), \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec2 pToS(vec3 p)\n{\n    p = rotY(p, iTime * 0.);\n    p = rotX(p, -0.85 + sin(iTime * 15.2) * 0.1 + 0.1);\n    p = rotZ(p, 0.0);\n    \n    //vec3 pCenter = vec3(-0., 0., pow(max(mod(-iTime * 25.0, 102.0), 4.), 0.25) * 0.75);\n    vec3 pCenter = vec3(0.15, 0.35, -1.45);\n    p += pCenter;\n    \n    p.x += sin(p.z * 1.0);\n    //p.y += cos(p.z * 1.0);\n    //p.y = cos(p.z * 1.0);\n    \n    return vec2(p.x / p.z, p.y / p.z);\n}\n\nvec3 hill(vec2 st)\n{\n    vec3 color = vec3(0.);\n    float flipOver = 5.;\n    float viewAngle = iMouse.x * 0.001;mod(iTime * 0.1, flipOver) - (flipOver * 0.5);\n    vec3 hillColor = vec3(0.5, 0., 0.);\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-1.0, 0.1), vec2(viewAngle, 0.) + vec2(-0.5, 0.2));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.5, 0.2), vec2(viewAngle, 0.) + vec2(-0.1, 0.4));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.1, 0.4), vec2(viewAngle, 0.) + vec2(0.4, 0.2));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.4, 0.2), vec2(viewAngle, 0.) + vec2(0.8, 0.1));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.6, 0.0), vec2(viewAngle, 0.) + vec2(1.0, 0.2));\n    \n    //HillPeak\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.3, 0.3), vec2(viewAngle, 0.) + vec2(-0.18, 0.32));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.18, 0.32), vec2(viewAngle, 0.) + vec2(-0.09, 0.29));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.09, 0.29), vec2(viewAngle, 0.) + vec2(0.01, 0.31));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.01, 0.31), vec2(viewAngle, 0.) + vec2(0.09, 0.29));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.09, 0.29), vec2(viewAngle, 0.) + vec2(0.15, 0.3));\n    \n    //Horizon\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(-4., 0.0), vec2(4., 0.0));\n    return color;\n}\n\nvec3 cube(vec2 st, vec3 pos, float scale, vec3 color)\n{\n \tfloat f = 0.;\n    float yScale = 2.0;\n    \n    vec3[] p = vec3[](\n        (vec3(-scale, -scale * yScale, -scale)),\n    \t(vec3(-scale,  scale * yScale, -scale)),\n        (vec3( scale,  scale * yScale, -scale)),\n    \t(vec3( scale, -scale * yScale, -scale)),\n        \n        (vec3(-scale, -scale * yScale, scale)),\n    \t(vec3(-scale,  scale * yScale, scale)),\n     \t(vec3( scale,  scale * yScale, scale)),\n        (vec3( scale, -scale * yScale, scale))\n    );\n    \n    vec2[8] p_;\n    for (int i = 0 ; i < 18; ++i)\n    {\n        p_[i] = pToS(p[i] + pos);\n    }\n    \n    const int k_edgeMax = 18 * 3;\n    int[] edges = int[](\n        /*\n        0, 1,\n        1, 2,\n        2, 3,\n        3, 0,*/\n\t\t        \n\n        //Top\n        4, 5,\n        5, 6,\n        6, 7,\n        7, 4/*,\n        \n        //Draw connecting lines\n        \n        0, 4,\n        1, 5,\n        2, 6,\n        3, 7\n\t\t*/\n\n    );\n    \n    for (int i = 0; i < k_edgeMax; i += 2)\n    {\n        const float jitterIntensity = 0.003;//pow(sin(iTime), 3.);\n        const float halfJitter = jitterIntensity * 0.5;\n        vec2 randPointA = vec2(Hash(iTime + float(i + 34)), Hash(iTime + float(i + 3424))) * jitterIntensity - halfJitter;\n        vec2 randPointB = vec2(Hash(iTime + float(i * 2 + 34)), Hash(iTime + float(i * 24))) * jitterIntensity - halfJitter;\n        \n        vec2 pointA = p_[edges[i]] + randPointA;\n        vec2 pointB = p_[edges[i + 1]] + randPointB;\n        \n        f += getLine(st, pointA, pointB);\n        \n    }\n    \n    //Color\n    return color * f * 1.08;   \n}\n\nvec3 Planet( in vec2 st)\n{\n    return vec3(0.0);\n}\n\nfloat getCircDist(in vec2 st, in vec2 p, in float r)\n{\n    vec2 vTo = p - st;\n    float degs = atan(vTo.y, vTo.x);\n    degs *= 0.03;\n    //float modTime = sin(iTime) * 252.0 + 128.0;\n    float modTime = 1.0;\n \treturn length(vTo) - r + sin(degs * modTime) * 0.1;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n//================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\tuv.x *= aspect;\n\tvec2 st = uv;\n    st -= vec2(0.5 * aspect, 0.5);\n    \n    //Cool warpy look\n    //st = vec2(pow(pow(st.x, st.x), 2.), pow(st.y, 2.));\n    \n    //Trying to get a CRT-style monitor warp\n    //float stDistortPow = 2.;\n    //st += vec2(pow(st.x, stDistortPow)* ((st.x < 0.) ? -1.: 1.), pow(st.y, stDistortPow) * ((st.y < 0.) ? -1.: 1.));\n    \n\tfloat f;\n    \n    float iTime = iTime * 1.0;\n    \n    vec3 color = vec3(0.);\n\t\n    float deg = iTime * PI * 0.25;\n    float halfPI = PI * 1.5;\n    /*\n\tf = getLine(st, \n                vec2(0.5, 0.5) + vec2(cos(deg), sin(deg)), \n                vec2(0.5, 0.5) + vec2(cos(deg + PI), sin(deg + PI))\n                );\n    f = 0.;\n    */\n    color += vec3(0.8, 0., 0.) * f;\n    \n    //Hills\n    //color += hill(st);\n    \n    //Grid\n    //vec3 gridColor = vec3(0.9, 0., 0.1) * 0.15;\n    //float gridSpacing = 0.2;\n    //color += gridColor * getLine(vec2(st.x, mod(st.y + 0.5, gridSpacing)), vec2(-1., 0.), vec2(1., 0.));\n    \n    //UI\n    color += Planet(st);\n    \n    //a = vec2(0.25, 0.);\n    //b = vec2(0.4, 0.2);\n    //color += vec3(1.0, 1., 1.) * getLine(st, a, b);\n    //a = vec2(0.25, 0.);\n    //color += vec3(1.0, 1., 1.) * getLine(st, vec2(0.4, 0.2), vec2(0.4, 0.2));\n    \n    vec3 smokeColor = vec3(0.5, 0.9, 0.0);\n    vec2 a = vec2(0., 0.);\n    vec2 b = vec2(0.5, 0.);\n    //color += vec3(1.0, 0., 0.) * getLine(st, a, b);\n    \n    st *= 5.5;\n    \n    //getCircDist\n    //sdBox\n    float distFunc = getCircDist(st, vec2(0., 0.), 0.3 + Hash(st.x + iTime * st.y) * 0.01);\n    //distFunc = step(distFunc, 0.1);\n    float y = mod((iTime * 1.1) + fbm(vec2(iTime * 0.001)), 2.2) - 1.1;\n    distFunc = min(distFunc,\n        getCircDist(st, vec2(0.3 + fbm(vec2(iTime * 0.01, y)) * 0.21, y), 0.2 + Hash(st.x + iTime) * 0.01)\n        );\n    \n    for (float i = 1.0; i <= 95.0; i += 1.0)\n    {\n        vec3 temp = rotZ(vec3(st.x, st.y, 0.), i + iTime * 0.02);\n        st = vec2(temp.x, temp.y);\n        y = y + mod(iTime * 1.1, 15.) * i;\n        distFunc = min(distFunc,\n        //getCircDist(st, vec2(-0.3 + fbm(vec2(iTime * 0.14, y)) * 0.11, y), 0.33 + Hash(st.x + iTime) * 0.015)\n                      \n        //sdBox(st + vec2(i * 0.3, 0.0), vec2(0.01 + i * 0.02, 0.2))\n        \n        \n        sdBox(vec2(mod(st.x + iTime, 1.5), st.y), vec2(0.01 + i * 0.02, 0.2))\n                       /*\n        getCircDist(st, \n                    vec2(\n                        (-0.3 * Hash(i) * 1.0) + fbm(vec2(iTime * 0.14, y)) * 0.81, \n                        y\n                    )\n                    , 0.33 * Hash(i) * 1.1 + Hash(st.x + iTime) * 0.015)//radius\n*/\n        );\n\n    }\n    \n    float circResult = (1.6 - pow(abs(distFunc), 0.15)) * 1.1;\n    color += smokeColor * circResult;\n    \n    \n    //float gamma = Smoothstep(st.y, 1.99, 8.0);\n    float gamma = 2.7;\n    color = vec3(pow(color.x, gamma), pow(color.y, gamma), pow(color.z, gamma));\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 395, 395, 499], [501, 501, 522, 522, 639], [641, 641, 667, 667, 969], [971, 971, 994, 994, 1238], [1240, 1323, 1367, 1367, 1393], [1395, 1478, 1526, 1526, 1574], [1576, 1576, 1622, 1622, 1789], [1791, 1791, 1834, 1834, 2090], [2092, 2092, 2138, 2138, 2407], [2409, 2409, 2437, 2437, 2601], [2603, 2603, 2631, 2631, 2802], [2804, 2804, 2832, 2832, 2998], [3000, 3000, 3019, 3019, 3418], [3420, 3420, 3440, 3440, 5067], [6675, 6675, 6701, 6701, 6725], [6727, 6727, 6781, 6781, 6990], [6992, 6992, 7029, 7029, 7113], [7115, 7198, 7255, 7255, 10288]], "test": "untested"}
{"id": "3llfD7", "name": "rainbow_energy_tunnel", "author": "slackmage", "description": "rainbow energy tunnel", "tags": ["tunnel"], "likes": 3, "viewed": 285, "published": 3, "date": "1596911953", "time_retrieved": "2024-07-30T20:51:59.571218", "image_code": "#define mainImage(O,C){\\\n\tfloat i,g,e,s,l;\\\n    vec3 p,q;\\\n    for(i=0.;++i<50.;){\\\n        vec3 p=g*normalize(vec3((C-.5*iResolution.xy)/iResolution.y,1))\\\n        \t+vec3(1,1,iTime);\\\n        q=p;\\\n        s=1.;\\\n        for(int j=0;j++<3;)\\\n            p=mod(p-3.,2.)-1.,\\\n            l=2./dot(p,p),\\\n            p*=l,\\\n            s*=l;\\\n        g+=e=length(p.xy)/s;\\\n        if(e<.003)break;\\\n\t}\\\n    O.xyz+=cos(q*5.3)*15./i;\\\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ttsfW4", "name": "大龙猫 - Quicky#039", "author": "totetmatt", "description": "Quicky", "tags": ["quicky"], "likes": 5, "viewed": 237, "published": 3, "date": "1596907734", "time_retrieved": "2024-07-30T20:52:00.337170", "image_code": "mat2 r(float f){\n    float c=cos(f),s=sin(f);\n    return mat2(c,s,-s,c);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5 * iResolution.xy) / iResolution.y;\n    vec2 uuv = uv;\n    uv*=r(iTime*.2+length(uv));\n    uv.x *=sign(sin(uv.y*100.));\n    uv.y *= sign(cos(uv.x*100.));\n    if(length(uuv)>.525) {\n         uv*=r(iTime*.2+length(uv));\n    uv.x *=-sign(cos(uv.y*100.));\n    uv.y *= -sign(sin(uv.x*100.));\n    }\n    float d = sin(-iTime+cos(iTime)*atan(uv.y,uv.x)+(3.*atan(uv.x,uv.y))+length(uv*10.));\n    vec3 col = smoothstep(0.1,0.01,vec3(d));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 74], [75, 75, 130, 130, 621]], "test": "untested"}
{"id": "3tlfDN", "name": "Offset Triangle Pattern", "author": "Shane", "description": "An offset triangle pattern.", "tags": ["triangle", "pattern", "offset", "zentangle"], "likes": 34, "viewed": 585, "published": 3, "date": "1596900332", "time_retrieved": "2024-07-30T20:52:01.354450", "image_code": "/*\n\n\tOffset Triangle Pattern\n\t-----------------------\n\n    Just something I coded for fun. It's an offset triangle pattern in the form \n    of an instant algorithmic Zentangle work, which completely defeats the purpose \n    of the Zentangle methodology, but here it is anyway. :)\n\t\n    The idea is pretty simple. Render an offset triangle grid, then with the minimum \n    returned triangle information, render a pattern inside it. I see this particular \n    arrangement a lot. The Zentangle crowd make things like this all the time... \n    Although, they have the benefit of hand drawing, whereas I had to make do with \n    time constraints, some rushed math and half the artistic talent. :D\n\n    You can happily ignore most of the code and just use the \"blocks\" function to\n\tobtain the required triangle information, then take it from there. I'm going\n\tto put up a few more examples along these lines. I might also put together an \n    offset triangle jigsaw pattern at some stage.\n\n\n\n\tRelated examples:\n\n\n\t// Mattz put one of these together ages ago.\n\tice and fire - mattz\n\thttps://www.shadertoy.com/view/MdfBzl\n\n\t// An offset triangle heightfield -- Very cool. I have one of these coming\n\t// that takes a different approach.\n\tTriangulated Heightfield Trick 3 - fizzer\n\thttps://www.shadertoy.com/view/ttsSzX\n\n    // An extruded offset triangle grid.\n\tExtruded Offset Triangle Grid - Shane\n\thttps://www.shadertoy.com/view/WtsfzM\n\n\n*/\n\n\n// Offsetting the triangle coordinates. The look is a lot cleaner without it.\n#define OFFSET_TRIS\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(1, 113)));\n    p = fract(vec2(262144, 32768)*n)*2. - 1.; \n    return sin(p*6.2831853 + iTime/2.); \n}\n\n// vec2 to vec2 hash.\nvec2 hash22C(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(289, 41)));\n    p = fract(vec2(262144, 32768)*n)*2. - 1.; \n    return sin(p*6.2831853 + iTime); \n}\n\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    // Cell ID and local coordinates.\n    vec2 i = floor(p); p -= i;\n    \n    // Four corner samples.\n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n    \n    // Bilinear interpolation -- Along X, along Y, then mix.\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n// Two layers of noise.\nfloat fBm(vec2 p){ return n2D3G(p)*.57 + n2D3G(p*2.)*.28 + n2D3G(p*4.)*.15; }\n\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// Triangle's incenter and radius.\nvec3 inCentRad(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    vec2 inCir = (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);   \n    \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return vec3(inCir, area/p);\n}\n\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){\n    \n    //float idm = 1. - s.x*s.y;\n    //if(idm == 0.) idm += 1e-6;\n    //mat2 inM = 1./(idm)*mat2(1, s.y, s.x, 1);\n    //return inM*p;\n    return inverse(mat2(1, -s.y, -s.x, 1))*p;\n}\n\n/*\n\n\n// Rounded triangle routine. Not used here, but handy.\nfloat sdTriR(vec2 p, vec2 v0, vec2 v1, vec2 v2){\n     \n    vec3 inC = inCentRad(v0, v1, v2);\n    float ndg = .0002/inC.z;\n    return sdTri(p, v0 - (v0 - inC.xy)*ndg,  v1 - (v1 - inC.xy)*ndg,  v2 - (v2 - inC.xy)*ndg) - .0002;      \n        \n}  \n\n// Rectangle dimentions, and consequently, the grid dimensions.\n//const vec2 rect = vec2(1.25, .8)*scale;\n//const vec2 rect = vec2(1., 1.5)*scale;\n// Equilateral dimensions: Basically, the base needs to be lengthened by\n// a factor involving sqrt(3), which easily relates back to equilateral geometry.\n//const vec2 rect = (vec2(1./.8660254, 1))*scale; // \"1/.8660254 = 2*sqrt(3)/3\". \n\n// Skewing half way along X, and not skewing in the Y direction. Skewing is \n// inversely effected by scale.\n//const vec2 sk = vec2(rect.x*.5, 0)/scale;\n// Irregular skewing is possible too, since it's all just math.\n//const vec2 sk = vec2(rect.x*.5, -rect.y*.25)/scale;\n\n// From the the following example:\n// Random Delaunay Triangulation - Tomkh\n// https://www.shadertoy.com/view/4sKyRD\n//\n// Use \"parabolic lifting\" method to calculate if two triangles are about to flip.\n// This is actually more reliable than circumscribed circle method.\n// The technique is based on duality between Delaunay Triangulation\n// and Convex Hull, where DT is just a boundary of convex hull\n// of projected seeds onto paraboloid.\n// We project (h1 h2 h3) triangle onto paraboloid\n// and return the distance of the origin\n// to a plane crossing projected triangle.\nfloat flipDistance(vec2 h1, vec2 h2, vec2 h3){\n\n   // Projects triangle on paraboloid.\n   vec3 g1 = vec3(h1, dot(h1, h1));\n   vec3 g2 = vec3(h2, dot(h2, h2));\n   vec3 g3 = vec3(h3, dot(h3, h3));\n   // Return signed distance of (g1, g2, g3) plane to the origin.\n   //#if FLIP_ANIMATION\n    // return dot(g1, normalize(cross(g3-g1, g2-g1)));\n   //#else\n     // If we don't do animation, we are only interested in a sign,\n     // so normalization is unnecessary.\n   \t return dot(g1, cross(g3-g1, g2-g1));\n   //#endif\n}\n*/\n\n// Global vertices, local coordinates, etc, of the triangle cell.\nstruct triS{\n    \n    vec2[3] v; // Outer vertices.\n    vec2 p; // Local coordinate.\n    vec2 id; // Position based ID.\n    float dist; // Distance field value.\n    float triID; // Triangle ID.\n};\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\ntriS blocks(vec2 q){\n    \n\n    const float tf = 2./sqrt(3.);\n    // Scale.\n\tconst vec2 scale = vec2(tf, 1)*vec2(1./4.);\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n     // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(tf/2., 0);\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual block ID and block center.\n    vec2 id = vec2(0), cntr;\n    \n    // For block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    float triID = 0.; // Triangle ID. Not used in this example, but helpful.\n\n\n    // Height scale.\n    const float hs = .5;\n\n\n    // Initializing the global vertices and local coordinates of the triangle cell.\n    triS gT, tri1, tri2;\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2. -  ps4[0];\n        // Skewed local coordinates.\n        p = skewXY(q.xy, sk);// - cntr*s;\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n       \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Skewed rectangle vertices. \n        vec2[4] vert = ps4;  \n     \n        #ifdef OFFSET_TRIS\n        // Offsetting the vertices.\n        vert[0] += hash22B((idi + vert[0]/2.))*.2;\n   \t\tvert[1] += hash22B((idi + vert[1]/2.))*.2;\n        vert[2] += hash22B((idi + vert[2]/2.))*.2; \n        vert[3] += hash22B((idi + vert[3]/2.))*.2;\n        #endif\n        \n        \n        // Unskewing to enable rendering back in normal space.\n        vert[0] = unskewXY(vert[0]*dim, sk);\n        vert[1] = unskewXY(vert[1]*dim, sk);\n        vert[2] = unskewXY(vert[2]*dim, sk);\n        vert[3] = unskewXY(vert[3]*dim, sk); \n        \n         \n        // Unskewing the rectangular cell ID.\n\t\tidi = unskewXY(idi*s, sk);  \n  \n      \n        // Some triangle flipping to ensure a Delaunay triangulation... Further non-Delaunay\n        // subdivisions will occur, so it's probably redundant, but it's here for completeness.\n        //float f = flipDistance(vert[0] - vert[2], vert[1] - vert[2], vert[3] - vert[2])<0.? 1. : -1.;\n \n        \n        // Partioning the rectangle into two triangles.\n        \n        \n        // Triangle one.\n        tri1.v = vec2[3](vert[0], vert[1], vert[2]); \n         //if(f>.5) tri1.v = vec2[3](vert[0], vert[1], vert[3]); // Delaunay flipping.\n        tri1.id = idi + inCentRad(tri1.v[0], tri1.v[1], tri1.v[2]).xy; // Position Id.\n        tri1.triID = float(i); // Triangle ID. Not used here.\n        tri1.dist = sdTri(p, tri1.v[0], tri1.v[1], tri1.v[2]); // Field distance.\n        tri1.p = p; // 2D coordinates.\n         \n        // Triangle two.\n        tri2.v = vec2[3](vert[0], vert[2], vert[3]);\n        //if(f>.5) tri2.v = vec2[3](vert[1], vert[2], vert[3]);  // Delaunay flipping.\n        tri2.id = idi + inCentRad(tri2.v[0], tri2.v[1], tri2.v[2]).xy; // Position Id.\n        tri1.triID = float(i + 4); // Triangle ID. Not used here.\n        tri2.dist = sdTri(p, tri2.v[0], tri2.v[1], tri2.v[2]); // Field distance.\n        tri2.p = p; // 2D coordinates.\n         \n        // Doesn't work, unfortunately, so I need to write an ugly \"if\" statement.\n        //triS gTi = tri1.dist<tri2.dist? tri1 : tri2;\n        triS gTi; \n        // Obtain the closest triangle information.\n        if(tri1.dist<tri2.dist) gTi = tri1; \n        else gTi = tri2;\n        \n        \n        // If applicable, update the overall minimum distance value,\n        // then return the correct triangle information.\n        if(gTi.dist<d){\n            d = gTi.dist;\n            gT = gTi;\n            //gT.id = idi + inCentRad(gT.v[0], gT.v[1], gT.v[2]).xy;\n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return gT;\n}\n\n/*\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n\n    \n}\n\n*/\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*24.;\n    q += vec2(n2D3G(p*1.5), n2D3G(p*1.5 + 7.3))*.1;\n    q *= rot2(-3.14159/2.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.);\n    float ns2 = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    ns2 = gr - ns2;\n    q *= rot2(-3.14159/5.);\n    float ns3 = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    ns3 = gr - ns3;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    ns = smoothstep(0., 1., min(min(ns, ns2), ns3) + .6); // Rough pencil sketch layer.\n    //\n    // Mix in a small portion of the pencil sketch layer with the clean colored one.\n    //col = mix(col, col*(ns + .3), .5);\n    // Has more of a colored pencil feel. \n    //col *= vec3(.8)*ns + .4;    \n    // Using Photoshop mixes, like screen, overlay, etc, gives more visual options. Here's \n    // an example, but there's plenty more. Be sure to uncomment the \"softLight\" function.\n    //col = softLight(col, vec3(ns)*.75);\n    // Uncomment this to see the pencil sketch layer only.\n    //if(mod(ip.x + ip.y, 2.)<.5) \n    // Grayscale override.\n    \n    col = vec3(ns); \n    \n \n    \n    return col;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Resolution and aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes; \n    \n    // Warping the background ever so slightly. The idea is that\n    // pencil drawings don't have perfectly straight lines.\n    uv += vec2(fBm(uv*12.), fBm(uv*12. + .5))*.005;\n    \n    \n    // Unit direction vector. Used for some mock lighting.\n    vec3 rd = normalize(vec3(uv, .5));\n    \n    // Scaling and translation.\n    const float gSc = 1.;\n    vec2 p = uv*gSc;// + vec2(0, iTime/24.);\n    vec2 oP = p; // Saving a copy for later.\n    \n    // Resolution and scale based smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    \n    // Take a function sample. \n    triS gT = blocks(p);\n    \n \n    // Triangle vertices, local coordinates and position-based ID.\n    // With these three things, you can render anything you want.\n    vec2[3] svV = gT.v;\n    vec2 svP = gT.p;\n    vec2 svID = gT.id;\n\n    \n    // Initializing the scene color to black.\n    vec3 col = vec3(0);  \n     \n    // Triangle color.\n    vec3 tCol = vec3(0);\n    \n    \n  \n    // Bottom layer color, or shade.\n    vec3 lCol = vec3(.05);\n     \n    \n    \n    // The triangle pattern: Render three wedged triangles with vertex points\n    // at each line edge extreme and a third point on the adjacent tangential\n    // edge (look at the top layer for a visual). Slide the adjacent edge\n    // point back a bit, then render another layer. If you do this a few times,\n    // a triangular spiral pattern will appear. You can add to the effect by\n    // coloring and shading according to layer depth.\n    //\n    // The following is just the way I chose to effect the aforementioned, but \n    // there'd no doubt be better ways to go about it, so how you achieve the \n    // same is up to you.\n    //  \n    vec3 triPat = vec3(1e5);\n    \n    vec2[3] v = svV;\n    \n    vec2 rp = svP;\n    //rp = rot2(iTime)*rp;\n  \n    // Start and end nudge factors. The third point needs to be moved along\n    // a tangent edge. The further out it is, the more the triangles \n    // appear to rotate.\n    \n  \n    float nfs = .45, nff = .07;\n    const int iter = 4; // Iterations.\n    for(int i = 0; i<iter; i++){\n        \n        // Normalized edge tangent vectors.\n        vec2[3] tng = vec2[3](normalize(v[1] - v[0]), normalize(v[2] - v[1]),\n                           normalize(v[0] - v[2])); \n        \n        lCol *= 1.8; // Increase the color for each layer.\n        \n        // Interpolate the nudge point factor.\n        float nf = mix(nfs, nff, float(i)/float(iter));\n\n        // Three side triangles for this particular layer, which consist of \n        // two vertices and a third point that slides out from the adjoining\n        // side... Just refer to the outer layer for a visual reference.\n        \n        vec2 atp; // Third, adjacent tangential edge point.\n        float ndg;\n        \n        // Edge one triangle.\n        ndg = length(v[2] - v[1])*nf; // Nudge length (decreasing each iteration).\n        atp = v[1] + tng[1]*ndg; // Adjacent tangential edge point.\n        triPat[0] = sdTri(rp, v[0], v[1], atp); // Wedge triangle for this edge.\n \n        // Edge two triangle.\n        ndg = length(v[0] - v[2])*nf;\n        atp = v[2] + tng[2]*ndg;\n        triPat[1] = sdTri(rp, v[1], v[2], atp);\n        //vec2 nw1 = p2;\n\n        // Edge three triangle.\n        ndg = length(v[1] - v[0])*nf;\n        atp = v[0] + tng[0]*ndg;\n        triPat[2] = sdTri(rp, v[2], v[0], atp);\n       \n        // Rotated sprinkled noise for this layer.\n        mat2 r2 = rot2(3.14159*float(i)/float(iter));\n        float nsl = fBm((r2*(svP - svID.xy))*64.)*.5 + .5;//mix(tx, tx2, .8);\n    \n        // Fake shading and noise application.\n        float sh = float(iter - i - 1)/float(iter);\n        lCol = vec3(1)*1./(1. + sh*sh*2.5);\n        lCol *= nsl*.5 + .5;\n        \n        // Failed experiment with color.\n        //if((i&1)==0) lCol *= vec3(2, 0, 0);\n        \n        // Rendering the three triangle wedges to each side.\n        for(int j = 0; j<3; j++){\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., triPat[j] - .002))*.5);\n            col = mix(col, vec3(0), 1. - smoothstep(0., sf*2., triPat[j]));// + .005/3.\n            col = mix(col, lCol, 1. - smoothstep(0., sf*2., triPat[j] + .0035));// .005*2./3.\n        }\n        \n    }\n    \n    // Outer layer noise. This is applied to the border cords and points.\n    float ns = fBm((svP - svID.xy)*64.)*.5 + .5;\n \n    // Outside lines.\n    float ln = 1e5;\n    ln = min(ln, lBox(svP, svV[0], svV[1], 0.));\n    ln = min(ln, lBox(svP, svV[1], svV[2], 0.));\n    ln = min(ln, lBox(svP, svV[2], svV[0], 0.));\n    ln -= .0055; \n     \n    \n    lCol = vec3(ns*.5 + .5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4.*iRes/450., ln - .002))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., ln)));\n    col = mix(col, lCol*clamp(-ln/.005, 0., 1.), (1. - smoothstep(0., sf, ln + .0035)));  \n     \n    \n    // Vertices.\n    vec3 cir = vec3(length(svP - svV[0]), length(svP - svV[1]), length(svP - svV[2]));\n    float verts = min(min(cir.x, cir.y), cir.z);\n    verts -= .016;\n \n    vec3 vCol = lCol*.7;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5.*iRes/450., verts))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .005, verts)));  \n    col = mix(col, vCol, (1. - smoothstep(0., sf, verts + .0035))); \n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, verts + .011))); // Pin staple hole. \n    \n    \n    // Slight pencil effect: Based on Flockaroo's pencil effect, which is far superior, so\n    // I'd definitely refer to that one, if you're interested in that kind of thing.\n    col = mix(col, pencil(col, oP), .5);\n    \n    // Applying a touch of color. It's a design cliche, but it works.\n    col = mix(col, col*vec3(1, .05, .1)/.7, (1. - smoothstep(0., sf, verts)));\n   \n  \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625)*1.05;\n    // Colored variation.\n    //col = mix(col*vec3(.25, .5, 1)/8., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n    \n\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlfDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1537, 1570, 1592, 1592, 1650], [1653, 1681, 1702, 1702, 1765], [1768, 1790, 1812, 2161, 2292], [2294, 2316, 2338, 2687, 2816], [2819, 2860, 2885, 2927, 3373], [3375, 3399, 3417, 3417, 3476], [3480, 3522, 3581, 3581, 4161], [4164, 4195, 4228, 4228, 4315], [4317, 4556, 4601, 4601, 4764], [4766, 4801, 4843, 4869, 5148], [5151, 5214, 5242, 5242, 5286], [5288, 5353, 5383, 5521, 5569], [12854, 12854, 12884, 13649, 15515]], "test": "untested"}
{"id": "WtlfDM", "name": "FrameStella - forked", "author": "alvarobyrne", "description": "The intersections of the sides of two tetrahedra in this layout lie in the vertices of a octahedron? And in this layout, the vertices of the tetrehedra lie on the vertices of a cube? Fork of \"FrameStella\" by gaz. https://shadertoy.com/view/3llBzN", "tags": ["cube", "tetrahedra", "tetrahedron", "octahedron", "stella"], "likes": 6, "viewed": 292, "published": 3, "date": "1596896615", "time_retrieved": "2024-07-30T20:52:02.222130", "image_code": "// Fork of \"FrameStella\" by gaz. https://shadertoy.com/view/3llBzN\n// 2020-08-08 14:15:50\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat deFrameStella(vec3 p){\n    p = abs(p)-1.;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    return length(cross(p,normalize(vec3(0,1,1))))-0.05;\n}\n\nfloat map(vec3 p){\n    return deFrameStella(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\tvec3 p,\n\tro=vec3(0,0,-4),\n\trd=normalize(vec3(uv,2));\n\tfloat h=0.,d,i,zoom = 1.1;\n\tro*=zoom;\n\tfor(i=1.;i<50.;i++){\n\t\tp=ro+rd*h;\n\t\tp/=zoom;\n\t\t//p.xy*=rot(iTime*.6);\n\t\t//p.yz*=rot(iTime*0.2);\n\t\tp.zy*=rot(iTime*0.1);\n\t\td=map(p);\n\t\tif(d<0.0001)break;\n\t\th+=d;\n\t}\n\tfragColor.xyz+=10./i;  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlfDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 173, 173, 347], [349, 349, 367, 367, 398], [400, 400, 457, 457, 801]], "test": "untested"}
{"id": "ttfBD7", "name": "Psychedelic rings", "author": "ChocolatePinecone", "description": "A hypnotising exercise practicing glsl programming with the book of shaders", "tags": ["rings", "psychedelic"], "likes": 1, "viewed": 281, "published": 3, "date": "1596876561", "time_retrieved": "2024-07-30T20:52:03.085821", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st = fragCoord.xy/iResolution.xy;\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st * 2.0 - 1.0;\n\n  // Make the distance field\n  d = length( abs(st) - 0.2 );\n\n  \n  color = vec3(fract(d*10.0 - iTime));\n  color *= sin(d * 20.0 - iTime);\n\n  // Visualize the distance field\n  fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 451]], "test": "untested"}
{"id": "wlXfW7", "name": "polkaTunnel0", "author": "pohy", "description": "polkaTunnel0", "tags": ["polkatunnel0"], "likes": 3, "viewed": 248, "published": 3, "date": "1596872172", "time_retrieved": "2024-07-30T20:52:03.945522", "image_code": "#define PI 3.14159\n\nfloat getFreq(float freq) {\n    int tx = int(freq / 22000. * 512.);\n    return texelFetch(iChannel0, ivec2(tx, 0), 0).r;\n}\n\nfloat getBand(float freq, float width) {\n    float avg = 0.;\n    float it = width / freq;\n    for (float i = 0.; i < it; i++) {\n        avg += getFreq(freq * i);\n    }\n    return avg;\n}\n\nvec2 toLogPolar(vec2 uv) {\n    return vec2(log(length(uv)), atan(uv.y, uv.x));\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float t = iTime * .1;\n    vec3 col = vec3(0);\n    \n    float snare = getFreq(5000.);\n    \n    uv *= 6. + (sin(t) * 3.);\n    uv = fract(abs(uv));\n    uv = toLogPolar(uv);\n    uv.x -= t + snare * .1;\n    uv *= 6. / PI;\n    uv = fract(uv) - .5;\n    \n    float r = .25 + getFreq(80.) * .2;\n    float dist = length(uv);\n    float delta = fwidth(dist);\n    float c = smoothstep(r * 1.01, r - delta, dist);\n    vec3 color = mix(vec3(.8, .8, .5), vec3(.2, .2, .8), snare);\n    col += c;//vec3(.8 + (snare * .2), .8 - (snare * .2), .5 - (snare * .2));\n    //col.rg = id;\n    //col += getFreq(60.);\n    //col.rg += uv;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXfW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 47, 47, 142], [144, 144, 184, 184, 329], [331, 331, 357, 357, 411], [413, 413, 432, 432, 508], [510, 510, 567, 567, 1324]], "test": "untested"}
{"id": "wtffDM", "name": "Triange Fade", "author": "cold_code", "description": "Remix of Triange Trip. Changed colors, more structured.\nhttps://www.shadertoy.com/view/MtdBz2", "tags": ["procedural", "triangle", "varonoi"], "likes": 10, "viewed": 368, "published": 3, "date": "1596858044", "time_retrieved": "2024-07-30T20:52:04.964797", "image_code": "// The MIT License\n// Copyright © 2020 Patryk Ozga\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions: The above copyright\n// notice and this permission notice shall be included in all copies or\n// substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",\n// WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n// THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define scale 10.\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 randPt(vec2 co) {\n  float f1 = rand(co);\n  float f2 = rand(co * f1);\n  return vec2(f1 * .8 + .1, f2 * .8 + .1);\n}\n\nvec2 sqPoint(vec2 sq) {\n  //float time = 2. * iTime + 1.;\n  //time = 2.;\n  //vec2 curPt = randPt(floor(sq) * floor(time));\n  //vec2 nextPt = randPt(floor(sq) * floor(time + 1.));\n  //return fract(time) * (nextPt - curPt) + curPt;\n    if(mod(floor(sq.y),2.) == 0.){\n  \t\treturn vec2(.5, .1 + .8*abs((floor(sq.x)-cos(iTime))/scale));\n    }\n    else{\n        return vec2(.5,.1 + .4*(1.+cos(2.*3.14*fract(iTime/5.)))*abs(floor(sq.y))/scale);\n    }\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\nfloat distToShade(float d) {\n  float time = (1. + .3 * cos(3. * iTime));\n  //time = 1.;\n  return smoothstep(0.01, 1., 1. / (100. * time * d));\n}\n\nfloat cross2d(vec2 u, vec2 v) { return u.x * v.y - u.y * v.x; }\n\nfloat triArea(vec2 a, vec2 b, vec2 c) { return cross2d(b - a, c - a) / 2.; }\n\nconst vec3[4] palette = vec3[4](vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n\nconst float _2PI = 6.28318;\n\nvec3 pal(in float t, in vec3[4] pal) {\n    t *= 2.4;\n    t += iTime/10.;\n  return pal[0] + pal[1] * cos(_2PI * (pal[2] * t + pal[3]));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.x;\n\n  //float scale = 10.;//= 1.25 *(pow(sin( iTime/8.) + 4., 1.5));\n  //scale = 2.;\n  vec2 sq = uv * scale;\n  vec2 uvSq = fract(sq);\n  vec2 sqPt = sqPoint(sq);\n  float c = 0.;\n  vec3 col = vec3(0.);\n  vec2[] offsets = vec2[](vec2(-1, -1), vec2(-1, 0), vec2(0, 1), vec2(1, 1),\n                          vec2(1, 0), vec2(0, -1)\n                          // vec2(-1, 1),\n                          // vec2(0, 0),\n                          // vec2(1, -1),\n  );\n\n  vec2 sqPtLast = sqPoint(sq + offsets[5]) + offsets[5];\n  for (int i = 0; i < 6; ++i) {\n    vec2 off = offsets[i];\n    vec2 sq2 = sq + off;\n    vec2 sqPt2 = sqPoint(sq2) + off;\n\n    //vec2 triCenter = (sqPt2 + sqPtLast + sqPt) / 3.;\n\n    float a = triArea(sqPt, sqPt2, sqPtLast);\n    //col.g += smoothstep(.1, 0., length(triCenter - uvSq));\n    float r1 = cross2d(uvSq - sqPt, sqPtLast - sqPt);\n    float r2 = cross2d(sqPt2 - sqPt, uvSq - sqPt);\n    \n      r1 = smoothstep(0., .001, r1);\n    r2 = smoothstep(0., .001, r2);\n    col += r1 * r2 * pal(a, palette);\n\n    float d = sdLine(uvSq, sqPt, sqPt2);\n    c += distToShade(d);\n\n    sqPtLast = sqPt2;\n  }\n\n  vec2[] diagOffsets = vec2[](vec2(-1, 0), vec2(0, 1),\n                              // vec2(-1, 0), vec2(0, -1),\n                              // vec2(1, 0), vec2(0, 1),\n                              vec2(1, 0), vec2(0, -1));\n  for (int i = 0; i < 4; i += 2) {\n    vec2 off1 = diagOffsets[ i];\n    vec2 sq1 = sq + off1;\n    vec2 sqPt1 = sqPoint(sq1) + off1;\n    vec2 vPt1 = sqPt1 - uvSq;\n\n    vec2 off2 = diagOffsets[ i + 1];\n    vec2 sq2 = sq + off2;\n    vec2 sqPt2 = sqPoint(sq2) + off2;\n\n    vec2 off3 = vec2(off1.x, off2.y);\n    vec2 sq3 = sq + off3;\n    vec2 sqPt3 = sqPoint(sq3) + off3;\n\n    float a = triArea(sqPt1,sqPt2, sqPt3);\n    \n    float r1 = cross2d(uvSq - sqPt2, sqPt1 - sqPt2);\n    float r2 = smoothstep(.01, 0., r1);\n    r1 = smoothstep(0., .001, r1);\n    col *= r2;\n    col += r1*pal(a, palette);\n\n    float d = sdLine(uvSq, sqPt1, sqPt2);\n    c += distToShade(d);\n  }\n\n  col -= vec3(c);\n  fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtffDM.jpg", "access": "api", "license": "mit", "functions": [[1135, 1135, 1156, 1156, 1227], [1229, 1229, 1251, 1251, 1347], [1349, 1349, 1372, 1578, 1793], [1795, 1795, 1842, 1842, 1961], [1963, 1963, 1991, 1991, 2107], [2109, 2109, 2140, 2140, 2172], [2174, 2174, 2213, 2213, 2250]], "test": "untested"}
{"id": "ltcBz4", "name": "Cool Pattern Thingy", "author": "croebot", "description": "Cool Pattern Thingy", "tags": ["patterns"], "likes": 2, "viewed": 262, "published": 3, "date": "1596834757", "time_retrieved": "2024-07-30T20:52:05.828488", "image_code": "// Fork of \"patterns-001\" by zwwgggbest. https://shadertoy.com/view/lltczB\n// 2018-10-05 15:03:56\n\n#define PI 3.141592653\n\nvec2 rotate2D(vec2 _uv, float _angle) \n{\n\tmat2 rotate = mat2(cos(_angle), -sin(_angle),\n        \t\t   sin(_angle), cos(_angle));\n    \n    _uv -= .5;\n    _uv = rotate * _uv;\n    _uv += .5;\n    \n    return _uv;\n}\n\nfloat box(vec2 _uv, vec2 _size, float _smoothEdge)\n{\t\n\t_size = vec2(.5) - _size * .5;\n    float aa = _smoothEdge * .5;\n    vec2 ret = smoothstep(_size, _size + vec2(aa), _uv);\n    ret *= smoothstep(_size, _size + vec2(aa), 1. - _uv);\n    return ret.x*ret.y;\n}\n\nfloat patterns1(vec2 _uv, vec2 _size, float _smoothEdge, float cnt, float t)\n{\n\t_uv *= cnt;\n    _uv = fract(_uv);\n    _uv = rotate2D(_uv, PI * t);\n   \n    return box(_uv, _size, _smoothEdge);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    float t = iTime; \n    float sz = iTime*.1;\n  \tcol += vec3(patterns1(uv, vec2(.7), .01, 5., cos(t) ) );\n  \tcol -= vec3(patterns1(uv, vec2(.7), .01, 10., 1. - floor(t)*.1 ));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcBz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 163, 163, 332], [334, 334, 386, 386, 593], [595, 595, 673, 673, 788], [790, 790, 847, 897, 1308]], "test": "untested"}
{"id": "3tfBW7", "name": "6. Animation Face", "author": "altera0", "description": "source : https://www.youtube.com/watch?v=vlD_KOrzGDc\n\nsimple onet : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect\n", "tags": ["animationface"], "likes": 1, "viewed": 214, "published": 3, "date": "1596827841", "time_retrieved": "2024-07-30T20:52:06.695171", "image_code": "\n\n#define S(a , b , t ) smoothstep( a , b , t )\n#define sat(x) clamp( x, 0.0f , 1.0f )\n\n\n// -------------------------------------------------\n// 리맵01\n// -------------------------------------------------\nfloat remap01 ( float a , float b , float v ) {\n\t// 이게 단순히 비율을 구하는 것 뿐만이 아니라,\n    // 로컬 좌표를 , ( 0 ~ 1)의 월드 UV로 사상시키는 의미도 담고 있다.\n    return sat( ( v - a ) / ( b - a ) );\n}\n\n// -------------------------------------------------\n// 리맵\n// -------------------------------------------------\nfloat remap( float a , float b , float c , float d , float value ) {\n    //return (value - a) / ( b - a ) * ( d - c ) + c;\n    return remap01( a , b , value ) * ( d - c ) + c;\n}\n\n// -------------------------------------------------\n// within함수 ( 리맵 01 함수의 vec2 버젼이다. )\n// -------------------------------------------------\nvec2 within( vec2 uv , vec4 rect ) {\n\t// remap01과 마찬가지로, UV를 사상 시키는 의미를 담고 있다.\n    return ( uv - rect.xy ) / ( rect.zw - rect.xy );   \n}\n\n\n\n// -------------------------------------------------\n// 눈\n// -------------------------------------------------\nvec4 Eye( vec2 uv, float side , vec2 mUv ) {\n    // 이미 uv가 넘어 올때, 어떤 구역 [ ~ ] 안에서 사상되어 있는 상태이다.\n    // within 함수에서 이미 계산되어 있는 상태이다.\n    // 즉 자기 자신의 중점을 ( 0 , 0 )으로 생각하고 자기 자신만 계산하면 된다.\n    \n\tuv -= 0.5f;\n    \n    // flip Side\n    uv.x *= side;\n    \n    float d = length(uv);\n\n    \n    vec4 irisCol = vec4( 0.3f, 0.5f, 1.0f , 1.0f );\n    \n    // 눈의 전체 동그라미\n    vec4 col = mix( vec4(1.0f) , irisCol , S( 0.1f , 0.7f , d ) * 0.5f );\n    \n    // 눈동자 전체의 감싸는 동그라미\n    // 뒷쪽의 sat는 그림자까지 표시해주기 위한 테크닉이다.\n    col.rgb *= 1.0f - S(0.45, 0.5f , d ) * 0.5f * sat ( -uv.y - uv.x * side ); // 중점에서 0.5이상 떨어진 곳만 둥글게 만든다.\n    \n    \n    d = length( uv - mUv * 0.5f );\n    \n    \n    // 눈동자 검은색 부분\n    col.rgb = mix( col.rgb , vec3(0.0f), S(0.3f , 0.28f, d ) );\n    \n    \n\n    // 눈동자 파란색 부분\n    irisCol.rgb *= 1.0f + S(0.3f, 0.05f, d );\n    \n    \n    \n    col.rgb = mix( col.rgb , irisCol.rgb , S( 0.28f, 0.25f , d ) );\n    \n         \n    d = length( uv - mUv * 0.7f );\n\n\t// 눈동자 파란색 부분 안의 다시 검은 부분    \n    col.rgb = mix( col.rgb ,vec3(0.0f) , S( 0.16f, 0.14f , d ) );\n\n    \n\n    \n    // eys High Light\n    float highLight = S( 0.1f , 0.09f , length( uv -vec2(-0.15f, 0.15f)));\n    highLight += S( 0.07f , 0.05f , length( uv + vec2( -0.08, 0.08 )));\n    \n    col.rgb = mix( col.rgb, vec3(1.0f), highLight );\n    col.a = S( 0.5f , 0.45f , d );\n    \n    \n    return col;\n}\n\n// -------------------------------------------------\n// 눈썹\n// -------------------------------------------------\nvec4 Brow( vec2 uv ) {\n    float y = uv.y;\n    uv.y += uv.x * 0.8 -0.3f;\n    \n    uv.x -= 0.1f;\n    uv -= 0.5f;\n    \n    vec4 col = vec4(0.0f);\n    \n    float blur = 0.1f;\n    \n    float d1 = length(uv);\n    float s1 = S(0.45f, 0.45f-blur , d1 );\n    float d2 = length( uv - vec2(0.1f, -0.2f) * 0.7f );\n    float s2 = S( 0.5f , 0.5-blur, d2 );\n    \n    \n    float browMask = sat( s1 - s2 );\n    \n    float colMask = remap01( 0.7f, 0.8f, y ) * 0.75f;\n    colMask *= S(0.6f, 0.9f, browMask);\n    //vec4 browCol = mix( vec4( 0.4f, 0.2f, 0.2f, 1.0f ), vec4(0.0f, 0.0f, 0.0f, 1.0f) , browMask );\n    \n    // 만드는 중간 과정을 보여주지 않는다면, \n    // 이런식의 단순 숫자 나열은 의미 없다.\n    return vec4(0);\n    \n}\n\n\n// -------------------------------------------------\n// 입\n// -------------------------------------------------\nvec4 Mouth( vec2 uv ) {\n    uv -= 0.5f;\n    vec4 col = vec4( 0.5f, 0.18f, 0.05f, 1.0f );\n    \n    uv.y *=1.5f;\n    uv.y -= uv.x * uv.x * 2.0f;\n    \n    float d = length(uv );\n    col.a = S( 0.5f , 0.48f, d );\n    \n    float td = length( uv - vec2(0.0f, 0.6f));\n\n    // 이빨에 약간의 다크 셰도우를 준다.\n    vec3 toothCol = vec3(1.0f) * S( 0.6f , 0.35f ,d );\n    \n    \n    // 거리에 따른 이빨의 색깔 합성.\n    col.rgb = mix( col.rgb, toothCol , S(0.4f, 0.37f ,td ) );\n    \n    // 혀\n    td = length(uv + vec2(0.0f, 0.5f ));\n    col.rgb = mix( col.rgb, vec3(1.0f, 0.05f, 0.05f ), S(0.5f, 0.2f,td));\n    \n    \n    return col;\n}\n\n// -------------------------------------------------\n// 머리\n// -------------------------------------------------\nvec4 Head( vec2 uv ) {\n \tvec4 col = vec4(0.9f , 0.65f, 0.1f, 1.0f);\n    \n    float d = length(uv);\n    \n    col.a = S(0.5f , 0.49f , d );\n    \n    \n    // 중심에서 시작해서 끝으로 갈수록 떨어지는 Fall Off\n    float edgeShader = remap01( 0.35f , 0.5f , d );\n    edgeShader = edgeShader * edgeShader;\n    col.rgb *= 1.0f -  edgeShader * 0.5f;\n    \n    \n    // 외곽선 테두리 ( 이건 자기가 찾아 놓은 값 대입 한 것 )\n    col.rgb = mix( col.rgb, vec3(0.6f, 0.3f, 0.1f), S(0.47f ,0.48f , d) );\n\n    \n    // 하이라이트\n    float highlight = S(0.41f, 0.405f, d );\n    highlight *= remap( 0.41f , -0.1f , 0.75f , 0.0f , uv.y );\n    highlight *= S( 0.18f, 0.19f, length( uv-vec2(0.21f, 0.07f)));\n    \n    col.rgb = mix( col.rgb, vec3(1.0f), highlight );\n    \n    // 오른쪽 볼 하이라이트\n    d = length( uv - vec2(0.25f, -0.2f) );\n    float cheek = S(0.2f, 0.01f, d ) * 0.4f;\n    cheek *= S(0.17f, 0.16f , d );\n    \n    \n    col.rgb = mix( col.rgb, vec3(1.0f,0.1f , 0.1f), cheek );\n    \n    \n    \n    return col;\n}\n\n\n// -------------------------------------------------\n// 얼굴\n// -------------------------------------------------\nvec4 Smiley( vec2 uv, vec2 mUv) {\n    vec4 col = vec4(0);\n    \n    float side = sign( uv.x );\n    \n    // 이게 좌우 대칭을 만들어 준다.\n    uv.x = abs( uv.x );\n    \n    vec4 head = Head(uv);\n    \n    // 여기에서 눈의 uv를 리맵화 한다. 인간이 알아 보기 쉽도록\n    vec4 eye = Eye( within( uv, vec4( 0.03, -0.1f , 0.35f , 0.25f) ) , side ,mUv );\n    vec4 mouth = Mouth( within( uv, vec4( -0.3f, -0.4f, 0.3f, -0.1f) ) );\n    vec4 brow = Brow( within( uv, vec4(0.03f, 0.2f , 0.4f, 0.45f ) ));  \n    \n    // 이거 섞어주는 순서가 중요하다.\n    col = mix( col , head , head.a ); // 헤드의 알파값으로 섞는다.\n    col = mix ( col , eye , eye.a );\n    col = mix ( col, mouth, mouth.a );\n\tcol = mix ( col , brow, brow.a );\n    \n    return col;\n}\n\n    \n// -------------------------------------------------\n// 메인\n// -------------------------------------------------\nvoid mainImage( out vec4 fragColor , in vec2 fragCoord ) {\n \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    // mouse uv\n    vec2 mUv = iMouse.xy / iResolution.xy;\n    mUv -= 0.5f;\n    \n    \n\tfragColor = Smiley(uv,mUv );    \n    \n    //fragColor =  vec4(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfBW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 207, 254, 412, 455], [457, 573, 641, 695, 750], [752, 917, 953, 1033, 1091], [1095, 1208, 1252, 1524, 2871], [2873, 2989, 3011, 3011, 3732], [3735, 3848, 3871, 3871, 4499], [4501, 4617, 4639, 4639, 5671], [5674, 5790, 5823, 5823, 6581], [6588, 6704, 6762, 6762, 7038]], "test": "untested"}
{"id": "WlXfW7", "name": "Noise Normalization", "author": "ruojake", "description": "My technique for restoring contrast in noise with any number of octaves. Useful when you really need your noise to hit 0 and 1 consistently. Number of octaves and persistence per octave are modulated by time. Right side normalized.", "tags": ["noise"], "likes": 2, "viewed": 286, "published": 3, "date": "1596825654", "time_retrieved": "2024-07-30T20:52:07.555869", "image_code": "// Noise Normalization by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// The technique is at row 56, rest is your normal noise stuff.\n// I came up with this thing via trial and error in desmos\n// so it may well be that there's some named, established and\n// well defined math in play that I'm simply unaware of.\n// If so, feel free to educate me in the comments!\n\nfloat oct;\nfloat per;\n\nfloat hash12(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(1.433, 1.512))) * 4313.441);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 i = floor(p);\n    vec2 f = smoothstep(0.,1.,p-i);\n    const vec2 o = vec2(1.,0.);\n    \n    return mix(mix(hash12(i),hash12(i+o),f.x),\n               mix(hash12(i+o.yx),hash12(i+1.),f.x),\n               f.y);\n}\n\nfloat fbm(vec2 p)\n{\n    float res = 0.;\n    float a = 1.;\n    for(float i = 1.; i <= oct; i += 1.)\n    {\n    \tres += noise(p) * a;\n        a *= per;\n        p *= 2.;\n        p += 100.;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    oct = floor(fract(iTime / 48.) * 6. + 1.);\n\tper = fract(iTime * .125) * .9 + .05;\n\n    float comp = (1.-per)/(1.-pow(per,oct));\n    float n = fbm(uv * 10. - vec2(iTime * .1, 0.)) * comp;\n    \n\t// here's the interesting bit\n    if (uv.x > 0.)\n    {\n    \tn = clamp(\n            (1. + per * log(oct))\n            * (n - .5) + .5,\n            0., 1.);\n        // clamping is kinda optional here \n        // but the value does occasionally cross beyond 0-1 range\n    }\n\n    vec3 col = vec3(n);\n    \n    if (uv.y < 0.)\n    {\n    \tcol = mix(vec3(1,0,0),vec3(0,0,1), n);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXfW7.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[437, 437, 459, 459, 520], [522, 522, 543, 543, 759], [761, 761, 780, 780, 969], [971, 971, 1028, 1028, 1699]], "test": "untested"}
{"id": "3lXfW7", "name": "Energy Explosion", "author": "Leria", "description": "Now, what if I combine my shaders Energy Transfer and 3D Shockwave Effect\nYou can rotate it !", "tags": ["noise", "raymarch", "sun", "shockwave", "energy", "transfer"], "likes": 6, "viewed": 589, "published": 3, "date": "1596824763", "time_retrieved": "2024-07-30T20:52:08.594093", "image_code": "// Fork of \"3D Shockwave Effect faster\" by Leria. https://shadertoy.com/view/3lXfRH\n// 2020-08-04 08:57:53\n\n// Fork of \"3D Shockwave Effect\" by Leria. https://shadertoy.com/view/wtlBRn\n// 2020-07-28 10:39:36\n\n//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.1\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t0\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nfloat anim = 0.;\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1.,  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  .6 );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif    \n    \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 6.), m.pos); \n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    int s = 0;\n    \n    for(s; s <140; s++)\n    {               \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        float d = length(center)-RADIUS-.5-jit*k;\n        float size = length(center)/RADIUS;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR            \n            #if ANIM      \n            \tanim = iTime+.2;\n            \n            #endif\n            \n            float rad_bubl = (RADIUS+anim*anim)/4.; //radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(0,0,0);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +6.*( length(p-pB) / (rad_bubl) - 1.);\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);             \n            \n            float dispersion_rate = fbm( ( \n                p/( clamp(-RADIUS, RADIUS, length(center)) + cos(PI-Psnoise(p/(30.)) ) -1./size*anim) //shockwave stuff\n            \t\t\t) )  ;; //local dispersion rate\n\n            float velocity = 1.60*(DISPERSION_VELOCITY*dispersion_rate); //modify it to tune the local velocity, 1.60 is precalculated value\n            //velocity\n            #define VT\tvelocity            \n           \n            //energy\n            float energy = .5*(VT*VT*VT)/rad_bubl; //energy transfer rate\n#define SQR(x) ( (x)*(x) ) \n            float l = exp(-.5*SQR(d/2.)); \n            \n            float n = ( Psnoise( (p-pB+dp)*l ) + energy)*(max(0.,d)*l) ;\n            \n\n            float mask = smoothstep(1.,\n                                   \t10.*RADIUS,\n                                  \tRADIUS/length(center));\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                               \t  0.,\n                                  1.) *n);\n            \n           if(length(p-cam.pos) >(dist_center+m.radius) || \n           (k*dens  < -9.9))\n        \t{\n         \tbreak;\n        \t}\n            //How colors (rgb) are absorbed at point p in the current iteration\n            //k is the step size          \n             vec3 rgb_t = exp(-vec3(\n                \t\tk * 2.* dens, \n                      \tk * 5. * dens,\n              \t      \tk * 7. * dens ));    \n            \n            t_acc *= (rgb_t);           \n    \n    \t\t//blending\n   \t\t\tc += t_acc*vec3(1.)*(1.-rgb_t);\n            #endif\n        }\n\n        //if it will never be in the shape anymore, return;        \n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n        \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(0.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXfW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1687, 1687, 1712, 1725, 2099], [2101, 2101, 2126, 2139, 2498], [2500, 2500, 2519, 2519, 2612], [2614, 2633, 2709, 2709, 2756], [2758, 2758, 2790, 2790, 2810], [2812, 2812, 2846, 2846, 2868], [2955, 2955, 2996, 2996, 3032], [3034, 3034, 3120, 3120, 3155], [3157, 3157, 3200, 3200, 3240], [3242, 3242, 3266, 3266, 3314], [3316, 3316, 3356, 3356, 3660], [3662, 3662, 3686, 3686, 3749], [3752, 3752, 3804, 3804, 7048], [7051, 7051, 7108, 7108, 7737]], "test": "untested"}
{"id": "3lfBDM", "name": "5. Making Face", "author": "altera0", "description": "source tutorial : https://www.youtube.com/watch?v=ZlNnrpM0TRg\nsimple onet : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect\n", "tags": ["makingface"], "likes": 0, "viewed": 272, "published": 3, "date": "1596822609", "time_retrieved": "2024-07-30T20:52:09.446814", "image_code": "#define S(a , b , t ) smoothstep( a , b , t )\n#define sat(x) clamp( x, 0.0f , 1.0f )\n\n\n// -------------------------------------------------\n// 리맵01\n// -------------------------------------------------\nfloat remap01 ( float a , float b , float v ) {\n\t// 이게 단순히 비율을 구하는 것 뿐만이 아니라,\n    // 로컬 좌표를 , ( 0 ~ 1)의 월드 UV로 사상시키는 의미도 담고 있다.\n    return sat( ( v - a ) / ( b - a ) );\n}\n\n// -------------------------------------------------\n// 리맵\n// -------------------------------------------------\nfloat remap( float a , float b , float c , float d , float value ) {\n    //return (value - a) / ( b - a ) * ( d - c ) + c;\n    return remap01( a , b , value ) * ( d - c ) + c;\n}\n\n// -------------------------------------------------\n// within함수 ( 리맵 01 함수의 vec2 버젼이다. )\n// -------------------------------------------------\nvec2 within( vec2 uv , vec4 rect ) {\n\t// remap01과 마찬가지로, UV를 사상 시키는 의미를 담고 있다.\n    return ( uv - rect.xy ) / ( rect.zw - rect.xy );   \n}\n\n\n\n// -------------------------------------------------\n// 눈\n// -------------------------------------------------\nvec4 Eye( vec2 uv ) {\n    // 이미 uv가 넘어 올때, 어떤 구역 [ ~ ] 안에서 사상되어 있는 상태이다.\n    // within 함수에서 이미 계산되어 있는 상태이다.\n    // 즉 자기 자신의 중점을 ( 0 , 0 )으로 생각하고 자기 자신만 계산하면 된다.\n    \n\tuv -= 0.5f;\n    float d = length(uv);\n\n    \n    vec4 irisCol = vec4( 0.3f, 0.5f, 1.0f , 1.0f );\n    \n    // 눈의 전체 동그라미\n    vec4 col = mix( vec4(1.0f) , irisCol , S( 0.1f , 0.7f , d ) * 0.5f );\n    \n    // 눈동자 전체의 감싸는 동그라미\n    // 뒷쪽의 sat는 그림자까지 표시해주기 위한 테크닉이다.\n    col.rgb *= 1.0f - S(0.45, 0.5f , d ) * 0.5f * sat ( -uv.y - uv.x ); // 중점에서 0.5이상 떨어진 곳만 둥글게 만든다.\n    \n    \n    // 눈동자 검은색 부분\n    col.rgb = mix( col.rgb , vec3(0.0f), S(0.3f , 0.28f, d ) );\n    \n    // 눈동자 파란색 부분\n    irisCol.rgb *= 1.0f + S(0.3f, 0.05f, d );\n    col.rgb = mix( col.rgb , irisCol.rgb , S( 0.28f, 0.25f , d ) );\n    \n    \n\t// 눈동자 파란색 부분 안의 다시 검은 부분    \n    col.rgb = mix( col.rgb ,vec3(0.0f) , S( 0.16f, 0.14f , d ) );\n\n    \n    // eys High Light\n    float highLight = S( 0.1f , 0.09f , length( uv -vec2(-0.15f, 0.15f)));\n    highLight += S( 0.07f , 0.05f , length( uv + vec2( -0.08, 0.08 )));\n    \n    col.rgb = mix( col.rgb, vec3(1.0f), highLight );\n    col.a = S( 0.5f , 0.45f , d );\n    \n    \n    return col;\n}\n\n\n// -------------------------------------------------\n// 입\n// -------------------------------------------------\nvec4 Mouth( vec2 uv ) {\n    uv -= 0.5f;\n    vec4 col = vec4( 0.5f, 0.18f, 0.05f, 1.0f );\n    \n    uv.y *=1.5f;\n    uv.y -= uv.x * uv.x * 2.0f;\n    \n    float d = length(uv );\n    col.a = S( 0.5f , 0.48f, d );\n    \n    float td = length( uv - vec2(0.0f, 0.6f));\n\n    // 이빨에 약간의 다크 셰도우를 준다.\n    vec3 toothCol = vec3(1.0f) * S( 0.6f , 0.35f ,d );\n    \n    \n    // 거리에 따른 이빨의 색깔 합성.\n    col.rgb = mix( col.rgb, toothCol , S(0.4f, 0.37f ,td ) );\n    \n    // 혀\n    td = length(uv + vec2(0.0f, 0.5f ));\n    col.rgb = mix( col.rgb, vec3(1.0f, 0.05f, 0.05f ), S(0.5f, 0.2f,td));\n    \n    \n    return col;\n}\n\n// -------------------------------------------------\n// 머리\n// -------------------------------------------------\nvec4 Head( vec2 uv ) {\n \tvec4 col = vec4(0.9f , 0.65f, 0.1f, 1.0f);\n    \n    float d = length(uv);\n    \n    col.a = S(0.5f , 0.49f , d );\n    \n    \n    // 중심에서 시작해서 끝으로 갈수록 떨어지는 Fall Off\n    float edgeShader = remap01( 0.35f , 0.5f , d );\n    edgeShader = edgeShader * edgeShader;\n    col.rgb *= 1.0f -  edgeShader * 0.5f;\n    \n    \n    // 외곽선 테두리 ( 이건 자기가 찾아 놓은 값 대입 한 것 )\n    col.rgb = mix( col.rgb, vec3(0.6f, 0.3f, 0.1f), S(0.47f ,0.48f , d) );\n\n    \n    // 하이라이트\n    float highlight = S(0.41f, 0.405f, d );\n    highlight *= remap( 0.41f , -0.1f , 0.75f , 0.0f , uv.y );\n    col.rgb = mix( col.rgb, vec3(1.0f), highlight );\n    \n    // 오른쪽 볼 하이라이트\n    d = length( uv - vec2(0.25f, -0.2f) );\n    float cheek = S(0.2f, 0.01f, d ) * 0.4f;\n    cheek *= S(0.17f, 0.16f , d );\n    \n    \n    col.rgb = mix( col.rgb, vec3(1.0f,0.1f , 0.1f), cheek );\n    \n    \n    \n    return col;\n}\n\n\n// -------------------------------------------------\n// 얼굴\n// -------------------------------------------------\nvec4 Smiley( vec2 uv ) {\n    vec4 col = vec4(0);\n    \n    // 이게 좌우 대칭을 만들어 준다.\n    uv.x = abs( uv.x );\n    \n    vec4 head = Head(uv);\n    \n    // 여기에서 눈의 uv를 리맵화 한다. 인간이 알아 보기 쉽도록\n    vec4 eye = Eye( within( uv, vec4( 0.03, -0.1f , 0.35f , 0.25f) ) );\n    vec4 mouth = Mouth( within( uv, vec4( -0.3f, -0.4f, 0.3f, -0.1f) ) );\n    \n    // 이거 섞어주는 순서가 중요하다.\n    col = mix( col , head , head.a ); // 헤드의 알파값으로 섞는다.\n    col = mix ( col , eye , eye.a );\n    col = mix ( col, mouth, mouth.a );\n    \n    return col;\n}\n\n    \n// -------------------------------------------------\n// 메인\n// -------------------------------------------------\nvoid mainImage( out vec4 fragColor , in vec2 fragCoord ) {\n \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    \n    \n\tfragColor = Smiley(uv );    \n    \n    //fragColor =  vec4(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfBDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 205, 252, 410, 453], [455, 571, 639, 693, 748], [750, 915, 951, 1031, 1089], [1093, 1206, 1227, 1499, 2681], [2684, 2797, 2820, 2820, 3448], [3450, 3566, 3588, 3588, 4548], [4551, 4667, 4691, 4691, 5293], [5300, 5416, 5474, 5474, 5670]], "test": "untested"}
{"id": "wtlfD4", "name": "4. Rectangle Destortion", "author": "altera0", "description": "source tutorial : https://www.youtube.com/watch?v=GgGBR4z8C9o\nsimple onet : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect\n\nI did It !", "tags": ["rectangledestortion"], "likes": 0, "viewed": 242, "published": 3, "date": "1596814550", "time_retrieved": "2024-07-30T20:52:10.311502", "image_code": "\nfloat Circle( vec2 uv , vec2 pos , float radius , float blur ) {\n    \n    float d = length( uv - pos );\n    float c = smoothstep( radius , radius - blur , d );\n    return c;\n}\n\n// 웃기 함수\nfloat Smily( vec2 uv , vec2 pos , float radius ) {\n    \n    float blur = 0.01f;\n    \n    // face\n    float c= Circle( uv , pos , radius , blur );\n\t\n    // eye\n    float eyeLeft = Circle ( uv , pos + vec2(-0.15f, 0.2f) , 0.1f , 0.005f );\n    float eyeRight = Circle ( uv , pos + vec2(0.15f, 0.2f) , 0.1f , 0.005f );\n    \n    // mouse\n    float mouse = Circle ( uv , pos + vec2(0.0f, 0.0f) , radius * 0.8f , blur );\n    mouse -= Circle  ( uv , pos + vec2(0.0f, 0.05f) , radius * 0.8f , blur );\n    mouse = clamp( 0. , 1., mouse );\n    \n    // 합성.\n    c -= eyeLeft;\n    c -= eyeRight;\n    c -= mouse;\n\n    return c;\n}\n\n// 밴드\nfloat Band( float t , float start , float end ,  float blur ) {\n    float c;\n    c = smoothstep(  start - blur , start + blur , t ); \n\n    // 반드시 곱셈이어야 한다.\n    c *= smoothstep ( end + blur , end - blur , t );\t// 이거 중요함. 스텝함수의 사용법 볼것\n\t\n    return c;\n}\n\n\n// 사각형\nfloat Rectangle( vec2 uv , vec2 center , float width , float height, float blur ) {\n\n    float c;\n    c = Band(  uv.x , center.x - width / 2.0f  , center.x + width / 2.0f , blur );\n    // 반드시 곱셈이어야 한다.\n    c *= Band( uv.y , center.y - height / 2.0f , center.y + height / 2.0f , blur );    \n    return c;\n}\n\nfloat remap01( float a, float b , float valueBetweenAtoB ) {\n\treturn (valueBetweenAtoB - a ) / ( b - a );   \n}\n\nfloat remap( float a , float b , float c , float d , float valueBetweenAtoB ) {\n\treturn remap01( a , b , valueBetweenAtoB ) * ( d - c ) + c;   \n}\n\n// 메인\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\t\t// compensate\n    \n    float radius = 0.4f;\n    vec2 pos = vec2(0.4f , 0.0f);\n    \n    float c;\n    vec3 col;\n    float blur;\n    \n    uv *= 1.0f;\n\n    float x = uv.x;\n    float m = -( x - 0.5f ) * ( x + 0.5f );\n\tm = m * m * 4.0f;\n    \n    float y;\n    //float y = uv.y - m;\n    //y = uv.y * sin( m + x + iTime * 2.0f);\n    y = uv.y - 0.1f * sin ( x*8.0f + iTime );\n\n    \n    //c = Smily( uv , -pos + vec2(0.0, 0.2f) , 0.4f );\n    //c += Rectangle( uv + uv.y , pos, 0.4f , 0.4f );\n    \n    blur = mix( 0.0001f , 1.0f , 0.1f );\n    blur = remap( -0.75f / 2.0f , 0.75f/2.0f , 0.0001f, 0.25f , x );\n    c = Rectangle( vec2(x , y ) , vec2(0.0f , 0.0f ) , 0.75f ,0.5f, blur );\n    \n    \n    col = vec3( 1.0f, 1.0f , 0.0f ) * c ;\n    fragColor = vec4(vec3(col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 65, 65, 176], [178, 195, 245, 245, 813], [815, 825, 888, 888, 1125], [1128, 1141, 1224, 1224, 1466], [1468, 1468, 1528, 1528, 1578], [1580, 1580, 1659, 1659, 1725], [1727, 1737, 1794, 1794, 2659]], "test": "untested"}
{"id": "3tfBDM", "name": "Sierpinski-5x5 Carpet-fork-fuzz", "author": "alvarobyrne", "description": "A Sierpinski-Carpet-like structure, but in a 5x5  arragement. At every iteration, the whole unit square is divided in 5x5 sub-squares and the subsquares subsquares at (1,1), (3,1), (1,3) and (3,3) get removed.", "tags": ["2d", "fractal", "sierpinksi"], "likes": 3, "viewed": 294, "published": 3, "date": "1596813929", "time_retrieved": "2024-07-30T20:52:11.085433", "image_code": "// Fork of \"Sierpinski - 5x5 Carpet\" by iq. https://shadertoy.com/view/XsSGRh\n// 2020-08-07 15:22:20\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\n// https://creativecommons.org/licenses/by-sa/3.0/\n\n\n// A Sierpinski Carpet like structure (2D Cantor). Instead of removing the central square \n// of a 3x3 subdivided square, in this shader I divide the square in 5x5 sub-squares and I \n// remove the four in the corners of the central one.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // unit square covering the whole screen\n\tvec2 z = fragCoord.xy / iResolution.xy;\n\n    // make it all white\n    float f = 1.0;\n\t\n    // iterate\t\n\tfor( int i=0; i<4; i++ ) \n\t{\n        //remove subsquares (1,1), (3,1), (1,3) and (3,3)\n\t\tf *= 1.0 - step( abs(abs(z.x-(0.5+0.36475*sin(iTime+sin(iTime*3./5.))))-0.15*(1.0+sin(iTime+sin(iTime)))), 0.1 )\n            *step( abs(abs(z.y-0.5+0.1*sin(iTime+sin(iTime)))-0.1*(1.0+cos(iTime+sin(iTime*7./5.)))), 0.1 );\n        // scale the shole thing down by a factor of 5\n\t\tz = fract( z*5.0 );\n\t}\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfBDM.jpg", "access": "api", "license": "cc-by-sa-3.0", "functions": [[494, 494, 551, 601, 1136]], "test": "untested"}
{"id": "3tXBWM", "name": "Stellar Window ver. 2", "author": "Kanata", "description": "just added rings to my old shader", "tags": ["complexnumber"], "likes": 3, "viewed": 279, "published": 3, "date": "1596808934", "time_retrieved": "2024-07-30T20:52:11.936158", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 res = iResolution.xy,\n          z = ( u* 2. - res) / min(res.x, res.y);\n\n    float t = iTime;\n    float scale = 2.;\n    z *= scale;\n    \n    vec2 a = vec2(sin(t * 0.5), cos(t * 0.5));\n    vec2 b = vec2(1., 0.);\n    vec2 c = vec2(0., 1.);\n    vec2 d = vec2(1., 0.);\n    vec2 e = vec2(sin(t* 0.43), cos(t* 0.43));\n    \n    \n    vec2 f = cpow(z, 100) + cmul(a, cpow(z, 4)) + cmul(b, cpow(z, 3))\n                     + cmul(c, cpow(z, 2)) + cmul(d, cpow(z, 1)) + e;\n    float theta = atan(f.x, f.y);\n    float r = length(f);\n    \n    float k = .01 * abs(sin(fract(0.1 * t) *  PI))/abs((length(z)- 1.1- fract(0.1 * t)));\n    float j = .01 * abs(sin(fract(0.1 * t) *  PI))/abs((length(z)- 1.17- fract(0.1 * t)));\n\n    \n    O = vec4(hsvToRgb(theta, 0.1/r, 0.3/r) + vec3(k + j), 1.);\n}", "image_inputs": [], "common_code": "const float PI  = 3.141592653589793;\n\nvec3 hsvToRgb(float h, float s, float v) {\n    // h: -π - +π, s: 0.0 - 1.0, v: 0.0 - 1.0\n    h = (h + PI) / (2.* PI) * 360.;\n\n    float c = s; // float c = v * s;\n    float h2 = h / 60.0;\n    float x = c * (1.0 - abs(mod(h2, 2.0) - 1.0));\n    vec3 rgb = (v - c) * vec3(1.0, 1.0, 1.0);\n\n    if (0.0 <= h2 && h2 < 1.0) {\n        rgb += vec3(c, x, 0.0);\n    } else if (1.0 <= h2 && h2 < 2.0) {\n        rgb += vec3(x, c, 0.0);\n    } else if (2.0 <= h2 && h2 < 3.0) {\n        rgb += vec3(0.0, c, x);\n    } else if (3.0 <= h2 && h2 < 4.0) {\n        rgb += vec3(0.0, x, c);\n    } else if (4.0 <= h2 && h2 < 5.0) {\n        rgb += vec3(x, 0.0, c);\n    } else if (5.0 <= h2 && h2 < 6.0) {\n        rgb += vec3(c, 0.0, x);\n    }\n\n    return rgb;\n}\n// hsvToRgb borrowed from\n// https://qiita.com/sw1227/items/4be9b9f928724a389a85\n// (slightly modified by Kanata)\n\n//operations on complex numbers borrowed from\n//https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n\n#define re(a) vec2((a).x, 0.)\n#define im(a) vec2(0., (a).y)\n#define cmul(a,b) ( mat2(a, -(a).y, (a).x ) * (b) )\n#define conj(a)     vec2( (a).x, -(a).y)\n#define cinv(a)   ( conj(a) / dot(a, a) )\n#define cdiv(a,b) ( cmul(a, cinv(b)) )\n#define cexp(a)   ( exp((a).x)* vec2(cos((a).y), sin((a).y)) )\n#define clog(a)     vec2( log(length(a)), atan((a).y,(a).x) )\n#define arg(a)\t( atan(a.y, a.x) )\n#define cpow(a,n)   cexp( float(n)* clog(a) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXBWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 825]], "test": "untested"}
{"id": "wllfD4", "name": "theyaremanycolors 6 - blue", "author": "thefox231", "description": "this was fun", "tags": ["theyaremanycolors"], "likes": 2, "viewed": 183, "published": 3, "date": "1596798994", "time_retrieved": "2024-07-30T20:52:12.703108", "image_code": "const vec3 layer1Color = vec3(0.0, 0.0, 254.0/255.0);\nconst vec3 layer2Color = vec3(57.0/255.0, 73.0/255.0, 251.0/255.0);\nconst vec3 layer3Color = vec3(0.0, 0.0, 4.0/255.0);\n\n#define scale 30.0\n#define offset 10.0\n\n#define fisheye_amount -0.1\n\nfloat hash(vec3 p3)\n{\n    p3.xy *= 400.0;\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // fisheye\n\n    uv -= 0.5;\n    uv *= 1.0 - fisheye_amount / 2.0;\n\n    float r = sqrt(dot(uv,uv));\n    uv *= 1.0 + r * fisheye_amount;\n    uv += 0.5;\n\n    vec2 res = iResolution.xy;\n    uv = clamp( uv, 1.0 / res, (res - 1.0) / res );\n\n    // fisheye end\n    \n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = layer1Color;\n    \n    float hash1 = round(hash(vec3(round(uv * scale) / scale, round(iTime * 15.0))));\n    uv += offset / iResolution.xy;\n    float hash2 = round(hash(vec3(round(uv * scale) / scale, round(iTime * 15.0 + 90.0))));\n    \n    col = mix(col, layer2Color, hash1);\n    col = mix(col, layer3Color, hash2);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 265, 265, 388], [390, 390, 447, 447, 1166]], "test": "untested"}
{"id": "wtsfD4", "name": "theyaremanycolors 7 - blue deep", "author": "thefox231", "description": "oooo..... pseudo bloom.........", "tags": ["theyaremanycolors"], "likes": 3, "viewed": 217, "published": 3, "date": "1596798946", "time_retrieved": "2024-07-30T20:52:13.468062", "image_code": "const vec3 layer1Color = vec3(0.0, 0.0, 0.0);\nconst vec3 layer2Color = vec3(1.0, 1.0, 1.0);\nconst vec3 layer3Color = vec3(0.0, 12.0/255.0, 242.0/255.0);\n\n#define scale 40.0\n#define offset 10.0\n\n#define passes 20.0\n#define bloomSize 0.2\n\n#define fisheye_amount -0.4\n\nfloat hash(vec3 p3)\n{\n    p3.xy *= 400.0;\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat smoothHash(vec3 p3) {\n   \treturn mix(round(hash(vec3(p3.xy, floor(p3.z)))), round(hash(vec3(p3.xy, ceil(p3.z)))), fract(p3.z));\n}\n\nvec4 render(vec2 uv) {\n    // fisheye\n\n    uv -= 0.5;\n    uv *= 1.0 - fisheye_amount / 2.0;\n\n    float r = sqrt(dot(uv,uv));\n    uv *= 1.0 + r * fisheye_amount;\n    uv += 0.5;\n\n    vec2 res = iResolution.xy;\n    uv = clamp( uv, 1.0 / res, (res - 1.0) / res );\n\n    // fisheye end\n    \n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = layer1Color;\n    \n    vec2 uvPix = round(uv * scale) / scale;\n    float hash1 = (smoothHash(vec3(uvPix, iTime * 3.3 + uv.x * 2.63)));\n    \n    uv += offset / iResolution.xy;\n    uvPix = round(uv * scale) / scale;\n    float hash2 = (smoothHash(vec3(uvPix, iTime * 5.3 + 90.0 + uvPix.y * 25.3 + uvPix.x * 24.53)));\n    \n    col = mix(col, layer2Color, hash1);\n    col = mix(col, layer3Color, hash2);\n    \n    return vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 col = vec4(0.0);\n    \n    for (int i = 0; float(i) < passes; i++) {\n        float progress = float(i) / passes;\n        vec2 scaledUv = (uv - 0.5) * (1.0 + progress * bloomSize) + 0.5;\n        vec4 rendered = render(scaledUv);\n        \n        float lumi = (rendered.r + rendered.g + rendered.b) / 3.0;\n        \n        col += rendered * pow(1.0 - progress, 3.0) * pow(lumi, 2.0);\n    }\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 287, 287, 410], [412, 412, 439, 439, 547], [549, 549, 571, 586, 1323], [1325, 1325, 1382, 1382, 1851]], "test": "untested"}
{"id": "WlXBW8", "name": "rgb crumple", "author": "thefox231", "description": "idk, looks interesting\nmouse to control intensity", "tags": ["voronoi", "glitch"], "likes": 5, "viewed": 521, "published": 3, "date": "1596794920", "time_retrieved": "2024-07-30T20:52:14.236008", "image_code": "#define amp iMouse.x / iResolution.x * 0.5\n\nfloat hash(float n)\n{\n    n=mod(n,64.0);\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    return hash(p.x + p.y*57.0);\n}\n\nfloat smoothNoise2(vec2 p)\n{\n    vec2 p0 = floor(p + vec2(0.0, 0.0));\n    vec2 p1 = floor(p + vec2(1.0, 0.0));\n    vec2 p2 = floor(p + vec2(0.0, 1.0));\n    vec2 p3 = floor(p + vec2(1.0, 1.0));\n    vec2 pf = fract(p);\n    return mix( mix(noise(p0), noise(p1), pf.x), \n               mix(noise(p2), noise(p3), pf.x), pf.y);\n}\n\nvec2 cellPoint(vec2 cell)\n{\n    return vec2(noise(cell)+cos(cell.y)*0.3, noise(cell*0.3)+sin(cell.x)*0.3);\n}\n\nvec3 voronoi2(vec2 t,float pw)\n{\n    vec2 p = floor(t);\n    vec3 nn=vec3(1e10);\n\n    float wsum=0.0;\n    vec3 cl=vec3(0.0);\n    for(int y = -1; y < 2; y += 1)\n        for(int x = -1; x < 2; x += 1)\n        {\n            vec2 b = vec2(float(x), float(y));\n            vec2 q = b + p;\n            vec2 q2 = q-floor(q/8.0)*8.0;\n            vec2 c = q + cellPoint(q2);\n            vec2 r = c - t;\n            vec2 r2=r;\n\n            float d = dot(r, r);\n            float w=pow(smoothstep(0.0,1.0,1.0-abs(r2.x)),pw)*pow(smoothstep(0.0,1.0,1.0-abs(r2.y)),pw);\n\n            cl+=vec3(0.5+0.5*cos((q2.x+q2.y*119.0)*8.0))*w;\n            wsum+=w;\n\n            nn=mix(vec3(q2,d),nn,step(nn.z,d));\n        }\n\n    return pow(cl/wsum,vec3(0.5))*2.0;\n}\n\nvec3 voronoi(vec2 t)\n{\n    return voronoi2(t*0.25,16.0)*(0.0+1.0*voronoi2(t*0.5+vec2(voronoi2(t*0.25,16.0)),2.0))+voronoi2(t*0.5,4.0)*0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 t=(fragCoord)/iResolution.y + (vec2(sin(iTime), cos(iTime)) - iTime * 2.0) * 0.4;\n    fragColor.a = 1.0;\n\n    vec2 tt = fract((t.xy+1.0)*0.5) * 32.0;\n\n    //float x=voronoi(tt).r;\n    //float x1=voronoi(tt+vec2(1e-2,0.0)).r;\n    //float x2=voronoi(tt+vec2(0.0,1e-2)).r;\n\n    //vec3 off = .86*mix(vec3(0.1,0.1,0.2)*0.4,vec3(1.05,1.05,1.0),0.5+0.5*dot(normalize(vec3(0.1,1.0,0.5)),\n    //                                                                            normalize(vec3((x1-x)/1e-2,(x2-x)/1e-2,8.0))*0.5+vec3(0.5)));\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col;\n    for (int i = 0; i < 3; i++) {\n        vec2 off = voronoi(tt + float(i) * 90.).rg;\n    \tcol[i] = texture(iChannel0, clamp(uv + (1. - off) * amp, 0.0, 1.0))[i];\n    }\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 65, 65, 123], [125, 125, 146, 146, 181], [183, 183, 211, 211, 506], [508, 508, 535, 535, 616], [618, 618, 650, 650, 1355], [1357, 1357, 1379, 1379, 1497], [1499, 1499, 1556, 1556, 2354]], "test": "untested"}
{"id": "wllBW4", "name": "theyaremanycolors 4 - green", "author": "thefox231", "description": "i like this one a lot", "tags": ["theyaremanycolors"], "likes": 2, "viewed": 161, "published": 3, "date": "1596788055", "time_retrieved": "2024-07-30T20:52:15.009939", "image_code": "#define angle 0.9\n#define scale 8.0\n#define scaleFg 1.5\n\n#define alpha 1.0 - fract(iTime * 7.0)\n\nconst vec3 colFg = vec3(0.0, 0.843, 0.0);\n\nvec2 rotateVec(vec2 v, float a){\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * (v - .5) + .5;\n}\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 lines(vec2 uv) {\n    bool mirror = false;\n    \n    uv = rotateVec(uv, angle);\n    uv += iTime * 0.3; // Offset lines\n    \n    if (fract(uv.x * scale/2.0) > 0.5) {\n    \tuv.x += uv.y;   // Make it diagonal\n    } else {\n        mirror = true;\n        uv.x -= uv.y;   // Make it diagonal\n    }\n    uv *= scale;     // Upscale\n    uv = fract(uv); // Fraction\n    \n    vec3 col = vec3(0.0, 0.0, 0.0); // Background color\n        \n    if (mirror) {\n        col = mix(colFg, col, step(uv.x, 0.5)); // Line color\n    } else {\n    \tcol = mix(col, colFg, step(uv.x, 0.5)); // Line color\n    }\n    \n    return col * alpha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;\n    \n    float angleOffset = hash(floor(iTime * 0.7)) * 3.14;\n    \n    fragColor = vec4(lines(rotateVec(uv, angleOffset)) + lines(rotateVec(uv * scaleFg + 0.2, angle * 2.0 + angleOffset)) * 0.2, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 172, 172, 272], [274, 274, 295, 295, 380], [382, 382, 403, 403, 999], [1001, 1001, 1058, 1058, 1303]], "test": "untested"}
{"id": "tllBW4", "name": "theyaremanycolors 3 - red deep", "author": "thefox231", "description": "yeah", "tags": ["theyaremanycolors"], "likes": 0, "viewed": 183, "published": 3, "date": "1596786210", "time_retrieved": "2024-07-30T20:52:15.772899", "image_code": "#define alpha 0.0\n#define beta 10.0\n\n#define squareScale 3.0\n#define fisheye_amount -0.7\n\nvec2 rotateVec(vec2 v, float a){\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * (v - .5) + .5;\n}\n\nfloat spiral(vec2 m, float t) {\n\tfloat r = length(m);\n\tfloat a = atan(m.y, m.x);\n\tfloat v = sin(50.*(sqrt(r)-0.02*a-.3*t));\n\treturn clamp(v,0.,1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // fisheye\n\n    uv -= 0.5;\n    uv *= 1.0 - fisheye_amount / 2.0;\n\n    float r = sqrt(dot(uv,uv));\n    uv *= 1.0 + r * fisheye_amount;\n    uv += 0.5;\n\n    vec2 res = iResolution.xy;\n    uv = clamp( uv, 1.0 / res, (res - 1.0) / res );\n\n    // fisheye end\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv *= 2.0;\n    uv += 0.5;\n    uv = abs(uv);\n    \n    vec2 uvOrig = uv;\n    \n    uv = rotateVec(uv, iTime * 3.0);\n    \n    vec3 col = vec3(0.3, 0.3, 0.3);\n    col = spiral(uv + .4 + sin(iTime * .5 + uv.y * 5.) * (.3 + sin(iTime) * .1), iTime * 30.0) * vec3(1.0, 0.0, 0.0);\n    \n    col.r += 0.1 * round(fract(rotateVec(uvOrig, iTime * 0.05) * squareScale + iTime * 45.5)).x - round(fract(rotateVec(uvOrig, iTime * 0.05) * squareScale + squareScale/2.0 + iTime * 13.5)).y;\n    col.r -= 0.1 * round(fract(rotateVec(uvOrig, iTime * 0.2 + 25.0) * squareScale + iTime * 13.5)).y - round(fract(rotateVec(uvOrig, iTime * 0.2 + 25.0) * squareScale + squareScale/2.0 + iTime * 33.5)).x;\n    col.r += 0.1 * round(fract(rotateVec(uvOrig, iTime * 0.2 + 13.0) * squareScale + iTime * 24.5)).y - round(fract(rotateVec(uvOrig, iTime * 0.2 + 25.0) * squareScale + squareScale/2.0 + iTime * 13.5)).x;\n    col.r -= 0.1 * round(fract(rotateVec(uvOrig, iTime * 0.2 + 18.0) * squareScale + iTime * 73.5)).y - round(fract(rotateVec(uvOrig, iTime * 0.2 + 25.0) * squareScale + squareScale/2.0 + iTime * 12.5)).x;\n    \n    fragColor = vec4(col + 0.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 122, 122, 222], [224, 224, 255, 255, 374], [376, 376, 433, 433, 1928]], "test": "untested"}
{"id": "3lsfDN", "name": "theyaremanycolors 1 - black", "author": "thefox231", "description": "yeah", "tags": ["theyaremanycolors"], "likes": 1, "viewed": 171, "published": 3, "date": "1596784981", "time_retrieved": "2024-07-30T20:52:16.533865", "image_code": "float hash(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(pow(hash(vec3(fragCoord.xy, iTime)), 3.0) * 0.2 + 0.05), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 124], [126, 126, 183, 183, 274]], "test": "untested"}
{"id": "WllfDN", "name": "theyaremanycolors 2 - red", "author": "thefox231", "description": "yeah", "tags": ["theyaremanycolors"], "likes": 1, "viewed": 165, "published": 3, "date": "1596784519", "time_retrieved": "2024-07-30T20:52:17.298820", "image_code": "#define alpha 0.0\n#define beta 10.0\n\n#define squareScale 6.0\n\nvec2 rotateVec(vec2 v, float a){\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * (v - .5) + .5;\n}\n\nvec4 spiral4(vec2 coord)\n{\t\n\tfloat alpha_t = alpha - iTime * 300.0;\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(dot(coord, coord));\n\n\tfloat phi = atan(y, x);\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\tfloat remainder = abs(cos(phi) - cos(phi_r));\n\n\treturn vec4(vec3(remainder), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 uvOrig = uv;\n    \n    uv = rotateVec(uv, iTime * 0.8);\n    \n    vec3 col = vec3(0.2, 0.0, 0.0);\n    col = spiral4(rotateVec(fragCoord.xy / iResolution.xy * (0.9 + uv * 0.1), iTime * 0.8) * iResolution.xy - (iResolution.xy * 0.5)).rgb * vec3(1.0, 0.0, 0.0);\n    \n    col.r += round(fract(rotateVec(uvOrig, iTime * 0.05) * squareScale + iTime * 13.5)).x - round(fract(rotateVec(uvOrig, iTime * 0.05) * squareScale + squareScale/2.0 + iTime * 13.5)).y;\n    \n    col.r -= round(fract(rotateVec(uvOrig, iTime * 0.2 + 25.0) * squareScale + iTime * 13.5)).y - round(fract(rotateVec(uvOrig, iTime * 0.2 + 25.0) * squareScale + squareScale/2.0 + iTime * 13.5)).x;\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllfDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 94, 94, 194], [196, 196, 222, 222, 532], [534, 534, 591, 591, 1389]], "test": "untested"}
{"id": "wtlBR8", "name": "Particle simulator Click to draw", "author": "vipiao", "description": "Click the squares top right to select tool.\nRight to left explanation:\nEraser,\nSand,\nWater,\nExplosive gas,\nFire,\nWater vapor,\nBomb,\nTank (A, D to move, ARROW RIGHT, ARROW LEFT to aim, SPACE to shoot),\nExplosion,\nBroken tank,\nEnemy (attacks player),\nLazer", "tags": ["simulation"], "likes": 29, "viewed": 1169, "published": 3, "date": "1596770129", "time_retrieved": "2024-07-30T20:52:18.439770", "image_code": "const ivec2 offsets[25] = ivec2[](\n    ivec2(-2, 2), ivec2(-1, 2), ivec2( 0, 2), ivec2( 1, 2), ivec2( 2, 2),\n    ivec2(-2, 1), ivec2(-1, 1), ivec2( 0, 1), ivec2( 1, 1), ivec2( 2, 1),\n    ivec2(-2, 0), ivec2(-1, 0), ivec2( 0, 0), ivec2( 1, 0), ivec2( 2, 0),\n    ivec2(-2,-1), ivec2(-1,-1), ivec2( 0,-1), ivec2( 1,-1), ivec2( 2,-1),\n    ivec2(-2,-2), ivec2(-1,-2), ivec2( 0,-2), ivec2( 1,-2), ivec2( 2,-2)\n);\nconst int offsetsIndices[25] = int[](\n    0, 1, 2, 3, 4,\n    5, 6, 7, 8, 9,\n    10, 11, 12, 13, 14,\n    15, 16, 17, 18, 19,\n    20, 21, 22, 23, 24\n);\nconst int indUULL = 0;const int indUUL = 1;const int indUU = 2;const int indUUR = 3;const int indUURR = 4;\nconst int indULL = 5;const int indUL = 6;const int indU = 7;const int indUR = 8;const int indURR = 9;\nconst int indLL = 10;const int indL = 11;const int indC = 12;const int indR = 13;const int indRR = 14;\nconst int indDLL = 15;const int indDL = 16;const int indD = 17;const int indDR = 18;const int indDRR = 19;\nconst int indDDLL = 20;const int indDDL = 21;const int indDD = 22;const int indDDR = 23;const int indDDRR = 24;\nfloat glowFactor(vec4 pixels[25], int cl){\n    float f = 0.;\n    #define GF(ind, cl) float(getClass(pixels[ind])==cl)\n    f +=\n        GF(indUULL,cl)*1. + GF(indUUL,cl)*4. + GF(indUU,cl)*7. + GF(indUUR,cl)*4. + GF(indUURR,cl)*1. +\n        GF(indULL,cl)*4. + GF(indUL,cl)*16. + GF(indU,cl)*26. + GF(indUR,cl)*16. + GF(indURR,cl)*4. +\n        GF(indLL,cl)*7. + GF(indL,cl)*26. + GF(indC,cl)*41. + GF(indR,cl)*26. + GF(indRR,cl)*7. +\n        GF(indULL,cl)*4. + GF(indDL,cl)*16. + GF(indD,cl)*26. + GF(indDR,cl)*16. + GF(indDRR,cl)*4. +\n        GF(indDDLL,cl)*1. + GF(indDDL,cl)*4. + GF(indDD,cl)*7. + GF(indDDR,cl)*4. + GF(indDDRR,cl)*1.\n    ;\n    f /= 273.0;\n\treturn f;\n}\nvec3 getColor(vec4 pixels[25]){\n    vec4 p = pixels[indC];\n    int cl = getClass(p);\n    vec3 color;\n    if(\n        cl == TANK ||\n        getClass(pixels[indU]) == TANK ||\n        getClass(pixels[indUR]) == TANK ||\n        getClass(pixels[indUL]) == TANK ||\n        getClass(pixels[indR]) == TANK ||\n        getClass(pixels[indL]) == TANK ||\n        getClass(pixels[indRR]) == TANK ||\n        getClass(pixels[indURR]) == TANK ||\n        getClass(pixels[indLL]) == TANK ||\n        getClass(pixels[indULL]) == TANK ||\n        getClass(pixels[indUUR]) == TANK ||\n        getClass(pixels[indUUL]) == TANK ||\n        getClass(pixels[indUU]) == TANK ||\n        getClass(pixels[indD]) == TANK ||\n        getClass(pixels[indDD]) == TANK ||\n        getClass(pixels[indDDRR]) == TANK ||\n        getClass(pixels[indDDLL]) == TANK ||\n        pixels[indDDL].x >= 0. && getClass(pixels[indDDL]) == TANK ||\n        pixels[indDR].x >= 0. && getClass(pixels[indDR]) == TANK ||\n        pixels[indDDR].x < 0. && getClass(pixels[indDDR]) == TANK ||\n        pixels[indDL].x < 0. && getClass(pixels[indDL]) == TANK\n    ){\n        color = TANK_COLOR;\n    }else if(\n        cl == TANK ||\n        getClass(pixels[indU]) == BROKEN_TANK ||\n        getClass(pixels[indUR]) == BROKEN_TANK ||\n        getClass(pixels[indUL]) == BROKEN_TANK ||\n        getClass(pixels[indR]) == BROKEN_TANK ||\n        getClass(pixels[indL]) == BROKEN_TANK ||\n        getClass(pixels[indRR]) == BROKEN_TANK ||\n        getClass(pixels[indURR]) == BROKEN_TANK ||\n        getClass(pixels[indLL]) == BROKEN_TANK ||\n        getClass(pixels[indULL]) == BROKEN_TANK ||\n        getClass(pixels[indUUR]) == BROKEN_TANK ||\n        getClass(pixels[indUUL]) == BROKEN_TANK ||\n        getClass(pixels[indUU]) == BROKEN_TANK ||\n        getClass(pixels[indD]) == BROKEN_TANK ||\n        getClass(pixels[indDD]) == BROKEN_TANK ||\n        getClass(pixels[indDDRR]) == BROKEN_TANK ||\n        getClass(pixels[indDDLL]) == BROKEN_TANK ||\n        pixels[indDDL].x >= 0. && getClass(pixels[indDDL]) == BROKEN_TANK ||\n        pixels[indDR].x >= 0. && getClass(pixels[indDR]) == BROKEN_TANK ||\n        pixels[indDDR].x < 0. && getClass(pixels[indDDR]) == BROKEN_TANK ||\n        pixels[indDL].x < 0. && getClass(pixels[indDL]) == BROKEN_TANK\n    ){\n        color = BROKEN_TANK_COLOR;\n    }else if(cl == SAND){\n        color = SAND_COLOR;\n    }else if(cl == WATER){\n        color = WATER_COLOR;\n    }else if(cl == GAS){\n        //color = GAS_COLOR;\n        color = EMPTY_COLOR;\n    }else if(cl == FIRE){\n        //vec3 c = FIRE_COLOR;\n        //c *= max(1.5/(1. + length(p.xy)*0.2), 0.2);\n        //c = min(c, 1.);\n        //color = c;\n        color = EMPTY_COLOR;\n    }else if(cl == WATER_VAPOR){\n        //color = WATER_VAPOR_COLOR;\n        color = EMPTY_COLOR;\n    }else if(cl == BOMB){\n        color = BOMB_COLOR;\n    }else if(cl == EXPLOSION){\n        color = EXPLOSION_COLOR;\n    }else if(cl == BROKEN_TANK){\n        color = BROKEN_TANK_COLOR;\n    }else if(\n            cl == AIRCRAFT || getClass(pixels[indD]) == AIRCRAFT || getClass(pixels[indDD]) == AIRCRAFT ||\n            getClass(pixels[indL]) == AIRCRAFT || getClass(pixels[indDDL]) == AIRCRAFT || getClass(pixels[indR]) == AIRCRAFT ||\n            getClass(pixels[indDDR]) == AIRCRAFT || getClass(pixels[indDLL]) == AIRCRAFT || getClass(pixels[indDDLL]) == AIRCRAFT ||\n            getClass(pixels[indDRR]) == AIRCRAFT || getClass(pixels[indDDRR]) == AIRCRAFT || getClass(pixels[indU]) == AIRCRAFT ||\n            getClass(pixels[indUL]) == AIRCRAFT || getClass(pixels[indUR]) == AIRCRAFT || getClass(pixels[indUU]) == AIRCRAFT\n    ){\n        color = AIRCRAFT_COLOR;\n    }else if(cl == LAZER){\n        color = LAZER_COLOR;\n    }else if(cl == MEGA_BOMB){\n        color = MEGA_BOMB_COLOR;\n    }else if(cl == DIRT){\n        color = DIRT_COLOR;\n    }else if(cl == CONCRETE){\n        color = CONCRETE_COLOR;\n    }else if(cl == CONCRETE_BROKEN){\n        color = CONCRETE_BROKEN_COLOR;\n    }else if(cl == NUKE){\n        color = NUKE_COLOR;\n    }else if(cl == GRASS){\n        color = GRASS_COLOR;\n    }else{\n    \tcolor = EMPTY_COLOR;\n   \t}\n    // Glow.\n    const int size = 8;\n    const int[size] cls = int[](BOMB, FIRE, GAS, WATER_VAPOR, LAZER, MEGA_BOMB, NUKE, GRASS);\n    const vec3[size] cols = vec3[](BOMB_COLOR, FIRE_COLOR, GAS_COLOR, WATER_VAPOR_COLOR, LAZER_COLOR, MEGA_BOMB_COLOR, NUKE_COLOR, GRASS_COLOR);\n    const float[size] facs = float[](4., 2., 1., 1., 8., 16., 16., 1.);\n    int unwind_breaker = 0; // I read somewhere but can't remember where, this would make the for loop not unwind, improving compile time.\n    for(int i=0; i<size+unwind_breaker; i++){\n    \tfloat fac = glowFactor(pixels, cls[i]) * facs[i];\n        color = mix(color, cols[i], fac);\n    }\n    /*// Glowing bullets.\n    float fac = glowFactor(pixels, BOMB);\n    color = mix(color, BOMB_COLOR, fac);\n    // Glowing fire.\n    fac = glowFactor(pixels, FIRE)*2.;\n    color = mix(color, FIRE_COLOR, fac);\n    // Glowing gas.\n    fac = glowFactor(pixels, GAS)*1.;\n    color = mix(color, GAS_COLOR, fac);\n    // Glowing water vapor.\n    fac = glowFactor(pixels, WATER_VAPOR)*1.;\n    color = mix(color, WATER_VAPOR_COLOR, fac);\n    // Glowing lazer.\n    fac = glowFactor(pixels, LAZER)*8.;\n    color = mix(color, LAZER_COLOR, fac);*/\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));*/\n    \n    ivec2 myCoords = ivec2(fragCoord);\n    \n    vec4 p = texelFetch(iChannel0, myCoords, 0);\n    \n    vec4 pixels[25];\n    for(int i=0; i<25; i++){\n    \t//pixels[i] = gp(myCoords + offsets[i]);\n    \tpixels[i] = texelFetch(iChannel0, myCoords + offsets[i], 0);\n    }\n    \n    // Render particles.\n    vec3 color = getColor(pixels);\n    \n    // Render GUI.\n    if(fragCoord.y >= iResolution.y - MENU_HEIGHT && iResolution.x - fragCoord.x < MENU_WIDTH * MENU_NUM_BUTTONS){\n        int fromRight = int((iResolution.x - fragCoord.x) / MENU_WIDTH);\n        if(fromRight == 0){\n        \tcolor = MENU_ERASER_COLOR;\n        }else if(fromRight == 1){\n        \tcolor = SAND_COLOR;\n        }else if(fromRight == 2){\n        \tcolor = WATER_COLOR;\n        }else if(fromRight == 3){\n        \tcolor = GAS_COLOR;\n        }else if(fromRight == 4){\n        \tcolor = FIRE_COLOR;\n        }else if(fromRight == 5){\n        \tcolor = WATER_VAPOR_COLOR;\n        }else if(fromRight == 6){\n        \tcolor = BOMB_COLOR;\n        }else if(fromRight == 7){\n        \tcolor = TANK_COLOR;\n        }else if(fromRight == 8){\n        \tcolor = EXPLOSION_COLOR;\n        }else if(fromRight == 9){\n        \tcolor = BROKEN_TANK_COLOR;\n        }else if(fromRight == 10){\n        \tcolor = AIRCRAFT_COLOR;\n        }else if(fromRight == 11){\n        \tcolor = LAZER_COLOR;\n        }else if(fromRight == 12){\n        \tcolor = MEGA_BOMB_COLOR;\n        }else if(fromRight == 13){\n        \tcolor = DIRT_COLOR;\n        }else if(fromRight == 14){\n        \tcolor = CONCRETE_COLOR;\n        }else if(fromRight == 15){\n        \tcolor = CONCRETE_BROKEN_COLOR;\n        }else if(fromRight == 16){\n        \tcolor = NUKE_COLOR;\n        }else if(fromRight == 17){\n        \tcolor = HOUSE_COLOR;\n        }else if(fromRight == 18){\n        \tcolor = GRASS_COLOR;\n        }\n    }\n    bool doAutoSpawn = texelFetch(iChannel0, ivec2(AUTO_SPAWN_AIRCRAFT, 0), 0).x > 0.5;\n    ivec2 topLeft = ivec2(iResolution.x*0.04, iResolution.y*0.95);\n    if(length(vec2(myCoords-topLeft)) < 5.){\n        if(doAutoSpawn){\n        \tcolor = mix(color, vec3(1.,0.,0.), 0.75);\n        }\n    }\n    \n    //\n    vec2 tankPos = texelFetch(iChannel0, ivec2(TANK_POSITION, 0), 0).xy;\n    if(myCoords == ivec2(tankPos)){\n    \tcolor.r = 1.;\n    }\n    // Crosshair.\n    if(tankPos.x != -1.){\n        vec2 tankDir = vec2(myCoords) - tankPos;\n        float tankShootAngle = texelFetch(iChannel0, ivec2(TANK_SHOOT_ANGLE, 0), 0).x;\n        vec2 aimDir = vec2(\n            cos(tankShootAngle),\n            sin(tankShootAngle)\n        );\n        float d = dot(tankDir, aimDir);\n        float cosA = d/length(tankDir);\n        const float minRange = 30.;\n        const float maxRange = 300.;\n        const float maxCosA = 0.9998;\n        if(d > minRange && d < maxRange && cosA > maxCosA){\n            //color.rgb = vec3(1.);\n            float forwardFactor = (d-minRange)/(maxRange-minRange);\n            forwardFactor *= (1.-forwardFactor);\n            float sideFactor = (cosA - maxCosA)/(1.-maxCosA);\n            color = mix(color, vec3(1), forwardFactor*sideFactor);\n        }\n    }\n    //color.r = tankShootAngle*0.1;\n    //gp(myCoords + offsets[i]);\n    \n    //\n    if(exist(p)){\n        //color += length(p.xy)*.01;\n        //color = mix(color, vec3(1., 0.8, 0.5), length(p.xy)*.01);\n        float f = 0.02;\n        if(getClass(p) == WATER_VAPOR){\n            f = 0.002;\n        }\n        color += vec3(1.0, 0.5, 0.125) * length(p.xy)*f;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Math.\n# define PI 3.1415926538\n# define SPEED 1.0\n\n// Input.\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_SPACE  = 32;\nconst int KEY_W  = 87;\nconst int KEY_A = 65;\nconst int KEY_S  = 83;\nconst int KEY_D  = 68;\nconst int KEY_C  = 67;\nconst int KEY_V  = 86;\nconst int KEY_E  = 69;\nconst int KEY_R  = 82;\nconst int KEY_Q  = 81;\nconst int KEY_J  = 74;\nconst int KEY_K  = 75;\n\n# define EMPTY -1\nconst vec3 EMPTY_COLOR = vec3(0., 0., 0.)/255.;\n# define SAND 0\nconst vec3 SAND_COLOR = vec3(242., 198., 95.)/255.;\n# define WATER 1\nconst vec3 WATER_COLOR = vec3(51., 76., 122.)/255.;\n# define GAS 2\nconst vec3 GAS_COLOR = vec3(80., 163., 133.)/255.;\n# define FIRE 3\nconst vec3 FIRE_COLOR = vec3(214., 128., 51.)/255.;\n# define WATER_VAPOR 4\nconst vec3 WATER_VAPOR_COLOR = vec3(128., 128., 160.)/255.;\n# define BOMB 5\nconst vec3 BOMB_COLOR = vec3(255., 255., 0.)/255.;\n# define TANK 6\nconst vec3 TANK_COLOR = vec3(64., 127., 0.)/255.;\n# define EXPLOSION 7\nconst vec3 EXPLOSION_COLOR = vec3(255., 170., 102.)/255.;\n# define BROKEN_TANK 8\nconst vec3 BROKEN_TANK_COLOR = vec3(64., 64., 64.)/255.;\n# define AIRCRAFT 9\nconst vec3 AIRCRAFT_COLOR = vec3(192., 0., 127.)/255.;\n# define LAZER 10\nconst vec3 LAZER_COLOR = vec3(255., 0., 0.)/255.;\n# define MEGA_BOMB 11\nconst vec3 MEGA_BOMB_COLOR = vec3(0., 127., 127.)/255.;\n# define DIRT 12\nconst vec3 DIRT_COLOR = vec3(155., 118., 83.)/255.;\n# define CONCRETE 13\nconst vec3 CONCRETE_COLOR = vec3(100., 100., 100.)/255.;\n# define CONCRETE_BROKEN 14\nconst vec3 CONCRETE_BROKEN_COLOR = vec3(80., 80., 80.)/255.;\n# define NUKE 15\nconst vec3 NUKE_COLOR = vec3(0., 100., 255.)/255.;\n# define HOUSE 16\nconst vec3 HOUSE_COLOR = vec3(255., 255., 255.)/255.;\n# define GRASS 16\nconst vec3 GRASS_COLOR = vec3(76., 174., 5.)/255.;\n\n# define MENU_HEIGHT 20.\n# define MENU_WIDTH 20.\n# define MENU_NUM_BUTTONS 19.\n# define MENU_ERASER_COLOR vec3(0.5,0.5,0.5)\nconst int SELECTOR = 0;\nconst int MOUSE_TIME_DOWN = 1;\nconst int TANK_POSITION = 2;\nconst int TANK_SHOOT_ANGLE = 3;\nconst int TIME = 4;\nconst int AUTO_SPAWN_AIRCRAFT = 5;\n\n# define GP \\\nvec4 gp(ivec2 coords){\\\n    /*if(*/\\\n    /*    coords.x < 0 || coords.x >= int(iResolution.x) ||*/\\\n    /*\tcoords.y < 1 || coords.y >= int(iResolution.y)*/\\\n    /*){*/\\\n    /*\treturn vec4(0);*/\\\n    /*}*/\\\n    return texelFetch(iChannel0, coords, 0);\\\n}\\\nvec4 gp(vec2 coords){\\\n    return gp(ivec2(coords));\\\n}\n# define GET_INCOMING \\\nivec2 getIncoming(ivec2 coords, out vec4 particle){\\\n    vec4 pU, pUR, pUL, pR, pL, pDR, pDL, pD;\\\n    if(exist(pU = gp(coords + ivec2(0, 1))) &&\\\n    \t\tparticleCellDir(pU) == D){\\\n        particle = pU;\\\n        return coords + ivec2(0, 1);\\\n    }else if(exist(pUR = gp(coords + ivec2(1, 1))) &&\\\n        \tparticleCellDir(pUR) == DL){\\\n        particle = pUR;\\\n        return coords + ivec2(1, 1);\\\n    }else if(exist(pUL = gp(coords + ivec2(-1, 1))) &&\\\n        \tparticleCellDir(pUL) == DR){\\\n        particle = pUL;\\\n        return coords + ivec2(-1, 1);\\\n    }else if(exist(pR = gp(coords + ivec2(1, 0))) &&\\\n        \tparticleCellDir(pR) == L){\\\n        particle = pR;\\\n        return coords + ivec2(1, 0);\\\n    }else if(exist(pL = gp(coords + ivec2(-1, 0))) &&\\\n        \tparticleCellDir(pL) == R){\\\n        particle = pL;\\\n        return coords + ivec2(-1, 0);\\\n    }else if(exist(pDR = gp(coords + ivec2(1, -1))) &&\\\n        \tparticleCellDir(pDR) == UL){\\\n        particle = pDR;\\\n        return coords + ivec2(1, -1);\\\n    }else if(exist(pDL = gp(coords + ivec2(-1, -1))) &&\\\n        \tparticleCellDir(pDL) == UR){\\\n        particle = pDL;\\\n        return coords + ivec2(-1, -1);\\\n    }else if(exist(pD = gp(coords + ivec2(0, -1))) &&\\\n        \tparticleCellDir(pD) == U){\\\n        particle = pD;\\\n        return coords + ivec2(0, -1);\\\n    } else {\\\n        particle = vec4(0,0,0,0);\\\n        return ivec2(-1);\\\n    }\\\n}\n# define MOVE_PARTICLE \\\nvec4 moveParticle(vec4 p, ivec2 myCoords, out ivec2 targetCoordsOut){\\\n\t\\\n    vec4 pNextState = p;\\\n    \\\n    /* Simulate movement.*/\\\n    /* Determine this cell's state*/\\\n    if(exist(p)){\\\n    \t/* This cell's particle exist.*/\\\n        /* Check if particle tries to move out of cell.*/\\\n        vec4 targetP; /* Target particle.*/\\\n        int thisDir = particleCellDir(p);\\\n        ivec2 targetCoords = myCoords;\\\n        if(thisDir == U){\\\n        \ttargetCoords += ivec2(0,1);\\\n        } else if(thisDir == D){\\\n        \ttargetCoords += ivec2(0,-1);\\\n        } else if(thisDir == R){\\\n        \ttargetCoords += ivec2(1,0);\\\n        } else if(thisDir == L){\\\n        \ttargetCoords += ivec2(-1,0);\\\n        } else if(thisDir == UR){\\\n        \ttargetCoords += ivec2(1,1);\\\n        } else if(thisDir == UL){\\\n        \ttargetCoords += ivec2(-1,1);\\\n        } else if(thisDir == DR){\\\n        \ttargetCoords += ivec2(1,-1);\\\n        } else if(thisDir == DL){\\\n        \ttargetCoords += ivec2(-1,-1);\\\n        }\\\n        if(\\\n            !exist(gp(targetCoords)) &&\\\n            myCoords == getIncoming(/*ivec2 coords=*/targetCoords, /*out vec4 particle=*/targetP) &&\\\n            !((thisDir == D || thisDir == DR || thisDir == DL) && myCoords.y == 1) &&\\\n            !((thisDir == L || thisDir == UL || thisDir == DL) && myCoords.x == 0) &&\\\n            !((thisDir == R || thisDir == UR || thisDir == DR) && myCoords.x == int(iResolution.x)-1) &&\\\n            !((thisDir == U || thisDir == UR || thisDir == UL) && myCoords.y == int(iResolution.y)-1)\\\n        ){\\\n            /* This particle is going to the target.*/\\\n        \tdestroy(pNextState);\\\n        \ttargetCoordsOut = targetCoords;\\\n        } else {\\\n            /* Stay the same.*/\\\n            /* Move by velocity.*/\\\n            vec2 pos = getPos(pNextState);\\\n            pos += limSize(pNextState.xy);\\\n            pos = clamp(pos, 0., 1.-1e-5);\\\n            pNextState.zw = floor(pNextState.zw) + pos;\\\n            \\\n            targetCoordsOut = myCoords;\\\n        }\\\n    } else {\\\n    \t/* This cell's particle does not exist.*/\\\n        /* Look for particle moving into cell.*/\\\n        ivec2 incomingCoords = getIncoming(/*ivec2 coords=*/myCoords, /*out vec4 particle=*/pNextState);\\\n        if(incomingCoords.x != -1){\\\n        \tvec2 pos = getPos(pNextState);\\\n            pos += limSize(pNextState.xy);\\\n            pos = mod(pos.xy, 1.-1e-3);\\\n            pNextState.zw = floor(pNextState.zw) + pos;\\\n            \\\n            targetCoordsOut = incomingCoords;\\\n        } else {\\\n        \ttargetCoordsOut = myCoords;\\\n        }\\\n    }\\\n    return pNextState;\\\n}\n# define SHOULD_DETONATE_BOMB \\\nbool shouldDetonateBomb(int cl){\\\n    return cl != BOMB && cl != FIRE && cl != EXPLOSION && cl != WATER_VAPOR && cl != WATER && cl != LAZER;\\\n}\n# define SHOULD_DETONATE_MEGA_BOMB \\\nbool shouldDetonateMegaBomb(int cl){\\\n    return cl != BOMB && cl != MEGA_BOMB && cl != FIRE && cl != EXPLOSION && cl != WATER_VAPOR && cl != WATER && cl != LAZER && cl != AIRCRAFT && cl != GAS;\\\n}\n# define SHOULD_DETONATE_NUKE \\\nbool shouldDetonateNuke(int cl){\\\n    return cl != BOMB && cl != MEGA_BOMB && cl != NUKE && cl != FIRE && cl != EXPLOSION && cl != WATER_VAPOR && cl != WATER && cl != LAZER && cl != AIRCRAFT && cl != GAS;\\\n}\n# define CALC_IMPULSES \\\nvec4 calcImpulses(ivec2 myCoords, int iteration){\\\n    vec4 p = gp(myCoords);\\\n    \\\n\tvec4 pNextState = p;\\\n    \\\n    ivec2 tankPos = ivec2(texelFetch(iChannel0, ivec2(TANK_POSITION, 0), 0).xy);\\\n    int pClass = getClass(p);\\\n    \\\n    /* Simulate forces.*/\\\n    \\\n    /* Collisions.*/\\\n    /* Particle-particle.*/\\\n    const ivec2 offsets[8] = ivec2[](\\\n        ivec2( 0, 1),\\\n        ivec2(-1, 1),\\\n        ivec2( 1, 1),\\\n        ivec2(-1, 0),\\\n        ivec2( 1, 0),\\\n        ivec2(-1,-1),\\\n        ivec2( 1,-1),\\\n        ivec2( 0,-1)\\\n    );\\\n    const vec2 normals[8] = vec2[](\\\n        normalize(vec2( 0,-1)),\\\n        normalize(vec2( 1,-1)),\\\n        normalize(vec2(-1,-1)),\\\n        normalize(vec2( 1, 0)),\\\n        normalize(vec2(-1, 0)),\\\n        normalize(vec2( 1, 1)),\\\n        normalize(vec2(-1, 1)),\\\n        normalize(vec2( 0, 1))\\\n    );\\\n    const int directions[8] = int[](\\\n    \tU, UL, UR, L, R, DL, DR, D\\\n    );\\\n    int cellMoveDir = particleCellDir(p);\\\n    vec4 targets[8];\\\n    for(int i=0; i<8; i++){\\\n    \tivec2 targetCoords = myCoords + offsets[i];\\\n        vec4 target = gp(targetCoords);\\\n        int targetClass = getClass(target);\\\n        targets[i] = target;\\\n        int direction = directions[i];\\\n        if(exist(p)){\\\n            if(exist(target)){\\\n                /**/\\\n                vec2 normal = normals[i];\\\n                /* Remove bomb. */\\\n                const float MIN_EXPLODE_DIST_TANK = 20.;\\\n                if(pClass == BOMB && shouldDetonateBomb(targetClass)){\\\n                    if(length(vec2(myCoords) - vec2(tankPos)) > MIN_EXPLODE_DIST_TANK &&\\\n                       targetClass != CONCRETE && targetClass != CONCRETE_BROKEN && targetClass != FIRE){\\\n                    \tsetClass(pNextState, EXPLOSION);\\\n                    }else{\\\n                    \tsetClass(pNextState, FIRE);\\\n                    }\\\n                }\\\n                /* Remove mega bomb. */\\\n                if(pClass == MEGA_BOMB && shouldDetonateMegaBomb(targetClass) && exist(gp(targetCoords + offsets[i]))){\\\n                \tsetClass(pNextState, EXPLOSION);\\\n                    pNextState.xy += -normal*16384. * sqrt(SPEED);\\\n                }\\\n                /* Remove nuke. */\\\n                if(pClass == NUKE && shouldDetonateNuke(targetClass)){\\\n                \tsetClass(pNextState, EXPLOSION);\\\n                    pNextState.xy += -normal*1.e9 * SPEED;\\\n                }\\\n                \\\n                /* Move apart if stuck. */\\\n                if(exist(target) && cellMoveDir == direction){\\\n                    \\\n                    vec2 myNextPos = getPos(pNextState);\\\n                    /* -(Normal (C - (0.5, 0.5))) Normal + C*/\\\n                    myNextPos = -dot(normal, myNextPos-vec2(0.5,0.5)) * normal + myNextPos;\\\n                    pNextState.zw = floor(pNextState.zw) + myNextPos;\\\n                }\\\n                \\\n                /* Heat transfer. */\\\n                /*int tempP = getTemperature(p);*/\\\n                /*int tempPN = getTemperature(pNextState);*/\\\n                /*int tempT = getTemperature(target);*/\\\n                /*int diff = tempP - tempT;*/\\\n                /*int breaker = 0;*/\\\n                /*if(diff < 0){*/\\\n                /*\tbreaker = -1;*/\\\n                /*} else if (diff > 0){*/\\\n                /*\tbreaker = 1;*/\\\n                /*}*/\\\n                /*setTemperature(pNextState, tempPN - diff/8);*/\\\n                \\\n                /* Evaporate water by fire. */\\\n                if(pClass == WATER && targetClass == FIRE && hash(vec2(myCoords.x, myCoords.y + i*11) + vec2(iTime*0.04)) < 0.5){\\\n                    setClass(pNextState, WATER_VAPOR);\\\n                }\\\n                /* Gas force. */\\\n                float repulsor = 0.;\\\n                if(length(pNextState.xy) < 1e2){\\\n                    if(pClass == GAS){\\\n                        repulsor = 4.;\\\n                    }else if(pClass == FIRE){\\\n                        repulsor = 0.2;\\\n                    }else if(pClass == WATER_VAPOR){\\\n                        repulsor = 1.;\\\n                    }else if(pClass == EXPLOSION){\\\n                        repulsor = 4.;\\\n                    }\\\n                }\\\n                \\\n                /* Bomb force. */\\\n                if(targetClass == BOMB && shouldDetonateBomb(pClass) && length(vec2(myCoords) - vec2(tankPos)) > MIN_EXPLODE_DIST_TANK){\\\n                    pNextState.xy += normal*1. * SPEED;\\\n                }\\\n                /* Mega bomb force. */\\\n                /*if(targetClass == MEGA_BOMB && shouldDetonateMegaBomb(pClass)){*/\\\n                    /*pNextState.xy += normal*40.*100.;*/\\\n                /*}*/\\\n                /* Nuke force. */\\\n                /*if(targetClass == NUKE && shouldDetonateNuke(pClass)){*/\\\n                    /*pNextState.xy += normal*1.e8;*/\\\n                /*}*/\\\n                \\\n                /* Explosion force. */\\\n                if(pClass != EXPLOSION && pClass != FIRE && pClass != BOMB && targetClass == EXPLOSION){\\\n                    pNextState.xy += normal*40. * SPEED;\\\n                }\\\n                /* Test. */\\\n                /*if((pClass == CONCRETE || pClass == CONCRETE_BROKEN) && targetClass == GAS){*/\\\n                    /*setClass(pNextState, WATER_VAPOR);*/\\\n                /*}*/\\\n                \\\n                /* Tank evaporate water. */\\\n                if(pClass == WATER && targetClass == TANK){\\\n                    setClass(pNextState, WATER_VAPOR);\\\n                }\\\n                \\\n                /* Tank dig sand. */\\\n                if(pClass == SAND && targetClass == TANK && targetCoords == tankPos && direction == D &&\\\n                   (texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x > 0.5 || texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x > 0.5)){\\\n                    pNextState.y += 1.;\\\n                }\\\n                \\\n                /* Collision impulse.*/\\\n                /* Normal collision.*/\\\n                float collisionDampener = 0.98;\\\n                if(pClass == WATER || targetClass == WATER){\\\n                    collisionDampener = 0.9;\\\n                }else if(pClass == GAS || targetClass == GAS){\\\n                    collisionDampener = 0.9;\\\n                }else if(pClass == WATER_VAPOR || targetClass == WATER_VAPOR){\\\n                    collisionDampener = 0.9;\\\n                }\\\n                vec2 relVel = target.xy*collisionDampener - p.xy; /* Target velocity - this particle velocity.*/\\\n                \\\n                float relVelProj = dot(relVel, normal) + repulsor;\\\n                /*if(relVelProj < 0.){*/\\\n                    /*continue;*/ /* The particles are moving apart.*/\\\n                /*}*/\\\n                float el = 1.; /* 0.5 non-elastic, 1.0 elastic collision.*/\\\n                if(relVelProj > 2.){\\\n                    el = 1.; /* Allow for shock waves. */\\\n                }\\\n                float massA = getMass(p);\\\n                float massB = getMass(target);\\\n                float collisionMass = 1./(1./massA + 1./massB); /* Force / collisionMass = acceleration.*/\\\n                float impulse = collisionMass * relVelProj * el;\\\n                impulse = max(impulse, 0.);\\\n                pNextState.xy += normal * impulse/massA;\\\n                \\\n                /* Tank break. */\\\n                if(pClass == TANK && (impulse > 40. ||\\\n                  targetClass == LAZER)){\\\n                    setClass(pNextState, BROKEN_TANK);\\\n                }\\\n                \\\n                /* Broken tank explode. */\\\n                if(pClass == BROKEN_TANK && (impulse > 20. && hash(vec2(myCoords.x, myCoords.y + i*11) + vec2(iTime*0.04)) < 0.25 ||\\\n                  targetClass == LAZER)){\\\n                    setClass(pNextState, EXPLOSION);\\\n                }\\\n                /* Explode aircraft. */\\\n                if(pClass == AIRCRAFT && (targetClass == BOMB || targetClass != LAZER && impulse > 5.)){\\\n                    setClass(pNextState, EXPLOSION);\\\n                }\\\n                \\\n                /* Fire ignite gass. */\\\n                if(pClass == GAS && targetClass == FIRE){\\\n                    setClass(pNextState, FIRE);\\\n                }\\\n                \\\n                /* Fire put out by water. */\\\n                if(pClass == FIRE && (targetClass == WATER || targetClass == WATER_VAPOR)){\\\n                    destroy(pNextState);\\\n                }\\\n                /*Burn Grass*/\\\n                if(pClass == GRASS && (targetClass == FIRE || targetClass == EXPLOSION) && hash(vec2(myCoords.x, myCoords.y + i*11) + vec2(iTime*0.04)) < 0.2){\\\n                    setClass(pNextState, FIRE);\\\n                }\\\n            }else{\\\n            }\\\n        }else{\\\n            /* Fire spawn from explosion. */\\\n            if(targetClass == EXPLOSION && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.05){\\\n            \tsetClass(pNextState, FIRE);\\\n                pNextState.xy = target.xy;\\\n            }\\\n            /* Fire spawn from energized materials. */\\\n            float energy;\\\n            if(exist(target) &&\\\n                (energy = pow(length(target.xy), 2.) * getMass(target)) > 800. &&\\\n                energy < 100000. &&\\\n                shouldDetonateMegaBomb(targetClass) &&\\\n                dot(normals[i], target.xy) <= 0. &&\\\n                hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.25\\\n                ){\\\n            \tsetClass(pNextState, FIRE);\\\n                pNextState.xy = 0.*-target.xy;\\\n            }\\\n            /* Fire spread. */\\\n            if(targetClass == FIRE && hash(vec2(myCoords) + vec2(iTime*0.05)) < 0.0006){\\\n            \tsetClass(pNextState, FIRE);\\\n                pNextState.xy = target.xy;\\\n            }\\\n            /* Broken tank burn. */\\\n            if(targetClass == BROKEN_TANK && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.05){\\\n            \tsetClass(pNextState, FIRE);\\\n                pNextState.xy = target.xy;\\\n            }\\\n            /*Spawn aircrafts.*/\\\n            bool doAutoSpawn = texelFetch(iChannel0, ivec2(AUTO_SPAWN_AIRCRAFT, 0), 0).x > 0.5;\\\n            if(doAutoSpawn && myCoords == ivec2(iResolution.x*0.5, iResolution.y*0.95) && hash(vec2(myCoords.x, myCoords.y) + vec2(iTime*0.04)) < 6.e-3){\\\n            \tsetClass(pNextState, AIRCRAFT);\\\n            }\\\n        }\\\n    }\\\n    /* Fire bomb from tank. */\\\n    ivec2 tankPosOffset = ivec2(0, -4);\\\n    vec4 tank = texelFetch(iChannel0, myCoords + tankPosOffset, 0);\\\n    if(\\\n        iteration == 0 && getClass(tank) == TANK &&\\\n        tankPos == myCoords + tankPosOffset &&\\\n        texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).x > 0.5 /*&&*/\\\n        /*ivec2(texelFetch(iChannel0, ivec2(TIME, 0), 0)).x % 8 == 0*/\\\n    ){\\\n        setClass(pNextState, BOMB);\\\n        float tankShootAngle = texelFetch(iChannel0, ivec2(TANK_SHOOT_ANGLE, 0), 0).x;\\\n        vec2 aimDir = vec2(\\\n            cos(tankShootAngle),\\\n            sin(tankShootAngle)\\\n        );\\\n        pNextState.xy = tank.xy + aimDir*15.;\\\n    }\\\n    \\\n    /* Fire put out by itself. */\\\n    if(pClass == FIRE && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.01){\\\n \t\tdestroy(pNextState);\\\n    }\\\n    /* Explosion put out by itself. */\\\n    if(pClass == EXPLOSION && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.02){\\\n \t\tsetClass(pNextState, FIRE);\\\n    }\\\n    /* Condensate water. */\\\n    if(pClass == WATER_VAPOR && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.0001){\\\n        setClass(pNextState, WATER);\\\n    }\\\n    /* Water force. */\\\n    const float waterForce = 0.1 * SPEED;\\\n    vec4 pD = gp(myCoords + ivec2(0, -1));\\\n    if(length(pNextState.xy) < 1e1){\\\n        if(pClass == WATER && exist(pD) && getClass(pD) == WATER){\\\n            vec4 left = targets[3];\\\n            vec4 right = targets[4];\\\n            if(exist(right) && getClass(right) == WATER){\\\n                if(exist(left) && getClass(left) == WATER){\\\n                    vec4 leftLeft = gp(myCoords + ivec2(-2,0));\\\n                    vec4 rightRight = gp(myCoords + ivec2(2,0));\\\n                    if(exist(rightRight) && getClass(rightRight) == WATER){\\\n                        if(exist(leftLeft) && getClass(leftLeft) == WATER){\\\n                            /* Do nothing.*/\\\n                        }else{\\\n                            pNextState.x -= waterForce;\\\n                        }\\\n                    }else if(exist(leftLeft) && getClass(leftLeft) == WATER){\\\n                        pNextState.x += waterForce;\\\n                    }else{\\\n                        /* Do nothing.*/\\\n                    }\\\n                }else{\\\n                    pNextState.x -= waterForce;\\\n                }\\\n            }else if(exist(left) && getClass(left) == WATER){\\\n                pNextState.x += waterForce;\\\n            } else{\\\n                /* Do nothing.*/\\\n            }\\\n        }\\\n    }\\\n    /*Spawn grass.*/\\\n    vec4 pU = gp(myCoords + ivec2(0, 1));\\\n    int pUClass = getClass(pU);\\\n    vec4 pUU = gp(myCoords + ivec2(0, 2));\\\n    int pUUClass = getClass(pUU);\\\n    if(exist(p) && getClass(p) == WATER && !exist(pU) && exist(pD) && (getClass(pD) == SAND || getClass(pD) == DIRT) && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.5){\\\n        setClass(pNextState, GRASS);\\\n    }\\\n    /*Remove grass.*/\\\n    vec4 pUUU;\\\n    int pUUUClass;\\\n    if(exist(p) && getClass(p) == GRASS &&\\\n        exist(pU) && (pUClass == SAND || pUClass == WATER) &&\\\n        exist(pUU) && (pUUClass == SAND || pUUClass == WATER) &&\\\n        exist((pUUU = gp(myCoords + ivec2(0,3)))) &&\\\n            ((pUUUClass = getClass(pUUU)) == SAND || pUUUClass == WATER) &&\\\n        hash(vec2(myCoords.x+1, myCoords.y) + vec2(iTime*0.04)) < 0.01){\\\n        setClass(pNextState, WATER_VAPOR);\\\n    }\\\n    /* Evaporate water by itself. */\\\n    if(pClass == WATER && pUClass != WATER && pUUClass != WATER && hash(vec2(myCoords.x+1, myCoords.y) + vec2(iTime*0.04)) < 0.0001){\\\n        setClass(pNextState, WATER_VAPOR);\\\n    }\\\n    /* Control enemy aircraft. */\\\n    if(pClass == AIRCRAFT){\\\n        /* Accelerate forward. */\\\n        vec2 dir = vec2(0,1);\\\n        float l = length(pNextState.xy);\\\n        if(l > 0.) dir = pNextState.xy/l;\\\n        pNextState.xy += dir*0.1;\\\n        /* Slow down to speed of 0.5. */\\\n        pNextState.xy /= max(l*2., 1.);\\\n        /*ivec2 toTank = tankPos - myCoords;*/\\\n        vec2 sideways = vec2(-dir.y, dir.x);\\\n        ivec2 frontLeft = ivec2(vec2(myCoords) + dir*100. + sideways*30.);\\\n        ivec2 frontRight = ivec2(vec2(myCoords) + dir*100. - sideways*30.);\\\n        if(\\\n            frontLeft.x > int(iResolution.x) || frontLeft.x < 0 || frontLeft.y > int(iResolution.y) || frontLeft.y < 0 ||\\\n            getClass(gp(frontLeft)) != EMPTY\\\n        ){\\\n            pNextState.xy -= sideways*0.05;\\\n        }else if(\\\n            frontRight.x > int(iResolution.x) || frontRight.x < 0 || frontRight.y > int(iResolution.y) || frontRight.y < 0 ||\\\n            getClass(gp(frontRight)) != EMPTY\\\n        ){\\\n            pNextState.xy += sideways*0.05;\\\n        }else if(tankPos.x != -1){\\\n            vec2 tankDir = vec2(tankPos) - vec2(myCoords);\\\n            if(dot(tankDir, sideways) > 0.){\\\n            \tpNextState.xy += sideways*0.002;\\\n            } else {\\\n            \tpNextState.xy -= sideways*0.002;\\\n            }\\\n        }\\\n    }\\\n    /* Fire lazer/mega bomb from aircraft. */\\\n    ivec2 aircraftPosOffset = ivec2(0, 4);\\\n    vec4 aircraft = texelFetch(iChannel0, myCoords + aircraftPosOffset, 0);\\\n    if(\\\n        tankPos.x != -1 && iteration == 0 && getClass(aircraft) == AIRCRAFT && hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.0025 &&\\\n        dot(normalize(vec2(tankPos) - vec2(myCoords+aircraftPosOffset)), normalize(aircraft.xy)) > 0.9\\\n    ){\\\n        if(hash(vec2(myCoords+1) + vec2(iTime*0.04)) < 0.1){\\\n        \tsetClass(pNextState, MEGA_BOMB);\\\n            pNextState.xy = aircraft.xy*64.;\\\n        }else{\\\n        \tsetClass(pNextState, LAZER);\\\n        \tpNextState.xy = aircraft.xy;\\\n        }\\\n    }\\\n    /* Lazer. */\\\n    if(pClass == LAZER){\\\n       \tfloat l = length(pNextState.xy);\\\n        if(l == 0.){\\\n        \tpNextState.xy = normalize(vec2(-1,-1));\\\n            l = 1.;\\\n        }\\\n    \tpNextState.xy = pNextState.xy/l*10.;\\\n        if(hash(vec2(myCoords) + vec2(iTime*0.04)) < 0.001){\\\n        \tdestroy(pNextState);\\\n        }\\\n    }\\\n    /* Particle-ground.*/\\\n    if(myCoords.y == 1 && pNextState.y < 0.){\\\n    \tpNextState.y = -0.5*pNextState.y;\\\n    \tpNextState.x *= 0.99;\\\n    }\\\n    /* Particle-ceiling.*/\\\n    if(myCoords.y == int(iResolution.y)-1 && pNextState.y > 0.){\\\n    \tpNextState.y = -0.5*pNextState.y;\\\n    \tpNextState.x *= 0.99;\\\n    }\\\n    /* Particle-left wall.*/\\\n    if(myCoords.x == 0 && pNextState.x < 0.){\\\n    \tpNextState.x = -0.5*pNextState.x;\\\n    \tpNextState.y *= 0.99;\\\n    }\\\n    /* Particle-right wall.*/\\\n    if(myCoords.x == int(iResolution.x)-1 && pNextState.x > 0.){\\\n    \tpNextState.x = -0.5*pNextState.x;\\\n    \tpNextState.y *= 0.99;\\\n    }\\\n    \\\n    /* Make sticky.*/\\\n\t/*vec2 myNextPos = getPos(pNextState);*/\\\n    /*myNextPos = mix(myNextPos, vec2(0.5,0.5), 0.1);*/\\\n    /*pNextState.zw = floor(pNextState.zw) + myNextPos;*/\\\n    \\\n    /*Concrete force*/\\\n    bool isSupported = false;\\\n    /*Break concrete*/\\\n    if(exist(p) && (pClass == CONCRETE || pClass == CONCRETE_BROKEN)){\\\n        vec4 below   = gp(myCoords + ivec2( 0,-1));\\\n        int belowClass = getClass(below);\\\n        \\\n        vec4 belowR  = gp(myCoords + ivec2( 1,-1));\\\n        int belowRClass = getClass(belowR);\\\n        \\\n        vec4 belowL  = gp(myCoords + ivec2(-1,-1));\\\n        int belowLClass = getClass(belowL);\\\n        \\\n        vec4 right   = gp(myCoords + ivec2( 1, 0));\\\n        int rightClass = getClass(right);\\\n        \\\n        vec4 left    = gp(myCoords + ivec2(-1, 0));\\\n        int leftClass = getClass(left);\\\n        \\\n        vec4 rightRight   = gp(myCoords + ivec2( 2, 0));\\\n        int rightRightClass = getClass(rightRight);\\\n        \\\n        vec4 leftLeft    = gp(myCoords + ivec2(-2, 0));\\\n        int leftLeftClass = getClass(leftLeft);\\\n        \\\n        vec4 rightRightD = gp(myCoords + ivec2( 2,-1));\\\n        int rightRightDClass = getClass(rightRightD);\\\n        \\\n        vec4 leftLeftD = gp(myCoords + ivec2(-2,-1));\\\n        int leftLeftDClass = getClass(leftLeftD);\\\n        \\\n        vec4 rightRightRight   = gp(myCoords + ivec2( 3, 0));\\\n        int rightRightRightClass = getClass(rightRightRight);\\\n        \\\n        vec4 leftLeftLeft    = gp(myCoords + ivec2(-3, 0));\\\n        int leftLeftLeftClass = getClass(leftLeftLeft);\\\n        \\\n        vec4 rightRightRightD = gp(myCoords + ivec2( 3,-1));\\\n        int rightRightRightDClass = getClass(rightRightRightD);\\\n        \\\n        vec4 leftLeftLeftD = gp(myCoords + ivec2(-3,-1));\\\n        int leftLeftLeftDClass = getClass(leftLeftLeftD);\\\n        if(\\\n            myCoords.y <= 1 ||\\\n            belowClass==CONCRETE || belowClass==SAND || belowClass==DIRT ||\\\n            exist(right) && (belowRClass==CONCRETE || belowRClass==SAND || belowRClass==DIRT) ||\\\n            exist(left) && (belowLClass==CONCRETE || belowLClass==SAND || belowLClass==DIRT) ||\\\n            exist(right) && exist(rightRight) && (rightRightDClass==CONCRETE || rightRightDClass==SAND || rightRightDClass==DIRT) ||\\\n            exist(left) && exist(leftLeft) && (leftLeftDClass==CONCRETE || leftLeftDClass==SAND || leftLeftDClass==DIRT) ||\\\n            exist(right) && exist(rightRight) && exist(rightRightRight) && (rightRightRightDClass==CONCRETE || rightRightRightDClass==SAND || rightRightRightDClass==DIRT) ||\\\n            exist(left) && exist(leftLeft) && exist(leftLeftLeft) && (leftLeftLeftDClass==CONCRETE || leftLeftLeftDClass==SAND || leftLeftLeftDClass==DIRT)\\\n        ){\\\n            isSupported = true;\\\n            if(pClass == CONCRETE){\\\n\t\t\t\tpNextState.x *= 0.8;\\\n                pNextState.y *= 0.8;\\\n                vec2 pos = getPos(pNextState);\\\n                pNextState = setPos(pNextState, mix(pos, vec2(0.5,0.5), 0.1));\\\n            }\\\n        }\\\n    }\\\n    if(exist(p) && pClass == CONCRETE && !isSupported){\\\n        setClass(pNextState, CONCRETE_BROKEN);\\\n    }\\\n    if(exist(p) && pClass == CONCRETE_BROKEN && isSupported && hash(vec2(myCoords.x, myCoords.y) + vec2(iTime*0.04)) < 0.005){\\\n        setClass(pNextState, CONCRETE);\\\n    }\\\n    /**/\\\n    float drag = 0.995;\\\n    /* Gravity.*/\\\n    if(true || !exist(pD)){\\\n        float gravity = -0.01;\\\n        if(isSupported){\\\n            gravity = 0.;\\\n        }else if(pClass == WATER_VAPOR){\\\n        \tgravity *= -1.;\\\n        }else if(pClass == FIRE){\\\n            gravity *= -1.;\\\n            drag = 0.99;\\\n        }else if(pClass == EXPLOSION){\\\n            gravity *= -100.;\\\n        }else if(pClass == AIRCRAFT){\\\n            gravity *= 0.;\\\n        }else if(pClass == LAZER){\\\n            gravity *= 0.;\\\n        }\\\n    \tpNextState.y += gravity * SPEED;\\\n        /*vec2 rad = vec2((myCoords - ivec2(iResolution*0.5)));*/\\\n        /*float l = length(rad);*/\\\n        /*pNextState.xy += -rad*10.0/(l*l*l+10.);*/\\\n    }\\\n    \\\n    /* Drag.*/\\\n    pNextState.xy *= pow(drag, SPEED);\\\n    \\\n    return pNextState;\\\n}\n# define SWAP_ABOVE_AND_CALC_IMPULSES \\\nvec4 swapAboveAndCalcImpulses(ivec2 myCoords, int iteration){\\\n    vec4 p = gp(myCoords);\\\n    ivec2 offset=ivec2(0,0);\\\n\t\\\n    if(exist(p) && getClass(p) != CONCRETE){\\\n        vec4 pU = gp(myCoords + ivec2(0, 1));\\\n        float pPriority = getPriority(p);\\\n        if(exist(pU) && getClass(pU) != CONCRETE){\\\n            float puPriority = getPriority(pU);\\\n            if(pPriority < puPriority){\\\n                vec4 pUU = gp(myCoords + ivec2(0, 2));\\\n                if(exist(pUU) && puPriority < getPriority(pUU) && getClass(pUU) != CONCRETE){\\\n                    /* Do nothing.*/\\\n                } else{\\\n                    /* Swap with above.*/\\\n                    offset= ivec2(0, 1);\\\n                }\\\n            }else{\\\n                /* Swap with below.*/\\\n                vec4 pD = gp(myCoords + ivec2(0, -1));\\\n                if(exist(pD) && getPriority(pD) < pPriority && getClass(pD) != CONCRETE){\\\n                    offset=  ivec2(0, -1);\\\n                }\\\n            }\\\n        }else{\\\n            /* Swap with below.*/\\\n            vec4 pD = gp(myCoords + ivec2(0, -1));\\\n            if(exist(pD) && getPriority(pD) < pPriority && getClass(pD) != CONCRETE){\\\n                 offset=  ivec2(0, -1);\\\n            } \\\n        }\\\n    }\\\n        /* Do nothing.*/\\\n    return calcImpulses(myCoords+offset, iteration);\\\n}\n# define TRACK_TANK \\\nivec2 trackTank(ivec2 tankCoords){\\\n\t/* Track tank. */\\\n    vec4 pC, pU, pUR, pUL, pR, pL, pDR, pDL, pD;\\\n    if(exist(pC = gp(tankCoords + ivec2( 0, 0))) && getClass(pC) == TANK){\\\n        return tankCoords + ivec2( 0, 0);\\\n    }else if(exist(pU = gp(tankCoords + ivec2( 0, 1))) && getClass(pU) == TANK){\\\n        return tankCoords + ivec2( 0, 1);\\\n    }else if(exist(pUR = gp(tankCoords + ivec2( 1, 1))) && getClass(pUR) == TANK){\\\n        return tankCoords + ivec2( 1, 1);\\\n    }else if(exist(pUL = gp(tankCoords + ivec2(-1, 1))) && getClass(pUL) == TANK){\\\n        return tankCoords + ivec2(-1, 1);\\\n    }else if(exist(pR = gp(tankCoords + ivec2( 1, 0))) && getClass(pR) == TANK){\\\n        return tankCoords + ivec2( 1, 0);\\\n    }else if(exist(pL = gp(tankCoords + ivec2(-1, 0))) && getClass(pL) == TANK){\\\n        return tankCoords + ivec2(-1, 0);\\\n    }else if(exist(pDR = gp(tankCoords + ivec2( 1,-1))) && getClass(pDR) == TANK){\\\n        return tankCoords + ivec2( 1,-1);\\\n    }else if(exist(pDL = gp(tankCoords + ivec2(-1,-1))) && getClass(pDL) == TANK){\\\n        return tankCoords + ivec2(-1,-1);\\\n    }else if(exist(pD = gp(tankCoords + ivec2( 0,-1))) && getClass(pD) == TANK){\\\n        return tankCoords + ivec2( 0,-1);\\\n    } else {\\\n        return ivec2(-1);\\\n    }\\\n}\\\n\nbool exist(vec4 p){\n\treturn p.z >= 1.;\n}\n\nvoid destroy(inout vec4 p){\n\tp.z = 0.;\n}\n\nvec2 getPos(vec4 p){\n\treturn mod(p.zw, 1.);\n}\n\nvec4 setPos(vec4 p, vec2 newPos){\n\treturn vec4(p.xy, floor(p.zw) + newPos);\n}\n\nint getClass(vec4 p){\n\treturn int(p.z)-1;\n}\n\nvoid setClass(inout vec4 p, int cl){\n\tp.z = mod(p.z, 1.) + float(cl+1);\n}\n\n/*int getTemperature(vec4 p){\n\treturn int(floor(p.w));\n}*/\n\n/*void setTemperature(inout vec4 p, int temp){\n\tp.w = mod(p.w, 1.) + float(temp);\n}*/\nconst float MASSES[17] = float[](\n    2.55, // Sand.\n    1.00, // Water.\n    0.01, // Gass.\n    0.01, // Fire.\n    0.01, // Water vapor.\n    9.00, // Bomb.\n   90.00, // TANK.\n    1.00, // Explosion.\n   90.00, // Broken tank.\n    2.55, // Aircraft.\n    3.00, // Lazer.\n10000.00, // Mega bomb.\n    1.50, // Dirt.\n   15.00, // Concrete.\n   15.00, // Concrete broken.\n    2.55, // Nuke.\n    1.00  // Grass.\n);\nfloat getMass(vec4 p){\n\treturn MASSES[getClass(p)];\n}\nconst float PRIORITIES[17] = float[](\n    2.,  // Sand.\n    1.,  // Water.\n    0.,  // Gass.\n    0.,  // Fire.\n    0.,  // Water vapor.\n    2.,  // Bomb.\n    2.,  // TANK.\n    0.,  // EXPLOSION.\n    2.,  // Broken tank.\n    2.,  // Aircraft.\n    2.,  // Lazer.\n    2.,  // Mega bomb.\n    2.,  // Dirt.\n    2.,  // Concrete.\n    2.,  // Concrete broken.\n    2.,  // Nuke.\n    2.   // Grass.\n);\nfloat getPriority(vec4 p){\n\treturn PRIORITIES[getClass(p)];\n}\n\nvec2 limSize(vec2 v){\n\tfloat l = dot(v,v);\n    if(l > 1.){\n    \tv /= sqrt(l);\n    }\n    return v;\n}\n\n# define C 0\n# define U 1\n# define D 2\n# define R 3\n# define L 4\n# define UR 5\n# define UL 6\n# define DR 7\n# define DL 8\n// Given the velocity of the particle, what other cell is it trying to reach?\nint particleCellDir(vec4 p){\n    vec2 pos = getPos(p);\n    vec2 nextPos = pos + limSize(p.xy);\n    if(nextPos.x >= 1.){\n    \t// Right.\n        if(nextPos.y >= 1.){\n        \t// Up.\n            return UR;\n        } else if(nextPos.y < 0.) {\n        \t// Down.\n            return DR;\n        } else {\n        \t// Vertical center.\n            return R;\n        }\n    } else if(nextPos.x < 0.){\n    \t// Left.\n        if(nextPos.y >= 1.){\n        \t// Up.\n            return UL;\n        } else if(nextPos.y < 0.) {\n        \t// Down.\n            return DL;\n        } else {\n        \t// Vertical center.\n            return L;\n        }\n    } else {\n        // Horizontal center.\n    \tif(nextPos.y >= 1.){\n        \t// Up.\n            return U;\n        } else if(nextPos.y < 0.) {\n        \t// Down.\n            /*if(getClass(p) == WATER){\n                if(p.x > 0.){\n                \treturn DR;\n                }else{\n                \treturn DL;\n                }\n            }*/\n            return D;\n        } else {\n        \t// Vertical center.\n            if(getClass(p) == WATER){\n                if(p.x > 0.){\n                \treturn R;\n                }else{\n                \treturn L;\n                }\n            }\n            return C;\n        }\n    }\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n/*\nbool getKeyToggle(int key){\\\n\treturn texelFetch( iChannel1, ivec2(key,2), 0 ).x > 0.5;\\\n}\\\nbool getKeyDown(int key){\\\n\treturn texelFetch( iChannel1, ivec2(key,0), 0 ).x > 0.5;\\\n}\\\nbool getKeyClick(int key){\\\n\treturn texelFetch( iChannel1, ivec2(key,1), 0 ).x > 0.5;\\\n}\\\n*/", "buffer_a_code": "\n// Particle.\n// p.xy = velocity right and up.\n// mod(p.zw, 1.) = position inside cell from left bottom.\n// floor(z) = class. 0 = empty, 1=sand.\n// floor(w) = temperature (celsius).\n\n// A particle can only move into an empty cell.\n// DL down left, D down center, DR down right, L center left, R center right, UL up left, U up center,  UR up right.\n// If there are multiple particles trying to move to the same cell, the order of prioritazion is U, UR, UL, R, L, DR, DL, D.\nGP\nGET_INCOMING\nMOVE_PARTICLE\n//SHOULD_DETONATE_BOMB\n//SHOULD_DETONATE_MEGA_BOMB\n//SHOULD_DETONATE_NUKE\n//CALC_IMPULSES\n//SWAP_ABOVE_AND_CALC_IMPULSES\nTRACK_TANK\n\nbool house(in vec2 fragCoord, in vec2 pos){\n    float d = length(fragCoord.xy - 0.5 - pos);\n    ivec2 diff = ivec2(fragCoord.xy - pos);\n    float rr = 3.;\n    if(\n    diff.x < 30 && diff.x > -30 && diff.y < 10 && diff.y > 0 ||\n    sdSegment( vec2(diff), vec2(-35, -7), vec2(1, 5)) < rr+1. ||\n    sdSegment( vec2(diff), vec2(35, -7), vec2(-1, 5)) < rr+1. ||\n    diff.x <= -30 && diff.x > -39 && diff.y < 79 && diff.y > -int(rr)-2 ||\n    diff.x >= 30 && diff.x < 39 && diff.y < 79 && diff.y > -int(rr)-2 ||\n    sdSegment( vec2(diff), vec2(-36, 36), vec2(0, 48)) < rr ||\n    sdSegment( vec2(diff), vec2(36, 36), vec2(0, 48)) < rr ||\n    sdSegment( vec2(diff), vec2(-36, 76), vec2(0, 88)) < rr ||\n    sdSegment( vec2(diff), vec2(36, 76), vec2(0, 88)) < rr ||\n    sdSegment( vec2(diff), vec2(0, 4), vec2(0, 88)) < rr\n\n    ){\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 myCoords = ivec2(fragCoord);\n    bool mouseDown = iMouse.z > 0.;\n    bool clickedMenu = mouseDown && iMouse.y >= iResolution.y - MENU_HEIGHT && iResolution.x - iMouse.x < MENU_WIDTH * MENU_NUM_BUTTONS;\n    float mouseTimeDown = texelFetch(iChannel0, ivec2(MOUSE_TIME_DOWN, 0), 0).x;\n    int selector = int(texelFetch(iChannel0, ivec2(SELECTOR,0), 0 ).x);\n    if(myCoords.y > 0){\n    \n    \tvec4 p = gp(myCoords);\n        ivec2 targetCoords;\n        vec4 pNextState = moveParticle(/*vec4 p=*/p, /*ivec2 myCoords=*/ivec2(fragCoord), /*out ivec2 targetCoords*/targetCoords);\n\n        // Input.\n        bool keyJ = texelFetch(iChannel1, ivec2(KEY_J, 0), 0).x > 0.5;\n        bool keyK = texelFetch(iChannel1, ivec2(KEY_K, 0), 0).x > 0.5;\n        float hBoost = 300.*(float(keyK)-float(keyJ));\n        float vBoost = 100.*(-float(keyK)-float(keyJ));\n        // Draw.\n        if(selector == 0){ // Eraser.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 0.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 1){ // Sand.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 1.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 2){ // Water.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 2.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 3){ // Gas.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 3.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 4){ // Fire.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 4.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 5){ // Water vapor.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 5.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 6){ // Bomb.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 1.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 6.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 7){ // Tank.\n            if(mouseDown && !clickedMenu && mouseTimeDown < 0.){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d <= 0.7){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 7.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 8){ // Explosion.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 30.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 8.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 9){ // Broken tank.\n            if(mouseDown && !clickedMenu && mouseTimeDown < 0.){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d <= 0.7){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 9.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 10){ // Enemy.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d <= 0.7){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 10.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 11){ // Lazer.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d <= 0.7){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 11.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 12){ // Mega bomb.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 1.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 12.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 13){ // Dirt.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 5.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 13.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 14){ // Concrete.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 5.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 14.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 15){ // Concrete broken.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 5.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 15.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 16){ // Nuke.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 1.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 16.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 17){ // House.\n            if(mouseDown && !clickedMenu){\n                if(house(fragCoord, iMouse.xy)){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 14.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        } else if(selector == 18){ // Grass.\n            if(mouseDown && !clickedMenu){\n                float d = length(fragCoord - 0.5 - iMouse.xy);\n                if(d < 2.){\n                    pNextState.x = hBoost;\n                    pNextState.y = vBoost;\n                    pNextState.z = 17.5;\n                    pNextState.w = 0.5;\n                }\n            }\n        }\n        // Control tank.\n        vec2 tankPos = texelFetch(iChannel0, ivec2(TANK_POSITION, 0), 0).xy;\n        const float tankAcceleration = 0.15;\n        const float tankMaxVel = 0.3;\n        if(exist(pNextState) && getClass(pNextState) == TANK && targetCoords == ivec2(tankPos)){\n            vec4 pD = gp(ivec2(tankPos) + ivec2(0, -1));\n            vec4 pDD = gp(myCoords + ivec2(0, -2));\n            vec4 pL = gp(ivec2(tankPos) + ivec2(-1, 0));\n            vec4 pR = gp(ivec2(tankPos) + ivec2(1, 0));\n            vec4 pU = gp(ivec2(tankPos) + ivec2(0, 1));\n            bool keyD = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x > 0.5;\n            bool keyA = texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x > 0.5;\n            if(exist(pD)/* || exist(pDD)*/ || exist(pR) || exist(pL)){\n                if(keyD){\n                    pNextState.x += clamp(max(tankMaxVel - pNextState.x, 0.), -tankAcceleration, tankAcceleration);\n                    if(exist(pR)){\n                        pNextState.y += clamp(max(tankMaxVel - pNextState.y, 0.), -tankAcceleration, tankAcceleration);\n                    }\n                } else if(keyA){\n                    pNextState.x -= clamp(max(tankMaxVel + pNextState.x, 0.), -tankAcceleration, tankAcceleration);\n                    if(exist(pL)){\n                        pNextState.y += clamp(max(tankMaxVel - pNextState.y, 0.), -tankAcceleration, tankAcceleration);\n                    }\n                } else{\n                    if(exist(pDD)){\n                \t\tpNextState.x += clamp(-pNextState.x, -0.04, 0.04);\n                    }\n                }\n                if(exist(pDD)){\n                \tpNextState.y = max(pNextState.y, 0.);\n                }\n            }\n        }\n\t\t\n        // Initiate world.\n        if(iTime < 0.1){\n            pNextState.x = 0.1;\n            pNextState.y = 1.1;\n            pNextState.z = 0.5;\n            pNextState.w = 0.5;\n        }\n        \n        // Spawn buildings.\n        if(texelFetch(iChannel1, ivec2(KEY_E, 1), 0).x > 0.5){\n            pNextState.x = 0.0;\n            pNextState.y = 0.0;\n            pNextState.z = 0.5;\n            pNextState.w = 0.5;\n            if(myCoords.y < 50){\n                setClass(pNextState, SAND);\n            }else if(myCoords.y < 70){\n                setClass(pNextState, DIRT);\n            }else if(myCoords.y < 73){\n                setClass(pNextState, GRASS);\n            }\n            const int offsetsSize = 12;\n            float diff = 100.0/iResolution.x;\n            vec2 offsets[offsetsSize] = vec2[](\n                vec2(iResolution.x * (0.1 + diff*0.),80),\n                vec2(iResolution.x * (0.1 + diff*0.),80+82),\n                vec2(iResolution.x * (0.1 + diff*0.),80+82*2),\n                vec2(iResolution.x * (0.1 + diff*0.),80+82*3),\n                vec2(iResolution.x * (0.1 + diff*1.),80),\n                vec2(iResolution.x * (0.1 + diff*2.),80),\n                vec2(iResolution.x * (0.1 + diff*2.),80+82),\n                vec2(iResolution.x * (0.1 + diff*2.),80+82*2),\n                vec2(iResolution.x * (0.1 + diff*3.),80),\n                vec2(iResolution.x * (0.1 + diff*3.),80+82),\n                vec2(iResolution.x * (0.1 + diff*4.),80),\n                vec2(iResolution.x * (0.1 + diff*6.),80)\n            );\n            for(int i=0; i<offsetsSize; i++){\n                if(house(fragCoord, offsets[i])){\n                    pNextState.x = 0.;\n                    pNextState.y = 0.;\n                    pNextState.z = 14.5;\n                    pNextState.w = 0.5;\n                }\n            }\n            if(myCoords.y > 420 && myCoords.y < 425){\n                setClass(pNextState, WATER_VAPOR);\n            }\n        }\n        \n    \tfragColor = pNextState;\n    } else {\n        vec4 pNextState = texelFetch(iChannel0, myCoords, 0);\n        \n        // Game logic.\n        if(myCoords == ivec2(SELECTOR, 0)){\n            if(\n                mouseDown && iMouse.y >= iResolution.y - MENU_HEIGHT &&\n                iResolution.x - iMouse.x < MENU_WIDTH * MENU_NUM_BUTTONS && mouseTimeDown < 0.\n            ){\n                pNextState.x = min(floor((iResolution.x - iMouse.x) / MENU_WIDTH), MENU_NUM_BUTTONS-1.);\n            }\n            if(iTime < 0.1){\n            \tpNextState.x = 1.;\n            }\n        }else if(myCoords == ivec2(MOUSE_TIME_DOWN, 0)){\n            if(mouseDown){\n            \tpNextState.x += 1.;\n            }else{\n            \tpNextState.x = -1.;\n            }\n        }else if(myCoords == ivec2(TANK_POSITION, 0)){\n            if(mouseDown && !clickedMenu && mouseTimeDown < 0. && selector == 7){\n            \tpNextState.xy = iMouse.xy;\n            } else {\n            \t// Track tank.\n                pNextState.xy = vec2(trackTank(ivec2(pNextState.xy)));\n            }\n        }else if(myCoords == ivec2(TANK_SHOOT_ANGLE, 0)){\n            bool keyRight = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x > 0.5;\n            bool keyLeft = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x > 0.5;\n            if(keyLeft){\n            \tpNextState.x = mod(pNextState.x+0.02, 2.*PI);\n            }else if(keyRight){\n            \tpNextState.x = mod(pNextState.x-0.02, 2.*PI);\n            }\n        }else if(myCoords == ivec2(TIME, 0)){\n            pNextState.x += 1.;\n        }else if(myCoords == ivec2(AUTO_SPAWN_AIRCRAFT, 0)){\n            bool keyQ = texelFetch(iChannel1, ivec2(KEY_Q, 1), 0).x > 0.5;\n            if(keyQ){\n            \tpNextState.x = pNextState.x > 0.5? 0.: 1.;\n            }\n        }\n    \tfragColor = pNextState;\n    }\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nGP\n//GET_INCOMING\n//MOVE_PARTICLE\nSHOULD_DETONATE_BOMB\nSHOULD_DETONATE_MEGA_BOMB\nSHOULD_DETONATE_NUKE\nCALC_IMPULSES\nSWAP_ABOVE_AND_CALC_IMPULSES\nTRACK_TANK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 myCoords = ivec2(fragCoord);\n    if(myCoords.y > 0){\n        vec4 p = gp(myCoords);\n        vec4 pNextState = swapAboveAndCalcImpulses(myCoords, 0);\n\n        fragColor = pNextState;\n    } else {\n    \tvec4 pNextState = texelFetch(iChannel0, myCoords, 0);\n        if(myCoords == ivec2(TANK_POSITION, 0)){\n            // Track tank.\n            pNextState.xy = vec2(trackTank(ivec2(pNextState.xy)));\n        }\n    \tfragColor = pNextState;\n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nGP\nGET_INCOMING\nMOVE_PARTICLE\n//SHOULD_DETONATE_BOMB\n//SHOULD_DETONATE_MEGA_BOMB\n//SHOULD_DETONATE_NUKE\n//CALC_IMPULSES\n//SWAP_ABOVE_AND_CALC_IMPULSES\nTRACK_TANK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 myCoords = ivec2(fragCoord);\n    if(myCoords.y > 0){\n    \n    \tvec4 p = gp(myCoords);\n        ivec2 targetCoords;\n        vec4 pNextState = moveParticle(/*vec4 p=*/p, /*ivec2 myCoords=*/ivec2(fragCoord), /*out ivec2 targetCoords*/targetCoords);\n\n    \tfragColor = pNextState;\n    } else {\n        vec4 pNextState = texelFetch(iChannel0, myCoords, 0);\n        if(myCoords == ivec2(TANK_POSITION, 0)){\n            // Track tank.\n            pNextState.xy = vec2(trackTank(ivec2(pNextState.xy)));\n        }\n    \tfragColor = pNextState;\n    }\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\nGP\n//GET_INCOMING\n//MOVE_PARTICLE\nSHOULD_DETONATE_BOMB\nSHOULD_DETONATE_MEGA_BOMB\nSHOULD_DETONATE_NUKE\nCALC_IMPULSES\nSWAP_ABOVE_AND_CALC_IMPULSES\nTRACK_TANK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 myCoords = ivec2(fragCoord);\n    if(myCoords.y > 0){\n        vec4 p = gp(myCoords);\n        vec4 pNextState = swapAboveAndCalcImpulses(myCoords, 1);\n\n        fragColor = pNextState;\n    } else {\n    \tvec4 pNextState = texelFetch(iChannel0, myCoords, 0);\n        if(myCoords == ivec2(TANK_POSITION, 0)){\n            // Track tank.\n            pNextState.xy = vec2(trackTank(ivec2(pNextState.xy)));\n        }\n    \tfragColor = pNextState;\n    }\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1088, 1088, 1130, 1130, 1757], [7074, 7074, 7131, 7314, 10835]], "test": "untested"}
{"id": "wd3XRf", "name": "Stringy mouse fun fun", "author": "Plento", "description": "Posting old shader. Use mouse for effect", "tags": ["mouse", "reaction"], "likes": 27, "viewed": 531, "published": 3, "date": "1596767779", "time_retrieved": "2024-07-30T20:52:19.219684", "image_code": "vec2 R;\n\nvec4 t(vec2 p){\n    return texture(iChannel1, p);   \n}\nfloat height(vec2 p){\n    return t(p).x;\n}\nvec3 Bumpyyyyyyyyyyyyyyyyyyyyyyyyyyyyy(vec2 uv, float strength){\n    float h = 0.002;\n    vec3 p = t(uv).xyz; \n    float dx = height(uv) - height(uv + vec2(h, .0));\n    float dy = height(uv) - height(uv + vec2(0., h));\n    return normalize( vec3(0., 0., -1.) + vec3(dx, dy, 0.)*strength);\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    R = iResolution.xy;\n    vec2 uv = u / R;\n    vec2 cuv =  vec2(u.xy - 0.5*R.xy)/R.y; \n\t\n    vec3 lp = vec3(0., 0., -1.0); \n    vec3 sp = vec3(cuv, 0.0); \n    vec3 ro = vec3(0, 0, -1.0); \n    vec3 rd = normalize(sp - ro);\n    vec3 ld = lp - sp;\n    \n    float dist = max(length(ld), 0.001);\n    ld /= dist;\n    vec3 objCol = t(uv).xyz;\n    \n    vec3 norm = Bumpyyyyyyyyyyyyyyyyyyyyyyyyyyyyy(uv, 12.0);\n  \t\n    float dif = max(dot(norm, ld), 0.);  \n    float spec = pow(max(dot( reflect(-ld, norm), -rd), 0.), 16.); \n    \n    float falloff = 1.5/(1. + dist*0.15 + dist*dist*2.15);\n    \n    vec3 col = (objCol*(dif + .5) + vec3(0.5, 0.6, 0.7)*spec*1.4)*falloff;\n   \n    f = vec4(col, 0.);\n}\n\n\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 R;\nvec4 t(vec2 p){\n    return texture(iChannel0, p/R);   \n}\n\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 m = vec2(iMouse.xy / R) - 0.5;\n    m.x *= R.x / R.y;\n    m *= .35;\n    vec2 dir = t(u).xy;\n   \n    vec2 up = t(u+vec2(.0, 1.)).xy;\n    vec2 dwn = t(u+vec2(.0, -1.)).xy;\n    vec2 lft = t(u+vec2(-1.0, 0.)).xy;\n    vec2 rgt = t(u+vec2(1.0, 0.)).xy;\n    \n    vec2 upl = t(u+vec2(-1.0, 1.)).xy;\n    vec2 upr = t(u+vec2(1.0, 1.)).xy;\n    vec2 dwnl = t(u+vec2(-1.0, -1.)).xy;\n    vec2 dwnr = t(u+vec2(1.0, -1.)).xy;\n    \n    vec2 sum = (up + dwn + lft + rgt + upl + upr + dwnl + dwnr);\n    \n    float div = dot(dir, (sum));\n    vec3 r = normalize(cross(vec3(dir,1.0), vec3(sum, 1.0)));\n    \n    \n    dir = normalize(sum-div*.09-r.z);\n    dir += hash22(u)*.01;\n   \n    //dir += .02;\n    \n    if(iFrame < 2){\n    \tdir = vec2(1);\n    }\n    \n    float d = length(uv - m);\n    if(iMouse.z > 0.0){\n        vec2 val = exp2(-d*25.)*hash22(u);\n        dir += val; \n    }\n    \n    //dir=mix(dir, hash22(u), .01);\n    \n    f = vec4(dir, 0., 00.);\n    \n}\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec2 R;\n\n\nvec4 t(vec2 p){\n    return texture(iChannel0, p);   \n}\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    R = iResolution.xy;\n    vec2 uv = u/R;\n    \n    uv-=0.5;\n    uv*=0.35;\n    uv+=0.5;\n    \n    vec4 bA = t(uv);\n    \n    \n    vec2 dir = bA.xy;\n    float div = bA.z;\n    float vel = bA.w;\n    \n    \n    vec3 col = vec3(sin(dir)*sin(dir), 0.8);\n    \n    \n \tf = vec4(col, 0.);   \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3XRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 24, 24, 63], [64, 64, 85, 85, 106], [107, 107, 171, 171, 397], [400, 400, 441, 441, 1132]], "test": "untested"}
{"id": "WtsfWN", "name": "Tree wallpaper", "author": "D3lphes", "description": "Based on : https://www.shadertoy.com/view/XtyGzh\nAnd iq's version: https://www.shadertoy.com/view/XtyGR1", "tags": ["tree"], "likes": 14, "viewed": 710, "published": 3, "date": "1596767707", "time_retrieved": "2024-07-30T20:52:19.989625", "image_code": "// Based on : https://www.shadertoy.com/view/XtyGzh\n// And iq's version: https://www.shadertoy.com/view/XtyGR1\n\n#define kDepth 7\n#define kBranches 3\n#define kMaxDepth 2187 // branches ^ depth\n\n//--------------------------------------------------------------------------\n\nmat3 matRotate( float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3( c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 matTranslate( float x, float y ) {\n    return mat3( 1, 0, 0, 0, 1, 0, -x, -y, 1 );\n}\n\nfloat sdBranch( vec2 p, float w1, float w2, float l ) {\n    float h = clamp( p.y/l, 0.0, 1.0 );\n\tfloat d = length( p - vec2(0.0,l*h) );\n    return d - mix( w1, w2, h );\n}\n\n//--------------------------------------------------------------------------\n\nfloat map( vec2 pos ) {\n    const float len = 6.2;\n    const float wid = 0.25;\n    float lenf = 0.55;\n    const float widf = 0.4;\n    float wind = iTime * 0.5;\n    \n    float d = sdBranch( pos, wid, wid*widf, len );\n    \n    int c = 0;\n    for( int count=0; count < kMaxDepth; count++ ) {\n        int off = kMaxDepth;\n    \tvec2 pt_n = pos;\n        \n        float l = len;\n        float w = wid;\n        \n      \tfor( int i=1; i<=kDepth; i++ ) {\n            l *= lenf;\n            w *= widf;\n\n            off /= kBranches; \n            int dec = c / off;\n        \tint path = dec - kBranches*(dec/kBranches); //  dec % kBranches\n          \n            mat3 mx;\n            \n            // Originals (references)\n\t    \t\n            //if( path == 0 ) {\n\t\t  \t//\tmx = matRotate(0.75 + 0.25*sin(wind-1.0)) * matTranslate( 0.0,0.4*l/lenf);\n\t    \t//} else if( path == 1 ) {\n          \t//\tmx = matRotate(-0.6 + 0.21*sin(wind)) * matTranslate(0.0,0.6*l/lenf);\n\t    \t//} else {\n          \t//\tmx = matRotate(0.23*sin(wind+1.)) * matTranslate(0.0,1.0*l/lenf);\n\t    \t//}\n            \n            float t = sin(iTime) - 0.1;\n            if( path == 0 ) {\n\t\t  \t\tmx = matRotate(0.75 + 0.15*t*sin(wind-1.0)) * matTranslate( 0.0,0.4*l/lenf);\n\t    \t} else if( path == 1 ) {\n          \t\tmx = matRotate(-0.6 + 0.11*t*sin(wind)) * matTranslate(0.0,0.6*l/lenf);\n\t    \t} else {\n          \t\tmx = matRotate(0.13*t*sin(wind+1.)) * matTranslate(0.0,1.0*l/lenf);\n\t    \t}\n            pt_n = (mx * vec3(pt_n,1)).xy;\n\n        \t// bounding sphere test\n            float y = length( pt_n - vec2(0.0, l) );\n       \t\tif( y-1.4*l > 0.0 ) { c += off-1; break; }\n            \n            d = min( d, sdBranch( pt_n, w, w*widf, l ) );\n     \t}\n        \n    \tc++;\n    \tif( c > kMaxDepth ) break;\n\t}\n    \n   \treturn d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // coordinate system\n    vec2  tree_uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float px = 2.0 / iResolution.y;\n\n    // frame in screen\n    tree_uv = tree_uv * 25.0 + vec2(0.0,6.5);\n    px = px * 4.0;\n   \n    // compute\n    float d = map( tree_uv );\n    \n    vec2 ground_uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 ground_right_top = step(vec2(0.94, 1.265),1.0-ground_uv);\n    vec2 ground_left_bottom = step(vec2(-0.06, -0.272),ground_uv);\n    float ground = ground_left_bottom.x * ground_left_bottom.y * ground_right_top.x * ground_right_top.y;\n    d *= 1. - ground;\n    \n  \tfloat fuzziness = 9.0;\n    \n    // shape\n    vec3 col = vec3( smoothstep( 0.0, fuzziness * px, d ) );\n    \n    col = vec3(mix(1., 0.15, col.r));\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[271, 271, 302, 302, 402], [404, 404, 443, 443, 493], [495, 495, 550, 550, 665], [745, 745, 768, 768, 2519], [2522, 2522, 2579, 2604, 3388]], "test": "untested"}
{"id": "WllBW4", "name": "centered square uv circle", "author": "3SvBop3F", "description": "circle", "tags": ["circle"], "likes": 2, "viewed": 352, "published": 3, "date": "1596740428", "time_retrieved": "2024-07-30T20:52:20.751588", "image_code": "\n\nconst float pi = 3.141592;\n    \n// lower right quadrant of circle\n// 1^2 = (y-1)^2 + (-x)^2\n//\n//     |\n//    /\n// .--\n//\nfloat arcramp(float x)\n{\n    return 1. - sqrt(\n        -(\n            pow(-x,2.)\n            - pow(1., 2.)\n        )\n    );\n}\n\n// upper left quadrant of circle\n// 1^2 = y^2 + (x-1)^2\n//\n//   -``\n//  /\n// |\n//\nfloat rarcramp(float x)\n{\n    return sqrt(\n        -(\n            pow(x-1., 2.)\n            -sqrt(1.)\n        )\n    );\n}\n\n// cos(x) adjusted to be periodic 0 to 1\n// y = (cos(x * pi * 2) / 2) + .5\n// \n// ``-       -``\n//    \\     /\n//      -..-\n//\nfloat bathtub(float x)\n{\n    return (\n        (\n            cos(x * pi * 2.)\n            / 2.\n        ) \n        + .5\n    );\n}\n\n\n// value {0...1} mapped to {-1...1}\nfloat s_p0p1_to_n1p1(float value)\n{\n    return mix(-1., 1., value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // compute uv\n    float max_res_dim = max(iResolution.x, iResolution.y);\n    vec2 uvsq_offset = (1.-(iResolution.xy/max_res_dim))/2.;\n\n    vec2 uvsq = (        // special case screen-is-uv-but-square-uv-space\n        gl_FragCoord.xy  // width/height\n        / max_res_dim    // of max width/height\n    ) + uvsq_offset;     // plus half the w/h margin\n\t\t\t\t\t     // is centered\n\n    vec2 uv = (          // optionally, use regular uv\n        gl_FragCoord.xy\n        / iResolution.xy\n    );\n    \n\tvec2 uvc = vec2(0.5,0.5); // center point to draw circle arround\n\n    // color expressions\n\t// shadertoy example color, to make it shinney\n    vec3 feature_color = 0.5 + 0.5*cos((iTime)+uv.xyx+vec3(0,2,4));\n\tvec3 background_color = vec3(0.10) + (vec3(0.10) * bathtub(iTime / 7.));\n\n    \n    fragColor = vec4(\n        mix(\n            feature_color, background_color,  // shade circle, or background\n            \n        \trarcramp(rarcramp(rarcramp(  // decay gradient to a thin ring\n                abs(s_p0p1_to_n1p1(  // circle gradient to two-band circle gradient\n          \t\t\t(distance(uvsq, uvc)*2.) // special case uv circle gradient, 0. center, 1. edge\n\t\t\t\t))\n        \t)))\n        ),\n        1.  // solid color (no alpha)\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 124, 148, 148, 249], [251, 333, 358, 358, 453], [455, 581, 605, 605, 707], [710, 746, 781, 781, 815], [817, 817, 874, 893, 2111]], "test": "untested"}
{"id": "tlXBW4", "name": "Truchet Balls", "author": "dr2", "description": "Balls rolling over a Truchet landscape (see source)", "tags": ["dynamics", "physics"], "likes": 21, "viewed": 542, "published": 3, "date": "1596706690", "time_retrieved": "2024-07-30T20:52:21.700052", "image_code": "// \"Truchet Balls\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Balls in and between channels based on hexagonal Truchet tiles \n  (mouseable, click upper-right for new run, lower-right to\n  switch between distant viewpoint and panoramic view near random ball)\n  In addition to gravity and friction there is a horizontal force that varies\n  with time, and other forces that bias the movement and reduce dispersal.\n*/\n\nmat3 QtToRMat (vec4 q);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int nBall = 64;\nvec3 vnObj, ltDir;\nvec2 gId, cMid;\nfloat tCur, dstFar, hgSize, cDir, trWidf, trHt;\nint nFrame, idBall;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat SurfHt (vec2 p)\n{\n  vec3 w;\n  vec2 s, r;\n  float b;\n  p -= cMid;\n  r = p / hgSize;\n  s = vec2 (0., - cDir);\n  b = dot (s - r, s - r);\n  w = vec3 (s, b);\n  s = 0.5 * vec2 (sqrt3, cDir);\n  b = dot (s - r, s - r);\n  if (b < w.z) w = vec3 (s, b);\n  s = 0.5 * vec2 (- sqrt3, cDir);\n  b = dot (s - r, s - r);\n  if (b < w.z) w = vec3 (s, b);\n  return trHt * smoothstep (0.25 * trWidf, trWidf, abs (sqrt (w.z) - 0.5));\n}\n\nfloat SurfDf (vec3 p)\n{\n  return 0.8 * (p.y - SurfHt (p.xz));\n}\n\nvoid SetTrConf ()\n{\n  cMid = HexToPix (gId * hgSize);\n  cDir = 2. * step (Hashfv2 (gId), 0.5) - 1.;\n}\n\nfloat SurfRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    d = SurfDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 SurfNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    u = ro - p.xyz;\n    rad = 0.45;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnObj = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 rs, u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    u = ro - p.xyz;\n    rad = 0.45;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  vec2 a;\n  u = vnBall * QtToRMat (Loadv4 (4 * idBall + 2));\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return 0.7 + 0.3 * step (0., sign (a.x) * sign (a.y));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, bgCol;\n  float dstObj, dstSurf, sh;\n  bgCol = mix (vec3 (0.8, 0.8, 0.6), vec3 (0.7, 0.7, 1.), smoothstep (-0.1, 0.05, rd.y));\n  dstObj = BallHit (ro, rd);\n  dstSurf = SurfRay (ro, rd);\n  if (min (dstObj, dstSurf) < dstFar) {\n    if (dstObj < dstSurf) {\n      ro += dstObj * rd;\n      vn = vnObj;\n      col4 = vec4 (HsvToRgb (vec3 (float (idBall) / float (nBall), 0.8, BallChqr (idBall, vn))), 0.2);\n    } else if (dstSurf < dstFar) {\n      ro += dstSurf * rd;\n      col4 = mix (vec4 (0.5, 0.35, 0.25, 0.), vec4 (1., 1., 0.7, 0.), smoothstep (0.94, 0.98, ro.y / trHt));\n      vn = VaryNf (2. * ro, SurfNf (ro), max (0.02, 2. - 2. * dstSurf / dstFar));\n    }\n    sh = 0.5 + 0.5 * BallHitSh (ro + 0.005 * ltDir, ltDir, 5.);\n    col = col4.rgb * (0.1 + 0.2 * max (- dot (vn, ltDir), 0.) +\n       0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col = mix (col, bgCol, smoothstep (0.7, 1., min (dstObj, dstSurf) / dstFar));\n    \n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\n#define AA    1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 col, rd, ro, vd, bMid;\n  vec2 canvas, uv, uvv, ut;\n  float az, el, asp, zmFac, sr, s, mb, bMid2;\n  int fBall;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  nFrame = iFrame;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (4 * nBall + 0);\n  hgSize = stDat.x;\n  trWidf = stDat.y;\n  trHt = stDat.z;\n  stDat = Loadv4 (4 * nBall + 1);\n  mPtr.xyz = stDat.xyz;\n  fBall = int (stDat.w);\n  ut = vec2 (mPtr.x, abs (mPtr.y)) + 0.05 * vec2 (1. / asp, 1.) - 0.5;\n  mb = min (ut.x, ut.y);\n  if (mPtr.z > 0. && mb < 0.) {\n    az = 2. * pi * mPtr.x;\n    el = 0.5 * pi * (mPtr.y + 0.25);\n    el = clamp (el, 0.02 * pi, 0.3 * pi);\n  } else if (fBall < 0) {\n    az -= 0.02 * pi * tCur;\n    el = 0.06 * pi;\n  } else {\n    az = 0.;\n    el = 0.;\n  }\n  ut = uv;\n  if (fBall < 0) {\n    stDat = Loadv4 (4 * nBall + 2);\n    bMid = stDat.xyz;\n    bMid2 = stDat.w;\n    ro = bMid + min (bMid2, 80.) * vec3 (cos (el) * sin (az + vec2 (0.5 * pi, 0.)), 2. * sin (el)).xzy;\n    vd = normalize (bMid - ro);\n    s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n    vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n       - vd.y * vd.z) / s, vd);\n    zmFac = 4.;\n  } else {\n    ro = Loadv4 (4 * fBall + 0).xyz;\n    ro.y += 1.;\n    vd = Loadv4 (4 * fBall + 1).xyz;\n    vd = normalize (vec3 (vd.x, 0., vd.z));\n    vd.xz = Rot2D (vd.xz, - az);\n    ro.xz -= 0.3 * vd.xz;\n    vuMat = mat3 (vec3 (vd.z, 0., - vd.x), vec3 (0., 1., 0.), vd);\n  }\n  dstFar = 200.;\n  ltDir = normalize (vec3 (0., 1., -1.));\n  ltDir.xz = Rot2D (ltDir.xz, 0.04 * pi * tCur);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    rd = (fBall < 0) ? vec3 (uvv, zmFac) : vec3 (0.5 * sin (uvv.x * pi / asp + vec2 (0., 0.5 * pi)), uvv.y).xzy;\n    rd = vuMat * normalize (rd);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (mPtr.z > 0. && min (uv.x - asp, abs (uv.y) - 1.) > -0.1)\n     col = mix (col, vec3 (0., 0.3, 1.), 0.3);\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Truchet Balls\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 64;\nfloat todCur, nStep, dstFar, hgSize, trWidf, trHt;\nint nFrame, fBall;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat SurfHt (vec2 p)\n{\n  vec3 w;\n  vec2 gId, cMid, s, r;\n  float cDir, b;\n  gId = PixToHex (p / hgSize);\n  cMid = HexToPix (gId * hgSize);\n  cDir = 2. * step (Hashfv2 (gId), 0.5) - 1.;\n  p -= cMid;\n  r = p / hgSize;\n  s = vec2 (0., - cDir);\n  b = dot (s - r, s - r);\n  w = vec3 (s, b);\n  s = 0.5 * vec2 (sqrt3, cDir);\n  b = dot (s - r, s - r);\n  if (b < w.z) w = vec3 (s, b);\n  s = 0.5 * vec2 (- sqrt3, cDir);\n  b = dot (s - r, s - r);\n  if (b < w.z) w = vec3 (s, b);\n  return trHt * smoothstep (0.25 * trWidf, trWidf, abs (sqrt (w.z) - 0.5));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fCent, grav, rSep,\n     fc, ft, drv, dt, spFreq;\n  fOvlap = 500.;\n  fricN = 0.5;\n  fricS = 0.1;\n  fricSW = 0.5;\n  fricT = 0.5;\n  fPull = 0.8;\n  fCent = 0.01;\n  spFreq = 0.0002;\n  fDamp = 0.4;\n  grav = 6.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am.xz += fPull * sin (spFreq * 2. * pi * nStep + vec2 (0.5 * pi, 0.));\n  am.z += 1.5 * fPull;\n  am.x -= fCent * rm.x;\n  am.y -= grav;\n  am -= fDamp * vec3 (1., 5., 1.) * vm;\n  wam -= 1e-4 * fDamp * wm;\n  dt = (fBall < 0) ? 0.02 : 0.005;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = vec2 (0., 3. * mIdf) + 35. * mod (todCur, 10.);\n  rm.y = 1.5;\n  vm = 0.5 * (2. * Hashv3f (mIdf + todCur) - 1.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, bMid;\n  vec2 iFrag, canvas, b;\n  float asp, bMid2;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  nFrame = iFrame;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  fBall = -1;\n  if (nFrame <= 5) {\n    hgSize = 4.;\n    trWidf = 0.25;\n    trHt = 0.4;\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    hgSize = stDat.x;\n    trWidf = stDat.y;\n    trHt = stDat.z;\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (4 * nBall + 1);\n    mPtrP.z = stDat.z;\n    fBall = int (stDat.w);\n    if (mPtr.z > 0. && mPtrP.z < 0. && mPtr.x > 0.5 - 0.05 / asp && abs (mPtr.y) > 0.5 - 0.05) {\n      if (mPtr.y > 0.) {\n        if (nStep > 100.) doInit = true;\n      } else {\n        if (fBall >= 0) fBall = -1;\n        else fBall = int (float (nBall) * Hashff (mod (todCur, 1000.)));\n      }\n    }\n  }\n  if (doInit) {\n    nStep = 0.;\n    fBall = -1;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n  }\n  if (pxId == 4 * nBall + 2) {\n    bMid = vec3 (0.);\n    bMid2 = 0.;\n    if (nStep > 0.) {\n      for (int n = VAR_ZERO; n < nBall; n ++) {\n        b = Loadv4 (4 * n).xz;\n        bMid.xz += b;\n        bMid2 += dot (b, b);\n      }\n      bMid.xz /= float (nBall);\n      bMid.y = 0.1;\n      bMid2 = sqrt (bMid2 / float (nBall) - dot (bMid.xz, bMid.xz));\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nBall;\n    if (pxId == kp) stDat = vec4 (hgSize, trWidf, trHt, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (mPtr.xyz, float (fBall));\n    else if (pxId == kp + 2) stDat = vec4 (bMid, bMid2);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Truchet Balls\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 64;\nfloat todCur, nStep, dstFar, hgSize, trWidf, trHt;\nint nFrame, fBall;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat SurfHt (vec2 p)\n{\n  vec3 w;\n  vec2 gId, cMid, s, r;\n  float cDir, b;\n  gId = PixToHex (p / hgSize);\n  cMid = HexToPix (gId * hgSize);\n  cDir = 2. * step (Hashfv2 (gId), 0.5) - 1.;\n  p -= cMid;\n  r = p / hgSize;\n  s = vec2 (0., - cDir);\n  b = dot (s - r, s - r);\n  w = vec3 (s, b);\n  s = 0.5 * vec2 (sqrt3, cDir);\n  b = dot (s - r, s - r);\n  if (b < w.z) w = vec3 (s, b);\n  s = 0.5 * vec2 (- sqrt3, cDir);\n  b = dot (s - r, s - r);\n  if (b < w.z) w = vec3 (s, b);\n  return trHt * smoothstep (0.25 * trWidf, trWidf, abs (sqrt (w.z) - 0.5));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fCent, grav, rSep,\n     fc, ft, drv, dt, spFreq;\n  fOvlap = 500.;\n  fricN = 0.5;\n  fricS = 0.1;\n  fricSW = 0.5;\n  fricT = 0.5;\n  fPull = 0.8;\n  fCent = 0.01;\n  spFreq = 0.0002;\n  fDamp = 0.4;\n  grav = 6.;\n  p = Loadv4 (4 * mId);\n  rm = p.xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n);\n    rmN = p.xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (4 * n + 1).xyz;\n      wmN = Loadv4 (4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am.xz += fPull * sin (spFreq * 2. * pi * nStep + vec2 (0.5 * pi, 0.));\n  am.z += 1.5 * fPull;\n  am.x -= fCent * rm.x;\n  am.y -= grav;\n  am -= fDamp * vec3 (1., 5., 1.) * vm;\n  wam -= 1e-4 * fDamp * wm;\n  dt = (fBall < 0) ? 0.02 : 0.005;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = vec2 (0., 3. * mIdf) + 35. * mod (todCur, 10.);\n  rm.y = 1.5;\n  vm = 0.5 * (2. * Hashv3f (mIdf + todCur) - 1.);\n  qm = vec4 (0., 0., 0., 1.);\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, bMid;\n  vec2 iFrag, canvas, b;\n  float asp, bMid2;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  nFrame = iFrame;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  fBall = -1;\n  if (nFrame <= 5) {\n    hgSize = 4.;\n    trWidf = 0.25;\n    trHt = 0.4;\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (4 * nBall);\n    hgSize = stDat.x;\n    trWidf = stDat.y;\n    trHt = stDat.z;\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (4 * nBall + 1);\n    mPtrP.z = stDat.z;\n    fBall = int (stDat.w);\n    if (mPtr.z > 0. && mPtrP.z < 0. && mPtr.x > 0.5 - 0.05 / asp && abs (mPtr.y) > 0.5 - 0.05) {\n      if (mPtr.y > 0.) {\n        if (nStep > 100.) doInit = true;\n      } else {\n        if (fBall >= 0) fBall = -1;\n        else fBall = int (float (nBall) * Hashff (mod (todCur, 1000.)));\n      }\n    }\n  }\n  if (doInit) {\n    nStep = 0.;\n    fBall = -1;\n  }\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n  }\n  if (pxId == 4 * nBall + 2) {\n    bMid = vec3 (0.);\n    bMid2 = 0.;\n    if (nStep > 0.) {\n      for (int n = VAR_ZERO; n < nBall; n ++) {\n        b = Loadv4 (4 * n).xz;\n        bMid.xz += b;\n        bMid2 += dot (b, b);\n      }\n      bMid.xz /= float (nBall);\n      bMid.y = 0.1;\n      bMid2 = sqrt (bMid2 / float (nBall) - dot (bMid.xz, bMid.xz));\n    }\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nBall;\n    if (pxId == kp) stDat = vec4 (hgSize, trWidf, trHt, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (mPtr.xyz, float (fBall));\n    else if (pxId == kp + 2) stDat = vec4 (bMid, bMid2);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXBW4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[919, 919, 942, 942, 1337], [1339, 1339, 1362, 1362, 1402], [1404, 1404, 1423, 1423, 1505], [1507, 1507, 1541, 1541, 2637], [2639, 2639, 2661, 2661, 2801], [2803, 2803, 2837, 2837, 3253], [3255, 3255, 3302, 3302, 3669], [3671, 3671, 3713, 3713, 3919], [3921, 3921, 3956, 3956, 5029], [5048, 5048, 5104, 5104, 7430], [7432, 7432, 7456, 7456, 7686], [7688, 7688, 7712, 7712, 7772], [7774, 7774, 7799, 7799, 8195], [8197, 8197, 8219, 8219, 8257], [8259, 8259, 8289, 8289, 8402], [8404, 8404, 8428, 8428, 8545], [8579, 8579, 8603, 8603, 8663], [8665, 8665, 8689, 8689, 8801], [8803, 8803, 8828, 8828, 9014], [9016, 9016, 9045, 9045, 9257], [9259, 9259, 9298, 9298, 9483], [9577, 9577, 9602, 9602, 9725]], "test": "untested"}
{"id": "3lfBWN", "name": "Waves Remix 2 Color", "author": "gchipunov", "description": "\n\nfrom waves, sound, wave, music, colors, beginner, audio, visualizer, easy, sounds\nCreated by ADOB in 2015-04-10\n", "tags": ["waves", "sound", "wave", "music", "colors", "beginner", "audio", "visualizer", "easy", "soundscreatedbyadobin20150410"], "likes": 6, "viewed": 565, "published": 3, "date": "1596687261", "time_retrieved": "2024-07-30T20:52:22.462015", "image_code": "// oringal createor https://www.shadertoy.com/user/ADOB\n// remixer coder: https://www.shadertoy.com/user/gchipunov\nfloat squared(float value) { return value * value; }\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\n\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n    \n\tfloat lineIntensity;\n    float glowWidth;\n    vec3 color = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 5.0; i++) {\n        \n\t\tuv.y += (0.2 * sin(uv.x + i/7.0 - iTime * 0.6));\n        float Y = uv.y + getWeight(squared(i) * 20.0) *\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\n        lineIntensity = 0.4 + squared(1.6 * abs(mod(uvTrue.x + i / 1.3 + iTime,2.0) - 1.0));\n\t\tglowWidth = abs(lineIntensity / (150.0 * Y));\n       // float k = i;\n        if(i== 0.0f)\n       {\n\t\tcolor += vec3(glowWidth * (2.0 + tan(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\n                 //     glowWidth * (2.0 - cos(iTime * 0.19)));\n                       glowWidth * (2.0 - tan(iTime * 0.19)));\n       }\n           else   if(i== 1.0f)\n        {\n \t\tcolor += vec3(glowWidth * (2.0 + sin(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.01)),\n                      glowWidth * (2.0 - cos(iTime * 0.01)));\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));           \n        }\n         else   if(i== 2.0f)\n        {\n \t\tcolor += vec3(glowWidth * (2.0 + cos(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\n                      glowWidth * (2.0 - cos(iTime * 0.19)));\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));           \n        }\n        else\n        {\n \t\tcolor += vec3(glowWidth/2.0 * (2.0 + tan(iTime * 0.13)),\n                      glowWidth/2.0 * (2.0 - sin(iTime * 0.23)),\n                      glowWidth/2.0 * (2.0 - cos(iTime * 0.19)));\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));           \n        }\n        \n\t}\t\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 23674, "src": "https://soundcloud.com/zubnid/zeldabetamax", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 115, 143, 143, 167], [169, 169, 200, 200, 259], [261, 261, 287, 287, 385], [387, 387, 444, 444, 2227]], "test": "untested"}
{"id": "3lffD4", "name": "OrbAttract(SST)", "author": "Del", "description": "cheap vfx shader", "tags": ["2d", "circles", "vfx"], "likes": 8, "viewed": 534, "published": 3, "date": "1596679522", "time_retrieved": "2024-07-30T20:52:23.235945", "image_code": "// orb attract shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (iResolution.xy - 2.0*fragCoord.xy)/iResolution.y;\n    //float v1 = 1.0+ sin(iTime+p.x*250.0)*0.3;\n    //float v2 = 1.0+ cos(iTime+p.y*250.0)*0.3;\n    \n    \n    p.y += sin(iTime*1.5+p.x*12.0)*0.05;\t// wibble\n    //p.x = sin(p.y*12.0)*0.05;\n    \n    \n    float speed = 0.45;\n    float d = length(p);\n    p*= 0.8;\t\t// scale\n\tfloat r = (p.x*p.x + p.y*p.y)*4.0;\n    //r+=sin(d*4.0);\t//*0.5;\n\tfloat v = 1.0 + .5*sin((r+iTime*speed)/0.08);\n    v =(v*d)*4.0;\n    v*=1.0-d;\n    v = clamp(v,0.0,4.0);\n    v*=v;\n\tvec3 col = vec3(0.6,0.5,0.9)*v;\n    //col*=v1*v2;\t// dotty\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lffD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 79, 79, 684]], "test": "untested"}
{"id": "wllfR4", "name": "Summoning Circle", "author": "BackwardsCap", "description": "If you say his name three times a portal will appear", "tags": ["noise", "ancient", "fonts", "symbols"], "likes": 22, "viewed": 598, "published": 3, "date": "1596650505", "time_retrieved": "2024-07-30T20:52:24.015860", "image_code": "//Summoning Circle\n//by Sam Gates (BackwardsCap)\n\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    c.rgb = vec3(0);\n\tc.rgb = S0(f).rgb/3.0+S1(f).rgb*.8;    \n    vec2 p = (2.0*f-R)/R.y;\n    float t = clamp((iTime/2.0)-6.0,0.,1.);\n    float t2 =clamp((iTime/2.0)-5.4,0.,.6)-clamp((iTime/2.0)-6.6,0.,.6);\n    \n    c.rgb+=clamp(1.0-(length(p)+.1),0.,1.)*S2(f).rgb*t;\n    \n    float a = (length(p)-1.)/2.;\n    vec3 ba = vec3(0);\n    for(int y=-4;y<=4;y++)\n    for(int x=-4;x<=4;x++)\n    {\n        vec2 o = vec2(x,y);\n        if(length(o)<66.)\n        ba+= S1(f+o).rgb;\n    }\n    \n    ba/=15.0;\n    \n    c.rgb+=ba*a+(ba*t2*.4);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R iResolution.xy\n#define PI 3.1415927\n#define m vec2(5.+2.*4.,10.)\n#define SS(U) smoothstep(PX, 0., U)\n\n#define MORPH\n\n//Any advice on fixing the inconsistency on the connecting edges or the aliasing would be very welcome\n#define PX 40./R.y\n\n\nfloat rand (vec2 p)\n{\n    float d = iDate.w;\n    #ifdef MORPH\n    vec2 pp =p/20.0;\n    d=floor(d*pp.x*pp.y)/30.;\n    #endif\n    return fract(sin(dot(p.xy,vec2(12389.1283,8941.1283)))*(12893.128933)+cos(floor(d)));\n}\n\nmat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\n//https://www.shadertoy.com/view/4llXD7\nfloat B(vec2 p, vec2 b, vec4 r)\n{\n    r.xy = p.x>0.0?r.xy : r.zw;\n    r.x = p.y>0.0 ? r.x : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return SS(min(max(q.x,q.y),0.0)+length(max(q,0.0))-r.x);\n}\n\nbool removed(float h, vec2 p)\n{\n    vec2 lp = mod(p,m);\n    float h2 = rand(vec2(20.+h*(floor(p.y))+10.84));\n    if(lp.x>=4.&&lp.x<11.||lp.y>=6.)return true;\n    return h*dot(h,h2)*5.<=.5;\n}\n\n\nfloat C(vec2 p){return SS(length(p-.5)-.4);}\n\nfloat CL(vec2 p, float a)\n{\n    vec2 bp = (p-.5);\n    bp*=rot(PI/4.*a);\n    bp.x+=.5;\n    return B(bp, vec2(.6,.345), vec4(.3));\n}\n\nfloat CE(vec2 p, vec2 o)\n{\n    return B((p+o)*rot(PI/4.), vec2(.5), vec4(0));\n}\n\nfloat EL(vec2 p, float t)\n{\n    vec2 b = vec2(.5,.4-PX);\n    p-=vec2(.5,.5);\n    p*=rot(PI/2.*t);\n    p.x+=PX;\n    vec4 r = vec4(b.x-b.x/2.,b.x-b.x/2.,0,0);\n    return B(p, b, r);\n}\n\nfloat D(vec2 p, float r)\n{\n    p-=.5;\n    p*=rot(PI/2.*r);\n    p+=.13;\n    float b1 = B(p,vec2(.5),vec4(.5,0,0,0));\n    p+=.77;\n    float b2 = B(p,vec2(.5),vec4(0,0,0,.025));\n    return b1-b2;\n}\n\n\nfloat T(vec2 p, float r)\n{\n    p-=.5;\n    p*=rot(PI/2.*r);\n    return B(p,vec2(.4-PX,.6), vec4(0));\n}\n\nfloat render(vec2 p, float h)\n{\n    bool neighbors[9];\n    int ul=6,u=7,ur=8,l=3,me=4,r=5,dl=0,d=1,dr=2;\n    int n=0;\n\n    float o = 0.;\n\n    for(float y=-1.;y<=1.;y++)\n    {\n        for(float x=-1.;x<=1.;x++){\n\n            int i = int((x+1.)+(y+1.)*3.);\n\n            vec2 pos = floor(p+vec2(x,y));\n\n            neighbors[i]= !removed(rand(pos),pos);\n\n            if(i!=me&&neighbors[i])\n            {\n                n++;\n            }\n        }\n    }\n    \n    p=fract(p);\n\n    if(neighbors[me])\n    {\n        if(n==0) return C(fract(p));\n\t\t\n        if(neighbors[u]&&neighbors[d]){\n\n            float o = T(p,0.);\n            if(neighbors[l])o+=EL(p+vec2(.175,0),0.);\n            if(neighbors[r])o+=EL(p-vec2(.175,0),2.);\n            return o;\n        }\n        if(neighbors[l]&&neighbors[r])\n        {\n            float o = T(p,1.);\n            if(neighbors[u])o+=EL(p-vec2(0,.25),1.);\n            if(neighbors[d])o+=EL(p+vec2(0,.25),3.);\n            return o;\n        }\n\n\n        if(neighbors[u]&&!neighbors[d]&&!neighbors[l]&&!neighbors[r])\n        {\n            float o = EL(p-vec2(0,.3),1.);\n\n            if(neighbors[dl]) o+=CL(p-vec2(.175),7.);\n            if(neighbors[dr]) o+=CL(p-vec2(-.175,.175),5.);\n\n            return o;\n        }\n\n        if(neighbors[d]&&!neighbors[u]&&!neighbors[l]&&!neighbors[r])\n        {\n            float o = EL(p+vec2(0,.3),3.);\n\n            if(neighbors[ul]) o+=CL(p+vec2(-.175,.175),1.);\n            if(neighbors[ur]) o+=CL(p+vec2(.175),3.);\n\n            return o;\n        }\n\n        if(neighbors[l]&&!neighbors[r]&&!neighbors[d]&&!neighbors[u])\n        {\n            float o = EL(p+vec2(.3,0),0.);\n\n            if(neighbors[ur]) o+=CL(p+vec2(.175,.175),3.);\n            if(neighbors[dr]) o+=CL(p-vec2(-.175,.175),5.);\n\n            return o;\n        }\n\n        if(neighbors[r]&&!neighbors[l]&&!neighbors[d]&&!neighbors[u])\n        {\n            float o = EL(p-vec2(.3,0),2.);\n\n            if(neighbors[ul]) o+=CL(p+vec2(-.175,.175),1.);\n            if(neighbors[dl]) o+=CL(p-vec2(.175),7.);\n\n            return o;\n        }\n        float j = 0.0;\n        if(!neighbors[u]&&neighbors[r]&&!neighbors[l]&&neighbors[d])j+= D(p,3.);\n        if(neighbors[u]&&neighbors[r]&&!neighbors[l]&&!neighbors[d])j+= D(p,2.);\n        if(!neighbors[u]&&!neighbors[r]&&neighbors[l]&&neighbors[d])j+= D(p,0.);\n        if(neighbors[u]&&!neighbors[r]&&neighbors[l]&&!neighbors[d])j+= D(p,1.);\n        if(neighbors[ul]&&!neighbors[l]&&!neighbors[u]) j+=CL(p+vec2(-.175,.175),1.);\n        if(neighbors[dl]&&!neighbors[l]&&!neighbors[d]) j+=CL(p-vec2(.175),7.);\n        if(neighbors[ur]&&!neighbors[r]&&!neighbors[u]) j+=CL(p+vec2(.175,.175),3.);\n        if(neighbors[dr]&&!neighbors[r]&&!neighbors[d]) j+=CL(p-vec2(-.175,.175),5.);\n        \n\n        return  j;\n    }else{\n        float o = 0.0;\n        if(!neighbors[ul]&&neighbors[u]&&neighbors[l])o+= CE(p,vec2(.07,-1.15));\n        if(!neighbors[ur]&&neighbors[u]&&neighbors[r])o+= CE(p, vec2(-1.11));\n        if(!neighbors[dl]&&neighbors[d]&&neighbors[l])o+= CE(p,vec2(.11));\n        if(!neighbors[dr]&&neighbors[d]&&neighbors[r])o+= CE(p,vec2(-1.11,.11));\n        return o;\n    }\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    c.rgb = vec3(0);\n    vec2 p = ((2.0*f-R)/R.y), u=p, r;\n    \n    p = vec2(log(length(p.xy)), atan(p.y,p.x));\n    p*= (6.0/PI)* 10.85;//(20.*clamp((1.0+sin(-2.1+iTime/5.))/1.5,0.1,1.25));\n    p+=vec2(5.,3.); \n    p.y+=iTime*2.0;\n    p.y = mod(p.y,10.015*13.0)-.2;\n    r=p;\n    vec2 lp = (p);\n    p=floor(p);\n    float hash = rand(p);\n    \n    \n    if(p.x>=-5.&&p.x<=4.)\n\t    c.rgb=vec3(clamp(render(lp,hash),0.,1.))*min(length(u)*4.,1.);\n    \n    //if(r.y>(1.0+sin(iTime))/2.0*130.)c.rgb*=0.;\n    \n}", "buffer_a_inputs": [], "common_code": "#define R iResolution.xy\n#define S0(U) texture(iChannel0, (U)/R)\n#define S1(U) texture(iChannel1, (U)/R)\n#define S2(U) texture(iChannel2, (U)/R)\n#define V(U) S0(mod(U,R))\n\n#define decay .9981\n\n//wrap the space (useful when sampling)\n#define A(U) T0(mod(U,R))", "buffer_b_code": "void F(vec2 p, vec2 offset, vec4 s, inout vec2 v, inout float pr, inout float d, inout float n)\n{\n    vec4 target = S0(p+offset-V(p+offset).xy);\n    offset=normalize(offset);\n    v+=offset*(target.w-s.w);\n    pr+=target.w;\n    d+=dot(offset,target.xy);\n    n++;\n}\n\nvoid mainImage(out vec4 s, vec2 p)\n{\n    s.rgb = vec3(0);\n    s = S0(p-V(p).xy);\n    vec2 v = vec2(0), u = (2.0*p-R)/R.y;\n    float d = 0., pr=0.,n=0.;\n    \n    F(p, vec2(0,1), s, v, pr, d, n);\n    F(p, vec2(0,-1), s, v, pr, d, n);\n    F(p, vec2(1,0), s, v, pr, d, n);\n    F(p, vec2(-1,0), s, v, pr, d, n);\n    \n    d/=n;\n    pr/=n;\n    v/=n;\n    \n    s.w = pr-d;\n\ts.xy -= v;   \n    s.z = d;\n    \n    s.xy*=decay;\n    \n    if(S1(p).r>0.)\n    {\n        s.xy = -u*.3;\n    }\n    \n    \n    if (p.x<1.||p.y<1.||R.x-p.x<1.||R.y-p.y<1.) s.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void F(vec2 p, vec2 offset, vec4 s, inout vec2 v, inout float pr, inout float d, inout float n)\n{\n    vec4 target = S0(p+offset-V(p+offset).xy);\n    offset=normalize(offset);\n    v+=offset*(target.w-s.w);\n    pr+=target.w;\n    d+=dot(offset,target.xy);\n    n++;\n}\n\nvoid mainImage(out vec4 s, vec2 p)\n{\ns.rgb = vec3(0);\n    s = S0(p-V(p).xy);\n    vec2 v = vec2(0);\n    float d = 0., pr=0.,n=0.;\n    \n    F(p, vec2(0,1), s, v, pr, d, n);\n    F(p, vec2(0,-1), s, v, pr, d, n);\n    F(p, vec2(1,0), s, v, pr, d, n);\n    F(p, vec2(-1,0), s, v, pr, d, n);\n    \n    d/=n;\n    pr/=n;\n    v/=n;\n    \n    s.w = pr-d;\n\ts.xy -= v;   \n    s.z = d;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 state, vec2 f)\n{\n    for(int i=0;i<2;i++)\n    f -= S1(f).xy;\n \n    state = S0(f);\n    \n    state*=decay;\n    float t = iTime/5.0;\n    \n    if(S2(f).r>0.1)\n        state.rgb += vec3((cos(iTime/3.0)+1.0)/2., (1.1+sin(iTime/5.0))/2.0, cos(sin(iTime)))*.05;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 92, 92, 621]], "test": "untested"}
{"id": "tllfWH", "name": "3. making Rectangle", "author": "altera0", "description": "source tutorial : https://www.youtube.com/watch?v=GgGBR4z8C9o\nsimple onet : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect\n\nI did It !", "tags": ["rectangle"], "likes": 0, "viewed": 240, "published": 3, "date": "1596647255", "time_retrieved": "2024-07-30T20:52:24.794778", "image_code": "float Circle( vec2 uv , vec2 pos , float radius , float blur ) {\n    \n    float d = length( uv - pos );\n    float c = smoothstep( radius , radius - blur , d );\n    return c;\n}\n\n// 웃기 함수\nfloat Smily( vec2 uv , vec2 pos , float radius ) {\n    \n    float blur = 0.01f;\n    \n    // face\n    float c= Circle( uv , pos , radius , blur );\n\t\n    // eye\n    float eyeLeft = Circle ( uv , pos + vec2(-0.15f, 0.2f) , 0.1f , 0.005f );\n    float eyeRight = Circle ( uv , pos + vec2(0.15f, 0.2f) , 0.1f , 0.005f );\n    \n    // mouse\n    float mouse = Circle ( uv , pos + vec2(0.0f, 0.0f) , radius * 0.8f , blur );\n    mouse -= Circle  ( uv , pos + vec2(0.0f, 0.05f) , radius * 0.8f , blur );\n    mouse = clamp( 0. , 1., mouse );\n    \n    // 합성.\n    c -= eyeLeft;\n    c -= eyeRight;\n    c -= mouse;\n\n    return c;\n}\n\n// 밴드\nfloat Band( float t , float start , float end ,  float blur ) {\n    float c;\n    c = smoothstep(  start - blur , start + blur , t ); \n    c *= smoothstep ( end + blur , end - blur , t );\t// 이거 중요함. 스텝함수의 사용법 볼것\n    return c;\n}\n\n\n// 사각형\nfloat Rectangle( vec2 uv , vec2 center , float width , float height ) {\n\n    float c;\n    c = Band(  uv.x , center.x - width / 2.0f  , center.x + width / 2.0f , 0.001f );\n    c *= Band( uv.y , center.y - height / 2.0f , center.y + height / 2.0f , 0.001f );    \n    return c;\n}\n\n\n// 메인\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\t\t// compensate\n    \n    float radius = 0.4f;\n    vec2 pos = vec2(0.4f , 0.0f);\n    \n    float c;\n    vec3 col;\n    \n    c = Smily( uv , -pos , 0.4f );\n    c += Rectangle( uv , pos , 0.4f , 0.4f );\n    \n    \n    col = vec3( 1.0f, 1.0f , 0.0f ) * c ;\n    fragColor = vec4(vec3(col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 64, 64, 175], [177, 194, 244, 244, 812], [814, 824, 887, 887, 1080], [1083, 1096, 1167, 1167, 1372], [1375, 1385, 1442, 1442, 1831]], "test": "untested"}
{"id": "wtlfWH", "name": "2. circle", "author": "altera0", "description": "source tutorial : https://www.youtube.com/watch?v=GgGBR4z8C9o\nsimple onet : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["circle"], "likes": 1, "viewed": 258, "published": 3, "date": "1596647154", "time_retrieved": "2024-07-30T20:52:25.573695", "image_code": "float Circle( vec2 uv , vec2 pos , float radius , float blur ) {\n    \n    float d = length( uv - pos );\n    float c = smoothstep( radius , radius - blur , d );\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\t\t// compensate\n    \n    float radius = 0.4f;\n    vec2 pos = vec2(0.0f);\n    float blur = 0.01f;\n    \n    // face\n    float c= Circle( uv , pos , radius , blur );\n\t\n    // eye\n    float eyeLeft = Circle ( uv , vec2(-0.15f, 0.2f) , 0.1f , 0.005f );\n    float eyeRight = Circle ( uv , vec2(0.15f, 0.2f) , 0.1f , 0.005f );\n    \n    // mouse\n    float mouse = Circle ( uv , pos + vec2(0.0f, 0.0f) , radius * 0.8f , blur );\n    mouse -= Circle  ( uv , pos + vec2(0.0f, 0.05f) , radius * 0.8f , blur );\n    mouse = clamp( 0. , 1., mouse );\n    \n    // 합성.\n    c -= eyeLeft;\n    c -= eyeRight;\n    c -= mouse;\n    \n    vec3 col =  vec3( 1.0f , 1.0f , 0.0f ) * c;\n    \n    fragColor = vec4(vec3(col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 64, 64, 175], [178, 178, 235, 235, 1039]], "test": "untested"}
{"id": "ttsfD8", "name": "[TWITCH] Lowlands juggernauts", "author": "evvvvil", "description": "Lowlands juggernauts - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["terrain", "demoscene", "beam", "glow", "organic", "monster", "dark", "core", "tank", "creature", "juggernaut", "monumental"], "likes": 27, "viewed": 1572, "published": 3, "date": "1596643243", "time_retrieved": "2024-07-30T20:52:26.419434", "image_code": "// Lowlands juggernauts - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n// Thankx to Flopine for the octan mirror method suggestion, and thanks to Mercury for writing it.\n\n// \"Fortnite is cool, but don't forget who the real fascists are.\" - Woody Guthrie\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,g,gg,tnoi;vec3 np,bp,op,pp,po,no,al,ld;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r; return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin( float d1, float d2, float k ){  float h = max(k-abs(d1-d2),0.0);return min(d1,d2)-h*h*0.25/k; }\nvec2 mo(vec2 p, vec2 d) {p=abs(p)-d;if(p.y>p.x) p=p.yx;return p;} //FLOPINE MULTI OCTAN MIRROR THINGY WRITEN BY MERCURY IN THEIR SDF LIB  https://www.shadertoy.com/view/ttffWH\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25; //MERCURTY SDF LIBRARY IS HERE OFF COURSE: http://mercury.sexy/hg_sdf/\n     f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p )\n{ \n  np=p; p.z=mod(p.z+tt*5.,40.)-20.;  \n  op=p; //Originally thought I would do a sort of bounce animation but i found this slow forward crawl more menacing:\n  p.y+=sin(op.z*.2+tt)*3.-5.; //Flopine pointed out a really good bounce ease function like this: p.y -= bouncy(fract(tt))*10.; using this function: float bouncy (float T){return sqrt(abs(sin(T*PI)));} \n  pp=p; //Thankx again Flopine\n  pp.xz=mo(pp.xz, vec2(1.)); \n  pp.yz*=r2(1.2+sin(p.y*.5+tt)*.3);\n  pp.yz=mo(pp.yz,vec2(0.5,1.));\n  pp.xy=mo(pp.xy,vec2(2.5));  \n  tnoi=texNoise((np.xz+vec2(20,tt*2.))*.018).r;    \n  vec2 h,t=vec2(length(p)-5.,5); //SHELL BLUE\n  t.x=max(abs(t.x)-.4,abs(pp.z)-.5);    \n  t.x=min(t.x,0.5*(op.y+tnoi*8.+4.)); //TERRAIN BLUE\n  bp=pp; bp.xy*=r2(-.9);\n  t.x=smin(t.x,0.6*max(length(bp.xz)-max(1.4-tnoi*4.,0.45),p.y-6.),1.); //TENTACLES BLUE    \n  float frill=sin(pp.y*15.)*0.03;    \n  h=vec2(length(p)-5.5,6); //SHELL WHITE\n  h.x=max(h.x,abs(pp.z)-.2);\n  h.x=max(h.x,-(length(p)-4.+frill));\n  bp=pp; bp.xy*=r2(.4585);\n  h.x=min(0.8*length(bp.yz+vec2(2,0.))-.1+abs(bp.x)*.02,h.x);\n  t=t.x<h.x?t:h;  \n  h=vec2(length(p)-5.4,3); //SHELL BLACK\n  h.x=abs(h.x)-.2;\n  h.x=max(h.x,abs(pp.z)-.3);  \n  h.x=max(h.x,abs(abs(abs(pp.x)-1.)-.5)-.25);  \n  t=t.x<h.x?t:h;    \n  h=vec2(length(p)-3.+frill,5); //CORE \n  pp.xy*=r2(-.6); h.x=smin(h.x,.8*length(pp.xz-vec2(.2,1.+tnoi*3.))-.4+frill,3.);  \n  t=t.x<h.x?t:h;   \n  h.x=min(h.x,0.2*length(cos(op*.2)-1.5)); //TERRAIN SOFT ORBS\n  g+=0.1/(0.1+h.x*h.x*40.);  \n  h=vec2(length(p)-3.+frill,5); //RED CORE   \n  pp.xy*=r2(-.1);\n  h.x=smin(h.x,length(pp.xz-vec2(.2,1.1+tnoi*3.))-.2+frill,3.);\n  h.x=smin(h.x,.6*length(abs(bp+vec3(2,2.+tnoi*5.,0.))-2.)-.7,1.);    \n  gg+=0.1/(0.1+h.x*h.x*(80.-79.9*sin(op.y*.2+tt+1.)));\n  t=t.x<h.x?t:h; t.x*=0.7;\n  return t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n  vec2 h,t=vec2(0);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.0001||t.x>120.) break;\n    t.x+=h.x;t.y=h.y;    \n  }\n  if(t.x>120.) t.y=0.;\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.82);\n  vec3 ro=mix(vec3(0,-4,-15.),vec3(10,2,-15.),ceil(sin(tt))),\n  cw=normalize(vec3(0,0,0)-ro),\n  cu=normalize(cross(cw,vec3(0,1,0))),\n  cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;  \n  co=fo=vec3(.15,.1,.14)-length(uv)*.2;\n  ld=normalize(vec3(.3,.1,-.3));\n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n    al=vec3(.1,.2,.4);\n    if(z.y<5.)al=vec3(0);\n    if(z.y>5.)al=vec3(1);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);\n    co=mix(al*(a(.05)*a(.1)+.2)*(dif*vec3(.1,.2,.4)*3.+s(.5)),fo,min(fr,.5));\n    co=mix(fo,co,exp(-.00005*t*t*t));\n  }  \n  fragColor = vec4(pow(co+g*.2*vec3(.1,.2,.7)+gg*.2*vec3(.7,.2,.1),vec3(.55)),1);\n} ", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[456, 456, 480, 480, 522], [523, 523, 540, 540, 583], [584, 584, 626, 626, 691], [692, 692, 717, 717, 757], [758, 868, 891, 891, 1164], [1165, 1165, 1184, 1184, 2960], [2961, 2961, 2989, 2989, 3158], [3248, 3248, 3305, 3305, 4196]], "test": "untested"}
{"id": "tlsfD8", "name": "1_1 ShaderToy Restart !", "author": "altera0", "description": "1. Shadertoy for absolute beginners\n\nhttps://www.youtube.com/watch?v=u5HAYVHsasc\n\n\n2. my game\n\n https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["shader"], "likes": 1, "viewed": 367, "published": 3, "date": "1596640252", "time_retrieved": "2024-07-30T20:52:27.386852", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\t\t// compensate\n    \n    float d = length( uv );\n\tfloat s = smoothstep( 0.3 , 0.3-0.01 , d );\n    \n    \n    fragColor = vec4(vec3(s),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 298]], "test": "untested"}
{"id": "WtsfDH", "name": "FXAA antialiasing", "author": "mystery", "description": "Replicated the post effect antialiasing from nvidia docs and catlikecoding example.\nLeft side is with antialiasing and right side is without.", "tags": ["posteffect", "posteffect", "antialiasing", "antialiasing"], "likes": 8, "viewed": 1024, "published": 3, "date": "1596620321", "time_retrieved": "2024-07-30T20:52:28.438036", "image_code": "// FXAA by Dave Hoskins, FXAA algorithm from NVIDIA\n// http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\n// https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/\n\n#define EDGE_STEP_COUNT 10\n#define EDGE_GUESS 8.0f\n#define EDGE_STEPS 1.0f, 1.5f, 2.0f, 2.0f, 2.0f, 2.0f, 2.0f, 2.0f, 2.0f, 4.0f\nconst float edgeSteps[EDGE_STEP_COUNT] = float[EDGE_STEP_COUNT]( EDGE_STEPS );\n\nfloat _ContrastThreshold = 0.0312f;\nfloat _RelativeThreshold = 0.063f;\nfloat _SubpixelBlending = 1.0f;\n\nvec4 Sample (sampler2D  tex2D, vec2 uv) {\n\treturn texture(tex2D, uv);\n}\n\nfloat SampleLuminance (sampler2D tex2D, vec2 uv) {\t\t\t\n\treturn dot(Sample(tex2D, uv).rgb, vec3(0.3f, 0.59f, 0.11f));\n}\n\nfloat SampleLuminance (sampler2D tex2D, vec2 texSize, vec2 uv, float uOffset, float vOffset) {\n\tuv += texSize * vec2(uOffset, vOffset);\n\treturn SampleLuminance(tex2D, uv);\n}\n\nstruct LuminanceData {\n\tfloat m, n, e, s, w;\n\tfloat ne, nw, se, sw;\n\tfloat highest, lowest, contrast;\n};\n\nLuminanceData SampleLuminanceNeighborhood (sampler2D tex2D, vec2 texSize, vec2 uv) {\n\tLuminanceData l;\n\tl.m = SampleLuminance(tex2D, uv);\n\tl.n = SampleLuminance(tex2D, texSize, uv,  0.0f,  1.0f);\n\tl.e = SampleLuminance(tex2D, texSize, uv,  1.0f,  0.0f);\n\tl.s = SampleLuminance(tex2D, texSize, uv,  0.0f, -1.0f);\n\tl.w = SampleLuminance(tex2D, texSize, uv, -1.0f,  0.0f);\n\n\tl.ne = SampleLuminance(tex2D, texSize, uv,  1.0f,  1.0f);\n\tl.nw = SampleLuminance(tex2D, texSize, uv, -1.0f,  1.0f);\n\tl.se = SampleLuminance(tex2D, texSize, uv,  1.0f, -1.0f);\n\tl.sw = SampleLuminance(tex2D, texSize, uv, -1.0f, -1.0f);\n\n\tl.highest = max(max(max(max(l.n, l.e), l.s), l.w), l.m);\n\tl.lowest = min(min(min(min(l.n, l.e), l.s), l.w), l.m);\n\tl.contrast = l.highest - l.lowest;\n\treturn l;\n}\n\nbool ShouldSkipPixel (LuminanceData l) {\n\tfloat threshold =\n\t\tmax(_ContrastThreshold, _RelativeThreshold * l.highest);\n\treturn l.contrast < threshold;\n}\n\nfloat DeterminePixelBlendFactor (LuminanceData l) {\n\tfloat f = 2.0f * (l.n + l.e + l.s + l.w);\n\tf += l.ne + l.nw + l.se + l.sw;\n\tf *= 1.0f / 12.0f;\n\tf = abs(f - l.m);\n\tf = clamp(f / l.contrast, 0.0, 1.0);\n\n\tfloat blendFactor = smoothstep(0.0f, 1.0f, f);\n\treturn blendFactor * blendFactor * _SubpixelBlending;\n}\n\nstruct EdgeData {\n\tbool isHorizontal;\n\tfloat pixelStep;\n\tfloat oppositeLuminance, gradient;\n};\n\nEdgeData DetermineEdge (vec2 texSize, LuminanceData l) {\n\tEdgeData e;\n\tfloat horizontal =\n\t\tabs(l.n + l.s - 2.0f * l.m) * 2.0f +\n\t\tabs(l.ne + l.se - 2.0f * l.e) +\n\t\tabs(l.nw + l.sw - 2.0f * l.w);\n\tfloat vertical =\n\t\tabs(l.e + l.w - 2.0f * l.m) * 2.0f +\n\t\tabs(l.ne + l.nw - 2.0f * l.n) +\n\t\tabs(l.se + l.sw - 2.0f * l.s);\n\te.isHorizontal = horizontal >= vertical;\n\n\tfloat pLuminance = e.isHorizontal ? l.n : l.e;\n\tfloat nLuminance = e.isHorizontal ? l.s : l.w;\n\tfloat pGradient = abs(pLuminance - l.m);\n\tfloat nGradient = abs(nLuminance - l.m);\n\n\te.pixelStep =\n\t\te.isHorizontal ? texSize.y : texSize.x;\n\t\n\tif (pGradient < nGradient) {\n\t\te.pixelStep = -e.pixelStep;\n\t\te.oppositeLuminance = nLuminance;\n\t\te.gradient = nGradient;\n\t}\n\telse {\n\t\te.oppositeLuminance = pLuminance;\n\t\te.gradient = pGradient;\n\t}\n\n\treturn e;\n}\n\nfloat DetermineEdgeBlendFactor (sampler2D  tex2D, vec2 texSize, LuminanceData l, EdgeData e, vec2 uv) {\n\tvec2 uvEdge = uv;\n\tvec2 edgeStep;\n\tif (e.isHorizontal) {\n\t\tuvEdge.y += e.pixelStep * 0.5f;\n\t\tedgeStep = vec2(texSize.x, 0.0f);\n\t}\n\telse {\n\t\tuvEdge.x += e.pixelStep * 0.5f;\n\t\tedgeStep = vec2(0.0f, texSize.y);\n\t}\n\n\tfloat edgeLuminance = (l.m + e.oppositeLuminance) * 0.5f;\n\tfloat gradientThreshold = e.gradient * 0.25f;\n\n\tvec2 puv = uvEdge + edgeStep * edgeSteps[0];\n\tfloat pLuminanceDelta = SampleLuminance(tex2D, puv) - edgeLuminance;\n\tbool pAtEnd = abs(pLuminanceDelta) >= gradientThreshold;\n\n\tfor (int i = 1; i < EDGE_STEP_COUNT && !pAtEnd; i++) {\n\t\tpuv += edgeStep * edgeSteps[i];\n\t\tpLuminanceDelta = SampleLuminance(tex2D, puv) - edgeLuminance;\n\t\tpAtEnd = abs(pLuminanceDelta) >= gradientThreshold;\n\t}\n\tif (!pAtEnd) {\n\t\tpuv += edgeStep * EDGE_GUESS;\n\t}\n\n\tvec2 nuv = uvEdge - edgeStep * edgeSteps[0];\n\tfloat nLuminanceDelta = SampleLuminance(tex2D, nuv) - edgeLuminance;\n\tbool nAtEnd = abs(nLuminanceDelta) >= gradientThreshold;\n\n\tfor (int i = 1; i < EDGE_STEP_COUNT && !nAtEnd; i++) {\n\t\tnuv -= edgeStep * edgeSteps[i];\n\t\tnLuminanceDelta = SampleLuminance(tex2D, nuv) - edgeLuminance;\n\t\tnAtEnd = abs(nLuminanceDelta) >= gradientThreshold;\n\t}\n\tif (!nAtEnd) {\n\t\tnuv -= edgeStep * EDGE_GUESS;\n\t}\n\n\tfloat pDistance, nDistance;\n\tif (e.isHorizontal) {\n\t\tpDistance = puv.x - uv.x;\n\t\tnDistance = uv.x - nuv.x;\n\t}\n\telse {\n\t\tpDistance = puv.y - uv.y;\n\t\tnDistance = uv.y - nuv.y;\n\t}\n\n\tfloat shortestDistance;\n\tbool deltaSign;\n\tif (pDistance <= nDistance) {\n\t\tshortestDistance = pDistance;\n\t\tdeltaSign = pLuminanceDelta >= 0.0f;\n\t}\n\telse {\n\t\tshortestDistance = nDistance;\n\t\tdeltaSign = nLuminanceDelta >= 0.0f;\n\t}\n\n\tif (deltaSign == (l.m - edgeLuminance >= 0.0f)) {\n\t\treturn 0.0f;\n\t}\n\treturn 0.5f - shortestDistance / (pDistance + nDistance);\n}\n\nvec4 ApplyFXAA (sampler2D  tex2D, vec2 texSize, vec2 uv) {\n\tLuminanceData l = SampleLuminanceNeighborhood(tex2D, texSize, uv);\n\tif (ShouldSkipPixel(l)) {\n\t\treturn Sample(tex2D, uv);\n\t}\n\n\tfloat pixelBlend = DeterminePixelBlendFactor(l);\n\tEdgeData e = DetermineEdge(texSize, l);\n\tfloat edgeBlend = DetermineEdgeBlendFactor(tex2D, texSize, l, e, uv);\n\tfloat finalBlend = max(pixelBlend, edgeBlend);\n\n\tif (e.isHorizontal) {\n\t\tuv.y += e.pixelStep * finalBlend;\n\t}\n\telse {\n\t\tuv.x += e.pixelStep * finalBlend;\n\t}\n\treturn vec4(Sample(tex2D, uv).rgb, l.m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texSize = 1.0f/iResolution.xy;\n    float t = 0.5f + sin(iTime) * 0.5;\n    if(uv.x < t) {\n    \tfragColor = ApplyFXAA(iChannel0,texSize, uv);\n    } else {\n        fragColor = texture(iChannel0, uv);\n    }\n    fragColor += step(abs(uv.x - t), texSize.x);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 NormalizeSpace(vec2 uv)\n{\n    return (uv - 0.5 * iResolution.xy) / iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvTex = fragCoord/iResolution.xy;\n    vec2 uv = NormalizeSpace(fragCoord);\n    float c = step(length(uv), 0.25);\n    fragColor = vec4(c, c, c, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsfDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[524, 524, 565, 565, 595], [597, 597, 647, 647, 714], [716, 716, 810, 810, 889], [997, 997, 1081, 1081, 1768], [1770, 1770, 1810, 1810, 1922], [1924, 1924, 1975, 1975, 2234], [2332, 2332, 2388, 2388, 3146], [3148, 3148, 3251, 3251, 4988], [4990, 4990, 5048, 5048, 5539], [5541, 5541, 5598, 5598, 5901]], "test": "untested"}
{"id": "WtsBDH", "name": "Bicubic C2 cont. Interpolation", "author": "TinyTexel", "description": "How to C2 continuous bicubic interpolation:\n- compute C1 continuous partial derivatives by using a specific convolution kernel (Buffer C)\n- construct a bicubic patch in each 2x2 neighborhood from the values+derivatives stored at the grid vertices (Image)\n", "tags": ["filter", "filtering", "bicubic", "cubic", "interpolation", "kernel", "reconstruction", "c2"], "likes": 27, "viewed": 1572, "published": 3, "date": "1596614589", "time_retrieved": "2024-07-30T20:52:29.389493", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nHow to C2 continuous bicubic interpolation:\n- compute C1 continuous partial derivatives by using a specific convolution kernel (Buffer C)\n- construct a bicubic patch in each 2x2 neighborhood from the values+derivatives stored at the grid vertices (Image)\n- bonus: analytically compute normals during the reconstruction\n\nbottom:\n\tleft:  bicubically sampled grey scale texture\n\tright: artifact free shading based on analytically computed C1 continuous normals  \ntop:\n\tleft:  abs(laplacian); useful for debugging the C2 continuity\n\tright: normals\n\n\nRelated:\n\n- https://www.shadertoy.com/view/wlsBz2 | \"C2-interpolating cubic Kernel\"   (plot + background info on the kernel used to compute the derivatives)\n- https://www.shadertoy.com/view/3tfBzX | \"Cubic Reconstruction\"            (derivation of the bicubic reconstruction scheme)\n- https://www.shadertoy.com/view/wtByDt | \"Single Sample Bicubic Sampling\"  (approximating the reconstruction with a single sample in 2d)\n- https://www.shadertoy.com/view/tdtyzj | \"Single Sample Tricubic Sampling\" (approximating the reconstruction with a single sample in 3d)\n\n*/\n\n// use this to scale the shown region\n#if 1\n\t#define SCALE 0.125*0.5\n#else\n\t#define SCALE 0.75\n#endif\n\n\n// CUBIC AND BICUBIC RECONSTRUCTION KERNELS ============================================================================================\n\nfloat kern_v(float x) { return 1.0-x*x*(3.0-2.0*abs(x)); }\nfloat kern_d(float x) { float o = abs(x)-1.0; return x*(o*o); }\n\nfloat kern_vD1(float x) { return x*(abs(x)*6.0-6.0); }\nfloat kern_dD1(float x) { return (abs(x)-1.0)*(abs(x)*3.0-1.0); }\n\nfloat kern_vD2(float x) { return abs(x) * 12.0 - 6.0; }\nfloat kern_dD2(float x) { return x * 6.0 + (x > 0.0 ? -4.0 : 4.0); }\n\n\nvec4 kern(vec2 p)\n{\n    return vec4(kern_d(p.x) * kern_v(p.y),\n                kern_v(p.x) * kern_d(p.y),\n                kern_d(p.x) * kern_d(p.y),\n                kern_v(p.x) * kern_v(p.y));\n}\n\nmat4 kern4x4(vec2 p)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    mat4 m = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n    \n    return m;\n}\n\nvoid kern4x4(vec2 p, out mat4 mA, out mat4 mB)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    vec2 vD2 = vec2(kern_vD2(p.x), kern_vD2(p.y));\n    vec2 dD2 = vec2(kern_dD2(p.x), kern_dD2(p.y));\n    \n    mA = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n\n    mB = mat4\n    (\n        /*   kernDxx      |  kernDyy      |  kernDxxy       |  kernDxyy    */\n        vec4(dD2.x * v.y  ,  d.x * vD2.y  ,  dD2.x * vD1.y  ,  dD1.x * vD2.y),\n        vec4(vD2.x * d.y  ,  v.x * dD2.y  ,  vD2.x * dD1.y  ,  vD1.x * dD2.y),\n        vec4(dD2.x * d.y  ,  d.x * dD2.y  ,  dD2.x * dD1.y  ,  dD1.x * dD2.y),\n        vec4(vD2.x * v.y  ,  v.x * vD2.y  ,  vD2.x * vD1.y  ,  vD1.x * vD2.y)\n    );\n}\n\n\n// BICUBIC SAMPLING ROUTINES =============================================================================================================\n\n// this is the most basic version which only evaluates the function value\nfloat SampleBicubic(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    float r = 0.0;\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += dot(c, kern(l));\n    }\n    \n\treturn r;\n}\n\n// ... this version also outputs derivatives (used here to compute normals)\nvec4 SampleBicubic2(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += kern4x4(l) * c;\n    }\n    \n    // r = vec4(df/dx, df/dy, ddf/dxy, f)\n\treturn r;\n}\n\n// ... this version also outputs higher order derivatives (only used to debug C2 continuity here)\nvec4 SampleBicubic3(sampler2D channel, vec2 uv, out vec4 d2)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    d2 = vec4(0.0);\n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        mat4 mA, mB;\n        kern4x4(l, /*out*/ mA, mB);\n        \n        r  += mA * c;\n        d2 += mB * c;\n    }\n    \n    // r  = vec4(  df/dx,   df/dy,  ddf/dxy ,         f)\n    // d2 = vec4(ddf/dxx, ddf/dyy, dddf/dxxy, dddf/dxyy)\n\treturn r;\n}\n\n\n// IMAGE ==========================================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{    \n   #if 0\n    //if(uv0.x < 256.0 && uv0.y < 256.0)\n    {\n    \tvec4 col = texelFetch(iChannel0, ivec2(uv0)/1, 0);\n        col.xyz = col.xyz * 2.0 + 0.2;\n    \tfragColor = vec4((clamp01(col.rgb)), 0.0);\n        return;\n    }\n   #endif\n \n    vec3 col;\n    \n    vec2 uv = uv0;\n    \n   #if 1\n    if(uv0.x >= iResolution.x*0.5)\n    uv.x -= iResolution.x*0.5;\n   #endif\n    \n    col = vec3(texture(iChannel0, uv0/iResolution.xy*0.125).r);\n    \n    float s = SCALE;\n    \n    uv += 2.0/SCALE;\n    uv += iMouse.xy;// - iResolution.xy*0.5;\n    \n    vec4 d2;\n    vec4 h = SampleBicubic3(iChannel0, uv * s, d2);\n    \n    float nscale = 4.0;// must be 1 for normals to properly align with height map\n    vec3 N = normalize(vec3(-h.xy * nscale, 1.0));\n    \n    vec3 V = vec3(0.0, 0.0, 1.0);\n    vec3 L = AngToVec(vec2(Pi*0.75, Pi*0.3)).xzy;\n    //vec3 L = AngToVec(vec2(Pi*0.75 + sin(iTime)*(Pi*0.3), Pi*0.3)).xzy;\n    vec3 H = normalize(L + V);\n\n    float ct = clamp01(dot(N, L));\n    \n    if(uv0.x < iResolution.x*0.5)\n    {\n        if(uv0.y < iResolution.y*0.75)\n        {\n    \t\tcol = vec3(h.w);// == col = vec3(SampleBicubic(iChannel0, uv0 * s));\n        }\n        else\n        {\n            col = vec3(abs(d2.x + d2.y));\n            //col = vec3(abs(d2.x + d2.y + d2.z + d2.w));\n            //col = vec3(abs(d2.z + d2.w));\n        }\n    }\n    else\n    {\n        if(uv0.y < iResolution.y*0.75)\n        {\n        \tfloat r = (1.0-Pow2(1.0-h.w));\n        \tcol = vec3(ct*h.w*h.w + 0.25*ct*r*(1.0/(1.0 + r*20.0 * (1.0-clamp01(dot(H, N))))));\n\n        \tcol = GammaEncode(clamp01(col));\n        }\n        else\n        {\n         \tcol = clamp01(N * 0.5 + 0.5);\n        }\n    }\n    \n    \n    fragColor = vec4(col, 0.0);\n}\n\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\n#define FILTERING_MODE 0\n/*\n\t0: interpolating cubic kernel (produces C2 continuous signal without altering the sample values)\n\t1: generalized cubic BSpline (produces C2 continuous signal with smaller kernel but alters the sample values)\n\t2: quadratic BSpline (produces C1 continuous signal)\n\t3: central difference (reconstructed signal will not be C2 continuous; overall bad quality)\n*/\n\n#define FETCH(uv) (texelFetch(iChannel3, uv + ivec2(40, 64), 0).b)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{    \n    ivec2 uv = ivec2(uv0 - 0.5);\n    \n    vec4 col = vec4(0.0);\n    \n#if FILTERING_MODE == 0\n    // ======================================================= INTERPOLATING CUBIC KERNEL =======================================================\n    \n    // truncated kernel radii for 1st and 2nd derivatives respectively\n    int r1 = 5;\n    int r2 = 2;\n    // setting r2 to 0 results in suprisingly little shading artifacts (which might mean that in 3d we can throw out all higher order derivatives..)\n    \n    \n    col.w = FETCH(uv);\n    \n   #if 1\n    // precomputed kernel\n    float kern[12];\n    kern[0] = 0.0         ; kern[1] = -0.803848    ; kern[ 2] = 0.21539       ; kern[ 3] = -0.0577137    ; \n    kern[4] = 0.0154643   ; kern[5] = -0.00414365  ; kern[ 6] = 0.00111029    ; kern[ 7] = -0.000297501  ; \n    kern[8] = 0.0000797152; kern[9] = -0.0000213596; kern[10] = 0.00000572329 ; kern[11] = -0.00000153355;\n   #else\n    // compute kernel at compile time\n    float kern[12];\n    {\n    \tkern[0] = 0.0;\n        \n        float sn = -1.0;\n    \tfor(uint i = 1u; i < 12u; ++i, sn = -sn)\n        \tkern[i] = sn * 3.0 * exp2(-float(i) * log2(2.0 + sqrt(3.0)));\n    }\n   #endif    \n    \n    // d/dx\n    for(int i = -r1; i <= r1; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, 0));\n        \n        float k = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        \n        col.x += f * k;\n    }\n    \n    // d/dy\n    for(int i = -r1; i <= r1; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(0, i));\n        \n        float k = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        \n        col.y += f * k;\n    }\n    \n    \n    // d^2/dxy\n    for(int j = -r2; j <= r2; ++j)\n    for(int i = -r2; i <= r2; ++i)\n    {\n        if(i == 0 || j == 0) continue;\n        \n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        float kx = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        float ky = kern[abs(j)] * (j > 0 ? -1.0 : 1.0);\n        \n        col.z += f * (kx * ky);\n    }\n\n#elif FILTERING_MODE == 1\n    // ======================================================= GENERALIZED CUBIC BSPLINE =======================================================\n    \n    float kernD0[3];\n    float kernD1[3];\n    \n    kernD0[0] = 2.0/3.0; kernD0[1] = 1.0/6.0; kernD0[2] = 0.0;\n    kernD1[0] =     0.0; kernD1[1] =    -0.5; kernD1[2] = 0.0;\n    \n    float sw;// side lobes weight\n\n    sw = 0.0;// cubic BSpline\n    \n   #if 1\n   \n    sw = 0.25;// similar to 1/3 but less ringing\n    \n   #elif 0\n   \n    sw = 1.0/3.0;// kernD0[0] == 1\n    \n   #elif 0\n    \n    sw = 0.186605;// max abs derivative == 1\n    \n   #elif 0\n    \n    sw = 1.0/6.0;// maximaly flat pass band\n    \n   #elif 0\n    \n    sw = -0.25;// spectrum falls off to 0 at Nyquist frequency\n    \n   #endif\n    \n    // add a pair of side lobes:\n    kernD0[0] += 1.0 * sw; kernD0[1] += -1.0/3.0 * sw; kernD0[2] += -1.0/6.0 * sw;\n    \t                   kernD1[1] += -1.0     * sw; kernD1[2] +=  0.5     * sw;\n    \n    int r = sw == 0.0 ? 1 : 2;\n    for(int j = -r; j <= r; ++j)\n    for(int i = -r; i <= r; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        int x = abs(i);\n        int y = abs(j);\n        \n        float kAx = kernD0[x];\n        float kAy = kernD0[y];\n        \n        float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n        float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n        \n        col += f * vec4(kBx * kAy, \n                        kAx * kBy, \n                        kBx * kBy,\n                        kAx * kAy);\n    }\n    \n#elif FILTERING_MODE == 2\n    // ======================================================= QUADRATIC BSPLINE =======================================================\n    \n    float kernD0[2];\n    float kernD1[2];\n    \n    kernD0[0] = 0.5; kernD0[1] =  0.25;\n    kernD1[0] = 0.0; kernD1[1] = -0.5 ;\n    \n    int r = 1;\n    for(int j = -r; j <= r; ++j)\n    for(int i = -r; i <= r; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        int x = abs(i);\n        int y = abs(j);\n        \n        float kAx = kernD0[x];\n        float kAy = kernD0[y];\n        \n        float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n        float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n        \n        col += f * vec4(kBx * kAy, \n                        kAx * kBy, \n                        kBx * kBy,\n                        kAx * kAy);\n    }\n    \n#else    \n    // ======================================================= CENTRAL DIFFERENCE =======================================================\n    \n    col.w = FETCH(uv);\n    \n    float kern[2];\n    \n    kern[0] =  0.0;\n    kern[1] = -0.5;\n    \n    for(int j = -1; j <= 1; ++j)\n    for(int i = -1; i <= 1; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        float kx = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        float ky = kern[abs(j)] * (j > 0 ? -1.0 : 1.0);\n        \n        col.xyz += f * vec3(kx * (j == 0 ? 1.0 : 0.0), \n                            ky * (i == 0 ? 1.0 : 0.0), \n                            kx * ky);\n    }\n    \n#endif    \n\n    // col = vec4(df/dx, df/dy, d^2f/dxy, f)\n    fragColor = col;\n}\n\n", "buffer_c_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nfloat cubic(float x) {return x*x*(3.-2.*x);}\nvec2  cubic(vec2  x) {return x*x*(3.-2.*x);}\nvec3  cubic(vec3  x) {return x*x*(3.-2.*x);}\nvec4  cubic(vec4  x) {return x*x*(3.-2.*x);}\n\nfloat quintic(float x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec2  quintic(vec2  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec3  quintic(vec3  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec4  quintic(vec4  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsBDH.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1425, 1425, 1448, 1448, 1483], [1484, 1484, 1507, 1507, 1547], [1549, 1549, 1574, 1574, 1603], [1604, 1604, 1629, 1629, 1669], [1671, 1671, 1696, 1696, 1726], [1727, 1727, 1752, 1752, 1795], [1798, 1798, 1817, 1817, 1992], [1994, 1994, 2016, 2016, 2655], [2657, 2657, 2705, 2705, 3849], [3992, 4066, 4115, 4115, 4538], [4540, 4616, 4665, 4665, 5134], [5136, 5234, 5296, 5296, 5938], [6074, 6074, 6125, 6125, 7829]], "test": "untested"}
{"id": "3llfW8", "name": "Voronoise (Readability Edit)", "author": "TEttinger", "description": "Voronoise by iq ( https://www.shadertoy.com/view/Xd23Dh ) is great, but the original shadertoy seems to have changed behavior recently. API_Beast kept the desired behavior ( https://www.shadertoy.com/view/ltfSzr ). This fixes his version.", "tags": ["voronoi", "noise", "perlin", "worley", "voronoise"], "likes": 1, "viewed": 370, "published": 3, "date": "1596587921", "time_retrieved": "2024-07-30T20:52:30.291082", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Original by iq: https://www.shadertoy.com/view/Xd23Dh (seems to have been edited)\n// Made more readable and understandable by Manuel Riecke/API_Beast\n// Edit by API_Beast: https://www.shadertoy.com/view/ltfSzr\n// A reserved word, sample, was used in code in API_Beast's version, and this corrects it.\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n\n\tvec2 p = 0.5 - 0.5*sin( iTime*vec2(1.01,1.71) );\n\n\tif(iMouse.w > 0.001)\n        p = vec2(0.0,1.0) + vec2(1.0,-1.0)*iMouse.xy/iResolution.xy;\n\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n    p = p*p*(3.0-2.0*p);\n\n\tfloat f = iqnoise( 24.0*uv, p.x, p.y );\n\n\tfragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llfW8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[429, 429, 449, 449, 556], [558, 558, 578, 578, 641], [643, 643, 706, 706, 1756], [1758, 1758, 1815, 1815, 2150]], "test": "untested"}
{"id": "ttfBDH", "name": "Cave at the Edge of the Universe", "author": "jarble", "description": "This cave is based on the [url=https://www.shadertoy.com/view/tl2yDz]\"Edge of the Universe\"[/url] fractal.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "thorns"], "likes": 0, "viewed": 298, "published": 3, "date": "1596578266", "time_retrieved": "2024-07-30T20:52:31.055039", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n#define ITERATIONS 20\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat sceneSDF(vec3 p) {\n    p /= 20.0;\n\tvec2 uv = p.xy - vec2(.5);\n    float time = p.z * 2. + 15.+length(sin(uv/10.0));\n    uv = sin(uv/(20.0+sin(uv.yx/20.0+time)))*3.0;\n    \n    float len = dot(uv, uv) * .3 - .4;\n    \n    vec3 z = sin(time + vec3(.23, .19, .17));\n    for (int i = 0; i < ITERATIONS; i++) {\n        z += cos(z.zxy + uv.yxy * float(i) * len);\n    }\n    \n    float val = z.r * .06 + .3;\n    val -= smoothstep(.1, -.3, len) * 1.5 + len * .3 - .4;\n    return val;\n}\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 1.0;\n    float t1 = iTime*speed;\n\tvec3 eye = vec3(-10.0-200.0,9.0-15.0,9.0*t1);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[612, 612, 636, 636, 1092], [1095, 1095, 1123, 1123, 1241], [1244, 1665, 1756, 1756, 2062], [2077, 2331, 2396, 2396, 2528], [2530, 2619, 2648, 2648, 2958], [2960, 3452, 3592, 3592, 4202], [4204, 4574, 4659, 4659, 5074], [5076, 5403, 5452, 5487, 5618], [5620, 5620, 5677, 5677, 6794]], "test": "untested"}
{"id": "wlffD8", "name": "Perpetually moving circles", "author": "ChocolatePinecone", "description": "Some moving circles to practice shadering", "tags": ["circles", "loading", "spinner", "perpetual"], "likes": 2, "viewed": 375, "published": 3, "date": "1596573558", "time_retrieved": "2024-07-30T20:52:31.817002", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.1415926538\n\nfloat drawCircle(vec2 pos, float radius, float edgeFade, vec2 fragCoord) {\n    // Get distance from pixel to circle radius\n    float dis = distance(fragCoord, pos.xy * iResolution.xy);\n    \n    // Return 1.0 if inside circle\n    return 1.0 - smoothstep(edgeFade * radius, radius, dis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    float pct = 0.0;\n    \n    // Set circle properties\n    float radius = 40.0;\n    float edgeFade = 0.9;\n    vec2 bottomLeft = vec2(0.25);\n    vec2 topRight = vec2(0.75);\n    \n    // Determine movement\n    vec2 maxMv = topRight.xy - bottomLeft.xy;\n    float offset = smoothstep(0.0, 1.0, mod(0.5 * iTime, 1.0));\n    vec2 mv = offset * maxMv;\n\n    // Draw circles\n    pct = drawCircle(vec2(bottomLeft.x, bottomLeft.y + mv.y), radius, edgeFade, fragCoord);\n    pct += drawCircle(vec2(bottomLeft.x + mv.x, topRight.y), radius, edgeFade, fragCoord);\n    pct += drawCircle(vec2(topRight.x, topRight.y - mv.y), radius, edgeFade, fragCoord);\n    pct += drawCircle(vec2(topRight.x - mv.x, bottomLeft.y), radius, edgeFade, fragCoord);\n    \n    // Set color\n    float lerp = sin(offset * PI);\n    vec3 red = vec3(0.5, 0.0, 0.0);\n    vec3 blue = vec3(0.494, 0.976, 1.0);\n\n    vec3 color = mix(blue, red, lerp) * pct;\n\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 145, 193, 358], [360, 360, 415, 415, 1398]], "test": "untested"}
{"id": "ttXfWH", "name": "raymarching1_", "author": "pohy", "description": "raymarching1", "tags": ["raymarching1"], "likes": 3, "viewed": 209, "published": 3, "date": "1596572278", "time_retrieved": "2024-07-30T20:52:32.691664", "image_code": "/*\n * Progressing with learning ray marching techniques.\n * I recommend to listen to Confidence of Equals by Isaac Chambers\n * https://jumpsuitrecords.bandcamp.com/track/confidence-of-equals\n * Some pretty smooth jams in that EP\n */\n\n#define MAX_ITER 100\n#define MAX_DIST 20.\n#define EPSILON 0.001\n\n#define PI 3.14159\n\nfloat posSin(float x) {\n    return sin(x) * .5 + .5;\n}\nfloat posCos(float x) {\n    return cos(x) * .5 + .5;\n}\n\nfloat sMin(float d1, float d2, float k) {\n    float h = clamp(.5 + .5 * (d2 -d1) / k, 0., 1.);\n    return mix(d2, d1, h) - k * h * (1. - h);\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec2 mapMat(vec3 p) {\n    float t = PI * 3. + iTime * .1;\n    // Plane\n    float d = p.y - (-.25) * sin(p.x - p.z * p.y) * .3;\n    \n    float mat = -1.;\n    \n    // Spheres\n    for (float i = 0.; i < 40.; i++) {\n        float a = i + t;\n        a += 1. + i + t * .2 * i;\n        float r = .25 + i * posSin(i + t * 8.) * .005;\n        float h = 1. + i * .1;\n        float off = .3 + posSin(t * 4.);\n        vec3 c = vec3(cos(a) * off, h, sin(a) * off);\n        float d1 = sdSphere(p - c, r);//length(p - c) - .25;\n        if (d1 < d) {\n            mat = mod(i, 2.);\n        }\n        d = sMin(d1, d, .2 * posSin(t));\n    }\n    \n    return vec2(d, mat);\n}\n\nfloat map(vec3 p) {\n    return mapMat(p).x;\n}\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0., EPSILON);\n    vec3 normal = normalize(vec3(\n        map(pos + eps.yxx) - map(pos - eps.yxx),\n        map(pos + eps.xyx) - map(pos - eps.xyx),\n        map(pos + eps.xxy) - map(pos - eps.xxy)\n    ));\n    return normal;\n}\n\nvec2 castRayMat(vec3 ro, vec3 rd) {\n    float td = 0.;\n    float mat;\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 pos = ro + td * rd;\n        vec2 h = mapMat(pos);\n        mat = h.y;\n        if (h.x < EPSILON) break;\n        td += h.x;\n        if (td > MAX_DIST) break;\n    }\n    if (td > MAX_DIST ) td = -1.;\n    return vec2(td, mat);\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n    return castRayMat(ro, rd).x;\n}\n\nvec3 scenePixelColor(vec3 ro, vec3 rd) {\n    vec3 col = vec3(.3, .75, 1.) - .7 * rd.y;\n    col = mix(col, vec3(.7, .75, .8), exp(-10. * rd.y));\n    \n    vec2 ray = castRayMat(ro, rd);\n    float td = ray.x;\n    \n    float t = PI + iTime * .1;\n    \n    if (td > EPSILON) {\n\t\tvec3 pos = ro + td * rd;\n        vec3 n = normal(pos);\n        \n        vec3 mate;\n        if (ray.y < -.5) {\n            mate = vec3(.2);\n        } else if (ray.y < .5) {\n            mate = vec3(.1, .3, .9);\n        \t//mate = vec3(.4, .1, mod(ray.y, 4.));\n        } else if (ray.y < 1.5) {\n        \tmate = vec3(.9, .3, .1);\n        }\n        \n        vec3 sunPos = normalize(vec3(.8 * sin(t) * 2., .4 - posSin(t) * .25, .2 + cos(t)));\n        \n        float sunDiff = clamp(dot(n, sunPos), .0, 1.);\n        float sunSha = step(castRay(pos + n * EPSILON, sunPos), .0);\n        float skyDiff = clamp(.5 + .5 * dot(n, vec3(0, 1, 0)), 0., 1.);\n        float bouDiff = clamp(.5 + .5 * dot(n, vec3(0, -1, 0)), 0., 1.);\n        \n        col = mate * vec3(7, 4.5, 3) * sunDiff * sunSha;\n        col += mate * vec3(.5, .8, .9) * skyDiff;\n        col += mate * vec3(.7, .3, .2) * bouDiff;\n    }\n    \n    col = pow(col, vec3(0.4545));\n    //col += ray.y;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float t = PI * 1.25 + iTime * .29;\n    //t = PI * .25;\n    \n    float a = t;//mouse.x * 10.;\n    float r = 8.;//4. + posSin(t) * 2.;//2. + mouse.y * 10.;\n    float h = 2.;//.5 + posSin(t) * 2.;\n    \n    vec3 ro0 = vec3(0., .1, .001);\n    //ro0 = vec3(r * sin(a), h, .001 + r * cos(a));\n    vec3 ro1 = vec3(0, 2.5, 10.);\n    vec3 ro = mix(ro0, ro1, posSin(t));\n    \n    // Camera\n    vec3 la0 = vec3(0., 8., 0.);\n    vec3 la1 = vec3(0, 2.25, 0);\n    vec3 la = mix(la0, la1, posSin(t));\n    vec3 cf = normalize(la - ro);\n    vec3 cr = normalize(cross(cf, vec3(0, 1, 0)));\n    vec3 cu = normalize(cross(cr, cf));\n    \n    vec3 rd = normalize(uv.x * cr + uv.y * cu + 1.5 * cf);\n\n    vec3 col = scenePixelColor(ro, rd);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 319, 342, 342, 373], [374, 374, 397, 397, 428], [430, 430, 471, 471, 572], [574, 574, 614, 614, 642], [644, 644, 677, 677, 705], [707, 707, 728, 728, 1360], [1362, 1362, 1381, 1381, 1407], [1409, 1409, 1432, 1432, 1675], [1677, 1677, 1712, 1712, 2024], [2026, 2026, 2059, 2059, 2094], [2096, 2096, 2136, 2136, 3336], [3338, 3338, 3395, 3395, 4259]], "test": "untested"}
{"id": "3tffDH", "name": "CGA Webcam", "author": "nightfox", "description": "An MS-DOS CGA palette webcam filter", "tags": ["retro", "webcam", "cga", "dos"], "likes": 2, "viewed": 628, "published": 3, "date": "1596552571", "time_retrieved": "2024-07-30T20:52:33.533413", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 cam = texture(iChannel0, uv).rgb;\n    \n    cam *= 1.5;\n    \n    vec3 cga[4];\n    \n    cga[0] = vec3(0.);\n    cga[1] = vec3(1.);\n    cga[2] = vec3(0.,1.,1.);\n    cga[3] = vec3(1.,0.,1.);\n    \n    vec3 closestColor = cga[0];\n    float closestDistance = distance(cam, cga[0]);\n    for (int i = 0; i <= 3; i++) {\n        float currentDistance = distance(cam, cga[i]);\n        if (currentDistance < closestDistance) {\n        \tclosestDistance = currentDistance;\n            closestColor = cga[i];\n        }\n    }\n    \n    cam = closestColor;\n\n    // Output to screen\n    fragColor = vec4(cam,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tffDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 756]], "test": "untested"}
{"id": "ttcSWN", "name": "asciiviisiion", "author": "ufffd", "description": "ascii vision", "tags": ["ascii"], "likes": 0, "viewed": 177, "published": 3, "date": "1596551910", "time_retrieved": "2024-07-30T20:52:34.430016", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 charsheet_res = vec2(16.,16.);\n    float charsheet_num = charsheet_res.x * charsheet_res.y;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // downsample\n    vec2 sample_uv = uv;\n    sample_uv *= charsheet_res;\n    sample_uv = floor(sample_uv);\n    sample_uv /= charsheet_res;\n\tvec3 col = texture(iChannel1,sample_uv).rbb;\n    // map color to character\n    float brightness = (col.r + col.g + col.b) / 3.;\n    float ascii = floor(brightness * charsheet_num);\n    vec2 ascii_pos = vec2(\n\t\tfloor(ascii / charsheet_res.x),\n        mod(ascii, charsheet_res.x)\n    );\n    // map screen uv to ascii uv\n    vec2 sub_uv = mod(uv * charsheet_res, 1.);\n    vec2 ascii_uv = sub_uv + ascii_pos;\n    ascii_uv /= charsheet_res;\n    vec3 ascii_col = texture(iChannel0,ascii_uv).rgb;\n    ascii_col = vec3(1.-step(ascii_col.r,0.5));\n    // fragColor = vec4(ascii_col,1.);return;\n    // pixel color\n    ascii_col *= texture(iChannel1,sample_uv).rgb;\n    col = ascii_col;\n    \n    \n    // mix original video back in\n    vec3 input_col = texture(iChannel1,uv).rgb;\n    input_col.g = clamp(input_col.g,0.,input_col.r+input_col.b);\n    col = mix(input_col,col,0.8);\n    // Output to screen\n    \n    // col = vec3(ascii / 256.); // show character code per square\n    // col = texture(iChannel0,uv).rgb; // show character sheet\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1449]], "test": "untested"}
{"id": "WtsfzM", "name": "Extruded Offset Triangle Grid", "author": "Shane", "description": "An extruded grid of packed rounded irregular triangles.", "tags": ["raymarching", "grid", "triangle", "skew", "extrude", "incircle"], "likes": 34, "viewed": 766, "published": 3, "date": "1596551774", "time_retrieved": "2024-07-30T20:52:35.391445", "image_code": "/*\n\n    Extruded Offset Triangle Grid\n    -----------------------------\n\n    This is an extruded grid of packed rounded irregular triangles. The triangles\n\tare rendered using some common and not so common triangle geometry.\n\n\tI've been meaning to post an extruded triangle grid for some time, but I keep\n    getting side tracked with other things -- Better late than never, I guess.\n\tThe lack of examples pretty much everywhere tells me that people enjoy coding \n    up extruded triangles about as much as I do. :D In fact, I couldn't even track \n\tdown an irregular packed extruded triangle still image anywhere, let alone code, \n    but I'm sure it's out there. Either way, there's now a reference on Shadertoy, \n    and I've tried to make the process as painless as possible.\n\n\tIn theory, rendering an extruded triangle grid is pretty simple: Render a\n\tregular square block grid, then chop each square block along the diagonal to\n\tproduce triangles. However, in order to avoid artifacts, neighbors need to be \n    considered, which means four block renders per pass, or eight extruded triangles.\n    On top of that, the aforementioned will only produce right angled isosceles \n    triangles, whereas most people will want nice regular equilateral ones. In order \n    to produce those, the rectangles need to be skewed (leant over to the right, in \n    this case) prior to subdivsion.\n\t\n\tLike most regular people, I don't enjoy implementing the skewing and unskewing\n\tprocess. I mean, I can do it, but I don't enjoy it. :) With that in mind, I \n    went to the trouble to clearly outline the process, so hopefully, it'll be easier \n    for anyone else who needs to do it.\n    \n    Anyway, the code's below. A lot of it is window dressing, so for anyone who\n\twould like to construct one of these, just look at the \"map\" function. For \n\tanyone who was wondering, an offset rounded quadrilateral grid is possible using \n    a subset of this setup, and I have one ready to go.\n\n    By the way, the comments are rushed, but I'll tidy them up in due course, and\n\tin case it isn't obvious, the example is a little GPU intensive, so I'll attempt\n\tto mitigate that as well. The most obvious thing I could do is bake the 2D\n\tface information into a buffer texture, then read from that, but for the purpose \n    of readability, I wanted to avoid that.\n\n\n*/\n\n\n\n// Offsetting the triangle coordinates. The look is a lot cleaner without it.\n#define OFFSET_TRIS\n\n// Skew the grid: In this case, we're just leaning the rectangles over to the \n// right a bit prior to the diagonal subdivision. I'm not sure who first noticed\n// that it was a better way to create triangle grids, but I'm glad they did.\n// Without skewing, you'll have subdivided right angled squares, which is fine,\n// if that's the look you're going for.\n#define SKEW_GRID\n\n// Just the flat plane.\n//#define FLAT_GRID\n\n\n// Max ray distance.\n#define FAR 20.\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// IQ's vec2 to float hash.\nvec2 hash22B(vec2 p){ \n    \n    // Faster.\n    return texture(iChannel1, p/1.13).xy*2. - 1.;\n    \n    /*\n    // Looks nicer, and more distributed, but slower, unfortunately.\n    p = vec2(dot(p, vec2(27.609, 113.583)), dot(p, vec2(57.527, 85.491)));\n    p = fract(sin(p)*43758.5453)*2. - 1.; \n    return p;\n    \n    // Animated.\n    return sin(p*6.2831853 + iTime);//mix(p, sin(p*6.2831853 + iTime), .35);\n    */\n}\n\n/*\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n    \n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + iTime); \n    \n}\n*/\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(in vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    //p = p/2. + .5;\n    //p = (floor(p*1024.) + .5)/1024.;\n    vec3 tx = texture(iChannel0, p/2.).xyz;\n    //vec3 tx = textureLod(iChannel0, p, 0.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n \n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n/*\n// IQ's distance to a regular polygon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define N 3\n//\nfloat sdPoly(in vec2 p, in vec2[N] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n*/\n\n// Rounded triangle routine.\nfloat sdTriR(vec2 p, vec2 v0, vec2 v1, vec2 v2, vec3 inC){\n    float ndg = .016/inC.z;\n    return sdTri(p, v0 - (v0 - inC.xy)*ndg,  v1 - (v1 - inC.xy)*ndg,  v2 - (v2 - inC.xy)*ndg) - .012;      \n        \n}  \n\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n\n// Triangle's incenter and radius.\nvec3 inCentRad(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    vec2 inCir = (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);   \n    \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return vec3(inCir, area/p);\n}\n\n/*\n// From the the following example:\n// Random Delaunay Triangulation - Tomkh\n// https://www.shadertoy.com/view/4sKyRD\n//\n// Use \"parabolic lifting\" method to calculate if two triangles are about to flip.\n// This is actually more reliable than circumscribed circle method.\n// The technique is based on duality between Delaunay Triangulation\n// and Convex Hull, where DT is just a boundary of convex hull\n// of projected seeds onto paraboloid.\n// We project (h1 h2 h3) triangle onto paraboloid\n// and return the distance of the origin\n// to a plane crossing projected triangle.\nfloat flipDistance(vec2 h1, vec2 h2, vec2 h3)\n{\n   // Projects triangle on paraboloid.\n   vec3 g1 = vec3(h1, dot(h1, h1));\n   vec3 g2 = vec3(h2, dot(h2, h2));\n   vec3 g3 = vec3(h3, dot(h3, h3));\n   // Return signed distance of (g1, g2, g3) plane to the origin.\n   //#if FLIP_ANIMATION\n    // return dot(g1, normalize(cross(g3-g1, g2-g1)));\n   //#else\n     // If we don't do animation, we are only interested in a sign,\n     // so normalization is unnecessary.\n   \t return dot(g1, cross(g3-g1, g2-g1));\n   //#endif\n}\n*/\n\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){\n    \n    //float idm = 1. - s.x*s.y;\n    //if(idm == 0.) idm += 1e-6;\n    //mat2 inM = 1./(idm)*mat2(1, s.y, s.x, 1);\n    //return inM*p;\n    return inverse(mat2(1, -s.y, -s.x, 1))*p;\n}\n\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n \n// Global vertices and local coordinates of the triangle cell.\n// It's lazy putting them here, but I'll tidy them up later.\nvec2[3] gV;\nvec2 gP;\n\n\nvec4 blocks(vec3 q){\n\n    \n    // Scale.\n    #ifdef SKEW_GRID\n\tconst vec2 scale = vec2(1./.8660254, 1)*vec2(1./6.);\n    #else\n    // Roughly the same area as the above cell, but it can be anything\n    // you want, and it doesn't have to be square either.\n    const vec2 scale = vec2(.18); \n    #endif\n\n    // Block dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = scale;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n    \n    #ifdef SKEW_GRID\n    // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(.5/.8660254, 0);//;\n    #else\n    const vec2 sk = vec2(0);\n    #endif\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates, center and overall cell ID.\n    vec2 p, ip, cntr, id = vec2(0);\n\n    \n    // Four block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    \n    float triID = 0.; // Triangle ID. Not used in this example, but helpful.\n    \n \n    // Height scale.\n    #ifdef FLAT_GRID\n    const float hs = 0.;\n    #else\n    const float hs = .25;\n    #endif\n\n    // Initializing the global vertices and local coordinates of the triangle cell.\n    gV = vec2[3](vec2(0), vec2(0), vec2(0));\n    gP = p;\n    \n    for(int i = 0; i<4; i++){\n\n        // Here's how you apply skewing to four neighboring blocks. There's a specific\n        // order, which would become apparent if you were to code this from scratch. \n        // You could check, if you wanted, or just take my word for it... On a side note,\n        // I make way too many mistakes, so you should never take my word for it. :D\n        \n        // Block center.\n        cntr = ps4[i]/2. - ps4[0]/2.;\n        \n        // Skewed local coordinates.\n        p = skewXY(q.xy, sk);\n        \n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Skewed rectangle vertices. \n        vec2[4] vert = ps4;  \n     \n        #ifdef OFFSET_TRIS\n        // Offsetting the vertices. Note that accuracy is important here. I had a bug for\n        // a while because I was premultiplying by \"s,\" to save some calculations, which meant\n        // points were not quite meeting at the joins... I won't bore you with the rest,\n        // except to say that it's necessary to keep these numbers simple.\n        vert[0] += hash22B((idi + vert[0]/2.))*.25;\n   \t\tvert[1] += hash22B((idi + vert[1]/2.))*.25;\n        vert[2] += hash22B((idi + vert[2]/2.))*.25; \n        vert[3] += hash22B((idi + vert[3]/2.))*.25;\n        #endif\n       \n        // Unskewing to enable rendering back in normal space.\n        vert[0] = unskewXY(vert[0]*dim, sk);\n        vert[1] = unskewXY(vert[1]*dim, sk);\n        vert[2] = unskewXY(vert[2]*dim, sk);\n        vert[3] = unskewXY(vert[3]*dim, sk); \n        \n        // Unskewing the rectangular cell ID.\n\t    idi = unskewXY(idi*s, sk); \n      \n          \n        // Mid edge points. Not used here.   \n        //vec2[4] mid = vec2[4](mix(vert[0], vert[1], .5), mix(vert[1], vert[2], .5),\n                              //mix(vert[2], vert[3], .5), mix(vert[3], vert[0], .5));  \n \n        \n        \n        // Some triangle flipping to ensure a Delaunay triangulation... Further non-Delaunay\n        // subdivisions will occur, so it's probably redundant, but it's here for completeness.\n        //float f = flipDistance(vert[0] - vert[2], vert[1] - vert[2], vert[3] - vert[2])<0.? 1. : -1.;\n \n        \n        // Partioning the rectangle into two triangles.\n        \n        // Triangle one.\n        vec2[3] v1 = vec2[3](vert[0], vert[1], vert[2]); \n        //if(f>.5) v1 = vec2[3](vert[0], vert[1], vert[3]); // Delaunay flipping.\n        \n        // Incircle position and radius.\n        vec3 inC = inCentRad(v1[0], v1[1], v1[2]);\n        \n        //float face1 = sdPoly(p, v1); \n        float face1 = sdTriR(p, v1[0], v1[1], v1[2], inC);\n        //float face1 = length(p - inC.xy) - inC.z;\n        //vec2 offs = (v1[0] + v1[1] + v1[2])/3.;\n        vec2 offs = inC.xy;\n        vec2 idi1 = idi + offs;\n        float h1 = hm(idi1);\n        //h1 = floor(h1*15.999)/15.; // Or just, \"h1 *= .15,\" for nondiscreet heights.\n        h1 *= hs;\n        float face1Ext = opExtrusion(face1 + .0*scale.x, (q.z + h1), h1); \n        //float cyl1 = opExtrusion(length(p - inC.xy) - .015, (q.z + h1 + .015), h1 + .015);\n         \n        // Triangle two.\n        vec2[3] v2 = vec2[3](vert[0], vert[2], vert[3]);\n        //if(f>.5) v2 = vec2[3](vert[1], vert[2], vert[3]);  // Delaunay flipping.\n       \n\n        inC = inCentRad(v2[0], v2[1], v2[2]);\n        //float face2 = sdPoly(p, v2);\n        float face2 = sdTriR(p, v2[0], v2[1], v2[2], inC);\n        //float face2 = length(p - inC.xy) - inC.z;\n        //offs = (v2[0] + v2[1] + v2[2])/3.;\n        offs = inC.xy;\n        vec2 idi2 = idi + offs;\n        float h2 = hm(idi2);\n        //h2 = floor(h2*15.999)/15.; // Or just, \"h1 *= .15,\" for nondiscreet heights.\n        h2 *= hs;\n        float face2Ext = opExtrusion(face2 + .0*scale.x, (q.z + h2), h2); \n        //float cyl2 = opExtrusion(length(p - inC.xy) - .015, (q.z + h2 + .015), h2 + .015);\n        \n        //face1Ext += max(face1, -.02);\n        //face2Ext += max(face2, -.02);\n        face1Ext += face1*.2;\n        face2Ext += face2*.2;\n        \n        //face1Ext = min(face1Ext, cyl1);\n        //face2Ext = min(face2Ext, cyl2);\n        \n        // Obtain the smallest triangle information.\n        vec4 di = face1Ext<face2Ext? vec4(face1Ext, idi1, h1) : vec4(face2Ext, idi2, h2);\n   \n        \n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di.x<d){\n            \n            d = di.x; // Minimum distance.\n            id = di.yz; // Position-based triangle ID.\n            triID = di.w; // Triangle ID. Not used here, but useful.\n       \n            // Setting the vertices and local coordinates.\n            // Hacked in at the last minute.\n            gV = v2; if(face1Ext<face2Ext) gV = v1;\n            gP = p;\n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, triID);\n}\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded blocks.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .0;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n    \n    //d4.x = -p.z + d4.x*.5;\n \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(1. + t*.125) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        // Hacky, but not all distance fields play nice. :)\n        t += i<40? d*.5 : d*.75; \n        //t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by forcing a break...\n    // Not sure if it works or not.\n    float sgn = 1.;\n    vec3 n = vec3(0);\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 6.;\n    p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*c*c*c, c*c, c); // Bluish tinge.\n    \n    return mix(p.zxy, p, n3D2*.34 + .665).yxz; // Mixing in a bit of purple.\n\n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, iTime*1.*.5, -1.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, .1, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(1.5, 3, -1.5);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime/8. - cos(iTime/12.))/2. );\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec3 svGID = gID;\n    \n    // Object ID.\n    float svObjID = objID;\n    \n    // Saved local triangle face coordinates and vertices.\n    vec2 svP = gP;\n    vec2[3] svV = gV;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Coloring the individual blocks with the saved ID.\n            \n            // Tri-planar texture coloring.\n            vec3 tx = tex3D(iChannel0, sp/1., sn);\n            // Solid coloring for each block.\n            vec3 tx2 = getTex(svGID.xy);\n            \n            // Triangle color.\n            texCol = mix(tx, tx2, 1.5);\n            \n              \n            //texCol = .55 + .45*cos(6.2831*hash21(svGID.xy)/2. + vec3(0, 1, 2));\n       \n            // Black dots at the incircle position on the triangle face.\n            //texCol = mix(texCol, vec3(0), \n            //\t\t\t\t1. - smoothstep(0., .005, length(sp.xy - svGID.xy) - .0086));\n \n            \n            // Rendering a dark ring around the face edges.\n            vec3 inC = inCentRad(svV[0], svV[1], svV[2]);\n            float tri = sdTriR(svP, svV[0], svV[1], svV[2], inC);\n            float tri2 = tri;\n            tri = max(abs(tri) - .001, abs(sp.z + svGID.z*2.));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, tri));\n            //texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, tri + .005));\n            \n            // Light lines from the incircle center to the vertices for emphasis.\n            const float ew = .001;\n            float ln = 1e5;\n            ln = min(ln, lBox(svP, inC.xy, svV[0], ew));\n            ln = min(ln, lBox(svP, inC.xy, svV[1], ew));\n            ln = min(ln, lBox(svP, inC.xy, svV[2], ew));\n            texCol = mix(texCol, min(texCol*1.66, 1.), (1. - smoothstep(0., .005, ln)));\n             \n            // Other markings.\n            //float pat = abs(fract(tri2*50.) - .5)*2. - .25;\n            //texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .005, max(tri2, pat)))*.7);\n            //texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, tri2 + inC.z - .01));\n            //texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, abs(tri2 + .015) - .001));\n\n \n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1.25/(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff = pow(diff, 2.)*1.35; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff + ao*.35 + vec3(.2, .4, 1)*fre + vec3(1, .4, .2)*spec*4.);\n        \n        vec3 cTex = envMap(reflect(rd, sn));//texture(iChannel2, reflect(rd, sn)).xyz; cTex *= cTex;\n        \n        col += col*cTex*5.;\n\n        // Shading.\n        col *= ao*sh*atten;\n        \n          \n\t\n\t}\n    \n/*    \n    // Just the 2D rendering.\n    uv = fragCoord/iResolution.y;\n    vec4 d = blocks(vec3(uv + iTime/32., 0.));\n    vec3 inC = inCentRad(gV[0],  gV[1],  gV[2]); \n    vec3 oCol = smoothstep(0., .5, getTex(d.yz));\n    float triD = sdTriR(gP, gV[0],  gV[1],  gV[2], inC); \n    float sf = 1./iResolution.y;\n    col = mix(vec3(.1), vec3(0), 1. - smoothstep(0., sf, triD));\n    col = mix(col, oCol, 1. - smoothstep(0., sf, triD + .005));\n*/        \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2990, 3023, 3045, 3045, 3103], [3106, 3134, 3155, 3155, 3218], [3221, 3249, 3270, 3291, 3662], [4269, 4516, 4539, 4976, 5126], [5128, 5282, 5331, 5633, 6542], [6546, 6610, 6630, 6630, 6679], [6682, 6709, 6766, 6766, 7062], [7066, 7108, 7167, 7167, 7747], [8522, 8551, 8609, 8609, 8756], [8761, 8791, 8838, 8838, 8889], [8891, 8922, 8955, 8955, 9042], [9044, 9283, 9328, 9328, 9491], [9670, 9705, 9747, 9773, 10052], [11153, 11216, 11244, 11244, 11288], [11290, 11355, 11385, 11523, 11571], [18474, 18498, 18516, 18535, 18842], [18846, 18867, 18903, 18952, 19487], [20245, 20436, 20488, 20605, 21912], [21915, 22067, 22103, 22103, 22357], [22359, 22502, 22523, 22523, 22869], [22871, 23170, 23190, 23190, 23538]], "test": "untested"}
{"id": "3lfBDH", "name": "base0", "author": "pohy", "description": "base0", "tags": ["base"], "likes": 0, "viewed": 240, "published": 3, "date": "1596549021", "time_retrieved": "2024-07-30T20:52:36.437648", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 col = vec3(0);\n    \n    col.rg += uv;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 203]], "test": "untested"}
{"id": "WlsBWr", "name": "nice sin", "author": "curiouspers", "description": "nice sin?", "tags": ["sin"], "likes": 26, "viewed": 647, "published": 3, "date": "1596542501", "time_retrieved": "2024-07-30T20:52:37.302336", "image_code": "// Raymarching part from \"Sphere Gears - Step 1\" by iq. https://shadertoy.com/view/ws3GD2\n// 2020-08-03 19:04:37\n\n// Created by curiouspers 04/08/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// set AA 2 if you have beafy pc\n#define AA 2\n#define OPTIMIZE 1\n\n// not worth it, too different look\n#define SIMPLERAO 0\n#define ORTHOANIM 0\n\n// #define SDBOX( p, r ) (  length(max(abs(p)-r,0.)))\n\nfloat hash( in float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat sdBox( in vec3 p, in vec3 r )\n{\n    vec3 d = abs(p)-r;\n    return length(max(d,0.));\n}\nfloat displacement(in vec3 p, in float force){\n\treturn (sin(force*p.z*1.0)/2.) / force;\n}\n\nvec4 map( in vec3 p, float time )\n{\n    vec3 boxSize = vec3(0.03, 0.2, 0.4);\n    vec3 start = vec3(0.32,-0.1,0.0);\n    vec3 dif = vec3(0.08,0.0,-0.015);\n    float d = 0.1;\n    \n    p -= start;\n    \n    #if OPTIMIZE\n    // bounding box\n    float bbox = sdBox( p+vec3(0.495,-0.09,0.), vec3(0.54, 0.2, 0.65) );\n    if (bbox < 0.05){\n    #endif\n        \n    float t = iTime*1.75;\n    float an1 = smoothstep(0.0,1.0,(sin(t+10.26)*.5+.6));\n    an1 *= an1;\n    float an2 = smoothstep(0.0,1.0,(sin(t+0.6)*.5+.6));\n    an2 *= an2;\n    float an3 = smoothstep(0.0,1.0,(sin(t+42.745)*0.5+0.6));\n    an3 *= an3;\n    float an4 = smoothstep(0.0,1.0,(sin(t+0.345)*0.5+0.6));\n    an4 *= an4;\n    float an5 = smoothstep(0.0,1.0,(sin(t+142.745)*0.6+0.6));\n    an5 *= an5;\n    float an6 = smoothstep(0.0,1.0,(sin(t+2.135)*0.6+0.6));\n    an6 *= an6;\n    float an7 = smoothstep(0.0,1.0,(sin(t+3.956)*0.7+0.6));\n    an7 *= an7;\n    float an8 = smoothstep(0.0,1.0,(sin(t+1.3)*0.7+0.6));\n    an8 *= an8;\n    \n\t#if 0\n    p.z = p.z*(0.8*smoothstep(0.0,1.0,(sin(t/4.)*2.6+.0)));\n\t#else\n\tp.z = p.z*0.8;\n\t#endif\n    vec3 q = p;\n    \n\n    for(float i=0.01; i<13.; i+=1.){\n        q=p+dif*i;\n        \n        #if OPTIMIZE\n        float bbox = sdBox( q +vec3(0.,-0.1,0.), vec3(boxSize.x, boxSize.y*1.0, boxSize.z) );\n        //d = min(d, bbox);\n        if (bbox >= 0.064){\n            continue;\n        }\n        #endif\n        \n        float h = hash(i*i/3.);\n        float h2 = hash(h*i/3.);\n        float c2 = mod(i-0.01, 2.);\n        float c3 = mod(i-0.01, 3.);\n        float c4 = mod(i-0.01, 4.);\n        float c5 = mod(i-0.01, 5.);\n        float c6 = mod(i-0.01, 6.);\n        vec3 qd = q+vec3(0.,0.,0.1)*h;\n        \n        if (i<1.){\n            q.y += displacement(q, 40.)*0.8;\n            float dis = displacement(qd+vec3(0.,0.,1.), 30.)*1.0 ;\n            q.y += dis+dis*an1;\n            q.y += \t\tdisplacement(qd+vec3(0.,0.,0.2), 60.)*1.0 * an3;\n\t\t} else {\n            q.y += (displacement(qd+vec3(0.,0.,1.2*h2), 20.)*0.9) ;\n            q.y += (displacement(qd+vec3(0.,0.,1.1*h),  20.)*an4*1.0) * c2 ;\n            q.y += (displacement(qd+vec3(0.,0.,1.9*h2), 20.)*an5*0.5) * c3;\n            q.y += (displacement(qd+vec3(0.,0.,1.5*h),  30.)*an6*0.7) * c4;\n            q.y += (displacement(qd+vec3(0.,0.,6.2*h),  30.)*an7*0.4) * c5;\n            q.y += (displacement(qd+vec3(0.,0.,2.2*h),  40.)*an8*0.3) * c6;\n    \t}\n        q.y += smoothstep(0.9,1.1,abs(q.z+dif.z)/boxSize.z)/10.; // edges\n        float d2 = sdBox( q, boxSize);\n        d = min(d, d2);\n        \n        // if hit box in front - skip all next boxes\n        #if OPTIMIZE\n        if (d2<0.0135)\n            break;\n        #endif\n    }\n\t\n    #if OPTIMIZE\n    }\n    #endif\n\n    //d = min(bbox,d);\n    return vec4( d, p );\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    #if SIMPLERAO\n    int   a = 3;\n    float b = 1.;\n    #else\n    int   a = 5;\n    float b = 4.;\n    #endif\n    \n    for( int i=ZERO; i<a; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/b;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    float t = 1.9;\n    float tmax = 3.1;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec4 h = map(ro+t*rd,time)/2.;\t\t\t//hack\n        if( h.x<0.001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\n\t    // camera\t\n        float an = 1.0;// 6.2831*time/40.0;\n        vec3 ta = vec3( 0.0, 0.1, 0.0 )*1.9;\n    \tvec3 ro = vec3(1., 1.2, 2.);// ray origin (camera pos)\n    \t//ro = vec3(0., 1.2, 2.);// ray origin (camera pos)\n        //vec3 ro = ta + vec3( 0.5*cos(an), 0.2, 0.5*sin(an) );\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0. );\n        \n        // ray direction\n        float fl = 4.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n        \n    #if !ORTHOANIM\n    float f = 0.56;\n\t#else\n\tfloat f = iMouse.x/iResolution.x;\n    #endif\n        \n    vec3 rd_orth = setCamera(ro, ta, 0.)*normalize(vec3(0., 0., 1.0));// ray direction via orthographic projection\n    rd = mix(rd, rd_orth, f);\n\n    #if ORTHOANIM\n    float orthRectSize = .0 + 3.0*iMouse.y/iResolution.y;\n    vec3 ro_orth = ro + vec3(p * orthRectSize, 0.);// ray origin \n    ro = mix(ro, ro_orth, f);\n    #endif\n        \n\n        // background\n        vec3 bcol = vec3(0.01, 0.7, 1.0);\n        vec3 tcol = vec3(0.71, 0.35, 0.87)-0.25;\n        vec3 col = mix(bcol, tcol, p.y*.5+0.5 /*1.0+rd.y*/);//vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        \n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n            vec3 l = vec3(2.0,1.0,-1.);\n            float ndl = dot(nor,l)*.4+.6;\n            vec3 amb = col*.5;\n            float rim = (dot(rd,nor)*.5+.5);\n            rim = clamp(0.0,1.0,(pow(rim,1.)));\n            float invRim = 1.0-rim;\n            invRim*=invRim*invRim*invRim;\n                        \n            float y = tuvw.y;\n            y = y*y*8.5;\n            y += 2.0;\n            y /= 3.0;\n            tcol = vec3(0.823, 0.686, 0.992)*0.8;\n\t\t\tcol = mix(bcol, tcol, y);\n            \n            col = col*ndl+amb;\n            col *= col + sin(tuvw.yyy*3000.)*col*0.9*invRim * nor.y + rim;\n            \n    #if SIMPLERAO\n            float ao = calcAO( tuvw.yzw, nor, time )*1.5;\n            ao += 3.0*ao*(1.-nor.y); // top\n            float side = nor.x*(1.-ao)*.8;  // side\n            ao += side;\n            ao *= ao;\n            col = mix(col,col*ao/.9,0.6);\n    #else\n            float ao = calcAO( tuvw.yzw, nor, time )*1.2;\n            ao += 2.0*ao*(1.-nor.y); // top\n            ao += nor.x*(1.-ao)*.2;  // side\n            col = mix(col,col*ao/.9,0.6);\n    #endif\n            \n            // color correction\n            col *= 0.5;\n            col *= col + nor.y*0.4;\n            //col = vec3(ao);\n        }\n            \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // gamma        \n    tot = pow(tot,vec3(0.45) );\n    \n    // cheap dithering to remove banding\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    // show banding\n    #if 0\n    tot = floor(tot*255.)/255.;\n    tot = (abs(dFdy(tot))+abs(dFdx(tot)))*200.0;\n    #endif\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsBWr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[438, 438, 464, 464, 503], [505, 505, 542, 542, 597], [598, 598, 644, 644, 687], [3477, 3477, 3524, 3524, 3733], [3735, 3735, 3792, 3792, 4169], [4171, 4171, 4228, 4228, 4497], [4499, 4499, 4551, 4551, 4728]], "test": "untested"}
{"id": "wtsfDr", "name": "Soundshwop Blend Modes", "author": "ljdp", "description": "What happens when you apply photoshop blend modes to audio?", "tags": ["audio", "blend"], "likes": 0, "viewed": 352, "published": 3, "date": "1596517313", "time_retrieved": "2024-07-30T20:52:38.068288", "image_code": "// Edit of Photoshop Blend Modes by ridhojeftha https://www.shadertoy.com/view/4tSGWV\n// Why not photoshop blend audio?\n\n//Darken\nvec3 darken (vec3 target, vec3 blend){\n    \n return min (target, blend);   \n}\n\n//Multiply\nvec3 multiply (vec3 target, vec3 blend){\n    return target*blend;\n}\n\n//Color Burn\nvec3 colorBurn (vec3 target, vec3 blend){\n    return 1.0 - (1.0 - target)/ blend;\n}\n\n//Linear Burn\nvec3 linearBurn (vec3 target, vec3 blend){\n    return target + blend - 1.0;\n}\n\n//Lighten\nvec3 lighten (vec3 target, vec3 blend){\n    return max (target, blend);\n}\n\n//Screen\nvec3 screen (vec3 target, vec3 blend){\n    return 1.0 - (1.0 - target) * (1.0 - blend);\n}\n\n//Color Dodge\nvec3 colorDodge (vec3 target, vec3 blend){\n    return target / (1.0 - blend);\n}\n\n//Linear Dodge\nvec3 linearDodge (vec3 target, vec3 blend){\n    return target + blend;\n}\n\n//Overlay\nvec3 overlay (vec3 target, vec3 blend){\n    vec3 temp;\n    temp.x = (target.x > 0.5) ? (1.0-(1.0-2.0*(target.x-0.5))*(1.0-blend.x)) : (2.0*target.x)*blend.x;\n    temp.y = (target.y > 0.5) ? (1.0-(1.0-2.0*(target.y-0.5))*(1.0-blend.y)) : (2.0*target.y)*blend.y;\n    temp.z = (target.z > 0.5) ? (1.0-(1.0-2.0*(target.z-0.5))*(1.0-blend.z)) : (2.0*target.z)*blend.z;\n    return temp;\n}\n\n//Soft Light\nvec3 softLight (vec3 target, vec3 blend){\n vec3 temp;\n    temp.x = (blend.x > 0.5) ? (1.0-(1.0-target.x)*(1.0-(blend.x-0.5))) : (target.x * (blend.x + 0.5));\n    temp.y = (blend.y > 0.5) ? (1.0-(1.0-target.y)*(1.0-(blend.y-0.5))) : (target.y * (blend.y + 0.5));\n    temp.z = (blend.z > 0.5) ? (1.0-(1.0-target.z)*(1.0-(blend.z-0.5))) : (target.z * (blend.z + 0.5));\n    return temp;   \n}\n\n//Hard Light\nvec3 hardLight (vec3 target, vec3 blend){\n    vec3 temp;\n    temp.x = (blend.x > 0.5) ? (1.0-(1.0-target.x)*(1.0-2.0*(blend.x-0.5))) : (target.x * (2.0*blend.x));\n    temp.y = (blend.y > 0.5) ? (1.0-(1.0-target.y)*(1.0-2.0*(blend.y-0.5))) : (target.y * (2.0*blend.y));\n    temp.z = (blend.z > 0.5) ? (1.0-(1.0-target.z)*(1.0-2.0*(blend.z-0.5))) : (target.z * (2.0*blend.z));\n    return temp;\n}\n\n//Vivid Light\nvec3 vividLight (vec3 target, vec3 blend){\n     vec3 temp;\n    temp.x = (blend.x > 0.5) ? (1.0-(1.0-target.x)/(2.0*(blend.x-0.5))) : (target.x / (1.0-2.0*blend.x));\n    temp.y = (blend.y > 0.5) ? (1.0-(1.0-target.y)/(2.0*(blend.y-0.5))) : (target.y / (1.0-2.0*blend.y));\n    temp.z = (blend.z > 0.5) ? (1.0-(1.0-target.z)/(2.0*(blend.z-0.5))) : (target.z / (1.0-2.0*blend.z));\n    return temp;\n}\n\n//Linear Light\nvec3 linearLight (vec3 target, vec3 blend){\n    vec3 temp;\n    temp.x = (blend.x > 0.5) ? (target.x)+(2.0*(blend.x-0.5)) : (target.x +(2.0*blend.x-1.0));\n    temp.y = (blend.y > 0.5) ? (target.y)+(2.0*(blend.y-0.5)) : (target.y +(2.0*blend.y-1.0));\n    temp.z = (blend.z > 0.5) ? (target.z)+(2.0*(blend.z-0.5)) : (target.z +(2.0*blend.z-1.0));\n    return temp;\n}\n\n//Pin Light\nvec3 pinLight (vec3 target, vec3 blend){\n     vec3 temp;\n    temp.x = (blend.x > 0.5) ? (max (target.x, 2.0*(blend.x-0.5))) : (min(target.x, 2.0*blend.x));\n    temp.y = (blend.y > 0.5) ? (max (target.y, 2.0*(blend.y-0.5))) : (min(target.y, 2.0*blend.y));\n    temp.z = (blend.z > 0.5) ? (max (target.z, 2.0*(blend.z-0.5))) : (min(target.z, 2.0*blend.z));\n    return temp;\n}\n\n//Difference\nvec3 difference (vec3 target, vec3 blend){\n    return abs (target - blend);\n    \n}\n//Exclusion\nvec3 exclusion (vec3 target, vec3 blend){\n    return 0.5 - 2.0*(target-0.5)*(blend-0.5);\n}\n\n//Subtract (thanks to Brandondorf9999)\nvec3 subtract (vec3 target, vec3 blend){\n    return target - blend;\n}\n\nvec3 modulo (vec3 target, vec3 blend){\n return mod(target,blend);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = 0.04 / ceil(mod (iTime/2.0, 6.0));\n    vec3 upperTexture = vec3(sin(iTime+fragCoord.x*scale));\n    vec3 lowerTexture = vec3(\n        (sin(iTime+fragCoord.x*2.5025*scale)*0.75)\n        +(sin(iTime+fragCoord.x*7.501*scale)*0.25));\n    \n    int time = int (mod (iTime/2.0, 18.0));\n    \n    vec3 finalImage = vec3(0.0);\n    if (time==0) finalImage =  darken ( upperTexture,  lowerTexture\t);\n    else if (time==1) finalImage = multiply ( upperTexture,  lowerTexture);\n    else if (time==2) finalImage =colorBurn ( upperTexture,  lowerTexture);\n    else if (time==3) finalImage =linearBurn ( upperTexture,  lowerTexture);\n    else if (time==4) finalImage =lighten ( upperTexture,  lowerTexture);\n    else if (time==5) finalImage =screen ( upperTexture,  lowerTexture);\n    else if (time==6) finalImage =colorDodge ( upperTexture,  lowerTexture);\n    else if (time==7) finalImage =linearDodge (upperTexture,  lowerTexture);\n    else if (time==8) finalImage =overlay ( upperTexture,  lowerTexture);\n    else if (time==9) finalImage =softLight ( upperTexture,  lowerTexture);\n    else if (time==10) finalImage =hardLight ( upperTexture,  lowerTexture);\n    else if (time==11) finalImage =vividLight ( upperTexture,  lowerTexture);\n    else if (time==12) finalImage =linearLight ( upperTexture,  lowerTexture);\n    else if (time==13) finalImage =pinLight ( upperTexture,  lowerTexture);\n    else if (time==14) finalImage =difference ( upperTexture,  lowerTexture);\n    else if (time==15) finalImage =exclusion (upperTexture, lowerTexture);\n    else if (time==16) finalImage = subtract(upperTexture, lowerTexture);\n    else if (time== 17) finalImage = modulo(upperTexture, lowerTexture);\n    \n    //set the color\n    finalImage.g = (finalImage.g*finalImage.g);\n    finalImage.b = 1.0 - (finalImage.g*finalImage.b);\n    fragColor = vec4(floor(finalImage*8.0)/8.0, 1.0);\n}", "image_inputs": [], "sound_code": "//Darken\nfloat darken (float target, float blend){\n    \n return min (target, blend);   \n}\n\n//Multiply\nfloat multiply (float target, float blend){\n    return target*blend;\n}\n\n//Color Burn\nfloat colorBurn (float target, float blend){\n    return 1.0 - (1.0 - target)/ blend;\n}\n\n//Linear Burn\nfloat linearBurn (float target, float blend){\n    return target + blend - 1.0;\n}\n\n//Lighten\nfloat lighten (float target, float blend){\n    return max (target, blend);\n}\n\n//Screen\nfloat screen (float target, float blend){\n    return 1.0 - (1.0 - target) * (1.0 - blend);\n}\n\n//Color Dodge\nfloat colorDodge (float target, float blend){\n    return target / (1.0 - blend);\n}\n\n//Linear Dodge\nfloat linearDodge (float target, float blend){\n    return target + blend;\n}\n\n//Overlay\nfloat overlay (float target, float blend){\n    return (target > 0.5) ? (1.0-(1.0-2.0*(target-0.5))*(1.0-blend)) : (2.0*target)*blend;\n}\n\n//Soft Light\nfloat softLight (float target, float blend){\n    return (blend > 0.5) ? (1.0-(1.0-target)*(1.0-(blend-0.5))) : (target * (blend + 0.5));  \n}\n\n//Hard Light\nfloat hardLight (float target, float blend){\n    return (blend > 0.5) ? (1.0-(1.0-target)*(1.0-2.0*(blend-0.5))) : (target * (2.0*blend));\n}\n\n//Vivid Light\nfloat vividLight (float target, float blend){\n    return (blend > 0.5) ? (1.0-(1.0-target)/(2.0*(blend-0.5))) : (target / (1.0-2.0*blend));\n}\n\n//Linear Light\nfloat linearLight (float target, float blend){\n    return (blend > 0.5) ? (target)+(2.0*(blend-0.5)) : (target +(2.0*blend-1.0));\n}\n\n//Pin Light\nfloat pinLight (float target, float blend){\n    return (blend > 0.5) ? (max (target, 2.0*(blend-0.5))) : (min(target, 2.0*blend));\n}\n\n//Difference\nfloat difference (float target, float blend){\n    return abs (target - blend);\n    \n}\n//Exclusion\nfloat exclusion (float target, float blend){\n    return 0.5 - 2.0*(target-0.5)*(blend-0.5);\n}\n\n//Subtract (thanks to Brandondorf9999)\nfloat subtract (float target, float blend){\n    return target - blend;\n}\n\n//Divide (thanks to Brandondorf9999)\nfloat divide (float target, float blend){\n return target/blend;   \n}\n\nfloat modulo (float target, float blend){\n return mod(target,blend);   \n}\n\nvec2 mainSound( in int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    float osc1 = sin(6.2831*420.0*time);\n    float osc2 = sin(6.2831*420.0*2.5025*time) * 0.75;\n    osc2 += sin(6.2831*220.0*7.601*time) * 0.25;\n    float finalImage;\n    int func = int (mod (time/2.0, 18.0));\n    //func = 1;\n    if (func==0) finalImage =  darken ( osc1,  osc2\t);\n    else if (func==1) finalImage = multiply ( osc1,  osc2);\n    else if (func==2) finalImage =colorBurn ( osc1,  osc2)*0.25;\n    else if (func==3) finalImage =linearBurn ( osc1,  osc2);\n    else if (func==4) finalImage =lighten ( osc1,  osc2);\n    else if (func==5) finalImage =screen ( osc1,  osc2);\n    else if (func==6) finalImage =colorDodge ( osc1,  osc2);\n    else if (func==7) finalImage =linearDodge (osc1,  osc2);\n    else if (func==8) finalImage =overlay ( osc1,  osc2);\n    else if (func==9) finalImage =softLight ( osc1,  osc2);\n    else if (func==10) finalImage =hardLight ( osc1,  osc2);\n    else if (func==11) finalImage =vividLight ( osc1,  osc2);\n    else if (func==12) finalImage =linearLight ( osc1,  osc2);\n    else if (func==13) finalImage =pinLight ( osc1,  osc2);\n    else if (func==14) finalImage =difference ( osc1,  osc2);\n    else if (func==15) finalImage =exclusion (osc1, osc2);\n    else if (func==16) finalImage =subtract (osc1, osc2);\n    else if (func==17) finalImage =modulo (osc1, osc2);\n        \n    return vec2( (floor(finalImage*8.0)/8.0) * 0.25 );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsfDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 130, 168, 168, 207], [209, 220, 260, 260, 287], [289, 302, 343, 343, 385], [387, 401, 443, 443, 478], [480, 490, 529, 529, 563], [565, 574, 612, 612, 663], [665, 679, 721, 721, 758], [760, 775, 818, 818, 847], [849, 859, 898, 898, 1241], [1243, 1256, 1297, 1297, 1643], [1645, 1658, 1699, 1699, 2051], [2053, 2067, 2109, 2109, 2462], [2464, 2479, 2522, 2522, 2841], [2843, 2855, 2895, 2895, 3227], [3229, 3242, 3284, 3284, 3324], [3325, 3337, 3378, 3378, 3427], [3429, 3468, 3508, 3508, 3537], [3539, 3539, 3577, 3577, 3609], [3611, 3611, 3668, 3668, 5588]], "test": "untested"}
{"id": "3tffRN", "name": "joes raytracer / pathtracer", "author": "copperbotte", "description": "simple raytracer, uses importance sampling with four different sampling methods.\n\nnow with multiple importance sampling!\n\nClick to reset the accumulation buffer.", "tags": ["raytracing"], "likes": 2, "viewed": 476, "published": 3, "date": "1596492314", "time_retrieved": "2024-07-30T20:52:39.365819", "image_code": "\n//include common\n\nvec3 saturationClip(vec3 rgb)\n{\n    vec3 hsv = rgb2hsv(rgb);\n    \n    if(1.0 < hsv.z)\n        hsv.yz /= hsv.z;\n    \n    return hsv2rgb(hsv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    \n    //saturation projection\n    col = saturationClip(col);\n    \n    //convert color space from lsrgb to srgb\n    col = lsrgb2srgb(col);\n    \n\t//output image\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Changelog, since the description has a character limit.\n// TODO: Fill changelog with old \"commits\"\n// 9/14/2020 - Added simple, non PBR fog\n// 1/16/2021 - Fixed MIS\n// 1/25/2021 - Corrected light sampler, no more brightness issues\n// 2/24/2021 - Reworked fog sampling\n\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n//another random number generator\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat hashrandom( float x )\n{\n    return floatConstruct(hash(floatBitsToUint(x)));\n}\n\n///////////////////\n// Scene Structs //\n///////////////////\n\nstruct Material\n{\n    vec3 emission;\n    vec3 albedo;\n    vec3 reflectivity;\n    float power; // vec3 requires 1 sample per color\n};\n\n//sky + fog + 2 planes + 11 spheres + triangle // + bunny\nconst int MatNum = 1 + 1 + 2 + 11 + 1;//5 + 10 + 1;\nMaterial Materials[MatNum];\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n} Spheres[2 + 9];\n\nstruct Plane\n{\n    vec3 normal;\n    float offset;\n} Planes[2];\n\nstruct Tri\n{\n    Plane plane; // metadata\n    vec3 vertex[3];\n} Tris[1];\n\n\nconst int iFrameStart = 0;\n\n//to World\nvec3 toWorld(vec3 dir, vec3 normOut)\n{\n    //todo: do this properly using quaternions\n    vec3 normDir = vec3(0,0,1);\n    \n    float epsilon = 1.0 - 1e-5;\n    if(epsilon < dot(normDir, normOut))\n        return dir;\n        \n    if(dot(normDir, normOut) < -epsilon)\n        return -dir;\n    \n    //make a pair of bases that are orthogonal to the output normal\n    vec3 a = cross(normDir, normOut);\n    a = normalize(a);\n    \n    vec3 b = cross(a, normOut);\n    b = normalize(b);\n    \n    mat3 M = mat3(a, b, normOut);\n    \n    return normalize(M * dir);\n}\n\n//random point in lat/long coords (naiive implementation)\nvec3 randMercator(out float pdf)\n{\n    float xi1 = rnd();\n    float xi2 = rnd();\n\t\n    float psi = xi1 * 3.141592;\n    float theta = xi2 * 2.0 * 3.141592;\n    \n    float x = sin(psi) * cos(theta);\n    float y = sin(psi) * sin(theta);\n    float z = cos(psi);\n\n    pdf = sin(psi);\n    \n    return vec3(x, y, z);\n}\n\n//random point in sphere\nvec3 randSphere()\n{\n    float xi1 = rnd() * 2.0 - 1.0;\n    float xi2 = rnd();\n\n    float theta = xi2 * 2.0 * 3.141592;\n    float sinp = sqrt(1.0 - xi1*xi1);\n\n    float x = sinp * cos(theta);\n    float y = sinp * sin(theta);\n    float z = xi1;\n\n    return vec3(x, y, z);\n}\n\nvec3 randLambert(vec3 normal)\n{\n    float xi1 = rnd();\n    float xi2 = rnd();\n\n    float theta = xi2 * 2.0 * 3.141592;\n    float cosp = sqrt(xi1);\n    float sinp = sqrt(1.0 - cosp*cosp);\n\n    float x = sinp * cos(theta);\n    float y = sinp * sin(theta);\n    float z = cosp;\n\n    return toWorld(vec3(x, y, z), normal);\n}\n\n//general case of randLambert\nvec3 randPhongSpec(vec3 normal, vec3 rIn, float power)\n{\n    vec3 refl = reflect(rIn, normal);\n    \n    float xi1 = rnd();\n    float xi2 = rnd();\n    \n    float theta = xi2 * 2.0 * 3.141592;\n    float cosp = pow(xi1, 1.0/power);\n    float sinp = sqrt(1.0 - cosp*cosp);\n\n    float x = sinp * cos(theta);\n    float y = sinp * sin(theta);\n    float z = cosp;\n\n    return toWorld(vec3(x, y, z), refl);\n}\n\nvec3 randScatterGeometric(vec3 rIn)\n{\n    /*\n    //fires a ray within a disc toward a sphere\n    //aligns output ray to input direction\n    \n    //\"normal\" is +z\n    \n    vec3 rSrc = vec3(0,0,1);\n    \n    vec3 norm = randLambert(rSrc); // i can't believe this popped out of the math!\n    \n    vec3 refl = reflect(-rSrc, norm);\n    */\n    \n    //direct formulation\n    float xi1 = rnd();\n    float xi2 = rnd();\n    \n    float theta = 2.0 * 3.141592 * xi1;\n    float phi = pow(xi2, 1.0 / 3.0); //cube root\n    phi = 2.0 * asin(phi);\n    \n    float sinp = sin(phi);\n    float cosp = cos(phi);\n    \n    float x = sinp * cos(theta);\n    float y = sinp * sin(theta);\n    float z = cosp;\n    \n\treturn toWorld(vec3(x,y,z), rIn);\n}\n\nvec2 randTri()\n{\n    //very simple, random triangle in a half unit square.\n    float xi1 = rnd();\n    float xi2 = rnd();\n    \n    float a = sqrt(xi1);\n    \n    return vec2(1.0-a, a*xi2);\n}\n\nstruct Ray\n{\n\tvec3 src;\n    vec3 dir;\n};\n    \nstruct tvHit\n{\n\tRay ray;\n    vec3 normal;\n    int id;\n    float rayDist;\n    float errRtrn; // debug\n};\n\nvoid tvSphere(Ray rIn, vec3 normIn, out tvHit hit, inout float rayDist, int id, float sRad, vec3 sPos)\n{\n    //*\n    //use the closer solution if ray is outside sphere, farther if inside\n    vec3 sDelta = sPos - rIn.src; // delta\n    float sDelta2 = dot(sDelta, sDelta);\n    \n    float sRayClosest = dot(sDelta, rIn.dir); // x\n    float sRad2 = sRad * sRad;\n    \n    //check if ray is outside\n    bool above = sRad2 <= sDelta2; // true if outside\n    bool facing = 0.0 <= sRayClosest;\n    \n    //catch if ray is on surface, and facing surface\n    const float epsilon = 1e-4; // 1e-4 is really high for an epsilon\n    if(abs(sRad2 - sDelta2) < epsilon)\n    {\n        if(dot(normIn, rIn.dir) < 0.0) // if ray points away from the surface it came from\n            return;\n        //adjust which side the ray lies on\n        above = dot(normIn, sDelta) < 0.0;\n        //facing = !above; // redundant?\n    }\n    \n    //catch if ray faces away, and is outside\n    if(above && !facing)\n        return;\n    \n    //ray can miss if r^2 < s^2\n    //find s\n    float sRayClosest2 = sRayClosest * sRayClosest;\n    float s2 = sDelta2 - sRayClosest2;\n    \n    //catch if r^2 < s^2, ray misses sphere\n    if(sRad2 < s2) // check for outside?\n        return;\n    \n    //ray should always hit\n    //find offset\n    float offset = sqrt(sRad2 - s2);\n    if(above) // use closer solution\n        offset = -offset;\n    \n    float rDist = sRayClosest + offset;\n    if(rDist < rayDist && 0.0 <= rDist)\n    {\n        hit.rayDist = rayDist = rDist;\n        hit.ray.src = rIn.src + rIn.dir * rDist;\n        hit.normal = normalize(hit.ray.src - sPos);\n        if(!above)\n            hit.normal = -hit.normal;\n        \n        hit.id = id;\n    }\n    \n    //*/\n    /*\n    vec3 sOffset = sPos - rIn.src; // delta\n    //ray points toward sphere\n    if(0.0 < dot(sOffset, rIn.dir))\n    {\n        float sRayClosest = dot(sOffset, rIn.dir);\n        float sRayClosestDist2 = dot(sOffset, sOffset) - sRayClosest*sRayClosest;\n        float sInnerOffset2 = sRad * sRad - sRayClosestDist2;\n        if(0.0 < sInnerOffset2)\n        {\n            //hit sphere, calculate intersection\n            float rDist = sRayClosest - sqrt(sInnerOffset2);\n            if(rDist < rayDist && 0.0 < rDist)\n            {\n                hit.rayDist = rayDist = rDist;\n                hit.ray.src = rIn.src + rIn.dir * rDist;\n                hit.normal = normalize(hit.ray.src - sPos);\n                //hit.normal /= sqrt(dot(hit.normal, hit.normal));\n                hit.id = id;\n            }\n        }\n    }\n    //*/\n}\n\nvoid tvPlane(Ray rIn, out tvHit hit, inout float rayDist, int id, vec3 normal, float off)\n{\n    //test if ray is above surface\n    float side = dot(rIn.src, normal);\n    bool above = off < side;\n    \n    //test if ray points toward surface\n    float proj = dot(rIn.dir, normal); //not the adjusted normal\n    bool facing = proj < 0.0;\n    \n    if(above == facing)\n    {\n        Ray rDst = rIn;\n        rDst.src = rIn.src + rIn.dir * ((off - side) / proj);\n\n        vec3 diff = rDst.src - rIn.src;\n        float dist = length(diff); //sqrt(dot(diff, diff));\n\n        if(dist < rayDist)\n        {\n            hit.rayDist = rayDist = dist;\n            hit.ray = rDst;\n            hit.normal = normal;\n            hit.id = id;\n            \n            if(!above)\n                hit.normal = -normal;\n        }\n    }\n}\n\nbool pointInTri(Tri tri, vec3 point, out vec2 coords)\n{\n    //v1 and v2 form a basis space, whose linear combination is vt. vt = a*v1 + b*v2.\n    //Since vt is guaranteed to be on the plane between the two, its psuedoinverse is its inverse.\n    //moore-penrose psuedoinverse: (MT*M)^-1 * MT = M+\n    \n    //move space toward first vertex\n    //maybe use a mul?\n    mat3 verts = mat3(tri.vertex[0], tri.vertex[1], tri.vertex[2]);\n    verts -= mat3(vec3(0.0), tri.vertex[0], tri.vertex[0]);\n    \n    mat2x3 space = mat2x3(verts[1], verts[2]); // can this be truncated from tri?\n    mat3x2 st = transpose(space);\n    mat2x2 inv = st * space;\n    \n    //if the inverse's inputs has no determinant, it covers no area, and has no inverse.\n    if(determinant(inv) == 0.0)\n        return false;\n    \n    mat3x2 mpi = inverse(inv) * st;\n    vec2 mpipt = mpi * (point - verts[0]); // move into basis space\n    \n    //if the point does not lie within the unit triangle, it misses.\n    if(mpipt.x < 0.0)\n        return false;\n    if(mpipt.y < 0.0)\n        return false;\n    if(1.0 < dot(mpipt, vec2(1,1)))\n       return false;\n    \n    coords = mpipt;\n    return true;\n}\n\nvoid tvTri(Ray rIn, out tvHit hit, inout float rayDist, int id, Tri tri)\n{\n    //this uses code from my one shader rasterizer for a point in triangle test, with the plane traverse above.\n    //https://www.shadertoy.com/view/wdGyWR\n    //ideally, models are arranged in a heirarchical format to accellerate raytracing, but doing that per frame\n    //    isn't ideal. Much more managable on a cpu / gpu system.\n    \n    //traverse toward plane\n    tvHit pHit;\n    pHit.ray = rIn;\n    pHit.normal = vec3(0,0,0);\n    pHit.id = 0; // id of the sky\n    \n    float dist = rayDist;\n    tvPlane(rIn, pHit, dist, id, tri.plane.normal, tri.plane.offset);\n    if(pHit.id == 0) // miss\n        return;\n    \n    if(rayDist <= dist)\n        return;\n    \n    vec2 coords;\n    if(!pointInTri(tri, pHit.ray.src, coords))\n        return;\n    \n    //lerp to find position\n    //Ray rDst = rIn;\n    //rDst.src = verts * vec3(1.0, coords);\n    \n    //if(dist < rayDist)\n    rayDist = dist;\n    hit = pHit;\n    //hit.ray = rDst;\n}\n/*\nvoid tvFog(Ray rIn, out tvHit hit, inout float rayDist, int id)\n{\n    float absorbtion = Materials[1].albedo.x;\n    if(absorbtion == 0.0)\n        return;\n    \n    float epsilon = rnd();\n    float x = log(epsilon) / absorbtion;\n    \n    Ray rDst = rIn;\n    rDst.src = rIn.src + rIn.dir * x;\n    \n    if(x < rayDist)\n    {\n        hit.rayDist = rayDist = x;\n        hit.ray = rDst;\n        hit.normal = rIn.dir; // hit.normal isn't used in BSDFs, only in and out directions.\n        hit.id = id;\n    }\n}\n*/\ntvHit traverse(Ray rIn, vec3 normIn, int inid) // normal is required to prevent the ray from going backwards from its surface\n{\n    tvHit hit;\n    hit.ray = rIn;\n    hit.normal = vec3(0);\n    hit.id = 0; // id of the sky\n    float rayDist = 1.0e30;\n    hit.rayDist = rayDist;\n    \n    //check if ray fires below current surface\n    if(dot(rIn.dir, normIn) < 0.0)\n    {\n        //hit nothing, return a bunch of zeroes\n        hit.rayDist = rayDist = 0.0;\n        hit.normal = normIn;\n        hit.id = inid;\n        return hit;\n    }\n    \n    \n    //raytrace fog\n    //fog can collide with itself\n    //tvFog(rIn, hit, rayDist, 1);\n    \n    //moved tvFog to outside traverse, to allow it to work with light sampling techniques.\n    //is this a two-bounce sampler?\n    //equi-angular sampling seems superior\n    \n    //plane\n    if(inid != 2)\n        tvPlane(rIn, hit, rayDist, 2, Planes[0].normal, Planes[0].offset);\n        //tvPlane(rIn, hit, rayDist, 2, normalize(vec3(-2,1,1)), vec3(0,0,-0.7));\n    \n    //other plane\n    if(inid != 3)\n    {\n        tvHit h = hit;\n        float rd = rayDist;\n    \ttvPlane(rIn, h, rayDist, 3, Planes[1].normal, Planes[1].offset);\n        vec2 p = h.ray.src.xy+vec2(0,-5);\n        //if(dot(p,p) <= 10.0*10.0) hit = h;\n        if(dot(p,p) > 10.0*10.0) h.id = 0;\n        if(rd > rayDist)\n            hit = h;\n    }\n    \n    \n    //raytrace sphere\n    //if(inid != 4)\n        //tvSphere(rIn, hit, rayDist, 4, 1.0, vec3(-1.0,3.0,-0.5 + 1.0 - 0.5 + 0.0*sin(iTime)));\n        tvSphere(rIn, normIn, hit, rayDist, 4, Spheres[0].radius, Spheres[0].position);\n    \t\n    //raytrace other sphere\n    if(inid != 5)\n    \ttvSphere(rIn, normIn, hit, rayDist, 5, Spheres[1].radius, Spheres[1].position);\n    //{\n    //    float sRad = 0.25;\n    //    tvSphere(rIn, hit, rayDist, 5, sRad, vec3(2.0*cos(iTime) - 1.0,3.0 + 2.0*sin(iTime),-1.0 + sRad));\n    //}\n    \n    for(int i=0; i<11 - 2; ++i)\n    \ttvSphere(rIn, normIn, hit, rayDist, i + 6, Spheres[i+2].radius, Spheres[i+2].position);\n    \n    if(inid != 15)\n        tvTri(rIn, hit, rayDist, 15, Tris[0]);\n    /*\n    if(hit.id == 3)\n    {\n        float p = 0.0;\n        vec2 xy = hit.ray.src.xy;\n        vec2 ixy = xy - vec2(ivec2(xy + vec2(10000.0)) - ivec2(10000.0));\n        if(0.5 < ixy.x) p = 1.0 - p;\n        if(0.5 < ixy.y) p = 1.0 - p;\n        \n        if(p == 1.0)\n        {\n            p = 0.0;\n            xy /= 20.0;\n            ixy = xy - vec2(ivec2(xy + vec2(10000.0)) - ivec2(10000.0));\n            if(19.0/20.0 < ixy.x && 19.0/20.0 < ixy.y) p = 1.0 - p;\n            if(p == 1.0)\n                hit.id = 0;\n        }\n    }*/\n    \n    return hit;\n}\n\nfloat brdfLambert(tvHit Hit, Ray rOut)\n{\n    float diffuse = dot(Hit.normal, rOut.dir) / 3.141592;\n    diffuse = clamp(diffuse, 0.0, 1.0);\n    return diffuse;\n}\n\nfloat brdfPhongSpecular(tvHit Hit, Ray rIn, Ray rOut, float power)\n{\n    vec3 refl = reflect(rIn.dir, Hit.normal);\n    \n    float specular = dot(rOut.dir, refl);\n    specular = clamp(specular, 0.0, 1.0);\n    \n    specular = pow(specular, power);\n    specular *= (power + 2.0) / (2.0 * 3.141592);\n  \treturn specular;\n}\n\nvec3 brdfPhong(tvHit Hit, Ray rIn, Ray rOut, Material Mat)\n{\n    vec3 albedo = Mat.albedo;\n    vec3 reflectivity = Mat.reflectivity;\n    float power = Mat.power;\n    \n    float diffuse = brdfLambert(Hit, rOut);\n    float specular = brdfPhongSpecular(Hit, rIn, rOut, power);\n    \n    vec3 brdf = (1.0 - reflectivity) * albedo*diffuse + reflectivity * specular;\n    \n    return brdf;\n}\n\nfloat bsdfUniform(tvHit Hit, Ray rOut)\n{\n    return 1.0 / (4.0 * 3.141592);\n}\n\nfloat bsdfGeometric(tvHit Hit, Ray rOut)\n{\n    //Cardioid!\n    //uses ray.dir instead of normal\n    float cosp = -dot(Hit.ray.dir, rOut.dir);\n    \n    //this can produce NaNs\n    //cosp out of bounds?\n    //if(sinp != sinp)\n    //    return 0.0;\n    cosp = clamp(cosp, -1.0, 1.0);\n    \n    float sinp = sin(acos(cosp)/2.0);\n    \n    return sinp / (8.0 * 3.141592 / 3.0);\n    \n    //geometric sampling is acting strange\n    //return bsdfUniform(Hit, rOut);\n\n    float normalizer = 1.0 / (4.0 * 3.141592);\n}\n\nfloat bsdfRayleigh(tvHit Hit, Ray rOut)\n{\n    //Spherical harmonics?\n    float cosp = -dot(Hit.ray.dir, rOut.dir);\n    \n    float bsdf = 1.0 + cosp*cosp;\n    \n    return bsdf / (16.0 * 3.141592 / 3.0);\n}\n\nfloat bvtfHomogenous(float fDist, float fpdf) // bidirectional volume transmission function\n{\n    float absorbtion = Materials[1].albedo.x;\n    if(absorbtion == 0.0) // no fog\n        return 1.0;\n    \n    fpdf += 1e-31;\n    \n    float ret = absorbtion*exp(-absorbtion * fDist) / fpdf;\n    \n    if(ret != ret)\n        return 0.0;\n    return ret;\n}\n\nvec3 sampleMercator(tvHit Hit, out float pdf)\n{\n  \tpdf = 1.0;\n    vec3 rOut = randMercator(pdf);\n    \n    if(dot(rOut, Hit.normal) < 0.0)\n        rOut = reflect(rOut, Hit.normal);\n    \n    pdf = 1.0 / pdf; // numerator pdf when multiplied\n    \n    //should these be packed into the sampler?\n    pdf /= (2.0 * 3.141592) * (3.141592 / 2.0); // sample space pdf: theta, psi\n    \n    return rOut;\n}\n\nvec3 sampleSphere(tvHit Hit, out float pdf)\n{\n  \tpdf = 1.0;\n    vec3 rOut = randSphere();\n    \n    if(dot(rOut, Hit.normal) < 0.0)\n        rOut = reflect(rOut, Hit.normal);\n    \n    //should these be packed into the sampler?\n    //float pdf = 1.0; // no numerator pdf\n    pdf /= 2.0 * 3.141592; // 4pi r^2 / 2, half a sphere's area (clamped)\n    \n    return rOut;\n}\nfloat pdfSphere(tvHit Hit, Ray rOut)\n{\n    return 1.0 / (2.0 * 3.141592);\n}\n\n\nvec3 sampleLambert(tvHit Hit, out float pdf)\n{\n  \t//pdf = 1.0; // no pdf at all, due to importance sampling\n    //this is absolutely wrong, the pdf is equal to the brdf so they cancel\n    //however, when the pdf is zero it should return 0 juuuust in case haha\n    \n    //if(0.0 < dot(Hit.normal, Hit.ray.dir))\n    //    Hit.normal *= -1.0;\n    \n    //Hit.normal *= -1.0;\n    \n    Ray ray;\n    ray.dir = randLambert(Hit.normal);\n    \n    pdf = brdfLambert(Hit, ray);\n    \n    return ray.dir;\n}\n\nfloat pdfLambert(tvHit Hit, Ray rOut)\n{\n    return brdfLambert(Hit, rOut);\n}\n\nvec3 samplePhongSpec(tvHit Hit, out float pdf, Ray rIn, float power)\n{\n    Ray ray;\n    \n    ray.dir = randPhongSpec(Hit.normal, rIn.dir, power);\n    pdf = brdfPhongSpecular(Hit, rIn, ray, power);\n\t\n    return ray.dir;\n}\n\nfloat pdfPhongSpec(tvHit Hit, Ray rIn, Ray rOut, float power)\n{\n    if(brdfLambert(Hit, rOut) <= 0.0)\n        return 0.0;\n    return brdfPhongSpecular(Hit, rIn, rOut, power);\n}\n\nvec3 samplePhongOld(tvHit Hit, out float pdf, Ray rIn, vec3 reflectivity, float power)\n{\n    Ray ray;\n    \n    //can this be done better by treating it as an MIS?\n    \n    //float refl = dot(reflectivity, vec3(1,1,1)) / 3.0;\n    \n    float refl = 0.5;\n    \n    if( refl < rnd()) // diffuse\n    {\n        ray.dir = sampleLambert(Hit, pdf);\n    \t//pdf *= 1.0 - refl;\n    }\n    else // specular\n    {\n        ray.dir = samplePhongSpec(Hit, pdf, rIn, power);\n    \t//pdf *= refl;\n    }\n    \n    return ray.dir;\n}\n\nvec3 samplePhong(tvHit Hit, out float pdf, Ray rIn, Material mat)\n{\n    return samplePhongOld(Hit, pdf, rIn, mat.reflectivity, mat.power);\n    float reflectivity = 0.25; // hardcoded\n    Ray ray;\n    \n    //can this be done better by treating it as an MIS?\n    float pdfLambert = 1.0;\n    float pdfPhongSpec = 1.0;\n    \n    vec3 samLambert = sampleLambert(Hit, pdfLambert);\n    vec3 samPhongSp = samplePhongSpec(Hit, pdfPhongSpec, rIn, mat.power);\n    \n    float misWeight = (1.0 - reflectivity)*pdfLambert + reflectivity*pdfPhongSpec;\n    float wLambert = pdfLambert / misWeight + 1e-10;\n    float wPhongSpec = pdfPhongSpec / misWeight + 1e-10;\n    \n    if(wLambert < rnd()) // diffuse\n    {\n        pdf = pdfLambert * wLambert;\n        ray.dir = samLambert;\n    }\n    else // specular\n    {\n        pdf = pdfPhongSpec * wPhongSpec;\n        ray.dir = samPhongSp;\n    }\n    \n    return ray.dir;\n}\n\nfloat pdfPhong(tvHit Hit, Ray rIn, Ray rOut, Material mat)\n{\n    float diffuse = pdfLambert(Hit, rOut);\n    return diffuse;\n    \n    //if(diffuse == 0.0)\n    //    return 0.0;\n    float specular = pdfPhongSpec(Hit, rIn, rOut, mat.power);\n    float refl = dot(mat.reflectivity, vec3(1,1,1)) / 3.0;\n    return refl*specular + (1.0-refl)*diffuse;\n}\n\nvec3 sampleLightSingular(tvHit Hit, out float pdf, out vec3 samPos, vec3 sPos, float sRad)\n{\n    //selects a random point on the light to raytrace towards\n    vec3 rPos = randSphere();\n    vec3 rNorm = rPos;\n    \n    //finds the vector from the ray source to this sample\n    rPos *= sRad;\n    rPos += sPos;\n    \n    samPos = rPos; // useful for fog sampling\n    \n    rPos -= Hit.ray.src;\n    \n    //pdf is the probability area projected toward from point\n    float r2 = dot(rPos, rPos);\n    vec3 rOut = rPos / sqrt(r2);\n    \n    float area = 2.0 * 3.141592 * sRad * sRad; // hemisphere? area\n    area *= abs(dot(rNorm, rOut)); // projected area\n    pdf = r2 / area; // 1/area, in case r2 is near zero it works better here\n    \n    /*\n    //repeat for the sample on the other side of the sphere, to find the complete pdf\n    rNorm = -reflect(rNorm, rOut); // other side\n    rPos = rNorm * sRad;\n    rPos += sPos;\n    rPos -= Hit.ray.src;\n    r2 = dot(rPos, rPos);\n    area = 4.0 * 3.141592 * sRad * sRad;\n    area *= abs(dot(rNorm, rOut));\n    pdf += r2 / area;\n    */\n    \n    if(pdf != pdf) // if r2 and the dot are both 0, pdf becomes NaN.\n        pdf = 0.0; // 0/0 == 0 haha\n    \n    return rOut;\n}\n\nfloat pdfLightSingular(tvHit Hit, Ray rOut, vec3 sPos, float sRad)\n{\n    vec3 delta = sPos - rOut.src;\n    vec3 ndelta = normalize(delta);\n    float delta2 = dot(delta, delta);\n    float r2 = sRad * sRad;\n    float proj = dot(ndelta, rOut.dir);\n    \n    if(proj < 0.0) // sphere is below ray\n        return 0.0;\n    \n    if(delta2 < r2) // ray is within sphere\n        return 0.0; // harder to code\n    \n    if(proj * proj <= (1.0 - (r2 / delta2))) // if the ray misses the sphere\n        return 0.0;\n    \n    //find intersection\n    float mdelta = sqrt(delta2);\n    float mmid = dot(delta, rOut.dir); // proj * mdelta // length of line that makes a right angle to the sphere\n    float mmid2 = mmid * mmid;\n    float mdev2 = r2 + mmid2 - delta2;\n    if(mdev2 < 0.0)\n        return 0.0;\n        \n    //mdev is the little length difference between mid and dist\n    float mdev = sqrt(mdev2);\n    \n    float dist1 = mmid - mdev; // is this a complex root?\n    float dist2 = mmid + mdev; // a sqrt's involved, and there's two conjugates\n    \n    vec3 sHit1 = dist1 * rOut.dir + rOut.src; // oh shit\n    vec3 sHit2 = dist2 * rOut.dir + rOut.src;\n    \n    vec3 n1 = normalize(sHit1 - sPos);\n    vec3 n2 = normalize(sHit2 - sPos);\n    \n    //find projected areas\n    float pdf = 0.0;\n\tfloat SA = 4.0 * 3.141592 * r2;\n\t\n\tfloat A1 = SA * abs(dot(n1, rOut.dir));\n\tfloat A2 = SA * abs(dot(n2, rOut.dir));\n\t\n\t// area facing the ray, over the distance ^2\n\tfloat pdf1 = (dist1 * dist1) / A1;\n\tfloat pdf2 = (dist2 * dist2) / A2;\n\t\n    pdf = pdf1 + pdf2;\n    \n    if(pdf != pdf) // if r2 and the dot are both 0, pdf becomes NaN.\n        pdf = 0.0; // 0/0 == 0 haha\n    \n    return pdf;\n}\n\nvec3 sampleTri(tvHit Hit, out float pdf, out vec3 samPos, Tri tri)\n{\n    vec2 uv = randTri();\n    \n    //build basis space\n    mat3 space = mat3(tri.vertex[0], tri.vertex[1], tri.vertex[2]);\n    space -= mat3(vec3(0.0), tri.vertex[0], tri.vertex[0]);\n    \n    //lerp into real space\n    vec3 rPos = space * vec3(1.0, uv);\n    \n    samPos = rPos; // useful for fog sampling\n    \n    rPos -= Hit.ray.src;\n    \n    //pdf is the probability area projected toward from point\n    float r2 = dot(rPos, rPos);\n    vec3 rOut = rPos / sqrt(r2);\n    \n    // there's gotta be an easier way to find this\n    float area = length(cross(space[1], space[2])) / 2.0; \n    \n    area *= abs(dot(tri.plane.normal, rOut)); // projected area\n    pdf = r2 / area; // 1/area, in case r2 is near zero it works better here\n    \n    return rOut;\n}\n\nfloat pdfTri(tvHit Hit, Ray rOut, Tri tri)\n{\n    //find if rOut hits the tri\n    tvHit hit;\n    hit.ray = rOut;\n    hit.normal = vec3(0,0,0);\n    hit.id = 0; // id of the sky\n    float rayDist = 1.0e30;\n    \n    tvTri(rOut, hit, rayDist, 1, Tris[0]); // id doesn't really matter\n    if(hit.id == 0)\n        return 0.0; // miss\n    \n    //build basis space\n    mat3 space = mat3(tri.vertex[0], tri.vertex[1], tri.vertex[2]);\n    space -= mat3(vec3(0.0), tri.vertex[0], tri.vertex[0]);\n    \n    //pdf is the probability area projected toward from point\n    float r2 = rayDist * rayDist;\n    \n    // there's gotta be an easier way to find this\n    float area = length(cross(space[1], space[2])) / 2.0; \n    \n    area *= abs(dot(tri.plane.normal, rOut.dir)); // projected area\n    float pdf = r2 / area; // 1/area, in case r2 is near zero it works better here\n    \n    return pdf;\n}\n\nvec3 sampleLight(tvHit Hit, out float pdf, out vec3 samPos)\n{\n    vec3 Out;\n    vec3 spos = vec3(0);\n    \n    //sample uniformly\n    //float pick = rnd();\n    //if(pick < 1.0 / 3.0)\n    //    Out = sampleLightSingular(Hit, pdf, Spheres[0].position, Spheres[0].radius);\n    //else if(pick < 2.0 / 3.0)\n    //    Out = sampleLightSingular(Hit, pdf, Spheres[3].position, Spheres[3].radius);\n    //else\n    //    Out = sampleTri(Hit, pdf, Tris[0]);\n    //pdf /= 3.0;\n    \n    //sample via a sample space\n    float samples[4];\n    float sample_sum = 0.0;\n    \n    int sn = 10; // 3\n    int mn = sn + 4;\n    \n    //surface area\n    samples[0] = 4.0 * 3.141592 * Spheres[0].radius * Spheres[0].radius;\n    samples[1] = 4.0 * 3.141592 * Spheres[3].radius * Spheres[3].radius;\n    samples[2] = 4.0 * 3.141592 * Spheres[sn].radius * Spheres[sn].radius;\n    samples[3] = length(cross(Tris[0].vertex[1]-Tris[0].vertex[0], Tris[0].vertex[2]-Tris[0].vertex[1]));\n    \n    //luminous flux (intensity * area)\n    sample_sum += samples[0] *= dot(vec3(1), Materials[4].emission);\n    sample_sum += samples[1] *= dot(vec3(1), Materials[7].emission);\n    sample_sum += samples[2] *= dot(vec3(1), Materials[mn].emission);\n    sample_sum += samples[3] *= dot(vec3(1), Materials[15].emission);\n    \n    float pick = rnd();\n    float samplespace = 0.0;\n    int i=0;\n    \n    for(i=0; i<4; ++i)\n    {\n        samplespace += samples[i] / sample_sum;\n        if(pick < samplespace)\n            break;\n    }\n    \n    if(i==0)\n        Out = sampleLightSingular(Hit, pdf, samPos, Spheres[0].position, Spheres[0].radius);\n    else if(i==1)\n        Out = sampleLightSingular(Hit, pdf, samPos, Spheres[3].position, Spheres[3].radius);\n    else if(i==2)\n        Out = sampleLightSingular(Hit, pdf, samPos, Spheres[sn].position, Spheres[sn].radius);\n    else\n        Out = sampleTri(Hit, pdf, samPos, Tris[0]);\n    \n    pdf *= samples[i] / sample_sum;\n    \n    Ray rOut = Hit.ray;\n    rOut.dir = Out;\n    \n    return Out;\n}\n\nvec3 sampleLight(tvHit Hit, out float pdf)\n{\n    vec3 samPos = vec3(0); // not needed here\n    return sampleLight(Hit, pdf, samPos);\n}\n\nfloat pdfLight(tvHit Hit, Ray rOut) // this should be below sampleLight when its done\n{\n    float pdf0 = pdfLightSingular(Hit, rOut, Spheres[0].position, Spheres[0].radius);\n    \n    //return pdf0;\n    //are multiple pdfs weighted averages, like in MIS?\n    \n    int sn = 10;\n    int mn = sn + 4;\n    \n    float pdf3 = pdfLightSingular(Hit, rOut, Spheres[3].position, Spheres[3].radius);\n    \n    float pdfn = pdfLightSingular(Hit, rOut, Spheres[sn].position, Spheres[sn].radius);\n    \n    //return (pdf0 + pdf3) / 2.0;\n    \n    float pdfT = pdfTri(Hit, rOut, Tris[0]);\n    \n    //sample uniformly\n    //return (pdf0 + pdf3 + pdfT) / 3.0;\n    \n    //sample via a sample space\n    float samples[4];\n    float sample_sum = 0.0;\n    \n    //surface area\n    samples[0] = 4.0 * 3.141592 * Spheres[0].radius * Spheres[0].radius;\n    samples[1] = 4.0 * 3.141592 * Spheres[3].radius * Spheres[3].radius;\n    samples[2] = 4.0 * 3.141592 * Spheres[sn].radius * Spheres[sn].radius;\n    samples[3] = length(cross(Tris[0].vertex[1]-Tris[0].vertex[0], Tris[0].vertex[2]-Tris[0].vertex[1]));\n    \n    //luminous flux (intensity * area)\n    sample_sum += samples[0] *= dot(vec3(1), Materials[4].emission);\n    sample_sum += samples[1] *= dot(vec3(1), Materials[7].emission);\n    sample_sum += samples[2] *= dot(vec3(1), Materials[mn].emission);\n    sample_sum += samples[3] *= dot(vec3(1), Materials[15].emission);\n    \n    float tpdf[4] = float[4](pdf0, pdf3, pdfn, pdfT);\n    float pdf = 0.0;\n    for(int i=0; i<4; ++i)\n        pdf += tpdf[i] * samples[i] / sample_sum;\n    \n    return pdf;\n    \n}\n\nvec3 sampleScatterUniform(tvHit Hit, out float pdf)\n{\n  \tpdf = 1.0;\n    vec3 rOut = randSphere();\n    \n    pdf /= 4.0 * 3.141592; // 4pi r^2, a sphere's area\n    \n    //pdf = bsdfUniform(Hit, ray);\n    \n    return rOut;\n}\n\nfloat pdfScatterUniform(tvHit Hit, Ray rOut)\n{\n    return 1.0 / (4.0 * 3.141592);\n}\n\nvec3 sampleScatterGeometric(tvHit Hit, out float pdf)\n{\n    Ray ray;\n    ray.dir = randScatterGeometric(Hit.normal);\n    \n    pdf = bsdfGeometric(Hit, ray);\n    \n    return ray.dir;\n}\n\nfloat pdfScatterGeometric(tvHit Hit, Ray rOut)\n{\n    return bsdfGeometric(Hit, rOut);\n}\n\nfloat sampleFogDistance(Ray rIn, out float fpdf)\n{\n    float absorbtion = Materials[1].albedo.x;\n    if(absorbtion == 0.0)\n    {\n        fpdf = 1.0;\n        return 1.0e31;\n    }\n    \n    float epsilon = rnd();\n    float x = -log(epsilon) / absorbtion;\n    \n    //find pdf\n    //fpdf = absorbtion * exp(-absorbtion * x); // epsilon\n    //fpdf = exp(-absorbtion * x); // epsilon\n    //fpdf = epsilon; // this absorbtion term vanishes somehow. \n    fpdf = absorbtion * epsilon; // Found it! This is because im using the integral, not the pdf in the bvtf.\n    return x;\n}\n\nfloat pdfFogDistance(float depth)\n{\n    float absorbtion = Materials[1].albedo.x;\n    if(absorbtion == 0.0)\n        return 0.0;\n    \n    return bvtfHomogenous(depth, 1.0);\n}\n\nfloat sampleFogEquiAngular(Ray rIn, out float fpdf)\n{ // egsr2012_volume.pdf\n    //pick a point on a light\n    tvHit Hit;\n    Hit.ray = rIn;\n    \n    float absorbtion = Materials[1].albedo.x;\n    if(absorbtion == 0.0)\n    {\n        fpdf = 1.0;\n        return 1.0e31;\n    }\n    \n    float lpdf = 1.0;\n    vec3 samPos = vec3(0);\n    vec3 lHit = sampleLight(Hit, lpdf, samPos);\n    \n    //find angle to sample pos\n    //find closest distance to sample\n    vec3 delta = samPos - rIn.src;\n    float mDelta = length(delta);\n    vec3 ndelta = delta / mDelta;\n    float x = dot(delta, rIn.dir);\n    float theta = acos(x / mDelta);\n    float D = mDelta * sin(theta);\n    float a = -(3.141592 / 2.0 - theta);\n    float b = 3.141592 / 2.0; // all fograys should go on forever\n    \n    //pick a point\n    float xi = rnd();\n    float t = xi*(b-a) + a;\n    float dist = D * tan(t); // move ray onto line\n    \n    delta = rIn.src + dist*rIn.dir;\n    \n    //find pdf\n    fpdf = D / (dot(delta, delta) * (b-a)); // this doesn't work?\n    //fpdf = (b-a) / (dot(delta, delta) * D); // but this one does?\n    //fpdf *= lpdf;\n    \n    return dist;\n    \n}\n\nfloat pdfFogEquiAngular(float depth)\n{\n    return 0.0; // oh god\n    // this needs the pdf to *all* lights along the entire path\n    // jesus christ\n}\n\nMaterial matTexture(tvHit Hit) // this function allows for material texturing\n{\n    Material mOut = Materials[Hit.id];\n    if(Hit.id == 0)\n    {\n        vec3 ldir = Hit.ray.dir;//rIn.dir;\n        ldir = vec3(ldir.x, ldir.z, -ldir.y);\n        mOut.emission = srgb2lsrgb(texture(iChannel1, ldir).xyz);\n        //mOut.emission = vec3(0.5,0.5,1) * 0.1;\n        //mOut.emission = vec3(0.0,0.0,0.0);\n        return mOut;\n    }\n    \n    if(Hit.id == 2)\n    {\n        mOut.albedo = srgb2lsrgb(texture(iChannel3, Hit.ray.src.xy).xyz);\n        return mOut;\n    }\n    \n    if(Hit.id == 3)\n    {\n        float p = 0.0;\n        vec2 xy = Hit.ray.src.xy;\n        vec2 ixy = xy - vec2(ivec2(xy + vec2(10000.0)) - ivec2(10000.0));\n        if(0.5 < ixy.x) p = 1.0 - p;\n        if(0.5 < ixy.y) p = 1.0 - p;\n        mOut.albedo = vec3((0.75-0.25)*p + 0.25);\n        //mOut.power = (10000.0-100.0)*(1.0-p) + 100.0;\n        return mOut;\n    }\n    \n    if(Hit.id == 15)\n    {\n        //vec3 c = srgb2lsrgb(texture(iChannel1, Hit.ray.dir).xyz);\n        //return mOut;\n        \n        vec2 coords;\n        pointInTri(Tris[0], Hit.ray.src, coords);\n        \n        vec3 c = srgb2lsrgb(texture(iChannel2, coords).xyz);\n        ///*\n        //hue-hue chroma key\n        vec3 c_hsv = rgb2hsv(c);\n        float adj = 0.8;\n        c_hsv.r += adj; if(1.0 < c_hsv.r) c_hsv.r -= 1.0;\n        if(c_hsv.r < 0.33) c_hsv.r += 0.33; // blue screen\n        c_hsv.r -= adj;\n        \n        c = hsv2rgb(c_hsv);\n        //*/\n        c *= dot(Materials[Hit.id].emission, vec3(1.0/3.0));\n        \n        mOut.emission = c;\n        return mOut;\n    }\n    \n    return mOut;\n}\n\nvec3 raytrace2(Ray rIn, vec3 normIn, int inid)\n{\n    tvHit Hit = traverse(rIn, normIn, inid);\n    \n    float fDist = Hit.rayDist;\n    float fpdf = 1.0;\n    \n    fDist = sampleFogDistance(rIn, fpdf);\n    //fDist = sampleFogEquiAngular(rIn, fpdf);\n    if(fDist < Hit.rayDist)\n    {\n        Hit.rayDist = fDist;\n        Hit.ray = rIn;\n        Hit.ray.src = rIn.src + rIn.dir * fDist;\n        Hit.normal = rIn.dir; // hit.normal isn't used in BSDFs, only in and out directions.\n        Hit.id = 1;\n    }\n    \n    /*\n    if(Hit.rayDist <= 0.0)\n    {\n        if(dot(rIn.dir, normIn) > 0.0)\n            return vec3(1,0.5,0);\n        return vec3(1,0,0);\n    }\n    */\n    /*\n    if(Hit.errRtrn > 0.0)\n        return vec3(1,0,1);\n    \n    if(Hit.rayDist < 0.0)\n        return vec3(1,0,0);\n    if(Hit.rayDist == 0.0 && Hit.id == 0)\n        return vec3(0,1,0);\n    if(Hit.rayDist > 1e10)\n        return vec3(0,0,1);\n    \n    return vec3(1) / log(Hit.rayDist + 1.0);\n    //return vec3(1) * max(0.0, dot(-rIn.dir, Hit.normal));\n    //return Hit.normal*0.5 + 0.5;\n    */\n    //vec3 refl = reflect(rIn.dir, Hit.normal);\n    //return refl*0.5 + 0.5;\n    //return srgb2lsrgb(texture(iChannel1, refl.xzy).xyz);\n    \n    vec3 Out = matTexture(Hit).emission;\n    \n    float transmission = bvtfHomogenous(fDist, fpdf);\n    Out *= transmission;\n    \n    //if(Hit.id == 0)\n    //    return Out;\n    \n    /*\n    if(Hit.id == 2)\n        Out = vec3(0,0,1);\n    \n    if(Hit.id == 3)\n        Out = vec3(0,1,0);\n    \n    if(Hit.id == 1)\n        Out = vec3(1,0,0);\n    */\n    return Out;\n}\n\nvec3 raytrace_fundamental(Ray rIn)\n{\n    tvHit Hit = traverse(rIn, rIn.dir, 0);\n    \n    Material Mat = matTexture(Hit);\n    vec3 Out = Mat.emission;\n    if(Hit.id == 0)\n        return Out;\n    \n    Ray rOut = Hit.ray;\n    float pdf = 1.0;\n    vec3 brdf = vec3(0);\n    \n    if(Hit.id == 1)// fog\n    {\n        rOut.dir = sampleScatterUniform(Hit, pdf);\n        brdf = vec3(1,1,0) * bsdfGeometric(Hit, rOut);\n        brdf+= vec3(0,0,1) * bsdfRayleigh(Hit, rOut);\n    }\n    else\n    {\n        rOut.dir = sampleSphere(Hit, pdf);\n        brdf = brdfPhong(Hit, rIn, rOut, Mat);\n    }\n    \n    vec3 rtrace = raytrace2(rOut, Hit.normal, Hit.id);\n    \n    pdf += 1e-10; // corrects for a division by zero error\n    \n    return Out + rtrace * brdf / pdf; \n}\n\nvec3 raytrace_fundamental_fog(Ray rIn)\n{\n    tvHit Hit = traverse(rIn, rIn.dir, 0);\n    \n    //fog, using tvFog in its current implementation, is a hardcoded importance sample for distance sampling.\n    //This is why the following code has the if statement, its a binary operation.\n    float fDist = Hit.rayDist;\n    float fpdf = 1.0;\n    \n    //fDist = sampleFogDistance(rIn, fpdf);\n    fDist = sampleFogEquiAngular(rIn, fpdf);\n    if(fDist < Hit.rayDist)\n    {\n        Hit.rayDist = fDist;\n        Hit.ray = rIn;\n        Hit.ray.src = rIn.src + rIn.dir * fDist;\n        Hit.normal = rIn.dir; // hit.normal isn't used in BSDFs, only in and out directions.\n        Hit.id = 1;\n    }\n    \n    float transmission = bvtfHomogenous(fDist, fpdf);\n    \n    Ray rOut = Hit.ray;\n    float pdf = 1.0;\n    vec3 brdf = vec3(0);\n    \n    Material Mat = matTexture(Hit);\n    vec3 Out = Mat.emission;\n    \n    if(Hit.id == 0)\n        return Out * transmission;\n\n    if(Hit.id == 1)// fog\n    {\n        //fpdf = 1.0;\n        rOut.dir = sampleScatterUniform(Hit, pdf);\n        brdf = vec3(1,1,0) * bsdfGeometric(Hit, rOut);\n        brdf+= vec3(0,0,1) * bsdfRayleigh(Hit, rOut);\n    }\n    else\n    {\n        //fpdf = 1.0;\n        rOut.dir = sampleSphere(Hit, pdf);\n        brdf = brdfPhong(Hit, rIn, rOut, Mat);\n    }\n\n    vec3 rtrace = raytrace2(rOut, Hit.normal, Hit.id);\n\n    //pdf *= fpdf;\n    pdf += 1e-10; // corrects for a division by zero error\n\n    Out += rtrace * brdf / pdf;\n    Out *= transmission;\n    \n    return Out; \n}\n\n\nvec3 raytrace_importance(Ray rIn)\n{\n    tvHit Hit = traverse(rIn, rIn.dir, 0);\n    \n    float fDist = Hit.rayDist;\n    float fpdf = 1.0;\n    \n    //fDist = sampleFogDistance(rIn, fpdf);\n    fDist = sampleFogEquiAngular(rIn, fpdf);\n    if(fDist < Hit.rayDist)\n    {\n    \n        float t = bvtfHomogenous(fDist, fpdf);\n        if(rnd() < t)\n        {\n            Hit.rayDist = fDist;\n            Hit.ray = rIn;\n            Hit.ray.src = rIn.src + rIn.dir * fDist;\n            Hit.normal = rIn.dir; // hit.normal isn't used in BSDFs, only in and out directions.\n            Hit.id = 1;\n        \n        }\n    }\n    \n    float transmission = bvtfHomogenous(fDist, fpdf);\n    \n    //return vec3(transmission);\n    \n    //return vec3(1) / Hit.rayDist;\n    //return vec3(1) * max(0.0, dot(-rIn.dir, Hit.normal));\n    //return Hit.normal*0.5 + 0.5;\n    \n    //vec3 refl = reflect(rIn.dir, Hit.normal);\n    //return srgb2lsrgb(texture(iChannel1, refl.xzy).xyz);\n    \n    Ray rOut = Hit.ray;\n    float pdf = 1.0;\n    \n    vec3 brdf = vec3(0);\n    \n    Material Mat = matTexture(Hit);\n    vec3 Out = Mat.emission;\n    \n    if(Hit.id == 0)\n        return Out * transmission;\n    \n    //rOut.dir = sampleSphere(Hit, pdf);\n    //rOut.dir = sampleLambert(Hit, pdf);\n    //rOut.dir = samplePhongSpec(Hit, pdf, rIn, Mat.power);\n    //rOut.dir = samplePhong(Hit, pdf, rIn, Mat);\n    //rOut.dir = sampleLight(Hit, pdf);\n    \n    if(Hit.id == 1)// fog\n    {\n        float pick = rnd();\n        pick = 1.0;\n        if(pick < 1.0 / 3.0) rOut.dir = sampleScatterUniform(Hit, pdf);\n        else if(pick < 2.0 / 3.0) rOut.dir = sampleScatterGeometric(Hit, pdf);\n        else rOut.dir = sampleLight(Hit, pdf);\n        brdf = vec3(1,1,0) * bsdfGeometric(Hit, rOut);\n        brdf+= vec3(0,0,1) * bsdfRayleigh(Hit, rOut);\n        //pdf *= 1.0-exp(-Hit.rayDist); // fog experiment\n    }\n    else\n    {\n        float pick = rnd();\n        pick = 1.0;\n        if(pick < 1.0 / 3.0) rOut.dir = sampleLambert(Hit, pdf);\n        else if(pick < 2.0 / 3.0) rOut.dir = samplePhongSpec(Hit, pdf, rIn, Mat.power);\n        else rOut.dir = sampleLight(Hit, pdf);\n        //pdf /= 3.0;\n\n        //float tpdf = pdfLight(Hit, rOut);\n        //pdf = tpdf;\n\n        //brdf = vec3(1) * brdfPhongSpecular(Hit, rIn, rOut, Mat.power);\n        //brdf *= Materials[Hit.id].reflectivity;\n        //brdf = vec3(1) * brdfLambert(Hit, rOut);\n        //brdf *= 1.0 - Materials[Hit.id].reflectivity;\n\n        brdf = brdfPhong(Hit, rIn, rOut, Mat);\n\n    }\n    \n    vec3 rtrace = raytrace2(rOut, Hit.normal, Hit.id);\n    \n    pdf += 1e-10; // corrects for a division by zero error\n       \n    // correct for pdf weirdness\n    if(pdf < 2e-10)\n    {\n        pdf = 1.0e31;\n    }\n    \n    Out += rtrace * brdf / pdf;\n    return Out * transmission;\n}\n\nconst int sa_BRDF = 4;\nconst int sa_BRDF_Spec = 4;\nconst int sa_Light = 4;\nconst int sa_Sphere = 4;\n\nvec3 raytrace_multiple_importance(Ray rIn)\n{\n    tvHit Hit = traverse(rIn, rIn.dir, 0);\n    \n    Material Mat = matTexture(Hit);\n    vec3 Out = Mat.emission;\n    if(Hit.id == 0)\n        return Out;\n    \n    Ray rOut = Hit.ray;\n    float pdf = 1.0;\n    \n    //MIS algo:\n    //collect samples from different sources\n    //for each dissimilar method, collect pdfs from each to find weighted pdf\n    //use wpdf instead for sum\n    \n    Ray rOutBRDF[sa_BRDF];\n    float pdfBRDF[sa_BRDF];\n    vec3 brdfBRDF[sa_BRDF];\n    vec3 rtBRDF[sa_BRDF];\n    \n    Ray rOutBRDF_Spec[sa_BRDF_Spec];\n    float pdfBRDF_Spec[sa_BRDF_Spec];\n    vec3 brdfBRDF_Spec[sa_BRDF_Spec];\n    vec3 rtBRDF_Spec[sa_BRDF_Spec];\n    \n    Ray rOutLight[sa_Light];\n    float pdf_Light[sa_Light];\n    vec3 brdfLight[sa_Light];\n    vec3 rtLight[sa_Light];\n    \n    // get samples for BRDF\n    for(int i=0; i<sa_BRDF; ++i)\n    {\n        rOutBRDF[i] = Hit.ray;\n        pdfBRDF[i] = 1.0;\n    \n        //rOutBRDF[i].dir = samplePhong(Hit, pdfBRDF[i], rIn, Mat);\n        rOutBRDF[i].dir = sampleLambert(Hit, pdfBRDF[i]);\n        brdfBRDF[i] = brdfPhong(Hit, rIn, rOutBRDF[i], Mat);\n        rtBRDF[i] = raytrace2(rOutBRDF[i], Hit.normal, Hit.id);\n    }\n    \n    // get samples for BRDF Specular\n    for(int i=0; i<sa_BRDF_Spec; ++i)\n    {\n        rOutBRDF_Spec[i] = Hit.ray;\n        pdfBRDF_Spec[i] = 1.0;\n    \n        rOutBRDF_Spec[i].dir = samplePhongSpec(Hit, pdfBRDF_Spec[i], rIn, Mat.power);\n        brdfBRDF_Spec[i] = brdfPhong(Hit, rIn, rOutBRDF_Spec[i], Mat);\n        rtBRDF_Spec[i] = raytrace2(rOutBRDF_Spec[i], Hit.normal, Hit.id);\n    }\n    \n    // get samples for Light\n    for(int i=0; i<sa_Light; ++i)\n    {\n        rOutLight[i] = Hit.ray;\n        pdf_Light[i] = 1.0;\n    \n        rOutLight[i].dir = sampleLight(Hit, pdf_Light[i]);\n        brdfLight[i] = brdfPhong(Hit, rIn, rOutLight[i], Mat);\n        rtLight[i] = raytrace2(rOutLight[i], Hit.normal, Hit.id);\n    }\n    \n    //accumulate MIS pass\n    vec3 MIS = vec3(0,0,0);\n    float sum_samples = float(sa_BRDF + sa_Light);\n    \n    //accumulate over BRDF\n    for(int i=0; i<sa_BRDF; ++i)\n    {\n        //find wpdf\n        float wpdf = 0.0;\n        \n        //this pdf was already precomputed\n        wpdf += float(sa_BRDF) * pdfBRDF[i];\n        \n        //compute other methods\n        wpdf += float(sa_BRDF_Spec) * pdfPhongSpec(Hit, rIn, rOutBRDF[i], Mat.power);\n        wpdf += float(sa_Light) * pdfLight(Hit, rOutBRDF[i]); // this right here is the problem\n        //wpdf += float(sa_Light) / (2.0 * 3.141592);\n        \n        wpdf += 1e-10; // corrects for a division by zero error\n        \n        // correct for pdf weirdness\n        if(wpdf < 2e-10)\n        {\n            wpdf = 1.0e31;\n        }\n        \n        //sample * brdf / weighted pdf\n        MIS += rtBRDF[i] * brdfBRDF[i] / wpdf;\n    }\n    \n    //accumulate over BRDF Specular\n    for(int i=0; i<sa_BRDF_Spec; ++i)\n    {\n        //find wpdf\n        float wpdf = 0.0;\n        \n        //this pdf was already precomputed\n        wpdf += float(sa_BRDF_Spec) * pdfBRDF_Spec[i];\n        \n        //compute other methods\n        wpdf += float(sa_BRDF) * pdfLambert(Hit, rOutBRDF_Spec[i]);\n        wpdf += float(sa_Light) * pdfLight(Hit, rOutBRDF_Spec[i]);\n        \n        wpdf += 1e-10; // corrects for a division by zero error\n        \n        // correct for pdf weirdness\n        if(wpdf < 2e-10)\n        {\n            wpdf = 1.0e31;\n        }\n        \n        //sample * brdf / weighted pdf\n        MIS += rtBRDF_Spec[i] * brdfBRDF_Spec[i] / wpdf;\n    }\n    \n    \n    //accumulate over Light\n    for(int i=0; i<sa_Light; ++i)\n    {\n        //find wpdf\n        float wpdf = 0.0;\n        \n        //this pdf was already precomputed\n        wpdf += float(sa_Light) * pdf_Light[i];\n        \n        //compute other methods\n        wpdf += float(sa_BRDF) * pdfLambert(Hit, rOutLight[i]);\n        wpdf += float(sa_BRDF_Spec) * pdfPhongSpec(Hit, rIn, rOutLight[i], Mat.power);\n        \n        wpdf += 1e-10; // corrects for a division by zero error\n        \n        // correct for pdf weirdness\n        if(wpdf < 2e-10)\n        {\n            wpdf = 1.0e31;\n        }\n        \n        //sample * brdf / weighted pdf\n        MIS += rtLight[i] * brdfLight[i] / wpdf;\n    }\n    \n    \n    return Out + MIS; \n}\n\nvec3 sample_MIS(tvHit Hit, Material Mat, out float pdf, int mode)\n{\n    Ray rOut = Hit.ray;\n    pdf = 1.0;\n    \n    //MIS one sample algo:\n    //same as MIS, but you randomly select the method, according to method space\n    \n    //build method space\n    const int methodCount = 4;\n    const float f_mC = float(methodCount);\n    float c_Sphere = 1.0 / 4.0;\n    float c_Lambert = 1.0 / 4.0;\n    float c_Specular = 1.0 / 4.0;\n    float c_Light = 1.0 / 4.0;\n    \n    float refl = dot(vec3(1), Mat.reflectivity) / 3.0;\n    \n    //bias toward more smooth samples, but still stick to 0 or 1 in edge cases\n    //refl = 2.0*refl - 1.0;\n    //refl *= refl*refl;\n    //refl = (refl + 1.0) / 2.0;\n    \n    c_Lambert = (1.0 - refl) * (2.0 / f_mC);\n    c_Specular = refl * (2.0 / f_mC);\n    \n    //c_Sphere =   0.5 / 3.0;\n    //c_Lambert =  0.5 / 3.0;\n    c_Sphere =   0.0 / 3.0;\n    c_Lambert =  1.0 / 3.0;\n    c_Specular = 1.0 / 3.0;\n    c_Light =    1.0 / 3.0;\n    \n    float methodSpace[methodCount];\n        methodSpace[0] = c_Sphere; methodSpace[1] = c_Lambert;\n        methodSpace[2] = c_Specular; methodSpace[3] = c_Light;\n    \n    //pick a method from methodspace\n    int c = 0;\n    float pick = rnd();\n    float methodSum = 0.0;\n    \n    if(mode < 0)\n    {\n        for(c=0; c<methodCount; ++c)\n        {\n            methodSum += methodSpace[c];\n            if(methodSum > pick)\n                break;\n        }\n    }\n    else\n    {\n        c = mode;\n        for(int i=0; i<methodCount; ++i)\n            methodSpace[c] = 1.0 / float(methodCount);\n    }\n    \n    //find a sample from the chosen method\n    if(c == 0)\n        rOut.dir = sampleSphere(Hit, pdf);\n    if(c == 1)\n        rOut.dir = sampleLambert(Hit, pdf);\n    else if(c == 2)\n        rOut.dir = samplePhongSpec(Hit, pdf, Hit.ray, Mat.power);\n    else //if(c == 3)\n        rOut.dir = sampleLight(Hit, pdf);\n    \n    \n    //Seperating the resulting samples, but still using weighted PDFs are useful for denoising, \n    //    while retaining MIS's variance reduction effects. Probably.\n    //if(rnd() < 0.5)\n    //rOut.dir = sampleLambert(Hit, pdf);\n    //else\n    //rOut.dir = sampleLight(Hit, pdf);\n    //rOut.dir = samplePhongSpec(Hit, pdf, Hit.ray, Materials[Hit.id].power);\n    \n    //fill wpdf using other methods\n    //sum(c * pdf(x)) / c\n    \n    //this pdf was already precomputed\n    pdf *= methodSpace[c]; \n    \n    for(int i=0; i<methodCount-1; ++i)\n    {\n        int j = (i+c+1) % methodCount; // skips the precomputed method\n        \n        if(j == 0)\n            pdf += methodSpace[j] * pdfSphere(Hit, rOut);\n        else if(j == 1)\n            pdf += methodSpace[j] * pdfLambert(Hit, rOut);\n        else if(j == 2)\n            pdf += methodSpace[j] * pdfPhongSpec(Hit, Hit.ray, rOut, Mat.power);\n        else //if(j == 3)\n            pdf += methodSpace[j] * pdfLight(Hit, rOut);\n    }\n    \n    //end of line\n    return rOut.dir;\n}\n\nvec3 sample_MIS(tvHit Hit, Material Mat, out float pdf)\n{\n    return sample_MIS(Hit, Mat, pdf, -1);\n}\n\nvec3 sample_fog_MIS(tvHit Hit, out float pdf)\n{\n    Ray rOut = Hit.ray;\n    pdf = 1.0;\n    \n    //MIS one sample algo:\n    //same as MIS, but you randomly select the method, according to method space\n    \n    //build method space\n    float c_Uniform = 1.0 / 3.0;\n    float c_Geometric = 1.0 / 3.0;\n    float c_Light = 1.0 / 3.0;\n    \n    float methodSpace[3]; methodSpace[0] = c_Uniform; methodSpace[1] = c_Geometric; methodSpace[2] = c_Light;\n    \n    //pick a method from methodspace\n    int c = 0;\n    float pick = rnd();\n    float methodSum = 0.0;\n    \n    for(c=0; c<3; ++c)\n    {\n        methodSum += methodSpace[c];\n        if(methodSum > pick)\n            break;\n    }\n    \n    //find a sample from the chosen method\n    if(c == 0)\n        rOut.dir = sampleScatterUniform(Hit, pdf);\n    else if(c == 1)\n        rOut.dir = sampleScatterGeometric(Hit, pdf);\n    else //if(c == 1)\n        rOut.dir = sampleLight(Hit, pdf);\n    \n    //this pdf was already precomputed\n    pdf *= methodSpace[c]; \n    \n    for(int i=0; i<3-1; ++i)\n    {\n        int j = (i+c+1) % 3; // skips the precomputed method\n        \n        if(j == 0)\n            pdf += methodSpace[j] * pdfScatterUniform(Hit, rOut);\n        else if(j == 1)\n            pdf += methodSpace[j] * pdfScatterGeometric(Hit, rOut);\n        else //if(j == 2)\n            pdf += methodSpace[j] * pdfLight(Hit, rOut); // use a special one for fog?\n    }\n    \n    //end of line\n    return rOut.dir;\n}\n\nfloat sample_fog_depth_MIS(Ray rIn, out float fpdf)\n{\n    float depth = 1.0e31;\n    fpdf = 1.0;\n    \n    //MIS one sample algo:\n    //same as MIS, but you randomly select the method, according to method space\n    \n    //build method space\n    float c_Depth = 1.0 / 2.0;\n    float c_EquiAngular = 1.0 / 2.0;\n    \n    float methodSpace[3]; methodSpace[0] = c_Depth; methodSpace[1] = c_EquiAngular;\n    \n    //pick a method from methodspace\n    int c = 0;\n    float pick = rnd();\n    float methodSum = 0.0;\n    \n    for(c=0; c<2; ++c)\n    {\n        methodSum += methodSpace[c];\n        if(methodSum > pick)\n            break;\n    }\n    \n    //find a sample from the chosen method\n    if(c == 0)\n        depth = sampleFogDistance(rIn, fpdf);\n    else // if(c == 1)\n        depth = sampleFogEquiAngular(rIn, fpdf);\n    \n    //this pdf was already precomputed\n    fpdf *= methodSpace[c]; \n    \n    for(int i=0; i<2-1; ++i)\n    {\n        int j = (i+c+1) % 2; // skips the precomputed method\n        \n        if(j == 0)\n            fpdf += methodSpace[j] * pdfFogDistance(depth);\n        else //if(j == 1)\n            fpdf += methodSpace[j] * pdfFogEquiAngular(depth);\n    }\n    \n    //end of line\n    return depth;\n}\n\nvec3 raytrace_MIS_sample(Ray rIn)\n{\n    tvHit Hit = traverse(rIn, rIn.dir, 0);\n    \n    float fDist = Hit.rayDist;\n    float fpdf = 1.0;\n    \n    //fDist = sampleFogDistance(rIn, fpdf);\n    //fDist = sampleFogEquiAngular(rIn, fpdf);\n    fDist = sample_fog_depth_MIS(rIn, fpdf);\n    if(fDist < Hit.rayDist)\n    {\n        float t = bvtfHomogenous(fDist, fpdf);\n        if(rnd() < t)\n        {\n            Hit.rayDist = fDist;\n            Hit.ray = rIn;\n            Hit.ray.src = rIn.src + rIn.dir * fDist;\n            Hit.normal = rIn.dir; // hit.normal isn't used in BSDFs, only in and out directions.\n            Hit.id = 1;\n        }\n    }\n    \n    float transmission = bvtfHomogenous(fDist, fpdf);\n    \n    Material Mat = matTexture(Hit);\n    vec3 Out = Mat.emission;\n    if(Hit.id == 0)\n        return Out * transmission;\n    \n    Ray rOut = Hit.ray;\n    float pdf = 1.0;\n    vec3 brdf = vec3(0);\n    \n    vec3 accum = vec3(0);\n    for(int i = 0; i<4; ++i) // deterministic mode, move some samples to specific methods\n    {\n    \n    if(Hit.id == 1)// fog\n    {\n        //rOut.dir = sampleScatterUniform(Hit, pdf);\n        //rOut.dir = sampleScatterGeometric(Hit, pdf);\n        rOut.dir = sample_fog_MIS(Hit, pdf);\n        brdf = vec3(1,1,0) * bsdfGeometric(Hit, rOut);\n        brdf+= vec3(0,0,1) * bsdfRayleigh(Hit, rOut);\n        //pdf *= 1.0-exp(-Hit.rayDist); // fog experiment\n    }\n    else\n    {\n        //rOut.dir = sampleSphere(Hit, pdf);\n        //rOut.dir = sample_MIS(Hit, Mat, pdf);\n        rOut.dir = sample_MIS(Hit, Mat, pdf, int(float(i)/1.0));\n        brdf = brdfPhong(Hit, rIn, rOut, Mat);\n        //pdf *= exp(-Hit.rayDist);\n    }\n    \n    vec3 rtrace = raytrace2(rOut, Hit.normal, Hit.id);\n    \n    pdf += 1e-10; // corrects for a division by zero error\n    \n    // correct for pdf weirdness\n    if(pdf < 2e-10)\n    {\n        pdf = 1.0e31;\n    }\n    \n    vec3 res = Out; // emission\n    res += rtrace * brdf / pdf;\n    res *= transmission;\n    \n    accum += res;\n    \n    //accum += rtrace * brdf / pdf;\n    \n    }\n    Out = accum / 4.0;\n    //Out += accum / 4.0;\n    //Out += rtrace * brdf / pdf;\n    \n    return Out;\n}\n\nvec3 Refract(vec3 rIn, vec3 normal, float eta)\n{\n    vec3 rOut = refract(rIn, normal, eta);\n    if(rOut == vec3(0))\n        return reflect(rIn, normal);\n    return rOut;\n}\n\nvec3 raytracePath(Ray rIn)\n{\n\t//raytracing with bounces, using a for loop instead of recusion\n    //const int maxBounces = 4;\n    const int maxBounces = 4;\n    int bounces = 0;\n        \n    vec3 emissive[maxBounces + 1];\n    vec3 brdf[maxBounces + 1];\n    \n    tvHit Hit;\n    Hit.id = 0;\n    Hit.normal = rIn.dir;\n    Ray ray = rIn;\n    \n    float ior = 1.0/1.33; // water\n    //float ior = 1.0/1.0003; // air\n    \n    for(bounces=0; bounces < maxBounces + 1; ++bounces)\n    {\n        Hit = traverse(ray, Hit.normal, Hit.id);\n        \n        emissive[bounces] = vec3(0,0,0);\n        \n        Material Mat = matTexture(Hit);\n        emissive[bounces] = Mat.emission;\n        if(Hit.id == 0)\n            break;\n        \n        //if(Hit.id == 3)\n        //    emissive[bounces] = vec3(0,1,0) / (0.25*0.25);\n        \n        Ray rold = ray;\n        ray = Hit.ray;\n        float pdf = 1.0;\n        /*\n        bool shiny = 0.5 < rnd();\n        float albedo = 1.0;\n        \n        if(Hit.id == 1 && !shiny)\n        \tif(sin(Hit.ray.src.x * 3.141592) * sin(Hit.ray.src.y * 3.141592) < 0.0)\n                albedo = 0.0;\n          \n        //if(Hit.id == 1 || shiny)//Hit.id == 2 || Hit.id == 3)\n       \tif(false && shiny && (Hit.id == 2 || Hit.id == 3))\n        {\n        \tpdf = 1.0 / (2.0 * 3.141592);\n            ray.dir = reflect(rold.dir, Hit.normal);\n        }\n        else\n        */\n        //if(bounces + 1 == maxBounces)\n       \t//\tray.dir = sampleLight(Hit, pdf);\n        //else\n        \n        if(Hit.id == 1)// fog\n        {\n            //rOut.dir = sampleScatterUniform(Hit, pdf);\n            //brdf = vec3(1,1,1) * bsdfUniform(Hit, rOut);\n            \n            //ray.dir = sampleScatterGeometric(Hit, pdf);\n            ray.dir = sample_fog_MIS(Hit, pdf);\n            //brdf[bounces] = vec3(1,1,1) * bsdfGeometric(Hit, ray);\n            //brdf[bounces] = vec3(1,1,1) * bsdfRayleigh(Hit, ray);\n            brdf[bounces] = vec3(1,1,0) * bsdfGeometric(Hit, ray);\n            brdf[bounces]+= vec3(0,0,1) * bsdfRayleigh(Hit, ray);\n        }\n        else if(4 <= Hit.id && Hit.id <= 14) // triangle\n        {\n            pdf = 1.0;\n            //ray.dir = reflect(ray.dir, Hit.normal);\n            ray.dir = Refract(ray.dir, Hit.normal, ior);\n            ior = 1.0 / ior;\n            //ray.dir = reflect(ray.dir, Hit.normal);\n            Hit.normal = -Hit.normal;\n            \n            brdf[bounces] = vec3(1);//brdfPhong(Hit, rold, ray, Mat);\n            \n        \n        }\n        else\n        {\n            //ray.dir = sampleLambert(Hit, pdf);\n        \t//ray.dir = samplePhong(Hit, pdf, rIn, Materials[Hit.id]);\n        \t//ray.dir = sampleLight(Hit, pdf);\n        \t//ray.dir = sampleMercator(Hit, pdf);\n        \t//ray.dir = sampleSphere(Hit, pdf);\n            ray.dir = sample_MIS(Hit, Mat, pdf);\n        \n        \t//brdf[bounces] = vec3(1,1,1) * brdfLambert(Hit, ray);\n        \tbrdf[bounces] = brdfPhong(Hit, rold, ray, Mat);\n        }\n        \n        if(pdf != pdf)\n            pdf = 1e-30;\n            \n        if(brdf[bounces] != brdf[bounces])\n            return vec3(1,0,0);\n        \n        if(1e-8 < pdf)\n            brdf[bounces] /= pdf;\n        else\n            brdf[bounces] = vec3(0,0,0);\n        \n        if(brdf[bounces] == vec3(0,0,0))\n            break;\n        \n        //brdf[bounces] = albedo;\n        \n    }\n    \n    //bounces--;\n    vec3 col = emissive[bounces];\n    bounces--;\n    \n    for(; 0<=bounces; --bounces)\n        col = emissive[bounces] + brdf[bounces] * col;\n        \n    return col;\n}\n\nvec3 raytrace(Ray rIn, vec2 fragCoord)\n{\n    //this function switches between different raytracing modes\n    \n    //if(fragCoord.x < 0.3333)// || 0.6666 < fragCoord.x) \n    //if(fragCoord.y < 0.3333)// || 0.6666 < fragCoord.x) \n        //return raytrace_fundamental(rIn);\n    //    return raytrace_importance(rIn);\n    /*if(0.6666 < fragCoord.x)\n        return raytraceLight(rIn);\n\t*/    \n\t\n    //return raytrace_fundamental(rIn);\n    //return raytrace_fundamental_fog(rIn);\n    //return raytrace_importance(rIn);\n    //return raytrace_multiple_importance(rIn); // use MIS sample below\n    return raytrace_MIS_sample(rIn);\n    //return raytracePath(rIn);\n}\n\nvoid initScene(in float rTime, in vec2 uv)\n{\n    \n    //rTime += (rnd() - 0.5) / 60.0; //const motion blur\n    rTime += (rnd() - 0.5) * iTimeDelta; // full frame adaptive motion blur\n    //rTime += (rnd() - 0.5) * iTimeDelta / 2.0; // half frame adaptive motion blur // this is how cameras work!\n\n    //setup materials\n    //sky\n    Materials[0].emission = vec3(0); // sky and fog only emit\n    \n    //fog\n    Materials[1].emission = vec3(0);\n    \n    //I'm not a fan of this formulation, I should redo it at some point\n    float f_n = 1000.0; //particle density\n    float f_r = 0.0005; //particle radius, 0.5mm\n    float f_c_vol = 1.0; //control volume, 1 cubic meter\n    \n    float f_crs_c_vol = pow(f_c_vol, 2.0 / 3.0); // v^(2/3)\n    float f_p_area = 3.141592 * f_r*f_r;\n    float f_denom = 1.0 - f_p_area / f_crs_c_vol;\n    float f_absorbtion = -log(f_denom) * f_n * f_crs_c_vol;\n    \n    //f_absorbtion *= 1000.0;\n    f_absorbtion *= 100.0;\n    //f_absorbtion *= (0.5 + 0.5*sin(iTime));\n    f_absorbtion = 0.0;\n    \n    //f_absorbtion *= 2000.0;\n    \n    //f_absorbtion *= 10.0;\n    \n    Materials[1].albedo = vec3(f_absorbtion); // repurpose\n    \n    ////////////\n    // planes //\n    ////////////\n    \n    //plane 0\n    Materials[2].emission     = vec3(0,0,0);\n    Materials[2].albedo       = vec3(1,1,1);\n    Materials[2].reflectivity = vec3(1,1,1) * 0.25;// * 4.0 * 0.99;\n    Materials[2].power        =               1000.0; // 1000.0;\n    //Materials[2].power        =               pow(10.0, sin(iTime / 5.0) + 3.0); // 1000.0;\n    //Materials[2].power        =               10000000.0; // 1000.0;\n    //Materials[2].power        =               10.0; // 1000.0;\n    //Materials[2].power        =               10000.0;\n    //Materials[2].power = 100.0;\n    \n    //Materials[2].power = 1000.0;\n    \n    for(int i=2+1; i<MatNum; ++i)\n        Materials[i] = Materials[2];\n    \n    //other plane\n    Materials[3] = Materials[2];\n    \n    //Materials[3].emission = vec3(1,1,1) * 10000.0;\n    \n    //setup planes\n    Planes[0].normal = vec3(0,0,1);\n    Planes[0].offset = dot(Planes[0].normal, vec3(0,0,-1.0));\n    Planes[1].normal = vec3(0,0,1);\n    Planes[1].offset = dot(Planes[1].normal, vec3(0,0, 1.75)); // fog -8.0+1.75\n    \n    /////////////\n    // spheres //\n    /////////////\n    \n    //large sphere\n    Materials[4] = Materials[2];\n    Materials[4].emission     = vec3(1,1,1) * 1.0;// / 100.0;\n    //Materials[4].power = 100000.0;\n    \n    //first sphere\n    Materials[5] = Materials[4];\n    Materials[5].emission     = vec3(0,1,0) * 100.0 * 0.0;\n    \n    //setup spheres\n    Spheres[0].radius = 1.0;//3.175 - 0.0;\n    Spheres[0].position = vec3(-1.0,3.0,0.0);\n    Spheres[1].radius = 0.25;\n    Spheres[1].position = vec3(1.0,3.0,-1.0 + Spheres[1].radius);\n    \n    //other spheres\n    float aTime = rTime + 4.1;\n    \n    for(int i=0; i<9; i++)\n    {\n        Spheres[2+i] = Spheres[1];\n        Materials[4+2+i] = Materials[5];\n        Spheres[2+i].position += vec3(0,i+1,0);\n        Spheres[2+i].position += vec3(2.0 * 0.3*float(i+1)*cos(aTime + float(i) / 2.0), 0.0, 0.0);\n    }\n    \n    Materials[7].emission = vec3(0,1,0) * 100.0;// / 1000.0;\n    //Materials[14].emission = vec3(1,1,1) * 10000.0;// / 1000.0;\n    //Spheres[3].position += vec3(2.0 * cos(iTime), 0.0, 0.0);\n    \n    float fTime = 0.0*rTime * 0.1 - 0.1;// + 3.141592;\n    \n    //Materials[14].emission = vec3(1,1,1) * 1000.0;//  10000.0;\n    \n    //Spheres[10].position.xy *= 2.0;\n    //Materials[14].emission *= 4.0 * 10.0;\n    \n    //Spheres[10].radius /= 5.0;\n    //Materials[14].emission *= 25.0;\n    //Spheres[10].position.z *= -1.0;\n    \n    mat2x2 fogrotate = mat2x2(vec2(cos(fTime), sin(fTime)), vec2(-sin(fTime), cos(fTime)));\n    //Spheres[10].position.xy = fogrotate * Spheres[10].position.xy;\n    \n    //////////\n    // tris //\n    //////////\n    \n    //setup tris\n    Materials[15] = Materials[2];\n    Materials[15].emission = vec3(0,0,1) * 10.0;// / 10.0;\n    //Materials[15].emission = vec3(1) * 100.0; // caustic scene\n    \n    //setup tris\n    float pTime = rTime;// + 4.1;\n    float speed = 1.0 * 0.25; //0.2;\n    float off = 0.33;\n    \n    pTime = off+speed*pTime;\n    \n    Tris[0].vertex[0] = vec3(3,4,1.0  + sin(pTime));\n    Tris[0].vertex[1] = vec3(1,5,1.0 + sin(pTime + 2.0*3.141592 / 3.0));\n    Tris[0].vertex[2] = vec3(4,7,1.0  + sin(pTime + 4.0*3.141592 / 3.0));\n    Tris[0].plane.normal = normalize(cross(Tris[0].vertex[1]-Tris[0].vertex[0], Tris[0].vertex[2]-Tris[0].vertex[0]));\n    Tris[0].plane.offset = dot(Tris[0].plane.normal, Tris[0].vertex[0]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //seed = fract(iTime) + iResolution.y * uv.x + uv.y;\n    //seed = iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    seed = hashrandom(iTime + iResolution.y * uv.x + uv.y);\n    \n    float rTime = iTime;// + 14.61;// + 2.0;\n    //float rTime = iTime * 0.0 + 23.14;// + 2.0;\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(rnd(), rnd(), rnd());\n    \n    initScene(rTime, uv);\n    \n    //render\n    \n    float x = fragCoord.x / iResolution.x;\n    float y = fragCoord.y / iResolution.y;\n    \n    x = x * 2.0 - 1.0;\n    y = y * 2.0 - 1.0;\n    y *= iResolution.y / iResolution.x;\n    \n    Ray ray;\n    col = vec3(0,0,0);\n    const int samples = 4; // *4 mis subsamples\n    for(int smp=0; smp<samples; ++smp)\n    {\n        seed += 1.0;\n        float dx = 2.0 * rnd() - 1.0;\n        float dy = 2.0 * rnd() - 1.0;\n        \n        dx /= iResolution.x;\n        dy /= iResolution.x;\n        \n        //dx = 0.0;\n        //dy = 0.0;\n        \n        ray.src = vec3(0,0,0);\n        ray.dir = vec3(x + dx,1,y + dy);\n        float cTime = rTime / 5.0;\n        float cCos = cos(cTime);\n        float cSin = sin(cTime);\n        mat4x4 t1 = mat4x4(vec4(1,0,0,0),vec4(0,1,0,0),vec4(0,0,1,0),vec4(0,5,0,1));\n        mat4x4 t2 = mat4x4(vec4(1,0,0,0),vec4(0,1,0,0),vec4(0,0,1,0),vec4(0,-5,0,1));\n        mat4x4 rotate = mat4x4(vec4(cCos, cSin, 0,0), vec4(-cSin, cCos, 0,0), vec4(0,0,1,0), vec4(0,0,0,1));\n        rotate = t1 * rotate * t2;\n        ray.src = (rotate * vec4(ray.src, 1.0)).xyz;\n        ray.dir = (rotate * vec4(ray.dir, 0.0)).xyz;\n        \n        ray.dir = normalize(ray.dir);\n        //ray.dir /= sqrt(dot(ray.dir, ray.dir));\n\n        vec3 clr = raytrace(ray, fragCoord / iResolution.xy);\n        col += clr / float(samples);\n    }\n    \n    //convert color space from lsrgb to srgb\n    //good enough\n    //col = sqrt(col);\n    \n    // Output to screen\n    \n    vec3 colacc = col;\n    \n    bool progressiveRendering = false;\n    vec4 tprev = texture(iChannel0, fragCoord/iResolution.xy);\n    int iFrameStart = int(tprev.w);\n    if(0.5 < iMouse.z)\n    {\n        iFrameStart = iFrame;\n     \tcolacc = col;   \n    }\n    if(progressiveRendering)\n    {\n        float spp1 = float(iFrame - iFrameStart);\n        float spp2 = float(iFrame - iFrameStart + 1);\n        vec3 colprev = tprev.xyz;\n        colacc = (col / spp2) + (colprev * (spp1/spp2));\n    }\n    \n    fragColor = vec4(colacc,float(iFrameStart)); // store start frame in alpha channel\n}", "buffer_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//color space transforms\nfloat lsrgb2srgb(float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 rgb)\n{\n\tvec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, k.wz), vec4(rgb.gb, k.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 hsv)\n{\n\tvec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    return hsv.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), hsv.y);    \n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tffRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 50, 50, 161], [163, 163, 220, 220, 480]], "test": "untested"}
{"id": "3tsBDr", "name": "Meander", "author": "wyatt", "description": "meandering currents", "tags": ["fluid"], "likes": 31, "viewed": 705, "published": 3, "date": "1596485808", "time_retrieved": "2024-07-30T20:52:40.216544", "image_code": "// Fork of \"Fluid Reaction\" by wyatt. https://shadertoy.com/view/3tfBWr\n// 2020-08-03 18:33:18\n\n// Fork of \"4-Substance\" by wyatt. https://shadertoy.com/view/3lffzM\n// 2020-08-03 02:14:45\n\n// Fork of \"Multi-Substance\" by wyatt. https://shadertoy.com/view/WtffRM\n// 2020-08-01 02:57:11\n\nMain {\n    Q = 1.-2.5*sin(A(U).wwww*(1.3+.2*vec4(1,2,3,4)));\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n            #define r 1.15\n#define N 15.\n#define S vec4(4,7,1,1)\n#define Gaussian(i) 0.3989422804/S*exp(-.5*(i)*(i)/S/S)\n", "buffer_a_code": "Main {\n    if (iFrame%2<1) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,1,0);\n            if (length(U-vec2(0.5)*R)<.3*R.y)Q.w = .3;\n        }\n        if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.xw = vec2(.25,.3);\n        if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n    } else {\n    \tQ = A(U);vec4 q = Q, dd = D(U);\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u), d = D(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.125*(-d.w*a.w+a.w*(a.w*a.z-1.-3.*a.w))*u;\n    \tQ.z  -= q.w*0.125*a.w*dot(u,a.xy-q.xy);\n    }\n    Q.xy = mix(Q.xy,D(U).xy,Q.w);\n    if (Q.w < 1e-3) Q.z *= 0.;\n    }\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    vec4 a = A(U);\n   \tQ = mix(D(U),a,a.w);\n    \n    vec4 m = 0.25*(D(U+vec2(0,1))+D(U+vec2(1,0))+D(U-vec2(0,1))+D(U-vec2(1,0)));\n    Q = mix(Q,m,vec4(0,0,1,.1));\n    \n    if (length(Q.xy)>0.) \n        Q.xy = .2*normalize(Q.xy)*Q.w;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    if (iFrame%2<1) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,1,0);\n            if (length(U-vec2(0.5)*R)<.3*R.y)Q.w = .3;\n        }\n        if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.xw = vec2(.25,.3);\n        if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n    } else {\n    \tQ = A(U);vec4 q = Q, dd = D(U);\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u), d = D(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.125*(-d.w*a.w+a.w*(a.w*a.z-1.-3.*a.w))*u;\n    \tQ.z  -= q.w*0.125*a.w*dot(u,a.xy-q.xy);\n    }\n    Q.xy = mix(Q.xy,D(U).xy,Q.w);\n    if (Q.w < 1e-3) Q.z *= 0.;\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    vec4 a = A(U);\n   \tQ = mix(D(U),a,a.w);\n    \n    vec4 m = 0.25*(D(U+vec2(0,1))+D(U+vec2(1,0))+D(U-vec2(0,1))+D(U-vec2(1,0)));\n    Q = mix(Q,m,vec4(0,0,1,.1));\n    \n    if (length(Q.xy)>0.) \n        Q.xy = .2*normalize(Q.xy)*Q.w;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3llBDr", "name": "Pulse team logo in neonwave", "author": "mrange", "description": "Created a team logo for my team at work in neon wave style. Thougnt it turned out ok so sharing it.", "tags": ["2d", "neon"], "likes": 6, "viewed": 515, "published": 3, "date": "1596484050", "time_retrieved": "2024-07-30T20:52:41.026379", "image_code": "// License CC0: Pulse team logo in neonwave\n//  Created a team logo for my team at work in neon wave style. Thougnt it turned out ok so sharing it.\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n#define SCA(a) vec2(sin(a), cos(a))\n\nconst vec2 sca0 = SCA(0.0);\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat emin(float a, float b, float k) {\n  float res = exp2( -k*a ) + exp2( -k*b );\n  return -log2( res )/k;\n}\n    \nfloat emax(float a, float b, float k) {\n  return -emin(-a, -b, k);\n}\n\nfloat planex(vec2 p, float w) {\n  return abs(p.y) - w;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, c.y, c.x)*p;\n  p = vec2((p.y>0.0)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l);\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat letterp(vec2 p) {\n  float b = box(p - vec2(-0.45, -0.25), vec2(0.1, 0.75));\n  float c = max(circle(p, 0.5), -circle(p, 0.3));\n  return min(b, c);\n}\n\nfloat letteru(vec2 p) {\n  return horseshoe(p - vec2(0.0, 0.125), sca0, 0.5, vec2(0.375, 0.1));\n}\n\nfloat letterl(vec2 p) {\n  return box(p, vec2(0.125, 0.75));\n}\n\nfloat letters(vec2 p) {\n  rot(p, -PI/6.0);\n  rot(p, -PI/2.0);\n  float u = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1)) - 0.0;\n  rot(p, PI);\n  float l = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1));\n  return min(u,l);\n}\n\nfloat lettere(vec2 p) {\n  return min(box(p, vec2(0.4, 0.1)), max(circle(p, 0.5), -circle(p, 0.3)));\n}\n\nfloat pulse(vec2 p) {\n  p.x += 1.95;\n  const float op = +0.10;\n  const float ou = +1.25;\n  const float ol = +2.10;\n  const float os = +2.80;\n  const float oe = +3.85;\n  float dp = letterp(p - vec2(op, 0.0));\n  float du = letteru(p - vec2(ou, 0.0));\n  float dl = letterl(p - vec2(ol, 0.0));\n  float ds = letters(p - vec2(os, 0.0));\n  float de = lettere(p - vec2(oe, 0.0));\n  float oo = 0.1;\n  float dx = abs(p.y) - oo;\n  dx = abs(dx) - oo*0.5;\n  float d = 1000000.0;\n  d = min(d, dp);\n  d = min(d, du);\n  d = min(d, dl);\n  d = min(d, ds);\n  d = min(d, de);\n  d = max(d, -dx);\n  return d;\n}\n\nfloat sun(vec2 p) {\n  const float ch = 0.0125;\n  vec2 sp = p;\n  vec2 cp = p;\n  mod1(cp.y, ch*6.0);\n  float d0 = circle(sp, 0.5);\n  float d1 = planex(cp, ch);\n  float d2 = p.y+ch*3.0;\n  float d = d0;\n  d = pmax(d, -max(d1, d2), ch*2.0);\n  return d;\n}\n\nfloat df(vec2 p) {\n  const vec2 off = vec2(0.0, -10.0+0.5);\n  const vec2 coff = vec2(0);\n  const float si = 5.0;\n  const float sc = 25.0;\n  float di = pulse((p - off)/si)*si;\n  float ds = sun(p/sc)*sc;\n  float d = ds;\n  d = emax(d, -(di - 0.5), 2.0+sin(0.5*TIME+p.x));\n  d = min(d, di);\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col = clamp(col,0.0,1.0);\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 sound(vec2 q, vec3 baseCol) {\n  // the sound texture is 512x2\n  int tx = int(q.x*512.0);\n  int ty = int(q.y*512.0);\n    \n  // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n  const int dfft = 7;\n  float fft  = 0.0; \n  for (int i = -dfft; i <= dfft; ++i) {\n    fft += sqrt(texelFetch(iChannel0, ivec2(ty+i,0), 0).x); \n  }\n  fft /= float(dfft)*2.0 + 1.0;\n\n  // second row is the sound wave, one texel is one mono sample\n  float wave = 0.0;\n  const int dwave = 5;\n  for (int i = -dwave; i <= dwave; ++i) {\n    wave += texelFetch(iChannel0, ivec2(tx+i,1), 0).x; \n  }\n  wave /= float(dwave)*2.0 + 1.0;\n\t\n  vec3 col = vec3(0.0);\n    \n  float xamp = sqrt(1.0-2.0*abs(q.x - 0.5));\n  col += 1.0*mix(vec3(0.0), baseCol, fft*fft);\n  float xoff = abs(0.125*(xamp*wave - 0.5) + 0.185 - q.y);\n  col += 1.25*xamp*vec3(1.0, 0.9, 1.0)*exp(-30.0*xoff);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  float dc = min(abs(p.x), abs(p.y));\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 sunCol = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 1.0), clamp((0.85 - p.y)*0.75, 0.0, 1.0));\n  vec3 glareCol = sqrt(sunCol);\n  float ss = smoothstep(-1.05, 0.0, p.y);\n  vec3 glow = mix(vec3(1.0, 0.7, 0.6).zyx, glareCol, ss);\n \n  float s = 15.0;\n  float d = df(p*s)/s;\n  float db = abs(d) - 0.0025;\n \n  vec3 col = vec3(1.0, 0.0, 1.0)*0.125;\n  vec3 corona = 0.65*glow*exp(-2.5*d)*ss;\n  col += sound(q, corona);\n  col += corona;\n  col = mix(col, sunCol*ss, smoothstep(-aa, aa, -d));\n  col = mix(col, glow*1.55, smoothstep(-aa, aa, -db));\n//  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -dc));\n  \n  col += 1.0-smoothstep(0.0, 2.0, TIME);\n  col = postProcess(col, q);\n\n    \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 23688, "src": "https://soundcloud.com/futurejoust/sunset-drive", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llBDr.jpg", "access": "api", "license": "cc0-1.0", "functions": [[334, 334, 367, 367, 452], [454, 454, 493, 493, 618], [620, 620, 659, 659, 748], [750, 750, 789, 789, 818], [820, 820, 859, 859, 929], [935, 935, 974, 974, 1003], [1005, 1005, 1036, 1036, 1061], [1063, 1063, 1094, 1094, 1120], [1122, 1122, 1149, 1149, 1225], [1227, 1227, 1277, 1277, 1494], [1496, 1496, 1519, 1519, 1649], [1651, 1651, 1674, 1674, 1747], [1749, 1749, 1772, 1772, 1810], [1812, 1812, 1835, 1835, 2092], [2094, 2094, 2117, 2117, 2195], [2197, 2197, 2218, 2218, 2785], [2787, 2787, 2806, 2806, 3036], [3038, 3038, 3056, 3056, 3338], [3340, 3340, 3377, 3377, 3570], [3572, 3572, 3606, 3638, 4457], [4459, 4459, 4514, 4514, 5391]], "test": "untested"}
{"id": "WtlBWr", "name": "Low Toner", "author": "wyatt", "description": "Forward advected compressible fluid simulation with 3 texturephylic substances", "tags": ["fluid"], "likes": 11, "viewed": 474, "published": 3, "date": "1596479369", "time_retrieved": "2024-07-30T20:52:41.794326", "image_code": "// Fork of \"4-Substance\" by wyatt. https://shadertoy.com/view/3lffzM\n// 2020-08-03 18:26:39\n\n// Fork of \"Multi-Substance\" by wyatt. https://shadertoy.com/view/WtffRM\n// 2020-08-01 02:57:11\n\nMain {\n    Q = 1.2*D(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n            #define r 1.3", "buffer_a_code": "Main {\n    if (iFrame%2<1) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,.1,0);\n            if (length(U-vec2(0.5)*R)<.3*R.y)Q.w = .8;\n        }\n        if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.w = .3;\n        if (U.x<2.||U.y<2.||R.x-U.x<2.||R.y-U.y<2.) Q *= 0.;\n    } else {\n    \tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u), c = C(U+u), d = D(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.125*(\n            a.w*(a.w*a.z-.8-.1*b.w-.1*c.w)+\n            -d.x\n           )*u;\n    \tQ.z -= q.w*0.125*a.w*(dot(u,a.xy-q.xy));\n    }\n    if (Q.w < 1e-3) Q.z *= 0.;\n    Q.xy *= 0.999;\n    }\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    if (iFrame%2<1) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,.1,0);\n            if (length(U-vec2(0.5)*R)<.3*R.y)Q.w = .8;\n        }\n        if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.w = .3;\n        if (U.x<2.||U.y<2.||R.x-U.x<2.||R.y-U.y<2.) Q *= 0.;\n    } else {\n    \tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u), c = C(U+u), d = D(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.125*(\n            a.w*(a.w*a.z-.8-.1*b.w-.1*c.w)+\n            -d.y\n           )*u;\n    \tQ.z -= q.w*0.125*a.w*(dot(u,a.xy-q.xy));\n    }\n    if (Q.w < 1e-3) Q.z *= 0.;\n    Q.xy *= 0.999;\n    }\n}", "buffer_b_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    if (iFrame%2<1) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,.1,0);\n            if (length(U-vec2(0.5)*R)<.3*R.y)Q.w = .8;\n        }\n        if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.w = .3;\n        if (U.x<2.||U.y<2.||R.x-U.x<2.||R.y-U.y<2.) Q *= 0.;\n    } else {\n    \tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u), c = C(U+u), d = D(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.125*(\n            a.w*(a.w*a.z-.8-.1*b.w-.1*c.w)+\n            -d.z\n           )*u;\n    \tQ.z -= q.w*0.125*a.w*(dot(u,a.xy-q.xy));\n    }\n    if (Q.w < 1e-3) Q.z *= 0.;\n    Q.xy *= 0.999;\n    }\n}", "buffer_c_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fork of \"Multi-Substance\" by wyatt. https://shadertoy.com/view/WtffRM\n// 2020-08-01 02:57:11\n\nMain {\n    vec4\n        n = A(U+vec2(0,1))+B(U+vec2(0,1))+C(U+vec2(0,1)),\n        e = A(U+vec2(1,0))+B(U+vec2(1,0))+C(U+vec2(1,0)),\n        s = A(U-vec2(0,1))+B(U-vec2(0,1))+C(U-vec2(0,1)),\n        w = A(U-vec2(1,0))+B(U-vec2(1,0))+C(U-vec2(1,0));\n    vec3 norm = \n        normalize(vec3(e.z*e.w-w.z*w.w,n.z*n.w-s.z*s.w,10)),\n        ref = reflect(vec3(0,0,-1),norm);\n   \n\tvec4 a = A(U), b = B(U), c = C(U);\n    Q = vec4(a.w,b.w,c.w,1);\n    Q.w = length(texture(iChannel3,ref).xyz);\n}", "buffer_d_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlBWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wlXBDn", "name": "Waving_001", "author": "cambalamas", "description": " ", "tags": ["waves"], "likes": 2, "viewed": 293, "published": 3, "date": "1596462346", "time_retrieved": "2024-07-30T20:52:42.662008", "image_code": "const float pi = 3.14159265358979323846264338327950288;\n\n//#define ANIMATE_ZOOM\n\n\n// -----------------------------------------------------------------------\n\nfloat map(in float v, in float i, in float I, in float o, in float O) {\n    return o + (O-o) * (v-i) / (I-i);\n}\nvec3 uClamp(in vec3 v) {\n    return clamp(vec3(0.), vec3(1.), v);\n}\nfloat uClamp(in float v) {\n    return clamp(0., 1., v);\n}\n\n// -----------------------------------------------------------------------\n\nfloat fleur(in float t, in vec2 p, in float n)\n{\n    float r = length(p);\n    float a = atan(p.x, p.y);\n    \n#ifdef ANIMATE_ZOOM\n    float rn = mix(0., 2., cos(t*0.15 + sin(t*0.1))) * r * pi;\n#else\n    float rn = 3. * r * pi;\n#endif\n    float an = a * n;\n    \n    float w = sin(t + an + cos(t + rn));\n    float e = cos(t - rn  + sin(t + an - w) - w) + w * w;\n    \n    return e;\n}\n\n\n// -----------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t     = iTime;\n    vec2  uv    = (fragCoord / iResolution.xy);\n    \n    float e = 0.;\n    vec2  p = uv * 2. - 1.;\n    \n    float tails = 500.;\n\n    float I = .2;\n    e += fleur(t, p + vec2(0.,0.), tails) * I;\n\n\n\n    float l1 = e;\n    float l2 = 1.-l1;\n    float l3 = smoothstep(0.1, 1., l2);\n    \n    float a1 = l1 - (l2);\n    float a2 = l2 - (l1);\n    float a3 = l3 - (l1+l2);\n    \n\n    vec3 cl1 = vec3(1,0,0) * a1 * I;\n    vec3 cl2 = vec3(0,1,0) * a2 * I;\n    vec3 cl3 = vec3(0,0,1) * a3 * I;\n    \n    fragColor = vec4(vec3(1.-e),1.);\n    //fragColor = vec4(vec3( e + (abs(e)-e) ),1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 229, 229, 269], [270, 270, 294, 294, 337], [338, 338, 364, 364, 395], [473, 473, 521, 521, 852], [931, 931, 988, 988, 1593]], "test": "untested"}
{"id": "tlfBDn", "name": "Pixelization gradient", "author": "zwegner", "description": "it's, like, pixelization and gradients, man", "tags": ["gradient", "pixelization"], "likes": 28, "viewed": 608, "published": 3, "date": "1596447854", "time_retrieved": "2024-07-30T20:52:43.560603", "image_code": "// Based on xxhash\nuint hash(uint x) {\n\tx *= 0xC2B2AE3Du;\n    x = x << 17 | x >> 15;\n    x ^= x >> 15;\n    x *= 0x85EBCA77u;\n    x ^= x >> 13;\n    x *= 0x165667B1u;\n    x ^= x >> 16;\n\treturn x;\n}\nfloat fhash2(vec2 xy) {\n    return float(hash(uint(1024.*xy.x) + hash(uint(1024.*xy.y)))) / float(0xFFFFFFFFu);\n}\nfloat fhash3(vec2 xy, uint z) {\n    return float(hash(uint(1024.*xy.x) + hash(uint(1024.*xy.y) +\n\t\t\thash(1024u*z)))) / float(0xFFFFFFFFu);\n}\n\nvec2 mask_coord(vec2 coord, int shift) {\n    uint mask = 0xFFFFu << shift;\n    return vec2(float(uint(coord.x) & mask),\n                float(uint(coord.y) & mask));\n}\n\nfloat get_sample(vec2 coord, int shift) {\n    coord = mask_coord(coord, shift);\n    vec2 uv = coord / iResolution.xy;\n    \n    float offset = 1.2 * (uv.x + uv.y - 1.);\n    float hxy = fhash2(coord);\n    float fshift = 6.*abs(uv.y - uv.x) + 1.8;\n    float tf = 13.*iTime/fshift + 1.*hxy;\n    uint t = uint(tf);\n    float h1 = fhash3(coord, t);\n    #if 1\n    float c = 1.2*h1 + offset;\n    #else\n\tfloat h2 = fhash3(coord, t+1u);\n    float f = clamp(1.8*(tf-float(t)), 0., 1.);\n    float c = 1.2*mix(h1, h2, f) + offset;\n    #endif\n\tc = (c - .5) * 2.5 / (1.5 + float(shift)) + .5;\n    return c;\n}\n\nfloat get_sample_t(vec2 coord, uint time) {\n    int shift = 0;\n    for (int s = 10; s >= 0; s--) {\n    \tvec2 xy = mask_coord(coord, s) / iResolution.xy;\n    \tfloat factor = 6.*abs(xy.y - xy.x)+1.;\n        if (s < int(factor + 1.*fhash3(xy, time))) {\n            shift = s;\n            break;\n        }\n    }\n    float c1 = get_sample(coord, shift);\n    float c2 = get_sample(coord, shift+1);\n    return (1.*c1+c2)/2.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float tf = .3*iTime;\n    uint t = uint(tf);\n    float c1 = get_sample_t(fragCoord, t);\n    float c2 = get_sample_t(fragCoord, t+1u);\n    float c = mix(c1, c2, tf-float(t));\n    fragColor = vec4(c,c,c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 19, 38, 38, 195], [196, 196, 219, 219, 309], [310, 310, 341, 341, 450], [452, 452, 492, 492, 619], [621, 621, 662, 662, 1214], [1216, 1216, 1259, 1259, 1636], [1638, 1638, 1693, 1693, 1903]], "test": "untested"}
{"id": "WtXfWr", "name": "Planets with Valleys", "author": "jarble", "description": "This is another variation of my \"Cratered Planets\" shader, with valleys instead of craters.", "tags": ["procedural", "3d", "raymarching", "terrain", "planets"], "likes": 2, "viewed": 337, "published": 3, "date": "1596427733", "time_retrieved": "2024-07-30T20:52:44.432273", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 400;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0005;\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat sceneSDF1(vec3 p,float i) {\n    p += sin(p.yzx*i/100.0)*50.0/i;\n    //p += sin(p.yzx*20.0)/80.0;\n    return  (3.0 -sin(length(p/i))*i -.9/(i)+ sin(p.x)+cos(p.y)+cos(p.z))*2.9;\n}\n\nfloat sceneSDF2(vec3 p,int iterations){\n    float k = 1.0;\n    float to_return = sceneSDF1(p,k);\n    for(int i = 0; i < iterations; i++){\n        k *= 6.0;\n\n        to_return = min(to_return, to_return*1.5/k+sceneSDF1(p*k,k/5.0));\n    }\n    return to_return;\n}\n\nfloat sceneSDF2(vec3 p){\n\treturn sceneSDF2(p,2);\n}\n\nfloat sceneSDF(vec3 p){\n    p /= 100.0;\n    return sceneSDF2(p,1)-sceneSDF2((p.yzx)*(10.0+sceneSDF2(p*(20.0))*.01))*.01;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= 100.0;\n    vec3 c1 = vec3(sceneSDF2(p+p.yzx/2.0),sceneSDF2(p+p.zxy/2.0),sceneSDF2(p+p/2.0));\n    return (sin(c1))*vec3(.5)/(10.0)+vec3(.5, .4,.4);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    //viewDir.xz *= sin(iTime)/2.0+1.0;\n    \n    vec3 eye = vec3(5.0, 5.0, 5.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 2.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXfWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 492, 525, 525, 675], [677, 677, 716, 716, 937], [939, 939, 963, 963, 989], [991, 991, 1014, 1014, 1113], [1115, 1115, 1143, 1143, 1301], [1303, 1724, 1815, 1815, 2127], [2142, 2396, 2461, 2461, 2593], [2595, 2684, 2713, 2713, 3023], [3025, 3517, 3657, 3657, 4247], [4249, 4619, 4704, 4704, 5062], [5064, 5391, 5440, 5475, 5606], [5608, 5608, 5665, 5665, 6788]], "test": "untested"}
{"id": "3tfBWr", "name": "Fluid Reaction", "author": "wyatt", "description": "Cool reaction from combining forces from 2 substances. ", "tags": ["fluid"], "likes": 14, "viewed": 472, "published": 3, "date": "1596424160", "time_retrieved": "2024-07-30T20:52:45.274022", "image_code": "// Fork of \"4-Substance\" by wyatt. https://shadertoy.com/view/3lffzM\n// 2020-08-03 02:14:45\n\n// Fork of \"Multi-Substance\" by wyatt. https://shadertoy.com/view/WtffRM\n// 2020-08-01 02:57:11\n\nMain {\n    vec4\n        n = A(U+vec2(0,1))+B(U+vec2(0,1))+C(U+vec2(0,1))+D(U+vec2(0,1)),\n        e = A(U+vec2(1,0))+B(U+vec2(1,0))+C(U+vec2(1,0))+D(U+vec2(1,0)),\n        s = A(U-vec2(0,1))+B(U-vec2(0,1))+C(U-vec2(0,1))+D(U-vec2(0,1)),\n        w = A(U-vec2(1,0))+B(U-vec2(1,0))+C(U-vec2(1,0))+D(U-vec2(1,0));\n    vec3 norm = \n        normalize(vec3(e.z*e.w-w.z*w.w,n.z*n.w-s.z*s.w,10)),\n        ref = reflect(vec3(0,0,-1),norm);\n   \n\tvec4 a = A(U), b = B(U), c = C(U), d = D(U);\n    Q = vec4(a.w,b.w,c.w,1)+d.w;\n    Q.xyz *= 1.8*mat3(.3,.5,.5,.3,.7,.2,.5,.6,.3);\n\tQ *= 1.+0.5*norm.x;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n            #define r 1.2\n#define N 15.\n#define S vec4(4,7,1,1)\n#define Gaussian(i) 0.3989422804/S*exp(-.5*(i)*(i)/S/S)\n", "buffer_a_code": "Main {\n    if (iFrame%2<1) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,.1,0);\n            if (length(U-vec2(0.5)*R)<.3*R.y)Q.w = .8;\n        }\n        if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.xw = vec2(.25,.3);\n        if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n    } else {\n    \tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u), d = D(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.125*(d.y+d.x+a.w*(a.w-.8))*u;\n    }\n    if (Q.w < 1e-3) Q.z *= 0.;\n    Q.y -= 1e-4*step(1e-3,Q.w);\n    Q.xy *= 0.999;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    if (iFrame%2<1) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,.1,0);\n            if (length(U-vec2(0.5)*R)<.3*R.y)Q.w = .8;\n        }\n        if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.xw = vec2(.25,.3);\n        if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n    } else {\n    \tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u), d = D(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.125*(d.x-.01*b.w+d.y+a.w*(a.w-1.))*u;\n        Q.xy -= q.w*0.125*(abs(q.z)*a.z)*vec2(-u.y,u.x);\n        Q.z  -= q.w*0.125*a.w*(dot(vec2(-u.y,u.x),a.xy-q.xy));\n    }\n    if (Q.w < 1e-3) Q.z *= 0.;\n    Q.y -= 1e-3*step(1e-3,Q.w);\n    Q.xy *= 0.999;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = vec4(0);\n    for (float i = -N; i <= N; i++) {\n    \tvec4 a = A(U+vec2(i,0)),\n             b = B(U+vec2(i,0));\n        Q += Gaussian(i)*vec4(a.w,b.w,0,0);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ = vec4(0);\n    for (float i = -N; i <= N; i++) {\n        Q += 2.*Gaussian(i)*A(U+vec2(0,i));\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfBWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WlffDn", "name": "Tubularity", "author": "Mipmap", "description": "Tweak #2 of Band Limited Synthesis 2 [url]https://www.shadertoy.com/view/wtXfRH[/url] by Inigo Quilez", "tags": ["2d", "cos", "filtering", "lod", "frequency", "bandlimited"], "likes": 18, "viewed": 674, "published": 3, "date": "1596420186", "time_retrieved": "2024-07-30T20:52:46.120758", "image_code": "// Tweak #2 of Band Limited Synthesis 2 https://www.shadertoy.com/view/wtXfRH by Inigo Quilez\n\n// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. \n//\n// Function fcos() is a band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)∫cos(t)dt with t ∈ (x-½w, x+½w)\n// = [sin(x+½w) - sin(x-½w)]/w\n// = cos(x)·sin(½w)/(½w)\n//\n// Can approximate smoothstep(2π,0,w) ≈ sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/articles/bandlimiting\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\nvec3 fcos( vec3 x )\n{\n    vec3 w = fwidth(x);\n    return cos(x) * smoothstep(3.14*2.0,0.0,w); // filtered-approx\n }\n\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.3,0.4,0.5);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.10*fcos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.10*fcos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.10*fcos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 w = p;\n        \n    // deform 1\n    p *= 0.25;\n    p = 0.5*p/dot(p,p);\n    vec2 q = p;\n    p.x += iTime*0.2;\n    \n    \n    // base color pattern\n    vec3 col = getColor( 0.4*length(p) );\n    \n    // lighting\n    col *= 1.4 - 0.07*length(q);\n \n   fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlffDn.jpg", "access": "api", "license": "mit", "functions": [[1923, 1923, 1944, 1944, 2038], [2040, 2040, 2069, 2069, 2577], [2579, 2579, 2635, 2654, 2997]], "test": "untested"}
{"id": "3tlBRr", "name": "Another blue noise gen", "author": "michael0884", "description": "yeah", "tags": ["noise"], "likes": 6, "viewed": 465, "published": 3, "date": "1596407639", "time_retrieved": "2024-07-30T20:52:46.991430", "image_code": "const float ITER = 36.;\nconst float FREQ = 0.7*3.14159;\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//a wave with its gradient\nvec4 sinC(vec2 uv, float freq, float i)\n{\n    vec2 ang = 2.*3.14159*hash21(i+ITER*float(iFrame/60));\n \tvec2 k = vec2(sin(ang.x), cos(ang.x));\n    float x = freq*dot(uv,k)  - ang.y;\n    float amp = 1.;//pow(freq, -3.5);\n    float H = amp*sin(x);\n    float Hdx = amp*cos(x);\n    return vec4(H, Hdx*k*freq, 0.3*amp);\n}\n\nvec3 map(vec2 uv) {\n    float freq = FREQ;\n    float amp = 1.;\n\n    vec4 h = vec4(0.0);\n    for(float i = 0.; i < ITER; i++) \n    {        \n        h += sinC(uv, freq, i);\n    \tfreq *= 1.0 + 0.3/ITER;\n    }\n    return 0.5*h.xyz/h.w + 0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //pixel coordinates\n    vec2 p = 0.4*fragCoord;\n\n    vec3 wave = map(p);\n    \n    if(iMouse.z > 0.)\n    {\n    \tif(iMouse.x > fragCoord.x) \n       \t\t wave = texture(iChannel0, p/1024.).xyz;\n    }\n    else\n        if(fragCoord.x < 0.5*iResolution.x) \n       \t\t wave = texture(iChannel0, p/1024.).xyz;\n        \n        \n    fragColor = vec4(wave.xxx,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 79, 79, 207], [209, 236, 277, 277, 551], [553, 553, 572, 572, 793], [796, 796, 853, 877, 1212]], "test": "untested"}
{"id": "3tsBR7", "name": "Flashlight Chase", "author": "granito", "description": "Using small number of radial shapes and stochastic position offsets to simulate volumetric lighting effect. Biggest drawback to this technique is that shadow casting is not possible. ", "tags": ["fast", "light", "cheap", "dither", "volumetric", "cone", "hack", "bluenoise", "performant"], "likes": 22, "viewed": 816, "published": 3, "date": "1596403709", "time_retrieved": "2024-07-30T20:52:47.762369", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = iTime + 2.5; \n    vec2 uv = fragCoord/iResolution.xy;\n    float bnoise;\n    \n    if (dithering == true)\n    { bnoise = fract( texture( iChannel0, fragCoord/1024.).x + T ); } //animated bluenoise pattern}\n    else\n    { bnoise = 0.5; }\n    \n    //3d camera\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize( vec3(p,-2.0) );\n    vec3 ro = vec3(0.0, 0.0, 5.0 );\n    \n    //running animation\n    float runtransition = smoothstep( 0., 1., sin(T*0.3));\n    float runadvancement = -cos(T*0.3) *1.2;\n    float runpos = abs(sin(T * 9.0)) * runtransition * 0.25;\n    float runrot = sin(T * 9.0 * 2. + 0.5) * runtransition * runtransition * 0.15 - 0.6;\n    float sway = cos(T * 9.0 + 0.5) * runtransition * runtransition * runtransition * 0.1;\n    \n    //flashlight setup\n    vec3 conepos = vec3(-0.3, runpos, runadvancement * 2.0 + 1.0);\n    vec3 conedirection;\n    conedirection = mix( normalize( vec3(sin(T),cos(T*0.6),-cos(T*0.3)+0.4) + vec3(cos(T*2.6),sin(T*2.2),-sin(T*2.3))*0.6 ), vec3(0., runrot, 0.), vec3(runtransition) );\n    float conelength = 2.0;\n    float coneangle = 1.1;\n    \n    //draw eyes\n    float eyes = draweye(ro, rd, conepos + vec3(0.25,0.75,-0.5) ) + draweye(ro, rd, conepos + vec3(0.4,0.75,-0.5) ) ;\n    eyes *= round(fract(T*0.45)+0.4);\n    \n    //add sway motion\n    conepos += mix( vec3(0.), vec3(sway, 0., 0.), vec3(runtransition) );\n    conedirection += vec3(sway, 0., 0.);\n    \n    //draw flashlight/volume light\n    float source = drawsource(ro, rd, conepos);\n    float cone = drawcone(ro, rd, conepos, conedirection, conelength, coneangle, bnoise);\n\n    //composite/color\n    fragColor = vec4(aces( vec3(source + cone) * vec3(0.7,0.9,1.) + vec3(eyes) * vec3(1.,0.,0.)   ) ,1.);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nint iterations = 8;\nbool dithering = true;\n\n\nfloat saturate (float x) { return clamp(x, 0., 1.); }\n\nvec3 aces(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nfloat distline(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd));\n}\n\nfloat draweye (vec3 ro, vec3 rd, vec3 cp)\n{\n    float shape = 1. - saturate(distline(ro, rd, cp) * 125.  );\n    return shape * 10.;\n}\n\nfloat drawsource (vec3 ro, vec3 rd, vec3 cp)\n{\n    float shape = 1. - saturate(distline(ro, rd, cp) * 25.  );\n    return (pow(shape,8.) * 40. + shape) * 2.;\n}\n\nfloat drawcone (vec3 ro, vec3 rd, vec3 cp, vec3 cd, float cl, float ca, float dither)\n{\n    float radialshapes;\n    float increment = 1. / float(iterations);\n    float spacing = cl * increment;\n    \n    for(int x = 0; x < iterations - 1; x++) //radialshapes\n    {\n        float iter = max( float(x) + (dither * 2. - 1.0) * 1.0, 0.001); // add dithering (hide iteration)\n        float localpos = iter * spacing; //distance along forward vector of cone\n        vec3 spos = localpos * cd + cp;\n        float ssize = ( max((2. * localpos), iter) / tan(ca) ) ; // isosceles base length\n    \tfloat shape = 1. - saturate( distline(ro, rd, spos) / ssize );\n        shape *= shape;\n        shape *= (1. / iter) * (1. / iter);\n        radialshapes += shape;\n    }\n    return radialshapes;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 1853]], "test": "untested"}
{"id": "tllfR7", "name": "sinus0", "author": "pohy", "description": "sinus0", "tags": ["sinus0"], "likes": 0, "viewed": 195, "published": 3, "date": "1596389918", "time_retrieved": "2024-07-30T20:52:48.537298", "image_code": "#define PI 3.14159\n\nvec2 rot(vec2 v, float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * .5 + .5) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col;// = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float size = .1;\n    vec2 pos = uv - vec2(sin(iTime), cos(iTime)) * .2;\n    pos = rot(pos, PI * sin(iTime));\n    float d = distance(pos, vec2(clamp(pos.x, -size, size), clamp(pos.y, -size, size)));\n    d = smoothstep(.01, .0, d);\n    \n    //col += d;\n    col += texture(iChannel0, pos).rgb * d;\n    //col.rg += uv; \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 47, 47, 140], [142, 142, 199, 249, 794]], "test": "untested"}
{"id": "ttsfRN", "name": "Interactive Orbit Cam - Template", "author": "AmarnathMurugan", "description": "This is a basic orbit camera created for my reference and later use. Feel free to use it in your shaders and let me know if this can be optimized further.\n\nControls : \nZ/X - Zoom\nArrow Keys: Orbit\n", "tags": ["interactive", "camera"], "likes": 1, "viewed": 497, "published": 3, "date": "1596375594", "time_retrieved": "2024-07-30T20:52:49.306242", "image_code": "//Changes zoom level\n#define FocalDistance 2.0 \n\n//Classic sphere hit fuction that returns white on hit or the background otherwise\n\nvec4 SphereHit(const in vec3 ro, const in vec3 rd)\n{\n\tfloat R = 0.1;\n    float b = 2.0 * dot(rd, ro);\n    float c = dot(ro.xyz, ro)- R*R;\n    float d = b*b - 4.0*c;\n\n\tif(d >= 0.0)\n        return vec4(1.0);\n    else \n        return texture(iChannel1,normalize(rd));\n}\n\n\n//==== Transformtion Matrices ===\n\nmat3 RotateY(float theta)\n{\n    float Cos = cos(theta);\n    float Sin = sin(theta);\n\treturn mat3(Cos,0.0,Sin,\n                0.0,1.0,0.0,\n                -Sin,0.0,Cos);\n}\n\nmat3 RotateX(float theta)\n{\n    float Cos = cos(theta);\n    float Sin = sin(theta);\n\treturn mat3(1.0,0.0,0.0,\n                0.0,Cos,-Sin,\n                0.0,Sin,Cos);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy-0.5;\n\tuv.x*= iResolution.x/iResolution.y;\n    //Get data from buffer\n    vec4 transform = texelFetch(iChannel0,ivec2(0,0),0);     \n    //Calculate the origin with transform data, here the z value is used to set the distance\n    vec3 ro = RotateY(transform.x) * RotateX(-transform.y) * vec3(0.0,0.0,-transform.z);\n    //usual look at calculation\n \tvec3 lp = vec3(0.0);\n    vec3 forward = normalize(lp-ro);\n    vec3 GlobalUp = vec3(0.0,1.0,0.0);\n    vec3 right = normalize(cross(forward,GlobalUp));\n    vec3 localUp = cross(right,forward);    \n    vec3 rd = (ro+forward*FocalDistance) + uv.x * right + uv.y * localUp - ro;    \n    fragColor = SphereHit(ro,normalize(rd));\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.1415926538\nconst int KEY_Z  = 90;\nconst int KEY_X  = 88;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nvec3 offset = vec3(0.0);\n//Used to set the initial offset\nvec3 initOffset = vec3(0.0,0.0,2.5);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    offset = texelFetch(iChannel0,ivec2(0,0),0).xyz; \n    //sets the offset value to initial offset when the program starts\n    if(iTime<0.1) offset = initOffset;    \n    offset.x+= (texelFetch(iChannel1,ivec2(KEY_RIGHT,0),0).x - texelFetch(iChannel1,ivec2(KEY_LEFT,0),0).x)*0.02 ;\n    offset.y+= (texelFetch(iChannel1,ivec2(KEY_UP,0),0).x - texelFetch(iChannel1,ivec2(KEY_DOWN,0),0).x)*0.02 ; \n    //the added value is multiplied by the z value to make it faster over time\n    offset.z+= (texelFetch(iChannel1,ivec2(KEY_X,0),0).x - texelFetch(iChannel1,ivec2(KEY_Z,0),0).x)*0.02 * offset.z; \n    \n    //Change this value to determine x rotation clamping\n    float limit = PI/4.0;\n    offset.y = clamp(offset.y,-limit,limit);\n    //Change this value to fix minimum and maximum distance form lookat point\n    offset.z = clamp(offset.z,1.0,10.0);\n    fragColor = vec4(offset,1.0);\n} ", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[437, 437, 464, 464, 608], [610, 610, 637, 637, 781], [785, 785, 842, 842, 1557]], "test": "untested"}
{"id": "ttsfRM", "name": "Wet-Tunnel", "author": "EvilRyu", "description": "Try some wet ground...", "tags": ["reflection", "tunnel", "wet"], "likes": 33, "viewed": 972, "published": 3, "date": "1596374066", "time_retrieved": "2024-07-30T20:52:50.262684", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n#define PI 3.14159265359\n#define PI_2 6.2831\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (-iResolution.xy + 2. * fragCoord) / iResolution.y;\n    \n    #if 1\n    vec3 acc = vec3(0);\n    \n    vec4 res = texture(iChannel0, uv);\n    vec3 col = res.xyz;\n    \n    vec2 d = vec2(res.w) * 0.01;\n    for(int i = -2; i <= 2; ++i)\n    {\n        for(int j = -2; j <=2; ++j)\n        {\n            acc += textureGrad(iChannel0, uv + vec2(float(i), float(j)) * 0.5 / iResolution.xy, dFdx(d), dFdy(d)).xyz;\n        }\n    }\n    \n    float intensity = dot(acc, vec3(.13));\n    \n    \n    col.xyz += acc/16. * intensity * .99;\n    \n    #else\n        \n   \tvec3 col = texture(iChannel0, uv).xyz;\n    #endif\n    col=tonemap(col);\n\tcol=pow(clamp(col,0.,1.0),vec3(0.45));\n  \tcol=clamp(col*0.5+0.5*col*col*1.3,0.0,1.0);\n    col*=0.5+0.5*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.7);\n    \n\tfragColor.xyz = col.xyz;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n#define PI 3.1415926535\n\nfloat hash11(float p)\n{\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash12(vec2 p)\n{\n    p=fract(p*vec2(5.3983, 5.4427));\n    p+=dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(p.x * p.y * 95.4337);\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat box2D(vec3 p, vec2 b)\n{\n    vec2 d = abs(p.xy) - b;\n    return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\n\nfloat vline(vec3 p, float h, float r)\n{\n    p.y-=clamp(p.y, 0.0, h);\n    return length(p)-r;\n}\n\nvec3 tri(vec3 p)\n{\n    return abs(fract(p) - .5);\n}\n\nfloat triNoise(vec3 p)\n{\n    return dot(tri(p + .5 * tri(p.yzx * 1.3 + vec3(.3, .7, .1) + 0.25 * tri(p.zyx * 2.6))), vec3(0.3333));\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    vec2 uv = (p.xy + vec2(37.0, 17.0)*p.z)+f.xy;\n    vec2 rg = textureLod(iChannel0, (uv  + 0.5)/256., .0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nfloat sphere(vec3 p)\n{\n    return length(p) - 1.;\n}\n\nint mateID = 0;\nfloat glow0 = 0., glow1 = 0.;\nbool doGlow = false;\n\nfloat lights(vec3 p, float d)\n{\n    vec3 q = p;\n    q.x = abs(q.x) - 1.15;\n    q.z = mod(q.z, 2.) - 1.;\n    float d2 = vline(q.xzy, 0.6, 0.16);\n    \n    if(d2 < d)\n    {\n    \tmateID = 4;\n    \td = d2;\n        if(doGlow) glow0 += 0.2 / (0.15 + abs(d));\n    }\n    \n    q.x = p.x;\n    d2 = vline(q.xzy - vec3(0., 0., 1.), 0.4, 0.16);\n    if(d2 < d)\n    {\n        mateID = 4;\n        d = d2;\n        if(doGlow) glow1 += 0.2 / (0.15 + abs(d));\n    }\n    \n    return d;\n}\n\nfloat tunnel(vec3 p)\n{\n    mateID = 0;\n    float d0 = 1.- length(p.xy) + triNoise(p) * 0.2;\n    float d1 = abs(p.y + 0.65);\n    \n    if(d1 < d0)\n    {\n        mateID = 1;\n        d0 = d1;\n    }\n    \n    vec3 q = p * 6.;\n    \n    vec2 f = fract(q.xz);\n    vec2 l = floor(q.xz);\n    \n    //vec2 off = smoothstep(-1.,-0.9, f) - smoothstep(0.9, 1., f);\n    //d1 -= (off.x + off.y) * 0.01;\n    \n    q.xz = mod(q.xz, vec2(1., 1.1)) - vec2(.5, .55);\n    float d2 = box(q + vec3(0., 3.97, 0.), vec3(0.2, 0.1, 0.45)*.98) / 6. - .01*noise(p*25.);\n    \n    if(d2 < d0)\n    {\n        mateID = 1;\n        d0 = d2;\n    }\n    \n    q = p * 6.;\n    q.xz = mod(q.xz + vec2(0.5, 0.5), vec2(1., 1.1)) - vec2(.5, .55);\n    \n    d2 = box(q + vec3(0., 3.97, 0.), vec3(0.2, 0.1, 0.45)*.98) / 6. - .02*noise(p*15.);;\n    \n    if(d2 < d0)\n    {\n        mateID = 1;\n        d0 = d2;\n    }\n    \n    q = p;\n    q.x = abs(q.x) - .8;\n    d2 = box2D(q + vec3(0., .7, 0.), vec2(0.175 , 0.1));\n    \n    if(d2 < d0)\n    {\n        mateID = 2;\n        d0 = d2;\n    }\n    \n    \n   \td0 = lights(p, d0);\n    \n    return d0;\n}\n\nfloat map(vec3 p)\n{\n    float d0 = tunnel(p);\n    return d0;\n}\n\nfloat mapSimple(vec3 p)\n{\n    float d0 = 1.- length(p.xy) + triNoise(p) * 0.2;\n    d0 = lights(p, d0);\n\n    return d0;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    vec2 e = vec2(0.001 * t , 0.);\n    \n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\nfloat ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i = 1.0; i <5.0 + 1.1; i++)\n    {\n        d = i / 5.;\n        r += w * (d - map(p + n * d));\n        w *= 0.5;\n    }\n    return 1.0 - clamp(r, 0., 1.);\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p=floor(x);\n    vec2 f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float n=p.x + p.y*57.0;\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\n}\nconst mat2 m=mat2(0.8,0.6,-0.6,0.8);\n\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    f+=.5*noise(p); p=m*p*2.;\n    f+=.25*noise(p); p=m*p*2.;\n    f+=.125*noise(p); p=m*p*2.;\n    f+=.0625*noise(p); p=m*p*2.;\n    f+=.03125*noise(p);\n    return f/0.984375;\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nvec3 reflection(vec3 p, vec3 n, vec3 rd, vec3 ro)\n{\n    rd = reflect(rd, n);\n    \n    float t = 0.01, d = 0.;\n    \n    p += 0.001 * n;\n    \n    float glow = 0.;\n    \n    doGlow = true;\n    for(int i = 0; i < 32; ++i)\n    {\n        d = mapSimple(p + t * rd);\n        \n        if(d < 0.005 || t > 20.)\n        \tbreak;\n        \n        t += d;\n    }\n    doGlow = false;\n    \n    vec3 radi = vec3(1.);\n    if(t < 20.)\n    {\n        p = p + t * rd;\n        n = normal(p, t);\n        \n        vec3 PL0 = ro + vec3(0, 0.5, 2.);\n        vec3 w0 = normalize(PL0 - p);\n        vec3 L0 = vec3(1.);\n\n        float dif = max(0., dot(n, w0));\n        float bac = max(0., dot(n, -w0));\n        float amb = 0.5 + 0.5 * n.y;\n        float spe = 0.;\n        float att = length(PL0 - p);\n        att = 1. / (att + att * att);\n\t\t\n\n    \tvec3 mate = vec3(.7);\n\n        radi = (4. * dif + .5 * bac + .5 * amb) * mate * L0 * att + spe * L0 * .25;\n\n        \n        if(mateID == 0)\n        {\n            float rho = length(p.xy);\n            float phi = asin(p.y / rho);\n\n            vec3 cy = vec3(rho, phi, p.z) * 6.;\n\n            vec2 f = fract(cy.zy) * 2. - 1.;\n            vec2 l = floor(cy.zy);\n\n            float rnd = hash12(l);\n\n            if(rnd > 0.7) radi = mix(radi, vec3(2.), 1. - smoothstep(0.4, .5, length(f)));\n        }\n    }\n        \n  \tradi += glow0 * 0.06 * vec3(1.,.5,.2);\n    radi += glow1 * 0.02 * vec3(.0,.5,1.);\n    return radi;\n}\n\nfloat ggx(float roughness, vec3 rd, vec3 W, vec3 n)\n{\n    vec3 H = normalize(W - rd);\n    float NoH = max(0., dot(n, H));\n    vec3 NxH = cross(n, H);\n    float a = roughness * roughness;\n    float b = NoH * a;\n    float c = a / ((1. - NoH * NoH) + b * b);\n    float d = c * c;\n    return d;\n}\n\nfloat schlickFresnel(vec3 rd, vec3 l)\n{\n    vec3 h = normalize(-rd + l);\n    float EdotH = max(0., dot(-rd, h));\n    return pow(max(0.0, 1.0 - EdotH), 2.0);\n}\n\nvec3 shading(vec3 p, vec3 n, vec3 ro, vec3 rd)\n{\n    vec3 PL0 = ro + vec3(0, 0.5, 2.);\n    vec3 w0 = normalize(PL0 - p);\n    vec3 L0 = vec3(1.);\n    \n    \n    float reflective = .0;\n    float roughness = 1.;\n    \n    bool hasRefl = false;\n    \n    vec3 mate = vec3(.1);\n    \n    float water = 0.;\n    float fade = 1.;\n    \n    // road, a little wet by default\n    if(mateID == 1)\n    {\n        mate = vec3(.2);\n        n=bump_mapping(p * (5. + 0.001 * iResolution.x), n, 0.02);\n        \n        // water area\n        water = smoothstep(0.0, 0.7, fbm(p.xz * 5.));\n\n        // very wet area\n        float k = smoothstep(0.1,0.9, fbm(p.zx * 10.));\n \n        // fade the lighting for water\n        fade = mix(fade, 0.3, 1. - smoothstep(0.3, 0.6, water));\n        \n        roughness = 0.8;\n        hasRefl = true;\n        \n        if(water < 0.6)\n        {\n            reflective = .5;\n            roughness = .8;\n        }\n        else if(water > 0.85)\n        {\n            roughness = mix(roughness, 0.1,  1. - smoothstep(0.0,.5,k));\n            reflective = .3;\n        }\n    }\n        \n    float occ = ao(p, n);\n\n    float tmp = map(p);\n    float dif = max(0., dot(n, w0));\n    float bac = max(0., dot(n, -w0));\n    float amb = 0.5 + 0.5 * n.y;\n    float spe = ggx(roughness, rd, w0, n) * max(0., dot(n, w0));\n    float att = length(PL0 - p);\n    att = 1. / (att + att * att * 4.);\n    float fre = schlickFresnel(rd, w0);\n    \n    \n    vec3 diffuse = (4. * dif + .5 * bac + .5 * amb + fre*fre*fre*5.) * (mate - mate * reflective) * L0 * att;\n    vec3 specular = spe * L0 * .25;\n        \n    vec3 radi = (diffuse + specular) * fade;\n       \n    // dirty\n    radi = mix(radi * vec3(smoothstep(0.1, .8, pow(fbm(p.xz * 5.), 1.))), radi, smoothstep(-1.,0.0, p.y));\n    \n    radi *= occ;    \n    \n    // dots on the wall\n    if(mateID == 0)\n    {\n        float rho = length(p.xy);\n        float phi = asin(p.y / rho);\n        \n        vec3 cy = vec3(rho, phi, p.z) * 6.;\n        \n        vec2 f = fract(cy.zy) * 2. - 1.;\n        vec2 l = floor(cy.zy);\n        \n        float rnd = hash12(l);\n        \n        if(rnd > 0.7) radi = mix(radi, vec3(2.), 1. - smoothstep(0.4, .5, length(f)));\n    }\n    \n    // smooth the normal for water area\n    if(mateID == 1)\n    {        \n        n = mix(n, normalize(vec3(0.,1.,0)*.98 + n*0.02), 1. - smoothstep(0.5, 0.8, water));\n    }\n    else if(mateID == 4)\n        radi = vec3(1.);\n    \n    // mix with reflection\n    if(hasRefl)\n    {\n      \tradi = mix(radi,  reflection(p, n, rd, ro) * reflective, fre);\n    }\n\n    return radi * 0.32;\n}\n\nfloat depth = 0.;\n\nvec3 scene(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 col = vec3(0.);\n    float rnd = 0.9 + 0.1 * hash12(uv.xy);\n    \n    float t = 0.01, d = 1e10;\n    \n    doGlow = true;\n    for(int i = 0; i < 128; ++i)\n    {\n        d = abs(map(ro + t * rd)) * rnd;\n        if(d < 0.001 + 0.0002 * t || t > 50.)\n            break;\n        \n        t += d;\n    }\n    doGlow = false;\n    \n    \n    if(t < 50.)\n    {\n        vec3 p = ro + t * rd;\n        vec3 n = normal(p, t);\n        col = shading(p, n, ro, rd);\n    }\n    \n    depth = t;\n    \n    col += glow0 * 0.03 * vec3(1.,.5,.2);\n    col += glow1 * 0.02 * vec3(.0,.5,1.);\n    col=mix(col, vec3(0.), 1.-exp(-.04*t*t));\n\n    return col;\n}\n\n\nmat3 cam(vec3 ro, vec3 ta)\n{\n    vec3 f = normalize(ta - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(r, u, f);\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    \n    \n    float fov = 1.5;\n    \n    float time = iTime * 1.5;\n    \n    vec3 ro = vec3(0., -.25, iTime);\n    vec3 ta = ro + vec3(0., 0., 1.);\n    \n    // debugging camera\n    float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    if(iMouse.z>0.||iMouse.w>0.)\n        ro=vec3(0.,0,-2)+vec3(cos(y_rot)*cos(x_rot),cos(y_rot)*cos(x_rot),cos(y_rot)*sin(x_rot))*1.;\n     \n    vec3 rd = normalize(cam(ro, ta) * vec3(p.x, p.y, fov));\n    \n    vec3 col = scene(ro, rd, p);\n    fragColor = vec4(col, depth);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfRM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[158, 158, 181, 181, 277], [278, 278, 335, 335, 1189]], "test": "untested"}
{"id": "ttlfRM", "name": "Floating color bubbles", "author": "avin", "description": "Visual experiment", "tags": ["circles", "colors", "depth", "focus"], "likes": 52, "viewed": 1280, "published": 3, "date": "1596372589", "time_retrieved": "2024-07-30T20:52:51.025644", "image_code": "#define TOTAL_LAYERS 12.0 \n\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n { \n    vec2 uv = (fragCoord.xy) / iResolution.x + vec2(100.);    \n                             \n    vec3 col = vec3(0.); \n        \n     \n    for(float layer =1.; layer <= TOTAL_LAYERS; layer++ ) {\n    \n        float SIZE = (17. - layer) * .5;\n        vec2 luv = uv * SIZE;\n    \tvec2 id = floor(luv);\n    \tluv = fract(luv) - 0.5;\n                       \n        for(float y =- 1.0; y <= 1.0; y++ ) {\n        \tfor(float x =- 1.0; x <= 1.0; x++ ) {\n                vec2 rid = id - vec2(x, y);\n\n                float rFactor1 = hash12(rid + 542. * layer);\n                float rFactor2 = hash12(rid + 159. * layer);\n                \n                float t = iTime*5.5/(10. + layer*5./rFactor1) + 100. * rFactor2;\n\n                vec2 ruv = luv + vec2(x, y) +                 \n                    vec2(\n                        sin(iTime*.1 + t + rFactor1),\n                        sin(iTime*.2 + t*.9 + rFactor2)                    \n                    );            \n\n                float l = length(ruv);            \n                float ld = length(ruv - vec2(.075));  \n                \n                float SF = 1./min(iResolution.x,iResolution.y)*SIZE*(layer*2.);\n\n                float d = smoothstep(SF,-SF,l-(.125 + hash12(rid + 700.)*.25));      \n\n                // Remove some bubbles to make breath space\n                d *= step(hash12(rid*75.4 + 100.), .5 + (layer/TOTAL_LAYERS));\n\n                // Determine bubble color factor\n                float colFactor = hash12(rid + 500.); // + iTime*.1;\n\n                vec3 iCol = hue(colFactor).rgb * d * (.7 + smoothstep(.1,.5,ld)*1.);\n\n                col = col + iCol*(.25 + (1. - layer/TOTAL_LAYERS)*.2); \n            \n        \t}\n    \t}                \n    }\n     \n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 131, 131, 251], [254, 254, 310, 310, 2086]], "test": "untested"}
{"id": "tlXBz7", "name": "My take on chrisloop's TronNoise", "author": "toomuchvoltage", "description": "This is my take on Christopher Sims's Tron Noise... built from scratch to fit in a Shadertoy. Did not look at the source code and simply started from the output on Twitter. The original is to be found here: https://github.com/chrisloop/TronNoise", "tags": ["noise", "tron", "chrisloop"], "likes": 26, "viewed": 734, "published": 3, "date": "1596370643", "time_retrieved": "2024-07-30T20:52:51.975106", "image_code": "/***********************************************************\n\n   My take on Christopher Sims' Tron Noise without looking at the source! ;)\n   Reference: https://twitter.com/csims314/status/1288964499387678727\n\t\t\t  https://github.com/chrisloop/TronNoise\n   All noise is modified iq noise : https://www.shadertoy.com/view/Msf3WH\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture (iChannel0, uv) + texture (iChannel1, uv) * 2.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/***********************************************************\n\n   My take on Christopher Sims' Tron Noise without looking at the source! ;)\n   Reference: https://twitter.com/csims314/status/1288964499387678727\n\t\t\t  https://github.com/chrisloop/TronNoise\n   All noise is modified iq noise : https://www.shadertoy.com/view/Msf3WH\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat remap(float value, float low1, float high1, float low2, float high2)\n{\n    return clamp (low2 + (value - low1) * (high2 - low2) / (high1 - low1), low2, high2);\n}\n\nfloat hatch(vec2 uv, vec2 scrUV, float inpTime)\n{\n    float inp = (noise ((floor (scrUV) + vec2(inpTime)) * 0.3333) + 1.0) * 0.5;\n    float inp2 = (noise (( floor (scrUV * 0.1) + vec2(inpTime * 0.5 + 150.0)) * 0.3333) + 1.0) * 0.5;\n    inp2 = remap (inp2, 0.3, 1.0, 0.0, 1.0);\n    inp = mix (inp, 0.5, pow (inp2 * 18.0, 0.6));\n\n    if ( inp > 0.9 )\n    {\n        if (abs (uv.x - uv.y) < 0.1)\n        {\n            if ( length(uv - vec2 (0.5)) < 0.707 * (inp - 0.9) * 10.0 ) return 1.0;\n            else return 0.0;\n        }\n        else return 0.0;\n    }\n    else if ( inp < 0.1 )\n    {\n        if (abs ((1.0 - uv.x) - uv.y) < 0.1)\n        {\n            if ( length(uv - vec2 (0.5)) < 0.707 * (1.0 - inp * 10.0) ) return 1.0;\n            else return 0.0;\n        }\n        else return 0.0;\n    }\n    else\n        return 0.0;\n}\n\nfloat hatch2(vec2 uv, vec2 scrUV)\n{\n    return hatch (uv, scrUV, iTime + 200.0) + \n\t\t   hatch (uv + vec2(0.5, -0.5), scrUV, iTime + 300.0) +\n\t\t   hatch (uv + vec2(-0.5, 0.5), scrUV, iTime + 400.0) +\n\t\t   hatch (uv + vec2(-0.5, -0.5), scrUV, iTime + 500.0) +\n\t\t   hatch (uv + vec2(0.5, 0.5), scrUV, iTime + 600.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float whr = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy * vec2 (whr, 1.0) * 40.0;\n    \n    float noiseVal = clamp (hatch2(fract (uv), uv), 0.0, 1.0);\n    float colorVal = (noise(uv / 75.0) + 1.0) * 0.5;\n    vec3 outCol = mix (vec3 (1.0, 0.5, 0.5), vec3 (1.0, 0.5, 1.0), colorVal) * noiseVal;\n\n    fragColor = vec4(outCol,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "/***********************************************************\n\n   My take on Christopher Sims' Tron Noise without looking at the source! ;)\n   Reference: https://twitter.com/csims314/status/1288964499387678727\n\t\t\t  https://github.com/chrisloop/TronNoise\n   All noise is modified iq noise : https://www.shadertoy.com/view/Msf3WH\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pixelWH = 1.0/iResolution.xy;\n\n    vec4 finalRes = vec4(0.0);\n    float totalW = 0.0;\n    for (int i = -5; i != 6; i++)\n    {\n        vec4 neighFetch = texture (iChannel0, uv + vec2 (0.0, float(i) * pixelWH.y));\n        finalRes += neighFetch;\n    }\n\tfinalRes /= 11.0;\n    \n    fragColor = finalRes;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/***********************************************************\n\n   My take on Christopher Sims' Tron Noise without looking at the source! ;)\n   Reference: https://twitter.com/csims314/status/1288964499387678727\n\t\t\t  https://github.com/chrisloop/TronNoise\n   All noise is modified iq noise : https://www.shadertoy.com/view/Msf3WH\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pixelWH = 1.0/iResolution.xy;\n\n    vec4 finalRes = vec4(0.0);\n    float totalW = 0.0;\n    for (int i = -5; i != 6; i++)\n    {\n        vec4 neighFetch = texture (iChannel0, uv + vec2 (float(i) * pixelWH.x, 0.0));\n        finalRes += neighFetch;\n    }\n\tfinalRes /= 11.0;\n    \n    fragColor = finalRes;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXBz7.jpg", "access": "api", "license": "mit", "functions": [[1774, 1774, 1831, 1831, 1951]], "test": "untested"}
{"id": "3lsfz7", "name": "many circles", "author": "butadiene", "description": "many rings", "tags": ["raymarching"], "likes": 2, "viewed": 270, "published": 3, "date": "1596365198", "time_retrieved": "2024-07-30T20:52:52.805884", "image_code": "#define time iTime\n#define resolution iResolution\n  float pi = 3.1415926535;\n  mat2 rot(float r){\n      return mat2(cos(r),sin(r),-sin(r),cos(r));\n  }\n  \n  float cube(vec3 p,vec3 s){\n      vec3 q = abs(p);\n      vec3 m = max(s-q,0.0);\n      return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n  }\n\n  float ring(vec3 p,float r,vec2 s){\n      vec2 q = abs(vec2(length(p.xz)-r,p.y));\n      vec2 m = max(s-q,0.);\n      return length(max(q-s,0.))-min(m.x,m.y);\n  }\n  float rings(vec3 p){\n      float cd = length(p.xz)-6.;\n      vec2 skr = vec2(length(p.xz),atan(p.x,p.z));\n      for(int i =0;i<4;i++){\n          float fi =float(i);\n          float es = skr.x-9.2/pow(2.,fi);\n          skr.x = abs(es);\n          skr.y += (fi+2.)*0.1*sign(es)*(time);\n      }\n      p.xz = skr.x*vec2(cos(skr.y),sin(skr.y));\n      float d2 = ring(p,0.2,vec2(0.2,0.3));\n      p -= vec3(0.3,0,0);\n      p.xz *= rot(pi/4.);\n      d2 = max(d2,-cube(p,vec3(0.3,0.5,0.3)));\n      d2 = max(d2,-cd);\n      return d2;\n  }\nfloat dist(vec3 p){\n\n  return rings(p);\n}\nvec3 gn (vec3 p){\n  vec2 e = vec2(0.0001,0.0);\n  return normalize(vec3(\n    dist(p+e.xyy)-dist(p-e.xyy),\n    dist(p+e.yxy)-dist(p-e.yxy),\n    dist(p+e.yyx)-dist(p-e.yyx)\n    ));\n}\nvec3 lighting(vec3 p,vec3 rd){\n  vec3 n = gn(p);\n  vec3 ld = normalize(vec3(0.2,0.1,1.0));\n  float ndl = max(dot(n,ld),0.0);\n  vec3 R = normalize(-ld+2.0*n*ndl);\n  float spec = pow(max(dot(-rd,R),0.0)*sign(ndl),10.0);\n  vec3 col = vec3(0.8*ndl+spec)+0.1;\n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = (fragCoord.xy * 2. - resolution.xy) / min(resolution.x, resolution.y);\n    float kt =time*0.+1.;\n    float ra =25.0;\n    vec3 ro =vec3(ra*cos(kt),10,ra*sin(kt));\n    vec3 ta =vec3(0.,0,0.);\n    vec3 cdir =normalize(ta-ro);\n    vec3 up =vec3(0.,1.,0.);\n    vec3 side= cross(cdir,up);\n    up = cross(side,cdir);\n    float fov =3.0;\n    vec3 rd =normalize(side*p.x+up*p.y+fov*cdir);\n    float d;\n    float t =1.001;\n    float hit =0.001;\n    for(int i=0;i<99;i++){\n      d = dist(ro+rd*t);\n      t+=d;\n      if(hit>d||t>1000.)break;\n    }\n    vec3 col =vec3(0.);\n    if(hit>d){\n      col = lighting(ro+rd*t,rd);\n    }\n    fragColor = vec4(col,1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 97, 97, 150], [156, 156, 182, 182, 294], [298, 298, 332, 332, 457], [460, 460, 480, 480, 986], [987, 987, 1006, 1006, 1028], [1029, 1029, 1046, 1046, 1208], [1209, 1209, 1239, 1239, 1479], [1480, 1480, 1537, 1537, 2198]], "test": "untested"}
{"id": "3lffzM", "name": "4-Substance", "author": "wyatt", "description": "Forward advected compressible fluid simulation with four repulsive substances.", "tags": ["fluid"], "likes": 39, "viewed": 1401, "published": 3, "date": "1596251112", "time_retrieved": "2024-07-30T20:52:53.677554", "image_code": "// Fork of \"Multi-Substance\" by wyatt. https://shadertoy.com/view/WtffRM\n// 2020-08-01 02:57:11\n\nMain {\n    vec4\n        n = A(U+vec2(0,1))+B(U+vec2(0,1))+C(U+vec2(0,1))+D(U+vec2(0,1)),\n        e = A(U+vec2(1,0))+B(U+vec2(1,0))+C(U+vec2(1,0))+D(U+vec2(1,0)),\n        s = A(U-vec2(0,1))+B(U-vec2(0,1))+C(U-vec2(0,1))+D(U-vec2(0,1)),\n        w = A(U-vec2(1,0))+B(U-vec2(1,0))+C(U-vec2(1,0))+D(U-vec2(1,0));\n    vec3 norm = \n        normalize(vec3(e.z*e.w-w.z*w.w,n.z*n.w-s.z*s.w,10)),\n        ref = reflect(vec3(0,0,-1),norm);\n   \n\tvec4 a = A(U), b = B(U), c = C(U), d = D(U);\n    Q = vec4(a.w,b.w,c.w,1)+d.w;\n    Q.xyz *= 1.8*mat3(.3,.5,.5,.3,.7,.2,.5,.6,.3);\n\tQ *= 1.+0.5*norm.x;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n            #define r 1.3", "buffer_a_code": "Main {\n    if (iFrame%2<1) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,.1,0);\n            if (length(U-vec2(0.5)*R)<.3*R.y)Q.w = .8;\n        }\n        if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.xw = vec2(.25,.3);\n        if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n    } else {\n    \tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u), c = C(U+u), d = D(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.25*a.w*(a.w*a.z-1.)*u;\n        Q.xy -= q.w*0.25*b.w*(b.w*b.z+3.)*u;\n        Q.xy -= q.w*0.25*c.w*(c.w*c.z+3.)*u;\n        Q.xy -= q.w*0.25*d.w*(d.w*d.z+3.)*u;\n    \tQ.z -= q.w*0.25*a.w*(dot(u,a.xy-q.xy));\n    }\n    if (Q.w < 1e-3) Q.z *= 0.;\n    Q.y -= 1e-3*step(1e-3,Q.w);\n    Q.xy *= 0.999;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    if (iFrame%2<1) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,.1,0);\n            if (length(U-vec2(0.5)*R)<.3*R.y)Q.w = .8;\n        }\n        if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.xw = vec2(.25,.3);\n        if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n    } else {\n    \tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u), c = C(U+u), d = D(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.25*a.w*(a.w*a.z-1.)*u;\n        Q.xy -= q.w*0.25*b.w*(b.w*b.z+3.)*u;\n        Q.xy -= q.w*0.25*c.w*(c.w*c.z+3.)*u;\n        Q.xy -= q.w*0.25*d.w*(d.w*d.z+3.)*u;\n    \tQ.z -= q.w*0.25*a.w*(dot(u,a.xy-q.xy));\n    }\n    if (Q.w < 1e-3) Q.z *= 0.;\n    Q.y -= 1e-3*step(1e-3,Q.w);\n    Q.xy *= 0.999;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    if (iFrame%2<1) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,.1,0);\n            if (length(U-vec2(0.5)*R)<.3*R.y)Q.w = .8;\n        }\n        if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.xw = vec2(.25,.3);\n        if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n    } else {\n    \tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u), c = C(U+u), d = D(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.25*a.w*(a.w*a.z-1.)*u;\n        Q.xy -= q.w*0.25*b.w*(b.w*b.z+3.)*u;\n        Q.xy -= q.w*0.25*c.w*(c.w*c.z+3.)*u;\n        Q.xy -= q.w*0.25*d.w*(d.w*d.z+3.)*u;\n    \tQ.z -= q.w*0.25*a.w*(dot(u,a.xy-q.xy));\n    }\n    if (Q.w < 1e-3) Q.z *= 0.;\n    Q.y -= 1e-3*step(1e-3,Q.w);\n    Q.xy *= 0.999;\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    if (iFrame%2<1) {\n        Q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(U+u);\n            vec2 w1 = clamp(U+u+a.xy-0.5*r,U - 0.5,U + 0.5),\n                 w2 = clamp(U+u+a.xy+0.5*r,U - 0.5,U + 0.5);\n            float m = (w2.x-w1.x)*(w2.y-w1.y)/(r*r);\n            Q.xyz += m*a.w*a.xyz;\n            Q.w += m*a.w;\n        }\n        if (Q.w>0.)\n            Q.xyz/=Q.w;\n        if (iFrame < 1) \n        {\n            Q = vec4(0,0,.1,0);\n            if (length(U-vec2(0.5)*R)<.3*R.y)Q.w = .8;\n        }\n        if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q.xw = vec2(.25,.3);\n        if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n    } else {\n    \tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u), c = C(U+u), d = D(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.25*a.w*(a.w*a.z-1.)*u;\n        Q.xy -= q.w*0.25*b.w*(b.w*b.z+3.)*u;\n        Q.xy -= q.w*0.25*c.w*(c.w*c.z+3.)*u;\n        Q.xy -= q.w*0.25*d.w*(d.w*d.z+3.)*u;\n    \tQ.z -= q.w*0.25*a.w*(dot(u,a.xy-q.xy));\n    }\n    if (Q.w < 1e-3) Q.z *= 0.;\n    Q.y -= 1e-3*step(1e-3,Q.w);\n    Q.xy *= 0.999;\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lffzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtffRM", "name": "Multi-Substance", "author": "wyatt", "description": "Forward advected compressible fluid simulation with two repulsive substances.", "tags": ["fluid"], "likes": 37, "viewed": 914, "published": 3, "date": "1596241133", "time_retrieved": "2024-07-30T20:52:54.454476", "image_code": "Main {\n    vec4\n        n = A(U+vec2(0,1))+B(U+vec2(0,1)),\n        e = A(U+vec2(1,0))+B(U+vec2(1,0)),\n        s = A(U-vec2(0,1))+B(U-vec2(0,1)),\n        w = A(U-vec2(1,0))+B(U-vec2(1,0));\n    vec3 norm = \n        normalize(vec3(e.z*e.w-w.z*w.w,n.z*n.w-s.z*s.w,3)),\n        ref = reflect(vec3(0,0,-1),norm);\n   \n\tvec4 a = A(U), b = B(U);\n    Q = 1.2*(a.w+b.w)*sin(-2.1+3.*a.w*a.z+(b.w*b.z+.4)*vec4(1,2,3,4));\n    Q += 0.6*(Q+.4)*C(U+40.*(a.w+b.w)*norm.xy);\n\tQ *= 0.8+texture(iChannel3,ref);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n", "buffer_a_code": "Main {\n    Q = vec4(0);\n\tfor (int x = -1; x <= 1; x++)\n\tfor (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n    \tvec4 a = A(U+u);\n        #define q 1.125\n\t\tvec2 w1 = clamp(U+u+a.xy-0.5*q,U - 0.5,U + 0.5),\n             w2 = clamp(U+u+a.xy+0.5*q,U - 0.5,U + 0.5);\n        float m = (w2.x-w1.x)*(w2.y-w1.y)/(q*q);\n        Q.xyz += m*a.w*a.xyz;\n        Q.w += m*a.w;\n    }\n    if (Q.w>0.)\n    \tQ.xyz/=Q.w;\n    if (iFrame < 1) \n    {\n        Q = vec4(0,0,.1,0);\n        if (length(U/R-0.3)<0.2)Q.w = 1.;\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<10.) Q.xw = vec2(.5,.5);\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = vec4(0);\n\tfor (int x = -1; x <= 1; x++)\n\tfor (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n    \tvec4 a = A(U+u);\n        #define q 1.125\n\t\tvec2 w1 = clamp(U+u+a.xy-0.5*q,U - 0.5,U + 0.5),\n             w2 = clamp(U+u+a.xy+0.5*q,U - 0.5,U + 0.5);\n        float m = (w2.x-w1.x)*(w2.y-w1.y)/(q*q);\n        Q.xyz += m*a.w*a.xyz;\n        Q.w += m*a.w;\n    }\n    if (Q.w>0.)\n    \tQ.xyz/=Q.w;\n    if (iFrame < 1) \n    {\n        Q = vec4(0,0,.1,0);\n        if (length(U/R-0.7)<0.2)Q.w = 1.;\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<10.) Q.xw = vec2(.5,.5);\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n\n}", "buffer_b_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (x != 0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.125*a.w*(a.w*a.z-1.)*u;\n        Q.xy -= q.w*0.125*b.w*(b.w*b.z+1.)*u;\n    \tQ.z -= q.w*0.125*a.w*(dot(u,a.xy-q.xy));\n    }\n    if (Q.w < 1e-3) Q.z *= 0.;\n    Q.y -= 5e-4*Q.w;\n    Q.xy *= 0.999;\n   \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ = A(U);vec4 q = Q;\n    for (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (x != 0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u), b = B(U+u);\n        u = (u)/dot(u,u);\n        Q.xy -= q.w*0.125*a.w*(a.w*a.z-1.)*u;\n        Q.xy -= q.w*0.125*b.w*(b.w*b.z+1.)*u;\n    \tQ.z -= q.w*0.125*a.w*(dot(u,a.xy-q.xy));\n    }\n    if (Q.w < 1e-3) Q.z *= 0.;\n    Q.y -= 5e-4*Q.w;\n    Q.xy *= 0.999;\n   \n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtffRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
