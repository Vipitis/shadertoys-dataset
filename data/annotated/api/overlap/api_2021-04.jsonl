{"id": "sdjSRD", "name": "Closest Points - Bezier & Line", "author": "oneshade", "description": "A bit more challenging but this was one of my few successful attempts at analytic multivariable minimization with anything other than a paraboloid. Should work in 3D if you replace vec2s with vec3s. Now much more compact and efficient.", "tags": ["bezier", "line", "cubic", "quadratic", "points", "closest"], "likes": 16, "viewed": 341, "published": 3, "date": "1619814429", "time_retrieved": "2024-07-30T19:22:33.925806", "image_code": "void update(in vec2 a, in vec2 b, inout vec4 pair, inout float comp, inout bool init) {\n    vec2 ba = b - a; float comp2 = dot(ba, ba);\n    if (init ? (comp2 < comp) : true) { pair = vec4(a, b); comp = comp2; init = true; }\n}\n\n// Evaluates the parametric equation for a bezier curve\n// a(1 - t)^2 + 2b(1 - t)t + ct^2\nvec2 posBezier(in vec2 a, in vec2 b, in vec2 c, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv + b * 2.0 * t * tInv + c * t * t;\n}\n\n// Solves for the closest point on a bezier curve\nvec2 closestOnBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return posBezier(v1, v2, v3, root);\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec2 p1 = posBezier(v1, v2, v3, roots.x), c1 = p - p1;\n        vec2 p2 = posBezier(v1, v2, v3, roots.y), c2 = p - p2;\n        float d1 = dot(c1, c1), d2 = dot(c2, c2);\n        return d1 < d2 ? p1 : p2;\n    }\n}\n\nvec4 closestPointsBezierLine(in vec2 ba, in vec2 bb, in vec2 bc, in vec2 la, in vec2 lb) {\n    vec2 p = ba - 2.0 * bb + bc, q = 2.0 * (bb - ba), r = la - lb, s = ba - la;\n    float c1 = dot(p, p), c2 = 2.0 * dot(p, q), c3 = 2.0 * dot(p, s) + dot(q, q), c4 = dot(r, r),\n          c5 = 2.0 * dot(p, r), c6 = 2.0 * dot(r, q), c7 = 2.0 * dot(q, s), c8 = 2.0 * dot(r, s);\n\n    // Cubic coefficients\n    float a = 4.0 * c1 - c5 * c5 / c4;\n    float b = (3.0 * c2 - 1.5 * c5 * c6 / c4) / a;\n    float c = (2.0 * c3 - (c5 * c8 + 0.5 * c6 * c6) / c4) / a;\n    float d = (c7 - 0.5 * c6 * c8 / c4) / a;\n\n    // Solve for the x coordinate of the minima (cubic solving based on https://en.wikipedia.org/wiki/Cubic_equation)\n    float inflect = b / 3.0, denom = 2.0 * c4, bSq = b * b;\n    vec2 pq = vec2(c - bSq / 3.0, bSq * b / 13.5 - b * c / 3.0 + d);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float v1 = 1.5 / pq.x * pq.y;\n\n    vec4 pair; float comp; bool init;\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2), x, y;\n        if (pq.x < 0.0) x = sign(pq.y) * cosh(acosh(v2 * -sign(pq.y)) / 3.0);\n        else x = sinh(asinh(v2) / 3.0);\n        x = -2.0 * sqrt(p2 / 3.0) * x - inflect, y = -((c5 * x + c6) * x + c8) / denom;\n        if (x >= 0.0 && x <= 1.0 && y >= 0.0 && y <= 1.0) update(posBezier(ba, bb, bc, x), la - r * y, pair, comp, init);\n    }\n\n    else {\n        float ac = acos(v1 * sqrt(-3.0 / pq.x)) / 3.0, m = 2.0 * sqrt(-pq.x / 3.0);\n        float x1 = m * cos(ac                ) - inflect, y1 = -((c5 * x1 + c6) * x1 + c8) / denom;\n        if (x1 >= 0.0 && x1 <= 1.0 && y1 >= 0.0 && y1 <= 1.0) update(posBezier(ba, bb, bc, x1), la - r * y1, pair, comp, init);\n        float x2 = m * cos(ac - 2.09439510239) - inflect, y2 = -((c5 * x2 + c6) * x2 + c8) / denom;\n        if (x2 >= 0.0 && x2 <= 1.0 && y2 >= 0.0 && y2 <= 1.0) update(posBezier(ba, bb, bc, x2), la - r * y2, pair, comp, init);\n        float x3 = m * cos(ac - 4.18879020479) - inflect, y3 = -((c5 * x3 + c6) * x3 + c8) / denom;\n        if (x3 >= 0.0 && x3 <= 1.0 && y3 >= 0.0 && y3 <= 1.0) update(posBezier(ba, bb, bc, x3), la - r * y3, pair, comp, init);\n    }\n\n    // Minimize along the boundary (0, 0) --> (1, 0) --> (1, 1) --> (0, 1)\n    update(ba, la - r * clamp(dot(la - ba, r) / c4, 0.0, 1.0), pair, comp, init);\n    update(bc, la - r * clamp(dot(la - bc, r) / c4, 0.0, 1.0), pair, comp, init);\n    update(la, closestOnBezier(la, ba, bb, bc), pair, comp, init);\n    update(lb, closestOnBezier(lb, ba, bb, bc), pair, comp, init);\n\n    return pair;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    // Bezier control points\n    vec2 ba = vec2(c2, s3) * 0.5;\n    vec2 bb = vec2(s1, s2) * 0.5;\n    vec2 bc = vec2(c3, c1) * 0.5;\n\n    // Line control points\n    vec2 la = vec2(s2, c3) * 0.5;\n    vec2 lb = vec2(s3, c1) * 0.5;\n\n    float d = min(length(uv - closestOnBezier(uv, ba, bb, bc)), sdLine(uv, la, lb));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(280.0 * d);\n\n    // Lines between control points\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, sdLine(uv, ba, bb) - 0.002));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, sdLine(uv, bb, bc) - 0.002));\n\n    // Bezier curve\n\tcolor = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(d) - 0.002));\n\n    // Bezier control points\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - ba) - 0.015));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - bb) - 0.015));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - bc) - 0.015));\n\n    // Line control points\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - la) - 0.015));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - lb) - 0.015));\n\n    // Closest points\n    vec4 closest = closestPointsBezierLine(ba, bb, bc, la, lb);\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, length(uv - closest.xy) - 0.015));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, length(uv - closest.zw) - 0.015));\n\n    // Shortest segment between\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, closest.xy, closest.zw) - 0.002));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjSRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 87, 87, 225], [227, 317, 378, 378, 467], [469, 519, 588, 588, 1767], [1769, 1769, 1859, 1859, 4362], [4364, 4364, 4411, 4411, 4519], [4521, 4521, 4576, 4576, 6721]], "test": "untested"}
{"id": "7s2XRW", "name": "electronebula", "author": "Del", "description": "nebula effect - left mouse for alternate", "tags": ["voronoi", "fbm", "nebula"], "likes": 11, "viewed": 464, "published": 3, "date": "1619808984", "time_retrieved": "2024-07-30T19:22:34.867289", "image_code": "// electric nebula effect\n//#define PROCEDURAL_HASH\n\n#ifdef PROCEDURAL_HASH\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n#else\nvec3 hash33( vec3 x )\n{\n\treturn texture( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, -100.0 ).xyz;\n}\n#endif\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.05);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n#define TWO_PI 6.2831853\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float dd = length(uv*uv)*0.125;\n    \n\tvec3 rd = normalize(vec3(uv.x, uv.y, 3.141592/8.));\n    rd.xy *= rot(dd-iTime*.025);\n\t\n\tfloat c = noiseLayers(rd*2.25);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.35,3.5);    \n    \n    \n    vec3 col =  vec3(0.55,0.8,0.35);\n    vec3 col2 =  vec3(.85,0.85,1.4)*2.0;\n\n    if (iMouse.z>0.5)\n    {\n        col =  vec3(0.35,0.75,1.2);\n        col2 =  vec3(2.15,1.15,0.28)*8.0;\n    }\n    \n    \n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    //pulse = clamp(pulse,0.0,2.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    //col=vec3(pulse2);\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2XRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[424, 444, 466, 466, 863], [865, 878, 908, 908, 1181], [1183, 1183, 1204, 1204, 1272], [1300, 1300, 1357, 1357, 2139]], "test": "untested"}
{"id": "sdjSzW", "name": "Neopolitan", "author": "percentcer", "description": "Why decide on a flavor", "tags": ["wave", "sine"], "likes": 1, "viewed": 260, "published": 3, "date": "1619808916", "time_retrieved": "2024-07-30T19:22:35.875100", "image_code": "#define TAU 6.28\n#define WAVES 20\nfloat wave(vec2 uv, float a, float h, float c) {\n    float s = sin(uv.x * h * TAU) * 0.5 + 0.5 + sin(iTime+uv.x*5.+c*1.2);\n    s *= a;\n    return abs(s - (uv.y - c));\n}\nfloat map(vec2 uv, out int id) {\n    float d = 10000.;\n    for(int i = 0; i < WAVES; i++) {\n        float ipoke = float(i)*.01;\n        float amp = 0.1 + ipoke;\n        float per = 2. + ipoke;\n        float offs = -.5+ipoke * 10.;\n        float dd = wave(uv, amp, per, offs);\n        if (dd < d) {\n            id = i;\n            d = dd;\n        }\n    }\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float blocks = floor((sin(iTime)*.5+.5)*50.+5.);\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 cell = floor(uv * blocks)/blocks;\n    int mat = -1;\n    float w = map(cell, mat);\n    float d = step(0.,w);\n    vec3 baseCol = vec3(1,1,0);\n    for (int i = 0; i < mat; i++){baseCol = baseCol.yzx;}\n    vec3 col = vec3(d) * baseCol;\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjSzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 82, 82, 202], [203, 203, 235, 235, 572], [573, 573, 630, 630, 996]], "test": "untested"}
{"id": "fdjXzD", "name": "Instance ray tracing", "author": "me_123", "description": "This is test of my instancing ray tracer, In the scene there is 475 objects. the Instancing speeds it up about 4 times for 9 instances, i still am optimizing the compile time.", "tags": ["instance"], "likes": 5, "viewed": 462, "published": 3, "date": "1619800451", "time_retrieved": "2024-07-30T19:22:36.797634", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 d = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    fragColor = vec4(d.xyz/d.w, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define initInst temp t = temp(0.0, vec3(0), vec3(0.8)); state s=state(maxDist, normal, color);\n#define setObject if (t.tmp != -1.0&&t.tmp<s.d0) {s.d0 = t.tmp;s.normal = t.normal;s.color=t.color;}\nfloat hash3(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nconst float maxDist = 1000.;\nvec2 box(in vec3 ro, in vec3 rd, in vec3 boxSize, out vec3 normal) {\n    boxSize /= 2.0;\n    ro += boxSize;\n\tvec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return vec2(-1.0);\n    normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2(tN, tF);\n}\nbool bound(in vec3 ro, in vec3 rd, in vec3 boxSize) {\n    boxSize /= 2.0;\n    ro += boxSize;\n\tvec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return false;//return vec2(-1.0);\n    return true;\n}\nstruct TRI {\n\tvec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\nvec3 tri(in vec3 ro, in vec3 rd, in TRI a) {\n\tvec3 v1v0 = a.v1-a.v0;\n\tvec3 v2v0 = a.v2-a.v0;\n\tvec3 rov0 = ro-a.v0;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, rd);\n    float d = 1./dot(rd, n);\n    float u = d*dot(-q, v2v0);\n    float v = d*dot(q, v1v0);\n    float t = d*dot(-n, rov0);\n    if (u<0. || u>1.0||v<0.0||(u+v)>1.0) t = -1.0;\n    return vec3(t, u, v);\n}\nmat2 rot(in float angle) {\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n//Instances\nstruct hit {\n\tfloat dist;\n    vec3 normal;\n    vec3 color;\n};\nstruct temp {\n\tfloat tmp;\n    vec3 normal;\n    vec3 color;\n};\nstruct state {\n\tfloat d0;\n    vec3 normal;\n    vec3 color;\n};\nfloat hitAC(in vec3 ro, in vec3 rd, out vec3 normal, out vec3 color) {\n    bool boundHit = bound(ro-vec3(0.02, 0.36, 0.02), rd, vec3(0.33, 0.5, 0.33));\n    if (!boundHit) return -1.0;\n    initInst\n\tt.color = vec3(0, 0.8, 0);\n    t.tmp = box(ro+vec3(0.0, 0.03, 0.0), rd, vec3(0.28, 0.03, 0.28), t.normal).x; setObject;\n    t.tmp = box(ro-vec3(0.016, 0.015, 0.016), rd, vec3(0.32, 0.044, 0.32), t.normal).x; setObject;\n    t.tmp = box(ro-vec3(0.0075, 0.245, 0.0075), rd, vec3(0.3, 0.23, 0.3), t.normal).x; setObject;\n    t.tmp = box(ro-vec3(0.01615, 0.285, 0.01615), rd, vec3(0.323, 0.04, 0.323), t.normal).x; setObject;\n    t.tmp = box(ro-vec3(-0.1, 0.360, -0.1), rd, vec3(0.087, 0.076, 0.087), t.normal).x; setObject;\n    normal = s.normal;\n    color =  s.color;\n\treturn s.d0;\n}\nfloat hitR1(in vec3 ro, in vec3 rd, out vec3 normal, out vec3 color) {\n    bool boundHit = bound(ro-vec3(0.0, 0.3, 0.0), rd, vec3(1.5, 0.4, 1.5));\n    if (!boundHit) return -1.0;\n    initInst;\n\tt.color = vec3(0.8, 0, 0);\n    t.tmp = box(ro, rd, vec3(0.1, 0.2, 1.5), t.normal).x; setObject;\n    t.tmp = box(ro, rd, vec3(1.5, 0.2, 0.1), t.normal).x; setObject;\n    t.tmp = box(ro+vec3(0.0, 0.0, 1.4), rd, vec3(1.5, 0.2, 0.1), t.normal).x; setObject;\n    t.tmp = box(ro+vec3(1.4, 0.0, 0.0), rd, vec3(0.1, 0.2, 1.5), t.normal).x; setObject;\n    mat2 r = rot(-0.1);\n    ro.xz *= r;\n    rd.xz *= r;\n    t.tmp = hitAC(ro-vec3(-0.8, -0.05, -0.2), rd, t.normal, t.color); setObject\n    t.tmp = hitAC(ro-vec3(-0.4, -0.05, -0.2), rd, t.normal, t.color); setObject\n    t.color = vec3(0, 0.8, 0);t.tmp = box(ro-vec3(-0.495, 0.29, -0.3), rd, vec3(0.5, 0.0393, 0.1), t.normal).x; setObject\n    normal = s.normal;\n    color =  s.color;\n\treturn s.d0;\n}\nfloat hitHouse(in vec3 ro, in vec3 rd, out vec3 normal, out vec3 color) {\n    //19 objects\n    ro.y -= 4.2;\n\tbool boundHit = bound(ro-vec3(0.0, 1.4, 0.0), rd, vec3(1.5, 7., 1.5));\n    if (!boundHit) return -1.0;\n    initInst\n\tt.color = vec3(0.8);\n    t.tmp = box(ro, rd, vec3(1.5, 5.2, 1.5), t.normal).x; setObject\n    t.tmp = box(ro-vec3(-0.18, 0.123, -0.18), rd, vec3(1.18, 0.123, 1.18), t.normal).x; setObject\n    t.tmp = box(ro-vec3(-0.18, 0.123, -0.18), rd, vec3(1.18, 0.123, 1.18), t.normal).x; setObject\n    t.tmp = box(ro-vec3(0.0, 0.9, 0.0), rd, vec3(1.5, 0.815, 1.5), t.normal).x; setObject\n    t.tmp = hitR1(ro-vec3(0.0, 1.0, 0.0), rd, t.normal, t.color); setObject\n    normal = s.normal;\n    color =  s.color;\n\treturn s.d0;\n}", "buffer_a_code": "const float camSize = 10.0;\nconst int size = 2;\nstruct hitt {\n\tfloat dist;\n    vec3 normal;\n    vec3 p;\n    vec3 color;\n};\nfloat hash(vec2 p) {\n    p = 50.*fract(p*0.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\nhitt hitScene(in vec3 ro, in vec3 rd) {\n    ro.y -= 1.0;\n    float d0 = 100000.;\n    vec3 tmpNormal = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 tmpColor = vec3(0);\n    vec3 color = vec3(0);\n    //A grid of 5x5 house instances\n    for (int x = -size; x < size+1; x += 1) {\n        for (int y = -size; y < size+1; y += 1) {\n            float b = hitHouse(ro+vec3((hash(vec2(x+5, y+1))-0.5)*1., 0, (hash(vec2(x+20, y+20))-0.5)*1.)+vec3(x*3, 0, y*3), rd, tmpNormal, tmpColor);//box(ro+vec3(float(x), 0.0, float(y)), rd, vec3(0.1, 2.0, 0.1)).x;\n            if (b != -1.0 && b < d0) {d0 = b;normal = tmpNormal;color=tmpColor;}\n        }\n    }\n    float g = box(ro-vec3(50., -1, 50.), rd, vec3(100, 0.1, 100), tmpNormal).x;\n    if (g != -1.0 && g < d0) {d0 = g;normal=tmpNormal;color=vec3(1.0, 0.5, 0.5);}\n    if (d0 > maxDist-1.0) hitt(-1., vec3(0), vec3(0), vec3(0));\n    return hitt(d0, normal, ro+rd*d0, color);\n}\nvec3 rus(vec2 seed) {\n    float u = hash(seed);\n    float v = hash(seed+2.);\n    float theta = u * 2.0 * 3.1415;\n    float phi = acos(2.0 * v - 1.0);\n    float r = pow(hash(seed+1.), 0.33333333);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r * sinPhi * cosTheta;\n    float y = r * sinPhi * sinTheta;\n    float z = r * cosPhi;\n    return (vec3(x, y, z));\n}\nvec3 sky(in vec3 rd) {\n    return vec3(1);\n}\nvec3 color(in vec3 ro, in vec3 rd, in vec2 uv) {\n    vec3 v = vec3(1.0);\n    for (int i = 0; i < 10; i += 1) {\n    \thitt h = hitScene(ro, rd);\n        if (h.dist >= maxDist) {\n        \tv *= sky(rd);\n            break;\n        }\n        ro = (ro+rd*h.dist)+(h.normal*0.001);\n        vec3 target = h.normal+(rus(uv));\n        rd = target;\n        v *= (h.color);\n    }\n\treturn vec3(v);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = (iMouse.xy/iResolution.xy)-0.5;\n    if (iFrame == 0) mouse = vec2(0, 5);\n    float r = iResolution.x/iResolution.y;\n    mouse *= (r)*1.;\n    float seed = (sin(iTime)*100.);\n    vec2 uv = ((fragCoord.xy/iResolution.xy)-0.5) * vec2(r, 1.);\n    uv += (vec2(hash(uv+seed), hash(uv+1.0+seed))-0.5)/iResolution.xy;\n    vec3 ro = vec3(sin(mouse.x*5.)*camSize, mouse.y*camSize, cos(mouse.x*5.)*camSize);\n    vec3 at = vec3(0.0, 0.0, 0.0);\n    at += vec3(-0.75, 6., -0.75);\n    ro += vec3(-0.75, 6., -0.75);\n    vec3 cam_z = normalize(at-ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.5 * cam_z);\n    vec3 col = color(ro, rd, uv+seed);\n    if (iMouse.z < 1.0) {\n        vec4 old = texture(iChannel0, (fragCoord.xy/iResolution.xy));\n        fragColor = vec4(((col)+old.xyz),old.w+1.);\n    } else {\n        fragColor = vec4(col,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 159]], "test": "untested"}
{"id": "NdjXzD", "name": "Closest Points - Lines", "author": "oneshade", "description": "I've finally got a reasonable closest points for lines method. Spurred by @iapafoto's shader: [url=https://www.shadertoy.com/view/fsBXzR]https://www.shadertoy.com/view/fsBXzR[/url]", "tags": ["2d", "lines", "points", "closest"], "likes": 11, "viewed": 248, "published": 3, "date": "1619800327", "time_retrieved": "2024-07-30T19:22:37.566578", "image_code": "void update(in vec2 a, in vec2 b, inout vec4 pair, inout float comp) {\n    vec2 ba = b - a;\n    float comp2 = dot(ba, ba);\n    if (comp2 < comp) { pair = vec4(a, b); comp = comp2; }\n}\n\nvec4 closestPointsLines(in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    vec2 ba = b - a, ca = c - a, dc = d - c;\n\n    // Closest points are an intersection (this case can be ignored in 3D)\n    float v = (ba.y * ca.x - ba.x * ca.y) / (dc.y * ba.x - dc.x * ba.y); // 2D cross products\n    float u = (ca.x + dc.x * v) / ba.x;\n    if (u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) return (a + ba * u).xyxy;\n\n    // Closest points are caps and projections of the caps\n    float baba = dot(ba, ba), dcdc = dot(dc, dc);\n\n    vec4 pair = vec4(a, c + dc * clamp(dot(-ca, dc) / dcdc, 0.0, 1.0));\n    vec2 diff = pair.zw - pair.xy;\n    float comp = dot(diff, diff);\n\n    update(b, c + dc * clamp(dot(b - c, dc) / dcdc, 0.0, 1.0), pair, comp);\n    update(c, a + ba * clamp(dot(   ca, ba) / baba, 0.0, 1.0), pair, comp);\n    update(d, a + ba * clamp(dot(d - a, ba) / baba, 0.0, 1.0), pair, comp);\n\n    return pair;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 a = vec2(c1, s2);\n    vec2 b = vec2(s1, c2);\n\n    vec2 c = vec2(s3, c1);\n    vec2 d = vec2(c2, s3);\n\n    float dist = min(sdLine(uv, a, b), sdLine(uv, c, d)) * 0.75;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(dist) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(dist));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * dist);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(dist * 0.6)));\n\n    color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - a) - 0.05));\n    color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - b) - 0.05));\n\n    color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - c) - 0.05));\n    color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - d) - 0.05));\n\n    vec4 closest = closestPointsLines(a, b, c, d);\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - closest.xy) - 0.05));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - closest.zw) - 0.05));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.015, sdLine(uv, closest.xy, closest.zw) - 0.01));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 70, 70, 183], [185, 185, 254, 254, 1090], [1092, 1092, 1139, 1139, 1247], [1249, 1249, 1304, 1304, 2812]], "test": "untested"}
{"id": "sslXD2", "name": " Smooth Voronoi Contours AR", "author": "Chaotnix", "description": "Just added audioreactive and flame\nflame is from https://www.shadertoy.com/view/MdX3zr", "tags": ["voronoi", "abstract", "smooth", "contour"], "likes": 11, "viewed": 644, "published": 3, "date": "1619798972", "time_retrieved": "2024-07-30T19:22:38.328540", "image_code": "/*\n     Smooth Voronoi Contours AR\n     --------------------------\n     Forked from Smooth Voronoi Contours by Shane https://www.shadertoy.com/view/4sdXDX\n     Flame is from Flame by xT95 https://www.shadertoy.com/view/MdX3zr\n     \n     I just added audioreactive and flame and changed some parameters   \n     \n    \n\n\tSmooth Voronoi Contours\n\t-----------------------\n\n\tUsing a numerical gradient to produce smooth \"fract\" contours on 2D Voronoi.\n\n\tShadertoy user \"drone1\" was kind enough to help me problem shoot some AA code\n\tyesterday on an image similar to this one, but I wanted to produce it without\n\tAA for realtime usage. There might be better methods, but this is the one I\n\tchose. It's partly based off of IQ's \"Ellipse - Distance Estimation\" example.\n\n\tIf you press pause, you should notice that the contour lines are smooth and \n\tprecise, regardless of the shape of the curve.\n\t\n\tFor anyone wondering, the weird abstract image is just an amalgamation of two \n\tlayers of smooth 2D Voronoi and an old concentric circle trick. In pseudo code:\n\n\tfloat val = Vor(p*freq)*A1 + Vor(p*freq*3.)*A2;\n\tval = clamp(cos(val*freq2*PI)*contrast, 0., 1.);\n\n    See IQ's distance estimation example for a good explanation regarding the \n\tgradient related contour snippet:\n\n    Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    There's an accompanying articles, which is really insightful here:\n    https://iquilezles.org/articles/distance\n\n\tAnother example using the technique.\n\t2D Noise Contours - Shane\n\thttps://www.shadertoy.com/view/XdcGzB\n\n*/\n\n// Glossy version. It's there to show that the method works with raised surfaces too.\n//#define GLOSSY\nconst float FREQ_RANGE = 20.0;\n\n\n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) {\n    \n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(41, 289)));\n    p = fract(vec2(2097152, 262144)*n);\n    return cos(p*6.283 + iTime)*.5;\n    //return abs(fract(p+ iTime*.25)-.5)*2. - .5; // Snooker.\n    //return abs(cos(p*6.283 + iTime))*.5; // Bounce.\n\n}\n\n// Smooth Voronoi. I'm not sure who came up with the original, but I think IQ\n// was behind this particular algorithm. It's just like the regular Voronoi\n// algorithm, but instead of determining the minimum distance, you accumulate\n// values - analogous to adding metaball field values. The result is a nice\n// smooth pattern. The \"falloff\" variable is a smoothing factor of sorts.\n//\nfloat smoothVoronoi(vec2 p, float falloff) {\n\n    vec2 ip = floor(p); p -= ip;\n\t\n\tfloat d = 1., res = 0.0;\n\t\n\tfor(int i = -1; i <= 2; i++) {\n\t\tfor(int j = -1; j <= 2; j++) {\n            \n\t\t\tvec2 b = vec2(i, j);\n            \n\t\t\tvec2 v = b - p + hash22(ip + b);\n            \n\t\t\td = max(dot(v,v), 1e-4);\n\t\t\t\n\t\t\tres += 1.0/pow( d, falloff );\n\t\t}\n\t}\n\n\treturn pow( 1./res, .5/falloff );\n}\n\n// 2D function we'll be producing the contours for. \nfloat func2D(vec2 p){\n\n    \n    float d = smoothVoronoi(p*2., 2.)*.66 + smoothVoronoi(p*6., 2.)*.34;\n    \n    return sqrt(d);\n    \n}\n\n// Smooth fract function. A bit hacky, but it works. Handy for all kinds of things.\n// The final value controls the smoothing, so to speak. Common sense dictates that \n// tighter curves, require more blur, and straighter curves require less. The way \n// you do that is by passing in the function's curve-related value, which in this case\n// will be the function value divided by the length of the function's gradient.\n//\n// IQ's distance estimation example will give you more details:\n// Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n// There's an accompanying article, which is really insightful, here:\n// https://iquilezles.org/articles/distance\nfloat smoothFract(float x, float sf){\n \n    x = fract(x); return min(x, x*(1.-x)*sf);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float beat = texture(iChannel0, vec2(floor(2. * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n\n    // Standard epsilon, used to determine the numerical gradient. \n    vec2 e = vec2(0.001, 0); \n\n    // The 2D function value. In this case, it's a couple of layers of 2D simplex-like noise.\n    // In theory, any function should work.\n    float f = func2D(uv); // Range [0, 1]\n  \n    // Length of the numerical gradient of the function above. Pretty standard. Requires two extra function\n    // calls, which isn't too bad.\n    float g = length( vec2(f - func2D(uv-e.xy), f - func2D(uv-e.yx)) )/(e.x);\n   \n    // Dividing a constant by the length of its gradient. Not quite the same, but related to IQ's \n    // distance estimation example: Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    g = 1./max(g, 0.001);\n    \n    // This is the crux of the shader. Taking a function value and producing some contours. In this case,\n    // there are twelve. If you don't care about aliasing, it's as simple as: c = fract(f*12.);\n    // If you do, and who wouldn't, you can use the following method. For a quick explanation, refer to the \n    // \"smoothFract\" function or look up a concetric circle (bullseye) function.\n    //\n    // For a very good explanation, see IQ's distance estimation example:\n    // Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    //\n    // There's an accompanying articles, which is really insightful, here:\n\t// https://iquilezles.org/articles/distance\n    //\n    float freq = 11.+5.*smoothstep(0.1,.9,0.5*beat); \n    // Smoothing factor. Hand picked. Ties in with the frequency above. Higher frequencies\n    // require a lower value, and vice versa.\n    float smoothFactor = iResolution.y*0.0125; \n    \n    #ifdef GLOSSY\n    float c = smoothFract(f*freq, g*iResolution.y/16.); // Range [0, 1]\n    //float c = fract(f*freq); // Aliased version, for comparison.\n    #else\n    float c = clamp(cos(f*freq*3.14159*2.)*g*smoothFactor, 0., 1.); // Range [0, 1]\n    //float c = clamp(cos(f*freq*3.14159*2.)*2., 0., 1.); // Blurry contours, for comparison.\n    #endif\n    \n    \n    // Coloring.\n    //\n    // Convert \"c\" above to the greyscale and green colors.\n    vec3 col = vec3(c);\n    vec3 col2 = vec3(c*0.64, c, c*c*0.1);\n    \n    #ifdef GLOSSY\n    col = mix(col, col2, -uv.y + clamp(fract(f*freq*0.5)*2.-1., 0., 1.0));\n    #else\n    col = mix(col, col2, -uv.y + clamp(cos(f*freq*3.14159)*2., 0., 1.0));\n    #endif\n    \n    // Color in a couple of thecontours above. Not madatory, but it's pretty simple, and an interesting \n    // way to pretty up functions. I use it all the time.\n    f = f*freq;\n    \n    #ifdef GLOSSY\n    if(f>8. && f<9.) col *= vec3(1, 0, .1);\n    #else\n    if(f>8.5 && f<9.5) col *= vec3(1, 0, .1);\n    #endif \n   \n    \n\t// Since we have the gradient related value, we may as well use it for something. In this case, we're \n    // adding a bit of highlighting. It's calculated for the contourless noise, so doesn't match up perfectly,\n    // but it's good enough. Comment it out to see the texture on its own.  \n    #ifdef GLOSSY\n    col += g*g*g*vec3(.3, .5, 1)*.25*.25*.25*.1;\n    #endif \n    \n    \n    //col = c * vec3(g*.25); // Just the function and gradient. Has a plastic wrap feel.\n\t\n    // Done.\n    vec2 uvA = fragCoord / iChannelResolution[1].xy;\n   \n//\tfragColor = mix(vec4( sqrt(clamp(col, 0., 1.)), 1.0 ),texture(iChannel1, uvA),0.9*beat);\n\tfragColor = vec4(mix(sqrt(clamp(col, 0., 1.)),texture(iChannel1, uvA).rgb,0.7*beat),1.);\n\t\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26913, "src": "https://soundcloud.com/ibogarecords/day-din-gaudium-parallels", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "float noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1. ))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n    a.xy = mix(a.xy, texture(iChannel0,p.xy).xy,3.3); \n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p +3. *  texture(iChannel0,p.xy).y) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\n\treturn d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(100.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 4.);\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\n\t\n\tfragColor = mix(vec4(0.), col, pow(glow*2.,4.));\n\t//fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\n\n}\n\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslXD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1703, 1735, 1756, 1840, 2077], [2079, 2464, 2508, 2508, 2846], [2848, 2901, 2922, 2922, 3033], [3035, 3707, 3744, 3744, 3799], [3802, 3802, 3859, 3859, 7485]], "test": "untested"}
{"id": "NdjSRD", "name": "1-bit noise", "author": "redline2466", "description": "1-bit greyscale effect based on a noise funciton", "tags": ["postprocessing", "greyscale"], "likes": 2, "viewed": 606, "published": 3, "date": "1619790771", "time_retrieved": "2024-07-30T19:22:39.290967", "image_code": "float randF(vec2 co){\n\treturn fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec3 video = texture(iChannel0, uv).rgb;\n\tfloat grey = (video.r + video.g + video.b) / 3.;\n\n\t// increase contrast\n\tgrey = smoothstep(1., 0., grey);\n\n\t// convert to 1-bit based on noise\n\tgrey = step(grey, randF(uv+iTime/1000.));\n\n\tfragColor = vec4(vec3(grey),1.);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjSRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 84], [86, 86, 143, 143, 446]], "test": "untested"}
{"id": "Ns2SzW", "name": "lightnebula", "author": "Del", "description": "just a nebula effect", "tags": ["voronoi", "fbm", "layer"], "likes": 8, "viewed": 354, "published": 3, "date": "1619788926", "time_retrieved": "2024-07-30T19:22:40.053927", "image_code": "// nebula effect\n\n// hash without sine (DaveH)\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.05);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    float dd = length(uv*uv)*0.25;\n    //uv *= 2.0+sin(iTime);\n    \n\tvec3 rd = normalize(vec3(uv.x, uv.y, 3.141592/8.));\n    rd.xy *= rot(dd-iTime*.025);\n\t\n\tfloat c = noiseLayers(rd*2.25);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.35,3.5);    \n    \n    \n    vec3 col =  vec3(0.55,0.8,0.35);\n    vec3 col2 =  vec3(0.95,0.7,0.65);\n    \n    col = mix(col,col2,0.5+sin(dd+uv.x*0.3+iTime*0.35)*0.5);\n    \n    \n    col = mix(col,col*1.95,0.5+sin(dd*23.0+iTime*.716+oc*8.0)*0.5)*c;\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2SzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 47, 68, 68, 272], [274, 294, 316, 316, 713], [715, 728, 758, 758, 1031], [1033, 1033, 1054, 1054, 1122], [1125, 1125, 1182, 1182, 1813]], "test": "untested"}
{"id": "4l2fzc", "name": "rainy ghost cube", "author": "nylki", "description": "Rotating cube engulfed in rain-like artefacts.", "tags": ["sdf"], "likes": 4, "viewed": 305, "published": 3, "date": "1619784043", "time_retrieved": "2024-07-30T19:22:40.984439", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// uniform vec2 iResolution;\n// uniform vec2 u_mouse;\n// uniform float iGlobalTime;\n\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float S = 0.01;\n\n\nconst vec3 spherePos = vec3(0.0, 0.0, 0.0);\n\nfloat sphere(vec3 p, float r) {\n return length(p) - r;\n}\n\n// New distance function for a cube\nfloat cube(vec3 p, float s /* half length of the faces */) {\n    vec3 q = abs(p) - vec3(s);\n    return min(max(q.x,max(q.y,q.z)),0.0) +\n         length(max(q,0.0));\n}\n\nfloat sdfGhost(float a, float b) {\n    return mod(iTime * b,a);\n}\n\n\nfloat distanceToNearestSurface(vec3 p) {\n    return sdfGhost(cube(vec3(1.0,0.0, 1.0) + p, 1.5), sphere(p,  1000.0));\n}\n\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\n\nvec3 calcNormalForPoint(vec3 p, float dist) {\n // ... my own old attempt at the normal calc without\n // Create the three vectors pointing out\n // along each one of the axes by copying p each time first.\n vec3 A = p;\n vec3 B = p;\n vec3 C = p;\n\n A.x += S;\n B.y += S;\n C.z += S;\n\n // Get their distances to the surface\n float distA = distanceToNearestSurface(A) - dist;\n float distB = distanceToNearestSurface(B) - dist;\n float distC = distanceToNearestSurface(C) - dist;\n\n // And use the distances as value for each axe (X,Y,Z)\n vec3 normal = normalize(vec3(distA,distB,distC));\n return normal;\n\n}\n\nvec3 computeToon(vec3 color, float steps) {\n return ceil(color * steps) / steps;\n}\n\nvec3 computeLambert(vec3 p, vec3 n, float intensity) {\n    \n\tvec3 lightPos = vec3(100., 30., 50.);\n    // calc vector pointing from light to point\n    // and then take dot product of that\n    // vector and the surface normal\n    vec3 lightToPoint = normalize(lightPos-p);\n    return vec3( intensity * dot(lightToPoint, n));\n}\n\nvec3 intersectWithWorld(vec3 p, vec3 dir) {\n\tfloat dist = 0.0;\n    for(int i = 0; i < 20; i++) {\n    \tvec3 currentRayPos = p + dir*dist;\n    \tfloat nearest = distanceToNearestSurface(currentRayPos);\n        if (nearest < 0.01) {\n        \tvec3 normal = calcNormalForPoint(currentRayPos, nearest);\n            return computeLambert(currentRayPos, normal, 1.0);\n        }\n        dist += nearest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 camPos = vec3(10.0*sin(iTime), 0.0, 10.0*cos(iTime));\n    vec3 camDir = vec3(-1.0*sin(iTime), 0.0, -1.0*cos(iTime));\n    vec3 camUp  = vec3(0.0, 1.0, 0.0);\n    \n    // tracing stuff\n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy);\n    \n    \n    // Generate Ray for this fragment\n \n    // create camera UV (-1 to 1.0) from UV (0.0 to 1.0)\n    \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    \n    // Get perpendicular vector from camUp and camDir\n    // which is the x axis of the camera basically\n\n    vec3 nright = normalize( cross(camUp, camDir) );\n    \n    // Calculate Pixel position in space to trace\n    vec3 pixel = camPos + camDir + nright*camUV.x*ulen + camUp*camUV.y*vlen;\n\t\n    // Calculate direction vector from camera to pixel\n    vec3 ray = normalize(pixel - camPos);\n\n\n    vec3 intersectionColor = intersectWithWorld(pixel, ray);\n    intersectionColor.r *= sin(iMouse.x/iResolution.x);\n    fragColor = vec4(intersectionColor , 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2fzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 256, 287, 287, 312], [314, 350, 410, 410, 516], [518, 518, 552, 552, 583], [586, 586, 626, 626, 704], [860, 860, 905, 1062, 1455], [1457, 1457, 1500, 1500, 1539], [1541, 1541, 1595, 1595, 1866], [1868, 1868, 1911, 1911, 2291], [2293, 2293, 2350, 2350, 3456]], "test": "untested"}
{"id": "fsjSzW", "name": "test audio: correlation in waves", "author": "FabriceNeyret2", "description": "See sound tab: ( rise gain )\nsound made of 1000 random frequencies around 440Hz.\nBut all fall in sync at 2\", then every 5\".  Listen, and try switch the random phase variant.  \nCause: accumulated intensity of N random sin is sqrt(N), but N if correlated.", "tags": ["audio", "correlation"], "likes": 3, "viewed": 380, "published": 3, "date": "1619782284", "time_retrieved": "2024-07-30T19:22:42.036626", "image_code": "// rise sound gain if necessary.\n// NB: sound quality degenerate over time because of float precision of time.\n\n// reuse base of https://shadertoy.com/view/7sSXzD\n\n// the interesting part is in the Sound tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 O, in vec2 u ) {\n    if (iResolution.y<2000.) {float c=message((u/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){O=vec4(c);return;}}\n\n    \n    vec2 uv = u / iResolution.xy;\n\tO = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// rise sound gain if necessary.\n// NB: sound quality degenerate over time because of float precision of time. fix: https://www.shadertoy.com/view/4ltfRN\n\n#define hash(p)  fract(sin( (p) * 12.9898 ) * 43758.5453) // random\n\n\nvec2 mainSound( int it, float t )\n{\n    float v  = 0., w, A=0., tau = 6.2831853, f, phi;\n    \n    for (float i = 1.; i < 1000.; i++ ) {\n        f = 440.*(1.+.1*hash(i));                      // freq fi in Hz\n        phi = 0.;                                      // sync phases\n     // phi = tau*hash(i+.5);                          // random phases\n        w = 1.;                                        // weight for freq fi\n        v +=  cos( tau * f *  (t-2.)  + phi  ) *w;     // weighted wave\n        A += w;                                        // cumul weight for normalization\n    }\n     \n    return vec2(  v / A ); // normalization: std dev = sqrt(A) if decorrelated,\n                           //                max can be A if correlated\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjSzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[592, 592, 615, 662, 841], [843, 843, 884, 884, 1075]], "test": "untested"}
{"id": "fdjSRW", "name": "Vogel/Fibonacci Flower loopless", "author": "FabriceNeyret2", "description": "minimalist variant of [url]https://www.shadertoy.com/view/wtsczN[/url]", "tags": ["fibonacci", "short", "loopless", "vogeldisk"], "likes": 18, "viewed": 507, "published": 3, "date": "1619778790", "time_retrieved": "2024-07-30T19:22:43.067869", "image_code": "// minimalist variant of  https://shadertoy.com/view/wtsczN\n\nvoid mainImage(out vec4 O, vec2 u) {   \n\n    vec2  R = iResolution.xy,                               \n          U = u+u - R;  \n\n    float f = 2.307, // Golden Angle 2.4 ok too\n          s = 15./R.y,\n         PI = 3.14, L = 2.*PI/f,\n          a = atan(-U.y,U.x), l = length(U)*s, \n         x1 =  a / f,\n         x2 = l*l,\n          k = round((x2-x1)/L ),\n          x = round( x1 + L*k );\n\n    O = vec4( x > 2e2 ? 0. :\n              1.5-.5* length( U - sqrt(x) *cos ( x * f  + vec2(0,PI/2.)) / s )  );  \n}\n/**/\n\n\n\n\n/** // golfed down to 218 chars (from 254)\nvoid mainImage(out vec4 O, vec2 u) {   \n    vec2  R = iResolution.xy,                               \n          U = u+u - R;  \n\n    float f = 2.4, \n          s = 15./R.y,\n          L = 6.28/f,\n          a = atan(-U.y,U.x) / f,\n          x = round( a + L*round( (dot(U*=s,U) - a ) / L ) );\n\n    O = vec4( x > 2e2 ? 0. :\n          3.- length( U - sqrt(x) *cos ( x * f  + vec2(0,1.57)) )/ s  )/2.;  \n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjSRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 97, 97, 564]], "test": "untested"}
{"id": "sdSXzD", "name": "Scaling a precomputed Vogel Disk", "author": "Tech_", "description": "Here is a little trick so you can precompute a vogel disk, and then choose how many samples you actually want to\nuse on the fly! Really handy!", "tags": ["precomputed", "vogeldisk"], "likes": 1, "viewed": 309, "published": 3, "date": "1619774273", "time_retrieved": "2024-07-30T19:22:43.854765", "image_code": "\n// Has to be below 128 in this case\n#define SAMPLES int((sin(iTime * 0.6) * 0.5 + 0.5) * 128.0)\n\n// Precomputed Vogel Disk Samples (unscaled), Max. Sample Count: 128\nconst vec2 samples[128] = vec2[128](\n\tvec2(1.0, 0.0),\n\tvec2(-0.7373686567474267, 0.6754905358674507),\n\tvec2(0.08742507190700873, -0.9961710981563631),\n\tvec2(0.6084396410711903, 0.7936001532088821),\n\tvec2(-0.9847137136041088, -0.17418065977600777),\n\tvec2(0.843754671423316, -0.5367290326145326),\n\tvec2(-0.2596024063463223, 0.9657155847449077),\n\tvec2(-0.4609094833467294, -0.8874471523200979),\n\tvec2(0.9393221955199893, 0.3430361686520928),\n\tvec2(-0.9243446128898057, 0.38155869354739536),\n\tvec2(0.42384389109733595, -0.9057352571140584),\n\tvec2(0.2992877584742551, 0.9541628988948668),\n\tvec2(-0.8652131812383979, -0.5014041792918476),\n\tvec2(0.9766749613940298, -0.2147231235474429),\n\tvec2(-0.575124896322102, 0.8180656169467652),\n\tvec2(-0.12851603682013718, -0.9917074307879543),\n\tvec2(0.7646523739929859, 0.6444429741620983),\n\tvec2(-0.9991458435471234, 0.04132291522275733),\n\tvec2(0.7088259267568097, -0.7053834457636143),\n\tvec2(-0.04618665603782159, 0.9989328269728871),\n\tvec2(-0.6407127119589392, -0.7677807113585372),\n\tvec2(0.991070520994052, 0.13333875061878397),\n\tvec2(-0.8208536752549119, 0.571138550459084),\n\tvec2(0.21947355161589133, -0.9756184500823601),\n\tvec2(0.4971876979773376, 0.8676430101026549),\n\tvec2(-0.9526951219209056, -0.30392763064274175),\n\tvec2(0.9077879604280591, -0.4194293968022086),\n\tvec2(-0.38605072188895717, 0.9224775553524406),\n\tvec2(-0.33846270726098293, -0.9409798062623693),\n\tvec2(0.885194523550148, 0.4652210823649616),\n\tvec2(-0.9669672565600903, 0.2549006173798968),\n\tvec2(0.5408287935449546, -0.8411326982543889),\n\tvec2(0.16938650610621825, 0.9855497001922978),\n\tvec2(-0.7906295036207344, -0.6122948538118145),\n\tvec2(0.9965848333549856, -0.08257523797613628),\n\tvec2(-0.6790719781886778, 0.734071691620727),\n\tvec2(0.004868388885300166, -0.9999881493246114),\n\tvec2(0.6718923803067166, 0.7406487894311139),\n\tvec2(-0.9957335856080879, -0.09227473376857097),\n\tvec2(0.7965537341389451, -0.6045677370066176),\n\tvec2(-0.1789744414684427, 0.9838537235285838),\n\tvec2(-0.5326197890374789, -0.8463546303563723),\n\tvec2(0.9644415551668435, 0.2642962100889084),\n\tvec2(-0.8896787803432055, 0.4565869772639451),\n\tvec2(0.3476015123589927, -0.9376423564482042),\n\tvec2(0.37705763591602437, 0.9261897965306133),\n\tvec2(-0.9036627202822134, -0.4282448925231335),\n\tvec2(0.9556080786359611, -0.29464079833873436),\n\tvec2(-0.5056087859599915, 0.8627628617181338),\n\tvec2(-0.20996761023785762, -0.9777083423245416),\n\tvec2(0.8152559906637783, 0.5791007422606377),\n\tvec2(-0.9923213444303496, 0.12368649638478495),\n\tvec2(0.648157962196271, -0.7615059133332961),\n\tvec2(0.03645819499878424, 0.9993351790152444),\n\tvec2(-0.70192968025803, -0.7122462523403402),\n\tvec2(0.9986965237875168, 0.0510416827184385),\n\tvec2(-0.7708859915871323, 0.6369731454109535),\n\tvec2(0.13815830905957235, -0.9904101582868583),\n\tvec2(0.5671386890463472, 0.8236223086990727),\n\tvec2(-0.9745392610722754, -0.22421692315412645),\n\tvec2(0.870051350518695, -0.4929611013666241),\n\tvec2(-0.3085584906794061, 0.9512053710054663),\n\tvec2(-0.4150084321454177, -0.909817564816267),\n\tvec2(0.9205871783267726, 0.39053712640458527),\n\tvec2(-0.9426164230982562, 0.33387764061920844),\n\tvec2(0.46952504036071074, -0.8829191562506009),\n\tvec2(0.25019002399113754, 0.9681967526775299),\n\tvec2(-0.8384897653764787, -0.5449173454377257),\n\tvec2(0.986362660146369, -0.1645864595553921),\n\tvec2(-0.6161366895920775, 0.7876392446663104),\n\tvec2(-0.07772249687783177, -0.9969750315223924),\n\tvec2(0.7307570059044652, 0.6826376771915987),\n\tvec2(-0.999952597579323, -0.009736662383207641),\n\tvec2(0.7439110456391366, -0.6682786515938441),\n\tvec2(-0.09712125857154902, 0.9952725562043185),\n\tvec2(-0.6006826391247896, -0.7994875652904665),\n\tvec2(0.9829707470158787, 0.18376210303282176),\n\tvec2(-0.8489416328010365, 0.5284866167625346),\n\tvec2(0.2689957027413946, -0.9631413769051059),\n\tvec2(0.45224345951209016, 0.8918945303837985),\n\tvec2(-0.9359362986021179, -0.3521693413103519),\n\tvec2(0.928011641446752, -0.3725511955950551),\n\tvec2(-0.43263232065134305, 0.9015704493426088),\n\tvec2(-0.289992336457554, -0.9570289675845182),\n\tvec2(0.8602950266652791, 0.5097964957656992),\n\tvec2(-0.978717394179953, 0.20521272458013576),\n\tvec2(0.5830566643859474, -0.8124314901055552),\n\tvec2(0.11886159972432572, 0.9929108319033357),\n\tvec2(-0.758346377211482, -0.651851802306491),\n\tvec2(0.9995005878281634, -0.03160023625158116),\n\tvec2(-0.7156550783948376, 0.6984538701787534),\n\tvec2(0.05590312089622038, -0.9984361977983683),\n\tvec2(0.6332126240556997, 0.7739778890488379),\n\tvec2(-0.9897258128813334, -0.14297837359679158),\n\tvec2(0.8263735999086266, -0.5631222543764872),\n\tvec2(-0.22895870213904643, 0.9734361369472593),\n\tvec2(-0.488719511120127, -0.8724409661693472),\n\tvec2(0.9496919158528981, 0.3131856717087355),\n\tvec2(-0.9118272053020062, 0.4105741682950025),\n\tvec2(0.395014274662789, -0.9186749821414703),\n\tvec2(0.32928466062635703, 0.944230698651651),\n\tvec2(-0.8806228625744237, -0.47381786997877967),\n\tvec2(0.9694033012241131, -0.24547350076085875),\n\tvec2(-0.5489929820533482, 0.8358269591585163),\n\tvec2(-0.1597825120831549, -0.9871522419730385),\n\tvec2(0.784630317597863, 0.6199639221005339),\n\tvec2(-0.9973416000348613, 0.07286791365136548),\n\tvec2(0.6861760970549589, -0.7274354705610826),\n\tvec2(-0.014589447945719347, 0.9998935683404705),\n\tvec2(-0.6646604843876253, -0.7471455283233698),\n\tvec2(0.9947894932505406, 0.10195030219833981),\n\tvec2(-0.8023933412227937, 0.5967955478732405),\n\tvec2(0.18853042405055256, -0.9820673496289951),\n\tvec2(0.5243603686955506, 0.8514964496352678),\n\tvec2(-0.9618245632755994, -0.27366678548867146),\n\tvec2(0.8940788234081423, -0.44790965331538907),\n\tvec2(-0.35670741477358137, 0.9342161528498361),\n\tvec2(-0.368028859051122, -0.9298143679818727),\n\tvec2(0.8994535427425931, 0.4370163892210431),\n\tvec2(-0.9584294216125181, 0.28532971066381074),\n\tvec2(0.5139787050788099, -0.8578029439944291),\n\tvec2(0.20044551578707553, 0.9797048510652855),\n\tvec2(-0.8095833156592938, -0.5870049872071824),\n\tvec2(0.993477729730364, -0.11402631507595888),\n\tvec2(-0.6555360024964044, 0.7551639222255219),\n\tvec2(-0.026733904214805534, -0.9996425853100865),\n\tvec2(0.6949615057992979, 0.7190469424572865),\n\tvec2(-0.9981522075226674, -0.060763234094524374)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.4 - 1.2;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float dist = 1000.0;\n    float samplesSqrt = sqrt(float(SAMPLES));\n    \n    for (int i = 0; i < SAMPLES; i++) \n    {\n        float sampleR = sqrt(float(i) + 0.5) / samplesSqrt;\n        vec2 samplePoint = uv - samples[i] * sampleR;\n        float distToPoint = dot(samplePoint, samplePoint);\n        dist = min(distToPoint, dist);\n    }\n    \n    float smoothEpsilon = 0.3 / iResolution.y;\n    dist = smoothstep(0.001 + smoothEpsilon, 0.001 - smoothEpsilon, dist);\n\n    fragColor = vec4(vec3(dist), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6356, 6356, 6413, 6413, 7030]], "test": "untested"}
{"id": "sdBXRD", "name": "Dolphin Orb", "author": "dr2", "description": "Magic orb -- immersive scene projected onto external sphere (mouseable)", "tags": ["projection", "spherical", "swim"], "likes": 11, "viewed": 362, "published": 3, "date": "1619771651", "time_retrieved": "2024-07-30T19:22:44.907949", "image_code": "// \"Dolphin Orb\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 7 in \"Dolphin\" series\n    \"Atlantis 2\"                (XdlBzX)\n    \"Closely Watched Dolphins\"  (MdlfRl)\n    \"Virtual Dolphins\"          (XlfBD2)\n    \"Golden Dolphin\"            (MtsBWX)\n    \"Cave Dolphins\"             (wdSyRD)\n    \"Nautilus Interior\"         (wt2fzz)\n*/\n\n#define USE_BMAP   false  // try true for stronger GPUs\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 Hashv3v3 (vec3 p);\nfloat Noisefv3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 fishPos, fishAng, vuPos, ltPos, ltDirEx;\nvec2 trkAx, trkAy, trkFx, trkFy;\nfloat dstFar, tCur, bGrid, pScale, dstBMap;\nint idObj;\nbool useBm;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, sin (trkFx * t)), dot (trkAy, sin (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkAx * trkFx, cos (trkFx * t)), dot (trkAy * trkFy, cos (trkFy * t)), 1);\n}\n\nfloat VPoly (vec3 p)\n{\n  vec3 ip, fp, a, w;\n  p *= pScale;\n  ip = floor (p);\n  fp = fract (p);\n  a = vec3 (4.);\n  for (float gz = -1.; gz <= 1.; gz ++) {\n    for (float gy = -1.; gy <= 1.; gy ++) {\n      for (float gx = -1.; gx <= 1.; gx ++) {\n        w = vec3 (gx, gy, gz) + 0.8 * Hashv3v3 (ip + vec3 (gx, gy, gz)) - fp;\n        a.z = dot (w, w);\n        if (a.z < a.x) a.xy = a.zx;\n        else a.y = min (a.z, a.y);\n      }\n    }\n  }\n  return sqrt (a.y - a.x);\n}\n\nfloat ObjDfG (vec3 p)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xy -= TrackPath (p.z).xy;\n  d = SmoothMax (length (fract (q) - 0.5) - 0.2 + 1.1 * (Noisefv3 (4. * q) - 0.5), 0.55 - length (q.xy), 0.2);\n  if ((USE_BMAP || useBm) && dstBMap < 6. && d < 0.05) d -= 0.04 * VPoly (p);\n  return 0.25 * d;\n}\n\nfloat ObjRayG (vec3 ro, vec3 rd)\n{\n  vec3 p, s, rdi;\n  float dHit, d, eps;\n  eps = 0.0002;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    p = ro + dHit * rd;\n    s = (bGrid * (floor (p / bGrid) + step (0., rd)) - p) * rdi;\n    dstBMap = dHit;\n    d = min (ObjDfG (p), abs (Minv3 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNfG (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDfG (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, szFac, d, dBodyF, dBodyB, dMouth, dFinT, dFinP, dFinD, dEye;\n  int id;\n  szFac = 0.25;\n  dMin = dstFar;\n  dMin /= szFac;\n  p = (p - fishPos) / szFac;\n  p.xz = Rot2D (p.xz, fishAng.y);\n  p.yz = Rot2D (p.yz, fishAng.x);\n  p.x = abs (p.x);\n  p.z -= 0.2;\n  p.yz = Rot2D (p.yz, 0.2 * fishAng.z);\n  q = p;\n  q.z -= -0.06;\n  dBodyF = PrEllipsDf (q, vec3 (0.07, 0.08, 0.24));\n  q = p;\n  q.z -= -0.12;\n  q.yz = Rot2D (q.yz, fishAng.z);\n  q.z -= -0.16;\n  dBodyB = PrEllipsDf (q, vec3 (0.035, 0.05, 0.25));\n  q.z -= -0.22;\n  q.yz = Rot2D (q.yz, 2. * fishAng.z);\n  q.xz -= vec2 (0.05, -0.05);\n  q.xz = Rot2D (q.xz, 0.4);\n  dFinT = PrEllipsDf (q, vec3 (0.08, 0.007, 0.04));\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (-0.03, 0.17), 0.1);\n  q.y = abs (q.y) - 0.004;\n  dMouth = PrEllipsDf (q, vec3 (0.025, 0.012, 0.06));\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (0.07, -0.1), 0.6);\n  dFinD = PrEllipsDf (q, vec3 (0.005, 0.1, 0.035));\n  q = p;\n  q.xy = Rot2D (q.xy, 0.8);\n  q.xz = Rot2D (q.xz - vec2 (0.07, -0.01), 0.6);\n  dFinP = PrEllipsDf (q, vec3 (0.09, 0.004, 0.03));\n  q = p - vec3 (0.04, 0.01, 0.11);\n  dEye = PrSphDf (q, 0.015);\n  d = SmoothMin (SmoothMin (dBodyF, dBodyB, 0.03), dFinT, 0.01);\n  d = SmoothMin (SmoothMin (d, dMouth, 0.015), min (dFinD, dFinP), 0.002);\n  if (d < dEye) id = 2;\n  else {\n    d = dEye;\n    id = 3;\n  }\n  DMIN (id);\n  return dMin * szFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    p = ro + d * rd;\n    h = min (ObjDf (p), ObjDfG (p));\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.6), vec3 (0.2, 0.4, 0.9), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + 0.2 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, roo, ltVec, ltDir;\n  float dstObj, dstObjG, ltDist, sh, atten, eDark, aDotL;\n  bGrid = 1.;\n  pScale = 10.;\n  roo = ro;\n  useBm = false;\n  bgCol = BgCol (rd);\n  dstObj = ObjRay (ro, rd);\n  dstObjG = ObjRayG (ro, rd);\n  if (dstObjG < min (dstObj, dstFar)) {\n    idObj = 1;\n    dstObj = dstObjG;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    useBm = true;\n    vn = (idObj == 1) ? ObjNfG (ro) : ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (mix (vec3 (0.7, 0.75, 0.7), vec3 (0.7, 0.7, 0.75),\n         smoothstep (0.45, 0.55, Noisefv3 (41.1 * ro))), 0.2);\n      col4 *= 1. - 0.2 * Noisefv3 (19.1 * ro);\n      vn = VaryNf (64. * ro, vn, 2.);\n    } else if (idObj == 2) {\n      col4 = vec4 (vec3 (0.8, 0.7, 0.75) * (1. - 0.3 * smoothstep (-0.5, -0.4, vn.y)), 0.2);\n    } else if (idObj == 3) {\n      col4 = vec4 (0., 0.5, 0.3, -1.);\n    }\n    ltVec = roo + ltPos - ro;\n    ltDist = length (ltVec);\n    ltDir = ltVec / ltDist;\n    if (col4.a >= 0.) {\n      eDark = (idObj == 1) ? 0.4 + 0.6 * smoothstep (0.05, 1., VPoly (ro)) : 1.;\n      useBm = false;\n      sh = ObjSShadow (ro, ltDir, ltDist);\n      atten = 1. / (0.6 + 0.1 * ltDist * ltDist);\n      col = atten * col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (rd, vn), ltDir), 0.), 32.)) * eDark;\n    } else col = col4.rgb;\n    col = mix (col, bgCol, 0.05 + 0.95 * smoothstep (0., 0.85, dstObj / dstFar));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  d = PrSphDf (q, 1.);\n  q.y = abs (q.y) - 0.45;\n  d = max (PrRoundCylDf (q.xzy, 1.02, 0.007, 0.007), - d);\n  DMIN (1);\n  q = p;\n  q.xz = (abs (q.x) > abs (q.z)) ? q.xz : q.zx;\n  d = max (PrTorusDf (q, 0.013, 1.06), abs (q.y) - 0.45);\n  q.xy = abs (q.xy) - vec2 (0.96, 0.46);\n  d = min (d, PrSphDf (q, 0.02));\n  DMIN (2);\n  q = p;\n  d = PrSphDf (q, 1. - 0.01);\n  DMIN (3);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += max (0.03, h);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  mat3 vuMat;\n  vec4 ds4, col4;\n  vec3 col, vn, vd;\n  float dstObj, t, sh;\n  int idObjEx;\n  trkAx = 0.5 * vec2 (2., 0.9);\n  trkAy = 0.5 * vec2 (1.3, 0.66);\n  trkFx = 2. * vec2 (0.2, 0.23);\n  trkFy = 2. * vec2 (0.17, 0.24);\n  t = 0.3 * tCur;\n  vuPos = TrackPath (t);\n  vuPos.xy += 0.02 * sin (0.05 * pi * tCur);\n  vd = normalize (TrackVel (t));\n  vuMat = StdVuMat (sin (vd.y), atan (vd.x, vd.z) - pi);\n  t -= 0.25;\n  fishPos = TrackPath (t);\n  vd = normalize (TrackVel (t));\n  fishAng = vec3 (sin (vd.y), atan (vd.x, vd.z), 0.1 * sin (pi * tCur));\n  ltPos = vuMat * vec3 (0., 0.5, -0.5);\n  dstObj = ExObjRay (ro, rd);\n  idObjEx = idObj;\n  ds4 = SphHit (ro, rd, 1.);\n  if (min (ds4.x, dstObj) < dstFar) {\n    if (ds4.x < dstObj) {\n      col = ShowScene (vuPos, ds4.yzw);\n    } else {\n      ro += dstObj * rd;\n      vn = ExObjNf (ro);\n      if (idObjEx == 1) col4 = vec4 (0.5, 0.3, 0.1, 0.) * (0.95 + 0.05 * sin (64. * pi * length (ro.xz)));\n      else if (idObjEx == 2) col4 = vec4 (0.5, 0.4, 0., 0.1);\n      sh = ExObjSShadow (ro, ltDirEx);\n      col = col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, ltDirEx), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (rd, vn), ltDirEx), 0.), 32.);\n    }\n  } else col = vec3 (0.1, 0.1, 0.2);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 16.;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -7.);\n  ltDirEx = vuMat * normalize (vec3 (1., 1., -1.));\n  rd = vuMat * normalize (vec3 (uv, 6.5));\n  fragColor = vec4 (ExShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec3 (0., cHashVA3.xy)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBXRD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1161, 1161, 1187, 1187, 1268], [1270, 1270, 1295, 1295, 1392], [1394, 1394, 1416, 1416, 1859], [1861, 1861, 1884, 1884, 2154], [2156, 2156, 2190, 2190, 2681], [2683, 2683, 2705, 2705, 2961], [2963, 2963, 2985, 2985, 4361], [4363, 4363, 4396, 4396, 4579], [4581, 4581, 4602, 4602, 4857], [4859, 4859, 4910, 4910, 5192], [5194, 5194, 5237, 5237, 5438], [5440, 5440, 5462, 5462, 5881], [5883, 5883, 5918, 5918, 7446], [7448, 7448, 7472, 7472, 7915], [7917, 7917, 7952, 7952, 8136], [8138, 8138, 8161, 8161, 8418], [8420, 8420, 8459, 8459, 8702], [8704, 8704, 8741, 8741, 10002], [10004, 10004, 10057, 10057, 10637], [10639, 10639, 10672, 10672, 10699], [10701, 10701, 10758, 10758, 10834], [10836, 10836, 10882, 10882, 10939], [10941, 10941, 10976, 10976, 11038], [11040, 11040, 11062, 11062, 11100], [11102, 11102, 11147, 11147, 11250], [11252, 11252, 11297, 11297, 11335], [11337, 11337, 11373, 11373, 11579], [11581, 11581, 11611, 11611, 11724], [11758, 11758, 11782, 11782, 11894], [11896, 11896, 11920, 11920, 12038], [12040, 12040, 12064, 12064, 12207], [12209, 12209, 12234, 12234, 12420], [12422, 12422, 12447, 12447, 12672], [12674, 12674, 12703, 12703, 12915], [12917, 12917, 12956, 12956, 13141]], "test": "untested"}
{"id": "fsSXzD", "name": "Min frste shader", "author": "KreaAda", "description": "My very first shader.", "tags": ["firstattempt"], "likes": 0, "viewed": 201, "published": 3, "date": "1619769012", "time_retrieved": "2024-07-30T19:22:45.666920", "image_code": "float radius = 0.2;\n\nbool bjorn(vec2 center, vec2 pixel, float time){\n\n\n    center.y += abs(0.4* time);\n        \n    float xdist = (center.x - pixel.x) * (iResolution.x/iResolution.y);\n    float ydist = center.y - pixel.y;\n    \n    float dist = xdist*xdist + ydist*ydist;\n    \n    \n    return dist < (radius*radius);\n    \n} \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //iTime+\n//    vec3 col = 0.5 + 0.5*cos(xy.xxx+vec3(0,2,4));\n//    vec3 col = vec3(xy.x);\n\n\n        vec3 col = vec3(cos(iTime),0.75,abs(cos(log(iMouse.x))));\n        // Output to screen\n        fragColor = vec4(col,1.0);\n\n    if (uv.x == uv.y)\n       {\n           fragColor = vec4(.0,.0,.0,1.0);\n       }\n       \n       \n    if (bjorn(vec2(0.5, radius), uv, abs(sin(iTime)))){\n\n        fragColor = vec4(abs(sin(iTime)),.0,1.0,1.0);    \n        \n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 69, 69, 323], [328, 328, 385, 435, 966]], "test": "untested"}
{"id": "ss2SR1", "name": "NANO (cryptocurrency) logo", "author": "melevy", "description": "NANO cryptocurrency logo", "tags": ["logo"], "likes": 6, "viewed": 598, "published": 3, "date": "1619766477", "time_retrieved": "2024-07-30T19:22:46.593442", "image_code": "float intersectSDF(float a, float b) {\n    return max(a, b);\n}\n\nfloat intersectRoundSDF(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a, r + b), vec2(0.));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat unionSDF(float a, float b) {\n    return min(a, b);\n}\n\nfloat unionRoundSDF(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a, r - b), vec2(0.));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat differenceSDF(float a, float b) {\n    return max(a, -b);\n}\n\nfloat differenceRoundSDF(float a, float b, float r) {\n\treturn intersectRoundSDF(a, -b, r);\n}\n\nfloat sphereSDF(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat cylinderSDF(vec3 p, float h, float r) {\n    float inOutRadius = length(p.xy) - r;\n    float inOutHeight = abs(p.z) - h / 2.;\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.);\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.));\n    return insideDistance + outsideDistance;\n}\n\nfloat torusSDF(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.yz) - t.x, p.x);\n    return length(q) - t.y;\n}\n\nfloat dumbbellSphereSDF(vec3 point, float radius) {\n    vec3 o1 = vec3(0., 0., 0.);\n    vec3 o2 = vec3(radius * 2. * sqrt(2.), 0., 0.);\n    float p1 = sphereSDF(point - o1, radius);\n    float p2 = sphereSDF(point - o2, radius);\n    float p = unionSDF(p1, p2);\n    float n = torusSDF(point - vec3(radius * sqrt(2.), 0., 0.), vec2(radius * sqrt(2.), radius));\n    float phi1 = dot(normalize(o2 - o1), normalize(point - o1));\n    float phi2 = dot(normalize(o1 - o2), normalize(point - o2));\n    if (phi1 > sqrt(2.) / 2. && phi2 > sqrt(2.) / 2.)\n        return -n;\n    else\n        return p;\n}\n\nfloat dumbbellCylinderSDF(vec3 point, float radius, float height) {\n    float p1 = cylinderSDF(point - vec3(0., 0., 0.), height, radius);\n    float p2 = cylinderSDF(point - vec3(radius * 2. * sqrt(2.), 0., 0.), height, radius);\n    float p = unionSDF(p1, p2);\n    float n1 = cylinderSDF(point - vec3(radius * sqrt(2.), radius * sqrt(2.), 0.), height * 8., radius);\n    float n2 = cylinderSDF(point - vec3(radius * sqrt(2.), radius * -sqrt(2.), 0.), height * 8., radius);\n    float n = unionSDF(n1, n2);\n    float c1 = cylinderSDF(point - vec3(radius * sqrt(2.), 0., 0.), height, radius);\n    float m = differenceRoundSDF(c1, n, 0.);\n    return unionSDF(p, m);\n}\n\nfloat dumbbellSDF(vec3 point, float radius, float height, float rounding) {\n    float d1 = dumbbellCylinderSDF(point, radius, height);\n    float d2 = dumbbellSphereSDF(point, radius);\n    return mix(d1, d2, .2) - rounding;\n}\n\nfloat bellSDF(vec3 point, float radius, float height, float rounding) {\n    float a1 = cylinderSDF(point, height, radius);\n    float a2 = sphereSDF(point, radius);\n    return mix(a1, a2, .2) - rounding;\n}\n\nfloat nanoLogoSDF(vec3 point, float radius, float height, float rounding) {\n    float a = bellSDF(point, radius, height, rounding);\n    float b1 = dumbbellSDF(point - vec3(radius * 2. * sqrt(2.), 0., 0.), radius, height, rounding);\n    float b2 = dumbbellSDF(point.yxz - vec3(0., radius * 4. * sqrt(2.), 0.), radius, height, rounding);\n    float b = unionSDF(b1, b2);\n    float c1 = dumbbellSDF(point - vec3(radius * 4. * sqrt(2.), radius * 4. * sqrt(2.), 0.), radius, height, rounding);\n    float c2 = dumbbellSDF(point - vec3(radius * 6. * sqrt(2.), radius * 4. * sqrt(2.), 0.), radius, height, rounding);\n    float c = unionSDF(c1, c2);\n    return unionSDF(a, unionSDF(b, c));\n}\n\nvec2 sceneSDF(vec3 point) {\n    float scale = 0.5;\n    float radius = 1. * scale;\n    float height = .1 * scale;\n    float rounding = .15 * scale;\n    vec3 p = point.xzy - vec3(radius * -3. * sqrt(2.), radius * -3. * sqrt(2.), .15);\n    float sdf = nanoLogoSDF(p, radius, height, rounding);\n    return vec2(sdf, 30. + sin(iTime / 10.));\n}\n\n// The following part is a copy-paste from https://www.shadertoy.com/view/Xds3zN\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(5.0,5.0,5.0));\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<200 && t<tmax; i++ )\n        {\n            vec2 h = sceneSDF( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = sceneSDF( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneSDF(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = sceneSDF( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy / iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), (cos(time / 5.) + 1.5) * 5. + 10.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 2.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2SR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 62], [64, 64, 116, 116, 204], [206, 206, 240, 240, 264], [266, 266, 314, 314, 401], [403, 403, 442, 442, 467], [469, 469, 522, 522, 561], [563, 563, 597, 597, 625], [627, 627, 672, 672, 948], [950, 950, 982, 982, 1056], [1058, 1058, 1109, 1109, 1647], [1649, 1649, 1716, 1716, 2310], [2312, 2312, 2387, 2387, 2536], [2538, 2538, 2609, 2609, 2742], [2744, 2744, 2819, 2819, 3425], [3427, 3427, 3454, 3454, 3765], [5445, 5445, 5470, 5470, 5489], [5490, 5490, 5515, 5515, 5534], [5535, 5535, 5571, 5571, 5599], [5601, 5649, 5700, 5700, 5905], [5907, 5907, 5947, 5947, 6761], [6763, 6808, 6886, 6909, 7301], [7303, 7349, 7381, 7381, 7956], [7958, 7958, 8000, 8000, 8314], [8316, 8368, 8432, 8453, 8686], [8688, 8688, 8753, 8772, 11252], [11254, 11254, 11306, 11306, 11483]], "test": "untested"}
{"id": "NsSSzW", "name": "hairy Britney", "author": "FabriceNeyret2", "description": "BuffA pauses the video to avoid the shower door effect.\nOk, very far from\nreference: Murat Yldrm work  ( see image at forum bottom ).\n[url]https://www.designboom.com/art/murat-yildirim-furry-artworks-09-19-2020/[/url]\n", "tags": ["worley", "short", "lic", "hairy"], "likes": 17, "viewed": 568, "published": 3, "date": "1619708605", "time_retrieved": "2024-07-30T19:22:47.527944", "image_code": "#define S(v)    smoothstep(30./R.y,0.,v )\n#define hash(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nfloat h; // pos along line\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    h = clamp(dot(p, b) / dot(b, b), 0., 1.);           // proj coord on line\n    return length(p - b * h);                           // dist to segment\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, I,I0,H,\n         P = ( 2.*u - R ) / R.y,\n         U = 20.*u/R.y,\n      // F = vec2(P.y,-P.x);                            // field direction of hairs\n         F = vec2(1,1);\n  //F = normalize(mix(F,vec2(1),.5+.5*sin(2.*iTime))) ; \n    float l = 1e5, d;\n    O = vec4(0);\n    \n    for( int k=0; k<9; k++ ) {                          // check neighbor cells\n        I = vec2(k%3-1,k/3-1);\n        for (float n=0.; n<17.; n++) {                  // N hair per cell\n            H =  hash(floor(U)+I+n/1.71);               // random position in cell\n            P = I + H + .05*cos(5.*iTime+n+vec2(0,11)); // relative to current cell, + motion\n         // d = length(fract(U)-P);                     // ( used only to draw debug points )\n         // if ( d < l ) l = d, I0=I; // P0 = P;        // ( used only to draw debug points )\n            O = max( O,  \n                     S( line(fract(U),I+.5,P-F))        // blend hair strends\n                  // S( line(fract(U),I+H,P-F))         // variant without strends\n                     * texture(iChannel0, (floor(U)+I+.5*H) *R.y/20./R ) *h ); // hair color\n        }\n    }\n                                                        // debug:\n//O = vec4( S(l-.1) );                                  //  show points\n//O = S(l-.1) *vec4(mod(floor(U)+I0,2.),.5,1) ;         //  color points(tile)\n//O = mix( vec4(mod(floor(U),2.),0,1), O, O.a );        //  show tiles\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// select a frame in the video\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n    O = iChannelTime[1] < .9\n          ? texture(iChannel1, U ) \n          : texture(iChannel0, U );\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSSzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 148, 183, 183, 359], [361, 361, 399, 399, 1840]], "test": "untested"}
{"id": "7d2Xzh", "name": " - Satellite Blueprint", "author": "totetmatt", "description": "Blueprint, but in Green", "tags": ["green", "holo", "satellite"], "likes": 5, "viewed": 274, "published": 3, "date": "1619697729", "time_retrieved": "2024-07-30T19:22:48.294893", "image_code": "#define fGlobalTime iTime\nfloat box(vec3 p,vec3 b){\n  vec3 q=abs(p)-b;\n  return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nmat2 rot(float a){\n     float c=cos(a),s=sin(a);return mat2(c,-s,s,c);\n}\nvec2 obj(vec3 p){\n p.z = -abs(p.z)+0.001;\n  vec2 h = vec2(1.);\n  h.x = box(p,vec3(.3,.5,.02));\n  h.x = min(h.x,box(p+vec3(.0,.5,.0),vec3(.05,.45,.01)));\n  \n  vec3 pp=p;\n\n  pp.xy =abs(pp.xy)-vec2(.15,.25);\n  pp.xy*=2.;\n  pp.xy =abs(pp.xy)-vec2(.15,.25);\n  pp.z+=.03;\n   \n  float d = box(pp,vec3(.14,.24,.03));\n  h.x = max(h.x,-d);\n  return h;\n  }\n  \n float sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n  float acc= 0.;\nvec2 sdf(vec3 p){\n \n  p.xz*=rot(.5+fGlobalTime);\n  p.xy*=rot(.5+fGlobalTime*.2);\n  float tt = texture(iChannel0,(asin(p.xy*5.)*cos(p.yz*2.))*.1+vec2(.1,0.)).g;\n  tt = floor(tt*100.)/100.;\n  float q = sdCappedCylinder(p.xzy,.30+tt*.017,.75+tt*.25)*.8;\n  \n  p.y = abs(p.y) - 1.;\n  vec2 h = obj(p);\n  h.x = min(h.x,q);\n  return h;\n}\nvec2 nv=vec2(-.001,.001);\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yyx)+q(nv.yxy)+q(nv.xxx));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n\tvec3 col = vec3(.1);\n  \n  vec2 zuv = fract(uv*50.);\n \n  if( abs(zuv.x) >= .990 || abs(zuv.y)  >= .990){\n      col = (exp(10.*-fract(fGlobalTime-length(uv))*abs(zuv.x-.5))+exp(5.*-abs(zuv.y-.5)))*vec3(.1,.9,.1);\n  }\n  vec3 ro=vec3(0.,0.,-3.),rd=normalize(vec3(uv,1.)),rp=ro;\n  vec3 lid=vec3(1.,2.,-3.),lic=vec3(.9,.0,.1);\n  \n  \n  for(float i=0.;i<=69.;i++){\n      vec2 d= sdf(rp);\n      acc += exp(5.*-d.x)/(69.+rp.y*10.);\n    d.x = max(0.0005+tan(uv.y*1000.)+sin(fGlobalTime+rp.y+rp.x*.5),d.x);\n      if(d.x<=0.001){\n        vec3 n = norm(rp);\n        //rd = reflect(rd,n);\n        \n        col=lic*max(0.,dot(normalize(lid),n))*sqrt(acc/length(ro-rp));\n        \n      }\n      \n      rp += rd*d.x;\n  }\n\n  col +=acc*.7*vec3(.1,1.,.1);\n\n  \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2Xzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 51, 51, 136], [137, 137, 155, 155, 209], [210, 210, 227, 227, 555], [560, 560, 612, 612, 719], [737, 737, 754, 754, 1066], [1119, 1119, 1137, 1137, 1196], [1198, 1198, 1255, 1305, 2167]], "test": "untested"}
{"id": "ss2Xzh", "name": "Marble Painting", "author": "wyatt", "description": "Mouse to paint ! Thanks to Flexi for the inspiration", "tags": ["fluid", "automata"], "likes": 29, "viewed": 876, "published": 3, "date": "1619681253", "time_retrieved": "2024-07-30T19:22:49.189501", "image_code": "// Fork of \"Colors!\" by wyatt. https://shadertoy.com/view/7dX3z7\n// 2021-04-29 06:26:31\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display \n\nMain \n{\n    float h = Paper(U);\n    Q = 1.5*D(U)+.8*C(U)*A(U).w;\n    Q = .8+h-Q;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\nfloat hash(vec2 p) // Dave H\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat Paper (vec2 U) { //https://www.shadertoy.com/view/NsfXWs\n    float h = .005*(sin(.6*U.x+.1*U.y)+sin(.7*U.y-.1*U.x));\n    for (float x = -1.; x<=1.;x++)\n    for (float y = -1.; y<=1.;y++){\n        h += .15*.125*hash(U+vec2(x,y));\n    }\n    return h;\n}", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 m = C(U);\n    float d = dot(m,vec4(-1,1,-1,1));\n    box if(x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 c = C(U+u);\n        float p = .1*Paper(U+u);\n        float f = length(m-c)*d;\n        Q.xy -= 0.1*a.w*(p+a.w-Q.w*f-1.)*u;  \n    }\n    Q.w *= 1.-1e-4;\n    //Q.y -= 1e-4*Q.w;\n    Q.xy *= 1.-exp(-10.*Q.w);\n    if (iMouse.z>0.&&length(U-iMouse.xy)<40.)\n        Q.w = 1.;\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    Q.w = clamp(Q.w,0.,3.);\n    if (iFrame < 1)Q = vec4(0,0,0.,.05);\n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-Q.w*q.w,0.);\n       float k = .5+.5*max(1.-Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 Qb = B(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u),\n             qb = B(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;\n       float k = .5;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Qb.xyz*wa+qb.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    if (iMouse.z>0.&&length(U-iMouse.xy)<40.)\n        Q = 0.5+0.5*sin(vec4(1,2,3,4)+iTime);\n    if (iFrame<1)\n        Q = 0.5+0.5*sin(vec4(1,2,3,4)*4.*length(U-0.5*R)/R.x);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = D(U);\n    vec4 a = A(U);\n    vec4 c = C(U)*a.w;\n    \n    Q = mix(Q,c,.001*a.w*a.w);\n    \n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2Xzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7sjSRh", "name": "what is a parabola", "author": "elenzil", "description": "reminding myself what a parabola is.\nturns out it's the set of points equidistant from a point and a line.\nwho knew ???", "tags": ["parabola"], "likes": 4, "viewed": 246, "published": 3, "date": "1619664889", "time_retrieved": "2024-07-30T19:22:50.135970", "image_code": "float sdCircle(in vec2 p, in vec2 c, in float r) {\n    return length(p - c) - r;\n}\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec2 c  = iMouse.x > 50.0 ? iMouse.xy : vec2(cos(iTime * 0.32), sin(iTime * 0.3)) * (min(iResolution.x, iResolution.y)/2.0 - 110.0) + iResolution.xy/2.0;\n    float d1 = abs(((XY - iResolution.xy / 2.0) * rot2(iTime * 0.11)).y);\n    float d2 = sdCircle(XY, c, 100.0);\n    float d3 = sdCircle(XY, c,   0.0);\n    float d4 = sdCircle(XY, iResolution.xy / 2.0, 100.0);\n    \n   \n    RGBA.a  = 1.0;\n    \n    // equidistance from a circle and a line\n    RGBA.r  = smoothstep(3.0, 1.0, abs(d1 - d2) / fwidth(d1 - d2));\n\n    // equidistance from a point and a line\n    RGBA.g  = smoothstep(3.0, 1.0, abs(d1 - d3) / fwidth(d1 - d2));\n    \n    // equidistance from a circle and a point\n    RGBA.rg = max(RGBA.rg, smoothstep(3.0, 1.0, abs(d3 - d4) / fwidth(d3 - d4)));\n\n    RGBA.b  = 0.0;\n    RGBA.b  = max(RGBA.b, smoothstep(3.0, 1.0, abs(d1)));\n    RGBA.b  = max(RGBA.b, smoothstep(3.0, 1.0, abs(d2)));\n    RGBA.b  = max(RGBA.b, smoothstep(3.0, 1.0, abs(d4)));\n    RGBA.b  = max(RGBA.b, smoothstep(3.0, 1.0, abs(sdCircle(XY, c,   1.0))));\n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjSRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 82], [84, 84, 108, 108, 192], [194, 194, 239, 239, 1288]], "test": "untested"}
{"id": "NsjXz1", "name": "Shera---She-Ra", "author": "jorge2017a1", "description": "Shera---She-Ra", "tags": ["sherashera"], "likes": 3, "viewed": 283, "published": 3, "date": "1619663735", "time_retrieved": "2024-07-30T19:22:51.123330", "image_code": "//por jorge2017a1 ----jorgeFloresP---28/abril/2021\n// referencia\n//https://www.shadertoy.com/view/tlGBW3\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\n////-------------------\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.73,.26),vec2(.68,.28),vec2(.60,.29),vec2(.54,.27),vec2(.52,.25),\nvec2(.53,.21),vec2(.54,.20),vec2(.55,.16),vec2(.68,.18),vec2(.73,.26) );\n\nfloat sdPoly27 POLY(27)\nvec2 pt27[ 27]=vec2[](  \nvec2(.20,.83),vec2(.19,.75),vec2(.21,.69),vec2(.24,.62),vec2(.28,.54),\nvec2(.30,.50),vec2(.27,.45),vec2(.22,.39),vec2(.19,.35),vec2(.17,.29),\nvec2(.20,.25),vec2(.26,.22),vec2(.30,.20),vec2(.31,.21),vec2(.26,.22),\nvec2(.21,.26),vec2(.18,.30),vec2(.19,.36),vec2(.23,.40),vec2(.28,.46),\nvec2(.30,.51),vec2(.29,.54),vec2(.25,.62),vec2(.21,.69),vec2(.19,.76),\nvec2(.21,.84),vec2(.20,.83) );\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.44,.60),vec2(.63,.45),vec2(.63,.42),vec2(.64,.42),vec2(.63,.45),\nvec2(.45,.60),vec2(.44,.60) );\n\nfloat sdPoly24 POLY(24)\nvec2 pt24[ 24]=vec2[](  \nvec2(.45,.60),vec2(.53,.53),vec2(.40,.47),vec2(.37,.45),vec2(.35,.41),\nvec2(.30,.13),vec2(.19,.06),vec2(.27,.07),vec2(.29,.09),vec2(.31,.10),\nvec2(.33,.10),vec2(.35,.09),vec2(.67,.17),vec2(.71,.24),vec2(.76,.37),\nvec2(.72,.38),vec2(.69,.40),vec2(.69,.43),vec2(.70,.47),vec2(.71,.51),\nvec2(.70,.54),vec2(.67,.62),vec2(.64,.66),vec2(.45,.60) );\n\nfloat sdPoly35 POLY(35)\nvec2 pt35[ 35]=vec2[](  \nvec2(.46,1.00),vec2(.41,.99),vec2(.38,.98),vec2(.34,.95),vec2(.30,.90),\nvec2(.28,.88),vec2(.28,.85),vec2(.27,.83),vec2(.27,.82),vec2(.25,.80),\nvec2(.24,.79),vec2(.24,.76),vec2(.25,.73),vec2(.27,.70),vec2(.28,.66),\nvec2(.29,.63),vec2(.29,.62),vec2(.31,.61),vec2(.34,.61),vec2(.39,.60),\nvec2(.45,.61),vec2(.56,.63),vec2(.62,.66),vec2(.64,.67),vec2(.64,.69),\nvec2(.64,.73),vec2(.63,.74),vec2(.65,.80),vec2(.67,.81),vec2(.68,.84),\nvec2(.66,.89),vec2(.59,.91),vec2(.49,.96),vec2(.47,.98),vec2(.46,1.00) );\n\nfloat sdPoly28 POLY(28)\nvec2 pt28[ 28]=vec2[](  \nvec2(.41,.60),vec2(.42,.55),vec2(.45,.51),vec2(.45,.45),vec2(.42,.40),\nvec2(.41,.35),vec2(.43,.32),vec2(.47,.31),vec2(.53,.33),vec2(.55,.35),\nvec2(.56,.39),vec2(.53,.41),vec2(.49,.41),vec2(.51,.39),vec2(.51,.36),\nvec2(.50,.35),vec2(.46,.35),vec2(.43,.36),vec2(.43,.39),vec2(.45,.40),\nvec2(.48,.42),vec2(.52,.43),vec2(.56,.45),vec2(.59,.48),vec2(.56,.51),\nvec2(.50,.56),vec2(.45,.60),vec2(.41,.60) );\n\nfloat sdPoly21 POLY(21)\nvec2 pt21[ 21]=vec2[](  \nvec2(.46,1.00),vec2(.39,1.00),vec2(.36,.98),vec2(.30,.91),vec2(.25,.88),\nvec2(.18,.81),vec2(.16,.73),vec2(.20,.64),vec2(.24,.55),vec2(.24,.50),\nvec2(.14,.42),vec2(.08,.35),vec2(.11,.28),vec2(.19,.21),vec2(.30,.19),\nvec2(.33,.29),vec2(.34,.38),vec2(.36,.44),vec2(.45,.50),vec2(.54,.52),\nvec2(.46,1.00) );\n\nfloat sdPoly44 POLY(44)\nvec2 pt44[ 44]=vec2[](  \nvec2(.46,1.00),vec2(.48,.98),vec2(.53,.94),vec2(.66,.89),vec2(.67,.86),\nvec2(.66,.82),vec2(.63,.75),vec2(.64,.67),vec2(.67,.61),vec2(.70,.53),\nvec2(.69,.44),vec2(.69,.41),vec2(.72,.39),vec2(.78,.37),vec2(.85,.37),\nvec2(.89,.35),vec2(.90,.31),vec2(.89,.29),vec2(.84,.28),vec2(.79,.29),\nvec2(.78,.31),vec2(.80,.32),vec2(.79,.32),vec2(.76,.31),vec2(.74,.29),\nvec2(.76,.27),vec2(.78,.26),vec2(.83,.26),vec2(.88,.27),vec2(.94,.30),\nvec2(.98,.34),vec2(.97,.38),vec2(.96,.42),vec2(.95,.46),vec2(.98,.51),\nvec2(.99,.53),vec2(.99,.78),vec2(.96,.80),vec2(.94,.84),vec2(.93,.89),\nvec2(.92,.95),vec2(.88,.98),vec2(.74,1.00),vec2(.46,1.00) );\n\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.33,.09),vec2(.48,.13),vec2(.63,.16),vec2(.69,.18),vec2(.70,.20),\nvec2(.81,.52),vec2(.84,.55),vec2(.87,.56),vec2(.94,.56),vec2(.98,.56),\nvec2(1.00,.22),vec2(.89,.06),vec2(.79,.02),vec2(.70,.01),vec2(.33,.01),\nvec2(.32,.03),vec2(.32,.06),vec2(.33,.09) );\n\nfloat sdPoly16 POLY(16)\nvec2 pt16[ 16]=vec2[](  \nvec2(.30,.70),vec2(.28,.71),vec2(.29,.73),vec2(.32,.73),vec2(.34,.73),\nvec2(.36,.73),vec2(.37,.73),vec2(.40,.71),vec2(.43,.69),vec2(.43,.69),\nvec2(.39,.69),vec2(.37,.70),vec2(.33,.71),vec2(.32,.70),vec2(.31,.70),\nvec2(.30,.70) );\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.30,.70),vec2(.31,.70),vec2(.31,.70),vec2(.37,.69),vec2(.37,.70),\nvec2(.41,.69),vec2(.40,.68),vec2(.38,.67),vec2(.32,.67),vec2(.30,.68),\nvec2(.30,.68),vec2(.29,.69),vec2(.29,.70),vec2(.30,.70) );\n\nfloat sdPoly17a POLY(17)\nvec2 pt17a[ 17]=vec2[](  \nvec2(.33,.96),vec2(.29,.90),vec2(.29,.90),vec2(.34,.90),vec2(.41,.90),\nvec2(.53,.89),vec2(.64,.86),vec2(.69,.85),vec2(.70,.85),vec2(.71,.88),\nvec2(.74,.90),vec2(.76,.90),vec2(.70,.93),vec2(.59,.95),vec2(.45,.97),\nvec2(.38,.97),vec2(.33,.96) );\n\nfloat sdPoly17b POLY(17)\nvec2 pt17b[ 17]=vec2[](  \nvec2(.76,.91),vec2(.73,.89),vec2(.70,.87),vec2(.71,.84),vec2(.73,.81),\nvec2(.76,.81),vec2(.81,.83),vec2(.81,.85),vec2(.82,.87),vec2(.87,.90),\nvec2(.95,.92),vec2(.98,.94),vec2(.99,.99),vec2(.94,.96),vec2(.84,.93),\nvec2(.78,.92),vec2(.76,.91) );\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.83,.88),vec2(.87,.87),vec2(.93,.88),vec2(.98,.89),vec2(.98,.94),\nvec2(.94,.93),vec2(.91,.92),vec2(.83,.88),vec2(.83,.88) );\n\nfloat sdPoly21b POLY(21)\nvec2 pt21b[ 21]=vec2[](  \nvec2(.83,.88),vec2(.87,.87),vec2(.93,.88),vec2(.98,.89),vec2(.98,.94),\nvec2(.94,.93),vec2(.91,.92),vec2(.83,.88),vec2(.83,.88),vec2(.82,.85),\nvec2(.82,.83),vec2(.83,.82),vec2(.88,.82),vec2(.95,.83),vec2(.99,.85),\nvec2(.98,.88),vec2(.95,.88),vec2(.90,.87),vec2(.85,.88),vec2(.83,.88),\nvec2(.83,.88) );\n\nfloat sdPoly17c POLY(17)\nvec2 pt17c[ 17]=vec2[](  \nvec2(.80,.83),vec2(.79,.82),vec2(.77,.81),vec2(.77,.81),vec2(.79,.79),\nvec2(.83,.78),vec2(.89,.78),vec2(.93,.80),vec2(.96,.81),vec2(.98,.83),\nvec2(.97,.84),vec2(.92,.82),vec2(.85,.82),vec2(.82,.83),vec2(.82,.84),\nvec2(.79,.82),vec2(.80,.83) );\n\n\nfloat sdPoly19 POLY(19)\nvec2 pt19[ 19]=vec2[](  \nvec2(.43,.90),vec2(.44,.88),vec2(.47,.88),vec2(.50,.88),vec2(.53,.87),\nvec2(.56,.87),vec2(.57,.86),vec2(.58,.84),vec2(.59,.84),vec2(.59,.84),\nvec2(.58,.84),vec2(.57,.86),vec2(.56,.86),vec2(.53,.87),vec2(.50,.87),\nvec2(.47,.88),vec2(.44,.88),vec2(.43,.89),vec2(.43,.90) );\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.34,.89),vec2(.28,.88),vec2(.28,.87),vec2(.34,.89),vec2(.34,.89) );\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat sdPoly7b POLY(7)\nvec2 pt7b[ 7]=vec2[](  \nvec2(.34,.86),vec2(.30,.85),vec2(.26,.85),vec2(.26,.84),vec2(.30,.85),\nvec2(.34,.85),vec2(.34,.86) );\n\nfloat sdPoly19b POLY(19)\nvec2 pt19b[ 19]=vec2[](  \nvec2(.43,.85),vec2(.46,.84),vec2(.47,.84),vec2(.50,.84),vec2(.52,.84),\nvec2(.54,.83),vec2(.56,.81),vec2(.56,.81),vec2(.60,.80),vec2(.60,.80),\nvec2(.56,.80),vec2(.56,.81),vec2(.54,.82),vec2(.52,.83),vec2(.50,.84),\nvec2(.47,.84),vec2(.46,.84),vec2(.43,.85),vec2(.43,.85) );\n\nfloat sdPoly8 POLY(8)\nvec2 pt8[ 8]=vec2[](  \nvec2(.34,.85),vec2(.29,.84),vec2(.29,.83),vec2(.30,.82),vec2(.33,.81),\nvec2(.34,.82),vec2(.34,.84),vec2(.34,.85) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.46,.83),vec2(.44,.81),vec2(.46,.80),vec2(.49,.80),vec2(.53,.80),\nvec2(.56,.80),vec2(.54,.81),vec2(.53,.83),vec2(.50,.84),vec2(.47,.83),\nvec2(.45,.82),vec2(.46,.83) );\n\nfloat sdPoly19c POLY(19)\nvec2 pt19c[ 19]=vec2[](  \nvec2(.33,.87),vec2(.34,.85),vec2(.34,.83),vec2(.33,.81),vec2(.31,.79),\nvec2(.29,.78),vec2(.29,.77),vec2(.31,.76),vec2(.34,.76),vec2(.35,.76),\nvec2(.31,.76),vec2(.29,.77),vec2(.30,.79),vec2(.31,.80),vec2(.33,.82),\nvec2(.35,.83),vec2(.35,.85),vec2(.34,.87),vec2(.33,.87) );\n\nfloat sdPoly5b POLY(5)\nvec2 pt5b[ 5]=vec2[](  \nvec2(.65,.77),vec2(.59,.75),vec2(.59,.74),vec2(.65,.77),vec2(.65,.77) );\n\nfloat sdPoly15 POLY(15)\nvec2 pt15[ 15]=vec2[](  \nvec2(.78,.77),vec2(.81,.71),vec2(.85,.64),vec2(.83,.58),vec2(.78,.53),\nvec2(.73,.49),vec2(.71,.47),vec2(.72,.47),vec2(.74,.49),vec2(.79,.53),\nvec2(.83,.58),vec2(.86,.64),vec2(.82,.71),vec2(.79,.77),vec2(.78,.77) );\n\n\n\nvec3 Rostroshera(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  \n  \n  float sd1 = sdPoly7(p, pt7); //\n  float sd2 = sdPoly24(p, pt24); //\n  float sd3 = sdPoly35(p, pt35); //\n  float sd4 = sdPoly28(p, pt28); //\n  float sd5 = sdPoly21(p, pt21); //\n  float sd6 = sdPoly44(p, pt44); //\n  float sd7 = sdPoly18(p, pt18); //\n  float sd8 = sdPoly16(p, pt16); //\n  float sd9 = sdPoly14(p, pt14); //\n  float sd10 = sdPoly10(p, pt10); //\n  float sd11 = sdPoly27(p, pt27); //\n  float sd12 = sdPoly17a(p, pt17a); //\n  float sd13 = sdPoly17b(p, pt17b); //\n  float sd14 = sdPoly9(p, pt9); //\n  float sd15 = sdPoly21b(p, pt21b); //\n  float sd16 = sdPoly17c(p, pt17c); //\n  float sd17 = sdPoly19(p, pt19); //\n  float sd18 = sdPoly5(p, pt5); //\n  float sd19 = sdPoly7b(p, pt7b); \n  float sd20 = sdPoly19b(p, pt19b); \n  float sd21 = sdPoly8(p, pt8); \n  float sd22 = sdPoly12(p, pt12); \n  float movx=0.015*sin(iTime);\n  float sd23= sdCircle( p-vec2(0.49+movx,0.82), 0.019 ); //der\n  float sd24= sdCircle( p-vec2(0.31+movx,0.835), 0.017 );//izq\n  float sd25 = sdPoly19c(p, pt19c); \n  float sd26 = sdPoly5b(p, pt5b); \n  float sd27 =sdPoly15(p, pt15); \n  \n  \n  vec3 colPiel=vec3(1.00,0.68,0.79);\n  vec3 colPiel2=vec3(0.96,0.65,0.04);\n  vec3 colPelo=vec3(1.0, 0.8,0.2);\n  col = mix(col,colPelo,S(sd5,0.0));  // pelo 2   interior\n  col = mix(col,vec3(1.0, 0.6,0.5),S(sd1,0.0));\n  \n  col= ponerBorde(colPiel,col,sd7);//brazo der\n  col= ponerBorde(colPiel,col,sd2);//cuerpo\n  col= ponerBorde(colPiel,col,sd3);//borde rostro\n  col= ponerBorde(colPelo,col,sd4);//pelo izq. adelante\n  col= ponerBorde(colPelo,col,sd6);//pelo der. adelante\n  col = mix(col,vec3(0.64,0.01,0.00),S(sd8,0.0));  //labio superior\n  col = mix(col,vec3(0.64,0.01,0.00),S(sd9,0.0));  //labio inferior\n  col = mix(col,vec3(0.81,0.18,0.00),S(sd10,0.0));  //busto\n  col = mix(col,vec3(0.0),S(sd11,0.0));  // ondulado negro\n  col= ponerBorde(vec3(0.86,0.19,0.00),col,sd12);\n  col= ponerBorde(vec3(0.86,0.19,0.00),col,sd13);\n  col= ponerBorde(vec3(0.86,0.19,0.00),col,sd14);\n  col= ponerBorde(vec3(0.86,0.19,0.00),col,sd15);\n  col= ponerBorde(vec3(0.86,0.19,0.00),col,sd16); //alas\n  col = mix(col,vec3(0.0) ,S( sd17,0.0)); //pestaa der\n  col = mix(col,vec3(0.0) ,S( sd18,0.0)); //pestaa izq\n  col = mix(col,vec3(0.0) ,S( sd19,0.0)); //sommbra ojo izq\n  col = mix(col,vec3(0.0) ,S( sd20,0.0));  //sombra ojo der\n  col = mix(col,vec3(1.0) ,S( sd21,0.0));  //pupila izq\n  col = mix(col,vec3(1.0) ,S( sd22,0.0));  //pupila der\n  col = mix(col,vec3(0.0) ,S( sd23,0.0));   //cornea izq\n  col = mix(col,vec3(0.0) ,S( sd24,0.0));  //cornea der\n  col = mix(col,vec3(0.0) ,S( sd25,0.0));  //nariz\n  col = mix(col,vec3(0.0) ,S( sd26,0.0));\n  col = mix(col,vec3(0.0) ,S( sd27,0.0));\n  \n  \n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    //posicion\n    vec2 p=uv+vec2(1.5,0.9);\n    p*=1.7;\n    p.x*=0.96;\n    p.y*=0.6; p.y+=0.1;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col=vec3((col.x+col.y+col.z)/3.0)*vec3(0.2,0.2,1.0);\n     col= Rostroshera( p,col*2.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjXz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 249, 249, 273], [6622, 6622, 6682, 6682, 6806], [8379, 8379, 8420, 8420, 11108], [11109, 11109, 11166, 11166, 11496]], "test": "untested"}
{"id": "7sBSzh", "name": "Chamber swarms", "author": "jarble", "description": "These swarms are separated by walls with fluctuating boundaries.", "tags": ["automata", "feedback", "swarm", "cellularautomata"], "likes": 5, "viewed": 297, "published": 3, "date": "1619627818", "time_retrieved": "2024-07-30T19:22:51.875320", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 2.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 7.0;\n\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = A/2.0;\nconst float NUM_NEIGH = A;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum += GET(d);\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL + ((cen-NUM_NEIGH) * (sum-cen));\n\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val =\n                        new_val\n                        //min(new_val,min_dist/16.)\n                    ;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBSzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 284]], "test": "untested"}
{"id": "wldfWf", "name": "2D SaintVenant", "author": "EvilRyu", "description": "An implementation of the paper:\nA SECOND-ORDER WELL-BALANCED POSITIVITY PRESERVING CENTRAL-UPWIND SCHEME FOR THE SAINT-VENANT SYSTEM\nhttps://www.intlpress.com/site/pub/files/_fulltext/journals/cms/2007/0005/0001/CMS-2007-0005-0001-a006.pdf", "tags": ["simulation", "water", "shallowwaterequation", "saintvenant"], "likes": 5, "viewed": 489, "published": 3, "date": "1619627299", "time_retrieved": "2024-07-30T19:22:52.807827", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// 2D Saint-Venant system of Shallow Water Equation\n// An implementation of the paper:\n// A SECOND-ORDER WELL-BALANCED POSITIVITY PRESERVING CENTRAL-UPWIND SCHEME FOR THE SAINT-VENANT SYSTEM\n// https://www.intlpress.com/site/pub/files/_fulltext/journals/cms/2007/0005/0001/CMS-2007-0005-0001-a006.pdf\n// 1D version here: https://www.shadertoy.com/view/wt3BDH\n\n#define FAR 200.\n#define PI 3.1415926535\n#define MATE_TERRIAN 0.\n#define MATE_WATER 1.\n\nvoid rot2d(inout vec2 p, float t)\n{\n    float ct=cos(t),st=sin(t);\n    vec2 q=p;\n\tp.x=ct*q.x+st*q.y;\n    p.y=-st*q.x+ct*q.y;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 getCellUV(vec2 uv)\n{\n    return uv * vec2( NUM_CELLS_X / iResolution.x, NUM_CELLS_Y / iResolution.y);\n}\n\nfloat water(vec2 p)\n{\n    return textureLod(iChannel0, p, 0.).x;\n}\n\n// bottom topology\nfloat B(vec2 uv)\n{\n    return terrian(uv * iResolution.x/64.);\n}\n\nbool refrRay = false;\n\nvec2 map(vec3 p)\n{\n    // the terrian is 100x100 size\n    float d = p.y - B(getCellUV((p.xz + 50.) / 100.));\n    float d1 = 1e5;\n\n    if(!refrRay)\n    {\n        d1 = p.y - water(getCellUV((p.xz + 50.) / 100.));\n        float mateid;\n        if(d < d1)  mateid = MATE_TERRIAN;\n        else        mateid = MATE_WATER;\n    \n        return vec2(smin(d, d1, .1), mateid);\n    }\n    \n    return vec2(d, MATE_TERRIAN);\n}\n\n\nvec3 getNormal(vec3 p, float t, float mate)\n{\n    vec2 e = vec2(0.001 * t , 0.);\n    if(mate == MATE_WATER) e.x = 0.1*t;\n    return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x,\n                          map(p + e.yxy).x - map(p - e.yxy).x,\n                          map(p + e.yyx).x - map(p - e.yyx).x));\n}\n\nvec3 getTerrianNormal(vec2 pos, float t)\n{   \n    vec2 e = vec2(0.001*t,0.0);\n\treturn normalize(vec3(terrian(pos-e.xy)-terrian(pos+e.xy),\n                           2.0*e.x,\n                           terrian(pos-e.yx)-terrian(pos+e.yx)));\n}\n\n\nvec2 intersect(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    float t = tmin;\n    vec2 res = vec2(1e5, 0.);\n    vec3 p;\n    for(int i = 0; i < 256; ++i)\n    {\n        if(res.x < 0.002 || t > tmax)\n        {\n            break;\n        }\n        \n        p = ro + t * rd;\n        \n        // the terrian is 100x100 size\n        if(abs(p.x) > 50. || abs(p.z) > 50.)\n        {\n            t = tmax;\n            break;\n        }\n        res = map(p);\n        t += res.x * .5;\n    }\n    \n    return vec2(t, res.y);\n}\n\nvec3 sunDir = normalize(vec3(1., 1., 0.));\nvec3 sunCol = vec3(1.000,0.980,0.898) * 2.;\nvec3 terrianBasecol = vec3(0.263,0.231,0.137);\nvec3 waterBaseCol = vec3(0.000,0.533,1.000);\n\nvec3 sceneRefr(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    refrRay = true;\n    vec3 col = vec3(0.004,0.318,0.557);\n    vec2 res = intersect(ro, rd, tmin, tmax);\n    if(res.x < tmax)\n    {\n        vec3 p = ro + rd * res.x;\n        vec3 n = getNormal(p, 1., res.y);\n        float dif = 1.*max(0., dot(sunDir, n));\n        col = terrianBasecol * dif;\n    }\n    \n    refrRay=false;\n    return col;\n}\n\nvec3 shading(vec3 pos, vec3 ro, vec3 rd, vec3 n, float t, float mateid)\n{\n    float dif = max(0., dot(sunDir, n));\n    float bac = max(0., dot(-sunDir, n));\n    float amb = max(0., dot(n, vec3(0,1,0)));\n    vec3 refl = normalize(reflect(rd, n));\n    vec3 refr = refract(rd, n, 1./1.33);\n    float spe = max(0.0, pow(clamp(dot(sunDir, refl), 0.0, 1.0), 32.0));\n    float fre = clamp(1.0 + dot(rd, n), .0, 1.); \n    vec3 col = vec3(0., 0.5, 1.);\n    \n    col += sunCol*(4.*dif + 1.*bac) + vec3(0.,.5,1.)*1.5*amb;\n    col *= terrianBasecol;\n    \n    if(mateid == MATE_WATER)\n    {\n        vec3 wcol = (1. * dif + 1. * spe + .5 * amb) * waterBaseCol * .3;\n        wcol += mix(sceneRefr(pos, refl, 0.1, 100.), sceneRefr(pos, refr, 0.01, 20.), .5);\n        float h = water(getCellUV((pos.xz + 50.)/100.)) - B(getCellUV((pos.xz+50.)/100.));\n        col = mix(col, wcol, smoothstep(.0, 0.3, h));\n    }\n    \n    col *= 0.2;\n    return col;\n}\n\nvec3 scene(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    vec3 col = vec3(0);\n    vec2 res = intersect(ro, rd, tmin, tmax);\n    float t = res.x, mateid = res.y;\n    if(t < tmax)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = getNormal(pos, 10., mateid);\n        col = shading(pos, ro, rd, n, t, mateid);\n    }\n    \n    col=mix(col, vec3(0.020,0.020,0.020), 1.-exp(-.0001*t*t));\n    return col;\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(-0., 41., 20.);\n    vec3 ta = ro + vec3(0,-2.5,-1.);\n        \n    \n    vec3 f = normalize(ta - ro);\n    vec3 r = normalize(cross(f, vec3(0,1,0)));\n    vec3 u = normalize(cross(r, f));\n    \n    vec3 rd = normalize(mat3(r, u, f) * vec3(p.x, p.y, 1.2));\n    \n    // debugging camera\n    float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    if(iMouse.z>0.||iMouse.w>0.)\n    {\n        rot2d(rd.xz, iMouse.x*.1);\n    }\n    \n    vec3 col = scene(ro, rd, 0.01, FAR);\n    col=pow(col, vec3(0.9));\n    col=tonemap(col);\n    col=pow(clamp(col,0.,1.0),vec3(0.45));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Saint-Venant system of Shallow Water Equation\n\n// Limiter to ensure non-oscillatory reconstruction\nvec3 minmod(vec3 a1, vec3 a2, vec3 a3)\n{\n    vec3 res;\n    \n    for(int i = 0; i < 3; ++i)\n    {\n        if(a1[i] > 0. && a2[i] > 0. && a3[i] > 0.)\n        {\n            res[i] = min(min(a1[i], a2[i]), a3[i]);\n        }\n        else if(a1[i] < 0. && a2[i] < 0. && a3[i] < 0.)\n        {\n            res[i] = max(max(a1[i], a2[i]), a3[i]);\n        }\n        else res[i] = 0.;\n    }\n    \n    return res;\n}\n\n// bottom topology\nfloat B(vec2 uv)\n{\n    return terrian(uv * iResolution.x/64.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y > NUM_CELLS_Y || fragCoord.x > NUM_CELLS_X * 4.)\n        return;\n            \n    // Buffer A is divided to 4 NUM_CELLS_X * NUM_CELLS_Y blocks\n    // for storing U_W, U_E, U_S, U_N respectively\n    float blockId = floor(fragCoord.x / NUM_CELLS_X);\n    vec2 uv = (fragCoord - vec2(NUM_CELLS_X * blockId, 0.)) / iResolution.xy;\n    \n\n    // water level: U.x = w\n    // discharge u: U.y = hu\n    // discharge v: U.z = hv\n    vec3 U = texture(iChannel1, uv).xyz;\n\n    // at (j+1, k), (j-1, k), (j, k+1), (j, k-1)\n    vec3 U_jp1 = texture(iChannel1, uv + oneCellX).xyz;\n    vec3 U_jm1 = texture(iChannel1, uv - oneCellX).xyz;\n    vec3 U_kp1 = texture(iChannel1, uv + oneCellY).xyz;    \n    vec3 U_km1 = texture(iChannel1, uv - oneCellY).xyz;\n\n\n    // Boundary\n    if((uv + oneCellX).x > (NUM_CELLS_X - 0.5)/iResolution.x)\n    {\n        U_jp1 = vec3(U.x, -U.y, U.z);\n    }\n\n    if((uv - oneCellX).x < 0.)\n    {\n        U_jm1 = vec3(U.x, -U.y, U.z);\n    }\n\n    if((uv + oneCellY).y > (NUM_CELLS_Y - 0.5)/iResolution.y)\n    {\n        U_kp1 = vec3(U.x, U.y, -U.z);\n    }\n\n    if((uv - oneCellY).y < 0.)\n    {\n        U_km1 = vec3(U.x, U.y, -U.z);\n    }\n\n\n    vec3 Ux, Uy;\n    vec3 a1 = theta * (U - U_jm1) / dx;\n    vec3 a2 = (U_jp1 - U_jm1) / (2.*dx);\n    vec3 a3 = theta * (U_jp1 - U) / dx;\n    Ux = minmod(a1, a2, a3);\n\n    a1 = theta * (U - U_km1) / dy;\n    a2 = (U_kp1 - U_km1) / (2.*dy);\n    a3 = theta * (U_kp1 - U) / dy;\n    Uy = minmod(a1, a2, a3); \n\n    // upwind at j-1/2,k and j,k-1/2\n    // downwind at j+1/2,k and j,k+1/2\n    vec3 U_W = U - dx * 0.5 * Ux;\n    vec3 U_E = U + dx * 0.5 * Ux;\n    vec3 U_N = U + dy * 0.5 * Uy;\n    vec3 U_S = U - dy * 0.5 * Uy;\n\n    // reconstruct water level for positivity preserving\n    // B_f: B/,\n    // B_b: B/,\n    // B_u: B,/\n    // B_d: B,/\n    float B_f = B(uv + halfCellX);\n    float B_b = B(uv - halfCellX);\n    float B_u = B(uv + halfCellY);\n    float B_d = B(uv - halfCellY);\n\n\n    if(U_E.x < B_f)\n    {\n        Ux.x = (B_f - U.x) / (0.5 * dx);\n        U_E.x = B_f;\n        U_W.x = 2. * U.x - B_f;\n    }\n\n    if(U_W.x < B_b)\n    {\n        Ux.x = (U.x - B_b) / (0.5 * dx);\n        U_E.x = 2. * U.x - B_b;\n        if(U_E.x < B_f)\n            U_E.x = B_f;\n        U_W.x = B_b;\n    }\n\n\n    if(U_N.x < B_u)\n    {\n        Uy.x = (B_u - U.x) / (0.5 * dy);\n        U_N.x = B_u;\n        U_S.x = 2. * U.x - B_u;\n    }\n\n    if(U_S.x < B_d)\n    {\n        Uy.x = (U.x - B_d) / (0.5 * dy);\n        U_S.x = B_d;\n        U_N.x = 2. * U.x - B_d;\n\n        if(U_N.x < B_u)\n            U_N.x = B_u;\n    }\n\n    // Also store bottom height at .w, so we don't have compute them again in the next pass\n    if(blockId == 0.)      fragColor = vec4(U_W, B_b);\n    else if(blockId == 1.) fragColor = vec4(U_E, B_f);\n    else if(blockId == 2.) fragColor = vec4(U_S, B_d);\n    else if(blockId == 3.) fragColor = vec4(U_N, B_u);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Saint-Venant system of Shallow Water Equation\n\n#define B0UV (uv)\n#define B1UV (uv + vec2(NUM_CELLS_X, 0.) / iResolution.xy)\n#define B2UV (uv + vec2(NUM_CELLS_X * 2., 0.) / iResolution.xy)\n#define B3UV (uv + vec2(NUM_CELLS_X * 3., 0.) / iResolution.xy)\n\n// bottom topology\nfloat B(vec2 uv)\n{\n    return terrian(uv * iResolution.x/64.);\n}\n\n// where and how much water at the begining\nvec3 initialCondition(vec2 uv, vec2 uv_f, vec2 uv_b)\n{\n    if(uv.x > 0.06 && uv.x < 0.15 && uv.y > 0.15 && uv.y < 0.3)\n    return vec3(2. + B(uv), 0., 0.);\n    else return vec3(B(uv), 0., 0.);\n    //return vec3(2. + B(uv), 0., 0.);\n}\n\nvec2 reconstructSpeed(float h, vec2 huv)\n{\n    float h4 = pow(h, 4.0);\n    return (sqrt(2.) * h * huv) / sqrt(h4 + max(h4, epsilon));\n}\n\nfloat localPropagationSpeedUpwind(float u_p, float u_m, float h_p, float h_m)\n{\n    return max(max(u_p + sqrt(g * h_p), u_m + sqrt(g * h_m)), 0.00001);\n}\n\nfloat localPropagationSpeedDownwind(float u_p, float u_m, float h_p, float h_m)\n{\n    return min(min(u_p - sqrt(g * h_p), u_m - sqrt(g * h_m)), -0.00001);\n}\n\nvec3 F(vec2 huv, float h, float u)\n{\n    return vec3(huv.x, h * u*u + g * 0.5 * h*h, u * huv.y);\n}\n\nvec3 G(vec2 huv, float h, float v)\n{\n    return vec3(huv.y, v * huv.x, h * v*v + g * 0.5 * h*h);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x > NUM_CELLS_X || fragCoord.y > NUM_CELLS_Y)\n        return;\n        \n    vec2 uv = fragCoord/iResolution.xy;\n        \n    // Get upwind and downwind derivatives on the four edges\n\n    // U/, = U_jp1_W\n    // U/, = U_jm1_E\n    // U/, = U_E\n    // U/, = U_W\n    // U,/ = U_kp1_S\n    // U,/ = U_km1_N\n    // U,/ = U_N\n    // U,/ = U_S\n    \n    vec4 U_W = texture(iChannel0, B0UV);\n    vec4 U_E = texture(iChannel0, B1UV);\n    vec4 U_S = texture(iChannel0, B2UV);\n    vec4 U_N = texture(iChannel0, B3UV);\n    \n    vec3 U_jp1_W = texture(iChannel0, B0UV + oneCellX).xyz;\n    vec3 U_jm1_E = texture(iChannel0, B1UV - oneCellX).xyz;\n    vec3 U_kp1_S = texture(iChannel0, B2UV + oneCellY).xyz;\n    vec3 U_km1_N = texture(iChannel0, B3UV - oneCellY).xyz;\n\n\n    // B_f: B/,\n    // B_b: B/,\n    // B_u: B,/\n    // B_d: B,/\n    float B_b = U_W.w;\n    float B_f = U_E.w;\n    float B_d = U_S.w;\n    float B_u = U_N.w;\n    \n    \n    // Boundary\n    if((B0UV + oneCellX).x > NUM_CELLS_X / iResolution.x)\n    {\n        U_jp1_W = vec3(U_E.x, -U_E.y, U_E.z);\n    }\n    \n    if((B1UV - oneCellX).x < NUM_CELLS_X / iResolution.x)\n    {\n        U_jm1_E = vec3(U_W.x, -U_W.y, U_W.z);\n    }\n    \n    if((B2UV + oneCellY).y > NUM_CELLS_Y / iResolution.y)\n    {\n        U_kp1_S = vec3(U_N.x, U_N.y, -U_N.z);\n    }\n    \n    if((B3UV - oneCellY).y < 0.)\n    {\n        U_km1_N = vec3(U_S.x, U_S.y, -U_S.z);\n    }\n    \n    // reconstruct water depth and propagation speed\n    // h/, = w/, - B/,\n    // h,/ = w,/ - B,/\n    float h_E = max(U_E.x - B_f, 0.);\n    float h_W = max(U_W.x - B_b, 0.);\n    float h_S = max(U_S.x - B_d, 0.);\n    float h_N = max(U_N.x - B_u, 0.);\n    \n    float h_jp1_W = max(U_jp1_W.x - B_f, 0.);\n    float h_jm1_E = max(U_jm1_E.x - B_b, 0.);\n    float h_kp1_S = max(U_kp1_S.x - B_u, 0.);\n    float h_km1_N = max(U_km1_N.x - B_d, 0.);\n    \n    \n    // velocity desingularization in case of very small h\n    vec2 uv_E = reconstructSpeed(h_E, U_E.yz);\n    vec2 uv_W = reconstructSpeed(h_W, U_W.yz);\n    vec2 uv_S = reconstructSpeed(h_S, U_S.yz);\n    vec2 uv_N = reconstructSpeed(h_N, U_N.yz);\n    vec2 uv_jp1_W = reconstructSpeed(h_jp1_W, U_jp1_W.yz);\n    vec2 uv_jm1_E = reconstructSpeed(h_jm1_E, U_jm1_E.yz);\n    vec2 uv_kp1_S = reconstructSpeed(h_kp1_S, U_kp1_S.yz);\n    vec2 uv_km1_N = reconstructSpeed(h_km1_N, U_km1_N.yz);\n\n    \n    // Local speeds of propagation\n    // the upper and lower bounds of local speeds can be estimated using\n    // the largest and smallest eigenvalues of the Jacobian F/U\n    // a/, = a,\n    // a/, = a,\n    // a/, = a,\n    // a/, = a,\n    // b,/ = b,\n    // b,/ = b,\n    // b,/ = b,\n    // b,/ = b,\n    float a_jp1_W = localPropagationSpeedUpwind(uv_E.x, uv_jp1_W.x, h_E, h_jp1_W);\n    float a_E     = localPropagationSpeedDownwind(uv_E.x, uv_jp1_W.x, h_E, h_jp1_W);\n    float a_jm1_E = localPropagationSpeedDownwind(uv_jm1_E.x, uv_W.x, h_jm1_E, h_W);\n    float a_W     = localPropagationSpeedUpwind(uv_jm1_E.x, uv_W.x, h_jm1_E, h_W);\n    float b_kp1_S = localPropagationSpeedUpwind(uv_N.y, uv_kp1_S.y, h_N, h_kp1_S);\n    float b_N     = localPropagationSpeedDownwind(uv_N.y, uv_kp1_S.y, h_N, h_kp1_S);\n    float b_km1_N = localPropagationSpeedDownwind(uv_km1_N.y, uv_S.y, h_km1_N, h_S);\n    float b_S     = localPropagationSpeedUpwind(uv_km1_N.y, uv_S.y, h_km1_N, h_S);\n\n    \n    // Recompute the discharge using reconstructed h and u\n    U_W.yz = h_W * uv_W;\n    U_E.yz = h_E * uv_E;\n    U_S.yz = h_S * uv_S;\n    U_N.yz = h_N * uv_N;\n    U_jp1_W.yz = h_jp1_W * uv_jp1_W;\n    U_jm1_E.yz = h_jm1_E * uv_jm1_E;\n    U_kp1_S.yz = h_kp1_S * uv_kp1_S;\n    U_km1_N.yz = h_km1_N * uv_km1_N;\n    \n    // Flux\n    vec3 F_W = F(U_W.yz, h_W, uv_W.x);\n    vec3 F_E = F(U_E.yz, h_E, uv_E.x);\n    vec3 F_jp1_W = F(U_jp1_W.yz, h_jp1_W, uv_jp1_W.x);\n    vec3 F_jm1_E = F(U_jm1_E.yz, h_jm1_E, uv_jm1_E.x);\n    \n    vec3 G_S = G(U_S.yz, h_S, uv_S.y);\n    vec3 G_N = G(U_N.yz, h_N, uv_N.y);\n    vec3 G_kp1_S = G(U_kp1_S.yz, h_kp1_S, uv_kp1_S.y);\n    vec3 G_km1_N = G(U_km1_N.yz, h_km1_N, uv_km1_N.y);\n    \n    \n    vec3 H_f = (a_jp1_W * F_E - a_E * F_jp1_W) / (a_jp1_W - a_E) + \n                (a_jp1_W * a_E) / (a_jp1_W - a_E) * (U_jp1_W - U_E.xyz);\n                \n    vec3 H_b = (a_W * F_jm1_E - a_jm1_E * F_W) / (a_W - a_jm1_E) + \n                (a_W * a_jm1_E) / (a_W - a_jm1_E) * (U_W.xyz - U_jm1_E);\n                \n    vec3 H_u = (b_kp1_S * G_N - b_N * G_kp1_S) / (b_kp1_S - b_N) + \n                (b_kp1_S * b_N) / (b_kp1_S - b_N) * (U_kp1_S - U_N.xyz);\n                \n    vec3 H_d = (b_S * G_km1_N - b_km1_N * G_S) / (b_S - b_km1_N) + \n                (b_S * b_km1_N) / (b_S - b_km1_N) * (U_S.xyz - U_km1_N);\n            \n    // Source Term\n    vec3 S = vec3(0., \n            -g * ((U_E.x + U_W.x) * 0.5 - (B_f+B_b)*0.5) * ((B_f-B_b) / dx),\n            -g * ((U_N.x + U_S.x) * 0.5 - (B_u+B_d)*0.5) * ((B_u-B_d) / dy));\n    \n\n    vec3 U_n = texture(iChannel1, uv).xyz;\n    \n    // Initial condition\n    if(iFrame ==0)\n    {\n        U_n = initialCondition(uv, uv+halfCellX, uv-halfCellX);\n    }\n    \n    \n    // Foward Eular\n    vec3 U = U_n + dt * (-(H_f - H_b)/dx - (H_u - H_d)/dy + S);\n\n    fragColor = vec4(U, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// 2D Saint-Venant system of Shallow Water Equation\n// An implementation of the paper:\n// A SECOND-ORDER WELL-BALANCED POSITIVITY PRESERVING CENTRAL-UPWIND SCHEME FOR THE SAINT-VENANT SYSTEM\n// https://www.intlpress.com/site/pub/files/_fulltext/journals/cms/2007/0005/0001/CMS-2007-0005-0001-a006.pdf\n// 1D version here: https://www.shadertoy.com/view/wt3BDH\n\n// No larger than iResolution.xy / 2\n#define NUM_CELLS_X 150.\n#define NUM_CELLS_Y 150.\n#define dx 1.\n#define dy 1.\n#define theta 1.4\n#define epsilon (0.01 * max(1., min(dx, dy)))\n#define g 9.812\n// not bounded by CFL condition as it requires \n// calculation of the max of all local speeds of propagation\n#define dt .02\n\n#define oneCellX  vec2(1./iResolution.x,  0.)\n#define halfCellX vec2(0.5/iResolution.x, 0.)\n#define oneCellY  vec2(0.,  1./iResolution.y)\n#define halfCellY vec2(0., 0.5/iResolution.y)\n\n\nfloat hash1(vec2 p)\n{\n    p = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return (a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\n\nconst mat2 m2 = mat2(.8,.6,-.6, .8);\n                      \nfloat terrian(vec2 p)\n{    \n    float f = 1.7;\n    float s = 0.7;\n    float a = 0.0;\n    float b = 0.6;\n    \n    for(int i=0; i<8; i++)\n    {\n        float n = noise(p);\n        a += b*n;\n        b *= s;\n        p = f*m2*p;\n    }\n\t\n    a=smoothstep(.5,1.2,a);\n    \n    return a*9.;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldfWf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[557, 557, 592, 592, 683], [685, 685, 724, 724, 813], [815, 815, 840, 840, 923], [925, 925, 946, 946, 991], [993, 1012, 1030, 1030, 1076], [1101, 1101, 1119, 1154, 1515], [1518, 1518, 1563, 1563, 1831], [1833, 1833, 1875, 1875, 2074], [2077, 2077, 2135, 2135, 2588], [2770, 2770, 2828, 2828, 3169], [3171, 3171, 3244, 3244, 4103], [4105, 4105, 4159, 4159, 4509], [4511, 4511, 4534, 4534, 4630], [4632, 4632, 4689, 4689, 5467]], "test": "untested"}
{"id": "ssSSRh", "name": "Insect swarms", "author": "jarble", "description": "These \"swarms\" seem to build walls as they move across the map.", "tags": ["automata", "feedback", "swarm", "cellularautomata"], "likes": 3, "viewed": 332, "published": 3, "date": "1619622385", "time_retrieved": "2024-07-30T19:22:53.851037", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 4.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 0.3;\n\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = 3.0;\nconst float NUM_NEIGH = 3.0;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum += GET(d);\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL + ((cen-NUM_NEIGH) * (sum-cen));\n\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val = new_val;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSSRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 284]], "test": "untested"}
{"id": "NdBSz1", "name": "Class II Goldberg Polyhedron ", "author": "Lichtso", "description": "UV-mapped hexagonal tiling on an icosahedron, See: https://en.wikipedia.org/wiki/Goldberg_polyhedron\n\nInstead of mesh tessellation this shader derives the tiling directly from polar angles.\nThis way the performance is independent of the number of tiles.", "tags": ["uv", "sphere", "hexagon", "tile", "polyhedron"], "likes": 14, "viewed": 398, "published": 3, "date": "1619620350", "time_retrieved": "2024-07-30T19:22:54.836403", "image_code": "#define rotate_around(angle, center) \\\n    mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, center.x, center.y, 1.0)* \\\n    mat3( \\\n        cos(angle), -sin(angle), 0.0, \\\n        sin(angle), cos(angle), 0.0, \\\n        0.0, 0.0, 1.0 \\\n    )* \\\n    mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, -center.x, -center.y, 1.0)\n\nconst mat3 rotate_m60 = rotate_around(radians(-60.0), vec2(0.5));\nconst mat3 rotate_p60 = rotate_around(radians(60.0), vec2(0.5));\nconst float M_PI = radians(180.0);\nconst float icosahedron_radius_by_edge_length = sin(M_PI*2.0/5.0);\nconst float inversesqrt5 = inversesqrt(5.0);\nconst vec3 ICOSAHEDRON_VERTICES[12] = vec3[](\n    vec3(0.0, -1.0, 0.0),\n    vec3(-0.27639320492744446, -inversesqrt5, -0.8506507873535156),\n    vec3(-0.8944271802902222, -inversesqrt5, -1.6430361299034693e-16),\n    vec3(-0.27639320492744446, -inversesqrt5, 0.8506507873535156),\n    vec3(0.7236068248748779, -inversesqrt5, 0.525731086730957),\n    vec3(0.7236068248748779, -inversesqrt5, -0.525731086730957),\n    vec3(0.27639320492744446, inversesqrt5, -0.8506507873535156),\n    vec3(-0.7236068248748779, inversesqrt5, -0.525731086730957),\n    vec3(-0.7236068248748779, inversesqrt5, 0.525731086730957),\n    vec3(0.27639320492744446, inversesqrt5, 0.8506507873535156),\n    vec3(0.8944271802902222, inversesqrt5, 1.6430361299034693e-16),\n    vec3(0.0, 1.0, 0.0)\n);\n\nfloat line_plane_intersection(vec3 origin, vec3 direction, vec3 point_on_plane, vec3 plane_normal) {\n    float determinant = dot(direction, plane_normal);\n    float zero = 0.0;\n    if(determinant == 0.0)\n        return zero/zero;\n    float parallel_distance = dot(point_on_plane-origin, plane_normal)/determinant;\n    return parallel_distance;\n}\n\nfloat line_sphere_intersection(vec3 origin, vec3 direction, float radius, out vec3 intersections[2]) {\n    float a = dot(direction, direction);\n    float b = -dot(direction, origin);\n    float c = dot(origin, origin) - radius*radius;\n    float d = (b*b)-a*c;\n    if(d < 0.0)\n        return -1.0;\n    d = sqrt(d);\n    direction /= a;\n    intersections[0] = origin+direction*(b-d);\n    intersections[1] = origin+direction*(b+d);\n    return b-d;\n}\n\nconst float blending_region = 0.1;\n\nbool side_of_half_plane(vec3 direction, int pole_index_a, int pole_index_b) {\n    vec3 aux_a = cross(ICOSAHEDRON_VERTICES[pole_index_a], ICOSAHEDRON_VERTICES[pole_index_b]);\n    return dot(direction, aux_a) > 0.0;\n}\n\nvec3 cart_to_bary(vec3 direction, ivec3 pole_indices) {\n    vec3 bary;\n    for(int i = 0; i < 3; ++i) {\n        vec3 b = ICOSAHEDRON_VERTICES[pole_indices[(i+1)%3]];\n        vec3 c = ICOSAHEDRON_VERTICES[pole_indices[(i+2)%3]];\n        float numerator = dot(direction, cross(b, c));\n        float denominator = 1.0+inversesqrt5+dot(direction, b)+dot(direction, c);\n        bary[i] = 10.0/M_PI*atan(numerator, denominator);\n    }\n    bary /= dot(vec3(1.0), bary);\n    return bary;\n}\n\nvec3 bary_to_cart(vec3 barycentric, ivec3 pole_indices) {\n    vec4 planes[3];\n    for(int i = 0; i < 3; ++i) {\n        vec3 b = ICOSAHEDRON_VERTICES[pole_indices[(i+1)%3]];\n        vec3 c = ICOSAHEDRON_VERTICES[pole_indices[(i+2)%3]];\n        float tangent = tan(M_PI/10.0*barycentric[i]);\n        planes[i].x = tangent*(1.0+inversesqrt5);\n        planes[i].yzw = cross(b, c)-tangent*(b+c);\n    }\n    vec3 l_g0 = planes[0].x * planes[1].yzw - planes[0].yzw * planes[1].x;\n    vec3 l_g1 = planes[0].z * vec3(planes[1].w, 0.0, -planes[1].y) + planes[0].w * vec3(-planes[1].z, planes[1].y, 0.0) + planes[0].y * vec3(0.0, -planes[1].w, planes[1].z);\n    vec4 p = l_g0.y * vec4(0.0, -planes[2].w, 0.0, planes[2].y) + l_g0.z * vec4(0.0, planes[2].z, -planes[2].y, 0.0) + l_g1.y * vec4(planes[2].z, 0.0, -planes[2].x, 0.0) + l_g1.z * vec4(planes[2].w, 0.0, 0.0, -planes[2].x) + vec4(l_g1.x, -l_g1.x, l_g0.x, -l_g0.x) * planes[2].yxwz;\n    return -p.yzw/p.x;\n}\n\nvec3 rotate_cube_coord(vec3 cube_coord) {\n    return vec3(\n        cube_coord.y-cube_coord.z,\n        cube_coord.z-cube_coord.x,\n        cube_coord.x-cube_coord.y\n    );\n}\n\nvec3 round_cube_coord(vec3 barycentric) {\n    vec3 rounded = round(barycentric);\n    vec3 diff = abs(rounded-barycentric);\n    if(diff.x > diff.y && diff.x > diff.z)\n        rounded.x = -rounded.y-rounded.z;\n    else if(diff.y > diff.z)\n        rounded.y = -rounded.x-rounded.z;\n    else\n        rounded.z = -rounded.x-rounded.y;\n    return rounded;\n}\n\nvec3 color_at_field(int gp_index, int triangle_latitude, int triangle_longitude, ivec3 cube_coord, vec2 tex_coord) {\n    ivec2 parallelogram_coord = cube_coord.xy;\n    if((triangle_longitude&1) == 1) {\n        parallelogram_coord = ivec2(3*gp_index)-parallelogram_coord;\n    }\n    if(triangle_longitude >= 2) {\n        parallelogram_coord[1] += 3*gp_index;\n    }\n    parallelogram_coord[1] = parallelogram_coord[1]*2+parallelogram_coord[0]%2;\n    parallelogram_coord[0] = (parallelogram_coord[0]+gp_index*2)/2-gp_index;\n    parallelogram_coord[1] = (parallelogram_coord[1]+gp_index*3)/3-gp_index;\n    int parallelogram_width = 1+gp_index/2*3+gp_index%2;\n    parallelogram_coord += ivec2(1+triangle_latitude*(parallelogram_width+2), 2);\n    return vec3(normalize(tex_coord-vec2(0.5))*0.3+vec2(0.8), 0.7);\n    // return cube_coord/gp_index;\n    // return vec3(parallelogram_coord.xy, 0.0)/float(gp_index*4);\n    // const float checker_board = 0.25;\n    // return normalize(vec3(cube_coord)/float(gp_index))*((mod(tex_coord.s, checker_board) < checker_board*0.5 != mod(tex_coord.t, checker_board) < checker_board*0.5) ? 1.0 : 0.8);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float planet_radius = 20.0;\n    \n    vec3 view_ray_origin = vec3(0.0, 0.0, planet_radius*10.0);\n    vec3 view_ray_hit = vec3(fragCoord/iResolution.xy*2.0-vec2(1.0), 0.0);\n    view_ray_hit.x *= iResolution.x/iResolution.y;\n    view_ray_hit.xy *= planet_radius*1.2;\n    vec3 view_ray_direction = normalize(view_ray_hit-view_ray_origin);\n\n    vec3 intersections[2];\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if(line_sphere_intersection(view_ray_origin, view_ray_direction, planet_radius, intersections) < 0.0)\n        return;\n    vec3 surface_normal = normalize(intersections[0]);\n    \n    float rotate_y = (iMouse.x/iResolution.x-0.5+iTime*0.02)*M_PI*2.0;\n    float rotate_x = (iMouse.y/iResolution.y-0.5)*M_PI;\n    surface_normal = (mat4(\n        cos(rotate_y), 0.0, sin(rotate_y), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -sin(rotate_y), 0.0, cos(rotate_y), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    )*mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos(rotate_x), sin(rotate_x), 0.0,\n        0.0, -sin(rotate_x), cos(rotate_x), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    )*vec4(surface_normal, 1.0)).xyz;\n\n    // Triangles and Barycentric\n    vec3 spherical = surface_normal;\n    float longitude = 1.0-acos(spherical[1])/M_PI;\n    float latitude = atan(spherical[0], spherical[2])/M_PI;\n    int triangle_latitude_south = int(mod((2.9+latitude)*2.5, 5.0));\n    int triangle_latitude_north = int(mod((3.1+latitude)*2.5, 5.0));\n    ivec3 pole_indices;\n    int triangle_longitude;\n    int triangle_latitude;\n    if(side_of_half_plane(spherical, 1+(triangle_latitude_south+1)%5, 1+triangle_latitude_south)) {\n        pole_indices = ivec3(1+(triangle_latitude_south+1)%5, 1+triangle_latitude_south, 0);\n        triangle_longitude = 0;\n        triangle_latitude = triangle_latitude_south;\n    } else if(side_of_half_plane(spherical, 6+triangle_latitude_north, 6+(triangle_latitude_north+1)%5)) {\n        pole_indices = ivec3(6+triangle_latitude_north, 6+(triangle_latitude_north+1)%5, 11);\n        triangle_longitude = 3;\n        triangle_latitude = triangle_latitude_north;\n    } else if(side_of_half_plane(spherical, 6+triangle_latitude_north, 1+triangle_latitude_north) &&\n              side_of_half_plane(spherical, 1+triangle_latitude_north, 6+(triangle_latitude_north+1)%5)) {\n        pole_indices = ivec3(6+(triangle_latitude_north+1)%5, 6+triangle_latitude_north, 1+triangle_latitude_north);\n        triangle_longitude = 2;\n        triangle_latitude = triangle_latitude_north;\n    } else {\n        pole_indices = ivec3(1+triangle_latitude_south, 1+(triangle_latitude_south+1)%5, 6+(triangle_latitude_south+1)%5);\n        triangle_longitude = 1;\n        triangle_latitude = triangle_latitude_south;\n    }\n    int gp_index = int(planet_radius/(icosahedron_radius_by_edge_length*3.0));\n    vec3 barycentric = cart_to_bary(spherical, pole_indices)*float(gp_index);\n    ivec3 cube_coord = ivec3(gp_index)-ivec3(rotate_cube_coord(round_cube_coord(rotate_cube_coord(barycentric))));\n    vec3 center_diff;\n\n    // Fix Edge Cases\n    if(cube_coord.x == gp_index*3 || cube_coord.y == gp_index*3 || cube_coord.z == gp_index*3) {\n        center_diff = barycentric*3.0-vec3(cube_coord);\n        if((triangle_longitude&1) == 1) {\n            center_diff *= -1.0;\n        }\n        switch(int(floor(longitude*6.0))) {\n            case 0:\n                triangle_latitude = (5-triangle_latitude)%5;\n            case 5:\n                switch(triangle_latitude) {\n                    case 1:\n                        center_diff = -center_diff.yzx;\n                        break;\n                    case 2:\n                        center_diff = center_diff.zxy;\n                        break;\n                    case 3:\n                        center_diff = center_diff.yzx;\n                        break;\n                    case 4:\n                        center_diff = -center_diff.zxy;\n                        break;\n                }\n                triangle_latitude = 0;\n                break;\n            case 3:\n            case 4:\n                cube_coord = ivec3(0.0, gp_index*3, 0.0);\n                triangle_latitude = triangle_latitude_south;\n                triangle_longitude = 3;\n                break;\n            case 1:\n            case 2:\n                cube_coord = ivec3(gp_index*3, 0.0, 0.0);\n                triangle_latitude = triangle_latitude_north+4;\n                triangle_longitude = 0;\n                break;\n        }\n    } else {\n        switch(triangle_longitude) {\n            case 3:\n                if(cube_coord.y == 0) {\n                    cube_coord.xy = cube_coord.yx;\n                    barycentric = vec3(-barycentric.y, float(gp_index)-barycentric.z, float(gp_index)-barycentric.x);\n                    triangle_latitude += 4;\n                }\n                break;\n            case 2:\n                if(cube_coord.x == 0) {\n                    cube_coord.yz = ivec2(gp_index*3)-cube_coord.yz;\n                    barycentric = vec3(-barycentric.x, float(gp_index)-barycentric.y, float(gp_index)-barycentric.z);\n                    triangle_longitude -= 1;\n                    triangle_latitude += 4;\n                } else if(cube_coord.z == 0) {\n                    cube_coord.xy = ivec2(gp_index*3)-cube_coord.xy;\n                    barycentric = vec3(float(gp_index)-barycentric.x, float(gp_index)-barycentric.y, -barycentric.z);\n                    triangle_longitude += 1;\n                }\n                break;\n            case 1:\n                if(cube_coord.y == 0) {\n                    cube_coord.xz = ivec2(gp_index*3)-cube_coord.xz;\n                    barycentric = vec3(float(gp_index)-barycentric.x, -barycentric.y, float(gp_index)-barycentric.z);\n                    triangle_longitude += 1;\n                } else if(cube_coord.z == 0) {\n                    cube_coord.xy = ivec2(gp_index*3)-cube_coord.xy;\n                    barycentric = vec3(float(gp_index)-barycentric.x, float(gp_index)-barycentric.y, -barycentric.z);\n                    triangle_longitude -= 1;\n                }\n                break;\n            case 0:\n                if(cube_coord.x == 0) {\n                    cube_coord.xy = cube_coord.yx;\n                    barycentric = vec3(float(gp_index)-barycentric.z, -barycentric.x, float(gp_index)-barycentric.y);\n                    triangle_latitude += 4;\n                }\n                break;\n        }\n        center_diff = barycentric*3.0-vec3(cube_coord);\n        if((triangle_longitude&1) == 1) {\n            center_diff *= -1.0;\n        }\n    }\n    triangle_latitude %= 5;\n\n    // Texture Coordinates\n    vec2 tex_coord = vec2(0.5)+0.75*vec2(center_diff.z, (center_diff.x-center_diff.y)/sqrt(3.0))/3.0;\n    vec3 edge_blending = (abs(center_diff)-vec3(1.0-blending_region))/blending_region*0.5;\n    edge_blending = smoothstep(vec3(0.0), vec3(1.0), edge_blending);\n    if((triangle_longitude&1) == 1) {\n        center_diff *= -1.0;\n    }\n    \n    float sum = 1.0-max(max(max(edge_blending.x, edge_blending.y), edge_blending.z), 0.0);\n    fragColor.rgb = sum*color_at_field(gp_index, triangle_latitude, triangle_longitude, cube_coord, tex_coord);\n    \n    // Texture Blending\n    #if 0\n    for(int i = 0; i < 3; ++i) {\n        if(edge_blending[i] > 0.0) {\n            int s = int(sign(center_diff[i]));\n            ivec3 dir = ivec3(0);\n            dir[i] = 2*s;\n            dir[(i+1)%3] = -s;\n            dir[(i+2)%3] = -s;\n            ivec3 neighbor_coord = cube_coord+dir;\n            vec2 neighbor_tex_coord = tex_coord;\n            switch(triangle_longitude) {\n                case 3:\n                case 0:\n                    if(neighbor_coord.x < 0) {\n                        neighbor_tex_coord = (rotate_p60*vec3(tex_coord, 1.0)).xy;\n                    } else if(neighbor_coord.y < 1) {\n                        neighbor_tex_coord = (rotate_m60*vec3(tex_coord, 1.0)).xy;\n                    }\n                    break;\n            }\n            fragColor.rgb += edge_blending[i]*color_at_field(gp_index, triangle_latitude, triangle_longitude, neighbor_coord, neighbor_tex_coord);\n            sum += edge_blending[i];\n        }\n    }\n    fragColor.rgb /= sum;\n    #endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBSz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1338, 1338, 1438, 1438, 1683], [1685, 1685, 1787, 1787, 2129], [2167, 2167, 2244, 2244, 2382], [2384, 2384, 2439, 2439, 2865], [2867, 2867, 2924, 2924, 3819], [3821, 3821, 3862, 3862, 3992], [3994, 3994, 4035, 4035, 4345], [4347, 4347, 4463, 4463, 5477], [5479, 5479, 5534, 5534, 13710]], "test": "untested"}
{"id": "wltBDl", "name": "Hexagon Grid", "author": "Dude", "description": "copied the pixelToCubial from somewhere else in shadertoy, cant remember where", "tags": ["hexagongrid"], "likes": 3, "viewed": 403, "published": 3, "date": "1619616705", "time_retrieved": "2024-07-30T19:22:55.584403", "image_code": "#define HMAT mat2(vec2(1., 0.), vec2(.5, 0.866))\n#define hScale .12\n\nfloat N21(vec2 p){\n    return fract(sin(p.x * 100. + p.y * 6574.) * 5647.);\n}\n\nfloat SmoothNoise(vec2 uv){\n    vec2 lv = fract(uv * 10.);\n    vec2 id = floor(uv * 10.);\n    \n    lv = lv * lv * (3. -2. * lv);\n    \n    float bl = N21(id);\n    float br = N21(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nvoid pixelToCubial(vec2 uv, out vec3 cubial, out vec3 grid) {\n\n    vec2 axial = inverse(HMAT) * uv;\n    cubial = vec3(axial, -axial.x - axial.y) / hScale;\n    grid = round(cubial);\n    vec3 dist = abs(cubial - grid);\n    if (dist.x > dist.y && dist.x > dist.z) {\n        grid.x = -grid.y - grid.z;\n    }\n    else if (dist.y > dist.z) {\n        grid.y = -grid.x - grid.z;\n    }\n    else {\n        grid.z = -grid.x - grid.y;\n    }\n}\n\nfloat cubialDistance(vec3 a, vec3 b) {\n    vec3 c = abs(a - b);\n    return max(c.x, max(c.y, c.z));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 vec_pos = (gl_FragCoord.xy);\n    vec2 uv = (vec_pos - .5*iResolution.xy) / iResolution.y;\n    uv *= 3.;\n    vec4 uv_r = vec4(uv.x, uv.y, 0., 0.);\n\n    vec3 cubial;\n    vec3 grid;\n    pixelToCubial(uv_r.xy, cubial, grid);\n\n    vec3 coord = cubial - grid;\n    vec3 dist = abs(coord.xyz - coord.zxy);\n\n    vec3 background_col = vec3(0.);\n    float edge = (12.*2.)-1.;\n    float center_distance = cubialDistance(grid/edge, vec3(0,0,0) );\n    if (center_distance > 0.5){\n        background_col = vec3(center_distance, center_distance, center_distance);\n    }\n    \n    float uvm = uv.y * 3. + uv.x + (SmoothNoise(grid.xy * (iTime*0.02)) * 1.9);\n    \n    float wave = sin(uvm+0.5+(iTime*2.));\n    float thickness = .1 * wave;\n    vec3 col = vec3(wave * 2., 1., 1.);\n    \n    thickness += 0.2;\n    col *= 1. - smoothstep(thickness, thickness + (2.0 / iResolution.y) / hScale, 1.0 - max(dist.x, max(dist.y, dist.z)));\n\n    col = (col + background_col)/2.;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltBDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 87, 87, 146], [148, 148, 175, 175, 515], [517, 517, 578, 578, 947], [949, 949, 987, 987, 1050], [1052, 1052, 1107, 1107, 2097]], "test": "untested"}
{"id": "7s2SRz", "name": "Light in the Dark: Forked-RogerB", "author": "RogerB", "description": "Notable changes:\n- Smooth blending of water and other materials.\n- Performance improvements.\n- Increased delta for water normal to reduce artifacting.\n- Added some compositions featuring smooth blending.", "tags": ["raymarching", "sdf", "water", "bridge"], "likes": 3, "viewed": 303, "published": 3, "date": "1619611215", "time_retrieved": "2024-07-30T19:22:56.535859", "image_code": "// Raymarcher adapted from implementation by Inigo Quilez\n\n#define GAMMA_CORRECTION\n#define MOTION\n#define DISTANCE_FOG\n\n// Material aliases\n#define WATER 0\n#define LAMBERT_RED 1\n#define BLOB 2\n\n// Scene compositions.\n//#define COMPOSITION_0\n//#define COMPOSITION_1\n#define COMPOSITION_2\n\n// Camera Views\n//#define VIEW_0\n#define VIEW_1\n//#define MOUSE_CONTROL\n\n// Water Noise (NO NOISE -> 0, PERLIN -> 1, WORLEY -> 2, IQ -> 3)\n// Iq noise taken from https://www.shadertoy.com/view/4sS3zG.\n#define NOISE 1\n#define SINEWAVES\n\nconst float INFINITY = 99999999999999999.99f;\nconst float PI = 3.14159;\nconst float EPSILON = 0.0001f;\nconst float MIN_CLIP = 0.001f;\nconst float FAR_CLIP = 500.f;\nconst int RAY_STEPS = 256;\nconst int SHADOW_RAY_STEPS = 256;\n\nvec2 random2(vec2 p, float seed) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * seed);\n}\n\nfloat noise2D(vec2 p, float seed){\n    p /= 20.f;\n    return fract(5.f * sin(dot(p, p) * seed) - p.y * cos(435.324 * seed * p.x));;\n}\n\nfloat worley(vec2 uv, float seed) {\n    uv *= 10.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor, seed); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbors Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nfloat noise3( vec3 p ) {\n    vec3 noise = fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n    return max(noise.x, max(noise.y, noise.z));\n}\n\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * pow(t2, vec3(5.f)) + 15.f * pow(t2, vec3(4.f)) - 10.f * pow(t2, vec3(3.f));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint).xyz * 2.f - vec3(1., 1., 1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlinNoise3D(vec3 p) {\n    float surfletSum = 0.f;\n    // Iterate over the four integer corners surrounding uv\n    for(int dx = 0; dx <= 1; ++dx) {\n        for(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n                surfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n            }\n        }\n    }\n    return surfletSum;\n}\n\n\t\nfloat hash(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099);\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat iqNoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                              hash( i + vec2(1.0,0.0) ), u.x),\n                         mix( hash( i + vec2(0.0,1.0) ), \n                              hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\nfloat almostAbs( float x )\n{\n    return almostIdentity(abs(x), 0.05, 0.025 );\n}\n\nfloat iqNoiseLayered( vec2 p )\n{\n    vec2 q = 0.05*p;\n\tfloat f = 0.0;\n    f += 0.50000*almostAbs(iqNoise( q )); q = m2*q*2.02; q -= 0.1*iTime;\n    f += 0.25000*almostAbs(iqNoise( q )); q = m2*q*2.03; q += 0.2*iTime;\n    f += 0.12500*almostAbs(iqNoise( q )); q = m2*q*2.01; q -= 0.4*iTime;\n    f += 0.06250*almostAbs(iqNoise( q )); q = m2*q*2.02; q += 1.0*iTime;\n    f += 0.03125*almostAbs(iqNoise( q ));\n    return 3.7-4.0*f;\n}\n\nbool equals(float a, float b){\n    return abs(a - b) < EPSILON;\n}\n\nbool equalsmargin(float a, float b, float m){\n    return abs(a - b) < m;\n}\n\nvec2 smin(float a, float b, float k){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n// Because the above implementation of smin doesn't work with k=0.\nvec2 hardMin(float a, float b) {\n    return (a<b) ? vec2(a, 0) : vec2(b, 1);\n}\n\nfloat isect( float d1, float d2, float k ) {\n    // float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    // return mix( d2, d1, h ) + k*h*(1.0-h); \n    return -smin(-d1, -d2, k).x;\n}\n\nfloat sub(float d1, float d2, float k) {\n    return isect(d1, -d2, k);\n}\n\nvec3 repeat(vec3 pos, float cx, float cy, float cz){\n    return vec3(mod(pos.x + 0.5f * cx, cx) - 0.5f * cx,\n                mod(pos.y + 0.5f * cy, cy) - 0.5f * cy,\n                mod(pos.z + 0.5f * cz, cz) - 0.5f * cz);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid computeray (vec3 eye, vec3 ref, vec2 ndc, float fov, out vec3 ro, out vec3 rd)\n{\n    vec3 look = ref - eye;\n    \n    float len = tan(fov * PI/180.f) * distance(eye, ref);\n    \n    vec3 v, h;\n    h = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    v = normalize(cross(h, look));;\n\n    h *= len * iResolution.x/iResolution.y;\n    v *= len;\n    \n    vec3 p = ref + ndc.x * h + ndc.y * v;\n            \n    p = ref + ndc.x * h + ndc.y * v;\n        \n    ro = eye;\n    rd = normalize(p - eye);\n}\n\nfloat infinite_plane_sdf(vec3 pos, float y){\n    return pos.y - y;\n}\n\nfloat sphere_sdf (vec3 ro, vec3 p, float r){\n    return length(ro - p) - r;\n}\n\nfloat box_sdf(vec3 ro, vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(ro - p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat cylinder_sdf(vec3 ro, vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(ro.xz - p.xz)-2.0*ra+rb, abs(ro.y - p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat vert_cylinder_sdf(vec3 ro, vec3 p, float r, float h){\n    float s0 = box_sdf(ro, vec3(0.f, 1.f, 0.f) + p, vec3(r, 2.f * r, h), 0.1f);\n    float s1 = sphere_sdf(ro, vec3(0.f, 0.f, 0.f) + p, r);\n    return isect(s0, s1, 0.1f);\n\n}\n\nfloat arch_sdf(vec3 ro, vec3 p, float r1, float r2, float t){\n    float s0 = vert_cylinder_sdf(ro, p, r1, t);\n    float s1 = vert_cylinder_sdf(ro, p, r2, 2.f * t);\n    float d1 = sub(s0, s1, 0.1f);\n    return d1;\n}\n\nfloat steps_sdf(vec3 ro, vec3 p, vec3 dim, int steps, int axis, int dir){\n    float d = INFINITY;\n    for (int i = 0; i < steps; i++){\n        float cur_step;\n        if (axis == 0){\n            cur_step = box_sdf(ro, vec3(dim.z * float(i) * float(dir) * 0.8f, 2.f * dim.y * float(i), 0.f) + p, dim, 0.1f);\n        } else if (axis == 1){\n            cur_step = box_sdf(ro, vec3(0.f, 2.f * dim.y * float(i), dim.x * float(i) * float(dir) * 0.8f) + p, dim.zyx, 0.1f);\n        }\n        d = min(cur_step, d);\n    }\n    return d;\n}\n\nfloat full_steps_sdf(vec3 ro, vec3 p, vec3 dim, int steps, int axis, int dir){\n    float d = INFINITY;\n    for (int i = 1; i < steps; i++){\n        float cur_step;\n        if (axis == 0){\n            cur_step = box_sdf(ro, vec3(dim.z * float(i) * float(dir), dim.y * float(i), 0.f) + p, vec3(dim.x, 2.f * float(i) * dim.y, dim.z), 0.1f);\n        } else if (axis == 1){\n            cur_step = box_sdf(ro, vec3(0.f, 2.f * dim.y * float(i), dim.x * float(i) * float(dir)) + p, vec3(dim.z, dim.y, dim.x), 0.1f);\n        }\n        d = min(cur_step, d);\n    }\n    return d;\n}\n\nvec3 map(vec3 p){\n    float aTime = iTime/2.f;\n    \n    //BRIDGE\n    vec3 q = repeat(p, 12.f , 0.f, 0.f);\n    float a0 = arch_sdf(q, vec3(0.f), 7.f, 5.f, 2.f);\n    float a1 = arch_sdf(q, vec3(0.f), 8.f, 6.f, 1.5f);\n    float d0 = sub(a0, a1, 0.2f);\n    \n    \n    // FLOATING BLOBS\n    vec3 qs1 = repeat(p, 40.f, 0.f, 40.f);\n    vec3 qs2 = repeat(p, 10.f, 0.f, 10.f);\n    float f = 5.f;\n    float hf = 15.5f * cos(p.z/40.f);\n    vec3 h0 = vec3(f * cos(iTime/4.f), 15.f + (sin(p.x) + cos(p.z)) * sin(iTime) - hf * (sin(p.x/20.f) + cos(p.z/20.f)) * cos(iTime), f * sin(iTime/2.f));\n    vec3 h1 = vec3(5.f + -f * cos(iTime/4.f), 20.f + (sin(p.x) + cos(p.z)) * sin(iTime) + hf * (cos(p.x/20.f) + sin(p.z/20.f)) * sin(iTime), 5.f + -f * sin(iTime/2.f));\n    float s0 = sphere_sdf(qs1, h0, 3.5f);\n    float s1 = sphere_sdf(qs1, h1, 3.5f);\n    float d1 = smin(s0 * 0.5f, s1 * 0.5f, 2.f).x;\n    \n    \n    // WATER\n    float plane_noise = 2.f;\n    #ifdef SINEWAVES\n    plane_noise += 1.f *(cos(p.x/10.f - cos(iTime)) + sin(p.z/15.f + sin(iTime))) * ((sin(iTime/5.f) + 1.1f)*0.5);\n    plane_noise -= 1.;\n    #endif\n    \n    #if NOISE == 0\n    // nop\n    #elif NOISE == 1\n    // plane_noise += (perlinNoise3D(p) * (sin(iTime/5.f) + 1.1f) * 0.5f);\n    // plane_noise += (perlinNoise3D(p) *  0.2f);\n    // plane_noise += (perlinNoise3D(p) * (sin(iTime/5.f) + 1.1f) * 0.1f);\n    // plane_noise += perlinNoise3D(vec3(p.x, 0., p.z)) * (sin(iTime/5.f) + 1.1f) * 0.1f; // 2D perlin noise is about 3x as fast to march through, but doesn't look as good.\n    // plane_noise += perlinNoise3D(vec3(p.x, iTime, p.z)) * (sin(iTime/5.f) + 1.1f) * 0.1f; // Using the time as the third component makes it look better, while still being 2D noise within a single frame so we keep the performance benefits. At least, we should but we don't for some reason.\n    // Shifting the noise over time is both fast and looks alright, however.\n    vec3 qWater = p + vec3(-iTime*3., 0., sin(iTime/(1.62*3.))*5.);\n    plane_noise += perlinNoise3D(vec3(qWater.x, 0., qWater.z)) * (sin(iTime/5.f) + 1.1f) * 0.1f;\n    #elif NOISE == 2\n    plane_noise += ((worley(p.xz/10.f, abs(sin(iTime) * cos(iTime/2.f)))) * (sin(iTime/5.f) + 1.1f) * 0.3f);\n    #elif NOISE == 3\n    // plane_noise += iqNoiseLayered(p.xz) * (sin(iTime/5.f) + 1.1f) * 0.5f;\n    plane_noise += iqNoiseLayered(p.xz) * 0.2f;\n    #endif\n    \n    float d2 = infinite_plane_sdf(p, plane_noise);\n    \n    \n    // COMPOSITION\n    // x: distance, y: material, z: water mask. (Water mask is used for mixing in the reflection term.)\n    vec3 res;\n    \n    #ifdef COMPOSITION_0\n    // In this block, water and blobs merge and the bridge is independent.\n    res.xz = smin(d1, d2, 3.f);\n    res.y = res.z < 1. ? float(BLOB) : float(WATER);\n\n    vec2 bridge_res;\n    bridge_res = hardMin(res.x, d0);\n    res.x = bridge_res.x;\n    res.y = bool(bridge_res.y) ? float(LAMBERT_RED) : res.y;\n    res.z = bool(bridge_res.y) ? 0. : res.z;\n    #endif\n    \n    #ifdef COMPOSITION_1\n    // In this block, blobs and the bridge merge with the water but not eachother.\n    vec3 bridge_water;\n    bridge_water.xz = smin(d0, d2, 1.);\n    bridge_water.y = float(LAMBERT_RED);\n    \n    vec3 blob_water;\n    blob_water.xz = smin(d1, d2, 3.);\n    blob_water.y = float(BLOB);\n    \n    res = bridge_water.x < blob_water.x ? bridge_water : blob_water;\n    res.y = res.z < 1. ? res.y : float(WATER); // For when water reflects into more water.\n    #endif\n    \n    #ifdef COMPOSITION_2\n    // Same as composition 1 but the blobs deform around the bridge.\n    vec3 bridge_water;\n    bridge_water.xz = smin(d0, d2, 1.);\n    bridge_water.y = float(LAMBERT_RED);\n    \n    float expanded_bridge = d0 - 1.;\n    float blob = d1;\n    //blob = smin(blob, expanded_bridge, 10.).x; // Make the far side of the blob smush away from the bridge; disabled because of artefacts where the bridge is close to the water.\n    blob = sub(blob, expanded_bridge, 2.); // Avoid the bridge instead of going through it.\n    \n    vec3 blob_water;\n    blob_water.xz = smin(blob, d2, 3.);\n    blob_water.y = float(BLOB);\n    \n    res = bridge_water.x < blob_water.x ? bridge_water : blob_water;\n    res.y = res.z < 1. ? res.y : float(WATER); // For when water reflects into more water.\n    #endif\n    \n    // TODO: add ability to smoothly blend all three materials, then make a scene that does that.\n    \n    return res;\n}\n\nvec3 calcNormal(in vec3 pos, float eps){\n    // Central differences approach.\n    // 6s compile time because of over-eager compiler inlining.\n    /*\n    vec2 e = vec2(eps, 0.f);\n    return normalize(vec3(map(pos + e.xyy).x - map(pos - e.xyy).x,\n                          map(pos + e.yxy).x - map(pos - e.yxy).x,\n                          map(pos + e.yyx).x - map(pos - e.yyx).x));\n    */\n    \n    \n    // Tetrahedron approach from https://iquilezles.org/articles/normalsSDF.\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+eps*e).x;\n    }\n    return normalize(n);\n    \n    \n    // Below this point are implementations of inlining-resistant central difference algorithms.\n    // I started messing with them because the tetahedron approach was causing black artefacts\n    // on the underside bridge corners. (But it turns out I had just accidentally set epsilon an\n    // order of magnitude higher than intended in one of the calls.)\n    // The below implementations aren't used any more, but I think they're interesting enough to keep.\n    \n    \n    // Inlining-resistant central differences.\n    // 3s compile time because two map calls get inlined.\n    // Follows the sprit of the inlining-resistant tertrahedron approach, but I haven't seen this implementation elsewhere.\n    /*\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<3; i++) {\n        vec3 e = vec3(((i+3)>>1)&1,(i>>1)&1,i&1);\n        n += e*map(pos+eps*e).x - e*map(pos-eps*e).x;\n    }\n    return normalize(n);\n    */\n\n\n    // Inlining-resistant central differences mk. 2.\n    // 2s compile time with the single inlined map call.\n    // This should be equivalent to mk. 1, but it isn't. (I notice it as banding in the water reflection in the smooth part of the water cycle.) I'm not currently sure why.\n    /*\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<6; i++) {\n        float signBit = float(i&1);\n        int j = i >> 1;\n        vec3 e = signBit * vec3(((j+3)>>1)&1,(j>>1)&1,j&1);\n        n += e*map(pos+eps*e).x;\n    }\n    return normalize(n);\n    */\n    \n    \n    // It's worth noting that the central differences approaches aren't much more expensive at runtime than the tetrahedron approach.\n    // (Not a lot of the total time is spent calculating normals.)\n}\n\nvec3 grad(vec3 pos, float eps) {\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+eps*e).x;\n    }\n    return n;\n}\n\nfloat shadowcast_pointlight(in vec3 ro, in vec3 rd, in float light_dist){\n    float res = 1.f;\n    float t = MIN_CLIP;\n    light_dist = min(light_dist, FAR_CLIP);\n    for (int i = 0; i < SHADOW_RAY_STEPS; i++){\n        t = min(t, light_dist);\n        vec3 pos = ro + rd * t;\n        float sdf = map(pos).x;\n        // Soft shadows were causing heavy banding on the blobs from the point light sources.\n        // The reason was that the \"distance function\" wasn't exact.\n        // We can fix this by using a first-order Taylor series approximation for the true distance function.\n        // (https://iquilezles.org/articles/distance)\n        // Nevermind, there's something else at play here, too. Also, computing the gradient during the shadow step is expensive.\n        // float dist = sdf / length(grad(pos, 0.01));\n        float dist = sdf * 50.;\n        res = min(res, 0.2 * dist/t);\n        t += sdf;\n        if (t >= light_dist || res < 0.001) break;\n    }\n    return res;\n}\n\n/*\nfloat shadowcast_pointlight(in vec3 ro, in vec3 rd, in float light_dist){\n    light_dist = min(light_dist, FAR_CLIP);\n    float res = 1.f;\n    float t = MIN_CLIP;\n    float ph = 1e20;\n    for (int i = 0; i < RAY_STEPS; i++){\n        vec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        \n        float y = h*h/(2.*ph);\n        float d = sqrt(h*h-y*y);\n        res = min(res, 10.f * d/max(0., t-y));\n        ph = h;\n        t += h;\n\n        if (res < 0.0001 || t > light_dist){\n            break;\n        }\n    }\n    return res;\n}\n*/\n\nfloat shadowcast(in vec3 ro, in vec3 rd){\n    return shadowcast_pointlight(ro, rd, FAR_CLIP);\n}\n\nfloat raycast(in vec3 ro, in vec3 rd, out vec2 mat){\n    float t = MIN_CLIP;\n    mat = vec2(-1, 0);\n    for (int i = 0; i < RAY_STEPS; i++){\n        vec3 pos = ro + rd * t;\n        vec3 sdf = map(pos);\n        float dist = sdf.x;\n        mat = sdf.yz;\n        if (abs(dist) < 0.0001f){\n            return t;\n        }\n        if (t > FAR_CLIP){\n            return -1.f;\n        }\n        t += dist;\n    }\n    return t;\n}\n\nvec3 calcmaterial(vec3 pos, vec3 nor, int mat){\n        vec3 col = vec3(0.f);        \n        \n        // ambient light parameters\n        vec3 sky_light = vec3(0.f, 0.1f, 0.3f) * clamp(0.5f + 0.5f * nor.y, 0.f, 1.f);\n        \n        // light parameters\n        float aTime = iTime/2.f;\n        #ifdef MOTION\n        vec3 light_pos = vec3(7.f * sin(aTime) - iTime , 7.f, 7.f * cos(aTime));\n        #else\n        vec3 light_pos = vec3(7.f * sin(aTime) , 7.f, 7.f * cos(aTime));\n        #endif\n        vec3 light_dir = normalize(light_pos - pos);\n        vec3 lambert_light = vec3(0.8f, 0.6f, 0.2f) * clamp(dot(nor, light_dir), 0.f, 1.f);\n        //vec3 lambert_light = vec3(0.8f, 0.6f, 0.2f);\n\n        #ifdef MOTION\n        vec3 light2_pos = vec3(-7.f * cos(aTime) - iTime, 7.f, -7.f * sin(aTime));\n        #else\n        vec3 light2_pos = vec3(-7.f * cos(aTime), 7.f, -7.f * sin(aTime));\n        #endif\n        vec3 light2_dir = normalize(light2_pos - pos);\n        vec3 lambert_light2 = vec3(0.8f, 0.2f, 0.01f) * clamp(dot(nor, light2_dir), 0.f, 1.f);\n        //vec3 lambert_light2 =vec3(0.8f, 0.2f, 0.01f);\n        \n\n        // bounce light (fake GI)\n        vec3 bounce_light = vec3(0.1f, 0.05f, 0.02f) * clamp(0.5f - 0.5f * nor.y, 0.f, 1.f);\n        \n        float light1_dist = distance(light_pos, pos);\n        float light2_dist = distance(light2_pos, pos);\n        // float t_shadow1 = shadowcast_pointlight(pos, light_dir, light1_dist) / (light1_dist*light1_dist);\n        // float t_shadow2 = shadowcast_pointlight(pos, light2_dir, light2_dist) / (light2_dist*light2_dist);\n        float t_shadow1 = shadowcast_pointlight(pos, light_dir, light1_dist);\n        float t_shadow2 = shadowcast_pointlight(pos, light2_dir, light2_dist);\n         //t_shadow = 1.f;\n                \n        vec3 base_colour;\n        \n        switch(mat){\n            case WATER:\n            base_colour = vec3(0.f, 0.1f, 0.3f) * 0.05f;\n            break;\n            case LAMBERT_RED:\n            // vec2 textureIndex = mix(pos.xy, pos.xz, 0.5);\n            // vec2 textureIndex = vec2(pos.x, pos.y+pos.z);\n            // base_colour  = texture(iChannel0, textureIndex.xy/4.f).xyz;\n            \n            if (abs(nor.y) > abs(nor.z)){\n                base_colour  = texture(iChannel0, pos.xz/4.f).xyz;\n            } else {\n                base_colour  = texture(iChannel0, pos.xy/4.f).xyz;\n            }\n            \n            base_colour *= vec3(0.9f, 0.2f, 0.4f);\n            break;\n            case BLOB:\n            base_colour = vec3(1.f, 0.4f, 0.3f);\n            break;\n        }\n        \n        // final colour evaluation\n        vec3 sum_light = vec3(0);\n        sum_light = lambert_light * t_shadow1 * 2.;\n        sum_light += lambert_light2 * t_shadow2 * 2.;\n        \n        sum_light += sky_light;\n        sum_light += bounce_light;\n        \n        return base_colour * sum_light;\n        //return sum_light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized device coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = vec2((2.f * uv.x) - 1.f, 1.f - (2.f * uv.y)); \n    \n    \n    // camera variance variable\n    #ifdef MOUSE_CONTROL\n    float u = 20.f * iMouse.x/iResolution.x;\n    float v = PI/2.f * iMouse.y/iResolution.y;\n    #endif\n    \n    // Camera parameters\n    #ifdef MOUSE_CONTROL\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(d * cos(u), 30.f * abs(sin(v)), d * sin(u));\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef VIEW_0\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(d, 7.5f, 0.f);\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef VIEW_1\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(0.f, 5.f, d);\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef MOTION\n    #ifndef VIEW_1\n    vec3 motion = vec3(-iTime, abs(sin(iTime)), 0.f);\n    #else\n    vec3 motion = vec3(-iTime, 0.f, 0.f);\n    #endif\n    eye += motion;\n    ref.x += motion.x;\n    #endif\n    float fov = 45.f;\n    \n    vec3 ro , rd;\n    computeray(eye, ref, ndc, fov, ro, rd);\n        \n    #ifdef DISTANCE_FOG\n    vec3 skyCol = mix(vec3(0.f, 0.1f, 0.3f) * 0.3f, vec3(0.f, 0.1f, 0.3f) * 0.f, abs(ndc.y * 1.25f));     \n    #else\n    vec3 skyCol = vec3(0.f);\n    #endif\n    vec3 col = skyCol;\n    vec2 mat = vec2(-1.f, 0.f);\n    float t = raycast(ro, rd, mat);\n    \n    // TODO: Clean this up to handle the water more nicely. (With less duplicated logic.)\n    if (t > 0.f){\n        vec3 pos = ro + t * rd;\n        \n        vec3 initialNorm = calcNormal(pos, 0.01f);\n        vec3 initialCol = calcmaterial(pos, initialNorm, int(round(mat.x)));    \n        // Add a water reflection. Blend it using the water mask stored in mat.y.\n        if (mat.y > 0.){\n            vec3 ro_new = pos;\n            vec3 rd_new = reflect(rd, initialNorm);\n            vec2 mat_new;\n            float t_new = raycast(ro_new, rd_new, mat_new);\n            \n            vec3 reflectedCol;\n            if (t_new > 0.) {\n                // pos = ro_new + t_new*rd_new;\n                // t = min(t + t_new, FAR_CLIP);\n                // mat = mat_new;\n                vec3 pos_new = ro_new + t_new*rd_new;\n                \n                vec3 reflectedNorm = calcNormal(pos_new, 0.01f);\n                reflectedCol = calcmaterial(pos_new, reflectedNorm, int(round(mat_new.x)));\n                // reflectedCol = calcmaterial(pos_new, reflectedNorm, BLOB);\n            } else {\n                // TODO: This is probably wrong, since the sky is non-uniform.\n                reflectedCol = skyCol;\n            }\n            reflectedCol *= 0.35; // Dampen the water reflection.\n            col = mix(initialCol, reflectedCol, mat.y);\n        } else {\n            col = initialCol;\n        }\n        // TODO: Apply these separately to initialCol and reflectedCol.\n        col *= 1.f - pow(t/FAR_CLIP, 2.f) * vec3(0.8f, 0.8f, 0.6f);\n        #ifdef DISTANCE_FOG\n        col += vec3(0.f, 0.1f, 0.3f) * 0.25f * (t/FAR_CLIP) * (t/FAR_CLIP) ;\n        #endif\n    }\n    \n    #ifdef GAMMA_CORRECTION\n    // Gamma correction - https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=1990s - 38:00\n    col = pow(col, vec3(0.4545f));\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,t);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2SRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[751, 751, 785, 785, 912], [914, 914, 948, 948, 1047], [1049, 1049, 1084, 1084, 1821], [1823, 1823, 1847, 1847, 2066], [2068, 2068, 2092, 2092, 2365], [2368, 2368, 2407, 2551, 3210], [3212, 3212, 3241, 3241, 3578], [3582, 3582, 3602, 3602, 3678], [3680, 3680, 3708, 3708, 4038], [4090, 4090, 4141, 4141, 4270], [4272, 4272, 4300, 4300, 4351], [4353, 4353, 4385, 4385, 4780], [4782, 4782, 4812, 4812, 4847], [4849, 4849, 4894, 4894, 4923], [4925, 4925, 4962, 4962, 5109], [5111, 5178, 5210, 5210, 5256], [5258, 5258, 5302, 5406, 5441], [5443, 5443, 5483, 5483, 5515], [5517, 5517, 5569, 5569, 5740], [5742, 5742, 5773, 5773, 5856], [5858, 5858, 5943, 5943, 6357], [6359, 6359, 6403, 6403, 6427], [6429, 6429, 6473, 6473, 6506], [6508, 6508, 6557, 6557, 6657], [6659, 6659, 6726, 6726, 6858], [6860, 6860, 6919, 6919, 7093], [7095, 7095, 7156, 7156, 7309], [7311, 7311, 7384, 7384, 7838], [7840, 7840, 7918, 7918, 8409], [8411, 8411, 8428, 8428, 12786], [12788, 12788, 12828, 13262, 15149], [15151, 15151, 15183, 15183, 15376], [15378, 15378, 15451, 15451, 16359], [16906, 16906, 16947, 16947, 17001], [17003, 17003, 17055, 17055, 17423], [17425, 17425, 17472, 17472, 20338], [20340, 20340, 20397, 20449, 23722]], "test": "untested"}
{"id": "ss2SRz", "name": "Protozoa", "author": "jarble", "description": "This cellular automaton seems to form many distinct \"swarms\" with different colors.", "tags": ["automata", "feedback", "cellularautomata"], "likes": 2, "viewed": 254, "published": 3, "date": "1619586996", "time_retrieved": "2024-07-30T19:22:57.479337", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 4.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 0.21;\n\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = 1.0;\nconst float NUM_NEIGH = 3.0;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum += GET(d);\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL + ((cen-NUM_NEIGH) * (sum));\n\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val = new_val;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2SRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 284]], "test": "untested"}
{"id": "ssBSzz", "name": "Chemical Reaction-Diffusion", "author": "michionlion", "description": "Simulates the reaction of two different chemicals, A and B. A is added at a given \"feed\" rate, B is removed at a given \"kill\" rate, and two B units reproduce into a third B unit in the presence of an A: 2B + 1A = 3B. The relevant parameters are in Common.", "tags": ["diffusion", "reaction", "reproduction", "chemistry"], "likes": 4, "viewed": 324, "published": 3, "date": "1619585737", "time_retrieved": "2024-07-30T19:22:58.332056", "image_code": "#define HIGHLIGHT_MULTIPLIER 2.5\n\nvec2 getAB(ivec2 pos) {\n    return texelFetch(iChannel0, pos, 0).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 AB = getAB(ivec2(fragCoord));\n\n    \n    float A = clamp(AB.x, 0.0, 1.0);\n    float B = clamp(AB.y, 0.0, 1.0);\n    \n    vec3 onlyB = vec3(0.1, 0.2, 1.0) * B;\n    vec3 leadingEdge = vec3(0.7, 0.85, 1.0) * (B - A) * HIGHLIGHT_MULTIPLIER;\n    vec3 straightB = vec3(B) * vec3(0.4, 0.6, 1.0);\n    \n    \n    fragColor = vec4(straightB + onlyB + leadingEdge,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// These can make many different looks and evolving structures\n#define FEED_RATE 0.055\n#define KILL_RATE 0.062\n\n// These also drastically change how the structures evolve;\n// They must be between 0.0 and 1.0 for interesting results\n#define A_DIFFUSION 1.0\n#define B_DIFFUSION 0.5\n\n// This should probably stay 1.0\n#define REACTIVITY 1.0\n// This does weird things when it's greater than 1.0\n#define TIME_SCALE 1.0\n\n#define B_INIT_RADIUS 32.0\n\n// Use the left mouse button to place \"B\"\n#define MOUSE_PLACE_SIZE 8.0", "buffer_a_code": "vec2 getAB(vec2 pos) {\n    return texelFetch(iChannel0, ivec2(mod(pos, iResolution.xy)), 0).xy;\n}\n\nvec2 laplacian(vec2 center, vec2 AB) {\n    // center\n    vec2 sum = -AB;\n    \n    // adjacent neighbors\n    sum += 0.2 * getAB(center + vec2(0, 1));\n    sum += 0.2 * getAB(center + vec2(0, -1));\n    sum += 0.2 * getAB(center + vec2(1, 0));\n    sum += 0.2 * getAB(center + vec2(-1, 0));\n    \n    // diagonal neighbors\n    sum += 0.05 * getAB(center + vec2(1, 1));\n    sum += 0.05 * getAB(center + vec2(1, -1));\n    sum += 0.05 * getAB(center + vec2(-1, 1));\n    sum += 0.05 * getAB(center + vec2(-1, -1));\n\n    sum.x = isnan(sum.x) ? 0.0 : sum.x;\n    sum.y = isnan(sum.y) ? 0.0 : sum.y;\n\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 1) {\n        // initialize simulation\n        float A = 1.0;\n        float B = max(0.0, min(1.0, B_INIT_RADIUS - distance(iResolution.xy / 2.0, fragCoord)));\n        \n        fragColor = vec4(A, B, 0.0, 1.0);\n        return;\n    }\n    \n    vec2 previous = getAB(fragCoord);\n    float A = clamp(isnan(previous.x) ? 0.0 : previous.x, 0.0, 1.0);\n    float B = clamp(isnan(previous.y) ? 1.0 : previous.y, 0.0, 1.0);\n    \n    if(iMouse.z > 0.0 && distance(fragCoord, iMouse.xy) < MOUSE_PLACE_SIZE) {\n        B = 0.5;\n    }\n    \n    \n    // conduct chemical diffusion simulation\n    \n    vec2 diffusion = laplacian(fragCoord, previous);\n    float deltaA = TIME_SCALE * (A_DIFFUSION * diffusion.x - (REACTIVITY * A * B * B) + FEED_RATE * (1.0 - A));\n    float deltaB = TIME_SCALE * (B_DIFFUSION * diffusion.y + (REACTIVITY * A * B * B) - B * (FEED_RATE + KILL_RATE));\n    \n    deltaA = isnan(deltaA) ? 0.0 : deltaA;\n    deltaB = isnan(deltaB) ? 0.0 : deltaB;\n    \n    A = clamp(A + deltaA, 0.0, 1.0);\n    B = clamp(B + deltaB, 0.0, 1.0);\n    \n    fragColor = vec4(A, B, 0.0, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBSzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 57, 57, 104], [106, 106, 163, 163, 530]], "test": "untested"}
{"id": "7sjXzR", "name": "Self-modifying wires", "author": "jarble", "description": "This cellular automaton arranges itself into a pattern of flickering wire-like structures.", "tags": ["automata", "feedback", "cellularautomata"], "likes": 6, "viewed": 298, "published": 3, "date": "1619581724", "time_retrieved": "2024-07-30T19:22:59.318419", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 4.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 0.11;\nconst float B = 0.80;\nconst float C = 2.5;\nconst float D = 1.0;\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = 1.0;\nconst float NUM_NEIGH = 9.0;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum += GET(d);\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL * (NUM_NEIGH + D) + B * ((C / NUM_NEIGH) * sum-cen) - sum;\n\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val = new_val;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjXzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 284]], "test": "untested"}
{"id": "ss2SzR", "name": "Glider ships", "author": "jarble", "description": "This \"infinite state\" automaton has many gliders that resemble ships. They often collide to form new structures.", "tags": ["automata", "feedback", "cellularautomata"], "likes": 4, "viewed": 280, "published": 3, "date": "1619578281", "time_retrieved": "2024-07-30T19:23:00.273865", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 4.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 0.11;\nconst float B = 0.80;\nconst float C = 2.5;\nconst float D = 1.0;\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = 1.0;\nconst float NUM_NEIGH = 9.0;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum += GET(d);\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL * (NUM_NEIGH + D) + B * ((C / NUM_NEIGH) * sum+cen) - sum;\n\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val = new_val;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2SzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 284]], "test": "untested"}
{"id": "Nd2Szz", "name": "Telesto Inpsired Cover Art", "author": "TheNosiriN", "description": "Another shader inspired by some lofi art.\nTry using the Abstract 3 Texture in Buffer A's iChannel0, or Lichen, actually you can try putting any texture on there see how it looks.", "tags": ["raymarching", "space", "planet", "lensflare", "lofi", "nft"], "likes": 51, "viewed": 1168, "published": 3, "date": "1619563547", "time_retrieved": "2024-07-30T19:23:01.249257", "image_code": "// Made by: TheNosiriN\n// I wish I didn't use a texture in the end ._.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define MARGIN //comment to remove annoying margins\n//#define LOW_QUALITY\n\n\n#define R (iResolution.xy)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n\nconst float margin = 1.65;\nconst vec3 light = normalize(vec3(0.9,0.5,-1));\n\nfloat dot2(vec3 p){ return dot(p,p); }\n\n\n\n// Dave_Hoskins Hash: https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p){\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n//\n\n\n// Anamorphic lensflare 1: https://www.shadertoy.com/view/wlcyzj\nfloat sunflare(vec2 uv){\n    float ang = atan(uv.y, uv.x);\n\tfloat d = length(uv);\n    d = pow(d, 0.1);\n\tfloat f = 1.2/(length(uv)*25.0+1.2);\n\tf = pow(f, 2.0);\n\tf = f+f*(sin((ang+1.0/18.0)*12.0)*.1+d*.1+.8);\n    return f;\n}\nfloat anflare(vec2 uv, float intensity, float stretch, float brightness){\n    uv.x *= 1.0/(intensity*stretch);\n    uv.y *= 0.5;\n    return smoothstep(0.009, 0.0, length(uv))*brightness;\n}\n//\n\nmat2 rotate(float angle){\n\tangle *= 3.142 / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat smin(float a, float b, float k){\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n\nvec2 space(vec3 p){\n    float h = sin(p.x*0.05+cos(p.z*0.05))*10.;\n    float i, a=1.;\n    for (vec2 np=p.xz; i<3.; i++){\n        #ifdef LOW_QUALITY\n        float re = textureLod(iChannel0, np*0.002, 1.).r;\n        #else\n        float re = textureLod(iChannel0, np*0.002, 0.).r;\n        #endif\n        h += (re*2.-1.)*a*(h*0.4);\n        np = mat2(0.8,-0.6,0.6,0.8) * np * 2.;\n        a *= 0.5;\n    }\n\n    vec2 d = vec2(p.y+10.+h, 0);\n    \n    p -= vec3(0,-10,-30);\n    p.xy *= rotate(30.);\n    p.xz *= rotate(10.);\n    vec3 q = abs(p)-4.5;\n    float qr = max(q.x,max(q.y,q.z));\n    #ifndef LOW_QUALITY\n    qr -= dot2(textureLod(iChannel0, vec2(p.x,min(p.y,p.z))*0.04, 2.).rgb)*0.3;\n    #endif\n    d.x = smin(d.x, max(qr, -length(p)+6.), 2. );\n    d.x = min(d.x, length( p-vec3(0,-0.5,0) )-1.);\n    \n    d.x *= 0.3;\n    return d;\n}\n\nfloat planet(vec3 eye, vec3 dir){\n    float rad = 4.5;\n    float a = dot(dir, dir);\n    float b = 2.*dot(eye,dir);\n    float c = dot(eye,eye)-rad*rad;\n    float d = b*b-4.*a*c;\n\n    if(d<0.)return -1.;\n    return (-b-sqrt(d))/(2.*a);\n}\n\n\n\nvec3 screenray(vec3 eye, vec3 dir, float maxd){\n    float d, i; vec2 ind;\n    for (; i<100. && d<maxd; i++){\n        vec2 ind = space(eye + dir * d);\n        if (abs(ind.x) < 0.001 * d)break;\n        d += ind.x;\n    }\n    return vec3(d, ind.y, i/100.);\n}\n\n\nfloat shadowray(vec3 eye, vec3 dir, float maxd) {\n    float d, i, r=1., ph=1e10;\n    for(; i<100. && d<maxd; i++){\n     \tvec3 p = eye + dir * d;\n        float ind = space(p).x;\n        if (abs(ind) < 0.001 * d)return 0.;\n        \n        float y = ind*ind/(2.0*ph),\n        nd = sqrt(ind*ind-y*y);\n        r = min( r, 10.0*nd/max(0.0,d-y) );\n        \n        d += ind;\n    }\n\n    return r;\n}\n\n\n\n\nfloat shade(vec3 eye, float dist, float md, vec3 P, vec3 N){\n    float shading = saturate(dot(N, light)*0.5+0.25);\n    shading = mix(min(1.0,shading*3.0), shading, dot(normalize(eye), N));\n    if (shading >= 0.0){ shading *= shadowray(P,light,50.)+0.1; }\n\n    return saturate( (shading+0.1)+(dist/md)*0.1 );\n}\n\n\n\n/* Sometime later...\nfloat stars(vec2 uv){\n    float d, i;\n    for (; i<3.; i++){\n        d = \n    }\n    \n    return d;\n}*/\n\n\n\nfloat makePixel(vec2 C){\n    vec2 uv = (C-R*0.5)/R.y;\n    \n    vec3 eye = vec3(0,-1.5,10);\n    \n    vec3 f = normalize(vec3(3,-3,0) - eye),\n    s = normalize(cross(f, vec3(0,1,0))),\n    dir = (\n        mat4(vec4(s,0), vec4(cross(s, f),0), vec4(-f,0), vec4(1)) * \n        vec4(normalize(vec3(uv, -0.8)), 0)\n    ).xyz;\n    \n    \n    vec3 pdir = dir;\n    float pd = planet(eye-vec3(0,-2,-1), pdir);\n    \n    float md = 100.;\n    vec3 gdir = dir;\n    gdir.y += sin(uv.x*2.0+1.3)*0.1;\n    vec3 dist = screenray(eye, gdir, md);\n    \n    vec3 sdir = dir;\n    sdir.xz *= rotate(-22.);\n    sdir.yz *= rotate(-7.5);\n    vec2 uvs = sdir.xy;\n    \n    \n    float col;\n    \n    if (dist.x < md){\n        vec3 P = eye + gdir * dist.x,\n        ep = vec3(-4, 4, 0) * 0.001,\n        N = normalize(\n            space(P+ep.xyy).x * ep.xyy + \n            space(P+ep.yxy).x * ep.yxy + \n            space(P+ep.yyx).x * ep.yyx + \n            space(P+ep.xxx).x * ep.xxx\n        );\n        \n        col += shade(eye, dist.x, md, P, N);\n        \n    }else{\n        if (pd > -1.){\n            vec3 P = eye + pdir * pd;\n            vec3 N = normalize(P);\n            N = normalize(N + dot2(textureLod(iChannel0, P.xy*0.5, 1.).rgb));\n            \n            float sh = shade(eye, pd, md, P, N)*2.0-1.;\n            col = mix(col, 1.0, saturate(sh));\n        }else{\n            col += length(uvs) < 0.009 ? 1.0 : 0.0;\n        }\n    }\n    col = mix(col*0.4, col, saturate(1.0-pow(dist.z,3.0)*3.0));\n    \n    col += sqrt(sunflare(uvs));\n    float an = pow(anflare(uvs, 600.0, 0.5, 0.63), 4.0);\n    an += smoothstep(0.0025, 1.0, an)*10.0;\n    an *= smoothstep(0.0, 1.0, an);\n    col += an;\n    \n    return saturate(col);\n}\n\n\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    if (C == vec2(0.5)){ O.a=R.x; return; }\n    if ( R.x!=texelFetch( iChannel1, ivec2(0), 0).a ){ O = vec4(0); return; }\n    \n    #ifdef MARGIN\n    float mR = min(R.x,R.y);\n    if (abs(C.x-R.x/2.) >= mR/margin){ O = vec4(0.0); return; }\n    if (abs(C.y-R.y/2.) >= mR/margin){ O = vec4(0.0); return; }\n    #endif\n    \n    \n    float col;\n    \n    col = (makePixel(C+hash21(float(iFrame))*1.5) + texture(iChannel1, C/R).r*50.)/51.;\n    \n    \n    // 1 channel, idk what to do with the rest\n    O = vec4(vec3(saturate(col)), 1.);\n    \n}\n", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2Szz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 130, 130, 194]], "test": "untested"}
{"id": "fd2SRR", "name": "Gem spiral mosaic", "author": "jarble", "description": "A mosaic of gems and spirals.", "tags": ["fractal", "spiral", "gem"], "likes": 2, "viewed": 269, "published": 3, "date": "1619550044", "time_retrieved": "2024-07-30T19:23:02.244595", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.65;\n        float scale1 = 1.05;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(-uv.x/scale+uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1;\n            uv = fract(-uv.yx/s1)*s1;\n            \n            scale1 += (uv.x*(.00025*fract((uv.x+iTime)/2.)));\n            //make it dance!\n            \n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2SRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 915]], "test": "untested"}
{"id": "7sBSRz", "name": "Simple test level flyby", "author": "mzsolt", "description": "I am working on a voxel based fps and thought of exporting a simple test level to prototype surface shaders.\nThis is just a basic flyby of a level I made for testing my simple lightmap code https://youtu.be/Qjur3U.\nThe prototyping can start from here. :)", "tags": ["flyby", "cga"], "likes": 3, "viewed": 321, "published": 3, "date": "1619546911", "time_retrieved": "2024-07-30T19:23:03.288804", "image_code": "// Based on Ray-Box intersection, by iq. https://www.shadertoy.com/view/ld23DV\n\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n\n// https://iquilezles.org/articles/boxfunctions\nfloat sBox( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n\t\n\treturn tN;\n}\n\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n/*\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}*/\n\nstruct BoxData\n{\n\tvec3 pos;\n\tvec3 siz;\n\tint ty;\n};\n\nstruct LightData\n{\n\tvec3 pos;\n\tvec3 col;\n\tfloat r;\n};\n\nstruct CamPosData\n{\n\tvec3 pos;\n\tvec3 tgt;\n};\n\nBoxData bd[99] = BoxData[99](\n    BoxData(vec3(5.000000,1.500000,-49.500000), vec3(8.000000,0.500000,10.500000), 3),\n    BoxData(vec3(12.500000,3.000000,-49.500000), vec3(0.500000,1.000000,10.500000), 3),\n    BoxData(vec3(4.500000,3.000000,-59.500000), vec3(7.500000,1.000000,0.500000), 3),\n    BoxData(vec3(8.500000,3.500000,-55.500000), vec3(1.500000,1.500000,0.500000), 4),\n    BoxData(vec3(8.500000,3.500000,-54.500000), vec3(1.500000,1.500000,0.500000), 4),\n    BoxData(vec3(7.500000,2.500000,-49.500000), vec3(1.500000,0.500000,0.500000), 4),\n    BoxData(vec3(8.500000,6.500000,-55.000000), vec3(0.500000,1.500000,1.000000), 4),\n    BoxData(vec3(9.500000,3.000000,-39.500000), vec3(2.500000,1.000000,0.500000), 3),\n    BoxData(vec3(7.500000,2.500000,-50.500000), vec3(0.500000,0.500000,0.500000), 4),\n    BoxData(vec3(7.500000,2.500000,-48.500000), vec3(0.500000,0.500000,0.500000), 4),\n    BoxData(vec3(7.500000,5.500000,-49.500000), vec3(0.500000,2.500000,0.500000), 4),\n    BoxData(vec3(6.500000,7.500000,-55.000000), vec3(1.500000,0.500000,1.000000), 4),\n    BoxData(vec3(3.500000,6.500000,-49.500000), vec3(3.500000,0.500000,0.500000), 4),\n    BoxData(vec3(1.500000,5.500000,-45.500000), vec3(0.500000,3.500000,0.500000), 4),\n    BoxData(vec3(1.000000,2.500000,-44.500000), vec3(1.000000,0.500000,0.500000), 4),\n    BoxData(vec3(0.500000,2.500000,-45.500000), vec3(0.500000,0.500000,0.500000), 4),\n    BoxData(vec3(7.500000,4.500000,-38.500000), vec3(0.500000,3.500000,0.500000), 3),\n    BoxData(vec3(7.500000,6.000000,-39.500000), vec3(0.500000,2.000000,0.500000), 3),\n    BoxData(vec3(4.500000,1.500000,-38.000000), vec3(2.500000,0.500000,1.000000), 3),\n    BoxData(vec3(6.500000,5.000000,-37.500000), vec3(0.500000,3.000000,0.500000), 3),\n    BoxData(vec3(4.500000,7.500000,-39.000000), vec3(2.500000,0.500000,1.000000), 3),\n    BoxData(vec3(5.500000,4.500000,-36.500000), vec3(0.500000,3.500000,0.500000), 3),\n    BoxData(vec3(3.500000,7.500000,-37.500000), vec3(2.500000,0.500000,0.500000), 3),\n    BoxData(vec3(2.500000,1.500000,-36.000000), vec3(2.500000,0.500000,1.000000), 3),\n    BoxData(vec3(4.500000,5.000000,-35.500000), vec3(0.500000,3.000000,0.500000), 3),\n    BoxData(vec3(2.500000,7.500000,-36.500000), vec3(2.500000,0.500000,0.500000), 3),\n    BoxData(vec3(3.500000,4.500000,-34.500000), vec3(0.500000,3.500000,0.500000), 3),\n    BoxData(vec3(1.500000,7.500000,-35.500000), vec3(2.500000,0.500000,0.500000), 3),\n    BoxData(vec3(0.500000,1.500000,-34.000000), vec3(2.500000,0.500000,1.000000), 3),\n    BoxData(vec3(-0.000000,3.000000,-39.500000), vec3(3.000000,1.000000,0.500000), 3),\n    BoxData(vec3(2.500000,4.500000,-38.500000), vec3(0.500000,2.500000,0.500000), 3),\n    BoxData(vec3(2.500000,5.000000,-33.500000), vec3(0.500000,3.000000,0.500000), 3),\n    BoxData(vec3(2.500000,5.500000,-39.500000), vec3(0.500000,1.500000,0.500000), 3),\n    BoxData(vec3(0.500000,7.500000,-34.500000), vec3(2.500000,0.500000,0.500000), 3),\n    BoxData(vec3(1.500000,4.000000,-37.500000), vec3(0.500000,3.000000,0.500000), 3),\n    BoxData(vec3(1.500000,4.500000,-32.500000), vec3(0.500000,3.500000,0.500000), 3),\n    BoxData(vec3(-0.500000,7.500000,-33.500000), vec3(2.500000,0.500000,0.500000), 3),\n    BoxData(vec3(-1.500000,1.500000,-28.000000), vec3(2.500000,0.500000,5.000000), 3),\n    BoxData(vec3(0.500000,4.500000,-36.500000), vec3(0.500000,2.500000,0.500000), 3),\n    BoxData(vec3(-1.500000,7.500000,-28.000000), vec3(2.500000,0.500000,5.000000), 3),\n    BoxData(vec3(0.500000,4.500000,-27.500000), vec3(0.500000,2.500000,4.500000), 3),\n    BoxData(vec3(0.500000,4.500000,-22.500000), vec3(0.500000,3.500000,0.500000), 1),\n    BoxData(vec3(-2.000000,2.500000,-21.500000), vec3(3.000000,0.500000,0.500000), 1),\n    BoxData(vec3(0.500000,5.500000,-21.000000), vec3(0.500000,2.500000,1.000000), 1),\n    BoxData(vec3(-2.000000,4.500000,-19.500000), vec3(3.000000,0.500000,0.500000), 1),\n    BoxData(vec3(0.500000,6.500000,-16.500000), vec3(0.500000,1.500000,3.500000), 1),\n    BoxData(vec3(-0.000000,0.500000,-1.500000), vec3(8.000000,0.500000,9.500000), 3),\n    BoxData(vec3(7.500000,2.500000,-1.500000), vec3(0.500000,1.500000,9.500000), 1),\n    BoxData(vec3(-0.500000,1.500000,-10.500000), vec3(7.500000,0.500000,0.500000), 1),\n    BoxData(vec3(-0.500000,2.500000,-10.500000), vec3(7.500000,0.500000,0.500000), 1),\n    BoxData(vec3(5.500000,3.500000,-10.500000), vec3(1.500000,0.500000,0.500000), 1),\n    BoxData(vec3(4.500000,6.000000,-7.500000), vec3(0.500000,5.000000,2.500000), 1),\n    BoxData(vec3(4.500000,7.500000,-10.500000), vec3(0.500000,3.500000,0.500000), 1),\n    BoxData(vec3(-0.500000,5.500000,-8.000000), vec3(4.500000,0.500000,3.000000), 1),\n    BoxData(vec3(1.500000,7.000000,-10.500000), vec3(2.500000,1.000000,0.500000), 1),\n    BoxData(vec3(0.500000,8.500000,-8.500000), vec3(0.500000,2.500000,1.500000), 1),\n    BoxData(vec3(3.500000,2.500000,-7.500000), vec3(0.500000,0.500000,0.500000), 2),\n    BoxData(vec3(3.500000,7.500000,-7.500000), vec3(0.500000,0.500000,0.500000), 2),\n    BoxData(vec3(-0.000000,3.000000,-0.500000), vec3(1.000000,1.000000,0.500000), 1),\n    BoxData(vec3(-0.000000,4.000000,-1.500000), vec3(1.000000,1.000000,0.500000), 1),\n    BoxData(vec3(-0.000000,5.000000,-2.500000), vec3(1.000000,1.000000,0.500000), 1),\n    BoxData(vec3(-0.000000,5.500000,-4.000000), vec3(1.000000,0.500000,1.000000), 1),\n    BoxData(vec3(3.500000,8.500000,-45.500000), vec3(0.500000,0.500000,1.500000), 4),\n    BoxData(vec3(2.500000,8.500000,-45.500000), vec3(0.500000,0.500000,0.500000), 4),\n    BoxData(vec3(2.500000,10.500000,-8.000000), vec3(1.500000,0.500000,3.000000), 1),\n    BoxData(vec3(0.500000,9.500000,-10.500000), vec3(0.500000,1.500000,0.500000), 1),\n    BoxData(vec3(-2.000000,10.500000,-6.000000), vec3(3.000000,0.500000,1.000000), 1),\n    BoxData(vec3(-0.500000,2.500000,7.500000), vec3(7.500000,1.500000,0.500000), 1),\n    BoxData(vec3(-0.000000,2.000000,0.500000), vec3(1.000000,1.000000,0.500000), 1),\n    BoxData(vec3(-0.000000,1.500000,1.500000), vec3(1.000000,0.500000,0.500000), 1),\n    BoxData(vec3(-2.500000,3.000000,-49.500000), vec3(0.500000,1.000000,9.500000), 3),\n    BoxData(vec3(-0.500000,4.000000,-35.500000), vec3(0.500000,3.000000,0.500000), 3),\n    BoxData(vec3(-1.500000,4.500000,-34.500000), vec3(0.500000,2.500000,0.500000), 3),\n    BoxData(vec3(-2.500000,4.000000,-33.500000), vec3(0.500000,3.000000,0.500000), 3),\n    BoxData(vec3(-3.500000,4.500000,-32.500000), vec3(0.500000,2.500000,0.500000), 3),\n    BoxData(vec3(-4.500000,4.500000,-27.500000), vec3(0.500000,3.500000,4.500000), 3),\n    BoxData(vec3(-2.500000,1.500000,-22.500000), vec3(2.500000,0.500000,0.500000), 1),\n    BoxData(vec3(-2.000000,3.500000,-20.500000), vec3(2.000000,0.500000,0.500000), 1),\n    BoxData(vec3(-2.500000,5.500000,-16.000000), vec3(2.500000,0.500000,3.000000), 1),\n    BoxData(vec3(-4.500000,5.000000,-22.500000), vec3(0.500000,3.000000,0.500000), 1),\n    BoxData(vec3(-4.500000,5.500000,-21.500000), vec3(0.500000,2.500000,0.500000), 1),\n    BoxData(vec3(-4.500000,6.000000,-20.500000), vec3(0.500000,2.000000,0.500000), 1),\n    BoxData(vec3(-4.500000,6.500000,-19.500000), vec3(0.500000,1.500000,0.500000), 1),\n    BoxData(vec3(-4.500000,7.000000,-16.000000), vec3(0.500000,1.000000,3.000000), 1),\n    BoxData(vec3(-0.500000,3.000000,-7.500000), vec3(0.500000,2.000000,2.500000), 1),\n    BoxData(vec3(-0.500000,4.000000,-10.500000), vec3(0.500000,1.000000,0.500000), 1),\n    BoxData(vec3(-2.000000,5.500000,-12.000000), vec3(2.000000,0.500000,1.000000), 1),\n    BoxData(vec3(-0.500000,7.000000,-12.000000), vec3(0.500000,1.000000,1.000000), 1),\n    BoxData(vec3(-3.500000,7.000000,-11.500000), vec3(0.500000,1.000000,1.500000), 1),\n    BoxData(vec3(-4.500000,3.000000,-7.500000), vec3(0.500000,2.000000,2.500000), 1),\n    BoxData(vec3(-6.000000,3.500000,-10.500000), vec3(2.000000,0.500000,0.500000), 1),\n    BoxData(vec3(-4.500000,4.500000,-10.500000), vec3(0.500000,0.500000,0.500000), 1),\n    BoxData(vec3(-4.500000,8.500000,-9.000000), vec3(0.500000,2.500000,2.000000), 1),\n    BoxData(vec3(-7.500000,2.500000,-1.500000), vec3(0.500000,1.500000,8.500000), 1),\n    BoxData(vec3(-3.500000,2.500000,-6.500000), vec3(0.500000,0.500000,0.500000), 2),\n    BoxData(vec3(-3.500000,7.500000,-6.500000), vec3(0.500000,0.500000,0.500000), 2),\n    BoxData(vec3(-4.500000,8.000000,-6.000000), vec3(0.500000,2.000000,1.000000), 1),\n    BoxData(vec3(-2.000000,10.500000,-9.000000), vec3(2.000000,0.500000,2.000000), 1),\n    BoxData(vec3(-7.500000,3.500000,8.500000), vec3(0.500000,0.500000,0.500000), 1)\n);\n\nLightData ld[9] = LightData[9](\n    LightData(vec3(2.500000,3.500000,-7.000000), vec3(1.000000,0.000000,1.000000), 5.000000),\n    LightData(vec3(-3.000000,3.500000,-7.000000), vec3(0.000000,1.000000,1.000000), 5.000000),\n    LightData(vec3(2.500000,8.500000,-7.000000), vec3(0.000000,0.400000,0.900000), 5.000000),\n    LightData(vec3(-3.000000,8.500000,-7.000000), vec3(0.900000,1.000000,0.100000), 5.000000),\n    LightData(vec3(-0.500000,6.000000,-25.000000), vec3(1.000000,1.000000,1.000000), 3.000000),\n    LightData(vec3(-0.500000,6.000000,-31.000000), vec3(1.000000,1.000000,1.000000), 3.000000),\n    LightData(vec3(-3.500000,6.000000,-25.000000), vec3(1.000000,1.000000,1.000000), 3.000000),\n    LightData(vec3(-3.500000,6.000000,-31.000000), vec3(1.000000,1.000000,1.000000), 3.000000),\n    LightData(vec3(-0.500000,6.000000,-34.000000), vec3(1.000000,1.000000,1.000000), 3.000000)\n);\n\nCamPosData cp[] = CamPosData[](\nCamPosData(vec3(-2.000000,1.900000,2.000000), vec3(-2.000000,1.900000,3.000000)),\nCamPosData(vec3(-2.000000,1.900000,2.000000), vec3(-2.009425,1.900000,2.999956)),\nCamPosData(vec3(-1.460000,1.932757,1.234773), vec3(-2.000350,1.986138,2.074519)),\nCamPosData(vec3(-2.892282,2.155061,4.702333), vec3(-3.393976,2.376269,3.866050)),\nCamPosData(vec3(-3.757271,2.518680,3.818990), vec3(-3.446917,2.773451,2.903145)),\nCamPosData(vec3(-2.996557,3.195341,-1.011240), vec3(-2.952601,3.170211,-2.009957)),\nCamPosData(vec3(-2.534242,3.074446,-5.956488), vec3(-2.518534,3.087013,-6.956285)),\nCamPosData(vec3(-2.454909,3.017715,-5.711578), vec3(-2.486197,3.105567,-6.707220)),\nCamPosData(vec3(-4.347242,1.910000,-1.520798), vec3(-3.867121,2.109710,-2.374964)),\nCamPosData(vec3(-2.655343,1.961232,-2.189268), vec3(-1.968674,1.983221,-2.915906)),\nCamPosData(vec3(0.351536,2.797791,-4.540000), vec3(0.495105,3.194939,-5.446455)),\nCamPosData(vec3(0.906096,3.366702,-8.691833), vec3(0.852952,3.272594,-9.685975)),\nCamPosData(vec3(2.417580,3.685781,-9.540000), vec3(2.268314,3.798638,-10.522335)),\nCamPosData(vec3(2.380995,3.726415,-8.059148), vec3(2.349808,3.845512,-9.051540)),\nCamPosData(vec3(1.174739,3.197919,-3.613107), vec3(1.143552,3.317016,-4.605499)),\nCamPosData(vec3(2.711044,2.775738,-1.441660), vec3(2.561009,2.825983,-2.429063)),\nCamPosData(vec3(1.808191,2.400199,2.925321), vec3(1.695948,2.651931,1.964055)),\nCamPosData(vec3(0.940645,2.854847,3.696516), vec3(0.828305,3.550760,2.987231)),\nCamPosData(vec3(0.217461,5.933011,-0.152619), vec3(0.004019,6.387001,-1.017682)),\nCamPosData(vec3(-0.834712,7.419567,-3.998655), vec3(-1.056111,7.579103,-4.960700)),\nCamPosData(vec3(-1.599242,7.553537,-7.580861), vec3(-1.792745,7.575527,-8.561714)),\nCamPosData(vec3(-2.184726,7.374053,-12.525115), vec3(-2.203441,7.254956,-13.517821)),\nCamPosData(vec3(-2.278282,6.910000,-17.487429), vec3(-2.296996,6.790903,-18.480135)),\nCamPosData(vec3(-2.327761,6.111896,-22.359962), vec3(-2.321779,5.805868,-23.311966)),\nCamPosData(vec3(-2.186686,5.035440,-27.222065), vec3(-2.136899,4.900762,-28.211702)),\nCamPosData(vec3(-0.993219,4.904999,-31.978512), vec3(-0.454830,5.005361,-32.815208)),\nCamPosData(vec3(2.171228,4.369769,-35.719467), vec3(2.794889,4.090777,-36.449680)),\nCamPosData(vec3(4.561439,3.589409,-39.984077), vec3(4.797843,3.617679,-40.955322)),\nCamPosData(vec3(4.739790,4.330019,-44.879646), vec3(4.578045,4.548162,-45.842068)),\nCamPosData(vec3(3.364606,4.765773,-49.650120), vec3(3.070709,4.797184,-50.605442)),\nCamPosData(vec3(-0.119510,4.995971,-52.331497), vec3(0.396747,5.444354,-53.061176)),\nCamPosData(vec3(-1.124801,4.916638,-55.486805), vec3(-0.414231,5.038854,-54.793873)),\nCamPosData(vec3(-2.172987,4.906855,-60.018024), vec3(-1.580975,4.960237,-59.213867)),\nCamPosData(vec3(-0.034418,4.800329,-63.079533), vec3(0.182555,4.903816,-62.108856)),\nCamPosData(vec3(3.056928,4.681053,-65.734558), vec3(3.150946,4.725021,-64.739960)),\nCamPosData(vec3(6.506225,4.625015,-66.172165), vec3(6.301536,4.731626,-65.199158)),\nCamPosData(vec3(9.294312,4.989921,-62.307842), vec3(9.105581,5.124599,-61.335091)),\nCamPosData(vec3(11.424669,5.425716,-57.879238), vec3(10.933987,5.516696,-57.012661)),\nCamPosData(vec3(12.199143,5.558903,-53.073444), vec3(11.559353,5.571469,-52.304996)),\nCamPosData(vec3(13.897681,5.578884,-49.589725), vec3(13.257891,5.591450,-48.821278)),\nCamPosData(vec3(14.351370,5.623287,-44.611916), vec3(13.701974,5.635853,-43.851570)),\nCamPosData(vec3(13.949431,5.721174,-39.631672), vec3(13.187083,5.736881,-38.984695)),\nCamPosData(vec3(13.510080,5.776707,-34.652901), vec3(12.741669,5.792414,-34.013138)),\nCamPosData(vec3(13.055349,5.832239,-29.675463), vec3(12.286938,5.847946,-29.035700)),\nCamPosData(vec3(12.600618,5.887772,-24.698084), vec3(11.832207,5.903479,-24.058321)),\nCamPosData(vec3(12.143284,5.943304,-19.720942), vec3(11.370868,5.959011,-19.086020)),\nCamPosData(vec3(10.600552,5.947750,-14.993365), vec3(9.682802,5.944608,-14.596219)),\nCamPosData(vec3(10.544567,5.942755,-11.117718), vec3(9.626818,5.939613,-10.720572)),\nCamPosData(vec3(8.563757,5.958488,-6.788820), vec3(7.572689,5.980478,-6.657287)),\nCamPosData(vec3(8.392307,5.958488,-3.293463), vec3(7.468257,5.911382,-3.672820)),\nCamPosData(vec3(7.676145,6.361337,1.006368), vec3(7.086134,6.137066,0.230746)),\nCamPosData(vec3(6.713125,7.291714,5.701828), vec3(6.391634,6.952976,4.817576)),\nCamPosData(vec3(3.644322,7.491270,7.165835), vec3(3.421862,7.285408,6.212875)),\nCamPosData(vec3(0.176282,7.491270,7.617840), vec3(0.116696,7.538376,6.620729)),\nCamPosData(vec3(-2.730626,7.599838,5.662962), vec3(-2.649177,7.659493,4.668072)),\nCamPosData(vec3(-2.257902,7.898043,0.695593), vec3(-2.160836,7.957697,-0.297896)),\nCamPosData(vec3(-1.983430,8.179771,-4.370270), vec3(-1.942655,8.233153,-5.368011)),\nCamPosData(vec3(-1.915488,8.268711,-6.032763), vec3(-1.874713,8.322093,-7.030504))\n);\n\nvec3 dirLdir = vec3(-0.2, -1.0, 0.8);\nvec3 dirLcol = vec3(0.9, 0.7, 0.5);\n\nvoid boxParams(in int i, out mat4 txx, out mat4 txi, out vec3 boxSize)\n{\n\tvec3 trapos = bd[i].pos;\n\tmat4 tra = translate( trapos.x, trapos.y, trapos.z );\n\ttxi = tra; \n\ttxx = inverse( txi );\n\tboxSize = bd[i].siz;\n}\n\nint iScene(in vec3 ro, in vec3 rd, out float tmin, out vec3 nor)\n{\n\tint oid = -1;\n\ttmin = 10000.0;\n\n\tfor (int i = 0; i < bd.length(); i++)\n\t{\n\t\tmat4 ttxi; \n\t\tmat4 ttxx;\n\t\tvec3 siz;\n\t\tboxParams(i, ttxx, ttxi, siz);\n\n\t\tvec4 res = iBox( ro, rd, ttxx, ttxi, siz);\n\n\t\tif( res.x>0.0 && res.x<tmin )\n\t\t{\n\t\t\ttmin = res.x; \n\t\t\tnor = res.yzw;\n\t\t\toid = i;\n\t\t}\n\t}\n\n\treturn oid;\n}\n\nbool isLightVisible(in vec3 ro, in int id)\n{\n\tfloat dist = length(ld[id].pos - ro);\n\tvec3 rd = normalize(ld[id].pos - ro);\n\tfloat tmin;\n\tvec3 nor;\n\tint oid = iScene(ro, rd, tmin, nor);\n\tif (oid == -1 || tmin > dist)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nfloat attenuation(in vec3 p, in vec3 l, in float radius)\n{\n\tfloat temp1 = 1.0 / (radius * radius);\n\tfloat temp2 = 2.0 / radius;\n\tvec3 ldir = l - p;\n    float r2 = dot(ldir, ldir);\n    float r = sqrt(r2);        \n    float ret = 0.0;\n\tif (r < radius)\n\t{\n\t\tret = clamp( r2 * temp1 * (r * temp2 - 3.0) + 1.0, 0.0, 1.0 );\n\t}\n\treturn ret;\n}\n\nvec3 light(in vec3 pos, in vec3 nor)\n{\n\tvec3 ro = pos + 0.001 * nor;\n\tvec3 ret = vec3(0.0);\n\n\tfor (int i = 0; i < ld.length(); i++)\n\t{\n\t\tif (isLightVisible(ro, i))\n\t\t{\n\t\t\tfloat att = attenuation(pos, ld[i].pos, ld[i].r);\n\t\t\tret = ret + ld[i].col * att;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvec3 mainPixel(in vec3 ro, in vec3 rd)\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace box\n\tvec3 boxSize = vec3(0.5,0.5,0.5);\n\tmat4 txx = mat4(1.0);\n\tmat4 txi = mat4(1.0);\n\n\tint oid = iScene(ro, rd, tmin, nor);\n\tif (oid != -1)\n\t{\n\t\tboxParams(oid, txx, txi, boxSize);\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.6,0.75,0.85) - 0.97*rd.y;\n    \n\tif( oid != -1 )\n\t{\n\t\tpos = ro + tmin*rd;\n\t\t\n        // material\n\t\tvec3  mate = vec3(1.0);\n\t\t// recover box space data (we want to do shading in object space)\t\t\t\n\t\tvec3 opos = (txx*vec4(pos,1.0)).xyz;\n\t\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n\t\tmate = abs(onor.x)*texture( iChannel0, 0.5*opos.yz ).xyz + \n\t\t\t\tabs(onor.y)*texture( iChannel0, 0.5*opos.zx ).xyz + \n\t\t\t\tabs(onor.z)*texture( iChannel0, 0.5*opos.xy ).xyz;\n\t\t\n        // directional lighting\n\t\tvec3  lig = normalize(dirLdir);\n\n\t\tvec3 dircol = vec3(0.0);\n\n\t\tfloat shaddist;\n\t\tvec3 shadnor;\n\t\tint shadid = iScene(pos+0.001*nor, -lig, shaddist, shadnor);\n\t\tif (shadid == -1)\n\t\t{\n\t\t\tfloat att = dot(nor, -lig);\n\t\t\tatt = clamp(att, 0.0, 1.0);\n\t\t\tdircol = att * dirLcol;\n\t\t}\n\n\t\tvec3 lightcol = light(pos, nor);\n\n\t\tcol = (lightcol + dircol) * mate;\n\t}\n\n\treturn col;\n}\n\n// CGA conversion from https://www.shadertoy.com/view/3tfSDX\n#define RGB(r,g,b) (vec3(r,g,b) / 255.0)\nvec3 CGAPal[4] = vec3[](RGB(0, 0, 0), \n                        RGB(255, 85, 255), \n                        RGB(85,255, 255), \n                        RGB(255, 255, 255));\n#define PAL_SIZE 4.0\n\nvec3 dither8x8(vec2 position, float brightness) {  \n  float idx = clamp(brightness,0.0,1.0)* (PAL_SIZE - 1.0);\n    \n  vec3 c1 = CGAPal[int(idx)];\n  vec3 c2 = CGAPal[int(idx) + 1];\n    \n  float limit = texture(iChannel1, position / iChannelResolution[1].xy).r;\n  float mixAmt = float(fract(idx) > limit);\n\n  return mix(c1,c2,mixAmt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n\tint idx = int(iTime) % (cp.length() - 1);\n    bool iscga = int(iTime) % ( 2 * (cp.length() - 1) ) >= (cp.length() - 1);\n\n\tfloat step = iTime - floor(iTime);\n\tvec3 roNow = cp[idx].pos;\n\tvec3 tgtNow = cp[idx].tgt;\n\tvec3 roNext = cp[idx+1].pos;\n\tvec3 tgtNext = cp[idx+1].tgt;\n\t\n    // camera origin\n\tvec3 ro = mix(roNow, roNext, step);\n\t// camera target\n\tvec3 ta = mix(tgtNow, tgtNext, step);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\tvec3 col = mainPixel(ro, rd);\n    if (iscga)\n    {\n        float gray = 0.299 * col.x + 0.587 * col.y + 0.114 * col.z;\n        col = dither8x8(fragCoord, gray);\n    }\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 128, 205, 242, 760], [763, 811, 876, 876, 1206], [1302, 1302, 1349, 1349, 1753], [1755, 1755, 1800, 1800, 1916], [16782, 16782, 16854, 16854, 16995], [16997, 16997, 17063, 17063, 17364], [17366, 17366, 17410, 17410, 17632], [17634, 17634, 17692, 17692, 17969], [17971, 17971, 18009, 18009, 18246], [18248, 18248, 18288, 18304, 19467], [19764, 19764, 19813, 19813, 20098], [20100, 20100, 20157, 20157, 21035]], "test": "untested"}
{"id": "sdSSzz", "name": "Crystal skull", "author": "mrange", "description": "License CC0: Crystal skull\nPerhaps it's just me that sees a glowing skull captured in a crystal?\nResult after continued experimenting with marble fractals and different kinds of trap functions\n", "tags": ["raymarch", "fractals", "marble"], "likes": 48, "viewed": 1257, "published": 3, "date": "1619543127", "time_retrieved": "2024-07-30T19:23:04.255220", "image_code": "// License CC0: Crystal skull\n// Perhaps it's just me that sees a glowing skull captured in a crystal?\n// Result after continued experimenting with marble fractals and different kinds of trap functions\n\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define L2(x)             dot(x, x)\n#define PCOS(x)           (0.5+0.5*cos(x))\n\n#define RAYSHAPE(ro, rd)  raySphere4(ro, rd, 0.5)\n#define IRAYSHAPE(ro, rd) iraySphere4(ro, rd, 0.5)\n\nconst float miss          = 1E4;\nconst float refrIndex     = 0.85;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\nconst vec3  skyCol1        = pow(vec3(0.2, 0.4, 0.6), vec3(0.25))*1.0;\nconst vec3  skyCol2        = pow(vec3(0.4, 0.7, 1.0), vec3(2.0))*1.0;\nconst vec3  sunCol         = vec3(8.0,7.0,6.0)/8.0;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Various ray object intersection from IQ:\n//  https://iquilezles.org/articles/intersectors\nfloat raySphere4(vec3 ro, vec3 rd, float ra) {\n    float r2 = ra*ra;\n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n    float ka = 1.0/dot(d2,d2);\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    float h = q*q - p*p*p;\n    if (h<0.0) return miss; //no intersection\n    float sh = sqrt(h);\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n    vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n    float r = length(v);\n    return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n}\n\nvec3 sphere4Normal(vec3 pos) {\n  return normalize( pos*pos*pos );\n}\n\nfloat iraySphere4(vec3 ro, vec3 rd, float ra) {\n  // Computes inner intersection by intersecting a reverse outer intersection\n  vec3 rro = ro + rd*ra*4.0;\n  vec3 rrd = -rd;\n  float rt = raySphere4(rro, rrd, ra);\n\n  if (rt == miss) return miss;\n  \n  vec3 rpos = rro + rrd*rt;\n  return length(rpos - ro);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 0.505));\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    float ts4 = RAYSHAPE(pos, ld);\n    vec3 spos = pos + ld*ts4;\n    float its4= IRAYSHAPE(spos, ld);\n    // Extremely fake soft shadows\n    float sha = ts4 == miss ? 1.0 : (1.0-1.0*tanh_approx(its4*1.5/(0.5+.5*ts4)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n// Marble fractal from https://www.shadertoy.com/view/MtX3Ws\nvec2 csqr(vec2 a) { \n  return vec2(a.x*a.x - a.y*a.y, 2.*a.x*a.y); \n}\n\nfloat l0(vec3 v) {\n  return abs(v.x) + abs(v.y) + abs(v.z);\n}\n\nfloat marble_df(vec3 p) {  \n  float res = 0.;\n\n  vec3 c = p;\n  const float scale = 0.72;\n  const int max_iter = 8;\n  for (int i = 0; i < max_iter; ++i) {\n    p    = scale*abs(p)/L2(p) - scale;\n    p.yz = csqr(p.yz);\n    p    = p.zxy;\n    res  += exp(-2. * L2(p-c));\n  }\n\n  return res;\n}\n\nvec3 marble_march(vec3 ro, vec3 rd, float d, float dist, vec2 tminmax) {\n  float t   = tminmax.x;\n  float dt  = mix(1.0, 0.02, d);\n  vec3 col  = vec3(0.0);\n  float c   = 0.;\n  const int max_iter = 64;\n  for(int i = 0; i < max_iter; ++i) {\n      t += dt*exp(-2.0*c);\n      if(t>tminmax.y) { \n        break; \n      }\n      vec3 pos = ro+t*rd;\n        \n      c = marble_df(pos); \n      c *= 0.5;\n        \n      vec3 dcol = vec3(c*c*c-c*dist, c*c-c, c);\n      col = col + dcol;\n  }    \n  const float scale = 0.005;\n  float td = (t - tminmax.x)/(tminmax.y - tminmax.x);\n  col *= exp(-10.0*td);\n  col *= scale;\n  return col;\n}\n\nvec3 render1(vec3 ro, vec3 rd, float d) {\n  vec3 ipos = ro;\n  vec3 ird  = rd;\n  \n  float its4  = IRAYSHAPE(ipos, ird);\n  \n  float fi    = smoothstep(8.75, 10.0, TIME);\n\n  vec3 dpos = ipos;\n  dpos.x = abs(dpos.x);\n  float dm = mix(0.75, 1.1, (PCOS(-TIME*0.5+8.0*dpos.y))*fi);\n  float dist = 0.0;\n  dist += 0.5*mix(7.0, (length(dpos.xy-vec2(0.1, 0.055))-0.05)*30.0, dm);\n  dist += 0.5*mix(7.0, (length(dpos.xy-vec2(0.0, -0.025))-0.05)*20.0, dm);\n  \n  ipos.z -= mix(0.3, 0.0, fi);\n  ipos.z -= 0.0125*sin(ipos.y*5.0-TIME*sqrt(1.25));\n  ipos -= vec3(0.0, 0.2, mix(0.25, 0.0, d*d*d*d));\n  return marble_march(ipos, ird, d, dist, vec2(0.0, its4));\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  float ts4 = RAYSHAPE(ro, rd);\n  if (ts4 < miss) {\n    t = ts4;\n    vec3 pos  = ro + ts4*rd;\n    vec3 nor  = sphere4Normal(pos);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = skyColor(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 4.0));\n\n    vec3 lv   = lightPos - pos;\n    float ll2 = L2(lv);\n    float ll  = sqrt(ll2);\n    vec3 ld   = lv / ll;\n\n    float dm  = min(1.0, 40.0/ll2);\n    float dif = pow(max(dot(nor,ld),0.0), 8.0)*dm;\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 100.);\n    float l   = dif;\n    \n    float d   = dot(rd, refr);\n    float lin = mix(0.0, 1.0, l);\n    const vec3 lcol = 2.0*sqrt(sunCol);\n    col = render1(pos, refr, d);\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) { \n  vec3 start  = 1.5*vec3(0.5, 0.5, -2.0);\n  vec3 end    = mix(0.4, 0.6, PCOS(TIME*0.1))*vec3(0.0, 0.2, -2.0);\n  float fi    = smoothstep(1.0, 10.0, TIME);\n  vec3 ro     = mix(start, end, fi);\n  ro.zy      *= ROT(0.1*sin(TIME*sqrt(0.05))*fi);\n  ro.xz      *= ROT(0.1*sin(TIME*sqrt(0.02))*fi);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = 2.0+0.5*tanh_approx(length(p));\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n  col = mix(vec3(0.0), col, smoothstep(0.0, 3.0, TIME));\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSSzz.jpg", "access": "api", "license": "cc0-1.0", "functions": [[906, 906, 934, 954, 1030], [1032, 1111, 1133, 1133, 1302], [1304, 1397, 1443, 1443, 2288], [2290, 2290, 2320, 2320, 2357], [2359, 2359, 2406, 2484, 2663], [2665, 2665, 2708, 2708, 2755], [2757, 2757, 2790, 2790, 3853], [3855, 3916, 3935, 3935, 3985], [3987, 3987, 4005, 4005, 4048], [4050, 4050, 4075, 4075, 4336], [4338, 4338, 4410, 4410, 4958], [4960, 4960, 5001, 5001, 5602], [5604, 5604, 5635, 5635, 6750], [6752, 6752, 6781, 6781, 7357], [7359, 7359, 7395, 7395, 7628], [7630, 7630, 7685, 7685, 7929]], "test": "ok"}
{"id": "Nsj3Wm", "name": "RGB SMNCA - Slackermanz", "author": "SlackermanzCA", "description": "\n", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 5, "viewed": 628, "published": 3, "date": "1619529562", "time_retrieved": "2024-07-30T19:23:05.391183", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nprecision highp int;\nprecision highp float;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bufA = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = bufA;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//   - Website: https://slackermanz.com\n//   - Github: https://github.com/Slackermanz\n//   - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//   - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//   - Discord DM: Slackermanz#3405\n//   - Reddit DM: https://old.reddit.com/user/slackermanz\n//   - Twitter: https://twitter.com/slackermanz\n//   - YouTube: https://www.youtube.com/c/slackermanz\n//   - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//   - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//   - Reddit: https://old.reddit.com/r/cellular_automata\n//   - Artificial Life: https://discord.gg/7qvBBVca7u\n//   - Emergence: https://discord.com/invite/J3phjtD\n//   - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n\nconst int MAXSNH = 10;\nconst int SCNH_COUNT = 24;\nconst int SCNH_COUNT_CHAN =  8;\n\nivec4 wsize_unpack(uint ui32) {\n\tivec4 \twsize;\n\t\t\twsize[0] = int(\t ui32 \t\t\t& uint(0x00000FFF) );\n\t\t\twsize[1] = int( (ui32 >> 12) \t& uint(0x00000FFF) );\n\t\t\twsize[2] = int( (ui32 >> 24)\t& uint(0x0000000F) );\n\t\t\twsize[3] = int( (ui32 >> 28)\t& uint(0x0000000F) );\n\treturn \twsize; }\n\nivec4 minfo_unpack(uint ui32) {\n\tivec4 \tminfo;\n\t\t\tminfo[0] = int( (ui32 >>  4) \t& uint(0x00000FFF) );\n\t\t\tminfo[1] = int(\t(ui32 >> 16) \t& uint(0x00000FFF) );\n\t\t\tminfo[2] = int(\t ui32 \t\t \t& uint(0x0000000F) );\n\t\t\tminfo[3] = int(\t(ui32 >> 28) \t& uint(0x0000000F) );\n\treturn \tminfo; }\n\nivec2 eval2_unpack(uint ui32) {\n\tivec2 \teval2;\n\t\t\teval2[0] = int( (ui32      ) \t& uint(0x0000FFFF) );\n\t\t\teval2[1] = int(\t(ui32 >> 16) \t& uint(0x0000FFFF) );\n\treturn \teval2; }\n\nivec4 eval4_unpack(uint ui32) {\n\tivec4 \teval4;\n\t\t\teval4[0] = int( (ui32      ) \t& uint(0x000000FF) );\n\t\t\teval4[1] = int(\t(ui32 >>  8) \t& uint(0x000000FF) );\n\t\t\teval4[2] = int(\t(ui32 >> 16) \t& uint(0x000000FF) );\n\t\t\teval4[3] = int(\t(ui32 >> 24) \t& uint(0x000000FF) );\n\treturn \teval4; }\n\nuint[8] eval8_unpack(uint ui32) {\n\tuint[8]\teval8;\n\t\t\teval8[0] = uint( (ui32      ) \t& uint(0x0000000F) );\n\t\t\teval8[1] = uint( (ui32 >>  4) \t& uint(0x0000000F) );\n\t\t\teval8[2] = uint( (ui32 >>  8) \t& uint(0x0000000F) );\n\t\t\teval8[3] = uint( (ui32 >> 12) \t& uint(0x0000000F) );\n\t\t\teval8[4] = uint( (ui32 >> 16) \t& uint(0x0000000F) );\n\t\t\teval8[5] = uint( (ui32 >> 20) \t& uint(0x0000000F) );\n\t\t\teval8[6] = uint( (ui32 >> 24) \t& uint(0x0000000F) );\n\t\t\teval8[7] = uint( (ui32 >> 28) \t& uint(0x0000000F) );\n\treturn \teval8; }\n\nfloat gdv(ivec2 off, int v) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n\tivec4\tdm\t\t= ivec4(iResolution.x,iResolution.y,1,0);\n\tvec4 \tfc \t\t= gl_FragCoord;\n\tvec2\tdc\t\t= vec2( dm[0]/dm[2], dm[1]/dm[2] );\n\tfloat\tcx\t\t= mod(fc[0]+float(off[0]), dc[0]) + floor(fc[0]/dc[0])*dc[0];\n\tfloat\tcy\t\t= mod(fc[1]+float(off[1]), dc[1]) + floor(fc[1]/dc[1])*dc[1];\n\tvec4 \tpxdata \t= texelFetch( txdata, ivec2(cx, cy), 0);\n\treturn \tpxdata[v]; }\n\nvec3 nhd( ivec2 nbhd, ivec2 ofst, float psn, float thr, int col ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -float(nbhd[0]); i <= float(nbhd[0]); i+=1.0) {\n\t\tfor(float j = -float(nbhd[0]); j <= float(nbhd[0]); j+=1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= float(nbhd[0]) && dist > float(nbhd[1]) && dist != 0.0 ) {\n\t\t\t\tcval = gdv(ivec2(int(i)+ofst[0],int(j)+ofst[1]),col);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } }\n\treturn vec3( c_value, c_valid, c_total ); }\n\n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(int seed) {\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1],  2.0, 19.0 + mod(iDate[3]+float(seed),17.0), 23.0 + mod(iDate[3]+float(seed),43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 14.0, 13.0 + mod(iDate[3]+float(seed),29.0), 17.0 + mod(iDate[3]+float(seed),31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1],  6.0, 13.0 + mod(iDate[3]+float(seed),11.0), 51.0 + mod(iDate[3]+float(seed),37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0); }\n\nfloat nh16_t_02(ivec2 nh, vec3[MAXSNH] rings){\n\tfloat e0_sum = 0.0;\n\tfloat e1_sum = 0.0;\n\tif(nh[0] == 0) { nh[0] = 1; }\n\tif(nh[0] > MAXSNH) { nh[0] = MAXSNH; }\n\tif(nh[0] <= nh[1]) { nh[1] = 0; }\n\tfor(int i = nh[1]; i < nh[0]; i++) {\n\t\te0_sum = e0_sum + rings[i][0];\n\t\te1_sum = e1_sum + rings[i][2]; }\n\treturn e0_sum / e1_sum; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//  PatternConfigData\n\tuint[48] SCD = uint[48] (\n\t\t3u, 9u, 12u, 12u, 13u, 1u, 8u, 10u, \n\t\t2u, 5u, 6u, 0u, 3u, 4u, 0u, 10u, \n\t\t2u, 4u, 6u, 5u, 0u, 1u, 7u, 14u, \n\t\t15u, 8u, 0u, 2u, 1u, 7u, 15u, 2u, \n\t\t8u, 8u, 3u, 5u, 1u, 9u, 11u, 8u, \n\t\t7u, 9u, 7u, 2u, 8u, 6u, 2u, 4u );\n\t\t\n\tuint[4] UBI = uint[4] (\n\t\t3381820956u, 1175436038u, 1788799421u, 696621573u );\n\t\t\n\tuint[48] UBV = uint[48] (\n\t\t1205682255u, 2045161636u, 547426430u, 1097105929u, \n\t\t652076278u, 1596149433u, 1213552863u, 3046415871u, \n\t\t730997574u, 2758318584u, 3645698113u, 985032273u, \n\t\t881500359u, 1494925827u, 1148408577u, 3334150709u, \n\t\t4048207263u, 2883048323u, 1114080772u, 499677996u, \n\t\t823602436u, 311811541u, 2035998513u, 507661684u, \n\t\t3709321582u, 65073978u, 642291892u, 776259900u, \n\t\t3598141797u, 3121169556u, 2446880420u, 1459516446u, \n\t\t2543447128u, 3790498444u, 418142298u, 1524730152u, \n\t\t344629599u, 1637917938u, 4122409199u, 4291737202u, \n\t\t320331416u, 1872345092u, 2286312465u, 1614695590u, \n\t\t2573465828u, 1980634842u, 1359788091u, 1191793090u );\n\t\t\n\tfloat SCL = 93.532906;\n\tfloat PZM = 0.950000;\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Setup\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tvec4\tfc \t\t= gl_FragCoord;\t\t\t\t//\tOrigin Pixel Coordinates\n\tfloat \tpsn\t\t= 65536.0;\t\t\t\t\t//\tTexture Precision\n\tfloat \tmnp \t= 1.0 / psn;\t\t\t\t//\tMinimum value of a precise step\n\tivec4\twsize\t= ivec4(iResolution.x,iResolution.y,1,0);\t//\tLayout Information\n\tivec4 \tminfo \t= ivec4(0,0,0,0);\t//\tMouse State Information\n\tfloat \tdiv_idx\t= floor((fc[0]*float(wsize[2]))/(float(wsize[0])))\n\t\t\t\t\t+ floor((fc[1]*float(wsize[2]))/(float(wsize[1])))*float(wsize[2]);\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tOrigin value references\n\tivec2\torigin  = ivec2(0,0);\n\tfloat \tref_r \t= gdv( origin, 0 );\n\tfloat \tref_g \t= gdv( origin, 1 );\n\tfloat \tref_b \t= gdv( origin, 2 );\n\n//\tOutput Values\n\tfloat \tres_r \t= ref_r;\n\tfloat \tres_g \t= ref_g;\n\tfloat \tres_b \t= ref_b;\n\n//\tNeighbourhood Rings\n\tvec3[MAXSNH] rings_r;\n\tfor(int i = 0; i < MAXSNH; i++) {\n\t\trings_r[i] = nhd( ivec2(i+1, i), origin, psn, 0.0, 0 ); }\n\n\tvec3[MAXSNH] rings_g;\n\tfor(int i = 0; i < MAXSNH; i++) {\n\t\trings_g[i] = nhd( ivec2(i+1, i), origin, psn, 0.0, 1 ); }\n\n\tvec3[MAXSNH] rings_b;\n\tfor(int i = 0; i < MAXSNH; i++) {\n\t\trings_b[i] = nhd( ivec2(i+1, i), origin, psn, 0.0, 2 ); }\n\n//\tParameters\n\tfloat s  = mnp * 16.0 *  64.0;\n\tfloat b  = mnp * 16.0 *  24.0;\n\tfloat n  = mnp * 16.0 *  16.0;\n\tfloat cy = mnp * 16.0 *  32.0 * (32.0 / sqrt(SCL));\n\tfloat li = mnp * 16.0 *  32.0;\t//\tdivide by 4 if used with cyclic\n\tfloat lu = mnp * 16.0 *  16.0;\n\n//\tGet Neighbourhood Values\n\tfloat[SCNH_COUNT_CHAN] nhv_r;\n\t\tnhv_r[0] = nh16_t_02(ivec2(SCD[0],  SCD[1]),  rings_r);\n\t\tnhv_r[1] = nh16_t_02(ivec2(SCD[2],  SCD[3]),  rings_r);\n\t\tnhv_r[2] = nh16_t_02(ivec2(SCD[4],  SCD[5]),  rings_r);\n\t\tnhv_r[3] = nh16_t_02(ivec2(SCD[6],  SCD[7]),  rings_r);\n\t\tnhv_r[4] = nh16_t_02(ivec2(SCD[8],  SCD[9]),  rings_g);\n\t\tnhv_r[5] = nh16_t_02(ivec2(SCD[10], SCD[11]), rings_g);\n\t\tnhv_r[6] = nh16_t_02(ivec2(SCD[12], SCD[13]), rings_b);\n\t\tnhv_r[7] = nh16_t_02(ivec2(SCD[14], SCD[15]), rings_b);\n\n\tfloat[SCNH_COUNT_CHAN] nhv_g;\n\t\tnhv_g[0] = nh16_t_02(ivec2(SCD[16], SCD[17]), rings_g);\n\t\tnhv_g[1] = nh16_t_02(ivec2(SCD[18], SCD[19]), rings_g);\n\t\tnhv_g[2] = nh16_t_02(ivec2(SCD[20], SCD[21]), rings_g);\n\t\tnhv_g[3] = nh16_t_02(ivec2(SCD[22], SCD[23]), rings_g);\n\t\tnhv_g[4] = nh16_t_02(ivec2(SCD[24], SCD[25]), rings_b);\n\t\tnhv_g[5] = nh16_t_02(ivec2(SCD[26], SCD[27]), rings_b);\n\t\tnhv_g[6] = nh16_t_02(ivec2(SCD[28], SCD[29]), rings_r);\n\t\tnhv_g[7] = nh16_t_02(ivec2(SCD[30], SCD[31]), rings_r);\n\n\tfloat[SCNH_COUNT_CHAN] nhv_b;\n\t\tnhv_b[0] = nh16_t_02(ivec2(SCD[32], SCD[33]), rings_b);\n\t\tnhv_b[1] = nh16_t_02(ivec2(SCD[34], SCD[35]), rings_b);\n\t\tnhv_b[2] = nh16_t_02(ivec2(SCD[36], SCD[37]), rings_b);\n\t\tnhv_b[3] = nh16_t_02(ivec2(SCD[38], SCD[39]), rings_b);\n\t\tnhv_b[4] = nh16_t_02(ivec2(SCD[40], SCD[41]), rings_r);\n\t\tnhv_b[5] = nh16_t_02(ivec2(SCD[42], SCD[43]), rings_r);\n\t\tnhv_b[6] = nh16_t_02(ivec2(SCD[44], SCD[46]), rings_g);\n\t\tnhv_b[7] = nh16_t_02(ivec2(SCD[46], SCD[47]), rings_g);\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUniform Buffer Unpacking\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tuint[48*4] \teval4;\n\tfor(int i = 0; i < 48; i++) {\n\t\tivec4 eval4_ivec = eval4_unpack(UBV[i]);\n\t\tfor(int j = 0; j < 4; j++) { eval4[i*4+j] = uint(eval4_ivec[j]); } }\n\n//\tAdjust eval4 values\n\tfloat[48*4] eval4_f;\n\tfloat\t\tfc_scale \t= 0.0;\n\tfloat\t\tub_scale \t= (float(wsize[2]) == 1.0) ? SCL * 0.5 : SCL;\n\tfloat \t\tzm_scale \t= PZM;\n\n\tfc_scale = ub_scale;\n\n\tfor(int i = 0; i < 48*4; i++) {\n\t\teval4_f[i] = (((1.0 / float(eval4[i])) * 1.5) - (0.3 * (1.0 / float(eval4[i])))) * fc_scale; }\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tTransition Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tfloat res_r_0  = ref_r;\n\tfloat res_r_1  = ref_r;\n\tfloat res_r_2  = ref_r;\n\tfloat res_r_3  = ref_r;\n\tfloat blr_r_0  = 0.0;\n\tfloat blr_r_1  = 0.0;\n\tfloat blr_r_2  = 0.0;\n\tfloat blr_r_3  = 0.0;\n\n\tfor(int i = 0; i < 2; i++) {\n\t\tblr_r_0 = blr_r_0 + nhv_r[i] * b;\n\t\tif(nhv_r[i] >= eval4_f[i*8+0] && nhv_r[i] <= eval4_f[i*8+1]) { res_r_0 = res_r_0 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+2] && nhv_r[i] <= eval4_f[i*8+3]) { res_r_0 = res_r_0 - s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+4] && nhv_r[i] <= eval4_f[i*8+5]) { res_r_0 = res_r_0 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+6] && nhv_r[i] <= eval4_f[i*8+7]) { res_r_0 = res_r_0 - s; } }\n\tres_r_0 = (res_r_0 + blr_r_0) / (1.0 + b * 2.0);\n\n\tfor(int i = 2; i < 4; i++) {\n\t\tblr_r_1 = blr_r_1 + nhv_r[i] * b;\n\t\tif(nhv_r[i] >= eval4_f[i*8+0] && nhv_r[i] <= eval4_f[i*8+1]) { res_r_1 = res_r_1 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+2] && nhv_r[i] <= eval4_f[i*8+3]) { res_r_1 = res_r_1 - s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+4] && nhv_r[i] <= eval4_f[i*8+5]) { res_r_1 = res_r_1 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+6] && nhv_r[i] <= eval4_f[i*8+7]) { res_r_1 = res_r_1 - s; } }\n\tres_r_1 = (res_r_1 + blr_r_1) / (1.0 + b * 2.0);\n\n\tfor(int i = 4; i < 6; i++) {\n\t\tblr_r_2 = blr_r_2 + nhv_r[i] * b;\n\t\tif(nhv_r[i] >= eval4_f[i*8+0] && nhv_r[i] <= eval4_f[i*8+1]) { res_r_2 = res_r_2 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+2] && nhv_r[i] <= eval4_f[i*8+3]) { res_r_2 = res_r_2 - s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+4] && nhv_r[i] <= eval4_f[i*8+5]) { res_r_2 = res_r_2 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+6] && nhv_r[i] <= eval4_f[i*8+7]) { res_r_2 = res_r_2 - s; } }\n\tres_r_2 = (res_r_2 + blr_r_2) / (1.0 + b * 2.0);\n\n\tfor(int i = 6; i < 8; i++) {\n\t\tblr_r_3 = blr_r_3 + nhv_r[i] * b;\n\t\tif(nhv_r[i] >= eval4_f[i*8+0] && nhv_r[i] <= eval4_f[i*8+1]) { res_r_3 = res_r_3 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+2] && nhv_r[i] <= eval4_f[i*8+3]) { res_r_3 = res_r_3 - s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+4] && nhv_r[i] <= eval4_f[i*8+5]) { res_r_3 = res_r_3 + s; }\n\t\tif(nhv_r[i] >= eval4_f[i*8+6] && nhv_r[i] <= eval4_f[i*8+7]) { res_r_3 = res_r_3 - s; } }\n\tres_r_3 = (res_r_3 + blr_r_3) / (1.0 + b * 2.0);\n\n\tfloat res_g_0  = ref_g;\n\tfloat res_g_1  = ref_g;\n\tfloat res_g_2  = ref_g;\n\tfloat res_g_3  = ref_g;\n\tfloat blr_g_0  = 0.0;\n\tfloat blr_g_1  = 0.0;\n\tfloat blr_g_2  = 0.0;\n\tfloat blr_g_3  = 0.0;\n\n\tfor(int i = 8; i < 10; i++) {\n\t\tblr_g_0 = blr_g_0 + nhv_g[i-8] * b;\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+0] && nhv_g[i-8] <= eval4_f[i*8+1]) { res_g_0 = res_g_0 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+2] && nhv_g[i-8] <= eval4_f[i*8+3]) { res_g_0 = res_g_0 - s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+4] && nhv_g[i-8] <= eval4_f[i*8+5]) { res_g_0 = res_g_0 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+6] && nhv_g[i-8] <= eval4_f[i*8+7]) { res_g_0 = res_g_0 - s; } }\n\tres_g_0 = (res_g_0 + blr_g_0) / (1.0 + b * 2.0);\n\n\tfor(int i = 10; i < 12; i++) {\n\t\tblr_g_1 = blr_g_1 + nhv_g[i-8] * b;\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+0] && nhv_g[i-8] <= eval4_f[i*8+1]) { res_g_1 = res_g_1 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+2] && nhv_g[i-8] <= eval4_f[i*8+3]) { res_g_1 = res_g_1 - s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+4] && nhv_g[i-8] <= eval4_f[i*8+5]) { res_g_1 = res_g_1 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+6] && nhv_g[i-8] <= eval4_f[i*8+7]) { res_g_1 = res_g_1 - s; } }\n\tres_g_1 = (res_g_1 + blr_g_1) / (1.0 + b * 2.0);\n\n\tfor(int i = 12; i < 14; i++) {\n\t\tblr_g_2 = blr_g_2 + nhv_g[i-8] * b;\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+0] && nhv_g[i-8] <= eval4_f[i*8+1]) { res_g_2 = res_g_2 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+2] && nhv_g[i-8] <= eval4_f[i*8+3]) { res_g_2 = res_g_2 - s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+4] && nhv_g[i-8] <= eval4_f[i*8+5]) { res_g_2 = res_g_2 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+6] && nhv_g[i-8] <= eval4_f[i*8+7]) { res_g_2 = res_g_2 - s; } }\n\tres_g_2 = (res_g_2 + blr_g_2) / (1.0 + b * 2.0);\n\n\tfor(int i = 14; i < 16; i++) {\n\t\tblr_g_3 = blr_g_3 + nhv_g[i-8] * b;\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+0] && nhv_g[i-8] <= eval4_f[i*8+1]) { res_g_3 = res_g_3 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+2] && nhv_g[i-8] <= eval4_f[i*8+3]) { res_g_3 = res_g_3 - s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+4] && nhv_g[i-8] <= eval4_f[i*8+5]) { res_g_3 = res_g_3 + s; }\n\t\tif(nhv_g[i-8] >= eval4_f[i*8+6] && nhv_g[i-8] <= eval4_f[i*8+7]) { res_g_3 = res_g_3 - s; } }\n\tres_g_3 = (res_g_3 + blr_g_3) / (1.0 + b * 2.0);\n\n\tfloat res_b_0  = ref_b;\n\tfloat res_b_1  = ref_b;\n\tfloat res_b_2  = ref_b;\n\tfloat res_b_3  = ref_b;\n\tfloat blr_b_0  = 0.0;\n\tfloat blr_b_1  = 0.0;\n\tfloat blr_b_2  = 0.0;\n\tfloat blr_b_3  = 0.0;\n\n\tfor(int i = 16; i < 18; i++) {\n\t\tblr_b_0 = blr_b_0 + nhv_b[i-16] * b;\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+0] && nhv_b[i-16] <= eval4_f[i*8+1]) { res_b_0 = res_b_0 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+2] && nhv_b[i-16] <= eval4_f[i*8+3]) { res_b_0 = res_b_0 - s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+4] && nhv_b[i-16] <= eval4_f[i*8+5]) { res_b_0 = res_b_0 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+6] && nhv_b[i-16] <= eval4_f[i*8+7]) { res_b_0 = res_b_0 - s; } }\n\tres_b_0 = (res_b_0 + blr_b_0) / (1.0 + b * 2.0);\n\n\tfor(int i = 18; i < 20; i++) {\n\t\tblr_b_1 = blr_b_1 + nhv_b[i-16] * b;\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+0] && nhv_b[i-16] <= eval4_f[i*8+1]) { res_b_1 = res_b_1 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+2] && nhv_b[i-16] <= eval4_f[i*8+3]) { res_b_1 = res_b_1 - s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+4] && nhv_b[i-16] <= eval4_f[i*8+5]) { res_b_1 = res_b_1 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+6] && nhv_b[i-16] <= eval4_f[i*8+7]) { res_b_1 = res_b_1 - s; } }\n\tres_b_1 = (res_b_1 + blr_b_1) / (1.0 + b * 2.0);\n\n\tfor(int i = 20; i < 22; i++) {\n\t\tblr_b_2 = blr_b_2 + nhv_b[i-16] * b;\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+0] && nhv_b[i-16] <= eval4_f[i*8+1]) { res_b_2 = res_b_2 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+2] && nhv_b[i-16] <= eval4_f[i*8+3]) { res_b_2 = res_b_2 - s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+4] && nhv_b[i-16] <= eval4_f[i*8+5]) { res_b_2 = res_b_2 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+6] && nhv_b[i-16] <= eval4_f[i*8+7]) { res_b_2 = res_b_2 - s; } }\n\tres_b_2 = (res_b_2 + blr_b_2) / (1.0 + b * 2.0);\n\n\tfor(int i = 22; i < 24; i++) {\n\t\tblr_b_3 = blr_b_3 + nhv_b[i-16] * b;\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+0] && nhv_b[i-16] <= eval4_f[i*8+1]) { res_b_3 = res_b_3 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+2] && nhv_b[i-16] <= eval4_f[i*8+3]) { res_b_3 = res_b_3 - s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+4] && nhv_b[i-16] <= eval4_f[i*8+5]) { res_b_3 = res_b_3 + s; }\n\t\tif(nhv_b[i-16] >= eval4_f[i*8+6] && nhv_b[i-16] <= eval4_f[i*8+7]) { res_b_3 = res_b_3 - s; } }\n\tres_b_3 = (res_b_3 + blr_b_3) / (1.0 + b * 2.0);\n\n\tint vir = 0;\n\tfloat viblur_r = 0.0;\n\tfloat vari_0r = abs(ref_r - res_r_0);\n\tfloat vari_1r = abs(ref_r - res_r_1);\n\tfloat vari_2r = abs(ref_r - res_r_2);\n\tfloat vari_3r = abs(ref_r - res_r_3);\n\tif(vari_0r < vari_1r) { vari_0r = vari_1r; vir = 1; }\n\tif(vari_0r < vari_2r) { vari_0r = vari_2r; vir = 2; }\n\tif(vari_0r < vari_3r) { vari_0r = vari_3r; vir = 3; }\n\tif(vir == 0) { res_r = res_r_0; viblur_r = blr_r_0; }\n\tif(vir == 1) { res_r = res_r_1; viblur_r = blr_r_1; }\n\tif(vir == 2) { res_r = res_r_2; viblur_r = blr_r_2; }\n\tif(vir == 3) { res_r = res_r_3; viblur_r = blr_r_3; }\n\n\tint vig = 0;\n\tfloat viblur_g = 0.0;\n\tfloat vari_0g = abs(ref_g - res_g_0);\n\tfloat vari_1g = abs(ref_g - res_g_1);\n\tfloat vari_2g = abs(ref_g - res_g_2);\n\tfloat vari_3g = abs(ref_g - res_g_3);\n\tif(vari_0g < vari_1g) { vari_0g = vari_1g; vig = 1; }\n\tif(vari_0g < vari_2g) { vari_0g = vari_2g; vig = 2; }\n\tif(vari_0g < vari_3g) { vari_0g = vari_3g; vig = 3; }\n\tif(vig == 0) { res_g = res_g_0; viblur_g = blr_g_0; }\n\tif(vig == 1) { res_g = res_g_1; viblur_g = blr_g_1; }\n\tif(vig == 2) { res_g = res_g_2; viblur_g = blr_g_2; }\n\tif(vig == 3) { res_g = res_g_3; viblur_g = blr_g_3; }\n\n\tint vib = 0;\n\tfloat viblur_b = 0.0;\n\tfloat vari_0b = abs(ref_b - res_b_0);\n\tfloat vari_1b = abs(ref_b - res_b_1);\n\tfloat vari_2b = abs(ref_b - res_b_2);\n\tfloat vari_3b = abs(ref_b - res_b_3);\n\tif(vari_0b < vari_1b) { vari_0b = vari_1b; vib = 1; }\n\tif(vari_0b < vari_2b) { vari_0b = vari_2b; vib = 2; }\n\tif(vari_0b < vari_3b) { vari_0b = vari_3b; vib = 3; }\n\tif(vib == 0) { res_b = res_b_0; viblur_b = blr_b_0; }\n\tif(vib == 1) { res_b = res_b_1; viblur_b = blr_b_1; }\n\tif(vib == 2) { res_b = res_b_2; viblur_b = blr_b_2; }\n\tif(vib == 3) { res_b = res_b_3; viblur_b = blr_b_3; }\n\n\tres_r = res_r - n;\n\tres_g = res_g - n;\n\tres_b = res_b - n;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tChannel Communication\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tCyclic\n/*\tfloat[6] cyw;\n\t\tcyw[0] = cy * -1.0;\n\t\tcyw[1] = cy *  1.0;\n\t\tcyw[2] = cy * -1.0;\n\t\tcyw[3] = cy *  1.0;\n\t\tcyw[4] = cy * -1.0;\n\t\tcyw[5] = cy *  1.0;\n\t\tfloat\tcyc_r = ( res_r * 1.0 \t\t+ res_g * cyw[0] \t+ res_b * cyw[1] ) / (1.0 + (cyw[0]+cyw[1]));\n\t\tfloat\tcyc_g = ( res_r * cyw[3]\t+ res_g * 1.0 \t\t+ res_b * cyw[2] ) / (1.0 + (cyw[2]+cyw[3]));\n\t\tfloat\tcyc_b = ( res_r * cyw[4]\t+ res_g * cyw[5] \t+ res_b * 1.0\t ) / (1.0 + (cyw[4]+cyw[5]));\n\tres_r = cyc_r; res_g = cyc_g; res_b = cyc_b;\n/**/\n\n//\tInterpolate\n/*\tfloat dt_rb = viblur_r / (b * 2.0);\n\tfloat dt_gb = viblur_g / (b * 2.0);\n\tfloat dt_bb = viblur_b / (b * 2.0);\n\tfloat\tinp_r = (res_r \t* 1.0 \t+ dt_gb *  li \t+ dt_bb *  li\t) / ( 1.0 + li * 2.0 );\n\tfloat\tinp_g = (dt_rb \t*  li \t+ res_g * 1.0 \t+ dt_bb\t*  li\t) / ( 1.0 + li * 2.0 );\n\tfloat\tinp_b = (dt_rb \t*  li\t+ dt_gb *  li \t+ res_b * 1.0\t) / ( 1.0 + li * 2.0 );\n\tres_r = inp_r;\n\tres_g = inp_g;\n\tres_b = inp_b;\n/**/\n\n//\tUnterpolate\n/*\tfloat\tunp_r = (res_r \t  \t* 1.0 \t+ res_g \t* -lu \t+ res_b \t* -lu\t) / ( 1.0 - lu * 2.0 );\n\tfloat\tunp_g = (res_r \t\t* -lu \t+ res_g \t* 1.0 \t+ res_b \t* -lu\t) / ( 1.0 - lu * 2.0 );\n\tfloat\tunp_b = (res_r \t\t* -lu\t+ res_g \t* -lu \t+ res_b \t* 1.0\t) / ( 1.0 - lu * 2.0 );\n\tres_r = unp_r;\n\tres_g = unp_g;\n\tres_b = unp_b;\n/**/\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 32.0) {\n        res_r = round(mod(float(iFrame),3.0));\n        res_g = round(mod(float(iFrame),5.0));\n        res_b = round(mod(float(iFrame),7.0)); }\n    if (iFrame == 0) { res_r = reseed(0); res_g = reseed(1); res_b = reseed(2); }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsj3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1043, 1043, 1100, 1150, 1280]], "test": "untested"}
{"id": "ssSSRR", "name": "Dancing squares animation", "author": "demicuz", "description": "Just trying to recreate a beautiful animation I found on Twitter: [url]https://twitter.com/loackme_/status/1385336764865384448[/url]\n\nI don't know yet how to properly animate 2D transformations, so the code is a mess.", "tags": ["2d", "animation", "aberration", "minimalistic"], "likes": 15, "viewed": 440, "published": 3, "date": "1619527976", "time_retrieved": "2024-07-30T19:23:06.402479", "image_code": "// Inspired by: https://twitter.com/loackme_/status/1385336764865384448\n\n#define ABERRATION\n\n#define BLUR 2. / min(iResolution.x, iResolution.y)\n#define SS(edge, x) smoothstep(-BLUR, BLUR, x - edge)\n\n#define PI 3.14159265359\n#define iR(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define iS(s) mat2(1./s, .0, .0, 1./s)\n\nfloat ease(float x) {\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat square(vec2 p, float size) {\n    return SS(abs(p.x), size) * SS(abs(p.y), size);\n}\n\nfloat hollow_square(vec2 p, float max_size, float border_width) {\n    return square(p, max_size) - square(p, max_size - border_width);\n}\n\nfloat square_anim_transform(vec2 p, float initial_scale, float angle,\n                            float scale, vec2 offset, float t) {\n    angle *= t;\n    scale = mix(initial_scale, scale, t);\n    offset *= t;\n    p = iR(angle) * iS(scale) * (p - offset);\n    \n    return hollow_square(p, .5, .03 / scale);\n}\n\nfloat full_animation(vec2 p, float t) {\n    // Initial positions and scales\n    vec2 p1 = p;\n    float s1 = .8;\n    vec2 p2 = p - vec2(-.2, .2);\n    float s2 = .19;\n    vec2 p3 = iR(PI*.25) * (p - vec2(.09, -.09));\n    float s3 = .36;\n    \n    float square_color = square_anim_transform(p1, s1, PI/2., s2, vec2(-.2, .2), t);\n    square_color += square_anim_transform(p2, s2, PI/4., s3, vec2(.29, -.29), t);\n    square_color += square_anim_transform(p3, s3, -3.*PI/4., s1, iR(PI*.25)*vec2(-.09, .09), t);\n    \n    return clamp(square_color, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord / iResolution.xy - vec2(.5);\n    p.x *= iResolution.x / iResolution.y;\n    \n    //vec2 m = iMouse.xy/iResolution.xy;\n    //float t = m.x;\n    \n    float t = iTime;\n    float t_speed = 1.;\n    \n    #ifdef ABERRATION\n    float t_offset = .015;\n    float t0 = ease(fract(t * t_speed));\n    float t1 = ease(fract((t - t_offset) * t_speed));\n    float t2 = ease(fract((t - 2.*t_offset) * t_speed));\n    vec3 color = vec3(full_animation(p, t0),\n                      full_animation(p, t1),\n                      full_animation(p, t2));\n    #else\n    vec3 color = vec3(full_animation(p, ease(fract(t * t_speed))));\n    #endif\n    \n    \n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSSRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 317, 338, 338, 411], [413, 413, 447, 447, 501], [503, 503, 568, 568, 639], [641, 641, 775, 775, 949], [951, 951, 990, 1026, 1503], [1505, 1505, 1560, 1560, 2248]], "test": "untested"}
{"id": "fsSSRz", "name": " - Test Glow2", "author": "totetmatt", "description": "Practicing glow stuff.\n\nThanks to FMS_Cat youyube video \nhttps://www.youtube.com/watch?v=5XPsUUcTElc ", "tags": ["glow", "ghost"], "likes": 9, "viewed": 370, "published": 3, "date": "1619522311", "time_retrieved": "2024-07-30T19:23:07.296089", "image_code": "#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,vec3(0.)))+min(max(q.x,max(q.y,q.z)),.0);\n  }\nfloat sdf(vec3 p){\n  vec3 pp=p;\n  p.xz *=rot(fGlobalTime*.3);\n  //p.xy*=rot(fGlobalTime*.2);\n  vec3 id = floor(p);\n\n  p = abs(p)-2.5;\n  p.xz *=rot(.785);\n  for(float i=0.;i<2.;i++){\n      p.xy = abs(p.xy)-vec2(.55,.75)*2.5;\n      p.xy *=1.2;\n      //p.xy = p.x <p.y ? p.xy:p.yx;\n      p.xz = p.x >p.z ? p.xz:p.zx;\n      //p.yz = p.y <p.z ? p.yz:p.zy;\n      p.xy *=rot(0.785*i);\n      \n  } \n  p*=.5;\n  //return length(abs(pp)-1.5)-1.;\n  \n  vec3 ppp= pp;\n  ppp.xz *=rot(.785*.4*clamp(sin(fGlobalTime*4.),-.5,.5));\n  ppp.yz *=rot(.785*.4*clamp(cos(fGlobalTime*4.),-.5,.5));\n  ppp.xy *=rot(3.1415*clamp(-cos(fGlobalTime*4.),-.5,.5) - 3.1415*clamp(sin(fGlobalTime*4.),-.5,.5));\n  ppp.z = fract(ppp.z);\n  ppp = abs(ppp)-.55;\n  //ppp = abs(ppp)-.25;\n\n  float zz = box(ppp,vec3(.1,.1,4.));\n  float q = length(pp)-2.1;\n  \n  q = min(q,zz);\n  return min(q,length(p)-(.5+sin(p.x*20.+fGlobalTime*5.)*.02-cos(p.z*25.+fGlobalTime*5.)*.03));\n}\n\nvec2 nv=vec2(-.001,.001);\n#define q(s) s*sdf(p+s)\nvec3 norm(vec3 p){\n  return normalize(q(nv.xyy)+\n                   q(nv.yxy)+\n                   q(nv.yyx)+\n                   q(nv.xxx)\n  );\n}\nvec3 pal(float t){\n  return vec3(.5)+vec3(.5)*cos(6.28*(1.*t+vec3(.0,.4,.6)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float accum=0.;\n  vec3 ro=vec3(0.,0.,-10.),rd=normalize(vec3(uv,1.)),rp=ro;\n  vec3 light= vec3(1.,2.,-3.);\n  vec3 col = vec3(length(uv)*.5);\n\tbool st = false;\n  for(float i=0.;i<=69.;i++){\n    float d = sdf(rp);\n    accum += exp(30.*-abs(d))/69.;\n    d = max(0.001+sin(fGlobalTime*4.+atan(rp.x,rp.z)*10.-length(uv)*8.)*.1+.1,abs(d));\n   \n    rp+=d*rd;\n    \n   \n  }\n   \n  col += accum*vec3(1.5,1.7,1.9);\n  \n  float qq = step(.5,sin(fGlobalTime)*.5+.5)*.3;\n  col = mix(vec3(.01),pal( .1+qq+accum),col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 44, 44, 91], [92, 92, 117, 117, 210], [211, 211, 229, 229, 1138], [1190, 1190, 1208, 1208, 1334], [1335, 1335, 1353, 1353, 1415], [1416, 1416, 1473, 1523, 2146]], "test": "untested"}
{"id": "sdfXRX", "name": "Color Volume", "author": "Txoka", "description": "Color cube (Use mouse to move)", "tags": ["3d", "volumetric", "transparent"], "likes": 6, "viewed": 368, "published": 3, "date": "1619515958", "time_retrieved": "2024-07-30T19:23:08.162772", "image_code": "vec3 volume(vec3 p,vec3 rd){\n    if(p.x*p.x>1.)return vec3(0);\n    if(p.y*p.y>1.)return vec3(0);\n    if(p.z*p.z>1.)return vec3(0);\n    \n    vec3 col=vec3(0);\n    col.r=smoothstep(-1.,1.,p.x);\n    col.g=smoothstep(-1.,1.,p.y);\n    col.b=smoothstep(-1.,1.,p.z);\n    //col.r+=0.4/dot2(p-vec3(0.5,0,0));\n    //col.g+=0.4/dot2(p-vec3(0,0.5,0));\n    //col.b+=0.4/dot2(p-vec3(0,0,0.5));\n    \n    return col;\n}\n\nvec3 trace(vec3 ro,vec3 rd){\n    vec3 col=vec3(0);\n    for(int i=0;i<512;i++){\n        ro+=rd*dx;\n        col+=pow(volume(ro,rd)*I,vec3(gamma));\n    }\n    return pow(col,vec3(1./gamma));\n}\n\nvoid mainImage(out vec4 O,in vec2 C){\n    vec3 uv = vec3((C*2.-iResolution.xy)/iResolution.y,-2);\n    \n    vec2 m=(iMouse.xy*2.-iResolution.xy)/iResolution.xy;\n\n    if(iMouse.z<=0.)m=vec2(-iTime/3.,0.4);\n\n    m*=vec2(1,0.5)*pi;\n    \n\n    vec3 ro=vec3(0,0,-3);\n    \n    \n    ro.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    ro.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    uv.yz*=mat2(cos(m.y),-sin(m.y),sin(m.y),cos(m.y));\n    uv.xz*=mat2(cos(m.x),-sin(m.x),sin(m.x),cos(m.x));\n    \n    vec3 rd=normalize(uv-ro);\n    \n    vec3 col=trace(uv,rd);\n    \n    O=vec4(col,1.);\n}", "image_inputs": [], "common_code": "const float gamma=2.2;\nconst float dx=0.01;\nconst float I=0.5*sqrt(dx);\n\nfloat dot2(vec2 a){return dot(a,a);}\nfloat dot2(vec3 a){return dot(a,a);}\n\nfloat pi=atan(1.)*4.;", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 402], [404, 404, 432, 432, 592], [594, 594, 631, 631, 1177]], "test": "untested"}
{"id": "fdSSRz", "name": "Uncontained Fracture", "author": "Tater", "description": "I made this in 25 minutes, inspired by shader showdown things. There are many artifacts but I am claiming them as features :D", "tags": ["raymarching"], "likes": 15, "viewed": 494, "published": 3, "date": "1619513897", "time_retrieved": "2024-07-30T19:23:09.037433", "image_code": "#define STEPS 164.0\n#define MDIST 300.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 glow = vec3(0);\nfloat box(vec3 p, vec3 s){\n    vec3 d = abs(p)-s;\n    return max(d.x,max(d.y,d.z));\n}\n\nvec2 map(vec3 p){\n    vec3 po = p;\n    //p.xy*=rot(iTime);\n    //p.yz*=rot(iTime);\n    //p.zx*=rot(iTime);\n    vec2 a = vec2(box(p,vec3(0.3)),1.0);\n    \n    glow+=vec3(1.000,0.067,0.090)*0.01/(0.01+a.x*a.x);\n    \n    \n    //a = (a.x>b.x)?b:a;\n    vec2 b = vec2(box(p-vec3(1,0,0),vec3(0.5)),2.0);\n    a = (a.x>b.x)?b:a;\n    b = vec2(box(p-vec3(-1,0,0),vec3(0.3)),3.0);\n    a = (a.x>b.x)?b:a;\n    \n    //a.x = min(a.x,b.x);\n    return a;\n}\n\nvec2 map2(vec3 p){\n    vec3 po = p;\n    float t = iTime;\n\n    for(float i=0.0;i<3.0;i++){\n        p=abs(p)-.3;\n        p.xy*=rot(0.5+t);\n        p.xz*=rot(0.5+t);\n    }\n    vec2 a = map(p);\n    a.x = box(po,vec3(1.5));\n    a.x = min(a.x,length(po)-2.0);\n    //vec2 b = vec2(po.y+1.8,2.0);\n    //a = (a.x>b.x)?b:a;\n    \n    return a;\n}\nvec2 map3(vec3 p){\n    vec3 po = p;\n    float t = iTime;\n    \n    vec2 a = map2(p);\n    \n    for(float i=0.0;i<9.0;i++){\n        p=abs(p)-vec3(2.3*i,1,1);\n        p.xy*=rot(pi/4.0*floor(t*3.0));\n        p.xz*=rot(pi/7.0*floor(t*3.0));\n        a = min(a,map2(p*0.5));\n    }\n        \n    //a.x = box(po,vec3(1.5));\n    //a.x = min(a.x,length(po)-2.0);\n    vec2 b = vec2(po.y+1.8,2.0);\n    a = (a.x>b.x)?b:a;\n    \n    po=mod(po,80.0)-40.0;\n    a.x = min(a.x,length(po.xz)-2.0);\n    a.x = min(a.x,length(po.zy)-2.0);\n    a.x = min(a.x,length(po.xy)-2.0);\n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.0);\n    return normalize(map3(p).x-vec3(\n    map3(p-e.xyy).x,\n    map3(p-e.yxy).x,\n    map3(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,30,-90);\n    vec3 rd = normalize(vec3(uv,1.0));\n    rd.zy*=rot(0.3);\n    ro.xz*=rot(iTime);\n    rd.xz*=rot(iTime);\n    vec3 p = ro;\n    float dO = 0.0;\n    float shad = 0.0;\n    float bnc = 0.0;\n    float dist = 0.0;\n    float dO2;\n    for(float i = 0.0; i<STEPS; i++){\n        p = ro + rd * dO;\n        vec2 d = map3(p);\n        dO += d.x;\n        dO2+= d.x;\n        if(dO2>MDIST || d.x < 0.01) {\n            shad = (i)/(STEPS);\n            if(bnc == 0.0)dist=dO;\n            if(bnc== 1.0||d.y!=2.0) {shad=i/STEPS; break;}\n            ro += rd*dO;\n            vec3 n = norm(ro);\n    \n            rd = reflect(rd,n);\n            ro += n*0.1;\n            dO = 0.0;\n            i=0.0;\n            bnc++;\n            \n        }\n    }\n    col = vec3(shad);\n    //col += 0.5*mix(vec3(0.176,0.259,1.000),vec3(0.722,0.067,1.000),sin(p.z*0.01));\n    col+=glow*0.2;\n    col=mix(col,vec3(0),(dist/MDIST));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 162, 162, 221], [223, 223, 240, 240, 660], [662, 662, 680, 680, 996], [997, 997, 1015, 1015, 1563], [1565, 1565, 1583, 1583, 1716], [1718, 1718, 1775, 1775, 2814]], "test": "untested"}
{"id": "fdBSRz", "name": "Fly The Mars Copter", "author": "dr2", "description": "Interactive flight on a nearby planet.", "tags": ["game", "interactive", "dynamics", "flight", "nasa"], "likes": 12, "viewed": 359, "published": 3, "date": "1619513423", "time_retrieved": "2024-07-30T19:23:10.051722", "image_code": "// \"Fly The Mars Copter\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Mouse controlled flight (drag small ring), automatic landing.\n Inset views are from forward and downward wide-angle cameras.\n Copter coordinates and altitude shown; grid and red/green spots\n are navigation aids.\n*/\n\n#define USE_BND_SPHERE 0  // (=0/1) set = 1 for slight speedup (visual promblems for some?)\n\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm2e (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\n#define VAR_ZERO min (iFrame, 0)\n\nmat3 vuMat, flMat;\nvec3 qHit, flPos, sunDir;\nvec2 hipPos;\nfloat tCur, dstFar, flDir, legLenU, legLenD, aU, aD, pPitch, pRot, heliScl, grndScl;\nint idObj, idVu;\nbool flHide, isSh;\nconst int idBase = 1, idLeg = 2, idAxl = 3, idProp = 4, idCamV = 5, idCamH = 6;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndDf (vec3 p)\n{\n  vec3 q;\n  float d, h, a, r, s, f;\n  q = p / grndScl;\n  r = length (q.xz);\n  d = p.y;\n  if (r > 0.) {\n    a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n    s = sqrt (r) / (2. * pi);\n    f = 32.;\n    h = 2.5 * s * mix (Fbm2e (f * vec2 (s, a + 1.)), Fbm2e (f * vec2 (s, a)), a);\n    d = max (r - 20., q.y - mix (s, h, smoothstep (1.4, 2.2, r)) * smoothstep (1.4, 2.6, r));\n  }\n  return grndScl * d;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.001, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (GrndDf (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\n#define SQ(x) ((x) * (x))\n\n#define SQ(x) ((x) * (x))\n#define ACOS_CLAMP(c) acos (clamp ((c), -1., 1.))\n\nvoid SetConf ()\n{\n  float legHtMin, legHtMax, toePos, d, h;\n  legLenU = 2.;\n  legLenD = 3.;\n  hipPos.x = 1.5;\n  toePos = 4.;\n  legHtMin = 0.45 * (legLenU + legLenD);\n  legHtMax = sqrt (SQ (legLenU + legLenD) - SQ (toePos - hipPos.x));\n  hipPos.y = flPos.y / heliScl + legHtMin;\n  h = min (hipPos.y, legHtMax);\n  d = sqrt (SQ (h) + SQ (toePos - hipPos.x));\n  aU = ACOS_CLAMP ((SQ (legLenU) - SQ (legLenD) + SQ (d)) / (2. * legLenU * d)) + acos (h / d) - 0.5 * pi;\n  aD = aU + ACOS_CLAMP ((SQ (legLenU) + SQ (legLenD) - SQ (d)) / (2. * legLenU * legLenD)) + pi;\n  d = hipPos.y - (legLenU + legLenD);\n  if (d > 0.) {\n    d = 0.13 * pi * smoothstep (0., 5., d);\n    aU -= d;\n    aD -= d;\n  }\n}\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 fb;\n  float d;\n  p = flMat * (p - vec3 (flPos.xz, hipPos.y * heliScl).xzy);\n  dMin /= heliScl;\n  p /= heliScl;\n  p.y += hipPos.y;\n  q = p;\n  q.y -= hipPos.y;\n#if USE_BND_SPHERE > 0\n  if (! isSh) d = length (q) - 6.3;\n  if (isSh || d < 0.1) {\n#else\n  if (true) {\n#endif\n    fb = normalize (vec2 (1.2, 1.));\n    for (float k = -1. + float (VAR_ZERO); k <= 1.; k += 2.) {\n      q = p;\n      q.xz = Rot2D (q.xz, k * pRot);\n      q.y -= hipPos.y + 2.4 + 1.2 * k;\n      d = PrRoundCylDf (q.xzy, 0.2 - 0.05 * k, 0.01, 1.2);\n      DMINQ (idAxl);\n      q.y -= 1.;\n      d = min (max (PrRoundCylDf (vec3 (q.x, Rot2D (q.yz, k * pPitch)).xzy, 3., 0.02, 0.01),\n         dot (vec2 (q.x, abs (q.z)), fb)),\n         max (PrRoundCylDf (vec3 (q.x, Rot2D (q.yz, - k * pPitch)).xzy, 3., 0.02, 0.01),\n         dot (vec2 (- q.x, abs (q.z)), fb)));\n      DMINQ (idProp);\n    }\n    q = p;\n    q.y -= hipPos.y + 0.1;\n    d = PrRoundCylDf (q.xzy, hipPos.x, 0.05, 0.2);\n    q.y -= 0.4;\n    d = min (d, PrRoundCylDf (q.xzy, 0.35 * hipPos.x, 0.05, 0.15));\n    DMINQ (idBase);\n    q = p;\n    q.y -= hipPos.y - 0.2;\n    d = PrCapsDf (q.xzy, 0.35 * hipPos.x, 0.1);\n    DMINQ (idCamV);\n    q.yz -= vec2 (0.2, hipPos.x);\n    d = PrCapsDf (q, 0.15 * hipPos.x, 0.2);\n    DMINQ (idCamH);\n    q = p;\n    q.xz = Rot2D (q.xz, pi / 6.);\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi)) + 0.5) / 6.);\n    q.xy = Rot2D (q.xy - hipPos * vec2 (-1., 1.), aU);\n    q.x += 0.5 * legLenU;\n    d = PrCapsDf (q.yzx, 0.1 * (0.8 + 0.2 * q.x / (0.5 * legLenU)) / 0.6, 0.5 * legLenU);\n    DMINQ (idLeg);\n    q.x += 0.5 * legLenU;\n    q.xy = Rot2D (q.xy, aD - aU);\n    q.x += 0.5 * legLenD;\n    d = PrCapsDf (q.yzx, 0.1 * (0.9 + 0.1 * q.x / (0.5 * legLenD)), 0.5 * legLenD);\n    DMINQ (idLeg);\n    q.x += 0.5 * legLenD;\n    q.xy = Rot2D (q.xy, 0.5 * pi - aD);\n    q.x -= -0.02;\n    d = PrRoundCylDf (q.yzx, 0.3, 0.02, 0.05);\n    DMINQ (idLeg);\n  } else dMin = min (dMin, d);\n  return heliScl * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  dMin = dstFar;\n  if (! flHide) dMin = FlyerDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 2. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 GrndCol (vec3 ro, vec3 vn, float dstGrnd)\n{\n  vec3 col;\n  col = vec3 (0.7, 0.55, 0.3);\n  if (ro.y > -0.1) {\n    col *= 1. - 0.3 * Fbm2 (4. * ro.xz);\n    col = mix (col, 0.8 * col, smoothstep (0.2, 0.7, 1. - vn.y));\n    col = mix (col, 1.1 * col, smoothstep (0.6, 0.9, ro.y / grndScl +\n       0.2 * sin (32. * atan (ro.z, - ro.x))));\n  } else {\n    col *= 1. - 0.3 * (1. - 0.7 * smoothstep (0.2, 0.4, dstGrnd / (3. * grndScl))) *\n       Fbm2 (4. * ro.xz);\n  }\n  return col;\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, fcBlk;\n  vec2 qBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 ror, col, vn, roo, rdo, g;\n  vec2 w, wd;\n  float dstObj, dstGrnd, sh, r, s, h, bsFac;\n  flHide = (idVu > 0);\n  roo = ro;\n  rdo = rd;\n  isSh = false;\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstGrnd, dstObj) < dstFar) {\n    if (dstGrnd < dstObj) {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      s = 1. - smoothstep (0.3, 0.6, dstGrnd / (3. * grndScl));\n      h = s * Fbm2 (ro.xz);\n      vn = VaryNf (2. * ro, vn, 2. * s * (1. - 0.8 * smoothstep (0.5, 0.7, h)));\n      col = GrndCol (ro, vn, dstGrnd);\n      col *= 1. + 0.2 * smoothstep (0.5, 0.7, h);\n      w = smoothstep (0.05, 0.1, mod (ro.xz, 5.));\n      r = length (ro.xz);\n      col *= 1. - 0.15 * (1. - w.x * w.y) * (1. - smoothstep (0.2, 0.3, r / (3. * grndScl)));\n      col = mix (vec3 (1., 1., 0.), col, smoothstep (0.05, 0.1, abs (r - 2.)));\n      col = mix (vec3 (1., 1., 0.), col, smoothstep (0.2, 0.3, r));\n      w = flPos.xz - ro.xz;\n      wd = (length (flPos.xz) > 0.) ? 0.5 * normalize (flPos.xz) : vec2 (0.);\n      col = mix (vec3 (1., 0.2, 0.2), col, 0.3 + 0.7 * smoothstep (0.15, 0.17, length (w + wd)));\n      col = mix (vec3 (0.2, 1., 0.2), col, 0.3 + 0.7 * smoothstep (0.15, 0.17, length (w - wd)));\n      col4 = vec4 (col, 0.05);\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == idBase) {\n        col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.02,\n           abs (length (qHit.xz) - 1.1) - 0.1));\n      } else if (idObj == idLeg) {\n        col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * sin (8. * pi * qHit.x));\n      } else if (idObj == idAxl) {\n        col4 = vec4 (0.8, 1., 0.8, 0.2) * (1. - 0.2 * sin (4. * atan (qHit.z, qHit.x)));\n      } else if (idObj == idProp) {\n        col4 = vec4 (1., 0.9, 0.8, 0.2) * (0.9 + 0.1 * sin (8. * pi * length (qHit.xz)));\n      } else if (idObj == idCamV) {\n        col4 = vec4 (0.1, 0.1, 0.1, 0.2);\n      } else if (idObj == idCamH) {\n        col4 = mix (vec4 (0.1, 0.1, 0.1, 0.2), vec4 (0.6 + 0.4 * sin (4. * pi * tCur), 0., 0., -1.),\n           step (length (qHit.xy), 0.1));\n      }\n    }\n    if (col4.a >= 0.) {\n      flHide = false;\n      isSh = true;\n      sh = ObjSShadow (ro, sunDir);\n      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    } else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n  } else {\n    col = vec3 (0.3, 0.2, 0.1) + StarPat (rd, 8.) +\n       vec3 (0.1, 0.1, 1.) * step (1. - dot (rd, normalize (vec3 (0., 0.12, 1.))), 1e-5); \n  }\n  if (idVu == 0) {\n    roo -= flPos + vec3 (0., 2.8, 0.);\n    s = length (roo) / 15.;\n    bsFac = (s >= 1.) ? 1. : 0.1 + 0.9 * s;\n    roo = roo * vuMat;\n    rdo = rdo * vuMat;\n    db4 = BlkHit (roo, rdo, bsFac * vec3 (1.6, 0.25, 0.05));\n    if (db4.x < min (dstObj, dstFar) && db4.w < 0.) {\n      w = (roo + db4.x * rdo).xy / bsFac + vec2 (-0.4, 0.);\n      g = floor (vec3 (10. * flPos.xz, 10. * flPos.y) + 0.5);\n      wd = 0.9 * vec2 (1., 0.3);\n      s = ShowInt (w - vec2 (-1., -0.1), wd, 5., g.x) +\n          ShowInt (w - vec2 (0., -0.1), wd, 5., g.y) +\n          ShowInt (w - vec2 (0.9, -0.1), wd, 5., g.z);\n      col = mix (col, vec3 (0.2, 1., 1.), s);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nmat3 FlMat (float flTilt)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (flTilt, flDir);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n         mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y , 0., ca.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat;\n  vec3 ro, rd, vd, col, wgBxC;\n  vec2 canvas, uv, us, mSize, ut[2], mMid[2], um, cnPos;\n  float zmFac, az, el, asp, aspW, flTilt, s;\n  int wgSel;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  mPtr.xyz = stDat.xyz;\n  wgSel = int (stDat.w);\n  az = 0.;\n  el = 0.;\n  if (wgSel == 0 && mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = 0.5 * pi * mPtr.y;\n  }\n  stDat = Loadv4 (1);\n  flDir = stDat.x;\n  flTilt = stDat.y;\n  flMat = FlMat (flTilt);\n  cnPos = stDat.zw;\n  dstFar = 1000.;\n  stDat = Loadv4 (2);\n  flPos = stDat.xyz;\n  stDat = Loadv4 (4);\n  pRot = stDat.x;\n  pPitch = stDat.y;\n  aspW = 1.3;\n  mSize = 0.3 * vec2 (aspW, 1.);\n  mMid[0] = vec2 (- (asp - mSize.x), 1. - mSize.y);\n  mMid[1] = vec2 (asp - mSize.x, 1. - mSize.y);\n  ut[0] = abs (uv - mMid[0]) - mSize;\n  ut[1] = abs (uv - mMid[1]) - mSize;\n  idVu = 0;\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      idVu = k + 1;\n      break;\n    }\n  }\n  grndScl = 50.;\n  heliScl = 0.3;\n  SetConf ();\n  if (idVu == 0) {\n    ro = vec3 (0., 8., -15.);\n    vd = flPos - ro;\n    zmFac = 1. + 0.12 * length (vd);\n    vuMat = StdVuMat (el + asin (vd.y / length (vd)), az + atan (vd.x, vd.z));\n    rd = vuMat * normalize (vec3 (uv, zmFac)); \n  } else if (idVu == 1) {\n    ro = flPos + vec3 (0., 3., 0.);\n    zmFac = 0.6;\n    rd = normalize (vec3 (uv, zmFac)) * flMat;\n  } else if (idVu == 2) {\n    ro = flPos + vec3 (0., 1.5, 0.);\n    zmFac = 0.6;\n    rd = normalize (vec3 (uv, zmFac));\n    rd.yz = Rot2D (rd.yz, 0.5 * pi);\n    rd.xz = Rot2D (rd.xz, flDir);\n  }\n  sunDir = normalize (vec3 (1., 2., -1.));\n  col = ShowScene (ro, rd);\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 4.)\n       col = vec3 (0.2, 0.7, 0.7);\n  }\n  if (idVu == 0) {\n    wgBxC = vec3 (0.41 * asp, -0.33, 0.13);\n    us = 0.5 * uv - wgBxC.xy;\n    s = (length (us) - wgBxC.z - 0.005) * canvas.y;\n    col = mix (vec3 (0.9, 0.9, 1.), col, smoothstep (0., 0.5, abs (s) - 1.));\n    if (s < 0.) {\n      if (Minv2 (abs (us)) * canvas.y < 1.) col = vec3 (0.9, 0.9, 1.);\n      col = mix (vec3 (0.8, 1., 0.8), col, smoothstep (0., 0.3,\n         abs (length (us - cnPos) * canvas.y - 10.) - 2.5));\n    }\n    if (wgSel == 0 && mPtr.z > 0. && Maxv2 (abs (uv)) < 0.04 && Minv2 (abs (uv)) < 0.003)\n       col = mix (col, vec3 (0.5, 1., 1.), 0.5);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2e (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 6; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.96875);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Fly The Mars Copter\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float txRow = 32.;\nconst float pi = 3.14159;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 flPos, flVel, wgBxC;\n  vec2 canvas, iFrag, ud, cnPos;\n  float tCur, tCurP, tDown, flDir, flDirN, flTilt, pRot, pPitch, dt, aLim,\n     asp, s, htFly;\n  int pxId, wgSel;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 5) discard;\n  asp = canvas.x / canvas.y;\n  wgSel = 0;\n  tDown = 1.;\n  if (iFrame <= 5) {\n    mPtrP = mPtr;\n    flDir = 0.5 * pi;\n    flTilt = 0.;\n    cnPos = vec2 (0.);\n    flPos = vec3 (0.);\n    flVel = vec3 (0.);\n    pRot = 0.;\n    pPitch = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (1);\n    flDir = stDat.x;\n    flTilt = stDat.y;\n    cnPos = stDat.zw;\n    stDat = Loadv4 (2);\n    flPos = stDat.xyz;\n    stDat = Loadv4 (3);\n    flVel = stDat.xyz;\n    stDat = Loadv4 (4);\n    pRot = stDat.x;\n    pPitch = stDat.y;\n    tCurP = stDat.z;\n    tDown = stDat.w;\n    aLim = 0.15 * pi;\n    wgBxC = vec3 (0.41 * asp, -0.33, 0.13);\n    if (mPtr.z > 0.) {\n      ud = mPtr.xy * vec2 (asp, 1.) - wgBxC.xy;\n      if (wgSel == 1) {\n        tDown = - tCur;\n        cnPos = ud;\n        s = length (cnPos);\n        if (s > 0.) cnPos = min (s, 0.135) * cnPos / s;\n        s = length (cnPos);\n        flDirN = (s > 0.01) ? 0.5 * pi + atan (- cnPos.y, - cnPos.x) : flDir;\n        flDirN -= 2. * pi * sign (flDirN - flDir) * step (pi, abs (flDirN - flDir));\n        flTilt = (s > 0.03) ? min (4. * (s - 0.02), 1.) * aLim : 0.;\n      } else if (mPtrP.z <= 0. && length (ud) < wgBxC.z + 0.03) wgSel = 1;\n    } else {\n      flTilt *= 0.97;\n      cnPos *= 0.97;\n      wgSel = 0;\n    }\n    dt = tCur - tCurP;\n    htFly = 5.;\n    if (tDown < 0.) {\n      flPos.y = min (flPos.y + 0.02 * (1. - smoothstep (htFly - 0.3, htFly, flPos.y)), htFly);\n      if (wgSel == 1 && flPos.y > 1.) flDir = mix (flDir, flDirN, 0.03);\n      flVel.xz = 6. * flTilt * Rot2D (vec2 (0., 1.), flDir);\n      if (tCur + tDown > 4.) tDown = 1.;\n    } else {\n      flPos.y = max (flPos.y - 0.02 * smoothstep (0., 0.3, flPos.y), 0.);\n    }\n    flTilt *= smoothstep (1., 2., flPos.y);\n    flVel *= smoothstep (1., 2., flPos.y);\n    if (length (flPos.xz) < 30. || dot (flPos.xz, flVel.xz) < 0.) flPos.xz += dt * flVel.xz;\n    pRot += ((flPos.y > 0.05) ? 3. : 0.7) * pi * dt;\n    pPitch = 0.05 * pi * (0.5 + 1.5 * smoothstep (0.03, 0.05, flPos.y));\n  }\n  if      (pxId == 0) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 1) stDat = vec4 (flDir, flTilt, cnPos);\n  else if (pxId == 2) stDat = vec4 (flPos, 0.);\n  else if (pxId == 3) stDat = vec4 (flVel, 0.);\n  else if (pxId == 4) stDat = vec4 (pRot, pPitch, tCur, tDown);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBSRz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1277, 1277, 1300, 1300, 1695], [1697, 1697, 1731, 1731, 2222], [2224, 2224, 2246, 2246, 2502], [2608, 2608, 2625, 2625, 3297]], "test": "untested"}
{"id": "wtl3Wn", "name": "Little Robot Face", "author": "maeln", "description": "Little robot face in 2D.", "tags": ["2d", "robot", "face"], "likes": 0, "viewed": 256, "published": 3, "date": "1619508512", "time_retrieved": "2024-07-30T19:23:10.822661", "image_code": "// iq primitives\n\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\nfloat round_bezier( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in float r )\n{\n  return bezier(p,a,b,c) - r;\n}\n\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat round_line( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n  return line(p,a,b) - r;\n}\n\nfloat poker_face(in vec2 p) {\n    float eye_left = round_line(p, vec2(-1.2, 0.5), vec2(-0.5, 0.5), 0.08);\n    float eye_right = round_line(p, vec2(1.2, 0.5), vec2(0.5, 0.5), 0.08);\n    float eyes = min(eye_left, eye_right);\n        \n    float mouth = round_line(p, vec2(-0.8, 0.0), vec2(0.8, 0.0), 0.08);\n    \n    return min(mouth, eyes);\n}\n\nfloat happy_face(in vec2 p) {\n    float eye_left = round_bezier(p,\n                            vec2(-1.2, 0.5),\n                            vec2(-0.8, 0.7),\n                            vec2(-0.5, 0.5),\n                                 0.08);\n    float eye_right = round_bezier(p,\n                            vec2(1.2, 0.5),\n                            vec2(0.8, 0.7),\n                            vec2(0.5, 0.5),\n                                  0.08);\n    float eyes = min(eye_left, eye_right);\n    \n    float mouth = round_bezier(p, vec2(-0.8, 0.0), vec2(0.0, -0.3), vec2(0.8, 0.0), 0.08);\n    return min(mouth, eyes);\n}\n\nvec4 fill(float dist, vec4 col) {\n    return col * smoothstep(4.0/iResolution.y, 0.0, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 background = vec3(0.0);\n    \n    vec4 output_color = vec4(background, 1.0);\n    vec4 happy = fill(happy_face(uv), vec4(1.0, 1.0, 1.0, 1.0));\n    vec4 poker = fill(poker_face(uv), vec4(1.0, 1.0, 1.0, 1.0));\n    output_color = happy;\n\n    fragColor = output_color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtl3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 66, 66, 1358], [1360, 1360, 1438, 1438, 1470], [1473, 1473, 1520, 1520, 1639], [1641, 1641, 1706, 1706, 1734], [1736, 1736, 1765, 1765, 2076], [2078, 2078, 2107, 2107, 2700], [2702, 2702, 2735, 2735, 2796], [2798, 2798, 2855, 2855, 3189]], "test": "untested"}
{"id": "7dXSDl", "name": "raymarching_3d_sdf_demo", "author": "luckywjr", "description": "raymarching_3d_sdf_demo", "tags": ["3d", "raymarching", "sdf"], "likes": 0, "viewed": 323, "published": 3, "date": "1619507064", "time_retrieved": "2024-07-30T19:23:11.570661", "image_code": "float sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 opUnion(vec2 d1, vec2 d2)\n{ \n    return d1.x < d2.x ? d1 : d2; \n}\n\nvec2 map(in vec3 pos)\n{\n    vec2 res = vec2(1e10, 0);\n    res = opUnion(res, vec2(sdSphere(pos+vec3(-0.3,-0.9,-2.), 0.4), 2));\n    res = opUnion(res, vec2(sdBox(pos+vec3(0.9,-0.8,-2.), vec3(0.3)), 3));\n    return res;\n}\n\n// \nvec2 raycast(in vec3 orign, in vec3 direction)\n{\n    vec2 res = vec2(-1, -1);\n    float lenMin = 0.0;\n    float lenMax = 20.0;\n        \n    //\n    float len2plane = (0.0-orign.y)/direction.y;\n    if(len2plane > 0.0)\n    {\n        lenMax = min(lenMax, len2plane);\n        res = vec2(len2plane, 1);\n    }\n    \n    float len = lenMin;\n    for(int i = 0; i < 70 && len < lenMax; i++)\n    {\n        // \n        vec2 d = map(orign + direction * len);\n        // \n        if(abs(d.x) < (0.001*len))\n            return vec2(len, d.y);\n            \n        // \n        len += d.x;\n    }\n    return res;\n}\n\n//\nbool calHardShadow(in vec3 orign, in vec3 direction, float lenMax)\n{\n    float len = 0.;\n    for(int i = 0; i < 70; i++)\n    {\n        vec2 d = map(orign + direction * len);\n        if(abs(d.x) < (0.001*len))\n        {\n            if(lenMax > len + 0.015) return true;\n            break;\n        }\n            \n        len += d.x;\n    }\n    return false;\n}\n\n//\nvec3 CalNormal(vec3 p)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize(e.xyy*map(p + e.xyy).x + \n                    e.yyx*map(p + e.yyx).x + \n                    e.yxy*map(p + e.yxy).x + \n                    e.xxx*map(p + e.xxx).x );\n}\n\n//\nvec3 render(in vec3 orign, in vec3 direction)\n{\n    vec3 col = vec3(0.7, 0.7, 0.9);\n    vec2 res = raycast(orign, direction);\n    if(res.x >= 0.)\n    {\n        vec3 p = orign + direction * res.x;//\n        vec3 normal = CalNormal(p);//\n        vec3 sum = vec3(-2.0, 2.0, -2.0);\n        \n        if(res.y == 1.)\n        {\n            //\n            normal = vec3(0,1,0);\n        }\n        \n        {\n            vec3 p2sum = normalize(sum-p);\n            //\n            col = vec3(1);\n            vec3 kd = vec3(0.9);\n            col = kd * max(0.0, dot(p2sum, normal));\n            //\n            vec3 p2camera = normalize(orign-p);\n            vec3 cs = p2camera + p2sum;\n            vec3 h = cs/dot(cs,cs);\n            vec3 ks = vec3(1.0);\n            col += ks * pow(max(0.0, dot(h, normal)), 3.0);\n            \n            //\n            if(res.y == 1.)\n                col += vec3(0.2,0.5,0.2);\n            if(res.y == 2.)\n                col += vec3(0.5,0,0);\n            if(res.y == 3.)\n                col += vec3(0,0.5,0.5);\n        }\n        \n        {\n            //\n            bool s = calHardShadow(sum, normalize(p-sum), length(p-sum));\n            if(s)\n                col -= vec3(0.6);\n        }\n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 camera = vec3(0.0, 1.0, -3);\n    const float fl = 3.0;// focal length \n    vec3 direction = normalize(vec3(p, fl));\n    vec3 orign = vec3(camera.x + p.x, camera.y + p.y, camera.z + fl);\n    \n    \n    vec3 col = render(orign, direction);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 59], [61, 61, 92, 92, 179], [181, 181, 213, 213, 251], [253, 253, 276, 276, 472], [474, 508, 556, 556, 1166], [1168, 1186, 1254, 1254, 1542], [1544, 1565, 1589, 1589, 1819], [1821, 1830, 1877, 1877, 3167], [3169, 3169, 3226, 3226, 3581]], "test": "untested"}
{"id": "fdSSzR", "name": "Fractal mosaic", "author": "jarble", "description": "This fractal forms a mosaic pattern.", "tags": ["fractal", "spiral", "mosaic"], "likes": 2, "viewed": 258, "published": 3, "date": "1619503875", "time_retrieved": "2024-07-30T19:23:12.421386", "image_code": "#define ITERS 9\nconst float scale = 2.7;\nconst float scale1 =-1.175;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/15.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy*8./15.;\n    for(int c=0;c<ITERS;c++){\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            //uv += uv1/s1;\n            //uv *= -1.;\n            uv = fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale+uv.x/scale1)/(scale))))/scale1;\n            \n            uv.x *= scale1;\n            uv = fract(-uv.yx/s1)*s1;\n            uv.y /= -scale1;\n            //uv = uv1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //divide by powers of 2 to get interesting rhythms\n    float a1 = a;\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n#define fmod0(x,y) mod(floor(x)+1.5*floor(mod(x,y/2.)),y)\n#define fmod1(x,y) floor(mod(floor(x+floor((x)/y)/y),y))\n#define fmod2(x,y) mod(floor(x+floor(x)*y)/y,y)\n#define fmod3(x,y) mod(floor(x)*floor(x)+floor(x)*floor((x)/y),y)\n#define fmod4(x,y) mod(floor(x-floor((x)/y)/y),y)\n#define sqmod(x,y) floor(mod(floor(1.+x/2.)*floor(1.+x*2.),y))\n\nvec2 mainSound(int samp, float t){\n  t /= 1.5;\n  \n  float s1 =\n      8.;\n  //t = t + floor(t/s1+floor(t/2.));\n\n  float\n  m1 =\n      fmod(t,s1)\n\n  ,\n  z1 =\n      (1.+fmod(t/s1+floor(t/2.),2.))\n\n  ;\n\n  t /=\n      1.+fmod(floor(t*s1+floor(t*2.))*floor(t/s1+floor(t/2.)+z1),2.)\n     \n  ;\n  float m3 =\n      fmod((t*8.+floor(t*2.))/(m1+.5),s1*z1)\n\n  ;\n  \n  t *=\n      1.+fmod(floor(t*s1)*floor(t/s1+z1),2.)\n  ;\n      \n      \n  float a= (1.-sqrt(fract(t*s1)))*.2,\n\n  nb = pow(2.,(m3+z1)/5.+7.);\n\n  return vec2(fract(t*nb*.998)\n   ,fract(t*nb))*a;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSSzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 942]], "test": "untested"}
{"id": "NsBXRR", "name": "Marble spirals", "author": "jarble", "description": "These fractal spirals have an odd \"marbled\" look.", "tags": ["fractal", "spiral", "marble"], "likes": 5, "viewed": 293, "published": 3, "date": "1619503318", "time_retrieved": "2024-07-30T19:23:13.178362", "image_code": "#define ITERS 9\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.5;\n        float scale1 = 1.15;\n        float s1 = scale1*scale;\n        col_prev = col;\n        vec2 uv1 = vec2(0.);\n        for(int i=0;i<ITERS;i++)\n        {\n            //uv += uv1/s1;\n            uv1= fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale+uv.x/scale1)/(scale))))/scale1;\n            uv = uv1;\n            uv.x *= scale1;\n            uv = fract(-uv.yx/s1)*s1;\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        //col[2] = abs((uv.y)+(uv.x)-col[2]);\n        //col[2] = fract((uv.y)-(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBXRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 73, 73, 949]], "test": "untested"}
{"id": "fsSXRR", "name": "Galaxy spiral fractal", "author": "jarble", "description": "This fractal has many small spirals embedded in a larger spiral pattern.", "tags": ["fractal", "spiral", "galaxy"], "likes": 3, "viewed": 290, "published": 3, "date": "1619501344", "time_retrieved": "2024-07-30T19:23:14.004154", "image_code": "#define ITERS 12\nconst float scale = 2.7;\nconst float scale1 = 1.165;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0/2.0;\n    uv.y += (iTime)/25.0/2.0;\n    for(int c=0;c<ITERS;c++){\n\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(uv.x/scale+uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1;\n            //uv.x *= sign(uv.y-.5);\n            uv = fract(-uv.yx/s1)*s1;\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSXRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 128, 128, 840]], "test": "untested"}
{"id": "NsSSRR", "name": "Petri dish", "author": "jarble", "description": "This cellular automaton resembles a petri dish with several different types of life-forms. Some random noise is added with each iteration.", "tags": ["feedback", "cellularautomata", "swamp"], "likes": 4, "viewed": 289, "published": 3, "date": "1619496909", "time_retrieved": "2024-07-30T19:23:14.890784", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 4.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 0.11;\nconst float B = 0.80;\nconst float C = 2.5;\nconst float D = 1.0;\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = 1.0;\nconst float NUM_NEIGH = 9.0;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum += GET(d);\n        sum += noise(fragCoord/res)/9.0;\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL * (NUM_NEIGH + D) + B * ((C / NUM_NEIGH) * sum - C * cen) - sum;\n\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val = new_val;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSSRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 284]], "test": "untested"}
{"id": "sdlSDl", "name": "reaction diffusion antialiased", "author": "mds2", "description": "antialiased thresholding of a reaction diffusion system.\n\nHit space bar to reset system", "tags": ["diffusion", "reaction"], "likes": 1, "viewed": 322, "published": 3, "date": "1619487791", "time_retrieved": "2024-07-30T19:23:15.658730", "image_code": "#define BW 0 // set to 1 to make the output black and white\n// set to 0 to make it a mix of cyan, red, black, and white\n\nfloat hill_val(in vec2 uv, in vec3 selector) {\n  uv = mod(uv, vec2(1.0));\n  float val = dot(selector, texture(iChannel0, uv).rgb) - 0.5;\n  return val;\n}\n\nvec2 hill_grad(in vec2 uv, in vec3 selector) {\n  float f = hill_val(uv, selector);\n  return 1000.0 * vec2(hill_val(uv + vec2(0.001, 0.0), selector) - f,\n                       hill_val(uv + vec2(0.0, 0.001), selector) - f);\n}\n\nfloat coverage(in vec2 uv, in vec3 selector) {\n    float val = hill_val(uv, selector);\n    float grad_mag = length(hill_grad(uv, selector)/iResolution.xy);\n    \n    float to_zero = val / grad_mag;\n    \n    float cov = max(0.0, min(0.5 + to_zero, 1.0));\n    return cov;\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    float cyan = coverage(uv, vec3(1.0, 0.0, 0.0));\n    float red = coverage(uv, vec3(0.0, 1.0, 0.0));\n\n#if BW\n    cyan = red;\n#endif\n\n    vec3 col = vec3(red, cyan, cyan);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float diffuse_weight = 0.025; // higher means less diffusion.  set greater than 0 and less than 1\nconst float react_weight = 0.25; // reaction speed : don't exceed 0.25.  higher is faster reaction\n\n// in the function \"greatest\" there are two calls to \"color_to_val_4\"\n// change those to \"color_to_val_1\", \"color_to_val_2\" etc to get different effects\n\nvec2 to_uv(in vec2 in_pixels) {\n    return in_pixels / iResolution.xy;\n\t// return 0.1 + mod(vec2(0.8) + in_pixels / iResolution.xy, vec2(0.9));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    \n    vec4 color = texture(iChannel1, to_uv(p));\n    \n    // color.rg = mod(10.0 * to_uv(p), vec2(1.0));\n    color.b = 1.0 - 0.5 * color.r - 0.5 * color.g;\n    \n\n    if (iTime < 0.05 || texelFetch(iChannel3, ivec2(32, 0), 0).r > 0.01) {\n\t    fragColor = vec4(color.rgb, 1.0);\n        return;\n    }\n   \n    \n    color = diffuse_weight * texture(iChannel0, to_uv(p));\n    \n    vec2 dir = 0.25 * normalize(mod(to_uv(p), vec2(0.5)) - vec2(0.25));\n      // vec2(0.95 * smoothstep(0.05, 0.0, abs(mod(to_uv(p).x, 0.25) - 0.125)), 0.0);\n      // vec2(0.0, 0.95);\n    mat2 diffuse_tensor = mat2(1.0 - dir.x * dir.x, -dir.x * dir.y,\n                               -dir.x*dir.y, 1.0 - dir.y * dir.y);\n    \n    float w = 0.25 * (1.0 - diffuse_weight);\n    const float scale = 2.0;\n    color = color +  w * texture(iChannel0, to_uv(p + scale * diffuse_tensor * vec2(1.1, 0.0)));\n    color = color +  w * texture(iChannel0, to_uv(p + scale * diffuse_tensor * vec2(0.0, 1.1)));\n    color = color +  w * texture(iChannel0, to_uv(p - scale * diffuse_tensor * vec2(1.1, 0.0)));\n    color = color +  w * texture(iChannel0, to_uv(p - scale * diffuse_tensor * vec2(0.0, 1.1)));\n    \n    color.rgb = color.rgb + react_weight * (1.0 * color.rgb * color.gbr - color.rgb * color.brg);//  + 0.005;\n    \n    color.a = 1.0;\n    color.rgb = max(vec3(0.0), min(vec3(1.0), color.rgb));\n\n    float delta = 1.5 - dot(color.rgb, vec3(1.0));\n\n    color.rgb += 0.01 * delta;\n    \n \n    fragColor = vec4(color.rgb,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 167, 167, 273], [275, 275, 321, 321, 500], [502, 502, 548, 548, 776], [778, 778, 835, 885, 1157]], "test": "untested"}
{"id": "7dsXWs", "name": "Capillaries", "author": "jarble", "description": "These \"capillaries\" move in a strange way. It reminds me of an Etch A Sketch.", "tags": ["feedback", "cellularautomata"], "likes": 6, "viewed": 244, "published": 3, "date": "1619487383", "time_retrieved": "2024-07-30T19:23:16.443632", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 0.11;\nconst float B = -0.80;\nconst float C = -2.5;\nconst float D = -1.0;\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = 1.0;\nconst float NUM_NEIGH = 9.0;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum += GET(d);\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL * (NUM_NEIGH + D) + B * ((C / NUM_NEIGH) * sum - C * cen) - sum;\n\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val = new_val;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val+hash/10.0;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsXWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 278]], "test": "untested"}
{"id": "sdsXWs", "name": "Orbital 2D", "author": "milesWaugh", "description": "A little experiment for fun. Blue --> orange gradient is where the wave-function is positive, purple --> green gradient is where the wave-function is negative.", "tags": ["quantum", "wavefunction", "orbtial"], "likes": 12, "viewed": 396, "published": 3, "date": "1619486819", "time_retrieved": "2024-07-30T19:23:17.330261", "image_code": "float pi = 3.141592653589793;\nfloat sq2 = sqrt(2.);\nfloat transitionSpeed = 60.; //Higher is faster\n\nfloat sw(float x, float s) {\n    return (atan(s * sin(pi * x))) / (.5 * pi);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0.);\n    float contour = 0.1;\n    int AA = 4; //Default value is 4x4 anti-aliasing\n    float AAA = float(AA * AA);\n\n    for(int i = 0; i < AA; i++) {\n        for(int j = 0; j < AA; j++) {\n            vec2 uv = (fragCoord + vec2(i, j) / float(AA) - iResolution.xy / 2.) / iResolution.y;\n            uv *= 7.;\n            float a = atan(uv.y / uv.x) - (uv.x < 0. ? pi : 0.);\n            a += a < 0. ? 2. * pi : 0.;\n            float d = sqrt(dot(uv, uv));\n            float mu = sw(iTime / 4., transitionSpeed);\n            mu = mu / 2. + .5;\n            float rot = iTime / 5.;\n            rot *= mu / 10. + 1.;\n            float w1 = cos(2. * a + rot) * exp(-d) * d * 2.5;\n            float w2 = cos(a + rot) * exp(-d) * d * 2.5;\n            float w = mu * w1 + w2 * (1. - mu);\n            float p = w * w;\n            p = max(min(p, 1.), 0.);\n            if(w < 0.) {\n                col += vec3(p, (-cos(pi * (p)) / 2. + .5), (1. - (acos(2. * p - 1.)) / pi)) / AAA;\n            } else {\n                col += vec3((-cos(pi * (p)) / 2. + .5), p, (1. - (acos(2. * p - 1.)) / pi)) / AAA;\n            }\n            float er = sin(pi * (p * 10. - floor(p * 10.)));\n            er -= p < 1. / 20. ? 5. : 0.;\n            er = (0.01) / (er * er);\n            col += vec3(min(er / AAA, 1. / AAA), min(0.7 * er / AAA, 1. / AAA), min(0.6 * er / AAA, 1. / AAA)) / 2.;\n        }\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 129, 129, 179], [181, 181, 236, 236, 1666]], "test": "untested"}
{"id": "7ssXWl", "name": "Another volumetric PT", "author": "michael0884", "description": "Now using SDFs properly! (I think)", "tags": ["volumetric"], "likes": 40, "viewed": 1040, "published": 3, "date": "1619483261", "time_retrieved": "2024-07-30T19:23:18.119152", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = tanh(1.2*acc/acc.w);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//CAMERA stuff\n#define FOV 1.0\n#define ANG 0.001\n#define PI 3.14159265\n#define TWO_PI 6.28318530718\n\nconst vec3 light = normalize(vec3(1,1,1));\nconst float light_bright = 2.0;\nconst float light_ang = 0.1;\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nmat3 get_cam(float phi, float theta)\n{\n    vec3 z_dir = vec3(cos(phi)*sin(theta),  cos(theta), sin(phi)*sin(theta));\n    vec3 x_dir = normalize(cross(z_dir, vec3(0,1,0)));\n    vec3 y_dir = normalize(cross(x_dir, z_dir));\n    return mat3(x_dir, y_dir, z_dir);\n}\n\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdMandelbulb( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<3; i++ )\n    {\n        // trigonometric version (MUCH faster than polynomial)\n        \n        // dz = 8*z^7*dz\n\t\tdz = 8.0*pow(m,3.5)*dz + 1.0;\n      //dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n      \n        // z = z^8+z\n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\nfloat sdShrek(vec3 p)\n{\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    //neural networks can be really compact... when they want to be\n    //loss 0.000032\nvec4 f0_0=sin(p.y*vec4(1.614,-.384,3.461,-1.449)+p.z*vec4(-1.740,-3.099,1.257,-4.194)+p.x*vec4(1.423,-.731,3.950,2.749)+vec4(8.860,-6.088,-1.444,-.854));\nvec4 f0_1=sin(p.y*vec4(-.614,4.579,-2.415,-.228)+p.z*vec4(-3.400,.411,2.157,5.092)+p.x*vec4(-.270,-3.123,3.553,-2.081)+vec4(-4.280,7.037,6.676,-4.043));\nvec4 f0_2=sin(p.y*vec4(-2.214,-1.697,-2.458,4.407)+p.z*vec4(-.505,-.133,1.820,-1.197)+p.x*vec4(.871,-2.552,-1.096,2.168)+vec4(-4.484,.480,4.456,6.656));\nvec4 f0_3=sin(p.y*vec4(-.262,-2.127,-1.644,2.066)+p.z*vec4(.936,-1.286,-2.796,-1.724)+p.x*vec4(-2.576,-3.029,3.619,-2.664)+vec4(-2.128,-1.856,.912,-4.219));\nvec4 f1_0=sin(mat4(-.175,-.141,-.181,.472,.489,.042,.178,.065,-.133,-.601,.384,.606,.263,-.225,.024,.052)*f0_0+\n    mat4(.098,-.435,.407,.053,.141,.108,.168,.313,-.374,.313,-.633,-.237,.296,-.092,.360,-.109)*f0_1+\n    mat4(-.176,-.664,.937,.178,-.583,-.178,-.535,.900,-.029,.356,-.298,.286,-.024,-.326,-.247,-.266)*f0_2+\n    mat4(-.835,.224,-.646,.308,-.166,.522,-.570,-.073,.047,-.005,-.242,-.191,.909,-.777,.278,.586)*f0_3+\n    vec4(-.176,2.932,2.633,-2.581))/1.0+f0_0;\nvec4 f1_1=sin(mat4(.749,-.599,.060,.201,-.584,-.380,-.259,-.265,-.113,-.045,-.065,.320,-.000,-.157,-.369,-.111)*f0_0+\n    mat4(-.400,.668,1.048,.477,.226,-.053,.362,.106,.470,-.557,.278,-.050,-.536,.537,.612,.275)*f0_1+\n    mat4(.685,.667,.474,-.149,.817,.178,.281,-.997,.225,-.281,-.254,-.012,.430,-.658,-.169,-.168)*f0_2+\n    mat4(-.089,-.062,.411,-.270,.016,-.351,.504,-.621,-.372,-.099,.459,-.068,-.388,.787,.695,.653)*f0_3+\n    vec4(.874,2.704,2.734,2.805))/1.0+f0_1;\nvec4 f1_2=sin(mat4(-.333,.630,-.095,-.111,.342,-.102,1.435,-.043,.302,-.710,-.089,-.692,.067,-.047,.046,-.422)*f0_0+\n    mat4(-.534,1.033,.178,-.453,.696,-.087,.148,.130,-.115,.143,-.336,-.327,-.102,-.410,.370,.048)*f0_1+\n    mat4(-.007,-.061,.888,-.374,-.059,-.973,.430,.050,-.113,-.428,-.590,-.414,-.198,-.424,.016,.285)*f0_2+\n    mat4(-.424,.566,.485,-.124,.416,.015,-.159,.513,-.429,.508,-.177,.190,-.571,.348,.324,-.368)*f0_3+\n    vec4(-.466,2.862,1.568,-2.639))/1.0+f0_2;\nvec4 f1_3=sin(mat4(-.026,-.149,-.096,-.071,.120,-.360,-1.019,-.550,-.089,-.020,.527,-.275,-.345,.112,-.160,-.434)*f0_0+\n    mat4(-.155,-.337,.294,-.055,.492,-.659,.231,.273,-.218,.718,.127,.420,-.238,-.451,.167,.370)*f0_1+\n    mat4(-.100,.416,-.164,-.078,.739,.003,-.123,-.696,-.125,.202,-.117,-.863,.344,-.077,-.164,-.210)*f0_2+\n    mat4(.194,-.275,-.282,-.496,.212,-.590,.201,-.477,-.228,-.461,-.468,.123,.167,-.749,.085,-.343)*f0_3+\n    vec4(-1.475,1.966,-.599,1.170))/1.0+f0_3;\nvec4 f2_0=sin(mat4(1.080,.872,.711,.104,-.660,-.142,.339,.249,-.538,.418,-.618,-.306,-.245,-.175,.919,.010)*f1_0+\n    mat4(.106,.512,.018,.883,-.682,-.317,-.718,.475,.948,.038,.574,-.350,.023,.970,-.766,-.102)*f1_1+\n    mat4(-.030,.754,.336,.579,.234,-.428,.030,.166,-.002,.211,.055,.803,.260,.031,-.520,.381)*f1_2+\n    mat4(1.245,.856,.354,.121,.430,.305,.790,.595,.811,-.195,-.067,-.106,-1.421,-.204,-.224,.791)*f1_3+\n    vec4(.633,2.190,2.576,2.018))/1.4+f1_0;\nvec4 f2_1=sin(mat4(-.996,.390,-.566,-.109,.387,1.037,-.638,.502,.281,-1.178,-.828,.312,.283,-.481,-.210,.117)*f1_0+\n    mat4(-.602,-1.130,.273,-.236,.057,.597,-.631,.156,-.654,.380,.573,-.101,-.234,.068,-1.024,.173)*f1_1+\n    mat4(-.701,-.500,-.727,-.173,.118,.611,.552,-.199,.059,.022,.418,.257,-.545,-.647,.448,-.700)*f1_2+\n    mat4(-.117,.682,.589,-.177,.646,-.025,.158,.017,-.317,.787,1.245,-.632,.519,-.488,-1.065,-.338)*f1_3+\n    vec4(1.238,2.124,-.652,1.610))/1.4+f1_1;\nvec4 f2_2=sin(mat4(-.041,.230,-.114,-1.108,.284,.695,.812,.578,1.379,-.228,-.261,-.672,-1.183,.124,-.086,-.331)*f1_0+\n    mat4(.336,.228,-.854,.183,.180,.017,.893,.442,-.643,.418,-.519,.101,1.136,.074,.436,.166)*f1_1+\n    mat4(.056,-.419,-.569,-.230,-1.501,.016,.276,-.461,.651,.871,.042,.257,-.036,.253,-.484,-.337)*f1_2+\n    mat4(.759,-.194,.608,-1.026,-1.631,.967,-.322,.307,.793,-.334,.523,.013,.792,-.088,-.167,.215)*f1_3+\n    vec4(-.405,2.659,-1.339,3.678))/1.4+f1_2;\nvec4 f2_3=sin(mat4(-.339,1.039,.044,.203,.042,-.744,.374,-1.190,.583,.152,-.218,-.236,.024,.066,-.172,.659)*f1_0+\n    mat4(.220,-.253,1.000,-.678,.038,-.133,-.593,-.444,-.459,-.264,.763,.378,-.388,.042,-.395,-.742)*f1_1+\n    mat4(.392,.475,.196,-.626,.014,.124,-.313,.056,-.065,-.452,.111,-.250,-.420,.529,-.215,1.039)*f1_2+\n    mat4(-.607,-.029,.254,.600,.523,.250,-.227,.773,.091,-.398,.193,-.483,.781,.248,-.055,.150)*f1_3+\n    vec4(-1.623,-2.998,-.552,-3.926))/1.4+f1_3;\nreturn dot(f2_0,vec4(-.054,-.051,.066,.043))+\n    dot(f2_1,vec4(.045,.041,.025,.086))+\n    dot(f2_2,vec4(.011,-.046,.074,-.094))+\n    dot(f2_3,vec4(-.053,.089,-.084,.041))+\n    0.077;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float pos)\n{\n    vec3 p3 = fract(vec3(pos)*vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat sdErastus(vec3 pos)\n{\n    float minDist = length(pos)-0.1;\n    for(int i = 0; i < 32; i++)\n    {\n        minDist = min(minDist,length(pos-(hash31(float(5*i))*1.0 - 0.5))-0.3);\n    }\n    return minDist;\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n", "buffer_a_code": "#define scatter 50.0\n#define extinct 10.0\n\nvec4 map(vec3 p)\n{\n    float sd = 1e10;\n    vec4 col = vec4(1.0);\n    //sd = min(sdErastus(p), sd);\n    float mand =sdMandelbulb(p,col); \n    sd = min(mand, sd);\n    float plane = p.y+1.0;\n    if(plane < sd) \n    {\n        sd = plane;\n        col = vec4(0,0,0,1.0);\n    }\n    return vec4(col.xyz, sd);\n}\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(vec3 rd)\n{\n\t// Atmosphere Scattering\n\tvec3 fsun = light;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(rd.y-0.1),0.)),2.)+0.1));\n\tif(rd.y < 0.)\n\t{\n\t\trd.y = 0.;\n\t\trd.xyz = normalize(rd.xyz);\n\t}\n    float mu = dot(rd, fsun);\n\t\n\tvec3 extinction = mix(exp(-exp(-((rd.y + fsun.y * 4.0) * (exp(-rd.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-rd.y * 16.0) + 0.1) * Kr / Br) * exp(-rd.y * exp(-rd.y * 8.0 ) * 4.0) * exp(-rd.y * 2.0) * 4.0, vec3(1.0 - exp(rd.y)) * 0.2, -rd.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,10.);\n\treturn light_bright*sky_col; \n}\n\nvec3 back(vec3 rd)\n{\n    return sky_color(rd);//texture(iChannel1, rd).xyz;\n}\n\n//trace up to a scattering threshold\nbool trace(inout vec4 ro, vec3 rd, float maxc, out vec3 ex)\n{\n    vec4 c = vec4(0.); //rgb extinction and w scattering\n    float td = 0.0;\n    for(int i = 0; i < 300; i++)\n    {\n        vec4 d = map(ro.xyz); //distance\n        float dx = max(ro.w*ANG, abs(d.w)); //ray step\n        ro += vec4(rd,1.)*dx; \n        td += dx;\n        c += (d.w < 0.0 ? vec4(extinct*d.xyz, scatter) : vec4(0.))*dx;\n        if(c.w > maxc || dx > 3.0 || td > 10.0) break;\n    }\n    ex = exp(-c.xyz); //return extinction\n    return c.w > maxc;\n}\n\nvec3 pathtrace(vec4 ro, vec3 rd)\n{\n    ro.w = 3.0 + 3.*rand();\n    ro += vec4(rd,1.0)*rand()*0.5;\n    vec3 tex = vec3(1.0);\n    vec3 emi = vec3(0.);\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 ex;\n        float thresh = -log(rand());\n        bool hit = trace(ro, rd, thresh, ex);\n        tex *= ex;\n        if(hit) \n        {\n            rd = udir(rand2());\n            vec4 sro = ro; \n            //shadow ray\n            if(!trace(sro, light, -log(rand()), ex)) emi += sky_color(light)*ex*light_ang;\n        }\n        else\n        {\n            emi += back(rd); break;\n        }\n    }\n    return emi*tex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n   \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    fragCoord += nrand2(0.5, vec2(0.));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 m = PI*iMouse.xy/iResolution.xy + 1e-3;\n    \n   \n    if(iMouse.z > 0.) fragColor*=0.6;\n    mat3 cam = get_cam(2.*m.x,PI - m.y);\n    \n    vec3 ro = -cam*vec3(0,0,2.3);\n    vec3 rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    vec3 c = pathtrace(vec4(ro,0.), rd);\n    // Output to screen\n    fragColor += vec4(c, 1.0);\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 81, 181]], "test": "untested"}
{"id": "ssfXDl", "name": "Cubic Transport Wormhole", "author": "Tater", "description": "high traffic area. ", "tags": ["raymarching", "cubes"], "likes": 15, "viewed": 696, "published": 3, "date": "1619476668", "time_retrieved": "2024-07-30T19:23:18.890090", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.1415926535\n#define STEPS 150.0\n#define MDIST 400.0\n#define pmod(p,x) (mod(p, x) - (x)*0.5)\n#define rotR 0.01\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec3 glow = vec3(0);\nvec2 map(vec3 p){\n    float t = mod(iTime,50.0)+15.0;\n    float t2 = t*1.5;\n    t2 = pow(fract(t2),2.5)+floor(t2);\n    //t2=t*2.0;\n    \n    vec3 po = p;\n    vec3 p2 = p;\n    \n    //Center Cubes\n    p2.z -= t2*120.0;\n    \n    float id2 = floor(p2.z/50.0)+2.0;\n    p2.z = pmod(p2.z,50.0);\n    \n    vec3 ccol = vec3(0);\n    \n    if(mod(id2,3.0)==0.0) ccol = vec3(1.000,0.412,0.059);\n    if(mod(id2,3.0)==1.0) ccol = vec3(0.392,0.102,1.000);\n    if(mod(id2,3.0)==2.0) ccol = vec3(0.118,0.224,0.992);\n    p2.yx*=rot(0.5*pi*t2*(mod(id2,2.0)*2.0-1.0));\n    \n    float scl = 0.7;\n    \n    p2 = abs(p2)-(4.5*abs(1.0+sin(id2*20.0)))*scl;\n    p2.xz*=rot(pi/4.0);\n    float cb = box(p2,vec3(2.5*scl));\n    p2 = abs(p2)-5.0*scl;\n    cb = min(cb,box(p2,vec3(2.5*scl)))-0.5;\n    \n\n    glow+=vec3(0.0085/(0.01+cb*cb))*ccol;\n    \n    vec2 a = vec2(cb,1.0);\n    \n    \n    //Outer Cubes\n    p.yx*=rot(p.z*rotR*pi/3.);\n    float modd = 12.0;\n    vec2 id = floor(p.xz/modd);\n    \n    p.z+=t*48.0*(mod(id.x,2.0)*2.0-1.0);\n    \n    \n    p.y = abs(p.y)-30.0;\n    \n    id.y = floor(p.z/modd);\n    p.xz=pmod(p.xz,modd);\n    \n    p.xy*=rot(t*pi/3.333);\n    \n    vec2 b = vec2(box(p, vec3(3.7)),mod(id.y,2.0)+2.0);\n    \n    a = (a.x<b.x)?a:b;\n    \n    glow+=vec3(0.01/(0.01+b.x*b.x));\n    \n    return a*vec2(0.5,1.0);\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = mod(iTime,50.0)*2.0+7.5;\n    \n    //Uncomment to stop camera movement\n    //t=9.0;\n    \n    vec2 off = vec2(25,-3.0)*rot(t*pi*10.*rotR);\n    \n    vec3 ro = vec3(off,t*30.0);\n    vec3 lk = vec3(0,0,999999.0);\n    vec3 f = normalize(lk-ro);\n    vec3 ra = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.8+uv.x*ra+uv.y*cross(f,ra));\n    float dO = 0.0;\n    vec3 p = vec3(0);\n    vec2 d = vec2(0);\n    for(float i =0.0; i<STEPS; i++){\n    \n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(d.x<0.0001||dO>MDIST){\n            break;\n        }\n    }\n    //vec3 mix1 = mix(vec3(0.012,0.180,0.745),vec3(0.502,0.000,0.690),sin(p.z*0.2));\n    \n    if(d.y==2.0){\n        glow*=vec3(0.012,0.180,0.745);\n        //glow*=mix1;\n        col+=glow*0.14;\n    }\n    if(d.y==3.0){\n        glow*=vec3(0.502,0.000,0.690);\n        //glow*=mix1;\n        col+=glow*0.14;\n    }\n    if(d.y==1.0){\n        col+=glow*0.14;\n    }\n    col=mix(col,vec3(0.000,0.161,0.459),(clamp(dO/MDIST,0.0,1.0)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 201, 201, 288], [310, 310, 327, 327, 1606], [1607, 1607, 1664, 1664, 2796]], "test": "untested"}
{"id": "7dfSWs", "name": "324_Baranov_v1v0", "author": "trile", "description": "324_Baranov_v1v0", "tags": ["324baranovv1v0"], "likes": 1, "viewed": 197, "published": 3, "date": "1619474277", "time_retrieved": "2024-07-30T19:23:20.052982", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float INF = 1e10;\n\nconst vec3 CAMERA_POS = vec3(3.5, 2.7, -6);\n\n\nconst vec3 LIGHT1_POS = vec3(2, 1.74, 3);\nconst float LIGHT1_RADIUS = 0.3;\nconst vec3 LIGHT1_COLOR = vec3(.1, .8, .1);\n\nconst vec3 LIGHT2_POS = vec3(-0.5, 0.2, -1.5);\nconst float LIGHT2_RADIUS = 0.2;\nconst vec3 LIGHT2_COLOR = vec3(0.4, 0.1, 0.4);\nvec3 randDir;\n\n\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\n\n\n// (CAMERA_POS + t * viewVec).y == -1\n// t = (-1 - CAMERA_POS.y) / viewVec.y;\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceRectangle(vec3 pos, vec3 dir, float a, float b,\n        out float u, out float v, out vec3 normal) {\n    // (pos + t * dir).z == 0\n    // t == -(pos.z) / dir.z\n    \n    float t = -(pos.z) / dir.z;\n    vec3 d = pos + t * dir;\n    if (abs(d.x) <= a / 2. && abs(d.y) <= b / 2. && t > 0.) {\n        u = (d.x + a / 2.) / a;\n        v = (d.y + b / 2.) / b;\n        \n        normal = vec3(0, 0, -1);\n        return t;\n    }\n    return INF;\n}\n\n\nfloat traceCube(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    // (pos + t * dir).z == -r\n    \n    float t, t0 = INF;\n    \n    t = (-r - pos.z) / dir.z;\n    vec3 d = pos + t * dir;\n    if (abs(d.x) <= r && abs(d.y) <= r && t < t0 && t > 0.) {\n        normal = vec3(0, 0, -1);\n        t0 = t;\n    }\n    t = (r - pos.z) / dir.z;\n    d = pos + t * dir;\n    if (abs(d.x) <= r && abs(d.y) <= r && t < t0 && t > 0.) {\n        normal = vec3(0, 0, 1);\n        t0 = t;\n    }\n    t = (-r - pos.x) / dir.x;\n    d = pos + t * dir;\n    if (abs(d.y) <= r && abs(d.z) <= r && t < t0 && t > 0.) {\n        normal = vec3(-1, 0, 0);\n        t0 = t;\n    }\n    t = (r - pos.x) / dir.x;\n    d = pos + t * dir;\n    if (abs(d.y) <= r && abs(d.z) <= r && t < t0 && t > 0.) {\n        normal = vec3(1, 0, 0);\n        t0 = t;\n    }\n    t = (-r - pos.y) / dir.y;\n    d = pos + t * dir;\n    if (abs(d.x) <= r && abs(d.z) <= r && t < t0 && t > 0.) {\n        normal = vec3(0, -1, 0);\n        t0 = t;\n    }\n    t = (r - pos.y) / dir.y;\n    d = pos + t * dir;\n    if (abs(d.x) <= r && abs(d.z) <= r && t < t0 && t > 0.) {\n        normal = vec3(0, 1, 0);\n        t0 = t;\n    }\n    return t0;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 1.5) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 cubeNorm;\n    float cubeT = traceCube(pos, dir, 1.0, cubeNorm);\n    if (cubeT < dist)\n        return true;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : 1.0f;\n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : 2.0f;\n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * 0.5\n    );\n}\n\n\n\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    vec4 colbuf = vec4(0, 0, 0, 0);\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float n1 = AIR_N;\n    float n2 = GLASS_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    const float DIAMOND_N = 2.5;\n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i < 10; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n        }\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n        if (light1T < t) {\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n        if (light2T < t) {\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n        vec3 recNorm;\n        float u, v;\n        float fireT = traceRectangle(curPos, curDir, 1.8, 1.8, u, v,recNorm);\n        if (fireT < t) {\n            vec2 p = -.5 + vec2(u, v);\n            float clr = 3.0 - (3.*length(2.*p));\n            vec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);\n            for(int i = 1; i <= 7; i++) {\n                float power = pow(2.0, float(i));\n                clr += (1.5 / power) * snoise(coord + vec3(0.,-iTime*.05, iTime*.01), power*16.);\n            }\n            if (clr > 0.03 && pow(max(clr,0.),2.)*0.4 > 0.03 && pow(max(clr,0.),3.)*0.15 > 0.03) {\n                t = fireT;\n                materialType = EMISSION;\n                normal = recNorm;\n                color = vec3( clr, pow(max(clr,0.),2.)*0.4, pow(max(clr,0.),3.)*0.15);\n            }\n        }\n        \n        vec3 cubeNorm;\n        float cubeT = traceCube(curPos, curDir, 1., cubeNorm);\n        if (cubeT < t) {\n            t = cubeT;\n            normal = cubeNorm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n                \n            } else {\n                colorMult *= vec3(0.5, 0.5, 0.5);\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n        }\n        \n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            colbuf += vec4(texture(iChannel0, worldPos.xz).rgb * 0.1, 0.0);\n            if (materialType == EMISSION) {\n                colbuf += vec4(color * colorMult, 0);\n                break;\n            } else if (materialType == DIFFUSE) {\n                colbuf += vec4(computeLight(worldPos, color, normal) * colorMult, 0);\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-3;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, n2);\n                curPos = worldPos + curDir * 1e-3;\n            }\n        } else {\n            colbuf += vec4(texture(iChannel1, viewVec).rgb * colorMult * 0.07, 0);\n        }\n    }\n    fragColor = vec4(colbuf);\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 234]], "test": "untested"}
{"id": "sdlSWl", "name": "Sizzling swamp", "author": "jarble", "description": "I adjusted the parameters of an \"infinite state\" automaton to make a swamp-like ecosystem. It looks even better in full-screen mode.", "tags": ["feedback", "cellularautomata", "swamp"], "likes": 10, "viewed": 281, "published": 3, "date": "1619470558", "time_retrieved": "2024-07-30T19:23:20.909691", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 4.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 0.11;\nconst float B = 0.80;\nconst float C = 2.5;\nconst float D = 1.0;\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = 1.0;\nconst float NUM_NEIGH = 9.0;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum += GET(d);\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL * (NUM_NEIGH + D) + B * ((C / NUM_NEIGH) * sum - C * cen) - sum;\n\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val = new_val;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 284]], "test": "untested"}
{"id": "fdlSDl", "name": "Cloudy crystal", "author": "mrange", "description": "License CC0: Cloudy crystal\nLate to the party I discovered: https://www.shadertoy.com/view/MtX3Ws\nPlayed around with it for a bit and thought it looked quite nice so I shared\n", "tags": ["raytracing", "crystal"], "likes": 133, "viewed": 2960, "published": 3, "date": "1619458567", "time_retrieved": "2024-07-30T19:23:21.685616", "image_code": "// License CC0: Cloudy crystal\n// Late to the party I discovered: https://www.shadertoy.com/view/MtX3Ws\n// Played around with it for a bit and thought it looked quite nice so I shared\n\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define L2(x)             dot(x, x)\n\n#define RAYSHAPE(ro, rd)  raySphere4(ro, rd, 0.5)\n#define IRAYSHAPE(ro, rd) iraySphere4(ro, rd, 0.5)\n\nconst float miss          = 1E4;\nconst float refrIndex     = 0.85;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\nconst vec3  skyCol1        = pow(vec3(0.2, 0.4, 0.6), vec3(0.25))*1.0;\nconst vec3  skyCol2        = pow(vec3(0.4, 0.7, 1.0), vec3(2.0))*1.0;\nconst vec3  sunCol         = vec3(8.0,7.0,6.0)/8.0;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Various ray object intersection from IQ:\n//  https://iquilezles.org/articles/intersectors\nfloat raySphere4(vec3 ro, vec3 rd, float ra) {\n    float r2 = ra*ra;\n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n    float ka = 1.0/dot(d2,d2);\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    float h = q*q - p*p*p;\n    if (h<0.0) return miss; //no intersection\n    float sh = sqrt(h);\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n    vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n    float r = length(v);\n    return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n}\n\nvec3 sphere4Normal(vec3 pos) {\n  return normalize( pos*pos*pos );\n}\n\nfloat iraySphere4(vec3 ro, vec3 rd, float ra) {\n  // Computes inner intersection by intersecting a reverse outer intersection\n  vec3 rro = ro + rd*ra*4.0;\n  vec3 rrd = -rd;\n  float rt = raySphere4(rro, rrd, ra);\n\n  if (rt == miss) return miss;\n  \n  vec3 rpos = rro + rrd*rt;\n  return length(rpos - ro);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 0.505));\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    float ts4 = RAYSHAPE(pos, ld);\n    vec3 spos = pos + ld*ts4;\n    float its4= IRAYSHAPE(spos, ld);\n    // Extremely fake soft shadows\n    float sha = ts4 == miss ? 1.0 : (1.0-1.0*tanh_approx(its4*1.5/(0.5+.5*ts4)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n// Marble fractal from https://www.shadertoy.com/view/MtX3Ws\nvec2 cmul(vec2 a, vec2 b) { \n  return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); \n}\n\nvec2 csqr(vec2 a) { \n  return vec2(a.x*a.x - a.y*a.y, 2.*a.x*a.y); \n}\n\nfloat marble_df(vec3 p) {  \n  float res = 0.;\n\n  vec3 c = p;\n  float scale = 0.72;\n  const int max_iter = 10;\n  for (int i = 0; i < max_iter; ++i) {\n    p    = scale*abs(p)/dot(p,p) - scale;\n    p.yz = csqr(p.yz);\n    p    = p.zxy;\n    res  += exp(-19. * abs(dot(p,c)));\n  }\n  return res;\n}\n\nvec3 marble_march(vec3 ro, vec3 rd, vec2 tminmax) {\n  float t   = tminmax.x;\n  float dt  = 0.02;\n  vec3 col  = vec3(0.0);\n  float c   = 0.;\n  const int max_iter = 64;\n  for(int i = 0; i < max_iter; ++i) {\n      t += dt*exp(-2.0*c);\n      if(t>tminmax.y) { \n        break; \n      }\n      vec3 pos = ro+t*rd;\n        \n      c = marble_df(ro+t*rd); \n      c *= 0.5;\n        \n      float dist = (abs(pos.x + pos.y-0.15))*10.0;\n      vec3 dcol = vec3(c*c*c-c*dist, c*c-c, c);\n      col = col + dcol;\n  }    \n  const float scale = 0.005;\n  float td = (t - tminmax.x)/(tminmax.y - tminmax.x);\n  col *= exp(-10.0*td);\n  col *= scale;\n  return col;\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 ipos = ro;\n  vec3 ird  = rd;\n  \n  float its4  = IRAYSHAPE(ipos, ird);\n  return marble_march(ipos, ird, vec2(0.0, its4));\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  float ts4 = RAYSHAPE(ro, rd);\n  if (ts4 < miss) {\n    t = ts4;\n    vec3 pos  = ro + ts4*rd;\n    vec3 nor  = sphere4Normal(pos);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = skyColor(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 4.0));\n\n    vec3 lv   = lightPos - pos;\n    float ll2 = L2(lv);\n    float ll  = sqrt(ll2);\n    vec3 ld   = lv / ll;\n\n    float dm  = min(1.0, 40.0/ll2);\n    float dif = pow(max(dot(nor,ld),0.0), 8.0)*dm;\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 100.);\n    float l   = dif;\n\n    float lin = mix(0.0, 1.0, l);\n    const vec3 lcol = 2.0*sqrt(sunCol);\n    col = render1(pos, refr);\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) { \n  vec3 ro = 0.6*vec3(2.0, 0, 0.2)+vec3(0.0, 0.75, 0.0);\n  ro.xz *= ROT(PI/2.0+sin(TIME*0.05));\n  ro.yz *= ROT(0.5+0.25*sin(TIME*0.05*sqrt(0.5))*0.5);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = 2.0;\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlSDl.jpg", "access": "api", "license": "cc0-1.0", "functions": [[845, 845, 873, 893, 969], [971, 1050, 1072, 1072, 1241], [1243, 1336, 1382, 1382, 2227], [2229, 2229, 2259, 2259, 2296], [2298, 2298, 2345, 2423, 2602], [2604, 2604, 2647, 2647, 2694], [2696, 2696, 2729, 2729, 3792], [3794, 3855, 3882, 3882, 3939], [3941, 3941, 3960, 3960, 4010], [4012, 4012, 4037, 4037, 4302], [4304, 4304, 4355, 4355, 4945], [4947, 4947, 4979, 4979, 5109], [5111, 5111, 5142, 5142, 6219], [6221, 6221, 6250, 6250, 6657], [6659, 6659, 6695, 6695, 6928], [6930, 6930, 6985, 6985, 7172]], "test": "ok"}
{"id": "sdXXDs", "name": "Nebula NGC 4262021-2", "author": "Leria", "description": "A nebula into a dark molecular cloud\n\nA+mouse: tune density   Z+mouse: camera distance\nB : change the background\nN : switch between different definition of multiplicative noise\nH : noise visualisation (tst)\nZ : zoom with mouse", "tags": ["fractal", "noise", "cloud", "nebula", "dust"], "likes": 3, "viewed": 441, "published": 3, "date": "1619453613", "time_retrieved": "2024-07-30T19:23:22.777696", "image_code": "// ==============================================================\n// Model and render nebula. see techreport Url: [soon]\n// Erwan Leria, 2020\n// Free for any use, just let my name appears or a link to this shader\n// ==============================================================\n\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n\n//Play with Nebula parameters !\nstruct Nebula\n{\n    vec3 pos;\n \tvec3 absorb_coef;\n    vec3 color;\n    float bubble_radius;\n};\n    \nNebula neb = Nebula(\n    \t\t\t\tvec3(0., 0., 0.) , //neb.pos\n    \t\t\t\tvec3(10., 20., 15.)/20.,  //nebabsorb_coef\n                    vec3(.4, .2, .1)/10.,\t//neb.color\n                    5. //\tneb.bubble_radius\n                   );\n\nvec3 cam_pos = vec3(0,0,3.); //towards 0 to zoom in\n\nfloat DISPERSION_VELOCITY =\t2.8;\n\n\n// --- noise parameters  --------------------------------------------\n\nfloat SCALE\t\t=\t4.; //Set noise max level of details in [1.,inf[ (max value recommended is 5. or 6.)\n\n//choose the nature of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n#define STRETCH\t\t \t\t1        // stretching\nvec3 stretching  = vec3( 1, 1, 1 );  // anisotropy\n\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n\n#define ANIM\t\t\t\t0    //animation 0 or 1\n#define RADIUS\t\t\t\t3.\n\n// --- dedicated noise utils ----------------------------------------\n\n#define GaussRand( rand1, rand2 ) \\\n    ( sqrt( - 2.*log(max(1e-5,rand1)) ) * vec2 ( cos( 6.28*(rand2) ),sin( 6.28*(rand2) ) ) )\n\n#define GaussNoise(p)  GaussRand( .5+.5*snoise(p), .5+.5*snoise(p+17.12) ).x\n\nfloat log_norm(float x, float mu, float sig)\n{\n    float ln_sqr = log((x+1e-5)-mu); //compute once the value\n    float r = (1./((x+1e-5 )*sig*2.51) )* ( exp( - (ln_sqr*ln_sqr)/(2.*sig*sig)  ) );\n \treturn (r<0.?0.:r) ;\n}\n\nfloat gaussian_distrib(float x, float mu, float s)\n{\n    float X = x-mu;\n    return (1./( s*2.51 )) * exp( - (X*X) / ( 2.*( s*s ) ) );\n}\n\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n//#define Psnoise(p)   2.*(  snoise(p) + 1. )\n//#define Psnoise(p)   max(0., 1. + 1.*GaussNoise(p) )\n//#define Psnoise(p)   max(0., .8 + 1.8*snoise(p) )\n\nfloat Psnoise1(vec3 p) {return ( 2.*( exp( snoise(p)) ) );  }\nfloat Psnoise2(vec3 p) {return  max(0., log_norm(snoise(p*10.), 0., 10.));}\nfloat Psnoise3(vec3 p) {return  max(0., 1. + .4*GaussNoise(p) ); }\n\n\nint selected_psnoise = 3; //Psnoise_i selector\n\nfloat Psnoise(vec3 p)\n{\n     return selected_psnoise == 3 ? Psnoise3(p)\n          : selected_psnoise == 2 ? Psnoise2(p)\n          :                          Psnoise1(p);\n}\n\n#define  rnd(v)     fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v)   ( 2.* rnd(v) - 1. )\n#define Bnoise(x)   abs(noise(x))\n\nfloat fbm_add( vec3 p, float level ) { // in [-1,1]\n    \n    float f = 0.;\n    vec3 s = vec3(2.);\n#if STRETCH\n   \tp *= stretching*  vec3(   1./8. );\n    s = 2./pow(stretching,vec3(1./4.));\n#endif\n    \n    for(float l = 0. ; l < level ; l++)\n    {\n     \tf += (1./exp2(l))*snoise(p);   p = p*s;\n    }\n    return f;\n}\n\nfloat fbm_mul( vec3 p, float level ) { // in [0,inf[\n    \n    float f = 1.;\n    vec3 s = vec3(2.);\n#if STRETCH\n   \tp *= stretching;\n   \ts = 2./pow(stretching,vec3(1./4.));\n#endif\n\n   \tfor(float i = 0. ; i < level ; i++)\n    {   _i = i;                      // for flownoise\n        f *= Psnoise(p); p = p*s;\n    }\n    return f;\n}\n\nfloat fbm(vec3 p, float level)\n{ \n#if ADDITIVE\n    return fbm_add(p, level);\n#else\n   \treturn fbm_mul(p, level);\n#endif   \n}\n\n// --- camera and nebula geometry -------------------------- \nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; // radius of bounding sphere of matter\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;    \n}\n\nvoid set_matter(vec3 pos, float radius)   { m = Matter(pos, radius); }\nvoid init_matter()                        { set_matter(vec3(0,0,0), RADIUS); }\n\n// --- position of light source\nvec3 lightpos = vec3(0); // or neb.pos\n\n\nfloat energy_t_r(vec3 p, float velocity, float typical_scale)\n{\n    float gas_dens = Psnoise(p*10.); //generation of a local dispersion = turbulence * rate\n    gas_dens +=  fbm(p*100., SCALE);\n \treturn gas_dens*.5*(velocity*velocity*velocity)/typical_scale;   \n}\n\nfloat local_velocity( float disp_rate)\n{\n\treturn 1.60*( DISPERSION_VELOCITY ) * disp_rate;  // $TUNE, 1.60 is a precomputed value\n}\n\n// --- main part: render nebula ------------------------------------\n// bounding sphere + volume marching\n\nfloat red_layer(float x)\n{\n    float tmp = (x-.9);\n    return 4.*exp( -(tmp*tmp)/(2.*0.016));\n}\n\nfloat green_layer(float x)\n{\n    float tmp = (x-.55);\n    return exp( -(tmp*tmp)/(2.*0.016));\n}\n\nfloat blue_layer(float x)\n{\n    float tmp = (x-.45);\n    return exp( -(tmp*tmp)/(2.*0.016));\n}\n\nfloat light_emission(float x)\n{\n    float tmp = (x-2.);\n    return 15.*exp( -(tmp*tmp)/(2.*2.));\n}\n\nfloat dynamic_dispersion(float x)\n{\n    float y = clamp( x, 0., 1./(neb.bubble_radius) );\n    float tmp = (y-2.);\n    return 1. - exp( -(tmp*tmp)/(2.*2.));\n}\n\n\n////////////////////////////////\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n   \n    float param_t = intersect_sphere(r, neb.pos, RADIUS); // test bounding sphere\n    if(param_t == -1.) return; // the ray miss the nebula bounding sphere\n\n    \n    if(param_t < 0.) param_t = 0.; // jump to the sphere intersection (skip the void), but if we are already inside\n    vec3  p = ray_interpolation(r, param_t + 1e-5);        \n    \n    float vt = -1.;         //value of the previous sample\n    \t\t\t\t\t\t//initializes the preintegration when >= 0         \n    \n    vec3 t_acc = vec3(1);\t// accumulated transparency\n    \n    if myKeyToggle(64+14) // key 'N' : switch multiplicative noise kind\n    {\n        selected_psnoise += 1;\n        if(selected_psnoise > 3) selected_psnoise = 0;\n    }\n            \n    for(int s=0; s < 120; s++)\n    {                 \n        vec3 center = p - neb.pos; //    \n        vec3 fromcam = cam.pos - p;\n        vec3 rgb_t = vec3(0);    // local transparency               \n               \n\n        //if we are no longer in the bounding sphere, stop marching the volume        \n\t\tif(length(fromcam) > length(cam.pos - neb.pos) + RADIUS) break;\n            // --- textured bubble model\n        float rad_bubl = neb.bubble_radius; // radius of bubble, also control the opening of the bubble                        \n \n\n        float dr = fbm_add( p*16. - 124.17, SCALE), //localy modify the radius of the bubble\n            de = fbm_add( p*4. - 98.12, SCALE ), //localy modify the thickness of the shell of the bubble\n\n        size = length(p-neb.pos)/RADIUS,\n            //mask of the bubble's shell\n            mask = smoothstep ( .1+1.2*de, .0, abs( ( length(p)-(rad_bubl))/rad_bubl  -3.8*dr )   ) ;\n\n        float dispersion_rate =  mask; \n\n        float velocity = local_velocity(dispersion_rate)  * dynamic_dispersion(100.*1./dot(center, center)) ; //local velocity (sometimes called sigma_v)\n\n        // physical value of the microstructures of the cloud\n        float scale = 10.;\n\n        //kinetic energy transfer rate as a dust grain density coefficient (transfer function)\n        //Astron Astrophys Rev (2012) 20:55DOI 10.1007/s00159-012-0055-yREVIEW ARTICLETurbulent molecular cloudsPatrick HennebelleEdith Falgarone p.21 & a27            \n        float TAU_PRIME = energy_t_r(p, velocity, scale); \n\n        //////////// PREINTEGRATION //////////////////////// \n        #define PREINTEGRATION\t1\n        //preintegration formula :\n        //https://www.researchgate.net/publication/2878658_High-Quality_Pre-Integrated_Volume_Rendering_Using_Hardware-Accelerated_Pixel_Shading            \n        #define TAU(d0, d1)\t( k*(Psnoise(p*10.) + fbm(p*10., SCALE)) * (INT_E(d1)-INT_E(d0))/(d1-d0) )\n\n        //primitive of the transfer function\n        #define INT_E(v)\t( (.125*(v*v*v*v))/(4.*scale) )   \n        /////////////////////////////////////////////////////\n\n        //ionization color on the rgb channels\n        vec3 colormap = clamp(vec3( red_layer(size), green_layer(size), blue_layer(size)), 0., 1.);\n\n        //Scattering coefficient\n        vec3 sigma_s = neb.color*colormap+1e-5;\n\n        //Absorption coefficient\n        vec3 absorption = neb.absorb_coef;\n\n        absorption *= exp( 5.*(myKeyParam(64+1)-.5) ); // key 'A'+mouse: tune overall opacity\n\n        //Attenuation coefficient\n        vec3 sigma_t = vec3(0);\n\n        if(vt == -1.) //if the value was not yet initialized, then initialize it doesn't use preintegration\n        {\n            sigma_t = (absorption)*TAU_PRIME;\n            vt = velocity+1e-5;  \n        }           \n\n        #if PREINTEGRATION\n        sigma_t = (absorption)*TAU(vt, velocity);\n        vt = velocity+1e-5;     \n        #else\n        sigma_t = (absorption)*TAU_PRIME;\n        #endif\n\n        rgb_t = exp(-sigma_t*k);    // <<< local transparency                                \n        // note that Dl = k has no unit  -> * coef to adapt\n\n\n        float epsilon = k;           // --- local lighting\n\n        lightpos = neb.pos;\n        vec3 L = normalize(p-lightpos);\n        // TAU_PRIME at neighbor location\n        #define nTAU(x,y,z) energy_t_r(p+epsilon*vec3(x,y,z), velocity , scale)\n\n        #if 1\n        vec3 N =   vec3( nTAU(1,0,0), nTAU(0,1,0), nTAU(0,0,1) )\n            - TAU_PRIME;\n        N = normalize(N+1e-5);\n        float dif = abs(dot(N, L));\n        #else\n        float dif = 2.*abs( nTAU(L.x,L.y,L.z) - TAU_PRIME ) / epsilon; // directional derivative https://iquilezles.org/articles/derivative\n        #endif\n\n        L = p-lightpos;\n        float l = length(L);\n        float sun = light_emission(l*l);\n        float shadow =  exp(- 1.*max(0., l  - (RADIUS) ) ) , // star illu: max at inner shell surface, then decay\n            //reflec = dif;                   // isotropic\n        reflec = 1.* ( 1. + dif*dif ); // Rayleigh phase function\n\n\n        // --- add current voxel contribution to ray\n        c += t_acc* (sigma_s/(sigma_t+1e-5) * reflec * sun * shadow) *  (1.-rgb_t);\n        t_acc *= rgb_t;    // accumulating the transparency of each voxel\n\n        \n        p += r.dir*k; //step to the next voxel according to the length of the sampling\n\n     //   k = uniform_step; //uniform step\n    }\n    \n    //output the transparency\n    transp_tot = t_acc;\n\n}\n\t\n// --- main ------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_matter();                        // --- init object and camera geometries\n\n    float z = 8.2 / (1.+ 2.*myKeyParam(64+26)); // key 'Z'+mouse: camera dist to nebula\n    set_camera(cam_pos, neb.pos); \n    time = iTime;              // for flownoise\n\n    //centering screen coordinates\n    vec2 R = iResolution.xy, \n        uv = (2.*fragCoord - R ) / R.y,\n        M =  iMouse.xy/R;\n\n    if myKeyToggle(64+8)                  // --- key 'H' : test noise \n    {\n        fragColor = vec4( fbm(vec3( uv, 1 )*40., 4.) );\n        return;\n    }\n\n    float degree = 2.*PI * M.x - PI;      // --- camera rotation: mouse or auto-rotation\n    float degree2 = 2.*PI * M.y - PI;\n    if ( iMouse.z<=0. || myKeyParam(0)>0. ) degree = iTime/2., degree2 = 0.;\n\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n\n    // vec2 m = 2.*PI * iMouse.xy/R - PI;\n    vec3 C = cam.pos, \n        ray = normalize(ray_dir);\n    C.xz *= rot2(degree);   C.yz *= rot2(degree2);\n    ray.xz *= rot2(degree); ray.yz *= rot2(degree2);\n    cam.pos = C;\n\n    // --- launch rendering\n    vec3     color = vec3(0), \n        transp_tot = vec3(1), \n        sky = vec3(0);             // set background \n    sky =   .5* texture(iChannel0,fragCoord/R+vec2(degree,degree2)).rrr;\n    if myKeyToggle(64+2) sky = vec3(1); //from black 2 white\n    \n\t//ray march the nebula\n    ray_march_scene(Ray(C, ray), .1, color, transp_tot);  \n\n    //rendering the background according to the pixel transparency\n    color += transp_tot * sky;\n    \n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.); //gamma colors rendered \n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// === utils ==============================\n\n#define PI \t\t\t\t\t3.1415926\n\n\n// --- keyboard ---------------------------\n\n// KeyParam(ascii) gives value of tuner #ascii\n// KeyToggle(ascii) gives toggle state for key #ascii\n// KeyParam(0) tells whether any key is currently pressed (e.g. to prevent mouse-move object) \n#define myKeyParam(ascii)    texelFetch( iChannel0, ivec2(ascii,0), 0 ).a \n#define myKeyToggle(ascii) ( texelFetch( iChannel0, ivec2(ascii+256,0), 0 ).a > .5 )\n\n\n\n// --- base noise -------------------------\n//most of \"noise stuff\" comes from iq\n\nfloat time, _i;            // for flownoise\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n    r -= .5;\n#if 0                             // flownoise. _i = perlin cascade level\n  //float t = time*exp2(_i)/256.;\n    float t =_i < 4. ? 0. : time/6.;\n    r.xy *= mat2( cos( 6.*t + vec4(0,11,33,0) ) );\n    r.yz *= mat2( cos( 4.7*t + vec4(0,11,33,0) ) );\n#endif\n\treturn r;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\tp  = -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return p;\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\n\n\n// --- geometric transformations ----------\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n// --- ray utils --------------------------\n\nstruct Ray\n{\n    vec3 origin; // origin\n    vec3 dir;    // direction of the ray\n};\n\nvec3 ray_interpolation(Ray r, float t)    { return (r.origin + r.dir*t);    }\n\n// Sphere intersection  distance ( or -1. if miss the sphere )\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.;\n\treturn -b - sqrt( h );\n}\n\n// Sphere SDF (for marching)\nfloat sdf_sphere(vec3 pXp0, float radius) { return (length(pXp0) - radius ); }\n", "buffer_a_code": "// === keyboard and sliders management ================\n\nvoid mainImage( out vec4 O, vec2 U )\n{    vec2 R = iResolution.xy; \n \n    // --- .rgb: backbround sky. [ do we really need to recompute this at every frame ? ]\n    \n    O = texture(iChannel1,U/256.); \n  //O = vec4( pow( O.r, 20. ) );             // BW stars\n  //O = pow( O, vec4(20) );                  // color stars\n    O *= pow( max(O.r,max(O.g,O.b)), 100.);  // faint color stats\n    \n    // --- .a: could be used to implement parameter persistant states ( for mouse or keyboard tuning ).\n    if (U.y>.5) return;\n \n    if (iFrame==0) {                         // init values\n        O.a = .5;\n                    \n    } else {                                 // tuning\n        O.a = texelFetch(iChannel0, ivec2(U), 0).a;\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n        \n        if (U.x<256.) {\n            if ( keyClick(U.x) && iMouse.z>0. )\n                O.a = iMouse.y/R.y; }        // tune value of parameter #ascii\n        else if(U.x<512.) \n            O.a = float(keyToggle(U.x-256.));// register the toggle on/off for #ascii\n       \n                                             // -> use KeyParam(ascii) to get it\n        if (U.x<1.) {                        //        KeyParam(0) tells where any key is used\n            O.a = 0.;\n            for (int i=0; i<256; i++) \n                if keyClick(i) { O.a = 1.; break; }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2121, 2121, 2167, 2167, 2340], [2342, 2342, 2394, 2394, 2478], [2723, 2723, 2747, 2747, 2784], [2785, 2785, 2809, 2809, 2860], [2861, 2861, 2885, 2885, 2927], [2978, 2978, 3001, 3001, 3149], [3297, 3297, 3335, 3348, 3611], [3613, 3613, 3651, 3665, 3942], [3944, 3944, 3976, 3976, 4068], [4442, 4442, 4482, 4482, 4532], [4534, 4534, 4577, 4577, 4604], [4605, 4605, 4648, 4648, 4683], [4758, 4758, 4821, 4821, 5020], [5022, 5022, 5062, 5062, 5153], [5262, 5262, 5288, 5288, 5357], [5359, 5359, 5387, 5387, 5454], [5456, 5456, 5483, 5483, 5550], [5552, 5552, 5583, 5583, 5650], [5652, 5652, 5687, 5687, 5809]], "test": "untested"}
{"id": "ssXXWs", "name": " - Test Glow", "author": "totetmatt", "description": "Testing glow.", "tags": ["glow"], "likes": 3, "viewed": 261, "published": 3, "date": "1619451127", "time_retrieved": "2024-07-30T19:23:23.541654", "image_code": "#define fGlobalTime iTime\nfloat g=0.;\nfloat box(vec3 p,vec3 b){\n  vec3 q = abs(p)-b;\n  return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat octa(vec3 p,float s){\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.577;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n  }\nfloat sdf(vec3 p){\n      \n       p.xz *=rot(fGlobalTime*.2);\n       p.xy *=rot(fGlobalTime*.2);\n   vec3 pp=p;\n       float d = octa(p,3.5);\n \n   \n      p = abs(p)-1.5;\n      for(float i=0.;i<=4.;i++){\n          p= abs(p)-.9;\n          p.xy*=1.2;\n      }\n      p.xz*=rot(-.785);\n      p.xy*=rot(-.785);\n      float e = octa(p,1.5+sin(fGlobalTime+length(pp.y)*2.)*.5+.5)/1.5;\n      d = max(-e,d);\n      p = abs(p)-0.95;\n      p.xz*=rot(-.785);\n      p.xy*=rot(-.785);\n      e = .5*octa(p,1.25);\n      d = max(-e,d);\n       \n      g += .7*(.02/(.3+sqrt(d)*d+sin(p.z*10.+fGlobalTime*10.)*.2));\n     \n    return d/3.5 ;\n}\nvec2 nv=vec2(-.0001,.0001);\n#define q(s) s*sdf(p+s)\nvec3 norm(vec3 p){\n  return normalize(\n      q(nv.xyy) + \n      q(nv.yxy) + \n      q(nv.yyx) + \n      q(nv.xxx) \n  );\n}\nvec3 pal(float t){\n  return .5+.5*cos(6.28*(1.*t+vec3(0.,.4,.6)));\n  }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n\tvec3 col = vec3(.1);\n  vec3 ro=vec3(0.,0.,-10.),rd=normalize(vec3(uv,1.)),rp=ro;\n  vec3 light=vec3(1.,2.,-3.);\n  for(float i=0.;i<=69.;i++){\n         float d = sdf(rp);\n         \n         if(d<=0.01) {\n            vec3 n = norm(rp);\n            col=vec3(1.)*max(0.,dot(normalize(light),n));\n            break;\n           \n         }\n         rp+=rd*d;\n \n  }\n  col += g*.5*vec3(.5,.1,.7);     \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXXWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 63, 63, 144], [145, 145, 163, 163, 210], [211, 211, 238, 238, 515], [516, 516, 534, 534, 1132], [1185, 1185, 1203, 1203, 1304], [1305, 1305, 1323, 1323, 1375], [1376, 1376, 1433, 1483, 1996]], "test": "untested"}
{"id": "7dXSWl", "name": "La drogue", "author": "rubix", "description": "I have no idea how this works", "tags": ["idk"], "likes": 2, "viewed": 268, "published": 3, "date": "1619448847", "time_retrieved": "2024-07-30T19:23:24.674624", "image_code": "// rubix 2021-04-27\n// based on Flopine's https://www.shadertoy.com/view/wlXBD4\n\n#define PI acos(-1.)\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec3 pal(float t, vec3 c) {return vec3(0.5)+vec3(0.5)*cos(2.*PI*(c*t+vec3(0.,0.34,0.66)));}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = mod(atan(p.y,p.x),per)-per*0.5;\n    p = vec2(cos(a),sin(a)) * length(p);\n}\n\nfloat sc(vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p, p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nfloat qsdfg(vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    moda(p.yz,3.);\n    \n    if (sin(iTime*0.15)>0.)\n        moda(p.yz,3.);\n    \n    float per = 10.;\n    float size = 3.;\n    p -= per * clamp(round(p/per),-size,size);\n\n    float it = (iTime-5.5)*0.3;\n    float t = mix(1.67, 2.68,\n        0.5+(3.*sin(it-PI)+sin(3.*it))/8.\n    );\n    \n    return max(-0.05, t - sc(p, 2.9));\n}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(qsdfg(p) - vec3(\n        qsdfg(p-eps.xyy),\n        qsdfg(p-eps.yxy),\n        qsdfg(p-eps.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(uv*15.,-50.),\n        rd = vec3(0.,0.,1.),\n        p = ro,\n        li = normalize(vec3(1.,2.,-1.)),\n        col = vec3(0.,0.,0.1);\n\n    bool hit = false; float d = 0.;\n    for (float i=0.; i<64.; i++)\n    {\n        d = qsdfg(p);\n        if (d<0.1)\n            break;\n        d = max(abs(d)-0.1,0.5);    ///////////\n        p += d*rd;\n    }\n    vec3 n = getnorm(p);        \n    float light = max(dot(n,li), 0.);\n    col = mix(vec3(0.,0.0,0.0),pal(length(p),vec3(.05)),light);\n    fragColor = vec4(sqrt(abs(col)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 121, 121, 164], [165, 165, 192, 192, 256], [258, 258, 294, 294, 412], [414, 414, 441, 441, 518], [520, 520, 541, 541, 929], [931, 931, 953, 953, 1103], [1105, 1105, 1160, 1160, 1842]], "test": "untested"}
{"id": "ssfSDl", "name": "angry goku v4", "author": "jorge2017a1", "description": "La tierra es destruida por freezer......y el dios de la destruccion y su ayudante wiss.....regresan el tiempo!!!!! :....goku esta muy molesto y enojado :)", "tags": ["angrygokuv4"], "likes": 5, "viewed": 272, "published": 3, "date": "1619445127", "time_retrieved": "2024-07-30T19:23:25.587184", "image_code": "//por jorge2017a1 ----jorgeFloresP---26/abril/2021\n// referencia\n//https://www.shadertoy.com/view/tlGBW3\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPoly17 POLY(17)\nvec2 pt17[ 17]=vec2[](  \nvec2(.10,1.00),vec2(.24,.32),vec2(.24,.29),vec2(.25,.28),vec2(.26,.26),\nvec2(.48,.01),vec2(.49,.00),vec2(.53,.01),vec2(.55,.03),vec2(.71,.21),\nvec2(.72,.22),vec2(.74,.24),vec2(.74,.26),vec2(.75,.30),vec2(.81,.56),\nvec2(.90,.99),vec2(.10,1.00) );\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.00,.09),vec2(.05,.17),vec2(.10,.23),vec2(.14,.27),vec2(.21,.33),\nvec2(.21,.12),vec2(.17,.06),vec2(.14,.00),vec2(.00,.00),vec2(.00,.09) );\n\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.00,.03),vec2(.04,.08),vec2(.09,.13),vec2(.15,.19),vec2(.19,.22),\nvec2(.21,.22),vec2(.20,.13),vec2(.14,.01),vec2(.00,.03) );\n\nfloat sdPoly11 POLY(11)\nvec2 pt11[ 11]=vec2[](  \nvec2(.78,.12),vec2(.78,.33),vec2(.83,.31),vec2(.89,.25),vec2(.95,.19),\nvec2(1.00,.13),vec2(1.00,.01),vec2(.86,.01),vec2(.83,.06),vec2(.79,.10),\nvec2(.78,.12) );\n\nfloat sdPoly11b POLY(11)\nvec2 pt11b[ 11]=vec2[](  \nvec2(.79,.24),vec2(.82,.23),vec2(.88,.18),vec2(.94,.14),vec2(1.00,.06),\nvec2(1.00,.01),vec2(.87,.01),vec2(.83,.05),vec2(.79,.11),vec2(.78,.12),\nvec2(.79,.24) );\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.22,.38),vec2(.21,.13),vec2(.14,.01),vec2(.86,.01),vec2(.78,.12),\nvec2(.78,.41),vec2(.22,.38) );\n\nfloat sdPoly13 POLY(13)\nvec2 pt13[ 13]=vec2[](  \nvec2(.11,.96),vec2(.07,.97),vec2(.05,.95),vec2(.04,.85),vec2(.05,.73),\nvec2(.06,.66),vec2(.09,.59),vec2(.13,.52),vec2(.17,.46),vec2(.18,.45),\nvec2(.19,.45),vec2(.21,.44),vec2(.11,.96) );\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.90,.99),vec2(.94,.99),vec2(.95,.98),vec2(.96,.93),vec2(.96,.86),\nvec2(.94,.75),vec2(.93,.67),vec2(.92,.61),vec2(.90,.58),vec2(.82,.45),\nvec2(.80,.44),vec2(.79,.44),vec2(.79,.45),vec2(.90,.99) );\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.19,.90),vec2(.21,.91),vec2(.23,.91),vec2(.25,.88),vec2(.36,.75),\nvec2(.44,.64),vec2(.45,.64),vec2(.46,.65),vec2(.47,.67),vec2(.46,.63),\nvec2(.45,.61),vec2(.42,.62),vec2(.34,.70),vec2(.28,.76),vec2(.25,.78),\nvec2(.22,.78),vec2(.19,.78),vec2(.19,.90) );\n\nfloat sdPoly22 POLY(22)\nvec2 pt22[ 22]=vec2[](  \nvec2(.52,.68),vec2(.53,.65),vec2(.53,.63),vec2(.54,.63),vec2(.57,.65),\nvec2(.61,.70),vec2(.68,.80),vec2(.73,.86),vec2(.78,.92),vec2(.80,.94),\nvec2(.82,.93),vec2(.82,.93),vec2(.83,.81),vec2(.82,.81),vec2(.79,.82),\nvec2(.77,.81),vec2(.71,.76),vec2(.61,.66),vec2(.58,.62),vec2(.56,.61),\nvec2(.53,.60),vec2(.52,.68) );\n\nfloat sdPoly13b POLY(13)\nvec2 pt13b[ 13]=vec2[](  \nvec2(.46,.26),vec2(.47,.27),vec2(.49,.28),vec2(.50,.28),vec2(.53,.28),\nvec2(.55,.26),vec2(.55,.26),vec2(.55,.27),vec2(.53,.28),vec2(.51,.29),\nvec2(.48,.29),vec2(.46,.27),vec2(.46,.26) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.51,.52),vec2(.50,.52),vec2(.49,.52),vec2(.49,.38),vec2(.49,.37),\nvec2(.50,.37),vec2(.51,.38),vec2(.51,.40),vec2(.51,.52) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.22,.78),vec2(.27,.76),vec2(.33,.72),vec2(.37,.67),vec2(.41,.64),\nvec2(.43,.62),vec2(.42,.60),vec2(.37,.60),vec2(.25,.61),vec2(.24,.67),\nvec2(.23,.74),vec2(.22,.78) );\n\nfloat sdPoly15b POLY(15)\nvec2 pt15b[ 15]=vec2[](  \nvec2(.57,.61),vec2(.62,.67),vec2(.67,.72),vec2(.73,.77),vec2(.77,.81),\nvec2(.77,.77),vec2(.76,.72),vec2(.75,.66),vec2(.74,.62),vec2(.68,.61),\nvec2(.62,.59),vec2(.60,.59),vec2(.58,.59),vec2(.58,.60),vec2(.57,.61) );\n\nfloat sdPoly11c POLY(11)\nvec2 pt11c[ 11]=vec2[](  \nvec2(.08,1.00),vec2(.15,1.00),vec2(.16,.95),vec2(.17,.87),vec2(.19,.78),\nvec2(.19,.78),vec2(.16,.80),vec2(.12,.84),vec2(.11,.86),vec2(.09,.91),\nvec2(.08,1.00) );\n\nfloat sdPoly6 POLY(6)\nvec2 pt6[ 6]=vec2[](  \nvec2(.16,1.00),vec2(.24,.83),vec2(.26,.82),vec2(.24,.90),vec2(.23,1.00),\nvec2(.16,1.00) );\n\nfloat sdPoly9c POLY(9)\nvec2 pt9c[ 9]=vec2[](  \nvec2(.29,1.00),vec2(.29,.94),vec2(.29,.86),vec2(.30,.79),vec2(.30,.78),\nvec2(.31,.84),vec2(.33,.91),vec2(.37,1.00),vec2(.29,1.00) );\n\nfloat sdPoly8 POLY(8)\nvec2 pt8[ 8]=vec2[](  \nvec2(.57,1.00),vec2(.52,.74),vec2(.53,.72),vec2(.56,.79),vec2(.64,.89),\nvec2(.71,.97),vec2(.76,1.00),vec2(.57,1.00) );\n\nfloat sdPoly8b POLY(8)\nvec2 pt8b[ 8]=vec2[](  \nvec2(.80,1.00),vec2(.77,.89),vec2(.86,.98),vec2(.85,.93),vec2(.82,.84),\nvec2(.90,.89),vec2(.95,.99),vec2(.80,1.00) );\n\nfloat sdPoly10b POLY(10)\nvec2 pt10b[ 10]=vec2[](  \nvec2(.21,.45),vec2(.00,.59),vec2(.00,1.00),vec2(.99,1.00),vec2(1.00,.60),\nvec2(.97,.58),vec2(1.00,.55),vec2(1.00,.42),vec2(.78,.38),vec2(.21,.45) );\n\nfloat sdPoly7b POLY(7)\nvec2 pt7b[ 7]=vec2[](  \nvec2(.25,.52),vec2(.33,.54),vec2(.40,.55),vec2(.44,.53),vec2(.46,.53),\nvec2(.38,.46),vec2(.25,.52) );\n\nfloat sdPoly7c POLY(7)\nvec2 pt7c[ 7]=vec2[](  \nvec2(.57,.53),vec2(.59,.54),vec2(.67,.56),vec2(.71,.56),vec2(.74,.55),\nvec2(.65,.47),vec2(.57,.53) );\n\nfloat sdPoly11d POLY(11)\nvec2 pt11d[ 11]=vec2[](  \nvec2(.48,.50),vec2(.45,.41),vec2(.45,.39),vec2(.48,.33),vec2(.50,.33),\nvec2(.53,.38),vec2(.51,.36),vec2(.51,.36),vec2(.48,.36),vec2(.48,.43),\nvec2(.48,.50) );\n\nfloat sdPoly16 POLY(16)\nvec2 pt16[ 16]=vec2[](  \nvec2(.47,.70),vec2(.46,.64),vec2(.46,.60),vec2(.46,.58),vec2(.48,.58),\nvec2(.50,.58),vec2(.52,.58),vec2(.53,.59),vec2(.52,.68),vec2(.52,.64),\nvec2(.52,.61),vec2(.52,.59),vec2(.48,.60),vec2(.47,.60),vec2(.47,.64),\nvec2(.47,.70) );\n\nfloat sdPoly4 POLY(4)\nvec2 pt4[ 4]=vec2[](  \nvec2(.22,.01),vec2(.28,.11),vec2(.30,.01),vec2(.22,.01) );\n\nfloat sdPoly4b POLY(4)\nvec2 pt4b[ 4]=vec2[](  \nvec2(.69,.01),vec2(.72,.12),vec2(.76,.02),vec2(.69,.01) );\n\nfloat sdPoly7d POLY(7)\nvec2 pt7d[ 7]=vec2[](  \nvec2(.47,.18),vec2(.50,.20),vec2(.52,.20),vec2(.54,.17),vec2(.52,.13),\nvec2(.49,.13),vec2(.47,.18) );\n\nfloat sdPoly7e POLY(7)\nvec2 pt7e[ 7]=vec2[](  \nvec2(.35,.70),vec2(.40,.64),vec2(.39,.62),vec2(.38,.61),vec2(.35,.63),\nvec2(.35,.66),vec2(.35,.70) );\n\nfloat sdPoly9d POLY(9)\nvec2 pt9d[ 9]=vec2[](  \nvec2(.59,.64),vec2(.62,.67),vec2(.65,.69),vec2(.65,.68),vec2(.65,.65),\nvec2(.63,.63),vec2(.62,.63),vec2(.60,.63),vec2(.59,.64) );\n\nfloat sdPoly19 POLY(19)\nvec2 pt19[ 19]=vec2[](  \nvec2(.07,.88),vec2(.06,.82),vec2(.07,.76),vec2(.07,.72),vec2(.07,.75),\nvec2(.09,.77),vec2(.10,.77),vec2(.12,.68),vec2(.14,.58),vec2(.15,.58),\nvec2(.17,.55),vec2(.17,.54),vec2(.20,.52),vec2(.17,.65),vec2(.14,.69),\nvec2(.14,.74),vec2(.12,.80),vec2(.10,.85),vec2(.07,.88) );\n\nfloat sdPoly23 POLY(23)\nvec2 pt23[ 23]=vec2[](  \nvec2(.84,.68),vec2(.86,.71),vec2(.86,.74),vec2(.86,.76),vec2(.86,.78),\nvec2(.88,.82),vec2(.90,.87),vec2(.91,.88),vec2(.92,.89),vec2(.93,.87),\nvec2(.93,.80),vec2(.91,.73),vec2(.91,.76),vec2(.91,.78),vec2(.90,.77),\nvec2(.90,.79),vec2(.88,.75),vec2(.88,.69),vec2(.87,.63),vec2(.85,.58),\nvec2(.84,.55),vec2(.80,.50),vec2(.84,.68) );\n\nfloat sdPoly12b POLY(12)\nvec2 pt12b[ 12]=vec2[](  \nvec2(.46,.24),vec2(.46,.27),vec2(.47,.28),vec2(.49,.29),vec2(.53,.29),\nvec2(.55,.28),vec2(.56,.25),vec2(.55,.23),vec2(.52,.23),vec2(.49,.23),\nvec2(.47,.23),vec2(.46,.24) );\n\nfloat sdPoly11e POLY(11)\nvec2 pt11e[ 11]=vec2[](  \nvec2(.46,.27),vec2(.47,.26),vec2(.50,.27),vec2(.53,.27),vec2(.55,.27),\nvec2(.55,.28),vec2(.54,.29),vec2(.51,.29),vec2(.48,.29),vec2(.47,.28),\nvec2(.46,.27) );\n\nvec3 RostroGokuv3(in vec2 pp, vec3 col) \n{\n  vec2 p=pp; //  p=p-vec2(0.0,-0.2);\n  float sd1 = sdPoly17(p, pt17);  //rostro\n  float sd2 = sdPoly10(p, pt10);\n  float sd3 = sdPoly9(p,pt9);\n  float sd4 = sdPoly11(p,pt11);\n  float sd5 = sdPoly11b(p,pt11b);\n  float sd6 = sdPoly7(p,pt7);\n  float sd7 = sdPoly13(p,pt13); //oreja\n  float sd8 = sdPoly14(p,pt14);\n  float sd9 = sdPoly18(p,pt18);\n  float sd10 = sdPoly22(p,pt22);\n  float sd11 = sdPoly13b(p,pt13b);\n  float sd12 = sdPoly9b(p,pt9b);\n  float sd13 = sdPoly12(p,pt12);\n  float sd14 = sdPoly15b(p,pt15b);\n  float sd15 = sdPoly11c(p,pt11c);\n  float sd16 = sdPoly6(p,pt6);\n  float sd17 = sdPoly9c(p,pt9c);\n  float sd18 = sdPoly8(p,pt8);\n  float sd19 = sdPoly8b(p,pt8b);\n  float sd20 = sdPoly10b(p,pt10b);\n  float sd21 = sdPoly7b(p,pt7b);\n  float sd22 = sdPoly7c(p,pt7c);\n  float sd23 = sdPoly11d(p,pt11d);\n  float sd24 = sdPoly16(p,pt16);\n  float sd25 = sdPoly4(p,pt4);\n  float sd26 = sdPoly4b(p,pt4b);\n  float sd27 = sdPoly7d(p,pt7d);\n  float sd28 = sdPoly7e(p,pt7e);\n  float sd29 = sdPoly9d(p,pt9d);\n  float sd30 = sdPoly19(p,pt19);\n  float sd31 = sdPoly23(p,pt23);\n  float sd32 = sdPoly12b(p,pt12b);\n  float sd33 = sdPoly11e(p,pt11e);\n  \n  col = mix(col,vec3(0.3),S(sd20,0.0)); //grande pelo  \n  col = mix(col,vec3(0.98,0.77,0.77),S(sd6,0.0));\n  col *= 1.0 - exp(-10.0*abs(sd1));\n  col = mix(col,vec3(1.00,0.77,0.78),S(sd1,0.0)); // rostro\n  col = mix(col,vec3(1.00,0.77,0.78),S(sd2,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd3,0.0)); //sobra musculo der\n  col = mix(col,vec3(1.00,0.77,0.78),S(sd4,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd5,0.0)); //sobra musculo izq\n  col = mix(col,vec3(1.00,0.77,0.78),S(sd7,0.0)); //oreja izq\n  col = mix(col,vec3(1.00,0.77,0.78),S(sd8,0.0)); //oreja der\n  col = mix(col,vec3(0.0),S(sd9,0.0)); //pestaa izq\n  col = mix(col,vec3(0.0),S(sd10,0.0)); //pestaa der\n  col = mix(col,vec3(0.0),S(sd11,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd12,0.0));//nariz\n  col = mix(col,vec3(1.0),S(sd13,0.0)); //ojo izq\n  col = mix(col,vec3(1.0),S(sd14,0.0)); //ojo der\n  col = mix(col,vec3(0.0),S(sd15,0.0)); //pelo gajo 1\n  col = mix(col,vec3(0.0),S(sd16,0.0)); //pelo gajo 2 //7:49\n  col = mix(col,vec3(0.0),S(sd17,0.0)); //pelo gajo 3\n  col = mix(col,vec3(0.0),S(sd18,0.0)); //pelo gajo 4\n  col = mix(col,vec3(0.0),S(sd19,0.0)); //pelo gajo 5\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd21,0.0));  //11:03\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd22,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd23,0.0));\n  col = mix(col,vec3(0.0),S(sd24,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd25,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd26,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd27,0.0));  //sombra\n  col = mix(col,vec3(0.0),S(sd28,0.0)); //ojo izq\n  col = mix(col,vec3(0.0),S(sd29,0.0)); //ojo der\n  col = mix(col,vec3(0.0),S(sd30,0.0)); //oreja lobulo izq\n  col = mix(col,vec3(0.0),S(sd31,0.0)); //oreja lobulo der\n  float t1=mod(iTime, 0.5);\n  float t2=mod(iTime, 1.0);\n  if (t1<t2)\n  {\n   col = mix(col,vec3(0.0),S(sd32,0.0)); // boca\n   col = mix(col,vec3(1.0),S(sd33,0.0));\n  }    \n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    vec2 p=uv+vec2(1.5,0.7);\n    p+=vec2(0.3,0.3);\n    p.x*=0.5;\n    p*=0.5+0.7*abs(sin(iTime*0.35));\n    vec3 col = 0.5 + 0.4*cos(iTime+uv.xyx+vec3(0,2,4));\n    col=vec3((col.x+col.y+col.z)/3.0)*vec3(0.2,0.2,1.0);\n    col= RostroGokuv3( p,col*2.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[7621, 7621, 7663, 7663, 10729], [10730, 10730, 10787, 10787, 11124]], "test": "untested"}
{"id": "7sfSWl", "name": "Nebula NGC 4262021", "author": "Leria", "description": "A+mouse: tune density   Z+mouse: camera distance\nB : change the background\nN : switch between different definition of multiplicative noise\nH : noise visualisation (tst)\nZ : zoom with mouse", "tags": ["fractal", "noise", "nebula", "toy"], "likes": 4, "viewed": 349, "published": 3, "date": "1619438100", "time_retrieved": "2024-07-30T19:23:26.539638", "image_code": "// ==============================================================\n// Model and render nebula. see techreport Url: [soon]\n// Erwan Leria, 2020\n// Free for any use, just let my name appears or a link to this shader\n// ==============================================================\n\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n\n//Play with Nebula parameters !\nstruct Nebula\n{\n    vec3 pos;\n \tvec3 absorb_coef;\n    vec3 color;\n    float bubble_radius;\n};\n    \nNebula neb = Nebula(\n    \t\t\t\tvec3(0, 0, 0.) , //neb.pos\n    \t\t\t\tvec3(15., 15., 15.),  //nebabsorb_coef\n                    vec3(1., .2, .2)/1.,\t//neb.color\n                    2.1 //\tneb.bubble_radius\n                   );\n\nvec3 cam_pos = vec3(0,0,10.); //towards 0 to zoom in\n\nfloat DISPERSION_VELOCITY =\t1.2;\n\n\n// --- noise parameters  --------------------------------------------\n\nfloat SCALE\t\t=\t4.; //Set noise max level of details in [1.,inf[ (max value recommended is 5. or 6.)\n\n//choose the nature of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n#define STRETCH\t\t \t\t1        // stretching\nvec3 stretching  = vec3( 1, 1, 1 );  // anisotropy\n\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////\n\n#define ANIM\t\t\t\t0    //animation 0 or 1\n#define RADIUS\t\t\t\t4.\n\n// --- dedicated noise utils ----------------------------------------\n\n#define GaussRand( rand1, rand2 ) \\\n    ( sqrt( - 2.*log(max(1e-5,rand1)) ) * vec2 ( cos( 6.28*(rand2) ),sin( 6.28*(rand2) ) ) )\n\n#define GaussNoise(p)  GaussRand( .5+.5*snoise(p), .5+.5*snoise(p+17.12) ).x\n\nfloat log_norm(float x, float mu, float sig)\n{\n    float ln_sqr = log((x+1e-5)-mu); //compute once the value\n    float r = (1./((x+1e-5 )*sig*2.51) )* ( exp( - (ln_sqr*ln_sqr)/(2.*sig*sig)  ) );\n \treturn (r<0.?0.:r) ;\n}\n\nfloat gaussian_distrib(float x, float mu, float s)\n{\n    float X = x-mu;\n    return (1./( s*2.51 )) * exp( - (X*X) / ( 2.*( s*s ) ) );\n}\n\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n//#define Psnoise(p)   2.*(  snoise(p) + 1. )\n//#define Psnoise(p)   max(0., 1. + 1.*GaussNoise(p) )\n//#define Psnoise(p)   max(0., .8 + 1.8*snoise(p) )\n\nfloat Psnoise1(vec3 p) {return ( 2.*( exp( snoise(p)) ) );  }\nfloat Psnoise2(vec3 p) {return  max(0., log_norm(snoise(p*10.), 0., 10.));}\nfloat Psnoise3(vec3 p) {return  max(0., 1. + .4*GaussNoise(p) ); }\n\n\nint selected_psnoise = 3; //Psnoise_i selector\n\nfloat Psnoise(vec3 p)\n{\n     return selected_psnoise == 3 ? Psnoise3(p)\n          : selected_psnoise == 2 ? Psnoise2(p)\n          :                          Psnoise1(p);\n}\n\n#define  rnd(v)     fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v)   ( 2.* rnd(v) - 1. )\n#define Bnoise(x)   abs(noise(x))\n\nfloat fbm_add( vec3 p, float level ) { // in [-1,1]\n    \n    float f = 0.;\n    vec3 s = vec3(2.);\n#if STRETCH\n   \tp *= stretching*  vec3(   1./8. );\n    s = 2./pow(stretching,vec3(1./4.));\n#endif\n    \n    for(float l = 0. ; l < level ; l++)\n    {\n     \tf += (1./exp2(l))*snoise(p);   p = p*s;\n    }\n    return f;\n}\n\nfloat fbm_mul( vec3 p, float level ) { // in [0,inf[\n    \n    float f = 1.;\n    vec3 s = vec3(2.);\n#if STRETCH\n   \tp *= stretching;\n   \ts = 2./pow(stretching,vec3(1./4.));\n#endif\n\n   \tfor(float i = 0. ; i < level ; i++)\n    {   _i = i;                      // for flownoise\n        f *= Psnoise(p); p = p*s;\n    }\n    return f;\n}\n\nfloat fbm(vec3 p, float level)\n{ \n#if ADDITIVE\n    return fbm_add(p, level);\n#else\n   \treturn fbm_mul(p, level);\n#endif   \n}\n\n\n// --- camera and nebula geometry -------------------------- \nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; // radius of bounding sphere of matter\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;    \n}\n\nvoid set_matter(vec3 pos, float radius)   { m = Matter(pos, radius); }\nvoid init_matter()                        { set_matter(vec3(0,0,0), RADIUS); }\n\n// --- position of light source\nvec3 lightpos = vec3(0); // or neb.pos\n\n\nfloat energy_t_r(vec3 p, float velocity, float typical_scale)\n{\n    float gas_dens = Psnoise(p*10.); //generation of a local dispersion = turbulence * rate\n    gas_dens +=  fbm(p*10., SCALE);\n \treturn gas_dens*.5*(velocity*velocity*velocity)/typical_scale;   \n}\n\nfloat local_velocity( float disp_rate)\n{\n\treturn 1.60*( DISPERSION_VELOCITY ) * disp_rate;  // $TUNE, 1.60 is a precomputed value\n}\n\n// --- main part: render nebula ------------------------------------\n// bounding sphere + volume marching\n\nfloat red_layer(float x)\n{\n    float tmp = (x-.75);\n    return 5.5*exp( -(tmp*tmp)/(2.*0.016));\n}\n\nfloat green_layer(float x)\n{\n    float tmp = (x-.5);\n    return exp( -(tmp*tmp)/(2.*0.016));\n}\n\nfloat blue_layer(float x)\n{\n    float tmp = (x-.25);\n    return exp( -(tmp*tmp)/(2.*0.016));\n}\n\nfloat light_emission(float x)\n{\n    float tmp = (x);\n    return 10.*exp( -(tmp*tmp)/(2.*4.));\n}\n\n////////////////////////////////\nvoid ray_march_scene(Ray r, float k, inout vec3 c, inout vec3 transp_tot)\n{\n    float uniform_step = k;\n   \n    float param_t = intersect_sphere(r, neb.pos, RADIUS); // test bounding sphere\n    if(param_t == -1.) return; // the ray miss the nebula bounding sphere\n\n    \n    if(param_t < 0.) param_t = 0.; // jump to the sphere intersection (skip the void), but if we are already inside\n    vec3  p = ray_interpolation(r, param_t + 1e-5);        \n    \n    float vt = -1.;         //value of the previous voxel\n    \t\t\t\t\t\t//initializes the preintegration when >= 0         \n    \n    vec3 t_acc = vec3(1);\t// accumulated transparency\n    \n    if myKeyToggle(64+14) // key 'N' : switch multiplicative noise kind\n    {\n        selected_psnoise += 1;\n        if(selected_psnoise > 3) selected_psnoise = 1;\n    }\n            \n    for(int s=0; s < 120; s++)\n    {                 \n        vec3 center = p - neb.pos; //    \n        vec3 fromcam = cam.pos - p;\n        vec3 rgb_t = vec3(0);    // local transparency               \n               \n\n        //if we are no longer in the bounding sphere, stop marching the volume        \n\t\tif(length(fromcam) > length(cam.pos - neb.pos) + RADIUS) break;\n            // --- textured bubble model\n        float rad_bubl = neb.bubble_radius; // radius of bubble, also control the opening of the bubble                        \n\n        float size = length(p-neb.pos)/RADIUS;\n\n        float dr = fbm_add( p*5.8 - 124.17, SCALE), //localy modify the radius of the bubble\n            de = noise( p - 98.12 ), //localy modify the thickness of the shell of the bubble\n\n            //mask of the bubble's shell\n            mask = smoothstep ( .2+.4*de, .0, abs( ( length(p)-(rad_bubl))/rad_bubl  -1.8*dr )   ) ;\n\n        float dispersion_rate =  mask; \n\n        float velocity = local_velocity(dispersion_rate); //local velocity (sometimes called sigma_v)\n\n        // physical value of the microstructures of the cloud\n        float scale = 10.;\n\n        //kinetic energy transfer rate as a dust grain density coefficient (transfer function)\n        //Astron Astrophys Rev (2012) 20:55DOI 10.1007/s00159-012-0055-yREVIEW ARTICLETurbulent molecular cloudsPatrick HennebelleEdith Falgarone p.21 & a27            \n        float TAU_PRIME = energy_t_r(p, velocity, scale); \n\n        //////////// PREINTEGRATION //////////////////////// \n        #define PREINTEGRATION\t1\n        //preintegration formula :\n        //https://www.researchgate.net/publication/2878658_High-Quality_Pre-Integrated_Volume_Rendering_Using_Hardware-Accelerated_Pixel_Shading            \n        #define TAU(d0, d1)\t( k*(Psnoise(p*10.) + fbm(p*10., SCALE)) * (INT_E(d1)-INT_E(d0))/(d1-d0) )\n\n        //primitive of the transfer function\n        #define INT_E(v)\t( (.125*(v*v*v*v))/(4.*scale) )   \n        /////////////////////////////////////////////////////\n\n        //ionization color on the rgb channels\n        vec3 colormap = clamp(vec3( red_layer(size), green_layer(size), blue_layer(size)), 0., 1.);\n\n        //Scattering coefficient\n        vec3 sigma_s = neb.color*colormap+1e-5;\n\n        //Absorption coefficient\n        vec3 absorption = neb.absorb_coef;\n\n        absorption *= exp( 5.*(myKeyParam(64+1)-.5) ); // key 'A'+mouse: tune overall opacity\n\n        //Attenuation coefficient\n        vec3 sigma_t = vec3(0);\n\n        if(vt == -1.) //if the value was not yet initialized, then initialize it doesn't use preintegration\n        {\n            sigma_t = (absorption)*TAU_PRIME;\n            vt = velocity+1e-5;  \n        }           \n\n        #if PREINTEGRATION\n        sigma_t = (absorption)*TAU(vt, velocity);\n        vt = velocity+1e-5;     \n        #else\n        sigma_t = (absorption)*TAU_PRIME;\n        #endif\n\n        rgb_t = exp(-sigma_t*k);    // <<< local transparency                                \n        // note that Dl = k has no unit  -> * coef to adapt\n\n\n        float epsilon = k;           // --- local lighting\n\n        lightpos = neb.pos;\n        vec3 L = normalize(p-lightpos);\n        // TAU_PRIME at neighbor location\n        #define nTAU(x,y,z) energy_t_r(p+epsilon*vec3(x,y,z), velocity , scale)\n\n        #if 1\n        vec3 N =   vec3( nTAU(1,0,0), nTAU(0,1,0), nTAU(0,0,1) )\n            - TAU_PRIME;\n        N = normalize(N+1e-5);\n        float dif = abs(dot(N, L));\n        #else\n        float dif = 2.*abs( nTAU(L.x,L.y,L.z) - TAU_PRIME ) / epsilon; // directional derivative https://iquilezles.org/articles/derivative\n        #endif\n\n        L = p-lightpos;\n        float l = length(L);\n        float sun = light_emission(l*l);\n        float shadow =  exp(- 1.*max(0., l  - (RADIUS) ) ) , // star illu: max at inner shell surface, then decay\n            reflec = dif;                   // isotropic\n        //reflec = .75* ( 1. + dif*dif ); // Rayleigh phase function\n\n\n        // --- add current voxel contribution to ray\n        c += t_acc* (sigma_s/(sigma_t+1e-5) * reflec * sun * shadow) *  (1.-rgb_t);\n        t_acc *= rgb_t;    // accumulating the transparency of each voxel\n\n        \n        p += r.dir*k; //step to the next voxel according to the length of the sampling\n\n     //   k = uniform_step; //uniform step\n    }\n    \n    //output the transparency\n    transp_tot = t_acc;\n\n}\n\t\n// --- main ------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_matter();                        // --- init object and camera geometries\n\n    float z = 8.2 / (1.+ 2.*myKeyParam(64+26)); // key 'Z'+mouse: camera dist to nebula\n    set_camera(cam_pos, neb.pos); \n    time = iTime;              // for flownoise\n\n    //centering screen coordinates\n    vec2 R = iResolution.xy, \n        uv = (2.*fragCoord - R ) / R.y,\n        M =  iMouse.xy/R;\n\n    if myKeyToggle(64+8)                  // --- key 'H' : test noise \n    {\n        fragColor = vec4( fbm(vec3( uv, 1 )*40., 4.) );\n        return;\n    }\n\n    float degree = 2.*PI * M.x - PI;      // --- camera rotation: mouse or auto-rotation\n    float degree2 = 2.*PI * M.y - PI;\n    if ( iMouse.z<=0. || myKeyParam(0)>0. ) degree = iTime/2., degree2 = 0.;\n\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n\n    // vec2 m = 2.*PI * iMouse.xy/R - PI;\n    vec3 C = cam.pos, \n        ray = normalize(ray_dir);\n    C.xz *= rot2(degree);   C.yz *= rot2(degree2);\n    ray.xz *= rot2(degree); ray.yz *= rot2(degree2);\n    cam.pos = C;\n\n    // --- launch rendering\n    vec3     color = vec3(0), \n        transp_tot = vec3(1), \n        sky = vec3(0);             // set background \n    sky =   .5* texture(iChannel0,fragCoord/R+vec2(degree,degree2)).rrr;\n    if myKeyToggle(64+2) sky = vec3(1); //from black 2 white\n    \n\t//ray march the nebula\n    ray_march_scene(Ray(C, ray), .1, color, transp_tot);  \n\n    //rendering the background according to the pixel transparency\n    color += transp_tot * sky;\n    \n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.); //gamma colors rendered \n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// === utils ==============================\n\n#define PI \t\t\t\t\t3.1415926\n\n\n// --- keyboard ---------------------------\n\n// KeyParam(ascii) gives value of tuner #ascii\n// KeyToggle(ascii) gives toggle state for key #ascii\n// KeyParam(0) tells whether any key is currently pressed (e.g. to prevent mouse-move object) \n#define myKeyParam(ascii)    texelFetch( iChannel0, ivec2(ascii,0), 0 ).a \n#define myKeyToggle(ascii) ( texelFetch( iChannel0, ivec2(ascii+256,0), 0 ).a > .5 )\n\n\n\n// --- base noise -------------------------\n//most of \"noise stuff\" comes from iq\n\nfloat time, _i;            // for flownoise\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n    r -= .5;\n#if 0                             // flownoise. _i = perlin cascade level\n  //float t = time*exp2(_i)/256.;\n    float t =_i < 4. ? 0. : time/6.;\n    r.xy *= mat2( cos( 6.*t + vec4(0,11,33,0) ) );\n    r.yz *= mat2( cos( 4.7*t + vec4(0,11,33,0) ) );\n#endif\n\treturn r;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\tp  = -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    return p;\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat cloud( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0);\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\n\n\n// --- geometric transformations ----------\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n// --- ray utils --------------------------\n\nstruct Ray\n{\n    vec3 origin; // origin\n    vec3 dir;    // direction of the ray\n};\n\nvec3 ray_interpolation(Ray r, float t)    { return (r.origin + r.dir*t);    }\n\n// Sphere intersection  distance ( or -1. if miss the sphere )\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.;\n\treturn -b - sqrt( h );\n}\n\n// Sphere SDF (for marching)\nfloat sdf_sphere(vec3 pXp0, float radius) { return (length(pXp0) - radius ); }\n", "buffer_a_code": "// === keyboard and sliders management ================\n\nvoid mainImage( out vec4 O, vec2 U )\n{    vec2 R = iResolution.xy; \n \n    // --- .rgb: backbround sky. [ do we really need to recompute this at every frame ? ]\n    \n    O = texture(iChannel1,U/256.); \n  //O = vec4( pow( O.r, 20. ) );             // BW stars\n  //O = pow( O, vec4(20) );                  // color stars\n    O *= pow( max(O.r,max(O.g,O.b)), 100.);  // faint color stats\n    \n    // --- .a: could be used to implement parameter persistant states ( for mouse or keyboard tuning ).\n    if (U.y>.5) return;\n \n    if (iFrame==0) {                         // init values\n        O.a = .5;\n                    \n    } else {                                 // tuning\n        O.a = texelFetch(iChannel0, ivec2(U), 0).a;\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n        \n        if (U.x<256.) {\n            if ( keyClick(U.x) && iMouse.z>0. )\n                O.a = iMouse.y/R.y; }        // tune value of parameter #ascii\n        else if(U.x<512.) \n            O.a = float(keyToggle(U.x-256.));// register the toggle on/off for #ascii\n       \n                                             // -> use KeyParam(ascii) to get it\n        if (U.x<1.) {                        //        KeyParam(0) tells where any key is used\n            O.a = 0.;\n            for (int i=0; i<256; i++) \n                if keyClick(i) { O.a = 1.; break; }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfSWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2116, 2116, 2162, 2162, 2335], [2337, 2337, 2389, 2389, 2473], [2718, 2718, 2742, 2742, 2779], [2780, 2780, 2804, 2804, 2855], [2856, 2856, 2880, 2880, 2922], [2973, 2973, 2996, 2996, 3144], [3292, 3292, 3330, 3343, 3606], [3608, 3608, 3646, 3660, 3937], [3939, 3939, 3971, 3971, 4063], [4438, 4438, 4478, 4478, 4528], [4530, 4530, 4573, 4573, 4600], [4601, 4601, 4644, 4644, 4679], [4754, 4754, 4817, 4817, 5015], [5017, 5017, 5057, 5057, 5148], [5257, 5257, 5283, 5283, 5354], [5356, 5356, 5384, 5384, 5450], [5452, 5452, 5479, 5479, 5546], [5548, 5548, 5579, 5579, 5643]], "test": "untested"}
{"id": "NsfXWs", "name": "AntoineC paper pattern", "author": "FabriceNeyret2", "description": "extracting and refactoring the paper layer in AntoineC's \"Moving cutouts 2\" [url]https://shadertoy.com/view/wd3yzf[/url]\nStrips = different zooms\nVertical = lighting angle ( + time for direction ).", "tags": ["pattern", "paper", "minimalist"], "likes": 14, "viewed": 463, "published": 3, "date": "1619426063", "time_retrieved": "2024-07-30T19:23:27.440230", "image_code": "// extracting and refactoring the paper layer in \"Moving cutouts 2\" by AntoineC. https://shadertoy.com/view/wd3yzf\n\n#define T(U, x,y)   texture(iChannel0, (U) * vec2(x,y) ).r\n\n#define Paper(U)  ( .7* ( T(U,2,.02) * T(U,.02,2.) ) + T(U,1,1) )  // --- paper texture\n\n\nvec3 Bump(vec2 U, float s )  // scaling s                          // --- bump of texture\n{\n   U *= s;\n   float h = Paper(U);\n   \n#if 0                                       // hardware derivative ok for scaling s <= .5\n\n    return normalize( vec3( dFdx(h), dFdy(h), 7.5 ) ); \n\n#else                                       // use manual derivative for scaling s >= .5\n\n   vec2 e = vec2(dFdx(U.x),0);\n   return normalize ( vec3( Paper(U-e) - h , Paper(U-e.yx) - h , 7.5 ) );\n\n#endif \n}\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\n\tvec2  R = iResolution.xy,\n          U = ( u - .5*R ) / R.y; \n    float t = 2.*iTime, \n          s = exp2( floor(-U.x*4.)/4. ),  // scaling \n          a = .2+(.5+U.y);\n\n    O = 1.05 * vec4( dot( Bump(U, s), vec3(cos(t)*cos(a), sin(t)*cos(a), sin(a) ) ) );\n    if ( fract(U.x*4.) < 4./R.y ) O = vec4(1,0,0,0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfXWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 357, 357, 749], [752, 752, 790, 790, 1102]], "test": "untested"}
{"id": "fsfSWs", "name": "Quadratic Bezier to Parabola", "author": "oneshade", "description": "Distance to quadratic bezier by mapping it to a parabola. Using @iq's parabola distance function. Clamping bounds seems to be trickier since the parameter space is different.", "tags": ["2d", "bezier", "mapping", "quadratic", "parabola"], "likes": 5, "viewed": 212, "published": 3, "date": "1619420479", "time_retrieved": "2024-07-30T19:23:28.202193", "image_code": "float sdBezier(in vec2 pos, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 v = a - 2.0 * b + c, ab = a - b; float d = v.y / v.x;\n    float infl = (d * ab.y + ab.x) / (v.x + d * v.y);\n\n    float inflInv = 1.0 - infl;\n    vec2 offs = a * inflInv * inflInv + b * 2.0 * inflInv * infl + c * infl * infl;\n\n    vec2 right = normalize(a * (infl - 1.0) + (1.0 - 2.0 * infl) * b + c * infl);\n    mat2 basis = mat2(right, -right.y, right.x);\n\n    a -= offs, c -= offs;\n    vec2 bt = vec2(dot(a, basis[0]), dot(c, basis[0])); // How to apply these clamping bounds?\n    float k = dot(a, basis[1]) / (bt.x * bt.x), ik = 1.0 / k;\n\n    pos = (pos - offs) * basis;\n    pos.x = abs(pos.x);\n\n    float p = ik * (pos.y - 0.5 * ik) / 3.0;\n    float q = 0.25 * ik * ik * pos.x;\n    float h = q * q - p * p * p;\n    float r = sqrt(abs(h));\n\n    float x = h > 0.0 ? pow(q + r,1.0 / 3.0) - pow(abs(q - r), 1.0 / 3.0) * sign(r - q) : 2.0 * cos(atan(r, q) / 3.0) * sqrt(p);\n    return length(pos - vec2(x, k * x * x));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    // Control points\n    vec2 a = vec2(-0.5, 0.0);\n    vec2 b = iMouse.z > 0.0 ? mouse : vec2(0.0, 0.4);\n    vec2 c = vec2(0.3, -0.4);\n\n    // Distance\n    float d = sdBezier(uv, a, b, c) * 2.0;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\n    // Lines between control points\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, sdLine(uv, a, b) - 0.002));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, sdLine(uv, b, c) - 0.002));\n\n    // Bezier curve\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(d * 0.5) - 0.002));\n\n    // Control points\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - a) - 0.015));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, length(uv - b) - 0.015));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - c) - 0.015));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfSWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 991], [993, 993, 1040, 1040, 1148], [1150, 1150, 1205, 1205, 2405]], "test": "untested"}
{"id": "NdfXDl", "name": "interactive nyanbrot zoomer", "author": "sh1boot", "description": "It's the Mandelbrot set, but with cats.  Click to zoom, cursor keys to pan.", "tags": ["mandelbrot", "nyancat", "stateful", "df64"], "likes": 7, "viewed": 355, "published": 3, "date": "1619414690", "time_retrieved": "2024-07-30T19:23:28.968145", "image_code": "FLOAT getParam(int i) {\n   return unpack(texelFetch(iChannel0, ivec2(i, 0), 0));\n}\n\n\nvec4 img(vec2 c, float off) {\n    c = clamp(c * 1.0 + vec2(0.5, 0.6), vec2(0.0), vec2(1.0));\n    float t = floor(fract(iTime * 4.0 + off) * 6.0);\n    c.x = (fract(c.x) + t) * 40.0 / 256.0;\n    return texture(iChannel1, c);\n}\n\n\nvec4 brot(FLOAT cx, FLOAT cy, float junk) {\n    float iter = 0.0;\n    FLOAT zx = cx;\n    FLOAT zy = cy;\n    vec4 colour = vec4(0.0);\n    for (int i = 0; i < 512; ++i) {\n        FLOAT tx = add(mul(zx, zx, junk), -mul(zy, zy, junk), junk);\n        FLOAT ty = mul(mul(zx, zy, junk), 2.0, junk);\n        zx = add(tx, cx, junk);\n        zy = add(ty, cy, junk);\n        if (i >= 30 && (i & 1) == 0) {\n          vec2 p = vec2(zx.x, zy.x);\n          if ((i & 2) == 0) p = p.yx;\n          if ((i & 4) == 0) p.y = -p.y;\n          if ((i & 8) == 0) p.x = -p.x;\n          vec4 tex = img(p, float(i) / 7.0);\n          if ((i % 3) == 1) tex = tex.rbga;\n          colour = mix(tex, colour, colour.a);\n          if (colour.a > 0.95) return colour;\n       }\n       if (lensquare(zx, zy, junk) > 4.0) break;\n       iter = iter + 1.0;\n    }\n    if (iter >= 511.0) return vec4(0.0, 0.0, 0.0, 0.0);\n\n//    return colour;\n\n    return vec4(0.5 + 0.5 * cos(3.0 + iter * 0.15 + vec3(0.0, 0.6, 1.0)), 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float junk = make_junk(iTime);\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    FLOAT cx = getParam(0);\n    FLOAT cy = getParam(1);\n    FLOAT zoom = getParam(2);\n    \n    cx = add(cx, mul(zoom, uv.x, junk), junk);\n    cy = add(cy, mul(zoom, uv.y, junk), junk);\n\n    fragColor = brot(cx, cy, junk);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if 0\n#define FLOAT float\nvec4 pack(FLOAT f) {\n    return vec4(f, 0.0, 0.0, 0.0);\n}\nFLOAT unpack(vec4 v) {\n    return v.x;\n}\nFLOAT toFLOAT(float x) {\n    return x;\n}\nFLOAT mul(FLOAT a, FLOAT b, float junk) {\n    return a * b;\n}\n\nFLOAT add(FLOAT a, FLOAT b, float junk) {\n    return a + b;\n}\nfloat lensquare(FLOAT a, FLOAT b, float junk) {\n    return mul(a, a, junk) + mul(b, b, junk);\n}\n// make a value of junk that works for the functions above.\nfloat make_junk(float a_positive_variable) {\n   return 0.0;\n}\n#else\n#define FLOAT vec4\nvec4 pack(FLOAT f) {\n    return f;\n}\nFLOAT unpack(vec4 v) {\n    return v;\n}\nFLOAT toFLOAT(float x) {\n    return vec4(x, 0.0, 0.0, 0.0);\n}\n\n// force the computation of x without optimisation, by making it depend on junk.\nfloat final(float x, float junk) {\n    return x + junk;\n}\n\nvec2 final(vec2 x, float junk) {\n    return x + junk;\n}\n\n// make a value of junk that works for the functions above.\nfloat make_junk(float a_positive_variable) {\n   return 1.0 - step(0.0, a_positive_variable);\n}\n\n// from: http://andrewthall.org/papers/df64_qf128.pdf\nvec2 quickTwoSum(float a, float b, float junk) {\n    float s = final(a + b, junk);\n    float e = b - (s - a);\n    return vec2(s, e);\n}\nvec2 twoSum(float a, float b, float junk) {\n    float s = final(a + b, junk);\n    float v = s - a;\n    float e = (a - (s - v)) + (b - v);\n    return vec2(s, e);\n}\nvec4 twoSumComp(vec2 a, vec2 b, float junk) {\n    vec2 s = final(a + b, junk);\n    vec2 v = s - a;\n    vec2 e = (a - (s - v)) + (b - v);\n    return vec4(s.x, e.x, s.y, e.y);\n}\nvec2 df64_add(vec2 a, vec2 b, float junk) {\n    vec4 sum = twoSumComp(a, b, junk);\n    vec2 s = sum.xy;\n    vec2 t = sum.wz;\n    s.y += t.x;\n    s = quickTwoSum(s.x, s.y, junk);\n    s.y += t.y;\n    s = quickTwoSum(s.x, s.y, junk);\n    return s;\n}\nvec2 split(float a, float junk) {\n    const float split = 4097.0;\n    float t = a * split;\n    float a_hi = t - final(t - a, junk);\n    float a_lo = a - a_hi;\n    return vec2(a_hi, a_lo);\n}\nvec4 splitComp(vec2 c, float junk) {\n    const float split = 4097.0;\n    vec2 t = c * split;\n    vec2 c_hi = t - final(t - c, junk);\n    vec2 c_lo = c - c_hi;\n    return vec4(c_hi.x, c_lo.x, c_hi.y, c_lo.y);\n}\n\nvec2 twoProd(float a, float b, float junk) {\n#if 1  // yes fma\n    float p = a * b;\n    float err = a * b - p;\n#else  // no fma\n    float p = a * b;\n    vec4 split = splitComp(vec2(a, b), junk);\n    vec2 aS = split.xy;\n    vec2 bS = split.wz;\n    float err = ((aS.x * bS.x - p)\n                 + aS.x * bS.y + aS.y * bS.x)\n                + aS.y * bS.y;\n#endif\n     return vec2(p, err);\n}\nvec2 df64_mult(vec2 a, vec2 b, float junk) {\n    vec2 p;\n\n    p = twoProd(a.x, b.x, junk);\n    p.y += a.x * b.y;\n    p.y += a.y * b.x;\n    p = quickTwoSum(p.x, p.y, junk);\n    return p;\n}\nvec2 df64_mult(vec2 a, float b, float junk) {\n    vec2 p;\n\n    p = twoProd(a.x, b, junk);\n    p.y += a.y * b;\n    p = quickTwoSum(p.x, p.y, junk);\n    return p;\n}\n\nFLOAT mul(FLOAT a, FLOAT b, float junk) {\n    return vec4(df64_mult(a.xy, b.xy, junk), 0.0, 0.0);\n}\nFLOAT mul(FLOAT a, float b, float junk) {\n    return vec4(df64_mult(a.xy, b, junk), 0.0, 0.0);\n}\nFLOAT add(FLOAT a, FLOAT b, float junk) {\n    return vec4(df64_add(a.xy, b.xy, junk), 0.0, 0.0);\n}\nfloat lensquare(FLOAT a, FLOAT b, float junk) {\n    return mul(a, a, junk).x + mul(b, b, junk).x;\n}\n#endif", "buffer_a_code": "FLOAT getParam(int i) {\n   return unpack(texelFetch(iChannel0, ivec2(i, 0), 0));\n}\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\nconst int KEY_HOME  = 36;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float junk = make_junk(iTime);\n    vec2 mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    int p = int(fragCoord.x);\n    FLOAT f = getParam(p);\n    FLOAT zoom = getParam(2);\n\n    int pluskey = 0;\n    int minuskey = 0;\n    FLOAT reset = toFLOAT(0.0);\n    FLOAT incr = mul(zoom, 0.025, junk);\n    float m = 0.0;\n\n    switch (p) {\n    case 0:\n        reset = toFLOAT(-0.75);\n        pluskey = KEY_RIGHT;\n        minuskey = KEY_LEFT;\n        m = mouse.x;\n        break;\n\n    case 1:\n        reset = toFLOAT(0.0);\n        pluskey = KEY_UP;\n        minuskey = KEY_DOWN;\n        m = mouse.y;\n        break;\n\n    case 2:\n        reset = toFLOAT(1.25);\n        pluskey = KEY_PGDN;\n        minuskey = KEY_PGUP;\n        break;\n    }\n\n    if (texelFetch(iChannel1, ivec2(KEY_HOME, 0), 0).x > .5 || iFrame < 1)\n        f = reset;\n    if (texelFetch(iChannel1, ivec2(pluskey, 0), 0).x > .5)\n        f = add(f, incr, junk);\n    if (texelFetch(iChannel1, ivec2(minuskey, 0), 0).x > .5)\n        f = add(f, -incr, junk);\n\n    if (iMouse.z > 0.0) {\n        f = add(f, mul(zoom, m, junk), junk);\n        zoom = mul(zoom, 0.975, junk);\n        f = add(f, -mul(zoom, m, junk), junk);\n        if (p == 2) f = zoom;\n    }\n\n    fragColor = pack(f);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 82], [85, 85, 114, 114, 309], [312, 312, 355, 355, 1294], [1297, 1297, 1354, 1354, 1680]], "test": "untested"}
{"id": "NdXXDl", "name": "Randomized infinite state CA", "author": "jarble", "description": "This \"infinite state\" cellular automaton has some random noise added with each iteration.", "tags": ["feedback", "cellularautomata"], "likes": 7, "viewed": 262, "published": 3, "date": "1619409367", "time_retrieved": "2024-07-30T19:23:29.729110", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 4.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 0.11;\nconst float B = 0.80;\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = 1.0;\nconst float NUM_NEIGH = 9.0;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum += GET(d);\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL * (NUM_NEIGH + 1.0) + B * ((2.0 / NUM_NEIGH) * sum - 2.0 * cen) - sum;\n\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val = new_val;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val;\n        fragColor.x += (noise(fragCoord/res)-.5)/5000.0;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXXDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 284]], "test": "untested"}
{"id": "NdS3Rc", "name": "sierpinski - Distance function", "author": "nbardy", "description": "A sierpinski pyramid and its inverse as distance functions", "tags": ["3d", "sdf", "distance", "piramid"], "likes": 2, "viewed": 251, "published": 3, "date": "1619407446", "time_retrieved": "2024-07-30T19:23:30.535953", "image_code": "// Fork of \"Pyramid - distance\" by iq. https://shadertoy.com/view/Ws3SDl\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec3 fold(vec3 p) { \n    return vec3(abs(p.x),p.y, abs(p.z));\n}\n\nfloat sdPyramid(in vec3 p, float h) {\n    vec3 top = vec3(0.0);   \n    //base if above the point\n    vec3 base = top + vec3(0.0,h,0.0);\n    float epsilon = 0.0001;\n    vec3 corner ;\n    vec3 cornerx;\n    vec3 cornerz;\n    \n    float final = 100.0;\n    p = fold(p);\n\n        corner = vec3(base.x + h/2.0, base.y, base.z + h/2.0);\n        cornerx = vec3(base.x - h/2.0, base.y, base.z + h/2.0);\n        cornerz = vec3(base.x + h/2.0, base.y, base.z - h/2.0);\n        float d1 = sdTriangle(p.xy, top.xy, cornerx.xy, corner.xy);\n        float d2 = sdTriangle(p.zy, top.zy, cornerz.zy, corner.zy);\n        float d = max(d1, d2);\n        \n        return d;\n\n}\n float D = 4.0;\n \n// calc normal\n// signed distance to a pyramid of base 1x1 and height h\n\n// TO speed up:\n// replace sdtriangle with wave functions.\nvec4 sdSerp( in vec3 p, in float h )\n{\n    vec3 top = vec3(0.0);   \n    //base if above the point\n    vec3 base = top + vec3(0.0,h,0.0);\n    float epsilon = 0.0001;\n    vec3 corner ;\n    vec3 cornerx;\n    vec3 cornerz;\n    vec3 norm;\n    \n    float d1;\n    float d2;\n    \n    float final = 100.0;\n    vec3 prefold = p;\n    p = fold(p);\n    for(float i = 0.0;  i < D; i++) {\n        float h2 = h/2.0 + 0.;\n        corner = vec3(base.x + h2, base.y, base.z + h2);\n        cornerx = vec3(base.x - h2, base.y, base.z + h2);\n        cornerz = vec3(base.x + h2, base.y, base.z - h2);\n        d1 = sdTriangle(p.xy, top.xy, cornerx.xy, corner.xy);\n        d2 = sdTriangle(p.zy, top.zy, cornerz.zy, corner.zy);\n        float d = max(d1, d2);\n        \n        if( d > epsilon) { \n            return vec4(d, vec3(0.0));\n        }\n        \n        float topd = length(p-top);\n        float cornerd = length(p-corner);\n        \n        final = min(final,d);\n            // calc normal\n        if(final < 0.0001) {\n             if(abs(p.y-base.y)- 0.00005 < 0.0001 ) {\n               norm = vec3(0.0,1.0,0.0);              \n              } else {\n              if(p.x > p.z) {\n                  norm = normalize(vec3(sign(prefold.x)*1.0,-1., 0.));          \n              } else {\n                  norm = normalize(vec3(0.0,-1.0,sign(prefold.z)*1.0));\n              }\n           }\n        }\n         \n        // TODO matmin instead of if\n        if( topd < cornerd) {\n           top = top;\n           h /= 2.0;\n           base = top + vec3(0.0,h,0.0);\n        } else {\n           h /= 2.0;\n           top = top + vec3(h/2.0, h, h/2.0);\n           base = top + vec3(0.0,h,0.0);\n           \n           p = fold(p - top) + top;\n        }\n        \n        \\\n        prefold = p;\n    }\n    \n    return vec4(final, norm);\n    \n\n}\n\n// sierpinski inverted\nvec4 sdSerpInv( in vec3 p, in float h )\n{\n    vec3 top = vec3(0.0);   \n    //base if above the point\n    vec3 base = top + vec3(0.0,h,0.0);\n    float epsilon = 0.0001;\n    vec3 corner ;\n    vec3 cornerx;\n    vec3 cornerz;\n    vec3 norm;\n    \n    float d1;\n    float d2;\n    \n    float final = 100.0;\n    vec3 prefold = p;\n    p = fold(p);\n    for(float i = 0.0;  i < D; i++) {\n        float h2 = h/2.0 + 0.;\n        float h4 = h2/2.0;\n        \n        corner = vec3(base.x + h2, base.y, base.z + h2);\n        vec3 base2 = base - vec3(0.,h2,0.);\n        \n        vec3 midcorner = vec3(base2.x + h4, base2.y, base2.z + h4);\n        cornerx = vec3(base2.x - h4, base2.y, base2.z + h4);\n        cornerz = vec3(base2.x + h4, base2.y, base2.z - h4);\n        float d1 = sdTriangle(p.xy, base.xy, cornerx.xy, midcorner.xy);\n        float d2 = sdTriangle(p.zy, base.zy, cornerz.zy, midcorner.zy);\n        float d = max(d1, d2);\n        \n\n        \n        float topd = length(p-top);\n        float cornerd = length(p-corner);\n        \n        final = min(final,d);\n        \n        // calc normal\n           if( d < epsilon) { \n                if(abs(p.y-base2.y) -0.00005 < 0.0001 ) {\n                    norm = vec3(0.0,-1.0,0.0);              \n                } else {\n                // TODO(gold edition): round corners with banded equality and rounded normal\n                    if(p.x > p.z) {\n                        norm = normalize(vec3(sign(p.x),1., 0.));          \n                    } else {\n                        norm = normalize(vec3(0.0,1.0,sign(p.z)));\n                    }\n                }\n                           \n           return vec4(d,norm);\n        }\n\n           \n        \n        norm = vec3(1.);\n        corner = vec3(base.x + h2, base.y, base.z + h2);\n        // TODO matmin instead of if\n        if( topd < cornerd) {\n           top = top;\n           h /= 2.0;\n           base = top + vec3(0.0,h,0.0);\n        } else {\n           h /= 2.0;\n           top = top + vec3(h/2.0, h, h/2.0);\n           base = top + vec3(0.0,h,0.0);\n           prefold = p;\n           p = fold(p - top) + top;\n        }\n\n\n    }\n    norm = vec3(0.,0.,0.);\n    \n    return vec4(final, norm);\n}\n\n// does the less distance of two d+norm vecs)\nvec4 dmin(vec4 v1, vec4 v2) {\n    if(v2.x < v1.x) {\n        return v2;\n    } else {\n        return v1;\n    }\n}\n\nvec4 map( in vec3 pos ,vec3 ro)\n{\n    vec3 p = pos;\n    float h = 1.0;\n    vec4 r1 = sdSerp(pos + vec3(0.,-0.2,0.), h);\n    vec4 r2 = sdSerpInv(p + vec3(0., 0.8,0.), h);\n    \n    vec3 nor = r1.yzw;\n\n    // This is a hack to remove stray plane intersection rays.\n    if(nor.y == 1.0 && nor.x == 0. && nor.z == 0.) {\n                 if(ro.y < pos.y) {\n                      r1.z = -1.0;\n                 }\n            }\n    nor = r2.yzw;\n               if(nor.y == -1.0 && nor.x == 0. && nor.z == 0.) {\n                 if(ro.y > pos.y) {\n                      r2.z = 1.0;\n                 }\n            }\n    \n    //return dmin(dmin(r1, r2), vec4(length(pos - vec3(1.5,0.0,0.0)) - 0.2, 0., 0.,0.));\n    return dmin(r1,r2);\n}\n    \n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.7*iTime;\n\tvec3 ro = vec3( 3.0*cos(an), 3.4*sin(iTime), 3.0*sin(an) );\n    //vec3 ro = vec3( 3.0*cos(an), 1.8*sin(0.2*iTime), 3.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n        vec4 result;\n\n        // raymarch\n        const float tmax = 60.0;\n        float t = 0.0;\n        for( int i=0; i<1024; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            result = map(pos, ro);\n            //unpack\n            float h = result.x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            \n            vec3 nor = result.yzw;\n            \n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdS3Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 141, 141, 742], [744, 744, 763, 763, 807], [809, 809, 846, 846, 1462], [1554, 1613, 1651, 1651, 3423], [3425, 3448, 3489, 3489, 5642], [5644, 5690, 5719, 5719, 5800], [5802, 5802, 5835, 5835, 6526]], "test": "untested"}
{"id": "NdfSDl", "name": "More Bezier Curve", "author": "oneshade", "description": "Quadratic bezier curve utilities.", "tags": ["2d", "bezier", "curve", "more", "utilities"], "likes": 17, "viewed": 703, "published": 3, "date": "1619404811", "time_retrieved": "2024-07-30T19:23:31.298913", "image_code": "// Evaluates the parametric equation of a quadratic bezier\n// ---> a(1-t)^2 + 2b(1-t)t + ct^2\nvec2 posBezier(in vec2 a, in vec2 b, in vec2 c, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv + b * 2.0 * t * tInv + c * t * t;\n}\n\n// Computes the derivative of a bezier curve for a given parameter value\nvec2 derivBezier(in vec2 v1, in vec2 v2, in vec2 v3, in float t) {\n     return 2.0 * (v1 * (t - 1.0) + (1.0 - 2.0 * t) * v2 + v3 * t);\n}\n\n// Computes a basis matrix for a point on a 2D bezier curve\n// Up is facing out from the curve, like you're riding along it\nmat2 basisBezier(in vec2 v1, in vec2 v2, in vec2 v3, in float t) {\n    vec2 right = normalize(v1 * (t - 1.0) + (1.0 - 2.0 * t) * v2 + v3 * t);\n    return mat2(right, -right.y, right.x);\n}\n\n// Computes the bezier curve's arclength from tmin to tmax\n// From this stack exchange: https://math.stackexchange.com/questions/12186/arc-length-of-b%C3%A9zier-curves\nfloat arclenBezier(in vec2 v1, in vec2 v2, in vec2 v3, in float tmin, in float tmax) {\n    vec2 ba = v2 - v1, cb = v3 - v2;\n    vec2 cbba = cb - ba;\n\n    float a = dot(cbba, cbba);\n    float b = dot(ba, cbba);\n    float c = dot(ba, ba);\n\n    vec4 pre = vec4(a * c - b * b, b / a, 2.0 * b, 0.0);\n    pre.w = sqrt(pre.x);\n\n    float atMin = a * tmin, atMax = a * tmax;\n    float q1 = (tmax + pre.y) * sqrt(c + pre.z * tmax + atMax * tmax) - (tmin + pre.y) * sqrt(c + pre.z * tmin + atMin * tmin);\n    float q2 = pre.x / pow(a, 1.5) * (asinh((atMax + b) / pre.w) - asinh((atMin + b) / pre.w));\n\n    return q1 + q2;\n}\n\n// vec4(vertex, rotation, height)\nvec4 bezierToParabola(in vec2 a, in vec2 b, in vec2 c) {\n    vec2 v = a - 2.0 * b + c, ab = a - b; float d = v.y / v.x;\n    float tVert = (d * ab.y + ab.x) / (v.x + d * v.y);\n\n    float tVertInv = 1.0 - tVert;\n    vec2 vert = a * tVertInv * tVertInv + b * 2.0 * tVertInv * tVert + c * tVert * tVert;\n\n    vec2 right = normalize(a * (tVert - 1.0) + (1.0 - 2.0 * tVert) * b + c * tVert);\n    mat2 basis = mat2(right, -right.y, right.x);\n\n    vec2 aRel = a - vert;\n    float aY = dot(aRel, basis[0]);\n    return vec4(vert, atan(basis[0].y, basis[0].x), dot(aRel, basis[1]) / (aY * aY));\n}\n\n// vec2(shortest distance, parameter of closest point)\n// clampRes flags whether the results should be held in the range [tmin, tmax]\nfloat dot2(in vec2 v) { return dot(v, v); }\nvec2 mapBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3, in float tmin, in float tmax, in bool clampRes) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    // Cubic coefficients ---> t3*t^3 + t2*t^2 + t1*t + t0*t^0\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0;\n    float t1 = dot(c1, c2) + 2.0 * dot(c3, c3);\n    float t0 = dot(c1, c3);\n\n    // Reduce by dividing by leading coefficient\n    // This simplifies out a lot of things\n    t2 /= t3, t1 /= t3, t0 /= t3;\n\n    // Depressed cubic coefficients (p and q) and precomputation\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    // Solutions and details gathered from here: https://en.wikipedia.org/wiki/Cubic_equation\n    if (qq * 0.25 + ppp / 27.0 > 0.0) { // One real root, use hyperbolic trig\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = -2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0;\n        if (clampRes) root = clamp(root, tmin, tmax);\n        return vec2(length(p - posBezier(v1, v2, v3, root)), root);\n    }\n\n    else { // Three real roots (only need to use two), use \"normal\" trig\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0; // 4pi/3 goes here --v\n        vec2 roots = 2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0;\n        if (clampRes) roots = clamp(roots, tmin, tmax);\n        float d1 = dot2(p - posBezier(v1, v2, v3, roots.x));\n        float d2 = dot2(p - posBezier(v1, v2, v3, roots.y));\n        return d1 < d2 ? vec2(sqrt(d1), roots.x) : vec2(sqrt(d2), roots.t);\n    }\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// https://www.shadertoy.com/view/ws3GD7\nfloat sdParabola(in vec2 pos, in float k) {\n    pos.x = abs(pos.x);\n\n    float ik = 1.0 / k;\n    float p = ik * (pos.y - 0.5 * ik) / 3.0;\n    float q = 0.25 * ik * ik * pos.x;\n\n    float h = q * q - p * p * p;\n    float r = sqrt(abs(h));\n\n    float x = h > 0.0 ?\n          // 1 root\n          pow(q + r, 1.0 / 3.0) - pow(abs(q - r), 1.0 / 3.0) * sign(r - q) :\n          // 3 roots\n          2.0 * cos(atan(r, q) / 3.0) * sqrt(p);\n\n    return length(pos - vec2(x, k * x * x)); // * sign(pos.x - x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    // Control points\n    vec2 a = vec2(-0.5, 0.0);\n    vec2 b = iMouse.z > 0.0 ? mouse : vec2(0.0, 0.4);\n    vec2 c = vec2(0.3, -0.4);\n\n    // Parameter bounds\n    float tmin = 0.5 + 0.5 * sin(iTime - 0.8);\n    float tmax = 0.5 + 0.5 * sin(iTime + 0.8);\n\n    // Ends the of the segment\n    vec2 e1 = posBezier(a, b, c, tmin);\n    vec2 e2 = posBezier(a, b, c, tmax);\n\n    // Point moving along the bezier and the basis matrix at that point\n    float t = mix(tmin, tmax, 0.5 + 0.5 * sin(iTime * 2.0));\n    vec2 p = posBezier(a, b, c, t);\n    mat2 basis = basisBezier(a, b, c, t);\n\n    // Order smallest to biggest\n    if (tmax < tmin) {\n        float tmp = tmax;\n        tmax = tmin;\n        tmin = tmp;\n    }\n\n    // Distance\n    float d = mapBezier(uv, a, b, c, tmin, tmax, true).x;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\n    // Fade to and from a texture mapped to the curve's arclength\n    vec2 bez = mapBezier(uv, a, b, c, tmin, tmax, false);\n    vec2 bUv = vec2(arclenBezier(a, b, c, 0.0, bez.y), bez.x);\n    color = mix(color, texture(iChannel0, bUv).rgb, 0.5 - 0.5 * cos(1.5 * iTime));\n\n    // Lines between control points\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, sdLine(uv, a, b) - 0.002));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, sdLine(uv, b, c) - 0.002));\n\n    // Parabola conversion\n    vec4 parabola = bezierToParabola(a, b, c);\n    vec2 cs = vec2(cos(parabola.z), sin(parabola.z));\n    float parabDist = sdParabola((uv - parabola.xy) * mat2(cs, -cs.y, cs.x), parabola.w);\n    color = mix(color, vec3(0.0, 1.0, 1.0), smoothstep(unit, 0.0, abs(parabDist) - 0.001) * mod(floor(bUv.x * 20.0), 2.0));\n    color = mix(color, vec3(0.0), smoothstep(unit, 0.0, length(uv - parabola.xy) - 0.015)); // Vertex\n\n    // Bezier curve\n\tcolor = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(d) - 0.002));\n\n    // End points\n    color = mix(color, vec3(1.0, 0.5, 0.0), smoothstep(unit, 0.0, length(uv - e1) - 0.015));\n    color = mix(color, vec3(1.0, 0.5, 0.0), smoothstep(unit, 0.0, length(uv - e2) - 0.015));\n\n    // Basis system axes at the moving point\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, p, p + 0.15 * basis[0]) - 0.002));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, p, p + 0.15 * basis[1]) - 0.002));\n\n    // Point moving along the bezier\n    color = mix(color, vec3(0.5, 0.0, 1.0), smoothstep(unit, 0.0, length(uv - p) - 0.015));\n\n    // Control points\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - a) - 0.015));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, length(uv - b) - 0.015));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - c) - 0.015));\n\n    // Output arclength\n    float arclen = arclenBezier(a, b, c, tmin, tmax);\n    color = digitIn(color, vec3(1.0), uv - vec2(-0.8,  -0.4), 100.0, arclen);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Handy debugging font by @valalalalala\n// Thanks!\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM  2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 94, 155, 155, 244], [246, 319, 385, 385, 455], [457, 581, 647, 647, 768], [770, 938, 1024, 1024, 1551], [1553, 1587, 1643, 1643, 2172], [2174, 2308, 2331, 2331, 2351], [2352, 2352, 2463, 2463, 4185], [4187, 4187, 4234, 4234, 4342], [4344, 4385, 4428, 4428, 4884], [4886, 4886, 4941, 4941, 8198]], "test": "untested"}
{"id": "fdfXWl", "name": "Magic Eye Hard Stepped", "author": "vsnchips", "description": "Checkerboard pattern procedural autostereogram", "tags": ["autostereogram"], "likes": 1, "viewed": 289, "published": 3, "date": "1619400975", "time_retrieved": "2024-07-30T19:23:32.162604", "image_code": "//////////////////////////\n\n//AutoStereogram Fragment Shader\n\nuniform sampler2D tHeightmap;\nuniform sampler2D tPattern;\n\nuniform float iYTile;\n\n\nbool sDisp = true;\nbool sPat = true;\n\n// Texture uniforms\nfloat iErr = 0.1;\nfloat iCmult = 3.;\nfloat iMmult  = 3.2;\nfloat iYmult = 2.6;\n\n// AutoStereogram key parameters - these ones make it work right\nfloat iCols = 10.;\nfloat iDMult = 0.015;\n//\n\nvec2 iOrigin = vec2(0.5);\nfloat itx = 1.;\nfloat ity = 1.;\n\n\n//varying vec4 vertColor;\n//varying vec4 vertTexCoord;\n\n\n#define PI 3.14159265359\n\n//out vec4 fragColor;\n\nvec2 iTranslate;\nfloat blue = 0.;\nfloat red = 0.;\n\nfloat green = 0.;\n\n/////////////////////\n\n//Audio uniforms\n\nuniform float[512] iSamples;\n\n////////////////////\n\n//STRUCTS\n\nstruct dispTrace\n{\n  vec4 samp;\n  float totaldisp;\n}theDTrace;\n\n\n\n\n////////////////////\n\n////////////////////\n\n//=============================================================================================================================================\n\n                      // Here, I define the texture to be mapped onto the shape.\n\n\nvec4 findCol(vec2 uv,float err){    // This casts an iteratively defined color pattern through a 2D binary search inspired algorithm\n  \n  vec4 rescol = vec4 ( 1.0,0.,1.0,1.0);\n  vec2 tlcnr = vec2(0.0); \n  vec2 brcnr = vec2(1.0);\n  vec4 tl = vec4 (1.,0.,0.,1.);\n  vec4 tr = vec4 (1.,0.,0.,1.);\n  vec4 bl = vec4 (1.,0.,0.,1.);\n  vec4 br = vec4 (1.,0.,0.,1.);\n\n  for (int i = 0; i < 32 ; i ++){\n\n  vec2 mid = tlcnr+0.5*(brcnr - tlcnr);\n\n    float cyan = fract(( tl.r + tr.r + bl.r + br.r)/iCmult)*0.5;\n    float magenta = fract(( tl.g + tr.g + bl.g + br.g)/iMmult)*0.5;\n    float yellow = fract(( tl.b + tr.b + bl.b + br.b)/iYmult)*0.5;\n\n    rescol = vec4(magenta+yellow,yellow+cyan,cyan+magenta,1.);\n\n    //if (abs(mid.x*0.2-uv.x)<err && abs(mid.y-uv.y)<err) break;\n    if (distance(vec2(mid.x*0.2,mid.y),vec2(uv.x*0.2,uv.y))<err) break;\n\n    if (uv.x>mid.x){\n      if (uv.y>mid.y){tlcnr = mid;\n          tl = rescol*1.3; tr = rescol; bl = rescol;} \n      else {tlcnr.x = mid.x;\n          brcnr.y = mid.y; tl = rescol; br = rescol; bl = rescol;}\n    }else{\n       if(uv.y>mid.y){tlcnr.y = mid.y; brcnr.x = mid.x;tl = rescol; tr = rescol; br = rescol;}\n        else {brcnr = mid; bl = rescol; tr = rescol; br = rescol;}\n    }\n\n   \n}\n   \n    //post processing tint\n\n    rescol.rgb =rescol.bgr;\n    //rescol.g=1-rescol.g;\n    rescol.g*=0.7;\n    return rescol;\n}\n\nvec4 getpattern(vec2 uv){\n\n   \n  // uv += iTime*0.01;\n\n   // add a constant displacement to hide the default column\n   /*\n   uv.x+=0.031*sin(uv.y*90.0);\n   uv.x+=0.01*sin(uv.y*300.0);\n   uv.x+=0.00031*sin(uv.y*1500.0);\n    */\n   \n   //return texture(iChannel0,uv);\n   return vec4( step(fract(uv.x*3.),0.5));\n\n}\n// =============================================================================================================================\n\n                                        //////////////////////////////////////////\n    \n                                        // Here is the working displacement method.\n                                    // Its slightly amazing how simple it is compared to the last one\n\n                                        //////////////////////////////////////////\n\n\nvoid dispCol(vec2 uv, vec2 origin){    // This one actually returns a color, in a struct with other stuff\n\n  float secwid = (1.0/iCols);\n  uv -= origin;\n  float chir = (uv.x < 0. ? -1. : 1.);\n  uv.x -= 0.5*chir*secwid;\n  float colwid = 1./iCols;\n \n// The loop's checking variables //                                                                                                                             \n  vec2 disp = uv;  \n  float thisD = 0.;\n\n//============================\nif (chir*disp.x>=0.){\n  for (int i = 0; i < 24; i++){        // The loop breaks dynamically. 24 tiles per side is heaps. Well need like 5\n   if (chir*disp.x<0.) break;\n\n    //Get the current displacement sample\n    vec2 transp = disp+iTranslate;\n   //thisD = texture(tHeightmap,transp).r;   \n    \n    //Post displacement sample transforms\n    float rotate = iTime*0.075;\n    transp = origin + mat2(cos(rotate),-sin(rotate), sin(rotate),cos(rotate)) * (transp);\n    \n    //Sample the heightmap\n    thisD = ( texture(iChannel1,transp).r  -0.75 )*3.;\n    thisD = step((0.5),fract(transp.x*5.) );\n    //smoothstep(fract(transp.y*5.),0.5,0.1) );\n\n    theDTrace.totaldisp += thisD;\n    \n    //step out the displacement\n    disp.x -= (1./iCols-thisD*iDMult)*chir;\n    \n    //visualse the step count\n    green++;\n\n}}\n//==============================\n\n  theDTrace.samp = getpattern(vec2(fract(disp.x*iCols),fract(uv.y))); \n}\n\n                              // And thats it. Magic eye is go.\n\n//====================================================================================================================================================\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n\n{\n\t\n\ttheDTrace.totaldisp=0.;\n\ttheDTrace.samp=vec4(0.);\n\n\t//vec2 fragCoord = vertTexCoord.xy;\n\t//vec2 uv = vertTexCoord.xy - 0.5;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;//\n    \n    //1000.0;\n\t\n\tiTranslate = vec2(0.0);\n\tiTranslate = vec2(itx,ity);\n\n\tfloat subCeiling = 0.15;\n\n\tdispCol(uv,iOrigin);\n\nvec4 color = theDTrace.samp;\n\n\tif (sDisp){\n\t      //color = vec4(theDTrace.totaldisp*0.5); color.b=pow(-theDTrace.totaldisp*3.,2.);\n          //color.g=green*2.6;\n\t}\n\n\t//color = getpattern(uv.xy);\n    //color = texture(iChannel1,uv.xy);\n\n\tfragColor = color;\n\n}\n  \n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1071, 1071, 1103, 1203, 2427], [2429, 2429, 2454, 2693, 2739], [3230, 3230, 3265, 3335, 4626], [4693, 4844, 4901, 4901, 5465]], "test": "untested"}
{"id": "ldBBzW", "name": "Magic Eye Experiment", "author": "vsnchips", "description": "An experiment in visual psychophysics.\n\nA realtime autpstereogram using rotating bilinear filtered grid as a heightmap.", "tags": ["autostereogram"], "likes": 2, "viewed": 388, "published": 3, "date": "1619400959", "time_retrieved": "2024-07-30T19:23:32.930550", "image_code": "//////////////////////////\n\n/*Author: Dan Aston */\n\n//AutoStereogram Fragment Shader\n\nuniform sampler2D tHeightmap;\nuniform sampler2D tPattern;\n\nuniform float iYTile;\n\n\nbool sDisp = true;\nbool sPat = true;\n\n// Texture uniforms\nfloat iErr = 0.1;\nfloat iCmult = 3.;\nfloat iMmult  = 3.2;\nfloat iYmult = 2.6;\n\n// AutoStereogram key parameters - these ones make it work right\nfloat iCols = 10.;\nfloat iDMult = 0.015;\n//\n\nvec2 iOrigin = vec2(0.5);\nfloat itx = 1.;\nfloat ity = 1.;\n\n\n//varying vec4 vertColor;\n//varying vec4 vertTexCoord;\n\n\n#define PI 3.14159265359\n\n//out vec4 fragColor;\n\nvec2 iTranslate;\nfloat blue = 0.;\nfloat red = 0.;\n\nfloat green = 0.;\n\n/////////////////////\n\n//Audio uniforms\n\nuniform float[512] iSamples;\n\n////////////////////\n\n//STRUCTS\n\nstruct dispTrace\n{\n  vec4 samp;\n  float totaldisp;\n}theDTrace;\n\n\n\n\n////////////////////\n\n////////////////////\n\n//=============================================================================================================================================\n\n                      // Here, I define the texture to be mapped onto the shape.\n\n\nvec4 findCol(vec2 uv,float err){    // This casts an iteratively defined color pattern through a 2D binary search inspired algorithm\n  \n  vec4 rescol = vec4 ( 1.0,0.,1.0,1.0);\n  vec2 tlcnr = vec2(0.0); \n  vec2 brcnr = vec2(1.0);\n  vec4 tl = vec4 (1.,0.,0.,1.);\n  vec4 tr = vec4 (1.,0.,0.,1.);\n  vec4 bl = vec4 (1.,0.,0.,1.);\n  vec4 br = vec4 (1.,0.,0.,1.);\n\n  for (int i = 0; i < 32 ; i ++){\n\n  vec2 mid = tlcnr+0.5*(brcnr - tlcnr);\n\n    float cyan = fract(( tl.r + tr.r + bl.r + br.r)/iCmult)*0.5;\n    float magenta = fract(( tl.g + tr.g + bl.g + br.g)/iMmult)*0.5;\n    float yellow = fract(( tl.b + tr.b + bl.b + br.b)/iYmult)*0.5;\n\n    rescol = vec4(magenta+yellow,yellow+cyan,cyan+magenta,1.);\n\n    //if (abs(mid.x*0.2-uv.x)<err && abs(mid.y-uv.y)<err) break;\n    if (distance(vec2(mid.x*0.2,mid.y),vec2(uv.x*0.2,uv.y))<err) break;\n\n    if (uv.x>mid.x){\n      if (uv.y>mid.y){tlcnr = mid;\n          tl = rescol*1.3; tr = rescol; bl = rescol;} \n      else {tlcnr.x = mid.x;\n          brcnr.y = mid.y; tl = rescol; br = rescol; bl = rescol;}\n    }else{\n       if(uv.y>mid.y){tlcnr.y = mid.y; brcnr.x = mid.x;tl = rescol; tr = rescol; br = rescol;}\n        else {brcnr = mid; bl = rescol; tr = rescol; br = rescol;}\n    }\n}\n   \n    //post processing tint\n\n    rescol.rgb =rescol.bgr;\n    //rescol.g=1-rescol.g;\n    rescol.g*=0.7;\n    return rescol;\n}\n\nvec4 getpattern(vec2 uv){\n\n   \n   // add a constant displacement to hide the default column\n   uv.x+=0.031*sin(uv.y*90.0);\n   uv.x+=0.01*sin(uv.y*300.0);\n   uv.x+=0.00031*sin(uv.y*1500.0);\n   \n   //Transform the pattern coordinates too\n   float rotate = iTime*0.1;\n   uv = iOrigin + mat2(cos(rotate),-sin(rotate), sin(rotate),cos(rotate)) * (uv - iOrigin);\n   \n   //uv.y+=0.25;\n   vec4 c= texture(iChannel0,uv); \n   return c;\n\n    \n}\n// =============================================================================================================================\n\n                                        //////////////////////////////////////////\n    \n                                        // Here is the working displacement method.\n                                    // Its slightly amazing how simple it is compared to the last one\n\n                                        //////////////////////////////////////////\n\n\nvoid dispCol(vec2 uv, vec2 origin){    // This one actually returns a color, in a struct with other stuff\n\n  float secwid = (1.0/iCols);\n\n  uv -= origin;\n\n  float chir = (uv.x < 0. ? -1. : 1.);\n\n  uv.x -= 0.5*chir*secwid;\n\n  float colwid = 1./iCols;\n \n// The loop's checking variables //                                                                                                                             \n  vec2 disp = uv;  \n  float thisD = 0.;\n\n//============================\nif (chir*disp.x>=0.){\n  for (int i = 0; i < 24; i++){        // The loop breaks dynamically. 24 tiles per side is heaps. Well need like 5\n   if (chir*disp.x<0.) break;\n\n    //Get the current displacement sample\n    vec2 transp = disp+iTranslate;\n   //thisD = texture(tHeightmap,transp).r;   \n    \n    //Post displacement sample transforms\n    float rotate = iTime*0.1;\n    transp = origin + mat2(cos(rotate),-sin(rotate), sin(rotate),cos(rotate)) * (transp);\n    \n    \n    //Sample the heightmap\n    thisD = ( texture(iChannel1,transp).r  -0.75 )*3.;\n\n    theDTrace.totaldisp += thisD;\n    \n    //step out the displacement\n    disp.x -= (1./iCols-thisD*iDMult)*chir;\n    \n    //visualse the step count\n    green++;\n\n}}\n//==============================\n\n  theDTrace.samp = getpattern(vec2(fract(disp.x*iCols),fract(uv.y+0.5))); \n}\n\n\n                              // And thats it. Magic eye is go.\n\n//====================================================================================================================================================\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n\n{\n\t\n\ttheDTrace.totaldisp=0.;\n\ttheDTrace.samp=vec4(0.);\n\n\t//vec2 fragCoord = vertTexCoord.xy;\n\t//vec2 uv = vertTexCoord.xy - 0.5;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;//\n    \n    //1000.0;\n\t\n\tiTranslate = vec2(0.0);\n\tiTranslate = vec2(itx,ity);\n\n\tfloat subCeiling = 0.15;\n\n\tdispCol(uv,iOrigin);\n\nvec4 color = theDTrace.samp;\n\n\tif (sDisp){\n\t      //color = vec4(theDTrace.totaldisp*0.5); color.b=pow(-theDTrace.totaldisp*3.,2.);\n          //color.g=green*2.6;\n\t}\n\n\t//color = getpattern(uv.xy);\n    //color = texture(iChannel1,uv.xy);\n\n    color=color.rbga;\n    color*=1.45;\n    float p = 2.;\n    color.rgb = vec3(\n    pow(color.r,p),\n    pow(color.g,p),\n    pow(color.b,p)\n    );\n    color.g*=0.8;\n   \n\tfragColor = color;\n\n}\n  \n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}\n\n", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}\n\n", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldBBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1095, 1095, 1127, 1227, 2446], [2448, 2448, 2473, 2539, 2881], [3372, 3372, 3407, 3477, 4686], [4754, 4905, 4962, 4962, 5693]], "test": "untested"}
{"id": "7ssSRs", "name": " good intentions", "author": "nabr", "description": "a lowkey black and white image showing a picture frame a white glowing light  in the middel and what appers to be a creature in the eye of the tornado, surronded by clouds.", "tags": ["raymarch", "sound", "fm", "blackandwhite", "pathtracer", "vox", "neoromanticism"], "likes": 18, "viewed": 560, "published": 3, "date": "1619385574", "time_retrieved": "2024-07-30T19:23:33.725425", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(abs(fragCoord.x*2.-iResolution.x)/iResolution.y<1.3)\n    fragColor = vec4((c.xyz/c.w)*6.+.05, 1);//contrast,brightness\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//some suff by iq>website\nfloat sdBox(vec3 p,vec3 s){p=abs(p)-s;return(length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.));}\nvec2 hash21(uint q)\n{\n    uvec2 n=q*uvec2(1597334697U,3812015801U);\n    n=(n.x^n.y)*uvec2(1597334697U,3812015801U);\n    return vec2(n)*(1.0/float(0xffffffffU));\n}\n\n//by sphinx glslsandbox.com/e#31401.0 \nfloat pnoise(in vec2 uv) \n{\n    const float k = 257.;\n    vec4 l = vec4(floor(uv), fract(uv));\n    float u = l.x + l.y * k;\n    vec4 v = vec4(u, u + 1., u + k, u + k + 1.);\n    v = fract(fract(1.23456789 * v) * v / .987654321);\n    l.zw = l.zw * l.zw * (3. - 2. * l.zw);\n    return mix(mix(v.x, v.y, l.z), mix(v.z, v.w, l.z), l.w);\n}\n\n//fractal with minification help by FabriceNeyret2\nfloat df(vec2 p)\n{\n    vec2 z=p;\n    for(float i=0.;i<9.;i++)\n    if((4.-dot(z=1.5*dot(z,z)*sin(4.3*atan(z.x*1.6,z.y)+vec2(0,33))+p,z))<0.)\n    return i;\n}\n\n\n#define dmin(a,b)((a.x<b.x)?a:b)\n\nvec2 f(vec3 p) \n{   \n    //light\n    float lt = sdBox(p, vec3(.175, .25, .2))- .015;\n    //frame\n    vec3 rp = abs(p) - vec3(1., 1.2, .2);\n    float y=length(length(vec2(max(rp.x, rp.y))))-.05;\n    float fr=max(y, rp.z-.1)+min(max(rp.x,max(rp.y,rp.z)),0.0);\n    //clouds\n    float s = 6.,h = 0.1, w = s/2., m = s/8.;\n    for(int i = 0; i<8; i++)\n    h += smoothstep(-.25,5.,((w*=.5)*pnoise((p.xy*(m*=2.)))));\n    p.z +=.8;\n    float fcd = sdBox(abs(vec3(p.xy,-min(p.z,-h+p.z))),vec3(2,2,.05));\n    \n    return dmin(dmin(vec2(lt,5.), vec2(fcd, 13.)), vec2(fr, 11.));\n}\n\nvec3 calcNormal(in vec3 pos)\n{\nvec3 eps=vec3(0.0001,0.0,0.0);\nreturn normalize(vec3((f(pos+eps.xyy)-f(pos-eps.xyy)).x,(f(pos+eps.yxy)-f(pos-eps.yxy)).x,(f(pos+eps.yyx)-f(pos-eps.yyx)).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    if(iFrame > 0)fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec3 col = vec3(1e-6);\n    vec2 R = iResolution.xy,  h = vec2(0);\n    float dy = df(11.*((fragCoord-.5*R)/R.y));//fractal\n    //seed by demofox \n    uint seed = (uint(fragCoord.x) * 1973u + uint(fragCoord.y) * 9277u + uint(iFrame) * 2669u) | 1u;\n    vec2 jjt = vec2(cos(R.y*hash21(seed)).x,sin(R.y*hash21(seed).y)),st =((fragCoord+jjt)*2.-R)/R.y;\n    \n    vec3 ro = vec3(0,0,3),rd = normalize(vec3(st,-2));\n    \n    if(abs(st.x)<1.3)\n    for(int b = 1; b < 4 + min(iFrame, 0); b++) \n    {\n        float t = 0.;\n        for(int i = 0; i < 80; i++) \n        {\n            h = f(ro + t * rd );\n            if(abs(h.x) < t *.001 || t > 5.)break;\n            t += h.x;\n        }\n        \n        ro+=t*rd;\n        vec3 n = calcNormal(ro);\n        ro+=n*.001;\n        \n        vec2 rv  = vec2(hash21(seed).x*2.-1., hash21(seed).y*6.283185);\n        float phi =rv.y, th = rv.x;\n        \n        // light frame cosine weighted hemisphere \n        vec3 u = normalize(cross(abs(n.x)>.1 ?vec3(0,1,0):vec3(1,0,0) , n )), v = cross(n, u);\n        float r = sqrt(th);\n        rd = (u * cos(phi) * r + v * sin(phi) * r + n * sqrt(1. - th));\n        \n        // light clouds\n        if(h.y == 13.&&h.y!=5.)\n        {\n        if(cos(t) < 0.001)n = -n;\n        vec3 ld = normalize(vec3(0.001, 0.001, 2. )) + n ;\n        //based on http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n        vec3 u = normalize((abs(ld.x) >.01 ) ? vec3(-ld.y, ld.x, 0.) : vec3(0., -ld.z, ld.y)), v = cross(ld, u);\n        float sth = sin(th);\n        rd =  (u * cos(phi) * sth + v * sin(phi) * sth + ld * cos(th));\n        }\n        rd = normalize(rd);\n        \n       col +=  float(h.y==5.)*(vec3(3)-max(1.,dy)) * vec3(.974);\n    }\n    \n    //reinhard gamma\n    col = col/(1.+col); \n    fragColor += vec4(pow(col,vec3(0.4545)),1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\n\n#define _f(x)fract(x)\nvoid f(float ft,float t,inout float y)\n{\n    y+=sin(2.*3520.*t)*exp(-6.*ft)\n        *sin(t*50.*exp(-0.05*pow(1.-ft,12.)))\n        *((1.-sqrt(ft))*3.*ft);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 y=vec2(1e-6);\n    float t=(float(samp)*(1./iSampleRate)),u=y.y;\n    for(int i=0;i<6;++i)\n    {\n        float x=1./4.95;\n        f(_f(t),vec2(17,27)[i%2]+t,y.x);\n        x+= 1./vec2(8,17)[i%2];\n        f(_f(t),x+t,y.y);\n        f(_f(x+.1*t),x+t,u);\n        t*= abs(1.-x);\n    }\n    float ft = _f(4.*t);\n    return.3*y+(u+.7*y*((1.-sqrt(ft))*5.*ft));\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 242]], "test": "untested"}
{"id": "NsXSWX", "name": "314_De_En_De_v4_v5", "author": "DeEnDe", "description": "i hate dodecahedrons", "tags": ["raytraycing"], "likes": 0, "viewed": 240, "published": 3, "date": "1619379669", "time_retrieved": "2024-07-30T19:23:34.740711", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(-5, 2, -7);\nconst vec3 LIGHT1_POS = vec3(-1, 1.5, 5);\nconst float LIGHT1_RADIUS = 0.5;\nconst vec3 LIGHT1_COLOR = vec3(1, 1, 1);\n\nconst vec3 LIGHT2_POS = vec3(4, 0.5, 2);\nconst float LIGHT2_RADIUS = 0.25;\nconst vec3 LIGHT2_COLOR = vec3(0.1, 1, 0.2);\nvec3 randDir;\n\nconst float or = 1.618;\nconst float rec = or - 1.0;  \n\nvec3 minecraft (in vec2 w) {\n\n    vec3 d = vec3(w, 1) / iResolution - 0.6;\n    vec3 p, c, f;\n    vec3 g = d; \n    vec3 o = vec3(0.2, 0.0, 8.0);\n    o.y = 3.0 * cos(o.x * o.z);\n    vec3 y = vec3(1, 2, 0);\n\n    for (float i = 0.0; i < 9.0; i += 0.001) {\n        o += d * i * 0.01;\n        c = o;\n        f = fract(c);\n        p = floor(c) * 0.3;\n        if (cos(p.z) + sin(p.x) > ++p.y) {\n\t    \tg = (f.y - 0.04 * cos((c.x + c.z) * 40.0) > 0.8 ? y : f.y * y.yxz) / i;\n            break;\n        }\n    }\n    \n    return g.rgb;\n}\n\n\nfloat pow2(float x) {\n    return x * x;\n}\nfloat fogSdf(vec3 pos) {\n    return length(pos) - 0.75;\n}\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled) {\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec4 sampleFog(vec3 pos, vec3 dir, in vec2 w) {\n\n    float t = fogSdf(pos);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fogSdf(curPos);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(10.0 * (\n            2.5 * texture(iChannel3, curPos * 0.3 + vec3(1, 1, 0)).x\n            + 1.5 * texture(iChannel3, curPos * 0.1 + vec3(1, 1, 0)).x\n            ) * 0.25 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    \n    vec3 color = minecraft(w);\n    vec3 tmp = rgb2hsv(color);\n    tmp.x /= 1.2;\n    tmp.z *= 1.7;\n    color = hsv2rgb(tmp);\n    color *= 0.9;\n    \n    return vec4(color * totalAbs, 1.0 - opacity);\n}\n\nbool isIn(vec3 a1, vec3 a2, vec3 a3, vec3 a4, vec3 a5,  vec3 point)\n{\n    vec3 v1 = a2 - a1;\n    vec3 v2 = a3 - a2;\n    vec3 v3 = a4 - a3;\n    vec3 v4 = a5 - a4;\n    vec3 v5 = a1 - a5;\n    vec3 normal = normalize(cross(v1, v2));\n    \n    return !((normalize(dot(cross(v1, point - a1), normal)) != 1.0 && \n          normalize(dot(cross(v1, point - a1), normal)) != -1.0) ||\n                      dot((cross(v1, point - a1)), normal) < 0.0 ||\n                      dot((cross(v2, point - a2)), normal) < 0.0 ||\n                      dot((cross(v3, point - a3)), normal) < 0.0 ||\n                      dot((cross(v4, point - a4)), normal) < 0.0 ||\n                      dot((cross(v5, point - a5)), normal) < 0.0);    \n}\n\n\nfloat plane5(vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 dir, vec3 pos, vec3 mid)\n{\n    vec3 a1 = v2 - v1;\n    vec3 a2 = v3 - v2;\n    vec3 normal = normalize(cross(a1, a2));\n    vec3 inMid = mid - v1;\n    if (dot(normal, inMid) > 0.0) {\n        normal = -normal;\n    }\n    \n    float dotNorm = dot(dir, normal);\n    float t = dot(v2 - pos, normal) / dotNorm;\n    vec3 worldPos = t * dir + pos;\n    if (t <= 0.) {\n        return INF;\n    }\n    if (isIn(v1, v2, v3, v4, v5, worldPos)) {\n        return t;\n    }\n    return INF; \n}\n\nvoid checkNormal(vec3 v1, vec3 v2, vec3 v3, vec3 mid, out vec3 normal)\n{\n    vec3 vect1 = v2 - v1;\n    vec3 vect2 = v3 - v2;\n    normal = normalize(cross(vect1, vect2));\n    vec3 inMid = mid - v1;\n    if (dot(normal, inMid) > 0.0)\n        normal = -normal;\n}\n\nvec3 trickVec(vec3 a, float size, vec3 trick) {\n    return a * size + trick;\n}\n\n\nfloat traceDod(vec3 pos, vec3 dir, out vec3 normal, float size, vec3 trick) \n{\n    vec3 mid = vec3(0, 0, 0);\n\n    \n    vec3 v[20];\n    v[0] = vec3(1, 1, 1);\n    v[1] = vec3(1, 1, -1);\n    v[2] = vec3(1, -1, 1);\n    v[3] = vec3(1, -1, -1);\n    v[4] = vec3(-1, 1, 1);\n    v[5] = vec3(-1, 1, -1);\n    v[6] = vec3(-1, -1, 1);\n    v[7] = vec3(-1, -1, -1);\n    v[8] = vec3(0, rec, or);\n    v[9] = vec3(0, rec, -or);\n    v[10] = vec3(0, -rec, or);\n    v[11] = vec3(0, -rec, -or);\n    v[12] = vec3(rec, or, 0);\n    v[13] = vec3(rec, -or, 0);\n    v[14] = vec3(-rec, or, 0);\n    v[15] = vec3(-rec, -or, 0);\n    v[16] = vec3(or, 0, rec);\n    v[17] = vec3(or, 0, -rec);\n    v[18] = vec3(-or, 0, rec);\n    v[19] = vec3(-or, 0, -rec);\n    \n    for (int i = 0; i < 20; i++) {\n        v[i] = trickVec(v[i], size, trick);\n    }\n    \n    float t = INF;\n    float cur_t;\n    cur_t = plane5(v[8], v[10], v[2], v[16], v[0], dir, pos, mid);\n    if (cur_t < t) {\n        t = cur_t;\n        checkNormal(v[8], v[10], v[2], mid, normal);\n    }\n \n    cur_t = plane5(v[12], v[14], v[4], v[8], v[0], dir, pos, mid);\n    if (cur_t < t) {\n        t = cur_t;\n        checkNormal(v[12], v[14], v[4], mid, normal);\n    }\n \n    cur_t = plane5(v[16], v[17], v[1], v[12], v[0], dir, pos, mid);\n    if (cur_t < t) {\n        t = cur_t;\n        checkNormal(v[16], v[17], v[1], mid, normal);\n    }\n \n \n    cur_t = plane5(v[17], v[3], v[11], v[9], v[1], dir, pos, mid);\n    if (cur_t < t) {\n        t = cur_t;\n        checkNormal(v[17], v[3], v[11], mid, normal);\n    }\n    \n    cur_t = plane5(v[9], v[5], v[14], v[12], v[1], dir, pos, mid);\n    if (cur_t < t) {\n        t = cur_t;\n        checkNormal(v[9], v[5], v[14], mid, normal);\n    }\n \n    cur_t = plane5(v[10], v[6], v[15], v[13], v[2], dir, pos, mid);\n    if (cur_t < t) {\n        t = cur_t;\n        checkNormal(v[10], v[6], v[15], mid, normal);\n    }\n \n    cur_t = plane5(v[13], v[3], v[17], v[16], v[2], dir, pos, mid);\n    if (cur_t < t) {\n        t = cur_t;\n        checkNormal(v[13], v[3], v[17], mid, normal);\n    }\n \n \n    cur_t = plane5(v[13], v[15], v[7], v[11], v[3], dir, pos, mid);\n    if (cur_t < t) {\n        t = cur_t;\n        checkNormal(v[13], v[15], v[7], mid, normal);\n    }\n    \n    cur_t = plane5(v[18], v[6], v[10], v[8], v[4], dir, pos, mid);\n    if (cur_t < t) {\n        t = cur_t;\n        checkNormal(v[18], v[6], v[10], mid, normal);\n    }\n \n    cur_t = plane5(v[14], v[5], v[19], v[18], v[4], dir, pos, mid);\n    if (cur_t < t) {\n        t = cur_t;\n        checkNormal(v[14], v[5], v[19], mid, normal);\n    }\n \n \n    cur_t = plane5(v[9], v[11], v[7], v[19], v[5], dir, pos, mid);\n    if (cur_t < t) {\n        t = cur_t;\n        checkNormal(v[9], v[11], v[7], mid, normal);\n    }\n \n \n    cur_t = plane5(v[15], v[7], v[19], v[18], v[6], dir, pos, mid);\n    if (cur_t < t) {\n        t = cur_t;\n        checkNormal(v[15], v[7], v[19], mid, normal);\n    }\n    return t;\n}\n\n// (CAMERA_POS + t * viewVec).y == -1\n// t = (-1 - CAMERA_POS.y) / viewVec.y;\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.5) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 sphNorm;\n    float sphT = traceSphere(pos, dir, 1.0, sphNorm);\n    if (sphT < dist)\n        return true;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : 20.0f / distSq1;\n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : 6.0f / distSq2;\n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * 0.1\n    );\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    vec3 randDir = normalize(randVals * 2.0 - 1.0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float BUILDING_R = 0.0;\n    float n1 = AIR_N;\n    float curN = 1.0;\n    float nextN = GLASS_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    const float DIAMOND_N = 2.5;\n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    vec3 colorMult = vec3(1, 1, 1);\n    float mult = 1.0;\n    for (int i = 0; i < 20; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = GLASS_N;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n        }\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n        if (light1T < t) {\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n        if (light2T < t) {\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n        \n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n        }\n        vec3 dodNorm;\n        float sphT = traceDod(curPos, curDir, dodNorm, 0.75, vec3(0.3, 0.3, 0.3));\n        if (sphT < t) {\n            t = sphT;\n            normal = dodNorm;\n            if (randVals.x * 0.5 < GLASS_R * 2.0){\n                materialType = REFLECTION;\n             }\n             else {\n                materialType = REFRACTION;\n\n             }\n\n        }\n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            if (materialType == EMISSION) {\n                fragColor.rgb = color;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb += mult * computeLight(worldPos, color, normal);\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-5;\n                n1 = nEnter;\n                vec4 fog = sampleFog(curPos, curDir, fragCoord);\n                fragColor.rgb += fog.rgb * fog.a * mult;\n                mult *= 1.0 - fog.a;\n            }\n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 234]], "test": "untested"}
{"id": "tsKSWV", "name": "merging sine tubes", "author": "LobsterCrew", "description": "played around with a bunch of sine functions\n", "tags": ["sine"], "likes": 5, "viewed": 252, "published": 3, "date": "1619377306", "time_retrieved": "2024-07-30T19:23:35.503671", "image_code": "float f(float x, float y)\n{\n    float arg = .9*iTime + 13.*y + 2.*sin(.3*iTime + 4.*x) - 20.*(x+.5)*y;\n\treturn clamp(.7*cos(arg) + .2*cos(3.*arg) + .05*cos(5.*arg), -1., 1.);\n}\n\nfloat g(float x, float y)\n{\n    float arg = .9*iTime + 15.*x*1.+ .5*cos(.1*iTime) + 2.*cos(1.2*iTime + 10.*y);\n\treturn clamp(-abs(.5*cos(arg)) + .7*cos(3.*arg) + .3*cos(5.*arg- 1.), -1., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 q =(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 res = vec2(f(q.x, q.y), g(q.x, q.y));\n    vec3 col = vec3(.0, .0, .5) + vec3( -1., .0, .5)*sqrt(res.x)*res.y;\n    col += vec3(.0, 1., .0)*res.x*res.x * res.y*res.y;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 176], [178, 178, 205, 205, 371], [373, 373, 430, 466, 762]], "test": "untested"}
{"id": "ssfSWX", "name": "simple AA crate", "author": "elenzil", "description": "nothing fancy. same lighting model as [url]https://www.shadertoy.com/view/NslXzH[/url] but plus AA.\nleft = no AA, right = AA.", "tags": ["aa"], "likes": 6, "viewed": 261, "published": 3, "date": "1619370133", "time_retrieved": "2024-07-30T19:23:36.546882", "image_code": "#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\n#define AA 0\n\n\nfloat opUnion(in float a, in float b, out bool aWins);\nfloat opMinus(in float a, in float b);\nfloat opIntsc(in float a, in float b);\nfloat opExtrusion( in vec3 p, in float d, in float h );\nfloat opOnion( in float sdf, in float thickness );\n\nfloat sdPlaneY(in vec3 p);\nfloat sdBoxFrame(in vec3 p, in vec3 b, in float e);\nvec3 sky(in vec3 dir);\nfloat fineNoise(in vec3 p);\n\n\nfloat gMapCalls;\n\nfloat gSceneTheta = 0.0;\n\nfloat map(in vec3 p, out vec3 localCoords, out int material) {\n    float d     = 1e9;\n    localCoords = p;\n    material    = 1;\n    \n    vec3 P;\n    bool aWins;\n\n    P = p;\n    P.xz *= rot2(gSceneTheta);\n    d = opUnion(d, sdBoxFrame(P, vec3(1.0), 0.0) - 0.2, aWins);\n    if (!aWins) {\n        material = 1;\n        localCoords = P;\n    }\n    \n    d = opOnion(d, 0.01);\n    \n    d = opIntsc(d, p.y - 0.9);\n\n    P = vec3(p.x, p.y + 1.2, p.z);\n    d = opUnion(d, sdPlaneY(P), aWins);\n    if (!aWins) {\n        material = 0;\n        localCoords = P;\n    }\n    \n/*  P = p;\n   // P.xz *= rot2(gTime * 0.3);\n    vec2 q = vec2( length(P.xz), P.y );\n    d = opUnion(d, sdParabola(q, 0.1, 0.1), aWins);\n    if (!aWins) {\n        material = 1;\n        localCoords = P;\n    }*/\n\n\n    return d;\n}\n\n\n// IQ: https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    vec3 unused1;\n    int unused2;\n    const float h = 0.002;      // replace by an appropriate value\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h, unused1, unused2);\n    }\n    return normalize(n);\n}\n\nconst float closeEps = 0.002;\n\nfloat march(in vec3 ro, in vec3 rd) {\n    const int maxSteps = 100;\n\n    vec3 localCoords;\n    int  material;\n\n    float t = 0.0;\n    for (int n = ZERO; n < maxSteps; ++n) {\n        float d = map(ro + rd * t, localCoords, material);\n        float closeEnoughEps = (n == maxSteps ? 0.2 : closeEps);\n        if (d < closeEnoughEps) {\n            return t;\n        }\n        t += d;\n        if (t > 200.0) {\n            return t;\n        }\n    }\n    return t;\n}\n\nvec3 lightDirection = normalize(vec3(-2.0, -1.0, 0.7));\n\nfloat calcDiffuseAmount(in vec3 p, in vec3 n) {\n    return clamp(dot(n, -lightDirection), 0.0, 1.0);\n}\n\nconst float AOFactorMin = 0.2;\nconst float AOFactorMax = 1.0;\nfloat calcAOFactor(in vec3 p, in vec3 n) {\n    vec3 unused1;\n    int unused2;\n    const float sampleDist = 0.4;\n    float dist = smoothstep(0.0, sampleDist, map(p + n * sampleDist, unused1, unused2));\n    return mix(AOFactorMin, AOFactorMax, (dist));\n}\n\nfloat calcShadowLight(in vec3 p) {\n    float t = march(p - lightDirection * 0.05, -lightDirection);\n    return t > 40.0 ? 1.0 : 0.0;\n}\n\nfloat maxComponent(in vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nstruct pol3 {\n    float rho;\n    float tht;\n    float phi;\n};\n\npol3 sphericalFromCartesian(in vec3 cartesian) {\n    pol3 ret;\n\n    ret.tht = atan(cartesian.z, cartesian.x);\n    ret.phi = acos(dot(normalize(cartesian), vec3(0.0, 1.0, 0.0))) - PI/2.0;\n    ret.rho = length(cartesian);\n\n    return ret;\n}\n\nconst vec3 albedo1 = vec3(0.0, 0.6, 1.0);\nconst vec3 albedo2 = vec3(0.7, 0.2, 0.3);\nconst vec3 albedo3 = vec3(0.5, 0.1, 0.2);\nconst vec3 albedo4 = vec3(1.0, 1.0, 0.2);\nconst vec3 albedo5 = vec3(1.0, 0.2, 0.2);\n\n\nvoid calcMaterialCommons(in int material, in vec3 pCrt, in pol3 pPol) {\n}\n\n\nvec3 getAlbedo(in int material, in vec3 pCrt, in pol3 pPol) {\n    switch (material) {\n    //    default: return vec3(1e9, 0.0, 1e9);\n        case 0: return vec3(0.2);\n        case 1: return vec3(1.0);\n    }\n}\n\nvec3 getReflectivity(in int material, in vec3 pCrt, in pol3 pPol) {\n    switch (material) {\n        default: return vec3(1.0, 0.0, 1.0);\n        case 0: return vec3(fineNoise(pCrt * 3.0));\n        case 1: return vec3(0.5);\n    }\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n\n    vec3 col = vec3(0.0);\n\n    int bouncesLeft = 3;\n\n    vec3 contributionLeft = vec3(1.0);\n\n    while (bouncesLeft >= 0 && maxComponent(contributionLeft) > 0.001) {\n        bouncesLeft -= 1;\n        float t = march(ro, rd);\n        vec3 p = ro + t * rd;\n        if (length(p) > 20.0) {\n            \n            col += sky(rd) * contributionLeft;\n            break;\n        }\n\n        vec3 normal = calcNormal(p);\n\n        vec3 ptCrt;\n        int material;\n        map(p, ptCrt, material);\n        pol3 ptSph = sphericalFromCartesian(ptCrt);\n\n\n        float incomingLight = 1.0;\n        incomingLight = min(incomingLight, calcDiffuseAmount(p, normal));\n        incomingLight = min(incomingLight, calcShadowLight(p));\n        float ambient = 0.05 * calcAOFactor(p, normal);\n        incomingLight += ambient;\n\n        float fres = 0.2 + 0.8 * clamp(pow(1.0 - abs(dot(rd, normal) - 0.1), 2.0), 0.0, 1.0);\n\n        calcMaterialCommons(material, ptCrt, ptSph);\n\n        vec3 reflectivity = fres * getReflectivity(material, ptCrt, ptSph);\n        vec3 diffuse = incomingLight * getAlbedo(material, ptCrt, ptSph);\n        \n        col += diffuse * (1.0 - reflectivity) * contributionLeft;\n        contributionLeft *= reflectivity;\n          \n        ro = p + normal * 0.05;\n        rd = reflect(rd, normal);\n    }\n\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec4 persistedInfo = texelFetch(iChannel0, ivec2(0, 0), 0);\n    setupCoords(iResolution.xy, 1.5);\n    setupTime(persistedInfo[2]);\n    vec2  uv        = worldFromScreen(XY);\n    float luv       = length(uv);\n    vec2  ms        = worldFromScreen(iMouse.xy) * 1.5;\n    float smoothEps = gWorldFromScreenFac * 2.0;\n\n    // look-from and look-to points\n    // right-handed system where x is right, y is up, z is forward.\n    float dt = 0.5;\n    float t = gTime * 0.23;\n    vec3 trgPt = vec3(0.0);\n    \n    gMapCalls = 0.0;\n    vec3 col = vec3(0.0);\n\n    gSceneTheta = ms.x * -1.5;\n    float camTheta = t;\n    float camAlttd = sin(t * 0.32) * 0.2 - ms.y * 0.8;\n    camAlttd = max(camAlttd, -0.1);\n    vec3 camPt = vec3(cos(camTheta), camAlttd, sin(camTheta)) * 5.0;\n    \n    // camera's forward, right, and up vectors. right-handed.\n    vec3 camFw = normalize(trgPt - camPt);\n    vec3 camRt = cross(camFw, vec3(0.0, 1.0, 0.0));\n    vec3 camUp = cross(camRt, camFw);\n\n    vec2 aaD = worldFromScreen(vec2(1.0));\n    bool leftSide = XY.x < iResolution.x / 2.0;\n    float accum = 0.0;\n    for (float aax = -0.5; aax <= 0.5; aax += 0.5) {\n        for (float aay = -0.5; aay <= 0.5; aay += 0.5) {\n            // ray origin and direction\n            vec3 ro    = camPt;\n            vec3 rd    = normalize(camFw + (uv.x + aax * gWorldFromScreenFac) * camRt + (uv.y + aay * gWorldFromScreenFac) * camUp);\n            const int maxSteps = 100;    \n            col += render(ro, rd);\n            accum += 1.0;\n            if (leftSide) {\n                break;\n            }\n        }\n        if (leftSide) {\n            break;\n        }\n    }\n    col /= accum;\n\n    float outCircle = smoothstep(-smoothEps, smoothEps, luv - 1.0);\n    col *= 1.0 - 0.1 * outCircle * pow(luv, 1.5);\n\n  //  col.r = gMapCalls / 200.0;\n  \n    col = pow(col, vec3(1.0 / 2.2));\n\n    col *= 1.0 + 0.5 * smoothstep(2.0, 0.0, abs(XY.x - iResolution.x/2.0));\n    \n    RGBA = vec4(col, 1.0);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n\nvec3 sky(in vec3 rd) {\n    float tht = atan(rd.z, rd.x);\n    float phi = acos(dot(normalize(rd), vec3(0.0, 1.0, 0.0)));\n    vec3 col = rd * 0.5 + 0.5;\n    col *= smoothstep(0.002, -0.002, sin(tht       * 4.0)) * -0.3 + 1.0;\n    col *= smoothstep(0.002, -0.002, sin(phi * 2.0 * 4.0)) * -0.3 + 1.0;\n    col = mix(col, col / max(col.r, max(col.g, col.b)), 0.2);\n    col *= rd.y < 0.0 ? 0.5 : 1.0;\n    return col;\n}\n\n// dir is unit-length\nvec3 directionToColor(in vec3 dir) {\n    vec3 ret = dir * 0.5 + 0.5;\n    return ret;\n}\n\n\nfloat opUnion(in float a, in float b, out bool aWins) {\n    aWins = a < b;\n    return aWins ? a : b;\n}\n\nfloat opMinus(in float a, in float b) {\n    return max(a, -b);\n}\n\nfloat opIntsc(in float a, in float b) {\n    return max(a, b);\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat opExtrusion( in vec3 p, in float d, in float h )\n{\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat sdPlaneY(in vec3 p)\n{\n    return p.y;\n}\n\n// IQ: https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame(in vec3 p, in vec3 b, in float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\n\n\n// noise from IQ: https://www.shadertoy.com/view/4sfGzS\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n                    \nfloat fineNoise(in vec3 p) {\n    vec3 q = 2.0 * p;\n    float f;\n    f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    return f;\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Fork of \"boilerplate stuff\" by elenzil. https://shadertoy.com/view/7dX3R2\n// 2021-04-05 18:18:15\n\nconst float PI  = 3.14159265359;\nconst float TAO = PI * 2.0;\n\n// global time parameter\nfloat gTime;\n\nvec2  gCanvasRes;\nfloat gCanvasSmallRes;\nfloat gZoom;\nfloat gScreenFromWorldFac;\nfloat gWorldFromScreenFac;\n\n\n// to prevent loop-unrolling\n#define ZERO (min(0, int(iFrame)))\n\n\n// set up world coordinates where a unit circle fits\n// in the smallest dimension of the canvas, plus a zoom factor.\nvoid setupCoords(in vec2 canvasResolution, in float zoom) {\n\n    gCanvasRes = canvasResolution;\n\n    // the smallest dimension of the canvas\n    gCanvasSmallRes = min(canvasResolution.x, canvasResolution.y);\n    \n    // small = shrink\n    gZoom = zoom;\n    \n    // factor to get from world scale to screen scale\n    gScreenFromWorldFac = gZoom * gCanvasSmallRes / 2.0;\n    \n    // factor to get from screen scale to world scale\n    gWorldFromScreenFac = 1.0 / gScreenFromWorldFac;\n}\n\nvec2 worldFromScreen(in vec2 screenPt) {\n    return (screenPt - gCanvasRes / 2.0) * gWorldFromScreenFac;;\n    \n}\n\n// in case we want to speed or slow down things from iTime.\n// this needs to be called in each pass.\nvoid setupTime(in float time) {\n    gTime = time;\n}\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n", "buffer_a_code": "\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\n// 0, 0:\n// [0] = is mouse down\n// [1] = is time frozen\n// [2] = current time\n// [3] = timescale\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    ivec2 IJ = ivec2(XY);\n\n    RGBA = texelFetch(iChannel0, IJ, 0);\n\n    if (iFrame == 0 || IJ.x != 0 || IJ.y != 0) {\n        RGBA = vec4(0.0, 0.0, iTime, 1.0);\n        return;\n    }\n\n    bool  mouseWasDown = RGBA[0] == 1.0;\n    bool  timeIsFrozen = RGBA[1] == 1.0;\n    float time         = RGBA[2];\n    float timeScale    = RGBA[3];\n\n    bool mouseIsDown = iMouse.z > 0.0;\n\n    timeIsFrozen = timeIsFrozen ^^ (!mouseIsDown && mouseWasDown);\n    \n    timeIsFrozen = mouseIsDown;\n\n    timeScale = clamp(timeScale + (timeIsFrozen ? -0.01 : 0.01) * 60.0 / iFrameRate, 0.0, 1.0);\n    time += iTimeDelta * timeScale;\n\n    RGBA[0] = mouseIsDown  ? 1.0 : 0.0;\n    RGBA[1] = timeIsFrozen ? 1.0 : 0.0;\n    RGBA[2] = time;\n    RGBA[3] = timeScale;\n\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfSWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 479, 541, 541, 1263], [1266, 1316, 1367, 1367, 1682], [1715, 1715, 1752, 1752, 2173], [2232, 2232, 2279, 2279, 2334], [2398, 2398, 2440, 2440, 2650], [2652, 2652, 2686, 2686, 2786], [2788, 2788, 2819, 2819, 2857], [2922, 2922, 2970, 2970, 3160], [3374, 3374, 3445, 3445, 3447], [3450, 3450, 3511, 3511, 3658], [3660, 3660, 3727, 3727, 3890], [3892, 3892, 3929, 3929, 5256], [5260, 5260, 5305, 5305, 7260], [7344, 7344, 7366, 7366, 7755], [7757, 7779, 7815, 7815, 7865], [7868, 7868, 7923, 7923, 7970], [7972, 7972, 8011, 8011, 8036], [8038, 8038, 8077, 8077, 8101], [8103, 8170, 8226, 8226, 8321], [8324, 8324, 8375, 8375, 8408], [8410, 8410, 8437, 8437, 8455], [8457, 8510, 8563, 8563, 8845], [8850, 8906, 8963, 8963, 9058], [9060, 9060, 9086, 9086, 9560], [9709, 9709, 9737, 9737, 9956]], "test": "untested"}
{"id": "wdtBRS", "name": "Floating Point Precision Fractal", "author": "emymin", "description": "weird", "tags": ["experiment"], "likes": 1, "viewed": 53, "published": 3, "date": "1619369723", "time_retrieved": "2024-07-30T19:23:37.520279", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=.5;\n    uv/=pow(iTime,iTime);\n    uv=1./uv;\n    vec3 col = vec3(float(   bool(int(floor(uv.x))%2) ^^ bool(int(floor(uv.y))%2))  );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ws3BWM", "name": "2d landscape", "author": "emymin", "description": "Just a landscape", "tags": ["2d"], "likes": 0, "viewed": 60, "published": 3, "date": "1619369685", "time_retrieved": "2024-07-30T19:23:38.295207", "image_code": "float rand(float p){\n \treturn fract(sin(p*213.23)*55132.2);   \n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  \tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  \tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    uv-=.5;\n    uv*=10.;\n\t\n    float sunfac =clamp( (1. - length((uv- 3.*vec2(-cos(iTime),sin(iTime))) *vec2(1.7,1.)))*3. , 0., 1.);\n    \n    uv.x+=iTime;\n    \n    float sky = mix(1.,0.,uv.y/10.+0.5);\n    vec3 skycol = vec3(sky*1.5,sky*1.5,1);\n    skycol+=mix(0.,noise(uv*3.),noise(uv*0.1)*0.1);\n    \n    \n    float ground = clamp((1.-sky/2.)*1.3, 0.,1.);\n    vec3 groundcol = vec3(0,ground,0);\n    vec3 mountaincol = vec3(ground);\n    \n    float rand = fract(sin(1924.231)*29183.);\n    float height = (((sin(uv.x+2.23*rand)*1.2+sin(uv.x+1.23*2.12*rand)/rand+sin(uv.x*4.)/3.)/3.)+5.)/2.;\n    float mountain_height = ((sin(uv.x*rand)*1.2+sin(uv.x*2.12142908*rand)/rand+sin(uv.x*4.)/3.)/3.)+5.-noise(uv.x*1.5)-noise(uv.x*5.)/5.;\n    \n    float groundfac = clamp( (uv.y+height)*20. , 0., 1.);\n    float mountainfac = clamp( (uv.y-5.+mountain_height)*20. , 0., 1.);\n    vec3 col;\n    \n    col = mix(skycol,vec3(1.,1.,0.),sunfac);\n    col = mix(mountaincol,col,mountainfac);\n    col = mix(groundcol,col,groundfac);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3BWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 64], [66, 66, 86, 86, 153], [155, 155, 176, 176, 267], [269, 269, 290, 290, 489], [491, 491, 548, 598, 1693]], "test": "untested"}
{"id": "NdXSWf", "name": "Daily Practice 04/24/21", "author": "byt3_m3chanic", "description": "Daily shader - was something that came to mind as a quick concept - ended up spending the weekend playing around to get this.", "tags": ["raymarching", "sphere", "reflections"], "likes": 9, "viewed": 401, "published": 3, "date": "1619365347", "time_retrieved": "2024-07-30T19:23:39.061159", "image_code": "/**\n    Daily Shader Practice - well maybe weekend shader practice.\n    \n    The pistons in the back can give away the pully system in place\n    for the motion. Otherwise it's a mess of code.\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .0001\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p,vec2(23.343,43.324)))*3434.3434);\n}\nmat2 rot(float a){\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\nfloat easeOutCubic(float t) {\n    return (t = t - 1.0) * t * t + 1.0;\n}\nfloat easeInCubic(float t) {\n    return t * t * t;\n}\n\nfloat vmax(vec3 p){\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat box(vec3 p, vec3 b){\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\n//@iq\nfloat cyl( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cap( vec3 p, float h, float r ){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvoid getMouse(inout vec3 p){\n    float x = -abs(.3*sin(T*.14));\n    float y = .65*sin(T*.2);\n    p.zy*=rot(x);\n    p.xz*=rot(y);\n}\n\n// commonly used var\nmat2 r180,r45;\nvec3 hit,hitPoint;\nfloat tmod=0.,idmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ga5=0.,ga6=0.;\nfloat time=0.,glow=0.,ambt=0.;\n\n// sdf scene\nvec2 map(vec3 p, float sg) {\n    p.y+=1.;\n\n    vec2 res = vec2(1e5,0.);\n    vec3 q = p;\n    vec3 qh = vec3(abs(q.x),q.y+12.75,q.z);\n    \n    //tunnels\n    float cutout = box(qh-vec3(5,0,-2.),vec3(1.5,13.5,1.5));\n    float bx = max(box(qh-vec3(5,0,-2.),vec3(1.75,12.125,1.75))-.01,-cutout);\n    if(bx<res.x) {\n        res = vec2(bx,2.);\n        hit=qh;\n    }  \n    \n    // platforms\n    vec3 qp = q-vec3(0,-.75,-2.);\n    float gain = ga1*15.;\n    float pt = min( box(qp-vec3( 5,-(15.-gain),0),vec3(1.,.125,1.))-.01,\n                    box(qp-vec3(-5,-gain,0),vec3(1.,.125,1.))-.01);\n    if(pt<res.x) {\n        res = vec2(pt,4.);\n        hit=qp;\n    } \n    if(sg>0.) glow+= (.0095)/(.00015+pt*pt);\n    //armbase\n    vec3 aq = q+vec3(0,.75,2.);\n    float cx = min(cyl(aq,.75,.45),cyl(aq,1.65,.15));\n    cx = min(length(aq-vec3(0,.5,0))-.45,cx);\n\n    if(cx<res.x) {\n        res = vec2(cx,2.);\n        hit=aq;\n    }  \n\n    //arm\n    vec3 ab = aq-vec3(0,.5,0);\n    \n    float degs = ga1*180.;\n    float degs2 = (ga2+ga3)*.36;\n    float degs3 = .52-(degs2);\n    mat2 baseTurn = rot(-degs*PI/180.);\n    \n    // main arm bend\n    ab.xz*=baseTurn;\n    vec3 aq2=aq;\n    aq2.xz*=baseTurn;\n    ab.xy*=rot(degs2+37.*PI/180.);\n    \n    float basedx = cyl(vec3(ab.x,abs(ab.y-1.55),ab.z)-vec3(.0,1.,0),.35,.05);\n    basedx = min(cyl(aq2-vec3(.75,.5,0),.5,.45),basedx);\n\n    vec3 abb = ab;\n    float lght = cap(abb,3.6,.05);\n    lght=min(cyl(aq2-vec3(.75,.05,1.),.15,.1),lght);\n    float lght2 =cyl(aq2-vec3(.75,.25,-1.),.15,.25);\n    \n    if(sg>0.) glow+= (.095)/(.0015+lght2*lght2);\n    if(sg>0.) ambt+= (.003)/(.0025+lght*lght);\n    \n    lght=min(lght2,lght);\n    if(lght<res.x) res =vec2(lght,4.);\n    abb.xz = abs(abb.xz)-.1;\n    float abase = cap(abb,3.6,.05);\n\n    //ball joint\n    vec3 ab2 = ab-vec3(0,3.6,0);\n    abase=min(length(ab2)-.25,abase);\n    // second arm bend\n    ab2.xy*=rot(degs3+60.*PI/180.);\n    float armlgt = 1.7;\n    abase = min(cap(ab2,armlgt,.1),abase);\n\n    float cup = cyl(ab2-vec3(0,armlgt,0),.35,.1);\n    abase=min(cup,abase);\n    abase=min(basedx,abase);\n    if(abase<res.x) {\n        res = vec2(abase,2.);\n        hit=ab;\n    } \n\n    // back pistons\n    float bak= box(q-vec3(0,-.5,-7.5),vec3(7.,.5,2.))-.15;\n    if(bak<res.x) {\n        res = vec2(bak,2.);\n        hit=q;\n    } \n    \n    float sp = cyl(q-vec3(  5.0 , ga1+.3, -7.5),1.35,ga1 );\n    sp = min(  cyl(q-vec3(  0.0 , ga2+.3, -7.5),1.35,ga2),sp);\n    sp = min(  cyl(q-vec3( -5.0 , ga3+.3, -7.5),1.35,ga3),sp);\n    if(sp<res.x) {\n        res = vec2(sp,2.);\n        hit=q;\n    } \n\n    // balls\n    vec3 blq = aq-vec3(0,2,0); \n    float deg3=0.,ofsx=0.;\n    \n    if(tmod>1.&&tmod<9.) {\n        blq.xz*=baseTurn;\n        deg3 =ga3+ga2+.15;  \n    } else if(tmod>9.&&tmod<12.) {\n        blq.xz*=r180;\n        deg3 =(16.15-gain);\n    } else if(tmod<1.||tmod>9.) {\n        deg3 =gain+1.15;\n    }\n    \n    if(tmod>1.&&tmod<8.) ofsx=(.2+ga2*.85)-1.;\n    if(tmod>8.&&tmod<9.) ofsx=(.2+ga3*.85)-1.;\n\n    float sphere = length(blq+vec3(5.+(ofsx),deg3,0))-.75;\n    if(sphere<res.x) {\n        res = vec2(sphere,2.);\n        hit=q;\n    } \n\n    float ground = max(p.y+.75,-cutout);\n    if(ground<res.x) {\n        res = vec2(ground,1.);\n        hit=p;\n    }   \n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    vec2 e = vec2(t*MIN_DIST,0);\n    float d= map(p,0.).x;\n    vec3 n = d - vec3(\n        map(p-e.xyy,0.).x,\n        map(p-e.yxy,0.).x,\n        map(p-e.yyx,0.).x\n        );\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d,sg);\n        if(ray.x<MIN_DIST*d) break;\n        d += i>150 ? ray.x*.5 : ray.x;\n        m  = ray.y;\n        if(d>MAX_DIST) break;\n       \n    }\n\treturn vec2(d,m);\n}\n\n//diffused shadow\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt)\n{\n    float k = 17.5;\n    float res = 1.0;\n    for( float t=mint; t < maxt; ){\n        float h = map(ro + rd*t,0.).x;\n        if( h<.001 )\n            return 0.;\n        res = min( res, k*h/t );\n        t += h;\n        if( res<.0001 || t>maxt ) break;\n    }\n    return res;\n}\n\nconst vec3 c = vec3(.95,.97,.98),\n           d = vec3(.06,.91,.70);\nvec3 hue(float t){ \n    return .55 + .45*cos( 13.+PI2*t*(c*d) ); \n}\n\nvec3 getStripes(vec2 uv){\n    uv.y+=T*1.2;\n    uv.y -= tan(radians(45.)) * uv.x;\n    float sd = mod(floor(uv.y * 5.5), 2.);\n    vec3 background = (sd<1.) ? vec3(.5) : vec3(.3);\n    return background;\n}\n\nvec3 getColor(float m) \n{\n    vec3 h = vec3(.1);\n    if(m==1.)\n    {\n        vec3 f  = fract(hitPoint*.2)-.5;\n        h  = (f.x*f.z>0.) ? vec3(0.255,0.459,0.506) : vec3(0.051,0.098,0.110) ; \n    }\n    if(m==4.) h  = (tmod<5.||tmod>12.) ? vec3(.01,.5,.1) : vec3(.69,.01,.02); \n    if(m==3.) h  = vec3(.359); \n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = iTime;\n    tmod = mod(time, 16.);\n    idmod = floor((time/16.-tmod));\n    float t1 = linearstep(2.0, 8.0, tmod);\n    float t2 = linearstep(9.0, 15., tmod);\n    float a1 = easeOutCubic(t1);\n    float a2 = easeOutCubic(t2);\n    \n    float t3 = linearstep(0.0, 1.0, tmod);\n    float t4 = linearstep(1.0, 2.0, tmod);\n    float a3 = easeOutCubic(t3);\n    float a4 = easeOutCubic(t4);\n    \n    float t5 = linearstep(8.0, 9.0, tmod);\n    float t6 = linearstep(9.0,10.0, tmod);\n    float a5 = easeOutCubic(t5);\n    float a6 = easeOutCubic(t6); \n\n    \n    ga1 = (t1-t2);\n    ga2 = (t3-t4);\n    ga3 = (a5-a6);\n    \n    r180 = rot(180.*PI/180.);\n   \n    \n    vec3 C =vec3(0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    // if you like to be retro - uncomment for fun\n    //uv = floor(uv*(86.*R.x/R.y))/(86.*R.x/R.y);\n\n    vec3 FC = mix(vec3(0.114,0.208,0.227),vec3(0.063,0.075,0.078),(uv.y-.5)*1.4);\n    \n    vec3 ro = vec3(0,0,8);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    getMouse(ro);\n    getMouse(rd);\n    \n    vec2 ray = marcher(ro,rd,255,1.);\n    float d = ray.x;\n    float m = ray.y;  \n    hitPoint=hit;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro+rd*d;\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(28.,8.,24.);\n        vec3 l = normalize(lpos-p);\n        // shade\n        float diff = clamp(dot(n,l),0.,1.) * 2.;\n        // shadow\n        float shadow = softshadow(p, l, 0.01, 12.0);\n        diff *= shadow;\n        \n        // coloring\n        vec3 h = getColor(m);\n        //specular \n        vec3 view = normalize(p - ro);\n        vec3 ref = reflect(normalize(lpos), n);\n        float spec =  0.75 * pow(max(dot(view, ref), 0.), 23.);\n        \n        C += h * diff+spec;\n        \n        // refleckt\n        if(m==2.)\n        {\n            vec3 rr=reflect(rd,n); \n            ray = marcher(p+(n*MIN_DIST),rr, 128,1.);\n            float rd = ray.x;\n            float rm = ray.y;  \n            hitPoint=hit;\n            if(rd<MAX_DIST){\n                p += rr*rd;\n                n = normal(p,rd);\n                l = normalize(lpos-p);\n                // shade\n                diff = clamp(dot(n,l),0.,1.);\n                // shadow\n                shadow = softshadow(p, l, 0.01, 12.0);\n                diff *= shadow;\n\n                // coloring\n                h = getColor(rm);\n\n                C = mix(C,h * diff,.75);\n                \n                // refleckt 2\n                if(m==2.)\n                {\n                    rr=reflect(rr,n); \n                    ray = marcher(p+(n*MIN_DIST),rr, 128,1.);\n                    rd = ray.x;\n                    rm = ray.y;  \n                    hitPoint=hit;\n                    if(rd<MAX_DIST){\n                        p += rr*rd;\n                        n = normal(p,rd);\n                        l = normalize(lpos-p);\n                        // shade\n                        diff = clamp(dot(n,l),0.,1.);\n                        // shadow\n                        shadow = softshadow(p, l, 0.01, 12.0);\n                        diff *= shadow;\n\n                        // coloring\n                        h = getColor(rm);\n\n                        C = mix(C,h * diff,.5);\n                    }\n                }\n            }\n        }\n        \n    } else {\n        C = FC;\n    }\n    \n    // standard fog based on distance\n    C = mix( C, FC, 1.-exp(-.000125*d*d*d));   \n     \n    vec3 ghue = (tmod<5.||tmod>12.) ? vec3(.01,.5,.1) : vec3(.69,.01,.02);\n    float glowMask = clamp(smoothstep(0.,9.,glow),0.,.9);\n    C = mix( C,clamp(C+glow*ghue,0.,.9), glowMask);    \n    float ambientMask = clamp(smoothstep(0.,9.,ambt),0.,.9);\n    C = mix( C,clamp(C+ambt,0.,.9), ambientMask);    \n   \n    if(m==1.){\n        vec3 stripes =getStripes(uv*5.3);\n        float f= .45+(.25*sin(uv.x*1.5+T));\n        float g= .75+(.27*sin(uv.y*1.7+T));\n        bool uvx = (uv.x<g&&uv.x>-g);\n        bool uvy = (uv.y<f&&uv.y>-f);\n        float ck = uvx && uvy ? 0. : 1.;\n        C = mix(C,vec3(stripes),ck);\n    }  \n    \n    // gamma correction\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[363, 363, 385, 385, 448], [449, 449, 467, 467, 516], [517, 517, 568, 568, 627], [628, 628, 657, 657, 699], [700, 700, 728, 728, 752], [754, 754, 773, 773, 809], [811, 811, 837, 837, 916], [917, 923, 961, 961, 1068], [1070, 1070, 1108, 1108, 1167], [1169, 1169, 1197, 1197, 1299], [1454, 1467, 1495, 1495, 4709], [4711, 4711, 4741, 4741, 4941], [4943, 4943, 4998, 4998, 5261], [5263, 5281, 5342, 5342, 5616], [5686, 5686, 5704, 5704, 5753], [5755, 5755, 5780, 5780, 5956], [5958, 5958, 5983, 5983, 6281], [6283, 6283, 6324, 6324, 10383]], "test": "untested"}
{"id": "NdlXDX", "name": "Remake of \"Sign by NIINOMI\"", "author": "avin", "description": "Remake of the tweet https://twitter.com/r21nomi/status/1386323991443361799", "tags": ["lines"], "likes": 13, "viewed": 350, "published": 3, "date": "1619364608", "time_retrieved": "2024-07-30T19:23:39.942802", "image_code": "#define PI 3.141592653589\n\n#define BACKGROUND vec3(238, 238, 254) / 255.\n#define PURPLE vec3(98, 53, 167) / 255.\n#define YELLOW vec3(248, 205, 58) / 255.\n#define RED vec3(224, 64, 86) / 255.\n#define BLUE vec3(67, 102, 251) / 255.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n  uv *= 1.25;\n\n  float t = iTime * 2.5;\n\n  vec3 rCol = BACKGROUND;\n  float f = 0.;\n  vec2 vuv = vec2(0.);\n  float fillFactor = 0.;\n\n  float size = .20;\n  float stepFactor = .05;\n  float moveFactor = size + stepFactor;\n\n  // PHASE 1 (circle)\n\n  vuv = uv + vec2(moveFactor, 0.);\n  fillFactor = step(-size, vuv.x) * step(vuv.x, size) * step(-size, vuv.y) * step(vuv.y, size);\n  f = step(fract(length(vuv) * 10. - iTime), .5);\n  rCol = mix(rCol, YELLOW, fillFactor * f);\n\n  // PHASE 2 (arrow down)\n\n  vuv = uv - vec2(moveFactor, 0.);\n  fillFactor = step(-size, vuv.x) * step(vuv.x, size) * step(-size, vuv.y) * step(vuv.y, size);\n  f = step(fract(vuv.y * 7. - abs(vuv.x * 7.) + t), .5);\n  rCol = mix(rCol, RED, fillFactor * f);\n\n  // PHASE 3 (corner)\n\n  vuv = uv + vec2(moveFactor * 3., 0.);\n  fillFactor = step(-size, vuv.x) * step(vuv.x, size) * step(-size, vuv.y) * step(vuv.y, size);\n  float ca = cos(PI * .25);\n  float sa = sin(PI * .25);\n  mat2 rot = mat2(ca, -sa, sa, ca);\n  vuv *= rot;\n  f = step(fract(vuv.y * 7. - abs(vuv.x * 7.) + t), .5);\n  rCol = mix(rCol, PURPLE, fillFactor * f);\n\n  // PHASE 3 (lines)\n\n  vuv = uv - vec2(moveFactor * 3., 0.);\n  fillFactor = step(-size, vuv.x) * step(vuv.x, size) * step(-size, vuv.y) * step(vuv.y, size);\n  f = step(fract(uv.y * 10. + t), .5);\n  rCol = mix(rCol, BLUE, fillFactor * f);\n\n  fragColor = vec4(rCol, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlXDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 286, 286, 1714]], "test": "untested"}
{"id": "NssXWX", "name": "Kaleidoscope 1", "author": "emymin", "description": "kaleidoscope experiment", "tags": ["kaleidoscope"], "likes": 1, "viewed": 76, "published": 3, "date": "1619361167", "time_retrieved": "2024-07-30T19:23:40.808487", "image_code": "vec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat runes(vec2 uv){\n    vec2 tuv = fract(uv);\n    vec2 id = floor(uv);\n    \n    if( rand(id)<0.3 ) tuv.x=1.-tuv.x;\n    if( rand(id)>0.6 ) if(rand(id)>0.8){tuv.x*=1.-tuv.x;} else {tuv.y*=1.-tuv.y;}\n    float runes = 1. - step(0.9, abs(abs(tuv.x-tuv.y)-.5)*10. );\n    return runes;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    int iterations = 5;\n    float s=0.5*sin(iTime*0.01);\n\tfor(int i=0;i<iterations;i++){\n\t\tuv=abs(uv)-s;\n\t\tuv=rot(uv,iTime*0.1);\n\t\ts=s/2.;\n\t}\n    \n    uv*=20.;\n    uv-=iTime*2.;\n    float runes = runes(uv);\n    vec4 texture = texture(iChannel0,uv);\n\n    vec3 col = vec3(1.,0.,0.)*runes;\n    //col = texture.rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 91], [92, 92, 112, 112, 179], [180, 180, 201, 201, 463], [465, 465, 522, 522, 960]], "test": "untested"}
{"id": "fdsXWX", "name": "Material Maker Experiment 001", "author": "PauloFalcao", "description": "Made in materialmaker just using 7 nodes! :)", "tags": ["generated", "materialmaker", "nodes"], "likes": 6, "viewed": 360, "published": 3, "date": "1619360438", "time_retrieved": "2024-07-30T19:23:41.947442", "image_code": "// Material Maker Experiment 001\n// By PauloFalcao\n//\n// Made in materialmaker just using 7 nodes! :)\n//\n// MaterialMaker is a nodebased shader maker to make procedural textures\n// With custom nodes GLSL nodes created directly in the tool,\n// it's possible to make complex stuff like raymarching :)\n//\n// It's also possible to export the generated code to Shadertoy!\n//\n// I made a library with Ray Marching nodes\n// 1st version 0.01 have 44 new nodes\n// Some nodes are based in code from other authors from shadertoy\n// I always refer the shader author and the shadertoy original code\n// The idea is to reuse the code to quicky create something without coding experience\n// Or just focus on the code of a single node\n//\n// You need Material Maker - https://rodzilla.itch.io/material-maker\n// And my library - https://github.com/paulofalcao/MaterialMakerRayMarching\n// This Material Maker graph is here\n// https://raw.githubusercontent.com/paulofalcao/MaterialMakerRayMarching/main/Examples/pxf001.mms\n// Just copy paste the code into Material Maker and the graph will appear! :)\n// Or save the file and use \"Edit\"->\"Load Selection\"\n// \n\n\nvec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\n\nconst float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\nconst float p_o1356810_CamY = 1.450000000;\nconst float p_o1356810_LookAtX = 0.000000000;\nconst float p_o1356810_LookAtY = 0.000000000;\nconst float p_o1356810_LookAtZ = 0.000000000;\nconst float p_o1356810_CamD = 1.500000000;\nconst float p_o1356810_CamZoom = 0.695000000;\nconst float p_o1356810_Reflection = 0.179000000;\nconst float p_o1356810_Specular = 1.000000000;\nconst float p_o1356810_Pow = 275.430000000;\nconst float p_o1356810_SunX = 0.439999998;\nconst float p_o1356810_SunY = 1.480000019;\nconst float p_o1356810_SunZ = -0.976000011;\nconst float p_o1356810_AmbLight = 0.250000000;\nconst float p_o1356810_AmbOcclusion = 0.391000000;\nconst float p_o1356810_Shadow = 0.921000000;\nconst float p_o1356813_r = 0.069900000;\n\nfloat o1356807_input_obj3d(vec3 p) {\n    float o1356813_0_1_sdf3d = length((p))-p_o1356813_r;\n    return o1356813_0_1_sdf3d;\n}\n\nconst float p_o1356804_smooth = 0.000990000;\nconst float p_o1356801_x = 0.086000000;\nconst float p_o1356801_y = 0.060000000;\nconst float p_o1356801_z = 0.096000000;\n\nvec4 o1356807_input_trans3d(vec4 p) {\n    vec4 o1356798_0_1_v4v4 = (vec4(v4v4_rotate((vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o1356804_smooth)),(p).w)).xyz-vec3(p_o1356801_x, p_o1356801_y, p_o1356801_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o1356804_smooth)),(p).w)).w)).xyz, -vec3((sin(iTime*4.0)*16.0), (sin(iTime*2.2)*16.0), (sin(iTime*1.3)*16.0))*0.01745329251), (vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o1356804_smooth)),(p).w)).xyz-vec3(p_o1356801_x, p_o1356801_y, p_o1356801_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o1356804_smooth)),(p).w)).w)).w));\n    vec4 o1356795_0_1_v4v4 = o1356798_0_1_v4v4;\n    vec4 o1356801_0_1_v4v4 = o1356795_0_1_v4v4;\n    vec4 o1356804_0_1_v4v4 = o1356801_0_1_v4v4;\n\n    return o1356804_0_1_v4v4;\n}\n\nfloat o1356807_input_custombool(vec2 uv) {\n    return min((uv).x,(uv).y);\n}\n\nfloat for_fold_o1356807(vec4 p) {\n  for(int i=0;i<6;i++){\n    p=o1356807_input_trans3d(p);\n  }\n  return o1356807_input_obj3d(p.xyz);\n}\n\nfloat for_min_o1356807(vec4 p) {\n  float m=999999.0;\n  for(int i=0;i<6;i++){\n    p=o1356807_input_trans3d(p);\n\tfloat d=o1356807_input_obj3d(p.xyz);\n\tm=min(m,d);\n  }\n  return m;\n}\n\nfloat for_custom_o1356807(vec4 p) {\n  float m=999999.0;\n  for(int i=0;i<6;i++){\n    p=o1356807_input_trans3d(p);\n\tfloat d=o1356807_input_obj3d(p.xyz);\n\tm=o1356807_input_custombool(vec2(m,d));\n  }\n  return m;\n}\n\nfloat o1356810_input_sdf_a(vec3 p) {\n    float o1356807_0_1_sdf3d = for_fold_o1356807(vec4((p),0.0));\n    return o1356807_0_1_sdf3d;\n}\n\nvec3 o1356810_input_tex3d_a(vec4 p) {\n    return vec3(1.0,0.1,0.1);\n}\n\nfloat o1356810_input_sdf_b(vec3 p) {\n    return max((p).y+1.0,length(vec3((p).x,(p).y+1.0,(p).z))-10.0);\n}\n\nvec3 o1356810_input_tex3d_b(vec4 p) {\n    return vec3(mod(floor((p).x*2.0)+floor((p).z*2.0),2.0))*0.9+0.1;\n}\n\nvec3 o1356810_input_hdri(vec2 uv) {\n    return Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o1356810_SunX,p_o1356810_SunY,-p_o1356810_SunZ)));\n}\n\nvec2 input_o1356810(vec3 p) {\n    float sdfa=o1356810_input_sdf_a(p);\n\tfloat sdfb=o1356810_input_sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o1356810(vec3 p){  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=input_o1356810(p+e.xyy).x;\n  float v2=input_o1356810(p+e.yyx).x;\n  float v3=input_o1356810(p+e.yxy).x;\n  float v4=input_o1356810(p+e.xxx).x;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o1356810(inout float d,inout vec3 p,inout vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = input_o1356810(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o1356810( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = input_o1356810( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o1356810( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = input_o1356810( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_o1356810(vec2 uv) {\n    uv-=0.5;\n\tvec3 cam=vec3((sin(iTime*0.1)*4.0),p_o1356810_CamY,(cos(iTime*0.13)*4.0))*p_o1356810_CamZoom;\n\tvec3 lookat=vec3(p_o1356810_LookAtX,p_o1356810_LookAtY,p_o1356810_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o1356810_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_o1356810(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=(dS.y<0.5)?o1356810_input_tex3d_a(vec4(p,1.0)):o1356810_input_tex3d_b(vec4(p,1.0));\n\tvec3 light=normalize(vec3(p_o1356810_SunX,p_o1356810_SunY,p_o1356810_SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_o1356810(p);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_o1356810(p,n),p_o1356810_AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_o1356810(p,light,0.05,5.0),p_o1356810_Shadow);\n\t\tcolor=min(vec3(max(shadow,p_o1356810_AmbLight)),max(l,p_o1356810_AmbLight))*max(cAO,p_o1356810_AmbLight)*objColor+pow(r,p_o1356810_Pow)*p_o1356810_Specular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o1356810(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=(dS.y<0.5)?o1356810_input_tex3d_a(vec4(p,1.0)):o1356810_input_tex3d_b(vec4(p,1.0));\n\t\t\tn=normal_o1356810(p);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o1356810_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o1356810_input_hdri(equirectangularMap(ref.xzy)).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,p_o1356810_Reflection);\n\t} else {\n\t\tcolor=o1356810_input_hdri(equirectangularMap(rd.xzy)).xyz;\n\t}\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float minSize = min(iResolution.x, iResolution.y);\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 o1356810_0_1_rgb = raymarch_o1356810((UV));\n    fragColor = vec4(o1356810_0_1_rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1139, 1139, 1173, 1173, 1477], [1510, 1510, 1545, 1545, 1634], [1658, 1732, 1767, 1767, 1884], [1886, 1886, 1919, 1919, 2215], [2217, 2217, 2253, 2253, 2460], [2462, 2462, 2497, 2497, 2706], [2708, 2708, 2745, 2745, 2834], [2836, 2836, 2886, 2886, 3433], [3435, 3435, 3483, 3483, 3753], [4497, 4497, 4533, 4533, 4623], [4791, 4791, 4828, 4828, 5515], [5517, 5517, 5559, 5559, 5592], [5594, 5594, 5627, 5627, 5728], [5730, 5730, 5762, 5762, 5908], [5910, 5910, 5945, 5945, 6119], [6121, 6121, 6157, 6157, 6255], [6257, 6257, 6294, 6294, 6326], [6328, 6328, 6364, 6364, 6434], [6436, 6436, 6473, 6473, 6544], [6546, 6546, 6581, 6581, 6713], [6715, 6715, 6744, 6744, 6906], [6908, 6984, 7013, 7013, 7271], [7273, 7273, 7353, 7353, 7517], [7519, 7564, 7614, 7614, 7883], [7885, 7930, 8015, 8015, 8334], [8336, 8336, 8369, 8369, 10056], [10058, 10058, 10113, 10113, 10373]], "test": "untested"}
{"id": "ssfSWf", "name": "Volumetric fractal golf", "author": "michael0884", "description": "just trying to optimize the code size, the only criterion is for it to look similar enough\nwas golfing this thing with https://www.shadertoy.com/user/loicvdb", "tags": ["2tweets"], "likes": 27, "viewed": 590, "published": 3, "date": "1619354319", "time_retrieved": "2024-07-30T19:23:42.794178", "image_code": "//318 by Xor\n#define V vec3\n#define f for(int i; i++<9;)\n\nvoid mainImage(out vec4 o, vec2 u) {\n    V R = iResolution, p = V(0,9,50.+fract(u*.5+u.y*.3)), a, l, c, e;\n    a++;\n    f f {\n        f {\n            c.y--;\n            V z = c.zzz*.1;\n            f z = V(z.x*z.x/z.y-z.y,z+z)*z.y + c*.1;\n            l *= e = dot(z,z) < 4. ? V(.6,.7,.8) : V(1);\n        }\n        o.rgb-=l*e-l;\n        l=a*=e;\n        c = p+=V(u-R.xy*.5, -R)/R.x;\n        c.xz *= mat2(sin(iTime-V(0,11,3)).yzxy);\n    }\n}\n\n\n//321 by loicvdb\n/*#define V vec3\n#define f for(int i; i++<9;)\n\nvoid mainImage(out vec4 o, vec2 u) {\n    V R = iResolution, p = V(0,9,50.+fract(u.x*.5+u.y*.3)), a, l, c, e;\n    a++;\n    f f {\n        f {\n            c.y--;\n            V z = c.zzz*.1;\n            f z = V(z.x*z.x-z.y*z.y, 2.*z.y*z) + c*.1;\n            l *= e = dot(z,z) < 4. ? V(.6,.7,.8) : V(1);\n        }\n        o.rgb-=l*e-l;\n        l=a*=e;\n        c = p+=V(u-R.xy*.5, -R)/R.x;\n        c.xz *= mat2(sin(iTime-V(0,11,3)).yzxy);\n    }\n}\n\n/*\n//322 by loicvdb\n\n#define V vec3\n#define f for(int i; i<9; i++)\n\nvoid mainImage(out vec4 o, vec2 u) {\n    V R = iResolution, p = V(0,9,50.+fract(u.x*.5+u.y*.3)), a, l, c, e;\n    a++;\n    f f {\n        f {\n            c.y--;\n            V z = c.zzz*.1;\n            f z = V(z.x*z.x-z.y*z.y, 2.*z.y*z) + c*.1;\n            l *= e = dot(z,z) < 4. ? V(.6,.7,.8) : V(1);\n        }\n        o.rgb-=l*e-l;\n        l=a*=e;\n        c = p+=V(u-R.xy*.5, -R)/R.x;\n        c.xz *= mat2(sin(iTime-V(0,11,3)).yzxy);\n    }\n}\n\n\n/*\n//327 chars by me\n\n#define V vec3\n#define f for(int i; i<9; i++)\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    V R = iResolution, p = V(0,0,50.+fract(u.x*.5+u.y*.3)), a, l, x;\n    a++;\n    f f {\n        f {\n            x = p+V(0,9-i,0);\n            x.xz *= mat2(sin(iTime-V(0,11,3)).yzxy);\n            V z = x.zzz*.1;\n            f z = V(z.x*z.x-z.y*z.y, 2.*z.y*z) + x*.1;\n            l *= x = dot(z,z) < 4. ? V(.6,.7,.8) : V(1);\n        }\n        o.rgb-=l*x-l;\n        p+=V(u-R.xy*.5, -R)/R.x;\n        l=a*=x;\n    }\n}\n\n/*\n//330 chars by loicvdb\n\n#define V vec3\n#define f for(int i; i<9; i++)\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    V R = iResolution, p = V(0,0,50.+fract(u.x*.5+u.y*.3)), a, l, x;\n    a++;\n    f f {\n        f {\n            x = p+V(0,9-i,0);\n            x.xz *= mat2(sin(iTime-V(0,11,3)).yzxy);\n            V z = x.zzz*.1;\n            f z = V(z.x*z.x-z.y*z.y, 2.*z.y*z) + x*.1;\n            l /= x = exp(V(dot(z,z) < 4.)*V(5,4,3)*.1);\n        }\n        o.rgb-=l/x-l;\n        p+=V(u-R.xy*.5, -R)/R.x;\n        l=a/=x;\n    }\n}\n\n/*\n\n//340 chars by me\n\n#define V vec3\n#define f for(int i; i<9; i++)\n\nvoid mainImage(out vec4 o, vec2 u) \n{\n    V R = iResolution, \n    p = V(0,0,50.+fract(u.x*.5+u.y*.3)),//bayer dither\n    a, l, \n    z, b, m; a++;\n    f f //ray marching loop\n    f //shadow loop\n    { \n      m = i>0 ? p+V(0,i,0) : p+=V(u-R.xy*.5, -R)/R.x;\n      m.xz *= mat2(sin(iTime-V(0,11,22)).yzxy); //rotation, closest integers to multiples of pi used here\n      z = m.zzz*.1;\n      f z = V(z.x*z.x-z.y*z.y, 2.*z.y*z) + m*.1; //fractal loop\n      b = exp(V(dot(z,z) < 4.) * V(.5,.4,.3)); //extinction\n    \n      i>0 ? l/=b: o.rgb-=l/b-l, l=a/=b; //integrate color\n    }\n}\n\n///350 chars by me\n\n#define V vec3\n#define f for(int i; i<9; i++)\n\nV e(V p) //density\n{\n    p.xz *= mat2(sin(iTime-V(0,11,22)).yzxy); //rotation, closest integers to multiples of pi used here\n    V z = p.zzz;\n    f z = V(z.x*z.x-z.y*z.y, 2.*z.y*z) + p; //fractal loop\n    return exp(V(dot(z,z) < 4.) * V(.5,.4,.3)); //extinction\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) \n{\n    V R = iResolution, \n    d = .1*V(u-R.xy*.5, -R)/R.x, //ray\n    p = V(0,0,5) + d*fract(u.x*.5+u.y*.3),//bayer dither\n    a, l; a++;\n    f f //ray marching loop\n    { \n      o.rgb-=l/e(p+=d)-l, l=a/=e(p); //integrate color\n      f l/=e(p+.1*V(0,i,0)); //shadow ray\n    }\n}\n\n\n\n\n\n\n///351 chars\n\n\n#define V vec3\n#define f for(int i; i<9; i++)\n\nV e(V p) //density\n{\n    p.xz *= mat2(sin(iTime-V(0,11,22)).yzxy); //rotation, closest integers to multiplies of pi used here\n    V z = p.zzz;\n    f z = V(z.x*z.x-z.y*z.y, 2.*z.y*z) + p; //fractal loop\n    return exp(V(dot(z,z) < 4.) * V(.5,.4,.3)); //extinction\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) \n{\n    V R = iResolution, \n    d = .1*V(u-R.xy*.5, -R)/R.y, //ray\n    p = V(0,0,5) + d*fract(u.x*.5+u.y*.3),//bayer dither\n    a, l; a++;\n    f f //ray marching loop\n    { \n      o.rgb-=l/e(p+=d)-l, l=a/=e(p); //integrate color\n      f l/=e(p+.1*V(0,i,0)); //shadow ray\n    }\n}\n\n\n\n\n\n\n//365 chars\n\n#define V vec3\n#define f for(int i = 0; i<9; i++)\n\nV e(V p) //density\n{\n    p.xz *= mat2(sin(iTime+V(0,1.5,3)).yzxy); //rotation \n    V z = p.zzz*.1;\n    f z = V(z.x*z.x-z.y*z.y, 2.*z.x*z.y, 0) + p*.1; //fractal loop\n    return exp(V(dot(z,z) < 4.) * V(.5,.4,.3)); //extinction\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) \n{\n    V R = iResolution, \n    d = V(u-R.xy*.5, -R.y)/R.y, //ray\n    p = V(0,0,30) + d*fract(u.x*.5+u.y*.3),//bayer dither\n    a = V(1), l;\n    o-=o;\n    f f //ray marching loop\n    { \n      o.rgb-=l/e(p+=d)-l, l=a/=e(p); //integrate color\n      f l/=e(p+V(0,i,0)); //shadow ray\n    }\n}\n\n\n\n\n\n//381 chars by loicvdb\n\n#define V vec3\n#define f for(int i = 0; i < 9; i++)\n\nV e(V p) {\n    p.xz *= mat2(sin(iTime+V(0,1.5,3)).yzxy);\n    p *= .1;\n    V z = p.zzz;\n    f z = V(z.x*z.x-z.y*z.y, 2.*z.x*z.y, 0) + p;\n    return exp(-V(dot(z,z) < 4.) * V(.5,.4,.3));\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    V R = iResolution, \n    d = V((u-R.xy*.5)/R.y, -1),\n    p = V(0,0,30) + d*fract(u.x*.5+u.y*.3),\n    a = V(1),\n    b, l;\n    for(o-=o; dot(p,p) < 1e3;\n        o.rgb-=(b=e(p+=d))*l-l,\n        l=a*=b)\n        f l *= e(p+V(0,i,0));\n}\n\n\n\n\n\n//485 chars - original starting point \n\nfloat e(vec3 p) {\n    vec2 z = p.zz, c = p.xy;\n    int i = 0;\n    for(; i < 9 && dot(z, z) < 4.; i++) z = vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y) + c;\n    return float(i>8);\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    o.xyz = iResolution;\n    float c = cos(iTime), s = sin(iTime);\n    mat3 r = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    vec3 d = vec3((u-o.xy*.5)/o.y, -1.)*r*.05,\n    p = vec3(0,0,3)*r + d*fract(u.x*.5+u.y*.3),\n    a = vec3(1),\n    v = vec3(5,4,3),\n    b;\n    o -= o;\n    for(; o.w < 99.; o.w++) {\n        vec3 l = vec3(0);\n        for(; l.y < .9; l.x -= .1*e(p+vec3(0,l.y+=.1,0)));\n        b = exp(-.05*e(p += d)*v);\n        o.rgb += (a*=b) * (1.-b) * exp(l.x*v);\n    }\n}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fdXSDX", "name": " - OpArt #2", "author": "totetmatt", "description": "Rework of OpArt 1. Now the rotation and scale are linked with a simple dot product.", "tags": ["opart"], "likes": 10, "viewed": 308, "published": 3, "date": "1619335731", "time_retrieved": "2024-07-30T19:23:43.556141", "image_code": "float box(vec2 uv,vec2 b){\n    vec2 q = abs(uv)-b;\n    return length(max(q,vec2(0.)))+ min(max(q.x,q.y),0.);\n}\nvec3 pal(float t){\n    return vec3(.5,.4,.5)+vec3(.5,.4,.5)*cos(6.28*(vec3(1.,1.,1.)*t+vec3(.40,.55,.60)));\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    float tempo=clamp(sin(iTime*.33),0.,.5);\n    uv*=4.+tempo;\n    uv+=fract(iTime*.01)*3.1415*2.;\n\n    uv*=rot(.785);\n    vec2 id = floor(uv);\n   uv = fract(uv)-.5;\n    if(mod(id.x,2.)==1.) { uv.x*=-1.;}\n        if(mod(id.y,2.)==1.) { uv.y*=-1.;}\n    vec3 col = vec3(.1);\n    float ll = 50.;\n     float  a= 1./30.;\n      if(uv.x >uv.y){\n      a+=sin(uv.y*4.)*.05+.05;\n      }\n      else {\n       a+=sin(uv.x*4.)*.05+.05;\n      }\n      a+=clamp(cos(iTime*.99)*.5,-.00,.25);\n     float rto = dot(vec2(1,1),vec2(1,0)*rot(3.1415*a));\n     \n     float d = 0.;\n    for(float i=0.;i<=ll;i++){\n    float l = box(uv,vec2(1.0));\n      \n\n      l = smoothstep(0.02,0.00099,(abs(l)-(.005-(1.-i)*.005)));\n      \n\n      d+=l;\n     \n      uv*=rot(3.1415*a);\n      \n      float q = rto;\n      uv*= q;\n  \n      \n    }\n    //d= d/ll;\n    \n    col = mix(vec3(0.1)+pal(tempo),vec3(.3,.5,.7),vec3(d));pal(d/ll);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 110], [111, 111, 129, 129, 220], [221, 221, 239, 239, 286], [287, 287, 342, 342, 1330]], "test": "untested"}
{"id": "NsfSWf", "name": "Autonomous Camera 3D", "author": "oneshade", "description": "A spinoff of my 2D version: [url=https://www.shadertoy.com/view/NdfXWX]https://www.shadertoy.com/view/NdfXWX[/url]", "tags": ["procedural", "3d", "camera", "random", "autonomous"], "likes": 3, "viewed": 133, "published": 3, "date": "1619313029", "time_retrieved": "2024-07-30T19:23:44.370962", "image_code": "struct Camera {\n    vec3 pos;\n    mat3 ori;\n};\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 Hash13(in float t) {\n   vec3 p3 = fract(t * vec3(0.1031, 0.1030, 0.0973));\n   p3 += dot(p3, p3.yzx + 33.33);\n   return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nCamera getCamera(in float t) {\n    float id = floor(t), local = fract(t);\n    vec3 a = Hash13(id), b = Hash13(id + 1.0), c = Hash13(id + 2.0);\n    vec3 mid1 = 0.5 * (a + b), mid2 = 0.5 * (b + c);\n\n    float tInv = 1.0 - local;\n    vec3 pos = mid1 * tInv * tInv + 2.0 * b * tInv * local + mid2 * local * local;\n\n    vec3 f = normalize(mid1 * (local - 1.0) + (1.0 - 2.0 * local) * b + mid2 * local);\n    vec3 r = vec3(-f.z, 0.0, f.x) / sqrt(1.0 - f.y * f.y);\n    vec3 u = cross(r, f);\n\n    return Camera(pos, mat3(r, u, f));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0);\n\n    Camera cam = getCamera(iTime * 0.25);\n\n    vec3 ro = cam.pos * 100.0 - 50.0;\n    vec3 rd = normalize(vec3(uv, 1.0)) * transpose(cam.ori);\n\n    float t = 0.0, k = 0.0, d;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        d = length(mod(p, 2.0) - 1.0) - 0.25;\n        if (d < 0.001 || t > 100.0) break;\n        t += d;\n        k++;\n    }\n\n    fragColor = vec4(0.5 - k / 100.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 89, 114, 114, 250], [252, 252, 282, 282, 776], [778, 778, 833, 833, 1331]], "test": "untested"}
{"id": "7sXXRX", "name": "Every Color I guess", "author": "Txoka", "description": "Rainbow :)", "tags": ["colors"], "likes": 3, "viewed": 269, "published": 3, "date": "1619305177", "time_retrieved": "2024-07-30T19:23:45.383256", "image_code": "float gamma=2.2;\nfloat pi=atan(1.)*4.;\nfloat I=1.;\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\tvec3 p=abs(fract(c.x+K.xyz)*6.0-K.w);\n\treturn c.z*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),c.y);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=(2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3 col=vec3(0);\n    \n    float a=atan(uv.x,uv.y)/(2.*pi);\n    float l=length(uv);\n    \n    col=hsv2rgb(vec3(a,1.-clamp(1.-l*2.,0.,1.),clamp(2.-l*2.,0.,1.)));\n    //col=col; :)\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 74, 74, 199], [201, 201, 254, 254, 527]], "test": "untested"}
{"id": "NdfXWX", "name": "Autonomous Movement 2D", "author": "oneshade", "description": "Autonomous movement.", "tags": ["2d", "random", "movement", "autonomous"], "likes": 8, "viewed": 199, "published": 3, "date": "1619300246", "time_retrieved": "2024-07-30T19:23:46.173144", "image_code": "float sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n\n    Camera cam = getCamera(float(iFrame) * 0.02);\n    cam.pos = cam.pos * 4.0 - 2.0;\n\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, cam.pos, cam.pos + cam.ori[0] * 0.5, 0.01)));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, cam.pos, cam.pos + cam.ori[1] * 0.5, 0.01)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct Camera {\n    vec2 pos;\n    mat2 ori;\n};\n\nvec2 Hash12(in float t) {\n\tvec3 p3 = fract(t * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nCamera getCamera(in float t) {\n    float id = floor(t), local = fract(t);\n    vec2 a = Hash12(id), b = Hash12(id + 1.0), c = Hash12(id + 2.0);\n    vec2 mid1 = 0.5 * (a + b), mid2 = 0.5 * (b + c);\n\n    vec2 pos = mix(mix(mid1, b, local), mix(b, mid2, local), local);\n    vec2 dir = normalize(mid1 * (local - 1.0) + (1.0 - 2.0 * local) * b + mid2 * local);\n\n    return Camera(pos, mat2(dir.y, -dir.x, dir));\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n\n    Camera cam = getCamera(float(iFrame) * 0.02);\n    cam.pos = cam.pos * 4.0 - 2.0;\n\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0), smoothstep(unit, 0.0, length(uv - cam.pos) - 0.05));\n    fragColor.rgb *= 0.99;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfXWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 171], [173, 173, 228, 228, 769]], "test": "untested"}
{"id": "fdsSDj", "name": "Diamond Bokeh", "author": "oneshade", "description": "Cool effect.", "tags": ["imageprocessing", "bokeh", "effect", "diamond"], "likes": 8, "viewed": 304, "published": 3, "date": "1619297161", "time_retrieved": "2024-07-30T19:23:47.346008", "image_code": "vec4 fetch(in sampler2D channel, in vec2 xy) {\n    return texture(channel, xy / iResolution.xy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = fetch(iChannel0, fragCoord);\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            if (i == 0 && j == 0) continue;\n            vec3 neighbor = fetch(iChannel0, fragCoord + vec2(i, j)).rgb / length(vec2(i, j));\n            if (length(neighbor) > length(fragColor.rgb)) fragColor.rgb = neighbor;\n        }\n    }\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 fetch(in sampler2D channel, in vec2 xy) {\n    return texture(channel, xy / iResolution.xy);\n}\n\nvec2 Hash12(in float t) {\n\tvec3 p3 = fract(t * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// vec4(position, orientation)\nvec4 getCamera(in float t) {\n    float id = floor(t), local = fract(t);\n    vec2 a = Hash12(id), b = Hash12(id + 1.0), c = Hash12(id + 2.0);\n    vec2 mid1 = 0.5 * (a + b), mid2 = 0.5 * (b + c);\n\n    float tInv = 1.0 - local;\n    vec2 pos = mid1 * tInv * tInv + 2.0 * b * tInv * local + mid2 * local * local;\n    vec2 dir = normalize(mid1 * (local - 1.0) + (1.0 - 2.0 * local) * b + mid2 * local);\n\n    return vec4(pos, dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec2 oUv = uv;\n\n    vec4 camera = getCamera(iTime * 0.25);\n\n    vec2 pos = camera.xy * 5.0 - 2.5;\n    uv -= pos;\n\n    vec2 face = camera.zw;\n    uv *= mat2(face.yx, -face.x, face.y);\n\n    fragColor = fetch(iChannel0, uv * iResolution.y + center);\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 fetch(in sampler2D channel, in vec2 xy) {\n    return texture(channel, xy / iResolution.xy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = fetch(iChannel0, fragCoord);\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            if (i == 0 && j == 0) continue;\n            vec3 neighbor = fetch(iChannel0, fragCoord + vec2(i, j)).rgb / length(vec2(i, j));\n            if (length(neighbor) > length(fragColor.rgb)) fragColor.rgb = neighbor;\n        }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec4 fetch(in sampler2D channel, in vec2 xy) {\n    return texture(channel, xy / iResolution.xy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = fetch(iChannel0, fragCoord);\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            if (i == 0 && j == 0) continue;\n            vec3 neighbor = fetch(iChannel0, fragCoord + vec2(i, j)).rgb / length(vec2(i, j));\n            if (length(neighbor) > length(fragColor.rgb)) fragColor.rgb = neighbor;\n        }\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec4 fetch(in sampler2D channel, in vec2 xy) {\n    return texture(channel, xy / iResolution.xy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = fetch(iChannel0, fragCoord);\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            if (i == 0 && j == 0) continue;\n            vec3 neighbor = fetch(iChannel0, fragCoord + vec2(i, j)).rgb / length(vec2(i, j));\n            if (length(neighbor) > length(fragColor.rgb)) fragColor.rgb = neighbor;\n        }\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsSDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 98], [100, 100, 155, 155, 511]], "test": "untested"}
{"id": "sdsXW2", "name": "Orthonormal Basis - A = A^-1", "author": "oneshade", "description": "The inverse of an orthonormal basis is alsoits tranpose which is much cheaper because it is just all the elements flipped diagonally.", "tags": ["inverse", "orthonormal", "basis", "transpose"], "likes": 7, "viewed": 168, "published": 3, "date": "1619289798", "time_retrieved": "2024-07-30T19:23:48.117944", "image_code": "// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    return abs(dot(p - a, normalize(b - a).yx * vec2(-1.0, 1.0)));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec3 color = vec3(0.0);\n    float unit = 8.0 / iResolution.y;\n\n    vec2 right = vec2(cos(iTime), sin(iTime));\n    mat2 mat = mat2(right, -right.y, right.x);\n    drawSDF(sdVectorArrow(uv, mat[0]), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdVectorArrow(uv, mat[1]), vec3(0.0, 1.0, 0.0));\n\n    mat2 inv = inverse(mat);\n    drawSDF(sdVectorArrow(uv, inv[0]), vec3(1.0, 1.0, 0.0));\n    drawSDF(sdVectorArrow(uv, inv[1]), vec3(0.0, 1.0, 1.0));\n\n    inv = transpose(mat);\n    drawSDF(sdVectorArrow(uv, inv[0]), vec3(1.0, 1.0, 0.0));\n    drawSDF(sdVectorArrow(uv, inv[1]), vec3(0.0, 1.0, 1.0));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 110, 164, 164, 440], [442, 442, 487, 487, 555], [557, 557, 607, 607, 676], [678, 678, 721, 721, 909], [911, 911, 966, 966, 1772]], "test": "untested"}
{"id": "7dlXW2", "name": "Hypnagogia 2", "author": "emymin", "description": "Second vision, started off as a single still ring and then started moving very fast", "tags": ["hypnagogia"], "likes": 1, "viewed": 59, "published": 3, "date": "1619288222", "time_retrieved": "2024-07-30T19:23:48.885891", "image_code": "#define PI 3.14152\n\nfloat rand(float p){\n \treturn fract(sin(p*213.23)*55132.2);   \n}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  \tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 polar = vec2(length(uv),atan(uv.y,uv.x) );\n    polar.x += noise(polar.y*5.)*sin(polar.y)*0.2;\n    polar.x = mod(polar.x-iTime*3.,.5);\n    \n    \n    float radius = 0.1;\n    float ringrad = .02;\n    \n    float ring = abs(polar.x-radius)-ringrad;\n    ring = smoothstep( radius,radius-ringrad-0.1,ring);\n    \n    vec3 col = vec3(.1,.6,1.)*ring;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlXW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 40, 40, 84], [86, 86, 107, 107, 198], [200, 200, 226, 226, 291], [293, 293, 350, 350, 830]], "test": "untested"}
{"id": "7ssSWj", "name": "Isolines Explained", "author": "jointstockact1860", "description": "FabriceNeyret2 created a great shader that used isolines. I was confused about what was going on and spent some time trying to understand the logic. Then I saved my working.", "tags": ["isolines", "isoline"], "likes": 5, "viewed": 241, "published": 3, "date": "1619279179", "time_retrieved": "2024-07-30T19:23:49.657827", "image_code": "#define PI 3.14159\n\n/*\n\n FabriceNeyret2 threw out a shader - https://www.shadertoy.com/view/ssXXWN - that\n draws isolines. No explanation is provided. I found a reference -\n https://iquilezles.org/articles/distance - in a different shader\n (https://www.shadertoy.com/view/Ms2XWc) to explain what was happening and spent a\n few hours ( :'[ ) understanding the technique.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float target;\n    \n    // f is the function we want to plot. In this case, the example will be sin(x)\n    // A little scaling is done so the function range is [0, 1] and can be displayed\n    // without getting clamped to [0, 1] by OpenGL.\n    float f = sin(uv.x * 4. * PI) * 0.5 + 0.5;\n    \n    if (uv.y > .75) \n        // Show function value\n        fragColor = vec4(f);\n    else if (uv.y > .5)\n        // Show - effectively - |df/dx| the gradient of f at x in change per pixel.\n        // This value should be ~= 0 because pixels are small vs the scale of the\n        // function. What we call 0 -> 4 pi is probably a couple of hundred pixels.\n        fragColor = vec4(fwidth(f));\n    else if (uv.y > 0.25)\n        // Now we start to introduce the lines. Gonna draw isolines when f == 0.3.\n        // Why 0.3? Well if I didn't pick any number then there would be no lines.\n        \n        // This plot indicated, using red, the difference between the value of f\n        // and the target where the isoline should go. We want the line roughly\n        // in the blackest part of the band.\n        \n        // I draw lines manually in blue to show where the isolines will go. This \n        // looks ok in this shader, but if the function was less regular this \n        // wouldn't draw a line. There'd be a blotch if I pick a value where the\n        // function stayed at 0.3 with a low gradient. sin(x) doesn't do that at \n        // 0.3. It does do that at, say, 0.03. If you change the constant and\n        // see the lines blur :/\n        target = 0.3,\n        fragColor = vec4(abs(fract(f)-target), 0, abs(f - target) <= 0.01, 0); \n    else\n        // Ok so we'll fix that blotching and force a line to be drawn.\n        \n        // 1) Imagine the line in the image displayed where f == 0.3 (which we \n        //    can't use directly because, eg, maybe f != 0.3 for any fragment \n        //    as values jumps in discrete steps and may go from soemthing like\n        //    0.29899 to 0.30001 - missing f == 0.3.\n        // 2) Consider instead the distance !e! from the line to the current\n        //    pixel. Following the reference, we start with Taylor's \n        //    approximation and realise it can all be simplified  & approximated \n        //    to:\n        //\n        //    f + gradient(of f) * !e! = 0.3\n        //\n        //    and our reference further explains that the *number of pixels* between \n        //    the current fragment and the line roughly obey the relation:\n        //\n        //    #pixels >= |0.3 - f| / |gradient(of f)|\n        //    \n        // 3) Now we can cheat. If we use that as a colour, 0 pixels is black. >1\n        //    pixels is white. So if we use that as a colour directly we get lines.\n        \n        //    I don't know how intentional it is but *if* the function is flat, ie \n        //    there is an area where f == 0.3, then fwidth will obviously be 0 and\n        //    0/0 is plotted as white in OpenGL - so no line. Excellent.\n        fragColor = vec4(abs(fract(f) - 0.3)/fwidth(f));\n        //fragColor = vec4(0/0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssSWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[375, 375, 432, 432, 3556]], "test": "untested"}
{"id": "NdsXW2", "name": "Elementary Cellular Automaton", "author": "kaihagseth", "description": "Implementation of 1d cellular automaton. Try changing the rule! Pan/zoom with arrow keys.\nhttps://mathworld.wolfram.com/ElementaryCellularAutomaton.html", "tags": ["cellularautomata", "wolfram"], "likes": 5, "viewed": 292, "published": 3, "date": "1619268294", "time_retrieved": "2024-07-30T19:23:50.551438", "image_code": "// Inspired by Stephen Wolfram :) \n// https://www.youtube.com/watch?v=VguG_y05Xe8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = vec4(vec3(1. - texelFetch( iChannel0, ivec2(fragCoord), 0 ).x), 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define RULE 30\n// Update: Stores states of automaton in buffers b and c channels... Can still be optimized\n//         a lot to store even more states without rolling over, but now it should be \n//         possible to calculate w * h iterations without overflowing.\n// Update: Added camera panning and zooming. Note that since only the \n//         1 dimensional state of the system is stored, things get a bit weird while panning.\n\n\nconst ivec2 ZOOMIX   = ivec2(0,0);\nconst ivec2 OFFSETIX = ivec2(1,0);\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nfloat getParam(ivec2 ix) {\n   return texelFetch(iChannel0, ix, 0).w;\n}\n\nfloat getOffset() {\n   return getParam(OFFSETIX);\n}\n\nfloat getZoom() {\n   return max(getParam(ZOOMIX), 1.);\n}\n\nbool keyPressed(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x > .5;\n}\n\nfloat getData(ivec2 coord) {\n    if (coord == ivec2(0, 0)) {\n        if      (keyPressed(KEY_UP))   return getZoom() * 1.01;\n        else if (keyPressed(KEY_DOWN)) return getZoom() / 1.02;\n        return getZoom();\n    } else if(coord == ivec2(1, 0))\n    {\n        if      (keyPressed(KEY_LEFT))  return getOffset() - 2.;\n        else if (keyPressed(KEY_RIGHT)) return getOffset() + 2.;\n        return   getOffset();\n    }\n    return 0.0;\n}\n\n\nivec2 ixToCoord(int i) {\n    return ivec2(i % int(iResolution.x),  i / int(iResolution.x));\n}\n\n// Returns value from previous iteration\nint px(int i) {\n    if (i < 0){\n        ivec2 c = ixToCoord(-1 - i);\n        return int(texelFetch(iChannel0, c, 0).z);\n    }\n    ivec2 c = ixToCoord(i);\n    return int(texelFetch(iChannel0, c, 0).y);\n}\n\nfloat dispPx(ivec2 coord) {\n    if (coord.y == 0) {\n        float i = ( float(coord.x) - (iResolution.x / 2.) ) / getZoom();\n        i += getOffset();\n        return float(px(int(floor(i))));\n    }\n    else if (coord.y < (int(getZoom())) ) {\n        return texelFetch(iChannel0, ivec2(coord.x, 0), 0).x;\n    }\n    return texelFetch(iChannel0, ivec2(coord.x, coord.y - int( getZoom())), 0).x; // scroll\n}\n\n// a: int to access as a bitset\n// n: bit index\nint getNthBit(int a, int n) {\n    return (a & ( 1 << n )) >> n;\n}\n\n//Generates current iteration\nvec2 cellStep(ivec2 coord) {  \n    int xb = (int(iResolution.x) * coord.y) + coord.x;\n    int xc =  -1- xb;\n    int  b = (px(xb+1) << 2) | (px(xb) << 1) | px(xb-1);\n    int  c = (px(xc+1) << 2) | (px(xc) << 1) | px(xc-1);\n    return vec2(getNthBit(RULE, b), getNthBit(RULE, c));\n}\n\n// Clear buffers and add seed.\nvec2 init(ivec2 coord) {\n    return vec2(float(coord == ivec2(1, 0)), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n    ivec2 coord = ivec2(fragCoord);\n    vec2 cellularPx = cellStep(coord);\n    if (iFrame == 0) cellularPx = init(coord);\n    float data = getData(coord);\n    fragColor = vec4(dispPx(coord), cellularPx, data);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsXW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 139, 139, 232]], "test": "untested"}
{"id": "fdlXW2", "name": "interactive mandelbrot zoomer", "author": "sh1boot", "description": "Just making a quick UI so I can explore mandelbrot set coordinate space while I work on render algorithms.\n\nAlso seems to be using df64 arithmetic successfully, but maybe that's just me.  Switch #if 0 to 1 in Common if it's broken for you (or too slow).", "tags": ["mandelbrot", "stateful", "df64"], "likes": 0, "viewed": 293, "published": 3, "date": "1619263131", "time_retrieved": "2024-07-30T19:23:51.315396", "image_code": "FLOAT getParam(int i) {\n   return unpack(texelFetch(iChannel0, ivec2(i, 0), 0));\n}\n\nvec4 brot(FLOAT cx, FLOAT cy, float junk) {\n    float iter = 0.0;\n    FLOAT zx = cx;\n    FLOAT zy = cy;\n    for (int i = 0; i < 512; ++i) {\n        FLOAT tx = add(mul(zx, zx, junk), -mul(zy, zy, junk), junk);\n        FLOAT ty = mul(mul(zx, zy, junk), 2.0, junk);\n        zx = add(tx, cx, junk);\n        zy = add(ty, cy, junk);\n        if (lensquare(zx, zy, junk) > 4.0) break;\n        iter = iter + 1.0;\n    }\n    if (iter >= 511.0) return vec4(0.0, 0.0, 0.0, 0.0);\n\n    return vec4(0.5 + 0.5*cos( 3.0 + iter*0.15 + vec3(0.0,0.6,1.0)), 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float junk = make_junk(iTime);\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    FLOAT cx = getParam(0);\n    FLOAT cy = getParam(1);\n    FLOAT zoom = getParam(2);\n    \n    cx = add(cx, mul(zoom, uv.x, junk), junk);\n    cy = add(cy, mul(zoom, uv.y, junk), junk);\n\n    fragColor = brot(cx, cy, junk);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "FLOAT getParam(int i) {\n   return unpack(texelFetch(iChannel0, ivec2(i, 0), 0));\n}\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\nconst int KEY_HOME  = 36;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float junk = make_junk(iTime);\n    vec2 mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    int p = int(fragCoord.x);\n    FLOAT f = getParam(p);\n    FLOAT zoom = getParam(2);\n\n    int pluskey = 0;\n    int minuskey = 0;\n    FLOAT reset = toFLOAT(0.0);\n    FLOAT incr = mul(zoom, 0.025, junk);\n    float m = 0.0;\n\n    switch (p) {\n    case 0:\n        reset = toFLOAT(-0.75);\n        pluskey = KEY_RIGHT;\n        minuskey = KEY_LEFT;\n        m = mouse.x;\n        break;\n\n    case 1:\n        reset = toFLOAT(0.0);\n        pluskey = KEY_UP;\n        minuskey = KEY_DOWN;\n        m = mouse.y;\n        break;\n\n    case 2:\n        reset = toFLOAT(1.25);\n        pluskey = KEY_PGDN;\n        minuskey = KEY_PGUP;\n        break;\n    }\n\n    if (texelFetch(iChannel1, ivec2(KEY_HOME, 0), 0).x > .5 || iFrame < 1)\n        f = reset;\n    if (texelFetch(iChannel1, ivec2(pluskey, 0), 0).x > .5)\n        f = add(f, incr, junk);\n    if (texelFetch(iChannel1, ivec2(minuskey, 0), 0).x > .5)\n        f = add(f, -incr, junk);\n\n    if (iMouse.z > 0.0) {\n        f = add(f, mul(zoom, m, junk), junk);\n        zoom = mul(zoom, 0.975, junk);\n        f = add(f, -mul(zoom, m, junk), junk);\n        if (p == 2) f = zoom;\n    }\n\n    fragColor = pack(f);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if 0\n#define FLOAT float\nvec4 pack(FLOAT f) {\n    return vec4(f, 0.0, 0.0, 0.0);\n}\nFLOAT unpack(vec4 v) {\n    return v.x;\n}\nFLOAT toFLOAT(float x) {\n    return x;\n}\nFLOAT mul(FLOAT a, FLOAT b, float junk) {\n    return a * b;\n}\n\nFLOAT add(FLOAT a, FLOAT b, float junk) {\n    return a + b;\n}\nfloat lensquare(FLOAT a, FLOAT b, float junk) {\n    return mul(a, a, junk) + mul(b, b, junk);\n}\n// make a value of junk that works for the functions above.\nfloat make_junk(float a_positive_variable) {\n   return 0.0;\n}\n#else\n#define FLOAT vec4\nvec4 pack(FLOAT f) {\n    return f;\n}\nFLOAT unpack(vec4 v) {\n    return v;\n}\nFLOAT toFLOAT(float x) {\n    return vec4(x, 0.0, 0.0, 0.0);\n}\n\n// force the computation of x without optimisation, by making it depend on junk.\nfloat final(float x, float junk) {\n    return x + junk;\n}\n\nvec2 final(vec2 x, float junk) {\n    return x + junk;\n}\n\n// make a value of junk that works for the functions above.\nfloat make_junk(float a_positive_variable) {\n   return 1.0 - step(0.0, a_positive_variable);\n}\n\n// from: http://andrewthall.org/papers/df64_qf128.pdf\nvec2 quickTwoSum(float a, float b, float junk) {\n    float s = final(a + b, junk);\n    float e = b - (s - a);\n    return vec2(s, e);\n}\nvec2 twoSum(float a, float b, float junk) {\n    float s = final(a + b, junk);\n    float v = s - a;\n    float e = (a - (s - v)) + (b - v);\n    return vec2(s, e);\n}\nvec4 twoSumComp(vec2 a, vec2 b, float junk) {\n    vec2 s = final(a + b, junk);\n    vec2 v = s - a;\n    vec2 e = (a - (s - v)) + (b - v);\n    return vec4(s.x, e.x, s.y, e.y);\n}\nvec2 df64_add(vec2 a, vec2 b, float junk) {\n    vec4 sum = twoSumComp(a, b, junk);\n    vec2 s = sum.xy;\n    vec2 t = sum.wz;\n    s.y += t.x;\n    s = quickTwoSum(s.x, s.y, junk);\n    s.y += t.y;\n    s = quickTwoSum(s.x, s.y, junk);\n    return s;\n}\nvec2 split(float a, float junk) {\n    const float split = 4097.0;\n    float t = a * split;\n    float a_hi = t - final(t - a, junk);\n    float a_lo = a - a_hi;\n    return vec2(a_hi, a_lo);\n}\nvec4 splitComp(vec2 c, float junk) {\n    const float split = 4097.0;\n    vec2 t = c * split;\n    vec2 c_hi = t - final(t - c, junk);\n    vec2 c_lo = c - c_hi;\n    return vec4(c_hi.x, c_lo.x, c_hi.y, c_lo.y);\n}\n\nvec2 twoProd(float a, float b, float junk) {\n#if 1  // yes fma\n    float p = a * b;\n    float err = a * b - p;\n#else  // no fma\n    float p = a * b;\n    vec4 split = splitComp(vec2(a, b), junk);\n    vec2 aS = split.xy;\n    vec2 bS = split.wz;\n    float err = ((aS.x * bS.x - p)\n                 + aS.x * bS.y + aS.y * bS.x)\n                + aS.y * bS.y;\n#endif\n     return vec2(p, err);\n}\nvec2 df64_mult(vec2 a, vec2 b, float junk) {\n    vec2 p;\n\n    p = twoProd(a.x, b.x, junk);\n    p.y += a.x * b.y;\n    p.y += a.y * b.x;\n    p = quickTwoSum(p.x, p.y, junk);\n    return p;\n}\nvec2 df64_mult(vec2 a, float b, float junk) {\n    vec2 p;\n\n    p = twoProd(a.x, b, junk);\n    p.y += a.y * b;\n    p = quickTwoSum(p.x, p.y, junk);\n    return p;\n}\n\nFLOAT mul(FLOAT a, FLOAT b, float junk) {\n    return vec4(df64_mult(a.xy, b.xy, junk), 0.0, 0.0);\n}\nFLOAT mul(FLOAT a, float b, float junk) {\n    return vec4(df64_mult(a.xy, b, junk), 0.0, 0.0);\n}\nFLOAT add(FLOAT a, FLOAT b, float junk) {\n    return vec4(df64_add(a.xy, b.xy, junk), 0.0, 0.0);\n}\nfloat lensquare(FLOAT a, FLOAT b, float junk) {\n    return mul(a, a, junk).x + mul(b, b, junk).x;\n}\n#endif", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlXW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 82], [84, 84, 127, 127, 627], [630, 630, 687, 687, 1013]], "test": "untested"}
{"id": "sdfXW2", "name": "Mystery Tube", "author": "Tater", "description": "My first tunnel! I'm not totally satisfied with it but I have a lot more ideas for other stuff now. ", "tags": ["raymarching", "tunnel"], "likes": 8, "viewed": 374, "published": 3, "date": "1619251577", "time_retrieved": "2024-07-30T19:23:52.086334", "image_code": "#define STEPS 128.0\n#define MDIST 150.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvec3 glow = vec3(0);\nvec3 ro = vec3(0);\nfloat sts(float x){ return x-sin(x); }\nfloat rotation (float t){\n    float r = sin(t*2.)*sin(t);\n    r += t;\n    r+=2.0*abs(t*0.2);\n    r+=smoothstep(0.0,1.0,sin(t*0.25))*15.0;\n    r+=tan(sin(t)*0.4);\n    r+=smoothstep(0.5,1.0,sin(t*0.25+2.0))*sin(floor(t*10.0)/10.0);\n   \n    r -= sts(sts(sts(t*2.0)))*pi/8.;\n    return r;\n}\n\nfloat box( vec3 p, vec3 s ){\n  vec3 d = abs(p) - s;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\nvec3 path(vec3 p){\n    return vec3(sin(p.z*0.1)*3.0,cos(p.z*0.1)*2.0,0);\n}\nfloat spinBox(vec3 p ,float t){\n    float yy = sin(t*2.0)*6.0;\n    p.xz*=rot(yy*1.5);\n    p.y+= yy;\n    float b = box(p-vec3(0,0,0), vec3(0.7));\n    return b;\n\n}\nvec2 map(vec3 p){\n    vec2 a,b;\n    float t = mod(iTime,500.0);\n\n\n    //Tunnel\n    a = vec2(length(p.xy-path(p).xy)-6.0, 2.0);\n    a.x=-a.x;\n    \n    vec3 p2 = p;\n    p2-=path(p2);\n    float modd = 30.0;\n    vec3 id = floor((p2)/modd+modd*0.5);\n    p2.z = mod(p2.z,modd)-modd*0.5;\n    \n    p2.y += -5.0;\n    \n    \n    //Top Lights\n    b = vec2(box(p2-vec3(0,0,0), vec3(0.1,1.0,0.1)), 3.0);\n    glow+=0.18/(0.18+b.x*b.x)*vec3(1.000,0.678,0.243);\n    a = (a.x<b.x)?a:b;\n    \n    //Doors\n    b = vec2(box(p2-vec3(0,0,3),vec3(25.0,25.0,0.5)),2.0);\n    b.x = max(-length(p2.x)+ro.z-p.z+12.0,b.x);\n    a = (a.x<b.x)?a:b;\n    \n\n    \n    \n    p2 = p-path(p);\n    id = floor((p2+15.0)/modd+modd*0.5);\n    \n    //Glow Boxes\n    if(mod(id.z,3.0)==0.0){\n    p2.z-=20.0;\n    p2.z = mod(p2.z,modd)-modd*0.5;\n    modd = 10.0;\n    b.y = 1.0;\n    \n    p2.xy*=rot(2.0);\n    b.x = spinBox(p2-vec3(0,8,0),t);\n    a = (a.x<b.x)?a:b;\n    glow+=0.0085/(0.01+b.x*b.x)*vec3(0.980,0.180,0.180);\n    p2.z+=5.0;\n    p2.xy*=rot(2.0);\n    b.x = spinBox(p2-vec3(0,8,0),t+1.0);\n    a = (a.x<b.x)?a:b;\n    glow+=0.0085/(0.01+b.x*b.x)*vec3(0.306,0.157,1.000);\n    p2.z+=5.0;\n    p2.xy*=rot(2.0);\n    b.x = spinBox(p2-vec3(0,8,0),t+2.0);\n    a = (a.x<b.x)?a:b;\n    glow+=0.0085/(0.01+b.x*b.x)*vec3(0.157,1.000,0.282);\n    }\n    \n    \n    //Glow Spikeys\n    if(mod(id.z,3.0)==1.0){\n    p2.z-=15.0;\n    p2.z = mod(p2.z,modd)-modd*0.5;\n    \n    vec3 tp2 = p2;\n    p2.z-=7.5;\n    p2.xy=tp2.xy*rot(rotation(t*1.5));\n    b.x = length(p2.xz)-p2.y*0.3+1.0;\n    glow+=0.0085/(0.01+b.x*b.x)*vec3(0.980,0.180,0.180);\n    a = (a.x<b.x)?a:b;\n\n    p2.z+=7.5;\n    p2.xy=tp2.xy*rot(rotation(t*1.5+5.0));\n    b.x = length(p2.xz)-p2.y*0.3+1.0;\n    glow+=0.0085/(0.01+b.x*b.x)*vec3(0.306,0.157,1.000);\n    a = (a.x<b.x)?a:b;\n    \n    p2.z+=7.5;\n    p2.xy=tp2.xy*rot(rotation(t*1.5+10.0));\n    b.x = length(p2.xz)-p2.y*0.3+1.0;\n    glow+=0.0085/(0.01+b.x*b.x)*vec3(0.157,1.000,0.282);\n    a = (a.x<b.x)?a:b;\n    \n\n    }\n    //Orb Trails\n    if(mod(id.z,3.0)==2.0){\n    p2.z-=15.0;\n    \n    p2.z = mod(p2.z,modd)-modd*0.5;\n    modd = 2.0;\n    \n    vec3 tp2 = p2;\n    \n    p2.xy*=rot(0.5);\n    p2.yz*=rot(-0.3);\n    p2+=vec3(4,t*3.0,0);    \n    p2.y = mod(p2.y,modd)-modd*0.5;\n    p2.z-=7.5;\n    b.x = length(p2)-0.5;\n    glow+=0.0085/(0.01+b.x*b.x)*vec3(0.980,0.180,0.180);\n    a = (a.x<b.x)?a:b;\n    \n    p2 = tp2;\n    p2.yx*=rot(1.5);\n    p2.yz*=rot(-0.3);\n    p2+=vec3(4,t*3.0,0);\n    p2.y = mod(p2.y,modd)-modd*0.5;\n    b.x = length(p2)-0.5;\n    glow+=0.0085/(0.01+b.x*b.x)*vec3(0.306,0.157,1.000);\n    a = (a.x<b.x)?a:b;\n    \n    p2 = tp2;\n    p2.yx*=rot(3.5);\n    p2.yz*=rot(-0.3);\n    p2+=vec3(4,t*3.0,0);\n    p2.y = mod(p2.y,modd)-modd*0.5;\n    p2.z+=5.5;\n    b.x = length(p2)-0.5;\n    glow+=0.0085/(0.01+b.x*b.x)*vec3(0.157,1.000,0.282);\n    a = (a.x<b.x)?a:b;\n    }\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = mod(iTime,500.0)*5.0+2.0;\n    ro = vec3(0,0,t);\n    ro+=path(ro);\n    \n    vec3 look = vec3(0,0,t+4.0);\n    look+=path(look);\n    vec3 f = normalize(look-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*0.85+uv.x*r+uv.y*cross(f,r);\n    \n    //vec3 rd = normalize(vec3(uv,1.0));\n    \n    float dO; \n    vec2 d;\n    vec3 p = ro;\n    for(float i = 0.0; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO += d.x*0.65;\n        if(d.x <0.001||dO>MDIST){\n            break;\n        }\n    }\n    if(d.y==3.0)col=vec3(0.961,1.000,0.475);\n    col+=glow*0.25;\n    col = mix(col,0.5*vec3(1.000,0.886,0.251),dO/(MDIST+50.0));\n    col = pow(col,vec3(0.9));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfXW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 173, 173, 192], [193, 193, 218, 218, 479], [481, 481, 509, 509, 596], [597, 597, 615, 615, 671], [672, 672, 703, 703, 833], [834, 834, 851, 851, 3669], [3671, 3671, 3728, 3728, 4536]], "test": "untested"}
{"id": "NslXzH", "name": "more things", "author": "elenzil", "description": "several firsts for me: AO, more than one reflection bounce, local coords, fancier materials.", "tags": ["reflections", "ao", "texturing"], "likes": 7, "viewed": 289, "published": 3, "date": "1619246295", "time_retrieved": "2024-07-30T19:23:53.033800", "image_code": "\n\n\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\nvec3 sky(in vec3 rd);\nmat2 rot2(in float theta);\nvec3 directionToColor(in vec3 dir);\n\nfloat opUnion(in float a, in float b);\nfloat opMinus(in float a, in float b);\nfloat opIntsc(in float a, in float b);\nfloat opUnion2(inout vec3 localSpace, in vec3 bSpace, inout int material, in int bMaterial, in float a, in float b);\nfloat opMinus2(inout vec3 localSpace, in vec3 bSpace, inout int material, in int bMaterial, in float a, in float b);\nfloat opIntsc2(inout vec3 localSpace, in vec3 bSpace, inout int material, in int bMaterial, in float a, in float b);\n\nfloat sdSphere(in vec3 p, in float r);\nfloat sdCylZ(in vec3 p, in float r);\nfloat sdCylY(in vec3 p, in float r);\nfloat sdBox( vec3 p, vec3 b );\n\nfloat gMapCalls;\n\nvec3  gSph1Pos;\nfloat gSph1Rad;\nmat2  gSPh1Rot;\nvec3  gSph2Pos;\nfloat gSph2Rad;\nmat2  gSPh2Rot;\nvec3  gSph3Pos;\nfloat gSph3Rad;\nfloat gSphMod;\nmat2  gChannelRot;\n\nvoid configScene() {\n    // move a bunch of trig etc out of the core map() routine and into once-per-fragment globals.\n    gSph1Pos    = vec3( 1.1, sin(gTime * 0.343) * 0.9, 0.0);\n    gSph1Rad    = smoothstep(0.5, 10.0, gTime) * 0.7 + 0.01;\n    gSPh1Rot    = rot2(gTime * 0.81);\n    gSph2Pos    = vec3(-1.1, sin(gTime * 0.443) * 0.9, 0.0);\n    gSph2Rad    = smoothstep(1.0, 4.0, gTime) * 0.7 + 0.01;\n    gSPh2Rot    = rot2(abs(sin(gTime * 0.443 * 0.5 - PI/4.0)) * 15.0);\n    gSphMod     = sin(gTime * 0.231) * 25.0 + 25.0;\n\n    gSph3Rad    = 30.0;\n    gSph3Pos    = vec3(0.0, gSph3Rad + 1.7, 0.0);\n}\n\n#define FOO                                               \\\n    int bMat = 0;                                         \\\n    gMapCalls += 1.0;                                     \\\n    float d = 1e9;                                        \\\n    p.y *= -1.0;                                          \\\n    vec3 P;                                               \\\n                                                          \\\n    /* ball 3 */                                          \\\n    bMat = 3;                                             \\\n    P = p - gSph3Pos;                                     \\\n /*   P.y += sin(dot(p.xz, p.xz) * 0.3 - gTime) * 0.1; */ \\\n    d = UN(VARIABLE_ARGS, sdSphere(P, gSph3Rad));         \\\n     \\\n    P = p - vec3(0.0, 1.0, 0.0); \\\n    d = MI(VARIABLE_ARGS, -0.2 + sdBox(P, vec3(1.0, 1.0, 30.0))); \\\n    d = MI(VARIABLE_ARGS, -0.2 + sdBox(P, vec3(30.0, 1.0, 1.0))); \\\n/*    P = vec3(mod(p.x - gTime * 0.321 + 0.0, 2.5) - 1.0, p.y - 3.0, p.z); \\\n    d = MI(VARIABLE_ARGS, -0.2 + sdSphere(P, 0.25)); \\\n    P = vec3(mod(p.z - gTime * 0.321 + 1.25, 2.5) - 1.0, p.y - 3.0, p.x).zyx; \\\n    d = MI(VARIABLE_ARGS, -0.2 + sdSphere(P, 0.25)); \\ */ \\\n    \\\n    bMat = 0;                                             \\\n                                                          \\\n    /* ball 1 */                                          \\\n    bMat = 1;                                             \\\n    P = p - gSph1Pos;                                     \\\n    P.yz *= gSPh1Rot;                                     \\\n    float sphPerturb = 0.004 * (-1.0 + 2.0 * smoothstep(-0.8, 0.8, (sin(P.y * gSphMod) + sin(P.x * gSphMod) + sin(P.z * gSphMod)))); \\\n    d = UN(VARIABLE_ARGS, sdSphere(P, gSph1Rad) + sphPerturb); \\\n    /* ball 2 */                                          \\\n    bMat = 2;                                             \\\n    P = p - gSph2Pos;                                     \\\n    P.zx *= gSPh2Rot;                                     \\\n    d = UN(VARIABLE_ARGS, sdSphere(P, gSph2Rad));         \\\n    /* Blank Line */\n\n\nfloat map(in vec3 p) {\n#define UN opUnion\n#define MI opMinus\n#define IN opIntsc\n#define VARIABLE_ARGS d\n    FOO\n    return d;\n}\n\nvec3 localCoords(in vec3 p, out int mat) {\n#undef UN\n#undef MI\n#undef IN\n#undef VARIABLE_ARGS\n#define UN opUnion2\n#define MI opMinus2\n#define IN opIntsc2\n#define VARIABLE_ARGS localSpace, P, mat, bMat, d\n    mat = -1;\n    vec3 localSpace = vec3(0.0);\n    FOO\n    return localSpace;\n}\n\n// IQ: https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.002;      // replace by an appropriate value\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h);\n    }\n    return normalize(n);\n}\n\n\nconst float closeEps = 0.002;\n\nfloat march(in vec3 ro, in vec3 rd) {\n    const int maxSteps = 100;\n\n    float d1 = map(ro);\n\n    vec3 p = ro;\n    float t = 0.0;\n    for (int n = 1; n <= maxSteps; ++n) {\n        float d = map(ro + rd * t);\n        float closeEnoughEps = (n == maxSteps ? 0.2 : closeEps);\n        if (d < closeEnoughEps) {\n            return t;\n        }\n        t += d;\n        if (t > 200.0) {\n            return t;\n        }\n    }\n    return t;\n}\n\nvec3 lightDirection = normalize(vec3(-2.0, -1.0, 0.2));\n\nfloat calcDiffuseAmount(in vec3 p, in vec3 n) {\n    return clamp(dot(n, -lightDirection), 0.0, 1.0);\n}\n\nconst float AOFactorMin = 0.2;\nconst float AOFactorMax = 1.0;\nfloat calcAOFactor(in vec3 p, in vec3 n) {\n    const float sampleDist = 0.4;\n    float dist = smoothstep(0.0, sampleDist, map(p + n * sampleDist));\n    return mix(AOFactorMin, AOFactorMax, (dist));\n}\n\nfloat calcShadowLight(in vec3 p) {\n    float t = march(p - lightDirection * 0.05, -lightDirection);\n    return t > 40.0 ? 1.0 : 0.0;\n}\n\nfloat maxPart(in vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nstruct pol3 {\n    float rho;\n    float tht;\n    float phi;\n};\n\npol3 sphericalFromCartesian(in vec3 cartesian) {\n    pol3 ret;\n\n    ret.tht = atan(cartesian.z, cartesian.x);\n    ret.phi = acos(dot(normalize(cartesian), vec3(0.0, 1.0, 0.0))) - PI/2.0;\n    ret.rho = length(cartesian);\n\n    return ret;\n}\n\nconst vec3 albedo1 = vec3(0.0, 0.6, 1.0);\nconst vec3 albedo2 = vec3(0.7, 0.2, 0.3);\nconst vec3 albedo3 = vec3(0.5, 0.1, 0.2);\nconst vec3 albedo4 = vec3(1.0, 1.0, 0.2);\nconst vec3 albedo5 = vec3(1.0, 0.2, 0.2);\n\n\nvoid calcMaterialCommons(in int material, in vec3 pCrt, in pol3 pPol) {\n}\n\n\nvec3 getAlbedo(in int material, in vec3 pCrt, in pol3 pPol) {\n    if (material == 1 || material == 2) {\n        float dots = smoothstep(0.005, -0.005, length(vec2(pPol.phi * 2.5 * 2.0, sin((pPol.tht + 2.2) * 5.0 / 1.0))) - 0.4);\n        vec3 alb = albedo1;\n        alb = mix(alb, albedo3, 0.7 * smoothstep(0.25, 0.3, abs((pPol.phi) * 2.0 + cos(pPol.tht * 5.0) * 0.3)));\n        alb = mix(alb, material == 1 ? albedo4 : albedo5, dots);\n        return alb;\n    }\n    else if (material == 0) {\n        return vec3(0.7);\n    }\n    else if (material == 3) {\n        return vec3(0.1, 0.1, 0.1);\n    }\n    else {\n        discard;\n    }\n}\n\nvec3 getReflectivity(in int material, in vec3 pCrt, in pol3 pPol) {\n\n    if (material == 0) {\n        return vec3(0.0);\n    }\n    else if (material <= 2) {\n        vec3 reflectAmount = vec3(1.0, 0.8, 0.5) * (sin(gTime * 0.3) * 0.45 + 0.55);\n\n        float vertStripes = smoothstep(-0.02, 0.02, sin(pPol.tht * 5.0 + pPol.phi * 4.0) - 0.7);\n\n        float lid = smoothstep(0.27, 0.269, abs(pPol.phi) * 0.2);\n\n        if (material == 0) {\n            reflectAmount *= 0.0;\n        }\n        reflectAmount *= 0.2 + 0.8 * ((1.0 - vertStripes) * lid);\n        return reflectAmount;\n    }\n    else if (material <= 3) {\n        return vec3(0.0, 0.2, 0.7);\n    }\n    else {\n        discard;\n    }\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n\n    vec3 col = vec3(0.0);\n\n    int bouncesLeft = 4;\n\n    vec3 contributionLeft = vec3(1.0);\n\n    while (bouncesLeft >= 0 && maxPart(contributionLeft) > 0.001) {\n        bouncesLeft -= 1;\n        float t = march(ro, rd);\n        vec3 p = ro + t * rd;\n        if (length(p) > 150.0) {\n            col += sky(rd) * contributionLeft;\n            break;\n        }\n\n        vec3 normal = calcNormal(p);\n\n        int material;\n        vec3 ptCrt = localCoords(p, material);\n        pol3 ptSph = sphericalFromCartesian(ptCrt);\n\n\n        float incomingLight = 1.0;\n        incomingLight = min(incomingLight, calcDiffuseAmount(p, normal));\n        incomingLight = min(incomingLight, calcShadowLight(p));\n        float ambient = 0.05 * calcAOFactor(p, normal);\n        incomingLight += ambient;\n\n        float fres = 0.4 + 0.8 * clamp(pow(1.0 - abs(dot(rd, normal) - 0.1), 2.0), 0.0, 1.0);\n\n        calcMaterialCommons(material, ptCrt, ptSph);\n\n        vec3 reflectivity = fres * getReflectivity(material, ptCrt, ptSph);\n        vec3 diffuse = incomingLight * getAlbedo(material, ptCrt, ptSph);\n        \n        col += diffuse * (1.0 - reflectivity) * contributionLeft;\n        contributionLeft *= reflectivity;\n          \n        ro = p + normal * 0.05;\n        rd = reflect(rd, normal);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec4 persistedInfo = texelFetch(iChannel0, ivec2(0, 0), 0);\n    setupCoords(iResolution.xy, 0.97);\n    setupTime(persistedInfo[2]);\n    vec2  uv        = worldFromScreen(XY);\n    float luv       = length(uv);\n    vec2  ms        = worldFromScreen(iMouse.xy);\n    float smoothEps = gWorldFromScreenFac * 2.0;\n\n    configScene();\n\n    // look-from and look-to points\n    // right-handed system where x is right, y is up, z is forward.\n    float dt = 0.5;\n    float t = gTime * 0.23;\n    vec3 trgPt = vec3(0.0);\n    \n    float lookChoice = smoothstep(-0.1, 0.1, sin(t * 0.41));\n    trgPt = mix(gSph1Pos, gSph2Pos, lookChoice);\n    trgPt.y *= -1.0;\n\n    vec3 col = vec3(0.0);\n\n    float camTheta = t + ms.x * 1.5;\n    float camAlttd = sin(t * 0.32) * 0.2 + ms.y * 0.4;\n    vec3 camPt = vec3(cos(camTheta), camAlttd, sin(camTheta)) * -2.2;\n    \n    // camera's forward, right, and up vectors. right-handed.\n    vec3 camFw = normalize(trgPt - camPt);\n    vec3 camRt = cross(camFw, vec3(0.0, 1.0, 0.0));\n    vec3 camUp = cross(camRt, camFw);\n    \n    \n\n    // mess with camPt, just for fun\n    float messAmt = luv < 1.0 ? 0.0 : 0.2 * (luv - 1.0);\n    camPt += camRt * messAmt;\n\n    // ray origin and direction\n    vec3 ro    = camPt;\n    vec3 rd    = normalize(camFw + uv.x * camRt / (1.0 + messAmt * 2.0) + uv.y * camUp / (1.0 + messAmt * 2.0));\n    \n    const int maxSteps = 100;\n    \n    gMapCalls = 0.0;\n\n    col += render(ro, rd);\n\n    float outCircle = smoothstep(-smoothEps, smoothEps, luv - 1.0);\n    col *= 1.0 - 0.1 * outCircle * pow(luv, 1.5);\n    col = mix(col, vec3(col.x + col.y + col.z) / 6.0, outCircle * clamp(0.0, 1.0, 2.0 * (luv - 1.0)));\n    col *= 1.0 + smoothstep(smoothEps, -smoothEps, abs(luv - 1.0));\n\n  //  col.r = gMapCalls / 200.0;\n  \n    col = pow(col, vec3(1.0 / 2.2));\n    \n    RGBA = vec4(col, 1.0);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n\nvec3 sky(in vec3 rd) {\n    float tht = atan(rd.z, rd.x);\n    float phi = acos(dot(normalize(rd), vec3(0.0, 1.0, 0.0)));\n    vec3 col = rd * 0.5 + 0.5;\n    col *= smoothstep(0.002, -0.002, sin(tht       * 4.0)) * -0.3 + 1.0;\n    col *= smoothstep(0.002, -0.002, sin(phi * 2.0 * 4.0)) * -0.3 + 1.0;\n    col = mix(col, col / max(col.r, max(col.g, col.b)), 0.2);\n    col *= rd.y < 0.0 ? 0.5 : 1.0;\n    return col;\n}\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n    \n}\n\n// dir is unit-length\nvec3 directionToColor(in vec3 dir) {\n    vec3 ret = dir * 0.5 + 0.5;\n    return ret;\n}\n\n\nfloat opUnion(in float a, in float b) {\n    return min(a, b);\n}\n\nfloat opMinus(in float a, in float b) {\n    return max(a, -b);\n}\n\nfloat opIntsc(in float a, in float b) {\n    return max(a, b);\n}\n\nfloat opUnion2(inout vec3 localSpace, in vec3 bSpace, inout int material, in int bMaterial, in float a, in float b) {\n    if (a < b) {\n        return a;\n    }\n    else {\n        localSpace = bSpace;\n        material = bMaterial;\n        return b;\n    }\n}\n\nfloat opMinus2(inout vec3 localSpace, in vec3 bSpace, inout int material, in int bMaterial, in float a, in float b) {\n    return opMinus(a, b);\n}\n\nfloat opIntsc2(inout vec3 localSpace, in vec3 bSpace, inout int material, in int bMaterial, in float a, in float b) {\n    return opIntsc(a, b);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdCylZ(in vec3 p, in float r) {\n    return length(p.xy) - r;\n}\n\nfloat sdCylY(in vec3 p, in float r) {\n    return length(p.xz) - r;\n}\n\nfloat sdPlaneY(in vec3 p)\n{\n    return p.y;\n}\n// IQ:\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Fork of \"boilerplate stuff\" by elenzil. https://shadertoy.com/view/7dX3R2\n// 2021-04-05 18:18:15\n\nconst float PI  = 3.14159265359;\nconst float TAO = PI * 2.0;\n\n// global time parameter\nfloat gTime;\n\nvec2  gCanvasRes;\nfloat gCanvasSmallRes;\nfloat gZoom;\nfloat gScreenFromWorldFac;\nfloat gWorldFromScreenFac;\n\n\n// to prevent loop-unrolling\n#define ZERO (min(0, int(iFrame)))\n\n\n// set up world coordinates where a unit circle fits\n// in the smallest dimension of the canvas, plus a zoom factor.\nvoid setupCoords(in vec2 canvasResolution, in float zoom) {\n\n    gCanvasRes = canvasResolution;\n\n    // the smallest dimension of the canvas\n    gCanvasSmallRes = min(canvasResolution.x, canvasResolution.y);\n    \n    // small = shrink\n    gZoom = zoom;\n    \n    // factor to get from world scale to screen scale\n    gScreenFromWorldFac = gZoom * gCanvasSmallRes / 2.0;\n    \n    // factor to get from screen scale to world scale\n    gWorldFromScreenFac = 1.0 / gScreenFromWorldFac;\n}\n\nvec2 worldFromScreen(in vec2 screenPt) {\n    return (screenPt - gCanvasRes / 2.0) * gWorldFromScreenFac;;\n    \n}\n\n// in case we want to speed or slow down things from iTime.\n// this needs to be called in each pass.\nvoid setupTime(in float time) {\n    gTime = time;\n}\n\n", "buffer_a_code": "\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\n// 0, 0:\n// [0] = is mouse down\n// [1] = is time frozen\n// [2] = current time\n// [3] = timescale\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    ivec2 IJ = ivec2(XY);\n\n    RGBA = texelFetch(iChannel0, IJ, 0);\n\n    if (iFrame == 0 || IJ.x != 0 || IJ.y != 0) {\n        RGBA = vec4(0.0, 0.0, iTime, 1.0);\n        return;\n    }\n\n    bool  mouseWasDown = RGBA[0] == 1.0;\n    bool  timeIsFrozen = RGBA[1] == 1.0;\n    float time         = RGBA[2];\n    float timeScale    = RGBA[3];\n\n    bool mouseIsDown = iMouse.z > 0.0;\n\n    timeIsFrozen = timeIsFrozen ^^ (!mouseIsDown && mouseWasDown);\n    \n    timeIsFrozen = mouseIsDown;\n\n    timeScale = clamp(timeScale + (timeIsFrozen ? -0.01 : 0.01) * 60.0 / iFrameRate, 0.0, 1.0);\n    time += iTimeDelta * timeScale;\n\n    RGBA[0] = mouseIsDown  ? 1.0 : 0.0;\n    RGBA[1] = timeIsFrozen ? 1.0 : 0.0;\n    RGBA[2] = time;\n    RGBA[3] = timeScale;\n\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslXzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[931, 931, 951, 1049, 1530], [4005, 4055, 4106, 4106, 4368], [4402, 4402, 4439, 4439, 4835], [4894, 4894, 4941, 4941, 4996], [5060, 5060, 5102, 5102, 5259], [5261, 5261, 5295, 5295, 5395], [5397, 5397, 5423, 5423, 5461], [5526, 5526, 5574, 5574, 5764], [5978, 5978, 6049, 6049, 6051], [6054, 6054, 6115, 6115, 6684], [6686, 6686, 6753, 6753, 7375], [7377, 7377, 7414, 7414, 8718], [8720, 8720, 8765, 8765, 10596], [10680, 10680, 10702, 10702, 11091], [11093, 11093, 11120, 11120, 11209], [11211, 11233, 11269, 11269, 11319], [11322, 11322, 11361, 11361, 11385], [11387, 11387, 11426, 11426, 11451], [11453, 11453, 11492, 11492, 11516], [11518, 11518, 11635, 11635, 11772], [11774, 11774, 11891, 11891, 11919], [11921, 11921, 12038, 12038, 12066], [12068, 12068, 12107, 12107, 12135], [12137, 12137, 12174, 12174, 12205], [12207, 12207, 12244, 12244, 12275], [12277, 12277, 12304, 12304, 12322], [12323, 12330, 12361, 12361, 12448]], "test": "untested"}
{"id": "ssXSD2", "name": "Bump Intersection", "author": "oneshade", "description": "Ray intersection with a bump.", "tags": ["3d", "raytracing", "ray", "raycasting", "intersection", "bump", "cubic"], "likes": 11, "viewed": 179, "published": 3, "date": "1619238844", "time_retrieved": "2024-07-30T19:23:53.855603", "image_code": "const vec2 eta = vec2(-0.5, sqrt(0.75));\nint solveCubic(in float a, in float b, in float c, in float d, out vec3 roots) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d;\n\n    b /= a, c /= a, d /= a;\n    float d0 = b * b - 3.0 * c;\n    float d1 = (2.0 * b * b - 9.0 * c) * b + 27.0 * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) + abs(C.y) < 1e-3) C = vec2(d1 - j, 0.0);\n    float t = atan(C.y, C.x) / 3.0, r = pow(0.25 * dot(C, C), 1.0 / 6.0);\n    C = vec2(cos(t), sin(t));\n\n    float w = -d0 / r - r;\n    roots.x = (C.x * w - b) / 3.0;\n    roots.y = (dot(vec2(C.x, -C.y), eta) * w - b) / 3.0;\n    if (h > 0.0) roots.z = (dot(C, eta) * w - b) / 3.0;\n    else if (abs(dot(C.yx, eta)) < abs(C.y)) roots.x = roots.y;\n\n    return h < 0.0 ? 1 : 3;\n}\n\n// Implicit equation: y = 1 / (1 + sqrt(x^2 + y^2)^2)\n// ---> y = 1 / (1 + x^2 + y^2)\n// ---> x^2y + yz^2 + y - 1 = 0\nvec4 iBump(in vec3 ro, in vec3 rd, in float h) {\n    float xxzz = dot(ro.xz, ro.xz) + 1.0;\n    float xzuw = dot(ro.xz, rd.xz) * 2.0;\n    float uuww = dot(rd.xz, rd.xz);\n\n    float coeff1 = uuww * rd.y;\n    float coeff2 = rd.y * xzuw + uuww * ro.y;\n    float coeff3 = ro.y * xzuw + xxzz * rd.y;\n    float coeff4 = xxzz * ro.y - h;\n\n    vec3 roots;\n    int nroots = solveCubic(coeff1, coeff2, coeff3, coeff4, roots);\n    return vec4(roots, nroots);\n}\n\nvec3 nBump(in vec3 p, in float h) {\n    return normalize(vec3(p.x * p.y, 0.5 * dot(p.xz, p.xz) + 0.5, p.y * p.z));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(-0.85, -0.5);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Height\n    float h = 1.251 + 1.25 * sin(iTime);\n    vec2 offs = 2.0 * sin(2.0 * iTime + vec2(1.57, 0.0));\n    ro.xz -= offs;\n\n    vec4 hits = iBump(ro, rd, h);\n    int nHits = int(hits[3]);\n\n    // Find closest valid intersection\n    vec3 hitPos;\n    float tMin = 1000000.0;\n    bool flagHit = false;\n    for (int n=0; n < nHits; n++) {\n        vec3 hitCandid = ro + rd * hits[n];\n        if (hits[n] > 0.0 && hits[n] < tMin) {\n            hitPos = hitCandid;\n            tMin = hits[n];\n            flagHit = true;\n        }\n    }\n\n    if (flagHit) {\n        vec3 n = nBump(hitPos, h);\n\n        hitPos.xz += offs;\n        float diff = abs(dot(n, -rd));\n        float checkers = mod(dot(floor(hitPos.xz), vec2(1.0)), 2.0);\n\n        fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25) * diff;\n    }\n\n    else {\n        fragColor = texture(iChannel0, rd);\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXSD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 121, 121, 909], [911, 1029, 1077, 1077, 1477], [1479, 1479, 1514, 1514, 1595], [1597, 1597, 1652, 1652, 3227]], "test": "untested"}
{"id": "7sXXW2", "name": "branches", "author": "lomateron", "description": "this...\n{\nu = vec2(atan(u.y,u.x),log(length(u)));  u = u*2.;\nu = cos(u.x-vec2(0,pi*.5))*exp(u.y);     u = u+m;\n}\nis what is needed inside a loop to make the julia fractal\nthen I just repeated each line and played with the constants until finding that", "tags": ["fractal", "zoom"], "likes": 11, "viewed": 317, "published": 3, "date": "1619235001", "time_retrieved": "2024-07-30T19:23:54.736248", "image_code": "float pi = 3.1415926535897932384626433832795;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = vec2(-6.9477,2.3521);\n    u = u*pow(2.,34.-iTime)+vec2(.00000202,0);\n    for(float i = .5; i < 45.; ++i)\n    {\n        u = vec2(atan(u.y,u.x),log(length(u)));  u = u*.5;\n        u = vec2(atan(u.y,u.x),log(length(u)));  u = u*-3.;\n        u = cos(u.x-vec2(0,pi*.5))*exp(u.y);     u = u+m;\n        u = cos(u.x-vec2(0,pi*.5))*exp(u.y);     u = u+m;\n    }\n    fragColor = (cos(u.x*2.+vec4(1,2,3,4))*.5+.5)*(sin(u.y*2.)*.4+.6);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXXW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 596]], "test": "untested"}
{"id": "7sXXDj", "name": "Inverse Smoothstep with Bounds", "author": "oneshade", "description": "Basically a remake of @iq's shader (https://www.shadertoy.com/view/MsSBRh) for the fun of reinventing the wheel and learning how he made his so compact (trig identities!). To be a bit more original, I also made it so the bounds can be adjusted.", "tags": ["function", "smoothstep", "cubic", "inverse", "bounds"], "likes": 6, "viewed": 150, "published": 3, "date": "1619229217", "time_retrieved": "2024-07-30T19:23:55.665763", "image_code": "#define bmin sin(iTime)\n#define bmax cos(iTime)\n\n#define func(x) fSmoothstep(x, sin(iTime), cos(iTime))\n#define inv(x) iSmoothstep(x, sin(iTime), cos(iTime))\n\n// Drawing utilities\n#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n#define drawf(f, t, c) draw(abs(uv.y - f(uv.x)) / sqrt(1.0 + pow((f(uv.x + 0.001) - f(uv.x - 0.001)) / 0.002, 2.0)) - t, c)\n\n// Smoothstep\nfloat fSmoothstep(in float x, in float edge0, in float edge1) {\n    //x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0); // clamp() is noninvertable\n    //return 3.0 * x * x - 2.0 * x * x * x;\n    return smoothstep(edge0, edge1, x);\n}\n\n// Inverse smoothstep\nfloat iSmoothstep(in float x, in float edge0, in float edge1) {\n    x = sin(asin(2.0 * x - 1.0) / 3.0) + 0.5;\n    return (edge1 - edge0) * x + edge0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(mod(uv.x + 0.2, 0.4) - 0.2) + 0.25 * unit, vec3(0.75));\n    draw(abs(mod(uv.y + 0.2, 0.4) - 0.2) + 0.25 * unit, vec3(0.75));\n    draw(abs(uv.x), vec3(0.0));\n    draw(abs(uv.y), vec3(0.0));\n\n    // Shift\n    uv += 0.5;\n\n    // Graph\n    drawf(func, 0.01, vec3(0.8, 0.0, 0.0));\n    drawf(inv, 0.01, vec3(0.0, 0.0, 0.8));\n\n    // The inverse is also the function reflected diagonally (x and y swapped)\n    // Here showing the axis of symmetry\n    float iSqrt2 = 0.70710678118; // sqrt(0.5)\n    draw(abs(dot(uv, vec2(iSqrt2, -iSqrt2))), vec3(0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXXDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[372, 386, 449, 579, 621], [623, 645, 708, 708, 796], [798, 798, 853, 853, 1599]], "test": "untested"}
{"id": "NssXzB", "name": "Divide by Z", "author": "oneshade", "description": "Dividing by z.", "tags": ["3d", "raymarching", "warp", "z", "divide"], "likes": 7, "viewed": 152, "published": 3, "date": "1619219652", "time_retrieved": "2024-07-30T19:23:56.503523", "image_code": "// Hack (https://iquilezles.org/articles/normalsSDF)\n#define ZERO min(iFrame, 0)\n\nmat2 Rotate(in float a) {\n    float rad = radians(a);\n    float c = cos(rad), s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\nfloat mapScene(in vec3 p) {\n    p.xy /= mix(1.0, max(0.1, 0.2 * p.z + 0.75), 0.5 + 0.5 * sin(iTime));\n\n    vec3 q = abs(p) - 2.5;\n    float box1 = max(abs(max(q.x, max(q.y, q.z))) - 0.05, p.z - 2.0);\n\n    p.xz *= Rotate(30.0);\n    p -= vec3(0.25, -1.0, -1.5);\n    q = abs(p) - vec3(0.75, 1.5, 0.75);\n    float box2 = max(q.x, max(q.y, q.z));\n\n    p -= vec3(0.8, -0.7, 2.0);\n    p.xz *= Rotate(-55.0);\n    q = abs(p) - 0.8;\n    float box3 = max(q.x, max(q.y, q.z));\n\n    p.y -= 1.3;\n    float sphere1 = length(p) - 0.5;\n\n    p -= vec3(-2.0, -1.0, 1.5);\n    float sphere2 = length(p) - 1.0;\n\n    return min(box1, min(box2, min(box3, min(sphere1, sphere2))));\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 getGrad(in vec3 p) {\n    vec2 v = vec2(1.0, -1.0);\n    vec2 e = v * 0.001;\n    return (v.xyy * mapScene(p + e.xyy) +\n            v.yyx * mapScene(p + e.yyx) +\n            v.yxy * mapScene(p + e.yxy) +\n            v.xxx * mapScene(p + e.xxx)) / e.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(vec3(0.125), 1.0);\n\n    if (iMouse.xy == vec2(0.0)) mouse = vec2(0.5 * sin(iTime * 0.5), 0.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=ZERO; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        vec3 j = getGrad(p);\n        float g = length(j);\n        float d = mapScene(p) / g;\n        if (d < 0.001) {\n            vec3 n = j / g;\n            fragColor.rgb += (0.5 + 0.5 * n) * max(0.0, dot(n, -rd));\n            break;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 107, 107, 205], [207, 207, 234, 234, 865], [867, 913, 938, 938, 1168], [1170, 1170, 1225, 1225, 2251]], "test": "untested"}
{"id": "NsXSW2", "name": "Aquiles", "author": "jorge2017a1", "description": "Aquiles", "tags": ["aquiles"], "likes": 9, "viewed": 222, "published": 3, "date": "1619209688", "time_retrieved": "2024-07-30T19:23:57.522798", "image_code": "//por jorge2017a1 ----jorgeFloresP---23/abril/2021\n// referencia\n//https://www.shadertoy.com/view/tlGBW3\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n//----------\nfloat sdBox( in vec2 p, in vec2 b )\n{  vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n////-------------------\n\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPoly60 POLY(60)\nvec2 pt60[ 60]=vec2[](  \nvec2(.42,.44),vec2(.08,.71),vec2(.06,.75),vec2(.10,.73),vec2(.43,.47),\nvec2(.44,.47),vec2(.21,.80),vec2(.19,.87),vec2(.24,.82),vec2(.46,.49),\nvec2(.47,.49),vec2(.33,.90),vec2(.33,.93),vec2(.35,.90),vec2(.50,.51),\nvec2(.51,.51),vec2(.48,.92),vec2(.48,.95),vec2(.49,.92),vec2(.53,.51),\nvec2(.55,.51),vec2(.63,.88),vec2(.65,.92),vec2(.66,.88),vec2(.58,.51),\nvec2(.59,.50),vec2(.76,.81),vec2(.79,.84),vec2(.79,.80),vec2(.62,.48),\nvec2(.64,.47),vec2(.86,.68),vec2(.91,.70),vec2(.90,.67),vec2(.66,.45),\nvec2(.66,.44),vec2(.89,.53),vec2(.95,.54),vec2(.90,.50),vec2(.68,.41),\nvec2(.68,.40),vec2(.90,.40),vec2(.94,.38),vec2(.90,.36),vec2(.71,.36),\nvec2(.70,.35),vec2(.73,.31),vec2(.74,.29),vec2(.74,.29),vec2(.72,.30),\nvec2(.68,.36),vec2(.65,.42),vec2(.61,.46),vec2(.56,.48),vec2(.51,.48),\nvec2(.46,.46),vec2(.43,.43),vec2(.41,.44),vec2(.42,.45),vec2(.42,.44) );\n\n\nfloat sdPoly15 POLY(15)\nvec2 pt15[ 15]=vec2[](  \nvec2(.46,.42),vec2(.44,.44),vec2(.46,.46),vec2(.51,.48),vec2(.56,.48),\nvec2(.61,.46),vec2(.65,.42),vec2(.68,.37),vec2(.63,.37),vec2(.61,.41),\nvec2(.57,.44),vec2(.53,.44),vec2(.49,.43),vec2(.48,.43),vec2(.46,.42) );\n\n\nfloat sdPoly77 POLY(77)\nvec2 pt77[ 77]=vec2[](  \nvec2(.41,.32),vec2(.42,.35),vec2(.44,.38),vec2(.46,.40),vec2(.47,.41),\nvec2(.48,.41),vec2(.48,.40),vec2(.46,.40),vec2(.45,.39),vec2(.46,.38),\nvec2(.49,.38),vec2(.50,.39),vec2(.52,.38),vec2(.54,.37),vec2(.56,.35),\nvec2(.57,.33),vec2(.57,.30),vec2(.57,.29),vec2(.56,.28),vec2(.55,.26),\nvec2(.54,.25),vec2(.57,.27),vec2(.57,.28),vec2(.58,.29),vec2(.59,.29),\nvec2(.61,.29),vec2(.62,.27),vec2(.64,.25),vec2(.62,.24),vec2(.61,.23),\nvec2(.60,.22),vec2(.61,.22),vec2(.62,.23),vec2(.64,.24),vec2(.65,.23),\nvec2(.66,.23),vec2(.65,.25),vec2(.64,.26),vec2(.62,.29),vec2(.61,.30),\nvec2(.60,.30),vec2(.58,.30),vec2(.58,.32),vec2(.58,.34),vec2(.60,.33),\nvec2(.62,.33),vec2(.63,.34),vec2(.64,.35),vec2(.64,.36),vec2(.62,.35),\nvec2(.61,.34),vec2(.59,.34),vec2(.57,.35),vec2(.56,.36),vec2(.54,.38),\nvec2(.61,.39),vec2(.60,.40),vec2(.58,.41),vec2(.54,.42),vec2(.51,.41),\nvec2(.50,.40),vec2(.50,.40),vec2(.49,.41),vec2(.52,.42),vec2(.54,.43),\nvec2(.57,.42),vec2(.59,.42),vec2(.61,.41),vec2(.61,.41),vec2(.57,.44),\nvec2(.51,.44),vec2(.46,.42),vec2(.44,.40),vec2(.42,.37),vec2(.41,.33),\nvec2(.40,.32),vec2(.41,.32) );\n\n// pelo\nfloat sdPoly30 POLY(30)\nvec2 pt30[ 30]=vec2[](  \nvec2(.42,.34),vec2(.44,.40),vec2(.48,.43),vec2(.51,.44),vec2(.56,.44),\nvec2(.61,.42),vec2(.63,.39),vec2(.64,.34),vec2(.62,.26),vec2(.60,.23),\nvec2(.59,.22),vec2(.58,.24),vec2(.58,.27),vec2(.58,.27),vec2(.58,.31),\nvec2(.57,.32),vec2(.55,.30),vec2(.54,.30),vec2(.54,.32),vec2(.53,.28),\nvec2(.53,.27),vec2(.51,.28),vec2(.51,.31),vec2(.49,.32),vec2(.47,.33),\nvec2(.45,.34),vec2(.44,.34),vec2(.43,.33),vec2(.42,.33),vec2(.42,.34) );\n\n// rostro\nfloat sdPoly33 POLY(33)\nvec2 pt33[ 33]=vec2[](  \nvec2(.42,.33),vec2(.43,.30),vec2(.41,.26),vec2(.41,.25),vec2(.42,.25),\nvec2(.43,.25),vec2(.43,.23),vec2(.44,.22),vec2(.44,.22),vec2(.44,.22),\nvec2(.44,.21),vec2(.45,.20),vec2(.44,.20),vec2(.44,.18),vec2(.45,.17),\nvec2(.47,.18),vec2(.53,.20),vec2(.57,.22),vec2(.59,.23),vec2(.58,.26),\nvec2(.58,.29),vec2(.58,.31),vec2(.56,.33),vec2(.54,.30),vec2(.53,.32),\nvec2(.53,.27),vec2(.51,.28),vec2(.51,.31),vec2(.48,.33),vec2(.45,.34),\nvec2(.43,.34),vec2(.42,.34),vec2(.42,.33) );\n\n// pestana\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.42,.32),vec2(.45,.33),vec2(.46,.32),vec2(.45,.32),vec2(.43,.32),\nvec2(.43,.32),vec2(.42,.32) );\n\n//ojo\nfloat sdPoly6 POLY(6)\nvec2 pt6[ 6]=vec2[](  \nvec2(.44,.31),vec2(.46,.31),vec2(.47,.30),vec2(.45,.29),vec2(.44,.30),\nvec2(.44,.31) );\n\nvec3 rayo(vec2 puv )\n{   vec2 uv=puv;\n    float s1 = 0.5+0.5*sin(iTime+uv.x*20.*(sin(iTime)+4.0));\n    float s2 = 0.5+0.25*sin(iTime+uv.x*100.*(sin(iTime)*2.0+2.0));\n    float r = pow(1.0-sqrt( abs(uv.y-s1)),1.5 );\n    float g = pow(1.0-sqrt( abs(uv.y-s2)),1.5 );\n    float b = 1.0*(r+g);\n   return vec3(r,g,b);\n}\n\nvec4 lines(vec2 position)\n{\tvec3 color;\n    if (position.x>0.4) return vec4(0.0);\n    float red1 = position.y-(0.02*cos(iTime+1.5)+1.)/2.+0.35;\n    float red2 = position.y-(0.02*cos(iTime+1.5)+1.)/2.+0.45;\n    \n\tred1 = 1.-pow(abs(red1*20.),.5);\n    red2 = 1.-pow(abs(red2*20.),.5);\n\tcolor= mix(vec3(0.),vec3(2.,0.,0.), red1);\n    color= mix(color,vec3(2.,0.,0.), red2);\n\t\n    color = clamp(color, 0.,2.);\n\tfloat m = max(max(color.x - 1.,color.y - 1.),color.z-1.);\n\tcolor += vec3(m);\n\tcolor = clamp(color, 0.,1.);\n\treturn vec4(color,float(distance(color,vec3(0.))));\n}\n\nvec3 RostroAquiles(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  float sd1 = sdPoly60(p-vec2(0.0,-0.2), pt60);  //casco1\n  float sd2 = sdPoly15(p-vec2(0.0,-0.2), pt15);  // casco2\n  float sd3 = sdPoly77(p-vec2(0.0,-0.2), pt77);  //casco3\n  float sd4 = sdPoly30(p-vec2(0.0,-0.2), pt30); //pelo\n  float sd5 = sdPoly33(p-vec2(0.0,-0.2), pt33); //rostro\n  float sd6 = sdPoly7(p-vec2(0.0,-0.2), pt7);  //pestaa\n  float sd7 = sdPoly6(p-vec2(0.0,-0.2), pt6);  //ojo\n  \n //col = mix(col,vec3(0.6, 0.4,1.0),S(sd1,0.0));\n  col = mix(col,vec3(0.7, 0.6,0.5),S(sd1,0.0));\n  col = mix(col,vec3(0.9, 0.8,0.6),S(sd2,0.0));\n  col = mix(col,vec3(0.98, 0.82,0.720),S(sd5,0.0));   //vec3(0.98, 0.82,0.720) piel\n  col = mix(col,vec3(0.1, 0.1,0.2),S(sd4,0.0));\n  col = mix(col,vec3(1.0, 0.3,0.6),S(sd3,0.0));\n  col = mix(col,vec3(0.2, 0.2,0.2),S(sd6,0.0));\n  col = mix(col,vec3(0.8, 0.2,0.2),S(sd7,0.0));\n  \n  vec3 cr1= rayo(p);\n  float sb1=sdBox(p-vec2(-0.1,0.1), vec2(0.5,0.0125) );\n  col = mix(col,cr1,S(sb1,0.0));\n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    //posicion\n    vec2 p=uv+vec2(1.5,0.7);\n    // escala\n    p.x*=0.7;\n    p.y*=0.8;\n    p*=0.5+1.0*abs(sin(iTime*0.35));\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col=vec3((col.x+col.y+col.z)/3.0)*vec3(0.2,0.2,1.0);\n    \n     col= RostroAquiles( p,col*2.0);\n    \n    vec4 l1= lines(p);\n  col = mix(l1.xyz,col,S(l1.w,0.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXSW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[432, 432, 465, 465, 487], [488, 488, 521, 521, 543], [544, 544, 577, 577, 598], [600, 638, 674, 674, 719], [720, 733, 770, 770, 843], [845, 845, 880, 880, 904], [906, 906, 940, 940, 1033], [5110, 5110, 5132, 5132, 5423], [5425, 5425, 5452, 5452, 5992], [5994, 5994, 6037, 6037, 7001], [7002, 7002, 7059, 7059, 7494]], "test": "untested"}
{"id": "NdlSzX", "name": "Ant Particles", "author": "michionlion", "description": "Particles follow trails left by other particles. Cool images appear!\nTry changing the number of agents (NUM_AGENTS_SQRT in Common), up to the smallest side resolution of the canvas; also, Buffer A has particle parameters, and B has trail parameters.\n", "tags": ["particles", "art", "trail", "ant"], "likes": 15, "viewed": 428, "published": 3, "date": "1619208608", "time_retrieved": "2024-07-30T19:23:58.418404", "image_code": "vec3 decompressColorRamp(float color) {\n    if (color > 1.0) {\n        return vec3(0.0);\n    } else if (color > 0.75) {\n        return mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (color - 0.75) * 4.0);\n    } else if (color > 0.5) {\n        return mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), (color - 0.5) * 4.0);\n    } else if (color > 0.25) {\n        return mix(vec3(0.0, 1.0, 1.0), vec3(0.0, 1.0, 0.0), (color - 0.25) * 4.0);\n    } else if (color >= 0.0) {\n        return mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), color * 4.0);\n    } else {\n        return vec3(1.0);\n    }\n}\n\nvec3 decompressColor(float color) {\n    uint fields = floatBitsToUint(color);\n    return vec3((fields >> 8) & 0xFu, (fields >> 4) & 0xFu, fields & 0xFu) / 15.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    //vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //fragColor = vec4(vec2(rand(fragCoord.xy), rand(fragCoord.yx)), 0.0, 0.0);\n    //fragColor = data;\n    //return;\n    \n    //vec2 location = fragCoord / iResolution.xy;\n    //vec2 pixelSize = 1.0 / iResolution.xy;\n\n    //vec3 point = vec3(0.0);\n    //for(int x = 0; x < NUM_AGENTS_SQRT; x++) {\n    //    for(int y = 0; y < NUM_AGENTS_SQRT; y++) {\n            \n    //        vec4 agentdata = texelFetch(iChannel0, ivec2(x, y),  0);\n    //        float closeToPoint = AGENT_SIZE / distanceSqr(agentdata.xy*iResolution.xy, fragCoord);\n    //        point = mix(point, decompressColor(agentdata.w), closeToPoint);\n            //if(ivec2(agentdata.xy*iResolution.xy) == ivec2(fragCoord)) {\n            //    point = decompressColor(agentdata.w);\n            //}\n    //    }\n    //}\n    \n    float trail = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n    \n    //fragColor = vec4(vec3(point) + vec3(trail), 1.0);\n    fragColor = mix(vec4(0.0), mix(vec4(0.0, 0.2, 1.0, 0.7), vec4(0.5, 1.0, 1.0, 1.0), trail), trail);\n    //fragColor = vec4(point*10.0 + vec3(trail), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TWO_PI 6.283185307179586\n#define SENSOR_DISTANCE 7.0\n#define SENSOR_RADIUS 2\n// in radians!\n#define SENSOR_ANGLE 0.8\n\n#define TURN_SPEED 0.2\n#define SPEED 1.0\n#define RANDOM_MOVEMENT 0.001\n#define RANDOM_BIAS 0.0\n\nfloat getTrailAt(ivec2 pos) {\n    return texelFetch(iChannel1, pos, 0).x;\n}\n\nfloat sense(vec2 pos, float angle, float sensorAngleOffset) {\n    float sensorAngle = angle + sensorAngleOffset;\n    vec2 sensorDir = vec2(cos(sensorAngle), sin(sensorAngle));\n    vec2 sensorCenter = pos + sensorDir * SENSOR_DISTANCE;\n    \n    float sensed = 0.0;\n    for(int xo = -SENSOR_RADIUS; xo <= SENSOR_RADIUS; xo++) {\n        for(int yo = -SENSOR_RADIUS; yo <= SENSOR_RADIUS; yo++) {\n            sensed += getTrailAt(ivec2(sensorCenter + vec2(xo, yo)));\n        }\n    }\n    return sensed / float((SENSOR_RADIUS + 1) * (SENSOR_RADIUS + 1));\n}\n\nvoid mainImage( out vec4 agentdata, in vec2 index ) {\n\n    // Initialize the agent data on the first frame.\n    if (iFrame == 1)\n    {\n        float r = (iResolution.y / 4.0) * sqrt(rand(index.xy));\n        float t = rand(index.yx) * TWO_PI;\n        float z = rand(index.xy*829.0);\n        \n        vec2 center = iResolution.xy / 2.0;\n        vec2 pos = center + vec2(r * cos(t), r * sin(t));\n\t\tagentdata = vec4(pos / iResolution.xy, z * TWO_PI, 0.0);\n        return;\n    }\n    \n    // no idea if this helps or hurts performance\n    if(index.y > float(NUM_AGENTS_SQRT) || index.x > float(NUM_AGENTS_SQRT)) discard;\n\n    vec4 previousAgentData = texelFetch(iChannel0, ivec2(index), 0);\n    vec2 pos = previousAgentData.xy * iResolution.xy;\n    float angle = previousAgentData.z * TWO_PI;\n    //float color = previousAgentData.w;\n    \n    float weightForward = sense(pos, angle, 0.0);\n    float weightLeft = sense(pos, angle, SENSOR_ANGLE);\n    float weightRight = sense(pos, angle, -SENSOR_ANGLE);\n    \n    float randomSteerStrength = rand(index.xy*angle + pos*angle) * 0.25 + 0.5;\n    \n    if (weightForward > weightLeft && weightForward > weightRight) {\n        angle += 0.0;\n        //color = 0.9;\n    } else if (weightForward < weightLeft && weightForward < weightRight) {\n        // Biasing this one direction or the other calms down a lot of things!\n        angle += (randomSteerStrength - 0.625 + RANDOM_BIAS) * RANDOM_MOVEMENT * TURN_SPEED;\n        //color = 0.0;\n    } else if (weightRight > weightLeft) {\n        angle -= randomSteerStrength * TURN_SPEED;\n        //color = 0.6;\n    } else if (weightLeft > weightRight) {\n        angle += randomSteerStrength * TURN_SPEED;\n        //color = 0.3;\n    }\n    \n    //color = uintBitsToFloat(uint(weightLeft * 15.0) << 8 | uint(weightRight * 15.0) << 4 | uint(weightForward * 15.0));\n\n    vec2 delta = vec2(cos(angle), sin(angle)) * SPEED;\n    pos += delta;\n    // loop when resolution hit\n    pos = mod(pos, iResolution.xy); \n    agentdata = vec4(pos / iResolution.xy, angle / TWO_PI, 0.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NUM_AGENTS_SQRT 128\n#define TOTAL_AGENTS float(NUM_AGENTS_SQRT*NUM_AGENTS_SQRT)\n\n#define AGENT_SIZE 0.25\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nfloat distanceSqr(vec2 A, vec2 B) {\n    vec2 C = A - B;\n    return dot( C, C );\n}", "buffer_b_code": "// Diffusion controls how much \"diffusion\" is applied to a trail every frame\n#define DIFFUSION 0.15\n\n// Evaporation controls how much is subtracted from each trail pixel every frame\n#define EVAPORATION 0.01\n\n// Strength controls how much initial trail is deposited by each agent\n#define STRENGTH 0.1\n\nfloat getPreviousTrail(vec2 pos) {\n    return texelFetch(iChannel1, ivec2(mod(pos, iResolution.xy)), 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 location = fragCoord / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    \n    float trail = 0.0;\n    for(int x = 0; x < NUM_AGENTS_SQRT; x++) {\n        for(int y = 0; y < NUM_AGENTS_SQRT; y++) {\n            \n            vec4 agentdata = texelFetch(iChannel0, ivec2(x, y),  0);\n            //if(distanceSqr(agentdata.xy*iResolution.xy, fragCoord) <= AGENT_SIZE) trail = STRENGTH;\n            if(ivec2(agentdata.xy*iResolution.xy) == ivec2(fragCoord)) trail = STRENGTH;\n            \n        }\n    }\n    \n    float previousTrail = getPreviousTrail(fragCoord);\n    \n    float diffused = 0.0;\n    for(int xo = -1; xo <= 1; xo++) {\n        for(int yo = -1; yo <= 1; yo++) {\n            diffused += getPreviousTrail(fragCoord + vec2(xo, yo));\n        }\n    }\n    \n    previousTrail = mix(previousTrail, diffused / 9.0, DIFFUSION);\n    previousTrail = max(0.0, previousTrail - EVAPORATION);\n    fragColor = vec4(vec3(min(1.0, previousTrail + trail)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlSzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 584], [586, 586, 621, 621, 748], [750, 750, 807, 1651, 1941]], "test": "untested"}
{"id": "fdsXDB", "name": "Tron  (2 player game)", "author": "mdb", "description": "a small 2D tron game:\nthe rules are simples:\n - survive the longer\n - you die if cross the wall of any player or ou go out of bound\n\ncommandes:\nblue player: arrow key\nred player: a,d or q,d\n\npress space to restart", "tags": ["game", "tron", "bloom"], "likes": 11, "viewed": 906, "published": 3, "date": "1619200325", "time_retrieved": "2024-07-30T19:23:59.609220", "image_code": "/*\na small 2D tron game,\n\nthe rules are simples:\n - survive the longest\n - you die if cross the wall of any player or ou go out of bound\n\ncommandes:\n *blue player: arrow key\n *red player: a,d or q,d\n\npress 'space' to restart\n\nhave fun and leave a like ;)\n*/\n\n\n//apply bloom effect\nfloat normpdf(in float x)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //declare stuff\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j));\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        vec3 c = texture(iChannel2, (fragCoord.xy+vec2(0.0, float(i))) / iResolution.xy).rgb;\n        final_colour += kernel[kSize+i]*c;\n  \n    }\n    \n    vec3 col =  texture(iChannel0, uv).xyz + final_colour/(Z)*1.6;\n    \n    //vigniettage\n    col *= 0.2 + 0.8*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.4 );\n    \n    //debug mode\n    //col += 0.5*texture(iChannel1, uv*0.1).rgb;\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//game variables\n\nbool inBox(vec2 coord, vec4 bounds) {\n    return coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\nvec2 currentCoord;\nvec4 outValue;\nbool onVar(vec2 coord){\n    return (inBox(currentCoord, vec4(coord, 1., 1.)));\n}\n\nbool keyPress(int key){\n    return (texture(iChannel1, vec2(float(key)/255.0, 0.5)).x == 1.0);\n}\nvoid initVars(){\n    if (onVar(_endGame)) outValue = vec4(0.0);\n    if (onVar(_p1)) outValue = vec4(-0.5, -0.1, 1.0, 0.0);\n    if (onVar(vec2(0.0, wall1))) outValue = vec4(-0.5, -0.1, 1.0, 0.0);\n    if (onVar(_p2)) outValue = vec4(0.5, 0.1, -1.0, 0.0);\n    if (onVar(vec2(0.0, wall2))) outValue = vec4(0.5, 0.1, 1.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    currentCoord = fragCoord;\n    outValue = vec4(0.0);\n    bool endGame = (load(_endGame).x == 1.0);\n    if(iFrame == 0 || (endGame && keyPress(32))){\n        initVars();\n    }else{   \n        bool pressD = keyPress(D);\n        bool pressA = keyPress(A);\n        bool pressQ = keyPress(Q);\n        bool pressLeft = keyPress(LEFTARROW);\n        bool pressRight = keyPress(RIGHTARROW);\n        // car mouvement and reaction to inputs\n        if(onVar(_p1)){\n            vec4 p1 = load(_p1);\n            if (!endGame){\n                p1.xy += p1.zw * carSpeed * iTimeDelta;\n\n                if(pressD){\n                    p1.zw = mat2x2(0.0, -1.0,\n                                   1.0,  0.0)*p1.zw;\n                }\n                if(pressA || pressQ){ // for ZQSD or WASD\n                    p1.zw = mat2x2(0.0, 1.0,\n                                  -1.0, 0.0)*p1.zw;\n            }}\n            outValue = p1;\n        }\n        if(onVar(_p2)){\n            vec4 p2 = load(_p2);\n            if (!endGame){\n                p2.xy += p2.zw * carSpeed * iTimeDelta;\n\n                if(pressRight){\n                    p2.zw = mat2x2(0.0, -1.0,\n                                   1.0,  0.0)*p2.zw;\n                }\n                if(pressLeft){ // for ZQSD or WASD\n                    p2.zw = mat2x2(0.0, 1.0,\n                                  -1.0, 0.0)*p2.zw;\n                }}\n            outValue = p2;\n        }\n        \n        //check if the game should end\n        if(onVar(_endGameTime)){\n            if(!endGame){\n                outValue = vec4(iTime, 0.0, 0.0, 0.0);\n            }else{\n                outValue = load(_endGameTime);\n            }\n        }\n        if(onVar(_endGame)){\n            vec4 gameResult = vec4(0.0);\n            if(endGame){\n                gameResult = load(_endGame);\n            }else{\n            \n                //first car\n                vec4 p1 = load(_p1);\n                vec4 p2 = load(_p2);\n                \n                vec2 lastPos = p2.xy;\n                for(int i = 0; i < 256; i++){\n                    vec3 wp = load(vec2(i, wall2)).xyz;\n                    if(wp.z < 0.9 || gameResult.x > 0.5) break; \n                    vec2 dxy = max(abs(p1.xy - 0.5*(lastPos + wp.xy)) - (wallWidth + abs(lastPos - wp.xy))*0.5, vec2(0.0));\n                    float touch = 1.0 - step(0.0, sqrt(dot(dxy,dxy)) - 0.5*carWidth);\n                    gameResult.xy += vec2(touch);\n                    lastPos = wp.xy;\n                }\n                lastPos = load(vec2(2, wall1)).xy;\n                for(int i = 3; i < 256; i++){\n                    vec3 wp = load(vec2(i, wall1)).xyz;\n                    if(wp.z < 0.9 || gameResult.x > 0.5) break; \n                    vec2 dxy = max(abs(p1.xy - 0.5*(lastPos + wp.xy)) - (wallWidth + abs(lastPos - wp.xy))*0.5, vec2(0.0));\n                    float touch = 1.0 - step(0.0, sqrt(dot(dxy,dxy)) - 0.5*carWidth);\n                    gameResult.xy += vec2(touch);\n                    lastPos = wp.xy;\n                }\n                \n\n                //second car\n                lastPos = p1.xy;\n                for(int i = 0; i < 256; i++){\n                    vec3 wp = load(vec2(i, wall1)).xyz;\n                    if(wp.z < 0.9 || gameResult.x > 0.5) break; \n                    vec2 dxy = max(abs(p2.xy - 0.5*(lastPos + wp.xy)) - (wallWidth + abs(lastPos - wp.xy))*0.5, vec2(0.0));\n                    float touch = 1.0 - step(0.0, sqrt(dot(dxy,dxy)) - 0.5*carWidth);\n                    gameResult.xz = vec2(touch);\n                    lastPos = wp.xy;\n                }\n                lastPos = load(vec2(2, wall2)).xy;\n                for(int i = 3; i < 256; i++){\n                    vec3 wp = load(vec2(i, wall2)).xyz;\n                    if(wp.z < 0.9 || gameResult.x > 0.5) break; \n                    vec2 dxy = max(abs(p2.xy - 0.5*(lastPos + wp.xy)) - (wallWidth + abs(lastPos - wp.xy))*0.5, vec2(0.0));\n                    float touch = 1.0 - step(0.0, sqrt(dot(dxy,dxy)) - 0.5*carWidth);\n                    gameResult.xz = vec2(touch);\n                    lastPos = wp.xy;\n                }\n                //check if a car goes outside the screen\n                vec2 pointTop = vec2(iResolution.x/iResolution.y, 1.0);\n                vec2 off1 = abs(p1.xy) - pointTop;\n                gameResult.xy += step(0.0, max(off1.x, off1.y));\n                vec2 off2 = abs(p2.xy) - pointTop;\n                gameResult.xz += step(0.0, max(off2.x, off2.y));\n                if(gameResult.x > 1.5){ //both dead -> random winner\n                    float r =  fract(sin((iTime + iDate.w*0.1)*100.0)*100.0); // poor random\n                    if(r < 0.5){gameResult.y = 0.0;\n                    }else{      gameResult.z = 0.0;}\n                }\n                gameResult.x = min(gameResult.x, 1.0);\n                \n            }\n            outValue = gameResult;\n        }\n        // storage of new walls if the car turn\n        if(wall1 <= currentCoord.y && currentCoord.y < wall1+1.0){\n            if(pressA || pressQ || pressD){\n                vec4 p1 = load(_p1);\n                if (currentCoord.x < 1.0){\n                    outValue = vec4(p1.x, p1.y, 1.0, 0.0);\n                }else{\n                    outValue = load(currentCoord - vec2(1.0, 0.0));\n                }\n            }else{\n                outValue = load(currentCoord);\n            }\n        }\n        if(wall2 <= currentCoord.y && currentCoord.y < wall2+1.0){\n            if(pressLeft || pressRight){\n                vec4 p2 = load(_p2);\n                if (currentCoord.x < 1.0){\n                    outValue = vec4(p2.x, p2.y, 1.0, 0.0);\n                }else{\n                    outValue = load(currentCoord - vec2(1.0, 0.0));\n                }\n            }else{\n                outValue = load(currentCoord);\n            }\n        }\n    }\n    fragColor = outValue;\n}\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float text(float looser, vec2 uv){\n    if(uv.y > 0.5){//color of the winner \"BLUE\" or \"RED\"\n        uv.y = 2.0*(uv.y-0.5);\n        if(looser < 0.5){//red loose\n            int letterID = int(floor(uv.x*4.0));\n            uv.x = fract(uv.x*4.0);\n            uv = uv*0.8 + 0.1;\n            vec2 co;\n            if(letterID == 0)co = vec2(2.0, 11.0);\n            if(letterID == 1)co = vec2(12.0, 11.0);\n            if(letterID == 2)co = vec2(5.0, 10.0);\n            if(letterID == 3)co = vec2(5.0, 11.0);\n            return texture(iChannel1, (co + uv)/16.0).x;\n        }else{\n            int letterID = int(floor(uv.x*3.0));\n            uv.x = fract(uv.x*3.0);\n            uv = uv*0.8 + 0.1;\n            vec2 co;\n            if(letterID == 0)co = vec2(2.0, 10.0);\n            if(letterID == 1)co = vec2(5.0, 11.0);\n            if(letterID == 2)co = vec2(4.0, 11.0);\n            return texture(iChannel1, (co + uv)/16.0).x;\n        }\n    }else{// \"WIN\"\n        uv.y*=2.0;\n        int letterID = int(floor(uv.x*3.0));\n        uv.x = fract(uv.x*3.0);\n        uv = uv*0.8 + 0.1;\n        vec2 co;\n        if(letterID == 0)co = vec2(7.0, 10.0);\n        if(letterID == 1)co = vec2(9.0, 11.0);\n        if(letterID == 2)co = vec2(14.0, 11.0);\n        return texture(iChannel1, (co + uv)/16.0).x;\n    }\n}\n// game scene\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y; \n    vec3 col = vec3(0.05, 0.0, 0.1)*2.0; //background\n    \n    //first car\n    vec4 p1 = load(_p1);\n    vec2 lastPos = p1.xy;\n    float p1Wall = 0.0;\n    for(int i = 0; i < 256; i++){\n        vec3 wp = load(vec2(i, wall1)).xyz;\n        if(wp.z < 0.9) break; \n        vec2 dxy = max(abs(uv - 0.5*(lastPos + wp.xy)) - (wallWidth + abs(lastPos - wp.xy))*0.5, vec2(0.0));\n        p1Wall = max(1.0 - smoothstep(0.0, 0.001, sqrt(dot(dxy,dxy)) - 0.00001), p1Wall);\n        lastPos = wp.xy;\n    }\n    col += vec3(1.0, 0.6, 0.3) * p1Wall;\n    vec2 duvp1 = abs(uv - p1.xy);\n    float carWeight = smoothstep(0.0, carWidth*0.2, carWidth - max(duvp1.x, duvp1.y));\n    col = mix(col, vec3(1.0, 0.6, 0.3)*3.0, carWeight);\n    \n    //second car\n    vec4 p2 = load(_p2);\n    lastPos = p2.xy;\n    float p2Wall = 0.0;\n    for(int i = 0; i < 256; i++){\n        vec3 wp = load(vec2(i, wall2)).xyz;\n        if(wp.z < 0.9) break; \n        vec2 dxy = max(abs(uv - 0.5*(lastPos + wp.xy)) - (wallWidth + abs(lastPos - wp.xy))*0.5, vec2(0.0));\n        p2Wall = max(1.0 - smoothstep(0.0, 0.001, sqrt(dot(dxy,dxy)) - 0.00001), p2Wall);\n        lastPos = wp.xy;\n    }\n    col += vec3(0.3, 0.6, 1.0) * p2Wall;\n    vec2 duvp2 = abs(uv - p2.xy);\n    carWeight = smoothstep(0.0, carWidth*0.2, carWidth - max(duvp2.x, duvp2.y));\n    col = mix(col, vec3(0.3, 0.6, 1.0)*3.0, carWeight);\n    \n    //death annim\n    vec4 endGame = load(_endGame);\n    if(endGame.x > 0.9){\n        vec3 dead; //0=red   1=blue\n        if(endGame.y > 0.9)dead = vec3(load(_p1).xy, 0.0);\n        if(endGame.z > 0.9)dead = vec3(load(_p2).xy, 1.0);\n        float t = iTime - load(_endGameTime).x;\n        float t2 = pow(max(0.0, t), 5.0)*0.3;\n        float c = smoothstep(0.0, 0.01,length(uv - dead.xy)-t2); \n        col = mix(col, vec3(1.0), 0.2*(1.0-c));\n        c *= smoothstep(0.0, 0.01,-length(uv - dead.xy)+t2+0.05);\n        col = mix(col, vec3(1.0), c);\n        \n        //winner announcement\n        float t3 = max(t-2.0, 0.0);\n        float k3 = 1.0/(1.0+exp(-3.0*t3 + 2.0));\n        col = mix(col, vec3(0.0), 0.8*k3);\n        \n        vec2 pointTop = vec2(iResolution.x/iResolution.y, 1.0)*0.75;\n        vec2 off1 = abs(uv) - pointTop;\n        k3 = max(0.0, k3-0.2)*2.5;\n        k3 *= 1.0-step(0.0, max(off1.x, off1.y));\n        vec3 textColor = mix(vec3(0.3, 0.6, 1.0), vec3(1.0, 0.6, 0.3), dead.z);\n        \n        col = mix(col, textColor, smoothstep(0.5, 0.51, text(dead.z, fragCoord/iResolution.xy*1.5-0.25))*k3);\n\n    }\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26841, "src": "https://soundcloud.com/algoritmos666/tron-legacy-soundtrack-ost-03", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "\n#define wallWidth 0.027\n#define carWidth 0.03\n#define carSpeed 0.4\n\n//keys\n#define Q 81\n#define A 65\n#define D 68\n#define LEFTARROW 37\n#define RIGHTARROW 39\n\n//bloom\n#define mSize 31\n#define sigma 6.0\n\n//variables management from https://www.shadertoy.com/view/wsByWV\n//shared variables (in buffer A)\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.0\n#define wall1 1.0\n#define wall2 2.0\n#define load( coord)  texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy))\n\nvar(_p1, 0, varRow); // p.x, p.y, v.x, v.y\nvar(_p2, 1, varRow);\nvar(_endGame, 2, varRow); // x:the game end, y:p1 loose, z:p2 loose\nvar(_endGameTime, 3, varRow);  //time in the end for death animations\n\n\n\n", "buffer_c_code": "//apply bloom effect\nconst float brightnessMin = 0.6;\n\nfloat brightPassFilter(vec3 color){\n    return step(brightnessMin, dot(color, vec3(0.333, 0.333, 0.333)));\n}\n\nfloat normpdf(in float x){\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //declare stuff\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j));\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        vec3 c = texture(iChannel0, (fragCoord.xy+vec2(float(i),0.0)) / iResolution.xy).rgb;\n        final_colour += kernel[kSize+i]*c*brightPassFilter(c);\n  \n    }\n\n\n    fragColor = vec4(final_colour/(Z), 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsXDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 281, 308, 308, 361], [363, 363, 420, 420, 1377]], "test": "untested"}
{"id": "sdlSDB", "name": "Mosaic pattern", "author": "jarble", "description": "This mosaic has an interwoven braid-like structure.", "tags": ["fractal", "mosaic"], "likes": 6, "viewed": 234, "published": 3, "date": "1619193477", "time_retrieved": "2024-07-30T19:24:00.609545", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    float t1 = 30.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/t1;\n    uv.y += (iTime)/t1;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.35;\n        float scale1 = 1.04;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv = fract(-uv.yx/s1)*s1;\n            uv.y /= -scale1;\n            uv= fract(uv+((vec2(-uv.x/scale+uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            \n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 786]], "test": "untested"}
{"id": "7slSDS", "name": "Iridescent portals", "author": "jarble", "description": "An edit of my \"Alien technology\" fractal.", "tags": ["fractal", "metal", "shiny", "portal"], "likes": 5, "viewed": 400, "published": 3, "date": "1619178527", "time_retrieved": "2024-07-30T19:24:01.492185", "image_code": "#define pattern vec3(0.0,0.0,0.0)\n//#define pattern vec2(2.0,2.0)\n//#define pattern vec2(2.0,iTime)\n\n#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/20.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.16;\n        float scale1 = 1.16;\n        col_prev = col;\n        \n        for(int i=0;i<ITERS;i++)\n        {\n            float uv1 = uv.x-uv.y;\n            uv= fract(pattern.z-uv-(((vec2(uv1+pattern.x*col.x,-pattern.y-uv1))/(scale1*scale*scale))))/scale1;\n            uv.x *= scale1;\n            uv = fract(pattern.z+uv.yx);\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slSDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 175, 175, 912]], "test": "untested"}
{"id": "NslXWS", "name": "Truchet Path / Robot Arm", "author": "byt3_m3chanic", "description": "Daily shader exercises / practice - Trying to use some other shading (phong) methods - Not sure if its a robotic arm in a crazy lab or alight bulb factory.. I <3 Truchets", "tags": ["raymarching", "truchet", "motion", "tiles"], "likes": 23, "viewed": 551, "published": 3, "date": "1619168683", "time_retrieved": "2024-07-30T19:24:02.421700", "image_code": "/**daily shader | 004 4/22/2021 @byt3_m3chanic*/\n#define COLOR(COORD) texture(iChannel0,(COORD))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n\tvec2 uv = fragCoord.xy/iResolution.xy;    \n    vec3 color = COLOR(uv).rgb;\n    // effect sammple\n    vec3 fgclr = vec3(0.);\n    float f = length(uv  - 1.75);\n    fgclr.x = COLOR(uv - vec2(f*0.001,0.)).x;\n    fgclr.y = COLOR(uv + vec2(f*0.001,.001)).y;\n    fgclr.z = COLOR(uv + vec2(f*0.002,.001)).z;\n \n    // mask for effect and mixdown \n    float dt = distance(uv.xy,vec2(.5))*2.15;\n    dt = smoothstep(0.,.8,1.-dt);\n    vec3 C = mix(fgclr,color,dt);\n    // output -gamma correct\n    fragColor = vec4(pow(C, vec3(0.4545)),1.);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/**daily shader | 004 4/22/2012 @byt3_m3chanic*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .001\n//2 to 1 hash\nfloat hash21(vec2 p){\n    return fract(sin(dot(p,vec2(27.609,57.583)))*43.5453); \n}\n// rotation\nmat2 rot(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvoid getMouse(inout vec3 p)\n{\n    float x =-.61;\n    //M.xy==vec2(0) ? -.65:-(M.y/R.y*.5-.25)*PI;\n    float y = M.xy==vec2(0) ? 0.:-(M.x/R.x*1.-.5)*PI;\n    p.zy*=rot(x);\n    p.xz*=rot(y);\n}\n\n//http://mercury.sexy/hg_sdf/\nfloat vmax(vec3 v) \n{\n    return max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b, float r) \n{\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)))-r;\n}\n//@iq\nfloat sdCap( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdCyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec3 hit,hitPoint;\nfloat hitId,objId;\nfloat time=0., moveTime=0., glow=0.;\nmat2 r180,r90;\n\nconst vec2 sc = vec2(.25), hsc = .5/sc; \nconst float amt = 6.;\nconst float dbl = amt*2.;\n\nvec2 map(vec3 p, float sg)\n{\n    p.zx+=vec2(moveTime,-moveTime);\n        \n    vec2 res = vec2(1e5,0.);\n    vec3 op = p;\n    vec2 id = floor(p.xz*sc) + .5;    \n    vec2 q = p.xz - id/sc;\n    vec3 pd = vec3(q.x,op.y,q.y);\n    \n    // Flip random cells\n    float rnd = hash21(id);\n    if(rnd<.5) q.y = -q.y;\n\n    // create truchet curves\n    vec2 d2 = vec2(length(q-hsc), length(q+hsc));  \n    float crv = abs(min(d2.x,d2.y)-hsc.x);\n    float dir = mod(id.x+id.y,2.)<.5? -1. : 1.;\n\n    vec2 pp = d2.x<d2.y? vec2(q - hsc) : vec2(q + hsc);\n    pp *= rot(time*dir);\n    \n    float a = atan(pp.y, pp.x);\n    float ai = floor(dir*a/PI*amt);\n\n    a = (floor(a/PI2*dbl) + .5)/dbl;\n\n    float ws = mod(ai,amt);\n\n    vec2 qr = rot(-a*PI2)*pp; \n    qr.x -= hsc.x;\n\n    vec3 npos = vec3(qr.x, op.y, qr.y);\n    vec3 nnos = vec3(qr.x, op.y-.2, qr.y);\n\n    float swn = 1.+(.15*cos(ws+time*5. ))*dir;\n    float dwn = 1.-(1.15*cos(ws+time*5. ))*dir;\n    \n    mat2 dir1 = rot(PI2-swn*PI2);\n    mat2 dir2 = rot(PI2+swn*PI2);\n    mat2 bdir = rnd>.5 ? dir1 : dir2;\n    mat2 adir = rnd>.5 ? rot(PI-dwn*PI) : rot(PI+dwn*PI);\n    \n    if(mod(ws,2.)<1.) nnos.xz *=(rnd<.5 ^^ dir<0.)? dir1 : dir2;\n\n    nnos.xy *= bdir;\n    vec3 ngos = nnos-vec3(0,.2,0);\n    ngos.xy *= adir;\n\n    float blox = fBox(npos,vec3(.15,.05,.05),.0)-.005;\n    float cl = sdCap(npos,.2,.01);\n\n    nnos.xz=abs(nnos.xz)-.01;\n    float c2 = sdCap(nnos,.195,.005);\n    float c3 = sdCap(ngos,.1,.0075);\n    float c4 = length(npos-vec3(0,.05,0))-.035;\n      c4 = min(length(npos-vec3(0,.2,0))-.015,c4);\n      \n    vec3 fpos = ngos-vec3(0,.08,0);\n    fpos.yz*=r90;\n    if(dir>.0) fpos.xy*=r180;\n    vec3 tpos = fpos-vec3(0,-.05,0);\n    vec2 c = vec2(sin(2.55),cos(2.55));\n    fpos.z=abs(fpos.z)-.015;\n    float hand = sdTorus(fpos-vec3(0,-.05,0), c, .035, .005);\n    \n    float tube = sdCap(tpos.yzx+vec3(0,.1,0),.2,.025);\n    if(tube<res.x) {\n        res = vec2(tube,5.);\n        hit= tpos-vec3(0,-.05,0);\n        hitId=sin(abs(ws-amt))*5.;\n    }\n    if(sg==1. && ws==1.) glow += .001/(.005+tube*tube);\n    if(sg==1. && (ws==5.||ws==3.)) glow += .001/(.005+tube*tube); \n    blox = min(blox,cl);\n    blox = min(blox,c2); \n    blox = min(blox,c3);\n    blox = min(blox,c4);\n    \n    blox = min(blox,hand);\n    if(blox<res.x) {\n        res = vec2(blox,4.);\n        hit= nnos;\n    }\n\n    //truchet track\n    vec3 tp = vec3(abs(abs(crv)-.145)-.075,op.y,crv);\n    float bx = fBox(tp, vec3(.0325, .015,1.), .0015)-.0025;\n    if(bx<res.x) {\n        res = vec2(bx, 3.);\n        hit=tp;\n    }\n\n    if(dir<.0){\n        vec3 pt = vec3(q.x,pd.y,q.y);\n        if(rnd>.5) pt.x *=-1.;\n        float cyl = sdCyl(pt-vec3(1.25,0,1.25),.5,.15);\n        cyl = min(sdCyl(pt+vec3(1.25,0,1.25),.5,.10),cyl);\n        if(cyl<res.x) {\n            res = vec2(cyl,6.);\n            hit= pt;\n        }\n\n    }\n    \n    float ground = p.y+.05;\n    if(ground<res.x) {\n        res = vec2(ground,1.);\n        hit=p;\n    }   \n    \n    return res;\n}\n// normal - tetrahedron method\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e, 0.).x+\n             h.yyx * map(p+h.yyx*e, 0.).x+\n             h.yxy * map(p+h.yxy*e, 0.).x+\n             h.xxx * map(p+h.xxx*e, 0.).x;\n    return normalize(n);\n}\n//good marcher\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg)\n{\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d, sg);\n        if(ray.x<MIN_DIST*d) break;\n        d += i>100 ? ray.x*.35 : ray.x * .75;\n        m  = ray.y;\n        if(d>MAX_DIST) break;\n       \n    }\n\treturn vec2(d,m);\n}\n//diffused shadow\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt)\n{\n    float k = 17.5;\n    float res = 1.0;\n    for( float t=mint; t < maxt; ){\n        float h = map(ro + rd*t,0.).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n        if( res<0.0001 || t>maxt ) break;\n    }\n    return res;\n}\n//compact phong\nvec3 phong(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 ro, vec3 lpos, vec3 n) \n{\n    vec3 l = normalize(lpos - p);\n    vec3 v = normalize(ro - p);\n    vec3 r = normalize(reflect(-l, n));\n    \n    float ln = dot(l, n);\n    float rv = dot(r, v);\n    float shadow = softshadow(p, l, 0.01, 12.0);\n    \n    if (ln < 0.0) return vec3(0.0);\n    if (rv < 0.0) return (k_d * ln) * shadow;\n \n    return (k_d * ln * shadow + k_s * pow(rv, alpha));\n}\n\nconst vec3 c = vec3(.985,.98,.99),\n           d = vec3(.25,.68,.89);\nvec3 hue(float t){ \n    return .50 + .45*cos(13.+PI2*t*(c*d)); \n}\n//materials\nvec3 getColor(vec3 p, float m)\n{\n    vec3 h = vec3(.9);\n        \n    if(m==1.)\n    {   //ground patterns\n        float s = sc.x*.5;\n        vec3 f  = fract(hitPoint*s)-.5;\n\n        float chk = (f.x*f.z);\n        float cir = length(f.xz)-.354;\n        cir=abs(abs(cir)-.03)-.005;\n        cir=smoothstep(.011,.01,cir);\n        \n        float cix = length(abs(f.xz)-vec2(.5))- .15;\n        if(chk>0.) cix=abs(cix)-.025;\n        cix=abs(cix)-.005;\n        cix=smoothstep(.011,.01,cix);\n\n        h = chk>0. ? vec3(cix) : vec3(1.-cir); \n    }\n    if(m==2.) h =vec3(.6,0,0);\n    if(m==3.) h =vec3(.05);\n    if(m==4.) h =vec3(.8,.8,.9);\n    if(m==5.) h = hue(hash21(vec2(objId,iDate.z)));\n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = T*.3;\n    moveTime = time*.75;\n    r90 = rot(90. *PI/180.);\n    r180= rot(180.*PI/180.);\n    //set base vars\n    vec3 C =vec3(0);\n    vec3 FC = vec3(.1);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    //cheap camera rig\n    vec3 ro = vec3(0,0,3.55);\n    vec3 rd = normalize(vec3(uv,-1));\n    //to pan and turn\n    getMouse(ro);\n    getMouse(rd);\n    \n    // ray marcher\n    vec2 ray = marcher(ro,rd,192,1.);\n    float d = ray.x;\n    float m = ray.y;\n    vec3 h;\n    // save hitpoint  \n    hitPoint=hit;\n    objId=hitId;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro+rd*d;\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(5,5,-6);\n        // shade\n        float shininess = 15.0;\n        vec3 phng =  phong(vec3(0.3), vec3(1.0), shininess, p, ro,lpos, n) * 2.;\n       \n        // coloring\n        h = getColor(hitPoint,m);\n        C += phng * h;\n    } else {\n        C = FC;\n    }\n\n    // standard fog based on distance\n    float glowMask = clamp(glow,.0,1.);\n    C = mix( C, vec3(.85,.27,.37)*(glow*.6)+C,glowMask); \n    C = mix( C, FC, 1.-exp(-.00095*d*d*d)); \n\n    O = vec4(C,1.0);\n}\n\n\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslXWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 155, 155, 690]], "test": "untested"}
{"id": "NssSWB", "name": "isolines radial gradient 2 col", "author": "FabriceNeyret2", "description": "SPACE to toggle turbulence vs bozo noise.\nBy popular demand, the color version of [url]https://shadertoy.com/view/NdsXRs[/url]\nwidth compensing scarity variant of [url]https://shadertoy.com/view/fdXXRX[/url]\n(  variants of balanced isolines )", "tags": ["procedural", "noise", "perlin"], "likes": 22, "viewed": 514, "published": 3, "date": "1619167086", "time_retrieved": "2024-07-30T19:24:03.199621", "image_code": "// color variant of https://shadertoy.com/view/NdsXRs\n// width compensing scarity variant of https://shadertoy.com/view/fdXXRX\n// variant of https://shadertoy.com/view/fdXXR2\n// gradient + 1pix-width lines + flownoise variant of https://shadertoy.com/view/NdXXRj\n// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. ) \\\n                    *  mat2(cos(iTime+vec4(0,11,33,0)))\n  #define draw(v,d,w)  clamp(1. - abs( fract(v-.5) - .5 ) / (d) + w, 0.,1.) // correct version\n//#define draw(v,d,w)  clamp(1. - abs( fract(v   ) - .5 ) / (d) + w, 0.,1.) // nicer here :-)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n//#define func( P )  ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n  #define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O = vec4(0);\n\tfloat l, dl, f = func(P),\n // df = fwidth(f);\n    df = length( ( vec2( func(P + eps.xy), func(P + eps.yx) ) -f ) / eps.x )*fwidth(P.x);\n#if 0\n    l = exp2(floor(log2(2.*fwidth(P.x)/df)));              // subvid amount (relative)\n    dl =     fract(log2(2.*fwidth(P.x)/df));      \n#else\n    l = exp2(floor(log2(1./22./df)));                      // subvid amount (absolute)\n    dl =     fract(log2(1./22./df));\n#endif\n\n    U -= .5*R/R.y;\n    float w = .5*( 1.1+sin( 4.*(dot(U,U)-.5*iTime)) );\n    f *= w;\n // f *= exp(- 4.* dot(U,U));\n // f *= max(.1, 1.-4.*dot(U,U));\n#if 0                                                      // draw isolines using sin\n    O = vec4(.5+.5*  mix( sin(50.*l*f) , sin(100.*l*f), dl ) ) * hue(6.*l); \n#else                                                      // draw isolines \n    df *= w;\n    l *= 8.; \n# if 0                                                     // BW\n    O += mix( draw(    f*l,    l*df , .5/w ),\n              draw( 2.*f*l, 2.*l*df , .5/w ),\n              dl ); // * hue(6.*l);\n# else                                                     // color\n    O  = mix( draw(    f*l,    l*df , .5/w ) * hue(   f*l*.1),\n              draw( 2.*f*l, 2.*l*df , .5/w ) * hue(2.*f*l*.1),\n              dl ); \n# endif\n#endif\n    \n    O = sqrt(O);                                           // to sRGB\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssSWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1016, 1016, 1039, 1039, 1332], [1334, 1334, 1358, 1413, 1572], [1574, 1574, 1612, 1612, 3076]], "test": "untested"}
{"id": "NdlXDB", "name": "GLSL bug: a-a != 0", "author": "FabriceNeyret2", "description": "even more simplified version of [url]https://shadertoy.com/view/NdlSDB[/url]", "tags": ["glsl", "precision", "bug"], "likes": 3, "viewed": 316, "published": 3, "date": "1619166562", "time_retrieved": "2024-07-30T19:24:03.964575", "image_code": "// even more simplified version of https://shadertoy.com/view/NdlSDB\n// acid test simplification of https://shadertoy.com/view/WlyBR3\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5 + iResolution.xy/2.;\n    U *= .01;\n    \n    O = vec4( abs( U.x*U.y  - U.x*U.y ) < 1e-10 );  \n // O = vec4(      U.x*U.y == U.x*U.y );             // differs from above\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlXDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 173, 173, 355]], "test": "untested"}
{"id": "fssSDB", "name": "a journey in precision error", "author": "FabriceNeyret2", "description": "- precision error making difference between 2 equivalent formula :-)\n- try uncomment line 17:  error in ab-ab is way more disturbing :-D", "tags": ["glsl", "precision", "bug"], "likes": 12, "viewed": 330, "published": 3, "date": "1619165415", "time_retrieved": "2024-07-30T19:24:04.749476", "image_code": "// inspired from https://shadertoy.com/view/NdlSDB\n// acid test simplification of https://shadertoy.com/view/WlyBR3\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5 + iResolution.xy/2.;\n    \n    float t = mod(iTime,10.);\n                                             // just alternates zoom and  translate in random dir \n    if ( t < 5. ) U += floor(30.*t) * sign( cos( 6.28*fract(1e4*sin(1e3*floor(iTime/10.))) +vec2(0,11) ));\n       else       U *= exp(-.1*floor(30.*(t-5.)));\n    \n    U *= .01;\n    float a = U.x , b = U.y;   \n     \n    O = vec4( abs( (1.+a)*(1.+b)-(1.+a+b) - a*b ) < 1e-10 );  // (1.+a)*(1.+b)-(1.+a+b) = a*b, with precision error\n // O = vec4( abs( a*b - a*b ) < 1e-10 );    // this one is way more disturbing \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 155, 155, 736]], "test": "untested"}
{"id": "NdlSDB", "name": "GLSL bug: side effects (fab)", "author": "FabriceNeyret2", "description": "The error between 2 math equivalent expression is normal, with different precision error.\nBut:\n- if you switch p1 definition so that p1 = p2 ; there is still a difference !\n- if you uncoment the last line, the green channel influence the red channel !", "tags": ["glsl", "bug"], "likes": 5, "viewed": 403, "published": 3, "date": "1619163403", "time_retrieved": "2024-07-30T19:24:05.526399", "image_code": "// acid test simplification of \"GLSL bug: side effects\" by ttg. https://shadertoy.com/view/WlyBR3\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;     // just to get the exact same pattern than https://www.shadertoy.com/view/WlyBR3\n    U *= .01;\n    float a = U.x , b = U.y,    \n          p1 = (1.+a)*(1.+b)-(1.+a+b), // is equivalent to a*b, but order introduce small differences\n       // p1 = a*b,                    //  try this one: should exactly = p2, but no !\n          p2 = a*b;\n     \n    O = vec4(0);\n    O.r = float( abs(p1-p2) < 1e-10 ); // expected precision error: black when p1 and p2 differs, otherwise red. \n    \n // O.r = float( abs( a*b - a*b ) < 1e-10 ); //  but this one should always be true... and is not !\n // O.r = float( a*b == a*b  );              //  plus it is inconsistant with this\n    \n // O.g = -p2;                        //  uncommenting this changes the red channel ! ( with 1st def of O.r )\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 138, 138, 946]], "test": "untested"}
{"id": "NdsSDS", "name": "Mirrored Dupin Cyclides", "author": "cyperus", "description": "Dupin Cyclides quartic surface raytraced with reflections.\nbased on\nmla@[url]https://www.shadertoy.com/view/3tVcWV[/url]\nFabriceNeyret2@[url]https://www.shadertoy.com/view/4ljyWc[/url]", "tags": ["reflection", "torus", "sphere", "raytrace", "cubic", "quartic", "lanczos"], "likes": 11, "viewed": 584, "published": 3, "date": "1619151693", "time_retrieved": "2024-07-30T19:24:06.472868", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"Mirrored Dupin Cyclides\" created by Colling Patrik (cyperus) in 2020\n//\n// based on original code \n// - mla --- Goursat Quartic Surface --- https://www.shadertoy.com/view/wsXGWS\n// - FabriceNeyret2 --- compared interpolation --- https://www.shadertoy.com/view/4ljyWc\n//\n// documentation:\n// - https://mathcurve.com/surfaces.gb/cycliddedupin/cyclidededupin.shtml\n// - https://en.wikipedia.org/wiki/Dupin_cyclide \n//\n// Controls:\n// <mouse>: change view direction\n// <up/down>: zoom\n// 'c': clip at x = 0\n// 'g': show grid\n// 'r': do rotation\n// 'm': mirror surface\n// 's': no reflections\n// 'p': plain colouring\n// 'e': toggle between elliptic-hyperbolic and parabolic cyclide.\n//\n// Quartic surfaces with rotational symmetry. Surface (including normals)\n// is raytraced using analytic solution to quartic due to Lanczos with\n// cubic solver from Numerical Recipes, plus some Newton-Raphson polishing.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 1;\n\n// Lighting\nvec3 light;\nfloat ambient;\nfloat diffuse;\nfloat specular = 0.4;\nfloat specularpow = 4.0;\nvec3 specularcolor = vec3(1);\n\n// Animation\nfloat animvelocity = 0.25;    \n//#define NEAREST\n//#define LINEAR\n#define CUBICLINEAR\n//#define CATMULL    \n\nfloat evalquadratic(float x, float A, float B, float C) {\n  return (A*x+B)*x+C;\n}\n\nfloat evalcubic(float x, float A, float B, float C, float D) {\n  return ((A*x+B)*x+C)*x+D;\n}\n\n// Quadratic solver from Kahan\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic(float a, float b, float c, float d, out vec3 res) {\n  if (a == 0.0) {\n    return quadratic(b,c,d,res.xy);\n  }\n  if (d == 0.0) {\n    res.x = 0.0;\n    return 1+quadratic(a,b,c,res.yz);\n  }\n  float tmp = a; a = b/tmp; b = c/tmp; c = d/tmp;  // TODO: if(very large roots) {solve for the reciprocal roots}\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    res[0] = -2.0*S*cos(theta/3.0)-a/3.0;\n    res[1] = -2.0*S*cos((theta+2.0*PI)/3.0)-a/3.0;\n    res[2] = -2.0*S*cos((theta+4.0*PI)/3.0)-a/3.0;\n    return 3;\n  } else {\n    float alpha = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),0.3333);\n    float beta = alpha == 0.0 ? 0.0 : Q/alpha;\n    res[0] = alpha + beta - a/3.0;\n    return 1;\n  }\n}\n\nfloat qcubic(float B, float C, float D) {\n  vec3 roots;\n  int nroots = cubic(1.0,B,C,D,roots);\n  // Sort into descending order\n  if (nroots > 1 && roots.x < roots.y) roots.xy = roots.yx;\n  if (nroots > 2) {\n    if (roots.y < roots.z) roots.yz = roots.zy;\n    if (roots.x < roots.y) roots.xy = roots.yx;\n  }\n  // And select the largest\n  float psi = roots[0];\n  // There _should_ be a positive root, but sometimes the cubic\n  // solver doesn't find it directly (probably a double root\n  // around zero).\n  if (psi < 0.0) assert(evalcubic(psi,1.0,B,C,D) < 0.0);\n  // If so, nudge in the right direction\n  psi = max(1e-6,psi);\n  // and give a quick polish with Newton-Raphson\n  for (int i = 0; i < 3; i++) {\n    float delta = evalcubic(psi,1.0,B,C,D)/evalquadratic(psi,3.0,2.0*B,C);\n    psi -= delta;\n  }\n  return psi;\n}\n\n// The Lanczos quartic method\nint lquartic(float c1, float c2, float c3, float c4, out vec4 res) {\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int resn = quadratic(1.0,alpha+a,beta+b,res.xy);\n  vec2 tmp;\n  if (quadratic(1.0,alpha-a,beta-b,tmp) != 0) { \n    res.zw = res.xy;\n    res.xy = tmp;\n    resn += 2;\n  }\n  return resn;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Solve for the smallest cubic term, this seems to give the least wild behaviour.\n  if (abs(B/A) < abs(D/E)) {\n    nroots = lquartic(B/A,C/A,D/A,E/A,roots);\n  } else {\n    nroots = lquartic(D/E,C/E,B/E,A/E,roots);\n    for (int i = 0; i < nroots; i++) {\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  assert(nroots == 0 || nroots == 2 || nroots == 4);\n  return nroots;\n}\n\nstruct Surface {\n  vec4 params;\n  vec3 p;\n};\n\n\n// https://en.wikipedia.org/wiki/Dupin_cyclide\n// https://mathcurve.com/surfaces.gb/cycliddedupin/cyclidededupin.shtml\n\nint elhypcyc_surface(Surface surface, in vec3 o, in vec3 d, out vec4 roots) {\n    // F : ( x^2+y^2+z^2 +b0^2-r0^2 )^2 -4*(( a0*x-c0*r0 )^2 + b^2*y^2) = 0\n    \n    // float not used = surface.params[0];\n    float a0 = surface.params[1];\n\tfloat c0 = surface.params[2];     \n\tfloat r0 = surface.params[3];\n    \n    // parameter constraints\n    a0 = abs(a0); // semi major axis of the ellipse\n    c0 = abs(c0); // linear eccentricity of the ellipse\n    r0 = abs(r0); // radius tangent spheres at (0,-+b) of the ellipse\n    if (c0 > a0) c0 = a0;\n    float b0 = sqrt(a0*a0-c0*c0); // semi minor axis of the ellipse    \n    \n    // commun factors\n    float od = dot(d,o);\n    float dd = dot(d,d); // dd = 1; unitvector\n    float e0 = dot(o,o) + b0*b0-r0*r0;\n    float f0 = a0*o.x-c0*r0;\n    float b02 = b0*b0;\n        \n    // A * t^4 + B * t^3 + C * t^2 + D * t^1 + E = 0\n    float A =    dd*dd;\n    float B = 4.*dd*od;\n    float C = 2.*(2.*od*od+dd*e0) -4.*( a0*a0*d.x*d.x       +b02*d.y*d.y );\n    float D = 4.*od          *e0  -8.*( a0   *d.x    *f0    +b02*d.y    *o.y );\n    float E =              e0*e0  -4.*(               f0*f0 +b02        *o.y*o.y );  \n    return quartic(A,B,C,D,E,roots);\n}\n\nvec3 elhypcyc_normal(Surface surface, vec3 p) {\n    // float not used = surface.params[0];\n    float a0 = surface.params[1];\n\tfloat c0 = surface.params[2];     \n\tfloat r0 = surface.params[3];\n    \n    // parameter constraints\n    a0 = abs(a0); // semi major axis of the ellipse\n    c0 = abs(c0); // linear eccentricity of the ellipse\n    r0 = abs(r0); // radius tangent spheres at (0,-+b) of the ellipse\n    if (c0 > a0) c0 = a0;\n    float b0 = sqrt(a0*a0-c0*c0); // semi minor axis of the ellipse   \n    \n    // grad(F)\n    float e0 = dot(p,p)+b0*b0-r0*r0;           \n    return 4.*(e0*p -2.*vec3(a0*(a0*p.x-c0*r0), b0*b0*p.y, 0.));\n}\n\nint elhypcyc_nanimparams = 12;\nvec4 elhypcyc_animparams(int i) {\n  // cyclide vec4(not used,a0,c0,r0)\n  if (i == 0) return vec4(0., 1.0, 0.0, 0.3); // torus \n  if (i == 1) return vec4(0., 1.0, 0.0, 0.3);\n  if (i == 2) return vec4(0., 1.0, 1.0, 0.0); // symmetric spheres \n  if (i == 3) return vec4(0., 1.0, 1.0, 0.0);    \n  if (i == 4) return vec4(0., 1.0, 0.3, 0.0); // symmetric horns \n  if (i == 5) return vec4(0., 1.0, 0.3, 0.0);\n  if (i == 6) return vec4(0., 1.0, 0.3, 0.3); // horn-ring \n  if (i == 7) return vec4(0., 1.0, 0.3, 0.3);\n  if (i == 8) return vec4(0., 1.0, 0.3, 1.0); // ring-spindel \n  if (i == 9) return vec4(0., 1.0, 0.3, 1.0);\n  if (i == 10)return vec4(0., 1.0, 0.0, 1.5); // torus-spindle\n  else        return vec4(0., 1.0, 0.0, 1.5);\n  \n}\n\n// https://en.wikipedia.org/wiki/Dupin_cyclide\n// https://mathcurve.com/surfaces.gb/cycliddedupin/cyclidededupin.shtml\nint paracyc_surface(Surface surface, in vec3 o, in vec3 d, out vec4 roots) {    \n    // F : (x+0.5*k0-1) * (x^2+y^2+z^2 -0.25*k0^2*p0^2) + p0*z^2 = 0\n    \n    // float not used = surface.params[0];\n    // float not used = surface.params[1];\n\tfloat p0 = surface.params[2]; // relation of the diameters of the two holes   \n\tfloat k0 = surface.params[3]; // shape of parabolas  \n    \n    // commun factors\n    k0 *= 0.5;\n    float d0 = -k0*k0*p0*p0;\n    float c0 = p0*(k0-1.);\n    float dd = dot(d,d); // dd = 1; unitvector\n    float od = dot(o,d);\n    float a0 = dot(o,o)+d0;\n    float b0 = o.x+c0;\n        \n    // A * t^3 + B * t^2 + C * t^1 + D = 0\n    float A = d.x   *dd;\n    float B = d.x*2.*od + b0   *dd + p0   *d.z*d.z;\n    float C = d.x   *a0 + b0*2.*od + p0*2.*o.z*d.z;\n    float D =           + b0   *a0 + p0   *o.z*o.z;\n    vec3 res; int resn = cubic(A, B, C, D, res);\n    roots = vec4(res,0.); return resn;\n}\n\nvec3 paracyc_normal(Surface surface, vec3 p) {\n    // float not used = surface.params[0];\n    // float not used = surface.params[1];\n\tfloat p0 = surface.params[2]; // relation of the diameters of the two holes   \n\tfloat k0 = surface.params[3]; // shape of parabolas \n    \n    // commun factors\n    k0 *= 0.5;\n    float pp = dot(p,p);\n    float d0 = -k0*k0*p0*p0;\n    float c0 = p0*(k0-1.);\n    //float f0 = p.x*(p.x+c0);\n    float f0 = p.x+c0; // TEST:\n    \n    // grad(F)           \n    return vec3(pp+d0+2.*p.x*f0, 2.*p.y*f0, 2.*p.z*(f0+p0));\n}\n\nint paracyc_nanimparams = 10;\nvec4 paracyc_animparams(int i) {\n  // vec4(not used,not used,p0,k0)\n  if (i == 0)  return vec4(0., 0., 1.0,-1.0); // ring equal diameters\n  if (i == 1)  return vec4(0., 0., 1.0,-1.0); \n  if (i == 2)  return vec4(0., 0., 1.0, 0.0); // ring equal diameters\n  if (i == 3)  return vec4(0., 0., 1.0, 0.0);  \n  if (i == 4)  return vec4(0., 0., 1.0, 0.5); // ring equal diameters\n  if (i == 5)  return vec4(0., 0., 1.0, 0.5); \n  if (i == 6)  return vec4(0., 0., 1.0, 1.0); // ring-horn \n  if (i == 7)  return vec4(0., 0., 1.0, 1.0);\n  if (i == 8)  return vec4(0., 0., 1.0, 2.0); // horn\n  else         return vec4(0., 0., 1.0, 2.0);\n  }\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nstruct Result {\n  vec3 p;\n  vec3 n;\n  vec3 color;\n  float t;\n};\n\nfloat gridline(vec3 p) {\n  // Draw some gridlines on surface\n  vec3 t = fract(p*4.0);\n  t = min(t,1.0-t);\n  float d = min(t.x,min(t.y,t.z));\n  return smoothstep(0.02,0.025,d);\n}\n\nint dosurface(Surface surface, vec3 p0, vec3 r, out vec4 roots) {\n  if (!key(CHAR_E))\n    return elhypcyc_surface(surface, p0, r, roots);\n  else\n    return paracyc_surface(surface, p0, r, roots);  \n\n}\n  \nvec3 donormal(Surface surface, vec3 p0) {\n  if (!key(CHAR_E))\n      return elhypcyc_normal(surface, p0);\n  else\n      return paracyc_normal(surface, p0);  \n}\n\nvec4 animparams(int i ) {\n  if (!key(CHAR_E))\n      return elhypcyc_animparams(i);\n  else\n      return paracyc_animparams(i);  \n}\n\nbool solve(Surface surface, vec3 p0, vec3 r, float tmin, inout Result result) {\n  vec4 roots;\n  int nroots = dosurface(surface,p0,r,roots);\n  // Find smallest root greater than tmin.\n  float t = result.t;\n  for (int i = 0; i < 4; i++) {\n    if (i == nroots) break;\n    if (roots[i] > tmin && roots[i] < t) {\n      vec3 p = p0+roots[i]*r;\n      if (!key(CHAR_C) || p.x > 0.0) { // clip at x == 0\n        t = roots[i];\n      }\n    }\n  }\n  if (t == result.t) return false;\n  vec3 p = p0 + t*r;\n  vec3 n = donormal(surface, p);\n  if (dot(n,r) > 0.0) n = -n;\n  n = normalize(n);\n  vec3 basecolor = abs(n);\n  basecolor *= gridline(p);\n  if (key(CHAR_P)) basecolor = vec3(0.8);\n  result.p = p; result.n = n; result.color = applylighting(basecolor,p,n,r);\n  return true;\n}\n\nSurface surface;\n\nvec3 scene(vec3 p, vec3 r) {\n  vec3 color = vec3(0);\n  float att = 1.0;\n  for (int i = 0; i < 6; i++) {\n    // If we've hit the surface some distance from origin,\n    // stop reflecting.\n    if (dot(p,p) > 1000.0) break;\n    // Solve from closest point to origin.\n    // This makes p.r = 0.\n    float tmin = -dot(p,r);\n    p += tmin*r;\n    Result res = Result(vec3(0),vec3(0),vec3(0),1e8);\n    if (!solve(surface,p,r,-tmin,res)) break;\n    if (key(CHAR_P) || key(CHAR_S)) return res.color;\n    color += att*res.color;\n    att *= 0.5;\n    p = res.p;\n    r = reflect(r,res.n);\n    p += 0.001*r;\n  }\n  if (key(CHAR_P)) return vec3(0.5);\n  if (key(CHAR_M)) return texture(iChannel1,r).xyz;  \n  return color + att*pow(abs(r),vec3(2));\n}\n\n\nint imod(int n, int m) {\n    return n-n/m*m;\n}\n\n// by FabriceNeyret2 --- compared interpolation --- https://www.shadertoy.com/view/4ljyWc\nvec4 nearest(vec4 v1) {\n    return v1;\n    }\n\nvec4 linear(vec4 v1, vec4 v2, float t) {\n    return mix(v1,v2,t);\n    }\n\nvec4 cubiclinear(vec4 v1, vec4 v2, float t) {\n    return mix(v1,v2,smoothstep(0.,1.,t));\n    }\n\nvec4 catmull(vec4 v0, vec4 v1, vec4 v2, vec4 v3, float t) {\n\tvec4 A0 = mix( v0, v1, t+1.),\n\t     A1 = mix( v1, v2, t),\n\t     A2 = mix( v2, v3, t-1.),\n         B0 = mix( A0, A1, .5*t + .5),\n\t     B1 = mix( A1, A2, .5*t);\n\treturn mix( B0, B1, t);\n    }\n\nvoid init() {\n  float ttime = animvelocity*iTime;\n  float rtime = floor(ttime);\n  ttime -= rtime;\n  \n  int nanimparams;\n  if (!key(CHAR_E)) {\n    nanimparams = elhypcyc_nanimparams; }\n  else{\n    nanimparams = paracyc_nanimparams; }\n  \n  vec4 params;\n  int isurface = max(0,keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  isurface %= nanimparams;+1;\n  if (isurface == 0) {\n    // get parameter id for interpolation\n    ivec4 param_id = ivec4(\n        int(rtime-1.0)%nanimparams,\n        int(rtime)%nanimparams,\n        int(rtime+1.0)%nanimparams,\n        int(rtime+2.0)%nanimparams);\n    // get parameter values with selected interpolation\n    #ifdef NEAREST\n    params = nearest(animparams(param_id[2]));\n    #endif\n    #ifdef LINEAR    \n    params = linear(animparams(param_id[1]),\n                    animparams(param_id[2]), ttime);\n    #endif\n    #ifdef CUBICLINEAR \n    params = cubiclinear(animparams(param_id[1]),\n                         animparams(param_id[2]), ttime);\n    #endif\n    #ifdef CATMULL \n    params = catmull(animparams(param_id[0]),\n                     animparams(param_id[1]),\n                     animparams(param_id[2]),\n                     animparams(param_id[3]), ttime);\n    #endif\n  } else {\n    params = animparams(isurface-1);\n  }\n  surface = Surface(params,vec3(0));\n}\n\n// GUI related code starts here\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = iTime + 3.5;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = vec3(1,1,-1);\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n  specular = 0.8;\n  specularpow = 10.0;\n\n  float scale = 1.0;\n  float camera = 4.0;\n  \n  vec3 p = vec3(0.0, 0.0, -camera);\n  p *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  init();\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n     for (int j = 0; j < AA; j++) {\n       vec2 uv = scale*(2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n       vec3 r = normalize(vec3(uv, 2.0));\n       r = transform(r);\n       r = normalize(r);\n       color += scene(p,r);\n     }\n  }\n  color /= float(AA*AA);\n  color = pow(color,vec3(0.4545));\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n// Common\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n// Debug\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\n#define assert(x)\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}", "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSDS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1434, 1434, 1491, 1491, 1515], [1517, 1517, 1579, 1579, 1609], [1611, 1642, 1698, 1698, 1930], [1932, 1990, 2051, 2051, 2922], [2924, 2924, 2965, 2965, 3741], [3743, 3773, 3841, 3841, 4355], [4357, 4357, 4431, 4431, 4814], [4983, 4983, 5060, 5184, 6176], [6178, 6178, 6225, 6268, 6813], [6846, 6846, 6879, 6916, 7577], [7579, 7698, 7774, 7938, 8617], [8619, 8619, 8665, 8751, 9165], [9197, 9197, 9229, 9264, 9826], [9828, 9828, 9888, 9888, 10125], [10192, 10192, 10216, 10252, 10369], [10371, 10371, 10436, 10436, 10571], [10575, 10575, 10616, 10616, 10732], [10734, 10734, 10759, 10759, 10863], [10865, 10865, 10944, 10944, 11629], [11649, 11649, 11677, 11677, 12380], [12383, 12383, 12407, 12407, 12429], [12431, 12521, 12544, 12544, 12565], [12567, 12567, 12607, 12607, 12638], [12640, 12640, 12685, 12685, 12734], [12736, 12736, 12795, 12795, 12986], [12988, 12988, 13001, 13001, 14287], [14289, 14321, 14348, 14348, 14698], [14700, 14700, 14757, 14757, 15529]], "test": "untested"}
{"id": "fslXWS", "name": "Look, Professor. A clown!", "author": "Molive", "description": "close enough\n\nI have all three channels, but I can only show one at once or WebGL crashes.", "tags": ["nn", "clown", "neuralnetwork", "siren", "sirennetwork"], "likes": 15, "viewed": 455, "published": 3, "date": "1619145381", "time_retrieved": "2024-07-30T19:24:07.603846", "image_code": "// Fork of \"sad cat\" by blackle. https://shadertoy.com/view/wl3yWX\n// 2021-04-23 02:27:12\n\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\n//based on the work of https://vsitzmann.github.io/siren/\n//https://colab.research.google.com/drive/11ANM7k_r0i1Ut9amzKN1_GQqwzp0pB-_?usp=sharing\n//https://imgur.com/a/wBxR7An\n//#define SHOW_SCARY_OUT_OF_BOUNDS\n\n#define FK(x) floatBitsToInt(x*x/7.)^floatBitsToInt(x)\nfloat hash(float a, float b) {\n    int x = FK(a),y=FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y*2.1;\n\nvec4 g0_0=sin(uv.x*vec4(9.3,-6.84,3.32,-2.77)+uv.y*vec4(8.78,-8.57,5.43,4.24)+vec4(-8.12,12.3,3.04,-4.94));\n    vec4 g0_1=sin(uv.x*vec4(-.362,-4.96,2.62,7.21)+uv.y*vec4(5.12,3.01,6.11,.374)+vec4(8.22,-9.66,10.2,6.41));\n    vec4 g0_2=sin(uv.x*vec4(-1.27,-.225,-1.07,-2.72)+uv.y*vec4(-5.85,-7.95,-3.61,4.29)+vec4(-11.7,-13.8,-4.48,13));\n    vec4 g0_3=sin(uv.x*vec4(-9.03,5.02,6.87,-3.84)+uv.y*vec4(-6.22,9.32,-3.75,2.57)+vec4(-10.7,-10.5,10.6,-10.3));\n    vec4 g0_4=sin(uv.x*vec4(-4.67,-2.31,-4.92,2.3)+uv.y*vec4(8.4,5.73,9.03,.159)+vec4(11.7,10.4,-8.88,-1.22));\n    vec4 g0_5=sin(uv.x*vec4(-2.73,.884,.778,-7.08)+uv.y*vec4(-2.81,8.72,5.44,3.55)+vec4(-13.7,-9.11,10.5,.538));\n    vec4 g1_0=sin(mat4(.159,-.0386,-.276,.367,-.272,.284,.329,-.0786,-.555,-.326,-.514,.11,.0818,-.0416,.118,-.00398)*g0_0+\n    mat4(.48,.631,-.355,-.0683,-.127,.504,.137,-.206,.268,-.113,-.131,.264,.385,-.00897,-.266,-.278)*g0_1+\n    mat4(-.294,.334,-.124,.0271,.659,-.0965,-.21,-.498,-.229,.0668,.0179,.304,.153,-.425,.063,.182)*g0_2+\n    mat4(.375,.222,.0641,-.272,.354,-.0408,.449,.289,-.247,.086,.124,-.494,.375,-.104,.328,-.458)*g0_3+\n    mat4(-.393,.229,-.666,-.474,.44,-.12,.415,-.588,-.605,-.432,.489,.00541,-.46,-.102,.172,-.138)*g0_4+\n    mat4(-.127,-.245,.55,-.137,-.382,-.217,-.148,-.223,.103,-.393,.141,-.529,.477,-.285,.177,.116)*g0_5+\n    vec4(-3.2,.0426,-3.57,3.5));\n    vec4 g1_1=sin(mat4(.0981,.00392,-.224,-.45,-.0107,.0917,-.187,.242,-.127,.377,-.0223,-.338,.146,-.0427,-.303,.152)*g0_0+\n    mat4(-.216,-.464,-.639,-.219,-.483,.766,.196,.307,.402,-.424,-.354,.125,.217,-.103,-.0176,.106)*g0_1+\n    mat4(.569,.158,-.132,-.393,-.292,.461,-.714,-.104,.128,.559,.0112,.236,.223,-.101,-.383,-.325)*g0_2+\n    mat4(.142,-.281,.353,.255,.21,-.00777,-.232,-.406,.574,-.442,.151,-.299,-.356,-.0195,-.413,.0136)*g0_3+\n    mat4(-.135,-.274,-.229,-.499,.556,-.129,.299,.457,.35,.166,-.0682,.259,.419,.203,-.0769,-.215)*g0_4+\n    mat4(.718,-.475,-.168,-.156,-.0529,.501,.129,-.244,-.199,-.493,-.314,.414,.254,.239,.35,.255)*g0_5+\n    vec4(3.33,-1.23,-.475,.636));\n    vec4 g1_2=sin(mat4(.572,.226,-.219,.182,-.594,.215,-.0657,.0799,-.00671,.255,-.334,.126,-.28,-.394,-.178,-.352)*g0_0+\n    mat4(-.0465,.44,.331,.389,.154,.256,.172,-.423,.236,.244,.00431,.0727,-.319,-.254,-.0497,.167)*g0_1+\n    mat4(.272,-.327,-.11,-.147,.467,.184,.0085,-.35,-.0334,.223,-.229,-.165,.551,-.428,-.498,.34)*g0_2+\n    mat4(.408,.18,.459,-.406,-.367,-.572,.562,-.25,.418,.748,.631,.175,-.418,-.372,.337,.333)*g0_3+\n    mat4(.183,.129,-.318,-.145,-.12,.12,.186,-.191,-.275,.407,-.137,.508,.0299,-.066,-.309,.217)*g0_4+\n    mat4(-.474,.234,.16,.399,.293,-.78,-.123,.144,.301,-.29,.255,-.336,-.415,-.183,.531,.0364)*g0_5+\n    vec4(-.314,-3.46,.676,.803));\n    vec4 g1_3=sin(mat4(-.133,.453,-.681,-.181,.0116,-.539,.244,.0984,-.189,.0781,-.431,-.482,-.679,.1,.249,.251)*g0_0+\n    mat4(-.503,.0693,-.116,.152,-.378,-.556,-.0983,-.251,.392,.367,-.33,-.506,.0558,-.212,.0731,-.0661)*g0_1+\n    mat4(.271,.5,-.389,-.273,-.145,.269,-.37,.669,-.448,.407,.121,-.264,-.0874,-.303,.301,.117)*g0_2+\n    mat4(.295,.216,.249,-.218,-.197,-.126,.378,-.329,.0639,.481,.179,.482,-.364,-.597,.0164,.567)*g0_3+\n    mat4(-.288,-.414,-.387,.0641,.578,.542,-.354,.504,-.366,-.306,.00526,-.183,.23,-.422,.406,-.253)*g0_4+\n    mat4(.78,.409,.188,.397,-.656,.391,.218,.386,.195,-.33,-.205,.0957,.53,-.215,-.326,.0629)*g0_5+\n    vec4(-2.89,-.698,-1.93,-3.33));\n    vec4 g1_4=sin(mat4(-.49,.034,.295,.349,.396,.282,-.0507,-.134,.408,.12,-.157,.106,.172,.295,-.357,-.0362)*g0_0+\n    mat4(-.0859,.249,-.771,-.129,-.17,.0681,-.0826,-.0143,.357,.538,-.662,-.687,-.242,.57,-.279,.489)*g0_1+\n    mat4(-.0113,-.399,-.262,.211,-.353,-.117,.0576,-.0983,-.15,-.281,.243,-.544,-.124,-.176,-.377,-.335)*g0_2+\n    mat4(-.0638,.218,.0249,.493,.0252,.502,-.244,.433,-.0644,.298,.458,.237,-.162,-.456,.0633,-.354)*g0_3+\n    mat4(-.119,.271,.209,-.326,.156,-.485,-.155,.468,.526,.245,-.167,.202,-.5,.328,-.249,-.106)*g0_4+\n    mat4(.0855,.359,-.652,.506,.267,-.0956,-.109,-.00391,-.423,.0419,-.34,-.135,.568,.183,.224,-.0867)*g0_5+\n    vec4(3.59,2.4,-3.45,-.949));\n    vec4 g1_5=sin(mat4(-.533,.428,.36,-.512,.015,.445,.819,.0859,.321,.626,-.291,-.659,-.355,-.294,-.507,-.481)*g0_0+\n    mat4(.363,.164,-.166,.49,.0155,.111,-.108,-.259,-.107,-.12,.029,-.461,.449,.351,.46,.0188)*g0_1+\n    mat4(-.295,.574,.111,.397,-.563,-.0473,.269,.0546,.508,.342,-.423,-.101,-.244,-.318,-.12,.126)*g0_2+\n    mat4(.667,.0567,-.238,.162,-.0355,.313,-.329,.575,-.524,.366,.399,-.609,.331,.4,-.559,.297)*g0_3+\n    mat4(-.0158,-.0821,.0706,-.0832,-.0453,.382,.0409,-.274,.394,.297,-.351,.19,-.251,-.245,.0275,.477)*g0_4+\n    mat4(-.443,-.54,.719,-.589,.177,-.318,-.587,-.533,.286,.155,-.292,-.194,.797,-.442,-.644,-.317)*g0_5+\n    vec4(-1.19,-1.02,-.864,-.463));\n    vec4 g2_0=sin(mat4(-.324,.221,.0288,.00133,.219,.0895,-.341,.185,-.283,-.453,.309,.476,-.367,-.0209,.368,.215)*g1_0+\n    mat4(-.321,.239,.37,.0411,-.269,.529,.614,.239,-.502,-.305,-.0326,.304,.0126,-.11,-.24,.0895)*g1_1+\n    mat4(-.332,.256,-.0848,.591,.267,.634,-.295,-.143,.17,.185,.0243,.643,.303,.502,.0802,.0923)*g1_2+\n    mat4(-.0395,.239,.462,.209,-.472,-.11,.138,-.0278,.119,.127,.218,.18,-.542,.0134,-.0123,-.347)*g1_3+\n    mat4(.339,.463,-.0603,-.0425,-.248,.333,.255,-.47,.396,.525,-.123,.266,-.15,-.128,.225,-.474)*g1_4+\n    mat4(.598,-.0725,-.384,.392,-.298,.0456,.662,-.18,.281,.244,.115,.0751,.36,.398,.306,.152)*g1_5+\n    vec4(-3.09,-.714,-.685,2.74));\n    vec4 g2_1=sin(mat4(-.0657,-.115,.391,-.603,.444,.25,-.614,.731,.379,-.354,-.638,-.327,.0285,-.0878,.0489,-.194)*g1_0+\n    mat4(.148,-.155,-.263,.123,-.0648,.0599,.406,.128,-.0839,-.265,-.243,.0698,-.513,-.0974,-.547,.492)*g1_1+\n    mat4(.442,-.0782,.308,.021,.0328,.54,.0749,.00109,-.398,-.256,-.233,-.313,-.253,-.247,-.233,.0169)*g1_2+\n    mat4(-.0154,.153,-.206,-.202,-.0699,.0461,-.104,.0185,.137,-.399,-.0314,-.168,.206,-.105,-.104,.00653)*g1_3+\n    mat4(-.385,.538,-.257,.253,-.492,-.603,.288,-.333,-.00918,-.457,-.306,.31,-.432,.238,.339,.365)*g1_4+\n    mat4(-.403,.0829,.663,.257,.00672,.109,-.404,-.429,.37,.257,-.449,.404,-.0215,-.347,-.275,.47)*g1_5+\n    vec4(3.32,-.693,1.66,.799));\n    vec4 g2_2=sin(mat4(-.413,-.378,.168,-.601,.295,.14,.0502,-.579,-.401,.541,.167,-.152,.0312,.695,.487,-.481)*g1_0+\n    mat4(-.282,.134,.12,.618,.276,-.501,-.107,.502,-.541,.00706,.0279,.0385,.437,-.118,-.141,.00963)*g1_1+\n    mat4(-.503,-.0292,.274,.741,-.679,-.0136,-.247,.435,-.257,.574,.187,.0853,.299,-.506,-.332,.163)*g1_2+\n    mat4(-.183,-.213,.341,.836,.409,-.475,-.522,.0202,-.236,-.344,.293,-.433,-.0578,.12,-.00949,.631)*g1_3+\n    mat4(-.0643,.114,.629,-.542,.114,.467,-.0537,.553,.215,.242,-.51,.293,-.359,-.37,-.223,-.601)*g1_4+\n    mat4(.235,.42,-.443,.277,.0871,.015,.587,.415,.582,-.563,-.237,-.316,-.237,-.636,.469,.0324)*g1_5+\n    vec4(.164,-1.05,-3.05,.601));\n    vec4 g2_3=sin(mat4(.127,-.827,-.342,.092,.0891,-.237,-.501,-.6,-.345,-.291,.222,-.247,-.451,.408,-.329,.334)*g1_0+\n    mat4(-.287,.34,-.269,-.278,.373,.163,.259,.725,.158,.39,-.282,.515,.533,.162,.359,-.245)*g1_1+\n    mat4(-.675,-.494,.184,-.273,.171,.245,-.332,.049,.502,.579,-.334,.123,.292,.256,-.22,-.407)*g1_2+\n    mat4(-.298,-.19,-.303,.0127,-.0312,.404,-.31,.104,.0498,.299,-.425,.668,.613,-.769,-.39,-.152)*g1_3+\n    mat4(-.297,.189,-.126,-.199,-.0607,.417,-.324,.129,-.251,-.296,-.224,-.151,-.191,.371,.314,-.19)*g1_4+\n    mat4(.0514,.587,-.234,.0563,.223,.215,.437,.27,-.378,.559,.0392,-.3,.0814,-.081,.334,.0364)*g1_5+\n    vec4(3.75,-1.31,-.709,3.46));\n    vec4 g2_4=sin(mat4(-.319,.507,-.31,.195,.0788,.431,.23,.525,.0308,-.194,.668,-.095,-.175,.251,.187,.0668)*g1_0+\n    mat4(-.277,.745,.123,.277,.473,.396,-.234,.274,-.605,.133,-.307,.156,.419,.425,-.2,-.518)*g1_1+\n    mat4(.437,.201,-.0216,-.391,.189,.431,.685,.433,-.489,.0756,-.369,.186,.0902,.291,-.0622,-.278)*g1_2+\n    mat4(.437,-.473,-.474,.392,.16,.31,-.35,-.278,-.048,-.00629,-.38,-.287,.122,-.0512,.262,-.025)*g1_3+\n    mat4(.512,-.121,.183,.0452,.0334,-.639,.0361,-.277,.41,-.622,.585,-.254,.407,-.531,-.377,-.136)*g1_4+\n    mat4(.146,-.299,-.574,-.18,.45,-.283,-.641,-.112,-.321,-.382,-.255,.0983,-.293,.37,.125,-.461)*g1_5+\n    vec4(3.74,-2.32,-3.77,3.66));\n    vec4 g2_5=sin(mat4(-.217,-.0917,-.282,-.484,-.634,.0915,-.0957,.712,.405,.429,.232,-.0998,.225,-.39,-.339,-.167)*g1_0+\n    mat4(.0801,-.154,-.383,-.0676,-.125,-.0338,-.223,.0178,.427,.403,-.307,-.334,.156,-.557,-.365,.491)*g1_1+\n    mat4(.649,.00679,.339,.29,.378,.417,.29,.306,.0721,-.141,-.506,.137,.0777,-.0625,.0641,-.413)*g1_2+\n    mat4(.428,.244,-.177,.0597,.296,.68,.398,.406,.121,-.52,.247,.653,.042,-.289,.566,-.0757)*g1_3+\n    mat4(.354,.211,.301,.239,.0856,.0836,-.114,.171,-.269,-.428,-.166,.319,-.194,.321,.151,-.552)*g1_4+\n    mat4(-.21,-.293,.055,-.226,-.23,.295,.334,.0974,.105,.278,.426,-.12,-.296,-.0371,.449,.3)*g1_5+\n    vec4(2.9,-.302,-1.79,-2));\n    vec4 g3_0=sin(mat4(-.566,.193,.168,.46,-.26,-.451,-.402,-.176,.245,-.406,.31,.45,-.386,.352,-.277,-.18)*g2_0+\n    mat4(-.369,.0639,-.0652,-.115,-.252,.142,.31,-.268,-.0591,.0704,.632,-.125,.22,-.157,.388,-.399)*g2_1+\n    mat4(.0977,.357,.358,-.335,-.302,-.378,-.546,.137,.545,.00467,.28,.147,.0443,-.114,.413,.291)*g2_2+\n    mat4(.0203,-.374,.506,-.128,.163,.25,-.0745,.224,-.141,-.537,-.589,.0669,.168,-.439,-.0964,-.0659)*g2_3+\n    mat4(-.33,.201,.0179,.344,.485,-.371,.212,-.0252,-.313,-.145,-.372,.542,.165,-.0104,.37,.476)*g2_4+\n    mat4(-.378,-.479,-.0862,-.257,.737,-.217,.158,.344,-.627,.333,.339,.149,.673,-.312,-.38,-.436)*g2_5+\n    vec4(2.06,-.638,-3.62,-2.97));\n    vec4 g3_1=sin(mat4(-.269,.54,.0384,-.464,-.298,-.521,.0159,.182,.385,.363,.254,.14,-.0866,.258,.315,.678)*g2_0+\n    mat4(.211,-.308,.581,-.255,.0235,-.171,.491,-.124,-.629,-.153,-.209,.15,.58,-.287,.458,.186)*g2_1+\n    mat4(.573,-.236,-.102,-.279,-.515,-.198,-.756,.0753,-.109,.0803,-.275,.0875,-.133,.166,-.28,.177)*g2_2+\n    mat4(-.36,-.117,-.009,-.253,-.28,.372,.19,-.323,.512,.0897,-.046,.0326,-.278,-.293,-.165,.00799)*g2_3+\n    mat4(.407,.488,-.322,.576,.616,.179,-.072,-.0875,.238,-.409,.28,-.357,.622,.0956,.104,-.405)*g2_4+\n    mat4(.138,.19,.133,-.0311,-.142,.409,-.231,.0394,.375,.577,-.294,.117,.138,.23,-.249,.172)*g2_5+\n    vec4(-3.78,.747,-.818,-3.75));\n    vec4 g3_2=sin(mat4(.225,-.327,-.0414,.0143,-.56,-.0419,-.572,.42,-.553,-.641,-.619,.113,.414,.126,.361,.35)*g2_0+\n    mat4(.453,-.235,.369,-.495,-.487,-.431,-.255,.178,-.262,.138,.152,-.421,.179,-.0269,-.409,-.474)*g2_1+\n    mat4(.389,-.284,-.126,.486,.0917,-.0411,-.049,-.313,-.145,-.516,.456,.049,.724,-.141,-.132,-.245)*g2_2+\n    mat4(-.384,.16,.415,-.438,-.259,-.378,.241,.271,-.414,-.618,-.208,-.108,.296,-.141,-.316,-.0745)*g2_3+\n    mat4(-.253,.0614,-.0959,.534,-.0523,.159,.0336,-.188,-.277,-.411,.0573,-.303,-.243,-.269,.0172,-.18)*g2_4+\n    mat4(-.266,.223,.29,.4,.153,.113,-.467,-.325,.0704,.268,-.221,-.0223,-.447,-.101,-.374,-.195)*g2_5+\n    vec4(3.65,-.848,-2.5,1.82));\n    vec4 g3_3=sin(mat4(.491,-.423,.164,-.436,-.209,-.467,.403,-.113,-.437,.513,-.271,.0957,.574,.192,-.413,.123)*g2_0+\n    mat4(-.537,.0772,.0676,-.563,-.127,-.28,-.285,-.184,-.0491,.324,.356,-.282,-.537,-.372,-.169,.158)*g2_1+\n    mat4(-.0888,.599,-.538,-.607,-.0887,-.289,.401,-.288,.38,.322,-.472,.418,-.165,-.334,.273,-.271)*g2_2+\n    mat4(-.289,-.0863,-.318,-.363,.56,.121,-.516,.121,.0445,-.0221,-.0185,-.459,-.305,-.0295,-.598,-.182)*g2_3+\n    mat4(-.463,-.643,.0986,-.217,.00544,.237,-.174,.203,.51,.139,.517,-.00314,.321,-.478,-.24,.108)*g2_4+\n    mat4(-.103,.501,-.343,.413,-.156,-.414,.0658,-.243,-.436,.603,.371,-.169,-.201,.0935,-.173,-.241)*g2_5+\n    vec4(2.69,1.13,-1.93,2.46));\n    vec4 g3_4=sin(mat4(-.0726,.107,-.256,-.621,-.352,-.147,-.59,.229,-.0561,-.393,-.275,-.294,.385,.113,.392,-.196)*g2_0+\n    mat4(-.407,-.413,.426,-.376,-.48,.0412,-.342,-.0933,.629,.00806,.409,.27,-.508,-.286,-.189,-.364)*g2_1+\n    mat4(-.0829,.345,-.00195,.297,-.746,.108,-.184,-.0562,-.572,.121,.688,.134,.0726,-.022,.0835,-.462)*g2_2+\n    mat4(-.119,-.443,-.525,.138,-.563,.537,-.512,-.415,-.639,-.42,-.124,-.412,.167,-.0407,.0551,.426)*g2_3+\n    mat4(-.0908,.422,.595,-.475,.0741,-.368,.0616,-.144,.699,.0673,.0931,-.558,-.611,.145,-.0913,.3)*g2_4+\n    mat4(.023,.232,.319,.392,-.029,-.144,.139,.288,.195,.262,.248,-.0663,-.0967,.195,-.223,-.214)*g2_5+\n    vec4(-2.31,-1.4,2.86,-.949));\n    vec4 g3_5=sin(mat4(.534,-.374,.28,.166,.386,.414,-.0442,.187,-.271,-.438,-.316,.174,-.00251,.138,.328,.0828)*g2_0+\n    mat4(-.429,.324,.0405,-.351,.0476,.0637,.243,.45,.053,-.0578,.227,.583,-.608,.145,-.233,.0656)*g2_1+\n    mat4(.0906,-.456,.0171,-.322,-.0126,-.599,.124,.254,.217,-.6,.466,-.216,-.341,.0743,-.341,-.0744)*g2_2+\n    mat4(.29,-.53,-.16,-.007,.51,-.149,.15,-.0172,-.228,-.0271,.00209,.586,-.255,.0509,-.115,-.124)*g2_3+\n    mat4(-.196,.336,.114,-.421,-.0841,-.285,.122,.00757,.054,-.0279,-.369,.00404,.209,.0529,.593,-.253)*g2_4+\n    mat4(-.491,-.289,.25,.00891,-.107,-.552,-.3,.541,-.538,-.337,-.0437,.205,.309,.192,.255,-.156)*g2_5+\n    vec4(-3.09,.0497,3.09,-2.89));\n    vec4 g4_0=sin(mat4(-.184,-.235,.448,.306,.442,.399,.0887,.0259,7.04e-05,-.163,-.424,-.387,.207,.179,-.29,-.128)*g3_0+\n    mat4(.454,.58,.352,.411,.192,.0549,-.574,.534,-.402,-.392,.298,.683,-.129,.529,-.223,.404)*g3_1+\n    mat4(-.303,.123,.499,.247,.337,.474,-.432,-.177,-.193,-.253,-.0524,.494,.301,-.335,.0981,.403)*g3_2+\n    mat4(.0697,.462,.572,-.434,.151,.129,-.0561,.161,-.111,.185,.04,-.452,.307,-.149,-.21,.115)*g3_3+\n    mat4(.00756,-.129,-.392,.425,-.0982,-.13,.261,.309,.172,-.373,-.141,-.27,.403,-.181,.254,-.259)*g3_4+\n    mat4(-.359,.63,-.0343,-.101,.615,-.016,.342,-.634,-.53,.303,-.158,-.244,-.173,.291,.332,-.268)*g3_5+\n    vec4(-3.32,-3.84,-1.75,1.84));\n    vec4 g4_1=sin(mat4(.11,-.0859,.268,-.0266,-.152,.267,.372,.334,.453,-.375,-.355,-.228,-.184,.0584,-.113,-.00691)*g3_0+\n    mat4(-.136,-.286,-.392,-.112,.239,-.256,-.336,-.263,.554,-.201,-.27,-.162,-.324,-.382,-.116,.167)*g3_1+\n    mat4(.0926,.14,.325,-.0195,-.275,.51,-.141,-.235,.161,.065,-.304,.145,.337,.189,-.0507,.431)*g3_2+\n    mat4(-.458,-.0453,.21,-.438,.15,.398,.701,.385,.0468,-.334,.177,-.627,-.121,-.267,-.335,.188)*g3_3+\n    mat4(.0469,-.281,-.213,-.661,.378,.302,-.42,-.477,.0591,.62,.451,.0016,-.414,.21,.125,-.255)*g3_4+\n    mat4(.0248,.352,.179,-.265,-.158,.204,.258,.291,-.584,-.637,-.445,-.466,.565,.163,.272,.148)*g3_5+\n    vec4(.314,3.17,.22,-3.17));\n    vec4 g4_2=sin(mat4(-.166,-.00318,-.394,-.311,-.108,.0485,.0266,.608,-.558,-.223,.248,-.148,-.0844,-.41,-.156,-.161)*g3_0+\n    mat4(.079,.216,.108,.536,-.111,.353,.304,.162,.156,-.227,.387,-.375,.0709,.349,.0556,.481)*g3_1+\n    mat4(.311,-.571,-.477,-.132,.0405,-.611,-.037,-.259,-.218,-.403,-.493,.031,-.584,-.362,-.333,.429)*g3_2+\n    mat4(.301,-.582,.0184,-.279,.00122,-.185,-.0238,.215,-.359,-.179,-.433,.105,.0999,-.0851,-.191,.0634)*g3_3+\n    mat4(.58,.185,.306,-.373,-.217,-.59,.0774,-.0321,-.392,-.171,.179,-.451,.364,-.255,-.197,.0611)*g3_4+\n    mat4(.213,-.00564,-.66,.0122,-.453,.0137,-.23,.456,-.249,-.311,-.529,.0291,.432,.024,.0994,-.265)*g3_5+\n    vec4(.713,-2.51,3.36,.503));\n    vec4 g4_3=sin(mat4(-.0244,.24,.298,-.47,-.6,-.289,-.528,-.141,.263,-.159,.237,.253,-.374,.39,.238,.0732)*g3_0+\n    mat4(-.0584,.0389,-.133,-.142,-.00765,-.186,-.582,-.0578,-.03,-.19,.233,.52,-.42,-.321,.348,.203)*g3_1+\n    mat4(.18,-.283,.225,-.334,.741,.187,-.274,.431,.312,-.601,.496,-.171,-.202,.0827,-.144,-.476)*g3_2+\n    mat4(-.174,.11,.414,-.123,-.347,-.184,-.101,-.238,.039,-.722,.195,.37,-.352,.244,.11,-.0305)*g3_3+\n    mat4(.341,-.0324,-.212,.354,-.214,-.322,.239,.278,.308,-.396,.149,-.305,.000104,-.0529,-.466,-.384)*g3_4+\n    mat4(-.192,-.368,.451,-.209,.511,-.135,-.00737,.626,-.266,-.588,-.268,.331,-.463,.216,-.219,.549)*g3_5+\n    vec4(3.85,2.75,2.75,1.66));\n    vec4 g4_4=sin(mat4(-.513,.324,-.185,-.589,-.296,-.191,-.401,-.112,.197,.514,-.0868,-.0783,.41,.233,.107,-.3)*g3_0+\n    mat4(-.0961,-.365,.0862,-.0399,-.0501,-.39,-.481,-.133,.0861,-.454,.209,.499,.102,.215,.171,-.0565)*g3_1+\n    mat4(.265,-.0702,-.448,.0671,.328,-.14,.255,-.333,.157,.108,-.22,-.054,-.491,-.0165,.527,-.0539)*g3_2+\n    mat4(-.341,-.279,.224,-.654,-.355,-.113,-.0297,.225,-.0354,.157,-.193,-.0822,.000791,-.0505,.0937,-.471)*g3_3+\n    mat4(-.349,.441,-.271,.477,.017,.143,-.721,-.383,-.435,-.289,.488,.203,.434,.347,.48,.436)*g3_4+\n    mat4(.0497,-.473,.158,-.0743,-.288,.324,.431,.19,.155,-.194,-.0785,-.0586,.0275,.27,-.0307,-.468)*g3_5+\n    vec4(.973,.683,2.08,.446));\n    vec4 g4_5=sin(mat4(-.394,.2,-.85,-.424,-.0927,-.424,-.413,.0976,-.386,-.551,-.261,-.589,-.481,-.156,.664,.391)*g3_0+\n    mat4(.525,.572,-.503,-.105,-.361,-.198,-.0428,.00861,.0541,-.219,-.283,.246,.491,.297,-.137,.224)*g3_1+\n    mat4(.588,-.0585,-.402,.562,.326,.284,-.226,-.295,-.0298,.535,.428,.471,-.375,-.403,.405,.328)*g3_2+\n    mat4(.185,.506,.445,-.192,.459,.22,-.466,-.0399,.384,.299,-.147,.687,.384,-.261,-.169,.283)*g3_3+\n    mat4(.528,.328,.14,-.296,.639,-.0728,-.097,.0904,.19,-.201,.0683,.387,-.0713,.563,.0613,-.723)*g3_4+\n    mat4(.434,-.239,-.352,-.157,-.571,-.471,-.237,-.17,-.535,.388,-.12,.173,-.366,-.537,-.093,.655)*g3_5+\n    vec4(-.724,1.78,-1.48,-1.63));\n    vec4 g5_0=sin(mat4(-.0749,.33,-.0169,-.321,.165,-.503,-.21,.187,-.199,.234,.488,.275,-.23,-.603,.0586,.496)*g4_0+\n    mat4(-.352,.461,-.432,.533,.512,.235,-.207,-.0633,-.103,-.0392,-.0185,-.421,.378,-.379,.372,-.528)*g4_1+\n    mat4(-.397,.38,.104,-.243,-.0983,.496,.0796,-.0226,-.0592,.371,-.396,-.311,.261,.16,-.46,-.396)*g4_2+\n    mat4(.317,-.408,-.214,-.221,.211,-.367,.242,.359,-.539,-.116,.0688,-.374,-.341,-.375,-.000791,.0193)*g4_3+\n    mat4(.112,.0338,.377,-.277,.159,.0397,.375,-.367,-.212,.361,.301,.223,.245,.22,.213,.0212)*g4_4+\n    mat4(.447,.0608,.448,.0609,.266,-.305,.142,-.0263,-.288,-.0776,.225,.308,.38,-.15,.37,-.571)*g4_5+\n    vec4(1.14,2.63,-1.61,.922));\n    vec4 g5_1=sin(mat4(-.137,-.349,-.297,.275,-.0733,.0291,.238,.297,.0996,.266,-.0436,.359,-.0777,.4,-.354,-.187)*g4_0+\n    mat4(.107,.273,.159,.536,-.129,-.0411,.444,-.0623,.303,.27,.442,.405,.415,-.295,.161,.0455)*g4_1+\n    mat4(.555,.462,.506,.407,.458,-.28,-.162,.192,.0229,-.412,-.126,-.149,-.322,.0473,.0521,-.617)*g4_2+\n    mat4(.056,.157,-.314,-.545,.22,-.557,-.261,.394,.328,-.219,.174,.283,-.387,-.483,-.0563,.394)*g4_3+\n    mat4(-.24,.253,-.223,-.588,-.138,-.711,.0584,-.52,-.314,.108,.053,.422,-.0179,-.376,-.604,.287)*g4_4+\n    mat4(.407,.418,.433,.427,.246,.228,-.433,-.436,-.268,-.0166,.304,-.173,-.164,.0216,-.267,.00566)*g4_5+\n    vec4(-1.73,-1.02,-2.88,.979));\n    vec4 g5_2=sin(mat4(.277,.288,.132,.555,.13,.134,.276,-.325,-.382,-.262,-.594,.0613,.285,-.0466,.436,-.155)*g4_0+\n    mat4(-.0311,-.222,.265,.117,.59,-.0166,-.109,.341,-.185,-.259,.494,.457,-.175,-.0928,-.115,-.453)*g4_1+\n    mat4(.347,.605,-.362,.296,-.533,.169,-.17,.428,-.549,-.552,-.502,.122,-.305,.094,-.0148,.353)*g4_2+\n    mat4(.0961,.435,-.493,.616,-.31,-.277,-.396,.315,.548,.226,.413,-.225,.0601,-.349,.441,-.0957)*g4_3+\n    mat4(-.578,.363,.679,.237,.346,.377,.491,-.0863,.147,.113,-.168,.2,.334,.564,-.141,.521)*g4_4+\n    mat4(-.359,-.384,-.323,-.448,.18,-.129,-.274,.0536,-.117,.166,.314,.297,.402,.143,.191,-.201)*g4_5+\n    vec4(.29,-.792,-.974,2.66));\n    vec4 g5_3=sin(mat4(.188,-.344,.354,-.461,-.0304,-.53,.386,.101,.226,.0468,.676,-.348,-.585,-.227,.0068,-.135)*g4_0+\n    mat4(.33,.0376,.325,.399,-.0416,-.154,.118,.109,-.0797,.211,-.19,-.284,-.00555,.177,.522,.0569)*g4_1+\n    mat4(-.205,.314,-.528,-.00328,.334,-.223,-.552,-.217,-.0498,.381,.253,-.475,-.492,.326,-.287,-.271)*g4_2+\n    mat4(-.416,-.0291,-.358,.0684,-.259,-.0399,-.0262,.0247,-.403,.0954,-.328,.583,-.062,-.37,-.127,.0934)*g4_3+\n    mat4(-.0568,.0349,.346,.464,-.458,-.0351,.323,-.284,-.605,-.0301,.276,.0156,-.358,.32,.151,.106)*g4_4+\n    mat4(.0477,-.0136,-.394,.184,-.334,.331,-.0545,.359,.631,.43,-.266,-.658,-.091,.586,.473,.138)*g4_5+\n    vec4(.289,-3.18,-3.72,-2.37));\n    vec4 g5_4=sin(mat4(.157,.431,.601,.3,.152,-.0834,.0849,-.543,.117,.26,.372,.23,.415,-.531,-.475,-.019)*g4_0+\n    mat4(.143,.308,-.0256,-.0329,-.17,.478,.244,-.0857,-.211,-.433,.116,.656,-.228,-.153,.665,.65)*g4_1+\n    mat4(-.413,.0945,-.236,.638,-.0312,-.113,-.456,-.542,-.024,.68,.574,.479,.532,-.323,.00343,-.45)*g4_2+\n    mat4(-.436,.204,-.243,.0228,-.112,.344,-.0543,.29,.417,-.038,.152,.0611,.225,-.503,-.342,-.00476)*g4_3+\n    mat4(.147,-.0762,-.12,.315,-.0487,-.502,.0236,-.236,.563,.279,.209,-.487,.446,-.187,-.287,-.491)*g4_4+\n    mat4(-.447,-.34,-.449,.117,.116,.012,.384,.329,-.329,.287,-.461,-.185,-.188,.395,-.393,.137)*g4_5+\n    vec4(.529,-1.65,2.48,2.52));\n    vec4 g5_5=sin(mat4(.186,-.238,.281,-.284,-.0882,-.392,.38,.0155,-.319,-.153,.0977,-.349,.309,-.308,.319,-.173)*g4_0+\n    mat4(.139,.0622,-.234,.544,-.497,-.573,-.313,-.318,.204,-.232,.471,-.367,-.219,.0466,-.312,-.112)*g4_1+\n    mat4(-.454,.682,.129,.514,.247,.102,.0395,-.29,-.328,.497,.0254,.118,.151,-.0565,.294,.583)*g4_2+\n    mat4(.0543,-.266,.33,-.0402,.467,-.438,-.517,-.248,.228,.103,.116,-.0504,.0893,.327,-.346,-.114)*g4_3+\n    mat4(.359,.427,-.445,.411,.267,-.346,.0697,-.22,-.23,.513,.339,-.157,.281,.416,.18,-.43)*g4_4+\n    mat4(-.356,-.577,-.343,-.00512,.125,.132,-.605,-.278,.184,.0987,-.372,.0794,-.624,-.362,.309,.5)*g4_5+\n    vec4(.748,.247,-3.5,1.67));\n    vec4 g6_0=sin(mat4(.18,-.25,.438,.387,.114,-.14,-.392,.271,-.176,.574,-.398,-.116,.115,-.119,-.0218,.0724)*g5_0+\n    mat4(.174,.588,.211,-.289,.384,.431,-.524,-.323,.165,.543,.227,-.377,-.0914,-.21,-.0128,-.37)*g5_1+\n    mat4(-.339,.246,-.105,-.448,.414,-.000114,.285,.394,.0303,-.0904,-.105,-.136,.289,-.26,.476,-.506)*g5_2+\n    mat4(.488,.199,-.0765,.555,-.405,.276,.21,-.0451,.457,-.254,-.105,-.127,.252,.501,.278,.0499)*g5_3+\n    mat4(.226,.2,.12,-.0885,-.213,.341,-.0128,.113,.436,-.495,-.0528,-.448,.464,-.374,.371,-.116)*g5_4+\n    mat4(.341,.222,.189,-.289,.465,-.368,.229,-.0877,.606,.012,.278,.588,.283,-.477,-.21,-.528)*g5_5+\n    vec4(2.85,-1.55,4.11,1.04));\n    vec4 g6_1=sin(mat4(-.369,-.0487,.486,-.375,.0226,.399,.0146,-.347,.44,.0115,-.382,.0313,-.569,-.218,-.177,.324)*g5_0+\n    mat4(.369,-.219,-.302,.121,.244,.445,-.3,.273,-.0195,.305,.289,.0966,.27,-.289,.536,.147)*g5_1+\n    mat4(.211,.297,.438,.216,-.168,-.269,.000526,.583,-.37,.457,.499,.483,-.704,.463,.255,-.323)*g5_2+\n    mat4(-.287,.33,.2,-.436,-.561,-.0207,.47,.449,-.289,.351,-.485,-.336,-.266,-.37,.0903,.027)*g5_3+\n    mat4(.277,.278,-.249,-.393,-.397,-.257,-.408,.2,.313,.339,-.13,.284,-.391,-.596,.364,.138)*g5_4+\n    mat4(-.598,.0481,.148,.211,-.113,.312,-.174,-.244,.105,-.568,.394,-.517,-.562,.381,.154,.178)*g5_5+\n    vec4(3.34,.165,-2.62,-2.34));\n    vec4 g6_2=sin(mat4(-.577,-.322,-.0635,-.408,-.308,.297,.333,-.272,.0882,.349,-.0181,.0397,-.359,.457,-.507,-.0289)*g5_0+\n    mat4(.491,.18,-.214,-.0144,.699,-.476,-.238,-.396,-.272,-.436,-.529,-.339,-.107,-.172,-.412,.354)*g5_1+\n    mat4(.0818,.0872,-.508,-.213,.506,-.433,-.475,.272,-.476,.445,.0324,.415,.306,.115,-.315,-.523)*g5_2+\n    mat4(-.371,.318,.405,.4,-.273,-.0953,.277,-.143,.00561,-.414,.251,.35,-.043,-.575,.129,.421)*g5_3+\n    mat4(.183,.096,.357,.371,-.18,-.208,-.038,-.249,-.278,.579,.743,-.316,-.119,.158,-.486,-.352)*g5_4+\n    mat4(-.459,.472,.115,-.0883,.249,-.541,.542,-.258,-.0547,-.25,.501,-.0666,.0498,.0503,.305,-.344)*g5_5+\n    vec4(-2.72,-1.24,2.72,-2.55));\n    vec4 g6_3=sin(mat4(.319,.32,.529,-.00626,-.171,-.47,-.374,.122,.136,-.116,.312,-.267,-.243,-.369,-.377,.554)*g5_0+\n    mat4(-.123,.276,.439,-.0931,.54,.0794,-.452,.149,-.0884,.18,.169,.0241,.585,-.37,-.305,.349)*g5_1+\n    mat4(-.384,.24,-.124,-.291,.16,.00356,.0378,-.326,.155,.16,.087,.212,.373,.137,.0131,.286)*g5_2+\n    mat4(.0683,.635,.0796,-.51,-.257,-.43,-.204,-.363,-.486,.198,-.415,-.496,.441,.539,-.452,-.553)*g5_3+\n    mat4(-.0594,-.473,.0999,.352,-.128,.169,.313,.184,-.0113,-.141,.316,.614,-.25,-.119,-.453,.169)*g5_4+\n    mat4(-.262,-.0753,-.578,.464,.0977,-.0317,-.549,.155,.669,.319,.441,-.0142,-.224,-.154,.325,.584)*g5_5+\n    vec4(-3.07,1.51,-2.09,4.08));\n    vec4 g6_4=sin(mat4(.31,-.485,-.553,.103,-.33,.298,-.236,.0874,-.213,-.373,.26,-.672,-.317,.53,.202,-.336)*g5_0+\n    mat4(.323,-.0685,.228,-.662,.191,-.237,.119,-.483,-.212,.178,-.335,-.286,-.336,.498,-.437,-.215)*g5_1+\n    mat4(.184,-.2,-.198,-.401,-.452,-.129,.324,.214,.109,-.494,.178,-.164,.279,-.398,.0709,.0252)*g5_2+\n    mat4(.0545,.437,-.233,-.4,-.469,.346,-.396,.141,.404,-.0962,-.296,.533,.5,-.215,.0914,-.201)*g5_3+\n    mat4(.0664,.17,-.0741,.288,-.172,-.186,-.208,-.522,-.0455,-.22,-.0539,.538,.326,.633,.0415,-.311)*g5_4+\n    mat4(.0219,.18,-.0643,.0685,-.536,-.261,.471,.449,.0476,.0212,.0933,.17,.202,.33,-.248,-.0702)*g5_5+\n    vec4(2.43,-.2,1.86,1.92));\n    vec4 g6_5=sin(mat4(.301,.137,.0769,.128,-.279,-.215,.423,.257,.627,.316,.078,.343,-.258,-.233,.113,-.0476)*g5_0+\n    mat4(.504,.683,.308,.238,-.348,-.195,-.283,.0963,-.395,.67,-.244,-.483,.394,-.142,.0393,-.442)*g5_1+\n    mat4(-.349,-.225,-.26,-.054,-.112,-.154,-.371,-.274,.433,.107,.616,.541,-.321,.0722,.36,.101)*g5_2+\n    mat4(.432,-.339,-.238,.0314,-.384,.205,.356,.255,-.338,.316,.152,.246,.509,.204,-.265,-.119)*g5_3+\n    mat4(-.361,-.0203,-.499,-.0557,-.298,-.309,.776,.137,.243,.0714,.245,.279,.101,-.435,.351,.481)*g5_4+\n    mat4(-.396,-.0125,-.361,-.177,-.0295,-.572,.339,-.546,.404,-.0853,.139,.00658,-.458,-.269,.395,.144)*g5_5+\n    vec4(-2.55,-.686,-2.29,-.00309));\n    vec4 g7_0=sin(mat4(-.0296,.342,.103,.181,.249,-.315,.289,-.419,.0675,-.184,.0518,-.2,.362,.156,-.0669,-.225)*g6_0+\n    mat4(.321,.313,.346,.105,-.229,.0465,.329,-.017,-.668,-.0596,-.319,-.0411,-.263,-.199,.26,.0627)*g6_1+\n    mat4(.542,.269,-.23,-.21,.34,.521,.11,-.0949,.201,.228,.0525,.114,.299,-.503,-.0146,-.0082)*g6_2+\n    mat4(.194,-.427,-.0912,.0864,-.277,-.378,-.367,-.668,-.617,.0608,-.511,.554,-.488,.442,.149,-.0805)*g6_3+\n    mat4(.222,-.162,.394,-.418,-.183,.026,-.0869,.177,.176,-.335,-.451,-.43,.368,.415,.531,.0644)*g6_4+\n    mat4(.0864,-.00857,.384,-.556,.43,.467,-.298,.453,-.588,.0869,.135,.547,.12,.48,.443,.0669)*g6_5+\n    vec4(-1.6,-1.7,2.09,-4.11));\n    vec4 g7_1=sin(mat4(-.28,.535,-.38,.237,.304,.257,-.403,.316,-.092,.0363,-.467,.507,.473,.109,.339,-.345)*g6_0+\n    mat4(-.172,.0841,.451,.0188,-.331,.502,-.241,-.348,-.531,-.0645,-.028,.179,-.161,-.179,-.282,-.343)*g6_1+\n    mat4(.266,.352,.531,-.356,-.0589,.363,-.135,-.469,-.13,.585,.453,.158,-.223,.149,.525,-.549)*g6_2+\n    mat4(.129,-.192,-.0573,.443,.554,-.348,.137,-.172,.312,.191,.105,.381,-.619,.305,.371,.242)*g6_3+\n    mat4(.314,-.47,-.0482,.452,.64,-.124,.348,.0283,.318,-.285,.31,.445,-.346,.131,.512,.0757)*g6_4+\n    mat4(-.454,.0989,.371,.312,-.0469,-.576,-.0459,.016,-.281,-.21,-.174,-.181,-.325,.266,.335,.297)*g6_5+\n    vec4(-3.14,-.95,2.47,3.37));\n    vec4 g7_2=sin(mat4(-.273,-.312,.522,.265,.063,-.274,-.289,.23,.081,-.355,-.349,.186,.228,.214,-.238,-.171)*g6_0+\n    mat4(.0595,.181,.0506,-.0206,.574,.118,-.42,.493,-.645,-.096,.211,.385,.339,.377,-.0832,-.151)*g6_1+\n    mat4(.166,.0387,.106,-.443,-.39,.246,-.34,.0332,-.0131,-.237,.166,-.362,-.0681,-.113,.0968,.295)*g6_2+\n    mat4(.3,.0916,-.298,.377,.151,.0895,.0021,-.174,-.263,-.0551,-.113,-.321,.337,-.2,-.302,.04)*g6_3+\n    mat4(-.238,-.0687,-.49,-.0147,.51,.457,-.105,.246,.181,-.21,.438,.0139,.495,-.0877,.54,.159)*g6_4+\n    mat4(-.027,.422,.253,.225,-.132,-.519,.102,-.347,-.376,.156,-.212,-.147,-.153,.24,-.343,-.598)*g6_5+\n    vec4(-.705,2.11,-1.34,-.00609));\n    vec4 g7_3=sin(mat4(-.289,.165,-.282,-.111,-.218,.141,.0866,.0484,-.0298,.241,-.127,-.0264,-.0894,.0889,.208,-.544)*g6_0+\n    mat4(-.0282,-.231,.292,-.0232,-.397,-.618,-.235,.272,.436,.187,.211,.415,.594,.115,.342,.443)*g6_1+\n    mat4(.57,.0552,-.357,.381,.0484,-.556,-.0207,.353,.00323,.511,.00527,-.319,.16,-.157,.508,.589)*g6_2+\n    mat4(-.0957,-.262,.175,-.33,.197,.372,-.439,.314,.39,-.107,.0832,.235,.0237,-.257,-.281,.0796)*g6_3+\n    mat4(.0704,.0647,-.478,.157,.012,.0179,-.455,-.442,-.14,-.271,.255,-.015,-.198,-.263,-.613,-.0448)*g6_4+\n    mat4(-.286,.324,-.287,-.0408,.0896,.683,.119,-.12,-.34,.223,.41,.0299,.0914,.0365,.145,-.0218)*g6_5+\n    vec4(-2.19,-.843,3.09,-2.67));\n    vec4 g7_4=sin(mat4(.107,-.262,.0636,.156,-.531,-.0384,.337,-.137,.346,.485,-.181,-.131,-.112,-.389,.334,-.178)*g6_0+\n    mat4(.186,-.174,.206,.439,.315,.383,-.472,-.0261,.578,-.0394,-.0335,.269,.323,-.427,.362,.482)*g6_1+\n    mat4(-.0726,-.505,.155,-.454,.329,.0583,-.355,-.175,-.0921,-.0884,-.0932,-.0381,.35,.211,.282,-.0456)*g6_2+\n    mat4(.0607,-.169,-.163,.0755,.158,.536,.284,.547,.662,-.426,.0227,-.389,-.212,-.0907,.194,.227)*g6_3+\n    mat4(-.192,.108,-.202,-.199,.596,-.279,.167,-.0319,-.458,.725,-.00767,.437,.216,-.298,.25,.22)*g6_4+\n    mat4(.185,.275,.407,-.207,-.437,-.191,.451,-.275,.254,-.0144,-.365,.00652,.211,.281,-.0884,-.0463)*g6_5+\n    vec4(-.287,3.36,2.5,-1.25));\n    vec4 g7_5=sin(mat4(-.606,-.542,.465,.107,-.452,.569,.0729,.404,-.373,-.408,-.362,.396,.217,-.074,-.027,.0849)*g6_0+\n    mat4(-.0693,-.103,.0464,.308,.265,.0665,-.228,-.0492,.115,-.425,.18,-.369,-.254,.367,.601,.494)*g6_1+\n    mat4(.32,-.393,-.409,-.145,-.666,-.468,.325,.403,-.629,.131,-.515,.0734,-.023,-.303,-.224,-.014)*g6_2+\n    mat4(.559,-.0106,-.549,-.437,.0966,.5,-.488,-.211,.353,.138,.401,.46,-.574,-.286,-.0389,.347)*g6_3+\n    mat4(-.0611,-.204,.187,-.209,-.212,.279,-.438,-.528,-.227,.343,.0364,.293,-.443,-.177,-.539,-.411)*g6_4+\n    mat4(.345,.018,.123,-.462,-.282,.379,-.0534,-.135,-.41,-.136,.157,-.109,-.302,.275,-.142,.556)*g6_5+\n    vec4(-.84,-.434,1.95,-2.52));\n    vec4 g8_0=sin(mat4(.378,.413,.401,-.189,-.0316,.185,-.0787,.349,.101,.0132,.395,.144,-.171,-.641,.286,-.137)*g7_0+\n    mat4(-.0472,.427,-.539,.349,.395,-.085,-.528,.131,.191,.242,-.218,.015,.0115,-.615,-.0738,-.146)*g7_1+\n    mat4(-.384,-.537,-.434,-.209,.558,-.0698,-.333,.191,-.607,.14,-.327,.107,-.0997,.469,.0829,-.0697)*g7_2+\n    mat4(-.2,-.104,.378,.00704,.256,-.381,-.289,-.0596,-.17,-.314,.279,.488,-.0687,-.0159,.218,-.305)*g7_3+\n    mat4(-.472,.0674,-.197,-.58,-.384,.066,-.262,-.126,-.122,-.282,-.248,-.158,-.285,.408,-.268,.0612)*g7_4+\n    mat4(.301,.478,-.0256,-.557,-.3,-.148,.554,-.0156,.366,.166,-.384,.359,.089,.183,-.043,.0964)*g7_5+\n    vec4(-3.56,3.33,-3.62,2.36));\n    vec4 g8_1=sin(mat4(.0725,-.187,-.0665,.144,-.06,.0923,-.167,.0806,.0168,-.488,-.0289,.111,-.229,.0307,-.663,.198)*g7_0+\n    mat4(.0507,.578,.393,.387,.166,.233,-.228,.127,-.114,-.00464,.337,.599,.346,.0379,.233,-.243)*g7_1+\n    mat4(-.262,-.651,.127,-.536,-.101,.101,-.471,.307,.549,-.0503,-.207,.307,-.0292,-.188,-.184,.0407)*g7_2+\n    mat4(-.198,-.305,-.423,.237,.574,.238,.514,.561,.0575,-.0819,-.734,.105,.00104,-.452,-.493,-.446)*g7_3+\n    mat4(.00531,-.242,-.291,.559,-.242,-.22,.0673,.0878,-.247,-.109,.133,-.242,-.269,-.265,.0744,-.01)*g7_4+\n    mat4(-.453,-.0973,.144,-.152,-.136,-.0555,.123,-.59,-.23,-.366,-.439,.203,.327,.538,.418,.0704)*g7_5+\n    vec4(-1.85,2.4,2.44,3.16));\n    vec4 g8_2=sin(mat4(-.0386,.322,.38,-.319,.214,-.242,.46,-.416,-.234,.296,.0436,-.263,.662,.243,-.248,.2)*g7_0+\n    mat4(-.383,-.178,.543,-.244,-.174,.687,-.194,.366,.0333,-.041,.422,.161,.464,.252,.125,-.0871)*g7_1+\n    mat4(.352,-.376,-.506,.0194,.116,.614,-.229,-.181,-.165,.404,.0732,.376,.349,.158,-.584,.219)*g7_2+\n    mat4(-.335,.23,-.0392,.388,-.161,-.175,.578,-.544,-.289,.0748,-.613,-.0317,.177,-.573,-.00669,.0313)*g7_3+\n    mat4(.226,.0493,.392,.632,-.27,.294,.0762,-.578,-.0247,.0584,-.295,.36,-.479,.0814,.299,-.58)*g7_4+\n    mat4(.316,.259,.296,.0234,.137,.0769,.0814,.27,-.208,-.0214,-.56,.374,.208,-.496,-.0435,.273)*g7_5+\n    vec4(.867,2.38,2.13,-1.17));\n    vec4 g8_3=sin(mat4(.387,.388,.183,-.0693,-.124,-.374,.318,.225,-.115,-.638,-.482,-.115,.502,-.564,-.0445,.536)*g7_0+\n    mat4(-.166,.183,.239,-.358,.386,-.427,.458,-.0779,.244,.14,-.507,.521,.55,.589,.0924,.0855)*g7_1+\n    mat4(-.454,.47,-.107,-.172,.325,-.589,.26,-.573,.172,.352,.333,.189,-.519,.118,.241,.0908)*g7_2+\n    mat4(.238,-.243,.364,-.452,-.185,-.155,.19,-.41,-.531,-.312,-.0684,-.464,.381,-.303,-.0445,.0445)*g7_3+\n    mat4(.394,.637,.207,.425,.445,.13,-.165,.496,-.269,.137,.244,.0297,-.118,.471,.482,-.0751)*g7_4+\n    mat4(-.271,-.157,-.272,.539,-.468,-.125,-.00509,.152,.605,-.346,-.38,.141,.215,-.12,-.157,.0757)*g7_5+\n    vec4(2.46,2.46,.269,-2.9));\n    vec4 g8_4=sin(mat4(-.331,-.565,.168,-.468,.309,.161,.293,-.536,.432,.425,-.18,-.138,.171,.285,-.0457,-.351)*g7_0+\n    mat4(-.459,-.181,-.159,-.292,-.339,-.315,-.261,-.0486,-.145,.439,.154,.487,.0516,.486,-.395,.435)*g7_1+\n    mat4(-.209,.0506,.342,.187,-.275,-.238,-.0318,.0408,.0437,-.348,-.477,-.3,.187,.212,.413,-.228)*g7_2+\n    mat4(.186,-.506,-.113,.184,-.573,.0639,-.0338,.191,-.126,.255,.166,.294,.218,.464,-.275,.366)*g7_3+\n    mat4(-.17,-.414,-.41,.277,.4,-.45,-.00769,-.45,-.127,-.109,.352,-.278,.089,-.188,.0718,-.0993)*g7_4+\n    mat4(.309,.401,.0343,.571,.506,-.19,-.36,.0383,-.00208,-.0421,-.244,.608,-.241,.173,-.429,.0159)*g7_5+\n    vec4(-.644,-.94,.881,2.58));\n    vec4 g8_5=sin(mat4(-.0965,.43,-.05,.0544,-.181,-.111,-.281,.0241,-.527,-.17,-.423,.0506,-.238,.307,.539,-.163)*g7_0+\n    mat4(.245,.405,.0394,-.458,.358,-.0875,.24,-.289,.0507,-.102,.201,.472,-.341,.249,.106,-.245)*g7_1+\n    mat4(-.206,-.251,-.327,-.331,.131,-.156,.562,-.0731,-.465,.521,-.0914,-.0383,-.329,-.268,.39,-.151)*g7_2+\n    mat4(-.298,.192,.133,.256,-.384,.156,.249,-.499,.346,.0525,.0659,-.211,-.516,-.0996,.589,-.262)*g7_3+\n    mat4(.0867,.223,-.331,.196,-.489,.411,.27,-.152,.544,.179,.362,-.08,-.232,-.0761,.0564,.0245)*g7_4+\n    mat4(.604,-.253,.265,.12,.044,-.091,-.745,.582,.429,.102,-.344,.625,-.445,.549,.351,.0546)*g7_5+\n    vec4(-3.47,-1.15,-2.37,-1.13));\n    vec4 g9_0=sin(mat4(.391,-.25,-.145,.298,.473,.631,-.533,-.137,.172,-.752,-.104,-.342,.224,-.0428,-.108,.145)*g8_0+\n    mat4(.155,.226,.227,-.17,-.402,.527,-.249,-.15,-.498,.245,.121,.107,-.23,.622,-.486,.0875)*g8_1+\n    mat4(.112,.0493,.366,.526,.279,.586,-.436,-.18,-.466,-.43,.571,-.549,.232,-.626,.0406,-.247)*g8_2+\n    mat4(-.148,-.06,-.0599,.347,-.0795,-.2,.28,-.00358,.241,-.34,.451,-.305,.206,.91,-.368,.0641)*g8_3+\n    mat4(-.22,.158,-.0927,-.0153,-.297,.136,.127,-.411,.48,.0995,-.3,-.277,-.0173,.224,.324,-.284)*g8_4+\n    mat4(.544,-.52,.237,.553,.402,.237,-.0826,.0818,.364,.19,.0122,-.357,.164,-.297,-.0437,.32)*g8_5+\n    vec4(-2.48,-.8,2.06,2.41));\n    vec4 g9_1=sin(mat4(.729,.185,-.265,-.198,-.343,.333,-.689,.15,.355,-.0594,-.137,-.112,.221,.377,-.1,.079)*g8_0+\n    mat4(.0523,-.354,.59,-.546,.374,.251,-.0249,-.114,.0323,.133,.0502,.0322,-.154,-.252,-.224,-.304)*g8_1+\n    mat4(-.478,-.396,-.263,.0432,.291,-.317,-.0663,-.306,-.414,-.339,.116,-.161,-.407,-.0941,-.182,.275)*g8_2+\n    mat4(-.574,-.0284,-.259,.237,-.31,-.307,.092,-.0339,.272,-.583,.332,-.0649,-.22,.31,.185,.386)*g8_3+\n    mat4(-.55,-.532,-.258,-.268,-.119,-.124,-.303,.0121,.332,-.12,.447,.0784,.321,-.733,-.368,.365)*g8_4+\n    mat4(.301,-.481,-.227,.121,.14,-.174,.351,-.327,-.117,.112,.354,.16,-.491,.332,.307,.164)*g8_5+\n    vec4(1.65,-1.86,1.26,-3.46));\n    vec4 g9_2=sin(mat4(.291,.212,.0303,-.0433,-.283,.00928,-.0237,.426,-.0145,.288,.203,.063,-.142,.306,-.178,-.396)*g8_0+\n    mat4(.0629,.484,-.342,-.109,.394,.323,-.346,-.328,.446,.0747,.368,-.174,-.26,-.405,.144,.172)*g8_1+\n    mat4(-.153,-.216,.367,.00905,-.374,-.179,.127,-.0844,-.248,-.343,.15,.508,-.239,-.106,.0719,-.0343)*g8_2+\n    mat4(-.481,-.471,.108,-.465,.227,-.445,.512,.325,.475,-.539,.0568,-.177,.27,-.338,-.235,.171)*g8_3+\n    mat4(.0749,.656,-.458,.164,-.0345,-.174,-.384,-.483,-.25,.309,.255,-.15,.186,.514,-.232,-.227)*g8_4+\n    mat4(.384,-.113,-.505,-.551,-.0961,.323,-.0403,-.119,-.125,.265,.264,-.0768,.0803,.415,.171,.381)*g8_5+\n    vec4(-2.91,3.58,3.26,-1.07));\n    vec4 g9_3=sin(mat4(.282,-.414,-.625,-.165,-.223,-.0614,.231,.182,-.446,.262,-.17,.593,-.0507,-.0282,-.216,-.41)*g8_0+\n    mat4(.0336,.408,-.0414,.232,-.248,-.208,-.143,.0777,-.192,-.537,.137,-.438,.047,-.251,-.207,.443)*g8_1+\n    mat4(-.137,-.27,-.108,.249,-.0146,.305,-.449,.352,.245,-.0424,-.593,-.321,.267,-.465,-.47,.255)*g8_2+\n    mat4(.236,-.127,-.264,.268,.198,-.487,.303,-.413,-.707,-.0773,.207,-.00318,.363,.428,-.659,.0932)*g8_3+\n    mat4(-.267,-.481,.0352,.566,.373,-.445,.0894,.405,-.233,-.169,.452,-.0909,-.554,-.153,-.267,-.478)*g8_4+\n    mat4(.25,-.0565,-.336,-.154,.401,.0973,.268,.335,-.427,.595,.372,.499,-.172,-.284,.126,.624)*g8_5+\n    vec4(-.604,-1.52,-.705,-.209));\n    vec4 g9_4=sin(mat4(-.264,.217,-.264,.0132,.489,.491,-.202,-.25,.162,-.144,-.432,-.291,-.254,-.323,.126,.0832)*g8_0+\n    mat4(.29,-.15,.142,.0574,.392,.392,-.076,-.00292,-.356,-.0759,-.0221,-.0531,.417,.349,.363,.604)*g8_1+\n    mat4(.123,-.272,.115,.0491,.134,.383,-.16,.062,.447,-.00105,-.108,.0642,-.403,-.162,-.0931,-.157)*g8_2+\n    mat4(.238,-.41,.296,.601,-.0407,.347,-.342,-.138,.407,-.118,.372,.213,.0259,.277,-.0489,-.56)*g8_3+\n    mat4(.417,.186,.475,.227,-.265,-.564,-.287,.235,-.442,-.0198,.208,.239,.532,-.00719,.283,-.426)*g8_4+\n    mat4(-.116,-.191,-.216,.226,.104,.337,.202,.0239,.322,-.0201,-.436,.0645,.383,-.122,.324,.315)*g8_5+\n    vec4(3.68,-.864,-1.08,-.74));\n    vec4 g9_5=sin(mat4(-.235,.342,-.0531,-.136,.119,-.429,-.0863,.43,.545,.517,-.305,-.243,-.0299,-.203,.295,.42)*g8_0+\n    mat4(-.053,-.221,-.146,.475,.469,-.297,.172,.0475,-.0651,.265,.148,.467,-.134,-.0534,-.223,.366)*g8_1+\n    mat4(.303,.366,-.264,.14,.0826,-.191,.237,.199,-.0351,.311,-.343,-.053,.312,.218,-.0775,.173)*g8_2+\n    mat4(.0491,-.526,.187,-.0768,.104,-.6,-.285,-.093,.209,.0246,-.615,-.457,-.0855,.233,-.0245,-.162)*g8_3+\n    mat4(.192,-.349,-.22,-.207,.0455,-.141,.278,-.0282,-.188,-.0408,.288,.332,.0847,.719,.223,-.0737)*g8_4+\n    mat4(.165,.319,.332,-.248,-.238,.169,-.531,.514,-.583,-.273,.15,.15,.104,-.267,-.125,-.372)*g8_5+\n    vec4(-2.47,-2.93,2.23,-4.08));\n    vec4 g10_0=sin(mat4(-.183,-.193,-.14,.0529,.595,-.457,.00942,.0218,.583,.137,-.44,-.525,.477,.413,.143,.438)*g9_0+\n    mat4(.0557,.375,.371,-.369,-.65,-.184,.097,-.421,-.0484,.227,-.268,.276,.0193,-.00438,-.353,-.284)*g9_1+\n    mat4(.286,.423,-.288,-.0855,.09,-.0479,-.0963,-.0222,-.268,.24,-.311,.256,-.583,.398,-.43,.427)*g9_2+\n    mat4(-.055,-.314,.254,.372,.178,.216,-.0324,-.248,-.0546,-.232,-.232,.501,-.153,-.122,-.0552,.272)*g9_3+\n    mat4(.014,-.394,.211,.0178,-.639,.113,.243,-.104,.111,-.623,-.404,.577,-.502,-.59,-.221,.429)*g9_4+\n    mat4(-.156,-.583,.0324,.0744,-.174,-.408,.124,-.602,-.0374,-.191,.297,-.274,-.372,-.457,.36,-.266)*g9_5+\n    vec4(-2.98,-1.83,-.0404,3.19));\n    vec4 g10_1=sin(mat4(.00777,.15,-.0156,.546,-.0496,-.233,.189,.0177,-.165,-.58,.0814,-.404,.128,-.251,-.252,.296)*g9_0+\n    mat4(-.412,-.239,-.035,-.263,.468,.569,.583,-.131,-.333,.216,-.144,-.351,-.607,-.451,.251,-.224)*g9_1+\n    mat4(.0365,-.48,-.152,.476,-.488,.308,-.412,-.499,.272,-.0836,.507,.0142,.00325,-.292,-.322,.242)*g9_2+\n    mat4(-.129,-.324,-.047,.398,-.278,.504,.242,-.23,.421,.492,.137,-.129,.169,.133,.243,.272)*g9_3+\n    mat4(-.117,-.164,.26,-.00495,-.34,.583,-.0535,-.458,.442,.237,-.245,.291,.587,-.395,.621,.133)*g9_4+\n    mat4(.0984,.565,-.109,.0499,.243,-.000647,-.00141,.277,.325,-.298,-.527,-.174,.417,.0376,-.345,-.487)*g9_5+\n    vec4(3.02,-1.68,-2.46,.504));\n    vec4 g10_2=sin(mat4(-.093,.111,.17,.172,.132,.0916,.305,-.13,.134,.0051,.306,-.596,-.374,.57,.443,.25)*g9_0+\n    mat4(-.423,-.123,-.684,.396,.279,.555,.395,.536,-.612,-.206,.259,-.672,-.435,-.203,.23,-.378)*g9_1+\n    mat4(-.356,.273,.116,.115,.307,.271,-.0324,-.348,.0804,-.509,.354,.115,.192,-.199,.12,-.166)*g9_2+\n    mat4(.0274,.117,-.515,.365,-.337,-.35,-.233,-.261,-.291,-.0731,-.214,.141,.21,.0483,-.0723,.445)*g9_3+\n    mat4(.557,-.485,.223,.343,.477,-.233,.33,.308,.143,-.62,.258,.42,.427,-.114,.211,.145)*g9_4+\n    mat4(.0565,.435,.0665,.185,-.317,-.169,.103,.456,-.426,.332,-.763,-.267,-.145,-.00286,.0592,-.234)*g9_5+\n    vec4(.834,3.84,1.52,-3.99));\n    vec4 g10_3=sin(mat4(-.547,-.0893,.357,.0407,.203,.495,.304,.209,.41,.394,-.148,.456,-.338,.0404,.33,.245)*g9_0+\n    mat4(.187,.199,.033,.203,-.101,.187,.186,-.0568,-.415,-.196,.276,-.393,-.213,.0816,-.0679,.275)*g9_1+\n    mat4(.0299,-.458,.39,.634,.474,.0642,.153,.132,-.321,.143,.222,-.268,.0919,.00569,.486,.122)*g9_2+\n    mat4(-.0684,-.194,-.263,-.126,-.739,.232,-.402,-.152,-.344,-.254,.706,-.351,.114,-.112,.269,.262)*g9_3+\n    mat4(-.0976,-.241,.0185,.29,-.608,-.34,-.321,-.274,-.204,-.457,.174,-.296,-.55,-.0757,.452,.351)*g9_4+\n    mat4(-.361,-.104,.127,.33,-.0124,-.217,.602,.572,-.439,.602,-.433,.371,-.393,.565,-.216,-.521)*g9_5+\n    vec4(-.356,-2.48,-.605,-.897));\n    vec4 g10_4=sin(mat4(-.0622,.32,.396,-.214,-.299,-.236,.0275,.268,.339,.227,-.082,.0886,.494,-.412,-.394,.356)*g9_0+\n    mat4(-.356,-.319,-.0133,-.201,-.421,-.0856,.237,-.247,-.42,-.111,-.106,-.479,-.0614,.478,-.312,-.373)*g9_1+\n    mat4(.0114,.128,-.0147,.103,-.188,-.13,-.465,.181,.0341,-.15,.426,-.208,-.222,-.392,-.169,.229)*g9_2+\n    mat4(-.252,-.168,-.261,-.117,.176,.676,.43,.213,.191,.478,.422,.177,.584,.36,.59,-.0171)*g9_3+\n    mat4(-.101,.0204,-.0488,-.00315,-.493,-.384,-.0627,.227,-.0118,-.187,.263,-.13,.28,-.0787,.335,.225)*g9_4+\n    mat4(.102,.0989,-.237,.426,.159,.0837,-.343,-.181,.469,-.37,-.136,.377,-.191,-.068,-.00491,-.0418)*g9_5+\n    vec4(2.86,-.679,-1.26,-2.37));\n    vec4 g10_5=sin(mat4(-.0635,-.3,.427,-.118,.56,-.351,.48,.475,-.277,-.604,.298,-.0951,-.286,-.341,-.166,-.266)*g9_0+\n    mat4(.17,-.135,.0794,.199,.0139,.185,.348,-.171,-.294,-.0439,.0972,.292,-.662,-.133,.464,.391)*g9_1+\n    mat4(-.241,-.115,-.00498,-.29,-.0174,-.505,-.447,-.196,.194,-.136,.132,-.116,.182,-.27,-.0868,-.42)*g9_2+\n    mat4(-.0779,.495,-.0735,-.399,-.343,.583,-.195,.0409,.206,-.25,.437,.419,-.327,-.236,.303,-.244)*g9_3+\n    mat4(.462,.544,.139,-.183,-.00746,-.107,.479,-.178,.301,.0279,.275,.453,-.215,-.247,.1,-.383)*g9_4+\n    mat4(-.0509,-.481,.259,-.089,.25,-.158,-.0792,-.23,-.115,-.383,-.704,.387,.0322,.5,-.436,.36)*g9_5+\n    vec4(.108,3.54,-3.89,3.94));\n    vec4 g11_0=sin(mat4(.558,-.314,-.35,.405,.059,-.386,-.267,-.221,-.127,.0203,-.00751,-.341,-.677,-.143,-.4,.471)*g10_0+\n    mat4(-.0525,.13,.265,.129,-.098,.301,-.00326,-.157,.257,-.475,.255,.19,.421,-.00202,.325,-.345)*g10_1+\n    mat4(-.423,-.186,-.209,.157,.00888,.162,-.288,.169,.0881,-.399,.227,-.483,.191,-.0347,-.58,.344)*g10_2+\n    mat4(.071,.118,.165,-.313,.339,-.0363,.328,-.345,-.284,.272,-.163,.133,.256,.158,-.263,.03)*g10_3+\n    mat4(.139,.0977,.309,-.236,-.557,.275,.183,.154,.63,.483,.551,-.305,.151,.142,-.304,.0786)*g10_4+\n    mat4(-.362,.413,.0171,-.293,-.0576,.144,-.251,-.107,-.637,.319,-.733,-.396,.559,-.288,.224,.0772)*g10_5+\n    vec4(-1.31,-.528,3.01,3.69));\n    vec4 g11_1=sin(mat4(-.412,.294,.412,.138,.0686,-.162,.273,.106,.229,.237,-.209,-.408,.225,.112,.0193,.441)*g10_0+\n    mat4(.402,-.535,-.131,-.137,-.466,-.39,.689,-.23,-.0781,-.0594,-.573,.0678,.143,-.286,.506,.00689)*g10_1+\n    mat4(-.148,.566,-.463,-.259,-.263,-.357,.078,-.186,-.00966,.406,.0764,.0495,.36,.371,.136,-.14)*g10_2+\n    mat4(.337,.327,-.265,.35,-.291,.273,.189,-.314,-.623,.174,.271,-.279,-.614,-.101,-.014,.118)*g10_3+\n    mat4(.184,-.119,.489,-.138,.296,-.18,.437,-.0818,-.411,-.612,.616,.093,-.327,.0707,-.439,.186)*g10_4+\n    mat4(.243,-.0598,-.209,.0214,.292,-.717,.649,.367,.552,.375,-.0291,.278,-.115,-.261,.499,-.401)*g10_5+\n    vec4(-3.54,-1.33,-3.01,-3.82));\n    vec4 g11_2=sin(mat4(-.369,.318,-.246,-.0288,-.0474,.0836,-.282,.0402,-.506,.166,.155,-.291,-.326,.486,-.156,.167)*g10_0+\n    mat4(.475,.27,-.101,-.0734,-.392,-.276,-.138,.146,.142,.276,.336,-.412,-.125,.194,.0809,.421)*g10_1+\n    mat4(-.263,-.245,.318,-.554,.15,-.396,-.02,-.413,.608,.128,-.318,.332,.181,-.414,-.293,-.000331)*g10_2+\n    mat4(-.121,.53,.394,-.561,.131,.11,-.182,.178,-.563,.44,-.574,-.00892,.0389,-.298,.473,.411)*g10_3+\n    mat4(-.154,-.576,-.47,-.0669,-.124,-.0471,.0351,.451,.146,.323,-.0899,-.351,-.108,-.111,-.0895,.278)*g10_4+\n    mat4(-.0437,.0239,-.236,.262,-.073,-.0448,.193,-.285,.477,-.105,-.215,.0693,.0894,-.121,.387,-.0505)*g10_5+\n    vec4(-3.7,2.4,-.744,-2.95));\n    vec4 g11_3=sin(mat4(.102,.301,-.422,.212,-.528,-.1,-.163,.396,-.361,-.359,.113,.23,-.165,.618,-.595,.04)*g10_0+\n    mat4(.289,.305,.0322,-.41,-.0267,.333,.501,-.175,.184,.208,-.52,.153,.179,.101,.557,.44)*g10_1+\n    mat4(.266,-.109,-.177,.316,-.0584,-.25,.238,.185,-.498,.426,.331,.338,-.323,-.183,-.403,.0892)*g10_2+\n    mat4(-.31,.472,.0872,.354,-.124,.31,-.191,-.054,.171,-.102,.692,.242,-.631,-.423,-.243,.364)*g10_3+\n    mat4(-.488,-.431,-.0857,-.475,-.194,-.37,.564,-.0398,.435,-.215,-.109,-.117,-.398,-.0328,.214,-.266)*g10_4+\n    mat4(-.503,.454,.117,-.458,.182,-.534,-.221,.174,.0772,-.196,-.107,.171,-.16,-.288,.126,-.391)*g10_5+\n    vec4(2.57,4.05,-3.89,-2.64));\n    vec4 g11_4=sin(mat4(-.0199,.0749,.4,.148,-.0334,-.466,-.29,-.19,-.137,-.369,.348,-.318,-.44,.395,.222,.219)*g10_0+\n    mat4(-.0784,-.0605,.0487,.399,.148,-.462,-.197,-.17,-.575,.311,.487,.143,-.39,-.334,-.52,-.583)*g10_1+\n    mat4(.471,.187,-.325,-.195,.213,.22,-.345,-.563,-.0328,-.00515,.113,.443,-.19,.152,-.0145,-.193)*g10_2+\n    mat4(.281,.223,.383,-.312,.43,.384,-.481,-.235,.234,.46,-.382,-.245,.463,-.432,-.375,-.287)*g10_3+\n    mat4(.435,-.0794,-.102,.173,.0287,.153,.23,.0909,-.107,.374,.385,.000201,-.0514,.0305,.311,-.592)*g10_4+\n    mat4(.25,-.399,.288,.605,-.0775,.327,.503,-.212,.325,-.209,.371,.491,-.082,.0285,.172,-.36)*g10_5+\n    vec4(3.74,4.05,3.44,.89));\n    vec4 g11_5=sin(mat4(-.142,-.215,-.494,-.424,.394,-.143,.0874,.0795,.472,.164,.0466,.139,-.0305,.377,.659,-.000886)*g10_0+\n    mat4(-.0304,.0552,.00664,-.0544,-.0205,-.0773,.143,-.609,.172,.136,.347,-.292,.383,.336,-.331,-.128)*g10_1+\n    mat4(.31,-.13,.647,-.293,.432,.265,-.0599,-.33,.254,.302,.473,-.356,-.0102,.431,-.51,.0215)*g10_2+\n    mat4(.222,-.252,.172,.343,-.104,-.347,-.0996,.076,-.33,-.121,.228,-.614,-.133,.235,-.211,-.169)*g10_3+\n    mat4(-.184,-.599,.217,.0319,.481,-.458,-.211,-.586,.25,-.523,-.039,.0428,.482,-.548,.0505,.3)*g10_4+\n    mat4(.266,.0444,.0116,.57,.066,-.313,.0684,-.0703,.0494,-.11,.151,.0692,.336,-.201,.136,.0481)*g10_5+\n    vec4(-1.93,-3.46,3.46,3.2));\n    vec4 g12_0=sin(mat4(-.058,-.132,.114,.501,-.34,-.519,.16,-.168,.0556,-.676,.571,.328,-.17,.248,-.185,-.158)*g11_0+\n    mat4(.273,.208,-.468,.249,-.324,.415,-.667,-.00419,-.166,-.185,.273,-.0977,-.287,-.113,-.176,-.308)*g11_1+\n    mat4(-.0988,-.139,.136,.353,.219,.285,-.178,-.239,.452,-.125,-.376,-.341,.573,.603,.233,.173)*g11_2+\n    mat4(-.447,-.281,.0326,-.425,.118,-.1,-.581,.435,.496,-.0279,-.211,.218,-.148,.383,.179,.182)*g11_3+\n    mat4(-.0115,.231,.137,.401,.524,.181,-.636,-.13,.117,-.236,-.0948,-.142,-.291,-.46,-.215,.0554)*g11_4+\n    mat4(.0584,.187,-.686,.537,-.341,.262,-.339,-.229,-.202,-.535,-.26,-.16,-.682,-.242,-.448,.184)*g11_5+\n    vec4(-2.81,3.63,2.62,-2.94));\n    vec4 g12_1=sin(mat4(.193,-.322,-.322,-.512,-.73,.373,-.07,-.162,-.314,.425,-.578,-.364,-.466,.0891,-.0127,.64)*g11_0+\n    mat4(.364,.331,-.235,-.0499,-.247,-.263,-.275,-.207,-.0553,-.0436,-.0931,.283,-.268,.0292,-.299,.224)*g11_1+\n    mat4(.229,.145,-.246,-.201,.325,.41,-.549,-.0334,-.217,.275,.314,-.217,-.153,.206,-.122,.0267)*g11_2+\n    mat4(.169,.0249,.131,.47,.268,.0762,-.0973,-.0178,.135,-.507,.0201,.185,-.33,-.283,-.411,-.523)*g11_3+\n    mat4(.0477,.403,.401,-.0772,-.191,-.172,-.373,.307,-.0362,.583,.416,-.769,.206,-.197,-.371,-.303)*g11_4+\n    mat4(.0696,-.322,-.0339,-.472,-.589,-.56,.363,.52,-.0511,.112,-.31,.185,-.145,-.144,-.363,.484)*g11_5+\n    vec4(3.11,-1.77,-3.31,3.66));\n    vec4 g12_2=sin(mat4(.519,-.384,-.323,-.158,-.0167,.186,.34,-.18,-.407,.379,-.3,.171,-.0315,.0603,-.284,.334)*g11_0+\n    mat4(.316,.0982,.0186,-.297,.282,-.113,-.409,-.0674,.304,.623,.257,-.138,-.0231,.329,.259,.285)*g11_1+\n    mat4(-.16,-.0438,.345,-.016,-.53,-.162,.111,-.18,-.143,-.467,-.045,.205,.601,-.57,-.585,-.535)*g11_2+\n    mat4(-.429,-.319,-.345,.0958,-.322,-.18,-.444,.0496,-.228,-.0144,.107,.34,-.351,.186,-.344,.242)*g11_3+\n    mat4(-.24,.23,-.521,.0627,-.236,-.0297,.0153,-.3,.108,.009,-.319,.166,-.063,-.466,.207,-.198)*g11_4+\n    mat4(.304,.0748,-.303,.124,-.529,-.267,-.134,.448,-.295,-.286,.141,.221,-.226,-.0162,.186,.224)*g11_5+\n    vec4(-4.06,1.06,1.84,-3.05));\n    vec4 g12_3=sin(mat4(-.212,-.198,-.256,.39,.276,-.128,-.0349,.399,.211,-.283,.354,-.011,.138,.352,-.0781,.192)*g11_0+\n    mat4(-.284,.558,.455,-.356,-.42,-.174,.482,.225,-.442,-.239,-.302,-.383,-.343,-.262,-.158,.226)*g11_1+\n    mat4(-.647,-.48,-.558,-.0608,.0386,-.345,.0316,-.368,-.0292,.498,-.311,-.573,-.515,.159,-.408,-.0416)*g11_2+\n    mat4(-.0927,-.434,.376,.369,-.156,.161,-.174,-.0415,-.587,-.655,-.487,.265,.0384,.0101,-.205,-.136)*g11_3+\n    mat4(-.0477,-.218,-.0724,-.4,.175,.41,-.061,-.23,.047,.414,.0504,-.17,.382,-.29,.0796,-.0228)*g11_4+\n    mat4(.108,.445,.000781,.0383,.0941,.275,-.191,-.165,.28,.154,.0683,-.0149,.13,.451,.435,-.0389)*g11_5+\n    vec4(-2.85,2.11,3.39,2.36));\n    vec4 g12_4=sin(mat4(.336,-.0553,-.341,.0531,.0925,-.197,-.575,-.073,-.0232,-.598,-.0548,.342,-.0814,.265,.253,-.363)*g11_0+\n    mat4(-.651,.095,-.358,-.0172,.316,-.178,-.311,.27,-.0291,-.117,.171,.346,-.00288,.562,.322,.0083)*g11_1+\n    mat4(.143,.268,.233,-.0304,.345,.327,-.0106,.503,-.568,.211,-.561,.193,-.285,.0247,.413,-.591)*g11_2+\n    mat4(-.161,.234,.0484,.375,-.34,.0262,-.08,.379,-.349,.488,.507,.439,-.621,-.166,-.249,-.475)*g11_3+\n    mat4(.0943,-.0637,-.128,-.351,.112,.399,-.443,-.248,.353,.0134,-.506,-.293,-.308,.238,.266,.604)*g11_4+\n    mat4(.00522,.576,-.206,-.314,.0693,.198,.592,-.307,-.221,-.0393,-.0585,.356,.0696,.384,-.386,.271)*g11_5+\n    vec4(-3.9,1.88,1.07,1.32));\n    vec4 g12_5=sin(mat4(.276,.0173,.397,-.409,-.136,.0255,.34,-.0584,-.342,.452,.395,.355,-.569,.436,-.324,.488)*g11_0+\n    mat4(-.145,.547,-.585,-.495,-.327,.0753,.208,-.00353,-.529,-.0284,-.115,-.231,-.167,-.00198,.28,.13)*g11_1+\n    mat4(-.106,.618,-.277,-.464,-.0895,.701,.425,.128,.277,-.407,.23,.259,.507,-.136,-.129,.089)*g11_2+\n    mat4(.234,.279,.291,.554,-.0455,.427,-.0479,-.284,-.346,-.235,.295,.134,-.2,-.0199,-.231,-.202)*g11_3+\n    mat4(.0487,-.623,-.0842,.286,.347,.27,-.0801,.308,.592,-.0889,-.617,.106,.0944,.509,.259,-.0489)*g11_4+\n    mat4(-.178,-.419,-.513,.235,.251,.391,.043,.405,-.0659,.346,-.245,.45,.0351,.391,-.029,-.308)*g11_5+\n    vec4(-2.97,-3.07,-.697,-.574));\n    vec4 g13_0=sin(mat4(.126,.44,-.313,-.148,.579,.384,.04,.38,-.577,-.109,.304,.147,.454,-.249,-.476,-.336)*g12_0+\n    mat4(.0518,.102,-.286,-.154,.0926,.434,.341,-.0239,-.145,-.137,-.356,-.474,-.0611,-.127,-.439,-.378)*g12_1+\n    mat4(.499,.35,.25,.258,-.289,.475,.237,.103,.055,-.0536,.3,-.343,.243,.228,-.11,-.205)*g12_2+\n    mat4(-.403,.306,.0647,.0113,-.298,-.575,-.28,.153,.481,-.39,.329,.711,-.223,.0174,-.406,-.303)*g12_3+\n    mat4(-.352,.299,.568,-.12,.512,.525,.302,-.298,.13,.106,-.0819,-.295,-.157,.201,.464,-.0595)*g12_4+\n    mat4(-.455,.11,-.0199,-.204,.00292,.578,-.0791,-.0685,.0162,-.35,.419,.00616,-.173,.678,-.409,-.192)*g12_5+\n    vec4(.0851,-1.91,-3.64,-2.62));\n    vec4 g13_1=sin(mat4(-.151,.389,.264,-.281,-.228,-.307,.0425,-.398,.00986,-.338,.198,.0676,-.23,.17,.437,.482)*g12_0+\n    mat4(-.339,-.358,-.0377,-.164,-.298,-.41,.0821,-.429,.436,-.0634,.122,-.632,-.0368,-.344,-.475,-.0995)*g12_1+\n    mat4(.284,-.296,.477,-.403,.0813,.218,-.0966,-.604,-.182,.248,.413,.431,-.159,.0951,.257,-.187)*g12_2+\n    mat4(-.0976,-.148,-.654,.572,.152,-.376,.414,.312,-.0653,-.559,.125,-.00528,-.139,.491,.588,.0311)*g12_3+\n    mat4(.138,.477,-.168,-.267,-.0954,-.189,-.447,-.044,-.186,.371,.246,-.369,-.359,.507,-.213,.312)*g12_4+\n    mat4(.206,.234,-.256,.0205,-.313,.203,-.27,.0159,.514,.358,.0924,-.0253,-.149,-.14,.176,.166)*g12_5+\n    vec4(1.39,-.565,2.03,-2.89));\n    vec4 g13_2=sin(mat4(.303,-.026,.401,.348,.315,.354,.207,-.347,-.349,-.246,-.018,.353,-.521,-.00646,-.533,-.306)*g12_0+\n    mat4(.149,-.128,.0679,.49,.032,.0726,-.328,.326,-.0474,-.0287,.183,-.279,.00615,.333,.0866,-.116)*g12_1+\n    mat4(.425,.224,-.407,.0368,.653,-.573,-.371,.19,.347,-.448,.0174,-.00695,.171,-.389,.347,-.186)*g12_2+\n    mat4(.421,-.337,.328,.507,-.164,.171,.197,-.248,-.0603,-.19,-.101,.306,.207,-.209,.045,-.122)*g12_3+\n    mat4(.444,-.329,-.397,-.434,-.0605,-.0683,-.368,-.338,-.143,.428,-.4,-.268,.878,.16,-.735,-.349)*g12_4+\n    mat4(.371,-.143,.205,-.368,-.41,.679,.338,-.359,.265,-.52,.345,.0895,-.664,.0291,-.123,.296)*g12_5+\n    vec4(3.82,.024,2.03,-.0912));\n    vec4 g13_3=sin(mat4(.2,-.000558,.0154,-.21,-.348,-.28,.293,-.468,-.307,.02,-.203,-.111,.115,-.222,-.139,-.297)*g12_0+\n    mat4(.007,.521,-.112,-.239,.273,.158,-.192,.208,.308,-.465,-.318,-.144,-.332,.274,.21,.0205)*g12_1+\n    mat4(-.191,.371,-.487,-.288,-.281,.231,-.262,-.0128,.536,.21,-.2,.102,.124,-.15,-.277,.234)*g12_2+\n    mat4(.0684,.385,.221,-.103,-.0771,.014,.0513,-.167,.12,.385,-.263,.691,.0881,-.493,.0435,.0385)*g12_3+\n    mat4(.296,.205,.316,-.142,.347,.244,.485,.366,-.466,.0665,.174,-.796,.0559,.455,.0582,.0426)*g12_4+\n    mat4(-.325,-.186,-.496,-.332,-.0618,-.143,.104,.16,.0836,.0188,-.206,-.232,.196,.246,.134,-.309)*g12_5+\n    vec4(-3.78,-3.52,-3.92,-1.87));\n    vec4 g13_4=sin(mat4(.0532,.341,.23,.441,.452,.289,-.163,-.375,-.251,.524,-.119,.64,-.401,-.365,-.457,-.193)*g12_0+\n    mat4(.382,.0777,.235,.418,.00696,.0427,.511,.226,-.0447,.118,-.441,-.196,-.0981,-.419,.196,-.46)*g12_1+\n    mat4(-.141,-.133,-.0307,.13,-.144,.416,.204,-.252,.457,.058,-.467,.303,-.104,.328,-.438,-.248)*g12_2+\n    mat4(.171,-.133,.486,.131,.12,.62,-.428,.192,-.118,.0432,.43,.514,-.148,.333,.195,.155)*g12_3+\n    mat4(.177,.418,-.148,-.106,.186,.387,-.0195,-.23,.0594,.172,.172,-.525,.489,-.331,-.181,.106)*g12_4+\n    mat4(.133,.219,.203,-.434,.558,-.206,.502,-.0911,.39,-.0577,-.56,-.314,-.108,-.389,.406,-.555)*g12_5+\n    vec4(3.26,-3.64,3.15,-1.83));\n    vec4 g13_5=sin(mat4(-.218,.0513,-.133,.385,-.62,-.383,.391,.238,-.00803,-.274,.122,-.107,.241,.0932,.39,.133)*g12_0+\n    mat4(.394,.347,.24,.0464,.0574,.273,-.0588,.332,-.0045,-.244,.174,.235,.276,-.111,.205,-.692)*g12_1+\n    mat4(-.36,.569,-.374,.564,.0296,.151,-.641,.399,-.445,.407,-.17,-.273,.298,-.0455,-.242,.0131)*g12_2+\n    mat4(.51,.375,.54,.244,.232,.0414,.22,-.269,.375,-.159,-.191,-.639,.255,-.178,.23,.0616)*g12_3+\n    mat4(.477,.504,-.343,.141,.062,.444,-.434,-.00296,-.314,.582,.287,-.425,.199,-.175,.313,-.16)*g12_4+\n    mat4(.447,.263,.462,.406,.043,-.192,-.223,-.0102,-.456,.19,.252,-.249,-.369,-.443,.155,-.436)*g12_5+\n    vec4(2.49,-2.56,1.61,3.57));\n    vec4 g14_0=sin(mat4(.152,.421,.727,.117,-.445,.0936,-.309,-.165,-.2,.156,.381,-.294,-.561,-.379,-.0318,.435)*g13_0+\n    mat4(-.229,.19,-.618,-.391,.3,.142,.505,-.252,-.437,-.509,.391,-.483,.393,.354,.12,.174)*g13_1+\n    mat4(-.0755,.227,-.181,-.119,-.59,.624,-.195,-.234,.0431,-.0105,.0761,-.584,.484,-.362,.202,.372)*g13_2+\n    mat4(-.295,-.0427,.611,.0703,-.0768,-.197,-.14,.202,-.00532,-.341,-.138,-.146,.314,.48,.125,.773)*g13_3+\n    mat4(.468,-.87,.284,-.21,-.426,.396,.202,.178,.443,-.17,-.22,-.0439,-.387,.547,.444,.58)*g13_4+\n    mat4(-.314,-.436,-.244,.108,.342,-.152,-.442,.119,.512,-.118,-.231,.0976,.491,-.659,-.422,.0414)*g13_5+\n    vec4(-3.6,.17,3.9,-3.21));\n    vec4 g14_1=sin(mat4(-.202,.157,.108,-.297,.235,-.162,.201,-.283,.489,.152,-.41,.512,.083,.366,.439,-.687)*g13_0+\n    mat4(.527,.0641,-.472,.399,-.642,.117,-.335,.424,-.475,-.168,.0149,-.365,.161,.324,.0843,-.252)*g13_1+\n    mat4(-.439,-.106,-.221,-.577,.0852,.457,-.185,-.237,-.392,.363,.00994,.706,-.0749,-.285,-.351,.501)*g13_2+\n    mat4(.27,.322,-.0581,-.101,-.296,.254,-.0354,-.0183,.0193,.169,-.576,.365,-.21,-.0638,-.504,-.208)*g13_3+\n    mat4(-.0496,.284,.0772,-.414,-.586,-.0543,.176,.0326,-.122,.18,.469,-.224,-.496,.448,-.268,-.146)*g13_4+\n    mat4(.133,.442,.268,-.13,-.332,.105,-.274,-.562,.545,-.345,-.0672,-.184,-.298,-.571,.378,.379)*g13_5+\n    vec4(-3.36,1.68,-.206,1.22));\n    vec4 g14_2=sin(mat4(.0826,-.111,-.11,-.166,.237,-.343,-.443,-.448,.329,-.0664,-.0326,-.0114,.641,-.42,.437,.0912)*g13_0+\n    mat4(-.595,.0221,-.257,-.153,-.118,-.492,-.261,-.239,.109,.159,-.648,-.00466,-.245,-.557,.196,.354)*g13_1+\n    mat4(.0444,-.543,-.0466,.0307,-.167,-.37,.242,.0122,.16,-.0043,.121,.483,.292,.444,-.0746,.0473)*g13_2+\n    mat4(.0643,-.52,-.19,-.0939,-.189,.205,.357,.32,-.207,-.422,-.346,.195,.148,-.597,.151,.0978)*g13_3+\n    mat4(.283,-.361,-.433,.321,.762,-.387,-.438,.21,-.633,.843,-.0989,-.181,-.041,.29,.499,.0942)*g13_4+\n    mat4(-.466,.244,.384,.669,.244,-.13,-.458,.485,.0761,-.0973,-.144,.486,.157,-.288,.325,-.261)*g13_5+\n    vec4(-1.34,-1.47,-1.2,-2.93));\n    vec4 g14_3=sin(mat4(.0635,-.317,.462,-.395,.198,.172,-.0504,.243,-.127,.15,.225,.0685,.164,.443,.361,.0249)*g13_0+\n    mat4(-.0469,.348,-.222,-.417,-.187,.257,.554,.108,.529,-.573,-.38,-.268,-.577,-.158,.00727,-.547)*g13_1+\n    mat4(.517,-.0614,.0379,.0515,.176,.0141,.194,.245,.506,.458,-.33,-.131,.755,.0476,-.337,.652)*g13_2+\n    mat4(.0235,-.237,.587,-.312,-.416,.132,-.212,-.198,.215,.172,-.0206,-.247,-.156,-.448,-.255,.228)*g13_3+\n    mat4(.023,-.181,-.44,.399,.22,-.561,.323,-.242,.41,.0149,.31,-.298,-.138,-.6,-.0498,.0936)*g13_4+\n    mat4(-.245,.347,-.0923,-.431,.674,.193,.387,.548,-.101,-.0531,.149,.337,-.0749,-.548,.297,.0218)*g13_5+\n    vec4(2.46,.794,-.579,.568));\n    vec4 g14_4=sin(mat4(.393,-.384,-.315,-.811,-.395,.00562,.226,.0048,-.671,.0423,-.467,-.241,-.165,-.00823,.59,-.401)*g13_0+\n    mat4(.15,.456,-.564,.0534,-.0382,-.0928,-.534,.0906,-.567,.278,-.348,.207,-.477,.243,-.12,-.511)*g13_1+\n    mat4(-.215,.357,.0965,-.0177,.494,-.0101,.358,.0845,-.349,.553,.0703,.431,.104,.347,-.223,-.157)*g13_2+\n    mat4(.0913,-.179,.373,-.492,.282,.0971,.11,.0294,-.2,.305,.0931,-.135,.128,.0183,.189,-.0378)*g13_3+\n    mat4(.318,.415,-.37,.153,.414,-.406,.47,-.465,.374,.0666,-.212,-.165,.147,.183,.0312,-.328)*g13_4+\n    mat4(-.62,.363,-.000843,.184,.0731,-.202,-.172,-.0909,-.263,.0916,-.127,.207,-.51,.314,.137,-.127)*g13_5+\n    vec4(.651,2.26,3.44,1.32));\n    vec4 g14_5=sin(mat4(-.274,-.488,.0583,-.204,.0293,.446,.546,-.112,.0421,-.416,.117,.217,-.195,-.000141,.162,-.141)*g13_0+\n    mat4(-.321,.129,-.508,.357,-.42,.439,-.387,-.079,-.436,-.55,-.0208,-.249,.2,-.642,.27,.537)*g13_1+\n    mat4(-.152,-.00532,.524,.00692,.24,-.343,.194,.5,.00158,.307,.241,-.112,.161,.118,-.07,-.689)*g13_2+\n    mat4(.41,-.381,-.00344,.288,.143,-.328,.213,-.253,-.235,-.164,-.489,-.0386,.0515,-.138,-.355,-.298)*g13_3+\n    mat4(-.281,-.486,-.321,.338,-.324,.455,-.0459,.326,-.151,.188,-.341,.0824,-.366,-.0878,-.34,-.0865)*g13_4+\n    mat4(-.113,-.148,-.518,.551,.0313,-.385,.281,-.194,-.469,-.394,-.475,.131,-.359,.0749,.346,-.484)*g13_5+\n    vec4(3.72,-3.57,-2.71,3.84));\n    vec4 g15_0=sin(mat4(.377,.207,-.103,-.394,.142,-.196,-.251,-.0499,-.42,.274,.459,-.2,.0464,-.381,.289,-.264)*g14_0+\n    mat4(-.469,.0814,-.0831,.591,-.299,.146,-.209,-.522,.194,.424,.0121,.0741,.401,-.0815,.258,-.205)*g14_1+\n    mat4(.484,.0931,.15,.656,.331,.363,-.081,.0802,-.542,.337,-.294,.636,.221,.341,.211,.444)*g14_2+\n    mat4(.175,-.532,-.444,-.337,.084,-.334,.137,-.238,.361,.22,-.421,-.133,.259,.293,-.0562,-.127)*g14_3+\n    mat4(-.174,-.619,.43,.0129,-.261,-.588,-.0721,-.117,.524,-.0502,-.144,.403,-.314,-.243,-.364,.419)*g14_4+\n    mat4(.2,-.267,-.509,.574,-.276,-.0502,.222,-.223,.351,.336,-.14,-.391,-.186,.57,.0502,.366)*g14_5+\n    vec4(1.76,-.761,3.61,2.75));\n    vec4 g15_1=sin(mat4(.052,-.437,-.367,-.0412,-.381,-.237,-.458,.045,.318,.129,-.684,-.238,.38,.382,.554,.378)*g14_0+\n    mat4(.342,-.455,.544,-.217,.0713,.343,.331,.62,-.073,-.147,.449,-.177,-.42,-.412,-.327,.0792)*g14_1+\n    mat4(-.264,-.27,-.406,-.318,-.0898,-.166,-.271,.12,-.435,.164,.308,-.357,-.124,.341,-.172,-.308)*g14_2+\n    mat4(.334,-.335,.678,-.0522,.45,.242,.0809,.358,-.534,-.269,-.319,-.334,.54,-.00391,.38,.184)*g14_3+\n    mat4(.213,.227,.565,-.409,.474,.129,-.255,-.165,-.691,.323,.194,.07,-.155,-.0717,-.276,.465)*g14_4+\n    mat4(.104,-.637,-.495,-.0126,-.331,-.609,-.184,-.317,-.225,.548,.32,.5,-.237,-.528,.138,-.526)*g14_5+\n    vec4(-3.56,-.586,3.67,2.3));\n    vec4 g15_2=sin(mat4(.312,-.203,.342,-.331,-.0232,.502,.229,-.387,-.189,-.0377,-.378,.0215,.0937,-.262,-.236,-.05)*g14_0+\n    mat4(-.0224,-.264,.273,.492,.317,-.116,.482,.445,-.206,-.176,.0764,-.447,-.201,-.508,.175,-.132)*g14_1+\n    mat4(-.42,-.0169,-.187,-.323,.341,-.349,-.396,-.465,.237,-.249,.145,-.531,-.248,.249,.215,.0796)*g14_2+\n    mat4(-.414,.184,.489,-.339,-.125,.026,-.498,.382,-.205,.487,-.425,-.193,.316,-.532,.127,-.275)*g14_3+\n    mat4(-.0292,-.00772,.0407,.00712,-.317,.166,-.0352,.505,.0896,.347,-.117,.352,.379,.271,.267,.291)*g14_4+\n    mat4(-.539,-.256,-.214,-.0957,-.224,.0043,.05,.122,-.0888,-.292,.242,.0821,-.0471,-.2,-.348,.227)*g14_5+\n    vec4(1.65,-4.11,.64,3.54));\n    vec4 g15_3=sin(mat4(-.319,.198,-.607,.459,.561,.168,-.549,-.22,-.0616,.425,.149,-.245,.0965,-.538,-.41,.213)*g14_0+\n    mat4(-.175,.333,-.508,.111,.157,.0249,-.314,.268,-.561,-.141,-.0334,-.322,.37,.183,.587,-.535)*g14_1+\n    mat4(-.345,-.0187,-.323,-.421,-.332,.342,.164,-.0187,.258,.241,-.304,-.662,-.258,.397,.24,.365)*g14_2+\n    mat4(-.468,-.19,-.346,.317,-.281,-.249,-.651,-.621,.0766,.0362,.581,-.113,-.236,-.0708,.174,-.269)*g14_3+\n    mat4(.108,-.0492,-.11,-.109,.379,.103,.135,.425,-.0771,.141,.191,.0667,.308,.0167,.351,-.205)*g14_4+\n    mat4(-.377,-.253,.402,-.337,-.17,.217,.282,-.475,-.152,-.437,-.0292,.0607,.559,-.164,.0645,-.174)*g14_5+\n    vec4(-2.35,-4.07,1.02,-1.42));\n    vec4 g15_4=sin(mat4(.811,-.478,.119,-.368,.363,.432,-.236,.163,.108,.398,.118,-.284,-.632,-.0547,.0583,.381)*g14_0+\n    mat4(-.0778,.515,.47,-.245,.0902,-.193,-.0968,-.17,-.198,.204,.212,.343,-.337,-.104,-.118,-.191)*g14_1+\n    mat4(.126,-.176,-.565,.2,-.195,.134,.23,-.0327,.453,-.0371,-.539,-.167,.455,-.311,-.529,-.304)*g14_2+\n    mat4(-.00253,.182,-.349,-.097,-.39,-.358,.0185,.485,-.115,.536,.0803,-.501,-.256,-.00789,.243,.239)*g14_3+\n    mat4(.199,-.018,-.116,.213,-.0229,-.387,-.265,.311,-.552,-.0406,.128,-.0748,.395,-.153,.00666,.269)*g14_4+\n    mat4(.331,.305,.408,.314,-.323,-.0954,.0603,-.428,-.0172,-.55,.22,.0867,.496,.0317,.494,-.51)*g14_5+\n    vec4(3.53,3.42,-3.08,-.113));\n    vec4 g15_5=sin(mat4(.171,-.223,-.205,.193,.0536,-.144,-.123,.152,.167,-.175,-.271,.325,.547,.346,-.129,-.021)*g14_0+\n    mat4(-.652,-.0127,-.231,.375,-.484,-.0978,-.103,.362,.178,.52,-.385,-.133,-.121,-.514,.124,-.496)*g14_1+\n    mat4(.165,-.532,-.00603,-.165,-.249,-.0645,.383,.0962,.274,-.0341,.2,.458,-.394,.237,.166,.49)*g14_2+\n    mat4(-.277,-.573,-.323,-.363,.306,-.425,-.0854,.35,-.205,.29,.178,.117,.145,.576,.271,-.222)*g14_3+\n    mat4(-.282,.301,.0768,.294,-.135,.173,-.186,-.439,.0544,-.0368,-.253,-.266,.0316,-.0478,.42,-.0467)*g14_4+\n    mat4(.0683,-.109,.597,.199,.111,-.28,.469,-.379,.421,.262,.418,-.286,.535,.337,-.406,-.568)*g14_5+\n    vec4(1.99,2.51,1.49,2.25));\n    vec4 g16_0=sin(mat4(.244,.267,-.466,-.0613,-.201,-.286,.338,-.213,.369,.293,.255,-.133,-.359,.409,-.681,-.367)*g15_0+\n    mat4(-.0611,.678,.336,.115,.0205,-.413,-.098,.113,-.473,.528,.625,-.333,-.472,-.307,-.286,.348)*g15_1+\n    mat4(-.378,.285,.218,-.0979,-.199,-.268,-.206,-.348,.36,-.441,-.576,-.0367,.0179,.392,-.0568,.215)*g15_2+\n    mat4(.383,-.173,.486,.804,-.196,.241,-.244,-.376,.123,.069,-.313,.164,-.0123,.743,-.173,.454)*g15_3+\n    mat4(.192,-.608,-.0882,.0595,-.326,.048,-.214,.327,.342,-.263,.427,.0978,.269,.0459,-.345,.0378)*g15_4+\n    mat4(.0869,-.516,-.383,-.302,-.0272,-.252,.221,-.208,.0436,.299,-.206,.372,-.276,-.452,-.527,.138)*g15_5+\n    vec4(1.92,-2.01,3.19,-.853));\n    vec4 g16_1=sin(mat4(.239,.476,.357,.395,-.402,.0328,-.274,.419,-.326,-.0282,-.492,.161,.164,.555,.305,.357)*g15_0+\n    mat4(-.336,.529,.14,.253,.531,-.104,.411,.138,-.1,-.109,.407,.0345,-.356,-.514,-.235,.385)*g15_1+\n    mat4(.0122,.463,-.107,-.304,-.229,.164,-.0902,.309,-.336,.441,-.12,-.304,.301,-.206,-.401,.356)*g15_2+\n    mat4(.00929,-.389,-.571,.133,-.0751,-.137,.242,-.458,-.45,.241,-.22,.233,-.585,-.431,-.241,-.168)*g15_3+\n    mat4(-.225,-.0752,.702,.308,.53,.543,-.0662,-.289,-.001,.402,.364,-.429,.478,-.0159,-.136,-.0795)*g15_4+\n    mat4(.00201,-.0943,-.215,-.297,.177,.271,.214,-.24,-.0392,.472,.443,.432,.455,.324,-.21,-.187)*g15_5+\n    vec4(3.14,3.2,.894,2.06));\n    vec4 g16_2=sin(mat4(.37,.659,.45,.314,.587,-.662,-.298,.395,-.222,.493,-.495,-.222,-.407,.552,-.0659,.201)*g15_0+\n    mat4(.477,-.425,.325,-.133,-.367,-.544,-.0353,-.492,.408,-.268,.16,-.0246,.485,-.377,.0957,.328)*g15_1+\n    mat4(-.16,.0887,-.322,-.311,.396,-.228,-.178,-.363,.292,.398,.455,-.261,.188,-.467,.21,.0374)*g15_2+\n    mat4(-.000757,.167,.346,.256,.466,-.109,-.326,.482,.102,.165,.787,-.632,-.336,-.565,.109,.0795)*g15_3+\n    mat4(-.504,.0864,.0163,.0735,.166,.518,-.551,-.364,.342,-.0121,-.468,-.181,-.195,.518,.243,.307)*g15_4+\n    mat4(.188,.0495,-.235,.266,-.141,.479,-.405,-.433,.0816,.603,.1,.316,.251,.618,-.408,-.593)*g15_5+\n    vec4(-1.53,2.23,1.25,1.26));\n    vec4 g16_3=sin(mat4(.0666,.111,.148,.705,-.197,.14,-.146,.119,-.55,.0471,-.146,-.383,.00176,.699,-.124,.335)*g15_0+\n    mat4(.43,.174,-.209,-.552,-.0105,.127,-.165,-.092,-.291,-.0164,-.354,.126,.177,-.0863,-.597,-.167)*g15_1+\n    mat4(.102,.607,-.00621,.179,.214,.314,.0944,.482,.0322,.0113,.244,-.344,-.0704,-.557,-.423,-.237)*g15_2+\n    mat4(.203,.185,.309,.0355,-.165,.476,-.129,.419,.628,.66,-.627,.295,-.385,.058,-.453,-.498)*g15_3+\n    mat4(.522,.0367,.0992,.464,-.0524,-.0318,-.141,-.0438,-.276,.0813,-.312,.449,.19,.049,.379,.389)*g15_4+\n    mat4(-.21,-.113,.37,.0912,.587,.653,-.18,-.329,.133,.633,-.391,-.285,-.185,.34,.499,.64)*g15_5+\n    vec4(-2.74,-2.49,-3.73,.596));\n    vec4 g16_4=sin(mat4(-.11,-.0506,-.575,-.431,-.356,-.026,.62,.428,.211,-.138,.14,.213,-.0463,-.15,.163,-.502)*g15_0+\n    mat4(.195,.492,.322,.403,.0613,.379,-.321,.414,-.356,.356,.0237,.462,.194,-.0809,.322,.0947)*g15_1+\n    mat4(.0618,-.589,-.471,-.217,.366,.271,-.466,-.515,-.242,-.142,-.0624,-.35,-.0158,.356,.0651,.469)*g15_2+\n    mat4(.429,.579,.101,-.199,.227,-.393,-.308,-.161,.336,.247,.27,.238,-.594,.578,-.259,-.0745)*g15_3+\n    mat4(.123,-.274,-.263,.397,-.0393,.199,-.108,-.446,-.0784,.164,.439,-.431,-.324,.192,-.298,.109)*g15_4+\n    mat4(.282,-.548,-.381,.0403,-.0557,.136,.302,.0704,-.218,-.596,-.475,-.513,-.193,-.382,.0178,.0485)*g15_5+\n    vec4(3.39,-3.59,3.45,2.74));\n    vec4 g16_5=sin(mat4(-.432,.411,-.353,.474,.291,.000192,-.0256,-.272,-.155,.195,.388,-.673,.229,-.0162,-.551,-.15)*g15_0+\n    mat4(.066,-.274,.0898,.525,-.513,-.375,-.328,-.538,.00666,-.356,.0917,-.0147,.285,-.0603,-.379,.357)*g15_1+\n    mat4(-.186,-.529,-.749,-.143,.562,.162,-.455,.14,-.343,.386,-.641,.211,-.255,-.281,.251,.0818)*g15_2+\n    mat4(-.105,-.118,.381,-.316,.027,.635,-.502,.0825,.331,.281,-.345,.236,.0667,.271,-.355,-.473)*g15_3+\n    mat4(.258,-.359,-.29,.189,-.395,.314,-.566,.473,-.307,-.26,.332,.536,-.403,.112,-.66,.439)*g15_4+\n    mat4(-.269,.212,-.668,-.0405,-.604,.363,-.151,.484,-.127,-.0369,.0565,.736,-.214,-.162,-.121,.0479)*g15_5+\n    vec4(1.5,-1.69,-1.59,-1.56));\n    vec4 g17_0=sin(mat4(-.374,-.258,-.0922,.254,-.35,-.45,.167,.428,-.335,-.146,.544,.443,-.705,-.105,-.442,-.127)*g16_0+\n    mat4(.289,-.106,-.268,.397,.244,-.413,.254,-.485,-.0812,.525,.553,.215,.0504,-.393,.506,-.282)*g16_1+\n    mat4(-.613,.132,-.0457,.00436,-.467,-.178,-.732,.351,.0656,.41,.592,-.0439,.272,-.114,-.211,-.193)*g16_2+\n    mat4(.247,.327,.00505,-.395,-.248,-.496,-.0766,.253,-.247,-.0875,.119,-.264,.656,-.00808,.541,.244)*g16_3+\n    mat4(.566,-.0713,.285,-.301,.188,-.186,.138,-.339,.0798,-.205,.311,.231,.194,-.275,.339,.486)*g16_4+\n    mat4(-.396,.00254,.093,.114,-.196,-.137,-.0234,-.0873,-.0867,.311,.602,.158,-.107,-.0926,.251,.272)*g16_5+\n    vec4(2.12,-2.05,-2.33,-2.51));\n    vec4 g17_1=sin(mat4(-.457,.335,-.477,-.405,.216,-.512,-.135,.387,.331,.485,-.391,-.462,-.289,.34,-.263,.21)*g16_0+\n    mat4(-.402,-.477,.307,.593,-.307,-.519,.0121,-.143,.137,.0743,-.018,-.456,-.162,.0709,.327,-.34)*g16_1+\n    mat4(-.0201,-.18,.228,.497,-.00694,.397,.458,.107,-.527,.497,-.419,-.133,.394,-.186,.000889,-.253)*g16_2+\n    mat4(-.313,.00946,.025,.737,-.135,-.11,.512,.611,.319,-.204,-.666,.396,-.154,.365,-.00678,-.227)*g16_3+\n    mat4(.53,.0118,.121,-.511,-.552,.628,-.144,-.456,-.324,-.0291,.723,.331,-.417,.113,-.0813,-.434)*g16_4+\n    mat4(-.43,.517,.527,-.445,-.0477,-.243,-.0688,.264,-.257,.454,-.18,-.0428,-.385,.107,-.163,.341)*g16_5+\n    vec4(1.16,.125,2.51,-2.56));\n    vec4 g17_2=sin(mat4(-.391,.128,.336,-.148,.0767,-.122,-.302,.0447,.181,-.323,-.337,-.0295,-.0576,-.322,.406,.101)*g16_0+\n    mat4(-.242,-.25,.2,.385,.448,-.0571,-.163,.125,.447,.622,.359,-.125,.09,-.485,.546,-.176)*g16_1+\n    mat4(-.0863,.146,.303,-.371,.442,.226,.126,.0875,.24,-.16,.121,-.0785,-.567,-.519,.512,-.61)*g16_2+\n    mat4(.278,-.221,-.0764,.185,.0912,-.286,.363,-.207,.304,-.355,-.248,.0776,.055,.566,-.245,-.151)*g16_3+\n    mat4(.348,.277,.291,-.641,.162,-.0114,.11,.0493,.44,-.296,-.457,.0149,.349,.158,-.0261,.2)*g16_4+\n    mat4(-.105,-.359,.235,.186,.388,-.349,-.454,-.398,-.447,-.302,-.309,-.27,-.112,-.158,-.361,.71)*g16_5+\n    vec4(-1.89,-2.81,-2.26,-1.99));\n    vec4 g17_3=sin(mat4(.376,.362,-.487,.0804,-.213,.0776,.0957,.193,.518,-.262,.0854,.0332,.33,.271,-.0219,.451)*g16_0+\n    mat4(.291,-.302,-.346,.416,.27,.453,-.109,-.181,.0992,.268,-.385,-.2,.259,-.218,-.513,-.136)*g16_1+\n    mat4(.473,-.209,-.134,-.207,-.532,.144,.27,-.132,.373,.212,-.4,.0587,-.247,.2,-.449,-.493)*g16_2+\n    mat4(-.261,.0328,.174,.432,-.0223,-.396,.395,.398,-.147,-.215,.0986,.152,.0144,.23,-.181,-.39)*g16_3+\n    mat4(-.45,.203,-.412,.343,-.244,-.466,.34,.299,-.394,-.124,-.17,-.0724,.259,-.0964,-.473,.415)*g16_4+\n    mat4(.161,-.508,-.328,-.234,-.163,.55,.642,-.28,.374,.0911,.398,-.317,.102,.128,.113,-.312)*g16_5+\n    vec4(-2.9,2,-.288,-.928));\n    vec4 g17_4=sin(mat4(-.497,-.178,.0336,-.467,.114,.397,.308,-.326,-.451,-.376,-.385,-.187,-.142,.0106,-.0368,-.185)*g16_0+\n    mat4(-.433,-.137,-.406,.56,-.324,-.0646,.455,-.353,-.454,.252,-.0463,.0499,-.377,-.251,-.0622,-.518)*g16_1+\n    mat4(-.293,-.151,-.178,-.388,.283,-.353,-.573,.639,.14,.389,.0556,-.443,-.511,-.084,.351,-.157)*g16_2+\n    mat4(.6,-.464,.404,.0613,-.196,.0664,.542,-.175,-.398,-.178,-.611,-.409,-.0357,-.247,.311,-.517)*g16_3+\n    mat4(-.584,.101,-.0258,-.0713,-.175,-.402,-.588,-.285,-.275,.368,.145,-.0863,-.664,.436,-.0686,-.176)*g16_4+\n    mat4(-.368,.278,.341,-.57,.579,.433,.329,.147,.377,.0815,-.341,-.354,-.165,.325,.097,-.0489)*g16_5+\n    vec4(2.32,2.62,1.67,-.657));\n    vec4 g17_5=sin(mat4(-.228,.711,.212,.082,.659,-.719,-.521,-.385,-.143,-.29,.433,-.463,.457,-.359,.1,-.761)*g16_0+\n    mat4(-.302,-.75,-.64,.516,-.499,-.314,-.655,.28,-.755,.031,-.141,.178,-.228,.133,-.343,-.00188)*g16_1+\n    mat4(-.205,-.55,.106,.331,.144,-.597,.169,.187,-.0614,-.323,-.132,.129,-.175,-.261,.347,.275)*g16_2+\n    mat4(.417,-.32,-.42,-.287,-.284,-.762,-.0801,.566,.274,-.196,-.0345,-.489,-.206,.351,.358,-.198)*g16_3+\n    mat4(-.495,.439,-.127,-.237,-.185,.000843,-.338,-.594,.192,.139,.163,-.417,-.56,.516,.369,-.402)*g16_4+\n    mat4(-.0875,-.393,.653,.206,-.263,.345,-.0249,.437,.16,-.072,.283,.00855,.071,-.726,-.603,.417)*g16_5+\n    vec4(.454,-2.36,-1.64,1.23));\n    vec4 g18_0=sin(mat4(.222,.539,-.154,.372,.477,-.345,-.103,.246,-.148,-.333,-.00188,.292,.233,-.25,-.415,.479)*g17_0+\n    mat4(.00321,.529,.637,.272,-.354,.229,.637,-.0225,-.579,.227,-.0582,.114,-.0394,.375,.24,.305)*g17_1+\n    mat4(.46,.181,.0599,.0779,.418,-.0986,-.508,.00149,-.314,.277,-.0371,-.509,.0703,-.399,-.531,-.423)*g17_2+\n    mat4(.584,-.0441,.351,-.139,-.674,.166,.00752,.0831,.312,.293,-.373,-.00699,.417,-.112,-.445,.261)*g17_3+\n    mat4(-.612,.317,.146,.186,-.458,.207,.413,-.182,-.108,.444,.631,.422,.575,-.582,-.531,-.171)*g17_4+\n    mat4(-.168,.0485,.473,-.247,.46,-.378,.223,-.215,.656,-.116,.144,-.0534,.207,-.159,.0607,.457)*g17_5+\n    vec4(-1.81,-1.33,2.28,-.142));\n    vec4 g18_1=sin(mat4(-.135,.5,.319,-.407,.299,-.0977,.311,.0178,.849,-.408,.12,.299,-.0552,-.39,.213,-.133)*g17_0+\n    mat4(.0307,.54,.185,-.148,-.492,-.179,.379,.535,-.527,.605,.178,-.018,-.128,.193,.543,.427)*g17_1+\n    mat4(-.097,-.518,-.378,-.204,.0241,-.0508,.108,.549,.422,-.196,-.442,-.471,.413,-.222,.11,-.111)*g17_2+\n    mat4(.599,-.311,-.276,-.476,-.256,-.386,-.191,-.224,.738,-.251,-.0883,-.327,.755,-.0256,-.847,.247)*g17_3+\n    mat4(-.322,.0142,.631,-.0638,-.565,.094,-.23,-.402,.289,.249,.395,-.163,.599,.387,.119,.243)*g17_4+\n    mat4(.428,.265,-.24,.00549,.641,-.508,.391,.0711,.401,-.0204,-.0809,.0466,-.0242,-.26,.0892,.819)*g17_5+\n    vec4(-1.48,-.257,-.941,-2.99));\n    vec4 g18_2=sin(mat4(-.388,-.41,.192,-.444,.146,.493,.632,.966,.544,.0469,-.0105,.751,.594,.168,-.0249,.593)*g17_0+\n    mat4(.613,-.495,-.384,-.472,.106,-.73,.0173,-.306,.352,.0969,-.432,-.364,-.0233,-.357,-.137,-.304)*g17_1+\n    mat4(-.714,-.0783,.149,.259,.114,-.207,-.123,.627,-.389,.572,-.25,.379,.0795,.27,-.253,.119)*g17_2+\n    mat4(-.141,.187,.267,-.469,.324,-.641,-.27,-.448,.165,.042,-.287,.364,-.229,-.106,.622,.563)*g17_3+\n    mat4(.097,-.66,-.544,-.418,.678,-.0624,-.00695,-.0559,.286,-.000824,-.385,-.636,-.161,.582,.181,.388)*g17_4+\n    mat4(.5,.368,-.366,-.306,.0421,-.237,-.208,.438,.201,-.305,.319,-.252,.118,.0806,.12,.061)*g17_5+\n    vec4(-.954,-4.16,.602,-3.29));\n    vec4 g18_3=sin(mat4(-.56,.659,-.502,-.525,.0288,.196,-.226,-.224,-.143,.624,.332,.668,.015,-.192,-.654,-.308)*g17_0+\n    mat4(-.355,.233,-.279,-.388,-.226,.467,.577,-.26,-.44,.223,.42,.0175,-.178,-.125,-.139,.171)*g17_1+\n    mat4(.355,.287,-.343,.703,.331,.219,.284,-.123,.153,-.158,-.253,.206,.305,.139,-.788,-.0271)*g17_2+\n    mat4(-.0862,-.212,-.449,.252,-.374,.351,.254,.152,.495,.386,.332,.393,-.173,-.118,-.123,-.179)*g17_3+\n    mat4(.0312,-.666,-.175,-.373,-.717,-.69,.621,.201,-.454,.305,.106,-.2,-.229,-.013,.279,.832)*g17_4+\n    mat4(-.282,-.0776,.715,.387,.416,.484,-.798,-.346,.577,.783,-.44,-.196,-.00792,.126,-.168,.211)*g17_5+\n    vec4(-2.41,3.21,-2.28,-.0516));\n    vec4 g18_4=sin(mat4(.017,-.0036,-.24,-.0895,.342,.478,.18,.378,.345,.194,.892,.315,-.158,.314,-.196,.417)*g17_0+\n    mat4(-.342,-.182,-.531,.455,-.0784,.299,.156,-.0375,-.526,-.314,.181,.357,-.664,.179,-.22,.458)*g17_1+\n    mat4(.875,.448,-.029,-.25,.294,-.221,-.0701,.515,.334,-.337,.0372,-.332,-.013,-.263,-.167,-.0482)*g17_2+\n    mat4(-.179,.69,-.424,-.214,-.0954,-.231,-.122,-.0922,.384,.292,.429,.296,.469,.114,-.133,-.362)*g17_3+\n    mat4(-.163,-.231,.495,-.0105,-.109,.1,.13,.0433,.489,-.175,-.446,-.0895,.697,-.179,-.0767,-.201)*g17_4+\n    mat4(.291,.0369,-.112,-.337,-.556,-.373,-.255,.123,.207,.172,-.204,-.0876,.824,.363,.314,.199)*g17_5+\n    vec4(-.874,-2.36,-3.74,-1.56));\n    vec4 g18_5=sin(mat4(.117,-.345,.38,-.0684,-.229,.192,-.118,-.0482,.387,-.0542,.609,-.609,.373,.274,-.167,.0756)*g17_0+\n    mat4(-.385,-.524,.0644,-.143,-.541,.17,.442,.578,-.266,.1,.274,-.0689,.043,-.688,-.146,.35)*g17_1+\n    mat4(-.162,.628,-.231,-.437,.476,-.224,.258,.305,-.0563,.272,.264,-.622,-.159,-.481,.0396,.167)*g17_2+\n    mat4(-.463,-.00645,.415,.125,-.373,-.547,-.176,.381,-.00323,.219,-.28,-.326,-.00354,-.294,-.358,.308)*g17_3+\n    mat4(-.333,.417,.587,.627,.275,-.286,-.128,.32,-.336,-.282,.421,.624,.479,-.114,.162,-.53)*g17_4+\n    mat4(-.535,.152,-.49,.619,-.198,.246,.426,-.337,-.344,.24,.287,-.461,-.239,-.0123,-.00474,.158)*g17_5+\n    vec4(-.0623,-3.63,-2.65,-3.87));\n    vec4 g19_0=sin(mat4(-.217,-.198,.359,-.408,.0497,.135,-.795,.37,-.473,-.266,.139,.197,-.103,-.648,.0318,-.33)*g18_0+\n    mat4(-.00103,.206,.612,-.0872,.566,-.0381,-.628,-.253,-.399,-.483,.708,-.263,.277,.602,-.12,.54)*g18_1+\n    mat4(-.217,-.197,.863,.126,-.245,.509,.392,-.664,.62,.658,-.0522,-.0858,-.444,.555,.19,-.357)*g18_2+\n    mat4(-.168,.249,.203,-.423,-.449,.597,-.0163,-.391,-.692,.219,.307,.738,.108,.243,.316,.344)*g18_3+\n    mat4(-.111,.162,-.0085,.149,-.468,-.163,.355,.183,.337,-.298,-.037,-.407,-.101,.876,.614,.273)*g18_4+\n    mat4(.125,.5,.213,-.434,.166,-.108,-.0128,-.183,-.113,-.24,-.223,.453,.223,.15,.236,.705)*g18_5+\n    vec4(4.08,3.48,-3.07,1.72));\n    vec4 g19_1=sin(mat4(.534,.376,-.06,.76,-.566,-.0102,-.000254,.305,.348,.19,-.0219,-.31,-.188,-.125,.125,-.378)*g18_0+\n    mat4(.352,.66,.404,.56,-.281,-.208,.0109,-.352,-.18,.0901,.44,-.0298,-.226,-.308,.701,-.0552)*g18_1+\n    mat4(.455,.195,-.364,.0125,-.176,-.493,-.142,.685,-.122,-.543,-.507,-.245,-.268,-.698,.0535,.114)*g18_2+\n    mat4(-.158,-.419,-.432,.698,-.371,.427,-.266,-.439,.541,-.644,-.0048,.225,.109,-.53,.183,.172)*g18_3+\n    mat4(.183,.566,-.416,.513,.11,.527,.146,.253,.106,.781,-.0812,.603,-.249,-.47,.183,-.197)*g18_4+\n    mat4(.346,-.067,.301,.311,-.311,-.558,-.302,.366,-.34,-.235,-.418,-.301,-.0957,-.074,.746,.474)*g18_5+\n    vec4(2.48,-3.4,-.89,-.207));\n    vec4 g19_2=sin(mat4(-.39,.386,-.342,.439,.283,-.282,.327,.396,.0813,-.416,.322,.0942,-.53,.315,.176,-.255)*g18_0+\n    mat4(-.541,.305,.147,.497,-.396,.532,-.434,.335,-.534,-.0337,.544,-.408,.31,-.311,-.248,-.493)*g18_1+\n    mat4(.139,.132,.564,-.531,-.0879,.388,-.352,.544,.161,-.0847,.178,.425,-.0804,-.0196,-.262,-.179)*g18_2+\n    mat4(-.589,.795,-.808,-.197,-.106,.302,.00409,.825,-.123,-.0786,.544,.221,.073,-.145,-.0719,-.109)*g18_3+\n    mat4(.201,.307,-.149,-.429,.585,-.151,.329,-.154,-.58,-.0833,.464,.367,.074,-.568,.747,-.282)*g18_4+\n    mat4(.124,.409,.147,.402,-.403,.602,-.0987,-.116,-.0685,-.742,.462,-.0362,-.223,-.21,.257,-.0461)*g18_5+\n    vec4(.815,-.0765,.829,2.22));\n    vec4 g19_3=sin(mat4(.325,-.855,.619,-.2,.264,-.41,.426,-.37,.0232,.225,.0439,.398,.703,.114,.0929,-.569)*g18_0+\n    mat4(.0247,-.488,-.321,.0438,.772,.0453,.544,-.395,.0962,-.034,.274,.204,-.768,.569,.154,.262)*g18_1+\n    mat4(-.333,.296,-.509,.0781,.12,-.0286,-.362,-.45,-.153,.476,-.113,-.242,.508,-.309,.0255,-.301)*g18_2+\n    mat4(.586,.0629,-.206,-.382,-.244,.0253,.0133,.0313,.335,.432,.0963,.302,-.394,.676,-.449,.43)*g18_3+\n    mat4(-.212,-.224,-.144,.374,.431,.12,-.23,.0647,.0534,-.451,-.218,-.16,.0284,.421,-.457,.275)*g18_4+\n    mat4(.224,-.0166,-.337,.284,.126,-.23,.228,.674,-.413,.454,-.0648,-.0259,-.409,.328,.185,-.0193)*g18_5+\n    vec4(-.568,2.58,2.06,.34));\n    vec4 g19_4=sin(mat4(-.132,.481,-.252,-.301,-.0802,-.0685,.382,.527,.0549,-.495,-.00478,-.293,.212,.42,.433,.511)*g18_0+\n    mat4(.269,-.73,.294,.346,.0651,.336,.00878,.157,-.274,-.581,-.611,.239,-.336,.0732,.347,-.128)*g18_1+\n    mat4(-.0492,-.244,.00665,-.501,.054,.0761,.0296,-.255,.0645,-.415,.357,.0981,-.142,.0741,-.0738,.33)*g18_2+\n    mat4(.203,.296,.245,.316,-.517,.116,-.496,.542,.214,-.487,-.134,.163,.0186,-.23,.228,-.612)*g18_3+\n    mat4(-.108,-.765,-.219,.283,.108,.0605,.431,-.225,.199,.449,-.196,.381,-.159,-.585,-.0277,-.341)*g18_4+\n    mat4(.542,-.0137,.0864,-.485,-.00504,.0554,-.337,.233,.1,-.538,.034,.556,.12,.486,.0115,-.168)*g18_5+\n    vec4(1.44,3.6,-2.2,-2.15));\n    vec4 g19_5=sin(mat4(.193,.299,.608,.677,.0175,.518,.148,.732,-.35,-.582,.436,-.293,-.0536,.113,-.202,.279)*g18_0+\n    mat4(-.0259,.473,.15,.0133,-.5,.672,-.448,-.197,.0267,-.377,.214,.51,.39,.484,-.218,-.675)*g18_1+\n    mat4(.00912,.38,-.345,-.278,-.361,.247,-.14,-.392,-.171,-.31,.0586,-.463,-.103,-.391,.171,-.288)*g18_2+\n    mat4(-.339,.139,.144,-.0863,-.194,.455,-.193,-.215,-.401,.0947,-.181,-.428,-.14,-.25,-.0744,-.571)*g18_3+\n    mat4(.407,-.534,-.801,-.0746,.34,-.0406,.136,.386,-.0122,.198,-.596,-.192,-.15,-.296,-.0725,-.332)*g18_4+\n    mat4(-.584,-.0713,.367,-.16,.165,.172,-.416,.426,-.392,.115,.12,.043,.261,-.438,-.375,-.596)*g18_5+\n    vec4(2.51,-2.44,-3.41,2.08));\n    vec4 g20_0=sin(mat4(-.124,-.0578,-.055,.375,.408,.28,-.102,.527,.505,-.427,-.513,-.333,.224,.0221,.618,.527)*g19_0+\n    mat4(-.0829,-.583,.0699,.134,-.0882,.437,.746,-.486,.0554,.472,.138,.478,.275,-.234,-.128,-.0252)*g19_1+\n    mat4(-.0275,-.157,.373,.289,.438,-.299,-.0739,-.181,.304,.292,.386,-.173,-.572,.499,.00983,.51)*g19_2+\n    mat4(-.0426,-.87,-.425,.227,.0724,.133,.356,.432,-.262,-.619,-.0853,-.435,-.357,.502,.459,.0495)*g19_3+\n    mat4(.139,-.834,-.754,-.135,.322,.00646,.469,.0432,.31,-.181,-.105,-.0706,-.392,-.17,-.281,-.156)*g19_4+\n    mat4(-.331,.342,.103,-.516,.297,.488,.542,-.13,.438,-.134,-.0106,.0516,-.225,-.679,-.308,.00648)*g19_5+\n    vec4(-3.68,-.378,-3.32,-3.77));\n    vec4 g20_1=sin(mat4(-.0398,-.202,.508,-.289,-.0575,.0548,.175,.913,-.485,-.468,-.76,.896,.102,-.619,-.111,-.116)*g19_0+\n    mat4(.276,-.482,.577,.326,-.224,-.0273,.841,-.845,-.023,-.356,-.224,.278,.00334,.17,-.068,-.536)*g19_1+\n    mat4(.0643,-.217,-.111,.112,-.0958,-.146,.589,-.146,.00386,-.0414,-.436,.31,.163,-.507,-.021,.489)*g19_2+\n    mat4(.174,.559,-.281,-.669,-.0759,.709,.482,-.353,.454,.404,.582,-.334,-.389,-.125,-.423,.0627)*g19_3+\n    mat4(.127,.292,.651,-.223,-.553,-.00413,-.121,-.168,.131,.118,-.0899,.344,-.0444,-.163,-.631,.262)*g19_4+\n    mat4(.567,-.194,-.214,.419,.105,.014,-.193,.63,.287,.435,-.836,-.286,-.216,-.445,.458,-.344)*g19_5+\n    vec4(-2.1,-.36,1.34,1.27));\n    vec4 g20_2=sin(mat4(.238,.123,.0671,-.29,-.312,-.556,.298,.0644,.285,-.226,.127,-.361,-.39,.281,.205,.691)*g19_0+\n    mat4(-.4,-.0855,-.387,-.329,.56,-.026,.112,.773,.375,-.558,-.507,-.316,-.206,.00709,.00923,-.236)*g19_1+\n    mat4(.331,.386,.223,-.351,-.454,-.649,.202,.277,.275,-.456,.305,.582,.418,-.0114,.112,-.0623)*g19_2+\n    mat4(-.00534,-.69,.0837,-.482,.217,.12,.146,.478,.674,.723,.552,.662,-.179,.125,-.324,-.13)*g19_3+\n    mat4(-.424,.0132,.521,.492,.241,.153,-.17,.0676,-.0493,-.315,-.062,-.0501,.179,-.166,-.178,-.641)*g19_4+\n    mat4(.524,.00674,.509,-.245,-.501,-.534,-.348,.355,-.844,-.32,.00292,-.722,-.0331,.83,.178,.377)*g19_5+\n    vec4(.763,3.72,4.01,-3.34));\n    vec4 g20_3=sin(mat4(.688,.338,-.704,-.063,.0687,.237,-.206,-.599,.132,.369,-.457,-.551,.688,-.0252,-.685,.0768)*g19_0+\n    mat4(.396,-.252,.0165,-.255,.106,-.205,-.366,.396,.813,.0949,.262,-.277,.451,-.247,.37,.0863)*g19_1+\n    mat4(.819,.444,-.0667,.0675,-.267,-.129,.686,.272,-.499,.201,.285,.0671,.333,-.981,.263,-.299)*g19_2+\n    mat4(-.886,.26,.313,.0199,-.518,.461,-.0102,.761,-.742,.589,-.00486,.279,.478,-.454,-.353,.227)*g19_3+\n    mat4(-.796,-.333,.039,-.584,.292,-.508,-.601,-.0239,.224,-.503,-.493,.293,.412,.0578,.26,-.304)*g19_4+\n    mat4(-.68,.71,.34,-.373,.296,-.0271,-.321,.345,-.303,-.719,-.503,.535,-.389,.0124,.258,.556)*g19_5+\n    vec4(-1.55,-.0497,-2.82,3.53));\n    vec4 g20_4=sin(mat4(-.343,.482,.136,-.0705,.856,.0349,.0754,-.578,.0649,-.0769,-.0918,.141,-.0475,.262,.389,-.528)*g19_0+\n    mat4(.459,-.544,-.204,-.469,-.673,-.693,-.735,.178,-.11,.322,-.0121,-.69,-.117,.223,-.0407,-.218)*g19_1+\n    mat4(-.325,.277,.111,-.309,.344,-.548,-.16,-.0702,.00933,-.169,-.329,-.239,.806,.133,-.352,-.159)*g19_2+\n    mat4(-.512,-.0274,-.0918,-.0507,-.107,-.316,-.818,.548,-.186,-.321,-.745,.527,.207,.0745,.773,.15)*g19_3+\n    mat4(.318,-.61,-.0453,.569,.125,-.255,.486,.118,.292,.138,.107,-.093,.24,.243,.168,-.338)*g19_4+\n    mat4(-.501,.163,-.28,.389,-.272,-.343,.514,-.611,.117,.391,-.255,-.1,-.228,.0793,-.813,.0321)*g19_5+\n    vec4(-2.97,-.541,-2.51,-.992));\n    vec4 g20_5=sin(mat4(.0148,.594,-.158,.808,.334,.278,.0136,.684,.7,-.257,.285,-.22,-.324,.24,-.342,.334)*g19_0+\n    mat4(.317,-.145,.0595,-.54,-.83,-.219,-.343,.00595,-.205,.259,.119,.924,.252,-.236,-.0344,.0147)*g19_1+\n    mat4(.406,.529,.187,.347,.112,.0344,-.24,.0723,-.0283,-.361,.0802,.543,.0355,-.159,.205,.571)*g19_2+\n    mat4(.233,-.189,.0319,-.7,.269,-.594,.0866,.0814,.296,-.408,-.0637,-.422,-.333,.361,-.292,.769)*g19_3+\n    mat4(-.307,-.0136,-.00781,-.0443,-.328,.178,.406,.358,-.0803,.32,.186,.227,-.0194,.0178,.198,-.379)*g19_4+\n    mat4(.00724,-.535,-.268,.343,.174,-.189,.239,-.113,.522,-.134,-.0255,-.0142,-.301,-.192,-.0701,-.707)*g19_5+\n    vec4(-4,-3.66,2.95,3.65));\n    float g=dot(g20_0,vec4(-.0242,.0198,-.0122,-.0169))+\n    dot(g20_1,vec4(.0175,-.00583,.0199,.0111))+\n    dot(g20_2,vec4(-.0277,.0138,.0204,.0117))+\n    dot(g20_3,vec4(-.0301,-.0243,.0319,.0167))+\n    dot(g20_4,vec4(-.00987,.0145,-.0185,-.0327))+\n    dot(g20_5,vec4(-.0228,-.0233,-.00943,-.0206))+\n    .429;\n\n    fragColor = vec4(g,g,g,1.0);\n#ifndef SHOW_SCARY_OUT_OF_BOUNDS\n    if (max(abs(uv.x),abs(uv.y)) > 1.) {\n        fragColor = vec4(.05);\n    }\n#endif\n    fragColor += hash(uv.x,uv.y)*.05-.025;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslXWS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[553, 553, 583, 583, 656], [658, 658, 715, 715, 84180]], "test": "untested"}
{"id": "NssXzs", "name": "My First Fluid Simulation", "author": "oneshade", "description": "Learning from: [url=https://wyattflanders.com/MeAndMyNeighborhood.pdf]https://wyattflanders.com/MeAndMyNeighborhood.pdf[/url]\nClick with the mouse to interact with the fluid.", "tags": ["simulation", "fluid", "first"], "likes": 14, "viewed": 346, "published": 3, "date": "1619136896", "time_retrieved": "2024-07-30T19:24:08.463546", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float k = length(texture(iChannel0, fragCoord / iResolution.xy).xy);\n    fragColor = vec4(sin(3.0 * k) - sin(k), sin(3.0 * k) * cos(k), sin(k), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 load(in vec2 pos) {\n    vec2 approxEnergy = texture(iChannel0, pos / iResolution.xy).xy;\n    vec2 approxPos = pos - approxEnergy;\n    return texture(iChannel0, approxPos / iResolution.xy);\n}\n\nvoid mainImage(out vec4 energy, in vec2 me) {\n    energy = vec4(0.0, 0.0, 0.0, length(texture(iChannel1, me / iResolution.xy).rgb));\n    if (iFrame > 0) {\n        vec4 rn = load(me + vec2(1.0, 0.0)); // Right neighbor\n        vec4 ln = load(me - vec2(1.0, 0.0)); // Left neighbor\n        vec4 un = load(me + vec2(0.0, 1.0)); // Up neighbor\n        vec4 dn = load(me - vec2(0.0, 1.0)); // Down neighbor\n        energy = load(me);\n\n        energy.b = (ln.b + rn.b + dn.b + un.b) * 0.25;\n\n        vec2 force = vec2(ln.b - rn.b, dn.b - un.b);\n        energy.xy += force * 0.25;\n\n        energy.b += (ln.x - rn.x + dn.y - un.y) * 0.25;\n\n        energy.y -= energy.w / 400.0;\n        energy.w += (ln.x * ln.w - rn.x * rn.w + dn.y * dn.w - un.y * un.w) * 0.25;\n\n        if (iMouse.z > 0.0 && length(iMouse.xy - me) < 25.0) {\n            energy.w = 1.0;\n        }\n\n        if (me.x < 10.0 || me.x > iResolution.x - 10.0 || me.y < 10.0 || me.y > iResolution.y - 10.0) {\n            energy.xy = vec2(0.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssXzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 211]], "test": "untested"}
{"id": "ssXSRl", "name": "Visualiser(sound!)", "author": "Pelegefen", "description": "\n you can change the song by switching the one in iChannel0,\nand can also mess around with the var's, in the beggining of main image. \n", "tags": ["2d", "fractal", "sound", "mandelbrot", "reactive", "music", "kaleidoscope", "visualiser", "snowflake", "set", "koch"], "likes": 6, "viewed": 528, "published": 3, "date": "1619136312", "time_retrieved": "2024-07-30T19:24:09.438938", "image_code": "// ----------------CAUTION!!!--- FLASHING BRIGHT LIGHTS!!!-------------------------\n\n\n\n// Credits - fractal zoom with smooth iter count adapted from - iq (Inigo quilez) - https://iquilezles.org/articles/msetsmooth\n// Koch Snowflake symmetry from tutorial by Martijn Steinrucken aka The Art of Code/BigWings - 2020 - https://www.youtube.com/watch?v=il_Qg9AqQkE&ab_channel=TheArtofCode\n//music - Varien & Razihel - Toothless Hawkins (And His Robot Jazz Band)\n\n\n\n//Some notes - color is determined by date and not time - hour of day dependent.\n//Move the mouse on the Y axis to change the symmetry.\n\n//----------------------------------------------------------------------------------\n\n//uncomment to sample audio input from MIC instead of SoundCloud.\n//#define MIC_INPUT\n\n//comment to make it less trippy and noisy.\n#define EXTRA_DMT\n\n\n#define PI 3.14159265359\n\n\n\n#define date iDate\n#define time iTime\n#define resolution iResolution\n\nfloat freqs[4];\n\n\nvec2 swirl(vec2 p, float i){\n\n    float an = atan(p.y, p.x);\n\t/*an = mod(an, PI);*/\n\tfloat dy = 1.0/(distance(p, vec2(0., 0.)))*((sin(time/2.)+1.02)*3.) + 2.*an;\n\n    \n    return vec2(cos(freqs[0]*10.0+dy)*i)+0.5;\n}\n\n\nvec2 rot(vec2 p,float a){\n    \n    float c = cos(a);\n    float s = sin(a);\n    \n    mat2 m = mat2(c,-s,s,c);\n    \n    p*=m;\n    return p  ;\n}\n\nfloat localTime(){\n\nfloat d = (date.w + date.x+date.y + date.z)/4.;\nreturn d ;\n\n}\n\nvec3 randomCol(float sc){\n\n float d = localTime();\n\tfloat r = sin(sc * 1. * d)*.5+.5;\n\tfloat g = sin(sc * 2. * d)*.5+.5;\n\tfloat b = sin(sc * 4. * d)*.5+.5;\n\n\tvec3 col = vec3(r,g,b);\n\tcol = clamp(col,0.,1.);\n\n\treturn col;\n\t}\n\n\n//--------------------------------------------------mandelbrot generator-----------https://iquilezles.org/articles/msetsmooth\n\n\tfloat mandelbrot(vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n\n    const float B = 128.0;\n    float l = 0.0;\n    vec2 z  = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z)>(B*B) ) break;\n        l += 1.0;\n    }\n\n    if( l>255.0 ) return 0.0;\n\n\n    // equivalent optimized smooth interation count\n    float sl = l - log2(log2(dot(z,z))) + 4.0;\n\n\n\n     return sl;\n }\n\n\nvec3 mandelbrotImg(vec2 p)\n{\n\n    //uncomment to see unmaped set\n\t//p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\n    float mtime =  time;\n    mtime -= freqs[3];\n    float zoo = 0.62 + 0.38*cos(.1*mtime);\n   float coa = cos( 0.015*(1.0-zoo)*mtime );\n   float sia = sin( 0.015*(1.0-zoo)*mtime );\n   zoo = pow( zoo,6.0);\n   vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n   vec2 c = vec2(-.745,.186) + xy*zoo;\n\n        float l = mandelbrot(c);\n        \n        \n\tvec3 col1 = 0.5 + 0.5*cos( 3.0 + l*.15 + randomCol(.1));\n    #ifdef EXTRA_DMT\n    vec3 col2 = 0.5 + 0.5*cos( 3.0 + l*.15 / randomCol(.1));\n    #else\n    vec3 col2 = 0.5 + 0.5*cos( 3.0 + l*.15 * randomCol(.1));\n    #endif\n    vec3 col = mix(col1,col2,(freqs[0])*.5+.5);\n\n\n\n\nreturn col;\n}\n\n//-----------------functions-----------\n\nfloat remap(float a1, float a2 ,float b1, float b2, float t)\n{\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\n}\n\n\nvec2 remap(float a1, float a2 ,float b1, float b2, vec2 t)\n{\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\n}\n\n\nvec4 remap(float a1, float a2 ,float b1, float b2, vec4 t)\n{\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\n}\n\n\n\n\n\nvec2 N(float angle) {\n    return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n//--------get soundtrack frequencies----\n\n\n    #ifdef MIC_INPUT\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n    #else \n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    #endif\n    float avgFreq = (freqs[0] +freqs[1] +freqs[2] +freqs[3])/4.;\n\n//--------image part---------\n    vec2 uv = (fragCoord.xy-.5*resolution.xy)/resolution.y;\n\tvec2 mouse = 1. - iMouse.xy/resolution.xy; // 0 1\n\tvec2 ouv = uv;\n    //uv.y -= .05;\n    uv = rot(uv,(sin(iTime*.1) /clamp( freqs[0],.3,1.)*.1  ) * PI  ) ;  \n\tuv *= 4.0 - (avgFreq * 1.5  );\n\n    uv.x = abs(uv.x);\n    \n    vec3 col = vec3(0);\n    float d;\n          uv = mix( uv +   swirl(uv  , 1. - freqs[0]), uv, freqs[0]);\n\n    float angle = 0.;\n    vec2 n = N((5./6.)*3.1415);\n\n    uv.y += tan((5./6.)*3.1415)*.5;\n   \td = dot(uv-vec2(.5, 0), n);\n    uv -= max(0.,d)*n*2.;\n    \n    float scale = 1. + freqs[3];\n    \n    n = N( freqs[0]*(2./3.)*3.1415);\n    uv.x += .5;\n   \n    for(int i=0; i<7; i++) {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n        \n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        d = dot(uv, n);\n        uv -= min(0.,d)*n*2.;\n       \n    }\n\n    d = length(uv/ clamp(freqs[2],0.1,.2 )- vec2(clamp(uv.x,-1., 1.), 0));\n    col += smoothstep(10./resolution.y, .0, d/scale);\n    uv /= scale;\t// normalization\n\n   \n\tvec3 manCol = mandelbrotImg(uv);\n\t col += manCol;\n\n\n \t\t// vignette effect\n\t  col *= 1.0 - 0.5*length(uv *0.5) / freqs[1];\n\n\t \n    fragColor = vec4( col,1.0);\n}", "image_inputs": [{"id": 21, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXSRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[950, 950, 978, 978, 1165], [1168, 1168, 1193, 1193, 1309], [1311, 1311, 1329, 1329, 1392], [1394, 1394, 1419, 1419, 1617], [1748, 1748, 1775, 1775, 2513], [2516, 2516, 2544, 2640, 3278], [3321, 3321, 3383, 3383, 3420], [3423, 3423, 3483, 3483, 3520], [3523, 3523, 3583, 3583, 3620], [3626, 3626, 3647, 3647, 3690], [3692, 3692, 3747, 3788, 5558]], "test": "untested"}
{"id": "sdXXWB", "name": "Alien technology 2", "author": "jarble", "description": "This seems to be some kind of spacecraft.", "tags": ["fractal", "metal", "shiny", "circuit", "machine"], "likes": 2, "viewed": 250, "published": 3, "date": "1619132971", "time_retrieved": "2024-07-30T19:24:10.511071", "image_code": "\n//Try changing this parameter to get more crazy patterns!\n\n\n#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/20.0;\n    uv.y += (iTime)/25.0;\n    float s1 = .85;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.16;\n        float scale1 = 1.14;\n        col_prev = col;\n        \n        for(int i=0;i<ITERS;i++)\n        {\n            s1 = s1 - col.x/64.0;\n            uv= fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1/s1;\n            uv = fract(-uv.yx);\n            uv.y /= -scale1/s1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXXWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 135, 135, 875]], "test": "untested"}
{"id": "ssXXDS", "name": "Acidify", "author": "HONKERTRON", "description": "Acid", "tags": ["acid"], "likes": 4, "viewed": 571, "published": 3, "date": "1619128375", "time_retrieved": "2024-07-30T19:24:11.369776", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(1.0 - fragCoord.x/iResolution.x, fragCoord.y/iResolution.y);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    vec4 frame1 = texture(iChannel0, uv);\n    float d1 =  0.025 * (cos(iTime / 2.0) - 0.5);\n    float d2 =  0.025 * (sin(iTime / 4.0) - 0.5);\n    vec4 frame2 = texture(iChannel0, vec2(uv.x - d1, uv.y + d2));\n    vec4 frame3 = texture(iChannel0, vec2(uv.x - d2, uv.y + d1));\n    float mixFactor1 = fract(sin(iTime / 2.0) + 0.75);\n    float mixFactor2 = fract(sin(iTime / 4.0) + 0.25);\n    fragColor = mix(mix(frame1, frame2, mixFactor1), frame3, mixFactor2);\n    //fragColor = mix(fragColor, texture(iChannel1, uv), 0.5);\n    //fragColor = mix(fragColor, texture(iChannel2, uv), 0.5);\n    //fragColor = mix(fragColor, texture(iChannel3, uv), 0.5);\n    fragColor *= vec4(col, 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXXDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 983]], "test": "untested"}
{"id": "7dXSWS", "name": "basic castle", "author": "jorge2017a1", "description": "basic castle", "tags": ["basiccastle"], "likes": 2, "viewed": 192, "published": 3, "date": "1619122171", "time_retrieved": "2024-07-30T19:24:12.333200", "image_code": "//por jorgefloresp.  ==jorge2017a1---22/abril/2021\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define PI 3.14\n#define roundnes 0.025\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n//Constants\nconst float tau = atan(1.0)*8.0;\nconst float pi = atan(1.0)*4.0;\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\nfloat rand(float x) { return fract(sin(x) * 4358.5453123); }\nfloat rand(vec2 co) { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357); }\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n\treturn p * mat2(ca, -sa, sa, ca);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat opRep1D( float p, float c )\n{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nfloat MarOnda(vec2 uv,float  t)\n{\n    uv.y += sin(uv.x*5.+t)*0.1;\n    return uv.y;\n}\n\nvec3 hacerOndasPasto(vec2 p, vec3 col)\n{\n    \n    float mo1= MarOnda(p-vec2(0.0,-0.6),0.0);\n    float sol= sdCircle( p-vec2(1.5*sin(iTime*0.5),0.6), 0.15) ;\n    \n    float dif1=-mo1;\n    float dif2=-mo1+0.1;\n    \n    float cielo=-p.y+0.1;\n    vec3 colcielo= nubes(p, iTime);\n    \n    col = mix(col,vec3(0.8,0.4646,0.1313),S(mo1,0.0));\n    col = mix(col,vec3(0.3,0.8,0.3),S(dif1,0.0));\n    col = mix(col,vec3(0.0,0.9,0.0),S(dif2,0.0));\n    //col = mix(col,vec3(0.0,0.0,1.0),S(cielo,0.0));\n    colcielo=mix(colcielo,vec3(0.0,0.0,1.0),0.5*sin(iTime));\n    col = mix(col,colcielo,S(cielo,0.0));\n    col = mix(col,vec3(1.0,0.8,0.5),S(sol,0.0));\n    return col;\n}\n\nvec3 castillo(vec2 p, vec3 col)\n{\n    float scolumna1=sdBox(p-vec2(-0.52,0.0), vec2(0.15,0.4) );\n    float scolumna2=sdBox(p-vec2(0.0,-0.15), vec2(0.4,0.25) );\n    float scolumna3=sdBox(p-vec2(0.52,0.0), vec2(0.15,0.4) );\n    float scolumnaC=sdBox(p-vec2(0.0,0.35), vec2(0.2,0.25) );\n    float ventana1=sdBox(p-vec2(-0.52,0.2), vec2(0.05,0.05) );\n    float ventana2=sdBox(p-vec2(0.0,0.5), vec2(0.05,0.05) );\n    float ventana3=sdBox(p-vec2(0.52,0.0), vec2(0.05,0.05) );\n    \n    float puerta1=sdBox(p-vec2(0.0,-0.25), vec2(0.1,0.15) );\n    \n    \n    vec2 pr= rotatev2( p, radians(180.0));\n    vec2 prb= rotatev2( p, radians(90.0));\n    float tr1= sdTriangleIsosceles(pr-vec2(0.53,-0.6), vec2(0.2,0.2) );\n    float tr2= sdTriangleIsosceles(pr-vec2(-0.52,-0.6), vec2(0.2,0.2) );\n    float tr3C= sdTriangleIsosceles(pr-vec2(0.0,-0.8), vec2(0.27,0.2) );\n    \n    float tr1ban= sdTriangleIsosceles(prb-vec2(-0.65,-0.725), vec2(0.05,0.2) );\n    float tr2ban= sdTriangleIsosceles(prb-vec2(-0.85,-0.2), vec2(0.05,0.2) );\n    float tr3ban= sdTriangleIsosceles(prb-vec2(-0.65,0.325), vec2(0.05,0.2) );\n    \n    //bloque ladrillos\n    vec2 prep=p;\n    prep.x=clamp(prep.x,-0.4,0.35);\n     prep.x= opRep1D( prep.x, 0.15 );\n    float bloques1=sdBox(prep-vec2(0.0,0.15), vec2(0.03,0.05) );\n    \n    col = mix(col,vec3(0.68,0.68,0.68),S(scolumna1,0.0));\n    col = mix(col,vec3(0.68,0.68,0.68),S(scolumna3,0.0));\n    col = mix(col,vec3(0.6,0.6,0.6),S(scolumna2,0.0));\n    col = mix(col,vec3(0.7,0.7,0.7),S(scolumnaC,0.0));\n    \n    col = mix(col,vec3(0.0,0.0,0.2),S(ventana1,0.0));\n    col = mix(col,vec3(0.0,0.0,0.2),S(ventana2,0.0));\n    col = mix(col,vec3(0.0,0.0,0.2),S(ventana3,0.0));\n    col = mix(col,vec3(0.0,0.0,0.2),S(puerta1,0.0));\n    \n    col = mix(col,vec3(0.6,0.6,0.6),S(tr1,0.0));\n    col = mix(col,vec3(0.6,0.6,0.6),S(tr2,0.0));\n    col = mix(col,vec3(0.6,0.6,0.6),S(tr3C,0.0));\n    \n    col = mix(col,vec3(1.0),S(tr1ban,0.0));\n    col = mix(col,vec3(1.0),S(tr2ban,0.0));\n    col = mix(col,vec3(1.0),S(tr3ban,0.0));\n    \n    col = mix(col,vec3(0.58,0.58,0.58),S(bloques1,0.0));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 p=uv;\n    vec3 col=vec3(0.65);\n   \n    col= hacerOndasPasto(p, col);\n    col= castillo(p-vec2(0.0,0.1), col);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "//Hashless Noise Experiment\nvec3 nubes(  in vec2 puv, float ptime )\n{\n    \n    vec2 c = puv/0.25;\n    \n    float g = 0.;\n    vec2 d = vec2(1,0);\n    for(float i = 1.;i++<=64.;)\n    {\n        //Use precomputed kernels here?\n        d = cos(cos(i*i-i)*246.+vec2(0,1.57));\n        //Or just rotate?\n        //d *= mat2(.8,.6,-.6,.8);\n        g += cos(dot(c++,d*sqrt(i))+ptime)/i;\n    }\n\n    vec3 col = vec3(g/3.+.5);\n\n    \n    return col;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXSWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[495, 495, 528, 528, 550], [551, 551, 584, 584, 606], [607, 607, 640, 640, 661], [663, 663, 684, 684, 723], [724, 724, 745, 745, 813], [815, 815, 849, 849, 946], [948, 948, 978, 978, 1061], [1063, 1063, 1100, 1100, 1180], [1182, 1182, 1217, 1217, 1245], [1247, 1247, 1298, 1298, 1606], [1608, 1608, 1643, 1643, 1688], [1690, 1690, 1723, 1723, 1774], [1776, 1776, 1816, 1816, 2433], [2435, 2435, 2468, 2468, 4531], [4533, 4533, 4590, 4590, 4807]], "test": "untested"}
{"id": "fdXXDB", "name": "Alien technology", "author": "jarble", "description": "I don't know what this thing is. It must be some sort of alien technology.", "tags": ["fractal", "metal", "shiny", "circuit", "machine"], "likes": 3, "viewed": 287, "published": 3, "date": "1619120259", "time_retrieved": "2024-07-30T19:24:13.231798", "image_code": "\n//Try changing this parameter to get more crazy patterns!\n#define s1 2.0\n\n#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/20.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        \n        \n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1/s1;\n            uv = -fract(-uv.yx);\n            uv.y /= -scale1/s1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXXDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 149, 149, 777]], "test": "untested"}
{"id": "sdlXzs", "name": "Pendulum integrator", "author": "michael0884", "description": "pendulum", "tags": ["sin"], "likes": 3, "viewed": 281, "published": 3, "date": "1619103828", "time_retrieved": "2024-07-30T19:24:13.998746", "image_code": "float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat sinline(in vec2 p, float amp, float freq)\n{\n    float s0 = 2.14*sin(0.1*iTime);\n    float c0 = 2.14*cos(0.1*iTime);\n    float s1 = 1.0;\n    float c1 = 0.0;\n    float sd = 1e10;\n    \n    float x = 0.0;\n    float dx = 0.4;\n    for(int i = 0; i < 256; i++)\n    {\n        //integrate \n        c1 = c0 - (sin(s0))*dx;\n        s1 = s0 + c1*dx;\n        \n        //plot line\n        sd = min(sd, sdSegment(p, vec2(x*freq, s0*amp), vec2((x+dx)*freq, s1*amp)));\n        \n        x += dx;\n        c0 = c1; s0 = s1;\n    }\n    \n    return sd;\n}\n\nvoid mainImage( out vec4 C, in vec2 X )\n{\n    float sd = sinline(X - iResolution.xy*vec2(0.0,0.5), 25.0, 30.);\n\n    vec3 col = (sin(sd/4.0)*0.5 + 0.5)/(1.0 + 0.1*sd*vec3(0.792,0.3,0.098));\n    // Output to screen\n    C = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlXzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 171], [174, 174, 223, 223, 711], [713, 713, 754, 754, 950]], "test": "untested"}
{"id": "sdlSzs", "name": "Sine wave integrator", "author": "michael0884", "description": "just a sine wave without sin() evaluations", "tags": ["sin"], "likes": 4, "viewed": 346, "published": 3, "date": "1619100314", "time_retrieved": "2024-07-30T19:24:14.812570", "image_code": "float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat sinline(in vec2 p, float amp, float freq)\n{\n    float s0 = 1.0;\n    float c0 = 0.0;\n    float s1 = 1.0;\n    float c1 = 0.0;\n    float sd = 1e10;\n    \n    float x = 0.0;\n    const float dx = 0.3;\n    for(int i = 0; i < 128; i++)\n    {\n        //integrate \n        c1 = c0 - s0*dx;\n        s1 = s0 + c1*dx;\n        \n        //plot line\n        sd = min(sd, sdSegment(p, vec2(x*freq, s0*amp), vec2((x+dx)*freq, s1*amp)));\n        \n        x += dx;\n        c0 = c1; s0 = s1;\n    }\n    \n    return sd;\n}\n\nvoid mainImage( out vec4 C, in vec2 X )\n{\n    float sd = sinline(X - iResolution.xy*vec2(0.0,0.5), 30.0, 30.);\n\n    vec3 col = (sin(sd/4.0)*0.5 + 0.5)/(1.0 + 0.1*sd*vec3(0.792,0.3,0.098));\n    // Output to screen\n    C = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 171], [174, 174, 223, 223, 678], [680, 680, 721, 721, 917]], "test": "untested"}
{"id": "NdXSzf", "name": "cloud_render2", "author": "mdb", "description": "test of cloud rendering, wait a bit for the image to converge", "tags": ["raymarching", "volumetric", "pathtracing"], "likes": 12, "viewed": 478, "published": 3, "date": "1619095764", "time_retrieved": "2024-07-30T19:24:15.715157", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    // do image post-prossesing\n    col = 1.0-exp(-1.3*col); \n    col = pow(col, vec3(1.3));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "//the sky\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = vec3(0.3, 0.7, 1.0)*0.7;\n    \n    vec3 sunDir = normalize(vec3(1.0, 0.3, -0.5));\n    //vec3 sunDir = normalize(vec3(0.0, 0.0, 0.5));\n    //vec3 sunDir = normalize(vec3(-0.5, -1.0, 1.8));\n    \n    col += 55.0*vec3(0.9764, 0.8058, 0.441)*pow(0.5 + 0.5*dot(sunDir, rayDir), 80.0);\n    col += vec3(0.8)*pow(0.5 + 0.5*dot(sunDir, rayDir), 2.0);\n    col *= vec3(1.1, 0.5, 0.4); //make the sky red (could be changed by the day)\n    col *= 1.5;\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "buffer_a_code": "//where all the stuff append\n#define PI 3.14159265359\n#define MAXSTEP 100\n#define STEPSIZE 0.04   //smaller for more detail\n#define MAXDEPTH 5\n#define FOGDENSITY 200.8\n#define aperture 0.01   //the bigger the faster the image blur\n#define focalLength 1.0\n\nconst vec3 camPos = vec3(0.5, 1.0, -1.8)*0.8;\nconst vec3 target = vec3(0.0, 0.0, 0.0);\n\n\nstruct Mat{vec3 c, e;}; //color, emission\n\nMat cloud = Mat(vec3(0.99, 0.99, 0.99), vec3(0.0));\n\n//box where the cloud is rendered\nconst vec3 up = vec3(30.0, 0.5, 30.0);\nconst vec3 down = vec3(-30.0, -0.5, -30.0);\n\n// pseudo random numbers////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 uv){\n    seed = uint(uv.y*iResolution.x + uv.x) + uint(iTime*6000000.0);\n}\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\nfloat noise(vec3 pos){\n    return texture(iChannel2, pos).x;\n}\n\nfloat fbm( vec3 pos )\n{\n    float f = 0.0;\n    float p = 0.3;\n    int o = 8; //octave\n    for(int i = 0; i < o; i++){ \n        f += pow(1.0-p, float(i))*p*noise(pos); pos*=2.01;\n    }\n    f /= 1.0-pow(1.0-p, float(o));\n    return f;\n}\n\n/////////////////////////////////////////////////////////////////////////\n\nvec2 box(vec3 ro, vec3 rd){\n        \n        vec3 dirfrac = 1.0 / rd;\n        float t1 = (down.x - ro.x)*dirfrac.x;\n        float t2 = (up.x - ro.x)*dirfrac.x;\n        float t3 = (down.y - ro.y)*dirfrac.y;\n        float t4 = (up.y - ro.y)*dirfrac.y;\n        float t5 = (down.z - ro.z)*dirfrac.z;\n        float t6 = (up.z - ro.z)*dirfrac.z;\n\n        float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n        float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n        // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us\n        if (tmax < 0.0) return vec2(-1.0);\n\n        // if tmin > tmax, ray doesn't intersect AABB\n        if (tmin > tmax) return vec2(-1.0);\n\n        return vec2(tmin, tmax);\n}\nvec3 newDir(vec3 n){\n    float teta = random()*2.0*PI;\n    float z = random()*2.0-1.0;\n    vec3 v = vec3(sqrt(1.0-z*z)*cos(teta), sqrt(1.0-z*z)*sin(teta), z);\n    return v;\n}\n\nfloat smax(vec3 v){\n    float k = 0.1;\n    return (v.x*exp(k*v.x) + v.y*exp(k*v.y) + v.y*exp(k*v.y))/(exp(k*v.x) + exp(k*v.y) + exp(k*v.y));\n}\n\nfloat density(vec3 p){\n    vec3 normPos = (p-down)/(up-down)*2.0-1.0;\n    normPos = abs(normPos);\n    float mask = smax(normPos);\n    mask = pow(mask, 4.0);\n    \n    float noise = fbm(p*0.05+0.35);\n    \n    float tres = 0.5+mask;\n    if (noise < tres)return STEPSIZE*0.1;\n    return FOGDENSITY*STEPSIZE;\n}\n\nfloat intersect(vec3 ro, vec3 rd, out Mat obj){\n    obj = cloud;\n    vec2 bounds = box(ro, rd);\n    \n    if (bounds.y < 0.0){ obj = Mat(vec3(0.0), texture(iChannel1, rd).xyz);return -1.0;}\n    \n    \n    float t = max(bounds.x, 0.0) + random()*STEPSIZE;\n    float maxDist = bounds.y;\n    \n    for(int i = 0; i < MAXSTEP; i++){\n        if(t > maxDist){ obj = Mat(vec3(0.0), texture(iChannel1, rd).xyz);return -1.0;}\n        vec3 p = ro + t * rd;\n        t += STEPSIZE * max(1.0,distance(p, camPos)*0.5);\n        \n        float prob = density(p);\n        if (random()<prob)return t;\n        \n    }\n    return -1.0;\n}\n\n\n\nvec3 march(vec3 ro, vec3 rd, vec2 uv){\n\tvec3 col = vec3(0.0);\n\tvec3 mask = vec3(1.0);\n    float k = 1.0;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tMat obj;\n        float t = intersect(ro, rd, obj);\n        \n\t\tro = ro + t * rd;\n        if(depth == MAXDEPTH - 2){\n            rd = normalize(vec3(1.0, 0.3, -0.5)); // not realisticly accurate but help the image converge faster\n            k = 0.1;\n        }else{\n            rd = newDir(rd);\n        }\n        \n\t\tcol += mask * obj.e * k;\n\t\tmask *= obj.c;\n        \n        if(t<=0.0)break; // dont intersect anything\n        if (dot(mask, mask)<0.000001)break; // have absorbed to much light that the ray is useless\n\t\t\n\t}\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    initRandomGenerator(fragCoord);\n    \n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec2 off = vec2(random(),random()) / iResolution.y;\n    vec3 rd = normalize(dir0 + right*(uv.x+off.x) + up*(uv.y+off.y));\n    \n    // for focal length\n    float t = dot(dir0*focalLength, dir0)/dot(rd, dir0); //distance to the focal plane\n    vec3 focalPoint = camPos + rd*t;\n    \n    float teta = random()*10.0*PI;\n    vec2 off2 = vec2(cos(teta), sin(teta))*sqrt(random())*aperture;\n    vec3 camPos2 = camPos + right*off2.x + up*off2.y;\n    vec3 rd2 = normalize(focalPoint-camPos2);\n    \n    vec3 col = march(camPos2, rd2, uv);\n    \n    vec3 last = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    float weight = 1.0/float(iFrame + 1);\n    col = col * weight + last * (1.0-weight);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXSzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 268]], "test": "untested"}
{"id": "NdlXzs", "name": "Day 490", "author": "jeyko", "description": "potvato", "tags": ["tv", "glitch", "static", "mdtmjvm"], "likes": 23, "viewed": 930, "published": 3, "date": "1619085300", "time_retrieved": "2024-07-30T19:24:16.521002", "image_code": "\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\nvec3 pal(float m){\n    vec3 c = 0.5 + 0.5*sin(vec3(\n        m + 0.5,\n        m + 0.3,\n        m - 0.5\n    ));\n    \n    c = pow(c,vec3(14.));\n    \n    return c;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(1);\n    \n    \n    {\n        vec2 p = uv;\n        \n        float md = 0.02;\n        float m =p.x*6. + iTime + sin(p.x + cos(iTime) + iTime);\n        \n        if(uv.y < 0.)\n            m += iTime;\n        p.x += sin(m)*0.1;\n        float id = floor(p.x/md);\n        p.y = abs(p.y);\n        p.x = pmod(p.x,md);\n        \n        float d = abs(p.x) - md*(0.1 + sin(id + m)*0.05)*2.;\n        d = max(d,abs(p.y - 0.45) -0.05);\n        \n        //col = mix(col,1.-col,smoothstep(fwidth(d),0.,d));\n        \n        md = 0.001;\n        float oid = floor(uv.y/md);\n        \n        float om =uv.x*6. + iTime + cos(oid) + sin(uv.x + cos(iTime + oid*5.) + iTime + oid);\n        \n        col = mix(col,pal(id),smoothstep(fwidth(d) + abs(sin(om))*0.005,0.,d));\n        \n        d = abs(p.y - 0.4) - 0.015;\n        col = mix(col,1.-col,smoothstep(fwidth(d) + 0.01*(0.5+0.5*sin(iTime +m)),0.,d));\n        \n        \n    }\n    {\n         vec2 p = uv;\n        \n        float md = 0.01;\n        float id = floor(p.y/md);\n        \n        float m =p.x*6. + iTime + cos(id) + sin(p.x + cos(iTime + id*5.) + iTime + id);\n        \n        if(uv.y < 0.)\n\n\n            m += iTime;\n        p.x += sin(m)*0.1 + m + cos(id + iTime);\n        p.y = pmod(p.y,md);\n        p.x = pmod(p.x,0.4);\n        \n        \n        float d = abs(p.y) - md*0.2;\n        d = max(d,abs(p.x) - 0.1);\n        d = max(d,abs(uv.y - 0.3 + sin(m*20000.)*sin( + id*md + iTime*1. + cos(id*md + iTime))*0.15) -0.25);\n        \n        col = mix(col,1.-col,smoothstep(fwidth(d) + 0.04*(0.5+0.5*sin(iTime + cos(20.*m))),0.,d));\n        \n    }\n    \n    {\n        // haha pp\n        vec2 pp = uv;\n        \n        float md = 0.0142;\n        float id = floor(pp.y/md);\n        \n        float m =pp.x*6. + iTime + cos(id) + sin(pp.x + cos(iTime*10.*sin(iTime) + id*5.) + iTime + id);\n        \n    \n        vec3 rd = normalize(vec3(uv + sin(m)*0.14,1));\n        vec3 ro = vec3(0,0,-2);\n        vec3 p = ro;\n        \n        float t = 0.; bool hit = false;\n        \n        for(int i = 0; i < 10; i++){\n            vec3 q = p;\n            q -= 0.2;\n            q.xy *= rot(-sin(m+iTime)*.01*sin(iTime) + 0.4*iTime);\n            float d = mix(length(q.yz),q.y,0.5+0.5*sin(iTime)) - 0.1 + sin(iTime + m*0.01)*0.1;\n            \n            if(d < 0.001){\n                hit = true; break;\n            }\n            \n            p = ro + rd*(t+=d);\n        }\n        \n        if(hit){\n            \n            col = mix(col,1. - col*pow(pal(m*10.1  + iTime*5.),vec3(22,1.4,0.4)),col + sin(m));\n            //col = 1.-col;\n        }\n        \n    }\n    \n    float m;\n    {\n        vec2 pp = uv;\n        \n        float md = 0.01;\n        float id = floor(pp.y/md);\n        \n        \n        m =pp.x*6. + iTime + cos(id) + sin(pp.x + cos(iTime + id*5.) + iTime + id);\n        \n        if(uv.x < 0.)\n            m = sin(m);\n        \n        \n        vec2 p = abs(uv);\n        \n        float d = length(p.x -(+ sin(m*120.4)*0.01 + 0.9 + sin(iTime + id*md*0.2)*0.04*sin(iTime))) - 0.0;\n    \n        \n    \n        col = mix(col,0.7-col*0.4,smoothstep(fwidth(d)*(5. + sin(m)*3.),0.,d));\n    }\n    \n     {\n         \n        vec2 p = uv;\n        p.x += m;\n        p = pmod(p,0.01);\n        \n        float d = abs(p.x);\n    \n        col = mix(col,0.2-col*1.,(1.-col)*smoothstep(fwidth(d)*(2. + sin(m*20.)*1.),0.,d));\n    }\n    {\n        vec2 pp = uv;\n        \n        float md = 0.01;\n        float id = floor(pp.y/md);\n        \n        \n        m =pp.x*6. + iTime + cos(id) + sin(pp.x + cos(iTime + id*5.) + iTime + id);\n        \n        col = mix(col, 1. - col, smoothstep(0.7,0.8,sin((iTime+ uv.x + sin(m*120. + iTime*20.)*0.4)/7. )));\n    \n    }\n    \n\n    col = max(col,0.03*(0.5+0.5*sin(iTime*2.)));\n    \n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlXzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 104, 104, 247], [251, 251, 308, 308, 4185]], "test": "untested"}
{"id": "sdlSRl", "name": "Antarctic Flag", "author": "dr2", "description": "Dynamic image mapped to floppy surface (mouseable)", "tags": ["dynamics", "mapping", "physics", "cloth", "penguin"], "likes": 11, "viewed": 379, "published": 3, "date": "1619081914", "time_retrieved": "2024-07-30T19:24:17.472458", "image_code": "// \"Antarctic Flag\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Dynamic image mapped to floppy surface (mouseable)\n// (mix of \"Union Jack Flag\" and \"Night of the Penguins\")\n\n/*\n  No. 9 in \"Sheet Dynamics\" series\n    \"Floppy Sheet\"              (MlVSz1)\n    \"Stonewashed Flag\"          (MlyXzD)\n    \"Floppy Cylinder\"           (4ltyz4)\n    \"Surface Skimmer\"           (XtcBzN)\n    \"Tempus Fugit\"              (Ml3fW2)\n    \"Floppy Clock With Dice\"    (3sXBDr)\n    \"Flagtime\"                  (NsfSR8)\n    \"Union Jack Flag\"           (NsXXRN)\n\n  No. 13 in \"Penguin\" series\n    \"Tux the Penguin\"           (lt3cDX)\n    \"Tux and Pals\"              (XlyyRR)\n    \"Endless Penguins\"          (MlVyzR)\n    \"Penguins Can't Fly\"        (ltVyzh)\n    \"Sliding Penguins\"          (XlcfzS)\n    \"Androids Love Penguins\"    (4tdBWf)\n    \"Night of the Penguins\"     (ttlSRr)\n    \"Tux is Worried\"            (tsfcRj)\n    \"Social Distancing\"         (3sBcz3)\n    \"Belvedere\"                 (3dSfzt)\n    \"Quantum Penguins\"          (wtsyzs)\n    \"Twisting Tux\"              (3st3Wl)\n*/\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HsvToRgb (vec3 c);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (vec2 vId);\n\nvec3 sunDir, sunDirEx, qHit;\nvec2 qgHit, gId, obOff;\nfloat dstFar, tCur, spLen, szFac, fAng, obRot, szPeng, hgSize, tWav;\nint idObj;\nbool isNite;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dh;\n  dMin = dstFar;\n  if (szPeng > 0.) {\n    p.xz -= HexToPix (gId * hgSize) + obOff;\n    p.xz = Rot2D (p.xz, obRot);\n    dMin /= szPeng;\n    p /= szPeng;\n    p.y -= 1.55;\n    q = p;\n    d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n    q.y -= 1.5;\n    dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n    DMINQ (1);\n    q = p;\n    q.yz -= vec2 (1.6, -0.6);\n    d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n    DMINQ (2);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = PrSphDf (q, 0.15);\n    DMINQ (3);\n    q = p;\n    q.x = abs (q.x);\n    q.xy -= vec2 (0.4, -0.8);\n    d = PrCylDf (q.xzy, 0.12, 0.7);\n    DMINQ (4);\n    q -= vec3 (0.1, -0.67, -0.4);\n    q.xz = Rot2D (q.xz, -0.07 * pi);\n    d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, 0.15 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, -0.3 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    DMINQ (5);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (1.1, 0.3, -0.2);\n    q.yz = Rot2D (q.yz, -0.25 * pi);\n    q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n    d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n    DMINQ (6);\n    q = p;\n    q.y -= -1.53;\n    d = abs (q.y) - 0.01;\n    DMINQ (7);\n    dMin *= szPeng;\n  }\n  return dMin;\n}\n\nfloat GrndHt (vec2 p)\n{\n  return Fbm2 (0.05 * p) - 0.5;\n}\n\nvoid SetPngConf ()\n{\n  vec2 g, w;\n  float t;\n  g = HexToPix (gId * hgSize);\n  if (GrndHt (g) < 0. || Hashfv2 (37. * gId + 99.) < 0.3) szPeng = 0.;\n  else {\n    obRot = 2. * pi * Hashfv2 (37. * gId + 99.);\n    t = Hashfv2 (17. * gId + 99.);\n    szPeng = 0.8 * (0.5 * sqrt3 - 0.3 * t);\n    w = Hashv2v2 (73. * gId + 77.);\n    obOff = hgSize * max (0., 0.5 * sqrt3 - szPeng) * w.x * sin (2. * pi * w.y + vec2 (0.5 * pi, 0.));\n    fAng = -0.2 * pi + 0.1 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur + 1.3 * t, 1.)) *\n       sin (16. * pi * tCur);\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 200; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetPngConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + 0.002;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < 0.0005 || dHit > dstFar || p.y < 0. || rd.y > 0. && p.y > 5.) break;\n  }\n  if (d >= 0.0005) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetPngConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.05, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = -0.98 * ro.y / rd.y;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    p = ro + dHit * rd;\n    d = p.y + 0.01 * step (GrndHt (p.xz), -0.01);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 t2;\n  float wFreq, wAmp, ht;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    p *= qRot;\n    t4 = (p.xyxy + tWav * vec2 (1., -1.).xxyy) * wFreq;\n    t4 += 2. * vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw)).xxyy - 1.;\n    t4 = abs (sin (t4));\n    v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t2 = 1. - sqrt (v4.xz * v4.yw);\n    t2 *= t2;\n    t2 *= t2;\n    ht += wAmp * dot (t2, t2);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec4 AurCol (vec3 ro, vec3 rd)\n{\n  vec4 col, mCol;\n  vec3 p, dp;\n  float ar;\n  dp = rd / rd.y;\n  p = ro + (50. - ro.y) * dp;\n  col = vec4 (0.);\n  mCol = vec4 (0.);\n  tWav = 0.05 * tCur;\n  for (float ns = float (VAR_ZERO); ns < 50.; ns ++) {\n    p += dp;\n    ar = 0.05 - clamp (0.06 * WaveHt (0.008 * p.xz), 0., 0.04);\n    mCol = mix (mCol, ar * vec4 (HsvToRgb (vec3 (mix (0.34 + 0.007 * ns, 0.,\n       smoothstep (30., 45., ns)), 1., 1. - 0.013 * ns)), 1.), 0.5);\n    col += mCol;\n  }\n  return col;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 SkyHzCol (vec3 ro, vec3 rd)\n{\n  vec4 aCol;\n  vec3 col;\n  float f, a;\n  a = atan (rd.x, - rd.z);\n  if (rd.y < 0.03 * Fbm1 (32. * a) + 0.005) {\n    col = (isNite ? 0.8 * vec3 (0.15, 0.3, 0.2) : vec3 (1.)) * (1. -\n       0.2 * Fbm2 (128. * vec2 (a, 4. * rd.y)));\n  } else {\n    if (isNite) {\n      aCol = AurCol (ro, rd);\n      col = (1. - 0.5 * aCol.a) * StarPat (rd, 4.) + 0.6 * aCol.rgb;\n    } else {\n      ro.xz += 2. * tCur;\n      col = vec3 (0.2, 0.3, 0.6) + 0.2 * (1. - max (rd.y, 0.)) +\n         0.1 * pow (max (dot (rd, sunDir), 0.), 16.);\n      f = Fbm2 (0.02 * (ro.xz + rd.xz * (100. - ro.y) / max (rd.y, 0.01)));\n      col = mix (col, vec3 (1.), 0.2 + 0.8 * f * rd.y);\n    }\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, sh;\n  bool isSky, isGrnd, isWat, doSh;\n  isSky = false;\n  isGrnd = false;\n  isWat = false;\n  doSh = false;\n  tWav = 0.4 * tCur;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = dstFar;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (idObj != 7) {\n      gId = PixToHex (ro.xz / hgSize);\n      vn = ObjNf (ro);\n      if (idObj == 1 || idObj == 6) vn = VaryNf (64. * ro, vn, 0.3);\n    }\n    if (idObj == 1) col4 = (qHit.z < -0.2 || qHit.z < 0. && length (qHit.xy) < 0.2) ?\n       vec4 (0.95, 0.95, 0.95, 0.05) : vec4 (0.1, 0.1, 0.15, 0.1);\n    else if (idObj == 2) col4 = vec4 (1., 0.8, 0.2, 0.2);\n    else if (idObj == 3) col4 = vec4 (0.05, 0.15, 0.05, 0.2);\n    else if (idObj == 4) col4 = vec4 (0.05, 0.1, 0.05, 0.1);\n    else if (idObj == 5) col4 = vec4 (0.9, 0.9, 0., 0.3);\n    else if (idObj == 6) col4 = vec4 (0.15, 0.15, 0.2, 0.1);\n    else if (idObj == 7) isGrnd = true;\n    doSh = true;\n  } else if (rd.y < 0.) {\n    dstGrnd = GrndRay (ro, rd);\n    ro += dstGrnd * rd;\n    if (ro.y < 0.) isWat = true;\n    else isGrnd = true;\n  } else isSky = true;\n  if (! isSky) {\n    if (isWat) {\n      ro += (- ro.y / rd.y) * rd;\n      rd = reflect (rd, VaryNf (0.5 * ro + vec3 (0.1 * tCur, 0., 0.1 * tCur), vec3 (0., 1., 0.), 0.1));\n      col = 0.9 * SkyHzCol (ro, rd);\n    } else {\n      if (isGrnd) {\n        col4 = vec4 (vec3 (0.95, 0.95, 1.) * min (0.9 + 0.2 * Fbm2 (ro.xz), 1.), 0.1);\n        vn = VaryNf (ro, vec3 (0., 1., 0.), 0.3);\n        doSh = (min (dstGrnd, dstObj) < dstFar);\n      }\n      if (isNite) {\n        if (isGrnd || idObj != 3) col = col4.rgb * vec3 (0.15, 0.3, 0.2) * (0.2 + 0.8 * max (0., vn.y));\n        else col = vec3 (0.7, 0., 0.) * max (- dot (vn, rd), 0.);\n      } else {\n        sh = doSh ? ObjSShadow (ro, sunDir) : 1.;\n        col = col4.rgb * (0.3 + 0.2 * max (dot (normalize (vec3 (vn.x, 0., vn.z)), - sunDir), 0.) +\n           0.6 * sh * max (dot (vn, sunDir), 0.)) +\n           col4.a * smoothstep (0.8, 1., sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      }\n    }\n    col = mix (col, vec3 (0.9) * (isNite ? 0.8 * vec3 (0.15, 0.3, 0.2) : vec3 (1.)),\n       smoothstep (0.3, 1., min (dstGrnd, dstObj) / dstFar));\n  } else col = SkyHzCol (ro, rd);\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvec3 TrackPos (float t)\n{\n  return vec3 (5. * cos (0.01 * 2. * pi * t) + 0.1 * t, 10., t);\n}\n\nvec3 SheetCol (float s)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd;\n  vec2 uv;\n  float spd;\n  uv = (qgHit / (0.5 * float (nBallE.y - 1)) - 1.);\n  uv.x -= 1.;\n  isNite = (s < 0.);\n  hgSize = 2.3;\n  spd = 5.;\n  ro = TrackPos (spd * tCur);\n  vd = normalize (TrackPos (spd * tCur + 0.1) - ro);\n  vuMat = StdVuMat (asin (vd.y) - 0.05 * pi, 0.5 * pi + atan (- vd.z, vd.x));\n  rd = vuMat * normalize (vec3 (uv, 1.7));\n  dstFar = 300.;\n  sunDir = normalize (vec3 (0.5, 2., -1.));\n  return (abs (uv.x) < 1.93 && abs (uv.y) < 0.93) ? ShowScene (ro, rd) : vec3 (0.3, 0.3, 0.5);\n}\n\nconst int nsMax = 5000;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nfloat SheetRay (vec3 ro, vec3 rd)\n{\n  vec3 r, q;\n  vec2 g;\n  float d, dMin, sz, szMax, szMin, grLen;\n  bvec2 ilt;\n  bool bkTrak;\n  grLen = 0.92 * spLen;\n  dMin = dstFar / (grLen * szFac);\n  ro /= szFac;\n  rd /= grLen;\n  szMax = float (nBallE.x - 1);\n  szMin = 1./32.;\n  sz = szMax;\n  g = vec2 (0.);\n  bkTrak = false;\n  for (int ns = VAR_ZERO; ns < nsMax; ns ++) {\n    if (sz == szMin) {\n      r = GetR (g) - ro;\n      q = cross (r, rd);\n      if (dot (q, q) < sz * sz) {\n        d = dot (r, rd);\n        if (d < dMin) {\n          dMin = d;\n          qgHit = g;\n        }\n      }\n      bkTrak = true;\n    }\n    q = cross (GetR (g + 0.5 * sz) - ro, rd);\n    bkTrak = bkTrak || (dot (q, q) > sz * sz);\n    if (bkTrak) {\n      bkTrak = false;\n      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));\n      g.x += ilt.x ? sz : - sz;\n      if (! ilt.x) {\n        if (sz == 0.5 * szMax) break;\n        g.y += ilt.y ? sz : - sz;\n        if (! ilt.y) {\n          sz *= 2.;\n          if (sz == szMax) break;\n          bkTrak = true;\n        }\n      }\n    } else if (sz > szMin) sz *= 0.5;\n  }\n  return dMin * grLen * szFac;\n}\n\nvec3 GetRC (vec2 v)\n{\n  return GetR (clamp (v, vec2 (0.), vec2 (nBallE - 1)));\n}\n\nvec3 SheetNf () \n{\n  vec3 c;\n  vec2 e = vec2 (1., 0.);\n  c = GetRC (qgHit);\n  return normalize (cross (GetRC (qgHit + e.yx) - c, GetRC (qgHit + e) - c));\n}\n\nfloat SheetSilHit (vec3 ro, vec3 rd)\n{\n  vec3 blkSize, pMin, pMax, v, tm, tp;\n  float dn, df;\n  pMin = Loadv4 (vec2 (1, nBallE.y)).xyz;\n  pMax = Loadv4 (vec2 (2, nBallE.y)).xyz;\n  ro /= szFac;\n  ro -= 0.5 * (pMin + pMax);\n  blkSize = 0.5 * (pMax - pMin) + 0.5;\n  v = ro  / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? szFac * dn : dstFar;\n}\n\nvec4 CylHit (vec3 ro, vec3 rd, float cylRad, float cylLen)\n{\n  vec3 s, vn;\n  float dMin, d, a, b, w, srdy;\n  dMin = dstFar;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - cylRad * cylRad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0.) {\n        d /= a;\n        s = ro + d * rd;\n      } else s.y = cylLen;\n    } else s.y = cylLen;\n    if (abs (s.y) < cylLen) {\n      dMin = d;\n      vn = vec3 (s.xz / cylRad, 0.).xzy;\n    } else if (srdy * ro.y < - cylLen) {\n      d = - (srdy * ro.y + cylLen) / abs (rd.y);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.xz) < cylRad) {\n          dMin = d;\n          vn = vec3 (0., 0., - srdy).xzy;\n        }\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 ExBgCol (vec3 rd)\n{\n  vec3 col;\n  vec2 u;\n  float el, f;\n  rd.xz = Rot2D (rd.xz, 0.01 * tCur);\n  el = asin (rd.y);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 96.;\n  col = mix (vec3 (0.1, 0.2, 0.4), vec3 (0.8), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, vec3 (0.2, 0.3, 0.4), smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  return col;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, dc4;\n  vec3 col, vn, q;\n  float dstObj, dstSheet, s, flSize;\n  szFac = 4. / float (nBallE.y - 1);\n  flSize = szFac * 0.5 * float (nBallE.y + 1);\n  q = ro;\n  q.y -= - 2. * flSize;\n  dc4 = CylHit (q, rd, 0.06, 3. * flSize + 0.2);\n  dstObj = dc4.x;\n  q = ro;\n  q.x -= 2. * flSize + 0.06;\n  dstSheet = (SheetSilHit (q, rd) < dstFar) ? SheetRay (q, rd) : dstFar;\n  if (min (dstSheet, dstObj) < dstFar) {\n    if (dstSheet < dstObj) {\n      vn = SheetNf ();\n      s = sign (dot (rd, vn));\n      if (s > 0.) vn = - vn;\n      col4 = vec4 (SheetCol (s), 0.);\n    } else {\n      ro += dstObj * rd;\n      vn = dc4.yzw;\n      col4 = vec4 (0.9, 0.9, 0.95, 0.1);\n      if (abs (ro.y) < flSize + 0.1) col4 *= (0.5 + 0.5 * smoothstep (0.05, 0.1,\n         abs (mod (4. * (ro.y + 0.02) / flSize + 0.5, 1.) - 0.5)));\n    }\n    col = col4.rgb * (0.5 + 0.5 * max (dot (vn, sunDirEx), 0.)) +\n       col4.a * pow (max (dot (reflect (sunDirEx, vn), rd), 0.), 32.);\n  } else col = ExBgCol (rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2.2 * pi * mPtr.x;\n    el += 0.4 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.2 * pi, 0.2 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -0.7, -20.);\n  ro.x += 4.;\n  rd = vuMat * normalize (vec3 (uv, 5.));\n  stDat = Loadv4 (vec2 (0, nBallE.y));\n  spLen = stDat.x;\n  dstFar = 160.;\n  sunDirEx = vuMat * normalize (vec3 (-0.5, 1., -1.));\n  fragColor = vec4 (ExShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Antarctic Flag\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 400.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 0.25;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), -0.8 * pi * (2. * Fbm1 (0.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 8. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Antarctic Flag\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 400.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 0.25;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), -0.8 * pi * (2. * Fbm1 (0.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 8. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlSRl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2036, 2036, 2058, 2058, 3623], [3625, 3625, 3648, 3648, 3682], [3684, 3684, 3704, 3704, 4239], [4241, 4241, 4274, 4274, 5372], [5374, 5374, 5395, 5395, 5652], [5654, 5654, 5691, 5691, 6100], [6102, 6102, 6136, 6136, 6389], [6391, 6391, 6414, 6414, 6954], [6956, 6956, 6988, 6988, 7456], [7458, 7458, 7493, 7493, 7946], [7948, 7948, 7982, 7982, 8656], [8658, 8658, 8693, 8693, 10994], [10996, 10996, 11021, 11021, 11088], [11090, 11090, 11115, 11115, 11649], [11676, 11676, 11696, 11696, 11723], [11725, 11725, 11760, 11760, 12841], [12843, 12843, 12864, 12864, 12923], [12925, 12925, 12943, 12943, 13080], [13082, 13082, 13120, 13120, 13504], [13506, 13506, 13566, 13566, 14314], [14316, 14316, 14340, 14340, 14740], [14742, 14742, 14779, 14779, 15793], [15795, 15795, 15851, 15851, 16549], [16551, 16551, 16584, 16584, 16611], [16613, 16613, 16655, 16655, 16706], [16708, 16708, 16743, 16743, 16805], [16807, 16807, 16831, 16831, 17061], [17063, 17063, 17087, 17087, 17147], [17149, 17149, 17173, 17173, 17290], [17292, 17292, 17314, 17314, 17352], [17354, 17354, 17376, 17376, 17414], [17416, 17416, 17461, 17461, 17564], [17566, 17566, 17623, 17623, 17706], [17708, 17708, 17744, 17744, 17950], [17952, 17952, 17982, 17982, 18095], [18129, 18129, 18153, 18153, 18213], [18215, 18215, 18239, 18239, 18292], [18294, 18294, 18318, 18318, 18448], [18450, 18450, 18475, 18475, 18621], [18623, 18623, 18648, 18648, 18834], [18836, 18836, 18858, 18858, 19012], [19014, 19014, 19035, 19035, 19190], [19192, 19192, 19221, 19221, 19433], [19435, 19435, 19474, 19474, 19654], [19721, 19721, 19745, 19745, 19795]], "test": "untested"}
{"id": "fslSzs", "name": "morphing balanced isolines-sbd", "author": "FabriceNeyret2", "description": "SPACE to toggle turbulence vs bozo noise.\nusing 1pix-width lines drawing + lines density gradient.  switch #8 for wrong-but-nice isolines.", "tags": ["procedural", "noise", "perlin"], "likes": 11, "viewed": 350, "published": 3, "date": "1619075007", "time_retrieved": "2024-07-30T19:24:18.481760", "image_code": "// \"morphing\" horizontal move variant of https://shadertoy.com/view/fdXXR2\n// gradient + 1pix-width lines + flownoise variant of https://shadertoy.com/view/NdXXRj\n// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. ) \n                //  *  mat2(cos(iTime+vec4(0,11,33,0)))\n  #define draw(v,d)    clamp(1. - abs( fract(v-.5) - .5 ) / (d), 0.,1.) // correct version\n//#define draw(v,d)    clamp(1. - abs( fract(v   ) - .5 ) / (d), 0.,1.) // nicer here :-)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n//#define func( P )  ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n  #define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(.5*iTime,0.);\t\n    O-=O;\n\tfloat l, dl, f = func(P), df;\n#if 0\n    l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));              // subvid amount (relative)\n    dl =     fract(log2(2.*fwidth(P.x)/fwidth(f)));      \n#else\n    l = exp2(floor(log2(1./22./fwidth(f))));                      // subvid amount (absolute)\n    dl =     fract(log2(1./22./fwidth(f)));\n#endif\n\n    f *= .5-.5*cos(6.28*u.x/R.x) + 1e-5;\n#if 0                                                             // draw isolines using sin\n    O = vec4(.5+.5*  mix( sin(50.*l*f) , sin(100.*l*f), dl ) ); \n#else                                                             // draw isolines \n    df = fwidth(f);\n // df = length( vec2( ( func(P + eps.xy), func(P + eps.yx) ) -f ) / eps.x )*fwidth(P.x);\n    l *= 8.; \n    O += mix( draw(    f*l,    l*df ),\n              draw( 2.*f*l, 2.*l*df ),\n              dl );\n#endif\n    \n    O = sqrt(O);                                                  // to sRGB\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[907, 907, 930, 930, 1223], [1225, 1225, 1249, 1304, 1463], [1465, 1465, 1503, 1503, 2561]], "test": "untested"}
{"id": "NdsXRs", "name": "isolines radial gradient 2", "author": "FabriceNeyret2", "description": "SPACE to toggle turbulence vs bozo noise.\nwidth compensating scarity variant of [url]https://shadertoy.com/view/fdXXRX[/url]\n\n( variant of balanced isolines )", "tags": ["procedural", "noise", "perlin"], "likes": 29, "viewed": 720, "published": 3, "date": "1619074652", "time_retrieved": "2024-07-30T19:24:19.471115", "image_code": "// width compensing scarity variant of https://shadertoy.com/view/fdXXRX\n// variant of https://shadertoy.com/view/fdXXR2\n// gradient + 1pix-width lines + flownoise variant of https://shadertoy.com/view/NdXXRj\n// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. ) \\\n                    *  mat2(cos(iTime+vec4(0,11,33,0)))\n  #define draw(v,d,w)  clamp(1. - abs( fract(v-.5) - .5 ) / (d) + w, 0.,1.) // correct version\n//#define draw(v,d,w)  clamp(1. - abs( fract(v   ) - .5 ) / (d) + w, 0.,1.) // nicer here :-)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n//#define func( P )  ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n  #define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O = vec4(0);\n\tfloat l, dl, f = func(P),\n // df = fwidth(f);\n    df = length( ( vec2( func(P + eps.xy), func(P + eps.yx) ) -f ) / eps.x )*fwidth(P.x);\n#if 0\n    l = exp2(floor(log2(2.*fwidth(P.x)/df)));              // subvid amount (relative)\n    dl =     fract(log2(2.*fwidth(P.x)/df));      \n#else\n    l = exp2(floor(log2(1./22./df)));                      // subvid amount (absolute)\n    dl =     fract(log2(1./22./df));\n#endif\n\n    U -= .5*R/R.y;\n    float w = .5*( 1.1+sin( 4.*(dot(U,U)-.5*iTime)) );\n    f *= w;\n // f *= exp(- 4.* dot(U,U));\n // f *= max(.1, 1.-4.*dot(U,U));\n#if 0                                                      // draw isolines using sin\n    O = vec4(.5+.5*  mix( sin(50.*l*f) , sin(100.*l*f), dl ) ) * hue(6.*l); \n#else                                                      // draw isolines \n    df *= w;\n    l *= 8.; \n# if 1                                                     // BW\n    O += mix( draw(    f*l,    l*df , .5/w ),\n              draw( 2.*f*l, 2.*l*df , .5/w ),\n              dl ); // * hue(6.*l);\n# else                                                     // color\n    O  = mix( draw(    f*l,    l*df , .5/w ) * hue(   f*l*.1),\n              draw( 2.*f*l, 2.*l*df , .5/w ) * hue(2.*f*l*.1),\n              dl ); \n# endif\n#endif\n    \n    O = sqrt(O);                                           // to sRGB\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsXRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[962, 962, 985, 985, 1278], [1280, 1280, 1304, 1359, 1518], [1520, 1520, 1558, 1558, 3022]], "test": "untested"}
{"id": "NdsXzl", "name": "Bismuth crystals", "author": "jarble", "description": "These pattern reminds me of bismuth crystals.", "tags": ["fractal", "spiral", "bismuth"], "likes": 11, "viewed": 454, "published": 3, "date": "1619063817", "time_retrieved": "2024-07-30T19:24:20.540256", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.1;\n        float scale1 = 1.13;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1;\n            uv = fract(-uv.yx/s1)*s1;\n                        \n\n            uv.y /= -scale1;\n            //scale1 += (uv.x*(.0005*fract(uv.x+iTime/4.)));\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        //        col[2] = fract((uv.y)-(uv.x));\n\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsXzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 933]], "test": "untested"}
{"id": "NdsSzl", "name": "Pseudo-3D fractal", "author": "jarble", "description": "This 2D fractal makes a convincing 3D illusion.", "tags": ["3d", "fractal", "spiral"], "likes": 6, "viewed": 282, "published": 3, "date": "1619059680", "time_retrieved": "2024-07-30T19:24:21.634331", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv.y += (iTime)/8.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.48;\n        float scale1 = 1.045;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv = fract(-uv.yx/s1)*scale;\n            uv.x *= scale1;\n            uv= fract(uv+((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 786]], "test": "untested"}
{"id": "fdsSzl", "name": "Spirals and Gems", "author": "jarble", "description": "These \"gems\" are separated by many spiral patterns.", "tags": ["fractal", "spiral", "metal", "gem"], "likes": 3, "viewed": 305, "published": 3, "date": "1619058634", "time_retrieved": "2024-07-30T19:24:22.595760", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv.y += (iTime)/8.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.35;\n        float scale1 = 1.07;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv = fract(-uv.yx/s1)*s1;\n            uv.y /= -scale1;\n            uv= fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            \n            //scale += (uv.x*(.005*fract(uv.x+iTime)));\n            //make it dance!\n        }\n        col[2] = abs(uv.y-uv.x);\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsSzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 839]], "test": "untested"}
{"id": "fssXRl", "name": "Iridescent spirals", "author": "jarble", "description": "These warped and distorted spirals have some \"iridescent\" patterns.", "tags": ["fractal", "spiral"], "likes": 11, "viewed": 433, "published": 3, "date": "1619057185", "time_retrieved": "2024-07-30T19:24:23.474411", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv.y += (iTime)/8.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.25;\n        float scale1 = 1.07;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv = fract(uv.yx/s1)*s1;\n            uv= fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.y /= -scale1;\n            \n            //scale1 -= (uv.x*(.005*fract(uv.x+iTime/2.)));\n            //make it dance!\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.0;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 854]], "test": "untested"}
{"id": "fdsXRl", "name": "dangerous curves v3", "author": "jorge2017a1", "description": "dangerous curves v3", "tags": ["dangerouscurvesv3"], "likes": 7, "viewed": 294, "published": 3, "date": "1619056452", "time_retrieved": "2024-07-30T19:24:24.688166", "image_code": "//por jorge2017a1-\n// referencia \n//----------------- pjkarlik \n///----------------Shane-------------- Voxel Corridor\n//https://www.shadertoy.com/view/tdVyzV\n//https://www.shadertoy.com/view/MdVSDh\n//https://www.shadertoy.com/view/4dfBWH   ...Road Raster Color\n\n#define MAX_STEPS 100\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n// path functions \nvec2 path(in float z)\n{ \n    vec2 p1 =vec2(2.13*sin(z * .15), 1.74*cos(z * .085));\n    vec2 p2 =vec2(2.97*sin(z * .079), 1.23*sin(z * .127));\n    return p1 - p2;\n}\n// Repeat space along one axis.\nfloat pMod(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n   \n   ///https://www.shadertoy.com/view/tdVyzV\n   p.y=p.y-5.0;\n   vec2 qath = p.xy - path(p.z);\n   vec3 q = vec3(qath,p.z);\n   vec3 dq = q;\n   \n    vec3 r = dq;\n    pMod(r.z,3.);\n    vec3 r2=r;\n    vec3 r3=r;\n    \n   \n    r = vec3((r.x)-10.0,r.y-3.5,r.z);\n    r2 = vec3(abs(r2.x)-10.0,r2.y-1.0,r2.z);\n    r3 = vec3(r3.x,r3.y+1.0,r.z);\n    \n  \n   float banqueta= sdBox(r2, vec3(1.0,1.0,10.0) );\n   float calle= sdBox(r3, vec3(10.0,1.0,10.0) );\n   \n   dq.x=abs(dq.x)- 11.0;\n   dq.y-=5.0;\n   dq.z= opRep1D( dq.z, 10.0 );\n   float poste= sdBox( dq, vec3(1.0,10.0,1.0) );\n  \n   res =opU3(res, vec3(poste,8.0,-1.0));\n  \n   res =opU3(res, vec3(banqueta,6.0,-1.0));\n   res =opU3(res, vec3(calle,-1.0,7.0));\n   \n    //return (dist, id_color, id_material)\n    return res;\n}\n///------------------------------------\n//Shane --------https://www.shadertoy.com/view/MdVSDh\n// The brick groove pattern. Thrown together too quickly.\n// Needs some tidy up, but it's quick enough for now.\n//\nconst float w2h = 2.; // Width to height ratio.\nconst float mortW = 0.05; // Morter width.\n\nfloat brickMorter(vec2 p)\n{\n    p.x -= step(1., p.y)*.5;\n    p = abs(fract(p + vec2(0, .5)) - .5)*2.;\n    // Smooth grooves. Better for bump mapping.\n    return smoothstep(0., mortW, p.x)*smoothstep(0., mortW*w2h, p.y);\n}\n\nfloat brick(vec2 p)\n{   p = fract(p*vec2(0.5/w2h, 0.5))*2.;\n    return brickMorter(p);//*(brickShade(p)*.25 + .75);\n}\n\n/*\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p, in vec3 n)\n{\n    n = abs(n);\n    if (n.x>0.5) p.xy = p.zy;\n    else if (n.y>0.5) p.xy = p.zx;\n    return brick(p.xy);\n}\n*/\n// correcion por Shane ..dia 24/abril/2021\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p, in vec3 n)\n{\n   p.xy -= path(p.z);\n    n = abs(n);\n    if (n.x>0.5) p.xy = p.zy;\n    else if (n.y>0.5) p.xy = p.zx;\n    return brick(p.xy);\n}\n\n\n// Standard function-based bump mapping function.\n\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor)\n{   const vec2 e = vec2(0.01, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n    grad -= nor*dot(nor, grad);          \n    return normalize( nor + grad*bumpfactor );\n}\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p, bool sombra)\n{ \n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    vec3 nor= normalize(n);\n    \n    if (sombra==true) return nor;\n    \n    if (mObj.id_material==7.0)\n     return nor;\n    else\n     return doBumpMap( p, nor,10.0);\n    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false;    minDist = dO;    break; } \n        dO += dS.x;\n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p, false);\n    mObj.phit=p;\n    return dO;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p, true);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n///============================================================\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\n\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{   vec3 l = normalize(lp - p);\n    vec3 r = reflect(-l, n);\n    float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{\n    vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(0.,dot(ldir,-n));\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    \n    if (mObj.blnShadow==true)\n    { fshadow=GetShadow(p,lp);}\n    else\n    {   fshadow=0.5; }\n\n    \n    vec3 lin = amb;\n    lin += 1.0*(dif+diff)*sh;\n    lin += 2.5*spe;\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    \n    lin *= atten*0.8*col*fshadow;\n    lin = pow(lin,vec3(0.4545));\n  return lin;\n    \n}\n///============================================================\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 montana(  in vec3 puv  )\n{\n\t\n    vec2 uv=puv.xy*5.5;\n    uv.x-=2.0;\n    vec3 rd=puv;\n    \n    uv.y+=1.0;\n    vec2 turn = uv;\n    float ti=iTime*2.0;\n    turn.x+=cos(ti*1.5+uv.y*10.0)*0.15+cos(ti+uv.y*10.0)*0.15;\n    float turntime=cos(ti*1.5+2.0)*0.15+cos(ti+2.0)*0.15;\n    \n    float ground=abs((turn.x-0.5)/(-turn.y*1.15+0.6));\n    ground=round(pow(3.0*ground,2.0));\n        \n    vec3  groundcolor=vec3(0.3,0.3,0.3);;\n    \n    if(uv.y<0.5)\n    {\n    \n        if(ground==0.0){groundcolor=vec3(0.3,0.3,0.3);}\n        if(ground==1.0){groundcolor=vec3(0.2,0.2,0.2);}\n        if(ground==2.0){groundcolor=vec3(1.0,0.6,0.2);}\n        if(ground==3.0){groundcolor=vec3(0.0,0.6,0.2);}\n        if(ground>=4.0){groundcolor=vec3(0.0,0.4,0.2);}\n        groundcolor*=clamp(round((sin((5.0/(0.55-uv.y*0.90))+(iTime*18.0+sin(iTime)*8.0))+1.0)*0.5)+0.8,0.0,1.0);\n    }else{\n        \n        float mountain=round((cos((uv.x*0.5+turntime+0.7)*7.0)+cos((uv.x+turntime))+cos((uv.x+turntime)*13.0)+2.0)-(uv.y*3.0));\n        groundcolor=vec3(0.0,mountain*0.3,mountain*0.15); \n        \n        if(groundcolor.y<=0.0)\n        { //groundcolor=vec3(0.0,0.6,1.0);   \n            float t = (rd.x + 1.0) / 2.0;\n            vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n            vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n            groundcolor=sky;\n        }\n    }\n\treturn groundcolor;\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{ \n     vec3 m1= montana(rd );\n    return m1;\n}\n\n///-------------------------------------------\n\nfloat c = 0.5;\nfloat s = 0.5*sqrt(3.0);\n\nconst int lkup[16] = int[16](\n\t0, 1, 2, 3,\n\t3, 1, 2, 0,\n\t0, 2, 1, 3,\n\t3, 2, 1, 0 );\n\nvec3 cairo( in vec2 puv )\n{ \n    vec4 col; \n    vec2 wpos=puv*0.5;\n    //\n    \n\tvec2 r = mod(wpos, 2.0);\n\tvec2 r2 = mat2(c,-s,s,c) * (min(r, 2.0-r) - 0.5);\n\n    int cell = ((r2.x>0.0) ?2:0);\n    cell=cell+ ((r2.y>0.0)? 1: 0);\n    \n\tint cidx = ((r.y>1.0)?8:0) + ((r.x>1.0)?4:0) + cell;\n\tint c = lkup[cidx];\n\n    if( c == 0 ) {\n\t\tcol = vec4( 88.0 / 255.0, 140.0 / 255.0, 94.0 / 255.0, 1.0 );\n\t} else if( c == 1 ) {\n\t\tcol = vec4( 191.0 / 255.0, 67.0 / 255.0, 105.0 / 255.0, 1.0 );\n\t} else if( c == 2 ) {\n\t\tcol = vec4( 128.0 / 255.0, 38.0 / 255.0, 64.0 / 255.0, 1.0 );\n\t} else {\n\t\tcol = vec4( 163.0 / 255.0, 204.0 / 255.0, 153.0 / 255.0, 1.0 );\n\t}\n    \n     col = .5 + .45*cos(6.2831*float(c)/10. + vec4(0, 1, 2, 0)); \n     vec3 col3=col.xyz;\n    return  col3*col3;\n}\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    if (id_material==6.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n              l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n    }\n    \n    if (id_material==7.0)\n    {\n        vec3 col= cairo(p.xz );\n    return col;\n    }\n    \n }\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n     if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,\n        1.055 * pow(c, vec3(1.0/2.4)) - 0.055,\n        step(vec3(0.0031308), c)\n    );\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p ;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        p = (ro + rd * d );  \n         \n         \n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n        col=linear2srgb(col);\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   \n   return col;\n}\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*8.0,1000.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( 0.0, 10.0, 10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,10.0,-25.0+t);\n   ro.xy += path(ro.z);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "//por jorgefloresp\n//referencia \n//https://www.shadertoy.com/view/ssfSzs  //khlorghaal\n\nvec2 mainSound( int samp, float time )\n{\n    float t= time;\n    float a1= sin(6.2831*440.0*t+sin(t*411.))*(.44*sin(t*210.));\n    float a2= sin(6.2831*450.0*t+sin(t*450.))*(.44*sin(t*110.0));\n    float a3= sin(6.2831*150.0*t+sin(t*650.))*(.044*sin(t*10.0));\n    float a4= 3.0*cos(a1-a2)*sin(a3);\n    return vec2(a1+a2+a3+a4);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsXRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[723, 723, 759, 759, 780], [781, 781, 813, 813, 897], [899, 937, 973, 973, 1018], [1019, 1084, 1118, 1118, 1216], [1217, 1217, 1251, 1251, 1343], [1344, 1344, 1378, 1378, 1470], [1471, 1511, 1545, 1545, 1642], [1644, 1663, 1686, 1686, 1826], [1827, 1859, 1898, 1898, 2031], [2032, 2072, 2097, 2097, 2912], [3214, 3214, 3241, 3241, 3435], [3437, 3437, 3458, 3458, 3554], [3556, 3882, 3923, 3923, 4052], [4106, 4106, 4164, 4164, 4522], [4525, 4576, 4613, 4613, 4951], [4953, 4953, 5002, 5002, 5655], [5656, 5710, 5746, 5746, 5999], [6000, 6064, 6091, 6091, 6108], [6110, 6110, 6146, 6146, 6238], [6240, 6240, 6286, 6286, 6418], [6420, 6420, 6494, 6494, 7617], [7618, 7682, 7762, 7762, 7894], [7895, 7936, 7967, 7967, 9356], [9359, 9359, 9391, 9391, 9437], [9613, 9613, 9640, 9640, 10376], [10379, 10430, 10477, 10477, 11115], [11116, 11168, 11261, 11261, 11535], [11537, 11586, 11612, 11612, 11736], [11738, 11738, 11796, 11796, 11848], [11850, 11850, 11881, 11881, 12533], [12537, 12586, 12643, 12643, 13187]], "test": "untested"}
{"id": "7dXSzs", "name": "interesting pattern 2", "author": "sympou", "description": "an experiment with multiple neighborhoods cellular automata.", "tags": ["cellularautomata"], "likes": 8, "viewed": 265, "published": 3, "date": "1619050649", "time_retrieved": "2024-07-30T19:24:25.785233", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float val = texelFetch( iChannel0, ivec2(fragCoord), 0 ).r;  \n    fragColor = vec4( val*val,val,1.-cos(val*3.1415), 1.0 );\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float radius = 15.0;\nint eyes = 3;\nfloat PI2 = 6.28318530718;\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\nfloat Cell( in vec2 p ) {   \n    p /= iResolution.xy;\n    p = fract(p);\n    return texture(iChannel0, p).r; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 coords = vec2( fragCoord );\n    float pixel = Cell(coords);\n    \n    float random = hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1)+mod(iTime,10000.));\n\n    float valMax = 0.0;\n    float valMin = 1.0;\n    float average = 0.0;\n    \n    float fraction = PI2/float(eyes);\n    for (int i = 0; i<eyes; i++) {\n        \n        float ang = fraction*float(i)+random*PI2;\n        vec2 dir = vec2(cos(ang),sin(ang));\n        vec2 xy = coords + dir * radius;\n        \n        float value = Cell(xy);\n        \n        average += value;\n        valMax = max(valMax, value);\n        valMin = min(valMin, value);\n    }\n    average = average/(float(eyes));\n    float average2 = (valMin + valMax)*0.5;\n    \n    float diff = valMax - valMin;\n\n    float finalPix;\n\n    if (diff>0.4) {\n        //chaos\n        finalPix = pixel - (average-0.5)*0.5;\n    } else {\n        //order\n        finalPix = pixel + (average-0.5)*0.065;\n    }\n        \n    finalPix = clamp(finalPix,0.0,1.0);\n\n    //blurring\n    //finalPix = mix(finalPix,average,0.13);\n    finalPix = mix(finalPix,average2,0.035);\n    \n         \n    if( iFrame==0 ) finalPix = random;\n    \n\tfragColor = vec4(finalPix,0,0,1);\n} ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 189]], "test": "untested"}
{"id": "ssXSRs", "name": "already there", "author": "nabr", "description": "abstract futuristic structure in black and white", "tags": ["raymarch", "sound", "fm", "pathtracer", "scifi", "synth", "warmandclose", "detuned", "futurism"], "likes": 12, "viewed": 449, "published": 3, "date": "1619041476", "time_retrieved": "2024-07-30T19:24:26.660891", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(abs(fragCoord.x*2.-iResolution.x)/iResolution.y<1.3)\n    fragColor = vec4(3.2*(c.xyz/c.w)+.05, 1);//contrast,brightness\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// hash and seed demofox>website>pathtracing-tutorial\nuint wang_hash(inout uint seed){seed=uint(seed^uint(61))^uint(seed>>uint(16));seed*=uint(9);seed=seed^(seed>>4);seed*=uint(0x27d4eb2d);seed=seed^(seed>>15);return seed;}\nfloat hashf(inout uint state){return float(wang_hash(state))/4294967296.;}\n//smoothUnion and sdBox by iq>website\nfloat sU( float d1, float d2, float k ){float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat sdBox(vec3 p, vec3 s) {p = abs(p) - s;return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);}\n#define dmin(a,b)((a.x<b.x)?a:b)\nvec2 f(vec3 p) \n{   \n    float c = 2.5;\n    //room\n    float rm = sdBox(vec3(p.x, p.y-.4, p.z), vec3(3, 1.5, 5.));\n    rm = abs(rm);\n    //door\n    float lt = sdBox(vec3(p.x, p.y+.15, p.z+4.95), vec3(.25, .5, .15));\n    float ppz = (p.z +1.2);\n    //circular lights\n    vec3 vslt = vec3(.8 * .5 - mod( max(0., cos(.2*p.z) + atan(p.y, p.x) ), .8),  length(p.xy) - 1.25,\n    ppz - c * clamp(round(ppz / c), -1., 1.5) );\n    vslt = abs(vslt) - vec3(.01, .01, 1.);\n    float slt = length(max(vec3(0), vslt)) + min(max(vslt.x, max(vslt.y, vslt.z)), 0.) -0.01;\n    //tubelights\n    float lz = p.z - c * clamp(round(p.z / c), -1., 1.);\n    float rr = length(vec2(min(-(length(vec2(p.x, p.y)) - 1.25), max(-1., p.y + .75)), lz)) - .05;\n    //frame \n    float fr = sdBox(vec3(lz,length(vec2(max(1., abs(p.x)),min(p.y - .45, -max(0.5, abs(p.y + .1) - .4)))) - 1.6, lz),vec3(.1, .05, 1));\n    //connections\n    float hlt = sdBox(vec3(2.*.5-mod(max(0.,atan(p.y, p.x) * 7.639), 2.),lz, length(vec2(p.x, p.y)) - 1.4), vec3(.1, .05, .3));\n    //path\n    float wlk = sdBox(vec3(p.x,p.y+.7,p.z), vec3(.35, .05, 3.8));\n    \n    return dmin(dmin(vec2(min(sU(fr, hlt, .1), rm), 11), dmin(vec2(rr, 7),vec2(min(slt, lt), 5))), vec2(wlk, 13));;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    if(iFrame > 0)fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = vec3(1e-6);\n    vec2 R = iResolution.xy,  h = vec2(0);\n    uint seed = (uint(fragCoord.x) * 1973u + uint(fragCoord.y) * 9277u + uint(iFrame) * 2669u) | 1u;\n    vec2 jjt = vec2(cos(R.y*hashf(seed)),sin(R.y*hashf(seed))),st =((fragCoord+jjt)*2.-R)/R.y;\n    vec3 ro = vec3(0,0,4.9),rd = normalize(vec3(st,-1.7));\n    vec3 memi = vec3(0), hput = vec3(.974);\n    if(abs(st.x)<1.3)\n    for(int b = 1; b < 6 + min(iFrame, 0); b++) \n    {\n        float t = 0.;\n        for(int i = 0; i < 80; i++) \n        {\n            h = f(ro + t * rd );\n            if(abs(h.x) < t *.001 || t > 10.)break;\n            t += h.x;\n        }\n       ro += t * rd;\n       //lights  - backward tracing from an artistically thought light source\n       vec3 ld = (h.y!=13.&&h.y!=7.)?(vec3(0, 3, .5 ) - ro):(vec3(0, 1., -5. ) + ro);\n       ld = normalize(ld);\n       //http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n       vec3 u = ((ld.x > ld.z ) ? vec3(-ld.y, ld.x, 0.) : vec3(0., -ld.z, ld.y)), v = cross(ld, u);\n       float phi = hashf(seed) * 6.283185, th = hashf(seed) * 2. - 1.,sth = sin(th);\n       rd =  normalize(u * cos(phi) * sth + v * sin(phi) * sth + ld * cos(th));\n       //dim the tube lights\n       if(h.y==5.){hput = vec3(.9);memi=vec3(.3);}\n       if(h.y==7.){hput = vec3(.1);memi=vec3(.1);}\n       col += memi * hput;\n    }\n    //reinhard gamma\n    col= col/(1.+col); \n    fragColor += vec4(pow(col,vec3(0.4545)),1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define _f(x) fract(x)\n\nfloat f(float tm, float rt, int ch )\n{\n    float f = 0., ff = 0., ft1 = _f(.5 * tm);\n    \n    f = sin(4186.01 * rt) * exp(-3.588 * ft1);\n    f *= min(1., 1378.125 * ft1) * max(0., 1. - ft1);\n    ff = f;\n    if (ch == 0)\n        ff *= cos(tm + 220.00 * exp(-0.01 * pow(1. - ft1, 12.))); // tremolo\n          // fuzzy\n          //the hairiness in all of this much more subtle with higher floating point res. \n          //such as desktop opengl compute shader, readpixels from 32 bit floating point texture\n    float fu = .8*sin(tm); // cos(tm) nummericly correct i just like the sin sound more \n    \n    //based on one pole filter push the lows then duck the  heights\n    return sin(sin(fu + f * 3.141594) + .1) / (1.725 - cos(10. * ff));\n}\nvec2 mainSound(int samp, float time)\n{\n    vec2 y = vec2(1e-6), b = y;\n    float Fs = (1. / iSampleRate);\n    float t0 = float( samp ) * Fs, x = 1., a = t0, t1 = t0,\n          dtn = .3*cos(6.*a)+sin(3.*a);\n    int it = 5;\n    for(int i=0;i<it;i++)\n    {\n        if(time>12.&&1.< time/11.)\n        {\n        float bft =t1;\n        vec2 bt = vec2(4.,3.);\n        if(time>43.)bt+=1.;\n        if(time>25.){\n            bft = ((mod(t1, bt.x)  < bt.y) ? t1: 2. * t1 );\n            }\n        float u = .25 * bft *vec3(1.5, 1.25, .5)[ abs(i + int( bft )) %3];\n        b += vec2( f( 3.+ t1 , u, 1  ), f(4.+t1,  u, 1 ) );\n        dtn *= .2;\n        }\n        float mx = i == 0 ? .5 : 1.;\n        y += vec2(f(.1*a+21., mx * t0  + 1.57, 0), f(.1*a+11., mx * t0  + 3.1, 0));\n        x +=  .5 - Fs * dtn;\n        a += t0;\n        t0 = abs(.5 * t0 * ( .5  - x));\n        t1 = abs(t1 * ( 1. - x));\n    }\n    return vec2( 1./float(2*it) ) * (b+y);\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 243]], "test": "untested"}
{"id": "sdXSRf", "name": "interesting pattern", "author": "sympou", "description": "currently experimenting with multiple neighborhoods cellular automata.\ni like this arrangement !\ni found the palette here :\nhttps://www.shadertoy.com/view/lt2GDc", "tags": ["cellularautomata"], "likes": 14, "viewed": 513, "published": 3, "date": "1619032982", "time_retrieved": "2024-07-30T19:24:27.527574", "image_code": "vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float val = texelFetch( iChannel0, ivec2(fragCoord), 0 ).r;\n   \n    vec3 col = pal(val,vec3(0.5),vec3(0.55),vec3(0.45),vec3(0.00,0.10,0.20) + 0.47 );\n\n    fragColor = vec4( col, 1.0 );\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float radius = 10.0;\nint eyes = 11;\nfloat PI2 = 6.28318530718;\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\nfloat Cell( in vec2 p ) {   \n    p /= iResolution.xy;\n    p = fract(p);\n    return texture(iChannel0, p).r; \n}\n\nconst int KEY_SPACE = 32;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 coords = vec2( fragCoord );\n    float pixel = Cell(coords);\n    \n    float random = hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1)+mod(iTime,10000.));\n\n    float valMax = 0.0;\n    float valMin = 1.0;\n    float average = 0.0;\n    \n    float fraction = PI2/float(eyes);\n    for (int i = 0; i<eyes; i++) {\n        \n        float ang = fraction*float(i);//+random*PI2;\n        vec2 dir = vec2(cos(ang),sin(ang));\n        vec2 xy = coords + dir * radius;\n        \n        float value = Cell(xy);\n        \n        average += value;\n        valMax = max(valMax, value);\n        valMin = min(valMin, value);\n    }\n    average = average/(float(eyes));\n    //float average2 = (valMin + valMax)*0.5;\n    \n    float diff = valMax - valMin;\n\n    float finalPix = pixel;\n\n    if (diff>0.25) {\n        //chaos\n        finalPix = pixel - sign(average-0.5)*0.01; //0.025\n    } else {\n        //order\n        finalPix = pixel + sign(average-0.5)*0.1;  //0.015\n    }\n    \n    \n    //blurring\n    finalPix = mix(finalPix,average,0.13);\n    //finalPix = mix(finalPix,average2,0.2);\n         \n    if( iFrame==0 || texelFetch( iChannel1, ivec2(KEY_SPACE,1),0 ).x > 0.0 ) finalPix = random;\n    \n\tfragColor = vec4(finalPix,0,0,1);\n} ", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 111], [113, 113, 170, 170, 363]], "test": "untested"}
{"id": "fdfXzl", "name": "Pixel Ball Of Energy", "author": "BackwardsCap", "description": "A ball of energy test vfx for a game I am working on with a friend", "tags": ["noise", "ancient", "fonts", "symbols"], "likes": 9, "viewed": 349, "published": 3, "date": "1619026404", "time_retrieved": "2024-07-30T19:24:30.145575", "image_code": "//Pixelated Portal\n//by Sam Gates (BackwardsCap)\n\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    float downscale = 5.;\n    f /= downscale;\n    f = floor(f);\n    f *= downscale;\n    c.rgb = S0(f).rgb*0.9;\n    vec2 p = (2.0*f-R)/R.y;\n    \n    float a = (length(p)-1.)/2.;\n    vec3 ba = vec3(0);\n    for(int y=-4;y<=4;y++)\n    for(int x=-4;x<=4;x++)\n    {\n        vec2 o = vec2(x,y);\n        if(length(o)<66.)\n        ba+= S1(f+o).rgb;\n    }\n    \n    ba/=15.0;\n    \n    c.rgb+=ba*a;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R iResolution.xy\n#define PI 3.1415927\n#define T iTime*.35\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n\n    vec2 p = ((2.0*f-R)/R.y), u=p;\n    \n    \n    vec2 lp = (p);    \n    vec2 ap = vec2(atan(u.y, u.x), (length(u)));\n    float n = 5.;\n    c.rgb = vec3(0);\n    for(float x=0.; x<n;x++){\n        p=lp;\n        p +=vec2(cos(T-x*20.), sin(T+x*20.))*.4;\n        p*= (6.0/PI)* 5.;\n        c.rgb+=vec3(clamp(1.-(length(p+cos((ap.x+ap.y)*10.))-.1),0.,1.));    \n    }\n}", "buffer_a_inputs": [], "common_code": "#define R iResolution.xy\n#define S0(U) texture(iChannel0, (U)/R)\n#define S1(U) texture(iChannel1, (U)/R)\n#define S2(U) texture(iChannel2, (U)/R)\n#define V(U) S0(mod(U,R))\n\n#define decay .99\n\n//wrap the space (useful when sampling)\n#define A(U) T0(mod(U,R))\n\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p.xy,vec2(1879.13287,5712.1273)))*12893.1278);\n}", "buffer_b_code": "void F(vec2 p, vec2 offset, vec4 s, inout vec2 v, inout float pr, inout float d, inout float n)\n{\n    vec4 target = S0(p+offset-V(p+offset).xy);\n    offset=normalize(offset);\n    v+=offset*(target.w-s.w);\n    pr+=target.w;\n    d+=dot(offset,target.xy);\n    n++;\n}\n\nvoid mainImage(out vec4 s, vec2 p)\n{\n    s = S0(p-V(p).xy);\n    vec2 v = vec2(0), u = (2.0*p-R)/R.y;\n    float d = 0., pr=0.,n=0.;\n    \n    F(p, vec2(0,1), s, v, pr, d, n);\n    F(p, vec2(0,-1), s, v, pr, d, n);\n    F(p, vec2(1,0), s, v, pr, d, n);\n    F(p, vec2(-1,0), s, v, pr, d, n);\n    \n    d/=n;\n    pr/=n;\n    v/=n;\n    \n    s.w = pr-d;\n\ts.xy -= v;   \n    s.z = d;\n    \n    s.xy*=decay;\n    \n    vec2 ap = vec2(atan(u.x, u.y), length(u));\n    \n    \n    if(S1(p).r>0.)\n    {\n        float m = 1.;\n        if(length(p)>.5)m=-2.;\n        s.xy = normalize(u)*.45 * m;//* vec2(cos(iTime), sin(iTime)) * .1 + (hash21(ap+iTime))- .5;\n    }\n    \n    s.xy = clamp(s.xy, -1., 1.); \n    if (p.x<1.||p.y<1.||R.x-p.x<1.||R.y-p.y<1.) s.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void F(vec2 p, vec2 offset, vec4 s, inout vec2 v, inout float pr, inout float d, inout float n)\n{\n    vec4 target = S0(p+offset-V(p+offset).xy);\n    offset=normalize(offset);\n    v+=offset*(target.w-s.w);\n    pr+=target.w;\n    d+=dot(offset,target.xy);\n    n++;\n}\n\nvoid mainImage(out vec4 s, vec2 p)\n{\n    s = S0(p-V(p).xy);\n    vec2 v = vec2(0);\n    float d = 0., pr=0.,n=0.;\n    \n    F(p, vec2(0,1), s, v, pr, d, n);\n    F(p, vec2(0,-1), s, v, pr, d, n);\n    F(p, vec2(1,0), s, v, pr, d, n);\n    F(p, vec2(-1,0), s, v, pr, d, n);\n    \n    d/=n;\n    pr/=n;\n    v/=n;\n    \n    s.w = pr-d;\n\ts.xy -= v;   \n    s.z = d;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 state, vec2 f)\n{\n    for(int i=0;i<2;i++)\n    f -= S1(f).xy;\n \n    state = S0(f);\n    \n    state*=decay;\n    float t = iTime/5.0;\n    \n    if(S2(f).r>0.1)\n        state.rgb += vec3((cos(iTime/3.0)+1.0)/2., (1.1+sin(iTime/5.0))/2.0, cos(sin(iTime)))*.1;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfXzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 92, 92, 481]], "test": "untested"}
{"id": "fsXSzs", "name": "::one", "author": "shale", "description": "This year's Revision inspired me to finally start properly learning shader programming :D", "tags": ["2d", "3d", "raymarching"], "likes": 5, "viewed": 225, "published": 3, "date": "1619024268", "time_retrieved": "2024-07-30T19:24:31.058135", "image_code": "#define S(a,s) smoothstep((1./iResolution.y)*2.*s,0.,a)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define R(a,b) (b*rot(a))\n\nfloat spheres(vec2 p,float rep) {\n  p *= rep;\n  p = fract(p)-.5;\n  return 1.- S(length(p)-.02,10.);\n}\n\nfloat sdc(vec2 p, vec2 r) {\n  vec2 q = abs(p)-r;\n  return max(q.x,q.y);\n}\n\nfloat mp (vec3 p) {\n  p.y+=sin(iTime);\n  p.x+=cos(iTime*.2)*2.5;\n  \n  p.xy = R(iTime,p.xy);\n  p.xz = R(iTime*.3,p.xz);\n  p.yz = R(iTime*.2,p.yz);\n  p = abs(p);\n  p -=vec3(1.+sin(iTime)*.5);\n  p.y+=sin(iTime)*.1;\n  \n  float d = length(p)-1.;\n  d += sin(p.x*20.+iTime)*.01;\n  d += cos(p.z*17.+iTime)*.03;\n  d += cos(p.y*23.+.4+iTime)*.02;\n  return d*.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 tv = (fragCoord/iResolution.y);\n    vec3 blue = texture(iChannel0,uv+iTime).xyz;\n    \n    vec3 col = vec3(1.);\n    col *= spheres(tv+floor(iTime)*.234,10.);\n    \n    float redbox = sdc(R(.3,uv)+vec2(.0,.6),vec2(1.1,.3));\n    col = mix(col,vec3(1,0,.2), S(redbox,1.));\n    \n    float blackbox = sdc(R(-.3,uv)+vec2(.0,-.6),vec2(.1,.3));\n    col = mix(col,vec3(0,0,0), .9*S(blackbox,3.));\n    \n    float stripes = sdc(fract(tv *15. + -tv.y + iTime)-.5,vec2(.3,.5));\n    float sbound = sdc(uv+vec2(.65,.4),vec2(.2,.05));\n    stripes = max(stripes, sbound);\n    col = mix(col,1.-col, S(stripes,1.));\n    col = mix(col, 1.-col, S(abs(sbound)-.002,1.));\n    \n    vec3 p,ro=vec3(-2,0,-10), rd=normalize(vec3(uv+blue.xy*.01,1));\n    float i,d=0.,dd;\n    for(i=0.;i<100.;i++){p=ro+rd*d;dd=mp(p);d+=dd;\n    if (dd<0.001||d>100.)break;}\n    \n    float t = d/100.+i/100.;\n    if (dd<0.001) col = (1.-col) + t;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXSzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 166, 166, 234], [236, 236, 263, 263, 309], [311, 311, 330, 330, 664], [666, 666, 723, 723, 1726]], "test": "untested"}
{"id": "fdfSRs", "name": "Sinking Ocean in another cosmos", "author": "tomachi", "description": "This is largely an exact clone of Michael0884 inspirational work at: https://www.shadertoy.com/view/WtfyDj but with a few precious operations had their values increased to make it more vigorous! https://michaelmoroz.github.io/Reintegration-Tracking/\n ", "tags": ["multipass"], "likes": 1, "viewed": 281, "published": 3, "date": "1619022378", "time_retrieved": "2024-07-30T19:24:31.860988", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n   // return mix(a*a, b*b, clamp(k,0.,1.)) * vec3(sin(iTime *1.01)) ;\n\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime * 200.0 ;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    // tomachi commented:\n    particle P = getParticle(data, pos);\n//    particle P = \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-2., 0., 2.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.5, 0.);\n    vec3 col1 = vec3(0.1, 0.4, 1.);\n\tvec3 fcol = mixN(col0, col1, tanh(3.*(rho.w - 0.7))*0.5 + 0.5);\n    // Output to screen\n  //   col = vec4(2.5);\n    col = rho;\n    col.xyz = mixN(col.xyz, fcol.xyz*(1.05*b + specular*5.), a);\n    col.xyz = mixN(col.xyz, 0.*vec3(0.5,0.5,1.), bord);\n    col.xyz = tanh(col.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 150.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(vec2 rho)\n{\n    //return 0.2*rho.x; //gas\n   // float GF = 1. -  smoothstep(0.49, 0.5, 1. - rho.y);\n   // float GF = 1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    float GF =  smoothstep(0.49, 0.5, 1. * rho.y);\n\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw * 1.0002353; // that should explode\n  //  P.M =vec2(0., 0.);// hack\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.12\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}\n\n/*\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}*/\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = 0.9 + 0.21*smoothstep(fluid_rho*0., fluid_rho*0.333, P0.M.x);\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n    \n    //gravity\n    F += P.M.x*vec2(0., -0.0004);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    // pressure limit\n    float pressure = dot(P.M, P.V) ;\n//    if ( pressure > 1000. ) { P.M = vec2(0., 100.); }\n    if ( pressure > 395.19 ) { \n        P.M = vec2(0.00001, 1.);\n        P.V *= 2.;\n    }\n\n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.) \n        {\n            P.X = pos;\n            P.V = 100.5*(rand.xy-0.5) + vec2(10., 0.);\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    if(length(P.X - R*vec2(0.8, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 - PI*0.5 + 0.3*sin(0.4*time));\n        P.M = mix(P.M, vec2(fluid_rho, 1.), 0.4);\n    }\n\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 243, 313, 364], [366, 366, 382, 382, 410], [412, 412, 457, 457, 1689]], "test": "untested"}
{"id": "fsXSRs", "name": "Boiling Ocean in Another Cosmos", "author": "tomachi", "description": "This is largely an exact clone of Michael0884 inspirational work at: https://www.shadertoy.com/view/WtfyDj but with a few precious operations had their values increased to make it more vigorous! https://michaelmoroz.github.io/Reintegration-Tracking/\n ", "tags": ["multipass"], "likes": 0, "viewed": 323, "published": 3, "date": "1619020652", "time_retrieved": "2024-07-30T19:24:32.941100", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n   // return mix(a*a, b*b, clamp(k,0.,1.)) * vec3(sin(iTime *1.01)) ;\n\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime * 200.0 ;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    // tomachi commented:\n    particle P = getParticle(data, pos);\n//    particle P = \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-2., 0., 2.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.5, 0.);\n    vec3 col1 = vec3(0.1, 0.4, 1.);\n\tvec3 fcol = mixN(col0, col1, tanh(3.*(rho.w - 0.7))*0.5 + 0.5);\n    // Output to screen\n  //   col = vec4(2.5);\n    col = rho;\n    col.xyz = mixN(col.xyz, fcol.xyz*(1.05*b + specular*5.), a);\n    col.xyz = mixN(col.xyz, 0.*vec3(0.5,0.5,1.), bord);\n    col.xyz = tanh(col.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n#define gravity -0.0017\n#define magic_value 1.0013\n#define dt 1.5\n#define border_h 350.\n\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(vec2 rho)\n{\n   // return 0.2*rho.x; //gas\n    //float GF = 1. -  smoothstep(0.49, 0.5, 1. - rho.y);\n   // float GF = 1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    float GF =  smoothstep(0.49, 0.5, 1. * rho.y);\n\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw * magic_value; // that should explode\n  //  P.M =vec2(0., 0.);// hack\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.12\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}\n\n/*\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}*/\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = 0.9 + 0.21*smoothstep(fluid_rho*0., fluid_rho*0.333, P0.M.x);\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n    \n    //gravity -0.0004\n    F += P.M.x*vec2(0., gravity);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/50.; \n        float d = distance(Mouse.xy, P.X)/100.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    // pressure limit\n    float pressure = dot(P.M, P.V) ;\n//    if ( pressure > 1000. ) { P.M = vec2(0., 100.); }\n    if ( pressure > 100. ){ \n      //  P.M = vec2(0.0000000000001, -1500.);\n      //  P.M = vec2(0.00000001, -1500.);\n        P.M = vec2(0.000000000000, -1500.);\n        P.M.xy = vec2(0.000000000000, -1000.);\n       P.V *= 0.5;\n    }\n\n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.) \n        {\n            P.X = pos;\n            P.V = 100.5*(rand.xy-0.5) + vec2(10., 0.);\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    if(length(P.X - R*vec2(0.8, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 - PI*0.5 + 0.3*sin(0.4*time));\n        P.M = mix(P.M, vec2(fluid_rho, 1.), 0.4);\n    }\n\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 243, 313, 364], [366, 366, 382, 382, 410], [412, 412, 457, 457, 1689]], "test": "untested"}
{"id": "fdXXzl", "name": "Pixelated Portal", "author": "BackwardsCap", "description": "A fork of my old portal shader and a potential portal vfx direction for a game I am working on", "tags": ["noise", "ancient", "fonts", "symbols"], "likes": 3, "viewed": 342, "published": 3, "date": "1619019610", "time_retrieved": "2024-07-30T19:24:33.710044", "image_code": "//Pixelated Portal\n//by Sam Gates (BackwardsCap)\n\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    c.rgb = vec3(0);\n    float downscale = 10.;\n    f /= downscale;\n    f = floor(f);\n    f *= downscale;\n    \n\tc.rgb = S0(f).rgb/2.0+S1(f).rgb*.8;    \n    vec2 p = (2.0*f-R)/R.y;\n    \n    float a = (length(p)-1.)/2.;\n    vec3 ba = vec3(0);\n    for(int y=-4;y<=4;y++)\n    for(int x=-4;x<=4;x++)\n    {\n        vec2 o = vec2(x,y);\n        if(length(o)<66.)\n        ba+= S1(f+o).rgb;\n    }\n    \n    ba/=15.0;\n    \n    c.rgb+=ba*a;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R iResolution.xy\n#define PI 3.1415927\n#define m vec2(5.+2.*4.,10.)\n#define SS(U) smoothstep(PX, 0., U)\n\n#define MORPH\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    c.rgb = vec3(0);\n    vec2 p = ((2.0*f-R)/R.y), u=p, r;\n    \n    p = vec2(log(length(p.xy)), atan(p.y,p.x));\n    p*= (6.0/PI)* 10.85;\n    p+=vec2(5.,3.); \n    p.y+=iTime*2.0;\n    p.y = mod(p.y,10.015*13.0)-.2;\n    vec2 lp = (p);    \n    \n    if(p.x>=-5.&&p.x<=4.)\n\t    c.rgb=vec3(clamp(1.-length(mod(lp,5.) - vec2(1,3. + sin(iTime))),0.,1.));    \n}", "buffer_a_inputs": [], "common_code": "#define R iResolution.xy\n#define S0(U) texture(iChannel0, (U)/R)\n#define S1(U) texture(iChannel1, (U)/R)\n#define S2(U) texture(iChannel2, (U)/R)\n#define V(U) S0(mod(U,R))\n\n#define decay .99\n\n//wrap the space (useful when sampling)\n#define A(U) T0(mod(U,R))", "buffer_b_code": "void F(vec2 p, vec2 offset, vec4 s, inout vec2 v, inout float pr, inout float d, inout float n)\n{\n    vec4 target = S0(p+offset-V(p+offset).xy);\n    offset=normalize(offset);\n    v+=offset*(target.w-s.w);\n    pr+=target.w;\n    d+=dot(offset,target.xy);\n    n++;\n}\n\nvoid mainImage(out vec4 s, vec2 p)\n{\n    s.rgb = vec3(0);\n    s = S0(p-V(p).xy);\n    vec2 v = vec2(0), u = (2.0*p-R)/R.y;\n    float d = 0., pr=0.,n=0.;\n    \n    F(p, vec2(0,1), s, v, pr, d, n);\n    F(p, vec2(0,-1), s, v, pr, d, n);\n    F(p, vec2(1,0), s, v, pr, d, n);\n    F(p, vec2(-1,0), s, v, pr, d, n);\n    \n    d/=n;\n    pr/=n;\n    v/=n;\n    \n    s.w = pr-d;\n\ts.xy -= v;   \n    s.z = d;\n    \n    s.xy*=decay;\n    \n    if(S1(p).r>0.)\n    {\n        s.xy = -u*sin(iTime - u.x)/2.;\n    }\n    \n    \n    if (p.x<1.||p.y<1.||R.x-p.x<1.||R.y-p.y<1.) s.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void F(vec2 p, vec2 offset, vec4 s, inout vec2 v, inout float pr, inout float d, inout float n)\n{\n    vec4 target = S0(p+offset-V(p+offset).xy);\n    offset=normalize(offset);\n    v+=offset*(target.w-s.w);\n    pr+=target.w;\n    d+=dot(offset,target.xy);\n    n++;\n}\n\nvoid mainImage(out vec4 s, vec2 p)\n{\n    s.rgb = vec3(0);\n    s = S0(p-V(p).xy);\n    vec2 v = vec2(0);\n    float d = 0., pr=0.,n=0.;\n    \n    F(p, vec2(0,1), s, v, pr, d, n);\n    F(p, vec2(0,-1), s, v, pr, d, n);\n    F(p, vec2(1,0), s, v, pr, d, n);\n    F(p, vec2(-1,0), s, v, pr, d, n);\n    \n    d/=n;\n    pr/=n;\n    v/=n;\n    \n    s.w = pr-d;\n\ts.xy -= v;   \n    s.z = d;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 state, vec2 f)\n{\n    state.rgb = vec3(0);\n    for(int i=0;i<2;i++)\n    f -= S1(f).xy;\n \n    state = S0(f);\n    \n    state*=decay;\n    float t = iTime/5.0;\n    \n    if(S2(f).r>0.1)\n        state.rgb += vec3((cos(iTime/3.0)+1.0)/2., (1.1+sin(iTime/5.0))/2.0, cos(sin(iTime)))*.1;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXXzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 92, 92, 522]], "test": "untested"}
{"id": "sdlXzf", "name": "Unstable complex wave evolution", "author": "tomachi", "description": "This is largely an exact clone of Michael0884 inspirational work at: https://www.shadertoy.com/view/WtfyDj but with a few precious operations had their values increased to make it more vigorous! https://michaelmoroz.github.io/Reintegration-Tracking/\n ", "tags": ["multipass"], "likes": 0, "viewed": 250, "published": 3, "date": "1619013420", "time_retrieved": "2024-07-30T19:24:34.477991", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n   // return mix(a*a, b*b, clamp(k,0.,1.)) * vec3(sin(iTime *1.01)) ;\n\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime * 200.0 ;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    // tomachi commented:\n    particle P = getParticle(data, pos);\n//    particle P = \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-2., 0., 2.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.5, 0.);\n    vec3 col1 = vec3(0.1, 0.4, 1.);\n\tvec3 fcol = mixN(col0, col1, tanh(3.*(rho.w - 0.7))*0.5 + 0.5);\n    // Output to screen\n  //   col = vec4(2.5);\n    col = rho;\n    col.xyz = mixN(col.xyz, fcol.xyz*(1.05*b + specular*5.), a);\n    col.xyz = mixN(col.xyz, 0.*vec3(0.5,0.5,1.), bord);\n    col.xyz = tanh(col.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 150.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(vec2 rho)\n{\n    //return 0.2*rho.x; //gas\n   // float GF = 1. -  smoothstep(0.49, 0.5, 1. - rho.y);\n   // float GF = 1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    float GF =  smoothstep(0.49, 0.5, 1. * rho.y);\n\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw * 1.0002353; // that should explode\n  //  P.M =vec2(0., 0.);// hack\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.12\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}\n\n/*\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}*/\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = 0.9 + 0.21*smoothstep(fluid_rho*0., fluid_rho*0.333, P0.M.x);\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n    \n    //gravity\n    F += P.M.x*vec2(0., -0.0004);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    // pressure limit\n    float pressure = dot(P.M, P.V) ;\n//    if ( pressure > 1000. ) { P.M = vec2(0., 100.); }\n    if ( pressure > 395.19 ) { \n        P.M = vec2(0.);\n        P.V *= 2.;\n    }\n\n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.) \n        {\n            P.X = pos;\n            P.V = 100.5*(rand.xy-0.5) + vec2(10., 0.);\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    if(length(P.X - R*vec2(0.8, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 - PI*0.5 + 0.3*sin(0.4*time));\n        P.M = mix(P.M, vec2(fluid_rho, 1.), 0.4);\n    }\n\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlXzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 243, 313, 364], [366, 366, 382, 382, 410], [412, 412, 457, 457, 1689]], "test": "untested"}
{"id": "7slXz2", "name": "In A Gas Cosmos", "author": "tomachi", "description": "This is largely an exact clone of Michael0884 inspirational work at: https://www.shadertoy.com/view/WtfyDj but with a few precious operations had their values increased to make it more vigorous! https://michaelmoroz.github.io/Reintegration-Tracking/\n ", "tags": ["multipass"], "likes": 2, "viewed": 287, "published": 3, "date": "1619000782", "time_retrieved": "2024-07-30T19:24:35.247932", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n   // return mix(a*a, b*b, clamp(k,0.,1.)) * vec3(sin(iTime *1.01)) ;\n\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime * 200.0 ;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-2., 0., 2.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.5, 0.);\n    vec3 col1 = vec3(0.1, 0.4, 1.);\n\tvec3 fcol = mixN(col0, col1, tanh(3.*(rho.w - 0.7))*0.5 + 0.5);\n    // Output to screen\n  //   col = vec4(2.5);\n    col = rho;\n    col.xyz = mixN(col.xyz, fcol.xyz*(1.05*b + specular*5.), a);\n    col.xyz = mixN(col.xyz, 0.*vec3(0.5,0.5,1.), bord);\n    col.xyz = tanh(col.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(vec2 rho)\n{\n    return 0.2*rho.x; //gas\n    float GF = 1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.12\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}\n\n/*\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}*/\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = 0.9 + 0.21*smoothstep(fluid_rho*0., fluid_rho*0.333, P0.M.x);\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n    \n    //gravity\n    F += P.M.x*vec2(0., -0.0004);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.) \n        {\n            P.X = pos;\n            P.V = 100.5*(rand.xy-0.5) + vec2(10., 0.);\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    if(length(P.X - R*vec2(0.8, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 - PI*0.5 + 0.3*sin(0.4*time));\n        P.M = mix(P.M, vec2(fluid_rho, 1.), 0.4);\n    }\n\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slXz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 243, 313, 364], [366, 366, 382, 382, 410], [412, 412, 457, 457, 1648]], "test": "untested"}
{"id": "sslXzX", "name": "MandelKoch- Music Visualiser ver", "author": "Pelegefen", "description": "Inspired by Tomachi's comment on the last one, decided to make my MandelKoch into a music visualiser.\nMusic by Sajanka. you can change the song by switching the one in iChannel0,\nand can also mess around with the var's, in the beggining of main image. \n", "tags": ["2d", "fractal", "sound", "mandelbrot", "reactive", "music", "kaleidoscope", "visualiser", "snowflake", "set", "koch"], "likes": 10, "viewed": 985, "published": 3, "date": "1618999291", "time_retrieved": "2024-07-30T19:24:36.090679", "image_code": "// ----------------CAUTION!!!--- FLASHING BRIGHT LIGHTS!!!-------------------------\n\n\n\n// Credits - fractal zoom with smooth iter count adapted from - iq (Inigo quilez) - https://iquilezles.org/articles/msetsmooth\n// Koch Snowflake symmetry from tutorial by Martijn Steinrucken aka The Art of Code/BigWings - 2020 - https://www.youtube.com/watch?v=il_Qg9AqQkE&ab_channel=TheArtofCode\n//music - Sajanka (Official) Sajanka - Sun Is Coming\n\n//Some notes - color is determined by date and not time - hour of day dependent.\n//Move the mouse on the Y axis to change the symmetry.\n\n//----------------------------------------------------------------------------------\n\n//uncomment to sample audio input from MIC instead of SoundCloud.\n//#define MIC_INPUT\n\n//comment to make it less trippy and noisy.\n#define EXTRA_DMT\n\n\n#define PI 3.14159265359\n\n\n\n#define date iDate\n#define time iTime\n#define resolution iResolution\n\nfloat freqs[4];\n\n\nvec2 rot(vec2 p,float a){\n    \n    float c = cos(a);\n    float s = sin(a);\n    \n    mat2 m = mat2(c,-s,s,c);\n    \n    p*=m;\n    return p  ;\n}\n\nfloat localTime(){\n\nfloat d = date.w / date.x;\nreturn d;\n\n}\n\nvec3 randomCol(float sc){\n\n float d = localTime();\n\tfloat r = sin(sc * 1. * d)*.5+.5;\n\tfloat g = sin(sc * 2. * d)*.5+.5;\n\tfloat b = sin(sc * 4. * d)*.5+.5;\n\n\tvec3 col = vec3(r,g,b);\n\tcol = clamp(col,0.,1.);\n\n\treturn col;\n\t}\n\n\n//--------------------------------------------------mandelbrot generator-----------https://iquilezles.org/articles/msetsmooth\n\n\tfloat mandelbrot(vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n\n    const float B = 128.0;\n    float l = 0.0;\n    vec2 z  = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z)>(B*B) ) break;\n        l += 1.0;\n    }\n\n    if( l>255.0 ) return 0.0;\n\n\n    // equivalent optimized smooth interation count\n    float sl = l - log2(log2(dot(z,z))) + 4.0;\n\n\n\n     return sl;\n }\n\n\nvec3 mandelbrotImg(vec2 p)\n{\n\n    //uncomment to see unmaped set\n\t//p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\n    float mtime =  time;\n    mtime -= freqs[3];\n    float zoo = 0.62 + 0.38*cos(.1*mtime);\n   float coa = cos( 0.015*(1.0-zoo)*mtime );\n   float sia = sin( 0.015*(1.0-zoo)*mtime );\n   zoo = pow( zoo,6.0);\n   vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n   vec2 c = vec2(-.745,.186) + xy*zoo;\n\n        float l = mandelbrot(c);\n        \n        \n\tvec3 col1 = 0.5 + 0.5*cos( 3.0 + l*.15 + randomCol(.1));\n    #ifdef EXTRA_DMT\n    vec3 col2 = 0.5 + 0.5*cos( 3.0 + l*.15 / randomCol(.1));\n    #else\n    vec3 col2 = 0.5 + 0.5*cos( 3.0 + l*.15 * randomCol(.1));\n    #endif\n    vec3 col = mix(col1,col2,sin(mtime)*.5+.5);\n\n\n\n\nreturn col;\n}\n\n//-----------------functions-----------\n\nfloat remap(float a1, float a2 ,float b1, float b2, float t)\n{\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\n}\n\n\nvec2 remap(float a1, float a2 ,float b1, float b2, vec2 t)\n{\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\n}\n\n\nvec4 remap(float a1, float a2 ,float b1, float b2, vec4 t)\n{\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\n}\n\n\n\n\n\nvec2 N(float angle) {\n    return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n//--------get soundtrack frequencies----\n\n\n    #ifdef MIC_INPUT\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n    #else \n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    #endif\n    float avgFreq = (freqs[0] +freqs[1] +freqs[2] +freqs[3])/4.;\n\n//--------image part---------\n    vec2 uv = (fragCoord.xy-.5*resolution.xy)/resolution.y;\n\tvec2 mouse = 1. - iMouse.xy/resolution.xy; // 0 1\n\tvec2 ouv = uv;\n    //uv.y -= .05;\n    \n    uv = rot(uv,(sin(iTime*.1) / freqs[0]*.1  ) * PI  ) ;  \n\tuv *= 4.0 - (avgFreq * 1.5  );\n\n    uv.x = abs(uv.x);\n    \n    vec3 col = vec3(0);\n    float d;\n\n    float angle = 0.;\n    vec2 n = N((5./6.)*3.1415);\n\n    uv.y += tan((5./6.)*3.1415)*.5;\n   \td = dot(uv-vec2(.5, 0), n);\n    uv -= max(0.,d)*n*2.;\n\n    float scale = 1.;\n\n    n = N( freqs[0]*(2./3.)*3.1415);\n    uv.x += .5;\n    for(int i=0; i<10; i++) {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n\n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        d = dot(uv, n);\n        uv -= min(0.,d)*n*2.;\n    }\n\n    d = length(uv/ clamp(freqs[2],0.1,.9 )- vec2(clamp(uv.x,-1., 1.), 0));\n    col += smoothstep(10./resolution.y, .0, d/scale);\n    uv /= scale;\t// normalization\n\n   \n\tvec3 manCol = mandelbrotImg(uv);\n\t col += manCol;\n\n\n \t\t// vignette effect\n\t  col *= 1.0 - 0.5*length(uv *0.5) * freqs[1];\n\n\t \n    fragColor = vec4( col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26821, "src": "https://soundcloud.com/sajankamusic/sajanka-sun-is-coming", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslXzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[928, 928, 953, 953, 1069], [1071, 1071, 1089, 1089, 1130], [1132, 1132, 1157, 1157, 1355], [1486, 1486, 1513, 1513, 2251], [2254, 2254, 2282, 2378, 3016], [3059, 3059, 3121, 3121, 3158], [3161, 3161, 3221, 3221, 3258], [3261, 3261, 3321, 3321, 3358], [3364, 3364, 3385, 3385, 3428], [3430, 3430, 3485, 3526, 5180]], "test": "untested"}
{"id": "sssSzX", "name": "sqrt", "author": "iq", "description": "Yet ANOTHER sqrt implementation, but without using IEEE754 bit tricks and assuming there isn't a hardware DIV and SQRT instructions, just MUL and ADD.", "tags": ["2d", "approximation", "sqrt"], "likes": 19, "viewed": 1061, "published": 3, "date": "1618994358", "time_retrieved": "2024-07-30T19:24:36.998252", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Yet ANOTHER sqrt approximation, but without using IEEE754 bit tricks.\n// Yellow, hardware sqrt. Purple, my software implementation.\n//\n// The game in this shader was to do it all assuming you are in some\n// ancient hardware that doesn't have hardware sqrt or division\n// instructions, but does have hardware multiplications. So, it actually\n// computes 1/sqrt(x) to avoid divisions in the Newtown-Raphson loop, at\n// the cost of one software division for inverting the output (or the\n// input). Also it assumes we don't know the floating point bit\n// representation, so it can't bit-shift the exponent of the argument to\n// get an initial guess.\n//\n// Note I have not done my research, so most likely\n// this method is not the optimal way to compute sqrt.\n// Be warned!\n\nfloat my_sqrt( float y )\n{\n    bool lto = y<1.0;\n    y = lto ? y : 1.0/y;\n    \n    float x  = 1.5-0.5*y;\n          x *= 1.5-0.5*y*x*x;\n          x *= 1.5-0.5*y*x*x;\n          x *= 1.5-0.5*y*x*x;\n          x *= 1.5-0.5*y*x*x;\n          x *= 1.5-0.5*y*x*x;\n          x *= 1.5-0.5*y*x*x;\n          x *= 1.5-0.5*y*x*x;\n          x *= 1.5-0.5*y*x*x;\n          x *= 1.5-0.5*y*x*x;\n\n    return lto ? 1.0/x : x;\n}\n\n// For reference, this is a bit-hacked version with one single \n// division. The constant 0x1fbe0000u should be tweaked to achieve\n// a better error over a particular range of values of y.\nfloat my_sqrt_for_IEEE754_and_one_division( float y )\n{\n    float x = uintBitsToFloat( 0x1fbe0000u+(floatBitsToUint(y)>>1) );\n    return 0.5*(x+y/x);\n}\n\n//------------------------------------------------------------------------------\n\nfloat my_sqrt_animated( float y )\n{\n    int num = min( int(iTime) % 15, 10 );\n\n    bool lto = y<1.0;\n    y = lto ? y : 1.0/y;\n\n    float x = 1.0;\n    for( int i=0; i<num; i++ )\n        x *= 1.5-0.5*y*x*x;\n\n    return lto ? 1.0/x : x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2  p = fragCoord/iResolution.x;\n    float px = 1.0/iResolution.x;\n    \n    p  *= 5.0;\n    px *= 5.0;\n\n    float al = max( step(mod(iTime,15.0),10.0),      \n                    smoothstep(-0.1,0.1,sin(6.283185*iTime)) );\n\n    vec3 col = vec3( 0.1 + 0.05*mod(floor(p.x)+floor(p.y),2.0) );\n    \n    // sqrt\n    {\n    float y = sqrt( p.x );\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0,1.5*px,abs(p.y-y)) );\n    }\n        \n    // approx sqrt\n    {\n    float y = my_sqrt_animated( p.x );\n    col = mix( col, vec3(1.0,0.0,1.0), al*(1.0-smoothstep(0.0,1.5*px,abs(p.y-y))) );\n    }\n    \n    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssSzX.jpg", "access": "api", "license": "mit", "functions": [[1852, 1852, 1878, 1878, 2257], [2259, 2448, 2503, 2503, 2599], [2683, 2683, 2718, 2718, 2918], [2920, 2920, 2977, 2977, 3618]], "test": "ok"}
{"id": "sslSRX", "name": "Cyclic", "author": "oneshade", "description": "Inspired by: [url=https://mathcurve.com/courbes2d/trochoid/trochoidacentre.shtml]https://mathcurve.com/courbes2d/trochoid/trochoidacentre.shtml[/url]", "tags": ["math", "animation", "curve", "parametric", "gif", "trochoid", "cyclic"], "likes": 14, "viewed": 198, "published": 3, "date": "1618982135", "time_retrieved": "2024-07-30T19:24:37.884882", "image_code": "// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.0;\n    float unit = 4.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Offset\n    uv.y += 0.15;\n    mouse.y += 0.15;\n\n    // Settings modified by mouse\n    float ra = 2.0, rb = -3.0, rc = 2.0;\n    if (iMouse.z > 0.0) {\n        ra = round(mouse.x);\n        rb = round(mouse.y);\n    }\n\n    // Positions\n    vec2 v1 = vec2(-0.5, -sqrt(1.0 / 12.0));\n    vec2 v2 = vec2(0.5, v1.y);\n    vec2 v3 = vec2(0.0, -2.0 * v1.y);\n\n    drawSDF(sdDisc(uv, v1, 0.03), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisc(uv, v2, 0.03), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisc(uv, v3, 0.03), vec3(1.0, 0.0, 0.0));\n\n    // Rings\n    drawSDF(abs(sdDisc(uv, v1, 0.5)), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(sdDisc(uv, v2, 0.5)), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(sdDisc(uv, v3, 0.5)), vec3(0.0, 0.0, 1.0));\n\n    // Brute force parametric plot\n    float tStep = 0.1;\n    vec2 prev; bool init;\n    for (float t=0.0; t < 6.28 + tStep; t += tStep) {\n        float t1 = t * ra, t2 = t * rb, t3 = t * rc;\n\n        vec2 rp1 = vec2(cos(t1), sin(t1)) * 0.5 + v1;\n        vec2 rp2 = vec2(cos(t2), sin(t2)) * 0.5 + v2;\n        vec2 rp3 = vec2(cos(t3), sin(t3)) * 0.5 + v3;\n\n        vec2 cur = (rp1 + rp2 + rp3) / 3.0;\n        if (init) drawSDF(sdLine(uv, prev, cur), vec3(0.5, 0.0, 0.0));\n        init = true;\n\n        prev = cur;\n    }\n\n    // Rotating triangle corners\n    float t1 = iTime * ra;\n    vec2 r1 = vec2(cos(t1), sin(t1)) * 0.5 + v1;\n\n    float t2 = iTime * rb;\n    vec2 r2 = vec2(cos(t2), sin(t2)) * 0.5 + v2;\n\n    float t3 = iTime * rc;\n    vec2 r3 = vec2(cos(t3), sin(t3)) * 0.5 + v3;\n\n    drawSDF(sdDisc(uv, r1, 0.03), vec3(0.0));\n    drawSDF(sdDisc(uv, r2, 0.03), vec3(0.0));\n    drawSDF(sdDisc(uv, r3, 0.03), vec3(0.0));\n\n    // Triangle anatomy\n    drawSDF(sdLine(uv, r1, r2), vec3(0.0));\n    drawSDF(sdLine(uv, r2, r3), vec3(0.0));\n    drawSDF(sdLine(uv, r3, r1), vec3(0.0));\n\n    vec2 c = (r1 + r2 + r3) / 3.0;\n    drawSDF(sdDisc(uv, c, 0.03), vec3(0.0));\n\n    drawSDF(sdLine(uv, r1, c), vec3(0.0));\n    drawSDF(sdLine(uv, r2, c), vec3(0.0));\n    drawSDF(sdLine(uv, r3, c), vec3(0.0));\n\n    // Vignette (kinda)\n    uv *= 0.5;\n    float dd = dot(uv, uv);\n    color -= 0.5 * dd * dd;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslSRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 102, 149, 149, 257], [259, 259, 307, 307, 339], [341, 341, 396, 396, 2759]], "test": "untested"}
{"id": "NssSzf", "name": "Peacock feather spiral", "author": "jarble", "description": "A simple fractal formula.", "tags": ["fractal", "spiral", "iridescence"], "likes": 7, "viewed": 387, "published": 3, "date": "1618973476", "time_retrieved": "2024-07-30T19:24:38.656818", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv.y += (iTime)/8.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.25;\n        float scale1 = 1.9;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv = fract(uv.yx/s1)*s1;\n            uv= -fract(uv+(((uv/scale-uv.yx/scale1)/(scale))))*scale/scale1;\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.0;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssSzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 729]], "test": "untested"}
{"id": "fdsSzf", "name": "curvas peligrosas-ladrillo", "author": "jorge2017a1", "description": "curvas peligrosas-ladrillo", "tags": ["curvaspeligrosasladrillo"], "likes": 5, "viewed": 253, "published": 3, "date": "1618971636", "time_retrieved": "2024-07-30T19:24:39.636199", "image_code": "//por jorge2017a1-\n// referencia \n//----------------- pjkarlik \n///----------------Shane-------------- Voxel Corridor\n//https://www.shadertoy.com/view/tdVyzV\n//https://www.shadertoy.com/view/MdVSDh\n\n#define MAX_STEPS 100\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n// path functions \nvec2 path(in float z)\n{ \n    vec2 p1 =vec2(2.13*sin(z * .15), 1.74*cos(z * .085));\n    vec2 p2 =vec2(2.97*sin(z * .079), 1.23*sin(z * .127));\n    return p1 - p2;\n}\n// Repeat space along one axis.\nfloat pMod(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n   \n   ///https://www.shadertoy.com/view/tdVyzV\n   p.y=p.y-5.0;\n   vec2 qath = p.xy - path(p.z);\n   vec3 q = vec3(qath,p.z);\n   vec3 dq = q;\n   \n    vec3 r = dq;\n    pMod(r.z,3.);\n    vec3 r2=r;\n    vec3 r3=r;\n    \n   \n    r = vec3(abs(r.x)-10.0,r.y-3.5,r.z);\n    r2 = vec3(abs(r2.x)-10.0,r2.y-1.0,r2.z);\n    r3 = vec3(r3.x,r3.y+1.0,r.z);\n    \n   float pared1= sdBox( r, vec3(1.0,2.0,10.0) );\n   float pared2= sdBox( r, vec3(1.0,2.0,10.0) );\n   float banqueta= sdBox(r2, vec3(3.0,1.0,10.0) );\n   float calle= sdBox(r3, vec3(10.0,1.0,10.0) );\n   \n   dq.x=abs(dq.x)- 11.0;\n   dq.y-=5.0;\n   dq.z= opRep1D( dq.z, 10.0 );\n   float poste= sdBox( dq, vec3(1.0,5.0,2.0) );\n  \n   res =opU3(res, vec3(poste,8.0,-1.0));\n   res =opU3(res, vec3(pared1,3.0,-1.0));\n   res =opU3(res, vec3(pared2,3.0,-1.0));\n   res =opU3(res, vec3(pared2,6.0,-1.0));\n   res =opU3(res, vec3(banqueta,5.0,-1.0));\n   res =opU3(res, vec3(calle,1.0,-1.0));\n   \n    //return (dist, id_color, id_material)\n    return res;\n}\n///------------------------------------\n\n//Shane --------https://www.shadertoy.com/view/MdVSDh\n// The brick groove pattern. Thrown together too quickly.\n// Needs some tidy up, but it's quick enough for now.\n//\nconst float w2h = 2.; // Width to height ratio.\nconst float mortW = 0.05; // Morter width.\n\nfloat brickMorter(vec2 p)\n{\n    p.x -= step(1., p.y)*.5;\n    p = abs(fract(p + vec2(0, .5)) - .5)*2.;\n    // Smooth grooves. Better for bump mapping.\n    return smoothstep(0., mortW, p.x)*smoothstep(0., mortW*w2h, p.y);\n}\n\nfloat brick(vec2 p)\n{   p = fract(p*vec2(0.5/w2h, 0.5))*2.;\n    return brickMorter(p);//*(brickShade(p)*.25 + .75);\n}\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p, in vec3 n)\n{\n    n = abs(n);\n    if (n.x>0.5) p.xy = p.zy;\n    else if (n.y>0.5) p.xy = p.zx;\n    return brick(p.xy);\n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor)\n{   const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n    grad -= nor*dot(nor, grad);          \n    return normalize( nor + grad*bumpfactor );\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{ \n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    //return normalize(n);\n    \n    vec3 nor= normalize(n);\n    return doBumpMap( p, nor,10.0);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false;    minDist = dO;    break; } \n        dO += dS.x;\n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n///============================================================\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\n\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{   vec3 l = normalize(lp - p);\n    vec3 r = reflect(-l, n);\n    float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{\n    vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(0.,dot(ldir,-n));\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    \n    if (mObj.blnShadow==true)\n    { fshadow=GetShadow(p,lp);}\n    else\n    {   fshadow=0.5; }\n\n    \n    vec3 lin = amb;\n    lin += 1.0*(dif+diff)*sh;\n    lin += 2.5*spe;\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    \n    lin *= atten*0.8*col*fshadow;\n    lin = pow(lin,vec3(0.4545));\n  return lin;\n    \n}\n///============================================================\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n \tvec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    if (id_material==6.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n              l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n    }\n }\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n     if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,\n        1.055 * pow(c, vec3(1.0/2.4)) - 0.055,\n        step(vec3(0.0031308), c)\n    );\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p ;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        p = (ro + rd * d );  \n         \n         \n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n        col=linear2srgb(col);\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   \n   return col;\n}\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*8.0,1000.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( 0.0, 10.0, 10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-25.0+t);\n   ro.xy += path(ro.z);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsSzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[660, 660, 696, 696, 717], [718, 718, 750, 750, 834], [836, 874, 910, 910, 955], [956, 1021, 1055, 1055, 1153], [1154, 1154, 1188, 1188, 1280], [1281, 1281, 1315, 1315, 1407], [1408, 1448, 1482, 1482, 1579], [1581, 1600, 1623, 1623, 1763], [1764, 1796, 1835, 1835, 1968], [1969, 2009, 2034, 2034, 3069], [3372, 3372, 3399, 3399, 3593], [3595, 3595, 3616, 3616, 3712], [3714, 3778, 3819, 3819, 3926], [3928, 3978, 4036, 4036, 4395], [4397, 4448, 4472, 4472, 4735], [4737, 4737, 4786, 4786, 5432], [5433, 5487, 5523, 5523, 5770], [5771, 5835, 5862, 5862, 5879], [5881, 5881, 5917, 5917, 6009], [6011, 6011, 6057, 6057, 6189], [6191, 6191, 6265, 6265, 7388], [7389, 7453, 7533, 7533, 7665], [7709, 7709, 7741, 7741, 7936], [7937, 7988, 8035, 8035, 8577], [8578, 8630, 8723, 8723, 8997], [8999, 9048, 9074, 9074, 9198], [9200, 9200, 9258, 9258, 9310], [9312, 9312, 9343, 9343, 9995], [9999, 10048, 10105, 10105, 10648]], "test": "untested"}
{"id": "fdsXRf", "name": "Stepped Time Remapping Functions", "author": "Tater", "description": "Something I've wanted for a while, visualizer here:\n[url]https://www.desmos.com/calculator/j6h3ket3hw[/url]\n\nI used it in this shader if you want a cooler example:\n[url]https://www.shadertoy.com/view/fssXzj[/url]", "tags": ["example", "tutorial"], "likes": 4, "viewed": 304, "published": 3, "date": "1618968075", "time_retrieved": "2024-07-30T19:24:40.494904", "image_code": "#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n//Thanks to Alan Wolfe in the shadertoy discord for suggesting to use monotonically increasing functions for this.\n\n//Play with the function here\n//https://www.desmos.com/calculator/j6h3ket3hw\n\n//t = initial Time\n//s1 = speed 1\n//s2 = speed 2\n//c = smoothing factor (1-30 works well)\nfloat timeRemap (float t, float s1, float s2, float c){\n    return 0.5*((s1-s2)*sqrt(c*c+1.0)*asin((c*cos(pi*t))/ sqrt(c*c+1.0))+(s1+s2)*c*t*pi)/(c*pi);\n}\n\n//Simpler version, same as before but c ranges from 0 to 3 ish (0.0-0.3 works best)\nfloat timeRemap2 (float t,float s1, float s2, float c){\n    return 0.5*(s2-s1)*(t-asin(cos(t*pi)/sqrt(c*c+1.0))/pi)+s1*t;\n    \n}\n//Same thing but without the smoothing\nfloat timeRemapEasy (float t, float s1, float s2){\n    return (s1-s2)*(fract(t)*step(1.0,mod(t,2.0))+floor(t*0.5))+t*s2;\n}\n\n//Worse version of the smoothing one but might be easier to remember?\nfloat timeRemapScuffed (float t, float s1, float s2){\nreturn (s1-s2)*(smoothstep(0.0,1.0,fract(t))*step(1.0,mod(t,2.0))+floor(t*0.5))+t*s2;}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime*0.25;\n    vec3 col =vec3(0);\n    \n    \n    float speed1 = 15.0;\n    float speed2 = -2.0;\n    t = timeRemap2(t, speed1, speed2, 0.1)*4.0;\n    \n    //Crappy visualizer for the function (just look at the desmos link)\n    vec2 uv2=uv*15.0;\n    uv2.y += timeRemap2(-uv2.x, sin(iTime), cos(iTime), 0.1)*4.0;\n    col += vec3(step(max(abs(uv2.x)-5.0,abs(uv2.y)),0.3),0,0);\n    \n    uv*=rot(t);\n    col += vec3(step(length(uv+vec2(0,0.3)),0.075));\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 358, 413, 413, 512], [514, 598, 653, 653, 726], [727, 766, 816, 816, 888], [890, 960, 1013, 1013, 1100], [1104, 1104, 1161, 1161, 1719]], "test": "untested"}
{"id": "7sfXzf", "name": "Quiet Chaos", "author": "miczac", "description": "Tunnel with capsules textured with fluid, fluid text is tiled. Neon lights drawn in un-repeated space (thanks NR4 for the help!). Audiovisual piece: https://youtu.be/d39Aq7E1d-8", "tags": ["fluid", "repetition", "neon"], "likes": 9, "viewed": 1411, "published": 3, "date": "1618955201", "time_retrieved": "2024-07-30T19:24:41.811384", "common_code": "//uncomment to see the fluid tiles texture\n//#define VISUALIZE_FLUID_TILES\n\n#define TAU 6.283189\n#define PI 3.14159265358\n\n#define GRID vec2(10,5)\nconst ivec2 iGRID = ivec2(GRID);\n#define CAP_LENGTH 2.\n#define TUNNEL_RADIUS 1.5\n#define CAP_RADIUS 0.05\n#define COMET_RADIUS 0.015\n\n#define FLUID_FADE_OUT 0.999\n#define LINE_LENGTH 0.04\n#define TRAPEZOID vec2(0.4, 0.6)\n#define FLUID_STRETCH vec2(8,.8)\n#define FLUID_TEX_ROTA sin(iTime*20.1)\n\n#define TRANSPARENCY_PASSES 50.\n\n#define CAMERA_MULT vec4(1,15,5,TAU)\n\nconst float fNUMBER_OF_OBJECTS = GRID.x*GRID.y;\nconst int NUMBER_OF_OBJECTS = int(fNUMBER_OF_OBJECTS);\n\nfloat Envelopes[NUMBER_OF_OBJECTS];\nvec3  Positions[NUMBER_OF_OBJECTS];\nvec4  Notes[NUMBER_OF_OBJECTS];      \nvec4  Lines[NUMBER_OF_OBJECTS]; \nvec3  Comets[NUMBER_OF_OBJECTS];\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nfloat envelope(float time, float freq)\n{\n   return 1.-fract(freq*time);   \n}\n\nfloat hash(float n){\n    return fract(sin(n)*753.5453123);\n}\n\nvec3 hash31( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat trapezoid(float x, vec2 begin_end)\n{\n//given a 0-1 ramp draw a trapezoid \n    //since the incoming envelope is a ramp from 1 to 0, invert it (it makes more sense)\n    x = 1.-x;\n    float trapez = min(smoothstep(0., begin_end.x, x),smoothstep( 1.,begin_end.y, x)); \n    return trapez;\n\n}\n\nfloat ln (vec2 p, vec2 a, vec2 b) \n{ // returns distance to line segment \n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\n\nvec2 path_grid(float id)\n{\n    float sector_width  = 1./ GRID.x;\n    float sector_height = 1./ GRID.y;\n    vec2 grid_pos = vec2(mod(id,GRID.x), floor(id/GRID.x)); \n    float  pos_x = grid_pos.x*sector_width+sector_width*0.5;\n    float pos_y = grid_pos.y*sector_height+sector_height*0.5;\n   \n   return vec2(pos_x, pos_y);   \n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;//*h-(r*0.3);\n}\n\nmat2 rotate(float angle)\n{\n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\nvec2 capsule_uv(vec3 p, float cap_length, float rota)\n{\n// texture a capsule placed at xz = 00  with variable y_pos and length\n    p.xz *= rotate(rota);\n    float u = fract((atan(p.z,p.x)/ 2.) / PI + 0.5);\n    float v = p.y/ cap_length;\n    return vec2(u,v);\n}\n\nmat3 camera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat slide(float cur, float tar, float slu, float sld)\n{\n    //slide up or slide down\n    float del = (tar>cur) ?  slu : sld;\n \tcur += (tar - cur) * del;\n    return    cur;\n}\n\n\nmat2 rotate(vec2 angles)\n{\n    return mat2(cos(angles.x),-sin(angles.x),sin(angles.y),cos(angles.y));\n}\n\nmat2 radial_repeat(vec2 p, float time, inout float id)\n{\n    float angle = TAU/GRID.x;\n    float radial_pos = atan(p.x,p.y)+angle*0.5;//-pi<>pi\n    float radial_sector = floor(radial_pos/angle);\n    //since atan has a disconituity at the edge (-PI<>PI) rotate\n    //slighlty tohave each sector contain the object, even at the edges\n    p.xy *= rotate(angle*0.25);\n    //id = floor(((atan(p.y,p.x)+TAU*0.5)/TAU)*GRID.x)/GRID.x;\n    id = floor(((atan(p.y,p.x)+TAU*0.5)/TAU)*GRID.x);\n    return rotate(angle*radial_sector);\n}\n\nfloat depth_repeat(float z, float time, inout float id)\n{\n    id = mod(floor(abs(z)), GRID.y);\n    z =  mod(z,1.) - 0.5;\n    //bounded z\n    //z =  z < -floor(abs(z)/GRID.y) && z < 0. ? mod(z,1.) - 0.5 : z + 0.5; \n    return z;\n\n}\n\nvec3 light_color(int id)\n{\n    return hash31(float(id)*0.003);\n}\n\nvec2 hash_displace(float id, float z)\n{\n    return vec2(sin(float(id)*210.656)*0.2,cos(float(id)*3020.121454)*0.3);\n\n}\n\n//https://www.shadertoy.com/view/MscSDB\nvec2 tunnel_path(in float z){ float s = sin(z/24.)*cos(z/16.); return vec2(s*9., 0); }\n\nvoid Update(sampler2D MIDI, float time)\n{\n    float angle = TAU/GRID.x;   \n    for(int id_rad   = 0; id_rad   < iGRID.x; id_rad++)\n    for(int id_depth = 0; id_depth < iGRID.y; id_depth++)\n    {\n        int id_line = id_rad+id_depth*iGRID.x;\n        float env = texelFetch(MIDI,ivec2(id_line,0),0).x;\n        Envelopes[id_line] = env;\n        float env_motion = 2.-pow(env,1.5)*1.8;\n        vec3 pos = vec3(0,env_motion,0)+vec3(0,TUNNEL_RADIUS,0);\n        pos.xz += hash_displace(float(id_line),time);\n        Positions[id_line] = pos;\n        //position in unrotated space\n        float uenv_motion = 2.-pow(env,1.5)*1.8;\n        vec3 upos = vec3(0,uenv_motion,0)+vec3(0,TUNNEL_RADIUS,0);\n        upos.xz += hash_displace(float(id_line),time);\n        float z = time-mod(time+float(id_depth), GRID.y)-0.5;\n        upos.xy *= rotate(float(id_rad+3)*angle);\n        upos.z += z;\n        upos.xy += tunnel_path(z);\n        Comets[id_line] = upos;\n    }\n}\n\nvec2 sphDistances( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;\n    return vec2( d, -b-sqrt(max(h,0.0)) );\n}\n\n\nbool vec_is_less(vec2 inp, vec2 compare)\n{\n    bool x = inp.x < compare.x;\n    bool y = inp.y < compare.y;\n    return x && y;\n}\n\nbool vec_is_greater(vec2 inp, vec2 compare)\n{\n    bool x = inp.x > compare.x;\n    bool y = inp.y > compare.y;\n    return x && y;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 iCoo = ivec2(fragCoord);\n    if(iCoo.y == 0 && iCoo.x < NUMBER_OF_OBJECTS)\n    {\n        vec3  vfd = hash31(float(iCoo.x));\n        float vel = vfd.x, freq = vfd.y*0.2, dur = 1./(vfd.z*55.);\n        float new_ramp     = envelope(iTime, freq);\n        vec4  prev_data    = iFrame < 1 ? vec4(0,0.5, 0.6, 1.) : texelFetch(iChannel0,iCoo,0);\n        float prev_env     = prev_data.x, \n              accum_env    = prev_data.y+prev_env*0.05,\n              prev_ramp    = prev_data.y;\n        bool trigger = new_ramp > prev_ramp;\n        float env = prev_env;\n        if(trigger)\n        {\n            env = 1.;            \n        } \n        else {env = slide(env, 0., 1.,dur);}\n        fragColor = vec4(env, new_ramp, 0.,0.);\n     }\n     else if (iCoo.y == 1 && iCoo.x < NUMBER_OF_OBJECTS)\n     {\n     //create 2 sets of texel coordinates, one slightly ahead of the other \n     //to draw line on fluid texture\n         vec2 point_ahead = path_grid(float(iCoo.x));\n         vec2 point_behind = point_ahead-vec2(0,LINE_LENGTH*1.);\n         fragColor = vec4(point_behind, point_ahead);\n     }  \n    \n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//from https://www.shadertoy.com/view/XtGcDK\nvec4 T ( vec2 U ) \n{\n//added mod on x dimension to wrap around sphere\n    U.x = mod(U.x, iResolution.x-1.);\n    if(U.x < 0.) U.x == iResolution.x-1.;\n    vec2 R = iResolution.xy;\n    return texture(iChannel0,U/R);\n} // samples fluid\n\nvec2 R;\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{   \n    \n    R = iResolution.xy;\n\n \tvec2 O = U,A = U+vec2(1,0),B = U+vec2(0,1),C = U+vec2(-1,0),D = U+vec2(0,-1);\n \tvec4 u = T(U), a = T(A), b = T(B), c = T(C), d = T(D);\n \tvec4 p;\n \tvec2 g = vec2(0);\n \t#define I 2\n \tfor (int i = 0; i < I; i++) {\n        U -=u.xy; A -=a.xy; B -=b.xy; C -=c.xy; D -=d.xy; \n        p += vec4(length(U-A),length(U-B),length(U-C),length(U-D))-1.;\n        g += vec2(a.z-c.z,b.z-d.z);\n        u = T(U);a = T(A); b = T(B); c = T(C); d = T(D);\n \t}   \n \tQ = u; \n \tvec4 N = 0.25*(a+b+c+d);\n \tQ = mix(Q,N, vec4(0,0,1,0)); \n \tQ.xy -= g/10./float(I); \n \tQ.z += (p.x+p.y+p.z+p.w)/10.; \n \tQ.z *= FLUID_FADE_OUT;\n    float sector_width = R.x / GRID.x;\n    float sector_height = R.y / GRID.y;\n    for(int x = 0; x < iGRID.x; x++)\n    for(int y = 0; y < iGRID.y; y++)\n    {\n        vec2 sector = vec2(float(x) * sector_width, float(y) * sector_height);\n        vec2 next_sector = sector + vec2(sector_width,sector_height);\n        bool is_inside_sector = vec_is_greater(U, sector) && vec_is_less(U, next_sector);\n        if(is_inside_sector)\n        {\n             int id = x + y*iGRID.x;\n            float env = texelFetch(iChannel1,ivec2(id,0),0).x;\n            if( env < 0.0001)\n            {\n                Q = mix(Q,vec4(0), 0.5);\n            }\n            else\n            {\n                //pixel coordinates of line to be drawn\n                vec4 line = texelFetch(iChannel1,ivec2(id,1),0)*R.xyxy;\n                float trapez = 1.-trapezoid(env,TRAPEZOID);\n                float q = ln(U,line.xy,line.zw);\n                vec2 m = line.xy-line.zw;\n                float l = length(m);\n                if (env  > .5 && l>0.) \n                {\n                    // accelerate fluid and add ink\n                    Q.xyw = mix(Q.xyw,vec3(-normalize(m)*min(l,10.)/5.,1.),max(0.,4.*trapez-q)/15.); \n                }\n            }\n\n        }\n        \n     }\n \t// init zeros\n \tif (iFrame < 1) Q = vec4(0);\n    //wipe is on iChannel1 (buff A)\n    //float wipe = 1.-texelFetch(iChannel1, ivec2(4, 0),0).x;\n    //float thickness = 0.2;\n    //Q = mix(Q, Q*wipeClean(wipe,U.y/R.y, thickness, true), WIPE_THICKNESS);\n    //Q.xy += grid_pos.xy*0.01;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec4 T ( vec2 U ) \n{\n//added mod on x dimension to wrap around sphere\n    U.x = mod(U.x, iResolution.x-1.);\n    if(U.x < 0.) U.x == iResolution.x-1.;\n    vec2 R = iResolution.xy;\n    return texture(iChannel0,U/R);\n} // samples fluid\n\nvec2 R;\n\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \tvec2 O = U,A = U+vec2(1,0),B = U+vec2(0,1),C = U+vec2(-1,0),D = U+vec2(0,-1);\n \tvec4 u = T(U), a = T(A), b = T(B), c = T(C), d = T(D);\n \tvec4 p;\n \tvec2 g = vec2(0);\n \t#define I 2\n \tfor (int i = 0; i < I; i++) {\n        U -=u.xy; A -=a.xy; B -=b.xy; C -=c.xy; D -=d.xy; \n        p += vec4(length(U-A),length(U-B),length(U-C),length(U-D))-1.;\n        g += vec2(a.z-c.z,b.z-d.z);\n        u = T(U);a = T(A); b = T(B); c = T(C); d = T(D);\n \t}   \n \tQ = u; \n \tvec4 N = 0.25*(a+b+c+d);\n \tQ = mix(Q,N, vec4(0,0,1,0)); \n \tQ.xy -= g/10./float(I); \n \tQ.z += (p.x+p.y+p.z+p.w)/10.;\n  \tQ.z *= FLUID_FADE_OUT;\n \t// init zeros\n \tif (iFrame < 1) Q = vec4(0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec4 T ( vec2 U ) \n{\n//added mod on x dimension to wrap around sphere\n    U.x = mod(U.x, iResolution.x-1.);\n    if(U.x < 0.) U.x == iResolution.x-1.;\n    vec2 R = iResolution.xy;\n    return texture(iChannel0,U/R);\n} // samples fluid\nvec2 R;\n\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{   R = iResolution.xy;\n \tvec2 O = U,A = U+vec2(1,0),B = U+vec2(0,1),C = U+vec2(-1,0),D = U+vec2(0,-1);\n \tvec4 u = T(U), a = T(A), b = T(B), c = T(C), d = T(D);\n \tvec4 p;\n \tvec2 g = vec2(0);\n \t#define I 2\n \tfor (int i = 0; i < I; i++) {\n        U -=u.xy; A -=a.xy; B -=b.xy; C -=c.xy; D -=d.xy; \n        p += vec4(length(U-A),length(U-B),length(U-C),length(U-D))-1.;\n        g += vec2(a.z-c.z,b.z-d.z);\n        u = T(U);a = T(A); b = T(B); c = T(C); d = T(D);\n \t}   \n \tQ = u; \n \tvec4 N = 0.25*(a+b+c+d);\n \tQ = mix(Q,N, vec4(0,0,1,0)); \n \tQ.xy -= g/10./float(I); \n \tQ.z += (p.x+p.y+p.z+p.w)/10.;\n  \tQ.z *= FLUID_FADE_OUT;\n \t// init zeros\n \tif (iFrame < 1) Q = vec4(0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "image_code": "vec4 get_fluid_texture(float id, vec2 cap_uv, sampler2D fluid, float time)\n{\n     //offset texture section by object id\n    vec2 sector_dim  = vec2(1./ GRID.x,1./ GRID.y);\n    //added half sector offset to uv.y since the drop is drawn in the middle\n    vec2 grid_pos = vec2(mod(id,GRID.x), floor(id/GRID.x)+sector_dim.y*0.5)*sector_dim; \n    float stretch = 1./FLUID_STRETCH.x;\n    //stretch middle of the texture section \n    cap_uv.x = (cap_uv.x*stretch+(1.-stretch)*0.5);\n    cap_uv *= sector_dim;\n    cap_uv.y /= FLUID_STRETCH.y;\n    cap_uv += grid_pos;\n    vec4 fluid_section = texture(fluid,cap_uv);\n    return fluid_section;\n}\n\nvec4 map(vec3 p, float time)\n{\n    vec3 q = p; \n    q.xy -= tunnel_path(q.z);\n    float id_rad = -1.;\n    mat2 rot_mat = radial_repeat(q.xy, time, id_rad); \n    q.xy *= rot_mat;\n    float  id_depth = 0.;\n    q.z = depth_repeat(q.z, time, id_depth);\n    int id_line = int(id_depth * GRID.x + id_rad);\n    vec3 front = Positions[id_line];\n    float envelope = Envelopes[id_line];\n    vec3 back = front +vec3(0,CAP_LENGTH,0);\n    vec2 cap_uv = capsule_uv(q-front, CAP_LENGTH*2., FLUID_TEX_ROTA*(envelope+0.1));\n    vec4 fluid = get_fluid_texture(float(id_line), cap_uv, iChannel1, time);\n    float bump = CAP_RADIUS*fluid.y*1.1;\n    float radius = CAP_RADIUS + bump ;\n    float cap = sdCapsule(q,front,back, radius);\n    return vec4(cap*0.7, id_line,cap_uv);    \n}\n\nvec2 comet_distance(vec3 ro, vec3 rd, int id_line, float time)\n{\n    //distance from comet's head in unrotated space, first used for lighting, \n    //second as a bool condition for drawing: if > than dist do not draw\n    float angle = TAU/GRID.x;\n    vec3 pos = Positions[id_line];\n    float env = texelFetch(iChannel0,ivec2(id_line,0),0).x;\n    int id_depth = id_line/iGRID.x, id_rad = int(mod(float(id_line),GRID.x));\n    float z = time-mod(time+float(id_depth), GRID.y)-0.5;\n    pos.xy *= rotate(float(id_rad+3)*angle);\n    pos.z += z;\n    pos.xy += tunnel_path(z);\n    float comet_radius = COMET_RADIUS;\n    vec2 com_distance = vec2(sphDistances(ro,rd,vec4(pos,0.8)).x,sphDistances(ro,rd,vec4(pos,CAP_LENGTH*0.5)).x );\n    //this is a hack I struggle with: to avoid drawing extra comets in the background\n    com_distance.y = 1.-com_distance.y;\n   \n    return com_distance;\n}\n\nvec3 comet_lights(vec3 ro, vec3 rd)\n{\n    //neon lights are drawn in unrotated space thank you Alex Anderson for the help with this step!\n    vec3 res = vec3(0);\n    for(int id = 0; id <  NUMBER_OF_OBJECTS; id++)\n    {\n        float comet_radius = COMET_RADIUS;\n        vec3 pos = Comets[id];\n        float env = Envelopes[id];\n        //calc light\n        float light_distance = sphDistances(ro,rd,vec4(pos,comet_radius)).x;\n        float falloff = .52*sqrt(env);\n        float light_intensity = falloff/pow(abs(light_distance),.42);\n        light_intensity =pow(light_intensity,5.4545)*(1.-env);        \n        res += light_color(id)*light_intensity;\n    }\n     return res;\n}\n\nvec3 normal(vec3 p, float time)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( p + e.xyy, time).x  + \n\t\t\t\t\t  e.yyx*map( p + e.yyx, time).x  + \n\t\t\t\t\t  e.yxy*map( p + e.yxy, time).x  + \n\t\t\t\t\t  e.xxx*map( p + e.xxx, time).x );\n}\n\nvec4 intersect(vec3 ro, vec3 rd, float time)\n{\n    float dist = 0.;\n    float id = -1.;\n    vec2 cap_uv = vec2(0);\n    for(int i =0; i < 80; i++)\n    {\n        vec3 p = ro + rd*dist;\n        vec4 hit = map(p, time);\n        id = hit.y;\n        dist +=  hit.x;\n        cap_uv = hit.zw;\n        if( dist > 20. || abs(dist) < 0.01) break;\n    }\n    return vec4(dist,id,cap_uv);\n}\n\nvec3 render(vec3 ro, vec3 rd, float time)\n{\n    //adapted from transparencey shader by Shane: https://www.shadertoy.com/view/Xd3SDs\n    vec3 lig_pos = normalize(vec3(2.,1.,0));\n    float ray_dist = length(rd), accum_dist;\n    //light variables\n    float light_dist, surf_light;\n    float thresh_dist = 0.05125; \n    vec3 background = vec3(0.02, 0.014, 0.03);\n    vec3 col = vec3(0.);\n    for(float i=0.; i< TRANSPARENCY_PASSES; i++)\t\n    {\n        // Break conditions. Anything that can help you bail early usually increases frame rate.\n        if( dot(col, vec3(.299, .587, .114)) > 1. || ray_dist> 26.) break;\n        vec3 p = ro + rd*ray_dist;\n        vec4 obj = map(p, time);\n        float hit = obj.x, id = obj.y;\n        vec2 cap_uv = obj.zw;\n        float envelope = Envelopes[int(id)];\n        accum_dist = (thresh_dist-abs(hit)*31./32.)/thresh_dist;\n        if(accum_dist > 0.)\n        {\n            vec3 p = ro+rd*hit;\n            vec3 norm = normal(p,time)*sign(hit);\n            vec3 single_col = max(0.,dot(norm, lig_pos)*0.5+0.5)*light_color(int(id))*2.;\n            //fluid texture\n            vec4 fluid = get_fluid_texture(id, cap_uv+vec2(0.,0.1),iChannel1, time);\n            //distances from head of comet, one for \n            vec2 comet_dist = comet_distance(ro,rd,int(id),time);\n            if(comet_dist.y > 0.5 && fluid.w > 0.)\n            {\n                col +=max(vec3(0),single_col*sin(fluid.w*1.5*fluid.x*10.* fluid.y*5.2*fluid.z*vec3(1,2,3)));\n            }\n            //col = max(col,col*(.3852/pow(comet_dist.x,0.1268)*envelope));\n        }\n        ray_dist += max(abs(hit)*.95, thresh_dist*.15);\n    }\n    col += comet_lights(ro,rd)*1.5;\n    col = encodeSRGB(col);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef VISUALIZE_FLUID_TILES\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord.xy),0);\n#else   \n    float time      = -iTime*3., \n          cam_y     = (iMouse.y/iResolution.y)*20., \n          cam_z     = 1.,\n          cam_rota  = 0.;//(iMouse.x/iResolution.x)*TAU;\n    Update(iChannel0,time);\n    vec3 ro = vec3(0,0,0);\n    vec2 uv = (2.*(fragCoord) - iResolution.xy) /iResolution.y;\n    vec3 lookat    = vec3(0,0,time) ;\n    float cam_dist_norm = cam_y/CAMERA_MULT.y;\n    ro = vec3(0,0,cam_z);\n    ro += lookat;\n    lookat.xy += tunnel_path(lookat.z);\n    ro.xy += tunnel_path(ro.z);\n    ro.y += cam_y;\n    ro.xy *= rotate(cam_rota);\n    mat3 cam = camera(ro, lookat, 0.);\n    float lens_aperture = 0.5+1.2*cam_y/CAMERA_MULT.y;\n    vec3 rd = cam*normalize(vec3(uv,lens_aperture));\n    vec3 col = vec3(0);\n    col = render(ro,rd, time);\n    col = pow(clamp(col,0.,1.),vec3(.45));\n    fragColor = vec4(col,1.0);\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfXzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 76, 119, 633], [635, 635, 665, 665, 1396], [1398, 1398, 1462, 1614, 2277], [2279, 2279, 2316, 2416, 2957], [2959, 2959, 2992, 2992, 3215], [3217, 3217, 3263, 3263, 3593], [3595, 3595, 3638, 3726, 5312], [5315, 5315, 5372, 5372, 6297]], "test": "untested"}
{"id": "sdfXzf", "name": "marriage of Shirley & Britney", "author": "elenzil", "description": "I couldn't resist this trivial change to Fabrice's latest.\noriginal: https://shadertoy.com/view/7sXXRf", "tags": ["procedural", "noise", "perlin", "isolines"], "likes": 5, "viewed": 328, "published": 3, "date": "1618954334", "time_retrieved": "2024-07-30T19:24:42.816696", "image_code": "// Fork of \"isolined Britney\" by FabriceNeyret2. https://shadertoy.com/view/7sXXRf\n// 2021-04-20 21:28:58\n\n// variant of https://shadertoy.com/view/sdlXRj\n// using texture instead of noise https://shadertoy.com/view/NdXXRj\n\n#define draw(v,d)       clamp(1. - abs( fract(v-.5) - .5 ) / (d), 0.,1.)\n#define Mix(c0,c1,v)    mix(c0,c1,v)\n//#define Mix(c0,c1,v)  vec4(c0,c1,0,0) // debug \n#define func( P )       texture(iChannel0, u/R , 2. ).r             \\\n                        + .001*texture(iChannel1, u/R , 0. ).r     // to cancel overcompressed mpeg regions\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y;\t\n    vec4 T = texture(iChannel2, u/R );\n    O-=O;\n\tfloat f = func(P),\n    l = exp2(floor(log2(.5/22./fwidth(f)))),                       // subvid amount (absolute)\n    dl =     fract(log2(.5/22./fwidth(f))),\n\n // f *= U.x;                                                      // draw isolines \n    df = fwidth(f);\n    l *= 12.;\n# if 1\n     O += Mix( draw(    f*l,    l*df ),\n               draw( 2.*f*l, 2.*l*df ),\n               dl ) * T;\n\n# else                                                             // color on different layers\n#   define Draw(c,ofs)                         \\\n      O.c = mix( draw(    f*l-ofs,    l*df ),  \\\n                 draw( 2.*f*l-ofs, 2.*l*df ),  \\\n                 dl ) * T.c\n    float ofs = .33;   // 0. : too subtle to see.\n    Draw(r, 0.);\n    Draw(g, ofs);\n    Draw(b, -ofs);\n# endif\n    \n    O = sqrt(O);                                                   // to sRGB\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfXzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[563, 563, 601, 601, 1582]], "test": "untested"}
{"id": "7sfXRf", "name": "isolined Britney golfed", "author": "FabriceNeyret2", "description": "iso-spaced lines along texture contours.  Try changing the LOD line #7.\nVariant of [url]https://shadertoy.com/view/sdlXRj[/url] and [url]https://shadertoy.com/view/NdXXRj[/url]  balanced isolines\nreplacing noise with the video texture.", "tags": ["procedural", "noise", "perlin", "isolines", "2tweets", "short", "golf"], "likes": 7, "viewed": 485, "published": 3, "date": "1618950234", "time_retrieved": "2024-07-30T19:24:43.703325", "image_code": "// golfed version of https://shadertoy.com/view/7sXXRf\n\n#define T(U,l)     texture( iChannel0, U, l ) \n#define D(k)       clamp( 1. - abs( fract(k*f*l-.5) - .5 ) / l/d/k, 0.,1.)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u / iResolution.xy;\n\n\tfloat f = 12.*T( U , 2. ).r + .001*T(U/.1, 2. ).r, \n          d =  fwidth(f),\n          w = -log2( 44. * d ),\n          l =  exp2(ceil(w)); \n\n     O = sqrt( mix( D(6.), D(12.), fract(w) ) * T( U,0.) );\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 217, 217, 456]], "test": "untested"}
{"id": "7sfSRf", "name": "Spiroidoscope", "author": "dyla", "description": "Playing again with those damn spirals.", "tags": ["2d", "spiral", "blackwhite", "logarithmic"], "likes": 2, "viewed": 273, "published": 3, "date": "1618947910", "time_retrieved": "2024-07-30T19:24:44.551058", "image_code": "\n#define PI 3.1415926\n#define DPI 6.28318530\n\n\nfloat getAngleDiff(float a1, float a2) {\n\n    float diff = a1-a2;\n    while (diff < -PI) diff += DPI;\n    while (diff >  PI) diff -= DPI;\n    \n    return diff;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*0.5;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.xx;\n    float r = length(uv);\n    float alpha =(atan(uv.y, uv.x))*9.0 + t*1.37;\n    alpha += sin(alpha*2.0)*sin(t*0.39);\n    float alphaForR = mod(log(r) * sin(t*0.2)*5.0 - t*1.53, DPI) + sin(r*DPI*2.0-t*1.12)*2.0;\n\n    \n    fragColor = vec4(1.0-smoothstep(0.55, 0.75, 1.0-abs(getAngleDiff(alpha, alphaForR)/PI)));\n\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfSRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 87, 87, 209], [211, 211, 268, 268, 668]], "test": "untested"}
{"id": "7dfXR2", "name": "fairy_circle.ff3", "author": "ff3", "description": "A fairy circle. This is my first shader. Hope it is acceptable for a first try.", "tags": ["fairy"], "likes": 0, "viewed": 240, "published": 3, "date": "1618946190", "time_retrieved": "2024-07-30T19:24:45.334962", "image_code": "const float CIRCLE_RAD = 100.;\nconst float TWO_PI = 6.28318530718;\nconst float AOE = 40.;\nconst int NUM_STARS = 12;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float intensity_exp = 0.0, intensity_lin = 0.0;\n\n    for (int j = 0; j < NUM_STARS; j++)\n    {\n        float theta = mod(texelFetch(iChannel0,ivec2(3*j,j),0).r, TWO_PI) + mod(float(iFrame),90.0);\n        float hypot = CIRCLE_RAD;\n        \n        vec2 star;\n\n        switch (j)\n        {\n            case 0:\n            case 4:\n            case 8:\n                star = (iResolution.xy * .5) + vec2(cos(theta) * hypot, sin(theta) * hypot);\n                break;\n            case 1:\n            case 5:\n            case 9:\n                star = (iResolution.xy * .5) + vec2(cos(theta) * -hypot, sin(theta) * hypot);\n                break;\n            case 2:\n            case 6:\n            case 10:\n                star = (iResolution.xy * .5) + vec2(cos(theta) * -hypot, sin(theta) * -hypot);\n                break;\n            case 3:\n            case 7:\n            case 11:\n                star = (iResolution.xy * .5) + vec2(cos(theta) * hypot, sin(theta) * -hypot);\n                break;\n        }\n        \n        float d = distance(fragCoord, star);\n        \n        intensity_exp += 1.0 - ( min(AOE, d * d) / AOE );\n        intensity_lin += 1.0 - ( min(AOE, d) / AOE );\n    }\n\n    fragColor = vec4(intensity_exp, intensity_exp, intensity_lin, 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfXR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 174, 174, 1442]], "test": "untested"}
{"id": "NsfXRf", "name": "Cookie casual Shader Showdown ", "author": "jeyko", "description": "we did this with Cookie Collective on a stream. ", "tags": ["shader", "design", "showdown"], "likes": 20, "viewed": 418, "published": 3, "date": "1618930622", "time_retrieved": "2024-07-30T19:24:46.097923", "image_code": "#define pmod(p,a) mod(p ,a) - 0.5*a\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat nois(vec3 _p){\n  vec4 p = vec4(_p,1. + iTime);\n  float n = 0.;\n  float amp = 1.;\n  for(int i = 0; i < 5; i++){\n  \n    p.xz *= rot(0.5);\n    p.wz *= rot(0.5);\n    p.yz *= rot(0.5);  \n    n += dot(sin(p),cos(p))*amp;\n  \n    amp *= 0.7;\n    p *= 1.5;\n  }\n  return n;\n}\nfloat N = 0.;\n\nvec3 pal(float m){return pow(0.5 + 0.5*sin(m + vec3(-0.5,-0.,0.5)),vec3(0.2));}\n\nfloat map(vec3 p){\n  N = nois(p*4.)*0.1;\n  float d = 10e5;\n  for(float i = 0.; i < 5.; i++){\n    p.xz *= rot(0.4 + (iTime + sin(iTime + i*11.5))*0.2);\n    p.yz *= rot(0.4 + (iTime + sin(iTime + i))*0.2);\n    d = min(d, length(p.xz) - 0.04 - N*0.5);\n    \n  }\n  return d;\n}\n\nfloat sdBox(vec2 p, vec2 s){p = abs(p) -s; return max(p.x,p.y);}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t\t\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(1);\n  \n  float pxsz = fwidth(uv.x);\n  {\n    vec3 c = vec3(0.6,0.2,0.7) + sin(uv.xyx*20.)*0.3;\n    \n    float md = 0.1;\n    \n    vec2 p = uv;\n    p.x += (sin(iTime) + iTime+ cos(iTime*1.5))*0.2;\n    vec2 id = floor(p/md);\n    float m = (sin(id.x + iTime + cos(id.y)*3.));\n    c = pal(uv.x + id.x);\n    p = pmod(p,md);\n    p *= rot(m + iTime);\n    \n    float d = abs(p.x);\n    d = min(d,abs(p.y));\n    \n    d = max(d,abs(length(p)- m*md*0.5) - 0.01);\n    \n    col = mix(col,c,smoothstep(pxsz,0.,d - 0.003));\n  }\n  {\n    vec3 c = vec3(0.6,0.2,0.7) + sin(uv.xyx*20.)*0.3;\n    \n    float md = 0.2;\n    \n    vec2 p = uv;\n    p += 0.05;\n    p.x += (sin(iTime) + iTime+ cos(iTime*1.5))*0.1;\n    vec2 id = floor(p/md);\n    float m = (sin(id.x + iTime + cos(id.y)*3.));\n    c = pal(uv.x + id.x);\n    p = pmod(p,md);\n    //p *= rot(m + iTime);\n    \n    float d = abs(p.x);\n    d = min(d,abs(p.y));\n    \n    //d = max(d,abs(length(p)- m*md*0.5) - 0.01);\n    \n    col = mix(col,c,smoothstep(pxsz,0.,d - 0.0001));\n  }\n  \n  \n  \n  {\n    vec3 p = vec3(0,0,-2);\n    vec3 rd = normalize(vec3(uv,1));\n    bool hit = false; float t= 0.;\n   \n    for(int i = 0; i < 60; i++){\n      float d = map(p);\n      if(d < 0.01){\n        hit = true;\n        break;\n      }\n      \n      p += rd*d;\n    }\n    if(hit){\n      //col = 1.-col;\n      col = vec3(1);\n      col = mix(col,pow(pal(p.x + p.y + sin(p.x)),vec3(2.)),nois(p*4.)*0.6);\n    }\n  }\n  \n  #define xor(a,b,c) min(max(a + c,-(b)),max(b,-(a)))\n  {\n    vec2 p = uv;\n    \n    float d = 10e5;\n    for(float i = 0.; i < 5.; i++){\n      float m = sin(iTime+i + cos(iTime+i));\n      vec2 q = p + vec2(m,0.)*0.2;\n      d = xor(d,abs(length(q) - length(sin(iTime+m))*0.2 ) - 0.01*m,-0.01);\n    }\n    col = mix(col,1.2-col,smoothstep(pxsz,0.,d));\n    \n  }\n  \n  {\n    vec2 p = uv;\n    p.y = abs(p.y) - 0.45;\n    float id = floor(p.x/0.1+ iTime*4. + cos(iTime+ sign(uv.y)*2. - 1.) + sign(uv.y)*2. - 1.);\n    \n    float d = abs(p.t) - 0.1;\n    \n    \n    col = mix(col,1.2-col*pal(id),smoothstep(pxsz,0.,d));\n    col = mix(col,1.2-col*pal(id*2.),smoothstep(pxsz,0.,abs(d) - 0.02));\n    \n    \n  }\n  \n  {\n    vec2 p = uv;\n    //p.y = abs(p.x) - 0.45;\n    \n    float d = abs(p.x - 0.6) - 0.1;\n    d = sdBox(p.x - vec2(0.5,0.),vec2(0.1,0.3));\n    \n    col = mix(col,1.-col*(0.6 + 0.5*pal(uv.y*4.)),smoothstep(pxsz,0.,d));\n    //col = mix(col,1.2-col*pal(id*2.),smoothstep(pxsz,0.,abs(d) - 0.02));\n    \n    \n  }\n  //col = 1. - col;\n  \n  //col = smoothstep(vec3(0),vec3(1.,0.9,1.1),col);\n  //col = pow();\n  \n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 106, 106, 357], [373, 373, 391, 391, 452], [454, 454, 472, 472, 725], [727, 727, 755, 755, 791], [792, 792, 847, 847, 3514]], "test": "untested"}
{"id": "fsXXzX", "name": "English Lane", "author": "blackjero", "description": "You are walking and flying through an infinite English countryside. \nChill out and use the mouse to look around. \nA single walk->fly cycle is about 50s.", "tags": ["forest", "cellular", "trees", "nature", "path", "roads", "devon"], "likes": 331, "viewed": 17235, "published": 3, "date": "1618927470", "time_retrieved": "2024-07-30T19:24:47.461277", "image_code": "IMAGE", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// English Lane by Jerome Liard, April 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/fsXXzX\n//\n// You are walking and flying through an infinite English countryside.\n// Chill out and use the mouse to look around. \n// A single walk->fly cycle is about 50s.\n//\n// Shadertoy compilation time seems to be about 15s, thanks for your patience.\n\n// This is the start lane index. At each walk-flight cycle we switch to the next lane midair.\n// You can set any reasonable integer value (negative ok too) to walk along other paths.\n\n#define FIRST_LANE_INDEX 10.0\n//#define FIRST_LANE_INDEX (-80.0+mod(iDate.x*365.+iDate.y*31.+iDate.z,160.)) // one different lane every day (no fade when day changes)\n\n// If the reprojection is janky please press the button that resets time to zero.\n//\n// I wanted to make a navigable countryside with paths inspired by paintings from Richard Thorn (see his book \"Down an English Lane\"), \n// and a little bit by Hiroshi Nagai and Tezuka Osamu's Jumping short anime (both life long inspirations).\n//\n// Creation of the initial patchwork and parameterized paths network:\n//\n//   - 2 perpendicular sets of regularly spaced parallel 1d lanes are used. \n//   - Each 1d lane has an id. The amplitude of each 1d lane must be such that they don't cross the previous or next 1d lane.\n//   - The horizonal set of parallel lanes have constant vertical center spacing.\n//   - The twist: the vertical set of parallel lanes can have their spacing set more freely based on which stab we are in the horizontal set.\n//     This helps generating complex branching patterns.\n//   - For each set of parallel lanes we simply use its local x coordinate as a parameter (used for garden brick wall and camera).\n//   - The intersections of lane stabs give us a cellular base for country patches, and for each patch we get an id, a distance to boundary, and parameterized borders.\n//\n// Trees and houses placement:\n//\n//   - Patches ids is used to decide what combination of things goes on the patch (trees, bushes, farms, walls, lawn...)\n//   - There are 3 layers of cellular placement for trees, bushes, and farms.\n//     - Bushes are too close to each other and must be soft blended, but 3x3 search is no-no so we do a \"4 or 5\" neighbours search (we only consider checkboard black cells).\n//     - For farms and trees we use randomly decimated jittered grid and actually only consider the current cell we are in, and hack marching to death to compensate.\n//   - Modeling:\n//     - Trees leaves volume have a base shape done with 2 spheres soft blended, then distored by 2 layers of packed 3d spheres tiling to blobify the leaves volume, and then some fine noise distortion on the surface.\n//       The use of densely packed sphere tiling is inspired by @Shane's Cellular Tiling https://www.shadertoy.com/view/4scXz2\n//     - Farms are randomized with gable and hipped roof, chimneys and colors very vaguely inspired by pictures of Devon.\n//\n// Marching:\n//\n//   - For patches, marching uses ghost steps nearby patch boundaries so that we don't check neighbour patches objects, only the patch we are in.\n//   - For trees and farms too, we force the raymarch to take ghost steps along their cell borders for x1 sdf eval.\n//     - This ghost point machinery is hacky and not perfect (esp on patches boundary where we don't have clean intersections) but still helps.\n//   - Because of all the cellular evals going on, to save height evals we use taylor expansion of the heightfield on local neiborhood.\n//   - Despite above efforts I had to resort to reprojection and still perf isn't great. \n//     Blurring the noise with reprojection also helps hide the general noisy lameness and gives better colors.\n//\n// Clouds are volumetric but baked in a spheremap at first frame and assumed distant.\n// Also had to turn view trace/shadow trace/scene gradient/cellular evals into loops to help compile time on the website, sometimes at the expense of runtime perfs.\n// As always some code, techniques, ideas from @iq, @Dave_Hoskins, @Shane, @FabriceNeyret2 are used in various places, \n// this shader also uses some spherical gaussian code from Matt Pettineo \n// (see comment for links to references).\n\n#define PI 3.141592654 // He does love his numbers\n#define FLT_MAX 1000000.0\n\n#define SQR2 1.414213562\n#define SQR3 1.732050807\n\n#define RED  vec3( 1, 0, 0 )\n#define GREEN vec3( 0, 1, 0 )\n#define BLUE vec3( 0, 0, 1 )\n#define WHITE vec3( 1, 1, 1 )\n#define BLACK vec3( 0, 0, 0 )\n#define MAGENTA vec3( 1, 0, 1 )\n#define YELLOW vec3( 1, 1, 0 )\n#define AZURE vec3( 0.0, 0.5, 1.0 )\n\n#define A_FEW_FUNC(type) \\\ntype saturate( type x ) { return clamp( x, type(0.0), type(1.0) ); } \\\ntype smoothstep_unchecked( type x ) { return ( x * x ) * ( type(3.0) - x * 2.0 ); } \\\ntype smoothstep_unchecked_d( type x ) { return 6.0 * x * ( type(1.0) - x ); }\n\nA_FEW_FUNC( float )\nA_FEW_FUNC( vec2 )\nA_FEW_FUNC( vec3 )\nA_FEW_FUNC( vec4 )\n\nfloat exp_decay( float x ) { return 1. - exp( -x ); }\n// cubic bump that goes through (0,0)->(1,0)\n// slope at x=0 is df0\n// slope at x=1 is df1\nfloat cubicbump( float x, float df0, float df1 ) { float a = df1 + df0; float c = df0; float b = -a - c; return x * ( x * ( x * a + b ) + c ); }\nfloat smoothbump( float a, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - a ), r ) / r ); }\n// like smoothstep, but takes a center and a radius instead\nfloat smoothstep_c( float x, float c, float r ) { return smoothstep( c - r, c + r, x ); }\n// centered at 0\nfloat smoothband( float x, float r, float raa ) { return 1. - smoothstep_c( abs( x ), r, raa ); }\n// range s,e\nfloat smoothband( float x, float s, float e, float raa ) { return smoothband( x - ( e + s ) * 0.5, ( e - s ) * 0.5, raa ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); } // return range -pi,pi\nfloat calc_angle( vec2 a, vec2 b ) { return calc_angle( vec2( dot( a, b ), dot( perp( a ), b ) ) ); }\nfloat contrast( float x, float s ) { return ( x - 0.5 ) * s + 0.5; }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec4 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nvec3 pow2( vec3 x ) { return x * x; }\nvec4 pow2( vec4 x ) { return x * x; }\n// variant of exp/log soft min and max that save a few instructions\nfloat smin_exp2( float a, float b, float k ) { return -log2( exp2( -k * a ) + exp2( -k * b ) ) / k; }\nfloat smax_exp2( float a, float b, float k ) { return -smin_exp2( -a, -b, k ); }\n// https://iquilezles.org/articles/smin\nfloat smin_pol( float a, float b, float k ) { float h = clamp( 0.5f + 0.5f * ( b - a ) / k, 0.0f, 1.0f ); return mix( b, a, h ) - k * h * ( 1.0 - h ); }\nfloat smax_pol( float a, float b, float k ) { return -smin_pol( -a, -b, k ); }\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat min_( float x, float y, float z ) { return min( min( x, y ), z ); }\nfloat max_( float x, float y, float z ) { return max( max( x, y ), z ); }\nfloat nearest( float x ) { return floor( 0.5 + x ); }\nfloat nearest( float x, float spacing ) { return floor( 0.5 + x / spacing ) * spacing; }\nvec2 nearest( vec2 x, vec2 spacing ) { return floor( vec2( 0.5 ) + x / spacing ) * spacing; }\nfloat sum( vec4 v ) { return v.x + v.y + v.z + v.w; }\nfloat safe_acos( float x ) { return acos( clamp( x, -1., 1. ) ); }\n\n// project this on line (O,d), d is assumed to be unit length\n#define PROJECT_ON_LINE1(type) \\\ntype project_on_line( type P, type O, type d ) { return O + d * dot( P - O , d ) / dot(d, d ); } \\\ntype project_on_plane( type P, type O, type n ) { return P - n * dot( P - O , n ) / dot(n, n ); } \\\n\nPROJECT_ON_LINE1( vec2 )\nPROJECT_ON_LINE1( vec3 )\n\n// https://iquilezles.org/articles/distance\n// fast and nice in most cases\n#define FAST_SIGNED_DISTANCE_TO_FUNC_11_ARG( a_signed_distance, a_p, a_func, a_arg, a_epsilon ) \\\n{ \\\n\tvec2 _p = a_p; \\\n\tfloat _epsilon = a_epsilon; \\\n\tfloat _y = a_func( _p.x, a_arg ); \\\n\tfloat _y1 = a_func( _p.x + _epsilon, a_arg ); \\\n\tfloat _ddy = ( _y1 - _y ) * ( 1. / _epsilon ); \\\n\ta_signed_distance = ( _p.y - _y ) / sqrt( 1. + _ddy * _ddy ); \\\n}\n\n// this macro returns:\n//  - the vector to the closest point on a curve (the length of which gives a better distance than FAST_SIGNED_DISTANCE_TO_FUNC_11) \n//  - the tangent at that closest point\n// http://www.geometrie.tugraz.at/wallner/sproj.pdf\n// input:\n//  a_p               eval at pos\n//  a_funcd           is the R->R function to evaluate, first guess (iteration start point) is vec2(a_p.x,a_func(a_p.x))\n//                    a_funcd can be a macro, it seems\n//                    returns the function value at t in .x and the derivative at t in .y\n//  a_funcd_arg       an argument passed to a_func\n//  a_cheap           num iterations, 2 should be enough, a_cheap==true only does 1 iteration\n//\n// output:\n//  a_ret   \t\t  a_ret.xy is vector to closest point on curve\n//                    a_ret.zw is the derivative (tangent at the closest point)\n//\n// note: we could get the sign from the first iteration\n\n#define CLOSEST_POINT_TANGENT_TO_FUNCD_11_ARG_CHEAP( a_ret, a_p, a_funcd, a_funcd_arg, a_cheap ) \\\n{ \\\n\tvec2 _p = a_p.xy, _c, _dc, _ev; \\\n\tfloat _t = _p.x; /* t0, could be a parameter if the user knows better */ \\\n\t_ev = a_funcd( _t, a_funcd_arg ); \\\n\t_c = vec2( _t, _ev.x ); \\\n\t_dc = vec2( 1.0, _ev.y ); /*important: 1 in x!*/ \\\n\tif ( !(a_cheap) ) /* IMPORTANT: if num iteration is 2, an if test can behave much better than for loop */ \\\n\t{ \\\n\t\t/*#if 0*/ \\\n\t\t/*vec2 _q = project_on_line( _p.xy, _c, _dc );*/ \\\n\t\t/*_t += dot( _dc, _q - _c ) / dot( _dc, _dc );*/ \\\n\t\t/* simplifies to: */ \\\n\t\t/*#else*/ \\\n\t\t_t += dot( _p.xy - _c, _dc ) / dot( _dc, _dc ); \\\n\t\t/*#endif*/ \\\n\t\t_ev = a_funcd( _t, a_funcd_arg ); \\\n\t\t_c = vec2( _t, _ev.x ); \\\n\t\t_dc = vec2( 1.0, _ev.y ); /*important: 1 in x!*/ \\\n\t} \\\n\ta_ret = vec4( _c - _p, _dc ); \\\n}\n\nvec3 transform_vector( mat4 m, vec3 v ) { return ( m * vec4( v, 0.0 ) ).xyz ; }\n\nstruct bounds2 { vec2 pmin; vec2 pmax; };\nbounds2 mkbounds_unchecked( vec2 amin, vec2 amax ) { bounds2 ret; ret.pmin = amin; ret.pmax = amax; return ret; }\n\n#define REPEAT_FUNCTIONS( type ) \\\ntype repeat( type x, type len ) { return len * fract( x * ( type( 1.0 ) / len ) ); }\\\ntype repeat_mirror( type x, type len ) { return len * abs( type( -1.0 ) + 2.0 * fract( ( ( x * ( type( 1.0 ) / len ) ) - type( -1.0 ) ) * 0.5 ) ); }\n\nREPEAT_FUNCTIONS( float )\nREPEAT_FUNCTIONS( vec2 )\n\n// badly antialiased stripes\n// r is the half width of the stripes\n// raa is the half size of the edge/aa smoothstep (ex: pixel_size)\n// period is the distance between 2 consecutive stripes\n\nfloat stripes( float x, float period, float r, float raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\nvec2 stripes( vec2 x, vec2 period, vec2 r, vec2 raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\n\n// triangular sin waves - you can drop in as a replacement for sin to get polygonized looks\nfloat tri_sin( float x ) { return (abs(fract((x-PI*0.5)/(PI*2.))-0.5)-0.25)*4.0; }\n\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\nfloat hash11(float p) { p = fract(p * .1031); p *= p + 33.33; p *= p + p; return fract(p); }\nfloat hash12(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * .1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }\nfloat hash13(vec3 p3) { p3 = fract(p3 * .1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }\nvec2 hash22(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xx +p3.yz )*p3.zy ); }\nvec2 hash23(vec3 p3) { p3 = fract(p3 * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xx +p3.yz )*p3.zy ); }\nvec3 hash31(float p) { vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xxy +p3.yzz )*p3.zyx ); }\nvec3 hash32(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yxz +33.33); return fract((p3.xxy +p3.yzz )*p3.zyx ); }\nvec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yxz +33.33); return fract((p3.xxy + p3.yxx )*p3.zyx ); }\n\n//###############################################################################\n\n// iq's function munged for vec4, used in city shader...\n// https://www.shadertoy.com/view/XlXcW4 note: source has changed since then...\n\nvec4 hash42_( ivec2 x0 )\n{\n\tuint k = 1103515245U;  // GLIB C\n\tuvec4 x = uvec4( x0, x0 * 0x8da6b343 );\n\tx = (( x >> 13U ) ^ x.yzwx ) * k;\n\tx = (( x >> 13U ) ^ x.zwxy ) * k;\n//\tx = (( x >> 13U ) ^ x.wxyz ) * k; // can't really tell the difference\n\treturn vec4( x ) * ( 1.0 / float( 0xffffffffU ));\n}\n\n// integer hashes\n// https://www.shadertoy.com/view/4tXyWN iq\n\nfloat hash1u2_4tXyWN( uvec2 x )\n{\n\tuvec2 q = 1103515245U * ( ( x >> 1U ) ^ ( x.yx  ) );\n\tuint  n = 1103515245U * ( ( q.x  ) ^ ( q.y >> 3U ) );\n\treturn float( n ) * ( 1.0 / float( 0xffffffffU ) );\n}\n\n// https://nullprogram.com/blog/2018/07/31/ Chris Wellons\n// https://www.shadertoy.com/view/WttXWX via Fabrice\n\nuint lowbias32(uint x) { x ^= x >> 16; x *= 0x7feb352dU; x ^= x >> 15; x *= 0x846ca68bU; x ^= x >> 16; return x; }\nfloat hash11u_lowbias32( uint x ) { return float( lowbias32( x ) ) / float( 0xffffffffU ); }\n\n#define V30 vec2( 0.866025403, 0.5 )\n#define V45 vec2( 0.707106781, 0.707106781 )\n#define V60 vec2( 0.5, 0.866025403 )\n\n// return a unit vector, or an angle (it's the same thing)\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\n// note that if point p is also a unit vector, rotate_with_unit_vector returns the same as doing unit_vector2 on the sum of the angles (obvious but)\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n// theta is angle with the z axis, range [0,pi].\n// phi is angle with x vectors on z=0 plane, range [0,2pi].\n// theta_vec is the unit vector for angle theta\n// phi_vec is the unit vector for angle phi\nvec3 zup_spherical_coords_to_vector( vec2 theta_vec, vec2 phi_vec ) { return vec3( theta_vec.y * phi_vec, theta_vec.x ); }\nvec3 zup_spherical_coords_to_vector( float theta, float phi ) { return zup_spherical_coords_to_vector( unit_vector2( theta ), unit_vector2( phi ) ); }\nvec3 zup_spherical_coords_to_vector( vec2 theta_phi ) { return zup_spherical_coords_to_vector( theta_phi.x, theta_phi.y ); }\n\n// note: n.xy==0 is undefined for phi, pleae handle in caller code\nvec2 vector_to_zup_spherical_coords( vec3 n )\n{\n\tfloat theta = safe_acos( n.z ); // note: vectors normalized with normalize() are not immune to -1,1 overflow which cause nan in acos\n\tfloat phi = calc_angle( n.xy  );\n\treturn vec2( theta, phi );\n}\n\nvec3 yup_spherical_coords_to_vector( vec2 theta, vec2 phi ) { return zup_spherical_coords_to_vector( theta, phi ).yzx ; }\nvec3 yup_spherical_coords_to_vector( float theta, float phi ) { return yup_spherical_coords_to_vector( unit_vector2( theta ), unit_vector2( phi ) ); }\n\nmat4 yup_spherical_coords_to_matrix( vec2 theta, vec2 phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( perp( theta ), phi ); // note: perp(theta) = unit_vector2(theta+PI*0.5)\n\tvec3 x = cross( y, z );\n\treturn ( mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) ) );\n}\n\nmat4 yup_spherical_coords_to_matrix( float theta, float phi ) {  return yup_spherical_coords_to_matrix( unit_vector2( theta ), unit_vector2( phi ) ); }\n\nmat4 z_rotation( float angle ) { vec2 v = unit_vector2( angle ); return mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) ); }\n\nmat3 mat3_rotation_x( vec2 v ) { return mat3( vec3( 1, 0, 0 ), vec3( 0, v.x, v.y ), vec3( 0, -v.y, v.x ) ); }\nmat3 mat3_rotation_z( vec2 v ) { return mat3( vec3( v.x, v.y, 0 ), vec3( -v.y, v.x, 0 ), vec3( 0, 0, 1 ) ); }\n\n// icdf for pdf a*exp(-a*x) (wikipedia Exponential distribution)\nfloat ed_icdf( float u, float a ) { return -log( 1. - u ) * ( 1.0 / a ); }\n\n#define INDEXHASHOFFSET3 vec3( 137.0, 53.0, 173 )\n\n#define LAYERED1(func,p,args) ((func(p*1.0,args)*0.5)                                                                                               *(1.0/(0.5)))\n#define LAYERED2(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25)                                                                         *(1.0/((0.5+0.25))))\n#define LAYERED4(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25+func(p*4.0,args)*0.125+func(p*8.0,args)*0.0625)                          *(1.0/((0.5+0.25+0.125+0.0625))))\n#define LAYERED5(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25+func(p*4.0,args)*0.125+func(p*8.0,args)*0.0625+func(p*16.0,args)*0.03125)*(1.0/((0.5+0.25+0.125+0.0625+0.03125))))\n\nfloat noise12( vec2 p, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec2 p00 = floor( p );\n\tvec2 p10 = p00 + vec2( 1, 0 );\n\tvec2 p01 = p00 + vec2( 0, 1 );\n\tvec2 p11 = p00 + vec2( 1, 1 );\n\n\tfloat v00 = hash12( p00 );\n\tfloat v10 = hash12( p10 );\n\tfloat v01 = hash12( p01 );\n\tfloat v11 = hash12( p11 );\n\n\tvec2 f = fract( p ); // p-p00 but beware large values...\n\n\tif ( use_smooth ) f = smoothstep_unchecked( f );\n\n\tfloat A = v10 - v00;\n\tfloat B = v01 - v00;\n\tfloat C = ( v11 - v01 ) - A;\n\tfloat D = v00;\n\n//\treturn mix( mix( v00, v10, f.x ), mix( v01, v11, f.x ), f.y ),\n\treturn A * f.x + B * f.y + C * f.x * f.y + D;\n}\n\nfloat noise13( vec3 p, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec3 p000 = floor( p ) + INDEXHASHOFFSET3;\n\tvec3 p100 = p000 + vec3( 1, 0, 0 );\n\tvec3 p010 = p000 + vec3( 0, 1, 0 );\n\tvec3 p110 = p000 + vec3( 1, 1, 0 );\n\tvec3 p001 = p000 + vec3( 0, 0, 1 );\n\tvec3 p101 = p000 + vec3( 1, 0, 1 );\n\tvec3 p011 = p000 + vec3( 0, 1, 1 );\n\tvec3 p111 = p000 + vec3( 1, 1, 1 );\n\n\tfloat v000 = hash13( p000 );\n\tfloat v100 = hash13( p100 );\n\tfloat v010 = hash13( p010 );\n\tfloat v110 = hash13( p110 );\n\tfloat v001 = hash13( p001 );\n\tfloat v101 = hash13( p101 );\n\tfloat v011 = hash13( p011 );\n\tfloat v111 = hash13( p111 );\n\n\tvec3 f = fract( p ); // bilinear\n\n\tif ( use_smooth ) f = smoothstep_unchecked(f);\n\t\n\treturn mix( mix( mix( v000, v100, f.x ),\n\t\t\t\t\t mix( v010, v110, f.x ), f.y ),\n\t\t\t\tmix( mix( v001, v101, f.x ),\n\t\t\t\t\t mix( v011, v111, f.x ), f.y ), f.z );\n}\n\nvec3 noise33( vec3 p, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec3 p000 = floor( p ) + INDEXHASHOFFSET3;\n\tvec3 p100 = p000 + vec3( 1, 0, 0 );\n\tvec3 p010 = p000 + vec3( 0, 1, 0 );\n\tvec3 p110 = p000 + vec3( 1, 1, 0 );\n\tvec3 p001 = p000 + vec3( 0, 0, 1 );\n\tvec3 p101 = p000 + vec3( 1, 0, 1 );\n\tvec3 p011 = p000 + vec3( 0, 1, 1 );\n\tvec3 p111 = p000 + vec3( 1, 1, 1 );\n\n\tvec3 v000 = hash33( p000 );\n\tvec3 v100 = hash33( p100 );\n\tvec3 v010 = hash33( p010 );\n\tvec3 v110 = hash33( p110 );\n\tvec3 v001 = hash33( p001 );\n\tvec3 v101 = hash33( p101 );\n\tvec3 v011 = hash33( p011 );\n\tvec3 v111 = hash33( p111 );\n\n\tvec3 f = fract( p ); // bilinear\n\n\tif ( use_smooth ) f = smoothstep_unchecked(f); // looks sharper in 3d\n\n\treturn mix( mix( mix( v000, v100, f.x ),\n\t\t\t\t\t mix( v010, v110, f.x ), f.y ),\n\t\t\t\tmix( mix( v001, v101, f.x ),\n\t\t\t\t\t mix( v011, v111, f.x ), f.y ), f.z );\n}\n\nfloat enoise13( vec3 p, float a, bool use_smooth )\n{\n\tp -= 0.5;\n\n\tvec3 p000 = floor( p ) + INDEXHASHOFFSET3;\n\tvec3 p100 = p000 + vec3( 1, 0, 0 );\n\tvec3 p010 = p000 + vec3( 0, 1, 0 );\n\tvec3 p110 = p000 + vec3( 1, 1, 0 );\n\tvec3 p001 = p000 + vec3( 0, 0, 1 );\n\tvec3 p101 = p000 + vec3( 1, 0, 1 );\n\tvec3 p011 = p000 + vec3( 0, 1, 1 );\n\tvec3 p111 = p000 + vec3( 1, 1, 1 );\n\n\tvec2 h000 = hash23( p000 );\n\tvec2 h100 = hash23( p100 );\n\tvec2 h010 = hash23( p010 );\n\tvec2 h110 = hash23( p110 );\n\tvec2 h001 = hash23( p001 );\n\tvec2 h101 = hash23( p101 );\n\tvec2 h011 = hash23( p011 );\n\tvec2 h111 = hash23( p111 );\n\n\tfloat v000 = ed_icdf( h000.x, a ) * h000.y;\n\tfloat v100 = ed_icdf( h100.x, a ) * h100.y;\n\tfloat v010 = ed_icdf( h010.x, a ) * h010.y;\n\tfloat v110 = ed_icdf( h110.x, a ) * h110.y;\n\tfloat v001 = ed_icdf( h001.x, a ) * h001.y;\n\tfloat v101 = ed_icdf( h101.x, a ) * h101.y;\n\tfloat v011 = ed_icdf( h011.x, a ) * h011.y;\n\tfloat v111 = ed_icdf( h111.x, a ) * h111.y;\n\n\tvec3 f = fract( p ); // bilinear\n\n\tif ( use_smooth ) f = smoothstep_unchecked(f); // looks sharper in 3d\n\n\treturn mix( mix( mix( v000, v100, f.x ),\n\t\t\t\t\t mix( v010, v110, f.x ), f.y ),\n\t\t\t\tmix( mix( v001, v101, f.x ),\n\t\t\t\t\t mix( v011, v111, f.x ), f.y ), f.z );\n}\n\n// prefix meaning: \n//  e stands for exponential distribution\n//  s stands for smoothstep interpolation\nfloat snoise12_( vec2 p, float args ) { return noise12( p, true ); }\nfloat snoise13_( vec3 p, float args ) { return noise13( p, true ); }\nvec3 noise33_( vec3 p, float args ) { return noise33( p, false ); }\nfloat enoise13_( vec3 p, float a ) { return enoise13( p, a, false ); }\nfloat sfbm1_12( vec2 p ) { return LAYERED1( snoise12_, p, -1.0); }\nfloat sfbm2_13( vec3 p ) { return LAYERED2( snoise13_, p, -1.0); }\nfloat sfbm2_13_leaf( vec3 p ) { return (noise13(p*0.8,true)+noise13(p*4.0,true)*0.6)/1.5;}\nfloat sfbm2_12( vec2 p ) { return LAYERED2( snoise12_, p, -1.0); }\nfloat efbm4_13( vec3 p, float arg ) { return LAYERED4( enoise13_, p, arg); }\nvec3 sfbm4_33( vec3 p ) { return LAYERED5( noise33_, p, -1.0); }\n\nstruct Ray { vec3 o; vec3 d;  };\n\nRay mkray( vec3 o, vec3 d ) { Ray tmp; tmp.o = o; tmp.d = d; return tmp; }\n\nvec3 get_view_dir( vec2 normalized_pos, float aspect, float tan_half_fovy_rcp )\n{\n\treturn normalize( vec3( normalized_pos.x * aspect, normalized_pos.y, -tan_half_fovy_rcp ) ); // note: looking down z\n}\n\n// same as get_view_ray_old but without a znear\n// note that we pass the reciprocal of tan_half_fovy\n// normalized_pos is (-1,1-)->(1,1)\nRay get_view_ray2( vec2 normalized_pos, float aspect, float tan_half_fovy_rcp, mat4 camera )\n{\n\treturn mkray( camera[3].xyz , transform_vector( camera, get_view_dir( normalized_pos, aspect, tan_half_fovy_rcp ) ) );\n}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up )\n{\n\tvec3 z = normalize( eye - center );\n\tvec3 x = normalize( cross( up, z ) );\n\tvec3 y = cross( z, x );\n\treturn mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) );\n}\n\nvec2 sphere_trace( Ray ray, float radius, vec3 center )\n{\n\tvec3 O = ray.o;\n\tvec3 d = ray.d;\n\tfloat tp = dot( center - O, d ); // O + d * tp = center projected on line (O,d)\n\tfloat h_sqr = lensqr( ( O + d * tp ) - center );\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere\n\tfloat dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)\n\treturn vec2( tp - dt, tp + dt ); // record 2 hits In, If\n}\n\nfloat plane_trace( vec3 ray_o, vec3 ray_d, vec3 base, vec3 n, float epsilon ) { float ddotn = dot( ray_d, n ); return abs( ddotn ) > epsilon ? dot( base - ray_o, n ) / ddotn : FLT_MAX; }\nfloat plane_trace( Ray ray, vec3 base, vec3 n, float epsilon ) { float ddotn = dot( ray.d, n ); return abs( ddotn ) > epsilon ? dot( base - ray.o, n ) / ddotn : FLT_MAX; }\nfloat plane_trace_z( Ray ray, float base, float epsilon ) { return abs( ray.d.z ) > epsilon ? ( base - ray.o.z ) / ray.d.z : FLT_MAX; }\n// d is a unit direction, ray starts at 0,0,0 base is plane position along z, this is just a division...\nfloat plane_trace_z( vec3 d, float base, float epsilon ) { return abs( d.z ) > epsilon ? base / d.z : FLT_MAX; }\n\n// build a little quadric so that y'(0)=0, y(r)=r, y'(r)=1 here\nfloat her2( float x, float r ) { return 0.5 * ( ( 1.0 / r ) * x * x + r ); }\n// smooth bevel (like a soft_abs function)\nfloat curved_max_vfunc_weld_quadric( float x, float r ) { x = abs( x ); return x > r ? x : her2( x, r ); }\n// max\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opI_soft2( float a, float b, float k ) { return smax_exp2( a, b, k ); }\nfloat opI_soft2_pol( float a, float b, float k ) { return smax_pol( a, b, k ); }\nfloat opI_weld_quadric( float a, float b, float r ) { float c = ( a + b ) * 0.5; return c + curved_max_vfunc_weld_quadric( a - c, r ); }\n// min(a,b) = -max(-a,-b)\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opU_soft2_pol( float a, float b, float k ) { return -opI_soft2_pol( -a, -b, k ); }\nfloat opU_weld_quadric( float a, float b, float r ) { return -opI_weld_quadric( -a, -b, r ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 );}\nfloat opS_soft2( float a, float b, float k ) { return opI_soft2( -b, a, k ); }\nfloat opI( float d1, float d2, float d3 ) { return max( max( d1, d2 ), d3 ); }\n\n// r can be zero\nfloat sd_bounds_range_round( vec2 p, vec2 mi, vec2 ma, float r )\n{\n\tvec2 h = ( ma - mi ) * 0.5;\n\tp = abs( p - ( mi + ma ) * 0.5 );\n\tvec2 c = h - r;\n\tfloat mask = maxcomp( step( c, p ) );\n\treturn mix( maxcomp( p - c ), length( max( p - c, vec2( 0.0 ) ) ), mask ) - r;\n}\n\n// r can be zero\nfloat sd_bounds_range_round( vec3 p, vec3 mi, vec3 ma, float r )\n{\n\tvec3 h = ( ma - mi ) * 0.5;\n\tp = abs( p - ( mi + ma ) * 0.5 );\n\tvec3 c = h - r;\n\tfloat mask = maxcomp( step( c, p ) );\n\treturn mix( maxcomp( p - c ), length( max( p - c, vec3( 0.0 ) ) ), mask ) - r;\n}\n\nfloat sd_bounds_half_size( float p, float h ) { p = abs( p ) - h; return p; }\nfloat sd_bounds_half_size( vec2 p, vec2 h ) { p = abs( p ) - h; return opI( p.x, p.y ); }\nfloat sd_bounds_half_size( vec3 p, vec3 h ) { p = abs( p ) - h; return opI( p.x, p.y, p.z ); }\nfloat sd_bounds_range( vec2 p, vec2 mi, vec2 ma ) { vec2 hmi = mi * 0.5; vec2 hma = ma * 0.5; return sd_bounds_half_size( p - ( hma + hmi ), hma - hmi ); }\n// those bounds repeat might be good after all, since they centering and lead to a correct repeat...\nfloat sd_bounds_range( float p, float mi, float ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds_range( vec3 p, vec3 mi, vec3 ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\n\nfloat sd_sphere( vec3 p, vec3 center, float radius ) { return length( p - center ) - radius; }\nfloat sd_sphere( vec2 p, vec2 center, float radius ) { return length( p - center ) - radius; }\n\n// iq's https://www.shadertoy.com/view/Xds3zN modified for z up\nfloat sdCylinder( vec3 p, vec2 h )\n{\n\tvec2 d = abs( vec2( length( p.xy ),p.z)) - h;\n\treturn min( max( d.x, d.y ), 0.0 ) + length( max( d, vec2( 0.0 ) ) );\n}\n\n// internal function in packed_spheres_tiling3d\nfloat packed_spheres_tiling3d_internal_layer( vec3 p )\n{\n\tvec2 rh = vec2( 1.0, SQR3 ); // r=1  (normally h = spacing*0.5 * SQR3, and here spacing=2)\n\tvec2 c = rh * 2.0; // cell size for each row\n\tvec2 i1 = floor( p.xy  / c );\n\tvec2 i2 = floor( ( p.xy  - rh ) / c );\n\treturn min(\n\t\tlength( p - vec3( ( i1 + vec2( 0.5 ) ) * c, 0 ) ) - 1.0f,\n\t\tlength( p - vec3( ( i2 + vec2( 0.5 ) ) * c + rh, 0 ) ) - 1.0f ); // second row offset by rh\n}\n\n// sdf of packed spheres of radius 1 (just add to distance for smaller radius...)\nfloat packed_spheres_tiling3d( vec3 p )\n{\n\tvec3 p0 = p;\n\tfloat h = SQR3; // height of equilateral triangle of edge len 1+1=2\n\tfloat b = ( 1.0 - h * h ) / ( -2.0 * h );\n\tfloat c = h - b;\n\tfloat h3 = sqrt( 2.0 * 2.0 - c * c ); // height of tetrahedra, also the spacing between layers, also the half period of each layer\n\tp = p0;\n\tp.z -= ( floor( ( p.z - ( -h3 ) ) / ( 2.0 * h3 ) ) + 0.5 ) * ( 2.0 * h3 ) - h3; // repeat layer\n\tfloat d1 = packed_spheres_tiling3d_internal_layer( p );\n//\treturn d1;\n\tp = p0;\n\tp.y += h - b; // offset to overlap centers of first layer exactly\n\tp.z -= ( floor( ( p.z - 0.0 ) / ( 2.0 * h3 ) ) + 0.5 ) * ( 2.0 * h3 ) - 0.0; // repeat layer\n\tfloat d2 = packed_spheres_tiling3d_internal_layer( p );\n//\treturn d2;\n//\treturn opU( d1, d2 );\n\treturn min( d1, d2 );\n}\n\n// r is sphere radius, distance between 2 spheres is spacing\n// r must be < spacing/2\nfloat packed_spheres_tiling3d( vec3 p, float r, float spacing )\n{\n\tfloat s = spacing * 0.5; // packed sphere radius\n\treturn packed_spheres_tiling3d( p * ( 1.0 / s ) ) * s + ( s - r );\n}\n\n// r is sphere radius, distance between 2 spheres is 2*r\nfloat packed_spheres_tiling3d( vec3 p, float r )\n{\n\treturn packed_spheres_tiling3d( p * ( 1.0 / r ) ) * r;\n}\n\nvec3 tonemap_reinhard( vec3 x ) { return x / ( 1. + x ); }\n// mentioned in http://resources.mpi-inf.mpg.de/tmo/logmap/\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }\n\n// the couple of following functions are copied from Matt Pettineo's spherical gaussian article, \n// I liked the soft look and ease of use of SG and ended up keeping to the end\n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/\n\nstruct SG { vec3 Amplitude; vec3 Axis; float Sharpness; };\n\n// approximate integral on omega of sg(v)dv\nvec3 ApproximateSGIntegral( in SG sg ) { return 2. * PI * ( sg.Amplitude / sg.Sharpness ); }\n\nSG CosineLobeSG( in vec3 direction )\n{\n\tSG cosineLobe;\n\tcosineLobe.Axis = direction;\n\tcosineLobe.Sharpness = 2.133f;\n\tcosineLobe.Amplitude = vec3( 1.17f );\n\treturn cosineLobe;\n}\n\n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-3-diffuse-lighting-from-an-sg-light-source/\n\nvec3 SGIrradianceFitted( in SG lightingLobe, in vec3 normal )\n{\n\tfloat muDotN = dot( lightingLobe.Axis, normal );\n\tfloat lambda = lightingLobe.Sharpness;\n\n\tfloat c0 = 0.36f;\n\tfloat c1 = 1.0f / ( 4.0f * c0 );\n\n\tfloat eml  = exp( -lambda );\n\tfloat em2l = eml * eml;\n\tfloat rl   = 1.0 / lambda;\n\n\tfloat scale = 1.0f + 2.0f * em2l - rl;\n\tfloat bias  = ( eml - em2l ) * rl - em2l;\n\n\tfloat x  = sqrt( 1.0f - scale );\n\tfloat x0 = c0 * muDotN;\n\tfloat x1 = c1 * x;\n\n\tfloat n = x0 + x1;\n\n\tfloat y = saturate( muDotN );\n\tif ( abs( x0 ) <= x1 ) y = n * n / x;\n\n\tfloat result = scale * y + bias;\n\n\treturn result * ApproximateSGIntegral( lightingLobe );\n}\n\n// what am I doing\nvec3 SGDiffuseFitted( in SG lightingLobe, in vec3 normal, vec3 albedo )\n{\n\tvec3 brdf = albedo / PI;\n\treturn SGIrradianceFitted( lightingLobe, normal ) * brdf;\n}\n\n// BUFFER_MODE\n// 0: normal size (ugly but use to check artifacts in high def, also cloudless)\n// 2: halfsize + history reprojection... blurry-but-AA type of thing\n#define BUFFER_MODE 2\n\n// iChannel0 is always Buf A\n// iChannel1 is always Buf B\n\n// note: glsl doesn't let us write if (1), so we write if (_1), note that occasionally compiler may fail to treat that as a static branch\n#define _1 true\n#define _0 false\n\n// skip space faster above bushes (and maybe other things if proves useful)\n// notes:\n//  - at higher res we can see that causes artifacts, see the bit that sets\n//    eval.terrain_warp and tweak hack constants there\n//  - this causes artifacts on trees's tracing... close to patch borders maybe? (messes with shadows sometimes)\n//  - this messes with bush shadows even when bush surface seems unchanged (shrinks shadows a bit)\n#define TERRAIN_WARP\n\n#define FORCE_LOOP +min(0,aFrame)\n#define FORCE_LOOPF +min(0.0,float(aFrame))\n\n#define SHADOW_TINT_SATURATION 0.45 // [0,1]\n\n#define AO _0 // nice term, visible extra cost, but doesn't contribute much, so disable \n#define SHADOWS _1\n\n#define SUN _1\n#define SUN_GLARE _0 // could be interesting but needs more work\n\n#define GROUND_OCCLUSION _1 // first sdf is ground's base level so we get occlusion\n#define PATH _1 // cost peanuts\n#define GRASS _1 // cost peanuts\n#define BUSH _1 // a bit expensive\n#define TREE _1 // super expensive\n#define FARM _1 // cost a little bit\n#define BRICKWALL _1 // cost a little bit\n\n#define TAYLOR_HEIGHT_BUSH _1\n#define TAYLOR_HEIGHT_TREE _1\n#define TAYLOR_HEIGHT_FARM _0 // object is too large, causes a little bit too much distortion\n\n#define GHOST_STEPS_PATCH _1\n#define GHOST_STEPS_TREE _1 // visible extra cost, fixes the trees, but we start hitting iteration limit\n#define GHOST_STEPS_FARM _1 // little cost (large cells) and fixes farms, hits a little bit more max iterations far away\n// about GHOST_MAX_DIST:\n// introduced a second distance for bird views\n// having 2 thresh lets us fix bird view, but they get more expensive\n#define GHOST_MAX_DIST_FROM_T0 7.0\n#define GHOST_MAX_DIST_ABS 25.0\n// fixes weird grain that happens when using second threshold that goes further away... hack hack...\n#define GHOST_EPS 0.0001\n\n#define DISPLACE_PATH _1 // a bit expensive, actually\n#define DISPLACE_PATH_AMPL 0.002\n\n#define DISPLACE_PINE _1\n#define DISPLACE_TREE _1\n#define DISPLACE_BUSH _1\n#define DISPLACE_BUSH_FREQ 8.0\n\n// CLOUD_MODE\n//  0: no cloud\n//  1: trace cloud per pixel (for debug)\n//  2: cache trace cloud in B texture every frame and use that (for debug)\n// >3: cache trace cloud in B texture only first frame and use that (same cost as no cloud)\n#define CLOUD_MODE 3\n\n// the wind doesn't have much amplitude, and movement isn't smooth enough, but reprojection hides that a bit...\n#define WIND_BUSH _1\n#define WIND_TREE_AND_PINES _1\n\n#define FARM_WINDOWS _1\n\n#define SOFT_BLEND_BUSH _1\n#define SQUARE_BUSH_TEST _1 // some farms have nicely cut bushes arounds them\n\n#define MATID_NONE    0.0\n#define MATID_BUSH    1.0\n#define MATID_TRUNK   2.0\n#define MATID_HOUSE   3.0\n#define MATID_ROOF    4.0\n#define MATID_PINE    5.0\n#define MATID_BRICKWALL   6.0\n#define MATID_GRASS   7.0\n#define MATID_GROUND  8.0\n#define MATID_TREE    9.0\n#define MATID_WINDOW 10.0\n#define MATID_HOUSE_BOTTOM 11.0\n\n#define BROWN (vec3(133,84,57)/255.0)\n#define PATH_COLOR BROWN\n#define PATH_COLOR2 (BROWN*0.8)\n#define COLOR_BUSH1 (0.8*vec3(0.07,0.3,0.05))\n#define COLOR_BUSH2 (0.55*vec3(0.12,0.6,0.2))\n#define COLOR_BUSH3 (0.55*vec3(0.1,0.35,0.09))\n#define COLOR_BUSH4 (0.82*vec3(0.18,0.39,0.06))\n#define COLOR_BUSH5 vec3(0.1,0.3,0.01) // rare color\n#define COLOR_TREE1 (vec3(0.1,0.35,0.09)*0.55)\n#define COLOR_TREE2 (vec3(0.1,0.45,0.08)*0.8)\n#define COLOR_TREE_SURF vec3(0.15,0.4,0.04)\n#define COLOR_GRASS vec3(0.1,0.35,0.09)\n#define COLOR_GRASS2 vec3(0.35,0.39,0.06)\n#define COLOR_MOWED_GRASS vec3(0.17,0.37,0.05)\n#define COLOR_MOWED_GRASS2 (COLOR_MOWED_GRASS* 0.6)\n#define COLOR_PINE (vec3(0.4,1.0,0.2)*0.2)\n#define COLOR_PINE2 (vec3(0.5,1.0,0.0)*0.32)\n#define COLOR_TRUNK (BROWN*0.5)\n#define COLOR_ROOF1 (vec3(0.6,0.2,0.3)*0.7)\n#define COLOR_ROOF2 (vec3(0.1,0.4,0.5)*0.7)\n#define COLOR_BRICKWALL mix(vec3(0.52,0.33,0.22),vec3(0.9,0.9,0.7),0.35)\n#define COLOR_HOUSE mix((vec3(1,1,1)*0.65),COLOR_BRICKWALL,0.1) // white is a bit too white so blend with brickwall color\n#define COLOR_HOUSE_BOTTOM (COLOR_HOUSE*0.7)\n\nstruct CellPoint\n{\n\tvec2 p;\n\tivec2 _pi; // some cell index to take a hash from\n\tfloat pradius; // point radius, small points can be closer to cell edges\n};\n\n// meaning of id varies, if 32bits floats we should be able to have exact ints up to 2^24=16777216\nstruct DistanceId { float d; float id;  };\n\nDistanceId MkDistanceId( float d, float id ) { DistanceId v; v.d = d; v.id = id; return v; }\n\nDistanceId MkDistanceId_16( float d, float id, float id_fraction )\n{\n\treturn MkDistanceId( d, float( int( id ) | ( int( id_fraction * 65535.0 ) << 5 ) ) );\n}\n\nDistanceId MkDistanceId_5_5_5( float d, float id, vec3 v )\n{\n\treturn MkDistanceId( d, float( int( id )\n\t\t\t\t\t\t\t\t   | ( int( v.x * 31.0 ) <<  5 )\n\t\t\t\t\t\t\t\t   | ( int( v.y * 31.0 ) << 10 )\n\t\t\t\t\t\t\t\t   | ( int( v.z * 31.0 ) << 15 ) ) );\n}\n\nvec2 DecodeId_16( DistanceId di )\n{\n\tint i = int( di.id );\n\treturn vec2( float( i&31 ), float( i >> 5 ) * ( 1.0 / 65535.0 ) );\n}\n\nfloat DecodeId( DistanceId di )\n{\n\tint i = int( di.id );\n\treturn float( i&31 );\n}\n\nvec4 DecodeId_5_5_5( DistanceId di )\n{\n\tint i = int( di.id );\n\treturn vec4( float( i&31 )\n\t\t\t\t , float( ( i >>  5 ) & 31 ) * ( 1.0 / 31.0 )\n\t\t\t\t , float( ( i >> 10 ) & 31 ) * ( 1.0 / 31.0 )\n\t\t\t\t , float( ( i >> 15 ) & 31 ) * ( 1.0 / 31.0 ) );\n}\n\n#if 0 \n// bogus build error on ? : in shadertoy\nDistanceId opUdi( DistanceId a, DistanceId b ) { return a.d < b.d ? a : b; }\n#else\nDistanceId opUdi( DistanceId a, DistanceId b ) { if ( a.d < b.d ) return a; return b; }\n#endif\n\n// some rough scale for the roads pattern\n// you need to tweak x spacing and y spacing of path slabs\n// and the x and y scale of the main path function\n#define LANEWIDTH 0.08\n\n// 0: sin waves\n//>1: sin waves with flat sections (default)\n// 2: constant (straight lines, rectangular layout)\n// 3: smooth noise\n#define LANE_FUNC 1\n\nvec2 PathNoise11sD( float x )\n{\n\tx -= 0.5;\n\tfloat fr = fract( x );\n\tint x0 = int( x - fr );\n\tuint i = uint( x0 );\n\tfloat y0 = hash11u_lowbias32( i );\n\tfloat y1 = hash11u_lowbias32( i + 1u );\n\tfloat f = smoothstep_unchecked( fr );\n\tfloat fd = smoothstep_unchecked_d( fr );\n\treturn vec2( mix( y0, y1, f ), ( y1 - y0 ) * fd );\n}\n\n// return lane's (y,y'), called a lot so make it cheap (this *does not* return world space y coord)\nvec2 wavyLaneFuncAndDerivative( float x, float lane_index )\n{\n#if LANE_FUNC==0\n\tfloat a = mix( 0.5, 1.7, ( 1.0 + cos( lane_index ) ) * 0.5 ); // per lane constant\n\treturn vec2( ( sin( a * x ) + 1.0 ) * 0.5, 0.5 * a * cos( a * x ) );\n#elif LANE_FUNC==1\n\t// sin wave with soft straight sections so it's just all curvy\n\tfloat a = mix( 0.9, 2.0, ( 1.0 + cos( lane_index ) ) * 0.5 ); // per lane constant\n\tfloat z = ( 1.0 + sin( x * a ) ) * 0.5;\n\treturn vec2( z * z, a * z * cos( a * x ) );\n#elif LANE_FUNC==2\n\treturn vec2( 0.5, 0 );\n#elif LANE_FUNC==3\n\treturn PathNoise11sD( x - lane_index * 80.0 );\n#endif\n}\n\n#define PATH_SPACING_Y 1.0\n// used by camera, don't forget to offset by lane_index (regular wavyLaneFuncAndDerivative() doesn't care!)\nvec2 wavyLaneFuncAndDerivative_WORLD( float x, float lane_index )\n{\n\treturn wavyLaneFuncAndDerivative( x, lane_index ) + vec2( lane_index * PATH_SPACING_Y, 0 );\n}\n\n// return vector to closest point in .xy, derivative there in .zw\n// use cheap when you don't care about accurate distance or closest point\nvec4 sdWavyLane( vec2 p, float lane_index, bool cheap )\n{\n\tvec4 ret;\n\tCLOSEST_POINT_TANGENT_TO_FUNCD_11_ARG_CHEAP( ret, p, wavyLaneFuncAndDerivative, lane_index, cheap )\n\treturn ret;\n}\n\nstruct SceneIn\n{\n\t// constant during trace:\n//\tvec3 o;\n\tvec3 v;\n\tvec3 v_rcp; // for cell boundaries\n\tint trace_flags; // we can skip material related calculations during the traversal and enable only on shade\n\t// varying during trace:\n\tvec3 p;\n\tfloat t0; // warp start to hmax\n\tfloat t;\n};\n\nstruct ClosestPath\n{\n\tDistanceId patch_di; // patch id and distance (which is also the distance to paths)\n\tvec2 v2closest; // vector to closest patch boundary point, in world coords\n\tfloat curve_local_param; // the curve parameter, p.x in the local curve distance eval, so we can parametrixe space for making walls etc\n\t\t\t\t\t   // (since the path uses x and y directions we need to know which was used)\n};\n\nvec2 GetLocalCurvePoint( ClosestPath path ) { return vec2( path.curve_local_param, length( path.v2closest ) ); }\n\n// spacing must be >= 1 for the band to work\nClosestPath EvalClosestPathSlab( vec2 p, float spacing, bool cheap )\n{\n\tfloat id1 = floor( p.y / spacing );\n\tp.y = p.y - id1 * spacing;\n\tvec4 c1 = sdWavyLane( p, id1, cheap ); // should return in 0,spacing\n\tfloat d1 = cheap ? abs( c1.y ) : length( c1.xy );\n\tfloat s1 = sign( c1.y ); // this tells us if are above or below the curve (which adjacent curve to eval)\n\n\tfloat id2 = id1 - s1; // find the other 1d lane of the slab we are in: next or prev\n\tvec4 c2 = sdWavyLane( p + vec2( 0, s1 * spacing ), id2, cheap );\n\tfloat d2 = cheap ? abs( c2.y ) : length( c2.xy );\n\tfloat s2 = sign( c2.y );\n\n\tfloat m = s2 < 0.0 ? id1 : id1 - s1;\n\n\tClosestPath eval;\n\tif ( d1 < d2 ) { eval.patch_di.d = d1; eval.v2closest = c1.xy; }\n\telse           { eval.patch_di.d = d2; eval.v2closest = c2.xy; }\n\teval.patch_di.id = m;\n\teval.curve_local_param = p.x;\n\treturn eval;\n}\n\n// the lane curve is evaluated 4 times (twice per axis)\nClosestPath EvalClosestPath( vec2 p, bool cheap )\n{\n\t// horizonal lanes\n\t// PATH_SPACING_Y must be >= 1 for the band to work\n\tClosestPath ev1 = EvalClosestPathSlab( p, PATH_SPACING_Y, cheap );\n\n\t// vertical lanes\n\t// each horizontal stab can call a different set of vertical lanes which generates complex patterns\n\tvec2 p2 = perp( p ); // 90 degrees\n\t// important: spacing2 must be >= 1 for the band to work\n\tfloat spacing2 = ( 1.0 + 4.0 * ( sin( ev1.patch_di.id * 10.0 ) + 1.0 ) * 0.5 ); // spacinf of vertical lane can differ per horizontal stab which is key to complex branching patterns\n\tClosestPath ev2 = EvalClosestPathSlab( p2, spacing2, cheap );\n\tev2.v2closest = -perp( ev2.v2closest ); // put v2closest back to world coords (-90 degrees)\n\n\tClosestPath eval = ev1;\n\teval.patch_di.id *= ev2.patch_di.id; // get a unique id for this patch\n\tif ( ev2.patch_di.d < ev1.patch_di.d )\n\t{\n\t\teval.patch_di.d = ev2.patch_di.d;\n\t\teval.v2closest = ev2.v2closest;\n\t\teval.curve_local_param = ev2.curve_local_param;\n\t}\n\treturn eval;\n}\n\n// I hope you like magic constant\n#define MAX_TERRAIN_HEIGHT 0.74\n#define TALLEST_OBJECT_HEIGHT 0.645\n\nfloat sin_bumps_array( vec2 p ) { return sin( p.x ) * sin( p.y ) + 1.0; }\n\n// this function is called a lot so pick something simple\nfloat BaseGroundHeight( vec2 p  )\n{\n\tfloat h = sin_bumps_array( p.xy * ( 0.16 * PI ) ) * 0.5;\n\treturn h * h * MAX_TERRAIN_HEIGHT; // sinbumps as is is too bumpy everywhere, we need also flatter areas, so square h\n}\n\n// image was blue point juniper... end result is noise vomit\nfloat pine_tree_cross_section( float x, vec2 rh ) { x /= rh.y; return cubicbump( x, 3.0, -0.98 ) * rh.x; }\nfloat sdRevolutionPine( vec3 p, float r, float h )\n{\n\tvec2 p2d = vec2( ( p.z ), length( p.xy ) );\n\tif ( p2d.x >= h ) return length( p2d - vec2( h, 0 ) ); // don't forget to deal with endpoints...\n\tif ( p2d.x <= 0.0 ) return length( p2d - vec2( 0, 0 ) );\n\tfloat d; // note: we could use FAST_SIGNED_DISTANCE_TO_FUNCD_11_ARG but function is relatively cheap to eval so\n\tFAST_SIGNED_DISTANCE_TO_FUNC_11_ARG( d, p2d, pine_tree_cross_section, vec2( r, h ), 1e-3 );\n\treturn d; // note: this is already signed\n}\n\nvec3 ApplyWind( vec3 pd, float aTime ) { return vec3( sin( aTime * 0.8 + pd.zx ) * 0.0003, 0 ); }\n\nfloat ddPineSurfLayer( vec3 p )\n{\n\tp *= 400.0;\n\tp.z *= 0.25;\n\tp.xy = rotate_with_angle( p.xy, p.z * 0.11 );\n\treturn ( ( tri_sin( p.x ) + tri_sin( p.y ) + tri_sin( p.z ) ) + 3. ) * ( 1. / 6. ); // normalize to 0,1\n}\n\nfloat ddPineSurf( vec3 p )\n{\n\treturn ( ddPineSurfLayer( p ) + ddPineSurfLayer( vec3( rotate_with_angle( p.xy, 0.5 ), p.z ) * 0.5 ) )\n\t\t   * ( 1. / ( 2.5 ) ); // normalize to 0,1\n}\n\nfloat sdDisplacePine( vec3 p, float d, float uheight )\n{\n\tif ( !DISPLACE_PINE ) return d;\n\tfloat dd_amp = 0.018;\n\tif ( d > dd_amp ) return d;\n\tdd_amp *= ddPineSurf( p );\n\treturn d + dd_amp;\n}\n\n#define TRACE_VIEW 1\n#define TRACE_SHADE 2\n#define TRACE_AO 4\n#define TRACE_SHADOW 16\n#define TRACE_HAS_DIRECTION 64 // note: it is faster to check flags than checking for v_rcp == 0 or whatnot (that might not been resolved to static)\n\nbool IsShadeTrace( int trace_flags ) { return ( trace_flags & TRACE_SHADE ) != 0; }\nbool IsShadowTrace( int trace_flags ) { return ( trace_flags & TRACE_SHADOW ) != 0; }\nbool HasDirection( int trace_flags ) { return ( trace_flags & TRACE_HAS_DIRECTION ) != 0; }\n\nDistanceId sdTreeLeaves( vec3 p, vec2 c, float cz, float trunk_height\n\t\t\t\t\t\t , float leaves_volume_base_radius\n\t\t\t\t\t\t , float leaves_volume_top_radius\n\t\t\t\t\t\t , int trace_flags\n\t\t\t\t\t\t , float color_rnd )\n{\n\tfloat d = FLT_MAX;\n\tvec3 c0 = vec3( c, cz + trunk_height * 0.7 );\n\tvec3 c1 = vec3( c, cz + trunk_height );\n\tfloat d0 = length( p - c0 ) - leaves_volume_base_radius;\n\tfloat d1 = length( p - c1 ) - leaves_volume_top_radius;\n\t// soft blend between 2 sphere for the base leaves volumes\n\tfloat k = leaves_volume_base_radius * 0.4;\n\td = opU_soft2_pol( d0, d1, k );\n//\treturn MkDistanceId( d, MATID_TREE );\n\n#define TREE_SDD 0.02 // upper bound for  amplitude of fine displacement on pines and trees\n\n\tfloat dd1 = 0.007;\n\tif ( d > dd1 + TREE_SDD ) return MkDistanceId( d, MATID_TREE ); // massive saving. only consider envelope displacement when we are close\n\n\tfloat d_envelope = d;\n\tbool blend = _1;\n\tfloat depth = 0.0;\n\tfloat uheight = 0.0;\n\t\n\tif ( _1 )\n\t{\n\t\t// make the leaves volume more bubbly by using 2 layers of *packed* 3d spheres regular tiling (non packed doesn't work well)\n\t\t// see @Shane's cellular tiling shaders/comments\n\n\t\tmat3 m3 =\n\t\t\tmat3_rotation_x( unit_vector2( radians( c.x * 200. ) ) ) *\n\t\t\tmat3_rotation_z( unit_vector2( radians( c.y * 200. ) ) );\n\n\t\tfloat dl1;\n\n\t\t{\n\t\t\tfloat c1 = leaves_volume_base_radius * 0.3;\n\t\t\tfloat da1 = packed_spheres_tiling3d( p * m3, c1, c1 * 2.5 ); // more spacing gives more clustering/bumpiness\n\t\t\tda1 += smoothstep( cz + trunk_height * 0.75, cz + trunk_height, p.z ) * 0.007;\n\t\t\tdl1 = blend\n\t\t\t\t? opI_weld_quadric( d_envelope, da1, leaves_volume_base_radius * 0.3 )\n\t\t\t\t: opI( d_envelope, da1 );\n\t\t}\n\n\t\tfloat dl2;\n\n\t\t{\n\t\t\t// note: the second packed_spheres_tiling3d could just be global and evaluated 1 for the 3 trees\n\t\t\tfloat c1 = leaves_volume_base_radius * 0.4;\n\t\t\tfloat da1 = packed_spheres_tiling3d( m3 * p, c1, c1 * 2.5 );\n\t\t\tdl2 = blend\n\t\t\t\t? opI_weld_quadric( d_envelope, da1, leaves_volume_base_radius * 0.25 )\n\t\t\t\t: opI( d_envelope, da1 );\n\t\t}\n\n\t\tfloat d_leaf_clusters = blend\n\t\t\t? opU_weld_quadric( dl1, dl2, leaves_volume_base_radius * 0.1 )\n\t\t\t: opU( dl1, dl2 );\n\n\t\td = blend\n\t\t\t? opU_weld_quadric( d_leaf_clusters, d_envelope + 0.02, leaves_volume_base_radius * 0.19 )\n\t\t\t: d_leaf_clusters;\n\n\t\tdepth = saturate( 1.0 / ( 1. + abs( d - d_envelope ) * 100. ) );\n\t\t\n\t\tfloat b = c0.z - leaves_volume_base_radius; // bottom most-ish\n\t\tfloat t = c1.z + leaves_volume_top_radius; // topmost-ish\n\t\tuheight = saturate( ( p.z - b )/( t - b ) ); // a 0-1 normalized height value for shading\n\t}\n\n\tif ( _1 )\n\t{\n\t\t// clip leaves volume's bottom with a wavy surface so it's not spherical things everywhere\n\t\tfloat clipsurf = ( ( c0.z - leaves_volume_base_radius * .6 )\n\t\t\t\t\t\t   + leaves_volume_base_radius * 0.1\n\t\t\t\t\t\t   * ( sin_bumps_array( p.xy * ( 13.0 * PI ) ) - 2.4 ) );\n\n\t\td = blend\n\t\t\t? opI_weld_quadric( d, -( p.z - clipsurf ), leaves_volume_base_radius * 0.15 )\n\t\t\t: opI( d, -( p.z - clipsurf ) );\n\t}\n\n\treturn MkDistanceId_5_5_5( d, MATID_TREE, saturate( vec3( depth, uheight, color_rnd ) ) );\n}\n\n// retrieve terrain height, using full eval or taylor expansion\nfloat CalcHeight( vec2 c, vec2 p, vec3 h_gradval, bool taylor_expansion_height )\n{\n\treturn taylor_expansion_height\n\t\t   ? h_gradval.z + dot( h_gradval.xy, c - p ) // h(p)=h(c)+(c-h).grad(c): taylor expansion to skip height evaluations \n\t\t   : BaseGroundHeight( c );\n}\n\nDistanceId sdGridObj_TreeOrPine( DistanceId di\n\t\t\t\t\t\t\t\t , vec3 p\n\t\t\t\t\t\t\t\t , CellPoint cr\n\t\t\t\t\t\t\t\t , float radius_fraction\n\t\t\t\t\t\t\t\t , float patch_id\n\t\t\t\t\t\t\t\t , inout vec3 color\n\t\t\t\t\t\t\t\t , SceneIn scenein\n\t\t\t\t\t\t\t\t , vec3 h_gradval, bool taylor_expansion_height )\n{\n\tvec2 c = cr.p;\n\tfloat r = radius_fraction * cr.pradius;\n\tfloat cz = CalcHeight( cr.p, p.xy, h_gradval, taylor_expansion_height );\n\n\tif ( _0 && ( ( length( p - vec3( c, cz ) ) - cr.pradius ) > di.d ) ) return di; // CULL\n#if 0\n\t// doesn't save enough vs extra test cost\n\tif ( HasDirection( scenein.trace_flags ) )\n\t{\n\t\tvec2 n = perp( scenein.v.xy );\n\t\tvec2 o = scenein.o.xy;\n\t\tvec2 pp = project_on_plane( c, o, n );\n\t\tif ( lensqr( p.xy - pp ) > r * r ) return di;\n\t}\n#endif\n\tvec4 hhh = hash42_( cr._pi * 123 );\n\tvec3 tree_base_point = vec3( c, cz );\n\n\tfloat pine_dice_roll = hhh.x;\n\tfloat pine_probability = 0.7;\n\t\n\tif ( _1 && ( pine_dice_roll > pine_probability) )\n\t{\n\t\tfloat pine_radius_scale = mix( 0.65, 0.75, hhh.w ) * r;\n\t\tfloat pine_height = mix( 0.42, 0.56, hhh.z * hhh.z );\n\t\tfloat uheight = saturate( ( p.z - cz ) / pine_height );\n\t\tDistanceId pine_tree = MkDistanceId_5_5_5( \n\t\t\tsdDisplacePine( p - tree_base_point\n\t\t\t\t\t\t\t, sdRevolutionPine( p - tree_base_point, pine_radius_scale, pine_height ), uheight )\n\t\t\t, MATID_PINE, vec3( 0.0, uheight, ( ( hhh.x - pine_probability ) * ( 1.0 / ( 1.0 - pine_probability ) ) ) ) );\n\t\treturn opUdi( di, pine_tree );\n\t}\n\n\thhh.x *= 1.0/pine_probability; // back into [0,1]\n\tfloat aa = mix( 0.018, 0.012, hhh.y ); // trunk\n\tfloat trunk_height = aa * ( 1.1 * 1.0 / 0.018 ) * mix( 0.2, 0.35, hhh.z * hhh.z );\n\tfloat trunk_radius = aa * 0.8;\n\tfloat leaves_volume_top_radius = mix( 0.5, 0.7, hhh.w ) * r;\n\tfloat leaves_volume_base_radius = mix( 1.1, 1.35, hhh.y ) * leaves_volume_top_radius;\n\tDistanceId leaves = sdTreeLeaves( p, c, cz, trunk_height, leaves_volume_base_radius, leaves_volume_top_radius, scenein.trace_flags, hhh.x );\n\tfloat trunk_uheight = saturate( ( p.z - cz ) / trunk_height );\n\ttrunk_radius *= mix(0.8,1.2,pow2(1.0-saturate(trunk_uheight*3.5)));\n\tDistanceId trunk = MkDistanceId( sdCylinder( p - tree_base_point, vec2( trunk_radius, trunk_height ) ), MATID_TRUNK );\n\tif ( trunk.d < 0. ) leaves = trunk; // horrible hack to force trunk to be trunk inside leaves, as the leaves sdf has been hacked to death and union doesn't quite work anymore\n\treturn opUdi( di, opUdi( trunk, leaves  ) );\n}\n\n// function used to make roof tiles\n// a1 is the slope of curve going up (1.)\n// a2 is the slope of curve going down (-2.)\n// p is the period\nfloat hard_waves( float x, float a1, float a2, float p ) { x = repeat( x, p ); return min( a1 * x, a2 * ( x - p ) ); }\n// roof tiles height field (hf)\nfloat hf_SurfaceRoofTiles( vec2 p ) { return 0.1 * hard_waves( p.y, 0.3, -1.1, 0.024 ) + 0.001 * ( 1.0 - pow2( 1.0 - abs( sin( p.x * 200. ) ) ) ); }\n\nstruct WindowOrDoorArg\n{\n\tvec2 c; // cellsize\n\tvec2 g; // num cells\n\tfloat frame_width, border_height, border_depth, glass_depth, frame_depth;\n};\n\nvoid sdOneWindow( vec3 p, inout DistanceId eval, WindowOrDoorArg args )\n{\n\tfloat d_in = eval.d;\n\tvec2 c = args.c;\n\tvec2 g = args.g - vec2( 1 );\n\tp.x += ( args.g.x * 0.5 - 0.5 ) * c.x; // center on x...\n\tvec2 pmin = -c.xy * 0.5;\n\tvec2 pmax = c.xy * ( vec2( 0.5 ) + g );\n\t// window glass and frame\n\tvec3 pr = p;\n\tvec2 i = floor( ( pr.xy - ( -c * 0.5 ) ) / c ); // c the cell size\n\ti = clamp( i, vec2( 0, 0 ), g );\n\tpr.xy -= i * c;\n\tfloat d_glass = sd_bounds_half_size( pr, vec3( c * 0.5 - vec2( args.frame_width ) * 0.5, args.glass_depth ) );\n\teval.d = opS( eval.d, d_glass );\n\t// window general frame\n\tfloat d_frame = sd_bounds_range( p, vec3( pmin, -args.frame_depth ), vec3( pmax, args.frame_depth ) );\n\teval.d = opS( eval.d, d_frame ); // make the whole window sink a bit\n\t// window border\n\tif ( _1 ) eval.d = opI( d_in - args.border_depth // clamp vs inflated version of source block we are decorating\n\t\t\t\t\t\t\t, opU( eval.d\n\t\t\t\t\t\t\t\t   , sd_bounds_range( p\n\t\t\t\t\t\t\t\t\t\t\t\t\t  , vec3( pmin.x, pmin.y - args.border_height, 0 )\n\t\t\t\t\t\t\t\t\t\t\t\t\t  , vec3( pmax.x, pmin.y, args.border_depth ) ) ) );\n\tif ( -d_glass == eval.d ) eval.id = MATID_WINDOW; // we used opS so we need -d_glass\n}\n\nvoid addWindow( inout DistanceId eval, vec3 p, float is_chimney_face, float half_wall_width )\n{\n\tp.y += 0.016; // adjust windows height\n\tvec2 c = vec2( 0.07*mix(1.8,1.0,is_chimney_face), 0.07 ); // tile size\n\tvec2 window_size = vec2( 0.018, 0.02 ); // size of the object inside each tile, must be smaller than c\n\tfloat d_glass = FLT_MAX;\n\tvec2 i = floor( ( p.xy - ( -c.xy * 0.5 ) ) / c.xy ); // c the cell size\n\tfloat maxnum_cells = floor( (half_wall_width / c.x) - 0.5 ); // max num window that fit on this wall, assume p.x centered\n\tivec2 imin = ivec2( -maxnum_cells, 1 );\n\tivec2 imax = ivec2(  maxnum_cells, 1 );\n\ti = clamp( i, vec2(imin), vec2(imax) );\n\tp.xy -= i * c;\n\tWindowOrDoorArg args;\n\targs.c = window_size; // cellsize\n\targs.g = mix( vec2( 2, 2 ), vec2( 2, 2 ), is_chimney_face ); // window glass grid size\n\tfloat scl = 0.012;\n\targs.frame_width = 0.05 * scl;\n\targs.border_height = 0.3 * scl;\n\targs.border_depth = 0.2 * scl; // can't be bigger than d_house_bottom_inset\n\targs.glass_depth = 0.3 * scl;\n\targs.frame_depth = 0.1 * scl;\n\tsdOneWindow( p, eval, args );\n}\n\n// convert point p to y=0 face local point, a is a plane base3d/origin2d point\nvec3 p2yface( vec3 p, vec2 orig ) { p.y = abs( p.y ); p.xy -= orig; p.xzy = p.xyz; p.x = -p.x; return p; }\n// convert point p to y=0 face local point, a is a plane base3d/origin2d point\nvec3 p2xface( vec3 p, vec2 orig ) { p.x = abs( p.x ); p.xy -= orig; return p.yzx; }\n\n// note: tracing detail doesn't always work very well on heightfields so z proj/triplanar type of mapping isn't great for roof\n// instead we do more tedious evals, building roof local points + 3d detail on that etc\nDistanceId sdFarm( vec3 p, CellPoint cr,float patch_id,float r, float detail )\n{\n\tvec4 hh = hash42_( cr._pi);\n\tbool has_chimney = hh.y > 0.4;\n\tbool _x2chimney = _1;\n\tvec2 hs1 = vec2( 0.25, 0.083 );\n\tvec2 hs2 = vec2( 0.083, 0.18+hh.z*0.02 );\n\tfloat h = 0.0996;\n\tfloat bottom_block_inset = 0.00498;\n\tfloat bottom_block_inset2 = bottom_block_inset*(has_chimney?0.0:1.0);\n\tfloat roof_thickness = 0.00166;\n\tfloat chimney_side_len = 0.018+hh.z*0.002; // chimney side length\n\tfloat chimney_height = h + hs1.y + chimney_side_len;\n\tfloat chimney_bottom = h + hs1.y - 0.04;\n\tfloat roof_tile_scl = 2.5; \n\tfloat roof_tile_scl2 = 1.1; \n\tbool half_hipped = hh.z>0.5;\n\tfloat bottom_inflate = 0.001;\n\tvec2 hs1_in = hs1 - vec2( bottom_block_inset2, bottom_block_inset );\n\tvec2 hs2_in = hs2 - vec2( bottom_block_inset );\n\t// symmetric window plane\n\tfloat block1_chimney_wall_plane_x = hs1_in.x;\n\tfloat block1_wall_plane_y = hs1_in.y;\n\tfloat block2_wall_plane_y = hs2_in.y;\n\tvec3 ps = p; // store signed p\n\tvec3 pay = p; pay.y = abs( pay.y ); // symmetric around y\n\tvec3 pax = p; pax.x = abs( pax.x ); // symmetric around x\n\tfloat d_block1_bottom = FLT_MAX;\n\tfloat d_block1_roof = FLT_MAX;\n\tfloat d_block1_bottom2 = FLT_MAX;\n\t{\n\t\t// --- gable roof, 2 planes (v-shaped)\n\t\tbounds2 block1 = mkbounds_unchecked( -hs1, hs1 );\n\t\tfloat d_block1_footprint = sd_bounds_range( p.xy, block1.pmin.xy, block1.pmax.xy );\n\t\tvec3 roof1_top_point = vec3( hs1.x, 0, h + hs1.y );\n\t\t// p.yz is the gable roof cross section space point\n\t\tvec3 roof_plane_local_p = vec3( -dot( pay.yz - roof1_top_point.yz, perp( V45 ) ), p.x, dot( pay.yz - roof1_top_point.yz, V45 ) );\n\t\td_block1_bottom = opI( roof_plane_local_p.z, d_block1_footprint );\n\t\td_block1_bottom = opI( d_block1_bottom, pay.y -hs1_in.y );\n\t\td_block1_bottom = opI( d_block1_bottom, pax.x - block1_chimney_wall_plane_x );\n\t\td_block1_bottom = opI( d_block1_bottom, roof_plane_local_p.z + 0.002 );\n\t\t// add tile detail to gabble roof, hacky mess to be sorted\n\t\td_block1_roof = roof_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof_plane_local_p.yx * roof_tile_scl )* roof_tile_scl2;\n\t\td_block1_roof = opS( d_block1_roof, roof_plane_local_p.z + 0.002 );\n\t\td_block1_roof = opI( d_block1_roof, d_block1_footprint );\n\t\td_block1_bottom2 = opI(d_block1_footprint-bottom_inflate,p.z);\n\t}\n\tfloat d_chimney = FLT_MAX;\n\tif ( has_chimney )\n\t{\n\t\tvec2 chimney_c = vec2( hs1_in.x, 0 );\n\t\tbounds2 chimney_footprint_b = mkbounds_unchecked( chimney_c - vec2( chimney_side_len ), chimney_c + vec2( 0, chimney_side_len * 0.5 ) );\n\t\tfloat d_chimney_footprint = sd_bounds_range( _x2chimney ? abs( p.xy ) : p.xy, chimney_footprint_b.pmin.xy, chimney_footprint_b.pmax.xy );\n\t\td_chimney = opI( chimney_bottom - p.z, opI( d_chimney_footprint, p.z -chimney_height ) );\n\t\tfloat d_chimney_hole = opI( chimney_bottom - p.z, opI( d_chimney_footprint, p.z - chimney_height * 1.5 ) ) + 0.002;\n\t\td_chimney = opS( d_chimney, d_chimney_hole );\n\t}\n\tfloat d_block2_roof = FLT_MAX;\n\tfloat d_block2_bottom = FLT_MAX;\n\tfloat d_block2_bottom2 = FLT_MAX;\n\tif ( hh.x > 0.4 )\n\t{\n\t\t// --- hipped roof\n\t\tbounds2 block2 = mkbounds_unchecked( -hs2, hs2 );\n\t\tfloat d_block2_footprint = sd_bounds_range( p.xy, block2.pmin.xy, block2.pmax.xy );\n\t\t//return d_block1_roof;\n\t\td_block2_bottom = opI( d_block2_footprint + bottom_block_inset, ( p.z - h ) ); // block2 is inset equally on x and y \n\t\td_block2_bottom2 = opI(d_block2_footprint-bottom_inflate,p.z);\n\t\t\n\t\t//return d_block2_bottom;\n\t\tvec3 roof2_corner_point = vec3( hs2, h );\n\t\tvec3 roof2a_plane_local_p = vec3( p.y, -dot( pax.xz - roof2_corner_point.xz, perp( V45 ) ),dot( pax.xz - roof2_corner_point.xz, V45 ) );\n\t\tfloat roof2detail_a = roof2a_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof2a_plane_local_p.xy * roof_tile_scl ) * roof_tile_scl2;\n\t\t// like the s1 one, exactly. just offset, can we factorize?\n\t\tvec3 roof2b_plane_local_p = vec3( p.x, -dot( pay.yz - roof2_corner_point.yz, perp( V45 ) ),dot( pay.yz - roof2_corner_point.yz, V45 ) );\n\t\tfloat roof2detail_b = roof2b_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof2b_plane_local_p.xy * roof_tile_scl ) * roof_tile_scl2;\n\t\td_block2_roof = opI( roof2b_plane_local_p.z, roof2a_plane_local_p.z );\n\t\td_block2_roof = opI( roof2detail_a, roof2detail_b );\n\n\t\tif ( half_hipped )\n\t\t{\n\t\t\td_block2_roof = opI( d_block2_roof, p.y );\n\t\t\td_block2_bottom = opI( d_block2_bottom, p.y );\n\t\t\td_block2_bottom2 = opI( d_block2_bottom2, p.y );\n\t\t}\n\t}\n\tDistanceId bb1 = MkDistanceId( d_block1_bottom, MATID_HOUSE );\n\tDistanceId bb2 = MkDistanceId( d_block2_bottom, MATID_HOUSE );\n\tif ( FARM_WINDOWS )\n\t{\n\t\taddWindow( bb1, p2xface( p, vec2( hs1_in.x, 0.0 ) ), 1., hs1_in.y );\n\t\taddWindow( bb1, p2yface( p, vec2( 0, hs1_in.y ) ), 0., hs1_in.x );\n\t\taddWindow( bb2, p2yface( p, vec2( 0, hs2_in.y ) ), 0., hs2_in.x );\n\t}\n\tDistanceId roof_eval = MkDistanceId( opI( h - p.z, opU( d_block1_roof, d_block2_roof ) ), MATID_ROOF );\n\tDistanceId bottom_eval = MkDistanceId( d_chimney, MATID_HOUSE );\n\tbottom_eval = opUdi( bottom_eval, bb1 );\n\tbottom_eval = opUdi( bottom_eval, bb2 );\n\tDistanceId bottom2_eval = MkDistanceId( opU( d_block1_bottom2, d_block2_bottom2 ), MATID_HOUSE_BOTTOM );\n\treturn opUdi( opUdi( roof_eval, bottom_eval ), bottom2_eval );\n}\n\nDistanceId sdGridObj_Farm( DistanceId di\n\t\t\t\t\t\t   , vec3 p\n\t\t\t\t\t\t   , CellPoint cr\n\t\t\t\t\t\t   , float radius_fraction\n\t\t\t\t\t\t   , float patch_id\n\t\t\t\t\t\t   , inout vec3 color\n\t\t\t\t\t\t   , SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval, bool taylor_expansion_height )\n{\n\tvec2 c = cr.p;\n\tfloat r = radius_fraction * cr.pradius;\n\tfloat cz = CalcHeight( cr.p, p.xy, h_gradval, taylor_expansion_height );\n\t\n\tif ( _0 && ( ( length( p - vec3( c, cz ) ) - cr.pradius ) > di.d ) ) return di; // CULL\n#if 0\n\tif ( HasDirection( scenein.trace_flags ) \n\t\t && ( sphere_trace( mkray( scenein.p, scenein.v ), r, vec3( c, cz ) ).x == FLT_MAX ) )\n\t{\n\t\treturn di;\n\t}\n#endif\n\t// orient farm along terrain gradient to reduce sinking cases\n\tvec2 e = vec2( 1e-3, 0 );\n\tvec2 h_gradval_at_c = ( vec2( BaseGroundHeight( c.xy + e.xy ),\n\t\t\t\t\t\t\t\t  BaseGroundHeight( c.xy + e.yx ) ) - vec2( cz ) ) / e.x; // be careful to not divide by e since it has zero in .y\n\t\n\tfloat grad_len = length( h_gradval_at_c );\n\n\t#define FARMS_GRAD_LIMIT   _1 // don't place farms when slope is too strong\n\t#define FARMS_GRAD_ELEVATE _1 // elevate house so they don't sink into the ground, using the gradient\n\t#define FARMS_GRAD_ALIGN   _1 // align farm with terrain gradient instead of random rotation\n\n\tif ( FARMS_GRAD_LIMIT && ( grad_len > 0.17 ) ) return di;\n\tif ( FARMS_GRAD_ELEVATE ) cz += r * grad_len * 0.65;\n\n\t// move to local coords\n\tp.xy -= c;\n\tp.z -= cz;\n\t\n\tp.xy = rotate_with_unit_vector( p.xy, FARMS_GRAD_ALIGN && ( grad_len > 0.01 )\n\t\t\t\t\t\t\t\t\t? normalize( h_gradval_at_c ) \n\t\t\t\t\t\t\t\t\t: unit_vector2( hash1u2_4tXyWN( uvec2(cr._pi) ) * 2.0 * PI ) ); // random rotation\n\n\tif ( _0 ) return MkDistanceId( sd_sphere( p, vec3( 0 ), r ), MATID_HOUSE ); // try make the building fit inside the sphere\n\n\tDistanceId eval = sdFarm( p, cr,patch_id, r, 1.0 );\n\t\n\tif ( IsShadeTrace( scenein.trace_flags ) && ( DecodeId( eval ) == MATID_ROOF ) )\n\t{\n\t\teval = MkDistanceId_16( eval.d, MATID_ROOF, hash11( patch_id ) ); // same roof color for all houses in patch\n\t}\n\n\treturn eval;\n}\n\nfloat sdBrickWall( vec3 p, ClosestPath path, float h )\n{\n\tfloat wall_start_dist = LANEWIDTH * 0.5 + 0.005;\n\tfloat wall_thickness = 0.018;\n\tfloat wall_height = 0.05;\n\tfloat wall_radius = 0.008;\n\tfloat d = FLT_MAX;\n\tfor ( float k = 0.0; k < 2.0; k += 1.0 )\n\t{\n\t\tvec3 pl = p; // p local\n\t\tpl.xy = GetLocalCurvePoint( path );\n\t\tpl.y -= wall_start_dist + wall_thickness * 0.5;\n\t\tpl.z -= h;\n\t\tvec3 s = vec3( 0.01, 0.006, 0.006 );\n\t\tfloat spacing = 0.0015;\n\t\tvec3 c;\n\t\tc.xz = vec2( s.x + spacing, 2.0 * s.z + spacing );\n\t\tc.y = s.y + spacing;\n\t\tvec2 offset = -0.5 * c.xz;\n\t\tfloat o = 0.5 * k;\n\t\toffset.xy += o * c.xz;\n\t\tvec2 i;\n\t\ti = floor( ( pl.xz - offset ) / c.xz );\n\t\ti.y = min( i.y, 2.0 );\n\t\tpl.xz -= i * c.xz;\n\t\tpl.xz -= o * c.xz;\n\t\tfloat r = 0.002;\n\t\td = opU( d, sd_bounds_range_round( pl, -s * 0.5, s * 0.5, r ) );\n\t}\n\tif ( _1 ) d -= 0.003 * sfbm2_13( p * 80.0 );\n\treturn d;\n}\n\nfloat sdGrass( vec3 p, float h ) { return p.z - h; }\n\n// scene eval output\nstruct SceneOut\n{\n\tDistanceId object_di;\n\tfloat d_ghost; // can we optimize that and have less of those?\n\tfloat base_height; // base ground height\n\tClosestPath path;\n\tClosestPath test2d; // for 2d view mode\n\tvec3 color; // special color case for bushes (when id_fraction is not enough)\n#ifdef TERRAIN_WARP\n\t// this cuts bush evals massively\n\tfloat terrain_warp; // todo: move out of this struct, this is not part of returned information\n#endif\n};\n\nvoid SceneOutInit( inout SceneOut eval ) { eval.d_ghost = FLT_MAX; }\n\nvec3 get_bush_palette( vec2 uv )\n{\n\treturn mix( mix( mix( COLOR_BUSH1, COLOR_BUSH2, uv.x ), mix( COLOR_BUSH3, COLOR_BUSH4, uv.x ), uv.y )\n\t\t\t\t, COLOR_BUSH5, smoothband( uv.x, 0.49, 0.51, 0.01 ) );\n}\n\nbool is_white_cell( vec2 p_index ) { return ( int( p_index.x + p_index.y ) & 1 ) == 1; }\n\nvoid consider_close_point_hi( inout float d, vec2 index, float r, inout vec4 color, vec3 p, float cellsize\n\t\t\t\t\t\t\t  , vec3 h_gradval, bool taylor_expansion_height, int trace_flags )\n{\n\tvec3 c;\n\tvec3 h = hash32( index );\n\tc.xy = ( index + h.xy ) * cellsize;\n\tc.z = CalcHeight( c.xy, p.xy, h_gradval, taylor_expansion_height ) + r * mix( -0.8, 1.3, h.z );\n\tfloat di = length( c - p ) - r;\n\td = min( d, di );\n\n\tif ( IsShadeTrace( trace_flags ) )\n\t{\n\t\tvec2 ch = hash22( index );\n\t\t// this is called only once in shade, knock yourself out\n\t\tfloat w = max( 1. - smoothstep( -r * 0.1, r * 0.25, di ), 1e-3 );\n\t\tcolor.xyz += get_bush_palette( ch ) * w;\n\t\tcolor.a += w;\n\t}\n}\n\nstruct CloseGridPointArgs { float cell_size, max_radius, radius_disparity; };\n\nstruct CloseGridPointArgsWithBand\n{\n\tCloseGridPointArgs args0;\n\tfloat band_start, band_end;\n\tbool taylor_expansion_height;\n};\n\n// 45 means we consider 4 or 5 neighbour (instead of 3x3) depending on whether we are on a white or a black cell (not perfect but covers lots of cases)\n// instead of giving the closest point this version does a little bit of extra calculation or each candidate for color blending on bushes\nfloat GetCloseGridPoints45( inout vec3 a_color, vec3 p, float cellsize, vec3 h_gradval, CloseGridPointArgsWithBand args, int trace_flags, int aFrame )\n{\n\tfloat r = args.args0.max_radius * 0.8;\n\tvec2 p_index = floor( p.xy * ( 1.0 / cellsize ) );\n\n\tfloat d = FLT_MAX;\n\tvec4 color = vec4( 0.0 );\n#if 0\n\t// the unrolled code path is faster on my current view (70ms->68ms) but shader compilation prefers the loop (-1s)\n\tif ( is_white_cell( p_index ) )\n\t{\n\t\t//white cell\n\t\tconsider_close_point_hi( d, p_index + vec2( -1,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t}\n\telse\n\t{\n\t\t//black cell\n\t\tconsider_close_point_hi( d, p_index + vec2( -1,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2( -1, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t}\n#else\n\tvec2 offset = vec2( 0, 1 ); // white cells check 4 canonical axis neigbours\n\tif ( !is_white_cell( p_index ) )\n\t{\n\t\tconsider_close_point_hi( d, p_index, r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags ); // this cell, only checked if black\n\t\toffset = vec2( 1, 1 ); // black cells check the 4 diagonal neighbours\n\t}\n\n\tfor ( int i = 0 FORCE_LOOP; i < 4; ++i )\n\t{\n\t\tconsider_close_point_hi( d, p_index + offset, r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\toffset = perp( -offset ); // go to next neighbour by rotating +90\n\t}\n#endif\n\tif ( IsShadeTrace( trace_flags ) ) // skipping this test breaks the trees...\n\t\ta_color = color.xyz / color.a;\n\n\treturn d;\n}\n\n#define bush_max_radius 0.04\n// for bushes we do something symbolic looking, with a slight Hiroshi Nagai vibe \nvoid AddContributionBushes( inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t\t, vec3 h_gradval, float groundz, vec3 patch_id_hash\n\t\t\t\t\t\t\t, bool is_forest_patch, float aTime, int aFrame )\n{\n\tvec3 p = scenein.p;\n\tbool has_bushes = patch_id_hash.x > 0.2;\n\tbool has_cut_bushes = SQUARE_BUSH_TEST && ( !is_forest_patch && patch_id_hash.x > 0.62 );\n\n\tfloat bush_cell_size = 0.095;\n\n\tfloat bush_d_min = p.z - ( groundz + bush_max_radius*1.9 ); // upper bound for distance to bushes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  // multiply by 2 else lots of bushes get cut... \n\n\t// note: whether we use > or <= has resulted in big difference in the past sometimes\n\tif ( !has_bushes\n\t\t || ( bush_d_min > eval.object_di.d )\n#ifdef TERRAIN_WARP\n\t\t || (\n\t\t\t  ( eval.terrain_warp != 0.0 ) &&\n\t\t\t  ( bush_d_min > 0.0 ) &&\n\t\t\t  ( bush_d_min < eval.terrain_warp ) ) // we know we can roughly traverse by eval.terrain_warp before hitting next bush\n#endif\n\t\t) return;\n\n\tfloat d = FLT_MAX;\n\tfloat id_fraction = 0.0;\n\tfloat freq = 1.0;\n\n\tif ( has_cut_bushes )\n\t{\n\t\tfreq = DISPLACE_BUSH_FREQ;\n\t\t\n\t\t// patch section 2d point\n\t\tvec2 p_patch_section = vec2( eval.path.patch_di.d, p.z - eval.base_height );\n\t\tfloat d_square_bush = sd_bounds_range( p_patch_section, vec2( LANEWIDTH - 0.015, 0 ), vec2( LANEWIDTH + 0.02, 0.05 ) );\n\t\td = d_square_bush; // we distort so...\n\n\t\teval.color = COLOR_BUSH3;\n\t}\n\telse\n\t{\n\t\tfreq = DISPLACE_BUSH_FREQ;\n\n\t\t// this is a patch with bushes on the side\n\t\tCloseGridPointArgsWithBand args;\n\t\targs.args0.cell_size = bush_cell_size;\n\t\targs.args0.max_radius = bush_max_radius;\n\t\targs.args0.radius_disparity = 0.4;\n\t\targs.band_start = LANEWIDTH * 0.5 + args.args0.max_radius * 0.5; // take a fraction of the radius so that some of the bushes overlap a bit with the path\n\t\targs.band_end = args.band_start + 0.18 + pow2( patch_id_hash.z ) * 0.3;\n\t\targs.taylor_expansion_height = TAYLOR_HEIGHT_BUSH;\n\n\t\td = GetCloseGridPoints45( eval.color, p, args.args0.cell_size * 0.5, h_gradval, args, scenein.trace_flags, aFrame );\n\n\t\tif ( SOFT_BLEND_BUSH ) d = opU_weld_quadric( p.z - eval.base_height, d, 0.027 );\n\n\t\t// clip bush vs path/walls (leak through walls is a happy accident)\n\t\tif ( _1 ) d = opS_soft2( d, abs( eval.path.patch_di.d ) - LANEWIDTH * 0.5, 100.0 );\n\n\t\tif ( _1 )\n\t\t{\n\t\t\t// fade bush inside patch\n\t\t\tfloat bf = ( sfbm1_12( p.xy * 18.0 ) - 0.5 ) * 0.33; // distort fade boundary\n\t\t\td = opS_soft2( d, args.band_end * ( 1. + bf ) - eval.path.patch_di.d, 30.0 );\n\t\t}\n\t}\n\n\tif ( DISPLACE_BUSH )\n\t{\n\t\tfloat dd = 0.0045; // need more displacement to see shadows...\n\n\t\tvec3 pd = p;\n\t\tif ( WIND_BUSH ) pd += ApplyWind( pd, aTime );\n\t\t\n\t\t // the test is < ..*3 because we INFLATE\n\t\tif ( d < dd * 3.0 ) d -= sfbm2_13( pd * vec3( 80.0, 80.0, 100 ) * freq ) * dd;\n\t}\n\n\teval.object_di = opUdi( eval.object_di, MkDistanceId_16( d, MATID_BUSH, id_fraction ) );\n}\n\n// return closest cell point with a radius, no neighbour, used by farms and trees\n// max_radius must be less than cell_size*0.5\n// radius_disparity percentage in 0,1\n// grid_offset in 0,1, conceptually...\nvoid GetClosestGridPoint( inout CellPoint point, vec2 p, CloseGridPointArgs args0, float grid_offset, float hoffset )\n{\n\tvec2 pi = floor( ( p - grid_offset ) / args0.cell_size );\n\tpoint._pi = ivec2( pi + vec2( hoffset ) );\n\tvec4 ph = hash42_( point._pi );\n//\tph.xy = vec2( 0.5 ); // debug\n\tpoint.pradius = args0.max_radius * ( 1.0 - args0.radius_disparity * ph.z );\n\tvec2 a = grid_offset + pi * args0.cell_size;\n\tvec2 b = a + vec2( args0.cell_size );\n\tpoint.p = mix( a + vec2( point.pradius ),\n\t\t\t\t   b - vec2( point.pradius ), ph.xy ); // important: +offset to put back in same space as p\n}\n\n// used by farms and trees\nbool GetClosestGridPointWithPathBand_x1( inout CellPoint point\n\t\t\t\t\t\t\t\t\t\t , vec2 p\n\t\t\t\t\t\t\t\t\t\t , vec3 h_gradval\n\t\t\t\t\t\t\t\t\t\t , CloseGridPointArgsWithBand args\n\t\t\t\t\t\t\t\t\t\t , float grid_offset, float hoffset )\n{\n\tGetClosestGridPoint( point, p, args.args0, grid_offset, hoffset );\n\n\t// we want to know if this point is within a band of the country patch we are currently in\n\tfloat distance_to_patch_border = abs( EvalClosestPath( point.p, true ).patch_di.d );\n\treturn ( distance_to_patch_border > args.band_start )\n\t\t&& ( distance_to_patch_border < args.band_end );\n}\n\nvoid SetSceneInDirection( inout SceneIn scenein, vec3 o, vec3 v, int trace_flags )\n{\n\tscenein.v = v;\n\tscenein.v_rcp = vec3( 1.0 ) / v;\n//\tscenein.o = o;\n\tscenein.trace_flags = trace_flags | TRACE_HAS_DIRECTION;\n\tscenein.t0 = 0.0;\n}\n\nvoid SetSceneInDirectionless( inout SceneIn scenein, int trace_flags )\n{\n\tscenein.v = vec3( 0.0 );\n\tscenein.v_rcp = vec3( 0.0 );\n//\tscenein.o = vec3( 0.0 );\n\tscenein.trace_flags = trace_flags;\n\tscenein.t0 = 0.0;\n}\n\nfloat ClampRayAgainstCurrentGridCell( vec3 p, vec3 v_rcp, vec3 cell_size, float cell_inflate_epsilon )\n{\n\t// we know the direction therefore we only have to test one side of each axis\n\tvec3 s = sign( v_rcp );\n\tvec3 amin = floor( p / cell_size ) * cell_size;\n\tamin -= vec3( cell_inflate_epsilon ); // instead of adding that to d_ghost we clamp to cell_size + cell_inflate_epsilon\n\tvec3 a = amin + ( ( s + 1.0 ) * 0.5 ) * ( cell_size + 2.0 * vec3( cell_inflate_epsilon ) );\n\tvec3 t = ( a - p ) * v_rcp; // ray vs all closest box planes\n//\tt += FLT_MAX * ( 1.0 - abs( s ) ); // when sign is zero, push next hit at t=+infinite, v_rcp has been set to zero in that case\n\treturn min( min( t.x, t.y ), t.z ); // should be > 0 by construction\n}\n\nbool CanGhostStep( SceneIn scenein, float maxdist_from_t0, float maxdist_abs )\n{\n\treturn HasDirection( scenein.trace_flags )\n\t\t&& ( scenein.t < maxdist_abs ) // GHOST_MAX_DIST_ABS\n\t\t&& ( ( scenein.t - scenein.t0 ) < maxdist_from_t0 ); // GHOST_MAX_DIST_FROM_T0\n}\n\nvoid GhostGridSteps( inout SceneOut eval, SceneIn scenein, float cell_size, float cell_inflate_epsilon )\n{\n\tfloat dm = ClampRayAgainstCurrentGridCell( scenein.p, scenein.v_rcp\n\t\t\t\t\t\t\t\t\t\t\t   , vec3( cell_size, cell_size, 20.0 ), cell_inflate_epsilon );\n\t// note that this doesn't deal with diagonals which might cross another cell\n\teval.d_ghost = min( eval.d_ghost, max( dm, GHOST_EPS ) );\n}\n\n// used by farms and trees\n#define SD_OBJECT_CONTRIB( _di_, _object_sd_func_, _grid_offset_, _hoffset_ ) {\\\n\tCellPoint _cp_; \\\n\tif ( GetClosestGridPointWithPathBand_x1( _cp_, p.xy, h_gradval, args, _grid_offset_, _hoffset_ ) )\\\n\t\t_di_.object_di = _object_sd_func_( _di_.object_di, p, _cp_, radius_fraction, _di_.path.patch_di.id, eval.color, scenein, h_gradval, args.taylor_expansion_height );\\\n}\n\nvoid AddContributionTrees( inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval, float groundz, vec3 patch_id_hash, int aFrame, float aTime )\n{\n\tvec3 p = scenein.p;\n\tfloat tree_max_radius = 0.15;\n\n\tCloseGridPointArgsWithBand args;\n\targs.args0.cell_size = 0.4;\n\targs.args0.max_radius = tree_max_radius;\n\targs.args0.radius_disparity = 0.1;\n\targs.band_start = args.args0.max_radius;\n\t// some patches are filled with trees, some other patches only have trees on the border\n#if 1\n\targs.band_end = patch_id_hash.x > 0.9 ? FLT_MAX : args.args0.max_radius * 3.0;\n#else\n\targs.band_end = FLT_MAX;\n#endif\n\targs.taylor_expansion_height = TAYLOR_HEIGHT_TREE;\n\n\tfloat grid_offset_step = 0.25; // this is wrong actually but creates a certain sparsity that is welcome\n\tvec3 grid_offsets = vec3( 0., 1.0, 2.0 ) * grid_offset_step * args.args0.cell_size;\n\tfloat radius_fraction = 1.0;\n#if 0\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.x, 000.0 );\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.y, 100.0 );\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.z, 200.0 );\n#else\n\t// this might be a bit faster (92->71!), also shadertoy compile time\n\tfor ( float f = 0.0 FORCE_LOOPF; f < 3.0; f += 1.0 )\n\t{\n\t\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offset_step * args.args0.cell_size * f, 100.0 * f );\n\t}\n#endif\n\n\tfloat mat_id = DecodeId( eval.object_di );\n\t// displace all the trees at once...\n\tif ( DISPLACE_TREE && ( ( mat_id == MATID_TREE ) || ( mat_id == MATID_PINE ) ) )\n\t{\n\t\tvec3 pd = p;\n\t\tif ( WIND_TREE_AND_PINES ) pd += ApplyWind( pd, aTime );\n\n\t\tfloat is_pine = ( mat_id == MATID_PINE ) ? 1. : 0.;\n\t\t\n\t\tpd.z *= mix(1.,0.75,is_pine);\n\t\t\n\t\teval.object_di.d += sfbm2_13_leaf( pd * 80.0 * 2.2 ) * TREE_SDD * mix( 1., 0.4, is_pine ) * 0.8;\n\t}\n\n\tif ( GHOST_STEPS_TREE && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS ) )\n\t{\n\t\t// note: offset zero for all + smallest cell size fraction multiple should yield same result\n\t\tfloat cell_inflate_epsilon = 0.004; // tree\n\t\tGhostGridSteps( eval, scenein, grid_offset_step * args.args0.cell_size, cell_inflate_epsilon );\n\t}\n}\n\nvoid AddContributionFarms( inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval, float groundz, vec3 patch_id_hash\n\t\t\t\t\t\t   , float closest_path_middle_point_height )\n{\n\tvec3 p = scenein.p;\n\tbool is_farm_patch = patch_id_hash.x > 0.2;\n\n\tif ( !is_farm_patch ) return;\n\n\tif ( FARM )\n\t{\n\t\t// farms are sparse so use 1 cell\n\t\tCloseGridPointArgsWithBand args;\n\t\targs.args0.cell_size = 1.2;\n\t\targs.args0.max_radius = 0.35;\n\t\targs.args0.radius_disparity = 0.3;\n\t\targs.band_start = args.args0.max_radius * 1.5;\n\t\targs.band_end = FLT_MAX;\n\t\targs.taylor_expansion_height = TAYLOR_HEIGHT_FARM;\n\t\tfloat radius_fraction = 0.8;\n\t\tSD_OBJECT_CONTRIB( eval, sdGridObj_Farm, 0.0, 0.0 );\n\t\tif ( GHOST_STEPS_FARM && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS ) )\n\t\t{\n\t\t\tfloat cell_inflate_epsilon = 0.004;\n\t\t\tGhostGridSteps( eval, scenein, args.args0.cell_size, cell_inflate_epsilon );\n\t\t}\n\t}\n\n\tif ( BRICKWALL && patch_id_hash.y > 0.7 ) // note: not all farm patch have a visible house on them...\n\t{\n\t\tDistanceId walls = MkDistanceId( sdBrickWall( p, eval.path, eval.base_height ), MATID_BRICKWALL );\n\t\teval.object_di = opUdi( eval.object_di, walls );\n\t}\n}\n\nvoid AddContributionGrass( inout SceneOut eval, vec3 p, float groundz, vec3 patch_id_hash )\n{\n\tfloat grass_height = ( groundz - 0.01 ) // make sure grass doesn't cover the path ground\n\t\t+ smoothstep( -0.02, 0.04, abs( eval.path.patch_di.d ) - LANEWIDTH * 0.5 ) * 0.0195;\n\tDistanceId grass = MkDistanceId_16( sdGrass( p, grass_height ), MATID_GRASS, patch_id_hash.z ); // each patch has slightly different colors\n\teval.object_di = opUdi( eval.object_di, grass );\n}\n\nvoid AddContributionPath( inout SceneOut eval, SceneIn scenein, float groundz )\n{\n\tvec3 p = scenein.p;\n\tfloat path_d_min = p.z - groundz;\n\n\tif ( !( path_d_min < eval.object_di.d ) ) return; // weird compiler horror happened depending how we write the if branch here\n\n\t// path is the most occluded thing so do it last\n\tDistanceId path_di = MkDistanceId_16( path_d_min // lower bound for bushes\n\t\t\t\t\t\t\t\t\t   , MATID_GROUND, ( 1.0 - smoothstep( 0.0, 0.05, eval.path.patch_di.d ) ) );\n\tif ( DISPLACE_PATH )\n\t{\n\t\t// this displacement is expensive, cull as much as we can, maybe we could just do that in shade\n\t\tfloat path_blend = 1.0 - smoothstep( 0.001, 0.008, eval.path.patch_di.d - LANEWIDTH * 0.5 );\n\t\tfloat distance_blend = 1.0 - smoothstep( 6.0, 7.0, scenein.t );\n\t\tfloat fade = path_blend * distance_blend;\n\t\tif ( fade > 0.0 ) // that cuts a bit\n\t\t{\n\t\t\t// so we can scale along road direction\n\t\t\tpath_di.d += fade * sfbm2_12( GetLocalCurvePoint( eval.path ) * vec2( 1, 2 ) * 80.0 ) * DISPLACE_PATH_AMPL;\n\t\t}\n\t}\n\n\teval.object_di = opUdi( eval.object_di, path_di );\n}\n\nSceneOut evalScene( SceneIn scenein, int aFrame, float aTime)\n{\n\tvec3 p = scenein.p;\n\n\tSceneOut eval;\n\tSceneOutInit( eval );\n\t\n\tfloat groundz = BaseGroundHeight( p.xy );\n\teval.base_height = groundz;\n\teval.path = EvalClosestPath( p.xy, false );\n\tvec3 h_gradval = vec3( 0.0, 0.0, groundz );\n\n#ifdef TERRAIN_WARP\n\tvec3 ground_normal;\n#endif\n\n\tif (\n#ifdef TERRAIN_WARP\n\t\t _1 ||\n#endif\n\t\t // any of those need the height gradient at p\n\t\t TAYLOR_HEIGHT_BUSH ||\n\t\t TAYLOR_HEIGHT_TREE ||\n\t\t TAYLOR_HEIGHT_FARM )\n\t{\n\t\tvec2 e = vec2( 1e-3, 0 );\n\t\tfloat hx = BaseGroundHeight( p.xy + e.xy );\n\t\tfloat hy = BaseGroundHeight( p.xy + e.yx );\n\t\th_gradval.xy = vec2( hx - eval.base_height,\n\t\t\t\t\t\t\t hy - eval.base_height ) / e.x; // be careful to not divide by e since it has zero in .y\n#ifdef TERRAIN_WARP\n\t\tvec3 px = vec3( p.xy + e.xy, hx );\n\t\tvec3 py = vec3( p.xy + e.yx, hy );\n\t\tvec3 pc = vec3( p.xy, eval.base_height );\n\t\tground_normal = normalize( cross( px - pc, py - pc ) );\n#endif\n\t}\n\n#ifdef TERRAIN_WARP\n\teval.terrain_warp = 0.0;\n\tif ( HasDirection( scenein.trace_flags ) )\n\t{\n\t\tfloat large_optimistic_step = 3.0;\n\t\tvec3 base = vec3( p.xy, eval.base_height + bush_max_radius*2.5 );\n\t\tRay warp_ray;\n\t\twarp_ray.o = scenein.p;\n\t\twarp_ray.d = scenein.v;\n\t\tfloat t2 = plane_trace( warp_ray, base, ground_normal, 1e-3 );\n\t\tif ( t2 > 0.0 )\n\t\t{\n//\t\t\tif ( dot( ground_normal, scenein.v ) < 0 ) // if terrain is convex at ground_normal in trace direction?\n\t\t\t\teval.terrain_warp = min( t2, large_optimistic_step );\n\t\t}\n\t}\n#endif\n\n\t// eval.path.patch_di.id is the patch id\n\t// eval.path.patch_di.d is the distance to closest path\n\t//\n\t// the path we walk on is flat so we need the height of center of the road\n\tvec2 closest_patch_border_point2 = p.xy + eval.path.v2closest; // center of road\n\tfloat closest_path_middle_point_height = BaseGroundHeight( closest_patch_border_point2 ); // fences use\n\n\teval.test2d = eval.path;\n\n\t// upper bound for distance to ground, take into account displacement that might dig a little on paths\n\tfloat d_ground_max = p.z - ( eval.base_height - DISPLACE_PATH_AMPL * 2.0 );\n#if 0\n\t// bogus build error on ? : in shadertoy\n\teval.object_di = GROUND_OCCLUSION // occlusion helps\n\t\t? MkDistanceId( d_ground_max, MATID_GROUND )\n\t\t: MkDistanceId( FLT_MAX, MATID_NONE ); // enable PATH to get a ground\n#else\n\tif ( GROUND_OCCLUSION ) eval.object_di = MkDistanceId( d_ground_max, MATID_GROUND ); // occlusion helps\n\telse eval.object_di = MkDistanceId( FLT_MAX, MATID_NONE ); // enable PATH to get a ground\n#endif\n\t// hit the patch boundary tangent plane, this has 2 properties we want:\n\t//  1- the closer we are to the boundary the more this approximates the hit point, sort of\n\t//  2- if ray leaches the patch boundary, the hit point will be far away\n\t//      -> that second one improves significantly the horrible artifact where we run out of points...\n\t//  also ignore far away hits for perfs   \n\t\n\t// todo: we don't need ghost steps if we are far above the ground! we can save a bit\n\n\tif ( GHOST_STEPS_PATCH && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS ) )\n\t{\n\t\tvec3 base = vec3( p.xy + eval.path.v2closest, p.z );\n\t\tvec3 normal = normalize( -vec3( eval.path.v2closest, 0 ) );\n\t\tfloat t2 = plane_trace( p, scenein.v, base, normal, 1e-3 );\n\t\tif ( t2 > 0.0 ) eval.d_ghost = min( eval.d_ghost, max( t2, GHOST_EPS ) );\n\t}\n\n//\tvec3 patch_id_hash = hash31( eval.path.patch_di.id );\n\tvec3 patch_id_hash = hash42_( ivec2( int( eval.path.patch_di.id ) ) ).xyz; // paranoid use of ints for important structural elements\n\n\tbool is_forest_patch = patch_id_hash.x > 0.65;\n\n\tif ( is_forest_patch )\n\t{\n\t\tif ( TREE ) AddContributionTrees( eval, scenein, h_gradval, groundz, patch_id_hash, aFrame, aTime );\n\t}\n\telse AddContributionFarms( eval, scenein, h_gradval, groundz, patch_id_hash, closest_path_middle_point_height );\n\n\tif ( BUSH ) AddContributionBushes( eval, scenein, h_gradval, groundz, patch_id_hash, is_forest_patch, aTime, aFrame );\n\tif ( GRASS ) AddContributionGrass( eval, p, groundz, patch_id_hash );\n\tif ( PATH ) AddContributionPath( eval, scenein, groundz );\n\n\treturn eval;\n}\n\nstruct TraceOutput\n{\n\tfloat t;\n\tfloat dist; // distance to surface (error)\n\tfloat shadow; // sun/main light occlusion\n};\n\n#define MAX_ITERATIONS_VIEW 120\n#define MAX_ITERATIONS_SHADOW 40 // set this as small as you can with your lighting setting, even if shadow ray escape to sky quickly this results in big win\n#define TMAX_VIEW 80.0 // was 200 before\n#define TMAX_SHADOW 40.0 // reducing this doesn't help much\n#define TFRAC 0.8\n#define DBREAK 0.0025 // tweak for perfs!!! depends on scene scale etc might make small features thicker than they actually are\n\nTraceOutput traceScene( Ray ray, float shadow_sharpness, int trace_flags\n\t\t\t\t\t\t, int max_iterations, float tfrac, float tmaxmax, float dbreak, vec2 uv, vec2 fragCoord, int aFrame, float aTime )\n{\n\tTraceOutput to;\n\tto.t = 0.0;\n\tto.dist = 0.0;\n\tto.shadow = 1.0;\n\n\tfloat tmax = tmaxmax; // default to absolute max\n\n\t{\n\t\t// clamp traced segment\n\t\tfloat hmax = MAX_TERRAIN_HEIGHT + TALLEST_OBJECT_HEIGHT; // there must be nothing above this height\n\t\tfloat thit = plane_trace_z( ray, hmax, 1e-4 );\n\t\tif ( thit > 0.0 )\n\t\t{\n\t\t\tif ( ray.o.z > hmax ) to.t = thit; // above hmax looking down\n\t\t\telse tmax = min( thit, tmaxmax ); // below hmax looking up, clamp at hmax\n\t\t}\n\t\telse if ( ray.o.z > hmax )\n\t\t{\n\t\t\tto.t = tmaxmax * 1.1; // above hmax looking up, there is only sky\n//\t\t\treturn to; // don't branch here, that might be actually slower\n\t\t}\n\t}\n\n\tSceneIn scenein;\n\tSetSceneInDirection( scenein, ray.o, ray.d, trace_flags );\n\tscenein.t0 = to.t;\n\t\n\tfor ( int i = 0 FORCE_LOOP; i < max_iterations; ++i )\n\t{\n\t\tscenein.p = ray.o + to.t * ray.d;\n\t\tscenein.t = to.t;\n\t\tSceneOut eval = evalScene( scenein, aFrame, aTime );\n\t\tfloat d = min( eval.object_di.d, eval.d_ghost );\n\t\t// note: ghost points might make us jump over solid tfrac points\n\t\tfloat is_ghost_step = ( d == eval.d_ghost ? 1.0 : 0.0 );\n\t\tto.dist = d;\n\n\t\t// important: do not move this block after the to.dist check!\n\t\tif ( IsShadowTrace( trace_flags )\n\t\t\t//&& ( is_ghost_step == 0.0 ) // creates ugly discontinuities\n\t\t\t)\n\t\t{\n\t\t\t// note: if eval.object_di.d < 0 we set shadow to 0 in effect\n\t\t\t// that catches the case where first point is inside an object (because shadow ray offset issues, ex: bush vs ground normal discontinuity)\n\t\t\t// for regular case if distance is neg it means we hit an object and so shadow = 0 too anyway\n\t\t\t// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf for shadows\n\t\t\tto.shadow = min( to.shadow, shadow_sharpness * max( eval.object_di.d, 0.0 ) / ( to.t + 1e-4f ) );\n\t\t\t\n\t\t\tif ( to.shadow <= 0.01 ) break;\n\t\t}\n\n\t\t// warning: never stop on a ghost step!!\n\t\tif ( ( ( is_ghost_step == 0.0 ) && ( to.dist <= dbreak * to.t ) )\n\t\t\t || ( to.t > tmax ) ) break;\n\n\t\t// the amount by which we advance t: drop tfrac on ghost steps\n\t\tfloat dt = to.dist * mix( tfrac, 1.0, is_ghost_step );\n\n\t\tto.t += dt;\n\t}\n\n\tif ( to.t > tmax ) to.t = tmaxmax * 1.1;\n\n\treturn to;\n}\n\n#ifdef SHADERTOY_STANDALONE\n#define TIME_OF_DAY iSlider0\n#else\n#define TIME_OF_DAY 0.56\n#endif\n\nvec3 get_sun_direction(float aTime)\n{\n\tfloat sun_elevation = radians( mix( -30.0, 90.0, TIME_OF_DAY ) ); // careful with z, long shadows make the tracing slower\n\treturn zup_spherical_coords_to_vector( unit_vector2( PI * 0.5 - sun_elevation )\n\t\t\t\t\t\t\t\t\t\t\t , _1 ? V45 : unit_vector2( 2.0 * PI * aTime / 3.0 ) );\n}\n\n#define cloud_re 3000.0\n#define cloud_r1 ((cloud_re)+8.0)\n#define cloud_r2 ((cloud_r1)+1.8)\n#define fake_earth_center vec3(0,0,-cloud_re)\n\nfloat cloudDensity( vec3 p )\n{\n\tfloat sparsity = 0.07; // 0,1.x\n\tfloat freq = 0.2;\n\tfloat d = efbm4_13( p * freq, 1.0 + sparsity );\n\tfloat r = length( p - fake_earth_center );\n\tfloat r2 = length( p.xy );\n\tfloat c = smoothstep( 3., 5., r2 ); // cleanup singularity at north pole a little bit\n\td *= smoothstep( 0.4, 0.6, d * c ); // multiply d by c give best fade out\n\td = max( d, 0. );\n\td *= smoothstep( cloud_r1, cloud_r1 + 0.1, r )\n\t\t* ( 1.0 - smoothstep( cloud_r2 - 0.1, cloud_r2, r ) ); // altitude band\n\treturn d;\n}\n\n// make some ultra basic clouds out of thin air, we will bake them in a spheremap\nvec3 traceClouds( vec3 n, float aTime )\n{\n\tvec3 sun_direction = get_sun_direction(aTime);\n\tRay ray = mkray( vec3( 0.0 ), n );\n\tvec2 vt1 = sphere_trace( ray, cloud_r1, fake_earth_center );\n\tvec2 vt2 = sphere_trace( ray, cloud_r2, fake_earth_center );\n\t//return vec4( vec3( 0.1*( t2.y - t1.y ) / ( r2 - r1 ) ), 0 );\n//\tfloat li = 1.0;\n\tfloat vlen = ( vt2.y - vt1.y );\n\tfloat vdt = vlen / 100.0;\n\tfloat vt = vt1.y;\n\tfloat vod = 0.0;\n\tfloat vod2 = 0.0;\n\tfloat c = 0.8;\n\t// view ray\n\tfor ( ; vt < vt2.y ; vt += vdt )\n\t{\n\t\tvec3 p = ray.o + ray.d * vt;\n\t\tfloat pd = cloudDensity( p );\n\t\t{\n\t\t\t// sun ray\n\t\t\tRay lray = mkray( p, sun_direction );\n\t\t\tvec2 lt2 = sphere_trace( lray, cloud_r2, fake_earth_center );\n\t\t\tfloat llen = lt2.y;\n\t\t\tfloat ldt = llen / 5.0;\n\t\t\tfloat lt = ldt;\n\t\t\tfloat lod = 0.0;\n\t\t\tfor (; lt < llen; lt += ldt )\n\t\t\t{\n\t\t\t\tvec3 lp = lray.o + lray.d * lt;\n\t\t\t\tfloat lpd = cloudDensity( p );\n\t\t\t\tlod += vdt * lpd * c * 10.0;\n\t\t\t}\n\t\t\tvod2 += vdt * pd * exp( -lod -vod ); // inscatter\n\t\t}\n\t\tvod += vdt * pd * c; // absorption\n\t}\n\n\t// for compositing we do something like exp( -vod ) * distant_sky_color + vod2\n\treturn vec3( saturate(vod2), exp( -vod ), 0 );\n\t\n#define cloud_lowest_absorption_remap 0.6\n\t\n}\n\n// map theta to uv .5 r, we only keep the [0,PI/2] theta range\n#if 0\nfloat theta2r05( float theta ) { return theta *(1.0/PI) ; }\nfloat r052theta( float r ) { return r * PI; }\n#else\n// give more resolution to the horizon\nfloat theta2r05( float theta ) { return pow(saturate(theta*(1.0/(PI*0.5))),2.0) *0.5; }\nfloat r052theta( float r ) { return pow((r*2.0),0.5) *PI*0.5; }\n#endif\n\nvec3 get_cloud( vec3 v, sampler2D aChannel1, vec3 aResolution, float aTime )\n{\n\tvec3 cloud = vec3(0.0);\n#if BUFFER_MODE==2\n\tif ( CLOUD_MODE>0 )\n\t{\n\t\tvec2 sc = vector_to_zup_spherical_coords( v );\n\t\tif ( sc.x > PI * 0.5 ) return BLUE;\n\t\tvec2 uv = vec2( 0.5 ) + unit_vector2( sc.y ) * theta2r05( sc.x );\n\t\tuv.x *= aResolution.y / aResolution.x;\n\t\tcloud = CLOUD_MODE==1\n\t\t\t? traceClouds( v, aTime )\n\t\t\t: texture( aChannel1, uv ).xyz; // return the highres one here for debug, should match with sampled one\n\t}\n#endif\t\n\treturn cloud; // debug\n}\n\nfloat sFlarePeak( vec2 p, float da, float a, float a_offset )\n{\n\ta += a_offset;\n\ta = floor( ( a / da ) + 0.5 ) * da;\n\tvec2 vv = unit_vector2( a - a_offset );\n\treturn abs( dot( p, perp( vv ) ) );\n}\n\nvec4 sunGlareCoords( mat4 cam, vec3 v, vec3 l )\n{\n\tvec3 sy = normalize( cross( cam[0].xyz, l ) );\n\tvec3 sx = normalize( cross( l, sy ) );\n\treturn vec4( normalize( vec2( dot( v, sx ), dot( v, sy ) ) ), dot( v, l ), -cam[2].z );\n}\n\nvec3 sunGlare( vec4 ppd // xy: angle as unit vector z: dot(v,l)\n\t\t\t   , float solid_sun_disk_radius\n\t\t\t   , float ray_length // higher value = shorter length\n\t\t\t   , float ray_thickness\n\t\t\t   , float ray_thickness_disparity\n\t\t\t   , float n1 // can be arbitrarily large\n\t\t\t   , float n2 // there is a loop on n2 - the number of rays is n1*n2 so we have a trade off between the repeat in sFlarePeak (which can't do proper additive on rays) and the for loop (which can)\n\t\t\t   , float falloff_glare_attn\n\t\t\t   , float falloff_glare_p1\n\t\t\t   , float falloff_glare_p2\n\t\t\t   , bool falloff_glare_multiplicative )\n{\n\tvec2 anglev = ppd.xy; // angle as unit vector\n\tfloat v_dot_l = ppd.z;\n\tfloat r = safe_acos( v_dot_l ) / PI; // could do without acos but it is a lot more easier to work with regular spacing\n\tvec2 p = anglev * r;\n\tfloat a = calc_angle( anglev );\n//\treturn vec3( stripes(r,0.02,0.001,0.001/2.0), stripes(degrees(a),10.,0.1,0.1/2.0),0.); // visualize polarcoords\n\tfloat v = 0.0;\n\tfloat d2 = max( r - solid_sun_disk_radius, 0. ); // falloff glare\n\tfloat da = 2.0 * PI / n1;\n\tfloat da2 = 2.0 * PI / ( n1 + n2 );\n\tfor ( float i = 0.; i < n2; ++i )\n\t{\n\t\tvec3 rr = hash31( i + 1. );\n\t\tfloat rda = rr.x * da2 * 0.1;\n\t\tfloat d1 = sFlarePeak( p, da, a, -i * da / n2 + rda );\n\t\tif ( r < solid_sun_disk_radius ) d1 = 0.;\n\t\tv += exp2( -d1 * d1 * ray_thickness * mix( 1.0-ray_thickness_disparity, 1.+ray_thickness_disparity, rr.y )\n\t\t\t\t   -d2 * ray_length * mix( 0.5, 1.5, rr.z ) );\n\t}\n\tfloat falloff_glare = falloff_glare_attn * ( 1.0 - powerful_scurve( d2, falloff_glare_p1, falloff_glare_p2 ) );\n\tv = falloff_glare_multiplicative ? v * falloff_glare : v + falloff_glare;\n\tv = min( v, 1. );\n\treturn vec3( v );\n}\n\n#define FOG_GROUND _1\n\n // set render to false for getting a value for lighting calculation as opposed to display\nvec3 get_top_sky_color( bool render ) {  return AZURE * ( render ? 0.6 : 1.0 ); }\nvec3 get_sky_horizon_color() { return mix( WHITE, AZURE, 0.4 ); }\nvec3 get_fog_color() { return mix( AZURE, WHITE, 0.15 ); }\n\n// return a v.z normalized so that horizon view direction is remapped to 0 and zenith is still 1\nfloat get_hacked_vz( vec3 v, float ez )\n{\n\tfloat zmin = -max(ez,0.)/(TMAX_VIEW*1.1); // z/f=zmin/1. where f=TMAX_VIEW*1.1\n\treturn max(0.,(v.z-zmin)/(1.-zmin));\n}\n\nvec3 get_sky( vec3 v, vec3 l, float ez, bool render )\n{\t\n\tfloat hz = get_hacked_vz( v, ez );\n\treturn mix( get_sky_horizon_color(), get_top_sky_color(render), pow( hz, 0.2 ));\n}\n\nvec3 get_sky_plus_clouds( vec3 v, vec3 l, float ez, sampler2D aChannel1, vec3 aResolution, float aTime )\n{\n\tvec3 col = get_sky( v, l, ez, true );\n\tvec3 cloud = get_cloud( v, aChannel1, aResolution, aTime  );\n\tvec3 sky_with_clouds =  col * mix( cloud_lowest_absorption_remap, 1., cloud.y ) + vec3( cloud.x ); // composite clouds, col * absorption + scattering\n\treturn mix( col, sky_with_clouds, smoothstep( 0., 0.025, v.z ) ); // fade to sky on thin horizon band\n}\n\n// e = eye pos, v = view vector, p = lit point, n = normal, l = sun direction\nvec3 shadeSample( in vec3 e, in vec3 v, mat4 cam, in vec3 p, in vec3 n, vec3 l\n\t\t\t\t  , float shadow, TraceOutput to, float ao, vec2 uv\n\t\t\t\t  , SceneOut eval, bool sky, sampler2D aChannel1, vec3 aResolution, float aTime )\n{\n\tvec3 col = vec3( 0. );\n\t\n\tvec3 sunI = vec3( 2.0 );\n\n\tvec3 top_sky_color = get_sky(vec3(0,0,1),l,e.z,false);\n\n\tSG sun_lobe = CosineLobeSG( l );\n\tsun_lobe.Amplitude *= sunI;\n\n\tSG sky_lobe = CosineLobeSG( vec3( 0, 0, 1 ) );\n\tsky_lobe.Amplitude *= top_sky_color;\n\n\tif ( !sky )\n\t{\n\t\tvec3 scene_color = vec3( 0 );\n\t\n\t\tfloat bush_factor = 0.0;\n\t\tfloat tree_factor = 0.0;\n\t\tfloat pine_factor = 0.0;\n\t\tvec3 sky_reflection = vec3(0,0,0);\n\t\t\n\t\tvec2 mm = DecodeId_16( eval.object_di );\n\t\tfloat matid = mm.x;\n\t\tfloat matid_f = mm.y; // we can have color variations within an id\n\n\t\tbush_factor = smoothbump( MATID_BUSH, 0.5, matid );\n\t\ttree_factor = smoothbump( MATID_TREE, 0.5, matid );\n\t\tpine_factor = smoothbump( MATID_PINE, 0.5, matid );\n\t\tvec4 mm4 = DecodeId_5_5_5( eval.object_di ); // yzw = depth uheight color_rnd\n\t\tfloat tree_ao = mix( 0.6, 1., smoothstep( 0., 0.5, mm4.z ) ); // make it very faint, doesn't fit the style\n\n\t\tscene_color = vec3( 0 )\n\t\t\t+ bush_factor * eval.color\n\t\t\t+ tree_factor * mix( mix( COLOR_TREE1, COLOR_TREE2, mm4.w ), COLOR_TREE_SURF, 0.0*mm4.y*mm4.y*mm4.y ) * tree_ao\n\t\t\t+ smoothbump( MATID_TRUNK, 0.5, matid ) * COLOR_TRUNK\n\t\t\t+ smoothbump( MATID_HOUSE, 0.5, matid ) * COLOR_HOUSE\n\t\t\t+ smoothbump( MATID_HOUSE_BOTTOM, 0.5, matid ) * COLOR_HOUSE_BOTTOM\n\t\t\t+ smoothbump( MATID_ROOF, 0.5, matid ) * mix( COLOR_ROOF1, COLOR_ROOF2, matid_f )\n\t\t\t+ smoothbump( MATID_BRICKWALL, 0.5, matid ) * COLOR_BRICKWALL\n\t\t\t+ pine_factor * mix( COLOR_PINE, COLOR_PINE2, mm4.w ) * tree_ao\n\t\t\t+ smoothbump( MATID_GRASS, 0.5, matid ) * mix( COLOR_GRASS, COLOR_GRASS2, matid_f )\n\t\t\t+ smoothbump( MATID_GROUND, 0.5, matid ) * mix( PATH_COLOR, PATH_COLOR2, matid_f )\n\t\t\t+ smoothbump( MATID_NONE, 0.5, matid ) * MAGENTA;\n\n\t\tif ( MATID_WINDOW == matid ) \n\t\t{\n\t\t\tscene_color = BLACK;\n\t\t\tvec3 vr = reflect( v, n );\n\t\t\tvec3 refl_color = get_sky_plus_clouds( vr, l, p.z, aChannel1, aResolution, aTime );\n\t\t\trefl_color = mix( COLOR_GRASS * mix( 0.2, 1.0, shadow ), refl_color, smoothstep( -0.03, -0.0, vr.z ) );\n\t\t\tsky_reflection = refl_color * mix( 0.2, 1.0, pow( 1.0 - saturate( dot( -v, n ) ), 2.0 ) );\n\t\t}\n\n\t\tif ( MATID_GRASS == matid )\n\t\t{\n\t\t\tvec3 lf = sfbm4_33( p * 40.0 );\n\t\t\tfloat hf = sfbm1_12( p.xy * 2800.0 );\n\n\t\t\tif ( matid_f > ( 1. - 0.04 ) ) // mowed lawn, should be rare\n\t\t\t{\n\t\t\t\tfloat period = 0.07;\n\t\t\t\tfloat s = stripes( rotate_with_angle( p.xy, matid_f * 1000.0 ).x, period, period * 0.25, 0.004 );\n\t\t\t\tscene_color = mix( COLOR_MOWED_GRASS, COLOR_MOWED_GRASS2, saturate( s + ( lf.x - 0.38 ) * 1.5 ) );\n\t\t\t}\n\n\t\t\t// just apply some noise\n\t\t\tscene_color *= 1.0 - 0.2 * ( saturate( 1.0 - lf.y ) );\n\t\t\tscene_color *= saturate( 1.0 - 0.4 * hf * saturate( 1.0 - lf.y ) );\n\t\t}\n\t\n\t\tvec3 albedo = scene_color; // return albedo;\n\n\t\tcol += shadow * SGDiffuseFitted( sun_lobe, n, albedo );\n\n\t\t// this way of doing diffuse makes shadow color be different on ground than back of object resting on it which sucks\n\t\tif ( _1 ) col += mix( SGDiffuseFitted( sky_lobe, n, albedo ), top_sky_color, SHADOW_TINT_SATURATION )\n\t\t\t\t// add more sky ambient to tint shadow in blue? in a way that is not too hacky?\n\t\t\t\t* mix( 0.15, 0.02, shadow )\n\t\t\t\t* ao;\n\n\t\tcol += sky_reflection;\n\n\t\tfloat d = length( p - e );\n\t\tif ( FOG_GROUND ) col = mix( col, get_fog_color() * 0.8, ( 1. - exp( -0.1 * max( d - 6.1, 0. ) ) ) * 0.378 ); // fog\n\t}\n\telse\n\t{\n\t\tcol = get_sky_plus_clouds( v, l, e.z, aChannel1, aResolution, aTime );\n\n\t\tif ( SUN ) // this sun is the one in the sky\n\t\t{\n\t\t\tvec4 ppd = sunGlareCoords( cam, v, l );\n\t\t\tcol += sunGlare( ppd, 0.007, 280., 100000.0, 0.2, 20.0, 4.0, 0.3, 0.4, 8., false )\n\t\t\t\t* vec3( 0.8, 0.8, 0.5 ) * sunI;\n\t\t}\n\t}\n\n\t// note: we would like to do SUN_GLARE here, but reprojection only works on solid world pos or distance sky\n\treturn col;\n}\n\nvec3 postProcess( vec3 col, vec2 uv, vec4 ppd )\n{\n\tif ( SUN_GLARE )\n\t{\n\t\tcol.xyz += 0.116 * sunGlare( ppd, 0., 7., 8000.0, 0.2, 8.0, 8.0, 0.3, 2., 2., true )\n\t\t\t* vec3( 1., 0.7, 0.2 ) * 2. // use warmer color for this glare\n\t\t\t* smoothstep( -0.15, 0.3, ppd.w )\n\t\t\t* (1.0-smoothstep( 0.78, 0.9, ppd.z ));\n\t}\n\n\tfloat exposure = 3.0; \n\t// maybe auto expose when staring straight at the sun? the sun is a bit saturated on the clouds\n\t//exposure = mix(exposure,1.,smoothstep(0.985,1.0,1.-ppd.z));\n\tcol = exposure * tonemap_reinhard( col );\n//\tcol = max( vec3( 0. ), contrast( col, vec3( 1.02 ) ) );\n\tfloat vignette = .0 + 1. * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.15 );\n\tcol *= vignette;\n\tcol = contrast( col, vec3( 1.06 ) );\n\tcol = gamma_correction_itu( col );\n\treturn col;\n}\n\nstruct CameraRet { vec3 eye; vec3 target; float roll; float pitch; };\n\nCameraRet init_cam() { CameraRet cam; cam.roll = 0.; cam.pitch = 0.; return cam; }\n\n#define STICKY_MOUSE false\n\nmat4 look_around_mouse_control( mat4 camera, float pitch, float tan_half_fovy, vec3 aResolution, vec4 aMouse, float dmmx )\n{\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( dmmx, pitch );\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( aMouse.z > 0.0 || STICKY_MOUSE ) mm = ( aMouse.xy - aResolution.xy * 0.5 ) / ( min( aResolution.x, aResolution.y ) * 0.5 );\n#endif\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\n\treturn camera * yup_spherical_coords_to_matrix( mm.y, mm.x );\n}\n\nstruct LanePoint { vec3 p; vec3 tangent2d; float lane_index; };\n\nLanePoint getPathPointAndDir( float x, float lane_index )\n{\n\tLanePoint ret;\n\tvec2 y = wavyLaneFuncAndDerivative_WORLD( x, lane_index );\n\tret.p.xy = vec2( x, y.x );\n\tret.p.z = BaseGroundHeight( ret.p.xy ) + 0.073;\n\tret.tangent2d = normalize( vec3( 1.0, y.y, 0 ) );\n\tret.lane_index = lane_index;\n\treturn ret;\n}\n\n// a cubicstep function that takes 2 arbitrary end points and 2 (begin end) slopes\nfloat cubicstep2( float x, vec2 p0, vec2 p1, float s0, float s1 )\n{\n\tx -= p0.x;\n\tp1 -= p0;\n\tx = clamp( x, 0., p1.x );\n\tfloat x1_sqr = p1.x * p1.x;\n\tvec3 eq1 = vec3( 3.0 * x1_sqr, 2.0 * p1.x, s1 - s0 );\n\tvec3 eq2 = vec3( x1_sqr * p1.x, x1_sqr, p1.y - s0 * p1.x );\n\tfloat a = ( eq1.y * eq2.z - eq1.z * eq2.y ) / ( eq1.y * eq2.x - eq1.x * eq2.y );\n\tfloat b = ( eq1.z - eq1.x * a ) / eq1.y;\n\treturn p0.y + ( ( a * x + b ) * x + s0 ) * x;\n}\n\nfloat linearstep2( float x, vec2 p0, float s0 ) { return p0.y + s0 * ( x - p0.x ); }\n\n// getCameraPathx is a line segment of length 'a', slope 'sa' followed by another line segment of length 'b', slope 'sb',\n// made periodic and smooth. \n// the 'a' segment is where we walk, the 'b' segment is where we fly \n// this lets us tweak length and speed of walk and flight sequences separately\n// the cubic transitions are a bit iffy and tedious looking but the curve must be really clean to make landing and take off transitions natural and gentle\n// return values:\n//  x: were we are on the lane\n//  y: flight smooth blend factor (0 means we walk >0 means we fly, function goes up and down smootly)\n//  z: the periodicity index, so each period can use a different lane\n//  w: the flight begin to end smoothstep, we use it so we can blend between lanes whilst we are in the air\nvec4 getCameraPathx( float x, float a, float b, float sa, float sb, float e )\n{\n\te = min( e, min( a, b ) * 0.5 ); // e is the half lenght of smooth transitions\n\tfloat period = a + b;\n\tfloat h = sa * a + sb * b;\n\tfloat n = floor( x / period );\n\tx -= n * period;\n//#if 1\n\tvec2 M = vec2( a, sa * a );\n\tvec2 F = vec2( a + b, h );\n\tvec2 A = vec2( 0, 0 );\n\tvec2 B = A + vec2( e, sa * e );\n\tvec2 C = M - vec2( e, sa * e );\n\tvec2 D = M + vec2( e, sb * e );\n\tvec2 E = F - vec2( e, sb * e );\n\tfloat y = n * h;\n\tif ( x < B.x ) y += cubicstep2( x, A + ( E - F ), B, sb, sa );\n\telse if ( x < C.x ) y += linearstep2( x, B, sa );\n\telse if ( x < D.x ) y += cubicstep2( x, C, D, sa, sb );\n\telse if ( x < E.x ) y += linearstep2( x, D, sb );\n\telse y += cubicstep2( x, E, F + ( B - A ), sb, sa );\n\tfloat section_b = min( smoothstep( C.x, D.x, x ), 1. - smoothstep( E.x, F.x + B.x - A.x, x ) )\n\t+ 1.0 - smoothstep( A.x + E.x - F.x, B.x, x );\n\treturn vec4( y, section_b, n, smoothstep( D.x, E.x, x ) ); // w: flight begin and end for lane transitions\n//#endif\n//\t// the function above if it was just piecewise linear\n//\tif ( x < a ) x *= sa; else x = sa * a + ( x - a ) * sb;\n//\treturn vec4( x + n * h, 0, n, 0 );\n}\n\n// get the args for getCameraPathx, with a travel lengh l and speed in input\nvec2 get_duration_and_slope( float l, float speed ) { float t = l / speed; return vec2( t, sqrt( max( l * l - t * t, 0. ) ) / t ); }\n\nmat4 walkAndFlyCamera( float tan_half_fovy, float aTime, vec4 aDate, vec3 aResolution, vec4 aMouse )\n{\n#if 1\n\tvec2 aa = get_duration_and_slope( 2.82, 1.41 );\n\tvec2 bb = get_duration_and_slope( 11.34, 7.56 );\n\tfloat te = 0.4;\n\tvec4 vv = getCameraPathx( te + aTime * 0.07, aa.x, bb.x, aa.y, bb.y, te ); // vv.y = is fly mode amount\n\tfloat lane_index = FIRST_LANE_INDEX;\n\tlane_index += vv.z;\n\tLanePoint pp_next = getPathPointAndDir( vv.x, lane_index+1.0 );\n\tLanePoint pp = getPathPointAndDir( vv.x, lane_index );\n\t// lerp with the next lane\n\tpp.p = mix(pp.p,pp_next.p,vv.w);\n\tpp.lane_index = mix(pp.lane_index,pp_next.lane_index,vv.w);\n\tpp.tangent2d = normalize(mix(pp.tangent2d,pp_next.tangent2d,vv.w));\n\t// lerp with straight curve corresponding to that (now blending) lane\n\tfloat alt = 1.;\n\tpp.p.z = mix( pp.p.z, alt, vv.y * vv.y );\n\tpp.p.y = mix( pp.p.y, ( pp.lane_index + 0.5 ) * PATH_SPACING_Y, vv.y * vv.y );\n\tpp.tangent2d = normalize( mix( pp.tangent2d, vec3( 1., 0., 0. ), vv.y ) );\n#else\n\tLanePoint pp = getPathPointAndDir( 9.8+aTime * 0.08, FIRST_LANE_INDEX ); // simple walk camera\n#endif\n\tCameraRet cam = init_cam();\n\tcam.eye = pp.p;\n\tcam.target = cam.eye + pp.tangent2d;\n\tcam.target.z -= mix(0.15,0.53, vv.y * vv.y); // this causes some roll on mouse movements as a happy side effect\n//\tcam.target.z -= 0.59 * vv.y * vv.y; // this causes some roll on mouse movements as a happy side effect\n\tmat4 camera = lookat( cam.eye, cam.target, vec3( 0., 0., 1. ) ) * z_rotation( cam.roll );\n\tfloat tilt = 0.2 * sin( aTime * 0.02 ) * vv.y * vv.y; // in flight mode add some small left-right to get some tilt when no one touches the mouse\n\tvec2 dmm = vec2( tilt, -0.35 * pow( abs( tilt ), 0.6 ) );\n\treturn look_around_mouse_control( camera, cam.pitch + dmm.y, tan_half_fovy, aResolution, aMouse, dmm.x );\n}\n\nvec2 pixelIndexToFragcoord( vec2 pixel_indexf, vec3 aResolution )\n{\n\t// note that pixelIndexToFragcoord(floor(fragCoord))==fragCoord\n\treturn aResolution.xy * ( ( vec2( 0.5 ) + pixel_indexf ) / aResolution.xy );\n}\n\nstruct CameraData { mat4 camera; float tan_half_fovy; }; // what we need to write for the reprojection\n\nCameraData GetCameraTransform( float aTime, vec4 aDate, vec3 aResolution, vec4 aMouse )\n{\n\tCameraData data;\n\n\tdata.tan_half_fovy = 0.6;\n\n#ifdef EXTRA_3D_CAMERA\n\tdata.camera = mat4( iCamera[0], iCamera[1], iCamera[2], iCamera[3] );\n\tdata.tan_half_fovy = iTanHalfFovy;\n#else\n\tdata.camera = walkAndFlyCamera( data.tan_half_fovy, aTime, aDate, aResolution, aMouse );\n#endif\n\treturn data;\n}\n\nvec3 mat_project_vector( vec3 v, mat4 camera ) { return vec3( dot( v, camera[0].xyz ), dot( v, camera[1].xyz ), dot( v, camera[2].xyz ) ); }\nvec3 mat_project_point_dir( vec3 p, mat4 camera ) { return normalize( mat_project_vector( p - camera[3].xyz, camera ) ); }\n\n// get subpixel index, 2x2 for now\nivec2 SubpixelIndex( int aFrame ) { aFrame &= 3; return ivec2( aFrame & 1, aFrame >> 1 ); }\n\nvec2 NumSubpixels( vec3 aResolution ) { return aResolution.xy / 2.0; }\n\nCameraData readCameraData( ivec2 offset, vec3 aResolution, sampler2D aChannel1 )\n{\n\tCameraData data;\n#if 0\n\tfloat y = offset.x + 2.0 * offset.y;\n\tdata.camera[0] = vec4( texture( aChannel1, ( vec2( 0.5 ) + vec2( 0, y ) ) / aResolution.xy, 0 ).xyz, 0 );\n\tdata.camera[1] = vec4( texture( aChannel1, ( vec2( 0.5 ) + vec2( 1, y ) ) / aResolution.xy, 0 ).xyz, 0 );\n\tdata.camera[2] = vec4( texture( aChannel1, ( vec2( 0.5 ) + vec2( 2, y ) ) / aResolution.xy, 0 ).xyz, 0 );\n\tdata.camera[3] = vec4( texture( aChannel1, ( vec2( 0.5 ) + vec2( 3, y ) ) / aResolution.xy, 0 ).xyz, 1 );\n\tdata.tan_half_fovy = texture( aChannel1, ( vec2( 0.5 ) + vec2( 4, y ) ) / aResolution.xy, 0 ).x;\n#else\n\tint y = offset.x + 2 * offset.y;\n\tdata.camera[0] = texelFetch( aChannel1, ivec2( 0, y ), 0 );\n\tdata.camera[1] = texelFetch( aChannel1, ivec2( 1, y ), 0 );\n\tdata.camera[2] = texelFetch( aChannel1, ivec2( 2, y ), 0 );\n\tdata.camera[3] = texelFetch( aChannel1, ivec2( 3, y ), 0 );\n\tdata.tan_half_fovy = texelFetch( aChannel1, ivec2( 4, y ), 0 ).x;\n#endif\n\treturn data;\n}\n\nvec4 mainScene( vec2 fragCoord, float aTime, vec4 aDate, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel1\n\t\t\t\t, out vec4 ppd )\n{\n\tfloat aspect = aResolution.x / aResolution.y;\n\tvec2 uv = fragCoord.xy / aResolution.xy;\n\n\tvec2 pixel = fragCoord.xy;\n\tvec4 fragColor = vec4( 0.0 );\n\n#if 1\n\tCameraData camera_data = GetCameraTransform( aTime, aDate, aResolution, aMouse );\n#else\n\tivec2 offset0 = SubpixelIndex( aFrame - 0 ); // I think we get previous frame because double buffer so doesn't work as is\n\tCameraData camera_data = readCameraData( offset0, aResolution, aChannel1 );\n#endif\n\n\tRay view_ray = get_view_ray2( ( uv - vec2( 0.5 ) ) * 2.0, aspect, 1.0 / camera_data.tan_half_fovy, camera_data.camera );\n\tfloat ao = 1.0;\n\n\tvec3 sun_direction = get_sun_direction( aTime );\n\tbool sky = false;\n\tfloat shadow = 1.0;\n\tTraceOutput to;\n\tvec3 p2;\n\tvec3 n;\n\tSceneOut eval_for_shade;\n\tSceneOutInit( eval_for_shade );\n    Ray trace_ray = view_ray;\n\tint trace_flags = TRACE_VIEW;\n\tint max_iterations = MAX_ITERATIONS_VIEW; \n\tfloat tmaxmax = TMAX_VIEW;\n\n\t// force a loop on view ray, shadow ray to prevent shadertoy compilation abject unrolling horror\n\tfor ( int pass = 0 FORCE_LOOP; pass < (SHADOWS?2:1); ++pass )\n\t{\n\t\tTraceOutput tmp_to = traceScene( trace_ray, 5.0, trace_flags, max_iterations, TFRAC, tmaxmax, DBREAK\n\t\t\t\t\t\t\t\t\t\t , uv, fragCoord, aFrame, aTime );\n\t\tif ( pass == 1 )\n\t\t{\n\t\t\t//shadow = ( tmp_to.t > TMAX_SHADOW ? 1 : 0 ); // check hard shadows\n\t\t\t//shadow = tmp_to.shadow; // default soft shadows, don't work well with this scene\n\t\t\tshadow = mix( 0.05, 1.0, smoothstep( 0.4, 0.6, tmp_to.shadow ) ); // take a threshold on default soft shadows, good for sunny setting\n\t\t\tbreak;\n\t\t}\n\n\t\t// only view rays make it here... \n\n\t\tto = tmp_to;\n\t\tp2 = view_ray.o + to.t * view_ray.d;\n\t\tsky = to.t > TMAX_VIEW;\n\n\t\tif ( sky ) break;\n\t\t\n\t\t// only view rays that hit solid surfaces make it here...\n\n\t\t// we need to evaluate normal vector at hit point, we will also retrieve extra material calculations\n\t\tSceneIn scenein;\n\t\tscenein.p = p2;\n\t\tSetSceneInDirectionless( scenein, TRACE_SHADE );\n\t\tscenein.t = 0.0;\n\n\t\t{\n\t\t\t// to set this epsilon, set the camera at 1000 and check fence and terrain normal...\n\t\t\t// it should look the same as 0,0,0...\n\t\t\tfloat e = 1e-3 * 2.;\n\t\t\tvec4 v; // center in .w, deltas in .xyz\n#if 0\n\t\t\tSceneIn scenein2 = scenein;\n\t\t\tscenein2.p = scenein.p + vec3( e, 0.0, 0.0 ); v.x = evalScene( scenein2, aFrame, aTime ).object_di.d;\n\t\t\tscenein2.p = scenein.p + vec3( 0.0, e, 0.0 ); v.y = evalScene( scenein2, aFrame, aTime ).object_di.d;\n\t\t\tscenein2.p = scenein.p + vec3( 0.0, 0.0, e ); v.z = evalScene( scenein2, aFrame, aTime ).object_di.d;\n\t\t\teval_for_shade = evalScene( scenein, aFrame, aTime );\n\t\t\tv.w = eval_for_shade.object_di.d;\n#else\n\t\t\t// force a loop on gradient eval to prevent shadertoy compilation abject unrolling horror\n\t\t\tfor ( int i = 0 FORCE_LOOP; i < 4; ++i )\n\t\t\t{\n\t\t\t\tSceneIn scenein2 = scenein;\n\t\t\t\tif ( i != 3 ) scenein2.p[i] += e; // let's live dangerously and use vector component random access\n\t\t\t\teval_for_shade = evalScene( scenein2, aFrame, aTime ); // note: eval_for_shade contains material data at center, at the end of the loop\n\t\t\t\tv[i] = eval_for_shade.object_di.d;\n\t\t\t}\n#endif\n\t\t\tn = normalize( v.xyz - vec3( v.w ) );\n\t\t}\n\n\t\tif ( AO )\n\t\t{\n\t\t\tSceneIn scenein2 = scenein;\n\t\t\tSetSceneInDirection( scenein2, p2, n, TRACE_AO );  // shouldn't change anything\n\n\t\t\t// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n\t\t\tfloat delta = 0.1;\n\t\t\tfloat a = 0.0;\n\t\t\tfloat b = 1.0;\n\t\t\tfor ( int i = 0 FORCE_LOOP; i < 4; i++)\n\t\t\t{\n\t\t\t\tfloat fi = float( i );\n\t\t\t\tscenein2.p = p2 + n * delta * fi;\n\t\t\t\tfloat d = evalScene( scenein2, aFrame, aTime ).object_di.d;\n\t\t\t\ta += ( delta * fi - d ) * b;\n\t\t\t\tb *= 0.5;\n\t\t\t}\n\t\t\tao = max( 1.0 - 1.8 * a, 0.0 );\n\t\t}\n\n\t\tif ( SHADOWS )\n\t\t{\n\t\t\t// hack: use a different normal offset for trees as noise shadows are very sensitive to that\n\t\t\tvec4 mm4 = DecodeId_5_5_5( eval_for_shade.object_di );\n\t\t\tfloat tree_ao = 1.0;\n\t\t\tif ( (mm4.x == MATID_TREE) || (mm4.x == MATID_PINE) )\n\t\t\t{\n\t\t\t\ttree_ao += 1.0 - smoothstep( 0.2, 0.5, mm4.z );\n\t\t\t\ttree_ao -= smoothstep( -0.2, 0.0, dot( sun_direction, n ) );\n\t\t\t\ttree_ao = saturate( tree_ao );\n\t\t\t}\n\n\t\t\t// note: because of surface noise, tweaking the shadow ray normal bias has a lot of impact on vegetation\n\t\t\t// might want to tweak it per surface too\n\t\t\ttrace_ray = mkray( p2 + n * mix( 0.004, 0.0005, tree_ao ), sun_direction ); // if bias is too small here tree shadows become shitty\n\t\t\ttrace_flags = TRACE_SHADOW;\n\t\t\tmax_iterations = MAX_ITERATIONS_SHADOW;\n\t\t\ttmaxmax = TMAX_SHADOW;\n\t\t}\n\t}\n\n\tfragColor.rgb = shadeSample( view_ray.o, view_ray.d, camera_data.camera, p2\n\t\t\t\t\t\t\t\t , n, sun_direction, shadow, to, ao, uv, eval_for_shade, sky, aChannel1, aResolution, aTime );\n\n\tppd = sunGlareCoords( camera_data.camera, view_ray.d, sun_direction );\n\n\tfragColor.a = to.t; // write depth in .w to recover the world position in reprojection\n\n\treturn fragColor;\n}\n\n#if BUFFER_MODE==0\nvec4 Mode0_NoBuffer_mainImage( vec2 fragCoord, float aTime, vec4 aDate, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel1 )\n{\n\tvec4 ppd;\n\tvec4 col = mainScene( fragCoord, aTime, aDate, aResolution, aFrame, aMouse, aChannel1, ppd );\n\tcol.rgb = postProcess( col.rgb, fragCoord / aResolution.xy, ppd );\n\treturn col;\n}\n#endif\n\n#if BUFFER_MODE==2\n\n// write camera\nvec4 Mode2_Reproject_mainBufferB( vec2 fragCoord, float aTime, vec4 aDate, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel0, sampler2D aChannel1 )\n{\n\tvec2 pi = floor( fragCoord );\n\tvec4 background = texelFetch( aChannel1, ivec2( pi ), 0 );\n\n\tif ( ( pi.y > 3.0 ) || \n\t\t ( pi.x > 4.0 ) ) \n\t{\n\t\tvec4 skybox = background;\n\n\t\tivec2 res_addr = ivec2( 5, 0 ); // store position for resolution\n\n\t\tif ( ( CLOUD_MODE > 1 ) &&\n\t\t\t ( ( CLOUD_MODE == 2 ) // always\n\t\t\t   || ( aFrame <= 1 ) // on first frame\n\t\t\t   || ( texelFetch( aChannel1, res_addr, 0 ).xy != vec2( aResolution.xy ) ) ) ) // on resolution change\n\t\t{\n\t\t\tif ( pi == vec2(res_addr) ) return vec4( aResolution.xy, 0, 0 );\n\t\t\t\n\t\t\tvec2 p = fragCoord / aResolution.y;\n\t\t\tif ( p.x > 1. || p.y > 1. ) skybox.xyz = MAGENTA;\n\t\t\telse\n\t\t\t{\n\t\t\t\tskybox.xyz = vec3( p,0 ); //vec3( traceClouds( n ) );\n\t\t\t\tp -= vec2( 0.5 );\n\t\t\t\tfloat r = length( p );\n\t\t\t\tvec3 n = zup_spherical_coords_to_vector( r052theta( r ), calc_angle( p ) ); // only care about theta in [0,PI/2]\n\t\t\t\tskybox.xyz = traceClouds( n, aTime );\n\t\t\t\tif ( r > 0.5 ) skybox.xyz = RED;\n\t\t\t\t//skybox = vec4( get_sky( n, vec3( 0 ) ).w, 0 );\n\t\t\t}\n\t\t}\n\n\t\tif ( CLOUD_MODE <= 1 ) skybox.xyz = MAGENTA;\n\n\t\treturn skybox; // unused area, we use the bottom (3*4,4) pixels\n\t}\n\n\tvec2 offset = vec2( SubpixelIndex( aFrame ) );\n\tfloat y = offset.x + 2.0 * offset.y; // subpixel flat index\n\t\n\tif ( pi.y == y )\n\t{\n\t\tCameraData data = GetCameraTransform( aTime, aDate, aResolution, aMouse );\n\t\tif ( pi.x == 0.0 ) return vec4( data.camera[0].xyz, 1 );\t   // return vec4( RED, 1 );    \n\t\tif ( pi.x == 1.0 ) return vec4( data.camera[1].xyz, 1 );\t   // return vec4( GREEN, 1 );  \n\t\tif ( pi.x == 2.0 ) return vec4( data.camera[2].xyz, 1 );\t   // return vec4( BLUE, 1 );   \n\t\tif ( pi.x == 3.0 ) return vec4( data.camera[3].xyz, 1 );\t   // return vec4( YELLOW, 1 ); \n\t\tif ( pi.x == 4.0 ) return vec4( data.tan_half_fovy, 0, 0, 1 ); // return vec4( MAGENTA, 1 );\n\t}\n\treturn background; // no touch = copy old data - we need to do that because shadertoy double buffers\n}\n\n// write each subpixel in its respective quadrant\nvec4 Mode2_Reproject_mainBufferA( vec2 fragCoord, float aTime, vec4 aDate, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel0, sampler2D aChannel1 )\n{\n\tivec2 hres = ivec2( aResolution.xy ) / 2;\n\tivec2 offset = SubpixelIndex( aFrame );\n\tivec2 pi = ivec2( floor( fragCoord ) );\n\tivec2 pi0 = pi;\n\t// gather for coherency (make 4 quadrant, each having a full scene, instead of pixel all top pixels in 4)\n\tif ( offset != ( pi / hres ) ) // quadrant this pixel is in\n\t{\n\t\treturn texelFetch( aChannel0, pi, 0 ); // no touch = copy old data - we need to do that because shadertoy double buffers\n\t}\n\tpi = ( pi - offset * hres ) * 2; // also clears offset lower bits\n\tfragCoord = pixelIndexToFragcoord( vec2( pi + offset ), aResolution );\n//\treturn vec4( offset, 0., 1. ); // quadrant debug color\n\tvec4 ppd;\n\treturn mainScene( fragCoord, aTime, aDate, aResolution, aFrame, aMouse, aChannel1, ppd );\n}\n\n// input uv maps 0,1 to screen\nvec2 applySubPixelOffsetTo01UV( vec2 uv, vec2 offseti, vec3 aResolution )\n{\n\t// important: since we sample the *center* of the top level pixel,\n\t// we want the *corner* of the corresponding subpixel in the quadrant image\n\t// (so offset by half the quadrant offset)\n\t// without that the image is much blurrier than it should\n\t// besides, the chance I got this wroing somewhere is high :-D\n\tuv -= ( offseti - vec2( 0.5 ) ) / aResolution.xy;\n\treturn ( uv + vec2( offseti ) ) * 0.5;\n}\n\nfloat reprojected( vec3 p, ivec2 offseti, CameraData cdati, vec3 aResolution, out vec4 ret, out Ray view_ray, sampler2D aChannel0 )\n{\n\tfloat aspect = aResolution.x / aResolution.y;\n//\tCameraData cdati = readCameraData( offseti, aResolution ); // passed from caller\n\tvec3 v = mat_project_point_dir( p, cdati.camera ); // ray direction in the older camera\n\tview_ray.d = v;\n\tview_ray.o = cdati.camera[3].xyz;\n\tfloat t = plane_trace_z( v, -1.0 / cdati.tan_half_fovy, 1e-3 );\n\tvec2 uv = ( v * t ).xy;\n\tuv.x /= aspect;\n\tuv = ( uv + vec2( 1.0 ) ) * 0.5;\n\tvec2 uvcheck = uv; // before going to quadrant uv, store the 01 range uv to do a uv range check see if our sampled thing is valid...\n\tuv = applySubPixelOffsetTo01UV( uv, vec2(offseti), aResolution );\n\tif ( ( t < 0.0 ) || ( t == FLT_MAX ) || ( saturate( uvcheck ) != uvcheck ) ) return 0.0;\n#if 0\n\tret = texture( aChannel0, uv );\n#else\n#if 0\n\tivec2 pmin = ivec2( 0, 0 );\n\tivec2 pmax = ivec2( aResolution.xy ) - ivec2( 1, 1 );\n#else\n\t// deal with borders\n\tivec2 pmin = offseti * ivec2( aResolution.xy ) / 2;\n\tivec2 pmax = pmin + ivec2( aResolution.xy ) / 2 - ivec2( 1, 1 );\n#endif\n\t// bilinear by hand so we can exclude samples and/or clamp borders properly\n\tvec2 pi = uv * aResolution.xy - vec2( 0.5 );\n\tivec2 i = ivec2( floor( pi ) );\n\tvec2 f = fract( pi );\n\tvec4 v00 = texelFetch( aChannel0, clamp( i + ivec2( 0, 0 ), pmin, pmax ), 0 ); // return im0;\n\tvec4 v10 = texelFetch( aChannel0, clamp( i + ivec2( 1, 0 ), pmin, pmax ), 0 );\n\tvec4 v01 = texelFetch( aChannel0, clamp( i + ivec2( 0, 1 ), pmin, pmax ), 0 );\n\tvec4 v11 = texelFetch( aChannel0, clamp( i + ivec2( 1, 1 ), pmin, pmax ), 0 );\n#if 1\n\tvec4 A = v10 - v00;\n\tvec4 B = v01 - v00;\n\tvec4 C = ( v11 - v01 ) - A;\n\tvec4 D = v00;\n\tret = A * f.x + B * f.y + C * f.x * f.y + D;\n#else\n\tret = mix( mix( v00, v10, f.x ), mix( v01, v11, f.x ), f.y );\n#endif\n#endif\n//\tret = vec4(uvcheck,0,1);\n\treturn 1.0;\n}\n\n// combine images history\nvec4 Mode2_Reproject_mainImage( vec2 fragCoord, float aTime, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel0, sampler2D aChannel1, out vec4 ppd )\n{\n\tivec2 hres = ivec2( aResolution.xy ) / 2;\n\tivec2 pi = ivec2( floor( fragCoord ) );\n\tivec2 offset0 = SubpixelIndex( aFrame - 0 ); // this frame\n\tivec2 offset1 = SubpixelIndex( aFrame - 1 ); // previous frame\n\tivec2 offset2 = SubpixelIndex( aFrame - 2 ); // previous previous frame\n\tivec2 offset3 = SubpixelIndex( aFrame - 3 );\n\tCameraData cdat0 = readCameraData( offset0, aResolution, aChannel1 );\n\tCameraData cdat1 = readCameraData( offset1, aResolution, aChannel1 );\n\tCameraData cdat2 = readCameraData( offset2, aResolution, aChannel1 );\n\tCameraData cdat3 = readCameraData( offset3, aResolution, aChannel1 );\n\t// reprojection code path\n\t// we need to be careful here... the point we reproject is the center of the quadrant,\n\t// the regular raytraced position if we were fullscreen, because it is the only point\n\t// that is common to all quadrants and the only point that will give us a stable image\n\t// with 4 last frames (without accumulating)\n\tvec2 uv = fragCoord / aResolution.xy;\n\tfloat aspect = aResolution.x / aResolution.y;\n\tRay view_ray0 = get_view_ray2( ( uv - vec2( 0.5 ) ) * 2.0, aspect, 1.0 / cdat0.tan_half_fovy, cdat0.camera );\n\tvec2 uv0 = applySubPixelOffsetTo01UV( uv, vec2(offset0), aResolution );\n\tvec4 im0 = texture( aChannel0, uv0 );\n//\treturn im0; // this one is always good, we have just calculated it\n\tvec3 p0 = view_ray0.o + view_ray0.d * im0.w; // the most recent world point we have\n\tvec4 im1, im2, im3;\n\tvec3 valid;\n\tRay view_ray1, view_ray2, view_ray3;\n\tvalid.x = reprojected( p0, offset1, cdat1, aResolution, im1, view_ray1, aChannel0 ); vec3 p1 = view_ray1.o + view_ray1.d * im1.w;\n\tvalid.y = reprojected( p0, offset2, cdat2, aResolution, im2, view_ray2, aChannel0 ); vec3 p2 = view_ray2.o + view_ray2.d * im2.w;\n\tvalid.z = reprojected( p0, offset3, cdat3, aResolution, im3, view_ray3, aChannel0 ); vec3 p3 = view_ray3.o + view_ray3.d * im3.w;\n\tvec4 w = vec4( 1.0 );\n\tw.yzw = valid.xyz;\n\tvec4 col = ( im0 * w.x + im1 * w.y + im2 * w.z + im3 * w.w ) / sum( w ); // note: don't preprocess here\n\tif ( SUN_GLARE ) ppd = sunGlareCoords( cdat0.camera, view_ray0.d, get_sun_direction( aTime ) ); // pass this to post processing\n\treturn col;\n}\n\n#endif\n\n#if BUFFER_MODE==0\n #define BUFFERB void mainImage( out vec4 fragColor, in vec2 fragCoord ) { }\n #define BUFFERA void mainImage( out vec4 fragColor, in vec2 fragCoord ) { }\n #define IMAGE void mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = Mode0_NoBuffer_mainImage( fragCoord, iTime, iDate, iResolution, iFrame, iMouse , iChannel1); }\n#elif BUFFER_MODE==2\n #define BUFFERB void mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = Mode2_Reproject_mainBufferB( fragCoord, iTime, iDate, iResolution, iFrame, iMouse , iChannel0, iChannel1); }\n #define BUFFERA void mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = Mode2_Reproject_mainBufferA( fragCoord, iTime, iDate, iResolution, iFrame, iMouse , iChannel0, iChannel1); }\n #define IMAGE \\\n  void mainImage( out vec4 fragColor, in vec2 fragCoord ) \\\n  { \\\n\t  vec4 ppd; \\\n\t  fragColor = Mode2_Reproject_mainImage( fragCoord, iTime, iResolution, iFrame, iMouse, iChannel0, iChannel1, ppd ); \\\n\t  fragColor.rgb = postProcess( fragColor.rgb, fragCoord / iResolution.xy, ppd ); \\\n\t  fragColor.a = 0.; /* remember we have the depth in alpha, png save will go weird so clear */ \\\n  }\n#endif\n", "buffer_a_code": "BUFFERA", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "BUFFERB", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXXzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NdfXRX", "name": "Shader Three js", "author": "hitaboy", "description": "Shader to threejs test", "tags": ["threejs"], "likes": 10, "viewed": 888, "published": 3, "date": "1618924974", "time_retrieved": "2024-07-30T19:24:48.351896", "image_code": "\nvec3 palette(float i)\n{\n\tif(i<4.0)\n\t{\n\t\tif(i<2.0)\n\t\t{\n\t\t\tif(i<1.0) return vec3(0.0,0.0,0.0);\n\t\t\telse return vec3(1.0,3.0,31.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(i<3.0) return vec3(1.0,3.0,53.0);\n\t\t\telse return vec3(28.0,2.0,78.0);\n\t\t}\n\t}\n\telse if(i<8.0)\n\t{\n\t\tif(i<6.0)\n\t\t{\n\t\t\tif(i<5.0) return vec3(80.0,2.0,110.0);\n\t\t\telse return vec3(143.0,3.0,133.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(i<7.0) return vec3(181.0,3.0,103.0);\n\t\t\telse return vec3(229.0,3.0,46.0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(i<10.0)\n\t\t{\n\t\t\tif(i<9.0) return vec3(252.0,73.0,31.0);\n\t\t\telse return vec3(253.0,173.0,81.0);\n\t\t}\n\t\telse if(i<12.0)\n\t\t{\n\t\t\tif(i<11.0) return vec3(254.0,244.0,139.0);\n\t\t\telse return vec3(239.0,254.0,203.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn vec3(242.0,255.0,236.0);\n\t\t}\n\t}\n}\n\n\nvec4 colour(float c)\n{\n\tc*=12.0;\n\tvec3 col1=palette(c)/256.0;\n\tvec3 col2=palette(c+1.0)/256.0;\n\treturn vec4(mix(col1,col2,c-floor(c)),1.0);\n}\n\nfloat periodic(float x,float period,float dutycycle)\n{\n\tx/=period;\n\tx=abs(x-floor(x)-0.5)-dutycycle*0.5;\n\treturn x*period;\n}\n\nfloat pcount(float x,float period)\n{\n\treturn floor(x/period);\n}\n\nfloat distfunc(vec3 pos)\n{\n\tvec3 gridpos=pos-floor(pos)-0.5;\n\tfloat r=length(pos.xy);\n\tfloat a=atan(pos.y,pos.x);\n\ta+=iTime*0.3*sin(pcount(r,3.0)+1.0)*sin(pcount(pos.z,1.0)*13.73);\n\treturn min(max(max(\n\tperiodic(r,3.0,0.2),\n\tperiodic(pos.z,1.0,0.7+0.3*cos(iTime/3.0))),\n\tperiodic(a*r,3.141592*2.0/6.0*r,0.7+0.3*cos(iTime/3.0))),\n\t0.25);\n\t//return max(length(gridpos)-0.5,\n\t//\t  abs(r-floor(r)-0.5)-0.1);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 pos, in vec3 dir)\n{\n\tvec3 ray_dir=-dir;\n\tvec3 ray_pos=pos;\n\n\tfloat a=cos(iTime)*0.0*0.4;\n\tray_dir=ray_dir*mat3(\n\t\tcos(a),0.0,sin(a),\n\t\t0.0,1.0,0.0,\n\t\t-sin(a),0.0,cos(a)\n\t);\n\n\tfloat i=192.0;\n\tfor(int j=0;j<192;j++)\n\t{\n\t\tfloat dist=distfunc(ray_pos);\n\t\tray_pos+=dist*ray_dir;\n\n\t\tif(abs(dist)<0.001) { i=float(j); break; }\n\t}\n\n\tfloat c=i/192.0;\n\tfragColor=colour(c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 coords=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\n\tvec3 ray_dir=normalize(vec3(coords,1.0+0.0*sqrt(coords.x*coords.x+coords.y*coords.y)));\n\tvec3 ray_pos=vec3(0.0,-1.0,iTime*1.0);\n\n\n    mainVR(fragColor, fragCoord, ray_pos, -ray_dir);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 722], [725, 725, 747, 747, 866], [868, 868, 922, 922, 992], [994, 994, 1030, 1030, 1057], [1059, 1059, 1085, 1085, 1464], [1466, 1466, 1544, 1544, 1890], [1893, 1893, 1949, 1949, 2217]], "test": "untested"}
{"id": "fdXXRX", "name": "isolines radial gradient", "author": "FabriceNeyret2", "description": "SPACE to toggle turbulence vs bozo noise.\nusing 1pix-width lines drawing + lines density gradient.  switch #8 for wrong-but-nice isolines.\nflownoise variant of [url]https://shadertoy.com/view/NdXXRj[/url] balanced isolines.", "tags": ["procedural", "noise", "perlin"], "likes": 19, "viewed": 624, "published": 3, "date": "1618922837", "time_retrieved": "2024-07-30T19:24:49.197635", "image_code": "// variant of https://shadertoy.com/view/fdXXR2\n// gradient + 1pix-width lines + flownoise variant of https://shadertoy.com/view/NdXXRj\n// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. ) \\\n                    *  mat2(cos(iTime+vec4(0,11,33,0)))\n  #define draw(v,d)    clamp(1. - abs( fract(v-.5) - .5 ) / (d), 0.,1.) // correct version\n//#define draw(v,d)    clamp(1. - abs( fract(v   ) - .5 ) / (d), 0.,1.) // nicer here :-)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n//#define func( P )  ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n  #define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, dl, f = func(P), df, w;\n#if 0\n    l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));              // subvid amount (relative)\n    dl =     fract(log2(2.*fwidth(P.x)/fwidth(f)));      \n#else\n    l = exp2(floor(log2(1./22./fwidth(f))));                      // subvid amount (absolute)\n    dl =     fract(log2(1./22./fwidth(f)));\n#endif\n\n    U -= .5*R/R.y;\n    w = .5*( 1.1+sin( 4.*(dot(U,U)-iTime)) );\n    f *= w;\n // f *= exp(- 4.* dot(U,U));\n // f *= max(.1, 1.-4.*dot(U,U));\n#if 0                                                             // draw isolines using sin\n    O = vec4(.5+.5*  mix( sin(50.*l*f) , sin(100.*l*f), dl ) ) * hue(6.*l); \n#else                                                             // draw isolines \n    df = fwidth(f);\n // df = length( ( vec2( func(P + eps.xy), func(P + eps.yx) )*w -f ) / eps.x )*fwidth(P.x);\n    l *= 8.; \n    O += mix( draw(    f*l,    l*df ),\n              draw( 2.*f*l, 2.*l*df ),\n              dl ) * hue(6.*l);\n#endif\n    \n    O = sqrt(O);                                                  // to sRGB\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXXRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[881, 881, 904, 904, 1197], [1199, 1199, 1223, 1278, 1437], [1439, 1439, 1477, 1477, 2664]], "test": "untested"}
{"id": "sdlSR2", "name": "", "author": "AFStar", "description": ",apihttps://www.shadertoy.com/view/4syGWK\n\nGenerate a distance field from an image", "tags": ["2d", "distance"], "likes": 0, "viewed": 244, "published": 3, "date": "1618906267", "time_retrieved": "2024-07-30T19:24:50.022430", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2(iResolution.x / iResolution.y,1.0); \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2.0 - 1.0) * aspect;    \n    vec2 nearest = texture(iChannel1,fragCoord.xy / iResolution.xy).xy / iResolution.xy;\n    vec2 p = (nearest * 2.0 - 1.0) * aspect;\n    float d = length(uv - p) * 5.;// * iMouse.x * 0.05;\n    fragColor = vec4(nearest,0.0, 1.0);\n    fragColor = vec4(d);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 uv = fragCoord / iResolution.xy;\n        vec4 color = texture(iChannel1,uv);\n     \n        fragColor=color;\n\n}\n\n", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 load0(ivec2 p) {\n    vec2 uv = (vec2(p)-0.5) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float nb = iMouse.y / iResolution.y;\n    float iter = mod(float(iFrame),500.0) / 50.;\n    if (iter < 0.5) {\n        vec2 uv = fragCoord / iResolution.xy;\n        //uv.x = clamp(uv.x * iResolution.x / iResolution.y, 0.0, 1.0);\n        vec4 color = texture(iChannel1,uv);\n        float lum = step(color.r,0.5);\n        if (lum < 0.4) {\n            fragColor=vec4(fragCoord,0.0,0.0);\n        } else {\n            fragColor= vec4(0.0);\n        }\n    } else {\n        float level = clamp(iter-1.0,0.0,11.0);\n        int stepwidth = int(exp2(11.0 - level)+0.5);        \n        ivec2 tc = ivec2(fragCoord + 0.5);        \n        float best_dist = 999999.0;\n        vec2 best_coord = vec2(0.0);\n        vec2 center = vec2(tc);\n        for (int y = -1; y <= 1; ++y) {\n            for (int x = -1; x <= 1; ++x) {\n                ivec2 fc = tc + ivec2(x,y)*stepwidth;\n\t\t        vec2 ntc = load0(fc).xy;\n                float d = length(ntc - center);\n                if ((ntc.x != 0.0) && (ntc.y != 0.0) && (d < best_dist)) {\n                    best_dist = d;\n                    best_coord = ntc;\n                }\n            }\n        }        \n        fragColor=vec4(best_coord,0.0,0.0);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlSR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 456]], "test": "untested"}
{"id": "fssXzj", "name": "Molten Neon", "author": "Tater", "description": "Wanted to make something with reflections, I think it turned out ok.", "tags": ["raymarching", "sdf", "glow", "vaporwave", "relfections"], "likes": 19, "viewed": 601, "published": 3, "date": "1618904757", "time_retrieved": "2024-07-30T19:24:50.973886", "image_code": "#define MDIST 120.0\n#define STEPS 164.0\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define sat(a) clamp(a,0.0,1.0)\n#define pi 3.141592\nvec3 col3 (vec3 col,float index){\n    if(index==1.0)col.rg=1.0-col.rg;\n    if(index==2.0)col.gb=1.0-col.gb;\n    return col;\n}\nfloat timeRemap2 (float t, float s1, float s2, float c){\n    return 0.5*((s1-s2)*sqrt(c*c+1.0)*asin((c*cos(pi*t))/ sqrt(c*c+1.0))+(s1+s2)*c*t*pi)/(c*pi);\n}\nfloat SU( float d1, float d2, float k ) {\n    float h = sat( 0.5 + 0.5*(d2-d1)/k);    \n    return mix( d2, d1, h ) - k*h*(1.0-h);   \n} \nfloat box( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) -0.3;\n}\nvec3 glw = vec3(0);\nfloat map2(vec3 p){\n    float a = length(p-vec3(0,sin(iTime)*4.0,0))-1.5;\n    glw +=(0.01/(0.01+a*a))*vec3(0.867,0.000,0.259);\n    float b = box(p,vec3(0.6,15.5,0.5))*0.9;\n    a = min(a,b);\n    return a;\n}\nfloat map(vec3 p){\n    vec3 np = p;\n    float t = mod(iTime+7.2,200.0);\n    float anim = smoothstep(-.2,.2,sin(t*0.5));\n    \n    \n    float s1 = 8.5;\n    float s2 = 1.0;\n    t = timeRemap2(t/(2.0*pi),s1,s2,10.0);//amazing\n    \n    np.xy*=rot(mod(t,2.0*pi+pi)*anim*0.2);\n    \n    float modd = 55.0+anim*400.0;//Banish the extra versions when it expands\n    \n    //vec2 id = abs(floor((p.xz+modd/2.0)/modd));\n    \n    np.xz = mod(np.xz+0.5*modd,modd)-0.5*modd;\n    np = abs(np)-vec3(0,0,anim*30.0);\n    np.x = abs(np.x)-(20.0*anim);\n    \n    np*=1.0-anim*0.3;\n    \n    t = floor(t)+pow(fract(t),2.0-anim*1.0);\n    for(int i = 0; i< 5; i++){\n        np = abs(np)-vec3(1.5+4.5*anim);\n        np.xy*=rot(0.3+t*0.7*1.1);\n        np.zy*=rot(0.5+t*0.7*1.1);\n    }\n    \n    float a = map2(np);\n    float b = p.y+3.0;\n    a = SU(a,b,1.0);\n    \n    b = length(p-vec3(0,-4.5+anim*10.0,0))-9.0;\n    glw +=0.01/(0.01+b*b)*vec3(0.035,0.690,0.000);\n    \n    a = SU(a,b,1.0);\n    float cir = 35.0;\n    t=0.5*iTime;\n    \n    vec3 ro = vec3(cir*sin(t),4.0+sin(t),cir*cos(t));\n    float camHole = length(p-ro)-5.0;\n    a = max(-camHole*0.8,a);\n    \n    return a;\n}\n\nvec3 norm(vec3 p) {\n    vec2 off=vec2(0.01,0);\n    return normalize(map(p)-vec3(map(p-off.xyy),map(p-off.yxy),map(p-off.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime*0.5;\n    float cir = 35.0;\n    vec3 ro = vec3(cir*sin(t),4.0+sin(t),cir*cos(t));\n    vec3 ro2 = ro;\n    vec3 look = vec3(0,0,0); float z = 0.7;\n    vec3 f = normalize(look-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*z+uv.x*r+uv.y*cross(f,r);\n        \n    float dO = 0.0;\n    float shad = 1.0;\n    float bnc = 0.0;\n    float dist = 0.0;\n    float dO2 = 0.;\n    vec3 p = vec3(0);\n    for(float i = 0.0; i<STEPS; i++){\n        p = ro + rd * dO;\n        float d = map(p)*0.9;\n        dO += d;\n        dO2 +=d;\n        if(dO2>MDIST || d < 0.01) {\n            shad = float(i)/(STEPS);\n            if(bnc == 0.0)dist=dO;\n            if(bnc == 1.0)break;\n            ro += rd*dO;\n            vec3 sn = norm(ro);\n            rd = reflect(rd,sn);\n            ro +=  sn*0.1;\n            dO = 0.0;\n            i=0.0;\n            bnc++;\n        }\n    }\n    col = vec3(shad)*mix(vec3(0.082,0.941,0.902),vec3(0.557,0.067,1.000),sin(dO*0.01))*4.0;\n    \n    col = mix(col,\n    mix(vec3(0.000,0.318,0.910),vec3(0.141,0.114,0.514),clamp(uv.y*2.0,0.,1.))\n    ,sat(dist/MDIST)*sat(dist/MDIST));\n    col+=glw*0.11*(1.0-sat(dist/(MDIST)));\n    col=pow(col,vec3(0.75));\n    float index = floor(mod(t*0.7,3.0));\n    //col = col3(col,index); //Uncomment for color swaps\n    //col.rb*=rot(sin(t*0.25+pi)*0.5+0.4); //actually this one is better :)\n    fragColor = vec4(col,0.0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssXzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 175, 175, 267], [268, 268, 324, 324, 423], [424, 424, 465, 465, 558], [560, 560, 588, 588, 684], [705, 705, 724, 724, 910], [911, 911, 929, 929, 2055], [2057, 2057, 2076, 2076, 2186], [2188, 2188, 2242, 2242, 3722]], "test": "untested"}
{"id": "sdlXRj", "name": "flownoise-isolined Britney stric", "author": "FabriceNeyret2", "description": "strict ribbons variant.\nSPACE to toggle turbulence vs bozo noise.\nUsing controled-by-video lines width  drawing + flownoise\nflownoise variant of [url]https://shadertoy.com/view/NdXXRj[/url] ", "tags": ["procedural", "noise", "perlin"], "likes": 7, "viewed": 451, "published": 3, "date": "1618898062", "time_retrieved": "2024-07-30T19:24:51.738840", "image_code": "// strict ribbons variant of https://shadertoy.com/view/fdXSz2\n// video-controled line width variant of https://shadertoy.com/view/NdXXRj\n// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. ) \\\n                    *  mat2(cos(iTime+vec4(0,11,33,0)))\n//#define draw(v,d,w)  clamp(1. - abs( fract(v-.5) - .5 ) / (d)/(w), 0.,1.)             // method 1: loose\n  #define draw(v,d,w)  clamp(1. - ( abs( fract(v-.5) - .5 ) -.1*(w-1.) ) / (d), 0.,1.)  // method 2: strict\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define Mix(c0,c1,v)     mix(c0,c1,v)\n//#define Mix(c0,c1,v)   vec4(c0,c1,0,0) // debug \n\n//#define func( P )  ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n  #define func( P )  ( keyToggle(32) ? noise( P ) : perlin( .5*(P) ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 4.*u/360. - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, dl, f = func(P), df, v,a;\n#if 0\n    l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));               // subvid amount (relative)\n    dl =     fract(log2(2.*fwidth(P.x)/fwidth(f)));      \n#else\n    l = exp2(floor(log2(.5/22./fwidth(f))));                       // subvid amount (absolute)\n    dl =     fract(log2(.5/22./fwidth(f)));\n#endif\n\n // f *= U.x;                                                      // draw isolines \n    df = fwidth(f);\n // df = length( vec2( ( func(P + eps.xy), func(P + eps.yx) ) -f ) / eps.x )*fwidth(P.x);\n    vec4 T = texture(iChannel0, u/R );\n    l *= 12.;\n# if 1\n    v = 4.*T.x*T.x+.1;\n#    if 0\n     O += Mix( draw(    f*l,    l*df , v ),\n               draw( 2.*f*l, 2.*l*df , v ),\n               dl );\n#    else                                          // AA: replace too thin ribbons by intensity\n     O += Mix( draw(    f*l,    l*df , max(v,1.) ),\n               draw( 2.*f*l, 2.*l*df , max(v,1.) ),\n               dl ) * min(v,1.);\n#    endif\n\n // O *= T/T.x;                                                    // color variant\n // O = mix( O, T, smoothstep(.2,.3,length(T-vec4(.14,.5,.1,1)) ));// isolines behind Britney\n // O = mix( O, T, smoothstep(.2,.4,T.x) );                        // frightening version :-p      \n\n# else                                                             // color on different layers\n#   define Draw(c,ofs)                                    \\\n      v = 3.*T.c;                                         \\\n      O.c = mix( draw(    f*l-ofs,    l*df, max(v,1.) ),  \\\n                 draw( 2.*f*l-ofs, 2.*l*df, max(v,1.) ),  \\\n                 dl ) * min(v,1.)\n    float ofs = .33;   // 0. : too subtle to see.\n    Draw(r, 0.);\n    Draw(g, ofs);\n    Draw(b, -ofs);\n# endif\n    \n    O = sqrt(O);                                                  // to sRGB\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlXRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1006, 1006, 1029, 1029, 1322], [1324, 1324, 1348, 1403, 1562], [1564, 1564, 1602, 1602, 3563]], "test": "untested"}
{"id": "fssSz2", "name": "cielo-navidad", "author": "jorge2017a1", "description": "cielo-navidad", "tags": ["cielonavidad"], "likes": 4, "viewed": 254, "published": 3, "date": "1618886574", "time_retrieved": "2024-07-30T19:24:52.699273", "image_code": "//por jorge2017a1-  19/abril/2021\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n\n//referencia snow\n//https://www.shadertoy.com/user/Catzpaw\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n\t\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    res =opU3(res, vec3(planeDist1,-1.0,6.0)); //inf\n           p.y=p.y-5.0;\n    //rotar centro origen\n     float posx=2.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xz = rotatev2(pp.xz, iTime);\n     pp.x=pp.x+posx;\n   \n    float sdrb3=  sdRoundBox( pp-vec3(posx,-3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 in\n    float sdrb3A= sdRoundBox(pp-vec3(posx,0.0,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    float sdrb3B= sdRoundBox(pp-vec3(posx,3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    \n    res =opU3(res, vec3(sdrb3,13.0,-1)); \n    res =opU3(res, vec3(sdrb3A,14.0,-1)); \n    res =opU3(res, vec3(sdrb3B,15.0,-1)); \n    \n   float sdsp1= sdSphere( p-vec3(-10.0,0.0,0.0), 6.0 );\n    res =opU3(res, vec3(sdsp1,201.0,-1)); \n    float sdsp2= sdSphere( p-vec3(14.0,3.0,10.0), 6.0 );\n   res =opU3(res, vec3(sdsp2,32.0,-1)); \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false;    minDist = dO;    break; } \n        dO += dS.x;\n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n\n///============================================================\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{   vec3 l = normalize(lp - p);\n    vec3 r = reflect(-l, n);\n    float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{\n    vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(0.,dot(ldir,-n));\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    \n    if (mObj.blnShadow==true)\n    { fshadow=GetShadow(p,lp);}\n    else\n    {   fshadow=0.5; }\n\n    \n    vec3 lin = amb;\n    lin += 1.0*(dif+diff)*sh;\n    lin += 2.5*spe;\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    \n    \n    lin *= atten*0.8*col*fshadow;\n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n///============================================================\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    \n}\n\n//https://www.shadertoy.com/user/Catzpaw\nfloat snow(vec2 uv,float scale)\n{\n\tfloat w=1.;//smoothstep(1.,0.,uv.y*(scale/10.));\n    float t=iTime*0.5;\n\tif(w<.1)return 0.;\n\tuv+=t/scale;\n    uv.y+=t*2./scale;\n    uv.x+=sin(uv.y+t*.5)/scale;\n\tuv*=scale;\n    vec2 s=floor(uv),f=fract(uv),p;\n    float k=3.,d;\n\tp=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;\n    d=length(p);\n    k=min(d,k);\n\tk=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n    \treturn k*w;\n}\n\nvec3 Nieve(vec2 puv)\n{\n    vec2 uv=puv;\n\tvec3 finalColor=vec3(0);\n\tfloat c=smoothstep(1.,0.3,clamp(uv.y*.3+.8,0.,.75));\n\tc+=snow(uv,30.)*.3;\n\tc+=snow(uv,20.)*.5;\n\tc+=snow(uv,15.)*.8;\n\tc+=snow(uv,10.);\n\tc+=snow(uv,8.);\n\tc+=snow(uv,6.);\n\tfinalColor=(vec3(c));\n    return  finalColor;\n}\n\nvec3 render_sky_color(vec3 rd)\n{\n    \n    float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    \n\tvec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    vec3 nieve= Nieve(rd.xy);\n    sky=mix(sky,nieve, 0.5);\n\treturn sky;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    if (id_material==6.0)\n    {   float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n        l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n    }\n}\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    \n     if( mObj.hitbln==false) return  getSkyColA(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\nif (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 renderReflect(TObj Obj, vec3 ro, vec3 rd, vec3 col )\n{  vec3 p;\n   float t;\n   vec3 colobj;  vec3 n;\n    /////-----------REFLECT--------------\n    if (int( Obj.id_color) ==201)\n    {\n       \n     vec3 colref;\n     for(int i=0; i<2; ++i)\n      {  \n       \n        t=RayMarch(ro,rd, MAX_STEPS);\n        \n        Obj=mObj;\n        \n        \n       if(t>MAX_DIST)\n       {\n         colobj= render_sky_color(rd);\n         return  colobj;\n       }  \n     \n        if( t<0.0 || t>MAX_DIST ) break;\n        p=ro+rd*t;\n        \n        n=GetNormal(p);\n        //produce ondas de mar\n        //n=normalize(n+0.01*sin(10.0* p+2.0*iTime));\n        \n        rd=reflect(rd,n);\n        ro =p+rd * MIN_DIST * 3.;\n        \n        if (t<MAX_DIST)\n        colobj=GetColorYMaterial( p, n, ro, rd,  int( Obj.id_color), Obj.id_material)*2.0;\n        colref=  Getluz( p,ro,rd, n, colobj ,light_pos1);\n        colref+= Getluz( p,ro,rd, n, colobj ,light_pos2);\n       }\n     col+=colref/(float(REFLECT));\n   } \n   return col;\n} \n\nvec3 Render(vec3 ro, vec3 rd)\n{\n  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p ;\n\n   //float d = RayMarch(ro, rd);\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        p = (ro + rd * d );  \n         \n         \n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n    col= renderReflect(Obj,  ro,  rd,  col );\n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,\n        1.055 * pow(c, vec3(1.0/2.4)) - 0.055,\n        step(vec3(0.0031308), c)\n    );\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-25.0);\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    vec3 col= Render( ro,  rd);\n    \n    float tp=mod(iTime, 2.0);\n    float tt=step(1.0,tp);\n    if (tt<1.0 )\n    col = linear2srgb(col);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssSz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[700, 700, 736, 736, 757], [758, 758, 790, 790, 874], [875, 875, 921, 921, 1008], [1012, 1037, 1071, 1071, 1169], [1170, 1170, 1204, 1204, 1296], [1297, 1297, 1331, 1331, 1423], [1424, 1464, 1498, 1498, 1595], [1596, 1636, 1661, 1661, 2942], [2944, 2995, 3019, 3019, 3207], [3210, 3210, 3259, 3259, 3946], [3948, 4002, 4038, 4038, 4285], [4288, 4352, 4379, 4379, 4396], [4398, 4398, 4434, 4434, 4526], [4527, 4527, 4573, 4573, 4705], [4707, 4707, 4781, 4781, 5947], [5948, 6046, 6126, 6126, 6258], [6259, 6300, 6327, 6327, 6442], [6444, 6485, 6518, 6518, 6899], [6901, 6901, 6923, 6923, 7184], [7186, 7186, 7218, 7218, 7483], [7485, 7536, 7583, 7583, 8107], [8162, 8162, 8255, 8255, 8585], [9598, 9598, 9629, 9629, 10335], [10337, 10386, 10412, 10412, 10536], [10538, 10538, 10596, 10596, 10648], [10650, 10699, 10756, 10756, 11345]], "test": "untested"}
{"id": "7sfSz2", "name": "Luna toy", "author": "kaihagseth", "description": "Youtube inspired moire", "tags": ["moire", "toy"], "likes": 4, "viewed": 272, "published": 3, "date": "1618862514", "time_retrieved": "2024-07-30T19:24:53.470211", "image_code": "// Inspired by Tim Rowetts youtube channel :)\n// https://www.youtube.com/watch?v=Mx7xusheSN0\n\n#define PI 3.141592\n#define ROLLSPEED 0.2\n#define STRIPES 24.\n#define RADIUS STRIPES/5.\n\n// True pixelwidth for antialiasing. Thank you Fabrice Neyret!\n#define PW STRIPES/iResolution.y \n\nfloat horizontalStripes(in vec2 uv)\n{\n    return smoothstep(-PW,PW, abs(fract(uv.y)-.5) - .25);\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2 (cos(angle), -sin(angle), sin(angle), cos(angle)) ;\n}\n\nfloat maskCircle(in vec2 uv, float radius)\n{\n    return smoothstep(radius-PW, radius+PW, length(uv));\n}\n\nvec2 roll(float dist, vec2 uv)\n{\n    float t = iTime * ROLLSPEED;\n    uv.x += dist * RADIUS * cos(t);\n    uv *= -rotate2d(dist * -cos(t));\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5* iResolution.xy) / iResolution. y;\n    vec2 st = uv;\n    uv *= STRIPES;\n    vec2 lightRoller =  roll(PI, uv + vec2(0.,(STRIPES/4.)));\n    vec2 darkRoller =   roll(-PI, uv - vec2(0., -.5+(STRIPES/4.)));\n    float lightRollerColor = horizontalStripes(lightRoller) * (1. - maskCircle(lightRoller, RADIUS));\n    float darkRollerColor =  horizontalStripes(darkRoller) * (1. - maskCircle(darkRoller, RADIUS));\n    fragColor = vec4(horizontalStripes(uv) + lightRollerColor - darkRollerColor);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfSz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 318, 318, 378], [380, 380, 408, 408, 478], [480, 480, 524, 524, 583], [585, 585, 617, 617, 740], [742, 742, 799, 799, 1319]], "test": "untested"}
{"id": "fdlSDn", "name": "Intercept those frequencies", "author": "z0rg", "description": "A cool idea I had watching some Jensen interceptor's covers", "tags": ["sound", "curves", "jenseninterceptor"], "likes": 10, "viewed": 436, "published": 3, "date": "1618856134", "time_retrieved": "2024-07-30T19:24:54.236163", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nfloat border(vec2 uv)\n{\n    uv -= vec2(0.,.02);\n    float body = _sqr(uv, vec2(.3,.2));\n    body = max(body, uv.x-uv.y-.475);\n    return abs(body)-0.0001;\n}\n\nvec3 rdr2(vec2 uv)\n{\n\n    vec3 col;\n    //return texture(iChannel0, (uv-vec2(.5))*vec2(iResolution.x)/iResolution.xy).xyz;\n    float cnt = 40.;\n    for (float i = 0.; i < cnt; ++i)\n    {\n        // camera version\n        //float pic = pow(texture(iChannel0, vec2(uv.x*.8+.5, 19.*i/1600.-iTime*.501+.3)).x, 2.);\n        float pic = pow(texture(iChannel0, vec2(uv.x*.25, 1.*i/1600.-iTime*.01)).y, 1.5);\n        pic *= sat(.5+abs(uv.x*2.));\n        pic += 2.*pow(texture(iChannel1, vec2((uv.x+.5),0.)).x,.5)*(1.-sat(i/cnt));\n        float lvl = abs(uv.y-.01*(i-cnt/2.)-0.05*pic)-0.001;\n        lvl = max(lvl, abs(uv.x)-.25);\n        col = mix(col, mix(vec3(0.071,0.769,0.627), vec3(1.000,0.918,0.502),sat(pic*2.-1.5)), (1.-sat(i/cnt))*(1.-sat(lvl*400.*(1.-sat(max(i/cnt, .1))))));\n    }\n    col = mix(col, col.yxz, sat((uv.x+.5)*2.));\n    \n    float strips = max(sin((uv.x-uv.y)*100.+iTime*2.), -(abs(uv.x)-.45));\n    vec3 stripsCol = mix(vec3(0.071,0.769,0.627), vec3(1.000,0.918,0.502), sat(sin(uv.y*15.)*.5+.5));\n    col = mix(col, stripsCol, 1.-sat(strips*iResolution.x));\n    \n    col += stripsCol * pow(1.-sat(length(uv)),5.)*.5;\n    \n    col = mix(col, stripsCol, 1.-sat(border(uv)*400.));\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec2 dir = normalize(vec2(1.));\n    float str = 0.01*texture(iChannel1, vec2(0.9,0.)).x;\n    vec3 col;\n    col.r = rdr2(uv+dir*str).r;\n    col.g = rdr2(uv).g;\n    col.b = rdr2(uv-dir*str).b;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    float stp = 0.02;\n    vec2 uv2 = floor(uv/stp)*stp;\n    vec3 col = rdr(uv);\n    col += rdr(uv2)*(1.-sat(length(uv2)))*.25;\n    col = pow(col, vec3(.85));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26713, "src": "https://soundcloud.com/jensen-interceptor/dj-deeon-jensen-interceptor#t=1:30", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlSDn.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[429, 429, 450, 450, 482], [484, 484, 503, 503, 557], [559, 559, 587, 587, 638], [640, 640, 663, 663, 796], [798, 798, 818, 818, 2009], [2011, 2011, 2030, 2030, 2243], [2245, 2245, 2302, 2302, 2559]], "test": "untested"}
{"id": "fsfSzM", "name": "Long-Exposure Camera", "author": "Zi7ar21", "description": "yeet", "tags": ["camera", "webcam"], "likes": 2, "viewed": 605, "published": 3, "date": "1618850045", "time_retrieved": "2024-07-30T19:24:55.010094", "image_code": "// ####### Long-Exposure Camera #######\n// Made by Zi7ar21 on April 19th, 2021\n// Last Updated:\n// April 19th, 2021 at 10:10 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/fsfSzM\n\n// Image Preview\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get the Image\n    vec4 texel = texel0;\n\n    // Convert Linear to sRGB\n    vec3 color = pow(texel.rgb, vec3(1.0/gamma));\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ##### CAMERA INPUT #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get the Incoming Frame from the Camera\n    vec3 color = texture(iChannel0, gl_FragCoord.xy/resolution.xy).rgb;\n\n    // Convert sRGB to Linear\n    color = pow(color, vec3(gamma));\n\n    // Ensure the Frame is within Range\n    color = clamp(color, 0.0, 1.0);\n\n    // Output the New Frame\n    fragColor = vec4(color*cameraBrightness, 1.0);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ##### IMAGE PROCESSING #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get the Previous Frame\n    fragColor = iFrame != 0 ? texel0 : vec4(0.0);\n\n    // Get the Frame from the Camera Buffer\n    vec4 texel = texel1;\n\n    // Output the New Frame\n    fragColor += vec4(texel.rgb, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ##### PARAMETERS #####\n#define gamma 2.2\n\n// Camera Adjustments\n// These are performed to the input, not the stack\n#define cameraBrightness 1.0\n\n// Processed Adjustments\n// These are performed to the stack, not the input\n#define postfxBrightness 1.0\n\n// ##### CONSTANTS #####\n#define resolution iResolution\n\n// Sample Channels\n#define texel0 texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0)\n#define texel1 texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0)\n#define texel2 texelFetch(iChannel2, ivec2(gl_FragCoord.xy), 0)\n#define texel3 texelFetch(iChannel3, ivec2(gl_FragCoord.xy), 0)", "buffer_c_code": "// ##### IMAGE EXPORT #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get the Frame\n    vec4 texel = texel0;\n\n    // Compute the Final Image\n    vec3 color = texel.a != 0.0 ? texel.rgb/texel.a : texel.rgb;\n\n    // Output the Rendered Image\n    fragColor = vec4(color*postfxBrightness, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfSzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 315, 369, 390, 565]], "test": "untested"}
{"id": "NsXXz2", "name": "MandelKochBrotFlake...?", "author": "Pelegefen", "description": "Wanted to see what trippy stuff awaits when i project a zoom into the mandelbrot set,\ninto the symmetry of the koch snowflake.\n", "tags": ["2d", "fractal", "mandelbrot", "interactive", "kaleidoscope", "snowflake", "set", "koch"], "likes": 6, "viewed": 335, "published": 3, "date": "1618847744", "time_retrieved": "2024-07-30T19:24:55.885753", "image_code": "// Credits - fractal zoom with smooth iter count adapted from - iq (Inigo quilez) - https://iquilezles.org/articles/msetsmooth\n// Koch Snowflake symmetry from tutorial by Martijn Steinrucken aka The Art of Code/BigWings - 2020 - https://www.youtube.com/watch?v=il_Qg9AqQkE&ab_channel=TheArtofCode\n\n//Some notes - color is determined by date and not time - hour of day dependent.\n//Move the mouse on the Y axis to change the symmetry.\n\n\n\n\n#define date iDate\n#define time iTime\n#define resolution iResolution\n\n\n\nfloat localTime(){\n\nfloat d = date.w / date.x;\nreturn d;\n\n}\n\nvec3 randomCol(float sc){\n\n float d = localTime();\n\tfloat r = sin(sc * 1. * d)*.5+.5;\n\tfloat g = sin(sc * 2. * d)*.5+.5;\n\tfloat b = sin(sc * 4. * d)*.5+.5;\n\n\tvec3 col = vec3(r,g,b);\n\tcol = clamp(col,0.,1.);\n\n\treturn col;\n\t}\n\n\n//--------------------------------------------------mandelbrot generator-----------https://iquilezles.org/articles/msetsmooth\n\n\tfloat mandelbrot(vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n\n    const float B = 128.0;\n    float l = 0.0;\n    vec2 z  = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z)>(B*B) ) break;\n        l += 1.0;\n    }\n\n    if( l>255.0 ) return 0.0;\n\n\n    // equivalent optimized smooth interation count\n    float sl = l - log2(log2(dot(z,z))) + 4.0;\n\n\n\n     return sl;\n }\n\n\nvec3 mandelbrotImg(vec2 p)\n{\n\n    //uncomment to see unmaped set\n\t//p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\n    \n    float zoo = 0.62 + 0.38*cos(.1*time);\n   float coa = cos( 0.015*(1.0-zoo)*time );\n   float sia = sin( 0.015*(1.0-zoo)*time );\n   zoo = pow( zoo,6.0);\n   vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n   vec2 c = vec2(-.745,.186) + xy*zoo;\n\n        float l = mandelbrot(c);\n        \n        \n\tvec3 col1 = 0.5 + 0.5*cos( 3.0 + l*.15 + randomCol(.1));\n    vec3 col2 = 0.5 + 0.5*cos( 3.0 + l*.15 / randomCol(.1));\n    vec3 col = mix(col1,col2,sin(time * .5)*.5+.5);\n\n\n\n\nreturn col;\n}\n\n//-----------------functions-----------\n\nfloat remap(float a1, float a2 ,float b1, float b2, float t)\n{\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\n}\n\n\nvec2 remap(float a1, float a2 ,float b1, float b2, vec2 t)\n{\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\n}\n\n\nvec4 remap(float a1, float a2 ,float b1, float b2, vec4 t)\n{\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\n}\n\n\n\n\n\nvec2 N(float angle) {\n    return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5*resolution.xy)/resolution.y;\n\tvec2 mouse = 1. - iMouse.xy/resolution.xy; // 0 1\n\tvec2 ouv = uv;\n    //uv.y -= .05;\n\tuv *= 3.0;\n\n    uv.x = abs(uv.x);\n\n    vec3 col = vec3(0);\n    float d;\n\n    float angle = 0.;\n    vec2 n = N((5./6.)*3.1415);\n\n    uv.y += tan((5./6.)*3.1415)*.5;\n   \td = dot(uv-vec2(.5, 0), n);\n    uv -= max(0.,d)*n*2.;\n\n    float scale = 1.;\n\n    n = N( mouse.y*(2./3.)*3.1415);\n    uv.x += .5;\n    for(int i=0; i<10; i++) {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n\n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        d = dot(uv, n);\n        uv -= min(0.,d)*n*2.;\n    }\n\n    d = length(uv - vec2(clamp(uv.x,-1., 1.), 0));\n    col += smoothstep(10./resolution.y, .0, d/scale);\n    uv /= scale;\t// normalization\n\n   \n\tvec3 manCol = mandelbrotImg(uv);\n\t col += manCol;\n\n\n \t\t// vignette effect\n\t  col *= 1.0 - 0.5*length(uv *1.2);\n\n\t \n    fragColor = vec4( col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXXz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[510, 510, 528, 528, 569], [571, 571, 596, 596, 794], [925, 925, 952, 952, 1690], [1693, 1693, 1721, 1817, 2310], [2353, 2353, 2415, 2415, 2452], [2455, 2455, 2515, 2515, 2552], [2555, 2555, 2615, 2615, 2652], [2658, 2658, 2679, 2679, 2722], [2724, 2724, 2779, 2779, 3716]], "test": "untested"}
{"id": "fsXXz2", "name": "Volcanic planet map 2", "author": "jarble", "description": "This fractal resembles a map of a volcanic planet.", "tags": ["fractal", "map", "bitwise", "volcanic"], "likes": 6, "viewed": 237, "published": 3, "date": "1618847680", "time_retrieved": "2024-07-30T19:24:56.804297", "image_code": "//#define ITERS 9 //normal world map\n#define ITERS 12 //swamp world\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 2000.0;\n    float trans = iTime * 500.0;\n    vec2 coord = (scale * fragCoord/iResolution.xy) + vec2(trans+30000.0,0.0);\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev = vec3(0.0);\n    for(int i = 0; i < ITERS; i++){\n        col_prev = col;\n        coord.y -= (4.0-result);\n        coord += coord.yy/8.0;\n        coord = coord.yx/(3.0)+col.xy;\n        //coord.y *= -1.0;\n        result = ((result + float(val = ((int(coord.x/1.5-coord.y/2.0) & int(coord.y/1.5+coord.x/2.0)) % 3)))/(2.0));\n        col.x = result;\n        col = ((col.yzx)*2.0+col_prev)/3.0;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXXz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NsXSz2", "name": "flownoise-isolined Britney col", "author": "FabriceNeyret2", "description": "SPACE to toggle turbulence vs bozo noise.\nUsing controled-by-video lines width  drawing + flownoise\nflownoise variant of [url]https://shadertoy.com/view/NdXXRj[/url] ", "tags": ["procedural", "noise", "perlin"], "likes": 6, "viewed": 341, "published": 3, "date": "1618844439", "time_retrieved": "2024-07-30T19:24:57.576233", "image_code": "// color variant of https://shadertoy.com/view/fdXSz2\n// gradient + 1pix-width lines + flownoise variant of https://shadertoy.com/view/NdXXRj\n// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. ) \\\n                    *  mat2(cos(iTime+vec4(0,11,33,0)))\n  #define draw(v,d,w)  clamp(1. - abs( fract(v-.5) - .5 ) / (d)/(w), 0.,1.)             // method 1 \n//#define draw(v,d,w)  clamp(1. - ( abs( fract(v-.5) - .5 ) -.1*(w-1.) ) / (d), 0.,1.)  // method 2\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define Mix(c0,c1,v)     mix(c0,c1,v)\n//#define Mix(c0,c1,v)   vec4(c0,c1,0,0) // debug \n\n//#define func( P )  ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n  #define func( P )  ( keyToggle(32) ? noise( P ) : perlin( .5*(P) ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 4.*u/360. - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, dl, f = func(P), df, v,a;\n#if 0\n    l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));              // subvid amount (relative)\n    dl =     fract(log2(2.*fwidth(P.x)/fwidth(f)));      \n#else\n    l = exp2(floor(log2(.5/22./fwidth(f))));                      // subvid amount (absolute)\n    dl =     fract(log2(.5/22./fwidth(f)));\n#endif\n\n // f *= U.x;                                                     // draw isolines \n    df = fwidth(f);\n // df = length( vec2( ( func(P + eps.xy), func(P + eps.yx) ) -f ) / eps.x )*fwidth(P.x);\n    vec4 T = texture(iChannel0, u/R );\n    l *= 8.;\n# if 0\n    v = 4.*T.x;\n    O += Mix( draw(    f*l,    l*df , max(v,1.) ),\n              draw( 2.*f*l, 2.*l*df , max(v,1.) ),\n              dl ) * min(v,1.);\n // O *= T/T.x;                   // color variant\n\n# else                            // color on different layers\n#   define Draw(c,ofs)                                    \\\n      v = 3.*T.c;                                         \\\n      O.c = mix( draw(    f*l-ofs,    l*df, max(v,1.) ),  \\\n                 draw( 2.*f*l-ofs, 2.*l*df, max(v,1.) ),  \\\n                 dl ) * min(v,1.)\n    float ofs = .33;   // 0. : too subtle to see.\n    Draw(r, 0.);\n    Draw(g, ofs);\n    Draw(b, -ofs);\n# endif\n    \n    O = sqrt(O);                                                  // to sRGB\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXSz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[996, 996, 1019, 1019, 1312], [1314, 1314, 1338, 1393, 1552], [1554, 1554, 1592, 1592, 3052]], "test": "untested"}
{"id": "fdXSz2", "name": "flownoise-isolined Britney", "author": "FabriceNeyret2", "description": "SPACE to toggle turbulence vs bozo noise.\nUsing controled-by-video lines width  drawing + flownoise\nflownoise variant of [url]https://shadertoy.com/view/NdXXRj[/url] ", "tags": ["procedural", "noise", "perlin"], "likes": 9, "viewed": 365, "published": 3, "date": "1618844104", "time_retrieved": "2024-07-30T19:24:58.348169", "image_code": "// video-controled line width variant of https://shadertoy.com/view/NdXXRj\n// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. ) \\\n                    *  mat2(cos(iTime+vec4(0,11,33,0)))\n  #define draw(v,d,w)  clamp(1. - abs( fract(v-.5) - .5 ) / (d)/(w), 0.,1.)             // method 1: loose \n//#define draw(v,d,w)  clamp(1. - ( abs( fract(v-.5) - .5 ) -.1*(w-1.) ) / (d), 0.,1.)  // method 2: strict\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define Mix(c0,c1,v)     mix(c0,c1,v)\n//#define Mix(c0,c1,v)   vec4(c0,c1,0,0) // debug \n\n//#define func( P )  ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n  #define func( P )  ( keyToggle(32) ? noise( P ) : perlin( .5*(P) ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 4.*u/360. - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, dl, f = func(P), df, v,a;\n#if 0\n    l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));               // subvid amount (relative)\n    dl =     fract(log2(2.*fwidth(P.x)/fwidth(f)));      \n#else\n    l = exp2(floor(log2(.5/22./fwidth(f))));                       // subvid amount (absolute)\n    dl =     fract(log2(.5/22./fwidth(f)));\n#endif\n\n // f *= U.x;                                                      // draw isolines \n    df = fwidth(f);\n // df = length( vec2( ( func(P + eps.xy), func(P + eps.yx) ) -f ) / eps.x )*fwidth(P.x);\n    vec4 T = texture(iChannel0, u/R );\n    l *= 8.;\n# if 1\n    v = 4.*T.x;\n    O += Mix( draw(    f*l,    l*df , max(v,1.) ),\n              draw( 2.*f*l, 2.*l*df , max(v,1.) ),\n              dl ) * min(v,1.);\n    \n // O *= T/T.x;                                                    // color variant\n // O = mix( O, T, smoothstep(.2,.3,length(T-vec4(.14,.5,.1,1)) ));// isolines behind Britney\n // O = mix( O, T, smoothstep(.2,.4,T.x) );                        // frightening version :-p      \n\n# else                                                             // color on different layers\n#   define Draw(c,ofs)                                    \\\n      v = 3.*T.c;                                         \\\n      O.c = mix( draw(    f*l-ofs,    l*df, max(v,1.) ),  \\\n                 draw( 2.*f*l-ofs, 2.*l*df, max(v,1.) ),  \\\n                 dl ) * min(v,1.)\n    float ofs = .33;   // 0. : too subtle to see.\n    Draw(r, 0.);\n    Draw(g, ofs);\n    Draw(b, -ofs);\n# endif\n    \n    O = sqrt(O);                                                  // to sRGB\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[944, 944, 967, 967, 1260], [1262, 1262, 1286, 1341, 1500], [1502, 1502, 1540, 1540, 3268]], "test": "untested"}
{"id": "fdXXR2", "name": "flownoise2 balanced isolines-sbd", "author": "FabriceNeyret2", "description": "SPACE to toggle turbulence vs bozo noise.\nusing 1pix-width lines drawing + lines density gradient.  switch #8 for correct isolines ( altered here for the look :-) ).\nflownoise variant of [url]https://shadertoy.com/view/NdXXRj[/url]", "tags": ["procedural", "noise", "perlin"], "likes": 14, "viewed": 445, "published": 3, "date": "1618841945", "time_retrieved": "2024-07-30T19:24:59.238788", "image_code": "// gradient + 1pix-width lines + flownoise variant of https://shadertoy.com/view/NdXXRj\n// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. ) \\\n                    *  mat2(cos(iTime+vec4(0,11,33,0)))\n//#define draw(v,d)    clamp(1. - abs( fract(v-.5) - .5 ) / (d), 0.,1.) // correct version\n  #define draw(v,d)    clamp(1. - abs( fract(v   ) - .5 ) / (d), 0.,1.) // nicer here :-)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n//#define func( P )  ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n  #define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, dl, f = func(P), df;\n#if 0\n    l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));              // subvid amount (relative)\n    dl =     fract(log2(2.*fwidth(P.x)/fwidth(f)));      \n#else\n    l = exp2(floor(log2(1./22./fwidth(f))));                      // subvid amount (absolute)\n    dl =     fract(log2(1./22./fwidth(f)));\n#endif\n    float w = U.x;\n    f *= w;\n#if 0                                                             // draw isolines using sin\n    O = vec4(.5+.5*  mix( sin(50.*l*f) , sin(100.*l*f), dl ) ); \n#else                                                             // draw isolines \n    df = fwidth(f);\n// df = length( ( vec2( func(P + eps.xy), func(P + eps.yx) )*w -f ) / eps.x )*fwidth(P.x);\n    l *= 8.; \n    O += mix( draw(    f*l,    l*df ),\n              draw( 2.*f*l, 2.*l*df ),\n              dl );\n#endif\n    \n    O = sqrt(O);                                                  // to sRGB\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXXR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[833, 833, 856, 856, 1149], [1151, 1151, 1175, 1230, 1389], [1391, 1391, 1429, 1429, 2477]], "test": "untested"}
{"id": "fsfXzj", "name": "flownoise balanced isolines-sbdv", "author": "FabriceNeyret2", "description": "flownoise variant of [url]https://shadertoy.com/view/NdXXRj[/url]\ninterpolated variant of |url]https://shadertoy.com/view/sdsXzB[/url] ", "tags": ["procedural", "noise", "perlin"], "likes": 10, "viewed": 281, "published": 3, "date": "1618840864", "time_retrieved": "2024-07-30T19:25:00.181268", "image_code": "// flownoise variant of https://shadertoy.com/view/NdXXRj\n// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. ) \\\n                    *  mat2(cos(iTime+vec4(0,11,33,0)))\n#define draw(v,d)      clamp(1. - abs( fract(v) - .5 ) / (d), 0.,1.)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n  #define func( P )  ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n//#define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, dl, f = func(P), df;\n    if ( int(u.y) == int(R.y*.4) ) { O.r++; return; }             // red separator\n    if ( U.y > .4 ) {\n#if 0\n        l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));          // subvid amount (relative)\n        dl =     fract(log2(2.*fwidth(P.x)/fwidth(f)));      \n#else\n        l = exp2(floor(log2(1./22./fwidth(f))));                  // subvid amount (absolute)\n        dl =     fract(log2(1./22./fwidth(f)));\n#endif\n\n#if 1                                                             // draw isolines using sin\n        O = (.5+.5*  mix( sin(50.*l*f) , sin(100.*l*f), dl ) ) * hue(f); \n#else                                                             // draw isolines \n        df = fwidth(f);\n     // df = length( vec2( ( func(P + eps.xy), func(P + eps.yx) ) -f ) / eps.x )*fwidth(P.x);\n        l *= 8.; \n        O += mix( draw(    f*l,    l*df ),\n                  draw( 2.*f*l, 2.*l*df ),\n                  dl );\n#endif\n    } \n    else {\n        f *= 8.;\n        O += draw( f, fwidth(f) );                                // draw isolines\n    }\n    \n    O = sqrt(O);                                                  // to sRGB\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfXzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[691, 691, 714, 714, 1007], [1009, 1009, 1033, 1088, 1247], [1249, 1249, 1287, 1287, 2574]], "test": "untested"}
{"id": "NdXXzj", "name": "Wireframe IFS", "author": "yasuo", "description": "Wireframe IFS", "tags": ["ifs"], "likes": 8, "viewed": 322, "published": 3, "date": "1618840430", "time_retrieved": "2024-07-30T19:25:01.100809", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .005\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) {\n        return val1;\n    }\n    return val2;\n}\n\nfloat hash(vec2 p) {\n    vec2 randP = fract(sin(p*123.456)*567.89);\n    randP += dot(randP,randP*34.56);\n    float rand = fract(randP.x*randP.y);\n    return rand;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdFrameCross( in vec3 p , float inf, float size, float e)\n{\n    float da = sdBoxFrame(p.xyz,vec3(inf,size,size),e);\n    float db = sdBoxFrame(p.yzx,vec3(size,inf,size),e);\n    float dc = sdBoxFrame(p.zxy,vec3(size,size,inf),e);\n    float d = min(da,min(db,dc));\n    mat3 rot = matRotateZ(iTime)*matRotateX(-iTime);\n    p*=rot;\n    d = min(d,sdBoxFrame(p,vec3(size*0.5),e));\n    return d;\n}\n\nvec4 GetDist(vec3 p) {\n    float t = iTime*1.2;\n    vec3 p2 = p;\n    mat3 rot = matRotateY(radians(25.0)+t)*matRotateX(radians(-30.0)+t);\n    mat3 rot2 = matRotateX(radians(-25.0)+t)*matRotateY(radians(30.0)+t);\n\n    float dist = 0.15+sin(t)*0.1;\n    \n    p = abs(p);\n    p-=dist;\n    p*=rot;\n    \n    float d = sdFrameCross(p,0.1,0.3,0.002);\n    \n    p = p2;\n    for(float i = 1.; i<=2.; i++){\n        p = abs(p);\n        p -= (dist*0.75)*i;\n        p *= rot2;\n        d = min(d,sdFrameCross(p+vec3(0.0,sin(t*i)*0.5,0.0), 0.1,0.3,0.002));\n    }\n    \n    // floor\n    p = p2;\n    p.y+=3.0;\n    float mask = length(p)-25.0;\n    p.z-=t*2.2;\n    p.xz = mod(p.xz,1.0)-0.5;\n    float d2 = sdBoxFrame(p,vec3(0.5,0.01,0.5),0.0025);\n    d2 = max(mask,d2);\n    \n    p = p2;\n    vec2 uv=p.xz;\n    float scale = 1.0+mod(iTime*10.0,40.0);\n    float shine = abs(length(uv)-scale)-1.0;\n    vec3 col = mix(vec3(0.1,0.5,0.9),vec3(0.7,0.8,1.0),1.0-smoothstep(0.0,0.5,shine));\n    vec4 res = combine(vec4(vec3(1.0),d),vec4(col,d2));\n    \n    return res;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,5,3);\n    \n    lightPos.yz *= Rot(radians(-60.0));\n    lightPos.xz *= Rot(iTime*.3+1.0);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.6;\n    \n    return vec2((lambert+dif),max(0.9, 1.0)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Bg(vec3 rd, vec2 p) {\n    p = rd.xy;\n    p*=10.0;\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n\n    float n = hash(p);\n    float rand = hash(id);\n    \n    vec3 col = vec3(.2,.1,.5);\n    \n    float k = rd.y*2.0+0.75;\n    col = mix(col,vec3(.1),k);\n    \n    vec2 pos = vec2(0.0);\n    if(rand<0.5){\n        pos.x += 0.3;\n    }\n    if(rand>0.7){\n        pos.y += 0.3;\n    }\n    \n    vec2 starPos = uv+pos;\n    starPos.x*=1.0-rand;\n    starPos.y*=2.0;\n    float d = length(starPos)-0.01;\n    if(rd.y>0.0){\n        col = mix(col,vec3(0.5),S(d,0.0));\n    }\n    \n    return col*n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -3);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-45.0+sin(iTime*.5)*10.0));\n    ro.xz *= Rot(iTime*.35+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0.0), 2.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,r.y),30.);\n        float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n        col = mix(Bg(r,uv),vec3(dif),0.5)+spec;\n        if(d.rgb != vec3(1.0)){\n            col*=d.rgb;\n        }\n    } else {\n        // background\n        col += Bg(rd,uv);\n    }\n    \n    float brightness = 1.25;\n    fragColor = vec4(col*brightness,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXXzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[622, 622, 658, 658, 733], [735, 735, 755, 755, 899], [901, 901, 946, 946, 1228], [1230, 1230, 1295, 1295, 1625], [1627, 1627, 1649, 1649, 2664], [2666, 2666, 2699, 2699, 2952], [2954, 2954, 2978, 2978, 3179], [3181, 3181, 3204, 3204, 3592], [3594, 3594, 3636, 3636, 3831], [3833, 3833, 3859, 3859, 4419], [4421, 4421, 4478, 4478, 5401]], "test": "untested"}
{"id": "NsXXRj", "name": "Ingenuity Mk.2 ?", "author": "dr2", "description": "Celebrating Martian flight - design drawings for \"Mars Copter\" (mouseable)", "tags": ["sketch", "mars", "nasa", "helicopter"], "likes": 24, "viewed": 566, "published": 3, "date": "1618836797", "time_retrieved": "2024-07-30T19:25:02.119087", "image_code": "// \"Ingenuity Mk.2 ?\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\n\nvec3 qHit, pgSize, ltDir, ltDirS;\nvec2 hipPos, ftPos;\nfloat tCur, dstFar, dMiss, legLenU, legLenD, aU, aD, pPitch, pRot, szFac;\nint idObj;\nconst int idBase = 1, idLeg = 2, idAxl = 3, idProp = 4;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 fb;\n  float dMin, d;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  fb = normalize (vec2 (1.2, 1.));\n  for (float k = -1. + float (VAR_ZERO); k <= 1.; k += 2.) {\n    q = p;\n    q.xz = Rot2D (q.xz, k * pRot);\n    q.y -= hipPos.y + 2.4 + 1.2 * k;\n    d = PrRoundCylDf (q.xzy, 0.2 - 0.05 * k, 0.01, 1.2);\n    DMINQ (idAxl);\n    q.y -= 1.;\n    d = min (max (PrRoundCylDf (vec3 (q.x, Rot2D (q.yz, k * pPitch)).xzy, 3., 0.02, 0.01),\n       dot (vec2 (q.x, abs (q.z)), fb)),\n       max (PrRoundCylDf (vec3 (q.x, Rot2D (q.yz, - k * pPitch)).xzy, 3., 0.02, 0.01),\n       dot (vec2 (- q.x, abs (q.z)), fb)));\n    DMINQ (idProp);\n  }\n  q = p;\n  q.y -= hipPos.y + 0.1;\n  d = PrRoundCylDf (q.xzy, hipPos.x, 0.05, 0.2);\n  q.y -= 0.4;\n  d = min (d, PrRoundCylDf (q.xzy, 0.35 * hipPos.x, 0.05, 0.15));\n  DMINQ (idBase);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi)) + 0.5) / 6.);\n  q.xy -= hipPos * vec2 (-1., 1.);\n  q.xy = Rot2D (q.xy, aU);\n  q.x += 0.5 * legLenU;\n  d = PrCapsDf (q.yzx, 0.1 * (0.8 + 0.2 * q.x / (0.5 * legLenU)) / 0.6, 0.5 * legLenU);\n  DMINQ (idLeg);\n  q.x += 0.5 * legLenU;\n  q.xy = Rot2D (q.xy, aD - aU);\n  q.x += 0.5 * legLenD;\n  d = PrCapsDf (q.yzx, 0.1 * (0.9 + 0.1 * q.x / (0.5 * legLenD)), 0.5 * legLenD);\n  DMINQ (idLeg);\n  q.x += 0.5 * legLenD;\n  q.xy = Rot2D (q.xy, 0.5 * pi - aD);\n  q.x -= -0.02;\n  d = PrRoundCylDf (q.yzx, 0.3, 0.02, 0.05);\n  DMINQ (idLeg);\n  return szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q -= vec3 (8., 0.4, 6.);\n  q.xz = Rot2D (q.xz, 0.2 * pi);\n  d = PrRoundCylDf (q, 0.33, 0.02, 5.);\n  d = max (d, - dot (vec2 (q.z, dot (q.xy, cos (2. * pi * floor (16. * (atan (q.y, - q.x) / (2. * pi) +\n     0.5) + 0.5) / 16. + vec2 (0., 0.5 * pi)))), sin (-0.4 * pi + vec2 (0.5 * pi, 0.))) - 1.6);\n  DMINQ (1);\n  q = p;\n  q.yz -= vec2 (-0.1, 4.);\n  d = max (PrRoundBoxDf (q, vec3 (pgSize + vec3 (1., 0.1, 1.)), 0.03), - PrBox2Df (q.xz, pgSize.xz));\n  DMINQ (2);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.xy, 1. - 0.1 * sq.x * sq.y).xzy;\n}\n\nvec2 ExBlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, fcBlk;\n  vec2 qBlk;\n  float dn, df, bSize;\n  bSize = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk)) / bSize;\n  } else qBlk = vec2 (0.);\n  return qBlk;\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, fcBlk;\n  vec2 qBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4;\n  if (idObj == idBase) {\n    col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.02,\n       abs (length (qHit.xz) - 1.1) - 0.1));\n  } else if (idObj == idLeg) {\n    col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * sin (8. * pi * qHit.x));\n  } else if (idObj == idAxl) {\n    col4 = vec4 (0.8, 1., 0.8, 0.2) * (1. - 0.2 * sin (4. * atan (qHit.z, qHit.x)));\n  } else if (idObj == idProp) {\n    col4 = vec4 (1., 0.9, 0.8, 0.2) * (0.9 + 0.1 * sin (8. * pi * length (qHit.xz)));\n  }\n  return col4;\n}\n\n#define ACOS_CLAMP(c) acos (clamp ((c), -1., 1.))\n\nvoid SetConf (float vp)\n{\n  vec2 knPos, r, a, b;\n  float tCyc, rl, s, t;\n  legLenU = 2.;\n  legLenD = 3.;\n  tCyc = 6.;\n  t = mod (tCur / tCyc, 1.);\n  pPitch = 0.05 * pi * (0.5 + 1.5 * SmoothBump (0.05, 0.5, 0.03, t));\n  hipPos = vec2 (1.5, 0.5 * (legLenU + legLenD) + 6. * step (vp, -0.5) * SmoothBump (0.25, 0.75, 0.2, t));\n  ftPos = vec2 (1.8 + 2.2 * (1. - smoothstep (0.2, 1.5, hipPos.y - (legLenU + legLenD))), 0.);\n  r = ftPos - hipPos;\n  rl = length (r);\n  b = vec2 (legLenU, legLenD);\n  if (rl < legLenU + legLenD) {\n    a = ACOS_CLAMP ((rl * rl + (b.y * b.y - b.x * b.x) * vec2 (-1., 1.)) / (2. * rl * b));\n    s = sign (r.x);\n    knPos = vec2 (hipPos.x, ftPos.y) + b * sin (vec2 ((a.x + 0.5 * pi) * s, a.y) -\n       asin (r.y / rl) * vec2 (- s, 1.));\n    r = knPos - hipPos;\n    aU = atan (r.y, r.x);\n    r = ftPos - knPos;\n    aD = atan (r.y, r.x);\n  } else {\n    aU = asin (r.x / (legLenU + legLenD)) - 0.5 * pi;\n    aD = aU;\n  }\n  pRot = ((vp != 1.) ? 2. : 0.2) * pi * tCur;\n}\n\nvec3 SkShowScene (vec3 ro, vec3 rd, vec2 uv)\n{\n  vec4 col4, vn4;\n  vec3 col, vn;\n  float dstObj;\n  dMiss = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn4 = ObjNfL (ro);\n    vn = vn4.xyz;\n    col4 = ObjCol ();\n    col = vec3 (1.) * Maxv3 (col4.rgb);\n    col *= (1. - 0.5 * smoothstep (0.5, 1., abs (vn4.w) / 64.)) *\n       (0.9 + 0.2 * Noisefv2 (Rot2D (uv, -0.2 * pi) * vec2 (16., 256.))) *\n       (0.5 + 0.5 * max (dot (vn, ltDirS), 0.));\n    dMiss = dstFar;\n  } else {\n    col = vec3 (1.);\n  }\n  col = mix (col, vec3 (0.3), exp (- 64. * dMiss));\n  return clamp (col, 0., 1.);\n}\n\nvec3 SkMain (vec2 fCoord, float vp)\n{\n  mat3 vuMat;\n  vec3 ro, rd, col;\n  vec2 uv;\n  float el, az, szFacT;\n  szFacT = szFac;\n  uv = fCoord / vec2 (5., 5.5);\n  if (vp == 0.) {\n    szFac = 0.7;\n    uv -= vec2 (-0.35, -1.7);\n    el = -0.05 * pi;\n    az = 0.;\n  } else if (vp == 1.) {\n    szFac = 0.65;\n    uv -= vec2 (0.3, -1.2);\n    el = -0.5 * pi;\n    az = 0.17 * pi;\n  } else if (vp == 2.) {\n    szFac = 0.63;\n    uv -= vec2 (0., -1.6);\n    el = -0.25 * pi;\n    az = 0.7 * pi;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -5., -20.);\n  rd = vuMat * normalize (vec3 (uv, 4.2));\n  ltDirS = vuMat * normalize (vec3 (0.7, 1., -0.7));\n  SetConf (vp);\n  col = SkShowScene (ro, rd, uv);\n  szFac = szFacT;\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 col, vn, qHitEx;\n  vec2 qBlk, q, sq;\n  float dstObj, dstExObj, sh, r;\n  int idObjEx;\n  bool isBg;\n  SetConf (-1.);\n  szFac = 0.7;\n  pgSize = vec3 (15., 0.1, 10.);\n  isBg = false;\n  dstExObj = ExObjRay (ro, rd);\n  idObjEx = idObj;\n  qHitEx = qHit;\n  dstObj = ObjRay (ro, rd);\n  db4 = BlkHit (ro - vec3 (0., -0.1, 4.), rd, pgSize);\n  if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {\n    if (dstObj < dstExObj) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      qBlk = mod (2. * ExBlkHit (ro, reflect (rd, vn)), 1.);\n      col4 = ObjCol ();\n    } else {\n      ro += dstExObj * rd;\n      vn = ExObjNf (ro);\n      if (idObjEx == 1) {\n        r = length (qHit.xy);\n        col4 = mix (vec4 (0.9, 0.7, 0.1, 0.), vec4 (1., 0.9, 0.1, 0.01), step (0.34, r));\n        col4 = mix (vec4 (0.3, 0.3, 0.3, 0.), col4, step (0.18, r));\n        col4 = mix (vec4 (0.8, 0.4, 0.1, 0.2), col4, step (qHitEx.z, 4.5));\n      } else if (idObjEx == 2) {\n        col4 = vec4 (0.5, 0.2, 0.1, 0.) * (0.9 + 0.1 * Noisefv2 (32. * qHit.xz));\n      }\n    }\n  } else if (db4.x < dstFar) {\n    ro += db4.x * rd;\n    vn = db4.yzw;\n    q = ro.xz - vec2 (0., 4.);\n    if (vn.y > 0.5 && PrBox2Df (q, pgSize.xz - 0.96) < 0.) {\n      sq = sign (q);\n      col = (sq.x < 0. || sq.y < 0.) ? SkMain (q - 0.5 * sq * pgSize.xz,\n         sq.y + 1. + 0.5 * (sq.x + 1.)) : vec3 (1.);\n      if (Minv3 (col) > 0.95) {\n        q = smoothstep (0.02, 0.05, abs (mod (q + 0.5, 1.) - 0.5));\n        col = mix (vec3 (0.4, 0.6, 0.9), vec3 (1.), min (q.x, q.y));\n      }\n    } else {\n      col = vec3 (1.) * (0.8 + 0.2 * step (0.5, vn.y));\n      sh = 1.;\n    }\n  } else {\n    isBg = true;\n  }\n  if (! isBg) {\n    SetConf (-1.);\n    sh = min (ObjSShadow (ro + 0.01 * vn, ltDir), ExObjSShadow (ro + 0.01 * vn, ltDir));\n    if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {\n      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      col += col4.a * vec3 (0.5) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *\n         SmoothBump (0.25, 0.75, 0.05, qBlk.y));\n    } else {\n      col *= 0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.);\n    }\n  } else {\n    qBlk = mod (8. * ExBlkHit (ro, rd), 1.);\n    col = vec3 (0.5, 0.4, 0.4) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +\n       vec3 (0.2) * (0.9 + 0.1 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *\n       SmoothBump (0.25, 0.75, 0.1, qBlk.y));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.27 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.8 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.5 * pi, -0.1 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1.5, -40.);\n  rd = vuMat * normalize (vec3 (uv, 4.7));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.7, 1., -0.7));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXXRj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[825, 825, 847, 847, 2296], [2298, 2298, 2331, 2331, 2514], [2516, 2516, 2537, 2537, 2792], [2794, 2794, 2816, 2816, 3145], [3147, 3147, 3184, 3184, 3413], [3415, 3415, 3439, 3439, 3973], [3975, 3975, 4010, 4010, 4194], [4196, 4196, 4219, 4219, 4476], [4478, 4478, 4517, 4517, 4748], [4750, 4750, 4790, 4790, 5154], [5156, 5156, 5190, 5190, 5634], [5636, 5636, 5680, 5680, 6036], [6038, 6038, 6054, 6054, 6572], [6625, 6625, 6650, 6650, 7612], [7614, 7614, 7660, 7660, 8237], [8239, 8239, 8276, 8276, 8981], [8983, 8983, 9018, 9018, 11522], [11524, 11524, 11577, 11577, 12199], [12201, 12201, 12247, 12247, 12294], [12296, 12296, 12329, 12329, 12418], [12420, 12420, 12463, 12463, 12527], [12529, 12529, 12586, 12586, 12662], [12664, 12664, 12686, 12686, 12724], [12726, 12726, 12748, 12748, 12786], [12788, 12788, 12845, 12845, 12928], [12930, 12930, 12966, 12966, 13172], [13174, 13174, 13204, 13204, 13317], [13351, 13351, 13375, 13375, 13487], [13489, 13489, 13514, 13514, 13700]], "test": "untested"}
{"id": "NdXXRj", "name": "noise balanced isolines -subdiv2", "author": "FabriceNeyret2", "description": "interpolated variant of |url]https://shadertoy.com/view/sdsXzB[/url] \n\nBottom: noise isovalues are not equidistant.\nTop: produce isolines by adding intermediate isovalues depending on slope.\n", "tags": ["procedural", "noise", "perlin"], "likes": 12, "viewed": 440, "published": 3, "date": "1618836033", "time_retrieved": "2024-07-30T19:25:02.961834", "image_code": "// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define draw(v,d)      clamp(1. - abs( fract(v-.5) - .5 ) / (d), 0.,1.)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n#define func( P )    ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n//#define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, dl, f = func(P), df;\n    if ( int(u.y) == int(R.y*.4) ) { O.r++; return; }             // red separator\n    if ( U.y > .4 ) {\n#if 0\n        l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));          // subvid amount (relative)\n        dl =     fract(log2(2.*fwidth(P.x)/fwidth(f)));      \n#else\n        l = exp2(floor(log2(1./22./fwidth(f))));                  // subvid amount (absolute)\n        dl =     fract(log2(1./22./fwidth(f)));\n#endif\n\n#if 1                                                             // draw isolines using sin\n        O = vec4(.5+.5*  mix( sin(50.*l*f) , sin(100.*l*f), dl ) ); \n#else                                                             // draw isolines 1-pixel thick\n        df = fwidth(f);\n     // df = length( ( vec2( func(P + eps.xy), func(P + eps.yx) ) -f ) / eps.x )*fwidth(P.x);\n        l *= 8.; \n        O += mix( draw(    f*l,    l*df ),\n                  draw( 2.*f*l, 2.*l*df ),\n                  dl );\n#endif\n    } \n    else {\n        f *= 8.;\n        O += draw( f, fwidth(f) );                                // draw isolines\n    }\n    \n    O = sqrt(O);                                                  // to sRGB\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXXRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[578, 578, 601, 601, 894], [896, 896, 920, 975, 1134], [1136, 1136, 1174, 1174, 2469]], "test": "untested"}
{"id": "NsXSRj", "name": "Mirrored Spheres-Torus Surface", "author": "cyperus", "description": "The Spheres-Torus quartic surface, raytraced with reflections.\nbased on\nmla@[url]https://www.shadertoy.com/view/3tVcWV[/url]\nFabriceNeyret2@[url]https://www.shadertoy.com/view/4ljyWc[/url]", "tags": ["reflection", "torus", "sphere", "raytrace", "cubic", "quartic", "lanczos"], "likes": 7, "viewed": 392, "published": 3, "date": "1618834721", "time_retrieved": "2024-07-30T19:25:04.215482", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"Mirror Spheres-Torus Quartic Surface\"\n//\n// based on original code \n// - mla --- Goursat Quartic Surface --- https://www.shadertoy.com/view/wsXGWS\n// - FabriceNeyret2 --- compared interpolation --- https://www.shadertoy.com/view/4ljyWc\n// - cyperus --- ispheres2torus Quartic Solver --- https://www.shadertoy.com/view/tddcRB\n//\n// Controls:\n// <mouse>: change view direction\n// <up/down>: zoom\n// <left/right>: cycle through some interesting parameters\n// 'c': clip at x = 0\n// 'g': show grid\n// 'r': do rotation\n// 'm': mirror surface\n// 's': no reflections\n// 'p': plain colouring\n//\n// Quartic surfaces with rotational symmetry. Surface (including normals)\n// is raytraced using analytic solution to quartic due to Lanczos with\n// cubic solver from Numerical Recipes, plus some Newton-Raphson polishing.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 1;\n\n// Lighting\nvec3 light;\nfloat ambient;\nfloat diffuse;\nfloat specular = 0.4;\nfloat specularpow = 4.0;\nvec3 specularcolor = vec3(1);\n\n// Animation\nfloat animvelocity = 0.25;    \n//#define NEAREST\n//#define LINEAR\n#define CUBICLINEAR\n//#define CATMULL    \n\nfloat evalquadratic(float x, float A, float B, float C) {\n  return (A*x+B)*x+C;\n}\n\nfloat evalcubic(float x, float A, float B, float C, float D) {\n  return ((A*x+B)*x+C)*x+D;\n}\n\n// Quadratic solver from Kahan\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic(float a, float b, float c, float d, out vec3 res) {\n  if (a == 0.0) {\n    return quadratic(b,c,d,res.xy);\n  }\n  if (d == 0.0) {\n    res.x = 0.0;\n    return 1+quadratic(a,b,c,res.yz);\n  }\n  float tmp = a; a = b/tmp; b = c/tmp; c = d/tmp;\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    res[0] = -2.0*S*cos(theta/3.0)-a/3.0;\n    res[1] = -2.0*S*cos((theta+2.0*PI)/3.0)-a/3.0;\n    res[2] = -2.0*S*cos((theta+4.0*PI)/3.0)-a/3.0;\n    return 3;\n  } else {\n    float alpha = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),0.3333);\n    float beta = alpha == 0.0 ? 0.0 : Q/alpha;\n    res[0] = alpha + beta - a/3.0;\n    return 1;\n  }\n}\n\nfloat qcubic(float B, float C, float D) {\n  vec3 roots;\n  int nroots = cubic(1.0,B,C,D,roots);\n  // Sort into descending order\n  if (nroots > 1 && roots.x < roots.y) roots.xy = roots.yx;\n  if (nroots > 2) {\n    if (roots.y < roots.z) roots.yz = roots.zy;\n    if (roots.x < roots.y) roots.xy = roots.yx;\n  }\n  // And select the largest\n  float psi = roots[0];\n  // There _should_ be a positive root, but sometimes the cubic\n  // solver doesn't find it directly (probably a double root\n  // around zero).\n  if (psi < 0.0) assert(evalcubic(psi,1.0,B,C,D) < 0.0);\n  // If so, nudge in the right direction\n  psi = max(1e-6,psi);\n  // and give a quick polish with Newton-Raphson\n  for (int i = 0; i < 3; i++) {\n    float delta = evalcubic(psi,1.0,B,C,D)/evalquadratic(psi,3.0,2.0*B,C);\n    psi -= delta;\n  }\n  return psi;\n}\n\n// The Lanczos quartic method\nint lquartic(float c1, float c2, float c3, float c4, out vec4 res) {\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int resn = quadratic(1.0,alpha+a,beta+b,res.xy);\n  vec2 tmp;\n  if (quadratic(1.0,alpha-a,beta-b,tmp) != 0) { \n    res.zw = res.xy;\n    res.xy = tmp;\n    resn += 2;\n  }\n  return resn;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Solve for the smallest cubic term, this seems to give the least wild behaviour.\n  if (abs(B/A) < abs(D/E)) {\n    nroots = lquartic(B/A,C/A,D/A,E/A,roots);\n  } else {\n    nroots = lquartic(D/E,C/E,B/E,A/E,roots);\n    for (int i = 0; i < nroots; i++) {\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  assert(nroots == 0 || nroots == 2 || nroots == 4);\n  return nroots;\n}\n\nstruct Surface {\n  vec4 params;\n  vec3 p;\n};\n\nint spheres2torussurface(Surface surface, in vec3 o, in vec3 d, out vec4 roots) {\n    \n\t/*\n\tray is defined by p(t) = o + t*d\n\tin vec3 p : intersection point (x,y,z)\n\tin vec3 o : ray-origin\n\tin vec3 d : ray-direction\n\tout vec4 roots: values roots\n\tout int number solutions from{0,1,2,3,4}\n    \n    surface is defined by (x^2+y^2-z^2-co)^2+4.0*(x^2+y^2)*z^2-cr^2=0\n    float cr : circle radius\n\tfloat co : circle origine\n\tafter some calculations you get the quartic equation\n\tA * t^4 + B * t^3 + C * t^2 + D * t^1 + E = 0\n\t*/\n    \n\t// not used = surface.params[0];\n\t// not used = surface.params[1];    \n\tfloat co = surface.params[2];    \n\tfloat cr = surface.params[3];\n    \n\n    if (co == 0.) {\n        //Sphere => quadratic equation\n        vec2 res;\n        int resn = quadratic(1.0, 2.0*dot(o,d), dot(o,o)-cr*cr, res);\n        roots = vec4(res, 0.,0.);\n        return resn;\n    }\n    else{\n    \t// commun factors\n        float oo2 = o.x*o.x+o.y*o.y, oo3 = oo2-o.z*o.z; // squares\n        float dd2 = d.x*d.x+d.y*d.y, dd3 = dd2-d.z*d.z;\n        float od2 = o.x*d.x+o.y*d.y, od3 = od2-o.z*d.z; // mixed products\n        float k = co*co-cr*cr; // const\n        // quartic equation coefficients\n        float A = \t dd3*dd3\n                    +4.0*dd2*d.z*d.z;\n        float B =  4.0*(\n                    +od3*dd3\n                    +2.0*d.z*(od2*d.z+dd2*o.z)\n                        );\n        float C =  2.0*(\n                    +(2.0*od3*od3+dd3*oo3) \n                    -co*dd3\n                    +2.0*(oo2*d.z*d.z+4.0*od2*o.z*d.z+dd2*o.z*o.z)\n                        );\n        float D =  4.0*(\n                    +oo3*od3\n                    -co*od3\n                    +2.0*o.z*(oo2*d.z+od2*o.z)\n\t\t\t\t\t);\n        float E = \t oo3*oo3\n                    -2.0*co*oo3\n                    +4.0*oo2*o.z*o.z\n                    +k;\n  \n      return quartic(A,B,C,D,E,roots);\n      }\n}\n\nvec3 spheres2torusnormal(Surface surface, vec3 p) {\n\t// not used = surface.params[0];\n\t// not used = surface.params[1];    \n\tfloat co = surface.params[2];    \n\tfloat cr = surface.params[3];\n    \n    // surface gradient\n    if (cr == 0.) \n        return 2.*p;\n    else\n        return 4.0*((p.x*p.x+p.y*p.y-p.z*p.z-co)*vec3(p.x,p.y,-p.z)\n                    + 2.0*p.z*vec3(p.x*p.z,p.y*p.z,p.x*p.x+p.y*p.y));\n}\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nstruct Result {\n  vec3 p;\n  vec3 n;\n  vec3 color;\n  float t;\n};\n\nfloat gridline(vec3 p) {\n  // Draw some gridlines on surface\n  vec3 t = fract(p*4.0);\n  t = min(t,1.0-t);\n  float d = min(t.x,min(t.y,t.z));\n  return smoothstep(0.02,0.025,d);\n}\n\nint dosurface(Surface surface, vec3 p0, vec3 r, out vec4 roots) {\n  return spheres2torussurface(surface,p0,r,roots);\n}\n  \nvec3 donormal(Surface surface, vec3 p) {\n  return spheres2torusnormal(surface,p);\n}\n  \nbool solve(Surface surface, vec3 p0, vec3 r, float tmin, inout Result result) {\n  vec4 roots;\n  int nroots = dosurface(surface,p0,r,roots);\n  // Find smallest root greater than tmin.\n  float t = result.t;\n  for (int i = 0; i < 4; i++) {\n    if (i == nroots) break;\n    if (roots[i] > tmin && roots[i] < t) {\n      vec3 p = p0+roots[i]*r;\n      if (!key(CHAR_C) || p.x > 0.0) { // clip at x == 0\n        t = roots[i];\n      }\n    }\n  }\n  if (t == result.t) return false;\n  vec3 p = p0 + t*r;\n  vec3 n = donormal(surface, p);\n  if (dot(n,r) > 0.0) n = -n;\n  n = normalize(n);\n  vec3 basecolor = abs(n);\n  basecolor *= gridline(p);\n  if (key(CHAR_P)) basecolor = vec3(0.8);\n  result.p = p; result.n = n; result.color = applylighting(basecolor,p,n,r);\n  return true;\n}\n\nSurface surface;\n\nvec3 scene(vec3 p, vec3 r) {\n  vec3 color = vec3(0);\n  float att = 1.0;\n  for (int i = 0; i < 6; i++) {\n    // If we've hit the surface some distance from origin,\n    // stop reflecting.\n    if (dot(p,p) > 1000.0) break;\n    // Solve from closest point to origin.\n    // This makes p.r = 0.\n    float tmin = -dot(p,r);\n    p += tmin*r;\n    Result res = Result(vec3(0),vec3(0),vec3(0),1e8);\n    if (!solve(surface,p,r,-tmin,res)) break;\n    if (key(CHAR_P) || key(CHAR_S)) return res.color;\n    color += att*res.color;\n    att *= 0.5;\n    p = res.p;\n    r = reflect(r,res.n);\n    p += 0.001*r;\n  }\n  if (key(CHAR_P)) return vec3(0.5);\n  if (key(CHAR_M)) return texture(iChannel1,r).xyz;  \n  return color + att*pow(abs(r),vec3(2));\n}\n\n// animation spheres2torus surface\nint nanimparams = 10;\nvec4 animparams(int i) {\n  if (i == 0) return vec4(0,0,0,1);\n  if (i == 1) return vec4(0,0,-1,1);\n  if (i == 2) return vec4(0,0,-1,1);\n  if (i == 3) return vec4(0,0,3,1);\n  if (i == 4) return vec4(0,0,3,1);  \n  if (i == 5) return vec4(0,0,-3,1);\n  if (i == 6) return vec4(0,0,-3,1);\n  if (i == 7) return vec4(0,0,1,1);\n  if (i == 8) return vec4(0,0,1,1);\n  else        return vec4(0,0,0,1);\n\n}\n\nint imod(int n, int m) {\n    return n-n/m*m;\n}\n\n// by FabriceNeyret2 --- compared interpolation --- https://www.shadertoy.com/view/4ljyWc\nvec4 nearest(vec4 v1) {\n    return v1;\n    }\n\nvec4 linear(vec4 v1, vec4 v2, float t) {\n    return mix(v1,v2,t);\n    }\n\nvec4 cubiclinear(vec4 v1, vec4 v2, float t) {\n    return mix(v1,v2,smoothstep(0.,1.,t));\n    }\n\nvec4 catmull(vec4 v0, vec4 v1, vec4 v2, vec4 v3, float t) {\n\tvec4 A0 = mix( v0, v1, t+1.),\n\t     A1 = mix( v1, v2, t),\n\t     A2 = mix( v2, v3, t-1.),\n         B0 = mix( A0, A1, .5*t + .5),\n\t     B1 = mix( A1, A2, .5*t);\n\treturn mix( B0, B1, t);\n    }\n\nvoid init() {\n  float ttime = animvelocity*iTime;\n  float rtime = floor(ttime);\n  ttime -= rtime;\n  \n  vec4 params;\n  int isurface = max(0,keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  isurface %= nanimparams;+1;\n  if (isurface == 0) {\n    // get parameter id for interpolation\n    ivec4 param_id = ivec4(\n        int(rtime-1.0)%nanimparams,\n        int(rtime)%nanimparams,\n        int(rtime+1.0)%nanimparams,\n        int(rtime+2.0)%nanimparams);\n    // get parameter values with selected interpolation\n    #ifdef NEAREST\n    params = nearest(animparams(param_id[2]));\n    #endif\n    #ifdef LINEAR    \n    params = linear(animparams(param_id[1]),\n                    animparams(param_id[2]), ttime);\n    #endif\n    #ifdef CUBICLINEAR \n    params = cubiclinear(animparams(param_id[1]),\n                         animparams(param_id[2]), ttime);\n    #endif\n    #ifdef CATMULL \n    params = catmull(animparams(param_id[0]),\n                     animparams(param_id[1]),\n                     animparams(param_id[2]),\n                     animparams(param_id[3]), ttime);\n    #endif\n  } else {\n    params = animparams(isurface-1);\n  }\n  surface = Surface(params,vec3(0));\n}\n\n// GUI related code starts here\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = iTime + 3.5;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = vec3(1,1,-1);\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n  specular = 0.8;\n  specularpow = 10.0;\n\n  float scale = 1.0;\n  float camera = 4.0;\n  \n  vec3 p = vec3(0.0, 0.0, -camera);\n  p *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  init();\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n     for (int j = 0; j < AA; j++) {\n       vec2 uv = scale*(2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n       vec3 r = normalize(vec3(uv, 2.0));\n       r = transform(r);\n       r = normalize(r);\n       color += scene(p,r);\n     }\n  }\n  color /= float(AA*AA);\n  color = pow(color,vec3(0.4545));\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n// Common\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n// Debug\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\n#define assert(x)\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}", "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXSRj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1340, 1340, 1397, 1397, 1421], [1423, 1423, 1485, 1485, 1515], [1517, 1548, 1604, 1604, 1836], [1838, 1896, 1957, 1957, 2764], [2766, 2766, 2807, 2807, 3583], [3585, 3615, 3683, 3683, 4197], [4199, 4199, 4273, 4273, 4656], [4704, 4704, 4785, 5304, 6590], [6592, 6592, 6643, 6715, 6999], [7001, 7001, 7061, 7061, 7298], [7365, 7365, 7389, 7425, 7542], [7544, 7544, 7609, 7609, 7662], [7666, 7666, 7706, 7706, 7749], [7753, 7753, 7832, 7832, 8517], [8537, 8537, 8565, 8565, 9268], [9327, 9327, 9351, 9351, 9720], [9722, 9722, 9746, 9746, 9768], [9770, 9860, 9883, 9883, 9904], [9906, 9906, 9946, 9946, 9977], [9979, 9979, 10024, 10024, 10073], [10075, 10075, 10134, 10134, 10325], [10327, 10327, 10340, 10340, 11491], [11493, 11525, 11552, 11552, 11902], [11904, 11904, 11961, 11961, 12733]], "test": "untested"}
{"id": "fdfSRj", "name": "colored balanced isolines", "author": "FabriceNeyret2", "description": "Bottom: noise isovalues are not equidistant.\nTop: produce isolines by adding intermediate isovalues depending on slope.", "tags": ["procedural", "noise", "perlin"], "likes": 9, "viewed": 316, "published": 3, "date": "1618834533", "time_retrieved": "2024-07-30T19:25:05.116074", "image_code": "// color variant of   https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define draw(v,d)      clamp(1. - abs( fract(v) - .5 ) / fwidth(d), 0.,1.)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n#define func( P )    ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n//#define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, f = func(P), df;\n\n // l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));     // subvid amount (relative)\n    l = exp2(floor(log2(1./22./fwidth(f))));             // subvid amount (absolute)\n    O = (.5+.5*sin(50.*l*f)) * hue(l*f);\n\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfSRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[576, 576, 599, 599, 892], [894, 894, 918, 973, 1132], [1134, 1134, 1172, 1172, 1535]], "test": "untested"}
{"id": "7dsXzB", "name": "Okayish Worley Clouds", "author": "Zerofile", "description": "It's pretty okay", "tags": ["noise"], "likes": 1, "viewed": 259, "published": 3, "date": "1618832812", "time_retrieved": "2024-07-30T19:25:06.232090", "image_code": "#define INVERSE_CLOUD_SIZE 0.5\n#define CLOUD_FALLOFF      0.15\n\n/*\nThis is rendering 6 overlapped 3D Worley Maps\n\nBy: Sir Bird / Zerofile\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    col = pow(col,vec3(INVERSE_CLOUD_SIZE))*(col*col*col+col*col);\n    col -= CLOUD_FALLOFF;\n    col = max(col,vec3(0.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 hash33(ivec3 p3)\n{   // HASH FUNCTION CREDIT: Dave_Hoskins\n    vec3 vp3 = vec3(p3);\n\tvp3 = fract(vp3 * vec3(.1031, .1030, .0973));\n    vp3 += dot(vp3, vp3.yxz+33.33);\n    return fract((vp3.xxy + vp3.yxx)*vp3.zyx);\n\n}\n\nfloat worleyNoise (vec3 uv) {\n\n    ivec3 pixelCoord = ivec3(uv);\n    vec3 local = fract(uv);\n    \n    float minLen = 3.;\n    \n    for (int x = -1; x <= 1; x++) {\n        vec3 relativeDistance;\n        relativeDistance = hash33(pixelCoord+ivec3(x,-1,-1))+vec3(x,-1.,-1.)-local;\n        float a = dot(relativeDistance,relativeDistance);\n        relativeDistance = hash33(pixelCoord+ivec3(x,-1,0))+vec3(x,-1.,0.)-local;\n        float b = dot(relativeDistance,relativeDistance);\n        relativeDistance = hash33(pixelCoord+ivec3(x,-1,1))+vec3(x,-1.,1.)-local;\n        float c = dot(relativeDistance,relativeDistance);\n        relativeDistance = hash33(pixelCoord+ivec3(x,0,-1))+vec3(x,0.,-1.)-local;\n        float a2 = dot(relativeDistance,relativeDistance);\n        relativeDistance = hash33(pixelCoord+ivec3(x,0,0))+vec3(x,0.,0.)-local;\n        float b2 = dot(relativeDistance,relativeDistance);\n        relativeDistance = hash33(pixelCoord+ivec3(x,0,1))+vec3(x,0.,1.)-local;\n        float c2 = dot(relativeDistance,relativeDistance);\n        relativeDistance = hash33(pixelCoord+ivec3(x,1,-1))+vec3(x,1.,-1.)-local;\n        float a3 = dot(relativeDistance,relativeDistance);\n        relativeDistance = hash33(pixelCoord+ivec3(x,1,0))+vec3(x,1.,0.)-local;\n        float b3 = dot(relativeDistance,relativeDistance);\n        relativeDistance = hash33(pixelCoord+ivec3(x,1,1))+vec3(x,1.,1.)-local;\n        float c3 = dot(relativeDistance,relativeDistance);\n        minLen = min(min(min(min(min(a,b),min(c,a2)),min(min(b2,c2),min(a3,b3))),c3),minLen);\n        \n    }\n    return sqrt(minLen);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col;\n    col = mix(col,1.-vec3(worleyNoise(vec3(uv*5.,iTime/6.))),1.);\n    col = mix(col,1.-vec3(worleyNoise(vec3(7.)+vec3(uv*7.,iTime/5.))),0.4);\n    col = mix(col,1.-vec3(worleyNoise(vec3(uv*10.,iTime/2.))),0.3);\n    col = mix(col,1.-vec3(worleyNoise(vec3(uv*20.,iTime))),0.1);\n    col = mix(col,1.-vec3(worleyNoise(vec3(uv*30.,iTime))),0.08);\n    col = mix(col,1.-vec3(worleyNoise(vec3(uv*50.,iTime))),0.05);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 199, 199, 447]], "test": "untested"}
{"id": "sdsXzB", "name": "noise balanced isolines - subdiv", "author": "FabriceNeyret2", "description": "Bottom: noise isovalues are not equidistant.\nTop: produce isolines by adding intermediate isovalues depending on slope.", "tags": ["procedural", "noise", "perlin"], "likes": 4, "viewed": 285, "published": 3, "date": "1618832181", "time_retrieved": "2024-07-30T19:25:07.004026", "image_code": "// Fork of \"test1: Noise balance\"           https://shadertoy.com/view/ssXXWN\n\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define draw(v,d)      clamp(1. - abs( fract(v) - .5 ) / fwidth(d), 0.,1.)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n#define func( P )    ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n//#define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, f = func(P), df;\n    if ( int(u.y) == int(R.y*.4) ) { O.r++; return; } // red separator\n    if ( U.y > .4 ) {\n     // l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));     // subvid amount (relative)\n        l = exp2(floor(log2(1./22./fwidth(f))));             // subvid amount (absolute)\n        O = vec4(.5+.5*sin(50.*l*f)); return; \n       df = fwidth(f);\n    // df = length( ( vec2( func(P + eps.xy), func(P + eps.yx) ) -f ) / eps.x )*fwidth(P.x);\n        l*=6.3; O += clamp(1. - .8*abs( fract(f*l) - .5 ) / df/l, 0.,1.); return; \n    } \n    else  f*=8.;\n    O += draw(f,f);                                               // draw isolines\n    O = sqrt(O);                                                  // to sRGB\n\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[599, 599, 622, 622, 915], [917, 917, 941, 996, 1155], [1157, 1157, 1195, 1195, 2047]], "test": "untested"}
{"id": "sdsXRB", "name": "testttt1233", "author": "wei", "description": "testttt1233", "tags": ["testttt1233"], "likes": 2, "viewed": 203, "published": 3, "date": "1618827229", "time_retrieved": "2024-07-30T19:25:07.778954", "image_code": "float circle(in vec2 _st, in float _radius){\n    if(_st.y<0.5) {\n        return 0.;\n    }\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*3.360);\n}\n\nfloat ring(in vec2 _st, in float _radius) {\n    return circle(_st,_radius)- circle(_st,_radius*0.8);\n}\n\nvec3 Rainbow(vec2 st) {\n    st = fract(st);\n\tfloat r = 0.28;\n\tfloat c1 = ring(st,r);\n    float c2 = ring(st,r*0.6);\n    float c3 = ring(st,r*0.6*0.6);\n    vec3 color = vec3(0.);\n    color += mix(color, vec3(1.000,0.185,0.499),c2);\n    color += mix(color, vec3(0.345,0.095,1.000),c3);\n\tcolor += mix(color, vec3(1.000,0.331,0.245),c1);\n    return color;\n}\n\nvec2 movingTiles(vec2 _st, float _zoom, float _speed){\n    _st *= _zoom;\n    float time = iTime*_speed;\n    if (fract( _st.y * 0.5) > 0.5){\n            _st.x += fract(time)*2.0;\n        } else {\n            _st.x -= fract(time)*2.0;\n        }\n    return fract(_st);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    st = movingTiles(st,4.,0.1);\n    vec3 col =vec3(0.);\n    vec3 rainbow = Rainbow(st);\n\tcol = rainbow;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 265], [267, 267, 310, 310, 369], [371, 371, 394, 394, 724], [726, 726, 780, 780, 993], [995, 995, 1052, 1052, 1251]], "test": "untested"}
{"id": "7ssSD4", "name": "Not a 16-cell honeycomb", "author": "jeyko", "description": "uuh", "tags": ["projection", "4d", "mdtmjvm"], "likes": 7, "viewed": 269, "published": 3, "date": "1618826347", "time_retrieved": "2024-07-30T19:25:08.549893", "image_code": "// Failed attempt at doing 16-cell reflections\n// thought it looked fun tho\n\n\n// Fork of \"Day 486[4d projected fractal]\" by jeyko. https://shadertoy.com/view/7dXXD4\n// 2021-04-17 09:42:03\n\n// Fork of \"Day 485[4d projected apollonian]\" by jeyko. https://shadertoy.com/view/fdXSD4\n// 2021-04-17 05:50:39\n\n// Performance vars\n\nfloat sliceCnt = 80.;\nfloat marchSteps = 30.;\nfloat dMult = 1.;\n\n\n// Coeff vars\n\nfloat rotSpd = .3;\nfloat fov4D = 0.4;     // scale up the sliceZDepth when widening the fov\nfloat sliceZDepth = 2.5; \nfloat minT = 10e5;\n\nfloat normalEps = 0.01;\nfloat distEps = 0.001;\nfloat distOffs = 0.;\n\nfloat ditherAmt = 0.5;\n\n#define DEBUG 0\n#define TUBES 1\nvec4 C;\nvec2 muv;\n\n\n\nfloat lattice16Cell(inout vec4 p){\n    \n    float dpp = dot(p,p);\n    dpp = 1.;\n    \n    //p.w = -p.w;\n    p /= dpp;\n    \n    \n    float sz =0.4;\n    for(float i = 0.; i < 3.; i++){\n       p = abs(p);\n       vec4 r = -normalize(vec4(1.,1,1,1));\n       \n       /*\n           r = vec4(0,1,0,0);\n           r.xy *= rot(-pi/4.);\n           r.zx *= rot(-pi/4.);\n           r.yw *= rot(pi/4.);\n           r = -r;\n       */\n       refl(p,r,sz);\n    }\n    \n    \n    //d.x = length(p) - 0.1;\n    \n    vec2 d = vec2(10e5);;\n    \n    #if 1\n        d.x = length(p.xzy);\n        d.x = min(d.x,length(p.xzw));\n        d.x = min(d.x,length(p.yzw)); \n        d.x = min(d.x,length(p.yxw));\n    #endif\n    \n    d.x = min(d.x,length(p) - 0.05);\n    return d.x*dpp;\n\n}\n\n\n\nvec2 map(vec4 p){\n    p -= vec4(.0,.0,.5,.5);\n    vec2 d;\n    vec4 orbit;\n    \n        p.yw *= rot( iTime*0.2*rotSpd );\n        p.yx *= rot( iTime*0.1*rotSpd );\n        p -= 0.2;\n\n        p.yz *= rot( iTime*1.3*rotSpd );\n        p.zw *= rot( iTime*1.*rotSpd );\n\n        p.xw *= rot( iTime*0.5*rotSpd );\n    \n    \n    //d.x = sdBoxEdges(p, vec4(0.4), 0.005);\n    //d.x =  sdTesseractFrame(  p, vec4(0.4), 0.01 );\n    \n    \n    d.x = lattice16Cell(p);\n    vec2 a;\n    //d.x = fTorus(p, a);\n\n    \n    d.x -= 0.01;\n    return d;\n}\n\nvec4 getNormal(vec4 p){\n    vec2 t = vec2(normalEps,0.00);\n    return normalize(map(p).x-vec4(\n        map(p-t.xyyy).x,\n        map(p-t.yxyy).x,\n        map(p-t.yyxy).x,\n        map(p-t.yyyx).x));\n}\n\n// suggested from tdhooper. Thanks!\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 8;\nvec4 getNormala(vec4 pos) {\n\n    vec4 eps = vec4(normalEps*1., 0, 0,0.);\n\t\n\tvec4 nor = vec4(0);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < NORMAL_STEPS; i++) {\n\t\tnor += map(pos + eps * invert).x * eps * invert;\n\t\teps = eps.wxyz;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*vec2(172.412,735.124)+uv.yx*vec2(97.354,421.653)+vec2(94.321,37.365)),vec2(4.6872,7.9841))+0.71243);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    C = 0.45*cos( vec4(0.5,3.9,1.4,1.1) + 0.15*iTime*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n\n    muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    muv *= 6.28;\n\n    vec3 col = vec3(0);\n\n\n    #if DEBUG\n    \n        vec3 gro = vec3(sin(muv.x),0,cos(muv.x))*sliceZDepth*1.5;\n        vec3 grd = normalize(vec3(uv,1));\n\n        gro.yz *= rot(-muv.y);\n        grd.yz *= rot(-muv.y);\n        grd.xz *= rot(-muv.x);\n\n    #endif\n    \n    \n    bool hitAtLeastOnce = false;\n    float dither = texture(iChannel1,(fragCoord)/1024.).x*2. - 1.;\n        \n    const vec3 fogCol = vec3(0.6,0.6,0.56)*1.;\n        \n    for(float slice = 0.; slice < sliceCnt; slice++){\n          \n        #if DEBUG\n            vec3 sliceUv = gro + grd * plaIntersect( gro + vec3(0,0,1)*slice/sliceCnt*1.*sliceZDepth , grd, vec4(0,0,-1,0) );\n        #else\n            vec2 sliceUv = uv*(1. +  slice/sliceCnt);\n        #endif\n        \n        \n        vec4 rd = normalize(vec4(sliceUv.xy,sliceZDepth*((slice + dither*ditherAmt)/sliceCnt - 0.5),fov4D));\n        \n        vec4 p = vec4(0.); \n       \n        bool hit = false;\n        vec2 d;\n        float glow = 0.;\n        float t = 0.;\n       \n    \n        for(float st = 0.; st < marchSteps; st++){\n            d = map(p);\n            d.x += distOffs;\n            if(d.x < distEps){\n                hit = true;\n                break;\n            } else if (t > 4.5){\n                break;\n            }\n            \n            d.x *= dMult;\n            t += d.x;\n            p += rd*d.x;\n        }\n        \n\n          \n        if(hit && t < minT){\n            minT = t;\n            hitAtLeastOnce = true;\n            vec4 n = getNormal(p); \n            \n            col = (pal(0.5,0.5*vec3(1.+ sin( p.w*6.)*0.,1.,1.),vec3(0.4,1.,1.5),1.,4.*dot(n,rd)));\n            //col = pow(abs(col),vec3(1.8));\n            //col *= AO(.1)*AO(.01)*AO(.04)*AO(.08)*AO(.13);\n            \n            col *= AO(.1)*AO(1.01)*2.;\n            \n            \n            col = mix(col,fogCol,smoothstep(0.,1.,(t)*.56- 0.5));\n            //col = mix(col,fogCol,0.7-exp(-t));\n            \n            }\n        \n        \n    }\n\n    if(!hitAtLeastOnce)\n        col = fogCol;\n    // reinhardt and sutff\n    col = 1./(1. + 1./col);\n    //col = 1. - exp(-col*1.);\n    col = ACESFilm(col);\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + e))\n\n#define AO(a) smoothstep(0.,1.,map(p+n*a).x/a)\n\n#define pi acos(-1.)\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n/*\nvec4 getNormala(vec4 p){\n    vec2 t = vec2(0.0004,0.00);\n    return normalize(vec4(\n        map(p+t.xyyy).x - map(p-t.xyyy).x,\n        map(p+t.yxyy).x - map(p-t.yxyy).x,\n        map(p+t.yyxy).x - map(p-t.yyxy).x,\n        map(p+t.yyyx).x - map(p-t.yyyx).x));\n}\n*/\n\n\nvoid refl(inout vec4 p, vec4 reflectionPlane, float offs){\n\n    reflectionPlane = normalize(reflectionPlane);\n    float dotReflectionPlane = dot(p + reflectionPlane*offs,reflectionPlane);\n    dotReflectionPlane = max(abs(dotReflectionPlane),0.)*sign(dotReflectionPlane);\n    p -= min(dotReflectionPlane,0.)*2.*reflectionPlane;\n}\nfloat hypercubeLattice(inout vec4 p){\nfloat sz = 0.4;\n    for(float i = 0.; i < 2.; i++){\n       p = abs(p);\n       refl(p,-vec4(0.,1.,0.,0.),sz);\n       refl(p,-vec4(1.,0.,0.,0.),sz);\n       refl(p,-vec4(0.,0.,1.,0.),sz);\n       refl(p,-vec4(0.,0.,0.,1.),sz);\n       \n    \n    }\n    \n    \n    //d.x = length(p) - 0.1;\n    \n    vec2 d;\n    d.x = length(p.xzy);\n    \n    d.x = min(d.x,length(p.xzw));\n    \n    d.x = min(d.x,length(p.yzw));\n    \n    d.x = min(d.x,length(p.yxw));\n    \n    d.x = min(d.x,length(p) - 0.03);\n    return d.x;\n\n}\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nfloat sdBox(vec4 p, vec4 s){p = abs(p) - s; return max(p.x,max(p.y,max(p.z,p.w)));}\n\n\nfloat sdBoxEdges(vec4 p, vec4 s, float edgeW){\n    float d = sdBox(p, s);\n    \n    vec2 e = vec2(edgeW,0.);\n    d = abs(d) - edgeW*0.1;\n    edgeW *= 1.5;\n    vec4 q = p;\n    /*\n    q.x = abs(q.x);\n    d = max(d, -sdBox(q- vec4(s.x,0,0,0), vec4(edgeW,s.y,s.z,s.w) - e.yxxx));\n    q = p;\n    q.y = abs(q.y);\n    d = max(d, -sdBox(q- vec4(0,s.y,0,0), vec4(s.x,edgeW,s.z,s.w) - e.xyxx));\n    q = p;\n    q.z = abs(q.z);\n    d = max(d, -sdBox(q- vec4(0,0,s.z,0), vec4(s.x,s.y,edgeW,s.w) - e.xxyx));\n    q = p;\n    q.w = abs(q.w);\n    d = max(d, -sdBox(q- vec4(0,0,0,s.w), vec4(s.x,s.y,s.z,edgeW) - e.xxxy));\n    */\n    \n    //d = max(d,-length(q.xyz) );\n    //d = max(d, -sdBox(p, s - vec4(edgeW,-cuttingEdgeW,edgeW,edgeW)));\n    //d = max(d, -sdBox(p, s - vec4(edgeW,edgeW,-cuttingEdgeW,edgeW)));\n    //d = max(d, -sdBox(p, s - vec4(edgeW,edgeW,edgeW,-cuttingEdgeW)));\n    \n    return d;\n}\n\n\n#define max4v(v) max(max(v.x, v.y), max(v.z, v.w))\n#define min4(x,y,z,w) min(min(x, y), min(z, w))\n\n\n#define dmin(d,b) d.x < b ? d : vec2(b,d.y + 1.)\nfloat sdTesseractFrame( vec4 p, vec4 b, float e ) { \n  p = abs(p)-b; \n  vec4 q = abs(p+e)-e; \n  mat4 t = mat4(\n        p.x, q.y, q.z, q.w,\n        q.x, p.y, q.z, q.w,\n        q.x, q.y, p.z, q.w,\n        q.x, q.y, q.z, p.w\n  );\n  return min4(\n        length(max(t[0], 0.0)+min(max4v(t[0]),0.0)),\n        length(max(t[1], 0.0)+min(max4v(t[1]),0.0)),\n        length(max(t[2], 0.0)+min(max4v(t[2]),0.0)),\n        length(max(t[3], 0.0)+min(max4v(t[3]),0.0))\n  );\n}\n\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssSD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[689, 689, 723, 723, 1437], [1441, 1441, 1458, 1458, 1967], [1969, 1969, 1992, 1992, 2167], [2276, 2276, 2303, 2303, 2548], [2550, 2550, 2570, 2570, 2699], [2702, 2702, 2759, 2759, 5182]], "test": "untested"}
{"id": "sdsXzS", "name": "Pentakis Dodecahedron", "author": "dr2", "description": "Pentakis dodecahedra (60 triangular faces): solid surrounded by sphericalized shell edges.", "tags": ["symmetry", "polyhedron"], "likes": 15, "viewed": 322, "published": 3, "date": "1618821594", "time_retrieved": "2024-07-30T19:25:09.405605", "image_code": "// \"Pentakis Dodecahedron\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir;\nfloat tCur, dstFar, rEx, rIn;\nint idObj;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 DodecSym (vec3 p)\n{   // (from \"Chinese Puzzle Balls 2\")\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, - 0.1 * pi);\n  p.x = - abs (p.x);\n  for (int k = VAR_ZERO; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.y = - abs (p.y);\n    p.zy = Rot2Cs (p.zy, csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a1, a2;\n  dMin = dstFar;\n  q = DodecSym (p);\n  a1 = 0.5 * acos (- 1. / sqrt (5.));\n  a2 = 0.5 * acos (- (80. + 9. * sqrt (5.)) / 109.);\n  d = abs (length (q) - rEx) - 0.1;\n  d = SmoothMax (d, min (dot (q.yz, sin (a1 - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.)))) - 0.06, 0.04);\n  DMIN (1);\n  d = - dot (q.yz, sin (a1 - a2 + vec2 (0., 0.5 * pi))) - rIn;\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col;\n  vec2 u;\n  float el, f;\n  el = asin (rd.y);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 64.;\n  col = mix (vec3 (0.1, 0.2, 0.4), vec3 (0.8), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, vec3 (0.2, 0.3, 0.4), smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, ds4;\n  vec3 col, vn, roo;\n  float dstObj, nDotL, sh;\n  rEx = 2.;\n  rIn = 0.8 + 0.4 * sin (tCur);\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (1., 0.8, 0.2, 0.2) * (0.95 + 0.05 * sin (32. * pi * length (ro)));\n    else if (idObj == 2) col4 = vec4 (0.8, 1., 0.2, 0.3);\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotL * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  } else {\n    col = BgCol (rd);\n  }\n  ds4 = SphHit (roo, rd, rEx + 0.06);\n  if (ds4.x < min (dstObj, dstFar)) {\n    vn = ds4.yzw;\n    col = mix (col * vec3 (0.9, 1., 0.9), BgCol (reflect (rd, vn)),\n       0.1 + 0.9 * pow (1. - max (- dot (rd, vn), 0.), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el -= 0.15 * pi * sin (0.01 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -12.);\n  zmFac = 5.2;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXzS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[468, 468, 492, 529, 1087], [1089, 1089, 1111, 1111, 1557], [1559, 1559, 1592, 1592, 1775], [1777, 1777, 1798, 1798, 2055], [2057, 2057, 2094, 2094, 2323], [2325, 2325, 2368, 2368, 2569], [2571, 2571, 2593, 2593, 2955], [2957, 2957, 2992, 2992, 3891], [3935, 3935, 3991, 3991, 5035], [5037, 5037, 5068, 5068, 5132], [5134, 5134, 5179, 5179, 5282], [5284, 5284, 5329, 5329, 5367], [5369, 5369, 5405, 5405, 5611], [5613, 5613, 5643, 5643, 5756], [5790, 5790, 5814, 5814, 5926], [5928, 5928, 5953, 5953, 6139], [6141, 6141, 6162, 6162, 6317]], "test": "untested"}
{"id": "7dsXRS", "name": "In Another Cosmos", "author": "tomachi", "description": "This is largely an exact clone of Michael0884 inspirational work at: https://www.shadertoy.com/view/WtfyDj but with a few precious operations had their values increased to make it more vigorous! https://michaelmoroz.github.io/Reintegration-Tracking/\n ", "tags": ["multipass"], "likes": 10, "viewed": 1230, "published": 3, "date": "1618813590", "time_retrieved": "2024-07-30T19:25:10.293231", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n   // return mix(a*a, b*b, clamp(k,0.,1.)) * vec3(sin(iTime *1.01)) ;\n\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime * 200.0 ;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-2., 0., 2.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.5, 0.);\n    vec3 col1 = vec3(0.1, 0.4, 1.);\n\tvec3 fcol = mixN(col0, col1, tanh(3.*(rho.w - 0.7))*0.5 + 0.5);\n    // Output to screen\n  //   col = vec4(2.5);\n    col = rho;\n    col.xyz = mixN(col.xyz, fcol.xyz*(1.05*b + specular*5.), a);\n    col.xyz = mixN(col.xyz, 0.*vec3(0.5,0.5,1.), bord);\n    col.xyz = tanh(col.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(vec2 rho)\n{\n    //return 0.2*rho.x; //gas\n    float GF = 1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.12\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}\n\n/*\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}*/\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = 0.9 + 0.21*smoothstep(fluid_rho*0., fluid_rho*0.333, P0.M.x);\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n    \n    //gravity\n    F += P.M.x*vec2(0., -0.0004);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.) \n        {\n            P.X = pos;\n            P.V = 100.5*(rand.xy-0.5) + vec2(10., 0.);\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    if(length(P.X - R*vec2(0.8, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 - PI*0.5 + 0.3*sin(0.4*time));\n        P.M = mix(P.M, vec2(fluid_rho, 1.), 0.4);\n    }\n\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 243, 313, 364], [366, 366, 382, 382, 410], [412, 412, 457, 457, 1648]], "test": "untested"}
{"id": "NdsXRB", "name": "Watercolor painting", "author": "jarble", "description": "I don't know what this pattern is, but I really like it.", "tags": ["fractal", "watercolor", "bitwise", "surrealism"], "likes": 12, "viewed": 646, "published": 3, "date": "1618799568", "time_retrieved": "2024-07-30T19:25:11.119024", "image_code": "//#define ITERS 9 //normal world map\n#define ITERS 12 //swamp world\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 10000.0;\n    float trans = iTime * scale/8.0;\n    vec2 coord = (scale * fragCoord/iResolution.xy) + vec2(trans+30000.0,0.0);\n    \n    // Heart of color selection.\n    int val = 0;\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev = vec3(0.0);\n    for(int i = 0; i < ITERS; i++){\n        col_prev = col;\n        coord.y -= (4.0-result);\n        coord += coord.yy/8.0;\n        coord = coord.yx/(3.0);\n        coord.x *= -1.5;\n        result = ((result + float(val = ((int(coord.x*2.0-coord.y/2.0) & int(coord.y*2.0+coord.x/2.0)) % 3)))/(2.0));\n        col.x = result;\n        col = ((col.yzx)*3.0+col_prev)/4.0;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsXRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NssSRB", "name": "Volcanic planet map", "author": "jarble", "description": "Another bitwise planet map. It looks somewhat like the surface of Titan.", "tags": ["fractal", "planet", "map", "desert", "bitwise", "volcanic"], "likes": 5, "viewed": 304, "published": 3, "date": "1618796784", "time_retrieved": "2024-07-30T19:25:11.983712", "image_code": "//#define ITERS 9 //normal world map\n#define ITERS 12 //swamp world\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 10000.0;\n    float trans = iTime * scale/8.0;\n    vec2 coord = (scale * fragCoord/iResolution.xy) + vec2(trans+30000.0,0.0);\n    \n    // Heart of color selection.\n    int val = 0;\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev = vec3(0.0);\n    for(int i = 0; i < ITERS; i++){\n        col_prev = col;\n        coord.y -= (4.0-result);\n        coord += coord.yy/16.0;\n        coord = coord.yx/(3.0);\n        result = ((result + float(val = ((int(coord.x*2.0-coord.y/2.0) & int(coord.y*2.0+coord.x/2.0)) % 3)))/(2.0));\n        col.x = result;\n        col = ((col.yzx)*3.0+col_prev)/4.0;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdXSzB", "name": "Bitwise Alien landscape FORK", "author": "deerfeeder", "description": "A cloudy landscape generated using a bitwise formula.", "tags": ["fractal", "cloud", "bitwise"], "likes": 4, "viewed": 251, "published": 3, "date": "1618791346", "time_retrieved": "2024-07-30T19:25:12.747669", "image_code": "// Fork of \"Bitwise cloud landscape\" by jarble. https://shadertoy.com/view/7slSDM\n// 2021-04-18 19:42:52\n\n#define ITERS 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale =7000.0;\n    float trans = iTime * 220.0;\n    vec2 coord = (scale * fragCoord/iResolution.xy * 0.5) + vec2(0,trans-3000.0);\n    coord.x += cos((coord.y + iTime) * 0.001)* 18.;\n    coord.y += cos((coord.x + iTime) * 0.01)* 28.;\n    int val = 0;\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev = vec3(0.0);\n    for(int i = 0; i < ITERS; i++){\n        col_prev = col;\n        coord.y -= (result-11.0);\n        coord += coord.yy/(6.0+3.0 * sin(iTime*0.004))+col.x;\n        coord = coord.yx/(3.4);\n        result = ((result + float(val = ((int(coord.x+coord.y/abs(2.5 + cos(iTime*0.001))) & int(coord.y+coord.x/2.4)) % 3)))/(2.0));\n        col.x = smoothstep(1.00,0.59,result*1.35);\n        col = ((col.yzx)*1.7+col_prev)/3.06;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXSzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NdsSzS", "name": "Powerpuff", "author": "zooi", "description": "The ending card for The Powerpuff Girls", "tags": ["heart", "thepowerpuffgirls"], "likes": 8, "viewed": 787, "published": 3, "date": "1618785922", "time_retrieved": "2024-07-30T19:25:13.518608", "image_code": "float heart(vec2 uv)\n{   \n    float absX = abs(uv.x);\n    uv.y = uv.y * 1.2 + absX * absX * 1.1 - absX * 0.66;    \n    return max(0., distance(uv, vec2(0.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    float d = fract(heart(uv * .4) * 5. - iTime); \n    vec3 f = d > 0.33 ? (d > 0.67 ? vec3(0.92, 0.00, 0.01) : vec3(0.96, 0.62, 0.80)) : vec3(0.94, 0.26, 0.42);\n    fragColor = vec4(f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 160], [162, 162, 219, 219, 477]], "test": "untested"}
{"id": "sdfXzB", "name": "Taskkk 2", "author": "zhgulden", "description": "    ", "tags": ["mashgraph"], "likes": 1, "viewed": 224, "published": 3, "date": "1618781836", "time_retrieved": "2024-07-30T19:25:14.576778", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, screenUV) / float(iFrame + 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float INF = 1e9;\nconst float SPHERE_R = 1.0;\nconst vec3 CAMERA_POS = vec3(3, 2.2, -6);\nconst vec3 LIGHT_POS = vec3(2, 1.5, 0);\nconst float LIGHT_RADIUS = 0.25;\nconst vec4 LIGHT_COLOR = vec4(1, 1, 1, 1);\n\nconst vec3 LIGHT2_POS = vec3(-2, 0.5, 2);\nconst float LIGHT2_RADIUS = 0.25;\nconst vec4 LIGHT2_COLOR = vec4(0.1, 0.7, 0.1, 1);\n\n\n// TRACE FUNCTIONS\nfloat tracePolygon(vec3 pos, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out vec3 normal)\n{\n    // Polygon interception with v = pos + t*dir\n    // \n    // Read more about method here: \n    // http://masters.donntu.org/2015/frt/yablokov/library/transl.htm\n    // result = (t, u, v) \n    \n    vec3 result;\n    \n    vec3 T  = pos - v0;\n    vec3 E1 = v1  - v0;\n    vec3 E2 = v2  - v0;\n    \n    vec3 P  = cross(dir, E2);\n    vec3 Q  = cross(T,   E1);\n    \n    \n    float det = dot(P, E1);\n    \n    float t = dot(Q, E2) / det;\n    float u = dot(P, T)  / det;\n    float v = dot(Q, dir) /det ;\n    \n    \n    float A = (v1.y-v0.y)*(v2.z-v0.z) - (v2.y-v0.y)*(v1.z-v0.z);\n    float B = (v1.z-v0.z)*(v2.x-v0.x) - (v2.z-v0.z)*(v1.x-v0.x);\n    float C = (v1.x-v0.x)*(v2.y-v0.y) - (v2.x-v0.x)*(v1.y-v0.y);\n    \n    normal.x = A;\n    normal.y = B;\n    normal.z = C;\n    \n    normal = normalize(normal);\n    \n    if( u >= 0.0 && v >= 0.0 && u + v <= 1.0 && t > 0.0)\n        return t;\n    \n    return INF;\n}\nfloat traceCube(vec3 pos, vec3 dir, float size, vec3 shift, out vec3 normal)\n{\n    float scaleCube = size/2.0;\n\n    int minIndex = 0;\n\n    vec3 normal1;\n    vec3 normal2; \n    vec3 normal3; \n    vec3 normal4; \n    vec3 normal5; \n    vec3 normal6; \n    vec3 normal7; \n    vec3 normal8; \n    vec3 normal9;\n    vec3 normal10;\n    vec3 normal11;\n    vec3 normal12;\n    \n    \n    \n    \n    vec3 v1 = vec3(shift.x - scaleCube, shift.y - scaleCube, shift.z + scaleCube);\n    vec3 v2 = vec3(shift.x + scaleCube, shift.y - scaleCube, shift.z + scaleCube);\n    vec3 v3 = vec3(shift.x + scaleCube, shift.y + scaleCube, shift.z + scaleCube);\n    vec3 v4 = vec3(shift.x - scaleCube, shift.y + scaleCube, shift.z + scaleCube);\n    vec3 v5 = vec3(shift.x + scaleCube, shift.y - scaleCube, shift.z - scaleCube);\n    vec3 v6 = vec3(shift.x + scaleCube, shift.y + scaleCube, shift.z - scaleCube);\n    vec3 v7 = vec3(shift.x - scaleCube, shift.y + scaleCube, shift.z - scaleCube);\n    vec3 v8 = vec3(shift.x - scaleCube, shift.y - scaleCube, shift.z - scaleCube);\n    \n    \n    float T1  = tracePolygon (pos, dir, v1, v2, v3, normal1);\n    float T2  = tracePolygon (pos, dir, v1, v3, v4, normal2);\n    \n    float T3  = tracePolygon (pos, dir, v1, v2, v5, normal3);\n    float T4  = tracePolygon (pos, dir, v1, v5, v8, normal4);\n    \n    float T5  = tracePolygon (pos, dir, v2, v3, v5, normal5);\n    float T6  = tracePolygon (pos, dir, v3, v5, v6, normal6);\n    \n    float T7  = tracePolygon (pos, dir, v5, v6, v7, normal7);\n    float T8  = tracePolygon (pos, dir, v5, v7, v8, normal8);\n    \n    float T9  = tracePolygon (pos, dir, v1, v4, v7, normal9);\n    float T10 = tracePolygon (pos, dir, v1, v7, v8, normal10);\n    \n    float T11 = tracePolygon (pos, dir, v3, v4, v6, normal11);\n    float T12 = tracePolygon (pos, dir, v4, v6, v7, normal12);\n    \n    \n    \n    \n    \n    //find min of all this triagles and minIndex\n    vec3[]  arrayN = vec3[] ( normal1,normal2,normal3,normal4,normal5,normal6,normal7,normal8,normal9,normal10,normal11,normal12 );\n    float[] arrayD = float[](   T1,     T2,     T3,     T4,     T5,     T6,     T7,     T8,     T9   ,  T10,     T11,     T12    );\n \n \n    float minT = arrayD[0];\n    \n    for (int i = 1; i < 12; i++)\n \n        if (minT > arrayD[i])\n        {\n            minT = arrayD[i];\n            minIndex = i;\n        }\n    \n    \n    \n    \n    // Output values\n    normal = arrayN[minIndex];\n    return arrayD[minIndex];\n    \n    \n    \n\n    //return INF;\n}\nfloat traceSphere(vec3 pos, vec3 dir, float R, out vec3 normal) {\n    // abs(pos + t * dir) = r\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t = r * r\n    // D = 4 * dot(pos, dir) ^ 2 - 4 * (dot(pos, pos) - r * r)\n    float b = dot(pos, dir);\n    float D = b * b - (dot(pos, pos) - R * R);\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D));\n    if (t < 0.0)\n        t = (-b + sqrt(D));\n    if (t < 0.0)\n        return INF;\n    vec3 wPos = pos + t * dir;\n    normal = normalize(wPos);\n    return t;\n}\nfloat traceOctahedron(vec3 pos, vec3 dir, float size, vec3 shift, out vec3 normal)\n{\n    float scaleOcta = 1.0/ size;\n    \n    int minIndex = 0;// index of intercepted triagle (from 0 to 7)\n    \n    vec3 normal1;\n    vec3 normal2; \n    vec3 normal3; \n    vec3 normal4; \n    vec3 normal5; \n    vec3 normal6; \n    vec3 normal7; \n    vec3 normal8; \n    \n    \n    \n    ///*\n    vec3 v1 = vec3(shift.x - scaleOcta, shift.y             , shift.z);\n    vec3 v2 = vec3(shift.x            , shift.y - scaleOcta , shift.z);\n    vec3 v3 = vec3(shift.x+scaleOcta  , shift.y             , shift.z);\n    vec3 v4 = vec3(shift.x            , shift.y+scaleOcta   , shift.z);\n    vec3 v5 = vec3(shift.x            , shift.y             , shift.z+scaleOcta);\n    vec3 v6 = vec3(shift.x            , shift.y             , shift.z-scaleOcta);\n    \n    \n    float T1 = tracePolygon (pos, dir, v1, v2, v5, normal1);\n    float T2 = tracePolygon (pos, dir, v2, v3, v5, normal2);\n    float T3 = tracePolygon (pos, dir, v3, v4, v5, normal3);\n    float T4 = tracePolygon (pos, dir, v4, v1, v5, normal4);\n    float T5 = tracePolygon (pos, dir, v1, v2, v6, normal5);\n    float T6 = tracePolygon (pos, dir, v2, v3, v6, normal6);\n    float T7 = tracePolygon (pos, dir, v3, v4, v6, normal7);\n    float T8 = tracePolygon (pos, dir, v4, v1, v6, normal8);\n    //*/\n\n    \n    \n    //find min\n    vec3[]  arrayN = vec3[] ( normal1,normal2,normal3,normal4,normal5,normal6,normal7,normal8 );\n    float[] arrayD = float[](   T1,     T2,     T3,     T4,     T5,     T6,     T7,     T8    );\n \n \n    float minT = arrayD[0];\n    \n    for (int i = 1; i < 8; i++)\n \n        if (minT > arrayD[i])\n        {\n            minT = arrayD[i];\n            minIndex = i;\n        }\n    \n    \n    \n    \n    // Output \n    normal = arrayN[minIndex];\n    return arrayD[minIndex];\n    \n    \n    \n}\nfloat traceCylinder(vec3 pos, vec3 dir, inout vec3 normal) {\n    const float R = 2.0f;\n    const float H = 0.1f;\n    float floorT = (-1.0 - pos.y) / dir.y;\n    if (floorT < 0.0)\n        return INF;\n    vec3 finalPos = pos + dir * floorT;\n    if (dot(finalPos.xz, finalPos.xz) < R * R) {\n        normal = vec3(0, 1, 0);\n        return floorT;\n    }\n    \n    float b = dot(pos.xz, dir.xz);\n    float a = dot(dir.xz, dir.xz);\n    float D = b * b - (dot(pos.xz, pos.xz) - R * R) * a;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D)) / a;\n    if (pos.y + t * dir.y < -1.0) {\n        vec3 wPos = pos + t * dir;\n        normal = normalize(vec3(wPos.x, 0, wPos.z));\n        return t;\n    }\n    \n    return INF;\n}\n\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 rvec = target - pos;\n    float dist = length(rvec);\n    vec3 dir = rvec / dist;\n    \n    vec3 normal = vec3(0, 0, 0);\n    \n    float t = traceSphere(pos, dir, SPHERE_R, normal);\n    if (dist >= t) {\n        return true;\n    }\n    \n    \n    vec3 octahedronNormal;\n    float octahedronT = traceOctahedron(pos, dir, 1.0, vec3(1.0, 0.0, 3.0), octahedronNormal);\n    if(octahedronT < dist)\n        return true;\n    \n    vec3 cylNormal = normal;\n    t = traceCylinder(pos, dir, cylNormal);\n    return (t > 0.0 && dist >= t);\n}\n\nvec3 refraction(vec3 v_in, vec3 normal, float n1, float n2) {\n    if (dot(v_in, normal) < 0.0)\n        normal = -normal;\n    float cosA = dot(v_in, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v_in - cosA * normal);\n    float sinB = n1 * sinA / n2;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return tang * sinB + normal * cosB;\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat fogSdf(vec3 pos)\n{\n    return length(pos) - 0.75;\n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nvec4 sampleFog(vec3 pos, vec3 dir)\n{\n    float t = fogSdf(pos);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float absorption = 10.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fogSdf(curPos);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(absorption * (\n            texture(iChannel3, curPos * 0.2).x\n            + texture(iChannel3, curPos * 0.4).x\n            + texture(iChannel3, curPos * 0.8).x\n            + texture(iChannel3, curPos * 1.6).x\n            ) * 0.25 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    \n    vec3 color;\n    vec3 v = pos + t*dir;\n    \n    float R1 = 0.50;\n    float R2 = 0.74;\n    float R3 = 0.99;\n    \n    \n    int n = 10;\n    float rad;\n    \n    for (int i = 0 ; i < n; i++){\n    \n        rad = R3 - float(i)/float(n-1)*(R3-R1);\n        \n        //if( pow2(v.x) + pow2(v.y) + pow2(v.z) < pow2(rad))\n            color = vec3(1.0, (rad - R1)/(R3-R1), 0  );\n    }\n    return vec4(5.0*color * totalAbs, 1.0 - opacity);\n}\n\nvec3 randVals;\nvec3 randDir;\n\nvec3 computeLighting(vec3 worldPos, vec3 color, vec3 normal, vec3 viewVec) {\n    vec3 lightPos = LIGHT_POS + randDir * LIGHT_RADIUS;\n    vec3 toLight = lightPos - worldPos;\n    bool occl = isOccluded(worldPos + normalize(toLight) * 1e-3, lightPos);\n    float lightAtten = 20.0f / dot(toLight, toLight) * (occl ? 0.0 : 1.0);\n\n    vec3 light2Pos = LIGHT2_POS + randDir * LIGHT2_RADIUS;\n    vec3 toLight2 = light2Pos - worldPos;\n    bool occl2 = isOccluded(worldPos + normalize(toLight2) * 1e-3, light2Pos);\n    float light2Atten = 10.0f / dot(toLight2, toLight2) * (occl2 ? 0.0 : 1.0);\n\n    return color * (\n        max(0.0f, dot(normal, normalize(toLight))) * lightAtten * LIGHT_COLOR\n        + max(0.0f, dot(normal, normalize(toLight2))) * light2Atten * LIGHT2_COLOR\n        + textureLod(iChannel0, viewVec, 10.0) * 0.3\n    ).rgb;\n}\n\n\n\n//FIRE\n\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n\n// Quality Settings\n#define MarchSteps 8\n// Scene Settings\n#define ExpPosition vec3(0.0)\n#define Radius 2.0\n#define Background vec4(0.1, 0.0, 0.0, 1.0)\n// Noise Settings\n#define NoiseSteps 1\n#define NoiseAmplitude 0.06\n#define NoiseFrequency 4.0\n#define Animation vec3(0.0, -3.0, 0.5)\n// Colour Gradient\n#define Color1 vec4(1.0, 1.0, 1.0, 1.0)\n#define Color2 vec4(1.0, 0.8, 0.2, 1.0)\n#define Color3 vec4(1.0, 0.03, 0.0, 1.0)\n#define Color4 vec4(0.05, 0.02, 0.02, 1.0)\n\n\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v)\n{\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0);\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\t// First corner\n\tvec3 i  = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\t// Permutations\n\ti = mod289(i);\n\tvec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n\tfloat value = 0.0;\n\tfloat cutoff = clamp(0.5/qWidth, 0.0, maxFreq);\n\tfloat fade;\n\tfloat fOut = minFreq;\n\tfor(int i=NoiseSteps ; i>=0 ; i--)\n\t{\n\t\tif(fOut >= 0.5 * cutoff) break;\n\t\tfOut *= 2.0;\n\t\tvalue += abs(snoise(position * fOut))/fOut;\n\t}\n\tfade = clamp(2.0 * (cutoff-fOut)/cutoff, 0.0, 1.0);\n\tvalue += fade * abs(snoise(position * fOut))/fOut;\n\treturn 1.0-value;\n}\n\nfloat SphereDist(vec3 position)\n{\n\treturn length(position - ExpPosition) - Radius;\n}\n\nvec4 Shade(float distance)\n{\n\tfloat c1 = saturate(distance*5.0 + 0.5);\n\tfloat c2 = saturate(distance*5.0);\n\tfloat c3 = saturate(distance*3.4 - 0.5);\n\tvec4 a = mix(Color1,Color2, c1);\n\tvec4 b = mix(a,     Color3, c2);\n\treturn \t mix(b,     Color4, c3);\n}\n\n// Draws the scene\nfloat RenderScene(vec3 position, out float distance)\n{\n\tfloat noise = Turbulence(position * NoiseFrequency + Animation*iTime, 0.1, 1.5, 0.03) * NoiseAmplitude;\n\tnoise = saturate(abs(noise));\n\tdistance = SphereDist(position) - noise;\n\treturn noise;\n}\n\n// Basic ray marching method.\nvec4 March(vec3 rayOrigin, vec3 rayStep)\n{\n\tvec3 position = rayOrigin;\n\tfloat distance;\n\tfloat displacement;\n\tfor(int step = MarchSteps; step >=0  ; --step)\n\t{\n\t\tdisplacement = RenderScene(position, distance);\n\t\tif(distance < 0.05) break;\n\t\tposition += rayStep * distance;\n\t}\n\treturn mix(Shade(displacement), Background, float(distance >= 0.5));\n}\n\nbool IntersectSphere(vec3 ro, vec3 rd, vec3 pos, float radius, out vec3 intersectPoint)\n{\n\tvec3 relDistance = (ro - pos);\n\tfloat b = dot(relDistance, rd);\n\tfloat c = dot(relDistance, relDistance) - radius*radius;\n\tfloat d = b*b - c;\n\tintersectPoint = ro + rd*(-b - sqrt(d));\n\treturn d >= 0.0;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals * 2.0 - 1.0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5) * 2.0)/iResolution.x;\n\n    vec3 forward = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    vec3 viewVec = normalize(forward + uv.x * right + uv.y * up);\n\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float curN = 1.0;\n    float nextN = GLASS_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float GLASS_T = 1.0 - GLASS_R;\n\n    vec3 currentPos = CAMERA_POS;\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    int iterationType;\n    vec3 color;\n    float mult = 1.0;\n\n    // Output to screen\n    for (int i = 0; i < 7; ++i) {\n        vec3 normal = vec3(0, 0, 0);\n\n        float t = traceSphere(currentPos - LIGHT_POS, viewVec, LIGHT_RADIUS, normal);\n        if (t != INF) {\n            color = LIGHT_COLOR.rgb * 5.0;\n            iterationType = EMISSION;\n        }\n        \n        float l2_t = traceSphere(currentPos - LIGHT2_POS, viewVec, LIGHT2_RADIUS, normal);\n        if (t > l2_t) {\n            t = l2_t;\n            color = LIGHT2_COLOR.rgb;\n            iterationType = EMISSION;\n        }\n\n        float sphere_t = traceSphere(currentPos, viewVec, SPHERE_R, normal);\n        if (sphere_t < t) {\n            /*\n            if (GLASS_R > randVals.y) {\n                iterationType = REFLECTION;\n            } else {\n                iterationType = REFRACTION;\n            }\n            */\n            t = sphere_t;\n            iterationType = EMISSION;\n            color = March(currentPos, viewVec).rgb;\n        }\n        vec3 cylNormal = normal;\n        float cylT = traceCylinder(currentPos, viewVec, cylNormal);\n        if (cylT < t) {\n            t = cylT;\n            vec3 pos = currentPos + t * viewVec;\n            color = texture(iChannel1, pos.xz * pos.y).rgb;\n            normal = cylNormal;\n            iterationType = DIFFUSE;\n        }\n        \n        {\n            vec3 octahedron2Normal;\n\n            float octahedron2T  = traceOctahedron(currentPos, viewVec, 1.0, vec3(1.0, 0.5, 3.0), octahedron2Normal);\n            // If trace is intercept with octahedron then make t shorter and equal to distance between camera and table.\n            if (octahedron2T < t)\n            {\n                t = octahedron2T;\n                color = vec3(1.0,0.5,0.0);\n                normal = octahedron2Normal;\n\n                \n                iterationType = DIFFUSE;\n\n            }\n        }\n        \n        \n        {\n            vec3 cubeNormal;\n\n            float cubeT  = traceCube(currentPos, viewVec, 2.0, vec3(0.0, 0.0, 0.0), cubeNormal);\n            // If trace is intercept with octahedron then make t shorter and equal to distance between camera and table.\n            if (cubeT < t)\n            {\n                t = cubeT;\n                color = vec3(1.0,1.0,1.0);\n                normal = cubeNormal;\n\n                //combine reflection and refraction;\n                if(randVals.x*0.1 < GLASS_R)\n                    iterationType = REFLECTION;\n\n                else{\n                    iterationType = REFRACTION;\n                    // We need to know what is outside the object \n                    if( dot(viewVec, normal) > 0.0 )// they not oppodite directed\n                    {\n                        curN = AIR_N;\n                    }\n                    else // they opposite directed \n                    {\n                        curN = GLASS_N;\n\n                    }\n\n                }\n                //materialType = REFRACTION;\n\n            }\n        }\n        \n        \n        // (c + t * v).y = -1.2\n        // t = (-1.2 -c.y) / v.y\n        float floorT = (-1.2 - currentPos.y) / viewVec.y;\n        if (floorT > 0.0 && floorT < t && length(currentPos + floorT * viewVec) < 10.0f) {\n            t = floorT;\n            vec3 pos = currentPos + t * viewVec;\n            color = texture(iChannel2, pos.xz * 0.2).rgb;\n            normal = vec3(0, 1, 0);\n            iterationType = DIFFUSE;\n            if(randVals.y < 0.29)\n                    iterationType = REFLECTION;\n        }\n        if (t != INF) {\n            if (iterationType == EMISSION) {\n                fragColor.rgb = color;\n                break;\n            } else if (iterationType == DIFFUSE) {\n                fragColor.rgb += mult * computeLighting(currentPos + t * viewVec, color, normal, viewVec);\n                break;\n            } else if (iterationType == REFLECTION) {\n                currentPos += viewVec * t;\n                fragColor.rgb += mult * computeLighting(currentPos + t * viewVec, color, normal, viewVec);\n                viewVec = reflect(viewVec, normal);\n                currentPos += viewVec * 1e-5;\n            } else if (iterationType == REFRACTION) {\n                currentPos += viewVec * t;\n                viewVec = refraction(viewVec, normal, curN, nextN);\n                currentPos += viewVec * 1e-5;\n                vec4 fog = sampleFog(currentPos, viewVec);\n                fragColor.rgb += fog.rgb * fog.a * mult;\n                mult *= 1.0 - fog.a;\n                float tmp = curN;\n                curN = nextN;\n                nextN = tmp;\n            }\n        } else {\n            fragColor += mult * texture(iChannel0, viewVec) * 0.3;\n            break;\n        }\n    }\n}   ", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, screenUV) + texture(iChannel1, screenUV);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 171]], "test": "untested"}
{"id": "fdlSRS", "name": "318_selevenko_v0v5", "author": "ghost18", "description": "homework", "tags": ["homework"], "likes": 1, "viewed": 332, "published": 3, "date": "1618779557", "time_retrieved": "2024-07-30T19:25:15.600042", "image_code": "const vec3 CAMERA_POS = vec3(0, 2, -7);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(0.0, 2.0, -7.0);\nconst vec3 LIGHT1_POS = vec3(-3, 3, 3.0);\nconst float LIGHT1_RADIUS = 0.5;\nconst vec4 LIGHT1_COLOR = vec4(1, 1, 1, 1);\n\nconst vec3 LIGHT2_POS = vec3(4,  3, 2);\nconst float LIGHT2_RADIUS = 0.25;\nconst vec4 LIGHT2_COLOR = vec4(0, 0.1, 1, 0.2);\n\nconst vec3 LIGHT3_POS = vec3(0, 3, 2);\nconst float LIGHT3_RADIUS = 0.3;\nconst vec4 LIGHT3_COLOR = vec4(1, 0, 1, 1);\n\nvec3 randDir;\n\nconst vec3 SPH2_POS = vec3(2.0, 2.0, 0.0);\n\nconst vec3 CYLINDER1_POS = vec3(0.0, 0.2, 0);\n\nfloat traceCylinder(vec3 pos, vec3 dir, inout vec3 normal) {\n    const float R = 1.0f;\n    const float H = 0.1f;\n    float floorT = (-1.0 - pos.y) / dir.y;\n    if (floorT < 0.0)\n        return INF;\n    vec3 finalPos = pos + dir * floorT;\n    if (dot(finalPos.xz, finalPos.xz) < R * R) {\n        normal = vec3(0, 1, 0);\n        return floorT;\n    }\n    \n    float b = dot(pos.xz, dir.xz);\n    float a = dot(dir.xz, dir.xz);\n    float D = b * b - (dot(pos.xz, pos.xz) - R * R) * a;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D)) / a;\n    if (pos.y + t * dir.y < -1.0) {\n        vec3 wPos = pos + t * dir;\n        normal = normalize(vec3(wPos.x, 0, wPos.z));\n        return t;\n    }\n    \n    return INF;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 sphNorm;\n    float sphT = traceSphere(pos, dir, 1.0, sphNorm);\n    if (sphT < dist){\n        return true;\n    }\n    vec3 cy1Norm;\n    float cy1T = traceCylinder(pos, dir, cy1Norm);\n    return (cy1T < dist);\n}\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n\n    if (dot(worldPos.xz, worldPos.xz) >= 30.0) {\n        return INF;\n    }   \n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0)\n        normal = -normal;\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = n1 * sinA / n2;\n    if (sinB > 1.0) {\n        return reflect(v, normal);\n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return tang * sinB + normal * cosB;\n}\n\nfloat rand(float frame) {\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat fogSdf(vec3 pos)\n{\n    return length(pos) - 0.75;\n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nvec3 Minecraft_drawing (in vec2 input_vector) {\n    \n    vec3 d = vec3(input_vector, 1) / iResolution - 0.5;\n    vec3 fractional_part;\n    vec3 source = d;\n    vec3 floor_scene;\n    vec3 scene_cut = vec3(10.8, 0.0, -18.0);\n    scene_cut.y = 3.0 * cos(scene_cut.z * scene_cut.x);\n    vec3 filter1 = vec3(1, 7, 0.1);\n    for (float i = 0.0; i < 25.0; i += 0.001) {\n        scene_cut += d * i * 0.15;\n        fractional_part = fract(scene_cut);\n        floor_scene = floor(scene_cut) * 0.5;\n        if (cos(floor_scene.z) + sin(floor_scene.x) > (floor_scene.y + 1.0)) {\n            floor_scene.y = floor_scene.y + 1.0;\n\t    \tsource = (fractional_part.y - 0.1 * cos((scene_cut.x + scene_cut.z) * 20.0) > 0.8 ? filter1 : fractional_part.y * filter1.yxz) / i;\n            break;\n        }\n    }\n    \n    return source.rgb;\n}\n\n\nvec4 sampleFog(vec3 pos, vec3 dir, in vec2 ex)\n{\n    float t = fogSdf(pos);\n    const float MARCH_SIZE = 0.011;\n    float opacity = 1.0;\n    float absorption = 10.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fogSdf(curPos);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(absorption * (\n            texture(iChannel3, curPos * 0.2).x\n            + texture(iChannel3, curPos * 1.4).x\n            + texture(iChannel3, curPos * 2.8).x\n            + texture(iChannel3, curPos * 5.6).x\n            ) * 0.25 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    return vec4(Minecraft_drawing(ex) * totalAbs, 1.0 - opacity);\n}\n\nvec3 randVals;\n\nvec3 computeLight(vec3 worldPos, vec3 color, vec3 normal, vec3 viewVec) {\n    vec3 light1Pos = LIGHT1_POS + randDir * LIGHT1_RADIUS;\n    vec3 toLight = light1Pos - worldPos;\n    bool occl = isOccluded(worldPos + normalize(toLight) * 1e-3, light1Pos);\n    float lightAtten = 20.0f / dot(toLight, toLight) * (occl ? 0.0 : 1.0);\n\n    vec3 light2Pos = LIGHT2_POS + randDir * LIGHT2_RADIUS;\n    vec3 toLight2 = light2Pos - worldPos;\n    bool occl2 = isOccluded(worldPos + normalize(toLight2) * 1e-3, light2Pos);\n    float light2Atten = 10.0f / dot(toLight2, toLight2) * (occl2 ? 0.0 : 1.0);\n    \n    vec3 light3Pos = LIGHT3_POS + randDir * LIGHT3_RADIUS;\n    vec3 toLight3 = light3Pos - worldPos;\n    bool occl3 = isOccluded(worldPos + normalize(toLight3) * 1e-3, light3Pos);\n    float light3Atten = 10.0f / dot(toLight3, toLight3) * (occl3 ? 0.0 : 1.0);\n\n    return color * (\n        max(0.0f, dot(normal, normalize(toLight))) * lightAtten * LIGHT1_COLOR\n        + max(0.0f, dot(normal, normalize(toLight2))) * light2Atten * LIGHT2_COLOR\n        + max(0.0f, dot(normal, normalize(toLight3))) * light3Atten * LIGHT3_COLOR\n        + textureLod(iChannel1, viewVec, 10.0) * 0.3\n    ).rgb;\n}\n\nfloat tracePolygon(vec3 pos, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out vec3 normal)\n{   \n    vec3 result;\n    \n    vec3 T = pos - v0;\n    vec3 E1 = v1  - v0;\n    vec3 E2 = v2  - v0;\n    \n    vec3 P = cross(dir, E2);\n    vec3 Q = cross(T,   E1);\n    \n    float det = dot(P, E1);\n    \n    float t = dot(Q, E2) / det;\n    float u = dot(P, T)  / det;\n    float v = dot(Q, dir) /det ;\n    \n    float A = (v1.y-v0.y)*(v2.z-v0.z) - (v2.y-v0.y)*(v1.z-v0.z);\n    float B = (v1.z-v0.z)*(v2.x-v0.x) - (v2.z-v0.z)*(v1.x-v0.x);\n    float C = (v1.x-v0.x)*(v2.y-v0.y) - (v2.x-v0.x)*(v1.y-v0.y);\n    \n    normal.x = A;\n    normal.y = B;\n    normal.z = C;\n    \n    normal = normalize(normal);\n    \n    if( u >= 0.0 && v >= 0.0 && u + v <= 1.0 && t > 0.0)\n        return t;\n    \n    return INF;\n}\n\nfloat traceOctahedron(vec3 pos, vec3 dir, float size, vec3 coords, out vec3 normal)\n{\n    float scaleOcta = 1.0/ size;\n    \n    int minIndex = 0;\n    \n    vec3 normal1;\n    vec3 normal2; \n    vec3 normal3; \n    vec3 normal4; \n    vec3 normal5; \n    vec3 normal6; \n    vec3 normal7; \n    vec3 normal8; \n    \n    vec3 v1 = vec3(coords.x - scaleOcta, coords.y, coords.z);\n    vec3 v2 = vec3(coords.x, coords.y - scaleOcta,coords.z);\n    vec3 v3 = vec3(coords.x + scaleOcta, coords.y, coords.z);\n    vec3 v4 = vec3(coords.x, coords.y + scaleOcta, coords.z);\n    vec3 v5 = vec3(coords.x, coords.y, coords.z + scaleOcta);\n    vec3 v6 = vec3(coords.x, coords.y, coords.z-scaleOcta);\n    \n    float T1 = tracePolygon(pos, dir, v1, v2, v5, normal1);\n    float T2 = tracePolygon(pos, dir, v2, v3, v5, normal2);\n    float T3 = tracePolygon(pos, dir, v3, v4, v5, normal3);\n    float T4 = tracePolygon(pos, dir, v4, v1, v5, normal4);\n    float T5 = tracePolygon(pos, dir, v1, v2, v6, normal5);\n    float T6 = tracePolygon(pos, dir, v2, v3, v6, normal6);\n    float T7 = tracePolygon(pos, dir, v3, v4, v6, normal7);\n    float T8 = tracePolygon(pos, dir, v4, v1, v6, normal8);\n\n    vec3[]  array1 = vec3[] (normal1, normal2, normal3, normal4, normal5, normal6, normal7, normal8);\n    float[] array2 = float[](T1, T2, T3, T4, T5, T6, T7, T8);\n \n    float minT = array2[0];\n    \n    for (int i = 1; i < 8; i++) {\n        if (minT > array2[i])\n        {\n            minT = array2[i];\n            minIndex = i;\n        }\n    }\n    normal = array1[minIndex];\n    return array2[minIndex];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    vec3 randDir = normalize(randVals * 2.0 - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5) * 2.0) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float n1 = AIR_N;\n    float n2 = GLASS_N;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    int materialType = EMISSION;\n    float mult = 1.0;\n    vec3 color;\n    \n    float GLASS_R = ((AIR_N - GLASS_N) * (AIR_N - GLASS_N)) / ((AIR_N + GLASS_N) * (AIR_N + GLASS_N));\n    float GLASS_T = 1.0 - GLASS_R;\n    \n    for (int i = 0; i < 10; i++) {\n    vec3 normal = vec3(0, 0, 0);\n\n        float t = traceSphere(curPos - LIGHT1_POS, viewVec, LIGHT1_RADIUS, normal);\n        if (t != INF) {\n            color = LIGHT1_COLOR.rgb * 5.0;\n            materialType = EMISSION;\n        }\n        \n        float l2_t = traceSphere(curPos - LIGHT2_POS, viewVec, LIGHT2_RADIUS, normal);\n        if (t > l2_t) {\n            t = l2_t;\n            color = LIGHT2_COLOR.rgb;\n            materialType = EMISSION;\n        }\n        \n        float l3_t = traceSphere(curPos - LIGHT3_POS, viewVec, LIGHT3_RADIUS, normal);\n        if (t > l3_t) {\n            t = l3_t;\n            color = LIGHT3_COLOR.rgb;\n            materialType = EMISSION;\n        }\n        \n        float sphere_t = traceSphere(curPos, viewVec, 1.0, normal);\n        if (sphere_t < t) {\n            if (GLASS_R > randVals.y) {\n                materialType = REFLECTION;\n            } else {\n                materialType = REFRACTION;\n            }\n            t = sphere_t;\n        }\n        vec3 cylNormal = normal;\n        float cylT = traceCylinder(curPos, viewVec, cylNormal);\n        if (cylT < t) {\n            t = cylT;\n            vec3 pos = curPos + t * viewVec;\n            color = texture(iChannel2, pos.xz * pos.y).rgb;\n            normal = cylNormal;\n            materialType = DIFFUSE;\n        }\n        vec3 planeNormal = normal;\n        float planeT = tracePlane(curPos, viewVec, planeNormal);\n        if (planeT > 0.0 && planeT < t) {\n            t = planeT;\n            vec3 pos = curPos + t * viewVec;\n            color = texture(iChannel0, pos.xz * 0.2).rgb;\n            normal = vec3(0, 1, 0);\n            materialType = DIFFUSE;\n            if (randVals.y < 0.3) {\n                materialType = REFLECTION;\n            }\n        }\n        \n        vec3 octahedronNormal;\n        const vec3 octahedronPosVec = vec3(2.0, 1.0, 0.0);\n        float octahedronT  = traceOctahedron(curPos, viewVec, 1.0, octahedronPosVec, octahedronNormal);\n        if (octahedronT < t)\n        {\n            t = octahedronT;\n            color = vec3(1.0, 0.0, 0.0);\n            normal = octahedronNormal;\n            if(randVals.x * 0.04 < GLASS_R)\n               materialType = REFLECTION;\n\n            else{\n                materialType = REFRACTION;\n                if(dot(viewVec, normal) > 0.0) {\n                    n2 = AIR_N;\n                } else {\n                    n2 = GLASS_N;\n\n                }\n\n            }\n\n        }\n        \n        if (t != INF) {\n            if (materialType == EMISSION) {\n                fragColor.rgb = color;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb += mult * computeLight(curPos + t * viewVec, color, normal, viewVec);\n                break;\n            } else if (materialType == REFLECTION) {\n                curPos += viewVec * t;\n                fragColor.rgb = mult * computeLight(curPos + t * viewVec, color, normal, viewVec);\n                viewVec = reflect(viewVec, normal);\n                curPos += viewVec * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curPos += viewVec * t;\n                viewVec = refraction(viewVec, normal, n1, n2);\n                curPos += viewVec * 1e-5;\n                vec4 fog = sampleFog(curPos, viewVec, fragCoord);\n                mult *= 1.0 - fog.a;\n                fragColor.rgb += fog.rgb * fog.a * mult;\n                float tmp = n1;\n                n1 = n2;\n                n2 = tmp;\n            }\n        } else {\n            fragColor += mult * texture(iChannel1, viewVec) * 0.3;\n            break;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 98, 98, 202]], "test": "untested"}
{"id": "ssfXRB", "name": "Ellipse Tangents Through Point", "author": "oneshade", "description": "Generalization to ellipses.", "tags": ["2d", "math", "geometry", "ellipse", "tangents"], "likes": 11, "viewed": 122, "published": 3, "date": "1618774376", "time_retrieved": "2024-07-30T19:25:16.364997", "image_code": "// https://www.desmos.com/calculator/i0ofizuwzm\n\n// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat deEllipse(in vec2 p, in vec2 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * dot(pa, ba) / dot(ba, ba));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        mouse.xy = vec2(sin(iTime), 1.0) * cos(iTime);\n        mouse.x += 2.0;\n    }\n\n    // Radii and angles\n    vec2 r = vec2(1.25, 0.65) + 0.25 * vec2(cos(iTime), sin(iTime));\n    vec2 a = atan(r.x * mouse.y, r.y * mouse.x) + vec2(1.0, -1.0) * acos(1.0 / length(mouse.xy / r));\n\n    // Points on the ellipse\n    vec2 t1 = vec2(cos(a.x), sin(a.x)) * r;\n    vec2 t2 = vec2(cos(a.y), sin(a.y)) * r;\n\n    // Ellipse\n    drawSDF(abs(deEllipse(uv, r)), vec3(1.0, 0.0, 0.0));\n\n    // Tangents\n    drawSDF(sdInfLine(uv, mouse.xy, t1), vec3(1.0, 0.8, 0.0));\n    drawSDF(sdInfLine(uv, mouse.xy, t2), vec3(1.0, 0.8, 0.0));\n\n    // Point\n    drawSDF(sdDisc(uv, mouse.xy, 0.05), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfXRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 159, 207, 207, 239], [241, 290, 329, 329, 430], [432, 432, 482, 482, 573], [575, 575, 630, 630, 1676]], "test": "untested"}
{"id": "NsXSWN", "name": "membrane", "author": "lennyjpg", "description": "soft moves", "tags": ["2d", "loop", "slow"], "likes": 1, "viewed": 226, "published": 3, "date": "1618757821", "time_retrieved": "2024-07-30T19:25:17.130949", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord/iResolution.xy;\nvec2 u = uv * 100.;\nfloat t = iTime * .37;\nuv.x += sin(uv.y * 2.) * .1;\nu.x += sin(uv.x * 4. + t) * 20.;\nfloat k = sin(u.x * 3.23) ;\nk = fract(u.x * .3);\nvec3 a = vec3(1.1, .05, .2);\nvec3 b = vec3(1., .4, .547);\nvec3 c = mix(a, b, k + sin(uv.y) - .5);\nfragColor = vec4(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 371]], "test": "untested"}
{"id": "fsfXRB", "name": "playing with colors", "author": "jorge2017a1", "description": "playing with colors", "tags": ["sdf", "reflect", "playingwithcolors"], "likes": 2, "viewed": 214, "published": 3, "date": "1618754460", "time_retrieved": "2024-07-30T19:25:18.090384", "image_code": "//por jorge2017a1-  18/abril/2021\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    res =opU3(res, vec3(planeDist1,-1.0,6.0)); //inf\n    float t1=mod(iTime,2.0);\n    float t2=mod(iTime,3.0);\n    \n    if (t1<t2)\n    {\n     res =opU3(res, vec3(planeDist2,14.0,MATERIAL_NO)); \n     res =opU3(res, vec3(planeDist3,100.0,MATERIAL_NO)); \n     res =opU3(res, vec3(planeDist4,100.0,MATERIAL_NO)); \n     res =opU3(res, vec3(planeDist5,100. ,MATERIAL_NO)); \n     res =opU3(res, vec3(planeDist6,16.0,MATERIAL_NO)); \n    }    \n      p.y=p.y-5.0;\n    //rotar centro origen\n     float posx=2.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xz = rotatev2(pp.xz, iTime);\n     pp.x=pp.x+posx;\n\n    float sdrb3=  sdRoundBox( pp-vec3(posx,-3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 in\n    float sdrb3A= sdRoundBox(pp-vec3(posx,0.0,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    float sdrb3B= sdRoundBox(pp-vec3(posx,3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    \n    res =opU3(res, vec3(sdrb3,13.0,-1)); \n    res =opU3(res, vec3(sdrb3A,14.0,-1)); \n    res =opU3(res, vec3(sdrb3B,15.0,-1)); \n    \n   float sdsp1= sdSphere( p-vec3(-10.0,0.0,0.0), 6.0 );\n    res =opU3(res, vec3(sdsp1,201.0,-1)); \n    float sdsp2= sdSphere( p-vec3(14.0,3.0,10.0), 6.0 );\n    \n   res =opU3(res, vec3(sdsp2,32.0,-1)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false;    minDist = dO;    break; } \n        dO += dS.x;\n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n///============================================================\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{   vec3 l = normalize(lp - p);\n    vec3 r = reflect(-l, n);\n    float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{\n    vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(0.,dot(ldir,-n));\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n    { fshadow=GetShadow(p,lp);}\n    else\n    {   fshadow=0.5; }\n    vec3 lin = amb;\n    lin += 1.0*(dif+diff)*sh;\n    lin += 2.5*spe;\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin *= atten*0.8*col*fshadow;\n    lin = pow(lin,vec3(0.35));\n    return lin;\n}\n///============================================================\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); \n    return col*2.0;\n    }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n\tvec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n  \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    if (id_material==6.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n        l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n    }\n}\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color)); colobj=coltex;}\n\n    if (id_material>-1.0 && id_color==-1)\n    { colobj=vec3(0.5); colobj*=getMaterial(p, id_material); return colobj; }\n    return colobj;\n}\n\nvec3 renderReflect(TObj Obj, vec3 ro, vec3 rd, vec3 col )\n{\n   vec3 p;\n   float t;\n   vec3 colobj;  vec3 n;\n  /////-----------REFLECT--------------\n    if (int( Obj.id_color) ==201)\n    {\n     vec3 colref;\n     for(int i=0; i<2; ++i)\n      {  \n        t=RayMarch(ro,rd, MAX_STEPS);\n        Obj=mObj;\n        \n       if(t>MAX_DIST)\n       { colobj= render_sky_color(rd);return  colobj;}  \n     \n        if( t<0.0 || t>MAX_DIST ) break;\n        p=ro+rd*t;\n        \n        n=GetNormal(p);\n        //produce ondas de mar\n        //n=normalize(n+0.01*sin(10.0* p+2.0*iTime));\n        \n        rd=reflect(rd,n);\n        ro =p+rd * MIN_DIST * 3.;\n        \n        if (t<MAX_DIST)\n        colobj=GetColorYMaterial( p, n, ro, rd,  int( Obj.id_color), Obj.id_material)*2.0;\n        \n        colref=  Getluz( p,ro,rd, n, colobj ,light_pos1);\n        colref+= Getluz( p,ro,rd, n, colobj ,light_pos2);\n       }\n     col+=colref/(float(REFLECT));\n   } \n   return col;\n} \n\nvec3 Render(vec3 ro, vec3 rd)\n{\n  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;mObj.ro=ro;\n   vec3 p ;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n        vec3 result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n    col= renderReflect(Obj,  ro,  rd,  col );\n   \n   return col;\n}\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    mObj.uv=uv;\n    float t; t=mod(iTime*1.0,360.0);    itime=t;\n\tmObj.blnShadow=true;\n    \n     light_pos1= vec3(5.0, 10.0, -10.0 );    light_color1=vec3( 1.0 );\n \t light_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n   vec3 ro=vec3(0.0,7.0+3.0*abs(sin(iTime)),-25.0);\n  \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfXRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[493, 493, 529, 529, 550], [551, 551, 583, 583, 667], [668, 668, 714, 714, 801], [803, 847, 894, 894, 921], [923, 923, 966, 966, 993], [995, 995, 1043, 1043, 1071], [1072, 1156, 1192, 1192, 1237], [1243, 1243, 1282, 1282, 1326], [1327, 1327, 1366, 1366, 1410], [1411, 1411, 1443, 1443, 1468], [1469, 1534, 1568, 1568, 1666], [1667, 1667, 1701, 1701, 1793], [1794, 1794, 1828, 1828, 1920], [1921, 1961, 1995, 1995, 2092], [2093, 2133, 2158, 2158, 3763], [3764, 3815, 3839, 3839, 4027], [4028, 4028, 4077, 4077, 4723], [4724, 4778, 4814, 4814, 5061], [5062, 5126, 5153, 5153, 5170], [5172, 5172, 5208, 5208, 5300], [5301, 5301, 5347, 5347, 5479], [5481, 5481, 5555, 5555, 6657], [6658, 6777, 6826, 6826, 7079], [7080, 7114, 7194, 7194, 7326], [7327, 7368, 7400, 7400, 7594], [7595, 7646, 7693, 7693, 8219], [8220, 8272, 8365, 8365, 8793], [9754, 9754, 9785, 9785, 10376], [10377, 10426, 10483, 10483, 10938]], "test": "untested"}
{"id": "fdXSzB", "name": "NoiseCloud_vince", "author": "vince_hua", "description": "a cloud effect by noise", "tags": ["noise"], "likes": 1, "viewed": 227, "published": 3, "date": "1618754175", "time_retrieved": "2024-07-30T19:25:18.862320", "image_code": "float N21(vec2 p) {\n    return fract(sin(p.x*100. + p.y*6574.)*5674.);\n}\n\nfloat SmoothNoise(vec2 uv){\n\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n    \n    float bl = N21(id);\n    float br = N21(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id + vec2(0, 1));\n    float tr = N21(id + vec2(1, 1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) {\n    float c = SmoothNoise(uv*4.);\n    c += SmoothNoise(uv*8.)*.5;\n    c += SmoothNoise(uv*16.)*.25;\n    c += SmoothNoise(uv*32.)*.125;\n    c += SmoothNoise(uv*65.)*.0625;\n    \n    return c / 2.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv += iTime * 0.1;\n    float c = SmoothNoise2(uv);\n    \n    vec3 col = vec3(c);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 72], [74, 74, 101, 101, 417], [419, 419, 448, 448, 645], [646, 646, 703, 703, 866]], "test": "untested"}
{"id": "NdfXRB", "name": "SoundEclipse /wo Circle", "author": "riggy93", "description": "I just delete the Circle.\nOriginal from https://www.shadertoy.com/view/ls3BDH.\nI'll use it as a visualization in virtualdj.", "tags": ["visualization", "mic", "virtualdj"], "likes": 4, "viewed": 338, "published": 3, "date": "1618753805", "time_retrieved": "2024-07-30T19:25:19.628272", "image_code": "// credit: https://www.shadertoy.com/view/ls3BDH\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 1920.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.0;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.0;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.5, 0.5, 0.5));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE) / FREQ_RANGE, 0.0)).x + 0.00;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 1.0);\n}\n\n\n//LINE\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.5 +iTime * 0.0, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.0) * 1.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\t\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfXRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 231, 252, 252, 421], [423, 423, 447, 447, 491], [493, 493, 522, 522, 608], [610, 610, 646, 646, 857], [859, 859, 894, 894, 958], [961, 968, 1019, 1019, 1268], [1271, 1271, 1328, 1328, 1728]], "test": "untested"}
{"id": "NsfSRB", "name": "Mossy rock", "author": "jarble", "description": "A more realistic moss pattern based on my \"bitwise lichen\" shader.", "tags": ["fractal", "rock", "stone", "bitwise", "moss", "lichen"], "likes": 8, "viewed": 283, "published": 3, "date": "1618752528", "time_retrieved": "2024-07-30T19:25:20.392230", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = .5;\n    float trans = iTime * 25.0*10.0;\n    vec2 coord = scale*(fragCoord + vec2(trans,0.0));\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev;\n    for(int i = 0; i < 9; i++){\n        col_prev = col;\n        coord.y += (2.0+result)/2.0;\n        coord += coord.yy/4.0;\n        coord = coord.yx/(2.0);\n        result = ((result + float(val = ((int(coord.x) | int(coord.y)) % (3+val))))/(2.0));\n        col.x = (result+col.z)/2.0;\n        col = (fract((col.yzx))+col_prev)/2.0;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfSRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NdfSWN", "name": "MSU building in octahedron", "author": "OFITSEROVLAD", "description": "CG 2nd HW Ofitserov 320", "tags": ["octahedron", "msu"], "likes": 0, "viewed": 258, "published": 3, "date": "1618749108", "time_retrieved": "2024-07-30T19:25:21.444416", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float GLASS_N = 1.5;\nconst float AIR_N = 1.0;\nconst float DIAMOND_N = 2.5;\n\n\n\nconst vec3 DownPoint = vec3(0, 0, 0);\nconst vec3 UpPoint = vec3(0, 2, 0);\nconst vec3 RightPoint = vec3(-1, 1, 0);\nconst vec3 LeftPoint = vec3(1, 1, 0);\nconst vec3 FrontPoint = vec3(0, 1, -1);\nconst vec3 BackPoint = vec3(0, 1, 1);\n\nconst int NUM_OF_MSU_TRIANGLES = 36;\nconst int NUM_OF_MSU_SPHERES = 3;\n\n\n\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\nconst float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(1, 2, 5);\n\nconst vec3 LIGHT1_POS = vec3(-3, 2, 1);\nconst float LIGHT1_RADIUS = .2;\nconst vec3 LIGHT1_COLOR = vec3(0.6, .9, 0.3);\n\nconst vec3 LIGHT2_POS = vec3(3, 2, -1);\nconst float LIGHT2_RADIUS = 0.1;\nconst vec3 LIGHT2_COLOR = vec3(0.9, 0.2, 0.9);\nvec3 randDir;\n\n\nstruct Triangle {\n    vec3 vertex0;\n    vec3 vertex1;\n    vec3 vertex2;\n};\n\nstruct Sphere {\n    vec3 orig;\n    float r;\n};\n\n\nfloat traceTriangle(vec3 pos, vec3 dir, vec3 vertex0, vec3 vertex1, vec3 vertex2, out vec3 normal)\n{\n    const float EPSILON = 0.0000001;\n    vec3 edge1, edge2, h, s, q;\n    float a,f,u,v;\n    edge1 = vertex1 - vertex0;\n    edge2 = vertex2 - vertex0;\n    h = cross(dir, edge2);\n    a = dot(edge1, h);\n\n    // This ray is parallel to this triangle.\n    if (a > -EPSILON && a < EPSILON) {\n        return INF;   \n    }\n    f = 1.0/a;\n    s = pos - vertex0;\n    u = dot(f * s, h);\n    if (u < 0.0 || u > 1.0) {\n        return INF;\n    }\n    q = cross(s, edge1);\n    v = dot(f * dir, q);\n    if (v < 0.0 || u + v > 1.0) {\n        return INF;\n    }\n\n    // At this stage we can compute t to find out where the intersection point is on the line.\n    float t = dot(f * edge2, q);\n    if (t > EPSILON) // ray intersection\n    {\n        normal = normalize(cross(edge2, edge1));\n        return t;\n    }\n    else // This means that there is a line intersection but not a ray intersection.\n        return INF;\n         \n\n}\n\n\n\n\n// (CAMERA_POS + t * viewVec).y == -1\n// t = (-1 - CAMERA_POS.y) / viewVec.y;\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-.7 - pos.y) / dir.y;\n    if (t <= 0.0) {\n       return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 64.0) {\n        return INF;\n    }\n    \n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-0.5 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.5) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -0.5) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -0.5) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\n\n\nvec3 rev(int x_, int z_, vec3 v) {\n    vec3 v_ = v;\n    if (x_ == 1) {\n        v_.x = 0. - v.x;\n    }\n\n    if (z_ == 1) {\n        v_.z = 0. - v.z;\n    }\n\n    return v_;\n}\n\nfloat fogSdf(vec3 pos)\n{\n    return length(pos) - 0.5;\n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nvec4 sampleFog(vec3 pos, vec3 dir)\n{\n    float t = fogSdf(pos);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float absorption = 10.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fogSdf(curPos);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(absorption * (\n            texture(iChannel3, curPos * 0.2).x\n            + texture(iChannel3, curPos * 0.4).x\n            + texture(iChannel3, curPos * 0.8).x\n            + texture(iChannel3, curPos * 1.6).x\n            ) * 0.25 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    return vec4(vec3(5, 2, 5) * totalAbs, 1.0 - opacity);\n}\n\n\n\nbool isOccluded(vec3 pos, vec3 target, Triangle[NUM_OF_MSU_TRIANGLES] MSU_triangles, Sphere[NUM_OF_MSU_SPHERES] MSU_spheres) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    \n    vec3 MSU_TriangleNorm;\n    float MSU_TriangleT;\n    for (int i=0; i < MSU_triangles.length(); i++) {\n\n        for (int x_=0; x_<2; x_++) {\n            for (int z_=0; z_<2; z_++) {\n                vec3 v0 = rev(x_, z_, MSU_triangles[i].vertex0);\n                vec3 v1 = rev(x_, z_, MSU_triangles[i].vertex1);\n                vec3 v2 = rev(x_, z_, MSU_triangles[i].vertex2);\n\n                if ( (x_ == 1 && z_ == 1) || (x_ == 0 && z_ == 0)){\n                    MSU_TriangleT = traceTriangle(pos, dir, v0, v1, v2, MSU_TriangleNorm);\n                } else {\n                    MSU_TriangleT = traceTriangle(pos, dir, v1, v0, v2, MSU_TriangleNorm);\n                }\n            }\n        }\n        if ((MSU_TriangleT + 1.) < dist )\n            return true;\n    }\n\n    \n    vec3 sphNorm;\n    for (int i=0; i < MSU_spheres.length(); i++) {\n        for (float x_=-1.; x_<2.; x_+=2.) {\n            for (float z_=-1.; z_<2.; z_+=2.) {\n                float sphT = traceSphere(pos + vec3(x_ * MSU_spheres[i].orig.x, MSU_spheres[i].orig.y, z_ * MSU_spheres[i].orig.z), dir, MSU_spheres[i].r, sphNorm);\n                if (sphT < dist) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n    \n    \n    \n}\n\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal, Triangle[NUM_OF_MSU_TRIANGLES] MSU_triangles, Sphere[NUM_OF_MSU_SPHERES] MSU_spheres) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS, MSU_triangles,MSU_spheres ) ? 0.0 : 20.0 / (distSq1 );\n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS, MSU_triangles, MSU_spheres) ? 0.0 : 10.0 / (distSq2);\n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * 0.2\n    );\n}\n\n\n\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.0) \n        return reflect(v, normal);\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n\n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n\n    float n1 = AIR_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i < 100; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.3).rgb;\n            normal = planeNorm;\n            if (randVals.z < GLASS_R*5.) {\n                materialType = REFLECTION;\n            }\n        }\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n        if (light1T < t) {\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n        if (light2T < t) {\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n        \n\n        Triangle Triangle1;\n        Triangle1.vertex0 = BackPoint;\n        Triangle1.vertex1 = LeftPoint;\n        Triangle1.vertex2 = DownPoint;\n\n        Triangle Triangle2;\n        Triangle2.vertex0 = DownPoint;\n        Triangle2.vertex1 = RightPoint;\n        Triangle2.vertex2 = BackPoint;\n\n        Triangle Triangle3;\n        Triangle3.vertex0 = DownPoint;\n        Triangle3.vertex1 = FrontPoint;\n        Triangle3.vertex2 = RightPoint;\n\n        Triangle Triangle4;\n        Triangle4.vertex0 = DownPoint;\n        Triangle4.vertex1 = LeftPoint;\n        Triangle4.vertex2 = FrontPoint;\n\n        Triangle Triangle5;\n        Triangle5.vertex0 = UpPoint;\n        Triangle5.vertex1 = LeftPoint;\n        Triangle5.vertex2 = BackPoint;\n\n        Triangle Triangle6;\n        Triangle6.vertex0 = UpPoint;\n        Triangle6.vertex1 = BackPoint;\n        Triangle6.vertex2 = RightPoint;\n\n        Triangle Triangle7;\n        Triangle7.vertex0 = UpPoint;\n        Triangle7.vertex1 = RightPoint;\n        Triangle7.vertex2 = FrontPoint;\n\n        Triangle Triangle8;\n        Triangle8.vertex0 = UpPoint;\n        Triangle8.vertex1 = FrontPoint;\n        Triangle8.vertex2 = LeftPoint;\n \n        Triangle triangles[] = Triangle[](Triangle1, Triangle2, Triangle3, Triangle4, Triangle5, Triangle6, Triangle7, Triangle8);\n \n        for (int i=0; i < triangles.length(); i++) {\n            float al = 0.8;\n            vec3 offset= vec3(0,0.6,0);\n            triangles[i].vertex0 -= offset;\n            triangles[i].vertex1 -= offset;\n            triangles[i].vertex2 -= offset;\n\n            triangles[i].vertex0 *= al;\n            triangles[i].vertex1 *= al;\n            triangles[i].vertex2 *= al;\n        }\n\n        vec3 TriangleNorm;\n        float TriangleT;\n        for (int i=0; i < triangles.length(); i++) {\n            TriangleT = traceTriangle(curPos, curDir, triangles[i].vertex0, triangles[i].vertex1, triangles[i].vertex2, TriangleNorm);\n            if (TriangleT < t) \n            {\n                t = TriangleT;\n                normal = TriangleNorm;\n                if (randVals.x < GLASS_R) {\n                    materialType = REFLECTION;\n                } else {\n                    colorMult *= vec3(0.95, 0.95, 1);\n                    materialType = REFRACTION;\n                    if (dot(curDir, normal) > 0.0) {\n                        nEnter = AIR_N;\n                    } else {\n                        nEnter = GLASS_N;\n                    }\n                }\n            }\n        }\n\n\n        // ================================================================================================================================================\n\n        const float y_1 = 3.5;\n        const float y_2 = 4.;\n        const float y_3 = 6.;\n        const float y_4 = 8.5;\n        const float y_5 = 10.;\n        const float y_6 = 13.;\n\n        const float x_2 = 2.;\n        const float x_1 = 1.2;\n        const float x_01 = 0.7;\n        const float x_001 = 0.12;\n\n        const float z_11 = 1.;\n\n\n        const vec3 MSU_2_0_2 = vec3(x_2, 0, 2);\n        const vec3 MSU_2_5_2 = vec3(x_2, y_3, 2);\n        const vec3 MSU_0_0_2 = vec3(0, 0, 2);\n        const vec3 MSU_0_5_2 = vec3(0, y_3, 2);\n\n\n        Triangle MSU_Triangle1;\n        MSU_Triangle1.vertex0 = MSU_2_5_2;\n        MSU_Triangle1.vertex1 = MSU_2_0_2;\n        MSU_Triangle1.vertex2 = MSU_0_0_2;\n\n\n        Triangle MSU_Triangle2;\n        MSU_Triangle2.vertex0 = MSU_2_5_2;\n        MSU_Triangle2.vertex1 = MSU_0_0_2;\n        MSU_Triangle2.vertex2 = MSU_0_5_2;\n\n        const vec3 MSU_2_5_0 = vec3(x_2, y_3, 0);\n        const vec3 MSU_2_0_0 = vec3(x_2, 0, 0);\n\n        Triangle MSU_Triangle3;\n        MSU_Triangle3.vertex0 = MSU_2_5_0;\n        MSU_Triangle3.vertex1 = MSU_2_0_0;\n        MSU_Triangle3.vertex2 = MSU_2_0_2;\n\n        Triangle MSU_Triangle4;\n        MSU_Triangle4.vertex0 = MSU_2_5_0;\n        MSU_Triangle4.vertex1 = MSU_2_0_2;\n        MSU_Triangle4.vertex2 = MSU_2_5_2;\n\n\n        \n        const vec3 MSU_2_0_1 = vec3(x_2, 0, z_11);\n        const vec3 MSU_2_3_1 = vec3(x_2, y_1, z_11);\n        const vec3 MSU_5_3_1 = vec3(5, y_1, z_11);\n        const vec3 MSU_5_0_1 = vec3(5, 0, z_11);\n\n        Triangle MSU_Triangle5;\n        MSU_Triangle5.vertex0 = MSU_5_3_1;\n        MSU_Triangle5.vertex1 = MSU_5_0_1;\n        MSU_Triangle5.vertex2 = MSU_2_0_1;\n\n        Triangle MSU_Triangle6;\n        MSU_Triangle6.vertex0 = MSU_5_3_1;\n        MSU_Triangle6.vertex1 = MSU_2_0_1;\n        MSU_Triangle6.vertex2 = MSU_2_3_1;\n\n        const vec3 MSU_5_4_4 = vec3(5,y_2,4);\n        const vec3 MSU_5_0_4 = vec3(5,0,4);\n        const vec3 MSU_5_0_0 = vec3(5,0,0);\n        const vec3 MSU_5_4_0 = vec3(5,y_2,0);\n\n        Triangle MSU_Triangle7;\n        MSU_Triangle7.vertex0 = MSU_5_4_4;\n        MSU_Triangle7.vertex1 = MSU_5_0_4;\n        MSU_Triangle7.vertex2 = MSU_5_0_0;\n\n        Triangle MSU_Triangle8;\n        MSU_Triangle8.vertex0 = MSU_5_4_4;\n        MSU_Triangle8.vertex1 = MSU_5_0_0;\n        MSU_Triangle8.vertex2 = MSU_5_4_0;\n\n\n        const vec3 MSU_7_4_4 = vec3(7,y_2,4);\n        const vec3 MSU_7_0_4 = vec3(7,0,4);\n\n        Triangle MSU_Triangle9;\n        MSU_Triangle9.vertex0 = MSU_7_4_4;\n        MSU_Triangle9.vertex1 = MSU_7_0_4;\n        MSU_Triangle9.vertex2 = MSU_5_0_4;\n\n        Triangle MSU_Triangle10;\n        MSU_Triangle10.vertex0 = MSU_7_4_4;\n        MSU_Triangle10.vertex1 = MSU_5_0_4;\n        MSU_Triangle10.vertex2 = MSU_5_4_4;\n\n\n        const vec3 MSU_7_4_0 = vec3(7,y_2,0);\n        const vec3 MSU_7_0_0 = vec3(7,0,0);\n\n        Triangle MSU_Triangle11;\n        MSU_Triangle11.vertex0 = MSU_7_4_0;\n        MSU_Triangle11.vertex1 = MSU_7_0_0;\n        MSU_Triangle11.vertex2 = MSU_7_0_4;\n\n        Triangle MSU_Triangle12;\n        MSU_Triangle12.vertex0 = MSU_7_4_0;\n        MSU_Triangle12.vertex1 = MSU_7_0_4;\n        MSU_Triangle12.vertex2 = MSU_7_4_4;\n\n\n\n        const vec3 MSU_0_5_0 = vec3(0,y_3,0);\n\n\n        Triangle MSU_Triangle13;\n        MSU_Triangle13.vertex0 = MSU_2_5_0;\n        MSU_Triangle13.vertex1 = MSU_2_5_2;\n        MSU_Triangle13.vertex2 = MSU_0_5_2;\n\n        Triangle MSU_Triangle14;\n        MSU_Triangle14.vertex0 = MSU_2_5_0;\n        MSU_Triangle14.vertex1 = MSU_0_5_2;\n        MSU_Triangle14.vertex2 = MSU_0_5_0;\n\n\n        const vec3 MSU_5_3_0 = vec3(5,y_1,0);\n        const vec3 MSU_2_3_0 = vec3(x_2,y_1,0);\n\n\n        Triangle MSU_Triangle15;\n        MSU_Triangle15.vertex0 = MSU_5_3_0;\n        MSU_Triangle15.vertex1 = MSU_5_3_1;\n        MSU_Triangle15.vertex2 = MSU_2_3_1;\n\n        Triangle MSU_Triangle16;\n        MSU_Triangle16.vertex0 = MSU_5_3_0;\n        MSU_Triangle16.vertex1 = MSU_2_3_1;\n        MSU_Triangle16.vertex2 = MSU_2_3_0;\n\n\n\n        Triangle MSU_Triangle17;\n        MSU_Triangle17.vertex0 = MSU_7_4_0;\n        MSU_Triangle17.vertex1 = MSU_7_4_4;\n        MSU_Triangle17.vertex2 = MSU_5_4_4;\n\n        Triangle MSU_Triangle18;\n        MSU_Triangle18.vertex0 = MSU_7_4_0;\n        MSU_Triangle18.vertex1 = MSU_5_4_4;\n        MSU_Triangle18.vertex2 = MSU_5_4_0;\n\n\n\n        const vec3 MSU_15_5_15 = vec3(x_1, y_3, x_1);\n        const vec3 MSU_15_7_15 = vec3(x_1, y_4, x_1);\n        const vec3 MSU_0_5_15 = vec3(0, y_3, x_1);\n        const vec3 MSU_0_7_15 = vec3(0, y_4, x_1);\n\n\n        Triangle MSU_Triangle19;\n        MSU_Triangle19.vertex0 = MSU_15_7_15;\n        MSU_Triangle19.vertex1 = MSU_15_5_15;\n        MSU_Triangle19.vertex2 = MSU_0_5_15;\n\n\n        Triangle MSU_Triangle20;\n        MSU_Triangle20.vertex0 = MSU_15_7_15;\n        MSU_Triangle20.vertex1 = MSU_0_5_15;\n        MSU_Triangle20.vertex2 = MSU_0_7_15;\n\n\n        const vec3 MSU_15_7_0 = vec3(x_1, y_4, 0);\n        const vec3 MSU_15_5_0 = vec3(x_1, y_3, 0);\n\n        Triangle MSU_Triangle21;\n        MSU_Triangle21.vertex0 = MSU_15_7_0;\n        MSU_Triangle21.vertex1 = MSU_15_5_0;\n        MSU_Triangle21.vertex2 = MSU_15_5_15;\n\n        Triangle MSU_Triangle22;\n        MSU_Triangle22.vertex0 = MSU_15_7_0;\n        MSU_Triangle22.vertex1 = MSU_15_5_15;\n        MSU_Triangle22.vertex2 = MSU_15_7_15;\n\n\n\n        const vec3 MSU_0_7_0 = vec3(0,y_4,0);\n\n\n        Triangle MSU_Triangle23;\n        MSU_Triangle23.vertex0 = MSU_15_7_0;\n        MSU_Triangle23.vertex1 = MSU_15_7_15;\n        MSU_Triangle23.vertex2 = MSU_0_7_15;\n\n        Triangle MSU_Triangle24;\n        MSU_Triangle24.vertex0 = MSU_15_7_0;\n        MSU_Triangle24.vertex1 = MSU_0_7_15;\n        MSU_Triangle24.vertex2 = MSU_0_7_0;\n\n\n\n\n        const vec3 MSU_1_7_1 = vec3(x_01, y_4, x_01);\n        const vec3 MSU_1_9_1 = vec3(x_01, y_5, x_01);\n        const vec3 MSU_0_7_1 = vec3(0, y_4, x_01);\n        const vec3 MSU_0_9_1 = vec3(0, y_5, x_01);\n\n\n        Triangle MSU_Triangle25;\n        MSU_Triangle25.vertex0 = MSU_1_9_1;\n        MSU_Triangle25.vertex1 = MSU_1_7_1;\n        MSU_Triangle25.vertex2 = MSU_0_7_1;\n\n\n        Triangle MSU_Triangle26;\n        MSU_Triangle26.vertex0 = MSU_1_9_1;\n        MSU_Triangle26.vertex1 = MSU_0_7_1;\n        MSU_Triangle26.vertex2 = MSU_0_9_1;\n\n\n        const vec3 MSU_1_9_0 = vec3(x_01, y_5, 0);\n        const vec3 MSU_1_7_0 = vec3(x_01, y_4, 0);\n\n        Triangle MSU_Triangle27;\n        MSU_Triangle27.vertex0 = MSU_1_9_0;\n        MSU_Triangle27.vertex1 = MSU_1_7_0;\n        MSU_Triangle27.vertex2 = MSU_1_7_1;\n\n        Triangle MSU_Triangle28;\n        MSU_Triangle28.vertex0 = MSU_1_9_0;\n        MSU_Triangle28.vertex1 = MSU_1_7_1;\n        MSU_Triangle28.vertex2 = MSU_1_9_1;\n\n\n\n         const vec3 MSU_0_9_0 = vec3(0,y_5,0);\n\n\n        Triangle MSU_Triangle29;\n        MSU_Triangle29.vertex0 = MSU_1_9_0;\n        MSU_Triangle29.vertex1 = MSU_1_9_1;\n        MSU_Triangle29.vertex2 = MSU_0_9_1;\n\n        Triangle MSU_Triangle30;\n        MSU_Triangle30.vertex0 = MSU_1_9_0;\n        MSU_Triangle30.vertex1 = MSU_0_9_1;\n        MSU_Triangle30.vertex2 = MSU_0_9_0;\n\n\n\n\n\n\n        const vec3 MSU_03_9_03 = vec3(x_001, y_5, x_001);\n        const vec3 MSU_03_12_03 = vec3(x_001, y_6, x_001);\n        const vec3 MSU_0_9_03 = vec3(0, y_5, x_001);\n        const vec3 MSU_0_12_03 = vec3(0, y_6, x_001);\n\n\n        Triangle MSU_Triangle31;\n        MSU_Triangle31.vertex0 = MSU_03_12_03;\n        MSU_Triangle31.vertex1 = MSU_03_9_03;\n        MSU_Triangle31.vertex2 = MSU_0_9_03;\n\n\n        Triangle MSU_Triangle32;\n        MSU_Triangle32.vertex0 = MSU_03_12_03;\n        MSU_Triangle32.vertex1 = MSU_0_9_03;\n        MSU_Triangle32.vertex2 = MSU_0_12_03;\n\n\n        const vec3 MSU_03_12_0 = vec3(x_001, y_6, 0);\n        const vec3 MSU_03_9_0 = vec3(x_001, y_5, 0);\n\n        Triangle MSU_Triangle33;\n        MSU_Triangle33.vertex0 = MSU_03_12_0;\n        MSU_Triangle33.vertex1 = MSU_03_9_0;\n        MSU_Triangle33.vertex2 = MSU_03_9_03;\n\n        Triangle MSU_Triangle34;\n        MSU_Triangle34.vertex0 = MSU_03_12_0;\n        MSU_Triangle34.vertex1 = MSU_03_9_03;\n        MSU_Triangle34.vertex2 = MSU_03_12_03;\n\n\n\n         const vec3 MSU_0_12_0 = vec3(0,y_6,0);\n\n\n        Triangle MSU_Triangle35;\n        MSU_Triangle35.vertex0 = MSU_03_12_0;\n        MSU_Triangle35.vertex1 = MSU_03_12_03;\n        MSU_Triangle35.vertex2 = MSU_0_12_03;\n\n        Triangle MSU_Triangle36;\n        MSU_Triangle36.vertex0 = MSU_03_12_0;\n        MSU_Triangle36.vertex1 = MSU_0_12_03;\n        MSU_Triangle36.vertex2 = MSU_0_12_0;\n\n \n        Triangle MSU_triangles[] = Triangle[](MSU_Triangle1, MSU_Triangle2, MSU_Triangle3, MSU_Triangle4, MSU_Triangle5, MSU_Triangle6,\n                        MSU_Triangle7, MSU_Triangle8, MSU_Triangle9, MSU_Triangle10, MSU_Triangle11, MSU_Triangle12, MSU_Triangle13, MSU_Triangle14, \\\n                        MSU_Triangle15, MSU_Triangle16, MSU_Triangle17, MSU_Triangle18, MSU_Triangle19, MSU_Triangle20, MSU_Triangle21, MSU_Triangle22, \\\n                        MSU_Triangle23, MSU_Triangle24, MSU_Triangle25, MSU_Triangle26, MSU_Triangle27, MSU_Triangle28, MSU_Triangle29, MSU_Triangle30, \\\n                        MSU_Triangle31, MSU_Triangle32, MSU_Triangle33, MSU_Triangle34, MSU_Triangle35, MSU_Triangle36);\n\n\n        float al = 0.05;\n        vec3 offset = vec3(0,1.5,0);\n\n\n        Sphere MSU_Sphere1;\n        MSU_Sphere1.r = 0.9;\n        MSU_Sphere1.orig = vec3(6, -(y_2 +  MSU_Sphere1.r), 3);\n\n\n        Sphere MSU_Sphere2;\n        MSU_Sphere2.r = 0.3;\n        MSU_Sphere2.orig = vec3(0, -(y_6 + MSU_Sphere2.r), 0);\n\n        Sphere MSU_Sphere3;\n        MSU_Sphere3.r = 0.3;\n        MSU_Sphere3.orig = vec3(x_2 - MSU_Sphere3.r , -(y_3 + MSU_Sphere3.r), x_2 - MSU_Sphere3.r);\n\n\n\n        Sphere MSU_spheres[] = Sphere[](MSU_Sphere1, MSU_Sphere2, MSU_Sphere3); \n\n        for (int i=0; i < MSU_spheres.length(); i++) {\n            MSU_spheres[i].orig-= offset;\n            MSU_spheres[i].r *= al;\n            MSU_spheres[i].orig *= al;\n        }\n\n\n\n        float y_line = y_2;\n        y_line += offset.y;\n        y_line *= al;\n\n        float y_line2 = y_3;\n        y_line2 += offset.y;\n        y_line2 *= al;\n\n        float x_line = x_2;\n        x_line *= al;\n\n\n        if (randVals.x < 0.8) {\n            for (int i=0; i < MSU_triangles.length(); i++) {\n                MSU_triangles[i].vertex0 += offset;\n                MSU_triangles[i].vertex1 += offset;\n                MSU_triangles[i].vertex2 += offset;\n                \n                MSU_triangles[i].vertex0 *= al;\n                MSU_triangles[i].vertex1 *= al;\n                MSU_triangles[i].vertex2 *= al;\n            }\n\n            vec3 MSU_TriangleNorm;\n            float MSU_TriangleT;\n            for (int i=0; i < MSU_triangles.length(); i++) {\n                for (int x_=0; x_<2; x_++) {\n                    for (int z_=0; z_<2; z_++) {\n                        vec3 v0 = rev(x_, z_, MSU_triangles[i].vertex0);\n                        vec3 v1 = rev(x_, z_, MSU_triangles[i].vertex1);\n                        vec3 v2 = rev(x_, z_, MSU_triangles[i].vertex2);\n\n                        if ( (x_ == 1 && z_ == 1) || (x_ == 0 && z_ == 0)){\n                            MSU_TriangleT = traceTriangle(curPos, curDir, v0, v1, v2, MSU_TriangleNorm);\n                        } else {\n                            MSU_TriangleT = traceTriangle(curPos, curDir, v1, v0, v2, MSU_TriangleNorm);\n                        }\n                        if (MSU_TriangleT < t) \n                        {\n                            t = MSU_TriangleT;\n                            normal = MSU_TriangleNorm;\n                            materialType = DIFFUSE;\n                        \n                            vec3 worldPos = t * curDir + curPos;\n                            color = vec3(0.9,0.8,0.5);\n                            if (abs(worldPos.x) > x_line + 1e-3 && worldPos.y > (y_line - MSU_spheres[0].r) && worldPos.y < (y_line - 2. * MSU_spheres[0].r / 3.)) {\n                                color = color = vec3(0.6,0.0,0.0);\n                            } else if (abs(worldPos.x) <= x_line + 1e-3 && worldPos.y > (y_line2 - MSU_spheres[0].r) && worldPos.y < (y_line2 - 2. * MSU_spheres[0].r / 3.)) {\n                                color = color = vec3(0.6,0.0,0.0);\n                            }\n                        \n                        }\n                    }\n                }\n                \n            }\n        \n\n        // ================================================================================================================================================\n            vec3 sphNorm;\n            vec3 gold_color = vec3(0.85, 0.65, 0.3);\n            for (int i=0; i < MSU_spheres.length(); i++) {\n                for (float x_=-1.; x_<2.; x_+=2.) {\n                    for (float z_=-1.; z_<2.; z_+=2.) {\n                        float sphT = traceSphere(curPos + vec3(x_ * MSU_spheres[i].orig.x, MSU_spheres[i].orig.y, z_ * MSU_spheres[i].orig.z), curDir, MSU_spheres[i].r, sphNorm);\n                        if (sphT < t) {\n                            t = sphT;\n                            normal = sphNorm;\n                            materialType = DIFFUSE;\n                            color =  gold_color;\n                        }\n                    }\n                }\n            }\n        }\n        // ================================================================================================================================================\n\n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * (worldPos.y - 1.)).rgb;\n            \n            normal = cylNorm;\n        }\n       \n        \n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal, MSU_triangles, MSU_spheres) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-5;\n\n                vec4 fog = sampleFog(curPos, viewVec);\n                fragColor.rgb += fog.rgb * fog.a * colorMult;\n                colorMult *= (1.0 - fog.a);\n\n                n1 = nEnter;\n            }\n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 234]], "test": "untested"}
{"id": "fsfSzS", "name": "noise balanced isolines -interp2", "author": "FabriceNeyret2", "description": "TAB for debug display.\nBottom: noise isovalues are not equidistant.\nCompare to [url]https://shadertoy.com/view/NdfXW7[/url], here I smart-interpolates between distance to peak and distance to valey.", "tags": ["procedural", "noise", "perlin"], "likes": 3, "viewed": 267, "published": 3, "date": "1618745186", "time_retrieved": "2024-07-30T19:25:22.294145", "image_code": "// Fork of \"test5: noise balanced isolines -interp\"  https://shadertoy.com/view/NdfXW7\n// Fork of \"test4: noise balanced isolines\" https://shadertoy.com/view/fsfXWM\n// Fork of \"test3: Curl noise balance\"      https://shadertoy.com/view/NssXD4\n// Fork of \"test1: Noise balance\"           https://shadertoy.com/view/ssXXWN\n\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define draw(v,d)      clamp(1. - abs( fract(v) - .5 ) / fwidth(d), 0.,1.)\n//#define Ierf(x)    ( atanh(x) / 1.2 )          // not so bad reciprocal of erf\n\n#define func( P )    ( keyToggle(32) ? perlin( P ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime), P0=P;\t\n    O-=O;\n\tfloat l0, l = 0., f = func(P), f0=f;\n    if ( int(u.y) == int(R.y*.4) ) { O.r++; return; } // red separator\n    if( U.y > .4) {\n        float s = .1;                           // steps size\n                                                //  --- ascent to peak\n        for (int i=0; i < 300; i++ ){\n            vec2 G =  ( f - vec2( func(P-eps.xy), func(P-eps.yx) )) /eps.x; // gradient\n         // vec2 G = vec2( dFdx(f), dFdy(f) ) * R.y/8.;\n            P += s* G;                          // ascent\n            l += s* length(G);                  // optional: cumul curved lenght\n            f = func( P ); \n            if ( length(G) < 1e-2 ) break;      // creast or valley reached\n        }\n     // l = length(P-P0);                       // optional: use straight distance instead of curved (ok for descent )\n        \n        l0 = l; l = 0.; P = P0; f = func(P); \n      //s = .1;                                        // --- descent to nega-peak\n        for (int i=0; i < 300; i++ ){\n            vec2 G =  ( f - vec2( func(P-eps.xy), func(P-eps.yx) )) /eps.x; // gradient\n         // vec2 G = vec2( dFdx(f), dFdy(f) ) * R.y/8.;\n            P -= s* G;                          // descent\n            l -= s* length(G);                  // optional: cumul curved lenght\n            f = func( P ); \n            if ( length(G) < 1e-2 ) break;      // creast or valley reached\n        }\n     // l = length(P-P0);                       // optional: use straight distance instead of curved (ok for descent )\n\n     // --- l0 = dist to iso0, l = dist to peak\n        if( keyToggle(9) ) {\n            O.g += draw(8.*l0,8.*l0)*U.x;\n            O.b += float(abs(f0)<.01);\n            O.r += draw(8.*l ,8.*l )*2.*U.x;\n         // return;\n        }\n        if ( max(fwidth(l0),fwidth(l)) > 50.*fwidth(U.x) ) return; // trim artifacts\n        \n        if (true) { float v1 = fract(f=8.*l), v0 = fract(8.*l0);\n                    v1 = fract(v1-v0+.5) +v0-.5; l = mix(v0,v1,abs(l0)/(abs(l0)+abs(l)));  \n                 // O += abs(fract(l)-.5)*2.; sin(6.28*l); \n                    O += draw(l,f); return; }\n     // l = (l0-l)/2.;\n\n        f = l;\n    }\n/*  else {\n        O = vec4(.5+f);                                           // draw noise\n        O.b += clamp(.5-.5*abs(f)/fwidth(f), 0.,1.); \n        return;\n    }\n*/\n\n // O = vec4(.5+.5*sin(50.*l));\n    f = 8.*f; O += draw(f,f); // draw isolines\n    O = sqrt(O);                                                  // to sRGB\n\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfSzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[772, 772, 795, 795, 1088], [1090, 1090, 1114, 1169, 1328], [1330, 1330, 1368, 1368, 3970]], "test": "untested"}
{"id": "NsXSRS", "name": " - Qualigraphic", "author": "totetmatt", "description": "Got inspired from a friend  creation : https://www.instagram.com/p/CNwSYrJha7n/", "tags": ["2d", "wave", "lines", "drawing"], "likes": 16, "viewed": 404, "published": 3, "date": "1618738991", "time_retrieved": "2024-07-30T19:25:23.153846", "image_code": "#define hash21(p) fract(sin(dot(p, vec2(122.9898, 78.2033))) * 43758.5453)\n\nfloat fig(vec2 uv,vec2 offset){\nvec2 uuv= uv;\n   uv+=offset;\n float d = length(uv)-.052;\n    d = smoothstep(.010,.011,d);\n    float c = d;\n\n    \n    for(float i=0.;i<25.;i++){\n        vec2 n = uv;\n        float h  = hash21(vec2(i,i+.12)+offset);\n         \n        float at= atan(n.x,n.y);\n\n       float q=length(uv)-(.120+.018*i+sin(iTime*.33+at*9.+h*h*h*h*exp(mod(i+7.,14.)))*(.01+.001*i+h*.008));\n       //q = smoothstep(.0040,.0071,abs(q)-.001-sin(iTime+i+at*2.+h*100.)*.005+.003);\n       q = smoothstep(0., fwidth(q),abs(q)-.001-sin(iTime+i+at*2.+h*100.)*.005-.0001);\n       d = min(q,d);\n    }\n    \n    float lim = .47;\n    if(abs(uuv.x) >lim || abs(uuv.y) > lim){\n        d=1.;\n    }\n    d = min(c,d);\n    return d;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n\n     \n     vec2 offset = vec2(-.4,.4);\n    float d = fig(uv,offset);\n    float e = fig(uv,offset*-1.);\n    d  =min(d,e);\n    vec3 col = vec3(d);\n    col = mix(vec3(.1),vec3(1.,.95,.9),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 107, 107, 799], [800, 800, 855, 855, 1143]], "test": "untested"}
{"id": "NdfXW7", "name": "noise balanced isolines - interp", "author": "FabriceNeyret2", "description": "TAB for debug display.\nBottom: noise isovalues are not equidistant.\n[url]https://shadertoy.com/view/fsfXWM[/url] shows drawing iso-distances from isoval0 (debug:green) or peaks (debug:red), with dual discontinuities.\n Here, solved with smart interpolatio", "tags": ["procedural", "noise", "perlin"], "likes": 7, "viewed": 588, "published": 3, "date": "1618738171", "time_retrieved": "2024-07-30T19:25:23.976646", "image_code": "// Fork of \"test4: noise balanced isolines\" https://shadertoy.com/view/fsfXWM\n// Fork of \"test3: Curl noise balance\"      https://shadertoy.com/view/NssXD4\n// Fork of \"test1: Noise balance\"           https://shadertoy.com/view/ssXXWN\n\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define draw(v,d)      clamp(1. - abs( fract(v) - .5 ) / fwidth(d), 0.,1.)\n//#define Ierf(x)    ( atanh(x) / 1.2 )          // not so bad reciprocal of erf\n\n#define func( P )    ( keyToggle(32) ? perlin( P ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime), P0=P;\t\n    O-=O;\n\tfloat l0, l = 0., f = func(P);\n    if ( int(u.y) == int(R.y*.4) ) { O.r++; return; } // red separator\n    if( U.y > .4) {\n        float s = .1;                           // steps size\n                        // --- descent to isoline-0\n        for (int i=0; i < 30; i++ ){\n            vec2 G =  ( f - vec2( func(P-eps.xy), func(P-eps.yx) )) /eps.x; // gradient\n         // vec2 G = vec2( dFdx(f), dFdy(f) ) * R.y/8.;\n            P -= s* f * G/dot(G,G);             // descent\n            l += s* f / length(G);              // optional: cumul curved lenght\n            f = func( P ); \n         // if ( length(G) < .2 ) return;       // trying to cull crests and valleys\n            if (abs(f) < 1e-3) break;           // isovalue 0 reached\n        }\n     // l = length(P-P0);                       // optional: use straight distance instead of curved (ok for descent )\n        \n        l0 = l; l = 0.; P = P0; f = func(P); \n      //s = .1;                                        // --- ascent to peak\n        for (int i=0; i < 300; i++ ){\n            vec2 G =  ( f - vec2( func(P-eps.xy), func(P-eps.yx) )) /eps.x; // gradient\n         // vec2 G = vec2( dFdx(f), dFdy(f) ) * R.y/8.;\n#if 0                                           // ... all from positive pole\n            P += s* G;                          // ascent\n            l += s* length(G);                  // optional: cumul curved lenght\n#else                                           // ... from both poles\n            P += s* sign(f)*  G;                // ascent\n            l += s* sign(f)* length(G);         // optional: cumul curved lenght\n#endif\n            f = func( P ); \n            if ( length(G) < 1e-2 ) break;      // creast or valley reached\n        }\n     // l = length(P-P0);                       // optional: use straight distance instead of curved (ok for descent )\n\n     // --- l0 = dist to iso0, l = dist to peak\n        if( keyToggle(9) ) {\n            O.g += draw(8.*l0,8.*l0)*U.x;\n            O.b += float(abs(l0)<.01);\n            O.r += draw(8.*l ,8.*l )*2.*U.x;\n         // return;\n        }\n        if ( max(fwidth(l0),fwidth(l)) > 50.*fwidth(U.x) ) return; // trim artifacts\n        \n     // if (false) { l = fract(f=8.*l), l0=fract(8.*l0), \n     //             l = fract(l-l0+.5) +l0-.5; l = mix(l0,l,l0/(l0+l));  // wrong slider: l changed\n     //             O += abs(fract(l)-.5)*2.; sin(6.28*l); return; }\n        if (true) { float v1 = 1.-fract(f=8.*l), v0 = fract(8.*l0);\n                    v1 = fract(v1-v0+.5) +v0-.5; l = mix(v0,v1,abs(l0)/(abs(l0)+abs(l)));  \n                 // O += abs(fract(l)-.5)*2.; sin(6.28*l); \n                    O += draw(l,f); return; }\n     // l = (l0-l)/2.;\n\n        f = l;\n    }\n/*  else {\n        O = vec4(.5+f);                                           // draw noise\n        O.b += clamp(.5-.5*abs(f)/fwidth(f), 0.,1.); \n        return;\n    }\n*/\n\n // O = vec4(.5+.5*sin(50.*l));\n    f = 8.*f; O += draw(f,f); // draw isolines\n    O = sqrt(O);                                                  // to sRGB\n\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfXW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[685, 685, 708, 708, 1001], [1003, 1003, 1027, 1082, 1241], [1243, 1243, 1281, 1281, 4455]], "test": "untested"}
{"id": "7dlXD7", "name": "Boxblur flow", "author": "kaihagseth", "description": "Interactive - draw with mouse", "tags": ["interactive", "draw"], "likes": 0, "viewed": 264, "published": 3, "date": "1618735782", "time_retrieved": "2024-07-30T19:25:24.846321", "image_code": "float normalizedSin(in float x)\n{\n    return (1.0 - cos(x)) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    fragColor = vec4(normalizedSin(x*2.), normalizedSin(x*4.), normalizedSin(x*3.), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MOUSEADD 5000.\n#define MOUSEMULTIPLY 1.1\n\nfloat px( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p + r) % r;\n    return texelFetch(iChannel0, p, 0).x;\n}\n\nfloat boxBlur(in ivec2 p)\n{  \n    float sum = px(ivec2(p.x, p.y-2)) + px(ivec2(p.x, p.y-1)) + px(ivec2(p.x-2, p.y)) + px(ivec2(p.x-1, p.y))\n             + px(ivec2(p.x+1, p.y)) + px(ivec2(p.x+2, p.y)) + px(ivec2(p.x, p.y+1)) + px(ivec2(p.x, p.y+2));\n    return sum / 8.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    ivec2 coord = ivec2(fragCoord);\n    float o = boxBlur(coord);\n    //o *= (sin(iTime*0.5) *0.003) + 1.0;\n    if(length(fragCoord.xy-iMouse.xy) < 1.5 && iMouse.z > .1)\n    {\n        o += MOUSEADD;\n        o *= MOUSEMULTIPLY;\n    }\n    fragColor = vec4(o, 0.0, 0.0, 0.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlXD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 68], [70, 70, 127, 127, 279]], "test": "untested"}
{"id": "7slSDM", "name": "Bitwise cloud landscape", "author": "jarble", "description": "A cloudy landscape generated using a bitwise formula.", "tags": ["fractal", "cloud", "bitwise"], "likes": 7, "viewed": 277, "published": 3, "date": "1618715097", "time_retrieved": "2024-07-30T19:25:25.616262", "image_code": "#define ITERS 9\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 2000.0;\n    float trans = iTime * 200.0;\n    vec2 coord = (scale * fragCoord/iResolution.xy) + vec2(trans+30000.0,0.0);\n    \n    int val = 0;\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev = vec3(0.0);\n    for(int i = 0; i < ITERS; i++){\n        col_prev = col;\n        coord.y -= (result-11.0);\n        coord += coord.yy/32.0+col.x;\n        coord = coord.yx/(2.5);\n        result = ((result + float(val = ((int(coord.x+coord.y/2.0) & int(coord.y+coord.x/2.0)) % 3)))/(2.0));\n        col.x = result;\n        col = ((col.yzx)*2.0+col_prev)/3.5;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slSDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dlXWM", "name": "2D Shadow Volumes", "author": "oneshade", "description": "Shadow volumes.", "tags": ["2d", "distancefield", "sdf", "light", "shadows", "shadowvolumes"], "likes": 9, "viewed": 388, "published": 3, "date": "1618713706", "time_retrieved": "2024-07-30T19:25:26.390193", "image_code": "// Whether or not shadows can hide objects\n//#define OBSTRUCT\n\n// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\nstruct ShadowVol2D {\n    vec2 ap;\n    vec2 ad;\n    vec2 bp;\n    vec2 bd;\n};\n\n// Shadow volumes\nShadowVol2D shadowVolLine(in vec2 l, in vec2 a, in vec2 b) {\n    return ShadowVol2D(a, normalize(a - l), b, normalize(b - l));\n}\n\nShadowVol2D shadowVolDisc(in vec2 l, in float r) {\n    float t = acos(r / length(l));\n    vec2 a = atan(l.y, l.x) + vec2(-t, t);\n    vec2 c1 = vec2(cos(a.x), sin(a.x)) * r;\n    vec2 c2 = vec2(cos(a.y), sin(a.y)) * r;\n    return ShadowVol2D(c1, normalize(c1 - l), c2, normalize(c2 - l));\n}\n\nShadowVol2D shadowVolBox(in vec2 l, in vec2 b) {\n    vec2 s = vec2(l.x < 0.0 ? -1.0 : 1.0, l.y < 0.0 ? -1.0 : 1.0);\n    vec2 c1 = vec2(b.x * sign(b.y - abs(l.y)), b.y) * s;\n    vec2 c2 = vec2(b.x, b.y * sign(b.x - abs(l.x))) * s;\n    return ShadowVol2D(c1, normalize(c1 - l), c2, normalize(c2 - l));\n}\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisc(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n}\n\nfloat sdShadowVolume2D(in vec2 p, in vec2 ap, in vec2 ad, in vec2 bp, in vec2 bd) {\n    vec2 pa = p - ap, pb = p - bp, ba = bp - ap;\n\n    vec2 b = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 e1 = pa - ad * max(0.0, dot(pa, ad) / dot(ad, ad));\n    vec2 e2 = pb - bd * max(0.0, dot(pb, bd) / dot(bd, bd));\n\n    vec2 bap = vec2(-ba.y, ba.x), h = 0.5 * (ad + bd);\n    float s = sign(max(dot(pa, vec2(-ad.y, ad.x)) * dot(pb, vec2(-bd.y, bd.x)), dot(pa, bap) * sign(dot(bap, -h))));\n    return sqrt(min(dot(b, b), min(dot(e1, e1), dot(e2, e2)))) * s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse.xy = vec2(0.0);\n\n    // Inverse square (kinda)\n    vec2 toLight = uv - mouse.xy;\n    vec3 color = vec3(1.0 / (1.0 + dot(toLight, toLight)));\n\n    // Shapes and shadow volumes\n    vec2 la = vec2(-2.0, -0.5), lb = vec2(-1.5, 1.0);\n    ShadowVol2D lineShadow = shadowVolLine(mouse.xy, la, lb);\n    float lineShadowVol = sdShadowVolume2D(uv, lineShadow.ap, lineShadow.ad, lineShadow.bp, lineShadow.bd); // Shadow volume distance\n    float line = sdLine(uv, la, lb); // Line distance\n\n    vec2 bp = vec2(0.0, -1.0), bb = vec2(0.5, 0.2);\n    ShadowVol2D boxShadow = shadowVolBox(mouse.xy - bp, bb); // Object space\n    boxShadow.ap += bp, boxShadow.bp += bp; // Back to world space\n    float boxShadowVol = sdShadowVolume2D(uv, boxShadow.ap, boxShadow.ad, boxShadow.bp, boxShadow.bd); // Shadow volume distance\n    float box = sdBox(uv - bp, bb); // Box distance\n\n    vec2 cp = vec2(1.0, 0.8); float cr = 0.6;\n    ShadowVol2D discShadow = shadowVolDisc(mouse.xy - cp, cr); // Object space\n    discShadow.ap += cp, discShadow.bp += cp; // Back to world space\n    float discShadowVol = sdShadowVolume2D(uv, discShadow.ap, discShadow.ad, discShadow.bp, discShadow.bd); // Shadow volume distance\n    float disc = sdDisc(uv - cp, cr); // Disc distance\n\n    if (min(sdLine(mouse.xy, la, lb), min(sdBox(mouse.xy - bp, bb), sdDisc(mouse.xy - cp, cr))) > 0.0) {\n        // Draw shadow volumes\n        drawSDF(lineShadowVol, vec3(0.0));\n        drawSDF(boxShadowVol, vec3(0.0));\n        drawSDF(discShadowVol, vec3(0.0));\n\n        // Draw shapes\n        #ifdef OBSTRUCT\n        drawSDF(max(line, -min(boxShadowVol, discShadowVol)), vec3(1.0, 0.8, 0.0));\n        drawSDF(max(box, -min(lineShadowVol, discShadowVol)), vec3(0.8, 0.0, 0.0));\n        drawSDF(max(disc, -min(lineShadowVol, boxShadowVol)), vec3(0.0, 0.0, 1.0));\n        #else\n        drawSDF(line, vec3(1.0, 0.8, 0.0));\n        drawSDF(box, vec3(0.8, 0.0, 0.0));\n        drawSDF(disc, vec3(0.0, 0.0, 1.0));\n        #endif\n    }\n\n    // Light is inside an object\n    else {\n        color = vec3(0.0);\n        #ifndef OBSTRUCT\n        drawSDF(line, vec3(1.0, 0.8, 0.0));\n        drawSDF(box, vec3(0.8, 0.0, 0.0));\n        drawSDF(disc, vec3(0.0, 0.0, 1.0));\n        #endif\n    }\n\n    // Draw light\n    drawSDF(sdDisc(uv - mouse.xy, 0.05), vec3(1.0, 0.8, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 252, 312, 312, 380], [382, 382, 432, 432, 670], [672, 672, 720, 720, 973], [975, 983, 1030, 1030, 1138], [1140, 1140, 1177, 1177, 1205], [1207, 1207, 1242, 1242, 1327], [1329, 1329, 1412, 1412, 1894], [1896, 1896, 1951, 1951, 4594]], "test": "untested"}
{"id": "fslXD7", "name": "Distance to 2D Shadow Volume", "author": "oneshade", "description": "Exact distance to a 2D shadow volume.", "tags": ["2d", "volume", "sdf", "shadow", "distance", "exact"], "likes": 15, "viewed": 252, "published": 3, "date": "1618708956", "time_retrieved": "2024-07-30T19:25:27.163127", "image_code": "struct ShadowVol2D {\n    vec2 ap;\n    vec2 ad;\n    vec2 bp;\n    vec2 bd;\n};\n\nShadowVol2D shadowVolBox2D(in vec2 l, in vec2 b) {\n    vec2 s = vec2(l.x < 0.0 ? -1.0 : 1.0, l.y < 0.0 ? -1.0 : 1.0);\n    vec2 c1 = vec2(b.x * sign(b.y - abs(l.y)), b.y) * s;\n    vec2 c2 = vec2(b.x, b.y * sign(b.x - abs(l.x))) * s;\n    return ShadowVol2D(c1, normalize(c1 - l), c2, normalize(c2 - l));\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n}\n\n// ap, bp: corners of the shadow volume\n// ad, bd: direction of the shadow corresponding to a corner of it\nfloat sdShadowVolume2D(in vec2 p, in vec2 ap, in vec2 ad, in vec2 bp, in vec2 bd) {\n    vec2 pa = p - ap, pb = p - bp, ba = bp - ap;\n\n    vec2 b = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 e1 = pa - ad * max(0.0, dot(pa, ad) / dot(ad, ad));\n    vec2 e2 = pb - bd * max(0.0, dot(pb, bd) / dot(bd, bd));\n\n    vec2 bap = vec2(-ba.y, ba.x), h = 0.5 * (ad + bd);\n    float s = sign(max(dot(pa, vec2(-ad.y, ad.x)) * dot(pb, vec2(-bd.y, bd.x)), dot(pa, bap) * sign(dot(bap, -h))));\n    return sqrt(min(dot(b, b), min(dot(e1, e1), dot(e2, e2)))) * s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(2.0, 1.0);\n\n    vec2 box = vec2(1.0, 0.5);\n    ShadowVol2D boxShadow = shadowVolBox2D(mouse, box);\n\n    float d = sdShadowVolume2D(uv, boxShadow.ap, boxShadow.ad, boxShadow.bp, boxShadow.bd);\n    d *= 0.5; // Expand isolines\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    // Shadow caster\n    float boxDist = sdBox(uv, box);\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, boxDist));\n    color = mix(color, vec3(0.0), smoothstep(unit, 0.0, abs(boxDist)));\n\n    // Edges of shadow volume\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(dot(uv - boxShadow.ap, vec2(-boxShadow.ad.y, boxShadow.ad.x)))));\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(dot(uv - boxShadow.bp, vec2(-boxShadow.bd.y, boxShadow.bd.x)))));\n\n    // Light\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - mouse) - 0.05));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslXD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 127, 127, 380], [382, 382, 417, 417, 502], [504, 611, 694, 694, 1176], [1178, 1178, 1233, 1233, 2593]], "test": "untested"}
{"id": "NslXDM", "name": "CircleCross - distance 2D", "author": "iq", "description": "Exact SDF to the intersection of four circles", "tags": ["2d", "distancefield", "sdf", "distancefunction", "distance"], "likes": 20, "viewed": 1311, "published": 3, "date": "1618705226", "time_retrieved": "2024-07-30T19:25:28.025820", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact SDF of four circle arcs\n\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdRoundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h);               // k should be const/precomputed at modeling time\n    \n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(dot2(p-vec2(1,k)))  :  // circular arc\n           sqrt(min(dot2(p-vec2(0,h)),     // top corner\n                    dot2(p-vec2(1,0))));   // right corner\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.35;\n    m *= 1.35;\n    \n    // animate\n    float he = 0.501-0.499*cos(iTime*1.1+0.0);\n    float ra = 0.100+0.100*sin(iTime*1.7+2.0);\n\n    // compute\n\tfloat d = sdRoundedCross( p, he ) - ra;\n\n    // colorize\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(100.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdRoundedCross(m, he) - ra;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslXDM.jpg", "access": "api", "license": "mit", "functions": [[1237, 1237, 1262, 1262, 1281], [1282, 1282, 1329, 1329, 1665], [1667, 1667, 1724, 1724, 2531]], "test": "untested"}
{"id": "NssXWM", "name": "BlobbyCross - distance 2D", "author": "iq", "description": "Exact SDF of a blobby cross made of parabolic segments. Inspired by oneshader's Tractrix SDF: [url]https://www.shadertoy.com/view/sdsXWN[/url]. The interior distance is not always exact.", "tags": ["2d", "distancefield", "sdf", "distancefunction", "cross", "parabola"], "likes": 23, "viewed": 1533, "published": 3, "date": "1618701851", "time_retrieved": "2024-07-30T19:25:28.792769", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Exact SDF of a blobby cross made of parabolic segments. Inspired by \n// oneshader's Tractrix SDF: https://www.shadertoy.com/view/sdsXWN\n// PLEASE NOTE - the interior distance is not always exact.\n\n\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat sdBlobbyCross( in vec2 pos, float he )\n{\n    pos = abs(pos);\n    pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n\n    float p = (he-pos.y-0.25/he)/(6.0*he);\n    float q = pos.x/(he*he*16.0);\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x,sqrt(2.0)/2.0);\n    \n    vec2 z = vec2(x,he*(1.0-2.0*x*x)) - pos;\n    return length(z) * sign(z.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 2.0;\n    m *= 2.0;\n    \n    float time = iTime;\n    float he = sin(time*0.43+4.0); he = (0.001+abs(he)) * ((he>=0.0)?1.0:-1.0);\n    float ra = 0.1 + 0.5*(0.5+0.5*sin(time*1.7)) + max(0.0,he-0.7);\n\n\tfloat d = sdBlobbyCross( p, he ) - ra;\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-1.5*abs(d));\n\tcol *= 0.8 + 0.2*cos(75.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdBlobbyCross(m, he) - ra;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssXWM.jpg", "access": "api", "license": "mit", "functions": [[1405, 1405, 1451, 1451, 1939], [1941, 1941, 1998, 1998, 2829]], "test": "untested"}
{"id": "7sfXD7", "name": "Odd little system", "author": "aferriss", "description": "A funky little feedback system I found today while playing around.", "tags": ["feedback"], "likes": 4, "viewed": 246, "published": 3, "date": "1618699194", "time_retrieved": "2024-07-30T19:25:29.567697", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Output to screen\n    fragColor = 1.0- step(0.00001, texture(iChannel0, uv));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tc = fragCoord.xy / iResolution.xy;\n    \n    vec4 tex = texture(iChannel1, tc);\n    //vec4 past = texture(iChannel0, tc + vec2(0.01));\n    \n    if(iFrame < 1 || iFrame % 1500 == 0 || iMouse.z > 0.0){\n    // Seed the feedback\n         if(tc.x >0.475 && tc.x < 0.525 && tc.y > 0.475 && tc.y <0.525){\n            fragColor = vec4(1.0);\n        } else {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        }\n    } else {\n        fragColor = tex;\n    }\n    \n    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    vec4 t = texture(iChannel0, uv);\n    \n    vec4 n = texture(iChannel0, uv + vec2(0.0, texel.y));\n    vec4 e = texture(iChannel0, uv + vec2(texel.x, 0.0));\n    vec4 w = texture(iChannel0, uv + vec2(-texel.x, 0.0));\n    vec4 s = texture(iChannel0, uv + vec2(0.0, -texel.y));\n    \n    if(iFrame % 2 == 0){ \n        fragColor = abs(e - t) + abs(w - t) ;\n    } else {\n        fragColor = abs(n - t) + abs(s - t) ;\n    }\n    \n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfXD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 188]], "test": "untested"}
{"id": "fsfXWM", "name": "noise balanced isolines", "author": "FabriceNeyret2", "description": "Bottom: noise isovalues are not equidistant.\nTop-Left: Drawing iso-spaced lines upon noise based on curved distance to isoline 0.\nProblem: discontinuities at creasts + pinched  look there.\nTop-Right: curve distance to peak. \nProblem: cellular look.", "tags": ["procedural", "noise", "perlin"], "likes": 7, "viewed": 380, "published": 3, "date": "1618690551", "time_retrieved": "2024-07-30T19:25:30.333649", "image_code": "// Fork of \"test3: Curl noise balance\"  https://shadertoy.com/view/NssXD4\n// Fork of \"test1: Noise balance\"  https://shadertoy.com/view/ssXXWN\n\n\n#define hash(p ) ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define grad(x,y)  dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n#define Ierf(x) ( atanh(x) / 1.2 )          // not so bad reciprocal\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f); // smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.));\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\n#define func( P ) ( keyToggle(32) ? perlin( P ) : noise( P ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime), P0=P;\t\n    O-=O;\n\tfloat l = 0., f = func(P);\n    \n    if( U.y > .4) {\n        if ( int(u.x) == int(R.x/2.) ) { O.r++; return; } // red separator\n        float s = .1;                               // steps size\n        if (U.x < .5*R.x/R.y)                       // --- left: descent to isoline-0\n            for (int i=0; i < 30; i++ ){\n                vec2 G =  ( f - vec2( func(P-eps.xy), func(P-eps.yx) )) /eps.x; // gradient\n             // vec2 G = vec2( dFdx(f), dFdy(f) ) * R.y/8.;\n                P -= s* f * G/dot(G,G);             // descent\n                l += s* f / length(G);              // optional: cumul curved lenght\n                f = func( P ); \n             // if ( length(G) < .2 ) return;       // trying to cull crests and valleys\n                if (abs(f) < 1e-3) break;           // isovalue 0 reached\n            }\n        else                                        // --- right: ascent to peak\n            for (int i=0; i < 30; i++ ){\n                vec2 G =  ( f - vec2( func(P-eps.xy), func(P-eps.yx) )) /eps.x; // gradient\n             // vec2 G = vec2( dFdx(f), dFdy(f) ) * R.y/8.;\n#if 1                                               // ... all from positive pole\n                P += s* G;                          // ascent\n                l += s* length(G);                  // optional: cumul curved lenght\n#else                                               // ... from both poles\n                P += s* sign(f)*  G;                // ascent\n                l += s* sign(f)* length(G);         // optional: cumul curved lenght\n#endif\n                f = func( P ); \n                if ( length(G) < 1e-2 ) break;      // creast or valley reached\n            }\n    //  l = length(P-P0);                           // optional: use straight distance instead of curved (ok for descent )\n        f = l;\n    }\n/*  else {\n        O = vec4(.5+f);                                           // draw noise\n        O.b += clamp(.5-.5*abs(f)/fwidth(f), 0.,1.); \n        return;\n    }\n*/\n\n // O = vec4(.5+.5*sin(50.*l));\n    f = 8.*f; O += clamp(1. - abs(fract(f)-.5)/fwidth(f), 0.,1.); // draw isolines\n    O = sqrt(O);                                                  // to sRGB\n\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[433, 433, 456, 456, 707], [709, 709, 733, 788, 947], [1013, 1013, 1051, 1051, 3376]], "test": "untested"}
{"id": "sdsXDN", "name": "Whack-a-Spook", "author": "Tater", "description": "spooky", "tags": ["mouse", "raymarch", "sdf", "tiling", "ghosts"], "likes": 14, "viewed": 400, "published": 3, "date": "1618690464", "time_retrieved": "2024-07-30T19:25:31.095612", "image_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define STEPS 128.0\n#define MDIST 300.0\n#define pi 3.141592\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\nfloat ball(vec3 p, float r){ return length(p)-r; }\n\nfloat cyl(vec3 p, float r){\n    return length(p.xz)-r;\n}\n\nfloat box(vec3 p, vec3 s) {\n    p=abs(p)-s;\n    return max(p.x, max(p.y,p.z));\n}\n\nvec3 gl = vec3(0);\n\nvec2 Dist1(vec3 p,float t){\n    vec3 np = p;\n    np.xz*=rot(t);\n    np.y +=sin(t)*15.5+15.0;\n    vec2 a = vec2(ball(np,1.5),0.0);\n    a.x = min(max(max(cyl(p,1.5),np.y-0.1),-np.y-1.5),a.x);\n    \n    float eye = ball(abs(np-vec3(1.3,0,0.))-vec3(0.,0,0.4),0.4);\n    a.x = min(eye,a.x);\n    \n    np.xz*=rot(t*2.0);\n    np.xz = abs(np.xz);\n    np.xz*=rot(pi/6.0);\n    np.xz = abs(np.xz);\n    np.xz*=rot(pi/6.0);\n    \n    float feet = ball(np-vec3(0,-2.1,1.5),0.9);\n    \n    a.x = SU(feet,a.x,0.2);\n    \n    a.x =max(-p.y-3.5,a.x);\n    gl+= 0.01/(0.1+abs(a.x))*vec3(0.682,0.843,0.882);\n    a.x =max(-p.y-2.5,a.x);\n\n    vec2 b = vec2(box(p-vec3(0,-3.5,0),vec3(3.0,1.0,3.0)),1.0);\n    \n    b = (b.x<a.x)?b:a;\n\n    b.x*=0.4;\n    return b;\n}\nvec2 Dist2(vec3 p){\n    vec3 np = p;\n    float t = iTime;\n    np.xz= abs(np.xz)-vec2(6);\n    np.xz= abs(np.xz)-vec2(3);\n    vec2 id = floor(p.xz/6.0);            \n    t+=hash12(id*0.5)*200.0; \n    vec2 c = Dist1(np,t);\n    \n    t = iTime;\n    np = p;\n    \n    float hx = 22.0;\n    float hz = 26.0;\n    np.x-=-hx*0.5+(iMouse.x/iResolution.x)*hx;\n    np.z-=-hz*0.5+(iMouse.y/iResolution.y)*hz;\n    np-=vec3(0,0,-20);\n    np.zy*=rot(-abs(sin(t*5.0))*0.5);\n    \n    vec2 a = vec2(0.6*cyl(np-vec3(0,0,18),2.0),2.0);\n    a.x = max(a.x,-np.y-3.0);\n    a.x = max(a.x,np.y-3.0);\n    \n    np.zy*=rot(pi/2.0);\n    \n    vec2 b = vec2(cyl(np,1.0),3.0);\n    b.x = max(b.x,-np.y);\n    b.x = max(b.x,np.y+-18.0);\n    a = (b.x<a.x)?b:a;\n    a.x*=0.7;\n    \n    a = (c.x<a.x&&a.x>0.0)?c:a;\n    return a;\n}\nvec3 march(vec3 ro, vec3 rd){\n    vec3 p = ro;\n    float i = 0.0;\n    float t = 0.0;\n    vec2 d=vec2(0);\n    float shad = 0.0;\n    for(i;i<STEPS; i++) {\n        d=abs(Dist2(p));\n        \n        if(d.x<.001) {\n            if(d.y!=0.0)break;\n            d.x=0.1;\n        }\n        if(t>MDIST){\n            d.y = 0.0;\n            i=0.0;\n            break;\n        }\n        t+=d.x;\n        p+=rd*d.x;\n    }    \n    return vec3(t, d.y, i);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime*0.4;\n\n    float cir = 18.0;\n    \n    vec3 ro = vec3(0,19.0+sin(t)*4.0,-25); \n    \n    \n    //Uncomment this line for camera spin\n    //ro = vec3(cir*sin(t),7.0+sin(t)*3.0,cir*cos(t));\n    \n    vec3 look = vec3(0,0,0);\n\n    float z = 1.0;\n    vec3 f = normalize(look-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*z+uv.x*r+uv.y*cross(f,r);\n    \n    vec3 obj = march(ro,rd);\n    \n    float shad = obj.z/STEPS;\n    \n    vec3 col = vec3(shad);\n    \n    if(obj.y == 1.0) {\n        col = vec3(1.1-shad);\n        col*=vec3(0.525,0.004,0.694);\n    }\n    else if(obj.y == 2.0) {\n        col = vec3(1.1-shad);\n        col*=vec3(0.196,0.196,0.196);\n        }\n    else if(obj.y == 3.0) {\n        col = vec3(0.8-shad);\n        col*=vec3(1.000,0.737,0.251);\n    }\n    else{\n    col = vec3(0.000,0.047,0.459)*0.4;\n    }\n    col+=min(gl*0.25,1.0);//Transparent effect from NuSan\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 133, 133, 250], [252, 252, 293, 293, 393], [394, 394, 422, 422, 444], [446, 446, 473, 473, 502], [504, 504, 531, 531, 584], [606, 606, 633, 633, 1338], [1339, 1339, 1358, 1358, 2125], [2126, 2126, 2155, 2155, 2564], [2565, 2565, 2622, 2622, 3618]], "test": "untested"}
{"id": "NsXXWM", "name": "315_Aiteyev_v0v1", "author": "logiteg00", "description": "my second task", "tags": ["mashgraph"], "likes": 0, "viewed": 259, "published": 3, "date": "1618687525", "time_retrieved": "2024-07-30T19:25:32.045073", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, screenUV) / float(iFrame + 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//MATH CONSTANTS\nconst float INF  = 1e10;\nconst int rayMachingTimes = 10;\n\n// CAMERA SETTINGS (5.0, 2.0, -2.7)\nconst float camera_x = 1.0;\nconst float camera_y =  2.4;\nconst float camera_z = -6.0;\n\nconst vec3  CAMERA_POS   = vec3 (camera_x, camera_y, camera_z);\n\n// SPHERE\nconst float SPHERE_R = 1.0;\n\n// TABLE\nconst float TABLE_RADIUS = 6.0;\nconst float tableTextureScale = 0.1;\n\n// FIRST LIGHT SOURCE\nconst vec3  LIGHT1_POS        = vec3 (-1.5, 0.7, 3.0);\nconst float LIGHT1_RADIUS     = 0.2;\nconst vec3  LIGHT1_COLOR      = vec3 (0.0, 1.0, 1.0);\nconst float LIGHT1_BRIGHTNESS = 10.0f;\n\n// SECOND LIGHT SOURCE\nconst vec3  LIGHT2_POS        = vec3 (1.5, 0.9, -1.0);\nconst float LIGHT2_RADIUS     = 0.2;\nconst vec3  LIGHT2_COLOR      = vec3 (1.0, 0.5, 0.5);\nconst float LIGHT2_BRIGHTNESS = 5.0f;\n\n// CUBEMAP\nconst float CUBEMAP_BRIGHTNESS = 0.35;\n\n// OCTAHEDRON\nconst float octahedronScale = 1.0;\nconst vec3 octahedronShift = vec3(2.0, -0.2, 0.0);\n\n// MATERALS\nconst int EMISSION = 0;// majorly it's material of the light source. it's spreading light from itself\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\n// REFRACTION\nconst float GLASS_N = 1.5;\nconst float OCTA_N = 1.50;\nconst float AIR_N = 1.0;\n\n// RANDOM\nvec3 randVals;\nvec3 randDir;\n\n\n\n\n\n// math functions\nfloat pow2(float x) \n{\n    return x * x;\n}\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\n// f(x,y,z) = 0  functions\n            //float r = 0.2;\n            //float k = 20.0;\nfloat f(vec3 v, float r, float k)\n{\n    return pow2(v.x) + pow2(v.y) + pow2(v.z)\n    - r*r - sin(k*v.x)*sin(k*v.y)*sin(k*v.z);\n}\nfloat dxf(vec3 v, float r, float k)\n{\n    return 2.0*v.x - k*cos(k*v.x)*sin(k*v.x)*sin(k*v.x);\n}\nfloat dyf(vec3 v, float r, float k)\n{\n    return 2.0*v.y - k*cos(k*v.y)*sin(k*v.y)*sin(k*v.y);\n}\nfloat dzf(vec3 v, float r, float k)\n{\n    return 2.0*v.z - k*cos(k*v.z)*sin(k*v.z)*sin(k*v.z);\n}\n\n// trace functions\nfloat traceSphere(vec3 pos, vec3 dir, float R, out vec3 normal) \n{\n    // abs(pos + t * dir) = r\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t = r * r\n    // D = 4 * dot(pos, dir) ^ 2 - 4 * (dot(pos, pos) - r * r)\n    float b = dot(pos, dir);\n    float D = b * b - (dot(pos, pos) - R * R);\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D));\n    if (t < 0.0)\n        t = (-b + sqrt(D));\n    if (t < 0.0)\n        return INF;\n    vec3 wPos = pos + t * dir;\n    normal = normalize(wPos);\n    return t;\n}\nfloat traceCylinder(vec3 pos, vec3 dir, inout vec3 normal) \n{\n    const float R = 1.0f;\n    const float H = 0.1f;\n    float floorT = (-1.0 - pos.y) / dir.y;\n    if (floorT < 0.0)\n        return INF;\n    vec3 finalPos = pos + dir * floorT;\n    if (dot(finalPos.xz, finalPos.xz) < R * R) {\n        normal = vec3(0, 1, 0);\n        return floorT;\n    }\n    \n    float b = dot(pos.xz, dir.xz);\n    float a = dot(dir.xz, dir.xz);\n    float D = b * b - (dot(pos.xz, pos.xz) - R * R) * a;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b - sqrt(D)) / a;\n    if (pos.y + t * dir.y < -1.0) {\n        vec3 wPos = pos + t * dir;\n        normal = normalize(vec3(wPos.x, 0, wPos.z));\n        return t;\n    }\n    \n    return INF;\n}\nfloat traceFunction(vec3 pos, vec3 dir, out vec3 normal, float r, float k)\n{\n    float dt = 0.1;\n    int times = 50;\n    \n    vec3 v = pos;\n    \n    for (int i = 0; i < times; i++)\n    {\n        \n        if( f(v,r,k) <= 0.0 ){\n            normal = vec3 (dxf(v,r,k), dyf(v,r,k), dzf(v,r,k));\n            return float(i)*dt;\n        }\n        else\n        {\n            v += (dt)*dir;\n            //t += dt;\n            \n        }\n    }\n    return INF;\n\n}\nfloat tracePolygon(vec3 pos, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out vec3 normal)\n{\n    // Polygon interception with v = pos + t*dir\n    // \n    // Read more about method here: \n    // http://masters.donntu.org/2015/frt/yablokov/library/transl.htm\n    // result = (t, u, v) \n    \n    vec3 result;\n    \n    vec3 T  = pos - v0;\n    vec3 E1 = v1  - v0;\n    vec3 E2 = v2  - v0;\n    \n    vec3 P  = cross(dir, E2);\n    vec3 Q  = cross(T,   E1);\n    \n    \n    float det = dot(P, E1);\n    \n    float t = dot(Q, E2) / det;\n    float u = dot(P, T)  / det;\n    float v = dot(Q, dir) /det ;\n    \n    \n    float A = (v1.y-v0.y)*(v2.z-v0.z) - (v2.y-v0.y)*(v1.z-v0.z);\n    float B = (v1.z-v0.z)*(v2.x-v0.x) - (v2.z-v0.z)*(v1.x-v0.x);\n    float C = (v1.x-v0.x)*(v2.y-v0.y) - (v2.x-v0.x)*(v1.y-v0.y);\n    \n    normal.x = A;\n    normal.y = B;\n    normal.z = C;\n    \n    normal = normalize(normal);\n    \n    if( u >= 0.0 && v >= 0.0 && u + v <= 1.0 && t > 0.0)\n        return t;\n    \n    return INF;\n}\nfloat traceTriangle(vec3 pos, vec3 dir, vec3 scale, vec3 shift, out vec3 normal)\n{\n    // triagle equation \n    // v * scale == 1 + shift * scale\n    \n    // v = (x,y,z)\n    // scale = (1/a, 1/b, 1/c)\n    // shift = (dx,  dy,  dz)\n    \n    \n    // (x,y,z) * scale == 1 + shift * scale\n    // x/a + y/b + z/c == 1 + dx/a + dy/b + dz/c\n    \n    // because v = pos + t*dir\n    \n    // t*(dir, scale) + (pos, scale) = 1 + (shift, scale)\n    \n    \n    // t = ( 1 + (shift, scale) - (pos, scale)  ) / (dir,scale)\n    \n    \n    float a = 1.0 /scale.x; // length from dx to a + dx\n    float b = 1.0 /scale.y; // length from dy to b + dy\n    float c = 1.0 /scale.z; // length from dz to c + dz\n    \n    \n    //if(scale.x == 0.0 || scale.y == 0.0 || scale.z == 0.0)\n        //return INF;\n    \n    \n    \n\n    \n    \n    \n    \n    float dx = shift.x;\n    float dy = shift.y;\n    float dz = shift.z;\n    \n    \n    float x_min = min(dx, a + dx);\n    float x_max = max(dx, a + dx);\n    \n    float y_min = min(dy, b + dy);\n    float y_max = max(dy, b + dy);\n    \n    float z_min = min(dz, c + dz);\n    float z_max = max(dz, c + dz);\n    \n    \n    // Calculate distance and coord on triangle\n    float t = (1.0 + dot(shift,scale) - dot(pos, scale) ) / dot(dir, scale);\n    if (t <= 0.0)\n        return INF;\n    \n    vec3 coord = pos + t*dir;\n    \n    \n    // Calculate normal to   x/a + y/b + z/c = 1\n    normal = normalize(scale);\n    //normal = normalize(vec3 (0,0,0));\n    \n    // if trace intercept with triagle \n    // coord.x in [x_min, x_max] equal to x_min < coord.x && coord.x < x_max\n    // coord.y in [y_min, y_max] equal to y_min < coord.y && coord.y < y_max\n    // coord.z in [z_min, z_max] equal to z_min < coord.z && coord.z < z_max\n    if( x_min <= coord.x && coord.x <= x_max   &&   y_min <= coord.y && coord.y <= y_max   &&   z_min <= coord.z && coord.z <= z_max)\n        return t;\n    else \n        return INF;\n}\nfloat traceOctahedron(vec3 pos, vec3 dir, float size, vec3 shift, out vec3 normal)\n{\n    // see function traceTriagle to see more information about \"scale\" parametr\n    float scaleOcta = 1.0/ size;\n    \n    int minIndex = 0;// index of intercepted triagle (from 0 to 7)\n    \n    vec3 normal1;\n    vec3 normal2; \n    vec3 normal3; \n    vec3 normal4; \n    vec3 normal5; \n    vec3 normal6; \n    vec3 normal7; \n    vec3 normal8; \n    \n    \n    \n    ///*\n    vec3 v1 = vec3(shift.x - scaleOcta, shift.y             , shift.z);\n    vec3 v2 = vec3(shift.x            , shift.y - scaleOcta , shift.z);\n    vec3 v3 = vec3(shift.x+scaleOcta  , shift.y             , shift.z);\n    vec3 v4 = vec3(shift.x            , shift.y+scaleOcta   , shift.z);\n    vec3 v5 = vec3(shift.x            , shift.y             , shift.z+scaleOcta);\n    vec3 v6 = vec3(shift.x            , shift.y             , shift.z-scaleOcta);\n    \n    \n    float T1 = tracePolygon (pos, dir, v1, v2, v5, normal1);\n    float T2 = tracePolygon (pos, dir, v2, v3, v5, normal2);\n    float T3 = tracePolygon (pos, dir, v3, v4, v5, normal3);\n    float T4 = tracePolygon (pos, dir, v4, v1, v5, normal4);\n    float T5 = tracePolygon (pos, dir, v1, v2, v6, normal5);\n    float T6 = tracePolygon (pos, dir, v2, v3, v6, normal6);\n    float T7 = tracePolygon (pos, dir, v3, v4, v6, normal7);\n    float T8 = tracePolygon (pos, dir, v4, v1, v6, normal8);\n    //*/\n    /*\n    float T1 = traceTriangle (pos, dir, vec3(scaleOcta, scaleOcta, scaleOcta), shift , normal1);\n    float T2 = traceTriangle (pos, dir, vec3(-scaleOcta, scaleOcta, scaleOcta), shift , normal2);\n    float T3 = traceTriangle (pos, dir, vec3(scaleOcta, -scaleOcta, scaleOcta), shift , normal3);\n    float T4 = traceTriangle (pos, dir, vec3(-scaleOcta, -scaleOcta, scaleOcta), shift , normal4);\n    float T5 = traceTriangle (pos, dir, vec3(scaleOcta, scaleOcta, -scaleOcta), shift , normal5);\n    float T6 = traceTriangle (pos, dir, vec3(-scaleOcta, scaleOcta, -scaleOcta), shift , normal6);\n    float T7 = traceTriangle (pos, dir, vec3(scaleOcta, -scaleOcta, -scaleOcta), shift , normal7);\n    float T8 = traceTriangle (pos, dir, vec3(-scaleOcta, -scaleOcta, -scaleOcta), shift , normal8);\n    */\n    \n    \n    //find min of all this triagles and minIndex\n    vec3[]  arrayN = vec3[] ( normal1,normal2,normal3,normal4,normal5,normal6,normal7,normal8 );\n    float[] arrayD = float[](   T1,     T2,     T3,     T4,     T5,     T6,     T7,     T8    );\n \n \n    float minT = arrayD[0];\n    \n    for (int i = 1; i < 8; i++)\n \n        if (minT > arrayD[i])\n        {\n            minT = arrayD[i];\n            minIndex = i;\n        }\n    \n    \n    \n    \n    // Output values\n    normal = arrayN[minIndex];\n    return arrayD[minIndex];\n    \n    \n    \n    \n    // old version \n    //return min(min(min(min(min(min(min(T1,T2),T3),T4),T5),T6),T7),T8);\n}\nfloat tracePlane (vec3 pos, vec3 dir, out vec3 normal )\n{\n    // Create a table. \n    // Table is a plane y = -1 with restriction x^2 + z^2 < TABLE_RADIUS^2. \n    // Texture of table is iChannel0.\n    \n    \n    // (pos + t*dir).y == -1.0\n    float t = (-1.2 - pos.y)/dir.y;// distance between table (y = -1) and viewVec.\n    \n    \n    \n    // t(distance) must be positive only!\n    if (t <= 0.0)\n    {\n        return INF;\n    }\n    \n    \n    normal = vec3(0,1,0);\n    \n    // trace intercept with plane y = -1\n    if(t > 0.0){\n        vec3 worldPos = t*dir + pos;//restoring world position of table coordinates\n        \n        \n        // if x^2 + z^2 >= TABLE_RADIUS^2 (not intercept with table). \n        if(dot(worldPos.xz, worldPos.xz) >= TABLE_RADIUS*TABLE_RADIUS)\n            return INF;\n           \n           \n        // trace intercepted with table.\n        return t;\n            \n    }\n    \n    \n    \n}\n\n\n\n// shadow\nbool isOccluded(vec3 pos, vec3 target) \n{\n    vec3 rvec = target - pos;\n    float dist = length(rvec);\n    vec3 dir = rvec / dist;\n    \n    vec3 normal = vec3(0, 0, 0);\n    \n    \n    vec3 functionNormal;\n    vec3 functionShift = vec3( -1.25,1.5,-1.2 );\n    float functionT = traceFunction(pos-functionShift, dir, functionNormal, 0.7, 50.0);\n    \n    if(functionT < dist)\n        return true;\n    \n    \n    vec3 octahedronNormal;\n    float octahedronT = traceOctahedron(pos, dir, octahedronScale, octahedronShift, octahedronNormal);\n    \n    if(octahedronT < dist)\n        return true;\n    \n    \n    \n    \n    float t = traceSphere(pos, dir, SPHERE_R, normal);\n    if (dist >= t) {\n        return true;\n    }\n    \n    \n    \n    \n    vec3 cylNormal = normal;\n    t = traceCylinder(pos, dir, cylNormal);\n    return (t > 0.0 && dist >= t);\n}\n// refraction\nvec3 refraction(vec3 v_in, vec3 normal, float n1, float n2) \n{\n    if (dot(v_in, normal) < 0.0)\n        normal = -normal;\n    float cosA = dot(v_in, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v_in - cosA * normal);\n    float sinB = n1 * sinA / n2;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return tang * sinB + normal * cosB;\n}\n// light\nvec3 computeLighting(vec3 worldPos, vec3 color, vec3 normal, vec3 viewVec) {\n    vec3 lightPos = LIGHT1_POS + randDir * LIGHT1_RADIUS;\n    vec3 toLight = lightPos - worldPos;\n    bool occl = isOccluded(worldPos + normalize(toLight) * 1e-3, lightPos);\n    float lightAtten = 20.0f / dot(toLight, toLight) * (occl ? 0.0 : 1.0);\n\n    vec3 light2Pos = LIGHT2_POS + randDir * LIGHT2_RADIUS;\n    vec3 toLight2 = light2Pos - worldPos;\n    bool occl2 = isOccluded(worldPos + normalize(toLight2) * 1e-3, light2Pos);\n    float light2Atten = 10.0f / dot(toLight2, toLight2) * (occl2 ? 0.0 : 1.0);\n\n    return color * (\n        max(0.0f, dot(normal, normalize(toLight))) * lightAtten * LIGHT1_COLOR\n        + max(0.0f, dot(normal, normalize(toLight2))) * light2Atten * LIGHT2_COLOR\n        + texture(iChannel0, viewVec, 10.0).rgb * CUBEMAP_BRIGHTNESS\n    ).rgb;\n}\n\n\n\n// rainbow fog\nfloat difcolor(float h,float h0, float h1, float x0, float x1)\n{\n    return (x1-x0)/(h1-h0)*h + (x0*h1 - h0 * x1)/(h1-h0);\n    //return (h1-h0)/(x1-x0)*(h-x0)  +  h0;\n}\nfloat fogSdf(vec3 pos)\n{\n    return length(pos) - 0.75;\n}\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\nvec4 sampleFog(vec3 pos, vec3 dir)\n{\n    float t = fogSdf(pos);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float absorption = 10.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fogSdf(curPos);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(absorption * (\n            texture(iChannel3, curPos * 0.2).x\n            + texture(iChannel3, curPos * 0.4).x\n            + texture(iChannel3, curPos * 0.8).x\n            + texture(iChannel3, curPos * 1.6).x\n            ) * 0.25 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    \n    vec3 color;\n    vec3 v = pos + t*dir;\n    float h = v.y;\n    \n    \n    float h0;\n    float h1;\n    float x0;\n    float x1;\n    \n    \n    float level1 =  0.9;\n    float level2 =  0.4;\n    float level3 =  0.2;\n    float level4 = -0.2;\n    float level5 = -0.4;\n    float level6 = -0.9;\n    \n    float outputColor;\n    \n    \n    \n    \n    if( level2 < h && h <= level1 )\n    {\n        h0 = level1;\n        h1 = level2;\n        \n        x0 = 0.0;\n        x1 = 1.0;\n        \n        outputColor = difcolor(h, h0, h1, x0, x1);\n        //outputColor = 0.0;\n        \n        color = vec3( 1.0, outputColor, 0.0) * totalAbs;\n    }\n    if( level3 < h && h <= level2 )\n    {\n        h0 = level2;\n        h1 = level3;\n        \n        x0 = 1.0;\n        x1 = 0.0;\n        \n        \n        outputColor = difcolor(h, h0, h1, x0, x1);\n        //outputColor = 0.0;\n        \n        \n        color = vec3( outputColor, 1.0, 0.0 ) * totalAbs;\n    }\n    if( level4 < h && h <= level3 )\n    {\n        h0 = level3;\n        h1 = level4;\n        \n        x0 = 0.0;\n        x1 = 1.0;\n    \n    \n        outputColor = difcolor(h, h0, h1, x0, x1);\n        //outputColor = 0.0;\n    \n    \n        color = vec3( 0.0, 1.0, outputColor ) * totalAbs;\n    }\n    if( level5 < h && h <= level4 )\n    {\n        h0 = level4;\n        h1 = level5;\n        \n        x0 = 1.0;\n        x1 = 0.0;\n    \n    \n        outputColor = difcolor(h, h0, h1, x0, x1);\n        //outputColor = 0.0;\n    \n    \n        color = vec3( 0.0, outputColor, 1.0 ) * totalAbs;\n    }\n    if( level6 <= h && h <= level5 )\n    {\n        h0 = level5;\n        h1 = level6;\n        \n        x0 = 0.0;\n        x1 = 1.0;\n    \n    \n        outputColor = difcolor(h, h0, h1, x0, x1);\n        //outputColor = 0.0;\n    \n    \n        color = vec3( outputColor, 0.0, 1.0 ) * totalAbs;\n    }\n    \n    \n    \n    \n    \n    return vec4(color * 5.0, 1.0 - opacity);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // random numbers\n    randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals);\n    \n    \n    // Anti-aliasing for better image. AA from -1 to 1\n    vec2 AA = (randVals.xy - 0.5 ) * 2.0;\n\n\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - iResolution.xy/2.0 + AA)/iResolution.x;\n\n\n    // Vectors forward up and right helps to create viewVec\n    vec3 forward = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n\n\n    // viewVec \n    vec3 viewVec = normalize(forward + uv.x * right + uv.y * up);\n\n\n    // refraction\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float curN = 1.0;\n    float nextN = GLASS_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float GLASS_T = 1.0 - GLASS_R;\n\n\n    // Current camera position\n    vec3 currentPos = CAMERA_POS;\n    \n\n    // properties\n    int iterationType;\n    vec3 color;\n    vec3 normal;\n    float mult = 1.0;\n\n\n\n\n\n\n    // do Ray-Marching few times\n    for (int i = 0; i < rayMachingTimes; ++i) {\n        \n        \n        // if planeT will equal to distance to table then t = planeT, otherwise t = infinity.\n        float t = INF;\n    \n    \n        // Light 1\n        {\n            t = traceSphere(currentPos - LIGHT1_POS, viewVec, LIGHT1_RADIUS, normal);\n            if (t != INF) {\n                color = LIGHT1_COLOR.rgb * 5.0;\n                iterationType = EMISSION;\n            }\n        }\n        \n        \n        // Light 2\n        {\n            float l2_t = traceSphere(currentPos - LIGHT2_POS, viewVec, LIGHT2_RADIUS, normal);\n            if (t > l2_t) {\n                t = l2_t;\n                color = LIGHT2_COLOR.rgb;\n                iterationType = EMISSION;\n            }\n        }\n        \n        \n        // Sphere with fog\n        {\n            float sphere_t = traceSphere(currentPos, viewVec, SPHERE_R, normal);\n            if (sphere_t < t) {\n                if (GLASS_R > randVals.y) {\n                    iterationType = REFLECTION;\n                } else {\n                    iterationType = REFRACTION;\n                }\n                t = sphere_t;\n            }\n        }\n        \n        \n        // Cylinder\n        {\n            vec3 cylNormal = normal;\n            float cylT = traceCylinder(currentPos, viewVec, cylNormal);\n            if (cylT < t) {\n                t = cylT;\n                vec3 pos = currentPos + t * viewVec;\n                color = texture(iChannel1, pos.xz * pos.y).rgb;\n                normal = cylNormal;\n                iterationType = DIFFUSE;\n            }\n        }\n        \n        \n        // Table\n        {\n            vec3 tableNormal;\n\n            float planeT = tracePlane(currentPos, viewVec, tableNormal);\n            // If trace is intercept with plane then make t shorter and equal to distance between camera and table.\n            if (planeT < t)\n            {\n                t = planeT;\n                vec3 worldPos = t*viewVec + currentPos;//restoring world position of table coordinates\n                color = texture (iChannel2, worldPos.xz * tableTextureScale).rgb;\n                normal = tableNormal;\n                iterationType = DIFFUSE;\n\n                // for make floor reflaction\n                if(randVals.y < 0.3)\n                    iterationType = REFLECTION;\n\n            }\n        }\n        \n        \n        // Octahedron\n        {\n            vec3 octahedronNormal;\n\n            float octahedronT  = traceOctahedron(currentPos, viewVec, octahedronScale, octahedronShift, octahedronNormal);\n            // If trace is intercept with octahedron then make t shorter and equal to distance between camera and table.\n            if (octahedronT < t)\n            {\n                t = octahedronT;\n                color = vec3(0.0,0.0,1.0);\n                normal = octahedronNormal;\n\n                //combine reflection and refraction;\n                if(randVals.x*0.01 < GLASS_R)\n                    iterationType = REFLECTION;\n\n                else{\n                    iterationType = REFRACTION;\n                    // We need to know what is outside the object \n                    if( dot(viewVec, normal) > 0.0 )// they not oppodite directed\n                    {\n                        nextN = AIR_N;\n                    }\n                    else // they opposite directed \n                    {\n                        nextN = GLASS_N;\n\n                    }\n\n                }\n                //materialType = REFRACTION;\n\n            }\n        }\n\n\n        // Triangle (mirror)\n        {\n            vec3 triangleNormal;\n            vec3 triangleScale = vec3(0.3, 0.1, 0.5);;\n            vec3 triangleShift = vec3(-0.0, -0.5, 1.0);\n\n            float triangleT  = traceTriangle(currentPos, viewVec, triangleScale, triangleShift, triangleNormal);\n            // If trace is intercept with Triagle then make t shorter and equal to distance between camera and table.\n            if (triangleT < t)\n            {\n                t = triangleT;\n                iterationType = REFLECTION;\n\n                normal = triangleNormal;\n            }\n        }\n        \n        //Function 1\n        {\n            vec3 functionNormal;\n            \n            vec3 functionShift = vec3( -1.35,1.5,-1.2 );\n            float functionT = traceFunction(currentPos-functionShift, viewVec, functionNormal, 0.7, 50.0);\n            // If trace is intercept with function then make t shorter and equal to distance between camera and table.\n            if (functionT < t)\n            {\n                t = functionT;\n                //vec3 worldPos = t*viewVec + currentPos;//restoring world position of table coordinates\n\n                iterationType = DIFFUSE;\n                color = vec3(0.2,0.1,0.5);\n                normal = functionNormal;\n            }\n            \n        }\n        \n        \n        \n        // DRAW OBJECT\n        if (t != INF) \n        {\n        \n        \n            // EMISSION\n            if (iterationType == EMISSION) {\n                fragColor.rgb = color;\n                break;\n            } \n            \n            \n            // DIFFUSE\n            else if (iterationType == DIFFUSE) {\n                fragColor.rgb += mult * computeLighting(currentPos + t * viewVec, color, normal, viewVec);\n                break;\n            } \n            \n            \n            // REFLECTION\n            else if (iterationType == REFLECTION) {\n                currentPos += viewVec * t;\n                fragColor.rgb += mult * computeLighting(currentPos + t * viewVec, color, normal, viewVec);\n                viewVec = reflect(viewVec, normal);\n                currentPos += viewVec * 1e-5;\n            } \n            \n            \n            // REFRACTION\n            else if (iterationType == REFRACTION) {\n            \n                // do refraction\n                currentPos += viewVec * t;\n                viewVec = refraction(viewVec, normal, curN, nextN);\n                currentPos += viewVec * 1e-5;\n                \n                // fog\n                vec4 fog = sampleFog(currentPos, viewVec);\n                fragColor.rgb += fog.rgb * fog.a * mult;\n                mult *= 1.0 - fog.a;\n                \n                //change N\n                float tmp = curN;\n                curN = nextN;\n                nextN = tmp;\n                \n            }\n            \n            \n        } \n        // DRAW BACKGROUND\n        else \n        {\n            fragColor += mult * texture(iChannel0, viewVec) * 0.3;\n            break;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, screenUV) + texture(iChannel1, screenUV);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 171]], "test": "untested"}
{"id": "sdsXWN", "name": "Distance to Tractrix Star", "author": "oneshade", "description": "Distance to a tractrix curve.", "tags": ["2d", "sdf", "distance", "cubic", "tractrix"], "likes": 7, "viewed": 257, "published": 3, "date": "1618682428", "time_retrieved": "2024-07-30T19:25:32.816012", "image_code": "// Check @iq's comment for a generalized version\nfloat sdTractrix(in vec2 p) {\n    p = abs(p);\n    if (p.y > p.x) p = p.yx;\n    if (p.x > 1.0) return length(vec2(p.x - 1.0, p.y));\n\n    float c = 3.0 - p.x - p.y;\n    vec2 pq = vec2(c, 0.5 * c + p.y) * 0.5 - 0.75;\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x), v1 = 1.5 / pq.x * pq.y, root, dist;\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(v2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(v2) / 3.0);\n        root = -2.0 * sqrt(p2 / 3.0) * root + 0.5;\n    }\n\n    else root = 2.0 * sqrt(-pq.x / 3.0) * cos(acos(v1 * sqrt(-3.0 / pq.x)) / 3.0) + 0.5;\n    vec2 cp = vec2(root, 1.0 - root);\n    float s = 1.0 - sqrt(p.x);\n\n    return length(p - cp * cp) * sign(p.y - s * s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.5;\n\n    float d = sdTractrix(uv);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 78, 78, 854], [856, 856, 911, 911, 1303]], "test": "untested"}
{"id": "sslSWN", "name": "Sunset at Sea", "author": "shophorn", "description": "The storm has finally faded, and all the monsters are gone too.", "tags": ["landscape"], "likes": 4, "viewed": 339, "published": 3, "date": "1618678736", "time_retrieved": "2024-07-30T19:25:33.591938", "image_code": "// Author: Leo Tamminen leo@leotamminen.fi\n// Title: Sunset at sea\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec3 skyBase            = vec3(0.160,0.706,0.920) * 0.544;\nvec3 waterBase          = vec3(0.162,0.875,0.526);\nvec3 sunDiscColor       = vec3(0.990,0.254,0.005) * 19.016;\nvec3 haloBaseColor      = vec3(1.0,0.236,0.025) * 4.824;\nvec3 haloTopColor       = vec3(0.995,0.857,0.118) * -0.392;\n\nvec2 discPosition       = vec2(0.790,0.150);\nfloat discSize          = 0.03;\nfloat discFeather       = 0.001;\nfloat discIntensity     = 10.;\n\nvec2 haloPosition       = vec2(0.760,0.600);\nfloat haloSize          = 0.536;\nfloat haloFeather       = 0.1;\nfloat haloIntensity     = 2.824;\n\nfloat skyline           = 0.236;\nfloat horizonWidth      = 0.026;\n\nvec2 effectResolution = vec2(20., 10.);\nfloat exposure  = 0.824;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    \n\t\n    \n    float waterSkyFactor    = smoothstep(skyline - horizonWidth, skyline + horizonWidth, st.y);\n    vec3 overlayColor       = mix(waterBase, vec3(1), waterSkyFactor);\n    st.y                    = mix(1.0 - st.y / skyline, (st.y - skyline) / (1.0 - skyline), waterSkyFactor);\n                            \n    \n    float time              = iTime * 0.05;\n    float waveOffset        = pow(1. - st.y, 5.);\n    float waveScale         = 100.;\n    float wave              = sin((time + waveOffset) * waveScale) * st.y;\n\n    st.x                    += (1.0 - waterSkyFactor) * (wave * 0.05);\n\n        \n    /// Sky base colour is gradient up and down from skyline. Overlaycolor will darken the water (lower) part.\n    vec3 skyColor           = mix(skyBase, pow(skyBase, vec3(3.0)), st.y) * overlayColor;\n    vec3 horizonColor       = vec3(1.0 - abs(waterSkyFactor * 2.0 - 1.0)) * 0.5;\n    \n    /// SUN COLOR ----------------------------\n    float discDistance      = distance(discPosition, st);\n    float discGradient      = 1.0 - smoothstep(discSize - discFeather, discSize + discFeather, discDistance);\n\n    float shapeGradient     = 1.0 - smoothstep(haloSize - haloFeather, haloSize + haloFeather, distance(haloPosition, st));\n\n    float colorGradient     = smoothstep(0.0, 1.0, (st.y - haloPosition.y + haloSize) / (haloSize * 2.0));\n    vec3 haloColor          = mix(haloBaseColor, haloTopColor, colorGradient);\n\n    vec2 haloFalloffPoint   = haloPosition - normalize(haloPosition - discPosition) * haloSize;\n    float haloFalloff       = pow(1.0 - clamp(distance(st, haloFalloffPoint) / (haloSize * 2.0), 0.0, 1.0), 2.312);\n\n    vec3 sunColor           = sunDiscColor * discGradient * discIntensity\n                            + haloColor * shapeGradient * haloFalloff * haloIntensity;\n    /// --------------------------------------\n    \n    vec3 color  = vec3(0.0);\n    color       += skyColor;    \n    color       += sunColor;\n    color       += horizonColor;\n\n    color           = vec3(1.0) - exp(-color * exposure);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[820, 820, 875, 875, 3028]], "test": "untested"}
{"id": "fslSWN", "name": "Room in a wall", "author": "TimurAB", "description": "fun 3d effect with a little bit of lighting\n\nI tried to achieve parallax effect, but this method is probably to heavy", "tags": ["raymarching", "cube", "parallax", "room"], "likes": 2, "viewed": 316, "published": 3, "date": "1618659108", "time_retrieved": "2024-07-30T19:25:34.356892", "image_code": "#define cube_size 1.0\n\nvec2 getPos (in vec2 fragCoord) {\n    return 2.0 * fragCoord / iResolution.xy - 1.0;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));\n}\n\t\t\nfloat dist (vec3 p) {\n    vec3 cube = vec3(0.0);\n    vec3 plane = vec3(0.0, 0.0, .1-cube_size);\n    vec3 q = abs(p - cube.xyz) - cube_size;\n    float c = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    float pn = plane.z - p.z;\n    return max(-min(1000., c), pn);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 _mouse = 0.5 * iMouse.xy / iResolution.xy - 0.25;\n    vec2 uv = getPos(fragCoord);\n    vec3 cam = vec3(0.0, 0.0, -3.);\n    vec3 pos = vec3(uv, cam.z + 1.0), p;\n    cam.yz *= rotate2d(_mouse.y);\n    pos.yz *= rotate2d(_mouse.y);\n    cam.xz *= rotate2d(_mouse.x);\n    pos.xz *= rotate2d(_mouse.x);\n    vec3 dir = normalize(pos - cam);\n    float d = 0.0, total = 0.0;\n    for(int i = 0; i < 100; i ++) {\n        p = pos + total * dir;\n        d = dist(p);\n        total += d;\n        if (d < 0.01 || total > 100.0) break;\n    }\n    vec3 col = vec3(uv,0.0);\n    if (total < 100.0) {\n        float ax = abs(p.x);\n        float ay = abs(p.y);\n        vec2 l = vec2(0.0);\n        if (ax < cube_size && ay < cube_size) {\n            if (ax > cube_size - 0.01) {\n                l.x = sign(p.x);\n                p.xz *= l.x*rotate2d(1.57);\n            }\n            if (ay > cube_size - 0.01) {\n                l.y = sign(p.y);\n                p.yz *= l.y*rotate2d(1.57);\n            }\n        }\n        col = texture(iChannel0, p.xy).rgb;\n        l = (-l + 1.0) / 2.5 + 0.2;\n        col *= length(l);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 56, 56, 109], [111, 111, 139, 139, 208], [212, 212, 233, 233, 490], [492, 492, 549, 549, 1691]], "test": "untested"}
{"id": "NdXXWH", "name": "Simple volumetrics test", "author": "clepirelli", "description": "Made for the willstall challenge - 1 shader a week keeps the depression meek\n\nUse the mouse to pan around, toying with the constants is also pretty fun!\nSpecial thanks to Nameless on discord for his explanation of beer's law and fixed step marching", "tags": ["3d", "volumetrics"], "likes": 8, "viewed": 495, "published": 3, "date": "1618657742", "time_retrieved": "2024-07-30T19:25:35.124839", "image_code": "const Box box = Box(vec3(-1.), vec3(1.));\nconst DirectionLight sun = DirectionLight(normalize(vec3(1.0)), vec3(.98, .48, .38));\n#define time (iTime+30.0)\nfloat getCameraAngle()\n{\n    if(useMouse)\n        return startingCameraAngle + 9.0*iMouse.x/iResolution.x;\n    else \n        return iTime*.1;\n}\nRay getHitRay(vec2 uv)\n{\n    const vec3 cameraPosition = vec3(cameraDistance, cameraHeight, cameraDistance);\n    \n    float angle = getCameraAngle();\n    vec3 pos = cameraPosition;\n    pos.x *= sin(angle);\n    pos.z *= cos(angle);\n    //camera calculations\n    vec3 target = vec3(.0);\n    vec3 rayOrigin = target + pos;\n    vec3 front = normalize(target-rayOrigin);\n    vec3 right = normalize(cross(front, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, front));\n    vec3 rayDir = normalize(uv.x*right+uv.y*up+1.0*front);\n    \t\n    return Ray(rayOrigin, rayDir);\n}\n\nvec3 sky(vec3 direction)\n{\n    return vec3(.2,.4,.9)-vec3(.4,.4,.9)*direction.y;\n}\n\nfloat calculateLightDensity(vec3 point)\n{\n    float result = .0;\n    \n    vec3 samplePoint = point;\n    vec3 fixedStep = sun.direction * lightStepSize;\n    \n    for(int i = 0; i < lightMaxSteps; i++)\n    {\n        result += sampleCloud(samplePoint, time);\n        \n        samplePoint += fixedStep;\n        \n        if(!insideBox(box, samplePoint))\n        {\n            break;\n        }\n    }\n    return result;\n}\n\nfloat sampleBlueNoise(vec2 uv)\n{\n    return texture(iChannel0, uv)[int(mod(float(iFrame), 3.0))];\n}\n\nvec3 Image(vec2 uv)\n{\n    Ray hitRay = getHitRay(uv);\n    float distanceToBox = boxIntersection(hitRay, box);\n    \n    if(insideBox(box, hitRay.origin) || distanceToBox > .0)\n    {\n        float blueNoiseOffset = sampleBlueNoise(uv)*cloudStepSize;\n        vec3 samplePoint = pointAt(hitRay, distanceToBox+blueNoiseOffset);\n        vec3 fixedStep = hitRay.direction * cloudStepSize;\n        \n        float transmittance = 1.0;\n        vec3 lightEnergy = vec3(.0);\n        for(int i = 0; i < cloudMaxSteps; i++)\n        {\n            float density = sampleCloud(samplePoint, time);\n            if(density > notDenseEnough)\n            {\n               transmittance *= 1.-density;\n               \n               float lightDensity = calculateLightDensity(samplePoint);\n               float beer = exp(-lightDensity*densityMultiplier)*density*transmittance;\n               float powder = 1.0-beer;\n               lightEnergy += beer*powder*sun.color;\n            }\n            samplePoint += fixedStep;\n            if(!insideBox(box, samplePoint) || transmittance <= .0001) \n            {\n                break;\n            }\n        }\n        \n        return lightEnergy+transmittance*sky(hitRay.direction);\n    } else \n    {\n        return sky(hitRay.direction);\n    }\n}\n\n\nMAIN_FUNCTION(Image)\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ----- constants ----\nconst int aa = 2;\n\nconst float notDenseEnough = .01;\n\nconst float cloudStepSize = .1;\nconst int cloudMaxSteps = 100;\n\nconst float lightStepSize = .2;\nconst int lightMaxSteps = 10;\n\nconst float densityMultiplier = 1.;\nconst float noiseCutoff = .4;\n\nconst float cameraDistance = 4.6;\nconst float cameraHeight = .0;\n\nconst bool useMouse = false;\nconst float startingCameraAngle = 3.14*.5;\n\n// ----- noise ----\n//all from iq: https://www.shadertoy.com/view/4sfGzS\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(vec3 x)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\nfloat sampleCloud(vec3 point, float time)\n{\n    const mat3 m = mat3( \n                 0.00,  0.80,  0.60,\n                -0.80,  0.36, -0.48,\n                -0.60, -0.48,  0.64 );\n    vec3 q = point+time*.1;\n    float f = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n\treturn max(.0, f-noiseCutoff);\n}\n\n// ----- structs ----\n\nstruct DirectionLight\n{\n    vec3 direction;\n    vec3 color;\n};\n\nstruct Box\n{\n    vec3 minimum;\n    vec3 maximum;\n};\nbool insideBox(Box box, vec3 point)\n{\n    return all(greaterThanEqual(point, box.minimum)) && all(lessThanEqual(point, box.maximum));\n}\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\nvec3 pointAt(Ray ray, float distanceAlong)\n{\n    return ray.origin + ray.direction * distanceAlong;\n}\n\n// ----- intersection -----\n\nfloat boxIntersection(Ray ray, Box box)\n{\n    //from: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\n    bool xSign = ray.direction.x >= 0.;\n    bool ySign = ray.direction.y >= 0.;\n    vec3 inverseDir = 1.0/ray.direction;\n    \n    float nearest = ((xSign ? box.minimum : box.maximum).x - ray.origin.x) * inverseDir.x; \n    float nextNearest = ((xSign ? box.maximum : box.minimum).x - ray.origin.x) * inverseDir.x; \n    float nearestY = ((ySign ? box.minimum : box.maximum).y - ray.origin.y) * inverseDir.y; \n    float nextNearestY = ((ySign ? box.maximum : box.minimum).y - ray.origin.y) * inverseDir.y; \n \n    if (nearest > nextNearestY || nearestY > nextNearest) \n        return -1.0;\n    \n    nearest = max(nearestY, nearest);\n    nextNearest = min(nextNearestY, nextNearest);\n    \n    bool zSign = ray.direction.z >= 0.;\n    float nearestZ = ((zSign ? box.minimum : box.maximum).z - ray.origin.z) * inverseDir.z;\n    float nextNearestZ = ((zSign ? box.maximum : box.minimum).z - ray.origin.z) * inverseDir.z; \n    \n    if ((nearest > nextNearestZ) || (nearestZ > nextNearest)) \n        return -1.0;\n    \n    nearest = max(nearest, nearestZ);\n    nextNearest = min(nextNearestZ, nextNearest);\n    \n    return nearest;\n}\n\n\n// ----- boilerplate -----\n\nvec4 colorCorrect(vec3 color)\n{\n    vec3 x = max(vec3(.0), color-.004);\n    vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n    return vec4(min(retColor, 1.0), 1.0);\n}\n\n#define MAIN_FUNCTION(function) \\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\\n{\\\n    vec3 total = vec3(.0);\\\n    /*MSAA*/\\\n    for(int i = 0; i <aa;i++)\\\n    for(int j = 0; j <aa;j++)\\\n    {\\\n    \t/*offset the uv for MSAA*/\\\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\\\n    \tuv.x *= iResolution.x/iResolution.y;\\\n    \t\\\n        total+= function(uv);\\\n    }\\\n    total /= float(aa*aa);\\\n    \\\n    /*Output to screen*/\\\n    fragColor = colorCorrect(total);\\\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXXWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 178, 178, 297], [298, 298, 322, 322, 869], [871, 871, 897, 897, 953], [955, 955, 996, 996, 1369], [1371, 1371, 1403, 1403, 1470], [1472, 1472, 1493, 1493, 2741]], "test": "untested"}
{"id": "NdsSD4", "name": "fungus", "author": "lomateron", "description": "click to delete\nkey A to apply image\nhere the only difference to this https://www.shadertoy.com/view/sslSR8\npoints dissolve through time\nif black and white meet then they both get bigger", "tags": ["convolution"], "likes": 17, "viewed": 627, "published": 3, "date": "1618654309", "time_retrieved": "2024-07-30T19:25:35.936668", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = a*4.+.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = A(u+vec2(0,0));\n    float b = 0.;\n    \n    //kernel convolution that pointifies\n    {\n        float z = 2.;//kernel convolution size\n        float t = z*2.+1.;\n              t = 1./(t*t-1.);\n        float blur = 1.5/z;\n        for(float i = -z; i<=z;++i){\n        for(float j = -z; j<=z;++j){\n          float s0 = 0.;\n          float s1 = 0.;\n          for(float i2 = -z; i2<=z;++i2){\n          for(float j2 = -z; j2<=z;++j2){\n          vec2 c = vec2(i2,j2)*blur;\n          s0 += max(0.,+A(u+vec2(i,j)+vec2(i2,j2)).x)/exp(dot(c,c));\n          s1 += max(0.,-A(u+vec2(i,j)+vec2(i2,j2)).x)/exp(dot(c,c));\n          }}\n          if(s0==0.)s0 = 1.;\n          if(s1==0.)s1 = 1.;\n          vec2 c = -vec2(i,j)*blur;\n          float d = A(u+vec2(i,j)).x;\n          float e = 1./exp(dot(c,c))*d*(1.-min(abs(d)+.01,1.));\n          b +=(+max(0.,+a.x)/s0\n               +max(0.,-a.x)/s1)*e;\n        }}\n    }\n    //kernel convolution that blurs\n    {\n        float z = 2.;//kernel convolution size\n        float t = z*2.+1.;\n              t = 1./(t*t-1.);\n        float blur = 1.5/z;\n        for(float i = -z; i<=z;++i){\n        for(float j = -z; j<=z;++j){\n          float s = 0.;\n          for(float i2 = -z; i2<=z;++i2){\n          for(float j2 = -z; j2<=z;++j2){\n          vec2 c = vec2(i2,j2)*blur;\n          s += 1./exp(dot(c,c));\n          }}\n          if(s==0.)s = 1.;\n          vec2 c = -vec2(i,j)*blur;\n          float d = A(u+vec2(i,j)).x;\n          b += d/s/exp(dot(c,c))*(min(abs(d)+.0,1.))*1.;\n        }}\n    }\n    a = vec4(b,a.xyz);\n\n    if(iMouse.z>0.)\n    {\n        vec2 m1 = 2.*(u-iMouse.xy)/iResolution.y;\n        a *= 1.-1./exp(dot(m1,m1));\n    }\n    if(iFrame==0)\n    {\n        vec2 m1 = (2.*u-iResolution.xy)/iResolution.y-vec2(-.02,0);\n        vec2 m2 = (2.*u-iResolution.xy)/iResolution.y-vec2(+.02,0);\n        a += +.1/exp(dot(m1,m1)*333.)\n             -.1/exp(dot(m2,m2)*333.);\n    }\n    float keyA  = texture( iChannel1, vec2(65.5/256.,.25) ).x;\n    if(keyA!=0.)a = texture( iChannel2, u/iResolution.xy).xxxx-.6;\n    fragColor = a;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 158]], "test": "untested"}
{"id": "ssXXWN", "name": "Noise balance", "author": "FabriceNeyret2", "description": "mouse.y controls parameter                    SPACE toggles noise / turbulence\n\nleft:  most transition between plates \nright: most transition near peaks", "tags": ["procedural", "noise", "perlin", "isolines"], "likes": 13, "viewed": 462, "published": 3, "date": "1618653536", "time_retrieved": "2024-07-30T19:25:36.700626", "image_code": "#define hash(p ) ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define grad(x,y)  dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n#define Ierf(x) ( atanh(x) / 1.2 )          // not so bad reciprocal\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), u = f*f*(3.-2.*f); // smoothstep\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<4; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\n      // P = 8.*U - vec2(iTime,0);         // also interesting to see pattern morphing\n\t\n\tfloat f = keyToggle(32) ? perlin( P ) : noise( P );\n    float m = iMouse.z > 0. ? 2.*iMouse.x/R.x :  2.*u.x/R.x;\n    \n    f = sign(f)*pow(abs(f),exp2(m)-1.) *exp2(m);\n    \n    if (U.y > .5) \n        f *= 8.,                                            // plot isolines\n        O = vec4(1. - abs(fract(f)-.5)/fwidth(f));\n    else\n        O = vec4( .5+.5*f );\n    O = sqrt(O);                                            // to sRGB\n\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 311, 311, 487], [489, 489, 513, 568, 727], [730, 730, 768, 768, 1379]], "test": "untested"}
{"id": "sdfXWN", "name": "Task2_water_in_cube", "author": "zhbogdanov", "description": "V1 - cube\nV5 - water ", "tags": ["cubewater"], "likes": 1, "viewed": 240, "published": 3, "date": "1618651070", "time_retrieved": "2024-07-30T19:25:37.656071", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv) / float(iFrame + 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float INF = 1e10;\n\nconst vec3 CAMERA_POS = vec3(-1., 2.9, -7);\n\nconst vec3 LIGHT1_POS = vec3(-2, 1.5, -2);\nconst vec3 LIGHT1_SIZE = vec3(0.3, 0.3, 0.3);\nconst vec3 LIGHT1_COLOR = vec3(1, 1, 1);\n\nconst vec3 LIGHT2_POS = vec3(-3, 0.5, -2.8);\nconst float LIGHT2_RADIUS = 0.25;\nconst vec3 LIGHT2_COLOR = vec3(1, 1, 1);\n\nconst vec3 LIGHT3_POS = vec3(-2, 0.5, 3);\nconst float LIGHT3_RADIUS = 0.25;\nconst vec3 LIGHT3_COLOR = vec3(1, 1, 1);\n\nconst vec3 LIGHT4_POS = vec3(-1.2,-0.2,2);\nconst float LIGHT4_RADIUS = 0.3;\nconst vec3 LIGHT4_COLOR = vec3(0.8, 0.9, 0.7);\n\nconst vec3 MOTHER_CUBE_SIZE = vec3(1, 1, 1);\n\nvec3 randDir;\n\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\nconst float GLASS_N  = 1.5;\nconst float WATER_N  = 1.33;\nconst float AIR_N    = 1.0;\n\nconst float def_coef = 0.05;\nconst int DEFAULT = 0;\nconst int DEFORMATION = 1;\n\n\n\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\n\nfloat traceCube(vec3 pos, vec3 dir, vec3 size, out vec3 normal)\n{\n    float t;\n    float min_t = INF;\n    vec3 cur_norm;\n    vec3 worldPos;\n\n    t = (-size.x - pos.x) / dir.x;\n    if (t > 0.0) {\n        worldPos = pos + dir * t;\n        if (abs(worldPos.y) <= size.y && abs(worldPos.z) <= size.z) {\n            normal = vec3(1, 0, 0);\n            if (t < min_t) {\n                min_t = t;\n                cur_norm = normal;\n            }\n        }\n    }\n\n    t = (size.x - pos.x) / dir.x;\n    if (t > 0.0) {\n        worldPos = pos + dir * t;\n        if (abs(worldPos.y) <= size.y && abs(worldPos.z) <= size.z) {\n            normal = vec3(-1, 0, 0);\n            if (t < min_t) {\n                min_t = t;\n                cur_norm = normal;\n            }\n        }\n    }\n\n    t = (-size.y - pos.y) / dir.y;\n    if (t > 0.0) {\n        worldPos = pos + dir * t;\n        if (abs(worldPos.x) <= size.x && abs(worldPos.z) <= size.z) {\n            normal = vec3(0, -1, 0);\n            if (t < min_t) {\n                min_t = t;\n                cur_norm = normal;\n            }\n        }\n    }\n\n    t = (size.y - pos.y) / dir.y;\n    if (t > 0.0) {\n        worldPos = pos + dir * t;\n        if (abs(worldPos.x) <= size.x && abs(worldPos.z) <= size.z) {\n            normal = vec3(0, 1, 0);\n            if (t < min_t) {\n                min_t = t;\n                cur_norm = normal;\n            }\n        }\n    }\n\n    t = (-size.z - pos.z) / dir.z;\n    if (t > 0.0) {\n        worldPos = pos + dir * t;\n        if (abs(worldPos.x) <= size.x && abs(worldPos.y) <= size.y) {\n            normal = vec3(0, 0, -1);\n            if (t < min_t) {\n            min_t = t;\n            cur_norm = normal;\n            }\n        }\n    }\n\n    t = (size.z - pos.z) / dir.z;\n    if (t > 0.0) {\n        worldPos = pos + dir * t;\n        if (abs(worldPos.x) <= size.x && abs(worldPos.y) <= size.y) {\n            normal = vec3(0, 0, 1);\n            if (t < min_t) {\n                min_t = t;\n                cur_norm = normal;\n            }\n        }\n    }\n    normal = cur_norm;\n    return min_t;\n}\n\nfloat sphere_deformation(vec3 p, vec3 d) {\n    return cos(20. * (p.x + d.x)) * cos(20. * (p.y + d.y)) * cos(20. * (p.z + d.z)) * def_coef;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal, int mode) {\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c;\n    if (mode == DEFAULT)\n        c = dot(pos, pos) - r * r;\n    else if (mode == DEFORMATION) {\n        float deform = sphere_deformation(pos, dir);\n        c = dot(pos, pos) - (r - deform) * (r - deform);\n    }\n    float D = b * b - a * c;\n    if (D < 0.0) \n        return INF;\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) \n        return INF;\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) \n{\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) \n    {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.5) \n    {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    \n    if (D < 0.0) \n    {\n        return INF;\n    }\n    \n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) \n    {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) \n        {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    \n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) \n    {\n        return INF;\n    }\n    \n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) \n    {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    \n    return INF;\n}\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 sphNorm;\n    float sphT = traceSphere(pos, dir, 1.0, sphNorm, DEFAULT);\n    if (sphT < dist)\n        return true;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * 0.5) ? 0.0 : 5.0 / distSq1;\n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : 5.0 / distSq2;\n    vec3 toLight3 = LIGHT3_POS - pos;\n    float distSq3 = dot(toLight3, toLight3);\n    float att3 = isOccluded(pos, LIGHT3_POS + randDir * LIGHT3_RADIUS) ? 0.0 : 5.0 / distSq3;\n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + max(0.0, dot(normal, normalize(toLight3))) * att3 * LIGHT3_COLOR\n        + texture(iChannel1, normal).rgb * 0.1\n    );\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) \n{\n    if (dot(v, normal) < 0.0) \n    {\n        normal = -normal;\n    }\n    \n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3  tang = normalize(v - cosA * normal);\n    \n    float sinB = sinA / n2 * n1;\n    if (sinB >= 1.0)\n    {\n        return reflect(v, normal);\n    }\n    else \n    {\n        float cosB = sqrt(1.0 - sinB * sinB);\n        return sinB * tang + cosB * normal;\n    }\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    vec3 randDir  = normalize(randVals - 0.5);\n    vec3 front    = normalize(-CAMERA_POS);\n    vec3 up       = vec3(0, 1, 0);\n    vec3 right    =  normalize(cross(front, up));\n    up            = normalize(cross(right, front));\n    vec2 uv       = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    vec3 viewVec  = normalize(front + right * uv.x + up * uv.y);\n    vec3 curPos   = CAMERA_POS;\n    vec3 curDir   = viewVec;\n    vec3 colorMult = vec3(1, 1, 1);\n\n    float n1      = AIR_N;\n    float WATER_R = pow2(WATER_N - GLASS_N) / pow2(WATER_N + GLASS_N);\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    \n    for (int i = 0; i < 10; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color, normal, worldPos;\n        float nEnter = AIR_N;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            worldPos = t * curDir + curPos;\n            color  = texture(iChannel0, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n            \n            if (randVals.x < 0.5) \n                materialType = REFLECTION;\n            else \n                materialType = DIFFUSE;\n        }\n\n        vec3 l1Norm;\n        float light1T = traceCube(curPos - LIGHT1_POS, curDir, LIGHT1_SIZE, l1Norm);\n        if (light1T < t) {\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        \n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm, DEFAULT);\n        if (light2T < t) {\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n\n        vec3 l3Norm;\n        float light3T = traceSphere(curPos - LIGHT3_POS, curDir, LIGHT3_RADIUS, l3Norm, DEFAULT);\n        if (light3T < t) {\n            t = light3T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l3Norm;\n        }\n        vec3 L4Norm;\n        float light4T = traceSphere(curPos - LIGHT4_POS, curDir, LIGHT3_RADIUS, L4Norm, DEFAULT);\n        if (light4T < t) {\n            t = light4T;\n            materialType = EMISSION;\n            vec3 worldPos = t * curDir + curPos;\n            color = LIGHT4_COLOR ;\n            normal = L4Norm;\n        }\n        \n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < t) {\n            t = cylT;;\n            vec3 worldPos = t * curDir + curPos;\n            color  = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n            materialType = DIFFUSE;\n        }\n\n        vec3 cubeNorm;\n        float cubeT = traceCube(curPos, curDir, MOTHER_CUBE_SIZE, cubeNorm);\n        if (cubeT < t) {\n            t = cubeT;\n            normal = cubeNorm;\n            if (randVals.x < GLASS_R) \n                materialType = REFLECTION;\n            else {\n                materialType = REFRACTION;\n                nEnter = dot(curDir, normal) > 0.0 ? AIR_N : GLASS_N;\n                \n            }\n        }\n\n        \n\n        if (randVals.x < 0.75)\n        {\n            vec3 water1Norm;\n            float water1T = traceSphere(curPos - vec3(-0.7, -0.7, -0.7), curDir, 0.223, water1Norm, DEFORMATION);\n            if (water1T < t) \n            {\n                t = water1T;\n                normal = water1Norm;\n                vec3 worldPos = t * curDir + curPos;\n                // for more realistic water\n                color = texture(iChannel3, worldPos).rgb + vec3(0, 0.3, 0.3);\n                materialType = REFRACTION;\n                if (randVals.x * 0.01 < WATER_R) \n                {\n                    materialType = EMISSION;\n                } \n                else \n                {\n                    colorMult *= vec3(0, 1, 1);\n                    materialType = REFRACTION;\n                    if (dot(curDir, normal) > 0.0) \n                    {\n                        nEnter = GLASS_N;\n                    } \n                    else \n                    {\n                        nEnter = 1.33;\n                    }\n                }\n                \n            }\n        }\n        if (randVals.x < 0.75)\n        {\n            vec3 water2Norm;\n            float water2T = traceSphere(curPos - vec3(-0.35, -0.45, -0.55), curDir, 0.3, water2Norm, DEFORMATION);\n            if (water2T < t) {\n                t = water2T;\n                normal = water2Norm;\n                vec3 worldPos = t * curDir + curPos;\n                // for more realistic water\n                color = texture(iChannel3, worldPos).rgb + vec3(0, 0.3, 0.3);\n                materialType = REFRACTION;\n                if (randVals.x * 0.01 < WATER_R) \n                {\n                    materialType = EMISSION;\n                } \n                else \n                {\n                    colorMult *= vec3(0, 1, 1);\n                    materialType = REFRACTION;\n                    if (dot(curDir, normal) > 0.0) \n                    {\n                        nEnter = GLASS_N;\n                    } \n                    else \n                    {\n                        nEnter = 1.33;\n                    }\n                }\n                \n            }\n        }\n        \n        if (randVals.x < 0.75)\n        {\n            vec3 water3Norm;\n            float water3T = traceSphere(curPos - vec3(0.05, -0.2, -0.1), curDir, 0.35, water3Norm, DEFORMATION);\n            if (water3T < t) {\n                t = water3T;                \n                normal = water3Norm;\n                vec3 worldPos = t * curDir + curPos;\n                // for more realistic water\n                color = texture(iChannel3, worldPos).rgb + vec3(0, 0.3, 0.3);\n                materialType = REFRACTION;\n                if (randVals.x * 0.01 < WATER_R) \n                {\n                    materialType = EMISSION;\n                } \n                else \n                {\n                    colorMult *= vec3(0, 1, 1);\n                    materialType = REFRACTION;\n                    if (dot(curDir, normal) > 0.0) \n                    {\n                        nEnter = GLASS_N;\n                    } \n                    else \n                    {\n                        nEnter = WATER_N;\n                    }\n                }\n                \n            }\n        }\n\n        if (randVals.x < 0.75)\n        {\n            vec3 water3Norm;\n            float water3T = traceSphere(curPos - vec3(0.15, 0.4, 0.4), curDir, 0.5, water3Norm, DEFORMATION);\n            if (water3T < t) {\n                t = water3T;                \n                normal = water3Norm;\n                vec3 worldPos = t * curDir + curPos;\n                // for more realistic water\n                color = texture(iChannel3, worldPos).rgb + vec3(0, 0.3, 0.3);\n                materialType = REFRACTION;\n                if (randVals.x * 0.01 < WATER_R) \n                {\n                    materialType = EMISSION;\n                } \n                else \n                {\n                    colorMult *= vec3(0, 1, 1);\n                    materialType = REFRACTION;\n                    if (dot(curDir, normal) > 0.0) \n                    {\n                        nEnter = GLASS_N;\n                    } \n                    else \n                    {\n                        nEnter = WATER_N;\n                    }\n                }\n                \n            }\n        }\n        \n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-5;\n                n1 = nEnter;\n            }\n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv) + texture(iChannel1,uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "//https://www.shadertoy.com/view/MdlXz8\n//#define SHOW_TILING\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n\tfloat time = iTime * 1.5+23.0;\n    // uv should be the 0-1 uv of texture...\n\tvec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    vec3 randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    \n    \n#ifdef SHOW_TILING\n\tvec2 p = mod(uv*TAU*12.0, TAU)-250.0;\n#else\n    vec2 p = mod(uv*TAU, TAU)-250.0;\n#endif\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 8.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n    \n\n\t#ifdef SHOW_TILING\n\t// Flash tile borders...\n\tvec2 pixel = 2.0 / iResolution.xy;\n\tuv *= 1.0;\n\n\tfloat f = floor(mod(iTime*2.5, 2.0)); \t// Flash value.\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n\t\n\t#endif\n\tfragColor = vec4(colour, 1.0);\n}", "cube_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 158]], "test": "untested"}
{"id": "7dXXDN", "name": "erf(x) & erf(x)", "author": "FabriceNeyret2", "description": "good approximation of erf function  ( light green )\nred: gaussian    blue: derivative of erf: ultra close.\n\nnot so bad approx of reciprocal (cyan) derived from not so bad approx of erf ( dark green )\ngrey:  Ierf(erf(x))   dark-red: y=x : ultra-close.\n", "tags": ["normal", "plot", "gauss", "erf", "reciprocal"], "likes": 7, "viewed": 624, "published": 3, "date": "1618649101", "time_retrieved": "2024-07-30T19:25:38.427010", "image_code": "#define P  ( sqrt(3.14159265359)/2. )\n\nfloat erf(float x) {                        // very good approx https://en.wikipedia.org/wiki/Error_function\n    float e = exp(-x*x);                    // ( Brmann series )\n    return sign(x)/P * sqrt( 1. - e ) * ( P + 31./200.*e - 341./8000. *e*e );\n}\n\n#define erf0(x)     tanh(1.2*(x))           // not so bad approx, with easy reciprocal\n#define Ierf(x) ( atanh(x) / 1.2 )          // not so bad reciprocal\n\n#define gauss(x,s)    exp(-.5*(x)*(x) / ((s)*(s)) )\n\n#define plot(v)     clamp( 1.- abs(v-y) / fwidth(v-y) , 0.,1.)\n\n#define deriv(f)   ( ( f(x) - f(x-1e-3) ) /1e-3 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) /R.y;\n    float x = U.x, y = U.y, v;\n    \n    O.g = plot( erf(x) );                   // erf\n    O.b = plot( P * deriv(erf) );           // derivative of erf\n    O.r = plot( gauss( x, 1./sqrt(2.)) );   // gaussian, for comparison\n    \n    O.g  += .3* plot( erf0(x) );            // lesser approx of erf\n    O.gb += .8* plot( Ierf(x) );            // reciprocal\n    O    += .5* plot( Ierf(erf(x)) );       // erf(erf)\n    O.r  += .5*plot( x );                   // y=x, for comparison\n    \n    O += plot(0.);\n    O = sqrt(O);                            // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXXDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 59, 147, 294], [621, 621, 659, 659, 1284]], "test": "untested"}
{"id": "ssfSWN", "name": "Day 486[4d kaliset]", "author": "jeyko", "description": "uuh", "tags": ["fractal", "projection", "4d", "mdtmjvm"], "likes": 4, "viewed": 292, "published": 3, "date": "1618643565", "time_retrieved": "2024-07-30T19:25:39.194957", "image_code": "// Fork of \"Day 486[4d projected fractal]\" by jeyko. https://shadertoy.com/view/7dXXD4\n// 2021-04-17 06:41:35\n\n// Fork of \"Day 485[4d projected apollonian]\" by jeyko. https://shadertoy.com/view/fdXSD4\n// 2021-04-17 05:50:39\n\n// My bro Nameless explained 4d projection/rendering to me,\n// so I needed to render fractals in it. fun stuff.\n\n// here follows my interpretation of his explanation\n\n// 2d creatures see a line\n// 3d creatures see a 2d array, projected by cam z\n// 4d creatrues see a 3d grid, projected by cam w\n\n\n// what i've done here is construct a 3d grid of 2d slices.\n// each slice is a full raymarch into 4d space, projected by the w\n// this just means that instead of doing\n// rd = normalize(vec3(uv,1));\n// we do\n// rd = normalize(vec3(uv,sliceIdx/sliceCnt,1));d\n// that's really about all there is to it. in the end we project the 3d grid isometrically to our 2d shadertoy screen.\n\n// this code is probably not a good learning resource though.\n\n\n\n// Performance vars\n\nfloat sliceCnt = 128.;\nfloat marchSteps = 30.;\nfloat dMult = 1.;\n\n\n// Coeff vars\n\nfloat rotSpd = 0.5;\nfloat fov4D = 0.4;     // scale up the sliceZDepth when widening the fov\nfloat sliceZDepth = 1.; \nfloat minT = 10e5;\n\nfloat normalEps = 0.01;\nfloat distEps = 0.001;\nfloat distOffs = 0.;\n\nfloat ditherAmt = 1.;\n\n#define DEBUG 0\n#define TUBES 1\n\n\nvec2 sdMeng(vec4 p){\n    float sc = 1.;\n    vec2 d = vec2(10e5,0.);\n    \n    //p = pmod(p,4.);\n    vec4 op = p;\n    for(float i = 0.; i < 4.; i++){\n        \n        float dpp = dot(p,p); \n        p /= dpp; sc /= dpp;\n        \n        p = abs(p);\n        //if(p.x > p.z) p.xz = p.zx;\n        //if(p.y > p.z) p.yz = p.zy;\n        //if(p.w > p.y) p.yw = p.wy;\n        \n        //if(p.x > p.w) p.xw = p.wx;\n        //if(p.x > p.y) p.xy = p.yx;\n        \n        \n        //if(i == 2.)\n        //p = pmod(p,vec4(3.5));\n        \n        p -= vec4(0.5,0.3,0.5,0.1)*.41;\n        p.wx *= rot(0.4 + iTime*0.1 );\n        p.wy *= rot(0.5*pi );\n        //p.xy *= rot(-0.4*pi);\n        \n        const float scMult = 1.4;\n        p *= scMult; sc *= scMult;\n        \n     \n    }\n    p /= sc;\n    \n    //d = dmin(d,ld(p.zxw) - 0.001 );\n    //d = dmin(d,length(p.y) - 0.00 );\n    \n    //d = dmin(d,sdBox(p,vec4(0.06)));\n    d = dmin(d,sdBox(p,vec4(0.01,0.01,0.01,.83)) - 0.0 );\n    d = dmin(d,sdBox(p,vec4(0.01,0.01,.61,.02)) - 0.0 );\n    \n    return d;\n}\n\nvec2 map(vec4 p){\n    \n    \n    p -= vec4(0.3,0.,1.,1.5);\n    //p.x += sin(iTime*0.5)*0.4;\n    \n    //p.wz *= rot(1.4);\n    //p.yw *= rot( -iTime*0.4);\n    \n    p.xw *= rot( iTime*1.5*rotSpd);\n    p.wz *= rot( -iTime*1.7*rotSpd );\n    \n    p.yw *= rot( iTime*1.5*rotSpd);\n    \n    p.yx *= rot( iTime*.5*rotSpd);\n    \n    //p.xz *= rot( iTime*0.7 *rotSpd);\n    \n    //p += 0.2 ;\n    \n    //p -= 0.5 ;\n    \n    //p.yw *= rot( -iTime*0.15);\n\n    //vec2 d = sdApollonian(p);\n    vec2 d = sdMeng(p);\n      \n     \n    return d;\n}\n\nvec4 getNormal(vec4 p){\n    vec2 t = vec2(normalEps,0.00);\n    return normalize(map(p).x-vec4(\n        map(p-t.xyyy).x,\n        map(p-t.yxyy).x,\n        map(p-t.yyxy).x,\n        map(p-t.yyyx).x));\n}\n\n// suggested from tdhooper. Thanks!\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 8;\nvec4 getNormala(vec4 pos) {\n\n    vec4 eps = vec4(normalEps*1., 0, 0,0.);\n\t\n\tvec4 nor = vec4(0);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < NORMAL_STEPS; i++) {\n\t\tnor += map(pos + eps * invert).x * eps * invert;\n\t\teps = eps.wxyz;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*vec2(172.412,735.124)+uv.yx*vec2(97.354,421.653)+vec2(94.321,37.365)),vec2(4.6872,7.9841))+0.71243);\n}\n\nvec2 halton (int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    muv *= 6.28;\n\n    vec3 col = vec3(0);\n\n\n    #if DEBUG\n    \n        vec3 gro = vec3(sin(muv.x),0,cos(muv.x))*sliceZDepth*1.5;\n        vec3 grd = normalize(vec3(uv,1));\n\n        gro.yz *= rot(-muv.y);\n        grd.yz *= rot(-muv.y);\n        grd.xz *= rot(-muv.x);\n\n    #endif\n    \n    \n    bool hitAtLeastOnce = false;\n    float dither = texture(iChannel1, fragCoord / 1024.0f).r*ditherAmt*2. - 0.5*ditherAmt;\n    \n    \n    const vec3 fogCol = vec3(0.6,0.6,0.56)*4.;\n\n    col = fogCol;\n    for(float slice = 0.; slice < sliceCnt; slice++){\n          \n        #if DEBUG\n            vec3 sliceUv = gro + grd * plaIntersect( gro + vec3(0,0,1)*slice/sliceCnt*1.*sliceZDepth , grd, vec4(0,0,-1,0) );\n        #else\n            vec2 sliceUv = uv;\n        #endif\n        \n        \n        vec4 rd = normalize(vec4(sliceUv.xy,sliceZDepth*((slice+(dither))/sliceCnt - 0.5),fov4D));\n        \n        vec4 p = vec4(0); \n       \n        bool hit = false;\n        vec2 d;\n        float glow = 0.;\n        float t = 0.;\n       \n    \n        for(float st = 0.; st < marchSteps; st++){\n            d = map(p);\n            d.x += distOffs;\n            if(d.x < distEps){\n                hit = true;\n                break;\n            } else if (t > 3.5){\n                //t = 10.;\n                break;\n            }\n            \n            d.x *= dMult;\n            t += d.x;\n            p += rd*d.x;\n        }\n        \n\n          \n        if(hit && t < minT){\n            minT = t;\n            hitAtLeastOnce = true;\n            vec4 n = getNormal(p); \n            \n            col = (pal(0.5,0.5*vec3(1.,1.,1.),vec3(0.4,1.,1.5),1.,4.*dot(n,rd)));\n            //col = pow(abs(col),vec3(1.8));\n            col *= AO(.1)*AO(.01)*AO(.04)*AO(.08)*AO(.13);\n            \n            \n            col = mix(col,fogCol,smoothstep(0.,1.,(t)*.66- 0.6));\n            }\n        else{\n        }\n        \n    }\n    \n    // reinhardt and sutff\n    col = 1./(1. + 1./col);\n    \n    //col = 0.5 - col*2.;\n    //col = 1. - exp(-col*1.);\n    col = ACESFilm(col);\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define NOISE_THRESHOLD 1.0\n#define comp(a, b, c) (v[a].c > v[b].c)\n#define swap(a, b, c) temp = v[b].c; v[b].c = v[a].c; v[a].c = temp;\n#define cmpswap(x, y) if (comp(x, y, r)){ swap(x, y, r)}; if (comp(x, y, g)){ swap(x, y, g)}; if (comp(x, y, b)){ swap(x, y, b)};\n\nvec3 medianSub(in vec3[9] v){\n    float temp;  \n        \n    cmpswap(0, 1); \n    cmpswap(3, 4); \n    cmpswap(6, 7); \n    \n    cmpswap(1, 2); \n    cmpswap(4, 5); \n    cmpswap(7, 8); \n    \n    cmpswap(0, 1); \n    cmpswap(3, 4); \n    cmpswap(6, 7); \n    cmpswap(2, 5); \n    \n    cmpswap(0, 3); \n    cmpswap(1, 4); \n    cmpswap(5, 8); \n    \n    cmpswap(3, 6); \n    cmpswap(4, 7); \n    cmpswap(2, 5); \n    \n    cmpswap(0, 3); \n    cmpswap(1, 4); \n    cmpswap(5, 7); \n    cmpswap(2, 6); \n    \n    cmpswap(1, 3); \n    cmpswap(4, 6); \n    \n    cmpswap(2, 4); \n    cmpswap(5, 6); \n    \n    cmpswap(2, 3); \n    \n    return (v[4]);\n}\n\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + e))\n\n#define AO(a) smoothstep(0.,1.,map(p+n*a).x/a)\n\n#define pi acos(-1.)\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n/*\nvec4 getNormala(vec4 p){\n    vec2 t = vec2(0.0004,0.00);\n    return normalize(vec4(\n        map(p+t.xyyy).x - map(p-t.xyyy).x,\n        map(p+t.yxyy).x - map(p-t.yxyy).x,\n        map(p+t.yyxy).x - map(p-t.yyxy).x,\n        map(p+t.yyyx).x - map(p-t.yyyx).x));\n}\n*/\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nfloat sdBox(vec4 p, vec4 s){p = abs(p) - s; return max(p.x,max(p.y,max(p.z,p.w)));}\n\n\nfloat sdBoxEdges(vec4 p, vec4 s, float edgeW){\n    float d = sdBox(p, s);\n    \n    float cuttingEdgeW = edgeW*1.;\n    //d = abs(d);\n    d = max(d, -sdBox(p, s - vec4(-cuttingEdgeW,edgeW,edgeW,edgeW)));\n    d = max(d, -sdBox(p, s - vec4(edgeW,-cuttingEdgeW,edgeW,edgeW)));\n    d = max(d, -sdBox(p, s - vec4(edgeW,edgeW,-cuttingEdgeW,edgeW)));\n    d = max(d, -sdBox(p, s - vec4(edgeW,edgeW,edgeW,-cuttingEdgeW)));\n    \n    \n    return d;\n}\n\n\n#define max4v(v) max(max(v.x, v.y), max(v.z, v.w))\n#define min4(x,y,z,w) min(min(x, y), min(z, w))\n\n\n#define dmin(d,b) d.x < b ? d : vec2(b,d.y + 1.)\nfloat sdTesseractFrame( vec4 p, vec4 b, float e ) { \n  p = abs(p)-b; \n  vec4 q = abs(p+e)-e; \n  mat4 t = mat4(\n        p.x, q.y, q.z, q.w,\n        q.x, p.y, q.z, q.w,\n        q.x, q.y, p.z, q.w,\n        q.x, q.y, q.z, p.w\n  );\n  return min4(\n        length(max(t[0], 0.0)+min(max4v(t[0]),0.0)),\n        length(max(t[1], 0.0)+min(max4v(t[1]),0.0)),\n        length(max(t[2], 0.0)+min(max4v(t[2]),0.0)),\n        length(max(t[3], 0.0)+min(max4v(t[3]),0.0))\n  );\n}\n\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1332, 1332, 1352, 1352, 2368], [2370, 2370, 2387, 2387, 2893], [2895, 2895, 2918, 2918, 3093], [3202, 3202, 3229, 3229, 3474], [3476, 3476, 3496, 3496, 3625], [3627, 3627, 3652, 3652, 3918], [3920, 3920, 3977, 3977, 6201]], "test": "untested"}
{"id": "7dXXD4", "name": "Day 486[4d projected fractal]", "author": "jeyko", "description": "uuh", "tags": ["fractal", "projection", "4d", "mdtmjvm"], "likes": 10, "viewed": 562, "published": 3, "date": "1618640832", "time_retrieved": "2024-07-30T19:25:39.963901", "image_code": "// Fork of \"Day 485[4d projected apollonian]\" by jeyko. https://shadertoy.com/view/fdXSD4\n// 2021-04-17 05:50:39\n\n// My bro Nameless explained 4d projection/rendering to me,\n// so I needed to render fractals in it. fun stuff.\n\n// here follows my interpretation of his explanation\n\n// 2d creatures see a line\n// 3d creatures see a 2d array, projected by cam z\n// 4d creatrues see a 3d grid, projected by cam w\n\n\n// what i've done here is construct a 3d grid of 2d slices.\n// each slice is a full raymarch into 4d space, projected by the w\n// this just means that instead of doing\n// rd = normalize(vec3(uv,1));\n// we do\n// rd = normalize(vec3(uv,sliceIdx/sliceCnt,1));d\n// that's really about all there is to it. in the end we project the 3d grid isometrically to our 2d shadertoy screen.\n\n// this code is probably not a good learning resource though.\n\n\n\n// Performance vars\n\nfloat sliceCnt = 100.;\nfloat marchSteps = 30.;\nfloat dMult = 1.;\n\n\n// Coeff vars\n\nfloat rotSpd = 0.5;\nfloat fov4D = 0.25;     // scale up the sliceZDepth when widening the fov\nfloat sliceZDepth = 1.; \nfloat minT = 10e5;\n\nfloat normalEps = 0.02;\nfloat distEps = 0.001;\nfloat distOffs = 0.;\n\nfloat ditherAmt = -1.;\n\n#define DEBUG 0\n#define TUBES 1\n\n\nvec2 sdMeng(vec4 p){\n    float sc = 1.;\n    vec2 d = vec2(10e5,0.);\n    \n    \n    for(float i = 0.; i < 4.; i++){\n        p = abs(p);\n        if(p.x > p.z) p.xz = p.zx;\n        if(p.y > p.z) p.yz = p.zy;\n        if(p.w > p.y) p.yw = p.wy;\n        if(p.x > p.w) p.xw = p.wx;\n        //if(p.x > p.y) p.xy = p.yx;\n        \n        \n        if(i == 2.)\n            p = pmod(p,vec4(3.5));\n        \n        p -= vec4(0.4,0.3,0.5,0.1);\n        //p.xy *= rot(0.5*pi);\n        \n        p *= 1.6; sc *=1.6;\n        \n     \n    }\n    p /= sc;\n    \n    //d = dmin(d,ld(p.zxw) - 0.001 );\n    //d = dmin(d,length(p.y) - 0.00 );\n    \n    //d = dmin(d,sdBox(p,vec4(0.06)));\n    d = dmin(d,sdBox(p,vec4(0.07,0.06,10.05,0.03)));\n    \n    return d;\n}\n\nvec2 map(vec4 p){\n    \n    \n    p -= 1.4;\n    p.x += sin(iTime*0.5)*0.;\n    \n    //p.wz *= rot(1.4);\n    //p.yw *= rot( -iTime*0.4);\n    \n    p.xw *= rot( iTime*0.5*rotSpd);\n    p.wz *= rot( iTime*0.7*rotSpd );\n    \n    p.yw *= rot( iTime*0.5*rotSpd);\n    //p.xz *= rot( iTime*0.7 *rotSpd);\n    \n    //p += 0.2 ;\n    \n    //p -= 0.5 ;\n    \n    //p.yw *= rot( -iTime*0.15);\n\n    //vec2 d = sdApollonian(p);\n    vec2 d = sdMeng(p);\n      \n     \n    return d;\n}\n\nvec4 getNormal(vec4 p){\n    vec2 t = vec2(normalEps,0.00);\n    return normalize(map(p).x-vec4(\n        map(p-t.xyyy).x,\n        map(p-t.yxyy).x,\n        map(p-t.yyxy).x,\n        map(p-t.yyyx).x));\n}\n\n// suggested from tdhooper. Thanks!\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 8;\nvec4 getNormala(vec4 pos) {\n\n    vec4 eps = vec4(normalEps*1., 0, 0,0.);\n\t\n\tvec4 nor = vec4(0);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < NORMAL_STEPS; i++) {\n\t\tnor += map(pos + eps * invert).x * eps * invert;\n\t\teps = eps.wxyz;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*vec2(172.412,735.124)+uv.yx*vec2(97.354,421.653)+vec2(94.321,37.365)),vec2(4.6872,7.9841))+0.71243);\n}\n\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton (int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    muv *= 6.28;\n\n    vec3 col = vec3(0);\n\n\n    #if DEBUG\n    \n        vec3 gro = vec3(sin(muv.x),0,cos(muv.x))*sliceZDepth*1.5;\n        vec3 grd = normalize(vec3(uv,1));\n\n        gro.yz *= rot(-muv.y);\n        grd.yz *= rot(-muv.y);\n        grd.xz *= rot(-muv.x);\n\n    #endif\n    \n    \n    bool hitAtLeastOnce = false;\n    //float dither = rnd(uv + iTime);\n    float dither = texture(iChannel1, fragCoord / 1024.0f).r*ditherAmt*2. - 0.5*ditherAmt;\n    \n    \n    //vec2 h = halton (int(fragCoord)%16);\n    //float dither = mod(h.x + h.y,1.);;  \n    for(float slice = 0.; slice < sliceCnt; slice++){\n          \n        #if DEBUG\n            vec3 sliceUv = gro + grd * plaIntersect( gro + vec3(0,0,1)*slice/sliceCnt*1.*sliceZDepth , grd, vec4(0,0,-1,0) );\n        #else\n            vec2 sliceUv = uv;\n        #endif\n        \n        \n        vec4 rd = normalize(vec4(sliceUv.xy,sliceZDepth*((slice+dither)/sliceCnt - 0.5),fov4D));\n        \n        vec4 p = vec4(0); \n       \n        bool hit = false;\n        vec2 d;\n        float glow = 0.;\n        float t = 0.;\n       \n    \n        for(float st = 0.; st < marchSteps; st++){\n            d = map(p);\n            d.x += distOffs;\n            if(d.x < distEps){\n                hit = true;\n                break;\n            } else if (t > 3.5){\n                //t = 10.;\n                break;\n            }\n            \n            d.x *= dMult;\n            t += d.x;\n            p += rd*d.x;\n        }\n        \n\n          \n        const vec3 fogCol = vec3(0.6,0.6,0.56)*1.;\n        if(hit && t < minT){\n            minT = t;\n            hitAtLeastOnce = true;\n            vec4 n = getNormal(p); \n            \n            col = (pal(0.5,0.5*vec3(1.+ sin( p.w*6.)*0.,1.,1.),vec3(0.4,1.,1.5),1.,4.*dot(n,rd)));\n            //col = pow(abs(col),vec3(1.8));\n            col *= AO(.1)*AO(.01)*AO(.04)*AO(.08)*AO(.13);\n            \n            \n            col = mix(col,fogCol,smoothstep(0.,1.,(t)*.46- 0.6));\n            }\n        else{\n            if(!hitAtLeastOnce)\n                col = fogCol;\n        }\n        \n    }\n    \n    // reinhardt and sutff\n    col = 1./(1. + 1./col);\n    //col = 1. - exp(-col*1.);\n    col = ACESFilm(col);\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + e))\n\n#define AO(a) smoothstep(0.,1.,map(p+n*a).x/a)\n\n#define pi acos(-1.)\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n/*\nvec4 getNormala(vec4 p){\n    vec2 t = vec2(0.0004,0.00);\n    return normalize(vec4(\n        map(p+t.xyyy).x - map(p-t.xyyy).x,\n        map(p+t.yxyy).x - map(p-t.yxyy).x,\n        map(p+t.yyxy).x - map(p-t.yyxy).x,\n        map(p+t.yyyx).x - map(p-t.yyyx).x));\n}\n*/\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nfloat sdBox(vec4 p, vec4 s){p = abs(p) - s; return max(p.x,max(p.y,max(p.z,p.w)));}\n\n\nfloat sdBoxEdges(vec4 p, vec4 s, float edgeW){\n    float d = sdBox(p, s);\n    \n    float cuttingEdgeW = edgeW*1.;\n    //d = abs(d);\n    d = max(d, -sdBox(p, s - vec4(-cuttingEdgeW,edgeW,edgeW,edgeW)));\n    d = max(d, -sdBox(p, s - vec4(edgeW,-cuttingEdgeW,edgeW,edgeW)));\n    d = max(d, -sdBox(p, s - vec4(edgeW,edgeW,-cuttingEdgeW,edgeW)));\n    d = max(d, -sdBox(p, s - vec4(edgeW,edgeW,edgeW,-cuttingEdgeW)));\n    \n    \n    return d;\n}\n\n\n#define max4v(v) max(max(v.x, v.y), max(v.z, v.w))\n#define min4(x,y,z,w) min(min(x, y), min(z, w))\n\n\n#define dmin(d,b) d.x < b ? d : vec2(b,d.y + 1.)\nfloat sdTesseractFrame( vec4 p, vec4 b, float e ) { \n  p = abs(p)-b; \n  vec4 q = abs(p+e)-e; \n  mat4 t = mat4(\n        p.x, q.y, q.z, q.w,\n        q.x, p.y, q.z, q.w,\n        q.x, q.y, p.z, q.w,\n        q.x, q.y, q.z, p.w\n  );\n  return min4(\n        length(max(t[0], 0.0)+min(max4v(t[0]),0.0)),\n        length(max(t[1], 0.0)+min(max4v(t[1]),0.0)),\n        length(max(t[2], 0.0)+min(max4v(t[2]),0.0)),\n        length(max(t[3], 0.0)+min(max4v(t[3]),0.0))\n  );\n}\n\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXXD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1223, 1223, 1243, 1243, 1953], [1955, 1955, 1972, 1972, 2413], [2415, 2415, 2438, 2438, 2613], [2722, 2722, 2749, 2749, 2994], [2996, 2996, 3016, 3016, 3145], [3148, 3227, 3252, 3252, 3518], [3519, 3519, 3576, 3576, 5955]], "test": "untested"}
{"id": "7sfXD4", "name": "RotatingSphere", "author": "nialred", "description": "Attempting to implement rotation, but am only able to rotate the xy pixel coordinates not the sphere itself. \n\nTrying to get better at this. Would appreciate comments and such suggesting how I might go about that.", "tags": ["sdf", "distortion", "sphere", "raymarcher", "rotation"], "likes": 2, "viewed": 187, "published": 3, "date": "1618640618", "time_retrieved": "2024-07-30T19:25:40.726861", "image_code": "/*\n\nI DID NOT DO THIS ALONE:\n========================\n\nReferences:\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttps://michaelwalczyk.com/blog-ray-marching.html\nhttps://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays\nhttps://www.shadertoy.com/view/4sdSDN\n\n*/\n\nconst int MAX_MARCHING_STEPS = 32; // Max steps you are willing to search for a \"hit\"\nconst float MAX_DIST = 1000.0; // Max distance to search for a \"hit\"\nconst float MIN_DIST = 0.0; // Where to start the march \nconst float EPSILON = 0.001; // How close you need to be to be considered a hit\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\n// I don't know where I should define this cause I don't know how this scales\n// once you introduce multiple shapes and whatnot, so I just made it global\nSphere sphere = Sphere(vec3(0.0, 0.0, 12.0), 3.0);\n\nvec3 ray_direction(float fieldOfView, vec2 size, vec2 uv) \n{ \n    float z = 1.0 / tan(radians(fieldOfView) / 2.0); // Distance to image plane\n    return normalize(vec3(uv, z));\n}\n\nfloat sphere_sdf(vec3 point)\n{\n    return length(point - sphere.center) - sphere.radius; // Return distance from sphere\n}\n\nfloat distort_surface(float freq, vec3 point)\n{\n    return sin(freq * point.x) * sin(freq * point.y) * sin(freq * point.z);\n}\n\nvoid rotate_2d(float freq, inout vec2 p)\n{\n    float c = cos(10.0*freq);\n    float s = sin(10.0*freq);\n    p = vec2((p.x*c) - (p.y*s), (p.x*s) + (p.y*c));\n}\n\nfloat map_world(vec3 point)\n{   \n    float displacement = distort_surface(cos(iTime/5.0)+200000000000000000000000000000000000.5, point); //500000000000.5\n    \n    float dist = sphere_sdf(point); // Distance from sphere \n    return dist + displacement;\n}\n\nfloat shortest_distance_to_surface(vec3 eye_pos, vec3 march_dir, float start, float end)\n{\n    float depth = start; // Starting point for ray march (0.0)\n    float dist = 0.0;    // Initalize distance from sphere variable\n    int i = 0;           \n    \n    while (i < MAX_MARCHING_STEPS)\n    {\n        dist = map_world(eye_pos + (depth * march_dir)); // Distance to sphere (distorted)\n        \n        if (dist < EPSILON) // If at the surface, return the depth from image plane\n        {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= end) // If at the max marching distance, return the max value\n        {\n            return end;\n        }\n        \n        i += 1;\n     }\n     \n     return end;\n}\n\nvec3 estimate_normal(vec3 point)\n{   \n    vec3 step = vec3(EPSILON, 0.0, 0.0);\n    \n    float gradient_x = map_world(point + step) - map_world(point - step);\n    float gradient_y = map_world(point + step.yxz) - map_world(point - step.yxz);\n    float gradient_z = map_world(point + step.yzx) - map_world(point - step.yzx);\n    \n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    \n    return normalize(normal);\n}\n\nfloat diffuse(vec3 current_pos, vec3 light_pos, vec3 normal)\n{\n    vec3 light_dir = normalize(light_pos - current_pos);\n    float intensity = max(0.0, dot(normal, light_dir));\n    return intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sphere.center = vec3(0.4*sin(iTime/5.0), 0.4*cos(iTime/5.0), 8.0 + sin(iTime/5.0));\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    float aspect_ratio = iResolution.x/iResolution.y;\n    uv.x = uv.x * aspect_ratio; // Account for image aspect ratio\n    \n    // Define camera position\n    vec3 cam_pos = vec3(0.0, 0.0, 0.0);\n    \n    // Define ray as vector from camera position to pixel position\n    rotate_2d(iTime/20.0, uv);\n    Ray ray = Ray(cam_pos, ray_direction(30.0, iResolution.xy, uv));\n      \n    // Define light position as a 3D vector\n    vec3 light_pos = vec3(0.0, 10.0, 0.0);\n    \n    // Find distance to surface\n    float dist = shortest_distance_to_surface(ray.origin, ray.direction, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) // If sphere doesn't exist at this pixel draw bg\n    {\n        // Eventually want to have the background be a cubic room \n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    \n    else // If sphere does exist at this pixel, draw color accordingly using basic lighting\n    {\n        vec3 point = ray.origin + dist*ray.direction;\n        vec3 normal = estimate_normal(point);\n        float intensity = diffuse(point, light_pos, normal);\n        normal = vec3(1.0, 0.9, 1.0) * intensity;\n        fragColor = vec4(normal, 1.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfXD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[956, 956, 1016, 1016, 1134], [1136, 1136, 1166, 1166, 1257], [1259, 1259, 1306, 1306, 1384], [1386, 1386, 1428, 1428, 1542], [1544, 1544, 1573, 1573, 1797], [1799, 1799, 1889, 1889, 2547], [2549, 2549, 2583, 2583, 2972], [2974, 2974, 3036, 3036, 3173], [3175, 3175, 3232, 3232, 4602]], "test": "untested"}
{"id": "7sXSD4", "name": "the case of the missing area", "author": "elenzil", "description": "intersecting circles with fake preservation of total area.\nwas watching kids play with soap bubbles.\nblue circle is twice the area of lavender.", "tags": ["bubbles"], "likes": 7, "viewed": 257, "published": 3, "date": "1618639678", "time_retrieved": "2024-07-30T19:25:41.501789", "image_code": "// Fork of \"boilerplate stuff\" by elenzil. https://shadertoy.com/view/7dX3R2\n// 2021-04-17 05:07:53\n\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdCircle(in vec2 p, in float r) {\n    return abs(sdDisk(p, r));\n}\n\nfloat sdAnnulus(in vec2 p, in float r1, in float r2) {\n    return abs(sdDisk(p, (r1 + r2) / 2.0)) - (r2 - r1) / 2.0;\n}\n\nvoid drawDisk(inout vec3 color, in vec3 colorNew, in vec2 p, in vec2 c, in float r) {\n    color = mix(color, colorNew, 0.2 * smoothstep(gSmoothEps, -gSmoothEps, sdDisk  (p - c, r)));\n    color = mix(color, colorNew,       smoothstep(gSmoothEps, -gSmoothEps, sdCircle(p - c, r)));\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    setupCoords(iResolution.xy, 0.95);\n    setupTime(iTime);\n\n    // draw something\n    \n    vec2 p = worldFromScreen(XY);\n    vec2 m = worldFromScreen(iMouse.xy);\n    \n    const vec3 colBG  = vec3(0.2, 0.3, 0.4);\n    const vec3 colFG1 = vec3(1.0, 0.9, 1.0);\n    const vec3 colFG2 = vec3(0.8, 0.9, 0.6);\n    const vec3 colFG3 = vec3(0.4, 0.5, 0.6);\n    \n    float gutter = min(100.0, iResolution.x * 0.06);\n    \n    // c2 = the moving circle\n    vec2  c2 = iMouse.x <= gutter ? vec2(cos(gTime * 1.1), sin(gTime * 0.9)) * 0.7 : m;\n    float r2 = 0.3;\n    \n    // c1 = the stationary circle\n    vec2  c1 = vec2(0.0);\n    float r1 = 0.3;\n    float my = iMouse.y / iResolution.y * 3.0;\n    if (iMouse.x <= 1.0) {\n        r1 = r2;\n    }\n    else if (iMouse.x <= gutter) {\n        if (my < 1.0) {\n            r1 = mix(0.0, r2, my);\n        }\n        else if (my < 2.0) {\n            r1 = r2;\n        }\n        else {\n            r1 = mix(r2, 1.0 / sqrt(2.0), my - 2.0);\n        }\n        \n    }\n    \n    // c3 = same as c1, but twice the area and static.\n    vec2  c3 = c1;\n    float r3 = r1 * sqrt(2.0);\n    \n    // d = the distance from center to center\n    float d = length(c2 - c1);\n    \n    // R = r1 + r2\n    float R12 = r1 + r2;\n    \n    // i = gap between boundaries. (> 0 = apart, < 0 = overlap)\n    float i = d - R12;\n    i = max(i, -2.0 * min(r1, r2));\n    \n    // i1 = overlap contributed by truncated circle c1\n    // i2 = overlap contributed by truncated circle c2\n    // i1 + i2 = i.\n    float i1 = i * r2 / R12;\n    float i2 = i * r1 / R12;\n    \n    // a1 = overlap area from c1. (guessing at formula)\n    // a2 = overlap area from c2. (guessing at formula)\n    float a1 = PI * r1 * i1;\n    float a2 = PI * r2 * i2;\n    \n    a1 = min(0.0, a1);\n    a2 = min(0.0, a1);\n    \n    // adjust radii to account for additional area, if any.\n    r1 = sqrt((PI * r1 * r1 - a1) / PI);\n    r2 = sqrt((PI * r2 * r2 - a2) / PI);\n   \n    vec3 col = colBG;\n    if (XY.x < gutter) {\n        float tmp = iMouse.y;\n        if (iMouse.x > gutter || (iMouse.y / iResolution.y * 3.0 > 1.0 && iMouse.y / iResolution.y * 3.0 < 2.0)) {\n            tmp = iResolution.y / 2.0;\n        }\n        if (XY.y / iResolution.y * 3.0 < 1.0 || XY.y / iResolution.y * 3.0 > 2.0) {\n            col *= 1.1;\n        }\n        col *= 1.0 + 0.3 * smoothstep(2.5, -2.5, abs(XY.y - tmp));\n    }\n    col *= 1.0 + 0.3 * smoothstep(2.5, -2.5, abs(XY.x - gutter));\n    \n    if (sdDisk(p - c1, r1) < 0.0 && sdDisk(p - c2, r2) < 0.0) {\n        col *= 1.0 + (int(XY.y) % 10 < 3 ? 0.5 : 0.0);\n    }\n\n    // disk of twice r1, for reference.\n    drawDisk(col, colFG3, p, c3, r3);\n    \n    drawDisk(col, colFG1, p, c1, r1);\n    drawDisk(col, colFG2, p, c2, r2);\n    \n    \n    \n    RGBA = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "const float PI  = 3.14159265359;\nconst float TAO = PI * 2.0;\n\n// global time parameter\nfloat gTime;\n\nvec2  gCanvasRes;\nfloat gCanvasSmallRes;\nfloat gZoom;\nfloat gScreenFromWorldFac;\nfloat gWorldFromScreenFac;\nfloat gSmoothEps;\n\n// set up world coordinates where a unit circle fits\n// in the smallest dimension of the canvas, plus a zoom factor.\nvoid setupCoords(in vec2 canvasResolution, in float zoom) {\n\n    gCanvasRes = canvasResolution;\n\n    // the smallest dimension of the canvas\n    gCanvasSmallRes = min(canvasResolution.x, canvasResolution.y);\n    \n    // small = shrink\n    gZoom = zoom;\n    \n    // factor to get from world scale to screen scale\n    gScreenFromWorldFac = gZoom * gCanvasSmallRes / 2.0;\n    \n    // factor to get from screen scale to world scale\n    gWorldFromScreenFac = 1.0 / gScreenFromWorldFac;\n    \n    // pixel epsilon for smoothstep\n    gSmoothEps = gWorldFromScreenFac * 2.5;\n}\n\nvec2 worldFromScreen(in vec2 screenPt) {\n    return (screenPt - gCanvasRes / 2.0) * gWorldFromScreenFac;;\n    \n}\n\n// in case we want to speed or slow down things from iTime.\n// this needs to be called in each pass.\nvoid setupTime(in float time) {\n    gTime = time;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXSD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 139, 139, 167], [169, 169, 208, 208, 240], [242, 242, 296, 296, 360], [362, 362, 447, 447, 643]], "test": "untested"}
{"id": "NsXXWN", "name": "Northern Warbler", "author": "TEttinger", "description": "Another Northern Lights shader; this one has much less frequent sine-wave patterns than Northern Journey did before it, and tends to form fluid shapes.", "tags": ["noise", "plasma", "color", "abstract", "lights", "northern"], "likes": 10, "viewed": 443, "published": 3, "date": "1618615651", "time_retrieved": "2024-07-30T19:25:42.266744", "image_code": "// CC0 licensed, do what thou wilt.\n\n// change the seed to any not-too-huge float and the colors/shapes will change.\nconst float SEED = 420.69; // starts off nicely.\nconst vec3 COEFFS = fract((SEED + 23.4567) * vec3(0.8191725133961645, 0.6710436067037893, 0.5497004779019703)) + 0.5;\n\n// what's different here is mostly how swayRandomized() incorporates the x, y, and z of seed and value for each component.\nvec3 swayRandomized(vec3 seed, vec3 value)\n{\n    return sin(seed.xyz + value.zxy - cos(seed.zxy + value.yzx) + cos(seed.yzx + value.xyz));\n}\n\n// this function, if given steadily-increasing values in con, may return exponentially-rapidly-changing results.\n// even though it should always return a vec3 with components between -1 and 1, we use it carefully.\nvec3 cosmic(vec3 c, vec3 con)\n{\n    con += swayRandomized(c, con.yzx);\n    con += swayRandomized(c + 1.0, con.zxy);\n    con += swayRandomized(c + 2.0, con.xyz);\n    return con * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 64.0 + swayRandomized(COEFFS.zxy, (iTime * 0.1875) * COEFFS.yzx).xy * 32.0;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.0625;\n    vec3 adj = vec3(-1.11, 1.41, 1.61);\n    vec3 s = (swayRandomized(vec3(34.0, 76.0, 59.0), aTime + adj)) * 0.25;\n    vec3 c = (swayRandomized(vec3(27.0, 67.0, 45.0), aTime - adj)) * 0.25;\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    \n    con = cosmic(COEFFS, con);\n    con = cosmic(COEFFS, con);\n    con = cosmic(COEFFS, con);\n    \n    fragColor = vec4(swayRandomized(COEFFS + 3.0, con * (3.14159265)) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 408, 452, 452, 548], [550, 764, 795, 795, 949], [951, 951, 1008, 1058, 1734]], "test": "untested"}
{"id": "fsXSWN", "name": "Atomic Energy", "author": "Tater", "description": "code is messy, I know. copy pasted from bonzomatic. \noriginally made during cookie collective live stream. ", "tags": ["raymarch", "glow"], "likes": 14, "viewed": 421, "published": 3, "date": "1618612962", "time_retrieved": "2024-07-30T19:25:43.110488", "image_code": "float donut(vec3 p, vec2 t){ return length(vec2(length(p.xz)-t.x,p.y))-t.y;}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define MAX_DIST 250.0\n#define STEP 128.0\nfloat g1 = 0.;\nvec2 Dist(vec3 p){\n  vec2 a = vec2(donut(p,vec2(1,0.5)),2.0);\n  vec2 b = vec2(length(p+vec3(0,1.0-abs(sin(iTime))*3.0,0))-0.5,1.0);\n  g1 += 0.01/(0.01+b.x*b.x);\n  b = (b.x < a.x) ? b:a;\n  return b;\n}\nvoid invert(inout float inv, float t, vec2 uv, float cap){\ninv = mix(inv,1.0-inv,step(sin(length(uv)*0.45-t)*0.5+0.6,cap));\n}\nvec2 Dist2(vec3 p){\n  float t= mod(iTime,200.0);\n  t = fract(t)*fract(t)+floor(t);\n  vec3 p2 = p;\n  \n  float modd = 42.0;\n  vec3 id = floor((p2+modd*0.5)/modd);\n  t+= id.x*2.0;\n  t+= id.z*2.0;\n  p2.yz*=rot(sin(t)*0.2);\n  p2.y +=sin(id.x+t)*12.0;\n  p2 = mod(p2+modd*0.5,modd)-modd*0.5;\n  p2.xy*=rot(t*(mod(abs(id.x),3.0)-1.0));\n  p2.zy*=rot(-t*0.5*(mod(abs(id.z),3.0)-1.0));\n  for(int i = 0; i < 4; i++){\n    p2 = abs(p2)-vec3(2,1,1);\n    p2.xy *=rot(0.5);\n    p2.zy *=rot(0.5+sin(t)*2.0);\n    p2.zx *=rot(0.5);\n  }\n  \n  return Dist(p2)*vec2(0.65,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n  float t = mod(iTime,200.0);\n  vec3 ro = vec3(t*3.0,0,-30);\n  vec3 rd = normalize(vec3(uv,1.05));\n  float dO = 0.0;\n  float shad = 0.0;\n  vec2 obj;\n  for(float i = 0.0; i <STEP; i++){\n    vec3 p = ro + rd*dO;\n    obj = Dist2(p);\n    dO += obj.x;\n    if(obj.x <0.001|| dO>MAX_DIST){\n      shad = i/STEP;\n      break;\n    }\n  }\n \n  vec3 col = vec3(0);\n \n  if(obj.y == 1.0){\n    shad= 1.0-shad;\n    col = vec3(shad)*vec3(0.2,0.5,0.8);\n  }\n  if(obj.y == 2.0){\n    shad= shad;\n    col = vec3(shad)*vec3(0.8,0.2,0.9);\n  }\n  col += g1*vec3(0.2,0.5,0.8)*0.2;\n  col = mix(col,vec3(0.235,0.075,0.369)*0.2,clamp(dO/MAX_DIST,0.0,1.0));\n  t = 0.6*t-2.0;\n  float inv = 0.0;\n  invert(inv,t,uv,0.5);\n  invert(inv,t,uv,0.466);\n  invert(inv,t,uv,0.433);\n  invert(inv,t,uv,0.4);\n  invert(inv,t,uv,0.366);\n  \n  col = mix(col*1.6,1.0-col,inv);\n  fragColor = vec4(min(col,1.0),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 76], [184, 184, 202, 202, 383], [384, 384, 442, 442, 509], [510, 510, 529, 529, 1063], [1064, 1064, 1121, 1121, 2043]], "test": "untested"}
{"id": "NdlSD8", "name": "Overstimulated Neurons", "author": "Chaotnix", "description": "Fork of \"Abstract Glassy Field\" by Shane. https://shadertoy.com/view/4ttGDH\n\n", "tags": ["raymarch", "refraction", "glass", "blob", "glow", "audioreactive", "soundcloud"], "likes": 7, "viewed": 940, "published": 3, "date": "1618608170", "time_retrieved": "2024-07-30T19:25:44.137742", "image_code": "// Fork of \"Abstract Glassy Field\" by Shane. https://shadertoy.com/view/4ttGDH\n\n\n/*\n\n\tAbstract Glassy Field\n\t---------------------\n\n\tAn abstract, blobby-looking field - rendered in the style of hot, glowing glass. It was \n\tproduced using cheap low-budget psuedoscience. :)\n\n\tThe surface was constructed with a spherized sinusoidal function, of sorts. I like it, because \n\tit's very cheap to produce, mildly reminiscent of noise and allows a camera to pass through it \n\twithout having to resort to trickery.\n\n\tThe fluid filled glass look is fake, but at least interesting to look at. Basically, it was\n\tproduced by indexing the reflected and refracted surface rays into a 3D tri-planar texture\n\tlookup. By the way, I've tried the real thing on this particular surface - with multiple ray \n\tbounces and so forth - and to say it's slower is an understatement. :)\n\n\tBy the way, if anyone is aware of some cheap and simple improvements, corrections, etc, feel\n\tfree to let me know.\n\n*/\n\n#define FAR 50. // Far plane, or maximum distance.\n\n//float objID = 0.; // Object ID\n\nfloat accum; // Used to create the glow, by accumulating values in the raymarching function.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.zy).xyz;\n    vec3 ty = texture(t, p.xz).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n// Camera path.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    //return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec3(s*12., 0., t);\n    \n    float a = sin(t * 0.11);\n    float b = cos(t * 0.14);\n    return vec3(a*4. -b*1.5, b*1.7 + a*1.5, t);\n    \n}\n\n\n// A fake, noisy looking field - cheaply constructed from a spherized sinusoidal\n// combination. I came up with it when I was bored one day. :) Lousy to hone in\n// on, but it has the benefit of being able to guide a camera through it.\n/*\nfloat map(vec3 p){\n \n    p.xy -= camPath(p.z).xy; // Perturb the object around the camera path.\n    \n     \n\tp = cos(p*.315*1.25 + sin(p.zxy*.875*1.25)); // 3D sinusoidal mutation.\n    \n    \n    float n = length(p) + 0.001* texture(iChannel0, p.xy ).x ; // Spherize. The result is some mutated, spherical blob-like shapes.\n\n    // It's an easy field to create, but not so great to hone in one. The \"1.4\" fudge factor\n    // is there to get a little extra distance... Obtained by trial and error.\n    return (n - 1.025)*2.33;\n    \n}\n*/\n\n\n// Alternative, even more abstract, field.\nfloat map(vec3 p){\n    \n    p.xy -= camPath(p.z).xy; // Perturb the object around the camera path.\n   \n\tp = cos(p*.1490 + sin(p.zxy*.4375)); // 3D sinusoidal mutation.\n    \n    // Spherize. The result is some mutated, spherical blob-like shapes.\n    float n = dot(p, p); \n    \n    p = sin(p*3.+cos(p.yzx*12.)); // Finer bumps. Subtle.\n    \n    return (n - p.x*p.y*p.z*.35 - .9)*1.33 + 0.001 * texture(iChannel0, p.xy ).x ; // Combine, and we're done.\n    \n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.35/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0.3, 1.);    \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(vec3 p){\n\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n                          map(p + e.yxy) - map(p - e.yxy), map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;\n        \n        // Simple distance-based accumulation to produce some glow.\n        if(abs(h)<.35) accum += (.35-abs(h))/24.;\n        \n    }\n\n    return min(t, FAR);\n}\n\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 24; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.01, 0.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.4, 1.0); \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n\n// Simple environment mapping.\nvec3 envMap(vec3 rd, vec3 n){\n    \n    vec3 col = tpl(iChannel0, rd*4., n);\n    return smoothstep(0.4, .7, col/2.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 3.;\n    vec3 o = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .25);  // \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 2.) + vec3(0, 1, 0); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/2.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    //vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    r = normalize(vec3(r.xy, (r.z - length(r.xy)*.125)));\n\n\n    // Raymarch.\n    float t = trace(o, r);\n    \n    // Save the object ID directly after the raymarching equation, since other equations that\n    // use the \"map\" function will distort the results. I leaned that the hard way. :)\n    //float sObjID = objID;\n\n    // Initialize the scene color to the background.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position.\n        vec3 p = o + r*t;\n\t\t\n        // Normal.\n        vec3 n = nr(p);\n        \n        // Sometimes, it's handy to keep a copy of the normal. In this case, I'd prefer the\n        // bumps on the surface to not have as much influence on the reflrection and \n        // refraction vectors, so I tone down the bumped normal with this. See the reflection\n        // and refraction lines.\n        vec3 svn = n;\n        \n        // Texture bump the normal.\n        float sz = 1./3.; \n        n = db(iChannel0, p*sz, n, .1/(1. + t*.25/FAR));\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n\n        \n        float at = 1./(1. + d*.05 + d*d*.0125); // Light attenuation.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 16.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.), 64.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), .0, 1.); // Fresnel reflection term.\n \n         \n        \n        // Texturing - or coloring - the surface. The \"color\"' of glass is provide by the surrounds...\n        // of it's contents, so just make it dark.\n        vec3 tx = vec3(.05); // tpl(vec3(0.,0.,0.), p*sz, n);\n         \n\n\t\t// Very simple coloring.\n        col = tx*(di*.1 + ao*.25) + vec3(.5, .7, 1)*sp*2. + vec3(1, .7, .4)*pow(fr, 8.)*.25;\n \n        // Very cheap, and totally fake, reflection and refraction. Obtain the reflection and\n        // refraction vectors at the surface, then pass them to the environment mapping function.\n        // Note that glass and fluid have different refractive indices, so I've fudged them into \n        // one figure.\n        //vec3 refl = envMap(normalize(reflect(r, svn*.5 + n*.5)), svn*.5 + n*.5);\n        //vec3 refr = envMap(normalize(refract(r, svn*.5 + n*.5, 1./1.35)), svn*.5 + n*.5);\n        \n        \n\t\t// You can also index into a 3D texture, but I prefer the above.\n        vec3 refl = texture(iChannel0, 0.2* normalize(reflect(r, svn*.5 + n*.5)).xy).xyz;\n        vec3 refr = texture(iChannel0, 0.2* normalize(refract(r, svn*.5 + n*.5, 1./1.31)).xy).xyz;\n        refl *= refl*.3;\n        refr *= refr*.4;\n        \n        \n        // More fake physics that looks like real physics. :) Mixing the reflection and refraction \n        // colors according to a Fresnel variation.\n        vec3 refCol = mix(refr, refl, pow(fr, 5.)); //(refr + refl)*.5; // Adding them, if preferred.\n        \n        // Obviously, the reflected\\refracted colors will involve lit values from their respective\n        // hit points, but this is fake, so we're just combining it with a portion of the surface \n        // diffuse value.\n        col += refCol*((di*di*.25+.75) + ao*.25)*1.5; // Add the reflected color. You could combine it in other ways too.\n        \n        // Based on IQ's suggestion: Using the diffuse setting to vary the color slightly in the\n        // hope that it adds a little more depth. It also gives the impression that Beer's Law is \n        // taking effect, even though it clearly isn't. I might try to vary with curvature - or some other\n        // depth guage - later to see if it makes a difference.\n        col = mix(col.xzy, col, di*.85 + .15); \n        \n        // Glow.\n        // Taking the accumulated color (see the raymarching function), tweaking it to look a little\n        // hotter, then combining it with the object color.\n        vec3 accCol = vec3(1, .3, .1)*accum;\n        vec3 gc = pow(min(vec3(1.5, 1, 1)*accum, 1.), vec3(1, 2.5, 12.))*.5 + accCol*.5;\n        col += col*gc*12.;\n        \n        \n        // Purple electric charge.\n        float hi = abs(mod(t/1. +  0.02 * texture(iChannel0, p.xy ).x, 8.) - 8./2.)*2.;\n        vec3 cCol = vec3(.01, .05, 1)*col*1./(.001 + hi*hi*.2);\n        col += mix(cCol.yxz, cCol, n3D(p*3.));\n \t\t// Similar effect.\n        //vec3 cCol = vec3(.01, .05, 1)*col*abs(tan(t/1.5 + iTime/3.));\n        //col += cCol;\n \n        \n        // Apply some shading.\n        col *= ao*sh*at;\n\n        \n    }\n    \n    \n    // Blend in a bit of light fog for atmospheric effect.\n    vec3 fog = vec3(.125, .04, .05)*(r.y*.5 + .5);    \n    col = mix(col, fog, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n\n    \n    // Subtle vignette.\n    u = fragCoord/iResolution.xy;\n    col = mix(vec3(0), col, pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125)*.5 + .5);\n\n \n    \n    // Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n    \n}", "image_inputs": [{"id": 26677, "src": "https://soundcloud.com/lyfsuxx/iwannabeyourgirlfriend", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlSD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1162, 1314, 1335, 1335, 1401], [1404, 1562, 1608, 1608, 2116], [2119, 2135, 2157, 2353, 2471], [3248, 3291, 3309, 3309, 3748], [3752, 3904, 3937, 3937, 4180], [4183, 4283, 4299, 4299, 4485], [4489, 4510, 4546, 4546, 5120], [5123, 5135, 5211, 5211, 5795], [5798, 5880, 5935, 5935, 6434], [6436, 6579, 6597, 6597, 6943], [6947, 6978, 7007, 7007, 7095], [7098, 7098, 7154, 7188, 13158]], "test": "untested"}
{"id": "fdXSD4", "name": "Day 485[4d projected apollonian]", "author": "jeyko", "description": "uuh", "tags": ["fractal", "projection", "4d", "apollonian", "mdtmjvm"], "likes": 9, "viewed": 413, "published": 3, "date": "1618607715", "time_retrieved": "2024-07-30T19:25:44.914664", "image_code": "// My bro Nameless explained 4d projection/rendering to me,\n// so I needed to render an apollonian in it. fun stuff.\n\n// here follows my interpretation of his explanation\n\n// 2d creatures see a line\n// 3d creatures see a 2d array, projected by cam z\n// 4d creatrues see a 3d grid, projected by cam w\n\n\n// what i've done here is construct a 3d grid of 2d slices.\n// each slice is a full raymarch into 4d space, projected by the w\n// this just means that instead of doing\n// rd = normalize(vec3(uv,1));\n// we do\n// rd = normalize(vec3(uv,sliceIdx/sliceCnt,1));\n// that's really about all there is to it. in the end we project the 3d grid perspectively to our 2d shadertoy screen.\n\n// this code is probably not a good learning resource though.\n\n\n\n// Performance vars\n\nfloat sliceCnt = 60.;\nfloat marchSteps = 30.;\nfloat dMult = 0.4;\n\n\n// Coeff vars\n\nfloat rotSpd = 0.5;\nfloat fov4D = 0.5;     // scale up the sliceZDepth when widening the fov\nfloat sliceZDepth = 1.; \nfloat minT = 10e5;\n\nfloat normalEps = 0.02;\nfloat distEps = 0.01;\nfloat distOffs = -0.01;\n\nfloat ditherAmt = 1.;\n\n#define DEBUG 0\n#define TUBES 1\n\n\nfloat ld(vec3 p){\n\n    #if TUBES\n        return length(p);\n    #else\n        return max(abs(p.x),max(abs(p.y),abs(p.z)));\n    #endif\n}\nfloat ld(vec2 p){\n    #if TUBES\n        return length(p);\n    #else\n        return max(abs(p.x),abs(p.y));\n    #endif\n}\nfloat ld(float p){\n    return p;\n}\nvec2 sdApollonian(vec4 p){\n    vec2 d = vec2(10e5,0.);\n    \n    float sc = 1.;\n    \n    for(float i = 0.; i < 4.; i++){\n        //p = abs(p);\n        p = pmod(p,vec4(1.5 + 0.5*iMouse.y/iResolution.y));\n        \n        float dpp = dot(p,p );\n        p /= dpp; sc /=dpp;\n        \n     \n    }\n    p /= sc;\n\n    d = dmin(d,ld(p.zxw) - 0.001 );\n    //d = dmin(d,length(p.y) - 0.00 );\n    \n    d = dmin(d,ld(length(p)) - 0.001 );\n    \n    return d;\n}\n\nvec2 map(vec4 p){\n    \n    \n    p -= 0.5 ;\n    p.x += sin(iTime*0.5)*0.;\n    \n    //p.wz *= rot(1.4);\n    //p.yw *= rot( -iTime*0.4);\n    \n    p.xw *= rot( iTime*0.5*rotSpd);\n    p.wz *= rot( iTime*0.7*rotSpd );\n    \n    p.yw *= rot( iTime*0.5*rotSpd);\n    p.xz *= rot( iTime*0.7 *rotSpd);\n    \n    //p += 0.2 ;\n    \n    //p -= 0.5 ;\n    \n    //p.yw *= rot( -iTime*0.15);\n\n    vec2 d = sdApollonian(p);\n     \n    return d;\n}\n\nvec4 getNormal(vec4 p){\n    vec2 t = vec2(normalEps,0.00);\n    return normalize(map(p).x-vec4(\n        map(p-t.xyyy).x,\n        map(p-t.yxyy).x,\n        map(p-t.yyxy).x,\n        map(p-t.yyyx).x));\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*vec2(172.412,735.124)+uv.yx*vec2(97.354,421.653)+vec2(94.321,37.365)),vec2(4.6872,7.9841))+0.71243);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    muv *= 6.28;\n\n    vec3 col = vec3(0);\n\n\n    #if DEBUG\n    \n        vec3 gro = vec3(sin(muv.x),0,cos(muv.x))*sliceZDepth*1.5;\n        vec3 grd = normalize(vec3(uv,1));\n\n        gro.yz *= rot(-muv.y);\n        grd.yz *= rot(-muv.y);\n        grd.xz *= rot(-muv.x);\n\n    #endif\n    \n    \n    bool hitAtLeastOnce = false;\n    float dither = texture(iChannel1, fragCoord / 1024.0f).r*ditherAmt*2. - 0.5*ditherAmt;\n        \n    for(float slice = 0.; slice < sliceCnt; slice++){\n          \n        #if DEBUG\n            vec3 sliceUv = gro + grd * plaIntersect( gro + vec3(0,0,1)*slice/sliceCnt*1.*sliceZDepth , grd, vec4(0,0,-1,0) );\n        #else\n            vec2 sliceUv = uv*(1. + slice/sliceCnt);\n        #endif\n        \n        \n        vec4 rd = normalize(vec4(sliceUv.xy,sliceZDepth*((slice + dither)/sliceCnt - 0.5),fov4D));\n        \n        vec4 p = vec4(0); \n       \n        bool hit = false;\n        vec2 d;\n        float glow = 0.;\n        float t = 0.;\n        \n        for(float st = 0.; st < marchSteps; st++){\n            d = map(p);\n            d.x += distOffs;\n            if(d.x < distEps){\n                hit = true;\n                break;\n            } else if (t > 3.5){\n                //t = 10.;\n                break;\n            }\n            \n            d.x *= dMult;\n            t += d.x;\n            p += rd*d.x;\n        }\n        \n\n          \n        const vec3 fogCol = vec3(0.6,0.6,0.56)*1.;\n        if(hit && t < minT){\n            minT = t;\n            hitAtLeastOnce = true;\n            vec4 n = getNormal(p); \n            \n            col = (pal(0.5,0.5*vec3(1.+ sin( p.w*6.)*0.,1.,1.),vec3(0.4,1.,1.5),1.,4.*dot(n,rd)));\n            col = pow(abs(col),vec3(1.8));\n            col *= AO(1.)*AO(0.3)*AO(0.1)*AO(0.05);\n            \n            \n            col = mix(col,fogCol,smoothstep(0.,1.,(t)*.46- 0.6));\n            }\n        else{\n            if(!hitAtLeastOnce)\n                col = fogCol;\n        }\n        \n    }\n    \n    // reinhardt and sutff\n    col = 1./(1. + 1./col);\n    //col = 1. - exp(-col*1.);\n    col = ACESFilm(col);\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + e))\n\n#define AO(a) smoothstep(0.,1.,map(p+n*a).x/a)\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.,1.);\n}\n/*\nvec4 getNormala(vec4 p){\n    vec2 t = vec2(0.0004,0.00);\n    return normalize(vec4(\n        map(p+t.xyyy).x - map(p-t.xyyy).x,\n        map(p+t.yxyy).x - map(p-t.yxyy).x,\n        map(p+t.yyxy).x - map(p-t.yyxy).x,\n        map(p+t.yyyx).x - map(p-t.yyyx).x));\n}\n*/\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nfloat sdBox(vec4 p, vec4 s){p = abs(p) - s; return max(p.x,max(p.y,max(p.z,p.w)));}\n\n\nfloat sdBoxEdges(vec4 p, vec4 s, float edgeW){\n    float d = sdBox(p, s);\n    \n    float cuttingEdgeW = edgeW*1.;\n    //d = abs(d);\n    d = max(d, -sdBox(p, s - vec4(-cuttingEdgeW,edgeW,edgeW,edgeW)));\n    d = max(d, -sdBox(p, s - vec4(edgeW,-cuttingEdgeW,edgeW,edgeW)));\n    d = max(d, -sdBox(p, s - vec4(edgeW,edgeW,-cuttingEdgeW,edgeW)));\n    d = max(d, -sdBox(p, s - vec4(edgeW,edgeW,edgeW,-cuttingEdgeW)));\n    \n    \n    return d;\n}\n\n\n#define max4v(v) max(max(v.x, v.y), max(v.z, v.w))\n#define min4(x,y,z,w) min(min(x, y), min(z, w))\n\n\n#define dmin(d,b) d.x < b ? d : vec2(b,d.y + 1.)\nfloat sdTesseractFrame( vec4 p, vec4 b, float e ) { \n  p = abs(p)-b; \n  vec4 q = abs(p+e)-e; \n  mat4 t = mat4(\n        p.x, q.y, q.z, q.w,\n        q.x, p.y, q.z, q.w,\n        q.x, q.y, p.z, q.w,\n        q.x, q.y, q.z, p.w\n  );\n  return min4(\n        length(max(t[0], 0.0)+min(max4v(t[0]),0.0)),\n        length(max(t[1], 0.0)+min(max4v(t[1]),0.0)),\n        length(max(t[2], 0.0)+min(max4v(t[2]),0.0)),\n        length(max(t[3], 0.0)+min(max4v(t[3]),0.0))\n  );\n}\n\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1113, 1113, 1130, 1130, 1247], [1248, 1248, 1265, 1265, 1367], [1368, 1368, 1386, 1386, 1402], [1403, 1403, 1429, 1429, 1848], [1850, 1850, 1867, 1867, 2274], [2276, 2276, 2299, 2299, 2474], [2476, 2476, 2496, 2496, 2625], [2628, 2628, 2685, 2685, 4950]], "test": "untested"}
{"id": "wsdXDM", "name": "Random Population", "author": "pyBlob", "description": "Beautiful random noise caused by mutations in growing cells.\n\nclick+drag: punch holes", "tags": ["mouse", "random", "cellular", "automaton"], "likes": 17, "viewed": 334, "published": 3, "date": "1618604890", "time_retrieved": "2024-07-30T19:25:45.680616", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z >= .0)\n    \tif (length(fragCoord - abs(iMouse.zw)) < length(iMouse.xy - abs(iMouse.zw)))\n    \t\tfragColor = mix(fragColor, vec4(.3), .5);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// https://www.shadertoy.com/view/4djSRW\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvoid test(inout vec4 id, ivec2 x)\n{\n    if (x == ivec2(0))\n        return;\n    if (id.w != 0.)\n        return;\n    vec4 next = texelFetch(iChannel0, x, 0);\n    if (next.w == 0.)\n        return;\n    vec3 pos = vec3(x,iTime);\n    vec4 blob = hash43(pos);\n    if (blob.w > 3e-1)\n        return;\n    vec3 delta = .1 * (blob.xyz - .5);\n    id = vec4(clamp(next.xyz + delta, vec3(0), vec3(1)), 1.);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(82, 1), 0).x>0.)\n    {\n        ivec2 xy = ivec2(fragCoord.xy) - ivec2(iResolution.xy/2.);\n        fragColor = vec4(0);\n        if (xy == ivec2(0,0))\n            fragColor = vec4(.5, .5, .5, 1);\n        return;\n    }\n    ivec2 x = ivec2(fragCoord);\n    if (x == ivec2(0))\n    {\n        fragColor = iMouse;\n        return;\n    }\n    vec4 id = texelFetch(iChannel0, x, 0);\n    test(id, x+ivec2(0, 1));\n    test(id, x+ivec2(1, 0));\n    test(id, x-ivec2(0, 1));\n    test(id, x-ivec2(1, 0));\n    fragColor = id;\n    vec4 lastMouse = texelFetch(iChannel0, ivec2(0), 0);\n    if (lastMouse.z >= .0 && iMouse.z < .0)\n        if (length(fragCoord - abs(lastMouse.zw)) < length(lastMouse.xy - abs(lastMouse.zw)))\n            fragColor = vec4(0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 271]], "test": "untested"}
{"id": "7dsSWH", "name": "hnzdl cg-msu v5v6", "author": "hnzdl", "description": "icosahedron with a drop of water\n+  \n+    - \n", "tags": ["cgmsu"], "likes": 0, "viewed": 247, "published": 3, "date": "1618603214", "time_retrieved": "2024-07-30T19:25:46.629080", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float INF = 1e9;\nconst float SPHERE_R = 1.0;\n\nconst vec3 CAMERA_POS = vec3(-1.6, 1.4, -6);\n\nconst vec3 LIGHT1_POS = vec3(-3, 1.5, 5);\nconst float LIGHT1_RADIUS = 0.5;\nconst vec3 LIGHT1_COLOR = vec3(0, 1, 1);\n\nconst vec3 LIGHT2_POS = vec3(1, 0.8, 2);\nconst float LIGHT2_RADIUS = 0.25;\nconst vec3 LIGHT2_COLOR = vec3(0.1, 1, 0.2);\n\nconst vec3 LIGHT3_POS = vec3(3, 1.5, -2);\nconst float LIGHT3_RADIUS = 0.15;\nconst vec3 LIGHT3_COLOR = vec3(2.0, 0.5, 0.8);\n\nvec3 randDir;\n\n\n//  20   12 \n\nfloat MARCH_SIZE = 0.01;\nint MAX_STEPS = 50;\nvec3 FOG_COLOR = vec3(0, 1, 1);\nfloat ABSORPTION = 10.0;\n\nvec3 vertexes[12] = vec3[12]\n   (vec3(-0.588235,0.9517647,0),\n    vec3(0.588235,0.9517647,0),\n    vec3(-0.588235,-0.9517647,0),\n    vec3(0.588235,-0.9517647,0),\n    vec3(0,-0.588235,0.9517647),\n    vec3(0,0.588235,0.9517647),\n    vec3(0,-0.588235,-0.9517647),\n    vec3(0,0.588235,-0.9517647), \n    vec3(0.9517647,0,-0.588235),\n    vec3(0.9517647,0,0.588235),\n    vec3(-0.9517647,0,-0.588235),\n    vec3(-0.9517647,0,0.588235));\n\nint triangles[3*20] = int[60]\n    (1,5, 0,\n    1, 8, 9,\n    2, 4, 3,\n    2,10,11,\n    4, 9, 3,\n    4,11,5,\n    5, 9, 4,\n    5,11,0,\n    6, 2, 3,\n    6, 7,10,\n    7,1, 0,\n    7, 6, 8,\n    8, 1, 7,\n    8, 6, 3,\n    9, 5,1,\n    9, 8, 3,\n    10,2, 6,\n    10,7, 0,\n    11,10,0,\n    11,4,2);\n\n// (CAMERA_POS + t * viewVec).y == -1\n// t = (-1 - CAMERA_POS.y) / viewVec.y;\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir,out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.5) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nfloat traceTriangle(vec3 pos, vec3 dir, vec3 x1, vec3 x2, vec3 x3, out vec3 normal){\n    vec3 diff1 = x2 - x1;\n    vec3 diff2 = x3 - x1;\n    float det = dot(diff1, cross(dir, diff2));\n    if (det < 1e-9 && det > -1e-9)\n        return INF;\n    float u = dot(pos - x1, cross(dir, diff2))/det;\n    if (u < 0.0 || u > 1.0) \n        return INF;\n    float v = dot(dir, cross(pos - x1, diff1))/det;\n    if (v < 0.0 || u + v > 1.0)\n        return INF;\n    float k = dot(diff2, cross(pos - x1, diff1))/det;\n    normal = normalize((x1 + x2 + x3) / 3.0); \n    if (k <= 0.0) \n        return INF;\n    return k;\n}\n\nfloat traceIcosahedron(vec3 pos, vec3 dir, out vec3 normal){\n    float t = INF;\n    vec3 cur_norm;\n    for (int i = 0; i<20; i++){\n        vec3 x1 = vertexes[triangles[i*3 + 0]];\n        vec3 x2 = vertexes[triangles[i*3 + 1]];\n        vec3 x3 = vertexes[triangles[i*3 + 2]];\n        float cur_t = traceTriangle(pos, dir, x1, x2, x3, cur_norm);\n        if (cur_t < t) {\n            t = cur_t;\n            normal = cur_norm;\n        }\n    }\n    return t;\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n     vec3 icoNorm;\n    float icoT = traceIcosahedron(pos, dir, icoNorm);\n    if (icoT < dist) {\n        return true;\n    } \n    \n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT  < dist);\n    \n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : 20.0f / distSq1;\n    \n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : 10.0f / distSq2;\n    \n    vec3 toLight3 = LIGHT3_POS - pos;\n    float distSq3 = dot(toLight3, toLight3);\n    float att3 = isOccluded(pos, LIGHT3_POS + randDir * LIGHT3_RADIUS) ? 0.0 : 7.0f / distSq3;\n    \n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + max(0.0, dot(normal, normalize(toLight3))) * att3 * LIGHT3_COLOR\n        + texture(iChannel1, normal).rgb * 0.1\n    );\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) \n        normal = -normal;\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.0) {\n        return reflect(v, normal);\n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return (sinB * tang + cosB * normal);\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)*2.0) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    float mult = 1.0;\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    const float DIAMOND_N = 2.5;\n    const float AIR_N = 1.0;\n    const float GLASS_N = 1.5;\n    float n1 = AIR_N;\n    float DIAMOND_R = pow2(AIR_N - DIAMOND_N) / pow2(AIR_N + DIAMOND_N);\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i <10; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel3, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n        }\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n        if (light1T < t) {\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n        if (light2T < t) {\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n        vec3 l3Norm;\n        float light3T = traceSphere(curPos - LIGHT3_POS, curDir, LIGHT3_RADIUS, l3Norm);\n        if (light3T < t) {\n            t = light3T;\n            materialType = EMISSION;\n            color = LIGHT3_COLOR;\n            normal = l3Norm;\n        }\n        //cmp+option+J\n        //gShaderToy.SetTexture(0, {mSrc:'https://upload.wikimedia.org/wikipedia/commons/5/5e/Water_drop_001.jpg', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n        //   \n        //     \n        vec3 sphNorm;\n        float sphT = traceSphere(curPos, curDir, 0.3, sphNorm);\n        if (sphT < t) {\n            t = sphT;\n            vec3 worldPos1 = curPos + t*curDir;\n            color = texture(iChannel0, worldPos1.xz * worldPos1.y).rgb * vec3(1, 0.75, 0.5);\n            normal = sphNorm;\n            materialType = DIFFUSE;\n        }\n        vec3 icoNorm;\n        float icoT = traceIcosahedron(curPos, curDir, icoNorm);\n        if (icoT < t) {\n            t = icoT;\n            normal = icoNorm;\n            if (randVals.x < GLASS_R*5.0) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.5,0.5,1.25);\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                }\n                else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            vec3 worldPos = curPos + t * curDir;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb * vec3(1, 0.75, 0.5);\n            normal = cylNorm;\n            materialType = DIFFUSE;\n        }\n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, nEnter);//nEnter\n                curPos = worldPos + curDir * 1e-5;\n                n1 = nEnter;\n            }\n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n            \n        }\n    }\n}\n\n", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 234]], "test": "untested"}
{"id": "wtGyzw", "name": "Fire Iteration", "author": "abhinavneelam", "description": "Creating fire using noise sampling", "tags": ["fire"], "likes": 1, "viewed": 256, "published": 3, "date": "1618595197", "time_retrieved": "2024-07-30T19:25:47.399022", "image_code": "#define PI 3.14159\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat texture0(vec2 uv)\n{\n    return texture(iChannel0, uv).x;\n}\n\nfloat rangestep(float px, float py, float x)\n{\n    float f3 = abs(px-py);\n    \n    float f4 = 2.0/f3;\n    \n    return -clamp(floor(abs((f4* (x-f3/2.0 - px)))),0.0,1.0)+1.0;\n}\n\nvec3 back(vec2 uv)\n{\n    float a = (noise(30.0*uv)*.5+.5);\n    \n    float or= 3.0;\n    \n    uv -= vec2(0.02,0.2);\n    uv*=vec2((0.75-0.70) * (.5*sin(or*iTime)+.5) + 0.7\n                    ,(0.55-0.48) * (.5*sin(or*iTime)+.5) + 0.48);\n    uv += vec2(0.13,0.0);\n    \n    float ss = 0.7*(1.0-smoothstep(.7,1.2, 2.2*distance(vec2(0.5,0.0),1.1*uv)));\n    \n    float w1 = 2.0 * noise(vec2(iTime,iTime))*.5+.5;\n    \n    float w2 = (1.0/8.0)*max(floor(6.0*w1),0.0);\n\n    vec3 col = 0.4*ss*vec3(1.0,0.0,0.0) * vec3(w2+noise(9.0*uv)*.5+.5);\n    \n    return col;\n}\n\nvec3 rgb(vec3 c)\n{\n    return c/255.0f;\n}\n\nvec2 rotatePoint(float angle, vec2 p)\n{\n    float si = sin(angle);\n    float co = cos(angle);\n    \n    return mat2( co, -si, si, co) * p;\n}\n\nvec3 particles(vec2 uv)\n{\n    float POINTS = 8.0;\n    \n    vec3 c = vec3(0.0);\n    float t = iTime;\n    \n    for(float i = 0.0;i<POINTS;i++)\n    {\n        float radius = 0.12;\n        radius = 0.2;\n        \n        float adif = 3.;\n        adif=10.;\n        \n        float rot;\n        //rot = (-PI/adif - PI/adif)*(.5*sin(t)+.5) + PI/adif;\n        \n        vec2 rand;\n        rand.x = texture0(vec2(i,i) / vec2(POINTS));\n        rand.y = texture0(vec2(rand.x));\n        \n        rand.y = mod(rand.y+t*8.5, 1.0);\n        \n        radius = (0.25-0.12) * (rand.y) + 0.12;\n        \n        float rx = rand.x = (0.9-0.1) * rand.x + 0.1;\n        float ry = rand.y = 60.0 * (1.0-0.0) * rand.y + 0.0;\n        \n        float rc = 9.0 * texture0(vec2(rand.x, rand.y));\n        \n        rot = (-PI/adif - PI/adif) * rand.x + PI/adif;\n        \n        vec2 p = rotatePoint(rot, rand-uv);\n        float pl = length(p);\n        \n        float cl = length(cross(vec3(0.0,1.0,0.), vec3(p,0.)));\n        \n        float clthres = 0.001;\n        \n        vec3 color = mix(rgb(vec3(255,40,0)),rgb(vec3(255,140,0)), rc);\n        \n        if(pl < radius && cl < clthres)\n            c += color * smoothstep(0.1 + radius, 0.1, (1./radius)*distance(uv,rand));\n    }\n    //rot, color, pos, \n\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = back(uv);\n    \n    float time = iTime;\n    //time=1.0;\n    \n    float iuv = 0.9*uv.y;\n    float box = rangestep(.3,.7,uv.x) * rangestep(.0,.9,uv.y);\n    //box=1.0;\n    \n    float b1 = 0.3 * sin(time) + 0.7;\n    float turby = 0.5 * uv.y * sin(5.0*time) + 1.0;\n    \n    float bad = 0.2*b1*noise(vec2(5.0*uv.x, uv.y)) + 0.4*turby*noise(vec2(0.8*uv.x+time,uv.y));\n    float turbx = uv.x + bad;\n    \n    float tempdist = distance(vec2(0.5,0.0),vec2(uv));\n    tempdist = 0.7*(1.0-smoothstep(vec2(0.0, 0.1).y, vec2(0.5,1.11).y,0.5* tempdist));\n    \n    vec3 orange = vec3(247.f, 103.f, 7.f) / 255.f;\n    vec3 col2 = tempdist*8.9 * orange * vec3((noise(25.0*vec2(turbx,0.15*uv.y - 0.3 * time)) * .5 + .5));\n    \n    vec2 p = uv + vec2(-0.5,-0.5+0.4);\n    p.x *= iResolution.x/iResolution.y;\n    \n    float v = smoothstep(-1.0, 1.2, 1.1*1.5*length(p) - 0.3);\n    //v=0.f;\n    col = mix(col2, col, v);\n    \n    //col = particles(uv);\n    //col += particles(uv)-col;\n    \n    col+=particles(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGyzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 42, 42, 181], [183, 183, 205, 205, 609], [611, 611, 636, 636, 675], [677, 677, 723, 723, 851], [853, 853, 873, 873, 1407], [1409, 1409, 1427, 1427, 1450], [1452, 1452, 1491, 1491, 1591], [1593, 1593, 1618, 1618, 2876], [2878, 2878, 2933, 2933, 4011]], "test": "untested"}
{"id": "sdsSD8", "name": "Team Omega", "author": "mrange", "description": "License CC0: Team Omega\nI recently joined a new team called Team Omega. I like making \"team shaders\" so created one. It's a \"remix\" of previous shaders so now nothing ground breaking.  After 27 seconds you seen all this shader has to offer :)\n", "tags": ["2d"], "likes": 14, "viewed": 437, "published": 3, "date": "1618592899", "time_retrieved": "2024-07-30T19:25:48.171955", "image_code": "// License CC0: Team Omega\n// I recently joined a new team called Team Omega. I like making \"team shaders\" so created one. \n// It's a \"remix\" of previous shaders so now nothing ground breaking. \n// After 27 seconds you seen all this shader has to offer :)\n// Song: Omega by vowl. https://soundcloud.com/vowlmusic/omega\n#define TIME        mod(iTime, 198.0)\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TTIME       (TAU*TIME)\n#define PSIN(x)     (0.5+0.5*sin(x))\n\nconst float corner0 = 0.02;\nconst float corner1 = 0.075;\nconst float topy    = 0.0475+corner0*0.5;\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// See Art of Code: Hexagonal Tiling Explained!\n// https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n  \n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = mix(p2, p1, vec2(dot(p1, p1) < dot(p2, p2)));\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)/2.0;\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat vmax(vec2 v) {\n  return max(v.x, v.y);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat corner(vec2 p) {\n  return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n\n// Distance fields by IQ\n// https://iquilezles.org/articles/distfunctions2d\nfloat roundedBox(vec2 p, vec2 b, vec4 r) {\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat parallelogram(vec2 p, float wi, float he, float sk) {\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p)-r;\n}\n\nvec2 refl(vec2 p, vec2 n) {\n  p -= n*min(0.0, dot(p, n))*2.0;\n  return p;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// Smooth min by IQ\n// https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) { \n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) { \n  return pmax(a, -a, k);\n}\n\nfloat omega(vec2 p) {\n  const float lw = 0.07;\n  const float sm = 0.066;\n  p.x = abs(p.x);\n  vec2 p0 = p;\n  p0.y -= 0.075;\n  float d0 = circle(p0, 0.36);\n  d0 = abs(d0)-lw;\n\n  vec2 p1 = p;\n  p1 -= vec2(0.175, -0.445);\n  p1.y = -p1.y;\n  p1  = refl(p1, normalize(vec2(1.0)));\n  float d1 = parallelogram(p1, 0.31, lw, 0.04);\n  \n  vec2 p2 = p;\n  float d2 = p2.y+0.20;\n  d1 = pmax(d1, d2, sm);\n  \n  vec2 p3 = p;\n  float d3 = min(-p3.y+0.075, -p3.x+0.105);\n  d0 = pmax(d0, d3, sm);\n\n  vec2 p4 = p;\n  p4 -= vec2(0.175, -0.445)-vec2(lw);\n  float d4 = length(p4);\n  d1 = sign(p4) == vec2(-1.0) ? d4 : d1;\n  \n  float d = d0;\n  d = min(d, d1);\n//  d = min(d, d4);\n  \n  return d;\n}\n\nfloat df(vec2 p) {\n  return omega(p);\n}\n\nfloat height_(vec2 p) {  \n  p *= 0.25;\n  vec2 p0 = p;\n  vec2 n0 = hextile(p0);\n  float h = hash(n0);\n  p0 *= ROT(TAU*h);\n  const float ss = 0.625;\n  float d0 = omega(p0/ss)*ss;\n  float d = d0;\n  d -= 0.02;\n  const float aa = 0.02;\n  float a = fract(127.0*h) > 0.5 ? 0.125 : -0.25;\n  return a*tanh_approx(smoothstep(aa, -aa, d));\n}\n\nfloat height(vec2 p) {\n  const mat2 rot1 = ROT(1.23);\n  float tm = 123.0+TTIME/320.0;\n  p += 5.0*vec2(cos(tm), sin(tm*sqrt(0.5)));\n  const float aa = -0.33;\n  const mat2  pp = (1.0/aa)*rot1;\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  \n  float tm2 = 0.5*TIME;\n  h += 1.0*sin(0.75*tm2+dot(normalize(vec2(-1.0, 1.5)), 4.0*p));\n  h += 0.5*sin(tm2+dot(normalize(vec2(1.0, 1.0)), 7.0*p));\n  h += 0.25*sin(1.25*tm2+dot(normalize(vec2(-2, 1.0)), 13.0*p));\n  h += 1.75;\n  h*= 0.2;\n  \n  for (int i = 0; i < 5; ++i) {\n    h += a*height_(p);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }  \n  const float hf = -0.125;\n  return hf*(h/d)+hf;\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nfloat synth(vec2 p) {\n  const float z = 4.0;\n  const float st = 0.02;\n  float dob = box(p, vec2(1.55, 0.5));\n  p.x = abs(p.x);\n  p.x += st*20.0;\n  p /= z;\n  float n = mod1(p.x, st);\n  float dib = 1E6;\n  const int around = 1;\n  for (int i = -around; i <=around ;++i) {\n    float fft = texture(iChannel0, vec2((n+float(i))*st*1.5, 0.25)).x; \n    float dibb = box(p-vec2(st*float(i), 0.0), vec2(st*0.25, 0.05*fft+0.001));\n    dib = min(dib, dibb);\n  }\n  \n  float dl = p.y;\n  dl = abs(dl) - 0.005;\n  dl = abs(dl) - 0.0025;\n  dl = abs(dl) - 0.00125;\n  float d = dib;\n  d = max(d, -dl);\n  d = pmax(d, dob, 0.025);\n  return d*z;\n}\n\nfloat omega_a(vec2 p) {\n  p.x = abs(p.x);\n  float db = roundedBox(p, vec2 (0.19, 0.166), vec4(corner1, corner0, corner1, corner0));\n  float dc = corner(p-vec2(0.045, -0.07))-corner0;\n  \n  float d = db;\n  d = max(d, -dc);\n  \n  return d;\n}\n\nfloat omega_e(vec2 p) {\n  p.y = abs(p.y);\n  float db = roundedBox(p, vec2 (0.19, 0.166), vec4(corner1, corner0, corner1, corner0));\n  float di = roundedBox(p-vec2(0.175, topy), vec2 (0.25, corner0), vec4(corner0));\n  \n  float d = db;\n  d = max(d, -di);\n  return d;\n}\n\nfloat omega_g(vec2 p) {\n  float db = roundedBox(p, vec2 (0.19, 0.166), vec4(corner0, corner1, corner1, corner1));\n  float dc = corner(-(p-vec2(-0.045, -0.057)));\n  dc = abs(dc) - corner0;\n  float dd = max(p.x-0.065, p.y-topy-corner0);\n  float d = db;\n  d = max(d, -max(dc, dd));\n  return d;\n}\n\nfloat omega_m(vec2 p) {\n  float db = roundedBox(p, vec2 (0.255, 0.166), vec4(corner1, corner0, corner0, corner0));\n  p.x = abs(p.x);\n  float dl = abs(p.x-0.095)-corner0*2.0;\n  float dt = p.y-topy;\n  \n  float d = db;\n  d = max(d, -max(dl,dt));\n  \n  return d;\n}\n\nfloat omega_o(vec2 p) {\n  float db = roundedBox(p, vec2 (0.19, 0.166), vec4(corner1));\n  float di = roundedBox(p, vec2 (0.19, 0.166)*0.45, vec4(corner0));\n  float d = db;\n  d = max(d, -di);\n  return d;\n}\n\nfloat omegaText(vec2 p) {\n  vec2 pn = p;\n  pn.y -= topy;\n  float dn = abs(pn.y)-corner0;\n  p.x += 0.95;\n  \n  vec2 po = p;\n  po.x += 0.0;\n  float do_ = omega_o(po);\n\n  vec2 pm = p;\n  pm.x -= 0.51;\n  float dm = omega_m(pm);\n\n  vec2 pe = p;\n  pe.x -= 1.02;\n  float de = omega_e(pe);\n\n  vec2 pg = p;\n  pg.x -= 1.465;\n  float dg = omega_g(pg);\n\n  vec2 pa = p;\n  pa.x -= 1.91;\n  float da = omega_a(pa);\n\n  \n  float d = 1E6;\n  d = min(d, do_);\n  d = min(d, dm);\n  d = min(d, de);\n  d = min(d, dg);\n  d = min(d, da);\n  d = max(d, -dn);\n\n  return d;\n}\n\nfloat beat() {\n  float beat = 0.0;\n  const float samples = 5.0;\n  const float st = 0.01;\n  for (float i = 0.0; i < samples; ++i) {\n    beat += texture(iChannel0, vec2(st*1.0+st*i, 0.25)).x; \n  }\n  return smoothstep(0.66, 1.0, beat/samples);\n}\n\nvec3 color(vec2 p) {\n  vec2 ppp = p;\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float aa = 2.0/RESOLUTION.y;\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, mix(-3.0, -10.0, PSIN(TIME+PI*p.x)), 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  const vec3 lcol1 = sqrt(vec3(1.25, 1.35, 2.0).zxy*0.15);\n  const vec3 lcol2 = vec3(2.0, 1.55, 1.25).zyx*0.85;\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.25*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh_approx(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*pow(diff1, 4.0)*lpow1;\n  col += dm*pow(diff2, 4.0)*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 20.0)*lcol1;\n  col += rm*pow(ref2, 20.0)*lcol2;\n  col *= smoothstep(6.0, 14.0, TIME);\n  \n  float ds = synth(ppp-vec2(0.0, -0.75));\n  float beat = beat();\n\n  const float zp = 1.35;\n  \n  vec2 op = ppp;\n  op.x += -0.25*ppp.y;\n  op /= zp;\n  float di = omegaText(op);\n  di *= zp;\n  float dio = di;\n  dio -= 0.025;\n  dio = abs(dio) - 0.005;\n  di = pmin(di, dio, 0.025);\n  di = min(di, ds);\n  float dg = di;\n\n  float off = -0.3 + 0.75*p.x-p.y;\n  float angle = -0.5+off-TTIME/16.0;\n\n  float gmix = pow(PSIN(angle), 14.0);\n  float gmix2 = mix(1.0, abs(1.0/(mod(angle, PI)-PI*0.5)), beat*smoothstep(1.75, 1.55, abs(off)));\n  col += -lcol2*0.25*(exp(-9.0*max(di, 0.0)));\n \n  dg = abs(dg-0.025);\n  float glow = exp(-20.0*max(dg+0., 0.0));\n  vec3 glowCol = mix(lcol2.zyx*lcol2.zyx/6.0, lcol2.zyx, glow*glow)*gmix2;\n  col = mix(col, vec3(mix(vec3(0.9), sqrt(glowCol*0.5), gmix)), smoothstep(-aa, aa, -di));\n  col += glowCol*glow*gmix;\n\n  return col;\n}\n\n// Post processing I found somewhere on shadertoy years ago\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  float aa = 2.0/RESOLUTION.y;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = color(p);  \n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(1.0, 4.0, TIME);\n  col *= 1.0-smoothstep(180.0, 198.0, TIME);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 26669, "src": "https://soundcloud.com/vowlmusic/omega", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsSD8.jpg", "access": "api", "license": "cc0-1.0", "functions": [[707, 707, 728, 728, 795], [797, 892, 920, 920, 1241], [1243, 1243, 1271, 1291, 1367], [1369, 1369, 1389, 1389, 1415], [1417, 1448, 1470, 1470, 1530], [1533, 1609, 1651, 1651, 1808], [1810, 1810, 1837, 1837, 1917], [1919, 1919, 1978, 1978, 2320], [2322, 2322, 2353, 2353, 2377], [2379, 2379, 2406, 2406, 2454], [2456, 2487, 2526, 2526, 2651], [2653, 2713, 2752, 2752, 2845], [2847, 2847, 2886, 2886, 2916], [2918, 2918, 2948, 2948, 2976], [2978, 2978, 2999, 2999, 3647], [3649, 3649, 3667, 3667, 3688], [3690, 3690, 3713, 3713, 4020], [4022, 4022, 4044, 4044, 4656], [4658, 4658, 4679, 4679, 4885], [4887, 4887, 4908, 4908, 5510], [5512, 5512, 5535, 5535, 5749], [5751, 5751, 5774, 5774, 6017], [6019, 6019, 6042, 6042, 6311], [6313, 6313, 6336, 6336, 6572], [6574, 6574, 6597, 6597, 6777], [6779, 6779, 6804, 6804, 7321], [7323, 7323, 7337, 7337, 7565], [7567, 7567, 7587, 7587, 9617], [9619, 9679, 9715, 9715, 9948], [9950, 9950, 10005, 10005, 10337]], "test": "untested"}
{"id": "NssSW8", "name": "Earth atmosphere from space ", "author": "FabriceNeyret2", "description": "Mouse controls Sun direction\n\nstill ultra-far from this ref ;-)\n[img]https://www.pausecafein.fr/images/cafein/2021/03/foutrement-interessant/coucher-soleil.jpg[/img]", "tags": ["earth", "atmosphere", "short"], "likes": 14, "viewed": 554, "published": 3, "date": "1618574522", "time_retrieved": "2024-07-30T19:25:48.938904", "image_code": "#define C(z)   exp(- 1./vec4(1,.6,.4,1) * H/(z) )        // spectral transmittance for optical depth z\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 1.2* ( 2.*u - R ) / R.y,\n         M = 1.2* ( 2.*iMouse.xy - R ) / R.y;\n\n    float H = .1,                                          // atmosphere thickness ralative to radius\n          r = dot(U,U),\n          d = dot(M,M),\n          t = -.3*iTime,\n          l = dot( vec3(U, sqrt(1.-r)),                    // hit point in Sun frame\n                   iMouse.z > 0.             \n                     ? vec3(M,sqrt(abs(1.-d))*sign(1.-d))  // Sun direction\n                     : vec3(cos(t)*vec2(cos(-.5),sin(-.5)),sin(t))\n                 );\n   \n    O = r < 1. ? ( 1.- C( sqrt(1.-r) )  )                  // atmosphere opacity along ray\n      * smoothstep(-sqrt(2.*H),0.,l) * smoothstep(1.,1.-16./R.y,r) // up to terminator + AA\n                + mix( l * vec4(.4,.4,1,0) ,               // ocean color\n                       2.5*C(max(0.,l)),                   // Sun color seen by clouds and reflected to space\n                       texture(iChannel0,U/vec2(5,1)+vec2(-t/20.,0)).r*smoothstep(1.,0.,abs(U.y))    // cloud layer\n                     )\n               : vec4(0);  \n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssSW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 142, 142, 1265]], "test": "untested"}
{"id": "sd2GDG", "name": "sphere_sphere", "author": "dark_dashas", "description": "sphere", "tags": ["sphere"], "likes": 2, "viewed": 253, "published": 3, "date": "1618567483", "time_retrieved": "2024-07-30T19:25:49.885374", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, screenUV) / float(iFrame + 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float PI = 3.14159265359;\n\nfloat MARCH_SIZE = 0.1;\nint MAX_STEPS = 100;\nfloat ABSORPTION = 0.5;\n\nconst float INF = 1e10;\nconst float EPS = 1e-3;\n\nconst float GLASS_N = 1.5;\nconst float AIR_N = 1.0;\n\nconst int EMISSION = 0;   // , \nconst int DIFFUSE = 1;    // \nconst int REFLECTION = 2; // \nconst int REFRACTION = 3; // \n\nstruct Sphere {\n    vec3 pos;\n    vec3 color;\n    float rad;\n    float intensity;\n    int material;\n};\nstruct Plane {\n    float pos;\n    int material;\n};\nstruct Cylinder {\n    float pos;\n    float rad;\n    int material;\n};\nstruct Intersection {\n    float dist;\n    vec3 normal;\n    vec3 color;\n    int material;\n};\n\nconst uint LIGHTS_COUNT = 3u;\nSphere LIGHTS[LIGHTS_COUNT];\n\nSphere SPHERE;\nCylinder CYL;\nPlane PLANE;\n\nconst vec3 CAMERA_POS = vec3(0, 1.2, -6);\n\nfloat rand(float frame) {\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n/////////////////////////INTERSECTION_FUNC////////////////////////////\n\nfloat tracePlane(vec3 pos, vec3 dir, float planePos, out vec3 normal)  {\n\n    normal = vec3(0.0, 1.0, 0.0);\n    \n    float t = (planePos - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 60.0) {\n        return INF;\n    }\n    \n    return t;\n}\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n     \n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    \n    if (D < 0.0) {\n        return INF;\n    }\n    \n    float t = (-b - sqrt(D));\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    \n    t = (-b + sqrt(D));\n    if (t < 0.0) {\n        return INF;\n    }\n    \n    normal = normalize(pos + t * dir);\n    return t;\n}\nfloat traceCylinder(vec3 pos, vec3 dir, float cylPos, float r, out vec3 normal) {\n\n    float t = (cylPos - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < r * r) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - r * r;\n    \n    float D = b * b - a * c;\n    \n    if (D < 0.0) {\n        return INF;\n    }\n    \n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= cylPos) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    \n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    \n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    \n    return INF;\n}\n\n////////////////////////////OCCLUSION///////////////////////////////\n\nbool isOccluded(vec3 pos, vec3 target) {\n\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir = dir / dist;\n    \n    vec3 normal = vec3(0, 0, 0);\n    \n    float t = traceSphere(pos - SPHERE.pos, dir, SPHERE.rad, normal);\n    if (dist >= t) {\n        return true;\n    }\n    \n    vec3 cylNormal = normal;\n    t = traceCylinder(pos, dir, CYL.pos, CYL.rad, cylNormal);\n    return (t > 0.0 && dist >= t);\n}\n\n////////////////////////////REFRACTION//////////////////////////////\n\nvec3 refraction(vec3 dir, vec3 normal, float n1, float n2) {\n\n    if (dot(dir, normal) < 0.0) {\n        normal = -normal;\n    }\n    \n    float cosA = dot(dir, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    \n    vec3 tang = normalize(dir - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    \n    if (sinB > 1.0) {\n        return reflect(dir, normal);\n    }\n    \n    float cosB = sqrt(1.0 - sinB * sinB);\n    \n    return sinB * tang + cosB * normal;\n}\n\n////////////////////////////MINECRAFT///////////////////////////////\n\nfloat ABSORBTION = 10.0;\nvec3 minecraft (in vec2 w) {\n\n    vec3 d = vec3(w, 1) / iResolution - 0.5;\n    vec3 p, c, f;\n    vec3 g = d; \n    vec3 o = vec3(0.2, 0.0, 8.0);\n    o.y = 3.0 * cos(o.x * o.z);\n    vec3 y = vec3(1, 2, 0);\n\n    for (float i = 0.0; i < 9.0; i += 0.01) {\n        o += d * i * 0.01;\n        c = o;\n        f = fract(c);\n        p = floor(c) * 0.3;\n        if (cos(p.z) + sin(p.x) > ++p.y) {\n\t    \tg = (f.y - 0.04 * cos((c.x + c.z) * 40.0) > 0.8 ? y : f.y * y.yxz) / i;\n            break;\n        }\n    }\n    \n    return g.rgb;\n}\nfloat pow2(float x) {\n    return x * x;\n}\nfloat fogSdf(vec3 pos) {\n    return length(pos) - 0.75;\n}\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled) {\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec4 sampleFog(vec3 pos, vec3 dir, in vec2 w) {\n\n    float t = fogSdf(pos);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fogSdf(curPos);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(ABSORBTION * (\n            2.5 * texture(iChannel3, curPos * 0.3 + vec3(1, 1, 0)).x\n            + 1.5 * texture(iChannel3, curPos * 0.1 + vec3(1, 1, 0)).x\n            ) * 0.25 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    \n    vec3 color = minecraft(w);\n    vec3 tmp = rgb2hsv(color);\n    tmp.x /= 1.2;\n    tmp.z *= 3.0;\n    color = hsv2rgb(tmp);\n    color *= 1.2;\n    \n    return vec4(color * totalAbs, 1.0 - opacity);\n}\n\n////////////////////////////LIGHTING////////////////////////////////\n\nvec3 randVals;\nvec3 randDir;\n\nvec3 computeLighting(vec3 pos, vec3 color, vec3 normal, vec3 viewVec) {\n    vec4 lighting = textureLod(iChannel0, viewVec, 10.0) * 0.3;\n\n    vec3 lightPos = LIGHTS[0].pos + randDir * LIGHTS[0].rad;\n    vec3 toLight = lightPos - pos;\n    float sq = dot(toLight, toLight);\n    bool occl = isOccluded(pos + normalize(toLight) * EPS, lightPos);\n    float lightAtten = LIGHTS[0].intensity / sq * (occl ? 0.0 : 1.0);\n    lighting += max(0.0f, dot(normal, normalize(toLight))) * vec4(LIGHTS[0].color, 1.0) * lightAtten;\n\n    lightPos = LIGHTS[1].pos + randDir * LIGHTS[1].rad;\n    toLight = lightPos - pos;\n    sq = dot(toLight, toLight);\n    occl = isOccluded(pos + normalize(toLight) * EPS, lightPos);\n    lightAtten = LIGHTS[1].intensity / sq * (occl ? 0.0 : 1.0);\n    lighting += max(0.0f, dot(normal, normalize(toLight))) * vec4(LIGHTS[1].color, 1.0) * lightAtten;\n\n    lightPos = LIGHTS[2].pos + randDir * LIGHTS[2].rad;\n    toLight = lightPos - pos;\n    sq = dot(toLight, toLight);\n    occl = isOccluded(pos + normalize(toLight) * EPS, lightPos);\n    lightAtten = LIGHTS[2].intensity / sq * (occl ? 0.0 : 1.0);\n    lighting += max(0.0f, dot(normal, normalize(toLight))) * vec4(LIGHTS[2].color, 1.0) * lightAtten;\n\n    return color * lighting.rgb;\n}\n\n//////////////////////////////MAIN//////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    LIGHTS[0].pos =  vec3(-2, 0.5, 2.5);\n    LIGHTS[0].color = vec3(0x3d, 0x96, 0x90)/255.0;\n    LIGHTS[0].rad = 0.5;\n    LIGHTS[0].intensity = 10.0;\n    LIGHTS[0].material = EMISSION;\n    \n    LIGHTS[1].pos =  vec3(1.4, 0.2, 4);\n    LIGHTS[1].color = vec3(0.8, 0.8, 0);\n    LIGHTS[1].rad = 0.15;\n    LIGHTS[1].intensity = 5.0;\n    LIGHTS[1].material = EMISSION;\n    \n    LIGHTS[2].pos =  vec3(2, 1.5, 0);\n    LIGHTS[2].color = vec3(0x6e, 0x9a, 0x44)/255.0;\n    LIGHTS[2].rad = 0.2;\n    LIGHTS[2].intensity = 10.0;\n    LIGHTS[2].material = EMISSION;\n    \n    SPHERE.pos = vec3(0, 0, 0);\n    SPHERE.color = vec3(1, 1, 1);\n    SPHERE.rad = 1.0;\n    \n    PLANE.pos = -1.25;\n    PLANE.material = DIFFUSE;\n    \n    CYL.pos = -1.0;\n    CYL.rad = 0.65;\n    CYL.material = DIFFUSE;\n    \n    vec2 screenUV = fragCoord/iResolution.xy;\n    randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals * 2.0 - 1.0);\n    \n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5) * 2.0)/iResolution.x;\n\n    vec3 forward = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    vec3 viewVec = normalize(forward + uv.x * right + uv.y * up);\n\n    float curN = 1.0;\n    float nextN = GLASS_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float GLASS_T = 1.0 - GLASS_R;\n\n    vec3 currentPos = CAMERA_POS;\n\n    vec3 color;\n    float mult = 1.0;\n\n    for (int i = 0; i < 7; ++i) {\n\n        Intersection INTERSECT;\n        INTERSECT.dist = INF;\n        vec3 normal;\n\n        for (uint i = 0u; i < LIGHTS_COUNT; ++i) {\n             float lightT = traceSphere(currentPos - LIGHTS[i].pos, \n                                         viewVec, LIGHTS[i].rad, normal);\n             if (lightT < INTERSECT.dist) {\n                 INTERSECT.dist = lightT;\n                 INTERSECT.normal = normal;\n                 INTERSECT.material = LIGHTS[i].material;\n                 INTERSECT.color = LIGHTS[i].color;\n             }\n        }        \n        \n        float sphT = traceSphere(currentPos - SPHERE.pos, viewVec, SPHERE.rad, normal);\n        if (sphT <  INTERSECT.dist) {\n             INTERSECT.dist = sphT;\n             INTERSECT.normal = normal;\n             \n             if (randVals.x * 0.5 < GLASS_R * 2.0){\n                INTERSECT.material = REFLECTION;\n             }\n             else {\n                 INTERSECT.material = REFRACTION;\n             }\n         }\n\n        float cylT = traceCylinder(currentPos, viewVec, CYL.pos, CYL.rad, normal);\n        if (cylT < INTERSECT.dist) {\n            INTERSECT.dist = cylT;\n            INTERSECT.normal = normal;\n            INTERSECT.material = CYL.material;\n            vec3 worldPos = currentPos + INTERSECT.dist * viewVec;\n            INTERSECT.color = texture(iChannel1, worldPos.xz * worldPos.y ).rgb;\n        }\n        \n        float planeT = tracePlane(currentPos, viewVec, PLANE.pos, normal);\n        if (planeT < INTERSECT.dist && length(currentPos + planeT * viewVec) < 10.0f) {\n            INTERSECT.dist = planeT;\n            INTERSECT.normal = normal;\n            INTERSECT.material = PLANE.material;\n            vec3 worldPos = currentPos + INTERSECT.dist * viewVec;\n            INTERSECT.color = texture(iChannel2, worldPos.xz * 0.1).rgb;\n            \n            \n            if (randVals.x < 0.2) {\n                INTERSECT.material = REFLECTION;\n            }\n            \n        }\n\n        if (INTERSECT.dist != INF) {\n        \n            vec3 worldPos = currentPos + INTERSECT.dist * viewVec;\n            \n            if (INTERSECT.material == EMISSION) {\n                fragColor.rgb = INTERSECT.color;\n                break;\n            }\n            else if (INTERSECT.material == DIFFUSE) {\n                fragColor.rgb  += mult * computeLighting(worldPos, INTERSECT.color, INTERSECT.normal, viewVec);\n                break;\n            }\n            else if (INTERSECT.material == REFLECTION) {\n                viewVec = reflect(viewVec, INTERSECT.normal);\n                currentPos = worldPos + viewVec * EPS;\n            }\n            else if (INTERSECT.material == REFRACTION) {\n                viewVec = refraction(viewVec, INTERSECT.normal, curN, nextN);\n                currentPos = worldPos + viewVec * EPS;\n                \n                float tmp = curN;\n                curN = nextN;\n                nextN = tmp;\n                \n                vec4 fog = sampleFog(currentPos, viewVec, fragCoord);\n                fragColor.rgb += fog.rgb * fog.a * mult;\n                mult *= 1.0 - fog.a;\n            }\n         }\n         else {\n            fragColor += mult * texture(iChannel0, viewVec) * 0.8;\n            break;\n         }\n\n    }\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenUV = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, screenUV) + texture(iChannel1, screenUV);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2GDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 171]], "test": "untested"}
{"id": "7dXSDH", "name": "Mercedes 500K", "author": "dr2", "description": "Loosely based on 1:8 scale model and simplified (since the original has almost 2400 parts)", "tags": ["car", "classic"], "likes": 16, "viewed": 366, "published": 3, "date": "1618564660", "time_retrieved": "2024-07-30T19:25:50.848798", "image_code": "// \"Mercedes 500K\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (=0/1) optional antialiasing (can be slow)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrFlatCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nvec3 sunDir, qHit, qTrHit, wlBase, carPos;\nvec2 wlRot;\nfloat tCur, dstFar, wlRad, strRot, carRot, dInt, dWarch, colCode;\nint idObj, idTrObj;\nbool isSh;\nconst int idBod = 1, idTyr = 2, idHub = 3, idDash = 4, idWarch = 5, idBase = 6, idExR = 7,\n   idExF = 8, idWscrn = 9, idSeat = 10, idStWhl = 11, idPlat = 12, idMLit = 13, idCLit = 14,\n   idSLit = 15, idRLit = 16, idAx = 17, idShin = 18, idLtSil = 19, idDkSil = 20;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = (id); }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = (id);  qHit = q;}\n#define DMINQTR(id) if (d < dMin) { dMin = d;  idTrObj = (id);  qTrHit = q;}\n\nfloat WheelDf (vec3 q, float dMin)\n{\n  float d;\n  d = max (PrRoundCylDf (q, wlRad - 0.05, 0.05, 0.15), 0.5 - length (q.xy));\n  DMINQ (idTyr);\n  d = min (PrCylDf (q, 0.5, 0.13), PrCylDf (q, 0.2, 0.17));\n  DMINQ (idHub);\n  return dMin;\n}\n\nfloat CarExDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  vec2 s;\n  float d, r, h, dw, t;\n  q = p;\n  d = PrCylDf (vec3 (q.x, abs (q.y) - 0.07, q.z - 2.7).yzx, 0.04, 1.55);\n  DMIN (idAx);\n  d = PrCylDf (vec3 (abs (abs (q.x) - 1.11) - 0.19, q.y, q.z - 2.7).xzy, 0.06, 0.11);\n  DMIN (idAx);\n  d = PrCylDf (vec3 (q.xy, q.z + 2.7).yzx, 0.1, 1.55);\n  DMIN (idAx);\n  q = p;\n  q.xz = abs (q.xz) - wlBase.xz;\n  qq = q;\n  qq.xz = (p.z > 0.) ? Rot2D (qq.xz, - strRot * sign (p.x)) : qq.xz;\n  qq.yz = Rot2D (qq.yz, - ((p.x < 0.) ? wlRot.x : wlRot.y) * sign (p.z));\n  dMin = WheelDf (qq.zyx, dMin);\n  q.x -= -0.1;\n  r = 0.8;\n  r *= (1. + 0.5 * smoothstep (0., 0.3 * r, q.z) * smoothstep (r, -0.2 * r, q.y));\n  h = (p.z > 0.) ? 0.1 * (q.z + 0.4) : 0.;\n  dWarch = PrFlatCapsDf (vec3 (q.x + h, q.yz).yzx, r, 0.35 * (1. - 0.2 * q.z) + 1.1 * h);\n  d = max (max (abs (dWarch) - 0.02, -0.21 - q.y), min (0.9 - length (q.yz), q.x));\n  if (p.z > 0.) d = SmoothMax (d, - max (0.52 - length (vec2 (q.x + 0.15, 0.5 - q.z)), 0.4 - q.z), 0.02);\n  d *= 0.7;\n  DMINQ (idWarch);\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (0.7, -3.5), 0.68 * pi);\n  dw = PrCylDf (q, wlRad + 0.01, 0.15);\n  dMin = WheelDf (q, dMin);\n  q.z -= 0.18;\n  d = min (PrSphDf (q, 0.08), PrCylDf ((q - vec3 (0., 0.12, 0.04)).xzy, 0.03, 0.12));\n  DMIN (idDkSil);\n  q = p;\n  qq = q;\n  qq.z -= -0.5;\n  dInt = PrRoundBoxDf (vec3 (qq.x, qq.y - 0.8, qq.z), vec3 (vec2 (0.85, 1.2) -\n     vec2 (0.03, 0.05) * qq.zx * qq.zx, 0.8).xzy, 0.1);\n  qq.z -= -0.1;\n  h = 0.8 * (1. - smoothstep (0.4, 1.4, - qq.z / 3.5));\n  qq.y -= -0.2 + h;\n  r = 0.3 * (1. + 0.3 * (qq.z - 2.) * (qq.z - 2.) * step (2., qq.z));\n  d = PrRoundBoxDf (qq, vec3 (1.1 - ((qq.z > 0.) ? 0.035 : 0.005) * qq.z * qq.z - r, h - r, 3.5), r);\n  d = SmoothMax (max (d, qq.z - 3.8 + 0.4 * qq.x * qq.x), - dInt, 0.05);\n  qq.y -= -0.8;\n  d = min (d, max (max (length (qq.xy) - 0.15, - qq.y), dInt));\n  d = 0.7 * SmoothMax (max (d, - dWarch), - dw, 0.05);\n  DMINQ (idBod);\n  q = p;\n  q.yz -= vec2 (-0.18, -0.2);\n  d = PrRoundBoxDf (q, vec3 (1.4, 0.01, 3.71), 0.02);\n  d = max (SmoothMin (d, max (PrCylDf (vec3 (q.x, q.y + 0.2, q.z - 2.9).yzx, 0.5, 1.4), 0.03 -\n     q.y), 0.03), - dWarch);\n  DMINQ (idBase);\n  q = p;\n  q -= vec3 (-0.8, 0.4, 1.4);\n  s = sin (-0.1 * pi + vec2 (0.5 * pi, 0.));\n  q.yz = Rot2Cs (q.yz, s);\n  s = Rot2Cs (vec2 (0., 0.15), s);\n  d = PrTorusBxDf (vec3 (q.x, q.y - s.x * sign (q.z), abs (q.z) - s.y), vec3 (0.1, 0.25, 0.2), 0.08);\n  DMINQ (idExF);\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (1.6, 0.8), 0.15 * pi);\n  q.z -= -0.05 * abs (q.x);\n  d = PrRoundBoxDf (q, vec3 (0.95, 0.4, 0.005), 0.015);\n  d = 0.9 * max (d, - PrRoundBox2Df (vec2 (abs (q.x), q.y) - vec2 (0.45, 0.1), vec2 (0.4, 0.24), 0.02));\n  DMIN (idWscrn);\n  q.x = abs (q.x);\n  d = PrCylDf ((q - vec3 (0.3, -0.18, 0.03)).yzx, 0.02, 0.2);\n  DMIN (idLtSil);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.7, -0.25, -3.);\n  d = max (abs (PrCapsDf (q, 0.06, 1.4)) - 0.02, -1.4 - q.z);\n  DMINQ (idExR);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1., 1.05, 0.3);\n  d = PrTorusBxDf (q.xzy, vec3 (0.08, 0.1, 0.03), 0.02);\n  DMIN (idShin);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.05, 1.4, 0.85);\n  d = max (PrSphDf (q, 0.1), q.z - 0.05);\n  DMINQ (idSLit);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.3, 1.2, 2.9);\n  d = max (max (PrSphDf (q, 0.1), q.z - 0.05), - dWarch);\n  DMINQ (idSLit);\n  q = p;\n  q.yz -= vec2 (0.6, 3.4);\n  d = max (PrCylDf (q.yzx, 0.02, 1.2), - dWarch);\n  DMIN (idShin);\n  q.y -= 0.14;\n  d = max (PrSphDf (q, 0.14), q.z - 0.04);\n  DMINQ (idCLit);\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.55, 0.11);\n  d = SmoothMax (abs (PrSphDf (q, 0.24)) - 0.01, q.z - 0.08, 0.01);\n  DMINQ (idMLit);\n  q.xy -= vec2 (-0.3, -0.3);\n  t = q.z + 0.2;\n  d = PrCylAnDf (q, 0.03 * (1. + 10. * t * t), 0.01, 0.2);\n  q.z -= -0.18;\n  d = min (d, PrCylDf (q, 0.08, 0.015));\n  DMIN (idShin);\n  q = p;\n  q.x = abs (q.x);\n  q.xz -= vec2 (0.5, -4.37);\n  d = PrCylDf (q, 0.07, 0.03);\n  DMINQ (idRLit);\n  q = p;\n  q.yz -= vec2 (1.5, 2.95);\n  d = PrSphDf (q, 0.11);\n  if (d < 0.05) {\n    d = PrTorusDf (q, 0.016, 0.1);\n    q.xy = Rot2D (q.xy, - pi / 6.);\n    q.xy = Rot2D (q.xy, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n    q.x += 0.05;\n    d = min (d, PrCylDf (q.yzx, 0.016, 0.05));\n    DMIN (idShin);\n  } else dMin = min (dMin, d);\n  q = p;\n  q.z = abs (q.z + 0.41);\n  q.yz -= vec2 (((p.z > 0.) ? -0.25 : -0.1), 3.96);\n  d = PrRoundBoxDf (q, vec3 (0.3, 0.13, 0.01), 0.01);\n  DMINQ (idPlat);\n  return dMin;\n}\n\nfloat CarInDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 s;\n  float d, t;\n  q = p;\n  q.yz -= vec2 (0.3, -0.1);\n  d = PrRoundBoxDf (q, vec3 (0.85, 0.07, 0.3), 0.05);\n  q.yz = Rot2D (q.yz - vec2 (0.5, -0.4), 0.57 * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.85, 0.07, 0.5), 0.05));\n  d = SmoothMax (d, 0.03 - abs (q.x + 0.05), 0.05);\n  DMINQ (idSeat);\n  q = p;\n  q.yz -= vec2 (0.3, -1.15);\n  d = PrRoundBoxDf (q, vec3 (0.8, 0.07, 0.3), 0.05);\n  q.yz = Rot2D (q.yz - vec2 (0.5, -0.4), 0.57 * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.8, 0.07, 0.5), 0.05));\n  DMINQ (idSeat);\n  q = p;\n  t = 0.05 * q.x * q.x;\n  q.yz -= vec2 (1.1 - t, 0.8);\n  d = 0.7 * max (max (PrRoundBox2Df (q.yz, vec2 (0.25 * (1. - t), 0.12), 0.02),\n     - PrCylDf (vec3 (abs (q.x - 0.42) - 0.25, q.y, q.z + 0.12), 0.17, 0.03)), dInt);\n  DMINQ (idDash);\n  q = p;\n  q -= vec3 (0.42, 1.1, 0.35);\n  q.yz = Rot2D (q.yz, -0.15 * pi);\n  d = PrTorusDf (q, 0.02, 0.33);\n  DMIN (idLtSil);\n  d = PrCylDf (q, 0.1, 0.02);\n  DMINQ (idStWhl);\n  s = q.xy;\n  q.xy = Rot2D (q.xy, 0.25 * pi - 8. * strRot);\n  q.xy = (abs (q.x) < abs (q.y)) ? q.xy : q.yx;\n  q.y = abs (q.y) - 0.17;\n  d = PrCylDf (q.xzy, 0.015, 0.17);\n  q.xy = s;\n  q.z -= 0.5;\n  d = min (d, PrCylDf (q, 0.03, 0.5));\n  DMIN (idDkSil);\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (0.2, 0.45), 0.1 * pi);\n  d = PrCylDf (q.xzy, 0.025, 0.4);\n  DMIN (idDkSil);\n  q.y -= 0.4;\n  d = PrSphDf (q, 0.06);\n  DMIN (idLtSil);\n  q = p;\n  q -= vec3 (0.42, 0., 0.65);\n  q.x = (q.x > 0.) ? abs (q.x - 0.25) - 0.08 : q.x + 0.2;\n  q.yz = Rot2D (q.yz, 0.1 * pi);\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.02, 0.1), 0.02);\n  DMIN (idDkSil);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  p.xz = Rot2D (p.xz, carRot);\n  p.yz -= vec2 (carPos.y, wlBase.z);\n  d = PrRoundBoxDf (p - vec3 (0., 0.6, 0.), vec3 (2., 1.4, 4.5), 0.01);\n  if (isSh || d < 0.1) {\n    dMin = CarExDf (p, dstFar);\n    if (dInt < 0.1) dMin = CarInDf (p, dMin);\n    else dMin = min (dMin, dInt);\n  } else dMin = d;\n  return dMin;\n}\n\nfloat ObjDfShEx (vec3 p)\n{\n  float dMin;\n  p.xz = Rot2D (p.xz, carRot);\n  p.yz -= vec2 (carPos.y, wlBase.z);\n  dMin = CarExDf (p, dstFar);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p.xz = Rot2D (p.xz, carRot);\n  p.yz -= vec2 (carPos.y, wlBase.z);\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (1.6, 0.8), 0.15 * pi);\n  q.z -= -0.05 * abs (q.x);\n  d = 0.9 * PrBoxDf (q, vec3 (0.95, 0.4, 0.01));\n  DMINQTR (idWscrn);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.55, 0.83, 3.42);\n  d = PrCylDf (q, 0.24, 0.02);\n  DMINQTR (idMLit);\n  return dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + dHit * rd;\n    d = TrObjDf (p);\n    if (d < 0.0002 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.01, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjSShadowEx (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDfShEx (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.01, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat PlateCol (vec2 s)\n{\n  float d;\n  if (s.x < -0.55) {\n    s.x += 1.3;\n    d = min (PrBox2Df (s, vec2 (0.06, 0.6)), max (abs (PrCaps2Df (s.yx, 0.55, 0.1)) - 0.06, - s.x));\n  } else if (s.x < 0.65) {\n    d = min (PrBox2Df (s, vec2 (0.06, 0.6)), max (abs (PrCaps2Df ((s - vec2 (0.07, 0.3)).yx,\n       0.25, 0.2)) - 0.06, - s.x));\n    s -= vec2 (0.3, -0.3);\n    d = min (d, max (PrBox2Df (Rot2D (s, - pi / 5.), vec2 (0.06, 0.4)), -0.3 - s.y));\n  } else {\n    d = PrBox2Df (vec2 (abs (s.x - 1.4) - 0.2, s.y), vec2 (0.06, 0.6));\n  }\n  return d;\n}\n\nfloat MSymCol (vec2 s)\n{\n  return min (abs (length (s) - 0.1) - 0.02, PrBox2Df (Rot2D (s, 2. * pi *\n     floor (3. * atan (s.y, - s.x) / (2. * pi) + 0.5) / 3.) + vec2 (0.05, 0.), vec2 (0.05, 0.02)));\n}\n\nvec4 CarCol (out vec2 vf, out float refFac)\n{\n  vec4 col4, col4B, col4Ls, col4Ds, col4Uh, col4Ly, col4HiRf;\n  vec2 s;\n  float t;\n  bool loRf;\n  col4B = vec4 (0.5, 0., 0., 0.2);\n  if (colCode > 0.) col4B.rgb = (colCode == 2.) ? col4B.grb : col4B.bgr;\n  col4Ls = vec4 (0.9, 0.9, 0.9, 0.2);\n  col4Ds = vec4 (0.4, 0.4, 0.4, 0.2);\n  col4Uh = vec4 (0.5, 0.3, 0.1, 0.05);\n  col4Ly = vec4 (0.9, 0.9, 0.8, 0.2);\n  col4HiRf = vec4 (0.9, 0.9, 0.9, 0.);\n  vf = vec2 (0.);\n  loRf = false;\n  if (idObj <= idDash) {\n    if (idObj == idBod) {\n      if (dInt < 0.03) {\n        col4 = 0.7 * col4Uh;\n        loRf = false;\n        vf = vec2 (64., 0.5);\n      } else {\n        col4 = col4B;\n        loRf = true;\n      }\n      if (qHit.z > 2.905) {\n        col4 = col4HiRf;\n        if (PrRoundBox2Df (vec2 (abs (qHit.x) - 0.28, qHit.y - 0.6), vec2 (0.05, 0.4), 0.15) < 0.) {\n          col4 *= 0.7;\n          vf = vec2 (64., 0.5);\n        }\n        if (length (qHit.xy + vec2 (0., 0.07)) < 0.04) col4 *= 0.3;\n      } else if (abs (qHit.z + 0.1 * qHit.y - 2.) < 0.8 && abs (abs (qHit.y - 0.7) - 0.15) < 0.07) {\n        col4 = col4Ds;\n        loRf = false;\n        vf = vec2 (64., 0.5);\n      } else if (qHit.y > 0.) {\n        t = (0.4 + 0.6 * smoothstep (0.005, 0.015, abs (PrRoundBox2Df (vec2 (qHit.y - 1.,\n           qHit.z + 0.07 * qHit.y + 0.35), vec2 (0.7, 0.9 - 0.07 * qHit.y), 0.2)))) *\n           (0.7 + 0.3 * smoothstep (0.005, 0.015, abs (PrRoundBox2Df (vec2 (qHit.y - 1.1,\n           qHit.z - 1.95), vec2 (0.85, 0.92), 0.02))));\n        if (abs (qHit.z - 1.95) < 0.93) t *= 0.7 + 0.3 * smoothstep (0.005, 0.015, abs (qHit.x));\n        col4 *= t;\n        if (t < 1.) loRf = false;\n        if (abs (qHit.x) > 0.95) {\n          t = PrRoundBox2Df (vec2 (abs (qHit.y - 0.7) - 0.25, qHit.z + 1.45), vec2 (0.1, 0.01), 0.01);\n          col4 = mix (col4Ds, col4, smoothstep (0., 0.01, t));\n          if (t < 0.) loRf = false;\n        }\n      }\n      if (qHit.z < -1.8) col4 = mix (col4HiRf, col4, smoothstep (0., 0.02,\n         PrRoundBox2Df (vec2 (abs (qHit.x) - 0.8, qHit.z + 2.5), vec2 (0.01, 0.6), 0.02)));\n    } else if (idObj == idTyr) {\n      t = length (qHit.xy);\n      if (t < 0.53) {\n        col4 = col4Ls * (0.5 + 0.5 * step (0., qHit.z));\n      } else {\n        col4 = vec4 (0.15, 0.15, 0.15, 0.);\n        if (t > 0.75) col4 *= 0.5 + 0.5 * abs (step (0., cos (32. * pi * qHit.z)) -\n           step (0.5, mod (64. * atan (qHit.y, - qHit.x) / (2. * pi) + 0.5, 1.)));\n      }\n    } else if (idObj == idHub) {\n      t = length (qHit.xy);\n      col4 = mix (col4Ds, col4HiRf, smoothstep (0., 0.002, abs (t - 0.17) - 0.01));\n      if (qHit.z > 0.) {\n        if (t < 0.15) col4 = mix (col4Ds, col4, smoothstep (0., 0.005, MSymCol (qHit.xy)));\n      } else col4 *= 0.3;\n      if (abs (t - 0.36) < 0.15) {\n        t = 1.;\n        for (float f = -1.; f <= 1.; f += 2.) {\n          s = Rot2D (qHit.xy, f * pi / 24.);\n          t = min (t, smoothstep (0.008, 0.01, abs (abs (dot (s, sin (2. * pi *\n             floor (12. * atan (s.y, - s.x) / (2. * pi) + 0.5) / 12. +\n             vec2 (0., 0.5 * pi)))) - 0.04)));\n        }\n        col4 = mix (col4Ls, 0.5 * col4B, t) * (0.5 + 0.5 * step (0., qHit.z));\n      }\n    } else if (idObj == idDash) {\n      col4 = mix (col4B, 0.8 * col4Uh, smoothstep (0.015, 0.02, abs (abs (qHit.y) - 0.2)));\n      col4 = mix (col4B, col4, smoothstep (0.015, 0.02, abs (PrRoundBox2Df (vec2 (qHit.x + 0.4,\n         qHit.y), vec2 (0.2, 0.1), 0.03))));\n      if (qHit.y > 0.22) {\n        vf = vec2 (64., 0.5);\n      } else {\n        s = vec2 (abs (qHit.x - 0.42) - 0.25, qHit.y);\n        t = length (s);\n        if (t < 0.15) {\n          col4 = vec4 (1., 1., 1., 0.1);\n          if (t > 0.13) col4 *= 0.2;\n          else {\n            if (t > 0.08) col4 *= 0.2 + 0.8 * smoothstep (0.2, 0.25,\n               mod (8. * atan (s.y, - s.x) / (2. * pi), 1.));\n            if (s.y > -0.02) col4 *= 0.2 + 0.8 * smoothstep (0.012, 0.015, abs (s.x));\n          }\n        }\n      }\n    }\n  } else if (idObj <= idPlat) {\n    if (idObj == idWarch) {\n      col4 = col4B * (0.5 + 0.5 * step (0., dWarch));\n      loRf = (dWarch > 0. && (qHit.x > -0.3 || qHit.y > 0.5));\n    } else if (idObj == idBase) {\n      col4 = col4B * (0.9 + 0.1 * step (0., qHit.y) * (cos (64. * qHit.x) - 1.) *\n         step (abs (qHit.z), 2.));\n    } else if (idObj == idExR) {\n      col4 = (qHit.z < - 1.2) ? col4HiRf : col4Ds;\n      if (qHit.z < 1.3) col4 *= 0.1 + 0.9 * step (0.07, length (qHit.xy));\n    } else if (idObj == idExF) {\n      col4 = mix (col4Ds, col4HiRf, step (-0.4, sin (48. * atan (qHit.y, - qHit.x))));\n    } else if (idObj == idWscrn) {\n      col4 = col4HiRf;\n    } else if (idObj == idSeat) {\n      col4 = col4Uh * (0.95 + 0.05 * cos (64. * qHit.x));\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idStWhl) {\n      col4 = mix (col4Ds, col4Ls, smoothstep (0., 0.004, MSymCol (Rot2D (1.5 * qHit.xy,\n         - pi / 6. - 8. * strRot))));\n    } else if (idObj == idPlat) {\n      col4 = mix (0.5 * col4B, vec4 (0.7, 0.7, 0.2, 0.2), step (0., qHit.z) * \n         (1. - smoothstep (0.02, 0.03, PlateCol (7. * qHit.xy))));\n    }\n  } else {\n    if (idObj == idMLit) {\n      col4 = mix (col4Ds, col4HiRf, smoothstep (0.01, 0.02, abs (qHit.z - 0.05)));\n      if (length (qHit) < 0.24 && qHit.z < -0.22) col4 = col4Ds;\n    } else if (idObj == idCLit) {\n      col4 = col4HiRf;\n      t = length (qHit.xy);\n      if (qHit.z > 0. && t < 0.12) {\n        col4 = col4Ly * (0.9 + 0.1 * cos (256. * t));\n        loRf = true;\n      }\n    } else if (idObj == idSLit) {\n      col4 = (qHit.z > 0. && length (qHit.xy) < 0.08) ? col4Ly : col4HiRf;\n    } else if (idObj == idRLit) {\n      col4 = (qHit.z < 0. && length (qHit.xy) < 0.05) ? vec4 (1., 0., 0., 0.2) : col4HiRf;\n    } else if (idObj == idAx) {\n      col4 = 0.7 * col4Ds;\n    } else if (idObj == idShin) {\n      col4 = col4HiRf;\n    } else if (idObj == idLtSil) {\n      col4 = col4Ls;\n    } else if (idObj == idDkSil) {\n      col4 = col4Ds;\n    }\n  }\n  refFac = 0.;\n  if (col4 == col4HiRf) refFac = 0.9;\n  else if (loRf) refFac = 0.15;\n  return col4;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi) * vec2 (0.5, 1.);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi) * vec2 (0.5, 1.);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return 1.2 * mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec3 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  e = vec2 (0.002, 0.);\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vn;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd, float sh)\n{\n  vec3 col, vn;\n  vec2 vf;\n  float f, ff;\n  vn = vec3 (0., 1., 0.);\n  vf = vec2 (0.);\n  ff = 1. - smoothstep (0.3, 0.6, dstGrnd / dstFar);\n  ro.x += 4.;\n  if (abs (ro.x) < 8.) {\n    f = smoothstep (0.395, 0.4, mod (0.2 * ro.z, 1.) * (1. - smoothstep (0.13, 0.15,\n       abs (abs (ro.x) - 7.6))));\n    vf = vec2 (16., 2. * (1. - 0.9 * f));\n    col = mix (vec3 (0.2) * (0.5 + 0.5 * Fbm2 (64. * ro.xz)), vec3 (0.8), f);\n  } else {\n    vn = RippleNorm (ro.zx, vn, 4. * ff);\n    vf = vec2 (4., 1.);\n    col = 0.6 * mix (vec3 (1., 0.8, 0.5), vec3 (0.9, 0.7, 0.5), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)));\n  }\n  if (vf.x > 0. && ff > 0.) vn = VaryNf (vf.x * ro, vn, vf.y * ff);\n  col *= 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.);\n  return col;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, rdo, col, colR, vn;\n  vec2 vf;\n  float dstObj, dstTrObj, dstGrnd, refFac, sh;\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  dstTrObj = TrObjRay (ro, rd);\n  roo = ro;\n  rdo = rd;\n  sh = 1.;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idPlat) qHit.x *= - sign (ro.z);\n    col4 = CarCol (vf, refFac);\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    isSh = true;\n    sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n    col = col4.rgb * (0.2 + 0.2 * max (dot (vn, sunDir * vec3 (-1., 1., 1.)), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    if (refFac > 0.) rd = reflect (rd, vn);\n  }\n  if (dstObj >= dstFar || refFac > 0.) {\n    if (rd.y < 0.) {\n      dstGrnd = - ro.y / rd.y;\n      ro += dstGrnd * rd;\n      vn = vec3 (0., 1., 0.);\n      sh = (dstGrnd < dstFar) ? ObjSShadowEx (ro + 0.01 * vn, sunDir) : 1.;\n      colR = GrndCol (vec3 (ro.xz + carPos.xz, 0.).xzy, rd, dstGrnd, sh);\n      colR = mix (colR, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n    } else {\n      colR = SkyBgCol (ro, rd);\n    }\n    col = (refFac > 0.) ? mix (col, 0.9 * colR, refFac) : colR;\n  }\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro = roo + dstTrObj * rdo;\n    vn = TrObjNf (ro);\n    if (idTrObj == idWscrn) col *= vec3 (1., 1., 0.8);\n    else if (idTrObj == idMLit) col *= vec3 (1., 1., 0.8) * (0.9 + 0.1 * cos (128. * qTrHit.x)); \n    rd = reflect (rdo, vn);\n    rd.y = abs (rd.y);\n    col = mix (col, SkyBgCol (ro, rd), 0.1 + 0.8 * pow (1. - abs (dot (vn, rdo)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t, todCur;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  stDat = Loadv4 (0);\n  carPos = stDat.xyz;\n  carRot = stDat.w;\n  stDat = Loadv4 (1);\n  wlBase = stDat.xyz;\n  wlRad = wlBase.y;\n  stDat = Loadv4 (2);\n  strRot = stDat.y;\n  wlRot = stDat.zw;\n  carPos.y += wlRad;\n  az = pi;\n  el = -0.12 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2.2 * pi * mPtr.x;\n    el -= 0.9 * pi * mPtr.y;\n  } else {\n    t = mod (0.007 * tCur, 2.);\n    az += 1.5 * pi * SmoothBump (0.25, 0.75, 0.25, mod (t, 1.)) * sign (t - 1.);\n    el += 0.05 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.45 * pi, -0.04 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -16.);\n  ro.xz += Rot2D (vec2 (0., wlBase.z), - carRot);\n  ro.y += carPos.y;\n  zmFac = 5.5;\n  dstFar = 100.;\n  colCode = floor (mod (todCur / 200., 3.));\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat PrFlatCapsDf (vec3 p, float r, float h)\n{\n  return length (vec2 (max (length (p.xy) - r, 0.), p.z)) - h;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Mercedes 500K\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 carPos, wlBase;\n  vec2 iFrag, wlRot, w;\n  float carRot, cRotN, strRot, wlRad, rTurn, spd, tc, nStep;\n  int pxId;\n  bool init;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= 3) discard;\n  init = (iFrame <= 5);\n  if (init) {\n    carPos = vec3 (0.);\n    carRot = 0.;\n    strRot = 0.;\n    wlBase = vec3 (1.45, 0.8, 2.7);\n    wlRot = vec2 (0.);\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    carPos = stDat.xyz;\n    carRot = stDat.w;\n    stDat = Loadv4 (1);\n    wlBase = stDat.xyz;\n    stDat = Loadv4 (2);\n    nStep = stDat.x;\n    strRot = stDat.y;\n    wlRot = stDat.zw;\n  }\n  wlRad = wlBase.y;\n  ++ nStep;\n  tc = mod (0.002 * nStep, 4.);\n  strRot = 0.07 * pi * SmoothBump (0.3, 0.7, 0.15, mod (tc, 1.)) * sign (mod (tc, 2.) - 1.) *\n     sign (tc - 2.);\n  spd = 0.03;\n  w = vec2 (1.);\n  if (abs (strRot) > 1e-4) {\n    cRotN = carRot - strRot * spd / pi;\n    rTurn = wlBase.z / asin (0.5 * strRot);\n    carPos.xz += rTurn * (sin (carRot - vec2 (0.5 * pi, 0.)) - sin (cRotN - vec2 (0.5 * pi, 0.)));\n    carRot = cRotN;\n    w += vec2 (-1., 1.) * wlBase.x / rTurn;\n  } else {\n    carPos.xz += spd * sin (carRot + vec2 (0., 0.5 * pi));\n  }\n  wlRot += w * spd / wlRad;\n  if      (pxId == 0) stDat = vec4 (carPos, carRot);\n  else if (pxId == 1) stDat = vec4 (wlBase, 0.);\n  else if (pxId == 2) stDat = vec4 (nStep, strRot, wlRot);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXSDH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1794, 1794, 1830, 1830, 2029], [2031, 2031, 2067, 2067, 6499], [6501, 6501, 6537, 6537, 8138], [8140, 8140, 8162, 8162, 8492], [8494, 8494, 8520, 8520, 8649], [8651, 8651, 8684, 8684, 8932], [8934, 8934, 8955, 8955, 9210], [9212, 9212, 9236, 9236, 9635], [9637, 9637, 9672, 9672, 9921], [9923, 9923, 9946, 9946, 10203], [10205, 10205, 10242, 10242, 10490], [10492, 10492, 10531, 10531, 10783], [10785, 10785, 10810, 10810, 11329], [11331, 11331, 11355, 11355, 11532], [11534, 11534, 11579, 11579, 17611], [17613, 17613, 17638, 17638, 18057], [18059, 18059, 18103, 18103, 18292], [18294, 18294, 18352, 18352, 19114], [19116, 19116, 19150, 19150, 19907], [19909, 19909, 19944, 19944, 21606], [21608, 21608, 21664, 21664, 23228], [23230, 23230, 23262, 23262, 23362], [23364, 23364, 23410, 23410, 23457], [23459, 23459, 23492, 23492, 23581], [23583, 23583, 23630, 23630, 23677], [23679, 23679, 23712, 23712, 23739], [23741, 23741, 23783, 23783, 23834], [23836, 23836, 23889, 23889, 23950], [23952, 23952, 24009, 24009, 24085], [24087, 24087, 24130, 24130, 24194], [24196, 24196, 24240, 24240, 24300], [24302, 24302, 24349, 24349, 24414], [24416, 24416, 24462, 24462, 24519], [24521, 24521, 24567, 24567, 24648], [24650, 24650, 24695, 24695, 24798], [24800, 24800, 24845, 24845, 24883], [24885, 24885, 24942, 24942, 25025], [25027, 25027, 25063, 25063, 25269], [25271, 25271, 25301, 25301, 25414], [25416, 25416, 25447, 25447, 25511], [25545, 25545, 25569, 25569, 25622], [25624, 25624, 25648, 25648, 25760], [25762, 25762, 25787, 25787, 25933], [25935, 25935, 25960, 25960, 26146], [26148, 26148, 26170, 26170, 26324], [26326, 26326, 26347, 26347, 26502], [26504, 26504, 26533, 26533, 26745], [26747, 26747, 26786, 26786, 26966], [27060, 27060, 27085, 27085, 27208]], "test": "untested"}
{"id": "7sfXW8", "name": "Frost Mountains", "author": "jarble", "description": "A simple fractal formula.\nFull-screen mode recommended.", "tags": ["fractal", "rainbow", "snow", "mountain", "frost"], "likes": 3, "viewed": 267, "published": 3, "date": "1618546558", "time_retrieved": "2024-07-30T19:25:51.613753", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    vec3 col_prev;\n    float t = iTime*2.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.5;\n        float scale1 = 1.4;\n        float s1 = scale1*scale;\n        for(int i=0;i<9;i++)\n        {\n            col_prev = col;\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.0-abs((uv.x-uv.y)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            //uv.x *= -(1.0+col.x/scale);\n            col[c] = (fract((.25*col.x+uv.y-uv.x/2.0)/2.5));\n            col = (col + col_prev.yzx)/2.0;\n        }\n     \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfXW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 840]], "test": "untested"}
{"id": "7dfXW8", "name": "Polyspline Editor", "author": "oneshade", "description": "Polyspline editor.", "tags": ["bezier", "spline", "quadratic", "editor", "polyspline"], "likes": 26, "viewed": 639, "published": 3, "date": "1618544272", "time_retrieved": "2024-07-30T19:25:52.496393", "image_code": "// Number of vertices in the polyspline\n#define N 10\n\n// Helper functions\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat sdPolyspline(in vec2 p, in vec2[N] cp) {\n    // Complete the first segment of the polyspline\n    vec2 v1 = cp[0], v2 = vec2(0.0), v3 = 0.5 * (cp[1] + v1);\n    vec2 pa = p - v1, ba = v3 - v1;\n    float d = dot2(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n\n    // Combine distances to quadratic beziers spanning each corner (vertex)\n    for (int n=1; n < N - 1; n++) {\n        v1 = 0.5 * (cp[n - 1] + cp[n]), v2 = cp[n], v3 = 0.5 * (cp[n] + cp[n + 1]);\n\n        vec2 c1 = p - v1;\n        vec2 c2 = 2.0 * v2 - v3 - v1;\n        vec2 c3 = v1 - v2;\n\n        // Solve a cubic to minimize the distance for the parameter\n        float t3 = dot(c2, c2);\n        float t2 = dot(c3, c2) * 3.0 / t3;\n        float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n        float t0 = dot(c1, c3) / t3;\n\n        float t22 = t2 * t2;\n        vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n        float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n        float p2 = abs(pq.x);\n        float r1 = 1.5 / pq.x * pq.y;\n\n        if (qq * 0.25 + ppp / 27.0 > 0.0) {\n            float r2 = r1 * sqrt(3.0 / p2), root;\n            if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n            else root = sinh(asinh(r2) / 3.0);\n            root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n            d = min(d, dot2(p - mix(mix(v1, v2, root), mix(v2, v3, root), root)));\n        }\n\n        else {\n            float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n            vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n            d = min(d, dot2(p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x)));\n            d = min(d, dot2(p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y)));\n        }\n    }\n\n    // Complete the last segment of the polyspline\n    v1 = cp[N - 1], v2 = vec2(0.0), v3 = 0.5 * (cp[N - 2] + v1);\n    pa = p - v1, ba = v3 - v1;\n    d = min(d, dot2(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)));\n\n    return sqrt(d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 2.0;\n    float unit = 4.0 / iResolution.y;\n\n    vec2[N] polyspline;\n    float de = 1e20, dp = 1e20;\n    for (int i=0; i < N; i++) {\n        polyspline[i] = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        dp = min(dp, length(uv - polyspline[i]));\n        if (i > 0) {\n            vec2 pa = uv - polyspline[i], ba = polyspline[i - 1] - polyspline[i];\n            de = min(de, length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)));\n        }\n    }\n\n    vec3 color = vec3(0.0);\n    color = mix(color, vec3(1.0, 0.8, 0.0), 1.0 - smoothstep(0.0, unit, de - 0.0025));\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, sdPolyspline(uv, polyspline) - 0.01));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, unit, dp - 0.025));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N 10", "buffer_a_code": "#define SELECTION_RADIUS 0.2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (iFrame == 0 && iFragCoord.x < N) {\n        fragColor.x = fragCoord.x / float(N) * 3.0 - 1.5;\n        fragColor.y = sin(fragColor.x * 2.0) * 0.5;\n    }\n\n    if (iFrame > 0) {\n        if (iFragCoord.x < N && iFragCoord.y == 0) {\n            vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 2.0;\n            fragColor = texelFetch(iChannel0, iFragCoord, 0);\n            if (length(mouse - fragColor.xy) < SELECTION_RADIUS) {\n                fragColor.xy = mouse;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfXW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 74, 97, 97, 117]], "test": "untested"}
{"id": "7sfSW8", "name": "Desert planet map", "author": "jarble", "description": "This fractal resembles a map of a desert planet.", "tags": ["fractal", "map", "desert", "bitwise"], "likes": 2, "viewed": 243, "published": 3, "date": "1618540546", "time_retrieved": "2024-07-30T19:25:53.263342", "image_code": "//#define ITERS 9 //normal world map\n#define ITERS 12 //swamp world\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 2000.0;\n    float trans = iTime * 200.0;\n    vec2 coord = (scale * fragCoord/iResolution.xy) + vec2(trans+30000.0,0.0);\n    \n    // Heart of color selection.\n    int val = 0;\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev = vec3(0.0);\n    for(int i = 0; i < ITERS; i++){\n        col_prev = col;\n        coord.y -= (4.0-result);\n        coord += coord.yy/8.0;\n        coord = coord.yx/(4.0);\n        result = ((result + float(val = ((int(coord.x-coord.y/2.0) & int(coord.y+coord.x/2.0)) % 3)))/(2.0));\n        col.x = result;\n        col = ((col.yzx)*3.0+col_prev)/3.5;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfSW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ssfSW8", "name": "invasion UFO v2", "author": "jorge2017a1", "description": "invasion UFO v2", "tags": ["invasionufov2"], "likes": 3, "viewed": 205, "published": 3, "date": "1618540213", "time_retrieved": "2024-07-30T19:25:54.210809", "image_code": "//por jorge2017a1-\n//referencia\n// helix 2 https://www.shadertoy.com/view/4sdBW8  \n//by FabriceNeyret2 in 2018-04-28\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\nvec3 light_pos3;  vec3 light_color3 ;\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 ovniDos(vec3 p, float pnumColor)\n{\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    ///esfera ovni\n    float sp1=sdSphere(p-vec3(0.0,5.0,0.0), 8.0 );\n    float sp2=sdSphere(p-vec3(.0,5.0,0.0), 10.0 );\n    \n    float sb1= sdBox( p-vec3(0.0,0.0,0.0), vec3(11,8.0,11.0) );\n    float sb2= sdBox( p-vec3(0.0,1.0,0.0),  vec3(11,8.0,11.0) );\n    \n    float dif1=differenceSDF(sp1, sb1);\n    float dif2=differenceSDF(sp2, sb2);\n     dif2=differenceSDF(dif1,dif2);\n    \n    res =opU3(res, vec3(dif1,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(dif2,pnumColor,MATERIAL_NO)); \n    return res;\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0); vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    \n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    vec3 pr=rotate_x(p,radians(90.0));\n    \n    float r0 = 5.0;float r1 = 1.5;float twist = .8;\n    float t=iTime;\n    vec3 q = pr;\n    float l = length(q.xy)-0.5;\n    float d = sin(atan(q.y,q.x)-q.z);           // sin: double\n    float td = length(vec2(l-5.0,d)) - 0.5;        // double-spring\n    \n    float alturadin=20.0-20.0*abs(sin(iTime*2.0));\n    float sc1=sdCylinderXY(pr-vec3(0.0,0.0,27.0-alturadin), vec2(3.0,alturadin) );\n    \n    float sc2=sdCylinderXY(pr-vec3(0.0,0.0,10.0), vec2(10.0,20.0) );\n    float inter1=intersectSDF(sc2,td);\n     \n    \n    \n    ///esfera ovni\n    float sp1=sdSphere(p-vec3(0.0,25.0,0.0), 10.0 );\n    float sb1= sdBox( p-vec3(0.0,20.0,0.0), vec3(11,8.0,11.0) );\n    float dif=differenceSDF(sp1, sb1);\n    \n    vec3 pr1=p-vec3(20.0,10.0+3.0*sin(iTime),10.0+iTime*5.0);\n    vec3 pr2=p-vec3(10.0,10.0+3.0*cos(iTime),20.0+iTime*7.0);\n       pr1.xz= opRep2D( pr1.xz, vec2(30.0));\n     pr2.xz= opRep2D( pr2.xz, vec2(30.0));\n    \n    vec3 ov2= ovniDos(pr1,2.0 );\n    vec3 ov3= ovniDos(pr2 ,3.0);\n     \n    res =opU3(res, vec3(sc1,5.0,MATERIAL_NO)); \n    res =opU3(res, vec3(inter1,6.0,MATERIAL_NO)); \n     res =opU3(res, vec3(dif,1.0,MATERIAL_NO)); \n     res =opU3(res, ov2);\n     res =opU3(res, ov3);\n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n///============================================================\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{   vec3 l = normalize(lp - p);\n    vec3 r = reflect(-l, n);\n    float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    return spe;\n}\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    //float rim=pow(1.0+dot(n,rd),3.0);\n    \n    vec3 lin = amb;\n    lin += 1.0*dif*vec3(1., .97, .85);\n    lin += 2.5*spe*vec3(1., .97, .85)*dif;\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    //lin += 0.35*rim*vec3(1.);\n    \n    return lin*atten*0.8;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{\n    float dO = 0.; vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false;    minDist = dO;    break; } \n        dO += dS.x;\n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj)*colobj*4.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    \n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n}\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    \n     if( mObj.hitbln==false) return  getSkyColA(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p ;\n\n   float d = RayMarch(ro, rd,MAX_STEPS);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        p = (ro + rd * d );  \n         \n         \n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos3);\n        result/=1.25;\n        col= result*dif1;\n    \n    }\n      else if(d>MAX_DIST)\n     col= getSkyColA(rd);\n   return col;\n}    \n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 40.0, -10.0 );  light_color1 =vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 40.0, 10.0 ); light_color2 = vec3( 1.0 ); \n    light_pos3= vec3( 0.0, 5.0, -10.0 );    light_color3 = vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,18.0,-40.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n        \n    col = pow(col, vec3(1.0/3.2));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfSW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[615, 615, 651, 651, 672], [673, 673, 705, 705, 789], [790, 790, 829, 829, 924], [925, 925, 964, 964, 1059], [1060, 1060, 1099, 1099, 1194], [1196, 1240, 1287, 1287, 1314], [1315, 1315, 1358, 1358, 1385], [1386, 1386, 1434, 1434, 1462], [1463, 1547, 1583, 1583, 1628], [1634, 1634, 1673, 1673, 1717], [1718, 1783, 1817, 1817, 1915], [1916, 1916, 1950, 1950, 2042], [2043, 2043, 2077, 2077, 2169], [2170, 2210, 2244, 2244, 2341], [2343, 2343, 2382, 2382, 2921], [2922, 2962, 2987, 2987, 4720], [4722, 4786, 4813, 4813, 4830], [4832, 4832, 4868, 4868, 4960], [4961, 4961, 5007, 5007, 5139], [5140, 5140, 5214, 5214, 5944], [5946, 5997, 6021, 6021, 6209], [6211, 6211, 6260, 6260, 6896], [6897, 6984, 7020, 7020, 7267], [7269, 7303, 7383, 7383, 7668], [7669, 7710, 7737, 7737, 7852], [7853, 7904, 7951, 7951, 8177], [8232, 8232, 8325, 8325, 8664], [8668, 8668, 8699, 8699, 9404], [9411, 9460, 9517, 9517, 10160]], "test": "untested"}
{"id": "sdXSW8", "name": "Bezier Scribbles", "author": "oneshade", "description": "Scribble made out of quadratic beziers.", "tags": ["bezier", "random", "spline", "curve", "quadratic", "path", "scribbles"], "likes": 9, "viewed": 255, "published": 3, "date": "1618536105", "time_retrieved": "2024-07-30T19:25:54.989726", "image_code": "// Based on a quick doodle I did on desmos:\n// https://www.desmos.com/calculator/mbtrtwqbwb\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat sdBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec2 p1 = p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x);\n        vec2 p2 = p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// Modified hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadcrtoy.com/view/4djSRW)\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy) * 2.0 - 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n\n    float dc = 1000000000000.0, dp = dc, de = dc;\n    float par = fract(iTime), sec = floor(iTime);\n    for (float v=sec; v < sec + 10.0; v++) {\n        vec2 v1 = Hash12(v), v2 = Hash12(v + 1.0), v3 = Hash12(v + 2.0);\n        vec2 a = mix(v1, v2, par), b = mix(v2, v3, par), c = mix(v3, Hash12(v + 3.0), par);\n        dc = min(dc, sdBezier(uv, 0.5 * (a + b), b, 0.5 * (b + c)));\n\n        de = min(de, sdLine(uv, a, b));\n        de = min(de, sdLine(uv, b, c));\n\n        dp = min(dp, dot2(uv - a));\n        dp = min(dp, dot2(uv - b));\n        dp = min(dp, dot2(uv - c));\n    }\n\n    vec3 color = vec3(0.0);\n\n    color = mix(color, vec3(1.0, 0.8, 0.0), 1.0 - smoothstep(0.0, 0.015, de - 0.0025));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.015, sqrt(dp) - 0.02));\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, dc - 0.01));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXSW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 116, 116, 136], [137, 137, 200, 200, 1413], [1415, 1415, 1462, 1462, 1570], [1572, 1670, 1695, 1695, 1836], [1838, 1838, 1893, 1893, 2945]], "test": "untested"}
{"id": "fdfSDH", "name": "Turning space inside out", "author": "tdhooper", "description": "A quick demo of the transformation used in my animation, Inside, the new Outside! [url]https://twitter.com/tdhooper/status/1378746948136624128[/url]", "tags": ["4d", "inversion"], "likes": 57, "viewed": 1574, "published": 3, "date": "1618532799", "time_retrieved": "2024-07-30T19:25:55.759668", "image_code": "/*\n\n    Turning space inside out\n    ------------------------\n\n    A quick demo of the transformation used in my animation,\n    Inside, the new Outside!\n    \n    https://twitter.com/tdhooper/status/1378746948136624128\n    \n    This is a bit like sphere inversion, but we can transition\n    from un-warped, to warped. It works by doing a stereographic\n    projection to and from 4d, and performing a rotation in 4d.\n    \n    I think this is called a mbius transformation, there are\n    some similar examples by Daniel Piker, along with code for\n    other environments:\n    \n    https://twitter.com/KangarooPhysics/status/1292180181185179648\n    https://spacesymmetrystructure.wordpress.com/2008/12/11/4-dimensional-rotations/\n\n    I got the stereographic projection code, and the general\n    approach for this from Matthew Arcus, who's made a lot of\n    amazing 4d shaders:\n    \n    https://www.shadertoy.com/view/lsGyzm\n    \n*/\n\n//#define SHOW_DISTANCE\n#define FIX_DISTANCE\n\n#define PI 3.14159265359\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// mla https://www.shadertoy.com/view/lsGyzm\nvec4 inverseStereographic(vec3 p) {\n  float k = 2.0/(1.0+dot(p,p));\n  return vec4(k*p,k-1.0);\n}\nvec3 stereographic(vec4 p4) {\n  float k = 1.0/(1.0+p4.w);\n  return k*p4.xyz;\n}\n\nstruct Model {\n    float d;\n    vec3 col;\n};\n\nModel scene(vec3 p) {\n    vec3 col = normalize(p) * .5 + .5;\n    float d = sdBoundingBox(p, vec3(.9), .2);\n    return Model(d, col);\n}\n\nModel sceneWarped(vec3 p) {\n\n    float f = length(p);\n\n    // Project to 4d\n    vec4 p4 = inverseStereographic(p);\n    \n    // Rotate in the 4th dimension\n    pR(p4.zw, -iTime);\n    \n    // Project back to 3d\n    p = stereographic(p4);\n    \n    Model model = scene(p);\n    \n    // When we're inside out, the entire universe gets collapsed\n    // into the middle of the scene, causing a lot of raymarching\n    // understepping and overstepping.\n    // This ia a rough attempt at fixing this, there's still a bit\n    // of overestimation in places so the raymarch loop is hacked\n    // to accommodate it.\n    #ifdef FIX_DISTANCE\n        float e = length(p.xyz);\n        model.d *= min(1., 1. / e) * max(1., f);\n    #endif\n    \n    return model;\n}\n\nModel map(vec3 p) {\n    Model model = sceneWarped(p);\n\n    #ifdef SHOW_DISTANCE\n        float d = abs(p.y);\n        if (d < model.d) {\n            model.col = min(vec3(0, 1. / model.d, model.d), 1.) * fract(model.d * 10.);\n            model.d = d;\n        }\n    #endif\n\n    return model;\n}\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0,0,8);\n    \n    vec2 im = iMouse.xy / iResolution.xy;\n    \n    if (iMouse.x <= 0.) {\n        im = vec2(.6,.3);\n    }\n    \n    pR(camPos.yz, (.5 - im.y) * PI / 2.);\n    pR(camPos.xz, (.5 - im.x) * PI * 2.5);\n    \n    mat3 camMat = calcLookAtMatrix(camPos, vec3(0), vec3(0,1,0));\n    \n    float focalLength = 3.;\n    vec3 rayDirection = normalize(camMat * vec3(p.xy, focalLength));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    Model model;\n    float dist = 0.;\n    bool bg = false;\n    vec3 bgcol = vec3(.014,.01,.02);\n    vec3 col = bgcol;\n\n    for (int i = 0; i < 100; i++) {\n        rayLength += dist * .8; // fix overstepping\n        rayPosition = camPos + rayDirection * rayLength;\n        model = map(rayPosition);\n        dist = model.d;\n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 15.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        col = model.col;\n        vec3 nor = calcNormal(rayPosition);\n        col *= dot(vec3(0,1,0), nor) * .5 + 1.;\n        float fog = 1. - exp((rayLength - 6.) * -.5);\n        col = mix(col, bgcol, clamp(fog, 0., 1.));\n    }\n\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfSDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1003, 1013, 1045, 1045, 1090], [1092, 1159, 1207, 1207, 1494], [1496, 1541, 1576, 1576, 1636], [1637, 1637, 1666, 1666, 1715], [1763, 1763, 1784, 1784, 1897], [1899, 1899, 1926, 1926, 2643], [2645, 2645, 2664, 2664, 2934], [2936, 3005, 3031, 3031, 3232], [3234, 3234, 3284, 3284, 3427], [3429, 3429, 3486, 3486, 4821]], "test": "untested"}
{"id": "fsXXWH", "name": "Bitwise planet map", "author": "jarble", "description": "This map was generated using a bitwise fractal formula. It appears to have continents and oceans with many different biomes.", "tags": ["fractal", "ocean", "map", "bitwise", "biome", "continents"], "likes": 4, "viewed": 262, "published": 3, "date": "1618528306", "time_retrieved": "2024-07-30T19:25:56.531604", "image_code": "#define ITERS 9 //normal world map\n//#define ITERS 6 //swamp world\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 2000.0;\n    float trans = iTime * 200.0;\n    vec2 coord = (scale * fragCoord/iResolution.xy) + vec2(trans+30000.0,0.0);\n    \n    int val = 0;\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev = vec3(0.0);\n    for(int i = 0; i < ITERS; i++){\n        col_prev = col;\n        coord.y -= (4.0-result);\n        coord += coord.yy/8.0;\n        coord = coord.yx/(4.0);\n        result = ((result + float(val = ((int(coord.x-coord.y/2.0) & int(coord.y+coord.x/2.0)) % 3)))/(2.0));\n        col.x = result;\n        col = ((col.yzx)*2.0+col_prev)/3.;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXXWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7sfSDr", "name": "impossible boxes piles 2", "author": "FabriceNeyret2", "description": "shaded variant of [url]https://shadertoy.com/view/NdfXR7[/url]\n\nreference: [img]https://i.imgur.com/oxv28g9.png[/img]", "tags": ["illusion", "escher", "isometric", "short", "reproduction", "paradoxical", "tomgauld"], "likes": 12, "viewed": 283, "published": 3, "date": "1618517463", "time_retrieved": "2024-07-30T19:25:57.299551", "image_code": "// shaded variant of https://shadertoy.com/view/NdfXR7\n\n\n#define rot(a)    mat2( cos(a+vec4(0,-1.57,1.57,0)) )    // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9., T = iTime;\n    vec3  R = iResolution, W = vec3(4,5,4), q,r,a,\n          M = iMouse.z > 0. ? 2.*iMouse.xyz/R -1. :      // try mouse control to see the trick :-)\n                               vec3(.785,.41,0),\n          p = vec3( 10.*(U+U-R.xy)/R.y, 20 );            // ray start. dir = (0,0,-1)\n                                       \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 ) {        // marching point along ray\n        q = p, t = 1.,\n        q.yz *= rot(M.y),                                // rotations\n        q.xz *= rot(M.x);\n        a = abs( r = round(q/W) );                       // box id\n        r = p.y<0. ? r : -r;                             // for \"vertical\" connections\n    \n        if ( a.x*a.z == 0. )\n            if (  a.y == 0. && max(a.x,a.z) < 5.         // 2 rows of boxes\n               || r == vec3(4,1,0) || r == vec3(0,1,4)   // \"vertical\" connections\n               )  q = mod(q+W/2.,W) - W/2.,  \n               // q.xz *= rot(.5*iTime),                 // box rot: try me !\n                  a = abs(q) - 1.2,\n                  t = max( a.x, max(a.y-1.,a.z) );       // box SDF\n        \n        p.z -= .5*t;                                     // step forward = dist to obj          \n    }\n\n                                                         // shading & coloring\n    vec3 N = t<.01 ? sign(q)*vec3(equal(t+vec3(0,1,0),a)) : vec3(0,-1,0),// normal in object space\n         L = 20.*normalize( vec3(cos(.7*T), sin(1.2*T),cos(T+1.)) - vec3(0,0,1.1) ), // light pos\n         V = vec3(0,0,1), H;                             // view dir\n    N.xz *= rot(-M.x),  N.yz *= rot(-M.y);               // to camera space\n\n    p.z *= smoothstep(1.,0.,abs(p.x)/(4.*W.x/sqrt(2.)) );// trick for continuous lighting\n\n    L = normalize( L - p );                              // get light direction\n    H = normalize( L + V );                              // half-vector for specular\n                                                         // shade surface : \n    O =   ( .2 + max(0.,dot(N,L)) ) * ( t < .01 ? vec4(1,0,0,0): vec4(.9,.9,1,1) ) // amb + diff\n        +   pow(max(0.,dot(N,H)),150.);                  // specular\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfSDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 181, 181, 2352]], "test": "untested"}
{"id": "NdXXW8", "name": "Distorted Orbit", "author": "nialred", "description": "Sphere orbiting around another sphere. Early stuff, so poorly written and poorly commented. ", "tags": ["distortion", "sphere", "cool"], "likes": 1, "viewed": 208, "published": 3, "date": "1618516281", "time_retrieved": "2024-07-30T19:25:58.158255", "image_code": "struct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Circle\n{\n    vec2 center;\n    float radius;\n};\n    \nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\n\nint intersect_circle(in vec2 uv, in Circle circle)\n{    \n    vec2 distance = abs(uv - circle.center);\n    \n    float radius_check = length(distance);\n    \n    /*\n    // Could use this instead to get smooth edges between sphere and background\n    float difference = radius - radius_check;\n    float color = clamp(difference / fwidth(difference), 0., 1.);\n    fragColor = vec4(color, 0.0, 1.0 - color, 1.0);\n    */\n    \n    if (radius_check < circle.radius)\n    {\n        // Inside circle\n        return 1;\n    } \n    else\n    {\n        // Outside circle\n        return 0;\n    } \n}\n\nvec4 diffuse(in vec3 surface, in vec3 center, in vec4 color, in vec3 light_pos) {\n\t// Surface normal\n\tvec3 n = normalize(surface - center);\n\t\n\t// Light direction from surface\n\tvec3 l = normalize(light_pos - surface);\n\n\t// The diffuse equation\n\treturn color * max(0.0, dot(n, l));\n}\n\nfloat diffuse2(vec3 current_pos, vec3 light_pos, vec3 normal)\n{\n    vec3 light_dir = normalize(current_pos - light_pos);\n    \n    float intensity = max(0.0, dot(normal, light_dir));\n    \n    return intensity;\n}\n\nfloat intersect_sphere(in Ray ray, in Sphere sphere)\n{\n    // Sphere center to ray origin\n    vec3 co = (ray.origin - sphere.center);\n    \n    // The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance\n\tfloat discrim = dot(co, ray.direction) * dot(co, ray.direction) - \n                         (dot(co, co) - (sphere.radius * sphere.radius));\n    \n    if (discrim >= 0.0)\n    {\n        return -dot(ray.direction, co) - sqrt(discrim);\n    }\n    else\n    {\n        return -1.0;\n    }\n\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates\n    vec2 uv = fragCoord.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_norm = uv / iResolution.xy;\n    \n    /*\n    // Initialize circle object\n    Circle circle = Circle(vec2(iResolution.x / 2.0, iResolution.y / 2.0), 200.0);\n    \n    // Check if current pixel position is inside the circle\n    int hit_circle = intersect_circle(uv, circle);\n    \n    // Color the pixel accordingly\n    if (hit_circle == 1)\n    {\n        fragColor = vec4(uv_norm.x, uv_norm.y, 1.0, 1.0);\n    }\n    else \n    {\n        fragColor = vec4(0.25 * uv_norm.x, 0.25 * uv_norm.y, 0.25, 1.0);\n    }\n    */\n    \n    \n    // Shift the range from [0 1] to [-1 1]\n    vec2 uv_norm_shift = uv_norm * 2.0 - 1.0;\n    \n    // Pixel position in 3D space (screen is at a z value of 0)\n    vec3 pixel_pos = vec3(uv_norm_shift.x / (iResolution.y/iResolution.x), uv_norm_shift.y, 0.0);\n    \n    // Eye position is behind the screen somewhere (hence the -4 z value)\n    vec3 eye_pos = vec3(0.0, 0.0, -4.0);\n    \n    // Ray used to see if it intersects with sphere\n    vec3 ray_dir = normalize(pixel_pos - eye_pos);\n    \n    // Define sphere with 3D center and radius values\n    //Sphere sphere = Sphere(vec3(0.0, 0.0, 7.0), 1.0);\n    Sphere sphere = Sphere(vec3(sin(0.5*iTime)*2.0, 0.0, (cos(0.5*iTime)*5.0) + 5.0), 0.25);\n    Sphere sphere2 = Sphere(vec3(0.0, 0.0, 5.0), 1.0);\n    \n    // Define ray\n    Ray ray = Ray(eye_pos, ray_dir);\n    \n    float surf_dist = intersect_sphere(ray, sphere);\n    float surf_dist2 = intersect_sphere(ray, sphere2);\n    \n    vec3 point = eye_pos + (surf_dist * ray_dir);\n    vec3 point2 = eye_pos + (surf_dist2 * ray_dir);\n    \n    \n    float z_buff = point.z - point2.z;\n    \n    // Distortion \"frequency\"\n    float d = sin(dot(uv_norm_shift ,vec2(12.9898,78.233))) + cos(dot(uv_norm_shift ,vec2(12.9898,78.233))) + 5.0;\n    \n    // Distort the distance to surface \n    float dist_disp = sin(d * point.x) * sin(d * point.y) * sin(d * point.z);\n    float dist_disp2 = sin(0.0 * point2.x) * sin(0.0 * point2.y) * sin(0.0 * point2.z);\n    vec3 disp_point = eye_pos + ((surf_dist + dist_disp) * ray_dir);\n    vec3 disp_point2 = eye_pos + ((surf_dist2 + dist_disp2) * ray_dir);\n    \n    // Distort the location of the current point on the sphere\n    float point_disp = sin(d * point.x) * sin(d * point.y) * sin(d * point.z);\n    \n    // If positive, then we draw a pixel of the sphere\n\tif (surf_dist >= 0.0 && surf_dist2 >= 0.0)\n    {\n        if (z_buff > 0.0)\n        {\n            // Choose a diffuse color\n            vec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n            // Choose an ambient color\n            vec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n            // Position of a white light\n            vec3 light_pos = vec3(20.0, 10.0, -10.0);\n            \n            fragColor = ambient_col + diffuse(disp_point2, sphere2.center, diffuse_col, light_pos);\n        }\n        \n        else\n        {\n            // Choose a diffuse color\n            vec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n            // Choose an ambient color\n            vec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n            // Position of a white light\n            vec3 light_pos = vec3(20.0, 10.0, -10.0);\n        \n            fragColor = ambient_col + diffuse(disp_point, sphere.center, diffuse_col, light_pos);\n        }\n    }\n    \n    else if (surf_dist < 0.0 && surf_dist2 >= 0.0)\n    {\n        // Choose a diffuse color\n        vec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n        // Choose an ambient color\n        vec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n        // Position of a white light\n        vec3 light_pos = vec3(20.0, 10.0, -10.0);\n            \n        fragColor = ambient_col + diffuse(disp_point2, sphere2.center, diffuse_col, light_pos);\n     }\n     \n     else if (surf_dist >= 0.0 && surf_dist2 < 0.0)\n     {\n         // Choose a diffuse color\n        vec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n        // Choose an ambient color\n        vec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n        // Position of a white light\n        vec3 light_pos = vec3(20.0, 10.0, -10.0);\n        \n        fragColor = ambient_col + diffuse(disp_point, sphere.center, diffuse_col, light_pos);\n      }\n      \n      else\n      {\n          // Otherwise we draw the color of the background\n          fragColor = vec4(0.0, 0.0, 0.0, 1);\n      }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXXW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 221, 221, 748], [750, 750, 831, 850, 1031], [1033, 1033, 1096, 1096, 1243], [1245, 1245, 1299, 1334, 1769], [1776, 1776, 1833, 1858, 6213]], "test": "untested"}
{"id": "fdXXW8", "name": "Blocky Spiral", "author": "percentcer", "description": "atan is always there for you when you need it", "tags": ["atan"], "likes": 2, "viewed": 210, "published": 3, "date": "1618516261", "time_retrieved": "2024-07-30T19:25:58.992025", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 blocks = floor((fragCoord.xy-iResolution.xy*.5)*.1);\n    vec3 mul = vec3(0.5 + 0.5 * sin(-10.*iTime + length(blocks)*.1 + mod(blocks.y,2.)));\n    vec3 bgCol = vec3(sin((iTime+atan(blocks.y,blocks.x)+length(blocks))), .7 + 0.5*sin(blocks.y),.8)+0.5*sin(iTime + blocks.xyy + vec3(0,2,4));\n    for(int i = 0; i < 4; i++) {\n        bgCol = bgCol.yzx;\n        bgCol.x*=bgCol.y*1.1;\n    }    \n    fragColor = vec4(bgCol*mul+bgCol*(0.7+0.1*sin(iTime)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXXW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 519]], "test": "untested"}
{"id": "7s23zy", "name": "dodic", "author": "dark_dashas", "description": "dod", "tags": ["dod"], "likes": 2, "viewed": 131, "published": 3, "date": "1618515011", "time_retrieved": "2024-07-30T19:25:59.945476", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel1, uv) / float(iFrame + 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel1, uv) + texture(iChannel2, uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* tracing functions*/\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal)  \n{\n    normal = vec3(0.0, 1.0, 0.0);\n    float t = (-1.25 - pos.y) / dir.y;\n    if (t <= 0.0) return INF;\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) return INF;\n    return t;\n}\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) \n{\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) return INF;\n    float t = (-b - sqrt(D));\n    if (t > 0.0) \n    {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = (-b + sqrt(D));\n    if (t < 0.0) return INF;\n    normal = normalize(pos + t * dir);\n    return t;\n}\nfloat traceTriangle(Triangle t, vec3 origin, vec3 dir, out vec3 norm) \n{\n    vec3 d1 = t.pos[1] - t.pos[0];\n    vec3 d2 = t.pos[2] - t.pos[0];\n    norm = normalize(cross(d1, d2));\n    float normalViewAngle = dot(dir, norm);\n    if (abs(normalViewAngle) < EPS) return INF;\n    float d = dot(t.pos[0] - origin, norm) / normalViewAngle;\n    if (d < 0.0) return INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 toHitVecs[3] = vec3[3](hitPos - t.pos[0], hitPos - t.pos[1], hitPos - t.pos[2]);\n    vec3 edges[3] = vec3[3](t.pos[1] - t.pos[0], t.pos[2] - t.pos[1], t.pos[0] - t.pos[2]);\n    float square = length(cross(edges[0], edges[1]));\n    float testSq[3] = float[3]( length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])), length(cross(toHitVecs[2], edges[2])));\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS) return d;\n    return INF;\n}\nfloat traceDod(vec3 pos, vec3 dir, out vec3 norm) \n{\n    vec3 curNorm;\n    float t = INF, curT;\n    for (int i = 0; i < 36; i++) \n    {\n        Triangle curTr;\n        for (int j = 0; j < 3; j++) \n        {\n            curTr.pos[j] = vertList[triagList[i * 3 + j] - 1];\n        }\n        curTr.pos[0].y += 0.4;\n        curTr.pos[1].y += 0.4;\n        curTr.pos[2].y += 0.4;\n        curTr.pos[0].x += 0.25;\n        curTr.pos[1].x += 0.25;\n        curTr.pos[2].x += 0.25;\n        curTr.pos[0].xy = rotate(curTr.pos[0].xy, 0.55);\n        curTr.pos[1].xy = rotate(curTr.pos[1].xy, 0.55);\n        curTr.pos[2].xy = rotate(curTr.pos[2].xy, 0.55);\n        curTr.pos[0].xz = rotate(curTr.pos[0].xz, 0.8);\n        curTr.pos[1].xz = rotate(curTr.pos[1].xz, 0.8);\n        curTr.pos[2].xz = rotate(curTr.pos[2].xz, 0.8);\n        curT = traceTriangle(curTr, pos, dir, curNorm);\n        if (curT < t) \n        {\n            t = curT;\n            norm = curNorm;\n        }\n    }\n    return t;\n}\nfloat tracePod(vec3 pos, vec3 dir, out vec3 norm)\n{\n    vec3 curNorm;\n    float t = INF, curT;\n    for (int i = 0; i < 8; i++) \n    {\n        Triangle curTr;\n        for (int j = 0; j < 3; j++) \n        {\n            curTr.pos[j] = vertListPod[triagListPod[i * 3 + j] - 1];\n        }\n        curT = traceTriangle(curTr, pos, dir, curNorm);\n        if (curT < t) \n        {\n            t = curT;\n            norm = curNorm;\n        }\n    }\n    return t;\n}\n\n\n/*building*/\nfloat MARCH_SIZE = 0.1;\nint MAX_STEPS = 100;\n\nfloat opS( float a, float b )\n{\n    return max( -b, a );\n}\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nvec3 calcNormal( in vec3 pos, vec3 b )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sdBox( pos + e.xyy, b ) + \n\t\t\t\t\t  e.yyx*sdBox( pos + e.yyx, b ) + \n\t\t\t\t\t  e.yxy*sdBox( pos + e.yxy, b ) + \n\t\t\t\t\t  e.xxx*sdBox( pos + e.xxx, b ) );\n}\nfloat sdBBox(vec3 p) {\n    float d1 = sdBox(p, vec3(0.3, 0.3, 0.3));\n    float d2 = sdBox(p + vec3(0, 0, 0.3), vec3(0.1, 0.1, 0.1));\n    return opS( d1, d2 );\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sdBBox( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*sdBBox( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*sdBBox( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*sdBBox( pos + e.xxx ) );\n}\nfloat marchBbox(in vec3 ro, in vec3 rd, vec3 b, bool box, out vec3 norm) \n{\n    float dist;\n    float t = EPS;\n    for (int i = 0; i < MAX_STEPS; i++) \n    {\n        float res;\n        if (box) res = sdBox(ro + rd * t, b);\n        else res = sdBBox(ro + rd * t);\n        if(res < EPS || t > INF) {\n            if (box) norm = calcNormal(ro + rd * t, b);\n            else norm = calcNormal(ro + rd * t);\n            break;\n        }\n        t += res;\n    }\n    if (t > INF) return INF;\n    return t;\n}\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.34;\n\t\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\nvec3 calcNormal( in vec3 pos, float h )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sdPyramid( pos + e.xyy, h ) + \n\t\t\t\t\t  e.yyx*sdPyramid( pos + e.yyx, h ) + \n\t\t\t\t\t  e.yxy*sdPyramid( pos + e.yxy, h ) + \n\t\t\t\t\t  e.xxx*sdPyramid( pos + e.xxx, h ) );\n}\nfloat marchPyr(in vec3 ro, in vec3 rd, out vec3 norm) \n{\n    float dist;\n    float t = EPS;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float res = sdPyramid(ro + rd * t, 0.6);\n        if(res < EPS || t > INF) {\n            norm = calcNormal(ro + rd * t, 0.6);\n            break;\n        }\n        t += res;\n    }\n    if (t > INF) return INF;\n    return t;\n}\n\n\n/*lighting*/\nbool isOccluded(vec3 pos, vec3 target)\n{\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 dodNorm;\n    float dodT = traceDod(pos, dir, dodNorm);\n    if (dodT < dist) return true;\n    \n    vec3 podNorm;\n    float podT = tracePod(pos, dir, podNorm);\n    if (podT < dist) return true;\n    return false;\n}\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) \n{\n    vec3 lighting = texture(iChannel2, normal).rgb;\n    for (int i = 0; i < lightsCounter; i++)\n    {\n        vec3 toLight1 = Lights[i].pos - pos;\n        float distSq1 = dot(toLight1, toLight1);\n        float att1 = isOccluded(pos, Lights[i].pos + randDir * Lights[i].rad) \n                ? 0.0 : Lights[i].intensity / distSq1;\n        lighting += max(0.0, dot(normal, normalize(toLight1))) * att1 * Lights[i].color;\n    }\n    return color * lighting;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy + (randVals.xy - 0.5) * 2.0) / iResolution.x; \n    \n    Lights[0].pos = vec3(-3, 1.5, 2);// + randVals * 0.3; \n    Lights[0].color = vec3(0xf0, 0xea, 0xd2) / 255.0;\n    Lights[0].rad = 0.5;\n    Lights[0].intensity = 15.0;\n    \n    Lights[1].pos = vec3(3, 2, 1);// + randVals * 0.15;\n    Lights[1].color = vec3(0xdd, 0xa1, 0x5e) / 255.0; \n    Lights[1].rad = 0.25;\n    Lights[1].intensity = 10.0;\n    \n    Lights[2].pos = vec3(-2, 1.6, 7);// + randVals * 0.3;\n    Lights[2].color = vec3(0xb5, 0xc9, 0x9a) / 255.0; \n    Lights[2].rad = 0.2;\n    Lights[2].intensity = 15.0;\n    \n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + uv.x * right + uv.y * up); \n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n\n    float n1 = AIR_N;\n    float n2 = DIAMOND_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i < 10; ++i) \n    {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) \n        {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * viewVec + curPos;\n            colorMult *= vec3(0xe9, 0xf5, 0xdb) / 255.0;\n            color = texture(iChannel1, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n        }\n        \n        for (int i = 0; i < lightsCounter; ++i) \n        {\n            vec3 lightNorm;\n            float lightT = traceSphere(curPos - Lights[i].pos, curDir, Lights[i].rad, lightNorm);\n            if (lightT < t) \n            {\n                t = lightT;\n                materialType = EMISSION;\n                color = Lights[i].color;\n                normal = lightNorm;\n            }\n        }\n        \n        vec3 dodNorm;\n        float dodT = traceDod(curPos, curDir, dodNorm);\n        if (dodT < t) \n        {\n            t = dodT;\n            normal = dodNorm;\n            if (randVals.x * 0.5 < DIAMOND_R * 3.0) materialType = REFLECTION;\n            else materialType = REFRACTION;\n        }\n        \n        vec3 podNorm;\n        float podT = tracePod(curPos, curDir, podNorm);\n        if (podT < t) \n        {\n            t = podT;\n            normal = podNorm;\n            materialType = REFLECTION;\n            colorMult *= vec3(0xdd, 0xa1, 0x5e) / 255.0; \n        }\n        \n        if (randVals.x < 0.8)\n        {\n            vec3 tmpPos = curPos + randVals * 0.06;\n            vec3 bNorm;\n            float buildingT = marchBbox(tmpPos + vec3(0, -0.3, 0), curDir, vec3(0), false, bNorm);\n            if (buildingT < t) \n            {\n                normal = bNorm;\n                vec3 worldPos = t * viewVec + tmpPos;\n                color = texture(iChannel0, worldPos.xy).rgb;\n                t = buildingT;\n                materialType = DIFFUSE;\n            }\n\n            vec3 windowNorm;\n            float windowT = marchBbox(tmpPos + vec3(0, -0.3, 0.2), curDir, \n                    vec3(0.1, 0.1, 0.05), true, windowNorm);\n            if (windowT < t) \n            {\n                normal = windowNorm;\n                vec3 worldPos = t * viewVec + tmpPos;\n                color = vec3(0.9, 0.9, 0.5);\n                t = windowT;\n                materialType = EMISSION;\n            }\n\n            vec3 pNorm;\n            float roofT = marchPyr(tmpPos + vec3(0, -0.6, 0), curDir, pNorm);\n            if (roofT < t) \n            {\n                normal = pNorm;\n                vec3 worldPos = t * viewVec + tmpPos;\n                color = texture(iChannel3, worldPos.xy).rgb;\n                t = roofT;\n                materialType = DIFFUSE;\n            }\n        }\n\n        if (t != INF) \n        {\n            vec3 worldPos = t * curDir + curPos;\n            \n            if (materialType == EMISSION) \n            {\n                fragColor.rgb = color * colorMult;\n                break;\n            }\n            else if (materialType == DIFFUSE)\n            {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                break;\n            }\n            else if (materialType == REFLECTION) \n            {\n                curDir = reflect(curDir,normal);\n                curPos = worldPos + curDir * 1e-3;\n            }\n            else if (materialType == REFRACTION) \n            {\n                curDir = refraction(curDir, normal, n1, n2);\n                curPos = worldPos + curDir * 1e-4;\n                float swap = n1;\n                n1 = n2;\n                n2 = swap;\n            }\n        }\n        else fragColor.rgb = texture(iChannel2, curDir).rgb * colorMult;\n    }\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265359\n#define PHI (1.618033988749895)\n\n\nconst float INF = 1e10;\nconst float EPS = 1e-3;\nvec3 randDir;\nconst vec3 CAMERA_POS = vec3(3, 4, -7);\n\n\n/*materials*/\nconst int EMISSION = 0;   \nconst int DIFFUSE = 1;    \nconst int REFLECTION = 2; \nconst int REFRACTION = 3; \nconst int MINECRAFT = 4;\n\n\n/*refraction*/\nconst float DIAMOND_N = 2.5;\nconst float GLASS_N = 1.5;\nconst float AIR_N = 1.0;\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) \n{\n    if (dot(v, normal) < 0.0) normal = -normal;\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.0) return reflect(v, normal);\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n\n/*figure structures*/\nstruct Sphere {\n    vec3 pos;\n    vec3 color;\n    float rad;\n    float intensity;\n};\nstruct Triangle \n{\n    vec3 pos[3];\n    vec3 normal;\n};\n\n/*podstavka verts*/\nvec3[6] vertListPod = vec3[6](\n  vec3( 0.0, -1,     2.2), \n  vec3( 0.0, -1.25,  2.2), \n  vec3(-1.5, -1,    -0.8), \n  vec3(-1.5, -1.25, -0.8), \n  vec3( 1.5, -1,    -0.8), \n  vec3( 1.5, -1.25, -0.8)\n);\nint[24] triagListPod = int[](\n    1, 3, 5,\n    2, 4, 6,\n    1, 2, 3,\n    2, 3, 4,\n    3, 4, 5,\n    4, 5, 6,\n    1, 2, 5,\n    2, 5, 6\n);\n\n/*pyramide verts\nvec3[4] vertListPyr = vec3[4](\n  vec3(), \n  vec3(), \n  vec3(), \n  vec3(), \n);\nint[18] triagListPyr = int[](\n    \n);\n*/\n\n/*cube verts\nvec3[8] vertListCube = vec3[20](\n  vec3(), \n  vec3(), \n  vec3(), \n  vec3(), \n  vec3(), \n  vec3(), \n  vec3(), \n  vec3(),\n);\nint[36] triagListCube = int[](\n    \n);\n*/\n\n\n/*dodecahedron verts*/\nvec3[20] vertList = vec3[20](\n  //blue\n  vec3( 1.0/PHI, 0.0,  PHI), //up right\n  vec3(-1.0/PHI, 0.0,  PHI), //up left\n  vec3( 1.0/PHI, 0.0, -PHI), //down right\n  vec3(-1.0/PHI, 0.0, -PHI), //down left\n  \n  //green\n  vec3(0.0,  PHI,  1.0/PHI), //up right\n  vec3(0.0, -PHI,  1.0/PHI), //up left\n  vec3(0.0,  PHI, -1.0/PHI), //down right\n  vec3(0.0, -PHI, -1.0/PHI), //down left\n  \n  //pink\n  vec3( PHI,  1.0/PHI, 0.0), //far right\n  vec3(-PHI,  1.0/PHI, 0.0), //far left\n  vec3( PHI, -1.0/PHI, 0.0), //near right\n  vec3(-PHI, -1.0/PHI, 0.0), //near left\n  \n  //orange\n  vec3( 1,  1,  1), \n  vec3( 1,  1, -1),\n  vec3( 1, -1,  1),\n  vec3( 1, -1, -1),\n  vec3(-1,  1,  1),\n  vec3(-1,  1, -1),\n  vec3(-1, -1,  1),\n  vec3(-1, -1, -1)\n  \n);\nint[108] triagList = int[](\n    1, 6, 15,\n    1, 6, 2,\n    2, 19, 6,\n    \n    15, 11, 16,\n    15, 6, 16,\n    6, 16, 8,\n    \n    1, 13, 9,\n    1, 9, 15,\n    15, 9, 11,\n    \n    19, 6, 8,\n    19, 8, 12,\n    12, 8, 20,\n    \n    20, 8, 16, \n    20, 16, 4,\n    16, 4, 3,\n    \n    11, 16, 3,\n    11, 3, 9, \n    3, 9, 14, \n    \n    1, 2, 17, \n    17, 1, 5,\n    1, 5, 13,\n    \n    7, 5, 13,\n    7, 13, 14,\n    13, 14, 9,\n    \n    4, 18, 7,\n    4, 7, 3,\n    3, 7, 14,\n    \n    2, 17, 19, \n    19, 17, 10, \n    10, 12, 19,\n    \n    4, 20, 18, \n    18, 20, 10, \n    20, 10, 12,\n    \n    10, 17, 5,\n    10, 5, 7, \n    10, 18, 7\n);\n\n\n/*light init*/\nconst int lightsCounter = 3;\nSphere Lights[lightsCounter];\n\n\n/*scale functions*/\nvec2 rotate(vec2 a, float b) {\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n\n/*utils*/\nfloat pow2(float x) \n{\n    return x * x;\n}\nfloat rand(float frame) \n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\nvec3 rgb2hsv(vec3 c) \n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c) \n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s23zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 157]], "test": "untested"}
{"id": "sdsXWr", "name": "Newton's Cradle Tutorial", "author": "BigWIngs", "description": "Lets make a Newtons Cradle", "tags": ["newtonscradle", "artofcode"], "likes": 44, "viewed": 1844, "published": 3, "date": "1618512451", "time_retrieved": "2024-07-30T19:26:00.917876", "image_code": "// \"Newton's Cradle Tutorial\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n// Patreon: https://www.patreon.com/TheArtOfCode\n//\n// This is the end-result of a tutorial I have on YouTube.\n// If you want to follow along you can start here:\n// https://youtu.be/nd7Auhb9YN8\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 6.\n#define SURF_DIST .001\n\n#if HW_PERFORMANCE!=0\n#define USE_AA\n#endif\n\n#define S smoothstep\n#define T iTime\n\nconst int MAT_BASE=1;\nconst int MAT_BARS=2;\nconst int MAT_BALL=3;\nconst int MAT_LINE=4;\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(vec2 p, vec2 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, p.y), 0.);\n}\n\nfloat sdLineSeg(vec3 p, vec3 a, vec3 b) {\n    vec3 ap=p-a, ab=b-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    vec3 c = a + ab*t;\n    return length(p-c);\n}\n\nvec2 sdBall(vec3 p, float a) {\n    \n    p.y-=1.01;\n    p.xy *= Rot(a);\n    p.y+=1.01;\n    \n    float ball = length(p)-.15;\n    float ring = length(vec2(length(p.xy-vec2(0, .15))-.03, p.z))-.01;\n    ball = min(ball, ring);\n    \n    p.z = abs(p.z);\n    float line = sdLineSeg(p, vec3(0,.15,0), vec3(0, 1.01, .4))-.005;\n    \n    float d = min(ball, line);\n    \n    return vec2(d, d==ball ? MAT_BALL : MAT_LINE);\n}\n\nvec2 Min(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\nvec2 GetDist(vec3 p) {\n    float base = sdBox(p, vec3(1,.1,.5))-.1;\n    float bar = length( vec2(sdBox(p.xy, vec2(.8,1.4))-.15, abs(p.z)-.4) )-.04;\n    \n    base += sin(p.x*10.)*.001;\n    \n    float \n        a = sin(iTime*3.),\n        a0 = a*.03,\n        a1 = min(0., a),\n        a5 = max(0., a);\n    \n    vec2 \n        b1 = sdBall(p-vec3(.6,.5,0), a0+a1),\n        b2 = sdBall(p-vec3(.3,.5,0), a0+(a+a1)*.05),\n        b3 = sdBall(p-vec3(0,.5,0), a0+a*.05),\n        b4 = sdBall(p-vec3(-.3,.5,0), a0+(a+a5)*.05),\n        b5 = sdBall(p-vec3(-.6,.5,0), a0+a5);\n    \n    vec2 balls = Min(b1, Min(b2, Min(b3, Min(b4, b5))));\n    \n    float d = min(base, bar);\n    d = min(d, balls.x);\n    \n    d = max(d, -p.y); // cut off the bottom\n    \n    int mat = 0;\n    \n    if(d==base)\n        mat = MAT_BASE;\n    else if(d==bar)\n        mat = MAT_BARS;\n    else if(d==balls.x)\n        mat = int(balls.y);\n        \n    return vec2(d, mat);\n}\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec2 dSMat = vec2(0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dSMat = GetDist(p);\n        dO += dSMat.x;\n        if(dO>MAX_DIST || abs(dSMat.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dSMat.y);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec4 Render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last) {\n    vec3 col = texture(iChannel0, rd).rgb;\n    vec2 dMat = RayMarch(ro, rd);\n    \n    ref *= 0.;\n    \n    float alpha = 0.;\n    if(dMat.x<MAX_DIST) {\n        vec3 p = ro + rd * dMat.x;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 refTex = texture(iChannel0, r).rgb;\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(0);\n        \n        int mat = int(dMat.y);\n        \n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n        if(mat==MAT_BASE) {\n            col += dif*.05;\n            ref = vec3(1)*fresnel;\n        } else if(mat==MAT_BARS) {\n            ref = vec3(.8);\n        } else if(mat==MAT_BALL) {\n            ref = vec3(.8, .6, .3);\n            if(last) col += refTex*ref;\n        } else if(mat==MAT_LINE)\n            col += dif*.1;\n            \n        ro = p + n*SURF_DIST*3.;\n        rd = r;\n        alpha = 1.;\n    }\n    return vec4(col, alpha);\n}\n\nvec3 RenderAll(vec2 pixCoord) {\n    vec2 uv = (pixCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.75,0), 2.);\n    vec3 col = vec3(0);\n    vec3 ref, fil=vec3(1);\n   \n    float numBounces = 3.;\n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = Render(ro, rd, ref, i==numBounces-1.);\n        col += pass.rgb*fil;\n        \n        fil*=ref;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    vec3 col = RenderAll(fragCoord);\n    #ifdef USE_AA\n    col +=\n        RenderAll(fragCoord+vec2(.5,.0))+\n        RenderAll(fragCoord+vec2(.0,.5))+\n        RenderAll(fragCoord+vec2(.5,.5));\n    col /= 4.;    \n    #endif\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound( int samp, float T )\n{\n    float \n        f = 3./3.1415,\n        t = fract(T*f),\n        m = smoothstep(.01, 0., t),\n        w = cos(t*1e5);\n    return vec2( w*m );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXWr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[778, 778, 797, 797, 859], [861, 861, 890, 890, 971], [973, 973, 1002, 1002, 1073], [1075, 1075, 1116, 1116, 1244], [1246, 1246, 1276, 1276, 1656], [1658, 1658, 1684, 1684, 1714], [1716, 1716, 1738, 1738, 2642], [2646, 2646, 2679, 2679, 2938], [2940, 2940, 2964, 2964, 3162], [3164, 3164, 3214, 3214, 3405], [3407, 3407, 3477, 3477, 4462], [4464, 4464, 4495, 4495, 5008], [5010, 5010, 5067, 5067, 5393]], "test": "untested"}
{"id": "fdsXDr", "name": "Bitwise lichen", "author": "jarble", "description": "This fractal looks like moss-covered bricks or tiles.", "tags": ["fractal", "wall", "bricks", "bitwise", "ruins", "lichen"], "likes": 12, "viewed": 307, "published": 3, "date": "1618498296", "time_retrieved": "2024-07-30T19:26:01.759626", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = .5;\n    float trans = iTime * 25.0*10.0;\n    vec2 coord = scale*(fragCoord + vec2(trans,0.0));\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev;\n    for(int i = 0; i < 9; i++){\n        col_prev = col;\n        coord.y += (4.0+result);\n        coord = coord.yx/(3.0);\n        result = ((result + float(val = ((int(coord.x) | int(coord.y)) % (3+val))))/(2.0));\n        col.x = (result+col.z)/2.0;\n        col = (fract((col.yzx))+col_prev)/2.0;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsXDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wlScR1", "name": "seamless-grid", "author": "xiaosong0911", "description": "smooth transition between grids of different scale", "tags": ["grid"], "likes": 4, "viewed": 365, "published": 3, "date": "1618490128", "time_retrieved": "2024-07-30T19:26:02.563476", "image_code": "float board(vec2 uv, float dx, float width, float one_in_pixels) {\n    uv /= dx;\n    uv = 0.5 - abs(uv-floor(uv)-0.5);\n    uv *= dx;\n    float dist = min(uv.x,uv.y);\n    return smoothstep(1.,-1., dist*one_in_pixels-width*0.5);\n}\n\nfloat boardauto(vec2 uv, float one_in_pixels) {\n    float mask = 0.;\n    float dx = exp(2.30258509299*ceil(-log(one_in_pixels)/2.30258509299));\n    float dxpixels = dx*one_in_pixels;\n    float alpha = (dxpixels-1.)/9.;\n    mask = max(mask, board(uv, dx * 1., 1., one_in_pixels) * alpha);\n    mask = max(mask, board(uv, dx * 5., 1.+alpha, one_in_pixels) * alpha);\n    mask = max(mask, board(uv, dx * 10., 1.+alpha*2., one_in_pixels));\n    mask = max(mask, board(uv, dx * 50., 2., one_in_pixels));\n    mask = max(mask, board(uv, dx * 100., 3., one_in_pixels));\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n    vec2 coord = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    float scale = exp(sin(.1*iTime)*0.5/.1);\n    vec3 col = vec3(1.-boardauto(coord*scale+vec2(1,0), iResolution.y/scale));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlScR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 228], [230, 230, 277, 277, 807], [809, 809, 866, 866, 1088]], "test": "untested"}
{"id": "fslSWr", "name": "Alien Bit Patterns", "author": "thope", "description": "Original tweet: https://twitter.com/aemkei/status/1378106731386040322\n\nTODO:\n- figure out how to do a perfecto loop\n- more bit patterns", "tags": ["alien", "xor", "pattern"], "likes": 5, "viewed": 336, "published": 3, "date": "1618488979", "time_retrieved": "2024-07-30T19:26:03.430159", "image_code": "/*\n    Not working in latest Safari! Try Chrome or something instead.\n*/\n\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 get_col(vec2 uv)\n{\n     return 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = get_col(uv);\n\n    // Adjust offset and scale\n    float scale = 0.1;\n    vec2 offset = iResolution.xy * 0.5;\n    offset.x -= iTime * 100.0;\n    offset.y += sin(iTime) * 100.0;\n    vec2 coord = fragCoord - offset;\n    coord *= scale;\n    \n    // Get x and y as integers\n    int x = abs(int(coord.x));\n    int y = abs(int(coord.y));\n    vec2 icoord = vec2(x,y);\n    \n    // Sparkle\n    float sparkle = random(icoord + iTime * 0.00001);\n    sparkle = saturate(sparkle - 0.2);\n    col = mix(get_col(uv + sparkle * 1.0), vec3(.0,.0,.0), sparkle);\n    \n    // Ripple\n    float ripple = texture(iChannel0, coord * 0.001 + iTime * 0.0001).r;\n    ripple *= texture(iChannel0, coord * 0.001 + iTime * 0.0001 * vec2(-.9,-1.)).r;\n    col *= saturate(ripple + 0.5);\n    \n    // Magic alien formulae\n    if((x ^ y) % 9 == 1)\n    {\n        fragColor = vec4(col,1.0);\n    }\n    else\n    {\n        col = get_col(uv) * ripple * 0.1;\n        fragColor = vec4(col,1.0);\n    }\n}\n\n/*\n    Unlicense    \n    This is free and unencumbered software released into the public domain.\n    For more information, please refer to <http://unlicense.org/>\n*/", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslSWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 98, 98, 205], [207, 207, 232, 232, 265], [267, 267, 290, 290, 345], [347, 347, 404, 454, 1499]], "test": "untested"}
{"id": "7dfSDr", "name": "315_filimonov_v3v0", "author": "ivanf", "description": "my task 2", "tags": ["mashgraph"], "likes": 1, "viewed": 193, "published": 3, "date": "1618473911", "time_retrieved": "2024-07-30T19:26:04.513263", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 glow = fire_color(2.5) * max(0., 1.1 - 1.8 * length(fragCoord - .5 * iResolution.xy ) / iResolution.y );\n\tvec3 col0 = texture(iChannel3, uv).rgb;\n    vec3 col1 = texture(iChannel2, uv).rgb;\n    fragColor = vec4(.06 * glow + max(col0, .8 * col1), 1.0) + texture(iChannel3, uv) + texture(iChannel0, uv) / float(iFrame + 1);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//MATH CONSTANTS\nconst float INF = 1e10;\nconst int rayMachingTimes = 20;\n\n// CAMERA SETTINGS\nconst float camera_x = 8.0;\nconst float camera_y =  1.2;\nconst float camera_z = -2.0;\nconst vec3 CAMERA_POS = vec3(camera_x, camera_y, camera_z);\n\n// FIRST LIGHT SOURCE\nconst vec3  LIGHT1_POS = vec3(-3, 1, -2);\nconst float LIGHT1_RADIUS = 0.4;\nconst vec3  LIGHT1_COLOR = vec3(0, 1.0, 1.0);\nconst float LIGHT1_BRIGHTNESS = 10.0f;\n\n// SECOND LIGHT SOURCE\nconst vec3  LIGHT2_POS = vec3(-2.5, 1.2, 4.0);\nconst float LIGHT2_RADIUS = 0.2;\nconst vec3  LIGHT2_COLOR = vec3(0.6, 1.0, 0.0);\nconst float LIGHT2_BRIGHTNESS = 20.0f;\n\n// CUBEMAP\nconst float CUBEMAP_BRIGHTNESS = 0.05;\n\n// OCTAHEDRON\nfloat octahedronScale = 0.8;\nvec3 octahedronShift = vec3(0.0,0.0,0.0);\n\n// MATERALS\nconst int EMISSION = 0;// majorly it's material of the light source. it's spreading light from itself\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\n// RANDOM\nvec3 randVals;\nvec3 randDir;\n\n// REFRACTION\nconst float GLASS_N = 1.5;\nconst float AIR_N = 1.0;\nconst float DIAMOND_N = 2.5;\n\n// MATH FUNCTIONS\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\nfloat pow2(float x) \n{\n    return x * x;\n}\n\n\n\n\n\n\n\n// TRACE FUNCTIONS\nfloat tracePolygon(vec3 pos, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out vec3 normal)\n{\n    // Polygon interception with v = pos + t*dir\n    // \n    // Read more about method here: \n    // http://masters.donntu.org/2015/frt/yablokov/library/transl.htm\n    // result = (t, u, v) \n    \n    vec3 result;\n    \n    vec3 T  = pos - v0;\n    vec3 E1 = v1  - v0;\n    vec3 E2 = v2  - v0;\n    \n    vec3 P  = cross(dir, E2);\n    vec3 Q  = cross(T,   E1);\n    \n    \n    float det = dot(P, E1);\n    \n    float t = dot(Q, E2) / det;\n    float u = dot(P, T)  / det;\n    float v = dot(Q, dir) /det ;\n    \n    \n    float A = (v1.y-v0.y)*(v2.z-v0.z) - (v2.y-v0.y)*(v1.z-v0.z);\n    float B = (v1.z-v0.z)*(v2.x-v0.x) - (v2.z-v0.z)*(v1.x-v0.x);\n    float C = (v1.x-v0.x)*(v2.y-v0.y) - (v2.x-v0.x)*(v1.y-v0.y);\n    \n    normal.x = A;\n    normal.y = B;\n    normal.z = C;\n    \n    normal = normalize(normal);\n    \n    if( u >= 0.0 && v >= 0.0 && u + v <= 1.0 && t > 0.0)\n        return t;\n    \n    return INF;\n}\nfloat traceOctahedron(vec3 pos, vec3 dir, float size, vec3 shift, out vec3 normal)\n{\n    // see function traceTriagle to see more information about \"scale\" parametr\n    float scaleOcta = 1.0/ size;\n    \n    int minIndex = 0;// index of intercepted triagle (from 0 to 7)\n    \n    vec3 normal1;\n    vec3 normal2; \n    vec3 normal3; \n    vec3 normal4; \n    vec3 normal5; \n    vec3 normal6; \n    vec3 normal7; \n    vec3 normal8; \n    \n    \n    \n    ///*\n    vec3 v1 = vec3(shift.x - scaleOcta, shift.y             , shift.z);\n    vec3 v2 = vec3(shift.x            , shift.y - scaleOcta , shift.z);\n    vec3 v3 = vec3(shift.x+scaleOcta  , shift.y             , shift.z);\n    vec3 v4 = vec3(shift.x            , shift.y+scaleOcta   , shift.z);\n    vec3 v5 = vec3(shift.x            , shift.y             , shift.z+scaleOcta);\n    vec3 v6 = vec3(shift.x            , shift.y             , shift.z-scaleOcta);\n    \n    \n    float T1 = tracePolygon (pos, dir, v1, v2, v5, normal1);\n    float T2 = tracePolygon (pos, dir, v2, v3, v5, normal2);\n    float T3 = tracePolygon (pos, dir, v3, v4, v5, normal3);\n    float T4 = tracePolygon (pos, dir, v4, v1, v5, normal4);\n    float T5 = tracePolygon (pos, dir, v1, v2, v6, normal5);\n    float T6 = tracePolygon (pos, dir, v2, v3, v6, normal6);\n    float T7 = tracePolygon (pos, dir, v3, v4, v6, normal7);\n    float T8 = tracePolygon (pos, dir, v4, v1, v6, normal8);\n    //*/\n    /*\n    float T1 = traceTriangle (pos, dir, vec3(scaleOcta, scaleOcta, scaleOcta), shift , normal1);\n    float T2 = traceTriangle (pos, dir, vec3(-scaleOcta, scaleOcta, scaleOcta), shift , normal2);\n    float T3 = traceTriangle (pos, dir, vec3(scaleOcta, -scaleOcta, scaleOcta), shift , normal3);\n    float T4 = traceTriangle (pos, dir, vec3(-scaleOcta, -scaleOcta, scaleOcta), shift , normal4);\n    float T5 = traceTriangle (pos, dir, vec3(scaleOcta, scaleOcta, -scaleOcta), shift , normal5);\n    float T6 = traceTriangle (pos, dir, vec3(-scaleOcta, scaleOcta, -scaleOcta), shift , normal6);\n    float T7 = traceTriangle (pos, dir, vec3(scaleOcta, -scaleOcta, -scaleOcta), shift , normal7);\n    float T8 = traceTriangle (pos, dir, vec3(-scaleOcta, -scaleOcta, -scaleOcta), shift , normal8);\n    */\n    \n    \n    //find min of all this triagles and minIndex\n    vec3[]  arrayN = vec3[] ( normal1,normal2,normal3,normal4,normal5,normal6,normal7,normal8 );\n    float[] arrayD = float[](   T1,     T2,     T3,     T4,     T5,     T6,     T7,     T8    );\n \n \n    float minT = arrayD[0];\n    \n    for (int i = 1; i < 8; i++)\n \n        if (minT > arrayD[i])\n        {\n            minT = arrayD[i];\n            minIndex = i;\n        }\n    \n    \n    \n    \n    // Output values\n    normal = arrayN[minIndex];\n    return arrayD[minIndex];\n    \n    \n    \n    \n    // old version \n    //return min(min(min(min(min(min(min(T1,T2),T3),T4),T5),T6),T7),T8);\n}\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) \n{\n    // pos -  \n    // dir - \n    //  dir   y = -1.5\n    // (AMERA_POS + t * dir).y == -1.5\n    // t = (-1.5 - pos.y) / dir.y\n    float planePosY = -1.5;\n    float t = (planePosY - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 50.0) {\n        return INF;\n    }\n    \n    normal = vec3(0, 1, 0);\n    \n    return t;\n}\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal )\n{\n    // dot(pos + t*dir, pos + t*dir) == r*r\n    // dot(pos, pos) + 2*t*dot(pos,dir) + t*t*dot(dir,dir) == r*r\n    // because of dot(dir,dir) == 1\n    \n    // t*t + 2*t*dot(pos,dir) + dot(pos, pos) - r*r == 0\n    \n    float b = dot(pos,dir);\n    float D = b * b - dot(pos, pos) + r*r;\n    \n    // if not intercept\n    if (D < 0.0)\n        return INF;\n    \n    \n    // it might be 2 roots. Choise the right one.\n    float t = -b - sqrt(D);\n    \n    if (t > 0.0){\n        normal = normalize(pos + t*dir) ;\n        return t;\n    }\n    \n    t = -b + sqrt(D);\n    if (t < 0.0)\n        return INF;\n    \n    \n    normal = normalize(pos + t*dir) ;\n    return t;\n}\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) \n{\n\n    float h = -1.3;\n    \n    float t = (h - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 1.0) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 1.0;\n    \n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    \n    t = (-b - sqrt(D)) / a;\n    \n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= h) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    \n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    \n    worldPos = t * dir + pos;\n    if (worldPos.y <= h) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    \n    return INF;\n}\n\n\n\n\n\n\n// SHADOW, LIGHT, REFRACTION FUNCTIONS\nbool isOccluded(vec3 pos, vec3 target) \n{\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n\n      \n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n    \n    vec3 octahedronNormal;\n    float octahedronT = traceOctahedron(pos, dir, octahedronScale, octahedronShift, octahedronNormal);\n    if(octahedronT < dist)\n        return true;\n        \n    vec3 octahedron2Normal;\n    float octahedron2T = traceOctahedron(pos, dir, octahedronScale, vec3(1.0, 0.0, 3.0), octahedronNormal);\n    if(octahedron2T < dist)\n        return true;\n        \n        \n    \n}\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal)\n{\n    // use formula from given task\n    // I = emissive + ambient + diffuse* att + speculat*att\n    // att = 1/dist^2\n    \n    \n    // LIGHT 1\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float dist1 = length(toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : LIGHT1_BRIGHTNESS / (dist1 * dist1);\n    \n    // LIGHT 2 \n    vec3 toLight2 = LIGHT2_POS - pos;\n    float dist2 = length(toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : LIGHT2_BRIGHTNESS / (dist2 * dist2);\n    \n    \n    // Output\n    return color *( \n    \n          max(0.0, dot(normal, normalize (toLight1) ) ) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize (toLight2) ) ) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * CUBEMAP_BRIGHTNESS\n    );\n}\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) \n{\n    if (dot(v, normal) < 0.0) {\n        //   \n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    //  \n    vec3 tang = normalize(v - cosA * normal);\n    //   \n    float sinB = sinA / n2 * n1;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Random numbers \n    randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals);\n    \n    \n    // Anti-aliasing for better image. AA from -1 to 1\n    vec2 AA = (randVals.xy - 0.5 ) * 2.0;\n    \n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - iResolution.xy/2.0 + AA)/iResolution.x;\n\n\n    // Vectors front up and right helps to create viewVec\n    vec3 front = normalize(-CAMERA_POS); //vector from (0,0,0) to CAMERA_POS\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up)); \n    up = normalize(cross(right, front));\n\n\n    // viewVec looks from CAMERA_POS from pixel (uv.x, uv.y) and go forward\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    \n    // motion blur\n    vec3 LIGHT1_POS = vec3(-1, 1, -2) + vec3(1, 1, 0) * randVals * 0.07;\n    // motion blur in one direction\n    vec3 LIGHT2_POS = vec3(0.4, 1.2, 2) + vec3(0, 1, 0) * randVals.y * 0.06;\n\n\n    // Current camera position and direction \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n\n\n    // For refraction (from physics) \n    float n1 = AIR_N;\n    float nEnter;\n    \n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    // doing Ray-Marching 20 times\n    for (int i = 0; i < rayMachingTimes; ++i) {\n    \n    \n        // if planeT will equal to distance to table then t = planeT, otherwise t = infinity.\n        float t = INF;\n        \n        // Properties of intercepted surface.\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        \n        // For refraction\n        nEnter = AIR_N;\n        \n        \n        // TABLE RENDERING\n        {\n            vec3 planeNorm;\n            float planeT = tracePlane(curPos, curDir, planeNorm);\n            if (planeT < t) {\n                t = planeT;\n                materialType = DIFFUSE;\n                vec3 worldPos = t * curDir + curPos;\n                color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n                normal = planeNorm;\n\n\n                // for make floor reflaction\n                if(randVals.y < 0.19)\n                    materialType = REFLECTION;\n            }\n        }\n        \n        // LIGHT 1 RENDERING\n        {\n            vec3 l1Norm;\n            float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n            if (light1T < t) {\n                t = light1T;\n                materialType = EMISSION;\n                color = LIGHT1_COLOR;\n                normal = l1Norm;\n            }\n        }\n        \n        // LIGHT 2 RENDERING\n        {\n            vec3 l2Norm;\n            float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n            if (light2T < t) {\n                t = light2T;\n                materialType = EMISSION;\n                color = LIGHT2_COLOR;\n                normal = l2Norm;\n            }\n        }\n        \n        // OCTAHEDRON RENDERING\n        {\n            vec3 octahedronNormal;\n\n            float octahedronT  = traceOctahedron(curPos, curDir, octahedronScale, octahedronShift, octahedronNormal);\n            // If trace is intercept with octahedron then make t shorter and equal to distance between camera and table.\n            if (octahedronT < t)\n            {\n                t = octahedronT;\n                color = vec3(0.0,0.0,1.0);\n                normal = octahedronNormal;\n\n                //combine reflection and refraction;\n                if(randVals.x*0.2 < GLASS_R)\n                    materialType = REFLECTION;\n\n                else{\n                    materialType = REFRACTION;\n                    // We need to know what is outside the object \n                    if( dot(curDir, normal) > 0.0 )// they not oppodite directed\n                    {\n                        nEnter = AIR_N;\n                    }\n                    else // they opposite directed \n                    {\n                        nEnter = GLASS_N;\n\n                    }\n\n                }\n                //materialType = REFRACTION;\n\n            }\n        }\n        \n        // OCTAHEDRON 2 RENDERING\n        {\n            vec3 octahedron2Normal;\n\n            float octahedron2T  = traceOctahedron(curPos, curDir, octahedronScale, vec3(1.0, 0.0, 3.0), octahedron2Normal);\n            // If trace is intercept with octahedron then make t shorter and equal to distance between camera and table.\n            if (octahedron2T < t)\n            {\n                t = octahedron2T;\n                color = vec3(1.0,0.5,0.0);\n                normal = octahedron2Normal;\n\n                \n                materialType = DIFFUSE;\n\n            }\n        }\n        \n        // CYLINDER RENDERING\n        {\n            vec3 cylNorm;\n            float cylT = traceCylinder(curPos, curDir, cylNorm);\n            if (cylT < t) {\n                t = cylT;\n                materialType = DIFFUSE;\n                vec3 worldPos = t * curDir + curPos;\n                color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n                normal = cylNorm;\n            }\n        }\n        \n        \n        \n        \n        \n        \n     \n        // IF WE INTERCEPT SOMETHING\n        {\n            if (t != INF) {\n            \n                vec3 worldPos = t * curDir + curPos;\n                fragColor = texture(iChannel0, worldPos.xz);\n                \n                \n                \n                if (materialType == EMISSION) {\n                    fragColor.rgb = color * colorMult;\n                    break;\n                    \n                    \n                } else if (materialType == DIFFUSE) {\n                    fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                    break;\n                    \n                    \n                } else if (materialType == REFLECTION) {\n                    curDir = reflect(curDir, normal);\n                    curPos = worldPos + curDir * 1e-5;\n                    \n                    \n                } else if (materialType == REFRACTION) {\n                    curDir = refraction(curDir, normal, n1, nEnter);\n                    curPos = worldPos + curDir * 1e-5;\n                    n1 = nEnter;\n                }\n            } \n            else \n                fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n        }\n        \n        \n        \n        \n        \n    }\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 fire_color(float x)\n{\n\treturn\n        // red\n        vec3(1., 0., 0.) * x\n        // yellow\n        + vec3(1., 1., 0.) * clamp(x - .5, 0., 1.)\n        // white\n        + vec3(1., 1., 1.) * clamp(x - .7, 0., 1.);\n}", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float A = 1.;\n\tconst int N = 2;\n\n    vec4 col = vec4(0);\n    for (int yoff = -N; yoff <= N; ++yoff) {\n        for (int xoff = -N; xoff <= N; ++xoff) {\n            vec2 off = vec2(xoff, yoff);\n            vec2 uv = (fragCoord + A * off) / iResolution.xy;\n            col += texture(iChannel0, uv) / (.5 + 1. * length(off / vec2(N, N)));\n        }\n    }\n\n    fragColor = vec4(col.rgb / float((N + N) * (N + N)), 1.0);\n}", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "mat4 rotate(float a, vec3 v)\n{\n    float c = cos(a);\n    vec3 ci = (1. - c) * v;\n    vec3 s = sin(a) * v;\n\n    return mat4(\n        ci.x * v.x + c, ci.x * v.y + s.z, ci.x * v.z - s.y, 0,\n        ci.y * v.x - s.z, ci.y * v.y + c, ci.y * v.z + s.x, 0,\n        ci.z * v.x + s.y, ci.z * v.y - s.x, ci.z * v.z + c, 0,\n        0, 0, 0, 1\n\t);\n}\n\nmat4 translate(vec3 v)\n{\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        v.x, v.y, v.z, 1\n    );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat traceSphere(vec3 origin, vec3 target, vec3 center, float radius)\n{\n    vec3 oc = origin - center;\n    float a = dot(target, target);\n    float b = 2. * dot(oc, target);\n    float c = dot(oc, oc) - radius * radius;\n    float disc = b * b - 4. * a * c;\n    if (disc < 0.) {\n        // no intersection\n        return -1.;\n    } else {\n        return (-b - sqrt(disc)) / (2. * a);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 mvp = rotate(radians(0. * iTime), vec3(0, 1, 0));\n    \n\tvec3 dir = (mvp * vec4(rayDirection(145.0, iResolution.xy, fragCoord), 1.)).xyz;\n    vec3 eye = (mvp * vec4(0., 0., 1.9, 1.)).xyz;\n\n    vec3 sphere_pos = vec3(0., 0., 0.);\n\n    float intensity = 0.;\n    \n    mat4 tex_mat = mat4(1.);\n    mat4 wind_mat = mat4(1.);\n    for (int i = 0; i < 9; ++i) {\n        float t = traceSphere(eye, dir, sphere_pos, 1. - float(i) / 40.);\n\n        if (t > 0.) {\n            vec3 hit_pos = eye + dir * t;\n            vec3 t_hit_pos = (tex_mat * wind_mat * vec4(hit_pos, 1.)).xyz;\n            vec3 normal = normalize(t_hit_pos - sphere_pos);\n\n            float alpha = texture(iChannel0, 1. / float(i) * vec2(atan(normal.z, normal.x) / radians(90.), normal.y)).r;\n\t\t\tintensity += step(1. - float(i) / 6., alpha) * .8 * alpha * max(0., dot(vec3(0, 0, 1.), hit_pos));\n\n            tex_mat = rotate(radians(11.) * iTime, normalize(vec3(.3, -.7, .1))) * tex_mat;\n            wind_mat = rotate(radians(15.) * iTime, normalize(vec3(1., 0., 0.))) * wind_mat;\n        }\n    }\n\n\tfragColor = vec4(fire_color(intensity), 1.);\n}", "buffer_d_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfSDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 433]], "test": "untested"}
{"id": "7sfXDn", "name": "Ordered Dithering (Bayer)", "author": "Tech_", "description": "Here is a nice little dithering shader! Hope you enjoy!", "tags": ["dithering"], "likes": 21, "viewed": 3475, "published": 3, "date": "1618468978", "time_retrieved": "2024-07-30T19:26:05.301157", "image_code": "\nfloat Bayer2(vec2 a) {\n    a = floor(a);\n    return fract(a.x / 2. + a.y * a.y * .75);\n}\n\n#define Bayer4(a)   (Bayer2 (.5 *(a)) * .25 + Bayer2(a))\n#define Bayer8(a)   (Bayer4 (.5 *(a)) * .25 + Bayer2(a))\n#define Bayer16(a)  (Bayer8 (.5 *(a)) * .25 + Bayer2(a))\n#define Bayer32(a)  (Bayer16(.5 *(a)) * .25 + Bayer2(a))\n#define Bayer64(a)  (Bayer32(.5 *(a)) * .25 + Bayer2(a))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dithering = Bayer64(fragCoord * 0.25) - 0.5;\n    vec2 uv = fragCoord / iResolution.xy;\n \n    uv.x += dithering;   \n   \n    fragColor = vec4(uv.x < 0.5);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfXDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 89], [377, 377, 434, 434, 599]], "test": "untested"}
{"id": "7dXXDn", "name": "2D Lighting - No Random Sampling", "author": "oneshade", "description": "Improved version of this shader: [url=https://www.shadertoy.com/view/3tsXzB]https://www.shadertoy.com/view/3tsXzB[/url]\nTodo: add shadows", "tags": ["2d", "light", "analytic"], "likes": 5, "viewed": 261, "published": 3, "date": "1618468254", "time_retrieved": "2024-07-30T19:26:06.064116", "image_code": "// 2D area lights I've been working on\n// https://www.shadertoy.com/view/fsfXDr\nfloat lightLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, pb = p - b;\n    return acos(dot(pa, pb) / (length(pa) * length(pb))) / 3.14;\n}\n\n// https://www.shadertoy.com/view/fsfSWn\nfloat lightDisc(in vec2 p, in float r) {\n    float dd = dot(p, p);\n    if (dd < r * r) return 1.0;\n    return 1.0 - acos(r / sqrt(dd)) / 1.57;\n}\n\n// https://www.shadertoy.com/view/ssXSDn\nfloat lightBox(in vec2 p, in vec2 b) {\n    p = abs(p);\n    if (all(lessThan(p, b))) return 1.0;\n    vec2 v1 = p - vec2(b.x * sign(b.y - p.y), b.y);\n    vec2 v2 = p - vec2(b.x, b.y * sign(b.x - p.x));\n    return acos(dot(v1, v2) / (length(v1) * length(v2))) / 3.14;\n}\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisc(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    vec3 color = vec3(0.0);\n\n    // UV relative to each light\n    vec2 bp1 = uv + vec2(1.6, -0.4);\n    vec2 bp2 = uv + vec2(0.0, sin(iTime));\n    vec2 dp = uv - vec2(1.6, 0.4);\n\n    // Solid color on the insides\n    if (sdBox(bp1, vec2(0.4)) < 0.0) color.gb += 1.0;\n    else if (sdBox(bp2, vec2(0.4, 1.5)) < 0.0) color.r += 0.8;\n    else if (sdDisc(dp, 0.2) < 0.0) color += 1.0;\n\n    // Lighting on the outsides\n    else {\n        color.gb += lightBox(bp1, vec2(0.4)) * 1.5;\n        color.r += lightBox(bp2, vec2(0.4, 1.5)) * 0.65;\n        color.rb += lightDisc(dp, 0.2) * vec2(0.5, 3.0);\n        color *= 0.6; // Tone down the brightness\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXXDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 80, 130, 130, 230], [232, 273, 313, 313, 417], [419, 460, 498, 498, 726], [728, 736, 783, 783, 891], [893, 893, 930, 930, 958], [960, 960, 995, 995, 1080], [1082, 1082, 1137, 1137, 1891]], "test": "untested"}
{"id": "7dfSDn", "name": "Northern Journey", "author": "TEttinger", "description": "A slow trek through a nearly-infinite span of changing colorful noise. Position changes over time, so the type of visual may change somewhat.", "tags": ["noise", "plasma", "lights", "journey", "northern"], "likes": 5, "viewed": 330, "published": 3, "date": "1618467351", "time_retrieved": "2024-07-30T19:26:06.837050", "image_code": "// CC0 licensed, do what thou wilt.\nconst float SEED = 42.0;\nconst vec3 COEFFS = fract((SEED + 23.4567) * vec3(0.8191725133961645, 0.6710436067037893, 0.5497004779019703)) + 0.5;\n\nvec3 swayRandomized(vec3 seed, vec3 value)\n{\n    return sin(seed.xyz + value.zxy - cos(seed.zxy + value.yzx) + cos(seed.yzx + value.xyz));\n}\n\n// this function, if given steadily-increasing values in con, may return exponentially-rapidly-changing results.\n// even though it should always return a vec3 with components between -1 and 1, we use it carefully.\nvec3 cosmic(vec3 c, vec3 con)\n{\n    vec3 n = con;\n    n += swayRandomized(c, con.yzx);\n    n += swayRandomized(c + 1.0, con.xyz);\n    n += swayRandomized(c + 2.0, con.zxy);\n    return n * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 64.0 + swayRandomized(COEFFS.zxy, (iTime * 0.25) * COEFFS.yzx).xy * 32.0;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.0625 + 32.0;\n    vec3 adj = vec3(-1.11, 1.41, 1.61);\n    vec3 s = (swayRandomized(vec3(34.0, 76.0, 59.0), aTime + adj)) * 0.25;\n    vec3 c = (swayRandomized(vec3(27.0, 67.0, 45.0), aTime - adj)) * 0.25;\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    \n    con = cosmic(COEFFS, con);\n    con = cosmic(COEFFS, con);\n    con = cosmic(COEFFS, con);\n    \n    fragColor = vec4(swayRandomized(COEFFS + 3.0, con * (2.0 * 3.14159265)) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 224, 224, 320], [322, 536, 567, 567, 731], [733, 733, 790, 840, 1527]], "test": "untested"}
{"id": "ssXSDn", "name": "2D Light Coverage - Box", "author": "oneshade", "description": "Lighting based on the probability that a light ray reaches a pixel.", "tags": ["2d", "light", "box", "coverage"], "likes": 6, "viewed": 203, "published": 3, "date": "1618463110", "time_retrieved": "2024-07-30T19:26:07.606991", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec3 color = vec3(0.0);\n\n    vec2 b = vec2(1.0 + 0.5 * cos(iTime), 0.5 + 0.25 * sin(iTime));\n\n    uv = abs(uv);\n    if (all(lessThan(uv, b))) color += 1.0;\n    else {\n        vec2 v1 = uv - vec2(b.x * sign(b.y - uv.y), b.y);\n        vec2 v2 = uv - vec2(b.x, b.y * sign(b.x - uv.x));\n        color += acos(dot(v1, v2) / (length(v1) * length(v2))) / 3.14;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 555]], "test": "untested"}
{"id": "7dXXWn", "name": "domain_wraping_noise_texture", "author": "penghuailiang", "description": "\nBlog: https://huailiang.github.io/blog/2021/noise/", "tags": ["noise", "fbm", "domian"], "likes": 7, "viewed": 377, "published": 3, "date": "1618457816", "time_retrieved": "2024-07-30T19:26:08.371946", "image_code": "#define OCTAVE_NUM 4\n\nvec3 random_perlin( vec3 p ) {\n    p = vec3(\n            dot(p,vec3(127.1,311.7,69.5)),\n            dot(p,vec3(269.5,183.3,132.7)), \n            dot(p,vec3(247.3,108.5,96.5)) \n            );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise_perlin (vec3 p) {\n    vec3 i = floor(p);\n    vec3 s = fract(p);\n\n    float a = dot(random_perlin(i),s);\n    float b = dot(random_perlin(i + vec3(1, 0, 0)),s - vec3(1, 0, 0));\n    float c = dot(random_perlin(i + vec3(0, 1, 0)),s - vec3(0, 1, 0));\n    float d = dot(random_perlin(i + vec3(0, 0, 1)),s - vec3(0, 0, 1));\n    float e = dot(random_perlin(i + vec3(1, 1, 0)),s - vec3(1, 1, 0));\n    float f = dot(random_perlin(i + vec3(1, 0, 1)),s - vec3(1, 0, 1));\n    float g = dot(random_perlin(i + vec3(0, 1, 1)),s - vec3(0, 1, 1));\n    float h = dot(random_perlin(i + vec3(1, 1, 1)),s - vec3(1, 1, 1));\n\n    vec3 u = smoothstep(0.,1.,s);\n\n    return mix(mix(mix( a, b, u.x),\n                mix( c, e, u.x), u.y),\n            mix(mix( d, f, u.x),\n                mix( g, h, u.x), u.y), u.z);\n}\n\n\n// 5\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    float a = 1.;\n    p = 2.0 * p;\n    for (int i = 0; i < OCTAVE_NUM; i++) {\n        f += a * noise_perlin(p);\n        p = 2.0 * p;\n        a /= 2.;\n    }\n    return f;\n}\n\nfloat domain_wraping( vec3 p )\n{\n    float v1 = fbm(p);\n    vec3 q = vec3(v1, v1, v1);\n    float v2 = fbm(p+q);\n    vec3 r = vec3(v2, v2, v2);\n    return fbm(p + r);\n}\n\nvec3 clamp01(vec3 c)\n{\n    return clamp(c,vec3(0.,0.,0.),vec3(1.,1.,1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float c1 = domain_wraping(vec3(1.*uv, iTime/10.0));\n    vec3 c = vec3(c1*c1 + 1.1*c1, 1.4*c1, 0.4*c1*c1);\n    vec3 color = 4. * c*c;\n    fragColor = vec4(clamp01(color), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXXWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 52, 52, 265], [266, 266, 295, 295, 1069], [1072, 1101, 1120, 1120, 1311], [1313, 1313, 1345, 1345, 1480], [1482, 1482, 1504, 1504, 1556], [1558, 1558, 1613, 1613, 1839]], "test": "untested"}
{"id": "ssfSWn", "name": "fbm_perlin_texture", "author": "penghuailiang", "description": "fbm perlin noise texture", "tags": ["fbm", "perlin"], "likes": 3, "viewed": 1939, "published": 3, "date": "1618456532", "time_retrieved": "2024-07-30T19:26:09.137898", "image_code": "#define OCTAVE_NUM 5\n\nvec3 random_perlin( vec3 p ) {\n    p = vec3(\n            dot(p,vec3(127.1,311.7,69.5)),\n            dot(p,vec3(269.5,183.3,132.7)), \n            dot(p,vec3(247.3,108.5,96.5)) \n            );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise_perlin (vec3 p) {\n    vec3 i = floor(p);\n    vec3 s = fract(p);\n\n    float a = dot(random_perlin(i),s);\n    float b = dot(random_perlin(i + vec3(1, 0, 0)),s - vec3(1, 0, 0));\n    float c = dot(random_perlin(i + vec3(0, 1, 0)),s - vec3(0, 1, 0));\n    float d = dot(random_perlin(i + vec3(0, 0, 1)),s - vec3(0, 0, 1));\n    float e = dot(random_perlin(i + vec3(1, 1, 0)),s - vec3(1, 1, 0));\n    float f = dot(random_perlin(i + vec3(1, 0, 1)),s - vec3(1, 0, 1));\n    float g = dot(random_perlin(i + vec3(0, 1, 1)),s - vec3(0, 1, 1));\n    float h = dot(random_perlin(i + vec3(1, 1, 1)),s - vec3(1, 1, 1));\n\n    vec3 u = smoothstep(0.,1.,s);\n\n    return mix(mix(mix( a, b, u.x),\n                mix( c, e, u.x), u.y),\n            mix(mix( d, f, u.x),\n                mix( g, h, u.x), u.y), u.z);\n}\n\n// 5\nfloat noise_fbm(vec3 p)\n{\n    float f = 0.0;\n    float a = 1.;\n    p = 4.0 * p;\n    for (int i = 0; i < OCTAVE_NUM; i++) {\n        f += a * noise_perlin(p);\n        p = 2.0 * p;\n        a /= 2.;\n    }\n    return f;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float c1 = noise_fbm(vec3(1.*uv, iTime/10.0));\n    vec3 color = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1*c1);\n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfSWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 52, 52, 265], [266, 266, 295, 295, 1069], [1071, 1100, 1125, 1125, 1316], [1317, 1317, 1372, 1372, 1568]], "test": "untested"}
{"id": "sdfSWn", "name": "Bitwise ice", "author": "jarble", "description": "This fractal looks like snow and ice.", "tags": ["fractal", "ice", "snow", "bitwise"], "likes": 2, "viewed": 248, "published": 3, "date": "1618456360", "time_retrieved": "2024-07-30T19:26:09.907839", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 0.4;\n    float trans = iTime * 25.0;\n    vec2 coord = (scale * fragCoord) + vec2(trans,0.0);\n    \n    int val = 0;\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev;\n    for(int i = 0; i < 9; i++){\n        col_prev = col;\n        coord.y += (4.0);\n        coord = coord.yx/(9.0);\n        result = ((result + float(val = ((int(coord.x+coord.y*3.0) | int(coord.y-coord.x*3.0)) % 3)))/(2.0));\n        col.x = (result+col.z)/2.0;\n        col = (fract((col.yzx))+col_prev)/2.0;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfSWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fsfXDr", "name": "2D Light Coverage - Line", "author": "oneshade", "description": "Lighting based on the probability that a light ray hits a pixel. This time its a line (no thickness).", "tags": ["2d", "line", "light", "coverage"], "likes": 12, "viewed": 327, "published": 3, "date": "1618454524", "time_retrieved": "2024-07-30T19:26:10.674789", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec3 color = vec3(0.0);\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 lineLightA = vec2(c3, s2);\n    vec2 lineLightB = vec2(s3, c1);\n\n    vec2 v1 = uv - lineLightA, v2 = uv - lineLightB;\n    color += acos(dot(v1, v2) / (length(v1) * length(v2))) / 3.14;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfXDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 588]], "test": "untested"}
{"id": "NdXXDr", "name": "Hallway Stroll 2", "author": "percentcer", "description": "Taking a walk again. Made use of some of the bitwise manipulation in https://www.shadertoy.com/view/fdXSWn", "tags": ["grid", "fract", "bitwise"], "likes": 2, "viewed": 210, "published": 3, "date": "1618453304", "time_retrieved": "2024-07-30T19:26:11.449717", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    const float WIDTH = 16.;\n    vec2 cell = floor(uv * WIDTH);\n\n    vec3 col = abs(\n        vec3(\n        cell.x*sin( -iTime*2. + abs(cell.x)*.05 ),\n        cell.y*1.1+sin(iTime*4.),\n        cell.y)\n    ) * (1./WIDTH);\n\n    float result = 0.;\n    int val = int(col.x) & int(col.y) % 3;\n    for(int i = 0; i < 3; i++){\n        col.y -= (.2 - result);\n        col *= 1.5;\n        val = (int(col.x-col.y) & int(col.y+col.x*4.0)) % 3;\n        result = (result + float(val)) * .5;\n        col.x = (result*2.0+col.x)/3.0;\n        col = col.yzx;\n    }  \n    \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXXDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fsXSDr", "name": "Bitwise clouds", "author": "jarble", "description": "This shader looks like clouds over the sea.", "tags": ["fractal", "sea", "clouds", "ocean", "forest", "bitwise"], "likes": 3, "viewed": 236, "published": 3, "date": "1618450640", "time_retrieved": "2024-07-30T19:26:12.212677", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 0.2;\n    float trans = iTime * 25.0;\n    vec2 coord = (scale * fragCoord.yx) + vec2(trans,0.0);\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 12; i++){\n        coord.y -= (3.0-result);\n        coord = coord/(2.5);\n        result = ((result + float(val = ((int(coord.x-coord.y) & int(coord.y+coord.x*2.0)) % 3)))/(2.0));\n        col.x = (result*(2.0)+col.z)/3.0;\n        col = col.yzx;\n    }\n    // Output.\n    fragColor = vec4((col/2.0),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXSDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fsXXWr", "name": "Hallway Stroll", "author": "percentcer", "description": "Taking a walk", "tags": ["grid", "fract"], "likes": 1, "viewed": 242, "published": 3, "date": "1618447076", "time_retrieved": "2024-07-30T19:26:12.982618", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    const float WIDTH = 16.;\n    vec2 cell = floor(uv * WIDTH);\n\n    vec3 col = abs(\n        vec3(\n        cell.x*sin( -iTime*2. + abs(cell.x)*.5 ),\n        cell.y*1.1+sin(iTime*4.),\n        cell.y)\n    ) * (1./WIDTH);\n    \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXXWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 379]], "test": "untested"}
{"id": "fdXSWr", "name": "Tribute-Pink Floyd live graphics", "author": "Pelegefen", "description": "Ok, i think i got the clock gang thing covered by now.\nLast Clock shader. promise. (for the meanwhile).\nAnyway that is the base shader i wanted to do from the start.\nits a tribute to the live graphics PinkFloyd used while preforming.\ninfo,credits, in code", "tags": ["time", "clock", "starfield", "tribute", "musicvideo", "pinkfloyd"], "likes": 1, "viewed": 276, "published": 3, "date": "1618445528", "time_retrieved": "2024-07-30T19:26:13.936069", "image_code": "// Main shader at Buffer C, this is a watercolor-like post-procces effects.\n\n\n// Original Clip - https://www.youtube.com/watch?v=BJImSd32f3Y&ab_channel=GoodOldMusic\n\n// Pink floyd's Time Tribute -  Clock shader by Peleg Gefen.\n// Basicaly a \"starfield\" effect with 2D clocks instead of stars, some \"3D\" trickery with UV manipulations.\n// The clocks are set of course, but might not be the best way to tell time, i'll leave it to you.\n\n// I Drew from the abyss Raja's watercolor shader and updated it to run in WebGL2.0 (added 1 to sample func lol)\n// link to WaterColor shader (dead) - https://www.shadertoy.com/view/Xdc3Df\n\n// took alot of inspiration from \"The Art Of Code - Starfield tutorial\" By Martijn Steinrucken\n// link to tutorial (very much alive) - https://www.youtube.com/watch?v=rvDo9LvfoVE&t=391s&ab_channel=TheArtofCode\n\n\n//water color FX r\nconst int radius = 8;\n\n\n\nvec3 sample1( vec2 fragCoord, const int x, const int y)\n{\n\tvec2 uv = (fragCoord.xy + vec2(x, y)) / iResolution.xy;\n\t//uv.y = 1.0 - uv.y;\n\t\n\treturn texture(iChannel1, uv).xyz;\n}\n\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n {\n\t vec2 src_size = vec2 (1.0 / iResolution.x, 1.0 / iResolution.y);\n     vec2 uv = fragCoord.xy/iResolution.xy;\n\n     float n = float((radius + 1) * (radius + 1));\n     int i; \n\t int j;\n     vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n     vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n     vec3 c;\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(iChannel1, uv + vec2(i,j) * src_size).rgb;\n             m0 += c;\n             s0 += c * c;\n         }\n     }\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(iChannel1, uv + vec2(i,j) * src_size).rgb;\n             m1 += c;\n             s1 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(iChannel1, uv + vec2(i,j) * src_size).rgb;\n             m2 += c;\n             s2 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(iChannel1, uv + vec2(i,j) * src_size).rgb;\n             m3 += c;\n             s3 += c * c;\n         }\n     }\n\n\n\t vec4 result;\n     float min_sigma2 = 1e+2;\n     m0 /= n;\n     s0 = abs(s0 / n - m0 * m0);\n\n     float sigma2 = s0.r + s0.g + s0.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m0, 1.0);\n     }\n\n     m1 /= n;\n     s1 = abs(s1 / n - m1 * m1);\n\n     sigma2 = s1.r + s1.g + s1.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m1, 1.0);\n     }\n\n     m2 /= n;\n     s2 = abs(s2 / n - m2 * m2);\n\n     sigma2 = s2.r + s2.g + s2.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m2, 1.0);\n     }\n\n     m3 /= n;\n     s3 = abs(s3 / n - m3 * m3);\n\n     sigma2 = s3.r + s3.g + s3.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m3, 1.0);\n     }\n\t\n\t const vec3 lumi = vec3(0.2126, 0.7152, 0.0722);\n\t\n\tvec3 hc =sample1(fragCoord,-1,-1) *  1.0 + sample1( fragCoord,0,-1) *  2.0\n\t\t \t+sample1( fragCoord,1,-1) *  1.0 + sample1(fragCoord,-1, 1) * -1.0\n\t\t \t+sample1( fragCoord,0, 1) * -2.0 + sample1( fragCoord,1, 1) * -1.0;\n\t\t\n\tvec3 vc =sample1(fragCoord,-1,-1) *  1.0 + sample1(fragCoord,-1, 0) *  2.0\n\t\t \t+sample1(fragCoord,-1, 1) *  1.0 + sample1( fragCoord,1,-1) * -1.0\n\t\t \t+sample1(fragCoord, 1, 0) * -2.0 + sample1( fragCoord,1, 1) * -1.0;\n\t\n\tvec3 c2 = sample1(fragCoord,0, 0);\n\t\n\tc2 -= pow(c2, vec3(0.2126, 0.7152, 0.0722)) * pow(dot(lumi, vc*vc + hc*hc), .5);\n\tfragColor = vec4(overlay(screen( result.rgb,c2.rgb), result.rgb) , 1.0);\n    \n }\n\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// renders the clock!\n\nvec4 Hand(vec2 uv , float l, float w, float t)\n{\n    vec4 col = vec4(0.);\n    \n\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , 1. * RES.y/RES.x * w);\n    \n    uv *= .35;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 7,/* Width*/6.,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n\n \n    col.a = col.r;// at this point, each of the rgb vals is at 1. and showing the mask, so store it in the A channel.\n    \n    col = max (col,vec4(0.));\n    return col;\n}\n\nvec4 HandsShadow(vec2 uv , float l, float w, float t , float b)\n{\n    vec4 col = vec4(0.);\n    \n    uv.y += .05;\n    uv.x -= .02;\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , w);\n    uv.y += .02;\n    uv *= .45;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 7,/* Width*/6. * w,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n    \n    \n   \n    \n    \n    col -= length(uv.y) * 2.; // attenuate based on height\n    \n    \n    \n    col = max (col,vec4(0.));\n    return col * .1;\n}\nvec4 Dial(vec2 uv, float m)\n{\n    \n    vec4 col = vec4(0.);\n    vec2 fuv = polarMap(uv + .5, .008 , .0) * .5;\n    \n    \n    fuv.x = fract(fuv.x * 8. ) ;\n    col += vec4(ShapeN(fuv+vec2(0.,-.6) ,4  ,  3.15, 0.8 ),0.7) * .5;\n    \n    \n    uv = polarMap(uv + .5, .0035 , .25) * .5;\n    \n    uv.x = fract(uv.x * 24. * m ) ;\n\n    vec2 id = floor(uv * 24.  );\n\n    if(id.x <=  1.6 && id.y >= 18. && id.y <= 26.)return col = vec4(.35);\n\n    col = clamp(col,0.,1.);\n    return col;\n}\n\n\n//returns a working clock\nvec4 ClockFace(vec2 uv){\n    \n    //uv += 1.5;\n    vec4 col = vec4(0.,0.,0.,1.);\n    \n    vec4 wt = vec4(.8,.7,0.,1.);// sample wood tex\n    \n    wt += S(-.7,.1,-abs(uv.y)); // add shine\n    \n    float f = circle(uv,4.3, .001 );//clocks frame\n    float fm = (1. - (circle(uv,4.3, .055 ) )) * .6;//clocks frame bevel\n    f -= fm;\n    col += f;\n    col -= circle(uv,3.8, .001 ) - circle(uv,3.7, .001 );//clocks frame\n    col = mix(col,  wt ,  col - circle(uv,3.7, .001 )); // apply wood tex\n\n    //Decoration at 12 o'clock\n    col += circle(uv + vec2(0.,-1.03),0.3, .001 ) * 0.5;\n    col -= circle(uv + vec2(0.,-1.03),0.25, .001 ) * 0.5;\n   // col += circle(uv + vec2(0.,-1.0),0.3, .5 );\n    col -= vec4(ShapeN(uv+vec2(0.,-.5) ,5  ,  5.15, 1.15 ),0.7) * .3;\n    col += circle(   uv + vec2(0.,-.8) ,0.1, .1 );\n    \n    \n    \n    \n    col -= (circle(uv,3.6, .001 ) * .18) + (-uv.y * .1); //inset and shading\n    \n    // Shadow\n    float d = length(uv + vec2(0.,0.1 ))* 0.88;\n    float m = 1. - circle(uv,4.3,.0001);\n  \n    \n     //add the dial and decoration\n    col -= Dial(uv/1.3, 1.);\n    \n    //---------- time is set here------------\n\n    vec4 iDate = iDate;\n    float mils = fract(iDate.w);\n\tfloat secs = mod( floor(iDate.w),        60.0 );\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\n\n\n    vec4 ch1 = Hand(uv, 0.9,0.9, hors  * TAU * .8 );//hours hand\n    \n    ch1 = clamp(ch1,0.,1.);\n    col -= ch1;\n    vec4 ch1s = HandsShadow(uv , 1.,.9, hors  * TAU * .8 , .5);\n    col -= ch1s;\n\n    vec4 ch2 = Hand(uv , 1.6,0.5, mins);//minutes hand\n\n    ch2 = clamp(ch2,0.,1.);\n    col -= ch2;\n    vec4 ch2s = HandsShadow(uv , 1.7,.7, mins , .5);\n    col -= ch2s;\n\n    //vec4 ch3 = Hand(uv ,  2.0, .07 ,secs ); //secondes hand\n    vec4 ch3 = vec4(segmentT(uv,vec2(0,0.),rot(vec2(0.,1.0)  ,secs * TAU/60.  ) , \n    1. * RES.y/RES.x * .05 ));\n   // vec4 ch3m = Hand(uv , 1.1, .05 ,secs ); //secondes hand m\n    //ch3 -= ch3m;\n    \n\n    ch3 = clamp(ch3,0.,1.);\n    col -= ch3;\n    vec4 ch3s = vec4(segmentT(uv,vec2(0,-0.02),rot(vec2(0.1* uv.y ,  1. - uv.y * .1)  ,secs * TAU/60.  ) , \n    1. * RES.y/RES.x * .05 )) * .1;\n    col -= ch3s;\n    \n    vec4 hCol = vec4(0.4,0.4,0.4,1.);// clock hand clr\n    \n    float sh = -   dot(-uv.x * .5,.5) + dot(-uv.y * .5,.5) + .8 ;// clock hands shading\n    \n    \n    vec4 tex1 =hCol / sh;// texture(iChannel0,(rot( uv * 2., -secs* TAU/60.)));\n    vec4 tex2 =hCol/ sh;// texture(iChannel0,(rot( uv * 2., -mins* TAU/60.)));\n    vec4 tex3 =hCol/ sh;// texture(iChannel0,(rot( uv * 2., -hors* TAU/60.)));// we also have to spin the texture per hand!\n  \n    col = mix (col, ch1 * tex3  , ch1) ;\n    col = mix (col,ch2 * tex2 ,ch2 ) ;\n    col = mix (col,ch3 * tex1 ,ch3 ) ;\n    \n    \n    //------------End of Time setting-----------------  \n   \n    float cc =  circle(uv,0.3, .001 ) ;//clocks hand cover\n    cc = ceil(cc);\n    \n    cc = max(cc,0.);\n    cc = min(cc,1.);\n    \n    col =  mix(vec4(cc * .3) , col,1. -cc);\n    col += vec4(circle(uv,0.3, .2 ) * .3) *(fract( uv.y* 50. - .1)  ) ; // dot on the clock hand cover\n    \n    col -= circle(uv,3.7, .001 ) * .18;// glass cover\n    col += max((circle(uv,3.9, .05 ) * .3 * uv.y),0.);\n     m = 1. - circle(uv,4.3,.001);\n    col.a =  1.- m;\n    col = col - m;\n    col = max(vec4(0.),col);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy/iResolution.xy);\n   // uv.y *= 0.56;\n    vec2 ouv = uv;\n    \n    vec4 col = vec4(0.0);\n    \n    uv -= .5;\n    uv.y += .22;\n\n     uv *= 5.2;\n     //col -= max( 1. - length((uv + vec2(.0,.1))* .7), 0.) ;\n    vec4 cf = ClockFace(uv );\n    col = mix(col,cf,cf.a);\n    \n    //if (ouv.x >= -0.01 && ouv.x <= .01) col -= vec4(1.,0.,0.,1.);\n\n  \n\n     \n     \n    // Output to screen\n    fragColor = col;\n}", "buffer_a_inputs": [], "common_code": "#define S smoothstep \n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define RES iResolution.xy\n\n\nvec3 darken( vec3 s, vec3 d )\n{\n\treturn min(s,d);\n}\n\nvec3 multiply( vec3 s, vec3 d )\n{\n\treturn s*d;\n}\n\nvec3 colorBurn( vec3 s, vec3 d )\n{\n\treturn 1.0 - (1.0 - d) / s;\n}\n\nvec3 linearBurn( vec3 s, vec3 d )\n{\n\treturn s + d - 1.0;\n}\n\nvec3 darkerColor( vec3 s, vec3 d )\n{\n\treturn (s.x + s.y + s.z < d.x + d.y + d.z) ? s : d;\n}\n\nvec3 lighten( vec3 s, vec3 d )\n{\n\treturn max(s,d);\n}\n\nvec3 screen( vec3 s, vec3 d )\n{\n\treturn s + d - s * d;\n}\n\nvec3 colorDodge( vec3 s, vec3 d )\n{\n\treturn d / (1.0 - s);\n}\n\nvec3 linearDodge( vec3 s, vec3 d )\n{\n\treturn s + d;\n}\n\nvec3 lighterColor( vec3 s, vec3 d )\n{\n\treturn (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d;\n}\n\nfloat overlay( float s, float d )\n{\n\treturn (d < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 overlay( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = overlay(s.x,d.x);\n\tc.y = overlay(s.y,d.y);\n\tc.z = overlay(s.z,d.z);\n\treturn c;\n}\n\nfloat softLight( float s, float d )\n{\n\treturn (s < 0.5) ? d - (1.0 - 2.0 * s) * d * (1.0 - d) \n\t\t: (d < 0.25) ? d + (2.0 * s - 1.0) * d * ((16.0 * d - 12.0) * d + 3.0) \n\t\t\t\t\t : d + (2.0 * s - 1.0) * (sqrt(d) - d);\n}\n\nvec3 softLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = softLight(s.x,d.x);\n\tc.y = softLight(s.y,d.y);\n\tc.z = softLight(s.z,d.z);\n\treturn c;\n}\n\nfloat hardLight( float s, float d )\n{\n\treturn (s < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 hardLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = hardLight(s.x,d.x);\n\tc.y = hardLight(s.y,d.y);\n\tc.z = hardLight(s.z,d.z);\n\treturn c;\n}\n\nfloat vividLight( float s, float d )\n{\n\treturn (s < 0.5) ? 1.0 - (1.0 - d) / (2.0 * s) : d / (2.0 * (1.0 - s));\n}\n\nvec3 vividLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = vividLight(s.x,d.x);\n\tc.y = vividLight(s.y,d.y);\n\tc.z = vividLight(s.z,d.z);\n\treturn c;\n}\n\nvec3 linearLight( vec3 s, vec3 d )\n{\n\treturn 2.0 * s + d - 1.0;\n}\n\nfloat pinLight( float s, float d )\n{\n\treturn (2.0 * s - 1.0 > d) ? 2.0 * s - 1.0 : (s < 0.5 * d) ? 2.0 * s : d;\n}\n\nvec3 pinLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = pinLight(s.x,d.x);\n\tc.y = pinLight(s.y,d.y);\n\tc.z = pinLight(s.z,d.z);\n\treturn c;\n}\n\nvec3 hardMix( vec3 s, vec3 d )\n{\n\treturn floor(s + d);\n}\n\nvec3 difference( vec3 s, vec3 d )\n{\n\treturn abs(d - s);\n}\n\nvec3 exclusion( vec3 s, vec3 d )\n{\n\treturn s + d - 2.0 * s * d;\n}\n\nvec3 subtract( vec3 s, vec3 d )\n{\n\treturn s - d;\n}\n\nvec3 divide( vec3 s, vec3 d )\n{\n\treturn s / d;\n}\n\n//\trgb<-->hsv functions by Sam Hocevar\n//\thttp://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\t\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hue( vec3 s, vec3 d )\n{\n\td = rgb2hsv(d);\n\td.x = rgb2hsv(s).x;\n\treturn hsv2rgb(d);\n}\n\nvec3 color( vec3 s, vec3 d )\n{\n\ts = rgb2hsv(s);\n\ts.z = rgb2hsv(d).z;\n\treturn hsv2rgb(s);\n}\n\nvec3 saturation( vec3 s, vec3 d )\n{\n\td = rgb2hsv(d);\n\td.y = rgb2hsv(s).y;\n\treturn hsv2rgb(d);\n}\n\nvec3 luminosity( vec3 s, vec3 d )\n{\n\tfloat dLum = dot(d, vec3(0.3, 0.59, 0.11));\n\tfloat sLum = dot(s, vec3(0.3, 0.59, 0.11));\n\tfloat lum = sLum - dLum;\n\tvec3 c = d + lum;\n\tfloat minC = min(min(c.x, c.y), c.z);\n\tfloat maxC = max(max(c.x, c.y), c.z);\n\tif(minC < 0.0) return sLum + ((c - sLum) * sLum) / (sLum - minC);\n\telse if(maxC > 1.0) return sLum + ((c - sLum) * (1.0 - sLum)) / (maxC - sLum);\n\telse return c;\n}\n\nmat2 Rot(float a){\nfloat s = sin(a);\nfloat c = cos(a);\n\n    return mat2(c, -s, s, c);\n}\nfloat Hash21(vec2 n){\n\n   return fract(sin(dot(n.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec3 ShapeN(vec2 st, int N, float w, float h){\n\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  st.x += 1.0 ;\n  st.y += .7;\n  st.y /= h;\n    st.x *= w;\n  // Number of sides of your shape\n  //int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulates the distance\n  d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  color = vec3(S(.41,.4,d));\n\n    return color;\n}\nvec2 polarMap(vec2 uv, float shift, float inner) {\n\n    uv = vec2(0.5) - uv;\n    \n    \n    float px = 1.0 - fract(atan(uv.y, uv.x) / 6.28 + 0.25) + shift;\n    float py = (length(uv) * (1.0 + inner * 2.0) - inner) * 2.0;\n    \n    return vec2(px, py);\n}\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\nfloat circle (vec2 p, float r, float g)\n{\n\n    float d = length(p / r);\n\n    float ss = S(.32,.32 - g,d);\n    \n    ss = max(0.,ss);\n    return ss;\n\n}\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn S(r, 0.7*r, d);\n}\nfloat segmentT(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A ;\n    float d = length(h - g * clamp(dot(g , h ) / dot(g,g), 0.0, 1.0));\n    \n\n\treturn S(r, 0.7*r, d);\n}", "buffer_b_code": "//BG\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(.5);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 ouv = uv;\n    vec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    \n    \n    uv = M*4.; \n    vec2 ruv = rot(uv,iTime* .05) * .5;\n    uv.x += .01 * iTime;\n    uv.x = sin(uv.y);\n    uv.y = abs(uv.y);\n    vec4 tx = texture(iChannel0,ruv + ouv) * 1.1;\n    vec4 tx1 = texture(iChannel1,( uv+ ouv)*.2+.5) * 1.3;\n    tx = vec4(tx.r);\n    tx1 = vec4(tx1.r);\n    col += vec4(.4,.4,1.,1.) * uv.y ;\n    col *= tx;\n    col *= tx1;\n    col = clamp(col,0.2,1.);\n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// number of layers to render, go over 5.5 only if you have a strong GPU! \n// min is 1.1\n#define NUM_LAYERS 5.5\n\nvec4 Layer(vec2 uv )\n{\n   // uv.y *= 2.0;\n    vec2 ouv = uv; //storing the original uvs.\n\n\n    uv.x +=  iTime * .001;\n    uv = rot(uv, 0.001 * iTime);\n    vec2 buv = uv;\n    //buv.x = buv.x +sin( buv.y + iTime * .001);\n    \n    \n    buv *= cos(sin(  iTime * .0001)*.5+.5) * 5.;\n    //vec2 mouse = iMouse.xy / iResolution.xy + .5;\n    //buv *= 1.- mouse.x + 1.5;\n    \n    buv.x -= .5;\n    \n    vec2 id = floor(buv);\n    vec2 fuv = fract(buv);\n    \n    buv = fuv;\n    vec4 col = vec4( 0.);\n    \n    buv -= .25;\n   // buv.x += .1;\n    //uv = buv;\n\n    if ( mod(id.x,2.) == 0.)buv.x = (( (buv.x )/ sin(Hash21(id) *(iTime * .5  * (Hash21(id)))))); //fake 3d rotation\n    \n    \n    //buv.y *= 2.5 +.5;\n    buv /= 1.5 - Hash21(id);// random size\n    vec4 cf = texture(iChannel0,rot(buv * 3.5  -0.5,iTime * .1 * (Hash21(id))));\n    \n    \n    cf = min(cf,vec4(1.));\n    \n    col = mix(col,cf,cf.a);\n    //col + id;\n    \n   //col += vec4(fuv,0.,1.);\n  \n    \n\n\ncol.a = floor(cf.a);\n//\nreturn col;\n\n}\n\nvec4 RegLayer(vec2 uv )\n{\n    vec2 ouv = uv; //storing the original uvs.\n\n\n    vec2 buv = uv;\n\n   buv *= (sin(iTime * .01)*.5+.5) * 20.;\n    //buv *= 13.;\n    \n    \n    vec2 id = floor(buv);\n    vec2 fuv = fract(buv);\n    \n    buv = fuv;\n    vec4 col = vec4( 0.);\n\n    \n    \n    \n    vec4 cf = texture(iChannel0,buv * 1.3);\n    \n    \n    cf = min(cf,vec4(1.));\n    \n    col = mix(col,cf,cf.a);\n    \n    \n\n  \n    \n\n\ncol.a = floor(cf.a);\n//\nreturn col;\n\n}\n\nvec4 ClockSoup(vec2 uv, vec2 nuv)\n{\n\n\n   vec2 ouv = uv;\n\tvec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    vec4 col = vec4(0);\n    float t = iTime*.01;\n    \n    uv += M*4.;\n    \n    uv *= Rot(t);\n    \n  \n     float m = 1.;\n    \n    vec4 tcol = vec4(0.);\n    \n    \n     //add clock layers loop\n    for(float i=0.; i<=1.; i+=1./NUM_LAYERS) {\n    \tfloat depth = fract(i+t);\n        \n        float s = mix(1.5, .01,i + depth);\n        float f = depth * smoothstep(1., .95, depth);\n        \n        uv = rot(uv, t * i);\n        vec4 l = Layer(uv*s+i*22.2-M);\n        l.a *= f;\n        m -= l.a;\n      \n        \n        col -= l.a;\n        col = clamp(col,0.,1.);\n        col = mix(col,l, l.a);\n\n    }\n    col = clamp(col,0.,1.);\n    //col = vec4(uv,.0,1.);\n    return col;\n}\n\nvec4 ClockHorizonSquash(vec2 uv, vec2 nuv)\n{\n    vec2 ouv = uv;\n    vec4 col = vec4(0.);\n    uv.x =  (abs(1.-uv.y) * uv.x) ;\n    uv.x = pow(uv.y,uv.x * .2 );\n    uv.y = pow(uv.y,.2);\n    uv.y = -abs(uv.y );\n    uv.y += fract(iTime * .05);\n    \n    \n    vec4 rl = RegLayer( ( uv + vec2(.205,.0)) * 1.3);\n\n    col += rl;\n    col = clamp(col,0.,1.);\n    col -=  pow(length(fract(1.- ouv.y)),12.1);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   vec2 nuv = fragCoord.xy/iResolution.xy;\n\n   vec2 ouv = uv;\n\tvec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    vec4 col = vec4(0);\n    float t = iTime*.01;\n    \n    float bs = (sin(t * 15.)*.5+.5);// used to blend between the animations\n    \n    vec4 bg = texture(iChannel2, nuv );\n    //\n    vec4 cs = ClockSoup(uv,nuv);\n    vec2 huv = uv;\n    huv.y = abs(huv.y);\n    vec4 chs = ClockHorizonSquash(huv - vec2((M.x * .5),abs(M.y) * .5),nuv);\n    \n    \n    col = clamp(col,0.,1.);\n    \n    \n    vec4 blend =  mix(cs,chs,S(0.4,.6,bs));\n    blend = clamp(blend,0.,1.);\n    col = mix(blend,bg,1. -blend);\n    \n\n    //col += cs;\n    col = pow(col, vec4(.82));\t//gamma corrct\n    \n    col -= pow(length(ouv * 2.),124.7)  ;//circle vignette\n    //col = vec4(1. -blend);\n    col = clamp(col,0.,1.);\n        //col = texture(iChannel0,nuv);\n   // col = vec4(Hash21(uv));\n    fragColor = col;\n\n    \n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[881, 881, 938, 938, 1057], [1061, 1061, 1120, 1120, 3883]], "test": "untested"}
{"id": "NsfXWn", "name": "Northern Wobble, Pearly Bauble", "author": "TEttinger", "description": "Another Northern Lights plasma/noise, using what may be a smoother approach for the swayRandomized() function. SEED should usually be positive.", "tags": ["noise", "plasma", "wobble", "lights", "northern"], "likes": 5, "viewed": 292, "published": 3, "date": "1618439938", "time_retrieved": "2024-07-30T19:26:14.706011", "image_code": "// CC0 licensed, do what thou wilt.\nconst float SEED = 42.0;\n\nvec4 coeffs(float seed){\n    return fract((seed + 23.4567) * vec4(0.8566748838545029, 0.733891856627126, 0.6287067210378087, 0.5385972572236101)) + 1.25;\n}\n\nfloat swayRandomized(float seed, float value)\n{\n    vec4 c = coeffs(seed);\n    return dot(sin(c * (cos(c.zwxy + value) + value)), c.wxyz * 0.2 - 0.125);\n}\n\nvec3 cosmic(float seed, vec3 con)\n{\n    con.x += swayRandomized(seed, con.z + con.x);\n    con.y += swayRandomized(seed, con.x + con.y);\n    con.z += swayRandomized(seed, con.y + con.z);\n    return con * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 100.0;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.2;\n    vec3 s = vec3(swayRandomized(-164.0531527, aTime - 1.11),\n                  swayRandomized(-776.648142, aTime + 1.41),\n                  swayRandomized(-509.935190, aTime + 1.61)) * 0.25;\n    vec3 c = vec3(swayRandomized(-105.2792407, aTime - 1.11),\n                  swayRandomized(-615.576687, aTime + 1.41),\n                  swayRandomized(-435.278990, aTime + 1.61)) * 0.25;\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    con = cosmic(SEED, con);\n    con = cosmic(SEED, con);\n    con = cosmic(SEED, con);\n    \n    fragColor = vec4(sin(con * 3.14159265) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfXWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 86, 86, 217], [219, 219, 266, 266, 373], [375, 375, 410, 410, 584], [586, 586, 643, 693, 1453]], "test": "untested"}
{"id": "fsfSWn", "name": "2D Light Coverage - Disc", "author": "oneshade", "description": "Lighting based on the probablity that a light ray hits a pixel.", "tags": ["2d", "light", "coverage"], "likes": 5, "viewed": 280, "published": 3, "date": "1618435393", "time_retrieved": "2024-07-30T19:26:15.473958", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    vec3 color = vec3(0.0);\n\n    vec2 lightPos = vec2(0.0);\n    float lightRadius = 1.0;\n\n    vec2 ray = uv - lightPos;\n    float dd = dot(ray, ray);\n    if (dd < lightRadius * lightRadius) color += 1.0;\n    else color += 1.0 - acos(lightRadius / sqrt(dd)) / 1.57;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfSWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 429]], "test": "untested"}
{"id": "NdXSWn", "name": "Circle Tangents Through Point", "author": "oneshade", "description": "I wish I'd seen the geometric intuition quicker.", "tags": ["math", "circle", "geometry", "tangents"], "likes": 6, "viewed": 158, "published": 3, "date": "1618433488", "time_retrieved": "2024-07-30T19:26:16.237915", "image_code": "// https://www.desmos.com/calculator/dx2vn81dpw\n\n// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * dot(pa, ba) / dot(ba, ba));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        mouse.xy = vec2(sin(iTime), 1.0) * cos(iTime);\n        mouse.x += 2.0;\n    }\n\n    // Radius and angles\n    float r = 1.0;\n    vec2 a = atan(mouse.y, mouse.x) + vec2(1.0, -1.0) * acos(r / length(mouse.xy));\n\n    // For just the points, this can be simplified (likely no sin/cos, just 1 or 2 sqrts)\n    vec2 t1 = vec2(cos(a.x), sin(a.x)) * r;\n    vec2 t2 = vec2(cos(a.y), sin(a.y)) * r;\n\n    // Circle\n    drawSDF(abs(sdDisc(uv, vec2(0.0), r)), vec3(1.0, 0.0, 0.0));\n\n    // Right triangle 1\n    drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t1),\n                sdLine(uv, t1, vec2(0.0)))), vec3(0.0, 0.0, 1.0));\n\n    // Right triangle 2\n    drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t2),\n                sdLine(uv, t2, vec2(0.0)))), vec3(0.0, 0.0, 1.0));\n\n    // Tangents\n    drawSDF(sdInfLine(uv, mouse.xy, t1), vec3(1.0, 0.8, 0.0));\n    drawSDF(sdInfLine(uv, mouse.xy, t2), vec3(1.0, 0.8, 0.0));\n\n    // Point\n    drawSDF(sdDisc(uv, mouse.xy, 0.05), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXSWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 159, 207, 207, 239], [241, 241, 291, 291, 382], [384, 384, 431, 431, 539], [541, 541, 596, 596, 2009]], "test": "untested"}
{"id": "fdXSWn", "name": "Bitwise vines", "author": "jarble", "description": "This fractal looks like a forest of hanging vines.", "tags": ["fractal", "forest", "bitwise", "vine", "jungle"], "likes": 8, "viewed": 321, "published": 3, "date": "1618433264", "time_retrieved": "2024-07-30T19:26:17.008853", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 0.2;\n    float trans = iTime * 25.0;\n    vec2 coord = (scale * fragCoord) + vec2(trans,0.0);\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 6; i++){\n        coord.y -= (3.0-result);\n        coord = coord/(2.0);\n        result = ((result + float(val = ((int(coord.x-coord.y) & int(coord.y+coord.x*2.0)) % 3)))/(2.0));\n        col.x = (result*2.0+col.z)/3.0;\n        col = col.yzx;\n    }\n    // Output.\n    fragColor = vec4((col/2.0),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7slSz7", "name": "Textile fiber", "author": "jarble", "description": "This fractal looks like a close-up photo of textile fibers.", "tags": ["fractal", "textile", "fibers"], "likes": 4, "viewed": 230, "published": 3, "date": "1618430324", "time_retrieved": "2024-07-30T19:26:17.772811", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 0.2;\n    float trans = iTime * 25.0;\n    vec2 coord = (scale * fragCoord) + vec2(trans,trans);\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 6; i++){\n        coord.y -= (3.0-result);\n        coord = coord.yx/3.0+coord.xx/(3.0);\n        result = ((result + float(val = ((int(coord.x+coord.y) & int(coord.y)) % 3)))/(2.0));\n        col.x = (result*2.0+col.z)/3.0;\n        col = col.yzx;\n    }\n    // Output.\n    fragColor = vec4((col/2.0),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slSz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NslSz7", "name": "Box - gradient 3D", "author": "Dain", "description": "Box with analytic gradient inside + outside", "tags": ["3d", "sdf", "gradient", "normal", "box", "analytic"], "likes": 1, "viewed": 278, "published": 3, "date": "1618430229", "time_retrieved": "2024-07-30T19:26:18.535771", "image_code": "// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//Rendering code from IQs torus gradient shader https://www.shadertoy.com/view/wtcfzM\n\n\n// Other SDF analytic gradients\n// Egg: https://www.shadertoy.com/view/7dXSz7\n// Oval: https://www.shadertoy.com/view/NdsSRM\n// Disk: https://www.shadertoy.com/view/NdlSR7\n// Box : https://www.shadertoy.com/view/NslSz7\n\n// Other SDF analytic gradients(By IQ):\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n\n//Set to 1 to show the finite difference gradient for comparison\n#define SHOW_NUMERIC_GRADIENT 0\n\n//show inside of box gradient(it shows the gradient at that location in the box, not the gradient of the surface caused by the sphere cut,\n//so the numeric gradients don't match when this is on)\n#define SHOW_INSIDE 0\n\nfloat sgn(float p){\n return p >= 0.0 ? 1.0 : -1.0;\n}\nvec3 sgn(vec3 p){\n return vec3(sgn(p.x), sgn(p.y), sgn(p.z));\n}\n\n//A 3D box with gradient\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .w = f(p)/z\n// .yzw = f(p) with f(p) = 1\nvec4 sdgBox(vec3 p, vec3 r) {\n    vec3 b = abs(p) - r;\n    vec3 bc = max(b, 0.0);\n    \n    float d2 = dot(bc,bc);   \n    float rSqrtD2 = inversesqrt(d2);\n    \n\tfloat d =  d2 *rSqrtD2;  \n    vec3 grad = bc*rSqrtD2 ;//bc*2.0*rSqrtD2*.5 simplies to this\n    \n    //inside box?\n    if(d2 == 0.f){\n         float mxy = max(b.x,b.y);\n         grad = (b.x > b.y) ? vec3(1.0, 0.0,0.0) : vec3(0.0,1.0,0.0);\n         grad = (b.z > mxy) ? vec3(0.0,0.0,1.0): grad;\n         d = max(mxy, b.z);\n    }\n   \n    return vec4(d, grad*sign(p));//sgn is more correct, but sign portable so using it here\n}\n\n//Do the box thing, and maybe other stuff\nvec4 sdgBoxWrap(vec3 p, float  a, float b) {\n   p.xyz = p.xzy;\n    vec3 box =  vec3(a,b, (a+b)*.5);\n    vec4 r= sdgBox(p,box) ;//\n    r.x -= max(sin(iTime*1.7)*.1,0.0);\n    \n  #if SHOW_INSIDE ==1\n    float spherehole = length(p-box)-.50;\n    if(r.x < -spherehole){\n        r.x = -spherehole;\n       // r.yzw = -normalize(p-box);\n    }\n  #endif\n    r.yzw = (r.ywz);\n    return r;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.65, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, -0.15, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n      float ra = 0.5;\n    float rb = 0.2+0.1*sin(iTime);\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgBoxWrap(pos,ra,rb).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgBoxWrap(pos,ra,rb).yzw;\n\n            // compute normal numerically, for comparison\n            // https://iquilezles.org/articles/normalsSDF\n            #if SHOW_NUMERIC_GRADIENT\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgBoxWrap( pos + e.xyy*eps, ra, rb ).x + \n                             e.yyx*sdgBoxWrap( pos + e.yyx*eps, ra, rb ).x + \n                             e.yxy*sdgBoxWrap( pos + e.yxy*eps, ra, rb ).x + \n                             e.xxx*sdgBoxWrap( pos + e.xxx*eps, ra, rb ).x );\n       \n\n            #endif\n    //nor =-nor;\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslSz7.jpg", "access": "api", "license": "mit", "functions": [[1812, 1812, 1831, 1831, 1864], [1865, 1865, 1882, 1882, 1928], [1930, 2072, 2101, 2101, 2655], [2657, 2699, 2743, 2743, 3079]], "test": "ok"}
{"id": "sdlXR7", "name": "Distance Field Soft Shadows", "author": "moranzcw", "description": "Distance Field Soft Shadows.", "tags": ["shadow", "softshadow", "ssdf"], "likes": 8, "viewed": 409, "published": 3, "date": "1618427986", "time_retrieved": "2024-07-30T19:26:19.313691", "image_code": "// Distance Field Soft Shadows - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.141592653;\n\n\n// oldschool rand() from Visual Studio\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\n// hash by Hugo Elias\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\n\n/* -------------------------------------\n\n1. SDF\n\n------------------------------------- */\n\n// SDF boolean\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n//SDF functions by iq.\n//see https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat quadSDF( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat boxSDF( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinderSDF( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// scene\nfloat sceneSDF(vec3 samplePoint) {\n    float sphere = sphereSDF(samplePoint + vec3(0.0, -0.5, 0.0), 0.5);\n    float scene = sphere;\n    \n    float cube = boxSDF(samplePoint+ vec3(1.5, -0.75, -1.5), vec3(0.25, 0.75, 0.25));\n    scene = unionSDF(scene, cube);\n    \n    float cylinder = cylinderSDF(samplePoint+ vec3(-1.5, -0.6, 1.5), 0.4, 0.6);\n    scene = unionSDF(scene, cylinder);\n    \n    float size = 4.0;\n    float ground = quadSDF(samplePoint,vec3(size,0.0,size), vec3(size,0.0,-size),\n                        vec3(-size,0.0,-size), vec3(-size,0.0,size));\n    scene = unionSDF(scene, ground);\n    \n    return scene;\n}\n\n/* -------------------------------------\n\n2. Ray Marching\n\n------------------------------------- */\nfloat rayMarching(vec3 origin, vec3 direction, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(origin + depth * direction);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n/* -------------------------------------\n\n3. Visibility for shading point\n\n------------------------------------- */\nfloat visibility(vec3 ro, vec3 rd, float start, float end, float k)\n{\n    float t = start;\n    vec3 p;\n    float dist;\n    float tempVisibility;\n    float visibility = 1.0;\n        \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n    {\n        p = ro + t * rd;\n        p = vec3(p.x + t * 0.05 * frand(), p.y + t * 0.05 * frand(), p.z + t * 0.05 * frand());\n        dist = sceneSDF(p) + 0.05 * t;\n        \n        tempVisibility = k * dist / t;\n        visibility = min(tempVisibility, visibility);\n        \n        if (dist < EPSILON) \n        {\n\t\t\treturn 0.0;\n        }\n        t += dist * (0.7 + frand() * 0.3); // dither\n        if (t >= end) \n        {\n            break;\n        }\n    }\n    visibility = pow(visibility, 2.0);\n    return visibility;\n}\n\n\n/* -------------------------------------\n\n4. Shading\n\n------------------------------------- */\n// normal\nvec3 surfaceNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// shading\nvec3 lambertShading(vec3 diffuseColor, vec3 p, vec3 normal, vec3 lightDir, vec3 lightIrradiance) {\n    float dotLN = dot(lightDir, normal);\n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    return lightIrradiance * dotLN * diffuseColor;\n}\n\nvec3 lambertIllumination(vec3 p) {\n    vec3 normal = surfaceNormal(p);\n    \n    vec3 lightDir = normalize(vec3(sin(0.3*iTime), 0.5, cos(0.3*iTime)));\n    vec3 lightIrradiance = vec3(0.8);\n    vec3 color = vec3(0.0);\n    color += visibility(p + normal*2.0*EPSILON, lightDir, MIN_DIST, MAX_DIST, 6.0) \n            * lambertShading(vec3(1.0), p, normal, lightDir, lightIrradiance);\n      \n    return color;\n}\n\n\n/* -------------------------------------\n\n5. Camera\n\n------------------------------------- */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 cameraOrigin, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - cameraOrigin);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // ray direction\n\tvec3 cameraRayDirInView = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec3 cameraPos = vec3(8.0 + 3.0 * sin(0.2 * iTime), 4.5, 8.0 - 3.0 * sin(0.2 * iTime));\n    mat3 viewToWorld = viewMatrix(cameraPos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 cameraRayDir = viewToWorld * cameraRayDirInView;\n    \n    // distance\n    float dist = rayMarching(cameraPos, cameraRayDir, MIN_DIST, MAX_DIST);\n    \n    // didn't hit\n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0);\n\t\treturn;\n    }\n    \n    // hit point\n    vec3 p = cameraPos + dist * cameraRayDir;\n    \n    // shading\n    vec3 color = lambertIllumination(p) + vec3(0.2);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlXR7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[380, 380, 401, 401, 413], [414, 414, 433, 433, 488], [489, 489, 508, 508, 540], [542, 564, 583, 583, 638], [733, 748, 794, 794, 826], [828, 828, 870, 870, 902], [904, 904, 951, 951, 984], [986, 1061, 1086, 1086, 1105], [1106, 1106, 1131, 1131, 1150], [1152, 1152, 1209, 1209, 1837], [1839, 1839, 1871, 1871, 1962], [1964, 1964, 1998, 1998, 2026], [2028, 2028, 2075, 2075, 2186], [2188, 2197, 2231, 2231, 2819], [2821, 2921, 2993, 2993, 3294], [3296, 3412, 3481, 3481, 4169], [4172, 4277, 4305, 4305, 4615], [4617, 4628, 4726, 4726, 4886], [4888, 4888, 4922, 4922, 5293], [5296, 5390, 5455, 5455, 5587], [5589, 5589, 5647, 5682, 5822], [5825, 5825, 5882, 5906, 6722]], "test": "untested"}
{"id": "7dlSR7", "name": "Progressive Lighting 2D", "author": "oneshade", "description": "Ooh, natural soft shadows!", "tags": ["2d", "raymarching", "lighting", "progressive"], "likes": 5, "viewed": 168, "published": 3, "date": "1618427035", "time_retrieved": "2024-07-30T19:26:20.079643", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor.rgb /= (fragColor.w + 1.0) / 20.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "struct Shape {\n    float dist;\n    vec3 refl;\n    vec3 emit;\n};\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash31(in vec3 p) {\n\tp = fract(p * 0.1031);\n    p += dot(p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nShape add(in Shape a, in Shape b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nShape sub(in Shape a, in Shape b) {\n    if (a.dist > -b.dist) return a;\n    return Shape(-b.dist, b.refl, b.emit);\n}\n\nShape inter(in Shape a, in Shape b) {\n    if (a.dist > b.dist) return a;\n    return b;\n}\n\nShape map(in vec2 p) {\n    return add(Shape(length(p - vec2(-0.25)) - 0.25, vec3(0.0), vec3(0.0)),\n           add(Shape(length(p - vec2(0.25)) - 0.02, vec3(0.0), vec3(1.0)),\n           Shape(max(abs(p.x - 0.4) - 0.2, abs(p.y - 0.15) - 0.05), vec3(0.0), vec3(0.0))));\n}\n\nvec2 getNormal(in vec2 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec2(map(p + e.xy).dist - map(p - e.xy).dist,\n                          map(p + e.yx).dist - map(p - e.yx).dist));\n}\n\nvec3 trace(in vec2 ro, in vec2 rd) {\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec2 p = ro + rd * t;\n        Shape scene = map(p);\n        if (scene.dist < 0.001) {\n            return scene.emit;\n        }\n\n        if (t > 10.0) {\n            break;\n        }\n\n        t += scene.dist;\n    }\n\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 rd = sin(Hash31(vec3(uv * 100.0, iFrame)) * 6.28 + vec2(1.57, 0.0));\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor += vec4(trace(uv, rd) + 0.01 * step(0.0, -map(uv).dist), 1.0);\n    if (iMouse.z > 0.0) fragColor = vec4(0.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 170]], "test": "untested"}
{"id": "sssSzM", "name": "Bitwise mountains", "author": "jarble", "description": "This fractal looks like a mountain range.", "tags": ["fractal", "landscape", "biome", "bitwisemath"], "likes": 6, "viewed": 252, "published": 3, "date": "1618425736", "time_retrieved": "2024-07-30T19:26:20.851579", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 0.2;\n    float trans = iTime * 25.0;\n    vec2 coord = (scale * fragCoord) + vec2(trans,trans);\n    \n    // Heart of color selection.\n    int val = 0;\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 9; i++){\n        coord.y -= (3.0-result);\n        coord = coord/3.0 + coord.yy/9.0;\n        result = ((result + float(val = ((int(coord.x) & int(coord.y)) % 3)))/(2.0));\n        col.x = (result*2.0+col.z)/3.0;\n        col = col.yzx;\n    }\n    // Output.\n    fragColor = vec4((col/2.0),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssSzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NslSRM", "name": "Day 482", "author": "jeyko", "description": "potate", "tags": ["mdtmjvm"], "likes": 9, "viewed": 406, "published": 3, "date": "1618416899", "time_retrieved": "2024-07-30T19:26:21.801041", "image_code": "// THE FRACTAL FORMULA IN THE BACKGROUND IS MODIFIED \"FoldcutToy.frag\" from Fragmentarium by DarkBeam\n\n\nvec4 n14(float f){ return texture(iChannel0,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat text(vec2 p, float[8] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x)];\n    //char += 112. ;\n    if(scrobble)\n        char += floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2)),14.) ) ;\n    \n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    \n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 uvn = fragCoord/iResolution.xy;\n    float pxsz = fwidth(uvn.x);\n\n    \n    vec3 col = texture(iChannel0,uvn).xyz;\n    \n    \n    col += 3.6*texture(iChannel1,uvn).xyz;\n    \n    col = pow(col,vec3(0.9,1.4,0.8));\n    \n    col = max(col,0.003);\n    \n    \n    \n{\n        vec2 p = uv;\n        vec2 md = vec2(0.08,0.05);\n        \n        p.x += 0.67 + md.x*1.;\n        p.y += md.y*0.5+0.2;\n        \n        vec3 c = vec3(1.3,1.35,1.46)*col*2. + (0.4-col*0.5)*1.4;\n        c = c*1.*(0.1-col);\n        //c = min(c,1.);\n        \n        {\n            vec2 id = floor(p/md);\n            vec2 q = pmod(p,md);\n            float d = sdBox(q, vec2(0.1,0.002));\n            \n            d = xor(d,sdBox(q + vec2(+ sin(14.*id.y + iTime*3. + sin(id.y + iTime))*0.04,0.), vec2(0.01 ,0.01)));\n            \n            //d = xor(d,0.0+sdBox(p - 0.0 , vec2(0.01 ,0.6)));\n            \n            \n            float cnd = float(abs(id.x) == 0. && abs(id.y) < 4.);\n            \n            //col = mix(col,c,cnd*smoothstep(pxsz,0.,d));\n        \n            float od = d;\n            \n            d = sdBox(p - vec2(-0.062,0) , vec2(0.001 ,0.2));\n            \n            \n            \n            //col = mix(col,c,smoothstep(pxsz,0.,d));\n        \n            float db = sdBox(uv + vec2(0.01,0.401) , vec2(0.6 ,0.415));\n            //col = mix(col,c,smoothstep(pxsz,0.,db));\n            \n        }\n        \n        //d = min(d, sdBox(uv + vec2(0.1), vec2(0.0,0.04)));\n        \n    }\n\n    {\n        float oo = 10e5;\n    \n            float ob = (sdBox(uv,vec2(1.45,0.46)));\n            \n            float cutout = sdBox(uv - vec2(0.5,0.4),vec2(0.6 + sin(iTime)*0.1,0.5));\n            \n            cutout = xor(cutout, sdBox(uv + vec2(0.3,0.4),vec2(0.6 + sin(iTime)*0.2,0.5)));\n            \n            float outerBox = max(abs(ob),-cutout);\n            outerBox = min(outerBox, max(abs(ob + 0.04), -cutout + 0.3));\n            \n            outerBox = min(outerBox, max(abs(ob + 0.01), -cutout + 0.3));\n            \n            oo = min(oo,outerBox) - 0.001;\n            {\n                vec2 p = uv;\n                float m = sin(iTime*0.4 + sin(iTime));\n                float b = sdBox(p - vec2(0.5 + m*0.1,0.4),vec2(0.3,0.5));\n                b = xorb(b,(sdBox(p - vec2(0.2,0.4),vec2(0.2,0.5))),0.1);\n                b = xorb(b,(sdBox(p - vec2(0.2,0.4),vec2(0.4,0.2))),0.1);\n                b = xorb(b,abs(sdBox(p - vec2(0.+m*0.2,0.4),vec2(0.4,0.1))),0.1);\n                b = xorb(b,(sdBox(p - vec2(0.-m*0.2 - 0.1,0.4),vec2(0.6,0.005))),0.1);\n                \n                oo = min(oo,abs(b) - 0.004);\n            \n                \n            }\n            {\n                vec2 p = uv + vec2(0.1,0.5);\n                p.x += iTime*0.2+ sin(iTime)*0.5;\n                p.x = pmod(p.x,2.);\n                float m = sin(iTime*0.3 + sin(iTime) );\n                float b = sdBox(p - vec2(0.5 + m*0.1,0.4),vec2(0.3,0.5));\n                b = xorb(b,(sdBox(p - vec2(0.2,0.4),vec2(0.2,0.5))),0.1);\n                b = xorb(b,(sdBox(p - vec2(0.1,0.4),vec2(0.4,0.2))),0.1);\n                b = xorb(b,abs(sdBox(p - vec2(0.+m*0.2,0.4),vec2(0.4,0.1))),0.1);\n                b = xorb(b,(sdBox(p - vec2(0.-m*0.2 - 0.1,0.4),vec2(0.6,0.00))),0.1);\n                \n                oo = min(oo,abs(b) - 0.03);\n            \n                \n            }   \n            {\n                vec2 p = uv + vec2(0.1,0.76);\n                p *= rot(0.*pi);\n                float m = sin(iTime*0.3 + 4. + sin(iTime+1.) );\n                float b = sdBox(p - vec2(0.5 + m*0.1,0.4),vec2(0.3,0.5));\n                b = xorb(b,(sdBox(p - vec2(0.4,0.4),vec2(0.,0.6))),0.1);\n                b = xorb(b,(sdBox(p - vec2(0.1,0.4),vec2(0.4,0.4))),0.1);\n                b = xorb(b,abs(sdBox(p - vec2(0.+m*0.2,0.4),vec2(0.4,0.1))),0.1);\n                b = xorb(b,(sdBox(p - vec2(0.-m*0.2 - 0.1,0.4),vec2(0.6,0.00))),0.1);\n                \n                oo = min(oo,abs(b) - 0.001);\n            \n                \n            }            \n            col = mix(col,(0.5-col) ,smoothstep(pxsz*2.,0., oo));\n            \n            float t = 10e5;\n            \n            for(float i = 0.; i < 4.; i++){\n                float m = sin(iTime*0.4 + sin(iTime)+i);\n                t = min(t,text(uv + vec2(0,sin(i+ m)*0.1), float[8](135.,130.,121.,119.,120.,132.,117.,130.), 0.04 +m*0.5 , 0.5 , true, 0.004, 0.3 + 0.1*sin(iTime+i*0.4), false));\n                \n                \n            }\n            {\n                float m = sin(iTime*0.4 + sin(iTime));\n                vec2 p = uv + vec2(0.7,-0.2);\n                p *= rot(0.5*pi);\n                p.x += (iTime + sin(iTime))*0.3;\n                p.x = pmod(p.x,2.);\n                t = min(t,text(p, float[8](128.,127.,132.,113.,132.,117.,1117.,1130.), 0.01 +m*0.4 , 0.4 , true, 0.0001, 0.4 + 0.*sin(iTime*0.3 + 0.4), true));\n            }   \n             \n            \n            col = mix(col,(0.5-col) ,smoothstep(pxsz + 0.054,0., t));\n            \n\n            \n    }\n     \n    \n    if(mod(iTime,6.)>5.5)\n        col = 1. - col*vec3(1,1,1.5);\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(a) texture(iChannel1,(a)/iResolution.xy)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,a) mod(p,a) - 0.5*a\n#define xorb(a,b,c) min(max(a + c,-(b)),max(b,-(a)))\n#define pi acos(-1.)\n\nmat3 orthogonalBasis(vec3 ro, vec3 lookAt){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(right, up, dir);\n}\nmat3  rotationMatrix3(vec3 v, float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\n\nfloat sdBox(vec2 p, vec2 s){p = abs(p) -s; return max(p.y,p.x);}\n\n#define xor(a,b) min(max(a,-(b)),max(b,-(a) +0.02))\n\nvec3 pal(float m){\n    vec3 c = 0.5+0.5*sin(m + vec3(1.5,0.,-0.5));\n    c = pow(c, vec3( .5));\n    \n    return c;\n}\n\n\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n", "buffer_a_code": "\n\nmat3 fracRotation1;\n\n\nfloat glow = 0.;\nfloat DE(vec3 z)\n{\nvec3 p = z;\n    float m = sin(iTime+sin(iTime)*1.)*0.5 + sin(iTime);\n    z.yz*=rot(.5 );\n    int Iterations = 5;\n    vec3 Offset = vec3(1.376,1.1,1.);\n    vec3 Offset2 = vec3(1.4+(m)*.4,.58,-0.4); \n    float Angle1 = -33.513514 + 5.*sin(m+iTime);\n    vec3 Rot1 = vec3(.96, -2.38 + (m), .19);\n    float Scale = 1.3686;\n\n\tfracRotation1 = Scale* rotationMatrix3(normalize(Rot1), Angle1);\n    float t; int n = 0;\n    float scalep = 1.;\n    float DE1 = 1e4;\n    vec3 z0=z;\n    for(int n = 0; n < Iterations; n++){\n        z *= fracRotation1;\n        //z = abs(z);\n           z -= Offset;\n        if (z.y>z.x) z.xy =z.yx;\n        if (z.z>z.x) z.xz = z.zx;\n        if (z.y>z.x) z.xy =z.yx;\n           z -= Offset2;\n        if (z.y>z.x) z.xy =z.yx;\n        if (z.z>z.x) z.xz = z.zx;\n        if (z.y>z.x) z.xy =z.yx;\n        \n        scalep *= Scale;\n        if(n == 3 || n == 1)\n            glow += exp(-length(z.z+ vec2(1.5,sin(m+iTime + p.x)*1. -0.))/scalep*16.);\n        if(n<3)\n            DE1 = min(DE1,abs(z.x/scalep));\n        else {\n            DE1 = max(DE1,-(z.x/scalep) );\n        \n        \n            //DE1 = max(DE1,-length(z.yz/scalep) + 0.1 );\n        \n        }\n        \n    }\n\t\n\t\t\n\t//Distance to the plane going through vec3(Size,0.,0.) and which normal is plnormal\n\treturn DE1;\n}\n\nvec2 map(vec3 _p){\n    vec2 d = vec2(10e4);\n    \n    //vec4 p = vec4(_p,1.);\n    \n    _p = abs(_p);\n    _p.xz *= rot(-3.);\n    _p.yz *= rot(3.);\n    //d.x = length(_p) - 1.;\n    d.x = DE(_p);\n\n    return d;\n}\n// fast normals, by tdhooper i think.\nconst int NORMAL_STEPS = 6;\nvec3 getNormal(vec3 pos) {\n\n    vec3 eps = vec3(.0001, 0, 0);\n\t\n\tvec3 nor = vec3(0);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < NORMAL_STEPS; i++) {\n\t\tnor += map(pos + eps * invert).x * eps * invert;\n\t\teps = eps.zxy;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\n\nvec3 getNormala(vec3 p){\n    vec2 t = vec2(0.001,0.);\n    return normalize(vec3( \n        map(p+t.xyy).x -map(p-t.xyy).x,\n        map(p+t.yxy).x -map(p-t.yxy).x,\n        map(p+t.yyx).x -map(p-t.yyx).x\n    ));\n}\n\n\nfloat cyclicNoise(vec3 _p){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(_p,1.+iTime*1.);\n    for(int i = 0; i < 4; i++){\n        p.xw *= rot(0.5);\n        p.yw *= rot(.5);\n        p.yz*= rot(1.5);\n        p -= sin(p + vec4(3,2,1.,3. + iTime))*.05*amp;\n        n += dot(sin(p),cos(p))*amp;\n        p *= 1.5;\n        amp *= 0.8;\n    }\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    vec3 col = vec3(0,0.004,0.004);\n    \n    vec3 ro = vec3(0.907761491,4.,3.55399078);\n    vec3 lookAt = vec3(-1.0086998,.8070591066,1.223318864);\n    ro.xz *= rot(sin(iTime*0.5 + cos(iTime/2.)*0.5)*.4 + 2.1  + 0.*(iMouse.x/iResolution.y*2. - 1.));\n    ro.z += 1.7;\n    vec3 rd = orthogonalBasis(ro, lookAt)*normalize(vec3(uv,1.));\n    \n    rd.yz *= rot(0.);\n    vec3 p = ro; float t = 0.; bool hit = false;\n    vec2 d;\n    for(int i = 0; i < 110; i++){\n        d = map(p);\n        if(d.x < 0.0006){\n            hit = true;\n            break;\n        }\n        p = ro + rd*(t+=d.x*0.4);\n    }\n    float fog = 0.;\n    vec3 fp = ro;\n    float ft = 0.;\n    float fogStSz = 0.05;\n    for(int i = 0; i < 0; i++){\n        float dens = cyclicNoise(fp*6.);\n        dens = max(dens,0.);\n        fog += (1.-fog)*dens*fogStSz;\n        if(ft > t){\n            break;\n        }\n        fp = ro + rd*(ft+=fogStSz);\n    }\n    \n    col += mix(vec3(0.,0.1,1.),vec3(1. + sin(iTime +uv.x*0.4)*0.2,0.5,1.),glow*1.6)*glow*0.1;\n    \n    \n    //col += fog*0.1*vec3(0.1,0.5,0.6);\n    if(hit){\n        vec3 n = getNormal(p);\n        \n        bool debug = false;\n        if(debug){\n            col = 0.5 + 0.5*n;\n        }else {\n            vec3 albedo = vec3(.1,0.9,.5);\n            vec3 lCol = vec3(0.2,0.5,0.9);\n            vec3 ldir = normalize(vec3(-1,1.,4.));\n            vec3 hf = normalize(n+ldir);\n            float diff = max(dot(ldir,n),0.);\n            float spec = pow(max(dot(hf,-rd),0.),15.)*1.4;\n            float fres = pow(1.-max(dot(-rd,n),0.),3.);\n            //spec = fres;\n            spec = mix(spec,fres,fres);\n            #define ao(a) smoothstep(0.,1.,map(p+n*a).x/a)\n            float AO = ao(0.3)*ao(4.1)*ao(0.9)+0.;\n            \n            col += 16.*mix(diff*0.02*albedo,lCol*spec,spec)*AO;\n        \n        }\n    \n        \n    } else{\n    \n        //col += sin(rd + vec3(3,4,1))*0.004;\n    }\n    \n    {\n        float pl = plaIntersect(  ro - 4.,  rd, vec4(1,0.,0,0) );\n        vec3 pp = ro +rd*pl;\n\n        vec2 p = pp.yz;\n        p.y += iTime*0. + sin(iTime)*0.0;\n        float md = 1.;\n        vec2 id = floor(p/md);\n        p = pmod(p,md);\n        float d = abs(p.y);\n        d = min(d,abs(p.x));\n        float m = sin(id.y + iTime + cos(id.x*20. +sin(id.y + iTime*0.5)*13.))*0.0;\n        d -= m*0.1;\n        d = max(d,-abs(length(p) - 0.01 -m) + 0.2);\n        //col = mix(col,vec3(0.6,0.7,0.4)*2.*col,col*smoothstep(pxsz,0.,uv.y + 0.3 + 0.04*7.*noise(vec3(uv*4.,1. + iTime))));\n        \n    }\n    \n    //col = clamp(col,0.,1.);\n    \n    col =0.5 - col*4.;\n    \n    //col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    C -= C;\n    vec2 kernSz = vec2(4.);\n    float iters = kernSz.x * kernSz.y;\n    float thresh = 0.1;\n    for(float x = 0.; x < iters; x++){\n            vec2 offs = vec2(\n                mod(x,kernSz.x) - 0.5*kernSz.x,\n                floor(x/kernSz.x) - 0.5*kernSz.y\n                );\n            vec4 t = texture(iChannel0,(U + offs*14.)/iResolution.xy,1.); \n            C += smoothstep(thresh,thresh+1.,t)*(1.-3.*dot(offs/kernSz,offs/kernSz));\n    \n\n    }\n    C = max(C,0.);\n    C /= iters;\n    //C = T(a);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 122, 122, 195], [1185, 1185, 1242, 1242, 6431]], "test": "untested"}
{"id": "NdlSR7", "name": "Disk - gradient 3D", "author": "Dain", "description": "Disk with analytic gradient\n\n", "tags": ["3d", "sdf", "gradient", "normal", "analytic", "disk"], "likes": 1, "viewed": 279, "published": 3, "date": "1618411522", "time_retrieved": "2024-07-30T19:26:22.572977", "image_code": "// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//Rendering code from IQs torus gradient shader https://www.shadertoy.com/view/wtcfzM\n\n\n// Other SDF analytic gradients\n// Egg: https://www.shadertoy.com/view/7dXSz7\n// Oval: https://www.shadertoy.com/view/NdsSRM\n// Disk: https://www.shadertoy.com/view/NdlSR7\n// Box : https://www.shadertoy.com/view/NslSz7\n\n// Other SDF analytic gradients(By IQ):\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n\n//Set to 1 to show the finite difference gradient for comparison\n#define SHOW_NUMERIC_GRADIENT 0\n\n//A Z up disk with gradient\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .w = f(p)/z\n// .yzw = f(p) with f(p) = 1\nvec4 sdgDiskZ(vec3 p, float x, float roundess) {\n    float k = length(p.xy);    \n    float g = max(k-x, 0.0);    \n\tfloat d = length(vec2(p.z, g)) -roundess;\n\n\tvec3 grad = p * vec3(g,g, k);\n\treturn vec4(d, normalize(grad));\n}\n//This shader assumes Y is up, so wrapping it to call the Z version\nvec4 sdgDiskY(vec3 p, float  a, float b) {\n    p.xyz = p.xzy;\n    vec4 r= sdgDiskZ(p, a,b);\n    r.yzw = r.ywz;\n    return r;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.65, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, -0.15, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n      float ra = 0.5;\n    float rb = 0.2+0.1*sin(iTime);\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgDiskY(pos,ra,rb).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgDiskY(pos,ra,rb).yzw;\n\n            // compute normal numerically, for comparison\n            // https://iquilezles.org/articles/normalsSDF\n            #if SHOW_NUMERIC_GRADIENT\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgDiskY( pos + e.xyy*eps, ra, rb ).x + \n                             e.yyx*sdgDiskY( pos + e.yyx*eps, ra, rb ).x + \n                             e.yxy*sdgDiskY( pos + e.yxy*eps, ra, rb ).x + \n                             e.xxx*sdgDiskY( pos + e.xxx*eps, ra, rb ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlSR7.jpg", "access": "api", "license": "mit", "functions": [[1594, 1739, 1787, 1787, 1963], [1964, 2032, 2074, 2074, 2158]], "test": "ok"}
{"id": "ssfXRH", "name": "Pink floyd's Time Tribute", "author": "Pelegefen", "description": "Ok, i think i got the clock gang thing covered by now.\nLast Clock shader. promise. (for the meanwhile).\nAnyway that is the base shader i wanted to do from the start.\nits a tribute to the live graphics PinkFloyd used while preforming.\ninfo,credits, in code", "tags": ["time", "clock", "starfield", "tribute", "pinkfloyd"], "likes": 0, "viewed": 190, "published": 3, "date": "1618409296", "time_retrieved": "2024-07-30T19:26:23.527425", "image_code": "// Main shader at Buffer C, this is a watercolor-like post-procces effects.\n\n\n// Original Clip - https://www.youtube.com/watch?v=BJImSd32f3Y&ab_channel=GoodOldMusic\n\n// Pink floyd's Time Tribute -  Clock shader by Peleg Gefen.\n// Basicaly a \"starfield\" effect with 2D clocks instead of stars, some \"3D\" trickery with UV manipulations.\n// The clocks are set of course, but might not be the best way to tell time, i'll leave it to you.\n\n// I Drew from the abyss Raja's watercolor shader and updated it to run in WebGL2.0 (added 1 to sample func lol)\n// link to WaterColor shader (dead) - https://www.shadertoy.com/view/Xdc3Df\n\n// took alot of inspiration from \"The Art Of Code - Starfield tutorial\" By Martijn Steinrucken\n// link to tutorial (very much alive) - https://www.youtube.com/watch?v=rvDo9LvfoVE&t=391s&ab_channel=TheArtofCode\n\n\n//water color FX r\nconst int radius = 8;\n\n\n\nvec3 sample1( vec2 fragCoord, const int x, const int y)\n{\n\tvec2 uv = (fragCoord.xy + vec2(x, y)) / iResolution.xy;\n\t//uv.y = 1.0 - uv.y;\n\t\n\treturn texture(iChannel1, uv).xyz;\n}\n\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n {\n\t vec2 src_size = vec2 (1.0 / iResolution.x, 1.0 / iResolution.y);\n     vec2 uv = fragCoord.xy/iResolution.xy;\n\n     float n = float((radius + 1) * (radius + 1));\n     int i; \n\t int j;\n     vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n     vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n     vec3 c;\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(iChannel1, uv + vec2(i,j) * src_size).rgb;\n             m0 += c;\n             s0 += c * c;\n         }\n     }\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(iChannel1, uv + vec2(i,j) * src_size).rgb;\n             m1 += c;\n             s1 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(iChannel1, uv + vec2(i,j) * src_size).rgb;\n             m2 += c;\n             s2 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(iChannel1, uv + vec2(i,j) * src_size).rgb;\n             m3 += c;\n             s3 += c * c;\n         }\n     }\n\n\n\t vec4 result;\n     float min_sigma2 = 1e+2;\n     m0 /= n;\n     s0 = abs(s0 / n - m0 * m0);\n\n     float sigma2 = s0.r + s0.g + s0.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m0, 1.0);\n     }\n\n     m1 /= n;\n     s1 = abs(s1 / n - m1 * m1);\n\n     sigma2 = s1.r + s1.g + s1.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m1, 1.0);\n     }\n\n     m2 /= n;\n     s2 = abs(s2 / n - m2 * m2);\n\n     sigma2 = s2.r + s2.g + s2.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m2, 1.0);\n     }\n\n     m3 /= n;\n     s3 = abs(s3 / n - m3 * m3);\n\n     sigma2 = s3.r + s3.g + s3.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m3, 1.0);\n     }\n\t\n\t const vec3 lumi = vec3(0.2126, 0.7152, 0.0722);\n\t\n\tvec3 hc =sample1(fragCoord,-1,-1) *  1.0 + sample1( fragCoord,0,-1) *  2.0\n\t\t \t+sample1( fragCoord,1,-1) *  1.0 + sample1(fragCoord,-1, 1) * -1.0\n\t\t \t+sample1( fragCoord,0, 1) * -2.0 + sample1( fragCoord,1, 1) * -1.0;\n\t\t\n\tvec3 vc =sample1(fragCoord,-1,-1) *  1.0 + sample1(fragCoord,-1, 0) *  2.0\n\t\t \t+sample1(fragCoord,-1, 1) *  1.0 + sample1( fragCoord,1,-1) * -1.0\n\t\t \t+sample1(fragCoord, 1, 0) * -2.0 + sample1( fragCoord,1, 1) * -1.0;\n\t\n\tvec3 c2 = sample1(fragCoord,0, 0);\n\t\n\tc2 -= pow(c2, vec3(0.2126, 0.7152, 0.0722)) * pow(dot(lumi, vc*vc + hc*hc), .5);\n\tfragColor = vec4(overlay(screen( result.rgb,c2.rgb), result.rgb) , 1.0);\n    \n }\n\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// renders the clock!\n\nvec4 Hand(vec2 uv , float l, float w, float t)\n{\n    vec4 col = vec4(0.);\n    \n\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , 1. * RES.y/RES.x * w);\n    \n    uv *= .35;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 7,/* Width*/6.,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n\n \n    col.a = col.r;// at this point, each of the rgb vals is at 1. and showing the mask, so store it in the A channel.\n    \n    col = max (col,vec4(0.));\n    return col;\n}\n\nvec4 HandsShadow(vec2 uv , float l, float w, float t , float b)\n{\n    vec4 col = vec4(0.);\n    \n    uv.y += .05;\n    uv.x -= .02;\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , w);\n    uv.y += .02;\n    uv *= .45;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 7,/* Width*/6. * w,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n    \n    \n   \n    \n    \n    col -= length(uv.y) * 2.; // attenuate based on height\n    \n    \n    \n    col = max (col,vec4(0.));\n    return col * .1;\n}\nvec4 Dial(vec2 uv, float m)\n{\n    \n    vec4 col = vec4(0.);\n    vec2 fuv = polarMap(uv + .5, .008 , .0) * .5;\n    \n    \n    fuv.x = fract(fuv.x * 8. ) ;\n    col += vec4(ShapeN(fuv+vec2(0.,-.6) ,4  ,  3.15, 0.8 ),0.7) * .5;\n    \n    \n    uv = polarMap(uv + .5, .0035 , .25) * .5;\n    \n    uv.x = fract(uv.x * 24. * m ) ;\n\n    vec2 id = floor(uv * 24.  );\n\n    if(id.x <=  1.6 && id.y >= 18. && id.y <= 26.)return col = vec4(.35);\n\n    col = clamp(col,0.,1.);\n    return col;\n}\n\n\n//returns a working clock\nvec4 ClockFace(vec2 uv){\n    \n    //uv += 1.5;\n    vec4 col = vec4(0.,0.,0.,1.);\n    \n    vec4 wt = vec4(.8,.7,0.,1.);// sample wood tex\n    \n    wt += S(-.7,.1,-abs(uv.y)); // add shine\n    \n    float f = circle(uv,4.3, .001 );//clocks frame\n    float fm = (1. - (circle(uv,4.3, .055 ) )) * .6;//clocks frame bevel\n    f -= fm;\n    col += f;\n    col -= circle(uv,3.8, .001 ) - circle(uv,3.7, .001 );//clocks frame\n    col = mix(col,  wt ,  col - circle(uv,3.7, .001 )); // apply wood tex\n\n    //Decoration at 12 o'clock\n    col += circle(uv + vec2(0.,-1.03),0.3, .001 ) * 0.5;\n    col -= circle(uv + vec2(0.,-1.03),0.25, .001 ) * 0.5;\n   // col += circle(uv + vec2(0.,-1.0),0.3, .5 );\n    col -= vec4(ShapeN(uv+vec2(0.,-.5) ,5  ,  5.15, 1.15 ),0.7) * .3;\n    col += circle(   uv + vec2(0.,-.8) ,0.1, .1 );\n    \n    \n    \n    \n    col -= (circle(uv,3.6, .001 ) * .18) + (-uv.y * .1); //inset and shading\n    \n    // Shadow\n    float d = length(uv + vec2(0.,0.1 ))* 0.88;\n    float m = 1. - circle(uv,4.3,.0001);\n  \n    \n     //add the dial and decoration\n    col -= Dial(uv/1.3, 1.);\n    \n    //---------- time is set here------------\n\n    vec4 iDate = iDate;\n    float mils = fract(iDate.w);\n\tfloat secs = mod( floor(iDate.w),        60.0 );\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\n\n\n    vec4 ch1 = Hand(uv, 0.9,0.9, hors  * TAU * .8 );//hours hand\n    \n    ch1 = clamp(ch1,0.,1.);\n    col -= ch1;\n    vec4 ch1s = HandsShadow(uv , 1.,.9, hors  * TAU * .8 , .5);\n    col -= ch1s;\n\n    vec4 ch2 = Hand(uv , 1.6,0.5, mins);//minutes hand\n\n    ch2 = clamp(ch2,0.,1.);\n    col -= ch2;\n    vec4 ch2s = HandsShadow(uv , 1.7,.7, mins , .5);\n    col -= ch2s;\n\n    //vec4 ch3 = Hand(uv ,  2.0, .07 ,secs ); //secondes hand\n    vec4 ch3 = vec4(segmentT(uv,vec2(0,0.),rot(vec2(0.,1.0)  ,secs * TAU/60.  ) , \n    1. * RES.y/RES.x * .05 ));\n   // vec4 ch3m = Hand(uv , 1.1, .05 ,secs ); //secondes hand m\n    //ch3 -= ch3m;\n    \n\n    ch3 = clamp(ch3,0.,1.);\n    col -= ch3;\n    vec4 ch3s = vec4(segmentT(uv,vec2(0,-0.02),rot(vec2(0.1* uv.y ,  1. - uv.y * .1)  ,secs * TAU/60.  ) , \n    1. * RES.y/RES.x * .05 )) * .1;\n    col -= ch3s;\n    \n    vec4 hCol = vec4(0.4,0.4,0.4,1.);// clock hand clr\n    \n    float sh = -   dot(-uv.x * .5,.5) + dot(-uv.y * .5,.5) + .8 ;// clock hands shading\n    \n    \n    vec4 tex1 =hCol / sh;// texture(iChannel0,(rot( uv * 2., -secs* TAU/60.)));\n    vec4 tex2 =hCol/ sh;// texture(iChannel0,(rot( uv * 2., -mins* TAU/60.)));\n    vec4 tex3 =hCol/ sh;// texture(iChannel0,(rot( uv * 2., -hors* TAU/60.)));// we also have to spin the texture per hand!\n  \n    col = mix (col, ch1 * tex3  , ch1) ;\n    col = mix (col,ch2 * tex2 ,ch2 ) ;\n    col = mix (col,ch3 * tex1 ,ch3 ) ;\n    \n    \n    //------------End of Time setting-----------------  \n   \n    float cc =  circle(uv,0.3, .001 ) ;//clocks hand cover\n    cc = ceil(cc);\n    \n    cc = max(cc,0.);\n    cc = min(cc,1.);\n    \n    col =  mix(vec4(cc * .3) , col,1. -cc);\n    col += vec4(circle(uv,0.3, .2 ) * .3) *(fract( uv.y* 50. - .1)  ) ; // dot on the clock hand cover\n    \n    col -= circle(uv,3.7, .001 ) * .18;// glass cover\n    col += max((circle(uv,3.9, .05 ) * .3 * uv.y),0.);\n     m = 1. - circle(uv,4.3,.001);\n    col.a =  1.- m;\n    col = col - m;\n    col = max(vec4(0.),col);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy/iResolution.xy);\n   // uv.y *= 0.56;\n    vec2 ouv = uv;\n    \n    vec4 col = vec4(0.0);\n    \n    uv -= .5;\n    uv.y += .22;\n\n     uv *= 5.2;\n     //col -= max( 1. - length((uv + vec2(.0,.1))* .7), 0.) ;\n    vec4 cf = ClockFace(uv );\n    col = mix(col,cf,cf.a);\n    \n    //if (ouv.x >= -0.01 && ouv.x <= .01) col -= vec4(1.,0.,0.,1.);\n\n  \n\n     \n     \n    // Output to screen\n    fragColor = col;\n}", "buffer_a_inputs": [], "common_code": "#define S smoothstep \n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define RES iResolution.xy\n\n\nvec3 darken( vec3 s, vec3 d )\n{\n\treturn min(s,d);\n}\n\nvec3 multiply( vec3 s, vec3 d )\n{\n\treturn s*d;\n}\n\nvec3 colorBurn( vec3 s, vec3 d )\n{\n\treturn 1.0 - (1.0 - d) / s;\n}\n\nvec3 linearBurn( vec3 s, vec3 d )\n{\n\treturn s + d - 1.0;\n}\n\nvec3 darkerColor( vec3 s, vec3 d )\n{\n\treturn (s.x + s.y + s.z < d.x + d.y + d.z) ? s : d;\n}\n\nvec3 lighten( vec3 s, vec3 d )\n{\n\treturn max(s,d);\n}\n\nvec3 screen( vec3 s, vec3 d )\n{\n\treturn s + d - s * d;\n}\n\nvec3 colorDodge( vec3 s, vec3 d )\n{\n\treturn d / (1.0 - s);\n}\n\nvec3 linearDodge( vec3 s, vec3 d )\n{\n\treturn s + d;\n}\n\nvec3 lighterColor( vec3 s, vec3 d )\n{\n\treturn (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d;\n}\n\nfloat overlay( float s, float d )\n{\n\treturn (d < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 overlay( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = overlay(s.x,d.x);\n\tc.y = overlay(s.y,d.y);\n\tc.z = overlay(s.z,d.z);\n\treturn c;\n}\n\nfloat softLight( float s, float d )\n{\n\treturn (s < 0.5) ? d - (1.0 - 2.0 * s) * d * (1.0 - d) \n\t\t: (d < 0.25) ? d + (2.0 * s - 1.0) * d * ((16.0 * d - 12.0) * d + 3.0) \n\t\t\t\t\t : d + (2.0 * s - 1.0) * (sqrt(d) - d);\n}\n\nvec3 softLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = softLight(s.x,d.x);\n\tc.y = softLight(s.y,d.y);\n\tc.z = softLight(s.z,d.z);\n\treturn c;\n}\n\nfloat hardLight( float s, float d )\n{\n\treturn (s < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 hardLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = hardLight(s.x,d.x);\n\tc.y = hardLight(s.y,d.y);\n\tc.z = hardLight(s.z,d.z);\n\treturn c;\n}\n\nfloat vividLight( float s, float d )\n{\n\treturn (s < 0.5) ? 1.0 - (1.0 - d) / (2.0 * s) : d / (2.0 * (1.0 - s));\n}\n\nvec3 vividLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = vividLight(s.x,d.x);\n\tc.y = vividLight(s.y,d.y);\n\tc.z = vividLight(s.z,d.z);\n\treturn c;\n}\n\nvec3 linearLight( vec3 s, vec3 d )\n{\n\treturn 2.0 * s + d - 1.0;\n}\n\nfloat pinLight( float s, float d )\n{\n\treturn (2.0 * s - 1.0 > d) ? 2.0 * s - 1.0 : (s < 0.5 * d) ? 2.0 * s : d;\n}\n\nvec3 pinLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = pinLight(s.x,d.x);\n\tc.y = pinLight(s.y,d.y);\n\tc.z = pinLight(s.z,d.z);\n\treturn c;\n}\n\nvec3 hardMix( vec3 s, vec3 d )\n{\n\treturn floor(s + d);\n}\n\nvec3 difference( vec3 s, vec3 d )\n{\n\treturn abs(d - s);\n}\n\nvec3 exclusion( vec3 s, vec3 d )\n{\n\treturn s + d - 2.0 * s * d;\n}\n\nvec3 subtract( vec3 s, vec3 d )\n{\n\treturn s - d;\n}\n\nvec3 divide( vec3 s, vec3 d )\n{\n\treturn s / d;\n}\n\n//\trgb<-->hsv functions by Sam Hocevar\n//\thttp://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\t\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hue( vec3 s, vec3 d )\n{\n\td = rgb2hsv(d);\n\td.x = rgb2hsv(s).x;\n\treturn hsv2rgb(d);\n}\n\nvec3 color( vec3 s, vec3 d )\n{\n\ts = rgb2hsv(s);\n\ts.z = rgb2hsv(d).z;\n\treturn hsv2rgb(s);\n}\n\nvec3 saturation( vec3 s, vec3 d )\n{\n\td = rgb2hsv(d);\n\td.y = rgb2hsv(s).y;\n\treturn hsv2rgb(d);\n}\n\nvec3 luminosity( vec3 s, vec3 d )\n{\n\tfloat dLum = dot(d, vec3(0.3, 0.59, 0.11));\n\tfloat sLum = dot(s, vec3(0.3, 0.59, 0.11));\n\tfloat lum = sLum - dLum;\n\tvec3 c = d + lum;\n\tfloat minC = min(min(c.x, c.y), c.z);\n\tfloat maxC = max(max(c.x, c.y), c.z);\n\tif(minC < 0.0) return sLum + ((c - sLum) * sLum) / (sLum - minC);\n\telse if(maxC > 1.0) return sLum + ((c - sLum) * (1.0 - sLum)) / (maxC - sLum);\n\telse return c;\n}\n\nmat2 Rot(float a){\nfloat s = sin(a);\nfloat c = cos(a);\n\n    return mat2(c, -s, s, c);\n}\nfloat Hash21(vec2 n){\n\n   return fract(sin(dot(n.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec3 ShapeN(vec2 st, int N, float w, float h){\n\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  st.x += 1.0 ;\n  st.y += .7;\n  st.y /= h;\n    st.x *= w;\n  // Number of sides of your shape\n  //int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulates the distance\n  d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  color = vec3(S(.41,.4,d));\n\n    return color;\n}\nvec2 polarMap(vec2 uv, float shift, float inner) {\n\n    uv = vec2(0.5) - uv;\n    \n    \n    float px = 1.0 - fract(atan(uv.y, uv.x) / 6.28 + 0.25) + shift;\n    float py = (length(uv) * (1.0 + inner * 2.0) - inner) * 2.0;\n    \n    return vec2(px, py);\n}\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\nfloat circle (vec2 p, float r, float g)\n{\n\n    float d = length(p / r);\n\n    float ss = S(.32,.32 - g,d);\n    \n    ss = max(0.,ss);\n    return ss;\n\n}\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn S(r, 0.7*r, d);\n}\nfloat segmentT(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A ;\n    float d = length(h - g * clamp(dot(g , h ) / dot(g,g), 0.0, 1.0));\n    \n\n\treturn S(r, 0.7*r, d);\n}", "buffer_b_code": "//BG\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(.5);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 ouv = uv;\n    vec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    \n    \n    uv = M*4.; \n    vec2 ruv = rot(uv,iTime* .05) * .5;\n    uv.x += .01 * iTime;\n    uv.x = sin(uv.y);\n    uv.y = abs(uv.y);\n    vec4 tx = texture(iChannel0,ruv + ouv) * 1.1;\n    vec4 tx1 = texture(iChannel1,( uv+ ouv)*.2+.5) * 1.3;\n    tx = vec4(tx.r);\n    tx1 = vec4(tx1.r);\n    col += vec4(.4,.4,1.,1.) * uv.y ;\n    col *= tx;\n    col *= tx1;\n    col = clamp(col,0.2,1.);\n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// number of layers to render, go over 5.5 only if you have a strong GPU! \n// min is 1.1\n#define NUM_LAYERS 5.5\n\nvec4 Layer(vec2 uv )\n{\n   // uv.y *= 2.0;\n    vec2 ouv = uv; //storing the original uvs.\n\n\n    uv.x +=  iTime * .001;\n    uv = rot(uv, 0.001 * iTime);\n    vec2 buv = uv;\n    //buv.x = buv.x +sin( buv.y + iTime * .001);\n    \n    \n    buv *= cos(sin(  iTime * .0001)*.5+.5) * 5.;\n    //vec2 mouse = iMouse.xy / iResolution.xy + .5;\n    //buv *= 1.- mouse.x + 1.5;\n    \n    buv.x -= .5;\n    \n    vec2 id = floor(buv);\n    vec2 fuv = fract(buv);\n    \n    buv = fuv;\n    vec4 col = vec4( 0.);\n    \n    buv -= .25;\n   // buv.x += .1;\n    //uv = buv;\n\n    if ( mod(id.x,2.) == 0.)buv.x = (abs( (buv.x )/ sin(Hash21(id) *(iTime * .5  * (Hash21(id)))))); //fake 3d rotation\n    \n    \n    //buv.y *= 2.5 +.5;\n    buv /= 1.5 - Hash21(id);// random size\n    vec4 cf = texture(iChannel0,rot(buv * 3.5  -0.5,iTime * .1 * (Hash21(id))));\n    \n    \n    cf = min(cf,vec4(1.));\n    \n    col = mix(col,cf,cf.a);\n    //col + id;\n    \n   //col += vec4(fuv,0.,1.);\n  \n    \n\n\ncol.a = floor(cf.a);\n//\nreturn col;\n\n}\n\nvec4 RegLayer(vec2 uv )\n{\n    vec2 ouv = uv; //storing the original uvs.\n\n\n    vec2 buv = uv;\n\n   buv *= (sin(iTime * .01)*.5+.5) * 20.;\n    //buv *= 13.;\n    \n    \n    vec2 id = floor(buv);\n    vec2 fuv = fract(buv);\n    \n    buv = fuv;\n    vec4 col = vec4( 0.);\n\n    \n    \n    \n    vec4 cf = texture(iChannel0,buv * 1.3);\n    \n    \n    cf = min(cf,vec4(1.));\n    \n    col = mix(col,cf,cf.a);\n    \n    \n\n  \n    \n\n\ncol.a = floor(cf.a);\n//\nreturn col;\n\n}\n\nvec4 ClockSoup(vec2 uv, vec2 nuv)\n{\n\n\n   vec2 ouv = uv;\n\tvec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    vec4 col = vec4(0);\n    float t = iTime*.01;\n    \n    uv += M*4.;\n    \n    uv *= Rot(t);\n    \n  \n     float m = 1.;\n    \n    vec4 tcol = vec4(0.);\n    \n    \n     //add clock layers loop\n    for(float i=0.; i<=1.; i+=1./NUM_LAYERS) {\n    \tfloat depth = fract(i+t);\n        \n        float s = mix(1.5, .01,i + depth);\n        float f = depth * smoothstep(1., .95, depth);\n        \n        uv = rot(uv, t * i);\n        vec4 l = Layer(uv*s+i*22.2-M);\n        l.a *= f;\n        m -= l.a;\n      \n        \n        col -= l.a;\n        col = clamp(col,0.,1.);\n        col = mix(col,l, l.a);\n\n    }\n    col = clamp(col,0.,1.);\n    //col = vec4(uv,.0,1.);\n    return col;\n}\n\nvec4 ClockHorizonSquash(vec2 uv, vec2 nuv)\n{\n    vec2 ouv = uv;\n    vec4 col = vec4(0.);\n    uv.x =  (abs(1.-uv.y) * uv.x) ;\n    uv.x = pow(uv.y,uv.x * .2 );\n    uv.y = pow(uv.y,.2);\n    uv.y = -abs(uv.y );\n    uv.y += fract(iTime * .05);\n    \n    \n    vec4 rl = RegLayer( ( uv + vec2(.205,.0)) * 1.3);\n\n    col += rl;\n    col = clamp(col,0.,1.);\n    col -=  pow(length(fract(1.- ouv.y)),12.1);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   vec2 nuv = fragCoord.xy/iResolution.xy;\n\n   vec2 ouv = uv;\n\tvec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    vec4 col = vec4(0);\n    float t = iTime*.01;\n    \n    float bs = (sin(t * 15.)*.5+.5);// used to blend between the animations\n    \n    vec4 bg = texture(iChannel2, nuv );\n    //\n    vec4 cs = ClockSoup(uv,nuv);\n    vec2 huv = uv;\n    huv.y = abs(huv.y);\n    vec4 chs = ClockHorizonSquash(huv - vec2((M.x * .5),abs(M.y) * .5),nuv);\n    \n    \n    col = clamp(col,0.,1.);\n    \n    \n    vec4 blend =  mix(cs,chs,S(0.4,.6,bs));\n    blend = clamp(blend,0.,1.);\n    col = mix(blend,bg,1. -blend);\n    \n\n    //col += cs;\n    col = pow(col, vec4(.82));\t//gamma corrct\n    \n    col -= pow(length(ouv * 2.),124.7)  ;//circle vignette\n    //col = vec4(1. -blend);\n    col = clamp(col,0.,1.);\n        //col = texture(iChannel0,nuv);\n   // col = Layer(uv);\n    fragColor = col;\n\n    \n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfXRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[881, 881, 938, 938, 1057], [1061, 1061, 1120, 1120, 3883]], "test": "untested"}
{"id": "NdsSRM", "name": "Oval - gradient 3D", "author": "Dain", "description": "Oval with analytic gradient\nOval shape is from sylvain69780 shader here https://www.shadertoy.com/view/Ws3BWH, but 3D and modified to be branchless so there are less length() calls\n\nOval is a capsule, with adjustable mid radius \n", "tags": ["3d", "sdf", "gradient", "normal", "analytic", "oval"], "likes": 1, "viewed": 391, "published": 3, "date": "1618404026", "time_retrieved": "2024-07-30T19:26:24.302353", "image_code": "// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//Rendering code from IQs torus gradient shader https://www.shadertoy.com/view/wtcfzM\n\n// sdgOval returns the oval SDF and its gradient, by \n// computing it analytically. \n\n// Other SDF analytic gradients\n// Egg: https://www.shadertoy.com/view/7dXSz7\n// Oval: https://www.shadertoy.com/view/NdsSRM\n// Disk: https://www.shadertoy.com/view/NdlSR7\n// Box : https://www.shadertoy.com/view/NslSz7\n\n\n// Other SDF analytic gradients(By IQ):\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n\n//Set to 1 to show the finite difference gradient for comparison\n#define SHOW_NUMERIC_GRADIENT 0\n\n//A Z up oval, similiar to a capsule with a customizable mid radius\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .w = f(p)/z\n// .yzw = f(p) with f(p) = 1\nvec4 sdgOvalZ(vec3 pIn, float  a, float b, float h) {\n    \n    //These first 4 lines can be precalculated once\n    float r = a - b; //a must be greater than b!\n\tfloat l = (h * h - r * r) / (r+r);\n\tfloat sub2 = (a + l);\n\tfloat sub1 = sub2 - length(vec2(h, l));\n       \n\n    vec2 p = vec2(length(pIn.xy), abs(pIn.z) );\n    \n\tbool isTop =((p.y-h)*l) > p.x * h;\n    \n\tfloat y = isTop? h: 0.0;\n\tfloat x = isTop ? 0.0: l;\n\n\tvec2 p2 = vec2( p.x + x, p.y - y );\n   \n\tfloat d = length(p2)- (isTop ? sub1 : sub2);  \n\tvec3 grad = vec3(pIn.xy, pIn.z-y)*vec3(p2.x, p2.x, p.x );\n  \n\treturn vec4(d, normalize(grad));\n}\n\n//This shader assumes Y is up, so wrapping it to call the Z up oval\nvec4 sdgOvalY(vec3 p, float  a, float b, float h) {\n    p.xyz = p.xzy;\n    vec4 r= sdgOvalZ(p, a,b,h);\n    r.yzw = r.ywz;\n    return r;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an),1.30, 1.0*sin(an));\n    vec3 ta = vec3( 0.0, .5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    float ra = 0.5 + 0.4*cos(iTime);\n    float rb = min(0.1+0.1*(sin(iTime)), ra*.9);\n    float height = abs(cos(iTime*.5))*.5 +0.6;\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgOvalY(pos,ra,rb, height).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgOvalY(pos,ra,rb, height).yzw;\n\n            // compute normal numerically, for comparison\n            // https://iquilezles.org/articles/normalsSDF\n            #if SHOW_NUMERIC_GRADIENT\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgOvalY( pos + e.xyy*eps, ra, rb,height ).x + \n                             e.yyx*sdgOvalY( pos + e.yyx*eps, ra, rb,height ).x + \n                             e.yxy*sdgOvalY( pos + e.yxy*eps, ra, rb,height ).x + \n                             e.xxx*sdgOvalY( pos + e.xxx*eps, ra, rb,height ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSRM.jpg", "access": "api", "license": "mit", "functions": [[1680, 1865, 1918, 1975, 2468], [2470, 2538, 2589, 2589, 2675]], "test": "ok"}
{"id": "7dXSz7", "name": "Egg - gradient 3D", "author": "Dain", "description": "Egg with analytic gradient\nEgg shape is from sylvain69780 shader here https://www.shadertoy.com/view/wsBBR3, but 3D and modified to be branchless so there are less length() calls\n\nEgg is similar to a BiCapsule, but rounded along the height axis\n", "tags": ["3d", "sdf", "gradient", "normal", "analytic", "egg"], "likes": 1, "viewed": 289, "published": 3, "date": "1618403220", "time_retrieved": "2024-07-30T19:26:25.074289", "image_code": "// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//Rendering code from IQs torus gradient shader https://www.shadertoy.com/view/wtcfzM\n\n// sdgEgg returns the egg SDF and its gradient, by \n// computing it analytically. \n\n// Other SDF analytic gradients\n// Egg: https://www.shadertoy.com/view/7dXSz7\n// Oval: https://www.shadertoy.com/view/NdsSRM\n// Disk: https://www.shadertoy.com/view/NdlSR7\n// Box : https://www.shadertoy.com/view/NslSz7\n\n\n// Other SDF analytic gradients(By IQ):\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n\n//Set to 1 to show the finite difference gradient for comparison\n#define SHOW_NUMERIC_GRADIENT 0\n\n//A Z up egg, similiar to a bicapsule but rounded along the axis instead of flat\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .w = f(p)/z\n// .yzw = f(p) with f(p) = 1\nvec4 sdgEggZ(vec3 pIn, float  a, float b, float h) {\n    //These first 4 lines can be precalculated once\n    float r = a - b; //a must be greater than b!\n\tfloat l = (h * h - r * r) / (r+r);\n\tfloat sub2 = (a + l);\n\tfloat sub1 = sub2 - length(vec2(h, l));\n\n    vec2 p = vec2(length(pIn.xy), pIn.z );\n    \n\tbool subZero = p.y < 0.0;\n\tbool isTop =((p.y-h)*l) > p.x * h;\n    \n\tfloat y = (!subZero && isTop)? h: 0.0;\n\tfloat x = (isTop || subZero) ? 0.0: l;\n\n\tvec2 p2 = vec2( p.x + x, p.y - y );\n     \n    float sub = isTop ? sub1 : sub2;\n    sub = subZero ? a : sub;\n      \n\n\tfloat d = length(p2)- sub;\n    \n\tvec3 grad = vec3(pIn.xy, pIn.z-y)*vec3(p2.x, p2.x, p.x );\n  \n\treturn vec4(d, normalize(grad));\n}\n\n//This shader assumes Y is up, so wrapping it to call the Z up egg\nvec4 sdgEggY(vec3 p, float  a, float b, float h) {\n    p.xyz = p.xzy;\n    vec4 r= sdgEggZ(p, a,b,h);\n    r.yzw = r.ywz;\n    return r;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 1.0, 1.0*sin(an));\n    vec3 ta = vec3( 0.0, .5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    float ra = 0.5 + 0.2*cos(iTime);\n    float rb = min(0.1+0.1*(sin(iTime)), ra*.9);\n    float height = abs(cos(iTime*.5))*.5 +0.6;\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgEggY(pos,ra,rb, height).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgEggY(pos,ra,rb, height).yzw;\n\n            // compute normal numerically, for comparison\n            // https://iquilezles.org/articles/normalsSDF\n            #if SHOW_NUMERIC_GRADIENT\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgEggY( pos + e.xyy*eps, ra, rb,height ).x + \n                             e.yyx*sdgEggY( pos + e.yyx*eps, ra, rb,height ).x + \n                             e.yxy*sdgEggY( pos + e.yxy*eps, ra, rb,height ).x + \n                             e.xxx*sdgEggY( pos + e.xxx*eps, ra, rb,height ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXSz7.jpg", "access": "api", "license": "mit", "functions": [[1678, 1876, 1928, 1980, 2575], [2577, 2644, 2694, 2694, 2779]], "test": "ok"}
{"id": "NdfXR7", "name": "impossible boxes piles", "author": "FabriceNeyret2", "description": "reference: [img]https://i.imgur.com/oxv28g9.png[/img]", "tags": ["illusion", "escher", "isometric", "short", "reproduction", "paradoxical", "tomgauld"], "likes": 11, "viewed": 301, "published": 3, "date": "1618397410", "time_retrieved": "2024-07-30T19:26:25.845228", "image_code": "\n#define rot(a)    mat2( cos(a+vec4(0,-1.57,1.57,0)) )    // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.;\n    vec3  R = iResolution, L = vec3(4,5,4), q,r,a,\n          M = // iMouse.z > 0. ? 2.*iMouse.xyz/R -1. :   // try mouse control to see the trick\n                               vec3(.785,.41,0),\n          p = vec3( 10.*(U+U-R.xy)/R.y, 20 );            // ray start. dir = (0,0,-1)\n                                       \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 ) {        // marching point along ray\n        q = p, t = 1.,\n        q.yz *= rot(M.y),                                // rotations\n        q.xz *= rot(M.x);\n        a = abs( r = round(q/L) );                       // box id\n        r = p.y<0. ? r : -r;                             // for \"vertical\" connections\n    \n        if ( a.x*a.z == 0. )\n            if (  a.y == 0. && max(a.x,a.z) < 5.         // 2 rows of boxes\n               || r == vec3(4,1,0) || r == vec3(0,1,4)   // \"vertical\" connections\n               )  q = mod(q+L/2.,L) - L/2.,  \n               // q.xz *= rot(.5*iTime),                 // box rot: try me !\n                  a = abs(q) - 1.2,\n                  t = max( a.x, max(a.y-1.,a.z) );       // box SDF\n        \n        p.z -= .5*t;                                     // step forward = dist to obj          \n    }\n\n    O = t<.01 ? vec4(1, 1,.9,1) * ( t==a.z ? .6 : t==a.x ? .4 : .8 ) // coloring\n              : vec4(.9,.9,1,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 125, 125, 1474]], "test": "untested"}
{"id": "sdXSRM", "name": "Northern Stream, Maybe Clean", "author": "TEttinger", "description": "There's an awful lot of bright colors for a river, but it does look like dyes flowing through water somewhat. Part of my Northern Lights series, with some updates.", "tags": ["noise", "plasma", "water", "lights", "stream", "northern"], "likes": 3, "viewed": 338, "published": 3, "date": "1618387476", "time_retrieved": "2024-07-30T19:26:26.609185", "image_code": "// CC0 licensed, do what thou wilt.\nconst float SEED = 42.0;\n\n// UE4 PseudoRandom function\nfloat pseudo(vec2 v) {\n    v = v + vec2(-64.340622, -72.465622);\n    return sin(dot(v.xyx * v.xyy, vec3(20.390625, 60.703125, 2.4281209)));\n}\n\nfloat swayRandomized(float seed, float value)\n{\n    float f = floor(value);\n    float start = pseudo(vec2(seed, f));\n    float end   = pseudo(vec2(seed, f+1.0));\n    return mix(start, end, smoothstep(0., 1., value - f));\n}\n\nvec3 cosmic(float seed, vec3 con)\n{\n    con.x += swayRandomized(seed, con.z + con.x);\n    con.y += swayRandomized(seed, con.x + con.y);\n    con.z += swayRandomized(seed, con.y + con.z);\n    return con * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 8.0 * fragCoord/iResolution.xy;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.225;\n    vec3 s = vec3(swayRandomized(-164.0531527, aTime - 1.11),\n                  swayRandomized(-776.648142, aTime + 1.41),\n                  swayRandomized(-509.935190, aTime + 1.61));\n    vec3 c = vec3(swayRandomized(-105.2792407, aTime - 1.11),\n                  swayRandomized(-615.576687, aTime + 1.41),\n                  swayRandomized(-435.278990, aTime + 1.61));\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    con = cosmic(SEED, con);\n    con = cosmic(SEED, con);\n    con = cosmic(SEED, con);\n    \n    fragColor = vec4(sin(con * 3.14159265) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 91, 113, 113, 232], [234, 234, 281, 281, 456], [458, 458, 493, 493, 667], [669, 669, 726, 776, 1522]], "test": "untested"}
{"id": "fdXSz7", "name": "rocket swimers form", "author": "lomateron", "description": "based on https://www.shadertoy.com/view/sdsXzN", "tags": ["convolution"], "likes": 4, "viewed": 248, "published": 3, "date": "1618383342", "time_retrieved": "2024-07-30T19:26:27.492822", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = a.x+.5                                   //color amount   of fluid\n                +vec4(1,1,0,0)*dot(a,vec4(1,-1,0,0))*11.;//color velocity of fluid\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = A(u+vec2(0,0));\n    float b = 0.;\n    \n    //b = +1.0*A(u+vec2(0,0)).x;\n    //kernel convolution that reads from current 2D frame values\n    {\n        float z = 1.;//kernel convolution size\n        float t = z*2.+1.;\n              t = 1./(t*t-1.);\n        float b0 = abs(a.x);\n        for(float i = -z; i<z+.5;++i){\n        for(float j = -z; j<z+.5;++j){\n          float s = 0.;\n          for(float i2 = -z; i2<z+.5;++i2){\n          for(float j2 = -z; j2<z+.5;++j2){\n          s += abs(A(u+vec2(i,j)+vec2(i2,j2)).x);\n          }}\n          float    d = 2./s;\n          if(s==0.)d = 0.;\n          s = b0*d;\n          float e = A(u+vec2(i,j)).x;\n          s = mix(s,(2.-s)*t,.36);\n          b += s*e;\n        }}\n    }\n    //kernel convolution that reads from previous 2D frame values\n    {\n        float z = 1.;//kernel convolution size\n        float t = z*2.+1.;\n              t = 1./(t*t-1.);\n        float b0 = abs(A(u+vec2(0,0)).y);\n        for(float i = -z; i<z+.5;++i){\n        for(float j = -z; j<z+.5;++j){\n          float s = 0.;\n          for(float i2 = -z; i2<z+.5;++i2){\n          for(float j2 = -z; j2<z+.5;++j2){\n          s += abs(A(u+vec2(i,j)+vec2(i2,j2)).y);\n          }}\n          float    d = 1./s;\n          if(s==0.)d = 0.;\n          s = b0*d;\n          float e = A(u+vec2(i,j)).y;\n          s = mix(s,(1.-s)*t,.33);\n          b -= s*e;\n        }}\n    }\n    a = vec4(b,a.xyz);\n\n    if(iFrame==0)\n    {\n        vec2  m1 = 2.*(u-iResolution.xy*.5)/iResolution.y;\n        a += 1./exp(dot(m1,m1)*22.);\n    }\n    fragColor = a;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 299]], "test": "untested"}
{"id": "NsXXzM", "name": "Fortifications", "author": "jarble", "description": "This fractal resembles some sort of roguelike dungeon map.", "tags": ["fractal", "bitwisemath"], "likes": 7, "viewed": 269, "published": 3, "date": "1618373003", "time_retrieved": "2024-07-30T19:26:28.381447", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 0.2;\n    float trans = iTime * 7.0;\n    vec2 coord = (scale * fragCoord) + vec2(trans,trans);\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    for(int i = 0; i < 3; i++){\n        coord /= (3.5+result);        \n        val = ((int(coord.x) | int(coord.y+result)) % (3-val));\n        result = ((result + float(val))/2.0);\n    }\n    // Output.\n    fragColor = vec4((result));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXXzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdsXzN", "name": "squared anti-fluid", "author": "lomateron", "description": "click to add fluid\npress A to apply image\nbased on https://www.shadertoy.com/view/fsfSzN\nas the fluid gains velocity it will flip from positive-negative and lose its velocity\noposite colors repell\nI wornder if something behaves like this in the real world", "tags": ["simulation", "fluid"], "likes": 8, "viewed": 398, "published": 3, "date": "1618359909", "time_retrieved": "2024-07-30T19:26:29.217212", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = vec4(0)+a.x*.5+.5                        //color amount   of fluid\n                +vec4(0,1,0,0)*dot(a,vec4(1,-1,0,0))*64.;//color velocity of fluid\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = A(u+vec2(0,0));\n    float b = 0.;\n    \n    //b = +1.0*A(u+vec2(0,0)).x;\n    //kernel convolution that reads from current 2D frame values\n    {\n        float z = 1.;//kernel convolution size\n        float t = z*2.+1.;\n              t = 1./(t*t-1.);\n        float b0 = abs(a.x);\n        for(float i = -z; i<=z;++i){\n        for(float j = -z; j<=z;++j){\n          float s = 0.;\n          for(float i2 = -z; i2<=z;++i2){\n          for(float j2 = -z; j2<=z;++j2){\n          s += abs(A(u+vec2(i,j)+vec2(i2,j2)).x);\n          }}\n          float    d = 2./s;\n          if(s==0.)d = 0.;\n          s = b0*d;\n          float e = A(u+vec2(i,j)).x;\n          s = mix(s,(2.-s)*t,min(abs(e),1.));\n          b += s*e;\n        }}\n    }\n    //kernel convolution that reads from previous 2D frame values\n    {\n        float z = 1.;//kernel convolution size\n        float t = z*2.+1.;\n              t = 1./(t*t-1.);\n        float b0 = abs(A(u+vec2(0,0)).y);\n        for(float i = -z; i<=z;++i){\n        for(float j = -z; j<=z;++j){\n          float s = 0.;\n          for(float i2 = -z; i2<=z;++i2){\n          for(float j2 = -z; j2<=z;++j2){\n          s += abs(A(u+vec2(i,j)+vec2(i2,j2)).y);\n          }}\n          float    d = 1./s;\n          if(s==0.)d = 0.;\n          s = b0*d;\n          float e = A(u+vec2(i,j)).y;\n          s = mix(s,(1.-s)*t,min(abs(e),1.));\n          b -= s*e;\n        }}\n    }\n    a = vec4(b,a.xyz);\n\n    float keyA  = texture( iChannel1, vec2(65.5/256.,.25) ).x;\n    float keyS  = texture( iChannel1, vec2(83.5/256.,.25) ).x;\n    if(keyA!=0.)a = texture( iChannel2, u/iResolution.xy).xxxx-.6;\n    if(keyS!=0.)a = vec4(0);\n    if(iMouse.z>0.||iFrame==0)\n    {\n                 vec2 m1 = 2.*(u-iMouse.xy)/iResolution.y;\n        if(iFrame==0) m1 = 2.*(u-iResolution.xy*.5)/iResolution.y;\n        a += .1/exp(dot(m1,m1)*22.);\n    }\n    fragColor = a;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 299]], "test": "untested"}
{"id": "sslXzN", "name": "Fractal 57_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 8, "viewed": 305, "published": 3, "date": "1618358555", "time_retrieved": "2024-07-30T19:26:30.059959", "image_code": "#define PI (atan(1.)*4.)\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define M(p,n)vec2(asin(sin(atan(p.x,p.y)*n))/n,1)*length(p)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.8)*.02*exp(-.2*i*i*e)\n    )\n    {\n        p=g*d;\n        q=p=R(p,normalize(vec3(1,1,2)),.5*sin(iTime*.1));\n        p+=vec3(.3,.5,iTime*.3);\n        p=sin(2.7*p+5.*sin(p*.3));\n        s=3.;\n        for(int i;i++<6;)\n            p=abs(p-1.7)-1.6,\n            s*=e=2.3/clamp(dot(p,p),.1,1.2),\n            p=abs(p)*e;\n        g+=e=length(p.zy)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 228, 228, 753]], "test": "untested"}
{"id": "NsjGD3", "name": "Floats and wobbles", "author": "Chaotnix", "description": "This is based on Fractal 51_gaz by gaz", "tags": ["fractal", "audioreactive", "soundcloud"], "likes": 2, "viewed": 312, "published": 3, "date": "1618355088", "time_retrieved": "2024-07-30T19:26:30.887745", "image_code": "//This shader is based on Fractal 51_gaz by gaz\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 fragColor,  in vec2 fragCoord)\n{\n    vec4 O=vec4(0);\n\tvec2 C = fragCoord;\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<40.;\n        O.xyz+=mix(vec3(1),H(log(s)*.45),.4)*.03*exp(-.2*i*i*e) \n    )\n    {\n        p=g*d +( .005 * texture(iChannel0,O.xy).xy,5.);// vec3(0,0,.5);\n        //p+= .001 * texture(iChannel0, vec2(length(C),.3) ).x;\n        p=R(p.zxy,normalize(vec3(0.2,0.4,0.9)),iTime*.03);\n        s=2.;\n        for(int i;i++<6;)\n            p=abs(p-vec3(1,2.8,1.5+sin(0.1 * clamp(texture(iChannel0, vec2(length(C),.3) ).x,0.3,.5)-g*.1)*.04))-vec3(1,3.+sin(iTime*.7)*.3,2.1),\n            p*=(fract(iTime*.5)>1.)?-1.:1.,\n            s*=e=7./clamp(dot(p,p),1.2,7.),\n            p*=e;\n            p+= clamp(texture(iChannel0, vec2(length(O),.8) ).y,0.1,1.) * .5, 5.;\n        g+=e=min(abs(p.z),length(p.xy)-.05)/s+1e-3;\n    }\n \n     vec4 cTexture = texture(iChannel1,p.xy);\n//     fragColor -= .5 * O - cTexture;\n     fragColor =  (.70 + O) - (1. - 0.5 * cTexture);\n//     fragColor = mix( 0.7 * O , cTexture, .25);\n//     fragColor = max( 0.7 * O , 0.3 * cTexture);\n\n\n}    ", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26654, "src": "https://soundcloud.com/redincansun/droplex-psychological-attack-original-mix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 211, 211, 1317]], "test": "untested"}
{"id": "7ssSR4", "name": "MinimalClock", "author": "kaihagseth", "description": "Minimal clock face.", "tags": ["clock", "animation"], "likes": 3, "viewed": 255, "published": 3, "date": "1618349598", "time_retrieved": "2024-07-30T19:26:31.652700", "image_code": "#define PI 3.141592\n\nvec3 arm(in vec2 st, float period, float radius, float thickness, vec3 color1, vec3 color2)\n{\n  float line = (1.0 - smoothstep(radius + .0001, radius - .0001,  st.y)) * (smoothstep(radius + thickness + .0001, radius + thickness - .0001,  st.y));\n  float phase = step(.5, fract(iDate.w/period / 2.0)) - .5;\n  float p1 = step(sign(phase), 0.0); \n  float p2 = step(-sign(phase), 0.0); \n  \n  float x = (fract(iDate.w/period) + st.x + .5) - 1.0;\n  float x2 = (-fract(iDate.w/period) - st.x + .5);\n  float c = clamp(sign(x), 0.0, 1.0);\n  float c2 = clamp(sign(x2), 0.0, 1.0);\n  \n  vec3 col1 = (p1*color1) + (p2*color2);\n  vec3 col2 = (p2*color1) + (p1*color2);\n  \n  vec3 out1 = (line * c * col1);\n  vec3 out2 = (line * c2 * col2);\n  return vec3(out2 + out1);\n}\n\n// Rotates cartesian coordinate system\nvec2 rotate2d(in vec2 st, in float angle)\n{\n    return st * mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n// Maps a cartesian coordinate system to a polar one\nvec2 map2Circle(in vec2 st)\n{\n    return vec2(atan(st.y, st.x), length(st)) / (2. * PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to .5)\n    vec2 st = ( fragCoord - .5* iResolution.xy) / min(iResolution.x, iResolution.y);\n    st = rotate2d(st, PI/2.0);      // Rotate 90 degrees to make clock start at top\n    st = map2Circle(st);            // Change coordinate system to polar coordinates\n    \n    vec3 color1 = vec3(1.0, 0.0, 0.0);\n    vec3 color2 = vec3(.4, 0.0, 0.0);\n    vec3 img = arm(st, 60.0, .0465, .0056, color1, color2); // seconds\n    \n    color1 = vec3(1.0, 0.7, 0.0);\n    color2 = vec3(.8, 0.4, 0.0);\n    img += arm(st, 60.0 * 60.0, .04, .005, color1, color2); // minutes\n    \n    color1 = vec3(0.8, 0.0, 1.0);\n    color2 = vec3(0.4, 0.0, 0.6);\n    img += arm(st, 60.0 * 60.0 * 12.0, .034, .0045, color1, color2); // hours\n    \n    img = max(vec3(0.0, 0.0, 0.1), img); // Add background\n   \n    // Output to screen\n    fragColor = vec4(img, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 114, 114, 775], [777, 816, 859, 859, 932], [934, 987, 1016, 1016, 1077], [1079, 1079, 1136, 1190, 2017]], "test": "untested"}
{"id": "fssXzN", "name": "mandelbulb-by neozhaoliang", "author": "jorge2017a1", "description": "mandelbulb-by neozhaoliang", "tags": ["mandelbulbbyneozhaoliang"], "likes": 8, "viewed": 380, "published": 3, "date": "1618344282", "time_retrieved": "2024-07-30T19:26:32.476498", "image_code": "//by neozhaoliang\n//https://www.shadertoy.com/user/neozhaoliang\n\n#define AA                 1//2\n#define FOV_DIST           3.0\n#define BULB_ITERATIONS    7//8\n#define SPONGE_ITERATIONS  9\n#define MAX_TRACE_STEPS    200//200\n#define MIN_TRACE_DIST     0.01\n#define MAX_TRACE_DIST     10.0\n#define PRECISION          1e-4\n#define PI                 3.14159265358979323\n#define T                  (iTime * 0.1)\n\n// view to world transformation\nmat3 viewMatrix(vec3 camera, vec3 lookat, vec3 up)\n{\n    vec3 f = normalize(lookat - camera);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    return mat3(r, u, -f);\n}\n\n// 2D rotatation\nvoid R(inout vec2 p, float a)\n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat mandelbulb(vec3 p)\n{\n    p /= 1.192;\n    p.xyz = p.xzy;\n    vec3 z = p;\n    vec3 dz = vec3(0.0);\n    float dr = 1.0;\n    float power = 8.0;\n    float r, theta, phi;\n    for (int i = 0; i < BULB_ITERATIONS; i++)\n    {\n        r = length(z);\n        if (r > 2.0)\n            break;\n        float theta = atan(z.y / z.x);\n        float phi = asin(z.z / r);\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n        r = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n        z = r * vec3(cos(theta) * cos(phi), cos(phi) * sin(theta), sin(phi)) + p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nfloat sdSponge(vec3 z)\n{\n    for(int i = 0; i < SPONGE_ITERATIONS; i++)\n    {\n        z = abs(z);\n        z.xy = (z.x < z.y) ? z.yx : z.xy;\n        z.xz = (z.x < z.z) ? z.zx : z.xz;\n        z.zy = (z.y < z.z) ? z.yz : z.zy;\t \n        z = z * 3.0 - 2.0;\n        z.z += (z.z < -1.0) ? 2.0 : 0.0;\n    }\n    z = abs(z) - vec3(1.0);\n    float dis = min(max(z.x, max(z.y, z.z)), 0.0) + length(max(z, 0.0)); \n    return dis * 0.6 * pow(3.0, -float(SPONGE_ITERATIONS)); \n}\n\nfloat DE(vec3 p)\n{\n    float d1 = mandelbulb(p);\n    float d2 = sdSponge(p);\n    return max(d1, d2);\n    \n}\n\nvec3 calcNormal(vec3 p)\n{\n    const vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n\t\t\t  DE(p + e.xyy) - DE(p - e.xyy),\n\t\t\t  DE(p + e.yxy) - DE(p - e.yxy),\n\t\t\t  DE(p + e.yyx) - DE(p - e.yyx)));\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    float h;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++)\n    {\n        h = DE(ro + rd * t);\n        if (h < PRECISION * t || t > MAX_TRACE_DIST)\n            return t;\n        t += h;\n    }\n    return -1.0;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 10; i++)\n    {\n        float h = DE(ro + rd * t);\n        res = min(res, k * h / t);\n        t += clamp(h, 0.01, 0.1);\n        if (h < 0.001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = DE(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.9;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd, vec3 lig)\n{\n    vec3 background = vec3(0.08, 0.16, 0.32);\n    vec3 col = background;\n    float t = trace(ro, rd);\n    if (t >= 0.0)\n\t{\n        col = vec3(0.9);\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        float occ = calcAO(pos, nor);\n        float amb = 0.3;\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n        float spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 16.0);\n        dif *= softShadow(pos, lig, 0.02, 5.0, 16.0);\n\n        vec3 lin = vec3(0.3);\n        lin += 1.8 * dif * vec3(1.0, 0.8, 0.55);\n        lin += 2.0 * spe * vec3(1.0, 0.9, 0.7) * dif;\n        lin += 0.3 * amb * vec3(0.4, 0.6, 1.0) * occ;\n        lin += 0.25 * fre * vec3(1.0) * occ;\n\n        col *= lin;\n\n        float atten = 1.0 / (1.0 + t * t * 0.1);\n\t    col *= atten * occ;\n\t    col = mix(col, background, smoothstep(0.0, 0.95, t / MAX_TRACE_DIST));\n    }\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 tot = vec3(0.0);\n    for (int ii = 0; ii < AA; ii ++)\n\t{\n\t    for (int jj = 0; jj < AA; jj++)\n\t\t{\n\t\t    // map uv to (-1, 1) and adjust aspect ratio\n\t\t    vec2 offset = vec2(float(ii), float(jj)) / float(AA);\n\t\t    vec2 uv = (fragCoord.xy + offset) / iResolution.xy;\n\t\t    uv = 2.0 * uv - 1.0;\n\t\t    uv.x *= iResolution.x / iResolution.y;\n\t\t    vec3 camera = vec3(4.0) / (min(3.5, 1.0 + pow(2.0, T)));\n\t\t    vec3 lookat = vec3(0.0);\n\t\t    vec3 up = vec3(0.0, 1.0, 0.0);\n\t\t    // set camera\n\t\t    vec3 ro = camera;\n            R(ro.xz, T);\n\t\t    mat3 M = viewMatrix(ro, lookat, up);\n\t\t    // put screen at distance FOV_DISt in front of the camera\n\t\t    vec3 rd = M * normalize(vec3(uv, -FOV_DIST));\n            vec3 lig = normalize(vec3(1.0, 2.0, 1.0));\n\t\t    vec3 col = render(ro, rd, lig);\n\t\t    tot += col;\n\t\t}\n\t}\n    tot /= float(AA * AA);\n    fragColor = vec4(tot, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 442, 494, 494, 639], [641, 658, 689, 689, 738], [740, 740, 766, 766, 1361], [1363, 1363, 1387, 1387, 1827], [1829, 1829, 1847, 1847, 1936], [1938, 1938, 1963, 1963, 2139], [2141, 2141, 2172, 2172, 2412], [2414, 2414, 2483, 2483, 2762], [2764, 2764, 2794, 2794, 3058], [3060, 3060, 3101, 3101, 4089], [4091, 4091, 4148, 4148, 5035]], "test": "untested"}
{"id": "7dXXz4", "name": " - Color of Game of Life", "author": "totetmatt", "description": "RGB Game of life style.", "tags": ["gameoflife"], "likes": 2, "viewed": 247, "published": 3, "date": "1618338705", "time_retrieved": "2024-07-30T19:26:33.242450", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n       vec2 uv = fragCoord/iResolution.xy;   \n    fragColor = pow(texture(iChannel0 ,uv),vec4(.5,.4,.6,1.));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 pal(float t){\n    return .5+.5*cos(2.*3.141592*(1.*t+vec3(.0,.3,.7)));\n}\nmat2 rot(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n       // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 id = (floor(uv*5.))*0.; // biome change, unused if *0.;\n        // Time varying pixel color\n    vec3 col = vec3(0.);\n\n    \n\n    \n    vec2 cpos = uv+vec2(sin(iTime),cos(iTime*.33))*.5;\n    float d = length(cpos)-.10-sin(iTime*.77)*.05+.05;\n    d= smoothstep(.01,.001,abs(d)-.0004);\n    col = vec3(d);\n    \n    \n    vec2 puv = ((uv*iResolution.y)+(.5*iResolution.xy))/iResolution.xy;\n    \n    vec4 acc = vec4(0.);\n    for(float x=-1.;x<=1.;x++){\n        for(float y=-1.;y<=1.;y++){\n               acc += texture(iChannel0,(puv+vec2(x,y)*.001));\n            }\n    }\n    \n    \n    vec4 pcol = vec4(0.,0.,0.,1.);\n    \n    for(int i=0;i<5;i++){\n        if(acc[i] >.3 && acc[i] <1.0 ){\n            if(acc[int(mod(float(i),3.))] >= 2.0*( acc[int(mod(float(i+1),3.))]  + acc[int(mod(float(i+2),3.))]) && \n            acc[i] >= .002*acc[int(mod(float(i+1)+mod(length(id),2.0),3.))]\n            ) {\n                pcol[i] += acc[i]+ acc[int(mod(float(i+1)+mod(length(id),2.0),3.))];\n                pcol[int(mod(float(i+1),3.))]= acc[int(mod(float(i+1)+mod(length(id),2.0),3.))]/2.*9.201;\n            } else {\n             //pcol[i] *= acc[i];\n            }\n        } else if(acc[i] >=1.0){ pcol[i]= acc[i]/9.201;}\n    }\n    pcol = pcol*1.001;\n    \n    \n    fragColor = vec4(col*pal(iTime*1.33+atan(cpos.x,cpos.y)*2.),1.0)+pcol;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXXz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 168]], "test": "untested"}
{"id": "fdlXz4", "name": "goldish truchet 3D", "author": "yasuo", "description": "goldish truchet 3D", "tags": ["truchet"], "likes": 4, "viewed": 271, "published": 3, "date": "1618336766", "time_retrieved": "2024-07-30T19:26:34.064252", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n\nfloat sdPie3d(vec3 p, float rad, float r, float h) {\n    p.xy = abs(p.xy);\n    vec2 c = vec2(sin(rad),cos(rad));\n    float d = max(p.y-h,length(p.xz) - r);\n    float m = length(p.xz-c*clamp(dot(p.xz,c),0.0,r)); \n    return max(d,m*sign(c.y*p.x-c.x*p.z));\n}\n\nfloat pattern(vec3 p) {\n    vec3 prevP = p;\n    float r = 1.135;\n    float h = 0.1;\n    float rad = radians(-45.0);\n    p*=matRotateY(radians(45.0));\n    \n    p.z*=-1.0;\n    p.z=abs(p.z);\n    p.z-=1.415;\n    \n    float d = sdPie3d(p,rad,r,h);\n    float d2 = sdPie3d(p,radians(180.),r*0.75,h+0.02);\n    d = max(-d2+0.01,d);\n\n    return d;\n}\n\nvec4 GetDist(vec3 p) {\n    \n    p.z-=iTime*1.1;\n    vec2 id = floor(p.xz*0.5);\n    p.xz = mod(p.xz,2.0)-1.0;\n\n    vec2 randP = fract(sin(id*123.456)*567.89);\n    randP += dot(randP,randP*34.56);\n    float rand = fract(randP.x*randP.y);\n    \n    float speed = 1.5;\n    if(rand<0.5) {\n        p.z*=-1.0;\n        speed = 1.0;\n    }\n    \n    float d = pattern(p);\n    \n    p.x-=iTime*speed;\n    p.x = mod(p.x,4.0)-2.0;\n    \n    float shine = length(p.xy)-0.05;\n    shine = 1.0-smoothstep(-0.1,0.1,shine);\n    vec4 res = vec4(vec3(1.0)*shine,d);\n\n    vec4 model = res;\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,5,-3);\n    \n    lightPos.yz *= Rot(radians(-30.0));\n    lightPos.xz *= Rot(iTime*1.5+1.0);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.6;\n    \n    return vec2((lambert+dif),max(0.9, 1.0)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*0.5+0.5;\n    vec3 col = mix(vec3(.3,.3,.3),vec3(1.0,.7,.0),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -10);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(30.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,r.y),30.);\n        float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n        col = mix(Bg(r),vec3(dif),0.5)+spec;\n        col += d.rgb;\n    } else {\n        // background\n        col += Bg(rd);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlXz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[515, 515, 567, 567, 771], [773, 773, 796, 796, 1112], [1114, 1114, 1136, 1136, 1697], [1699, 1699, 1732, 1732, 1985], [1987, 1987, 2011, 2011, 2212], [2214, 2214, 2237, 2237, 2627], [2629, 2629, 2671, 2671, 2866], [2868, 2868, 2886, 2886, 2986], [2988, 2988, 3045, 3045, 3822]], "test": "untested"}
{"id": "7sXSz4", "name": "Fork UniverseWi JulianCode 354", "author": "JulianCode1337", "description": "Followed a wonderful *Art of Code* tutorial // aka BigWIngs @shadertoy\nhttps://www.youtube.com/watch?v=3CycKKJiwis\n\nIf there is no sound => reload iChannel0 (Soundcloud)\n\nEnjoy :)", "tags": ["2d", "tutorial", "abstract", "pseudo3d", "artofcode"], "likes": 8, "viewed": 634, "published": 3, "date": "1618320366", "time_retrieved": "2024-07-30T19:26:35.218168", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - ba*t);\n}\n\nfloat N21 (vec2 p) {\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p) {\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\n// Get random position\nvec2 GetPos(vec2 id, vec2 offs) {\n    vec2 n = N22(id+offs)*iTime;\n    //float x = sin(iTime * n.x);\n    //float y = cos(iTime * n.y);    \n    return offs+sin(n)*.4;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b) {\n    float d = DistLine(p, a, b);\n    float m = S(.03, .01, d);\n    float d2 = length(a-b);\n    m *= S(1.2, .8, d2)*.5+S(.05, .03, abs(d2-.75));\n    return m;\n}\n\nfloat Layer(vec2 uv) {\n    float m = 0.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n\n    //m = S(.1, .05, d);\n    \n    vec2 p[9];\n    \n    int i = 0;\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y));\n    }\n    }\n    float t = iTime*10.;\n    \n    for (int i = 0; i < 9; i++) {\n        m += Line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i]-gv)*20.;\n        float sparkle = 1./dot(j,j);\n        \n        m += sparkle*(sin(t+fract(p[i].x)*10.)*.5 +.5);\n    }\n    m += Line(gv, p[1], p[3]);\n    m += Line(gv, p[1], p[5]);\n    m += Line(gv, p[7], p[3]);\n    m += Line(gv, p[7], p[5]);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy/iResolution.xy) -.5;\n    \n    float gradient = uv.y;\n\n    float m = 0.;\n    float t = iTime * .1;\n\n    float s = sin(t);\n    float c = cos(t);\n    \n    mat2 rot = mat2(c, -s, s, c);    \n    uv *= rot;\n    mouse *= rot;\n    \n    // fract snaps Layer back, after he moved away => continuous Layer behind Layer\n    for (float i=0.; i<1.; i+= 1./4.) {\n        float z = fract(i+t);\n        float size = mix(10., .5, z);\n        float fade = S(0., .5, z) * S(1., .8, z);\n        m += Layer(uv * size + i*20. - mouse)*fade;\n    }\n    \n    // different colours, bc of 3 different sin-speeds\n    vec3 base = sin(t*5.*vec3(.345, .456, .657))*.4 + .6;\n    vec3 col = m*base;\n    \n    float fft = texelFetch(iChannel0, ivec2(.7,0), 0).x;\n    gradient *= fft;\n    \n    col -= gradient*base*0.4;\n    \n    \n    // Grid\n    //if (gv.x > .48 || gv.y > .48)col = vec3(1,0,0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXSz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 80, 80, 204], [206, 206, 226, 226, 320], [322, 322, 340, 340, 394], [396, 419, 452, 452, 586], [588, 588, 624, 624, 784], [786, 786, 808, 808, 1478], [1480, 1480, 1537, 1537, 2521]], "test": "untested"}
{"id": "7sfXR4", "name": "Fork Spiral por JulianCode 461", "author": "JulianCode1337", "description": "Spiral portal", "tags": ["spiral", "portal"], "likes": 11, "viewed": 529, "published": 3, "date": "1618319511", "time_retrieved": "2024-07-30T19:26:36.112775", "image_code": "float speed = -10.0;\nfloat frequency = 20.0;\n\nvoid spin(inout vec2 pos){\n    float angle = iTime - atan(length(pos)) * 3.0;\n    pos.xy = vec2( \n        pos.x * cos(angle) - pos.y * sin(angle),\n        pos.y * cos(angle) + pos.x * sin(angle)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float t = iTime * speed;\n    vec2 position = (fragCoord.xy - iResolution.xy * .5) / iResolution.x;\n    \n    spin(position);\n    \n    float angle = atan(position.y, position.x) / (2. * 3.14159265359);\n    angle -= floor(angle);\n    float rad = length(position);\n    float angleFract = fract(angle * 256.);\n    float angleRnd = floor(angle * 256.) + 1.;\n    float angleRnd1 = fract(angleRnd * fract(angleRnd * .7235) * 45.1);\n    float angleRnd2 = fract(angleRnd * fract(angleRnd * .82657) * 13.724);\n    float t2 = t + angleRnd1 * frequency;\n    float radDist = sqrt(angleRnd2);\n    float adist = radDist / rad * .1;\n    float dist = (t2 * .1 + adist);\n    dist = abs(fract(dist) - 0.5);\n    \n    float outputColor = (1.0 / (dist)) * cos(0.7 * sin(t)) * adist / radDist / 30.0;\n    angle = fract(angle + .61);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.8,1.5,3);\n\n    fragColor = vec4(outputColor * col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 72, 72, 253], [255, 255, 312, 312, 1251]], "test": "untested"}
{"id": "7dfXR4", "name": "blue fog", "author": "JulianCode1337", "description": "its private for my client, so a repost", "tags": ["repost", "forapi"], "likes": 2, "viewed": 286, "published": 3, "date": "1618319146", "time_retrieved": "2024-07-30T19:26:36.931586", "image_code": "#define PI 3.141592654\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3D(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n\n#define LOOP 4\nfloat fbm(vec3 p)\n{\n    float res=0.0;\n    float fre=1.0;\n    float ap=0.5+0.5/(1e-5+float(LOOP));\n    for(int i=0;i<LOOP;i++)\n    {\n        res+=ap*(0.5+0.5*simplex3D(p*fre));\n        fre*=3.0;\n        ap*=0.5;\n    }\n    res=pow(res,5.0);\n    return max(res,0.0);\n}\nfloat fbm_mask(vec3 p)\n{\n    float res=1.0;\n    float fre=1.0;\n    float ap=0.5+0.5/(1e-5+float(LOOP));\n    for(int i=0;i<LOOP;i++)\n    {\n\t\tfloat temp=0.5+0.5*simplex3D(p*fre);\n        res*=1.0-0.9*ap+ap*temp;\n        fre*=3.0;\n\t\tap*=0.5;\n    }\n    res=pow(res,5.0);\n    return max(res,0.0);\n}\n\nfloat CloudDensity(vec3 p)\n{\n\treturn fbm_mask(p);\n\t// return fbm(p);\n}\nconst vec3 SkyColor=vec3(0.68,0.63,0.58);\n#define IStepCount 60\n#define SamplerScale 0.01\n\n\nbool TraceClouds(vec3 RayOrigin,vec3 RayDir,float TMin,float TMax,out vec4 Luminance)\n{\n\n    Luminance=vec4(0.0);\n\t\n    // float alpha=0.0;\n    float StepT=(TMax-TMin)/float(IStepCount);\n\tfloat fogT = 0.;\n\tfloat PreStepT=StepT;\n    for(float t=TMin;t<TMax;)\n    {\n        vec3 CurrentPos=RayOrigin+t*RayDir;\n        float density=CloudDensity(SamplerScale*CurrentPos);\n\n\t\tfloat Bottom=RayOrigin.y-400.0;\n\t\tfloat Top=RayOrigin.y+70.0;\n\t\tfloat HeightFactor=clamp((CurrentPos.y-Bottom)/(Top-Bottom),0.0,1.0);\n\t\tfloat k=100.0*pow(1.0-HeightFactor,3.0);\n\n\t\tdensity=clamp(density*k,0.0,1.0);\n        float density2=density*density;\n\t\tfloat density05=sqrt(density);\n\t\tvec3 CloudColor=2.0-vec3(0.85,0.85,0.99);\n        vec3 color=2.2*pow(vec3(density2),CloudColor);\n        Luminance.xyz+=color*(1.0-Luminance.w);\n        Luminance.w+=density*(1.0-Luminance.w);\n\n\t\t\n\t\tif(Luminance.w>0.99)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tPreStepT=1.0*StepT*(1.0-0.99*density05);\n\t\tt+=PreStepT;\n\t\t// t+=1.0*StepT*(1.0-0.9*Luminance.w);\n    }\n    \n\n    return true;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n\n    vec2 coord=uv*2.0-1.0;\n    coord.x*=iResolution.x/iResolution.y;\n    // vec4 res=vec4(fbm(vec3(coord*2.0,iMouse.x+100.0+iTime*0.1)));\n    // vec3 RayOrigin=vec3(0.0,0.0,0.0);\n    vec3 RayOrigin=vec3(0.0,0.0,iTime*0.3/SamplerScale);\n    // vec3 RayOrigin=vec3(0.0,iTime*0.5/SamplerScale,0.0);\n    // vec3 RayOrigin=vec3(iTime*0.5/SamplerScale,0.0,iTime*0.5/SamplerScale);\n    vec3 RayDir=normalize(vec3(coord,1.0));\n\n    float TMin=20.0;\n    float TMax=200.0;\n    vec4 Luminance=vec4(0.0);\n    TraceClouds(RayOrigin,RayDir,TMin,TMax,Luminance);\n    fragColor=vec4(smoothstep(0.0,0.7,sqrt(Luminance.xyz))+SkyColor*(1.0-Luminance.w),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 46, 46, 219], [326, 349, 374, 627, 1544], [1562, 1562, 1581, 1581, 1828], [1829, 1829, 1853, 1853, 2122], [2124, 2124, 2152, 2152, 2194], [2287, 2287, 2374, 2374, 3321], [3324, 3324, 3378, 3378, 4059]], "test": "untested"}
{"id": "fsfSzN", "name": "fluid circuit erosion", "author": "lomateron", "description": "click to add weird fluid\nanother accident\ngetting close to simulating fluids using only kernel convolution\ncode looks ugly but it's just simple kernel convolution\n2D frames are saved and each frame moved into .x -> .y -> .z -> .w\n", "tags": ["convolution"], "likes": 11, "viewed": 476, "published": 3, "date": "1618313317", "time_retrieved": "2024-07-30T19:26:38.026658", "image_code": "//based on https://www.shadertoy.com/view/sslSR8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,u);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = A(u+vec2(0,0));\n    float b = 0.;\n    \n    b = +1.0*A(u+vec2(0,0)).x;\n    //kernel convolution that reads from current 2D frame values\n    {\n        float z = 1.;//kernel convolution size\n        float t = z*2.+1.;\n              t = 1./(t*t-1.);\n        float b0 = abs(a.x);\n        for(float i = -z; i<z+.5;++i){\n        for(float j = -z; j<z+.5;++j){\n          float s = 0.;\n          for(float i2 = -z; i2<z+.5;++i2){\n          for(float j2 = -z; j2<z+.5;++j2){\n          s += abs(A(u+vec2(i,j)+vec2(i2,j2)).x);\n          }}\n          float    d = 1./s;\n          if(s==0.)d = 0.;\n          s = b0*d;\n          float e = A(u+vec2(i,j)).x;\n          s = mix(s,(1.-s)*t,min(abs(e),1.));\n          b += s*e;\n        }}\n    }\n    //kernel convolution that reads from previous 2D frame values\n    {\n        float z = 1.;//kernel convolution size\n        float t = z*2.+1.;\n              t = 1./(t*t-1.);\n        float b0 = abs(A(u+vec2(0,0)).y);\n        for(float i = -z; i<z+.5;++i){\n        for(float j = -z; j<z+.5;++j){\n          float s = 0.;\n          for(float i2 = -z; i2<z+.5;++i2){\n          for(float j2 = -z; j2<z+.5;++j2){\n          s += abs(A(u+vec2(i,j)+vec2(i2,j2)).y);\n          }}\n          float    d = 1./s;\n          if(s==0.)d = 0.;\n          s = b0*d;\n          float e = A(u+vec2(i,j)).y;\n          s = mix(s,(1.-s)*t,.5);\n          b -= s*e;\n        }}\n    }\n    a = vec4(b,a.xyz);\n\n    float keyA  = texture( iChannel1, vec2(65.5/256.,.25) ).x;\n    float keyS  = texture( iChannel1, vec2(83.5/256.,.25) ).x;\n    if(keyA!=0.)a = texture( iChannel2, u/iResolution.xy).xxxx;\n    if(keyS!=0.)a = vec4(0);\n    if(iMouse.z>0.||iFrame==0)\n    {\n                 vec2 m1 = 2.*(u-iMouse.xy)/iResolution.y;\n        if(iFrame==0) m1 = 2.*(u-iResolution.xy*.5)/iResolution.y;\n        a += .4/exp(dot(m1,m1)*111.);\n    }\n    fragColor = a;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfSzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 106, 106, 185]], "test": "untested"}
{"id": "NsXXRN", "name": "Union Jack Flag", "author": "dr2", "description": "Another physical flag (rectangular version, see \"Flagtime\" for details)", "tags": ["flag", "physics", "wind", "cloth", "britannia"], "likes": 20, "viewed": 678, "published": 3, "date": "1618310453", "time_retrieved": "2024-07-30T19:26:39.237421", "image_code": "// \"Union Jack Flag\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\n#define IS_RECT 1  // (= 0/1) common to all shaders\n\n#if IS_RECT\nconst ivec2 nBallE = ivec2 (65, 33);\n#else\n#define LBIG   0\n#if LBIG\nconst ivec2 nBallE = ivec2 (65, 65);\n#else\nconst ivec2 nBallE = ivec2 (33, 33);\n#endif\n#endif\n\nconst int nsMax = 5000;\n\nvec3 sunDir;\nvec2 qgHit;\nfloat dstFar, tCur, todCur, spLen, szFac;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nfloat SheetRay (vec3 ro, vec3 rd)\n{\n  vec3 r, q;\n  vec2 g;\n  float d, dMin, sz, szMax, szMin, grLen;\n  bvec2 ilt;\n  bool bkTrak;\n  grLen = 0.92 * spLen;\n  dMin = dstFar / (grLen * szFac);\n  ro /= szFac;\n  rd /= grLen;\n  szMax = float (nBallE.x - 1);\n  szMin = 1./32.;\n  sz = szMax;\n  g = vec2 (0.);\n  bkTrak = false;\n  for (int ns = VAR_ZERO; ns < nsMax; ns ++) {\n    if (sz == szMin) {\n      r = GetR (g) - ro;\n      q = cross (r, rd);\n      if (dot (q, q) < sz * sz) {\n        d = dot (r, rd);\n        if (d < dMin) {\n          dMin = d;\n          qgHit = g;\n        }\n      }\n      bkTrak = true;\n    }\n    q = cross (GetR (g + 0.5 * sz) - ro, rd);\n    bkTrak = bkTrak || (dot (q, q) > sz * sz);\n    if (bkTrak) {\n      bkTrak = false;\n      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));\n      g.x += ilt.x ? sz : - sz;\n      if (! ilt.x) {\n#if IS_RECT\n        if (sz == 0.5 * szMax) break;\n#endif\n        g.y += ilt.y ? sz : - sz;\n        if (! ilt.y) {\n          sz *= 2.;\n          if (sz == szMax) break;\n          bkTrak = true;\n        }\n      }\n    } else if (sz > szMin) sz *= 0.5;\n  }\n  return dMin * grLen * szFac;\n}\n\nvec3 GetRC (vec2 v)\n{\n  return GetR (clamp (v, vec2 (0.), vec2 (nBallE - 1)));\n}\n\nvec3 SheetNf () \n{\n  vec3 c;\n  vec2 e = vec2 (1., 0.);\n  c = GetRC (qgHit);\n  return normalize (cross (GetRC (qgHit + e.yx) - c, GetRC (qgHit + e) - c));\n}\n\nfloat SheetSilHit (vec3 ro, vec3 rd)\n{\n  vec3 blkSize, pMin, pMax, v, tm, tp;\n  float dn, df;\n  pMin = Loadv4 (vec2 (1, nBallE.y)).xyz;\n  pMax = Loadv4 (vec2 (2, nBallE.y)).xyz;\n  ro /= szFac;\n  ro -= 0.5 * (pMin + pMax);\n  blkSize = 0.5 * (pMax - pMin) + 0.5;\n  v = ro  / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? szFac * dn : dstFar;\n}\n\nvec4 CylHit (vec3 ro, vec3 rd, float cylRad, float cylLen)\n{\n  vec3 s, vn;\n  float dMin, d, a, b, w, srdy;\n  dMin = dstFar;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - cylRad * cylRad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0.) {\n        d /= a;\n        s = ro + d * rd;\n      } else s.y = cylLen;\n    } else s.y = cylLen;\n    if (abs (s.y) < cylLen) {\n      dMin = d;\n      vn = vec3 (s.xz / cylRad, 0.).xzy;\n    } else if (srdy * ro.y < - cylLen) {\n      d = - (srdy * ro.y + cylLen) / abs (rd.y);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.xz) < cylRad) {\n          dMin = d;\n          vn = vec3 (0., 0., - srdy).xzy;\n        }\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  rd.y = abs (rd.y);\n  ro.xz -= vec2 (2., -1.5) * tCur;\n  return mix (vec3 (0.1, 0.2, 0.4), vec3 (0.8), clamp (0.2 + Fbm2 (0.1 *\n     (ro.xz + rd.xz * (100. - ro.y) / max (rd.y, 0.001))) * rd.y, 0., 1.));\n}\n\nvec3 SheetCol (float s)\n{  // specs from Wikipedia\n  vec3 col, colB, colR, colW;\n  vec2 p, q;\n  float w;\n  p = (qgHit / (0.5 * float (nBallE.y - 1)) - 1.);\n  p.x -= 1.;\n  colB = vec3 (1., 33., 105.) / 255.;\n  colR = vec3 (200., 16., 46.) / 255.;\n  colW = vec3 (1.);\n  col = colB;\n  w = 1./15.;\n  q = Rot2D (p, atan (0.5));\n  col = mix (colW, col, smoothstep (0., 0.02, abs (q.y) - 3. * w));\n  col = mix (colR, col, smoothstep (0., 0.02, abs (q.y - sign (p.x) * w) - w));\n  q = Rot2D (p, atan (-0.5));\n  col = mix (colW, col, smoothstep (0., 0.02, abs (q.y) - 3.* w));\n  col = mix (colR, col, smoothstep (0., 0.02, abs (q.y - sign (p.x) * w) - w));\n  q = p;\n  col = mix (colW, col, smoothstep (0., 0.02, min (abs (q.x), abs (q.y)) - 5.* w));\n  col = mix (colR, col, smoothstep (0., 0.02, min (abs (q.x), abs (q.y)) - 3.* w));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, dc4;\n  vec3 col, vn, q;\n  float dstObj, dstSheet, s, flSize;\n  szFac = 4. / float (nBallE.y - 1);\n  flSize = szFac * 0.5 * float (nBallE.y + 1);\n  q = ro;\n  q.y -= - flSize;\n  dc4 = CylHit (q, rd, 0.06, 2. * 2. * flSize + 0.2);\n  dstObj = dc4.x;\n  q = ro;\n#if IS_RECT\n  q.x -= 2. * flSize + 0.06;\n#else\n  q.x -= flSize + ((LBIG == 0) ? 0.06 : 0.12);\n#endif\n  dstSheet = (SheetSilHit (q, rd) < dstFar) ? SheetRay (q, rd) : dstFar;\n  if (min (dstSheet, dstObj) < dstFar) {\n    if (dstSheet < dstObj) {\n      vn = SheetNf ();\n      s = sign (dot (rd, vn));\n      if (s > 0.) vn = - vn;\n      col4 = vec4 (SheetCol (s), 0.);\n    } else {\n      ro += dstObj * rd;\n      vn = dc4.yzw;\n      col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      if (abs (ro.y) < flSize + 0.1) col4 *= (0.5 + 0.5 * smoothstep (0.05, 0.1,\n         abs (mod (4. * (ro.y + 0.02) / flSize + 0.5, 1.) - 0.5)));\n    }\n    col = col4.rgb * (0.2 + 0.1 * max (0., vn.y) + 0.2 * max (- dot (vn, sunDir), 0.) +\n       0.8 * max (dot (vn, sunDir), 0.)) + col4.a * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  }\n  el = clamp (el, 0.05 * pi, 0.2 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 5.5;\n#if IS_RECT\n  ro = vec3 (4., -0.5, -20.);\n#else\n  ro = vec3 (2., -0.5, -20.);\n#endif\n  ro = vuMat * ro;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  stDat = Loadv4 (vec2 (0, nBallE.y));\n  spLen = stDat.x;\n  dstFar = 160.;\n  sunDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Union Jack Flag\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define IS_RECT 1  // (= 0/1) common to all shaders\n\n#if IS_RECT\nconst ivec2 nBallE = ivec2 (65, 33);\n#else\n#define LBIG   0\n#if LBIG\nconst ivec2 nBallE = ivec2 (65, 65);\n#else\nconst ivec2 nBallE = ivec2 (33, 33);\n#endif\n#endif\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n#if IS_RECT\n  fSpring = 400.;\n#else \n  fSpring = 200.;\n#endif\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n#if IS_RECT\n  fGrav = 0.25;\n#else\n  fGrav = 1.;\n#endif\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 10. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Union Jack Flag\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define IS_RECT 1  // (= 0/1) common to all shaders\n\n#if IS_RECT\nconst ivec2 nBallE = ivec2 (65, 33);\n#else\n#define LBIG   0\n#if LBIG\nconst ivec2 nBallE = ivec2 (65, 65);\n#else\nconst ivec2 nBallE = ivec2 (33, 33);\n#endif\n#endif\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n#if IS_RECT\n  fSpring = 400.;\n#else \n  fSpring = 200.;\n#endif\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n#if IS_RECT\n  fGrav = 0.25;\n#else\n  fGrav = 1.;\n#endif\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 10. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Union Jack Flag\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define IS_RECT 1  // (= 0/1) common to all shaders\n\n#if IS_RECT\nconst ivec2 nBallE = ivec2 (65, 33);\n#else\n#define LBIG   0\n#if LBIG\nconst ivec2 nBallE = ivec2 (65, 65);\n#else\nconst ivec2 nBallE = ivec2 (33, 33);\n#endif\n#endif\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n#if IS_RECT\n  fSpring = 400.;\n#else \n  fSpring = 200.;\n#endif\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n#if IS_RECT\n  fGrav = 0.25;\n#else\n  fGrav = 1.;\n#endif\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 10. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Union Jack Flag\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define IS_RECT 1  // (= 0/1) common to all shaders\n\n#if IS_RECT\nconst ivec2 nBallE = ivec2 (65, 33);\n#else\n#define LBIG   0\n#if LBIG\nconst ivec2 nBallE = ivec2 (65, 65);\n#else\nconst ivec2 nBallE = ivec2 (33, 33);\n#endif\n#endif\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n#if IS_RECT\n  fSpring = 400.;\n#else \n  fSpring = 200.;\n#endif\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n#if IS_RECT\n  fGrav = 0.25;\n#else\n  fGrav = 1.;\n#endif\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 10. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXXRN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[743, 743, 763, 763, 790], [792, 792, 827, 827, 1927], [1929, 1929, 1950, 1950, 2009], [2011, 2011, 2029, 2029, 2166], [2168, 2168, 2206, 2206, 2590], [2592, 2592, 2652, 2652, 3400], [3402, 3402, 3433, 3433, 3640], [3642, 3642, 3667, 3692, 4482], [4484, 4484, 4519, 4519, 5663], [5665, 5665, 5721, 5721, 6517], [6519, 6519, 6541, 6541, 6579], [6581, 6581, 6603, 6603, 6641], [6643, 6643, 6700, 6700, 6783], [6785, 6785, 6821, 6821, 7027], [7029, 7029, 7059, 7059, 7172], [7206, 7206, 7230, 7230, 7360], [7362, 7362, 7387, 7387, 7573], [7575, 7575, 7596, 7596, 7751], [7818, 7818, 7842, 7842, 7892]], "test": "untested"}
{"id": "fsXSz4", "name": "test1111111", "author": "wei", "description": "test", "tags": ["test"], "likes": 2, "viewed": 207, "published": 3, "date": "1618303215", "time_retrieved": "2024-07-30T19:26:40.122056", "image_code": "// Author @patriciogv - 2015\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat plot(vec2 uv, float sinOffX, float len) { \n        if(uv.y >0.5) {\n            return 0.0;\n        }\n        \n        if(uv.y <len+abs(sin(iTime))*noise(uv)) {\n            return 0.;\n        }\n    \n    \tif(uv.x >0.1) {\n            return 0.;\n        }\n        if(uv.x <-0.060) {\n            return 0.;\n        }\n        float t = abs(1. / (1000.456* uv.x + sin(uv.y * sinOffX+iTime) * (20.00)));\n    return smoothstep(0., 0.150, t);\n}\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 l = _st-vec2(0.5)+noise(_st+iTime)/20.;\n    if(_st.y<0.5){\n        return 0.;\n    }\n    return 1.-smoothstep(_radius-(_radius*0.050),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0);\n}\n\nfloat circle2(in vec2 _st, in float _radius){\n     _st.y = _st.y*2.;\n    vec2 l = _st-vec2(0.5)+noise(_st+iTime)/20.;\n    return 1.-smoothstep(_radius-(_radius*0.050),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0);\n}\n\nfloat circle3(in vec2 _st, in float _radius){\n    vec2 l = _st-vec2(0.5)+noise(_st+iTime)/20.;\n    return 1.-smoothstep(_radius-(_radius*0.050),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 st = (fragCoord-.025*iResolution.xy)/iResolution.y;\n    vec4 color = vec4(0.0);\n    \n\tfloat moveY = sin(noise(st+iTime))*0.02;\n    vec4 bodyColor = vec4(1.000,0.859,0.965,1.);\n    vec4 eyeColor = vec4(0.257,0.252,0.285,1.000);\n    \n    color = vec4(0.182,0.187,0.860, 1.)*st.y*0.9;\n    \n    float f = 0.;\n\n     for(float i=0.;i<1.;i+=1./10.) {\n        f+=plot(st-vec2(0.432+0.6*i,noise(st)*0.080),noise(st*10.)*12., abs(0.5-i)*0.4);\n    }\n    //+plot(st-vec2(0.430,-0.050),  0.5)+plot(st-vec2(0.620,-0.050), 0.960)+plot(st-vec2(0.780,0.060), 1.);\n    \n    vec4 b1 = bodyColor*f;\n    color = mix(color, b1, b1.a);\n    \n    \n    float color1f = circle2(st-vec2(.20,0.310+moveY),0.492);\n    float color2f = circle(st-vec2(.20,0.070+moveY),0.476);\n    vec4 head = bodyColor*(color1f+color2f-(color1f*color2f));\n    color = mix(color, head, head.a);\n    \n    vec4 eye = eyeColor*circle3(st-vec2(0.032,0.174+moveY),0.004+abs(sin(iTime))*0.001);\n\tcolor =  mix(color, eye, eye.a);\n    \n    eye = eyeColor*circle3(st-vec2(0.368,0.174+moveY),0.004+abs(sin(iTime))*0.001);\n\tcolor =  mix(color, eye, eye.a);\n\n\tfragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXSz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 103, 103, 220], [222, 222, 248, 248, 765], [768, 768, 815, 815, 1208], [1210, 1210, 1254, 1254, 1488], [1490, 1490, 1535, 1535, 1748], [1750, 1750, 1795, 1795, 1985], [1989, 1989, 2046, 2046, 3171]], "test": "untested"}
{"id": "fdXXR4", "name": "Starry background with nebula", "author": "mrange", "description": "License CC0: Starry background with nebula\nCreated for another shader but thought the background could be useful to others so extracted it\n", "tags": ["2d"], "likes": 17, "viewed": 890, "published": 3, "date": "1618301095", "time_retrieved": "2024-07-30T19:26:40.934883", "image_code": "// License CC0: Starry background with nebula\n//  Created for another shader but thought the background could be useful to others so extracted it\n\n// Controls how many layers of stars\n#define LAYERS            5.0\n\n// QUINTIC or HERMITE interpolation?\n#define QUINTIC\n\n// How often to change the nebula\n#define PERIOD            15.0\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)           (0.5 + 0.5*cos(x))\n#define TTIME             (TAU*TIME)\n\nconst mat2 rotSome          = ROT(1.0);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat hash(vec2 co) {\n  co += 123.4;\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2 (dot (p, vec2 (127.1, 311.7)),\n            dot (p, vec2 (269.5, 183.3)));\n\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\n// From one of IQ's value noise shaders\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n\n#ifdef QUINTIC\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n  \n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat globalCloudDensity(vec2 p, float off) {\n  vec2 pp = p;\n\n  p *= 3.33;\n\n  float gcd = vnoise(p+off);\n  gcd *= smoothstep(PI/2.0, PI/4.0, abs(pp.x));\n  gcd *= smoothstep(PI/6.0, PI/18.0, abs(pp.y));\n\n  return gcd;\n}\n\nfloat localCloudDensity(vec2 p, float off) {\n  p *= 10.0;\n  const float aa = -0.45;\n  const mat2 pp = 2.03*rotSome;\n  float a = 0.5;\n  float s = 0.0;\n  p += off;\n\n  s += a*vnoise(p); a *= aa; p *= pp;\n  s += a*vnoise(p); a *= aa; p *= pp;\n  s += a*vnoise(p); a *= aa; p *= pp;\n  s += a*vnoise(p); a *= aa; p *= pp;\n  s += a*vnoise(p); a *= aa; p *= pp;\n    \n  return s*2.75;\n}\n\nvec3 clouds(vec3 ro, vec3 rd, out float cloudDensity) {\n  vec3 srd = toSpherical(rd.zxy);\n  float y = sin(srd.y);\n\n  vec2 pp = srd.zy;\n  pp.x *= y;\n  pp.y -= PI/2.0;\n  pp *= ROT(0.5);\n\n  float h = hash(floor(2.0+TIME/PERIOD));\n  float off = 10.0*fract(123.0*h)+100.0;\n\n  float gcd = globalCloudDensity(pp, off);\n\n  float cd = gcd*localCloudDensity(pp, off);\n  float cdo = gcd*localCloudDensity(pp+00.075*vec2(0.125, -0.25), off);\n  cloudDensity = cd;\n\n  // Basis for some very fake shading\n  float cli = mix(-0.5, 1.0, 0.5 + 0.5*tanh_approx(12.0*(cd-cdo)));\n  \n  float tc = clamp(cd, 0.0, 1.0);\n  float huec = (mix(-0.2, 0.05, tc)+0.05)-0.15*(h-0.5)-0.0;\n  float satc = mix(0.9, 0.5, tc);\n  float bric = 1.0;\n  vec3 colc = hsv2rgb(vec3(huec, satc, bric))+cli*vec3(0.9, 0.7, 0.9);\n  tc *= tc;\n\n  vec4 cc = vec4(colc*0.66, tc);\n  cc = clamp(cc, 0.0, 1.0);\n\n  return cc.xyz*cc.w;\n}\n\nvec3 stars(vec3 ro, vec3 rd, float cloudDensity) {\n  vec3 col = vec3(0.0);\n  vec3 srd = toSpherical(rd.xzy);\n  \n  const float m = LAYERS;\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = srd.yz+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.025, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(srd.y);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*109.0);\n    float h2 = fract(h.x*113.0);\n    float h3 = fract(h.x*127.0);\n\n    vec3 hsv = vec3(fract(0.025-0.4*h1*h1), mix(0.5, 0.125, s), 1.0);\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*hsv2rgb(hsv);\n\n    vec3 ccol = col+ exp(-(2000.0/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    float p = i < 3.0 ? mix(0.125, 2.0, cloudDensity)*y : y;\n    p = clamp(p, 0.0, 1.0);\n    col = h3 < p ? ccol : col;\n  }\n  \n  return col;\n}\n\nvec3 grid(vec3 ro, vec3 rd) {\n  vec3 srd = toSpherical(rd.xzy);\n  \n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/8.0*PI);\n  vec2 pp = srd.yz;\n  vec2 np = mod2(pp, dim);\n\n  vec3 col = vec3(0.0);\n\n  float y = sin(srd.y);\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return 0.25*tanh(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(2.0, 0, 0.);\n  ro.xy *= ROT(-0.33*sin(TTIME/12.0));\n  ro.xz *= ROT(1.5+0.33*sin(TTIME/12.0));\n  vec3 la = vec3(0.0, 0.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n\n  const float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = vec3(0.0);\n\n  float cloudDensity;  \n  col += clouds(ro, rd, cloudDensity);\n  col += stars(ro, rd, cloudDensity);\n  col += grid(ro, rd);\n  \n  col = clamp(col, 0.0, 1.0);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXXR4.jpg", "access": "api", "license": "cc0-1.0", "functions": [[666, 666, 694, 714, 790], [792, 792, 814, 814, 862], [864, 864, 885, 885, 967], [969, 969, 989, 989, 1126], [1128, 1207, 1229, 1229, 1398], [1400, 1431, 1467, 1467, 1561], [1563, 1563, 1589, 1589, 1698], [1700, 1700, 1737, 1737, 1989], [1991, 2031, 2053, 2053, 2625], [2627, 2627, 2672, 2672, 2845], [2847, 2847, 2891, 2891, 3223], [3225, 3225, 3280, 3280, 4103], [4105, 4105, 4155, 4155, 5005], [5007, 5007, 5036, 5036, 5406], [5408, 5408, 5463, 5463, 6138]], "test": "ok"}
{"id": "fsjGDd", "name": "P11 rayMarching&camera", "author": "DEMERCY", "description": "i don know what happend but it is pretty cool", "tags": ["raymarching"], "likes": 0, "viewed": 204, "published": 3, "date": "1618288760", "time_retrieved": "2024-07-30T19:26:41.765661", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\nfloat GetDist(vec3 p);\nfloat sdBox(vec3 p ,vec3 s){\n    \n        return length(max(abs(p) - s,0.));\n}\nfloat sdTorus(vec3 p , vec2 r){   //Torus\n    float x = length(p.xz) - r.x;\n    float d = length(vec2(x,p.y)) - r.y;\n    return d;\n}  \nfloat sdCapsule(vec3 p,vec3 a ,vec3 b, float r){    //capsule\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab,ap)/ dot(ab,ab);\n    t = clamp(t,0.,1.);\n    vec3 c = a + t * ab;\n    float d = length(p - c)-r;\n    return d;\n}\nfloat sdCylinder(vec3 p,vec3 a ,vec3 b, float r){    //capsule\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab,ap)/ dot(ab,ab);\n    vec3 c = a + t * ab;\n    \n    float x = length(p - c)-r;\n    float y = (abs(t-0.5)-0.5)*length(ab);\n    float e = length(max(vec2(x,y),0.));\n    float i = min(max(x,y),0.);\n    return e+i;\n}\n\nmat2 Rot(float a){          //rotation\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 GetNormal(vec3 p ){\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    return normalize(n);  \n}\nfloat RayMarch(vec3 ro,vec3 rd){\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS;i++){\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dS < SURF_DIST || dO > MAX_DIST)break;\n    }\n    return dO;\n}\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(2,4,-1.5);    //light\n     vec3 lightPos2 = vec3(2,4,-1.5);    //light\n    //lightPos.xz += vec2(sin(iTime),cos(iTime))*2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n,l),0.3,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p))dif *= .5;\n    return dif;\n}\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0,3,0,0.45);     //sphere\n    float sphereDist = length(p - s.xyz) - s.w;\n   \n    float planeDist = p.y+.8;     //plane\n    \n    float cd = sdCapsule(p,vec3(-0.64,2.2,0),vec3(-1,1.6,0),.3);   //capsule\n    float cd2 = sdCapsule(p,vec3(0.64,2.2,0),vec3(1,1.6,0),.3);\n    float td = sdTorus(p - vec3(0,3.7,0),vec2(.5,.1));    //torus\n    float bd = sdBox(p-vec3(0,2,0),vec3(.5));            //box\n    float cyld = sdCylinder(p,vec3(-.3,.3,0),vec3(-.3,2,0),.15);    //cylinder\n    float cyld2 = sdCylinder(p,vec3(.3,.3,0),vec3(.3,2,0),.15); \n    float cyld3 = sdCylinder(p,vec3(0,3,0),vec3(0,2.5,0),.24); \n    float d = min(planeDist,cd);\n    d = min(d,cd2);\n    d = min(d,td);\n    d = min(d,sphereDist);\n    d = min(d,bd);\n    d = min(d,cyld);\n     d = min(d,cyld2);\n      d = min(d,cyld3);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec3 lookat = vec3 (0,2,0);\n    float zoom = 1.;\n    vec3 ro =  vec3(sin(iMouse.x/iResolution.x*5.5)*5.,\n                       -iMouse.y/iResolution.y*5.+3.5,\n                    cos(iMouse.x/iResolution.x*5.5)*5.);                  //camera\n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0,1,0),f);\n    vec3 u = cross(f,r);\n\n    vec3 rd = normalize(f*zoom+r*uv.x+u*uv.y);\n   \n \n vec3 col = vec3(0);\n \n float d = RayMarch(ro,rd);\n vec3 p = ro + rd * d;\n float dif = GetLight(p);\n col = vec3(dif);\n fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjGDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 117, 117, 167], [168, 168, 199, 209, 300], [303, 303, 351, 364, 540], [541, 541, 590, 603, 878], [880, 880, 898, 918, 991], [993, 993, 1017, 1017, 1206], [1207, 1207, 1239, 1239, 1450], [1451, 1451, 1474, 1474, 1830], [1832, 1832, 1854, 1854, 2677], [2680, 2680, 2736, 2736, 3341]], "test": "untested"}
{"id": "7ssSz8", "name": "visita Ufo tierra", "author": "jorge2017a1", "description": "visita Ufo tierra", "tags": ["visitaufotierra"], "likes": 4, "viewed": 251, "published": 3, "date": "1618282269", "time_retrieved": "2024-07-30T19:26:42.729086", "image_code": "//por jorge2017a1- 12/abril/2021\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\n\n///referencia  https://www.shadertoy.com/view/tdVfWd   \n///Created by jllusty in 2020-12-18\n\n/// dr2  Cloud =)Nubes\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n    \n    float sc1= sdCylinderXZ( p-vec3(0.0,10.0,0.0), vec2(20.0,0.25) );\n    float se1=sdEllipsoid(  p-vec3(0.0,10.0,0.0), vec3(5.0,6.0,5.0) );\n    float se2=sdEllipsoid(  p-vec3(0.0,15.0,0.0), vec3(3.0,2.0,3.0) );\n    float sb1= sdBox(  p-vec3(0.0,6.0,0.0), vec3(6.0,4.0,6.0) );\n    \n    float dif= differenceSDF( se1, sb1);\n    res =opU3(res, vec3(sc1,-1.0,6.0)); \n    res =opU3(res, vec3(se2,-1.0,6.0)); \n    res =opU3(res, vec3(dif,-1.0,6.0)); \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    float strength = 2.; // lower number makes lighting do deeper into sphere\n    float  fresnel = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), strength);\n    lin+=vec3(1.0)*fresnel;\n     \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n         if ( abs(dS.x)<MIN_DIST)\n        { mObj.hitbln = true; minDist = abs(dO);break; }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; minDist = min(minDist, dO); break; }\n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\nfloat pi = 4.*atan(1.);\n\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvec2 rand(vec2 n) { \n\tfloat a = fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    float b = fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    return vec2(a,b);\n}\n\nvec3 RadialandAngular( vec2 puv )\n{\n    vec2 uv=puv;\n\n    float r = length(uv);\n    \n    if (int(floor(r)) % 2 == 0) {\n        float freq = rand(vec2(floor(r),1)).y;\n        uv *= rotate(freq*iTime);\n    }\n    float theta = atan(uv.y,uv.x)+pi;\n\n    float n = 7.;    \n    float eps = 30./iResolution.y;\n    float dt = abs(mod(theta+pi/n,2.*pi/n)-pi/n);\n    float ct = smoothstep(2.*eps,eps,dt*r);\n    \n    float dr = abs(fract(r+0.5)-0.5);\n    float cr = smoothstep(2.*eps,eps,dr);\n    \n    float cc = max(ct,cr);\n    \n    vec2 dc = rand(vec2(floor(n*theta/(2.0*pi)),floor(r)));\n    vec3 col = mix(vec3(dc.x),vec3(0.),cc);\n\n    // Output to screen\n    return col;\n}\n\n////----------------------------------------------\n\n\n\n//const float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\n\nvec3 sunDir;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float cloudFac, w, f, s;\n    float tCur;\n   //float  a = pi * (0.5 + 0.3 * sin (0.1 * tCur));\n   float  a = pi * (0.5 + 0.3 * sin (0.1 * iTime*5.0));\n    sunDir = normalize (vec3 (cos (a), 0.5, sin (a)));\n    \n    \n     tCur = iTime*10.0;\n    if (rd.y > 0.) {\n  \t  ro.x += 2. * tCur;\n    \tp = 0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz);\n    \tw = 0.8;\n    \tf = 0.;\n    for (int j = 0; j < 4; j ++) \n    {\n    \tf += w * Noisefv2 (p);\n      \tw *= 0.5;\n      \tp *= 2.;\n    }\n        \n    cloudFac = clamp (3. * f * rd.y - 0.1, 0., 1.);\n        \n  }\n    else cloudFac = 0.;\n    \n  s = max (dot (rd, sunDir), 0.);\n    \n  col = vec3 (0.1, 0.2, 0.5) + 0.25 * pow (1. - max (rd.y, 0.), 8.) +\n     (0.35 * pow (s, 6.) + 0.65 * min (pow (s, 256.), 0.3));\n  return mix (col, vec3 (1.), cloudFac);\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    if (id_material==6.0)\n    {\n        float escala=0.25;\n        vec3 col= RadialandAngular( p.xz );\n        return col;\n   }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n   \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n////----------------------------------\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(0.0, 20.0, -10.0 );  light_color1 =1.25*vec3( 1.0);\n \tlight_pos2= vec3( -5.0, -5.0, -5.0 ); light_color2 =1.25* vec3(1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n    \n\n    vec3 ro=vec3(0.0,7.0,-25.0);\n    ro.y+=10.0*sin(iTime);\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    //rd=rotate_x(rd, float phi)\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n      col= SkyCol (ro,  rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "///modificado por jorgefloresP\n//https://www.shadertoy.com/view/ssBGzD\n//Created by nabr in 2021-04-08\n\n#define Fs iSampleRate\n#define _f(x) fract(x)\n\n\nfloat square(float f)\n{\n\treturn sign(fract(f)-0.5);\n}\n\n\n// whoob\nfloat whoob(float t)\n{\n    int it = int(t) & 3;\n    //original\n    float f0 = 47.123*float(int[](44,52,50,42)[it]);\n    float f1 = 47.123*float(int[](74,68,65,48)[it]);\n   \n    \n    float sf0=sin(f0 * t);\n    float sf1=sin(f1 * t);\n\n    float sf3=sin(f1 * t+20.*sin(f1*t));\n    float sc1=square(sf0+sf1);\n    \n    float smul=(sf0+sf1+sf3)*sc1;\n    \n    return.25*clamp(smul,-1.0, 1.0);\n}\n\n\n// drums\nvec2 drums(float t)\n{\n    float bd = 0., sn = 0., hh = 0.;\n    t = mod(t, 8.);\n    \n    float m = float[](.5, 2., 1.,.5, 1., 1., 1., 4.)[int(4.*t)%8];\n    \n    float snf0 = _f(2.*t), snf1 = _f(t),snf2 = _f(3.*t),bdf0 = _f(m *t) ,bdf1 =_f(8.*t)\n    ,pf= pow(bdf1, 3.);\n    // snare\n    sn = sin(1508. * t) * cos(1508. * exp(-.06 * snf2 ) + cos(snf1 * 1500.));\n    sn *= min(1.,floor(.5+snf1)) * exp(-14. * snf0);\n    sn += .2*clamp(sn*abs(1.-cos(sn/4./snf0)),-0.1, 0.2);\n    // base drums\n    bd = sin(628.31 *  t) * cos(376.98 * exp(-0.0432 * pow(1.-bdf1, 10. )) );\n    bd *= min(1., 20. * bdf1) * max(0.,1.-bdf1) * exp(-12. * bdf0);\n    // shakers, autopan\n    hh = cos( exp(-10. * (pf-2.*floor(pf)-1.) )  * 6.2831 * 260.) \n          * exp(-45. * bdf1) * min(1., .002 + bdf1);\n    return vec2(.8 * sn, sn)  + 1. * bd + \n           vec2(hh*(cos(t)+sin(t)),hh*(-sin(t)+cos(t)));\n}\n\n//Fsynth\nvec2 Fsynth(int s)\n{\n    vec2 y = vec2(1e-6);\n    const float w[19]=float[19](210.,411.,178.,258.,610.,0.,340.,120.,0.,510.,344.,388.,0.,606.,605.,405.,0.,10.,610.);\n    \n    float rt = float(s) / Fs * .5;\n    float frt = _f(rt);\n    float pfrt = pow(min(sqrt(sqrt(1.-frt)), 100. * frt), 4.);\n    float sf = 6.283185 * float(s)/Fs;\n    \n    y.y =  sin(sf * w[int(rt) % 10]);\n    y.y += clamp(y.y+(1.-cos(9.*y.y)),-3.,.3) * pfrt;\n    y.x =  sin(sf * w[int(rt) % 9 + 10]);\n    y.x += clamp(y.x+(1.+sin(6.*y.x)),-.2,.9) * pfrt;\n    y.x += ((y.x-floor(.5*y.x)) * atan(1.-frt,25.*frt));\n    return vec2(y.x,y.y);\n}\n\n\nvec2 mainSound(int s, float t)\n{\n    // observation: \n    // the echoes, the synth itself, also introduce phase rotation \n    // with bitreduction -noise, copying, inverse multiplying, finaly adding the original sound\n    // i can control the stereowidth of the output \n    \n    vec4 y = vec4(1e-6);\n    vec4 b =y;\n    vec2 d=(s>44100*4)?drums(t):vec2(1e-6);\n    \n    const int k[8] = int[8](83341,68581,78517,102859,87421,95279,86813,73907);\n   \n    int nt0 = 953, nt1 = 1571, nt11 = 1031;\n    \n    float v1, v2;\n    \n    for(int ii=0;ii<8;++ii)\n    {\n        if(ii<5)\n        {\n         v1=Fsynth((s-(nt0+=k[ii]))).x;   \n         v2=Fsynth((s-(nt1+=k[ii]))).x;\n         y.xw+=vec2(v1, v2);\n        } \n         \n        if(ii>1) \n        {\n            v1=Fsynth((-s+(nt1+=k[ii]))).y;\n            v2=Fsynth((-s+(nt11+=k[ii]))).y;\n            y.yz+=vec2(v1,v2);\n        }\n    }\n    b = y;\n    float bt = pow(.8, 8.);\n    b.x = (bt * floor(y.y/ bt + .5));\n    b.y = (bt * floor(y.x/ bt + .5));\n    \n    \n    vec2 s1=((.03*((b.xy*1.-b.wz) + y.xy) )+d);\n    vec2 s2=d+whoob(t);\n   \n    return mod(t,10.)<5.?s1:s2;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 584, 584, 605], [606, 606, 638, 638, 722], [723, 723, 762, 762, 857], [858, 858, 897, 897, 992], [993, 993, 1032, 1032, 1127], [1129, 1173, 1220, 1220, 1247], [1249, 1249, 1292, 1292, 1319], [1321, 1321, 1369, 1369, 1397], [1398, 1469, 1503, 1503, 1601], [1602, 1602, 1636, 1636, 1728], [1729, 1729, 1763, 1763, 1855], [1856, 1896, 1930, 1930, 2027], [2029, 2029, 2066, 2066, 2149], [2152, 2192, 2217, 2217, 2831], [2833, 2833, 2898, 2898, 3665], [3667, 3718, 3742, 3742, 3930], [3933, 3933, 3966, 3966, 4649], [4650, 4704, 4740, 4740, 4974], [4975, 5030, 5110, 5110, 5387], [5454, 5454, 5476, 5476, 5543], [5545, 5545, 5564, 5564, 5726], [5728, 5728, 5763, 5763, 6392], [6597, 6597, 6621, 6621, 6668], [6670, 6670, 6695, 6695, 6874], [6876, 6876, 6901, 6901, 7260], [7277, 7277, 7309, 7309, 8123], [8125, 8176, 8223, 8223, 8398], [8452, 8452, 8545, 8545, 8819], [8820, 8859, 8886, 8886, 8996], [8998, 9047, 9104, 9104, 10425]], "test": "untested"}
{"id": "fdlSRn", "name": "Parabola - Three-Point Control", "author": "oneshade", "description": "Parabola parametrized by three control points.", "tags": ["control", "three", "point", "parabola", "systemofequations"], "likes": 7, "viewed": 156, "published": 3, "date": "1618281809", "time_retrieved": "2024-07-30T19:26:43.578813", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\n// Solved by hand\n//vec3 getQuadraticCoeffs(in vec2 a, in vec2 b, in vec2 c) {\n//    float ax2 = a.x * a.x, bx2 = b.x * b.x, cx2 = c.x * c.x;\n//\n//    float p1 = ax2 * b.x - a.x * bx2, p2 = ax2 * c.x - a.x * cx2;\n//    float q1 = ax2 - bx2, q2 = ax2 - cx2;\n//    float r1 = a.y * bx2 - ax2 * b.y, r2 = a.y * cx2 - ax2 * c.y;\n//\n//    float qc = (p2 * r1 - p1 * r2) / (p1 * q2 - p2 * q1);\n//    float qb = (-q1 * qc - r1) / p1;\n//    float qa = (a.y - qc - qb * a.x) / (a.x * a.x);\n//\n//    return vec3(qa, qb, qc);\n//}\n\n// Matrix solving\nvec3 getQuadraticCoeffs(in vec2 a, in vec2 b, in vec2 c) {\n    return vec3(a.y, b.y, c.y) * inverse(mat3(a.x * a.x, a.x, 1.0, b.x * b.x, b.x, 1.0, c.x * c.x, c.x, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float t = 0.25 * unit;\n    vec3 color = vec3(1.0);\n\n    // Load control points\n    vec2 p1 = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 p2 = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec2 p3 = texelFetch(iChannel0, ivec2(2, 0), 0).xy;\n\n    // Grid\n    draw(abs(mod(uv.x + 0.125, 0.25) - 0.125) + t, vec3(0.0, 0.0, 1.0));\n    draw(abs(mod(uv.y + 0.125, 0.25) - 0.125) + t, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Parabola\n    vec3 coeffs = getQuadraticCoeffs(p1, p2, p3);\n    float f = coeffs[0] * uv.x * uv.x + coeffs[1] * uv.x + coeffs[2];\n    float d = 2.0 * coeffs[0] * uv.x + coeffs[1];\n    draw(abs(uv.y - f) / sqrt(1.0 + d * d) - t, vec3(0.6, 0.0, 0.6));\n\n    // Draw control points\n    draw(length(uv - p1) - 0.075, vec3(0.0));\n    draw(length(uv - p2) - 0.075, vec3(0.0));\n    draw(length(uv - p3) - 0.075, vec3(0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SELECTION_RADIUS 0.2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (iFrame == 0) {\n        if (iFragCoord == ivec2(0, 0)) fragColor.xy = vec2(-2.0,  1.0);\n        if (iFragCoord == ivec2(1, 0)) fragColor.xy = vec2( 0.0, -1.0);\n        if (iFragCoord == ivec2(2, 0)) fragColor.xy = vec2( 2.0,  1.0);\n    }\n\n    if (iFrame > 0) {\n        if (iFragCoord.x < 3 && iFragCoord.y == 0) {\n            vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n            fragColor = texelFetch(iChannel0, iFragCoord, 0);\n            if (length(mouse - fragColor.xy) < SELECTION_RADIUS) {\n                fragColor.xy = mouse;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[588, 606, 664, 664, 777], [779, 779, 834, 834, 1898]], "test": "untested"}
{"id": "sdfSzr", "name": "Voronoi funs", "author": "account", "description": "Voronoi", "tags": ["voronoi", "noise"], "likes": 1, "viewed": 332, "published": 3, "date": "1618280453", "time_retrieved": "2024-07-30T19:26:44.346760", "image_code": "float ring(vec2 p, vec2 pos, float r1, float r2){\nvec2 a = normalize(p-pos);\nreturn length((pos+a*r1)-p)-r2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    q = q * 2.0 - 1.0;\n    q.x *= 1.3;\n    q.y /= 1.3;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 c = texture(iChannel0, uv).xyz;\n    float dist = ring(q, vec2(0.), 0.5,0.002);\n    c += clamp(vec3(exp(-42.0*dist)),0.,1.)*1.6;\n    if(length(q)>0.75)c=vec3(exp(-12.0*dist));\n        c = mix(c*1.4, c*0.5, vec3(length(q)+0.1));\n    \n    if(length(q)>0.5)c=texture(iChannel1, uv).xyz;\n    \n\n    //fragColor = vec4(c,1.);\n    //c+=col*(length(coord));\n    \n   // c = pow(c, vec3(1./2.2));\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 hash2( vec2 p )\n{\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\nvec3 voronoi(vec2 p){\nvec2 f = floor(p);\nvec2 res = vec2(8.);\nfor(int i = 0; i < 9; i++){\nvec2 coords = f + vec2(mod(float(i),3.)-1., float(i/3)-1.);\nvec2 o = hash2( coords );\no = 0.5 + 0.4*sin( iTime + 6.2831*o );\nvec2 pos = (coords+o);\nfloat d = dot(pos-p,pos-p);\nif( d < res.x )\n{\n    res.y = res.x;\n    res.x = d;\n}\nelse if( d < res.y )\n{\n    res.y = d;\n}\n}\nreturn palette(res.x+res.y+iTime, vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.2,0.2));\n}\n\nfloat voronoif(vec2 p){\nvec2 f = floor(p);\nvec2 res = vec2(8.);\nfor(int i = 0; i < 9; i++){\nvec2 coords = f + vec2(mod(float(i),3.)-1., float(i/3)-1.);\nvec2 o = hash2( coords );\no = 0.5 + 0.4*sin( iTime + 6.2831*o );\nvec2 pos = (coords+o);\nfloat d = dot(pos-p,pos-p);\nif( d < res.x )\n{\n    res.y = res.x;\n    res.x = d;\n}\nelse if( d < res.y )\n{\n    res.y = d;\n}\n}\nreturn res.x+(1.0-res.y);\n}\n\nvec3 fbm(vec2 p){\nvec3 n = voronoi(p)*0.5;\nn += voronoi(p*2.)*0.25;\nn += voronoi(p*4.)*0.125;\nn += voronoi(p*8.)*0.0625;\nreturn n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    vec3 col = fbm((uv)*2.0+voronoif(uv*2. + length(fbm(uv*2.)))*0.2)*1.1;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 hash2( vec2 p )\n{\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\nvec2 voronoi(vec2 p){\nvec2 f = floor(p);\nvec2 res = vec2(8.);\nfor(int i = 0; i < 9; i++){\nvec2 coords = f + vec2(mod(float(i),3.)-1., float(i/3)-1.);\nvec2 o = hash2( coords );\no = 0.5 + 0.4*sin( iTime + 6.2831*o );\nvec2 pos = (coords+o);\nfloat d = dot(pos-p,pos-p);\nif( d < res.x )\n{\n    res.y = res.x;\n    res.x = d;\n}\nelse if( d < res.y )\n{\n    res.y = d;\n}\n}\nreturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    vec2 res = voronoi(uv*3.);\n    vec3 col = palette(res.x+res.y+iTime, vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2))*1.1;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfSzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 110], [112, 112, 169, 169, 732]], "test": "untested"}
{"id": "sslSR8", "name": "inverse pointify image", "author": "lomateron", "description": "mouse click to paint\nkey A to reset image\nkey S to clean image\nthe effects of pontifying can be inverted, this creates bluring\nthen a transition between pontifying-bluring can be made\nthis transition variable is taken from the same image its convoluting", "tags": ["convolution", "paint"], "likes": 2, "viewed": 342, "published": 3, "date": "1618273507", "time_retrieved": "2024-07-30T19:26:45.111715", "image_code": "//based on https://www.shadertoy.com/view/fdsSRr\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,u);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float keyA  = texture( iChannel1, vec2(65.5/256.,.25) ).x;\n    float keyS  = texture( iChannel1, vec2(83.5/256.,.25) ).x;\n\n    float z = 1.;//kernel convolution size\n    float t = z*2.+1.;\n          t = 1./(t*t-1.);\n    vec4 b0 = abs(A(u+vec2(0,0)));\n    vec4 b = vec4(0);\n    for(float i = -z; i<z+.5;++i){\n    for(float j = -z; j<z+.5;++j){\n      vec4 s = vec4(0);\n      for(float i2 = -z; i2<z+.5;++i2){\n      for(float j2 = -z; j2<z+.5;++j2){\n      s += abs(A(u+vec2(i,j)+vec2(i2,j2)));\n      }}\n      if(s.x==0.)s.x = 1.;\n      if(s.y==0.)s.y = 1.;\n      if(s.z==0.)s.z = 1.;\n      if(s.w==0.)s.w = 1.;\n      s = b0/s;\n      s = mix(s,(1.-s)*t,min(abs(A(u+vec2(i,j))),1.));\n      b += s*A(u+vec2(i,j));\n    }}\n    vec4 a = b;\n    if(keyA!=0.)a = texture( iChannel2, u/iResolution.xy);\n    if(keyS!=0.)a = vec4(0);\n    if(iFrame==0)a = sin(u.xy*.03+sin(u.yx*.03)).xyyy*.3+.3;\n    if(iMouse.z>0.||iFrame==0)\n    {\n        vec2 m1 = 2.*(u-iMouse.xy)/iResolution.y;\n        a += .1/exp(dot(m1,m1)*111.);\n    }\n    fragColor = a;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 106, 106, 185]], "test": "untested"}
{"id": "NdXSz8", "name": "approx. NACAxxxx - 2d distance", "author": "jmpep", "description": "Signed distance field for the polygonal approximation of the NACA 4-digits series. \n\nDrag vertically to change the maximum camber (first digit) and vertically to change its location along the chord (second digit).\n\n", "tags": ["2d", "sdf", "cfd", "naca"], "likes": 6, "viewed": 416, "published": 3, "date": "1618271997", "time_retrieved": "2024-07-30T19:26:45.936509", "image_code": "// The MIT License\n// Copyright  2021 Javier Meseguer de Paz\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// Signed distance field of a NACAxxxx (4-digit series)\n// https://en.wikipedia.org/wiki/NACA_airfoil#Four-digit_series\n//\n// I couldn't find an analytical SDF, and computing the derivatives to use Newton-Rhapson to approximate the\n// SDF numerically yielded monstruous derivatives:\n// http://javiermeseguer.com/wp-content/uploads/2021/04/naca-symbolic.html\n//\n// So I decided to just convert the NACA to a simple polygon and just SDF it instead.\n// \n// I don't think this is terribly useful, but who knows.\n//\n// Credits:\n// - The implementation for the polygon SDF comes from: https://www.shadertoy.com/view/WdSGRd\n//\n// Related:\n// - NACA00xx: https://www.shadertoy.com/view/ssBGWd\n\n\n// Use this macros to define what NACAxxxx profile to use. Use mouse_x or mouse_y to\n// determine the digit by dragging the mouse in the x or y directions respectively.\n// Usually these digits are integers (they are digits, after all) but in this shader\n// using real values is allowed for greater interactivity.\n#define DIGIT0 mouse_y // DIGIT0 is the maximum camber as a percentage of the chord.\n#define DIGIT1 mouse_x // DIGIT1 * 10 is the location of the maximum camber (also % chord)\n#define DIGIT2 2       // DIGIT2 x 10 + DIGIT3 gives the maximum thickness (% chord)\n#define DIGIT3 2\n\n#define IS_DEMO 1\n\n// Define how many segments to use to approximate the NACA\n#define N 40\n\nvec2 naca(float d1, float d2, float d3, float d4, float mx) {\n    float m = d1 / 100.0;\n    float p = d2 / 10.0;\n    float t = (d3 * 10.0 + d4) / 100.0;\n    \n    if (d2 < 1.0) {\n        m = 0.0;\n        p = 0.5;\n    }\n    \n    float x = mx;\n    if (x > 1.0) x = x - 2.0;\n    if (x < 0.0) x = - x;\n        \n    float sx = sqrt(x);\n    float yt = 5.0 * t * (0.2969*sx + x*(-0.126 + x * (-0.3516 + x * (0.2843 + x * (-0.1037)))));\n\n    float yc = 0.0;\n    float dycdx = 0.0;\n\n    if (x <= p) {\n        yc = m/(p*p) * (2.0*p*x-x*x);\n        dycdx = (2.0*m/(p*p))*(p-x);\n    } else {\n        float temp = (1.0 - p);\n        yc = (m/(temp*temp))*((1.0-2.0*p)+2.0*p*x-x*x);\n        dycdx = (2.0*m/(1.0-p*p))*(p-x);\n    }\n\n    float omega = atan(dycdx);\n    \n    vec2 res;\n    if (mx < 0.0) {\n        res.x = x + yt * sin(omega);\n        res.y = yc - yt * cos(omega);\n    } else {\n        res.x = x - yt * sin(omega);\n        res.y = yc + yt * cos(omega);\n    }\n\n    return res;\n}\n\nfloat cross2d(vec2 v0, vec2 v1) {\n    return v0.x*v1.y - v0.y*v1.x;\n}\n\n// polygon's sdf from https://www.shadertoy.com/view/wdBXRW\nfloat sdPolygonalNACA( vec2 p, float d1, float d2, float d3, float d4 ) {\n   \n    // compute first vertex\n    float ttA = -1.001;\n    vec2 cA = naca(d1, d2, d3, d4, ttA);        \n\n    // initialize distance and sign\n    float d = dot(p-cA,p-cA);\n    float s = 1.0;\n    \n    for (int i = 1; i <= N; ++i) {\n        // compute next vertex\n        float tB = 2.0 * float(i)/float(N) - 1.001;\n        \n        // .. we don't sample uniformly. Instead, we use the next formula to \n        // .. achieve a higher sampling rate closer to the leading edge, where\n        // .. the curvature is higher.\n        float ttB = tB * tB * sign(tB);\n        vec2 cB = naca(d1, d2, d3, d4, ttB);\n        \n        // distance squared\n        vec2 e = cA - cB;\n        vec2 w =  p - cB;\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        \n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y >= cB.y, \n                            p.y < cA.y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;\n        \n        // current vertex becomes the previous vertex\n        ttA = ttB;\n        cA = cB;\n    }\n      \n    return sqrt(d) * s;\n}\n\n// from iq's signed distance field gallery\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    float mouse_x = m.x * 9.0;\n    float mouse_y = m.y * 9.0;\n    \n    float d1 = 8.0;\n    float d2 = 4.0;\n    float d3 = float(DIGIT2);\n    float d4 = float(DIGIT3);\n    \n    if (m.x != 0.0 || m.y != 0.0) \n    {\n        d1 = float(DIGIT0);\n        d2 = float(DIGIT1);\n    }\n    \n    #if IS_DEMO // override with demo purposes\n        d1 = mix(0.0, 8.0, 0.5 + 0.5 * sin(iTime));\n        d2 = mix(3.0, 7.0, 0.5 + 0.5 * sin(iTime / 2.0));\n        d3 = mix(1.0, 3.0, 0.5 + 0.5 * sin(iTime / 4.0));\n        d4 = mix(0.0, 9.0, 0.5 + 0.5 * sin(iTime / 8.0));        \n    #endif\n    \n    float d = sdPolygonalNACA(0.65 * (uv + vec2(0.5, 0.0)), d1, d2, d3, d4); \n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-5.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*d/(0.65));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n    fragColor = vec4( col, 1.0 );    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdXSz8.jpg", "access": "api", "license": "mit", "functions": [[2461, 2461, 2522, 2522, 3433], [3435, 3435, 3468, 3468, 3504], [3506, 3566, 3639, 3671, 4827], [4829, 4872, 4929, 4929, 5928]], "test": "ok"}
{"id": "NsB3Dd", "name": "SphereMarcher", "author": "nialred", "description": "Ray marched sphere with distortion. Still think I messed something up, but I am moving on. Hopefully the next thing I write will be a little cleaner/better documented.", "tags": ["sdf", "sphere"], "likes": 1, "viewed": 238, "published": 3, "date": "1618264018", "time_retrieved": "2024-07-30T19:26:46.710440", "image_code": "/*\nReferences:\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttps://michaelwalczyk.com/blog-ray-marching.html\nhttps://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays\n*/\n\nconst int MAX_MARCHING_STEPS = 32;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nSphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 2.5);\n\n/*\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n*/\n\nfloat sphere_sdf(vec3 point)\n{\n    return length(point - sphere.center) - sphere.radius;\n}\n\nfloat map_world(vec3 point)\n{\n    float d = 10.0;\n    float displacement = sin(d * point.x) * sin(d * point.y) * sin(d * point.z);\n    float dist = sphere_sdf(point);\n    \n    return dist + displacement;\n}\n\nfloat shortest_distance_to_surface(vec3 eye_pos, vec3 march_dir, float start, float end)\n{\n    float depth = start;\n    int i = 0;\n    float dist = 0.0;\n    \n    while (i < MAX_MARCHING_STEPS)\n    {\n        dist = map_world(eye_pos + (depth * march_dir));\n        \n        if (dist < EPSILON)\n        {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= end)\n        {\n            return end;\n        }\n        \n        i += 1;\n     }\n     \n     return end;\n}\n\nvec3 estimate_normal(vec3 point)\n{\n    vec3 step = vec3(EPSILON, 0.0, 0.0);\n    \n    float gradient_x = map_world(point + step) - map_world(point - step);\n    float gradient_y = map_world(point + step.yxz) - map_world(point - step.yxz);\n    float gradient_z = map_world(point + step.yzx) - map_world(point - step.yzx);\n    \n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    \n    return normalize(normal);\n}\n\nfloat diffuse(vec3 current_pos, vec3 light_pos, vec3 normal)\n{\n    vec3 light_dir = normalize(current_pos - light_pos);\n    \n    float intensity = max(0.0, dot(normal, light_dir));\n    \n    return intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    \n    // Define ray as vector from camera position to pixel position\n    Ray ray = Ray(vec3(0.0, 0.0, -5.0), vec3(uv, 1.0));\n    \n    vec3 light_pos = vec3(2.0, -5.0, 3.0);\n    \n    float dist;\n    dist = shortest_distance_to_surface(ray.origin, ray.direction, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    \n    else \n    {\n        vec3 normal = estimate_normal(ray.origin + dist*ray.direction);\n        //normal = normal * 0.5 + 0.5; // convert back to RGB\n        float intensity = diffuse(ray.origin + dist*ray.direction, light_pos, normal);\n        normal = vec3(1.0, 0.0, 0.0) * intensity;\n        fragColor = vec4(normal, 1.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsB3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[747, 747, 777, 777, 837], [839, 839, 868, 868, 1044], [1046, 1046, 1136, 1136, 1552], [1554, 1554, 1588, 1588, 1974], [1976, 1976, 2038, 2038, 2185], [2187, 2187, 2244, 2295, 3123]], "test": "untested"}
{"id": "7dfXzH", "name": "pentagram p", "author": "pikmin2010", "description": "p", "tags": ["p"], "likes": 1, "viewed": 274, "published": 3, "date": "1618259626", "time_retrieved": "2024-07-30T19:26:47.489358", "image_code": "float sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n\tvec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\nvec2 rotate(vec2 uv, float rotation, vec2 mid)\n{\nuv = (uv - mid )  * mat2( cos(rotation), -sin(rotation),sin(rotation), cos(rotation)) + mid;\nreturn uv;   \n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat sdf(vec2 uv){\nfloat pent = sdPentagon(rotate(uv,iTime,vec2(0.))*-1.,0.09);\nvec2 trioff =uv + vec2(0.,0.26);\nfloat tri = 5.0;\nfor(float x= 0.0;x<5.;x++){\n\nvec2 t = rotate(trioff,5.*x,vec2(0.0,0.26));\ntri = min(sdTriangleIsosceles(t,vec2(0.0735,0.172)),tri);\n\n}\n\n\nfloat d =min(tri,pent);\n\nreturn d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n \n \n    uv = rotate(uv,iTime*-0.75,vec2(0.));\n     vec3 col = vec3(0.0);\n      float d = sdf(uv);\n      //from FabriceNeyret2's comment\n      fragColor = vec4( smoothstep( 1.5/iResolution.y, 0.,abs(d)) , 0,0,1); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfXzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 336], [337, 337, 385, 385, 494], [496, 496, 539, 539, 821], [823, 823, 842, 842, 1127], [1130, 1130, 1187, 1237, 1514]], "test": "untested"}
{"id": "NdsSzn", "name": "Donut Holes", "author": "Tater", "description": "The first real thing I've made with ray marching. I've mostly using bits from Bigwings, and evvvil's tutoirals. I'm sure I'm doing a lot of things wrong. ", "tags": ["raymarch"], "likes": 11, "viewed": 489, "published": 3, "date": "1618256863", "time_retrieved": "2024-07-30T19:26:48.361027", "image_code": "#define MAX_STEP 128\n#define MAX_DIST 300.0\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec2 Dist(vec3 p){\n    float tt= iTime;\n    vec3 po = p;\n    vec3 p2 = p;\n    \n    p.xz = mod(p.xz,3.0)-1.5;\n    \n    vec2 h; vec2 t;\n    \n    float y = 1.5*sin((floor(p2.x/3.0)+0.5)*sin(tt)*0.6)*cos((floor(p2.z/3.0)+0.5)*sin(tt)*0.6);\n    \n    t = vec2(sdTorus(p+vec3(0,y,0),vec2(1.0,0.4)*0.8),1.0);\n    h = vec2(sdSphere(p+vec3(0,y*3.0,0),0.4),3.0);\n    \n    t=(t.x<h.x)?t:h;\n    p2.xz = mod(p.xz-1.5,3.0)-1.5;\n    vec2 d = abs(p2.xz)-1.9 ;\n    vec2 b = vec2(max(d.x,d.y),0);\n   // b.x = min(-(abs(p.y)-2.1),b.x);\n    b.x = -b.x;\n    if(length(po)<50.0)t=(t.x<b.x)?t:b;\n    \n    return vec2(t.x,t.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime*0.25;\n   \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(7.0*sin(t),5.5,7.0*cos(t));\n    \n    vec3 lookat = vec3(0,3.1,0); \n    float zoom = 1.1;\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), f));\n    vec3 u = cross(f,r);\n    \n    vec3 c = ro + f*zoom; \n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    vec3 rd = i-ro; \n    float dO = 0.0;\n    float shad = 1.0;\n    vec2 d;\n    for(int i = 0; i<MAX_STEP; i++){\n        vec3 p = ro + rd * dO;    \n        d = Dist(p);       \n        dO += d.x;\n        if(dO>MAX_DIST || d.x < 0.0001) {\n            shad = float(i)/float(MAX_STEP); //found this in one of flopine's shader\n            break;\n        }\n    }\n    col = vec3(shad)*(1.0-dO/MAX_DIST);\n    //col *= 1.0-(dO/MAX_DIST)*1.0;\n    col = 1.2-col;\n    if(d.y > 0.5)col*=mix(vec3(0.710,0.549,1.000),vec3(0.000,0.000,0.000),(dO/MAX_DIST));\n    if(d.y > 1.5)col*=vec3(1.000,0.035,0.059)+0.2;\n    \n    col = mix(col, vec3(0.369,0.000,0.357), clamp(dO/MAX_DIST,0.0,1.0));\n     \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 80, 80, 104], [105, 105, 138, 138, 203], [204, 204, 222, 222, 808], [810, 810, 867, 867, 1994]], "test": "untested"}
{"id": "wttfDj", "name": "Gopher Golang", "author": "cepalle", "description": "Mascot of Golang", "tags": ["modeling", "golang"], "likes": 7, "viewed": 284, "published": 3, "date": "1618255205", "time_retrieved": "2024-07-30T19:26:49.238681", "image_code": "// Fork of \"CyrillRayMarching starting poin3\" by sylvain69780. https://shadertoy.com/view/ttVcRG\n// 2021-01-21 21:18:38\n\n// Fork of \"RayMarching starting point\" by BigWIngs. https://shadertoy.com/view/WtGXDD\n// 2020-11-29 14:59:32\n\n// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 256\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdHear(vec3 p) {\n    p.xz *= Rot(1.6);\n    \n    vec3 q = p.yxz;\n    float dTorus = sdTorus(q, vec2(0.15, 0.05));\n    float dCylinder = sdCappedCylinder(q - vec3(0.0, -0.025, 0.0), 0.15, 0.025);\n    float d = min(dTorus, dCylinder);\n    return d;\n}\n\nfloat sdFoot(vec3 p) {\n    vec3 aFoot = vec3(0.6, -0.5, -0.1);\n    p.xz *= Rot(0.0);\n    float dFoot1 = sdStick(p, aFoot, aFoot - vec3(0.1, 0.07, 0.4), 0.15, 0.1).x;\n    float dFoot2 = sdStick(p, aFoot, aFoot - vec3(0.0, 0.07, 0.4), 0.15, 0.1).x;\n    return min(dFoot1, dFoot2);\n}\n\nvec2 GetDistMat(vec3 p) {\n    float m=0.0;\n    float alpha = sin(iTime) / 10.0;\n    float alphab = sin(iTime - 1.0) / 10.0;\n\n    vec3 pBody = p;\n    pBody.zy *= Rot(alphab);\n    float dbody = sdEllipsoid(pBody-vec3(0.0,-1.0,0.0),vec3(0.65,0.5,0.5));  // body\n\n    float dgrnd = p.y + 2.0;\n    \n    p = p - vec3(0.0, -0.5, 0.0);\n    p.zy *= Rot(alpha);\n    p = p + vec3(0.0, -0.5, 0.0);\n\n    float dhead = sdEllipsoid(p,vec3(0.65,0.5,0.5)); // head\n\n    float dbodyhead = smin( dhead, dbody,1.5);  // body + head\n\n    vec3 pNose = p-vec3(0.0,-0.20,-0.56);\n    // pNose.y += pNose.x * p.x;\n    pNose = opCheapBend( pNose, -2.0 );\n    float dNose = sdVerticalCapsule(pNose, 0.2, 0.08); // Nose\n\n    float dTruffle = sdEllipsoid(p-vec3(0.0,-0.15,-0.61),vec3(0.07,0.05,0.05)); // Truffle\n\n    vec3 pArm = pBody;\n    pArm.x = abs(pArm.x);\n    vec3 a = vec3(0.6, -0.5, -0.1);\n    float dArm = sdStick(pArm, a, a - vec3(-0.3, 0.3, 0.0), 0.1, 0.15).x; // Arm\n\n    p.x = abs(p.x);\n\n    float dTeeth = sdBox(p-vec3(0.050,-0.30,-0.57), vec3(0.03, 0.06, 0.006)) - 0.02;\n\n    float dhear = sdHear(p-vec3(0.50,0.30,0.15));    \n    \n    float deyeW = length(p-vec3(0.3,0.0,-0.4))-0.25;\n    float deyeB = length(p-vec3(0.3,0.0,-0.46))-0.20;\n    \n    vec3 pFoot = pBody;\n    pFoot.x = abs(pFoot.x);\n    pFoot = pFoot - vec3(-0.25, -0.95, 0.25);\n    float dFoot = sdFoot(pFoot);\n    // d-min\n    \n    float d = min(dbodyhead, dgrnd);\n    d = min(d, deyeW);\n    d = min(d, deyeB);\n    d = min(d, dhear);\n    d = min(d, dNose);\n    d = min(d, dTruffle);\n    d = min(d, dTeeth);\n    d = min(d, dArm);\n    d = min(d, dFoot);\n    \n    // color\n    \n    if ( deyeW == d )  m = 1.0;\n    if ( deyeB == d )  m = 3.0;\n    if ( dgrnd == d ) m = 2.0;\n    if ( dbodyhead == d ) m = 4.0;\n    if ( dhear == d ) m = 4.0;\n    if ( dNose == d ) m = 5.0;\n    if ( dTruffle == d ) m = 3.0;\n    if ( dTeeth == d ) m = 1.0;\n    if ( dArm == d ) m = 4.0;\n    if ( dFoot == d ) m = 5.0;\n\n    return vec2(d,m);\n}\n\nfloat GetDist(vec3 p) {\n    return GetDistMat(p).x;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0),f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float mint = SURF_DIST;\n    float tmax = MAX_DIST;\n    int technique =1;\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0, 1, -3.0);\n    if ( iMouse.x > 10.0 ) {\n        vec2 m = iMouse.xy/iResolution.xy-0.5;\n        ro.yz *= Rot((m.y*0.5)*3.14);\n        ro.xz *= Rot(m.x*6.2831);\n    } else {\n        ro.xz *= Rot(sin(iTime*.1)*.2);\n    }\n    vec3 rd = GetRayDir(uv, ro, vec3(0.0, -0.5, 0.0), 1.);\n\n    vec3 col = vec3(0.4, 0.4, 0.9) * (1.0 - rd.y);\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n\t\t// lighing  \n        float matid = GetDistMat(p).y;\n        if (matid == 1.0) {\n            col = vec3(0.9,0.9,0.9);\n        } else if (matid == 2.0) {\n            col = vec3(0.6,0.6,0.6);\n        } else if (matid == 3.0) {\n            col = vec3(0.05,0.05,0.05);\n        } else if (matid == 4.0) {\n            col = vec3(0.1,0.5,0.5);\n        } else {\n            col = vec3(0.8, 0.6, 0.2);\n        }\n        vec3 sunDir = normalize(vec3(4, 4, -3));\n        // lighting terms\n        float occ = calcOcclusion(p, n);\n        float sha = calcSoftshadow( p+n*.001, sunDir );\n        float sun = clamp( dot( n, sunDir ), 0.0, 1.0 );\n        float sky = clamp( 0.5 + 0.5*n.y, 0.0, 1.0 );\n        float ind = clamp( dot( n, normalize(sunDir*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\n        // compute lighting\n        vec3 lin  = sun*vec3(1.64,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n                lin += sky*vec3(0.16,0.20,0.28)*occ;\n                lin += ind*vec3(0.40,0.28,0.20)*occ;\n\n        // multiply lighting and materials\n\t\tcol = col * lin;        \n        \n        \n        // float dif = dot(n, normalize(vec3(1,2,3)))*0.5+0.5;\n        // float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        // col *= dif;  \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.x -= clamp( p.x, -h / 2.0, h / 2.0 );\n  return length( p ) - r;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opCheapBend( in vec3 p, float k )\n{\n    // const float k = 10.0; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttfDj.jpg", "access": "api", "license": "mit", "functions": [[1707, 1707, 1729, 1729, 1823], [1825, 1825, 1847, 1847, 2078], [2080, 2080, 2102, 2102, 2360], [2362, 2362, 2387, 2387, 4330], [4332, 4332, 4355, 4355, 4385], [4387, 4387, 4421, 4421, 4632], [4634, 4634, 4658, 4658, 4848], [4850, 4850, 4900, 4900, 5090], [5092, 5092, 5141, 5141, 5427], [5429, 5474, 5522, 5522, 6425], [6427, 6427, 6484, 6484, 8344]], "test": "untested"}
{"id": "sdfSz8", "name": "circuit background effect", "author": "yasuo", "description": "circuit", "tags": ["circuit"], "likes": 9, "viewed": 467, "published": 3, "date": "1618253719", "time_retrieved": "2024-07-30T19:26:50.098382", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat layer(vec2 p, float sc, float flip){\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n    \n    vec2 randP = fract(sin(id*123.456)*567.89);\n    randP += dot(randP,randP*34.56);\n    float rand = fract(randP.x*randP.y);\n    float scale = 0.05;\n    \n    float lineW = 0.14;\n    \n    if(rand<0.5 || rand>=0.8){\n        float dir = (rand>=0.8)?1.0:-1.0;\n        uv*=Rot(radians(dir*45.0*flip));\n        uv.x = abs(uv.x);\n        uv.x-=0.355;\n        lineW = 0.1;\n    }\n    \n    lineW*=sc;\n    float d = max(-(uv.x+(lineW*0.5)),(uv.x-(lineW*0.5)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv.xy *= Rot(radians(sin(iTime*.3)*20.0));\n    \n    float d2 = abs(uv.y);\n    float k = 1. / d2;\n    uv = uv * k + vec2(0, k);\n    uv.x-=iTime*0.5;\n    \n    vec2 prevUV = uv;\n    uv*= 3.0;\n    \n    uv.y-= iTime*2.2;\n    \n    vec3 col = vec3(0.0);\n    float d = layer(uv,0.6,1.0);\n    \n    col = mix(col,vec3(1.0,1.0,1.0),S(d,0.0));\n        \n    uv = prevUV;\n    uv*= 2.6;\n    uv.y-= iTime*2.1;\n    d = layer(uv,0.4,-1.0);\n    col = mix(col,vec3(0.5,0.7,1.0),S(d,0.0));\n\n    uv = prevUV;\n    uv*= 2.4;\n    uv.y-= iTime*2.5;\n    d = layer(uv,1.8,1.0);\n    col = mix(col,vec3(1.0,0.2,0.5),S(d,-0.2));\n    \n    vec3 prevCol = col;\n    \n    uv = prevUV;\n    uv*= 2.2;\n    uv.y-= iTime*2.6;\n    d = layer(uv,1.8,-1.0);\n    col *= S(d,-0.2);\n    \n    col = prevCol+(col*6.0);\n    \n    col*=d2*1.5;\n    \n    float brightness= 0.9;\n    fragColor = vec4(col*brightness,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 201, 201, 725], [727, 727, 784, 784, 1719]], "test": "untested"}
{"id": "7sXSz8", "name": "Days 480", "author": "jeyko", "description": "potatee", "tags": ["mdtmjvm"], "likes": 24, "viewed": 430, "published": 3, "date": "1618253699", "time_retrieved": "2024-07-30T19:26:50.993987", "image_code": "// it's like the last one but uninspired! \n// lol, still okay looking tho\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,-(iTime + sin(iTime))*0.2);\n    for(float i = 0.; i < 6.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.+iTime*1.5) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    //n = sin(n*1.);\n    return n;\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    p.xz *= rot((iTime+sin(iTime))*0.5);\n    float n = noise(p*1.5);\n    d.x = length(p) - 1. + n*0.15;\n    d.x*=0.8;\n    return d;\n}\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0.);\n    return normalize(vec3(\n        map(p+t.xyy).x - map(p-t.xyy).x,\n        map(p+t.yxy).x - map(p-t.yxy).x,\n        map(p+t.yyx).x - map(p-t.yyx).x \n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    float pxsz = fwidth(uv.x + uv.y);\n    //vec3 col = vec3(0.1,0.6,0.8)*1. + sin(vec3(0.1,0.3,0.1)*uv.x*4. + vec3(5,2,1) + uv.y + sin(iTime))*0.5;\n    vec3 col = vec3(0.9,1.,1.);\n    \n    \n    bool hit = false;\n    \n    vec3 ro = vec3(0,0,-3.);\n    vec3 rd = normalize(vec3(uv,1. + sin(iTime)*0.));\n    float t = 0.;\n\n    {\n    \n        float modD = 0.2;\n        vec2 p = uv - vec2(0,iTime*0.1 );\n        vec2 id = floor(p/modD);\n        float n = noise(vec3(id,1. + iTime));\n        p = pmod(p,modD);\n        float d = length(p) - 0.00 + n*0.004;\n        \n        col = mix(col,vec3(1.)*pal(n + p.y*144.) + 0.3,smoothstep(pxsz,0.,d));\n        \n    }\n\n    {\n        vec3 p = ro;\n        \n        vec2 d; \n        for(int i = 0; i < 30; i++){\n            d = map(p);\n            if(d.x < 0.009){\n                hit = true;\n                break;\n            }\n            p = ro + rd * ( t += d.x);\n        }\n        \n        if(hit){\n            vec3 n = getNormal(p);\n            vec3 r = reflect(rd,n);\n            vec3 rfr = refract(rd,n,.5);\n            \n            //col = 0.501 + 0.5*sin(r*1.4 + dot(-n,rfr)*2. + vec3(1,4,5.) + length(rfr + n)*6.);\n            //col = pal();\n            col = 0.501 + 0.5*sin(r*.6 + n*vec3(1.5,1.1,0.5)*1. + 0.5*dot(r,n)*13.5 - r*0.5  + vec3(1.5,3.7,5.) + 0.8*length(rfr + n)*4.);\n            #define ao(a) smoothstep(0.,1.,map(p+n*a).x/a)\n            //col *= ao(0.04);\n            //col = max(col,0.);\n            //col = smoothstep(0.,1.,col);\n            col = pow(col,vec3(0.3,0.35,0.26));\n            //col = 0.5 + n*0.5;\n        }\n    }\n\n    {\n        vec2 p = uv;\n        vec2 md = vec2(0.11,0.04);\n        \n        //p.x += 0.67 + md.x*1.;\n        //p.y += md.y*0.5+0.2;\n        \n        vec3 c = vec3(0.1,0.35,0.46)*col*2.5 + (0.4-col*0.5)*1.4 + 0.1*vec3(3,2,1)*sin(p.xyx*14. + iTime);\n        c = max(c,0.1);\n        \n        vec3 oc = c*2.6*(1.-col + 0.4); \n        c = oc;\n        \n        //c =  (pal(uv.y*11. + iTime*1.) + 0.5)*c*1.5*(col*1.);\n    \n            {\n                \n                \n                \n                for(float i = 0.; i < 115.; i++){\n                    float plane = plaIntersect( ro \n                        + vec3(0.,0.,0.6 - .5*sin(i)), rd, vec4(0,0,-1,0) );\n                    vec3 p = ro + rd*plane;\n                    p.x += sin(i*112.)*2.;\n                    p.y += 1.6-mod(0.1*iTime*(1. + sin(i)*0.8),1.)*5.;\n                    float db = 10e5;\n                    \n                \n                    float m = sin(iTime + i*1.17);\n                    m = m + sin(iTime+i*1.05);\n                    \n                    p.xy*=rot(m*11.);\n        \n                vec2 s = 0.5*vec2(0.1*(0.6 + m*0.1) ,0.01+m*0.0255*0.);\n                    db = sdBox(p.xy ,s );\n                    db = xorb(db,sdBox(p.xy*rot(0.5*3.14) , s),-0.0);\n                \n                    //db = xor(db, sdBox(uv*rot(m*1.) , vec2(0.1*(0.6 + m*0.5) ,m*0.0155)));\n                \n                    if(plane < t){\n                        //col = mix(col,(1.-col + 0.35)*(4. + pow(pal(p.y*10.),vec3(0.5)))*0.5,smoothstep(0.03,0.0,db));\n                \n                        col = mix(col,(1.-col + 1.)*pow(pal(p.y*10. + i + iTime),vec3(0.7)),smoothstep(pxsz,0.,db));\n                    }\n                }\n                \n                /*\n                if(plane < t)\n                    col = mix(col,oc,smoothstep(pxsz,0.,db));\n                */\n            }\n        {\n            vec2 omd = md;\n            vec2 id = floor(p/md);\n            \n            \n            p*=rot(0.);\n            md.x *= 2.;\n            vec2 idr = floor(p/md);\n            vec2 q = pmod(p,md);\n            //q.y += sin(idr.y + (iTime + sin(iTime))*2.)*md.y*0.3;\n            float d = sdBox(q, vec2(0.1,0.002));\n            \n            d = xorb(d,0.005+sdBox(q + vec2(+ sin(5.*idr.y + iTime*1. + 3.*sin(idr.y + iTime))*md.x*0.6,0.), vec2(0.5*md.x ,0.01)),0.04);\n            \n            //d = xor(d,0.0+sdBox(p - 0.0 , vec2(0.01 ,0.6)));\n            \n            \n            //vec2 ca = vec2();\n            //cnd += float((id.x) == 6. && abs(id.y - 3.) < 7.);\n            \n            vec2 pa = vec2(0.77,0.3);\n            vec2 pb = - vec2(0.77,0.3);\n            \n            float wa = 0.03;\n            float wb = 0.0001;\n            \n            float outer = sdBox(uv +pa,vec2(omd.x/2.,md.y*3.5));\n            \n            vec2 z = uv + pa;\n            \n            float oo = max(abs(outer - wa) - wb,-sdBox(z - 0.08,vec2(omd.x/2.,md.y*3.5)) ); \n            oo = max(oo,-sdBox(z + 0.08*vec2(0.6,0.45),vec2(omd.x/2.,md.y*3.5)) ); \n            \n            float bb = sdBox(uv +pb,vec2(omd.x/4.,md.y*3.5));\n            outer = min(outer,bb);\n            \n            z = uv + pb;\n            \n            oo = min(oo,max(abs(bb - wa) - wb,-sdBox(z - 0.08,vec2(omd.x*1.,md.y*3.5)) )); \n            oo = max(oo,-sdBox(z + 0.08*vec2(0.1,0.45),vec2(omd.x/2.,md.y*7.5)) ); \n            \n            oo = (oo - 0.00) - 0.0001;\n            \n            \n            \n            \n            float mu = sin(iTime*0.5+sin(iTime))*0.4;\n            \n            float ob = (sdBox(uv,vec2(0.85,0.46)));\n            \n            float cutout = sdBox(uv - vec2(0.5,0.4),vec2(0.6 + sin(iTime)*0.2,0.5));\n            \n            cutout = min(cutout, sdBox(uv + vec2(0.5,0.4),vec2(0.6 + sin(iTime)*0.2,0.5)));\n            \n            float outerBox = max(abs(ob),-cutout);\n            outerBox = min(outerBox, max(abs(ob + 0.04), -cutout + 0.3));\n            \n            outerBox = min(outerBox, max(abs(ob + 0.06), -cutout + 0.3));\n            \n            oo = min(oo,outerBox);\n            \n            \n            col = mix(col,c,smoothstep(pxsz,0., oo));\n            \n            \n               \n           \n            float cnd = smoothstep(pxsz,0., outer);\n            \n            //col = mix(col,col*c,cnd*smoothstep(0.05,0.,d));\n            col = mix(col,c,cnd*smoothstep(pxsz,0.,d));\n            \n            \n            \n            float od = d;\n            \n            d = sdBox(p - vec2(-0.022,0) , vec2(0.01 ,0.2));\n            \n            \n            {\n            \n                float dmu = 10e4;\n                for(float i = 0.; i < 2.; i++){\n                    float plane = plaIntersect( ro \n                        + vec3(0.,0.,+1.4 - .5*sin(iTime + i)), rd, vec4(0,0,-1,0) );\n                    vec3 p = ro + rd*plane;\n                    \n                    \n                    float dmub = length(uv + vec2(sin(i+iTime)*0.1,0.)) - 0.1;\n                    if(plane < t){\n                        dmu = min(xorb(dmu,abs(dmub -0.4) - 0. -0.1*sin(iTime*1.+i*0.3),0.0),0.01);\n                \n                    }     \n                }\n            \n                //oo = min(oo,dmu);\n                col = mix(col,c,smoothstep(pxsz,0., dmu));\n                        \n                //dmu = min(dmu,abs(dmu - 0.02) - 0.01);\n\n                \n            \n            }\n            //d = min(d,xor(d,sdBox(p - vec2(-0.022,0) , vec2(0.001 ,0.5))));\n            //d = min(d,xor(d,sdBox(p - vec2(-0.06,0) , vec2(0.001 ,0.3))));\n            //d = min(d,xor(d,sdBox(p - vec2(-0.05,0) , vec2(0.046 ,0.3))));\n            //d = min(d,xor(d,sdBox(p - vec2(-0.1,0.3) , vec2(0.02 ,0.1))));\n            //d = abs(d) - 0.001;\n            \n            \n        }\n        \n        //d = min(d, sdBox(uv + vec2(0.1), vec2(0.0,0.04)));\n        \n    }\n    \n    float doo = -abs(uv.x ) + 0.55;\n    \n    if(doo <0.){\n        col = (1.-col) + 0.3;\n        col.xz*=rot(0.3 + sin(uv.y+iTime + sin(iTime))*0.4);\n        col = smoothstep(0.,1.,col);\n        col = smoothstep(0.,1.,col);\n        \n    }\n    if(mod(iTime,6.)>5. || iMouse.z > 0.)\n        col = 1. - col;\n        \n    col = pow(col,vec3(0.3545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "float fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\nfloat sdBox(vec2 p, vec2 s){p = abs(p) -s; return max(p.y,p.x);}\n\n\nvec3 pal(float m){\n    vec3 c = 0.5+0.5*sin(m + vec3(1.5,0.,-0.5));\n    c = pow(c, vec3( .5));\n    \n    return c;\n}\n\n#define xor(a,b) min(max(a,-(b)),max(b,-(a)))\n\n#define xorb(a,b,c) min(max(a + c,-(b)),max(b,-(a)))\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 247, 247, 640], [642, 642, 659, 659, 823], [824, 824, 847, 847, 1036], [1038, 1038, 1095, 1095, 8977]], "test": "untested"}
{"id": "fdfSz8", "name": " - Quicky#051", "author": "totetmatt", "description": "Practice on reflection + fractal like structure", "tags": ["quicky"], "likes": 5, "viewed": 258, "published": 3, "date": "1618245772", "time_retrieved": "2024-07-30T19:26:51.788862", "image_code": "#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat ball(vec3 p,float l){\n    return length(p)-l;\n}\n\nvec2 mmin(vec2 a,vec2 b){return a.x < b.x ? a:b;}\nfloat box(vec3 p,vec3 a){\n  vec3 q = abs(p)-a;\n   return length(max(vec3(0.),q)+min(0.,max(q.z,max(q.x,q.y))));\n  }\nvec2 ball1(vec3 p){ \n \n  vec2 d = vec2(10000.,-1.);\n   float c = 6.;\n  for(float i=0.;i<=c;i++){ \n       p= abs(p)-.200*i;\n        p.xz = p.x > p.z ? p.xz:p.zx;\n\n        p.xy *=rot(.754*i);      \n\n       p.xy = p.x > p.y ? p.xy:p.xy;\n        if(mod(i,2.)==1.){\n        d = mmin(d, vec2(ball(p+vec3(1.5*(1.+i/c),0.,.0),1.)/2.5,mod(i,2.)+1.0));\n        } else {\n          d = mmin(d, vec2(box(p+vec3(1.8+p.y*(1.+i/c),-0.5,.0),vec3(0.5,0.5,.6))/1.5,mod(i,2.)+1.0));\n          }\n     \n      \n    }\n    return d;\n\n}\nvec2 sdf(vec3 p){\n  p.zy *=rot(sin(fGlobalTime*.3)*.5);\n    p.xy *=rot(fGlobalTime*.1);\n  vec2 b1 = ball1(p);\n // p.zy *=rot(3.141591/4.+fGlobalTime);\n  p.y = abs(p.y)-.5;\n   p.x = abs(p.x)-.5;\n  vec2 aa =p.xy *rot(p.z*4.);\n  vec2 bb =p.xy *rot(p.z*8.);\n  \n    p.xy = mix(aa,bb,-1.5);\n    \n  for(float j=0.;j<=2.;j++) { p.yxz = abs(p.zyx)-.2; p.yx *=rot(1.3*j);};\n    \n     p.yz = p.z > p.y ? p.yz:p.yx;\n  vec2 b2 = vec2(box(p,vec3(.151)+vec3(.4,.0,.0))/4.9,3.);\n  return mmin(b1,b2);\n}\n  \n vec2 nv= vec2(.001,.0);\n  vec3 norm(vec3 p){\n      return normalize(vec3(sdf(p+nv.xyy).x-sdf(p-nv.xyy).x,sdf(p+nv.yxy).x-sdf(p-nv.yxy).x,sdf(p+nv.yyx).x-sdf(p-nv.yyx).x));\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\nvec3 col = vec3(.1);\n  vec3 ro = vec3(.0001,.0001,-2.1);\n  vec3 rd = normalize(vec3(uv,.6));\n  vec3 rp = ro;\n  float td =0.;\n  vec3 light = vec3(.01,.02,.03);\n  for(float i=0.;i<=69.*3.;i++){\n        vec2 d = sdf(rp);\n        rp += rd*d.x*.8;\n        td += d.x;\n        if(d.x<= 0.000001){\n           vec3 n = norm(rp);\n          float ld = length(light-rp);\n          if(d.y == 1.0){  \n           \n            col += vec3(0.2,.5,.5)*dot(normalize(light),n)*2./ld;\n            break;\n          } else if(d.y == 2.){\n              rd = reflect(rd,n);\n              rp += rd*0.01;\n            col +=vec3(.1,0.,0.);\n            }\n          else if(d.y == 3.){\n              rd = reflect(rd,n);\n              rp += rd*0.00001;\n            col +=vec3(.3,0.2,0.1);\n            }\n          }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 44, 44, 91], [92, 92, 119, 119, 145], [147, 147, 172, 172, 196], [197, 197, 222, 222, 312], [313, 313, 332, 332, 823], [824, 824, 841, 841, 1310], [1341, 1341, 1359, 1359, 1492], [1494, 1494, 1551, 1601, 2510]], "test": "untested"}
{"id": "7dlSzr", "name": "\"Pink Floyd - Time\" like clock", "author": "Pelegefen", "description": "it's a clock inspired by the music video of Time by Pink Floyd.\nlink to music video - https://www.youtube.com/watch?v=BJImSd32f3Y&ab_channel=GoodOldMusic", "tags": ["clock", "wip"], "likes": 4, "viewed": 551, "published": 3, "date": "1618243305", "time_retrieved": "2024-07-30T19:26:52.554814", "image_code": "#define S smoothstep \n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define RES iResolution.xy\n\nvec3 ShapeN(vec2 st, int N, float w, float h){\n\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  st.x += 1.0 ;\n  st.y += .7;\n  st.y /= h;\n    st.x *= w;\n  // Number of sides of your shape\n  //int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulates the distance\n  d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  color = vec3(S(.41,.4,d));\n\n    return color;\n}\nvec2 polarMap(vec2 uv, float shift, float inner) {\n\n    uv = vec2(0.5) - uv;\n    \n    \n    float px = 1.0 - fract(atan(uv.y, uv.x) / 6.28 + 0.25) + shift;\n    float py = (length(uv) * (1.0 + inner * 2.0) - inner) * 2.0;\n    \n    return vec2(px, py);\n}\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\nfloat circle (vec2 p, float r, float g)\n{\n\n    float d = length(p / r);\n\n    float ss = S(.32,.32 - g,d);\n    \n    ss = max(0.,ss);\n    return ss;\n\n}\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn S(r, 0.7*r, d);\n}\nfloat segmentT(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A ;\n    float d = length(h - g * clamp(dot(g , h ) / dot(g,g), 0.0, 1.0));\n    \n\n\treturn S(r, 0.7*r, d);\n}\n\n\n\nvec4 Hand(vec2 uv , float l, float w, float t)\n{\n    vec4 col = vec4(0.);\n    \n\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , 1. * RES.y/RES.x * w);\n    \n    uv *= .35;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 7,/* Width*/6.,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n\n \n    col.a = col.r;// at this point, each of the rgb vals is at 1. and showing the mask, so store it in the A channel.\n    \n    col = max (col,vec4(0.));\n    return col;\n}\n\nvec4 HandsShadow(vec2 uv , float l, float w, float t , float b)\n{\n    vec4 col = vec4(0.);\n    \n    uv.y += .05;\n    uv.x -= .02;\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , w);\n    uv.y += .02;\n    uv *= .45;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 7,/* Width*/6. * w,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n    \n    \n   \n    \n    \n    col -= length(uv.y) * 2.; // attenuate based on height\n    \n    \n    \n    col = max (col,vec4(0.));\n    return col * .1;\n}\nvec4 Dial(vec2 uv, float m)\n{\n    \n    vec4 col = vec4(0.);\n    vec2 fuv = polarMap(uv + .5, .008 , .0) * .5;\n    \n    \n    fuv.x = fract(fuv.x * 8. ) ;\n    col += vec4(ShapeN(fuv+vec2(0.,-.6) ,4  ,  3.15, 0.8 ),0.7) * .5;\n    \n    \n    uv = polarMap(uv + .5, .0035 , .25) * .5;\n    \n    uv.x = fract(uv.x * 24. * m ) ;\n\n    vec2 id = floor(uv * 24.  );\n\n    if(id.x <=  1.6 && id.y >= 18. && id.y <= 26.)return col = vec4(.35);\n\n    col = clamp(col,0.,1.);\n    return col;\n}\n\n\n//returns a working clock\nvec4 ClockFace(vec2 uv){\n\n    vec4 col = vec4(0.,0.,0.,1.);\n    \n    vec4 wt = vec4(.8,.7,0.,1.);// sample wood tex\n    \n    wt += S(-.7,.1,-abs(uv.y)); // add shine\n    \n    float f = circle(uv,4.3, .001 );//clocks frame\n    float fm = (1. - (circle(uv,4.3, .055 ) )) * .6;//clocks frame bevel\n    f -= fm;\n    col += f;\n    col -= circle(uv,3.8, .001 ) - circle(uv,3.7, .001 );//clocks frame\n    col = mix(col,  wt ,  col - circle(uv,3.7, .001 )); // apply wood tex\n\n    //Decoration at 12 o'clock\n    col += circle(uv + vec2(0.,-1.03),0.3, .001 ) * 0.5;\n    col -= circle(uv + vec2(0.,-1.03),0.25, .001 ) * 0.5;\n   // col += circle(uv + vec2(0.,-1.0),0.3, .5 );\n    col -= vec4(ShapeN(uv+vec2(0.,-.5) ,5  ,  5.15, 1.15 ),0.7) * .3;\n    col += circle(   uv + vec2(0.,-.8) ,0.1, .1 );\n    \n    \n    \n    \n    col -= (circle(uv,3.6, .001 ) * .18) + (-uv.y * .1); //inset and shading\n    \n    // Shadow\n    float d = length(uv + vec2(0.,0.1 ))* 0.88;\n    float m = 1. - circle(uv,4.3,.0001);\n  \n    \n     //add the dial and decoration\n    col -= Dial(uv/1.3, 1.);\n    \n    //---------- time is set here------------\n\n    vec4 iDate = iDate;\n    float mils = fract(iDate.w);\n\tfloat secs = mod( (iDate.w),        60.0 );\n\tfloat mins = mod( (iDate.w/60.0),   60.0 );\n\tfloat hors = mod( (iDate.w/3600.0), 24.0 );\n\n\n    vec4 ch1 = Hand(uv, 0.9,0.9, hors  * TAU * .8 );//hours hand\n    \n    ch1 = clamp(ch1,0.,1.);\n    col -= ch1;\n    vec4 ch1s = HandsShadow(uv , 1.,.9, hors  * TAU * .8 , .5);\n    col -= ch1s;\n\n    vec4 ch2 = Hand(uv , 1.6,0.5, mins);//minutes hand\n\n    ch2 = clamp(ch2,0.,1.);\n    col -= ch2;\n    vec4 ch2s = HandsShadow(uv , 1.7,.7, mins , .5);\n    col -= ch2s;\n\n    //vec4 ch3 = Hand(uv ,  2.0, .07 ,secs ); //secondes hand\n    vec4 ch3 = vec4(segmentT(uv,vec2(0,0.),rot(vec2(0.,1.0)  ,secs * TAU/60.  ) , \n    1. * RES.y/RES.x * .05 ));\n   // vec4 ch3m = Hand(uv , 1.1, .05 ,secs ); //secondes hand m\n    //ch3 -= ch3m;\n    \n\n    ch3 = clamp(ch3,0.,1.);\n    col -= ch3;\n    vec4 ch3s = vec4(segmentT(uv,vec2(0,-0.02),rot(vec2(0.1* uv.y ,  1. - uv.y * .1)  ,secs * TAU/60.  ) , \n    1. * RES.y/RES.x * .05 )) * .1;\n    col -= ch3s;\n    \n    vec4 hCol = vec4(0.4,0.4,0.4,1.);// clock hand clr\n    \n    float sh = -   dot(-uv.x * .5,.5) + dot(-uv.y * .5,.5) + .8 ;// clock hands shading\n    \n    \n    vec4 tex1 =hCol / sh;// texture(iChannel0,(rot( uv * 2., -secs* TAU/60.)));\n    vec4 tex2 =hCol/ sh;// texture(iChannel0,(rot( uv * 2., -mins* TAU/60.)));\n    vec4 tex3 =hCol/ sh;// texture(iChannel0,(rot( uv * 2., -hors* TAU/60.)));// we also have to spin the texture per hand!\n  \n    col = mix (col, ch1 * tex3  , ch1) ;\n    col = mix (col,ch2 * tex2 ,ch2 ) ;\n    col = mix (col,ch3 * tex1 ,ch3 ) ;\n    \n    \n    //------------End of Time setting-----------------  \n   \n    float cc =  circle(uv,0.3, .001 ) ;//clocks hand cover\n    cc = ceil(cc);\n    \n    cc = max(cc,0.);\n    cc = min(cc,1.);\n    \n    col =  mix(vec4(cc * .3) , col,1. -cc);\n    col += vec4(circle(uv,0.3, .2 ) * .3) *(fract( uv.y* 50. - .1)  ) ; // dot on the clock hand cover\n    \n    col -= circle(uv,3.7, .001 ) * .18;// glass cover\n    col += max((circle(uv,3.9, .05 ) * .3 * uv.y),0.);\n     m = 1. - circle(uv,4.3,.001);\n    col.a =  1.- m;\n    col = col - m;\n    col = max(vec4(0.),col);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    vec2 ouv = uv;\n    \n    vec4 col = vec4(0.0);\n    \n    //-----BG--------\n    vec4 bg = texture(iChannel0,uv);\n    bg *= .2;\n    bg -= fract(uv.y * 5. ) * .1;\n    bg += fract(uv.y * 5. ) * .2;\n    \n    float m = bg.r;\n    bg += m;\n    col += bg;\n    //------end of BG-----\n     uv *= 3.;\n    \n     col -= max( 1. - length((uv + vec2(.0,.1))* .63), 0.) ;\n    vec4 cf = ClockFace(uv);\n    col = mix(col,cf,cf.a);\n    \n    //if (ouv.x >= -0.01 && ouv.x <= .01) col -= vec4(1.,0.,0.,1.);\n\n  \n\n     \n     \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlSzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 151, 151, 603], [604, 604, 654, 654, 855], [856, 856, 883, 883, 958], [959, 959, 1000, 1000, 1108], [1109, 1109, 1158, 1158, 1293], [1294, 1294, 1344, 1344, 1488], [1492, 1492, 1540, 1540, 2004], [2006, 2006, 2071, 2071, 2542], [2543, 2543, 2572, 2572, 3018], [3021, 3047, 3071, 3071, 6348], [6350, 6350, 6407, 6457, 7072]], "test": "untested"}
{"id": "NsfSR8", "name": "Flagtime", "author": "dr2", "description": "Physical flag, virtual clock", "tags": ["clock", "flag", "physics", "wind", "cloth"], "likes": 13, "viewed": 394, "published": 3, "date": "1618242327", "time_retrieved": "2024-07-30T19:26:53.518238", "image_code": "// \"Flagtime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Physical flag, virtual clock (bits from \"Stonewashed Flag\", \"Tempus Fugit\", etc.)\n\n  Flag is a smooth flexible sheet interpolating across a square mesh of small \n  spheres that interact through springs and other forces (bending, excluded\n  volume, wind pressure, gravity, damping). Wind speed and direction vary \n  randomly with time. The equations of motion of the spheres are solved\n  numerically.\n  \n  Rendering the sheet requires finding the closest intersection of a ray (if it \n  enters a bounding box) with the set of (nonplanar) quads based on the sphere \n  coordinates; this done by (emulated) recursive interpolation of the texture \n  containing the coordinates (down to visual accuracy, and backtracking when a hit \n  occurs or when intersection is impossible). Quad edges are removed by \n  (effectively) smoothing the surface normals.\n*/\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\n#define LBIG   0  // (= 0/1) common to all shaders\n\n#if LBIG\nconst int nBallE = 65;\n#else\nconst int nBallE = 33;\n#endif\n\nconst int nsMax = 3000;\n\nvec3 sunDir;\nvec2 qgHit;\nfloat dstFar, tCur, todCur, spLen, szFac;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nfloat SheetRay (vec3 ro, vec3 rd)\n{\n  vec3 r, q;\n  vec2 g;\n  float d, dMin, sz, szMax, szMin, grLen;\n  bvec2 ilt;\n  bool bkTrak;\n  grLen = 0.92 * spLen;\n  dMin = dstFar / (grLen * szFac);\n  ro /= szFac;\n  rd /= grLen;\n  szMax = float (nBallE - 1);\n  szMin = 1./32.;\n  sz = szMax;\n  g = vec2 (0.);\n  bkTrak = false;\n  for (int ns = VAR_ZERO; ns < nsMax; ns ++) {\n    if (sz == szMin) {\n      r = GetR (g) - ro;\n      q = cross (r, rd);\n      if (dot (q, q) < sz * sz) {\n        d = dot (r, rd);\n        if (d < dMin) {\n          dMin = d;\n          qgHit = g;\n        }\n      }\n      bkTrak = true;\n    }\n    q = cross (GetR (g + 0.5 * sz) - ro, rd);\n    bkTrak = bkTrak || (dot (q, q) > sz * sz);\n    if (bkTrak) {\n      bkTrak = false;\n      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));\n      g.x += ilt.x ? sz : - sz;\n      if (! ilt.x) {\n        g.y += ilt.y ? sz : - sz;\n        if (! ilt.y) {\n          sz *= 2.;\n          if (sz == szMax) break;\n          bkTrak = true;\n        }\n      }\n    } else if (sz > szMin) sz *= 0.5;\n  }\n  return dMin * grLen * szFac;\n}\n\nvec3 GetRC (vec2 v)\n{\n  return GetR (clamp (v, vec2 (0.), vec2 (nBallE - 1)));\n}\n\nvec3 SheetNf () \n{\n  vec3 c;\n  vec2 e = vec2 (1., 0.);\n  c = GetRC (qgHit);\n  return normalize (cross (GetRC (qgHit + e.yx) - c, GetRC (qgHit + e) - c));\n}\n\nfloat SheetSilHit (vec3 ro, vec3 rd)\n{\n  vec3 blkSize, pMin, pMax, v, tm, tp;\n  float dn, df;\n  pMin = Loadv4 (vec2 (1, nBallE)).xyz;\n  pMax = Loadv4 (vec2 (2, nBallE)).xyz;\n  ro /= szFac;\n  ro -= 0.5 * (pMin + pMax);\n  blkSize = 0.5 * (pMax - pMin) + 0.5;\n  v = ro  / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? szFac * dn : dstFar;\n}\n\nvec4 CylHit (vec3 ro, vec3 rd, float cylRad, float cylLen)\n{\n  vec3 s, vn;\n  float dMin, d, a, b, w, srdy;\n  dMin = dstFar;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - cylRad * cylRad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0.) {\n        d /= a;\n        s = ro + d * rd;\n      } else s.y = cylLen;\n    } else s.y = cylLen;\n    if (abs (s.y) < cylLen) {\n      dMin = d;\n      vn = vec3 (s.xz / cylRad, 0.).xzy;\n    } else if (srdy * ro.y < - cylLen) {\n      d = - (srdy * ro.y + cylLen) / abs (rd.y);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.xz) < cylRad) {\n          dMin = d;\n          vn = vec3 (0., 0., - srdy).xzy;\n        }\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  rd.y = abs (rd.y);\n  ro.xz -= 1.5 * tCur;\n  return mix (vec3 (0.1, 0.2, 0.4), vec3 (0.8), clamp (0.2 + Fbm2 (0.1 *\n     (ro.xz + rd.xz * (100. - ro.y) / max (rd.y, 0.001))) * rd.y, 0., 1.));\n}\n\nvec3 SheetCol (float s)\n{\n  vec3 col;\n  vec2 b, g, c;\n  float rad, a, f, gRot;\n  col = vec3 (0.9, 0.9, 1.);\n  c = vec2 (1., 0.4);\n  rad = 0.5 * float (nBallE - 1);\n  b = 1.1 * (qgHit / rad - 1.);\n  b = vec2 (- b.y, b.x);\n  if (s > 0.) b.y *= -1.;\n  a = atan (b.y, - b.x) / pi;\n  if (abs (mod (6. * (a + 1.) + 0.5, 1.) - 0.5) < 0.03 && abs (length (b) - 0.95) < 0.05 ||\n     abs (6. * a) < 0.03 && abs (length (b) - 0.9) < 0.1) col = c.yyx;\n  col = mix (c.yyx, col, 0.8 + 0.2 * SmoothBump (0.15, 0.85, 0.02, mod (rad * length (b), 1.)));\n  col = mix (col, c.yyx, smoothstep (0.96, 0.97, length (b)));\n  gRot = todCur / (12. * 3600.);\n  g = Rot2D (b, 2. * pi * gRot - pi);\n  g.x -= 0.25;\n  f = length (max (abs (g) - vec2 (0.3, 0.027 * (0.6 - 0.4 * g.x / 0.3)), 0.));\n  col = mix (col, c.xxy * (1. - 0.4 * step (0.01, f)), step (f, 0.02));\n  gRot *= 12.;\n  g = Rot2D (b, 2. * pi * gRot - pi);\n  g.x -= 0.35;\n  f = length (max (abs (g) - vec2 (0.4, 0.013 * (0.6 - 0.4 * g.x / 0.4)), 0.));\n  col = mix (col, c.yxy * (1. - 0.4 * step (0.01, f)), step (f, 0.02));\n  gRot *= 60.;\n  g = Rot2D (b, 2. * pi * (floor (60. * gRot) + smoothstep (0.8, 1., mod (60. * gRot, 1.))) / 60. - pi);\n  g.x -= 0.4;\n  f = length (max (abs (g) - vec2 (0.46, 0.007 * (0.6 - 0.4 * g.x / 0.46)), 0.));\n  col = mix (col, c.xyy * (1. - 0.4 * step (0.01, f)), step (f, 0.02));\n  col = mix (vec3 (0.1, 0.1, 0.2), col, smoothstep (0.007, 0.013, length (b)));\n  col = mix (col, vec3 (1., 0., 0.), step (1.95 * rad, qgHit.y));\n  col = mix (col, vec3 (0., 1., 0.), step (-0.05 * rad, - qgHit.y));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, dc4;\n  vec3 col, vn, q;\n  float dstObj, dstSheet, s, flSize;\n  szFac = 4. / float (nBallE - 1);\n  flSize = szFac * 0.5 * float (nBallE + 1);\n  q = ro;\n  q.y -= - flSize;\n  dc4 = CylHit (q, rd, 0.06, 2. * flSize + 0.2);\n  dstObj = dc4.x;\n  q = ro;\n  q.x -= flSize + ((LBIG == 0) ? 0.06 : 0.12);\n  dstSheet = (SheetSilHit (q, rd) < dstFar) ? SheetRay (q, rd) : dstFar;\n  if (min (dstSheet, dstObj) < dstFar) {\n    if (dstSheet < dstObj) {\n      vn = SheetNf ();\n      s = sign (dot (rd, vn));\n      if (s > 0.) vn = - vn;\n      col4 = vec4 (SheetCol (s), 0.);\n    } else {\n      ro += dstObj * rd;\n      vn = dc4.yzw;\n      col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      if (ro.y > - flSize - 0.1) col4 *= (0.5 + 0.5 * smoothstep (0.05, 0.1,\n         abs (mod (4. * (ro.y + 0.02) / flSize + 0.5, 1.) - 0.5)));\n    }\n    col = col4.rgb * (0.2 + 0.1 * max (0., vn.y) + 0.2 * max (- dot (vn, sunDir), 0.) +\n       0.8 * max (dot (vn, sunDir), 0.)) + col4.a * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  }\n  el = clamp (el, 0.05 * pi, 0.2 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 5.5;\n  ro = vuMat * vec3 (2., -0.5, -20.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  stDat = Loadv4 (vec2 (0, nBallE));\n  spLen = stDat.x;\n  dstFar = 160.;\n  sunDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Flagtime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define LBIG   0  // (= 0/1) common to all shaders\n\n#if LBIG\nconst int nBallE = 65;\n#else\nconst int nBallE = 33;\n#endif\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 200.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE * nBallE; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE - 1 && iv.x > 0 && iv.x < nBallE - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 1.;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 10. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE - 1) / 8)) != 0. && iv.y != nBallE - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE, nBallE) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE * pxIv.y;\n  nb = nBallE * nBallE;\n  if (pxIv.x >= 2 * nBallE || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE) iv.x -= nBallE;\n  mId = iv.y * nBallE + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Flagtime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define LBIG   0  // (= 0/1) common to all shaders\n\n#if LBIG\nconst int nBallE = 65;\n#else\nconst int nBallE = 33;\n#endif\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 200.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE * nBallE; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE - 1 && iv.x > 0 && iv.x < nBallE - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 1.;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 10. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE - 1) / 8)) != 0. && iv.y != nBallE - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE, nBallE) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE * pxIv.y;\n  nb = nBallE * nBallE;\n  if (pxIv.x >= 2 * nBallE || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE) iv.x -= nBallE;\n  mId = iv.y * nBallE + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Flagtime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define LBIG   0  // (= 0/1) common to all shaders\n\n#if LBIG\nconst int nBallE = 65;\n#else\nconst int nBallE = 33;\n#endif\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.14159;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 200.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE * nBallE; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE - 1 && iv.x > 0 && iv.x < nBallE - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 1.;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 10. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE - 1) / 8)) != 0. && iv.y != nBallE - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE, nBallE) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE * pxIv.y;\n  nb = nBallE * nBallE;\n  if (pxIv.x >= 2 * nBallE || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE) iv.x -= nBallE;\n  mId = iv.y * nBallE + iv.x;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE) ? v : r), 0.);\n  else {\n    if (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfSR8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1484, 1484, 1504, 1504, 1531], [1533, 1533, 1568, 1568, 2609], [2611, 2611, 2632, 2632, 2691], [2693, 2693, 2711, 2711, 2848], [2850, 2850, 2888, 2888, 3268], [3270, 3270, 3330, 3330, 4078], [4080, 4080, 4111, 4111, 4306], [4308, 4308, 4333, 4333, 5884], [5886, 5886, 5921, 5921, 6998], [7000, 7000, 7056, 7056, 7784], [7786, 7786, 7808, 7808, 7846], [7848, 7848, 7870, 7870, 7908], [7910, 7910, 7967, 7967, 8050], [8052, 8052, 8088, 8088, 8294], [8296, 8296, 8326, 8326, 8439], [8473, 8473, 8497, 8497, 8627], [8629, 8629, 8654, 8654, 8840], [8842, 8842, 8863, 8863, 9018], [9085, 9085, 9109, 9109, 9159]], "test": "untested"}
{"id": "7dlXzr", "name": "Fractal 56_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 7, "viewed": 369, "published": 3, "date": "1618238142", "time_retrieved": "2024-07-30T19:26:54.397886", "image_code": "#define PI (atan(1.)*4.)\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define M(p,n)vec2(asin(sin(atan(p.x,p.y)*n))/n,1)*length(p)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(length(q)*.5),.7)*.01*exp(-8.*i*i*e)\n    )\n    {\n        p=g*d;\n        p.z-=10.;\n        q=p=R(p,normalize(vec3(1,2,2)),iTime*.5);\n        s=3.;\n        for(int i=0;i++<8;){\n            p.xy= M(p.xy,4.);\n            p.y-=1.;\n            p.zy = M(p.zy,3.);\n            p.y-=3.;\n            s*=3.;\n            p*=3.;\n        }\n        g+=e=length(p.xy)/s-.001;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlXzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 228, 228, 758]], "test": "untested"}
{"id": "7dlXzn", "name": "Pixel BVH", "author": "paniq", "description": "precomputed BVH for 2D pixel mask", "tags": ["pixel", "bvh"], "likes": 10, "viewed": 557, "published": 3, "date": "1618235398", "time_retrieved": "2024-07-30T19:26:55.363305", "image_code": "#define LEVELS 9\n#define NUMRECTS 510 //(1 << LEVELS)\n#define MAXSIZE 128.0\n\nconst uint rect[NUMRECTS] = uint[](\n0x0u, 0x7373050du, 0x73733e0du, 0x3e73050du, 0x73403e0du, 0x73733e40u, 0x3e40050du, 0x3e730540u, \n0x54403e0du, 0x73405412u, 0x54733e40u, 0x736e5440u, 0x22400520u, 0x3e40220du, 0x22600540u, 0x3e732240u, \n0x47403e0du, 0x542b470eu, 0x69235412u, 0x73405423u, 0x47733e40u, 0x54724755u, 0x696e545du, 0x735d5440u, \n0x222f0b20u, 0x1c40052fu, 0x3e402229u, 0x3e29220du, 0x1c510540u, 0x22600b51u, 0x3e572240u, 0x3e732257u, \n0x471a3e0du, 0x45403e2du, 0x541f470eu, 0x542b4c1fu, 0x61235412u, 0x6923611au, 0x73406b26u, 0x6b405423u, \n0x45533e40u, 0x47733e66u, 0x54614c55u, 0x54724761u, 0x616e545du, 0x6966615du, 0x735a6b40u, 0x6b5d5440u, \n0x142f0b26u, 0x222f1420u, 0x1340052fu, 0x1c39132fu, 0x34342229u, 0x3e403429u, 0x3a292221u, 0x3e21220du, \n0x13510540u, 0x1c511347u, 0x145a0b51u, 0x22601451u, 0x3457224cu, 0x3e573440u, 0x3a5f2257u, 0x3e73225fu, \n0x47163e0du, 0x471a4216u, 0x42343e2du, 0x45403e34u, 0x541b470eu, 0x541f481bu, 0x54244c1fu, 0x542b5024u, \n0x5c165412u, 0x61235416u, 0x651e611au, 0x6923611eu, 0x6f2e6b26u, 0x73406b2eu, 0x6b325423u, 0x6b405632u, \n0x454c3e40u, 0x42533e4cu, 0x476a4266u, 0x47733e6au, 0x545c5055u, 0x54614c5cu, 0x54654861u, 0x54724765u, \n0x616a545du, 0x5c6e546au, 0x6962615du, 0x65666162u, 0x73526b40u, 0x6f5a6b52u, 0x6b5d544fu, 0x6b4f5640u, \n0x142a0f26u, 0x142f0b2au, 0x22241720u, 0x222f1424u, 0x1337072fu, 0x13400537u, 0x1c33132fu, 0x17391333u, \n0x30302229u, 0x34343029u, 0x3e353429u, 0x3e403535u, 0x35292221u, 0x3a293525u, 0x3721220eu, 0x3e13370du, \n0x13490540u, 0x13510749u, 0x174d1347u, 0x1c51134du, 0x14560b51u, 0x145a0f56u, 0x225c1451u, 0x2260175cu, \n0x30572250u, 0x3457304cu, 0x3e4b3540u, 0x3e57344bu, 0x355f2257u, 0x3a5b3557u, 0x3772225fu, 0x3e73376du, \n0x41153e0du, 0x4716410du, 0x45184216u, 0x471a4516u, 0x40303e2du, 0x42343e30u, 0x443a3e34u, 0x45403e3au, \n0x4f1b470eu, 0x541b4f10u, 0x4a1d481bu, 0x541f4a1bu, 0x4e214c1fu, 0x54244e1fu, 0x54275024u, 0x542b5227u, \n0x59165412u, 0x5c165914u, 0x5f235416u, 0x61235f18u, 0x631e611au, 0x651e631cu, 0x6723611eu, 0x69236720u, \n0x6d296b26u, 0x6f2e6b29u, 0x71356b2eu, 0x73406b35u, 0x56315423u, 0x6b325623u, 0x583a5632u, 0x6b405832u, \n0x45463e40u, 0x444c3e46u, 0x42503e4cu, 0x40533e50u, 0x456a4268u, 0x476a4566u, 0x41733e6bu, 0x4773416au, \n0x54595255u, 0x545c5059u, 0x4e614c5fu, 0x54614e5cu, 0x4a654863u, 0x54654a61u, 0x4f724765u, 0x54704f65u, \n0x5f6a545du, 0x61685f5du, 0x596e546au, 0x5c6c596au, 0x6762615du, 0x6960675du, 0x63666162u, 0x65646362u, \n0x734b6b40u, 0x71526b4bu, 0x6f576b52u, 0x6d5a6b57u, 0x605d544fu, 0x6b5d604fu, 0x584f5646u, 0x6b4f5840u, \n0x112a0f28u, 0x142a1126u, 0xd2f0b2cu, 0x142f0d2au, 0x1c241722u, 0x22241c20u, 0x1e2f1424u, 0x222e1e24u, \n0x9370732u, 0x1337092fu, 0xc400537u, 0x13400c37u, 0x1933132fu, 0x1c31192fu, 0x17351333u, 0x15391335u, \n0x2d2e2229u, 0x30302d29u, 0x34323029u, 0x34343232u, 0x3c2b3429u, 0x3e35342bu, 0x3e383535u, 0x3e403738u, \n0x31292221u, 0x35293123u, 0x38293525u, 0x3a293827u, 0x3710340eu, 0x29212220u, 0x3e133a0du, 0x3a11370eu, \n0xc490540u, 0x13490c40u, 0x94e0749u, 0x13510949u, 0x154b1347u, 0x174d134bu, 0x1951134du, 0x1c51194fu, \n0xd540b51u, 0x14560d51u, 0x11580f56u, 0x145a1156u, 0x1e5c1451u, 0x225c1e52u, 0x1c5e175cu, 0x22601c5cu, \n0x2d572252u, 0x30572d50u, 0x344e324cu, 0x3457304eu, 0x3e483740u, 0x3e4b3548u, 0x3e55344bu, 0x3c573455u, \n0x315f2257u, 0x355d3157u, 0x385b3557u, 0x3a593857u, 0x37723470u, 0x2960225fu, 0x3e733a6du, 0x3a72376fu, \n0x41143e0du, 0x41153f14u, 0x460e410du, 0x4716410eu, 0x44174216u, 0x45184416u, 0x47194516u, 0x471a4619u, \n0x3f2e3e2du, 0x40303e2eu, 0x41323e30u, 0x42343e32u, 0x43373e34u, 0x443a3e37u, 0x44403e3au, 0x4540443cu, \n0x4b0f470eu, 0x4f1b470fu, 0x52114f10u, 0x541b4f11u, 0x4a1c481bu, 0x4a1d491cu, 0x4b1e4a1bu, 0x541f4b1bu, \n0x4e204c1fu, 0x4e214d20u, 0x4f234e1fu, 0x54244f1fu, 0x51265024u, 0x54275124u, 0x54295227u, 0x542b5329u, \n0x57165412u, 0x59165713u, 0x5a165914u, 0x5c165a15u, 0x5d175416u, 0x5f235417u, 0x60195f18u, 0x61235f19u, \n0x621b611au, 0x631e611bu, 0x641d631cu, 0x651e631du, 0x6623611eu, 0x6723661fu, 0x68216720u, 0x69236721u, \n0x6c276b26u, 0x6d296b27u, 0x6e2c6b29u, 0x6f2e6b2cu, 0x70316b2eu, 0x71356b31u, 0x723a6b35u, 0x73406b3au, \n0x562e5423u, 0x5631552eu, 0x6a325623u, 0x6b326a24u, 0x58345632u, 0x583a5734u, 0x0u, 0x0u, \n0x44463e40u, 0x45444440u, 0x44493e46u, 0x434c3e49u, 0x424e3e4cu, 0x41503e4eu, 0x40523e50u, 0x3f533e52u, \n0x446a4269u, 0x456a4468u, 0x47674666u, 0x476a4567u, 0x416c3f6bu, 0x41733e6cu, 0x4772416au, 0x46734172u, \n0x54575355u, 0x54595257u, 0x515c505au, 0x545c5159u, 0x4e604d5fu, 0x4e614c60u, 0x4f614e5du, 0x54614f5cu, \n0x4a644963u, 0x4a654864u, 0x4b654a62u, 0x54654b61u, 0x4f714765u, 0x4b724771u, 0x546f4f65u, 0x52704f6fu, \n0x5f69545du, 0x5d6a5469u, 0x61675f5du, 0x60685f67u, 0x576e546au, 0x596d576au, 0x5a6c596au, 0x5c6b5a6au, \n0x6662615du, 0x6761665du, 0x695f675du, 0x6860675fu, 0x63656162u, 0x62666165u, 0x65636362u, 0x64646363u, \n0x73466b40u, 0x724b6b46u, 0x714f6b4bu, 0x70526b4fu, 0x6f546b52u, 0x6e576b54u, 0x6d596b57u, 0x6c5a6b59u, \n0x6052554fu, 0x605d5452u, 0x6b5c604fu, 0x6a5d605cu, 0x584c5746u, 0x584f564cu, 0x0u, 0x0u, \n0x11291028u, 0x112a0f29u, 0x14271226u, 0x142a1127u, 0xd2d0c2cu, 0xd2f0b2du, 0xe2f0d2bu, 0x142f0e2au, \n0x19241723u, 0x1c241922u, 0x21241c21u, 0x22242120u, 0x1e251524u, 0x1e2f1425u, 0x222d1e24u, 0x212e1e2du, \n0x9340832u, 0x9370734u, 0xa370930u, 0x13370a2fu, 0xc3d0637u, 0xc40053du, 0x133c0c37u, 0x12400c3cu, \n0x1833132fu, 0x1932182fu, 0x1a31192fu, 0x1c301a2fu, 0x16351333u, 0x17341633u, 0x15371335u, 0x14391337u, \n0x2a2d2229u, 0x2d2e2a29u, 0x302f2d29u, 0x30302f2fu, 0x34313029u, 0x34323131u, 0x34333232u, 0x34343333u, \n0x3b2b3429u, 0x3c2b3b2au, 0x3d2c342bu, 0x3e35342cu, 0x36363535u, 0x3e383635u, 0x3e3b3738u, 0x3e40383bu, \n0x2e292221u, 0x31292e22u, 0x33243123u, 0x35293124u, 0x37263525u, 0x38293526u, 0x39283827u, 0x3a293828u, \n0x3510340fu, 0x3710350eu, 0x0u, 0x0u, 0x3e123a0du, 0x3e133c12u, 0x0u, 0x0u, \n0xc430540u, 0xc490643u, 0x12440c40u, 0x13490c44u, 0x94c0749u, 0x94e084cu, 0xa500949u, 0x13510a49u, \n0x14491347u, 0x154b1349u, 0x164d134bu, 0x174d164cu, 0x1851134du, 0x1951184eu, 0x1a51194fu, 0x1c511a50u, \n0xd530b51u, 0xd540c53u, 0xe550d51u, 0x14560e51u, 0x11570f56u, 0x11581057u, 0x14591156u, 0x145a1259u, \n0x1e5b1451u, 0x1e5c155bu, 0x21531e52u, 0x225c1e53u, 0x195d175cu, 0x1c5e195cu, 0x215f1c5cu, 0x2260215cu, \n0x2a572253u, 0x2d572a52u, 0x30512f50u, 0x30572d51u, 0x344d334cu, 0x344e324du, 0x344f314eu, 0x3457304fu, \n0x3e453840u, 0x3e483745u, 0x364b354au, 0x3e4b3648u, 0x3e54344bu, 0x3d553454u, 0x3b573455u, 0x3c563b55u, \n0x2e5f2257u, 0x315e2e57u, 0x355c3157u, 0x335d315cu, 0x385a3557u, 0x375b355au, 0x3a583857u, 0x39593858u, \n0x35713470u, 0x37723570u, 0x0u, 0x0u, 0x3e6e3c6du, 0x3e733a6eu\n);\n\nvec4 getrect(uint i) {\n    uint x = (i >= uint(NUMRECTS))?0u:rect[i];\n    return (vec4(x & 0xffu, (x >> 8) & 0xffu, (x >> 16) & 0xffu, x >> 24)/MAXSIZE) * 2.0 - 1.0;\n}\n\nbool inrect(vec2 o, vec4 rc) {\n    return (o.x >= rc.x) && (o.y >= rc.y) && (o.x < rc.z) && (o.y < rc.w);\n}\n\nbool find_rect (vec2 o, out uint c) {\n    c = 0u;\n    for (uint i = 0u; i <= uint(LEVELS); ++i) {\n        uint k0 = (c << 1);\n        uint k1 = k0 + 1u;\n        // leaf?\n        if ((k1 >= uint(NUMRECTS)) || ((rect[k0]==0u) && (rect[k1]==0u))) {\n            return true;\n        }\n        vec4 rc = getrect(k0);\n        if (inrect(o, rc)) {\n            c = k0;\n        } else {\n            rc = getrect(k1);\n            if (inrect(o, rc)) {\n                c = k1;\n            } else {\n                return false;\n            }\n        }\n    }\n}\n\n// from https://www.shadertoy.com/view/WlfXRN\nvec3 viridis(float t) {\n\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    set_line_width_px(1.0);\n\n    {\n        uint c = 0u;\n        bool leaf = find_rect(get_origin(), c);\n        vec4 rc = getrect(c);\n        int d = 0;\n        for (int i = 0; i <= LEVELS; ++i) {\n            if (c == 0u)\n                break;\n            d += 1;\n            c = c >> 1;\n        }\n        vec3 col = viridis(float(d)/float(LEVELS));\n        if (leaf) {\n            col = mix(col, vec3(1.0), 0.5);\n        }\n        set_source_rgb(col);\n        clear();\n        if (leaf) {\n            set_source_rgba(0.0,0.0,0.0,0.7);\n            rectangle(rc.x, rc.y, rc.z - rc.x, rc.w - rc.y);\n            stroke();\n        }\n    }\n    set_line_width_px(1.0);\n    // find best rect we're in\n    uint c = 0u;\n    bool found = find_rect(get_query(), c);\n    vec4 rc = getrect(c);\n    rectangle(rc.x, rc.y, rc.z - rc.x, rc.w - rc.y);\n    if (!found) {\n        set_source_rgb(vec3(0.5));    \n        stroke(); \n    } else {\n        set_source_rgb(vec3(0.8));    \n        fill_preserve();\n        set_source_rgb(vec3(0.0));    \n        stroke(); \n    }\n\n    blit(fragColor);\n}", "image_inputs": [], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.11\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.4;\n\tAAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlXzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6710, 6710, 6732, 6732, 6877], [6879, 6879, 6909, 6909, 6986], [6988, 6988, 7025, 7025, 7535], [7537, 7583, 7606, 7606, 8262], [8264, 8264, 8321, 8321, 9446]], "test": "untested"}
{"id": "fdsSRr", "name": "pointify image", "author": "lomateron", "description": "mouse click to paint\nkey A to reset image\nkey S to clean image\nI think I have already seen this process somewhere\nincrease the convolution size to make points bigger\n", "tags": ["convolution", "paint"], "likes": 1, "viewed": 291, "published": 3, "date": "1618210296", "time_retrieved": "2024-07-30T19:26:56.169150", "image_code": "//an accident\n//was exploring how to make fluids using only kernel convolutions\n//read my comment here https://www.shadertoy.com/view/fdjGzW\n//code applies blur kernel each frame https://en.wikipedia.org/wiki/Kernel_(image_processing)\n//but the kernel values are different across space\n//the kernel values are the same image its convolving\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,u)+.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float keyA  = texture( iChannel1, vec2(65.5/256.,.25) ).x;\n    float keyS  = texture( iChannel1, vec2(83.5/256.,.25) ).x;\n    float z = 1.;//kernel convolution size\n    vec4 b0 = abs(A(u+vec2(0,0)));\n    vec4 b = vec4(0);\n    for(float i = -z; i<z+.5;++i){\n    for(float j = -z; j<z+.5;++j){\n      vec4 s = vec4(0);\n      for(float i2 = -z; i2<z+.5;++i2){\n      for(float j2 = -z; j2<z+.5;++j2){\n      s += abs(A(u+vec2(i,j)+vec2(i2,j2)));\n      }}\n      if(s.x==0.)s.x = 1.;\n      if(s.y==0.)s.y = 1.;\n      if(s.z==0.)s.z = 1.;\n      if(s.w==0.)s.w = 1.;\n      b += b0/s*A(u+vec2(i,j));\n    }}\n    vec4 a = b;\n    if(keyA!=0.)a = texture( iChannel2, u/iResolution.xy)-.5;\n    if(keyS!=0.)a = vec4(0);\n    if(iFrame==0)a = sin(u.xy*.04+sin(u.yx*.04)).xyxy;\n    if(iMouse.z>0.||iFrame==0)\n    {\n        vec2 m1 = 2.*(u-iMouse.xy)/iResolution.y;\n        a += sin(m1.x*32.)/exp(dot(m1,m1)*111.);\n    }\n    fragColor = a;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 341, 398, 398, 480]], "test": "untested"}
{"id": "7sfXRr", "name": "Windowed Anachronism 3.1", "author": "wilkie", "description": "Bounces a classic Windows 3.1 bordered window around the screen where the client area of the window will be a 16 color dither of whatever is drawn beneath it-- in this case Himred's https://www.shadertoy.com/view/ld2yDz shader.", "tags": ["2d", "retro", "dither", "bayer", "gui", "concept"], "likes": 21, "viewed": 518, "published": 3, "date": "1618195910", "time_retrieved": "2024-07-30T19:26:57.243279", "image_code": "// The resolution of the dither.\nconst float ResolutionDivisor = 1.0;\n\n// The number of colors\n// (It treats every color as equidistant... which is not accurate to the\n//  actual hardware, of course)\nconst float PaletteRGBSize = 1.0;\n\n// Can switch between the 4 by 4 and 8 by 8 bayer matrices\n#define BAYER_MATRIX bayer8x8\n//#define BAYER_MATRIX bayer4x4\n\nconst vec3 BUTTON_HIGHLIGHT = vec3(1.0, 1.0, 1.0);\nconst vec3 BUTTON_SHADOW = vec3(129.0/255.0, 129.0/255.0, 129.0/255.0);\n\nconst float BORDER_WIDTH = 4.0;\nconst vec3 BORDER_FILL = vec3(193.0/255.0, 193.0/255.0, 193.0/255.0);\nconst vec3 BORDER_STROKE = vec3(0.0, 0.0, 0.0);\n\nconst vec3 TITLE_FILL = vec3(166.0/255.0, 203.0/255.0, 243.0/255.0);\n\nconst int SYSTEM_BUTTON_MENU = 0;\nconst int SYSTEM_BUTTON_MINIMIZE = 1;\nconst int SYSTEM_BUTTON_MAXIMIZE = 2;\n\nconst int TRIANGLE_UP = 0;\nconst int TRIANGLE_DOWN = 1;\nconst int TRIANGLE_LEFT = 2;\nconst int TRIANGLE_RIGHT = 3;\n\nfloat quantize(float inp, float period)\n{\n\treturn floor((inp + period / 2.) / period) * period;\n}\n\nfloat bayer4x4(vec2 uvScreenSpace, float divisor)\n{\n\tvec2 bayerCoord = floor(uvScreenSpace/divisor);\n\tbayerCoord = mod(bayerCoord, 4.);\n\n\tconst mat4 bayerMat = mat4(\n\t\t\t1,9,3,11,\n\t\t\t13,5,15,7,\n\t\t\t4,12,2,10,\n\t\t\t16,8,14,6) / 16.;\n\tint bayerIndex = int(bayerCoord.x + bayerCoord.y * 4.);\n\tif(bayerIndex == 0) return bayerMat[0][0];\n\tif(bayerIndex == 1) return bayerMat[0][1];\n\tif(bayerIndex == 2) return bayerMat[0][2];\n\tif(bayerIndex == 3) return bayerMat[0][3];\n\tif(bayerIndex == 4) return bayerMat[1][0];\n\tif(bayerIndex == 5) return bayerMat[1][1];\n\tif(bayerIndex == 6) return bayerMat[1][2];\n\tif(bayerIndex == 7) return bayerMat[1][3];\n\tif(bayerIndex == 8) return bayerMat[2][0];\n\tif(bayerIndex == 9) return bayerMat[2][1];\n\tif(bayerIndex == 10) return bayerMat[2][2];\n\tif(bayerIndex == 11) return bayerMat[2][3];\n\tif(bayerIndex == 12) return bayerMat[3][0];\n\tif(bayerIndex == 13) return bayerMat[3][1];\n\tif(bayerIndex == 14) return bayerMat[3][2];\n\treturn bayerMat[3][3];\n}\n\n\nfloat bayer8x8(vec2 uvScreenSpace, float divisor) {\n\n\tvec2 bayerCoord = floor(uvScreenSpace/divisor);\n\tbayerCoord = mod(bayerCoord, 8.);\n    \n\tint bayerIndex = int(bayerCoord.x + bayerCoord.y * 8.);\n    \n    float limit = 0.0;\n\n    if (bayerIndex == 0) limit = 0.015625;\n    if (bayerIndex == 1) limit = 0.515625;\n    if (bayerIndex == 2) limit = 0.140625;\n    if (bayerIndex == 3) limit = 0.640625;\n    if (bayerIndex == 4) limit = 0.046875;\n    if (bayerIndex == 5) limit = 0.546875;\n    if (bayerIndex == 6) limit = 0.171875;\n    if (bayerIndex == 7) limit = 0.671875;\n    if (bayerIndex == 8) limit = 0.765625;\n    if (bayerIndex == 9) limit = 0.265625;\n    if (bayerIndex == 10) limit = 0.890625;\n    if (bayerIndex == 11) limit = 0.390625;\n    if (bayerIndex == 12) limit = 0.796875;\n    if (bayerIndex == 13) limit = 0.296875;\n    if (bayerIndex == 14) limit = 0.921875;\n    if (bayerIndex == 15) limit = 0.421875;\n    if (bayerIndex == 16) limit = 0.203125;\n    if (bayerIndex == 17) limit = 0.703125;\n    if (bayerIndex == 18) limit = 0.078125;\n    if (bayerIndex == 19) limit = 0.578125;\n    if (bayerIndex == 20) limit = 0.234375;\n    if (bayerIndex == 21) limit = 0.734375;\n    if (bayerIndex == 22) limit = 0.109375;\n    if (bayerIndex == 23) limit = 0.609375;\n    if (bayerIndex == 24) limit = 0.953125;\n    if (bayerIndex == 25) limit = 0.453125;\n    if (bayerIndex == 26) limit = 0.828125;\n    if (bayerIndex == 27) limit = 0.328125;\n    if (bayerIndex == 28) limit = 0.984375;\n    if (bayerIndex == 29) limit = 0.484375;\n    if (bayerIndex == 30) limit = 0.859375;\n    if (bayerIndex == 31) limit = 0.359375;\n    if (bayerIndex == 32) limit = 0.0625;\n    if (bayerIndex == 33) limit = 0.5625;\n    if (bayerIndex == 34) limit = 0.1875;\n    if (bayerIndex == 35) limit = 0.6875;\n    if (bayerIndex == 36) limit = 0.03125;\n    if (bayerIndex == 37) limit = 0.53125;\n    if (bayerIndex == 38) limit = 0.15625;\n    if (bayerIndex == 39) limit = 0.65625;\n    if (bayerIndex == 40) limit = 0.8125;\n    if (bayerIndex == 41) limit = 0.3125;\n    if (bayerIndex == 42) limit = 0.9375;\n    if (bayerIndex == 43) limit = 0.4375;\n    if (bayerIndex == 44) limit = 0.78125;\n    if (bayerIndex == 45) limit = 0.28125;\n    if (bayerIndex == 46) limit = 0.90625;\n    if (bayerIndex == 47) limit = 0.40625;\n    if (bayerIndex == 48) limit = 0.25;\n    if (bayerIndex == 49) limit = 0.75;\n    if (bayerIndex == 50) limit = 0.125;\n    if (bayerIndex == 51) limit = 0.625;\n    if (bayerIndex == 52) limit = 0.21875;\n    if (bayerIndex == 53) limit = 0.71875;\n    if (bayerIndex == 54) limit = 0.09375;\n    if (bayerIndex == 55) limit = 0.59375;\n    if (bayerIndex == 56) limit = 1.0;\n    if (bayerIndex == 57) limit = 0.5;\n    if (bayerIndex == 58) limit = 0.875;\n    if (bayerIndex == 59) limit = 0.375;\n    if (bayerIndex == 60) limit = 0.96875;\n    if (bayerIndex == 61) limit = 0.46875;\n    if (bayerIndex == 62) limit = 0.84375;\n    if (bayerIndex == 63) limit = 0.34375;\n  \n    return limit;\n}\n\nvoid drawBox(inout vec3 color, vec3 fill, vec3 stroke, vec2 fragCoord, vec2 position, vec2 size)\n{\n    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&\n        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {        \n        color = fill;\n        \n        if (fragCoord.x - 0.5 == position.x ||\n            fragCoord.x - 0.5 == position.x + size.x - 1.0 ||\n            fragCoord.y - 0.5 == position.y ||\n            fragCoord.y - 0.5 == position.y + size.y - 1.0) {\n            color = stroke;\n        }        \n    }\n}\n\nvoid drawBevel(inout vec3 color, vec3 highlight, vec3 shadow, vec2 fragCoord, vec2 position, vec2 size)\n{\n    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&\n        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {\n        if (fragCoord.x - 0.5 == position.x + size.x - 1.0 ||\n                 fragCoord.y - 0.5 == position.y) {\n            color = shadow;\n        }  \n        else if (fragCoord.x - 0.5 == position.x ||\n            fragCoord.y - 0.5 == position.y + size.y - 1.0) {\n            color = highlight;\n        }\n    }\n}\n\nvoid drawTriangle(inout vec3 color, vec3 fill, vec2 fragCoord, vec2 position, vec2 size, int direction) {\n    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&\n        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {\n        // Get coordinates relative from the center.\n        vec2 xy = fragCoord - vec2(0.5, 0.5) - position - floor(size / 2.0);\n        if (xy.x + xy.y >= 0.0 &&\n            xy.y - xy.x >= 0.0 && direction == TRIANGLE_DOWN) {\n            color = fill;\n        }\n        if (xy.x + xy.y >= 0.0 &&\n            xy.x - xy.y >= 0.0 && direction == TRIANGLE_LEFT) {\n            color = fill;\n        }\n        if (xy.x + xy.y <= 0.0 &&\n            xy.y - xy.x <= 0.0 && direction == TRIANGLE_UP) {\n            color = fill;\n        }\n        if (xy.x + xy.y <= 0.0 &&\n            xy.x - xy.y <= 0.0 && direction == TRIANGLE_RIGHT) {\n            color = fill;\n        }       \n    }\n}\n\nvoid drawBorder(inout vec3 color, vec2 fragCoord, vec2 position, vec2 size)\n{   \n    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&\n        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {\n        \n        if (fragCoord.x >= position.x + BORDER_WIDTH &&\n            fragCoord.x < (position.x + size.x - BORDER_WIDTH) &&\n            fragCoord.y >= position.y + BORDER_WIDTH &&\n            fragCoord.y < (position.y + size.y - BORDER_WIDTH)) {\n            // Interior\n        }\n        else if (fragCoord.x >= position.x + BORDER_WIDTH - 1.0 &&\n                 fragCoord.x < (position.x + size.x - BORDER_WIDTH + 1.0) &&\n                 fragCoord.y >= position.y + BORDER_WIDTH - 1.0 &&\n                 fragCoord.y < (position.y + size.y - BORDER_WIDTH + 1.0)) {\n            color = vec3(0.0, 0.0, 0.0);\n        }\n        else {        \n            color = vec3(193.0/255.0, 193.0/255.0, 193.0/255.0);\n        \n            // Overall border\n            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, position, size);\n            \n            // Bottom-left\n            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, position, vec2(23.0, 23.0));\n            \n            // Top-left\n            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, vec2(position.x, position.y + size.y - 23.0), vec2(23.0, 23.0));\n            \n            // Bottom-left\n            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, vec2(position.x + size.x - 23.0, position.y), vec2(23.0, 23.0));\n            \n            // Top-left\n            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, vec2(position.x + size.x - 23.0, position.y + size.y - 23.0), vec2(23.0, 23.0));\n        }        \n    }\n}\n\nvoid drawSystemButton(inout vec3 color, vec2 fragCoord, vec2 position, vec2 size, int type)\n{\n    drawBox(color, BORDER_FILL, BORDER_STROKE, fragCoord, position, size);\n    \n    if (type != SYSTEM_BUTTON_MENU) {\n        // Draw Bevel\n        drawBevel(color, BUTTON_HIGHLIGHT, BUTTON_SHADOW, fragCoord, position + vec2(1.0, 1.0), size - vec2(2.0, 2.0));\n        drawBevel(color, BORDER_FILL, BUTTON_SHADOW, fragCoord, position + vec2(2.0, 2.0), size - vec2(4.0, 4.0));\n    }\n    \n    if (type == SYSTEM_BUTTON_MENU) {\n        // Draw wacky minus sign thingy\n        drawBox(color, vec3(1.0, 1.0, 1.0), BUTTON_SHADOW, fragCoord, position + vec2(4.0, 8.0), vec2(13.0, 3.0));\n        drawBox(color, vec3(1.0, 1.0, 1.0), BORDER_STROKE, fragCoord, position + vec2(3.0, 9.0), vec2(13.0, 3.0));\n    }\n    else if (type == SYSTEM_BUTTON_MINIMIZE) {\n        // Draw Downward Facing Triangle... which is somehow not a yoga position\n        drawTriangle(color, BORDER_STROKE, fragCoord, position + vec2(6.0, size.y - 15.0), vec2(7.0, 7.0), TRIANGLE_DOWN);\n    }\n    else if (type == SYSTEM_BUTTON_MAXIMIZE) {\n        // Draw Upward Facing Triangle... which is somehow not a yoga position\n        drawTriangle(color, BORDER_STROKE, fragCoord, position + vec2(6.0, size.y - 11.0), vec2(7.0, 7.0), TRIANGLE_UP);\n    }\n}\n\nvoid drawTitle(inout vec3 color, vec2 fragCoord, vec2 position, vec2 size)\n{\n    // Draw title bar box\n    drawBox(color, TITLE_FILL, BORDER_STROKE, fragCoord, position, size);\n    \n    // Draw system buttons\n    drawSystemButton(color, fragCoord, position, vec2(size.y, size.y), SYSTEM_BUTTON_MENU);\n    drawSystemButton(color, fragCoord, vec2(position.x + size.x - size.y - size.y + 1.0, position.y),\n                                       vec2(size.y, size.y), SYSTEM_BUTTON_MINIMIZE);\n    drawSystemButton(color, fragCoord, vec2(position.x + size.x - size.y, position.y),\n                                       vec2(size.y, size.y), SYSTEM_BUTTON_MAXIMIZE);\n}\n\nvoid drawWindow(inout vec3 color, vec2 fragCoord, vec2 position, vec2 size)\n{\n    // Normalize to screen coords\n    position.y = iResolution.y - size.y - position.y;\n    \n    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&\n        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {\n                \n        color += (BAYER_MATRIX(fragCoord - position, ResolutionDivisor) - 0.5) * (0.99);\n\n        vec3 quantizationPeriod = vec3(1.0 / PaletteRGBSize);\n\n        color = vec3(\n            quantize(color.r, quantizationPeriod.r),\n            quantize(color.g, quantizationPeriod.g),\n            quantize(color.b, quantizationPeriod.b)\n        );\n\n        vec2 titleSize = vec2(size.x - (BORDER_WIDTH * 2.0) + 2.0, 20.0);\n        vec2 titlePos = vec2(position.x + BORDER_WIDTH - 1.0, position.y + size.y - titleSize.y - BORDER_WIDTH + 1.0);\n        drawTitle(color, fragCoord, titlePos, titleSize);\n        \n        drawBorder(color, fragCoord, position, size);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n\tvec4 tex = texture(iChannel0, uv);\n\tvec3 color = tex.xyz;\n    //vec3 color = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Position and size of the window (depends on time)\n    vec2 windowPos = vec2(iTime, iTime) / 3.0;\n    vec2 windowSize = vec2(floor(iResolution.y / 2.), floor(iResolution.y / 2.));\n    \n    // Craft our 'fake' screen that is twice the size of our real one\n    vec2 screenSize = vec2(iResolution.x/iResolution.y, 1.) * 2.0;\n    \n    // How big the window is relative to the normal screen\n    vec2 windowSpace = vec2(windowSize.x / iResolution.x, windowSize.y / iResolution.y);\n\n    // The size of the area in which the box can bounce (on the 'fake' screen)\n    vec2 size = screenSize - windowSpace * 2.0;\n    \n    // Remap so (0,0) is bottom left, and (1,1) is top right\n    windowPos = windowPos / size + 0.5;\n    \n    // Constrict movement within the 'normal' screen\n    // We determine how many 'double screens' the object moved\n    // (It loops every time it moves the distance of two screens.)\n    vec2 flip = mod(floor(windowPos), 2.0);\n    \n    // And then subtract the amount it would have moved on the real screen if it\n    // looped on the real resolution... this has it 'bounce' on the edges.\n    windowPos = abs(flip - mod(windowPos, 1.0));\n    \n    // Return to the screen coordinate space\n    windowPos *= vec2(iResolution) - windowSize;\n    windowPos = floor(windowPos);\n    \n    // Draw the window\n    drawWindow(color, fragCoord, windowPos, windowSize);\n\n    // Output the color\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This itself is from: https://www.shadertoy.com/view/ld2yDz\n// I added the gradient background for more variety and slowed\n// down the cube's rotation.\n// The original comments and code follow\n// ----------------------------------------------------------\n\n// 6 shaders mapped on the 6 faces of a cube without any buffer\n//\n// Coded because I love cubes (don't ask me why)\n// and also love the retro amiga scene.\n//\n// The six shaders I love and I used here:\n//\n// Face 1: WWDC14 by capnslipp - https://www.shadertoy.com/view/XdfyRB\n// Face 2: Plasma by Klk - https://www.shadertoy.com/view/XsVSzW\n// Face 3: YaraGui by dila - https://www.shadertoy.com/view/ldlyWS\n// Face 4: Combustible Voronoi by Shane - https://www.shadertoy.com/view/4tlSzl\n// Face 5: Ring twister by Flyguy - https://www.shadertoy.com/view/Xt23z3\n// Face 6: Glenz by myself - https://www.shadertoy.com/view/4lt3R7 \n//\n// The rasterization is from: https://www.shadertoy.com/view/MdS3Rz by Hlorenzi\n// The sinus croll is by myself improved by gPlatl\n//\n// Tune is from the game Xenon2 on Amiga\n\n\nvec3 xcolor = vec3(0.2, 0.5, 1.0);\nvec2 xtp  = vec2(0);  // text position\nvec2 xpos;\nfloat tau = atan(1.0) * 8.0;\nfloat pi = atan(1.0) * 4.0;\nfloat aaSize = 0.0;\nvec3 cubevec;\n\n#define FONT_SIZE1 0.45\n#define FONT_SIZE2 0.3\n#define FONT_SPACE 0.42\n#define SIN_FREQ 0.75\n#define SIN_SPEED 3.0\n#define SCROLL_LEN 65.\n#define SCROLL_SPEED 2.0\n#define SIN_AMP 0.5\n#define S(a) c+=char(float(a)); xtp.x-=FONT_SPACE;\n#define xtime iTime\n#define NUM_FACES 4\n#define IN_RADIUS 0.25\n#define OUT_RADIUS 0.70\n#define XSCROLL_SPEED -0.9\n#define COLOR_1 0.50, 0.90, 0.95\n#define COLOR_2 0.95, 0.60, 0.10\n\nvec3 calcSine(vec2 uv, float frequency, float amplitude, float shift, float offset, vec3 color, float width, float exponent)\n{\n    float y = sin(iTime * frequency + shift + uv.x) * amplitude + offset;\n    float d = distance(y, uv.y);\n    float scale = smoothstep(width, 0.0, distance(y, uv.y));\n    return color * scale;\n}\n\nvec3 Bars(vec2 uv)\n{\n    //vec2 uv = f / iResolution.xy;\n    vec3 color = vec3(0.0);\n    color += calcSine(uv, 2.0, 0.25, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.1, 3.0);\n    color += calcSine(uv, 2.6, 0.15, 0.2, 0.5, vec3(0.0, 1.0, 0.0), 0.1, 1.0);\n    color += calcSine(uv, 0.9, 0.35, 0.4, 0.5, vec3(1.0, 0.0, 0.0), 0.1, 1.0);\n    return color;\n}\n\nvec3 Twister(vec3 p)\n{\n    float f = sin(iTime/3.)*1.45;\n    float c = cos(f*p.y);\n    float s = sin(f/2.*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat Cube( vec3 p )\n{\n    p=Twister(p);\n    cubevec.x = sin(iTime) / 0.5;\n    cubevec.y = cos(iTime) / 0.5;\n    mat2 m = mat2( cubevec.y, -cubevec.x, cubevec.x, cubevec.y );\n    p.xy *= m;p.xy *= m;p.yz *= m;p.zx *= m;p.zx *= m;p.zx *= m;\n    cubevec = p;\n    return length(max(abs(p)-vec3(0.4),0.0))-0.08;\n}\n\nfloat Face( vec2 uv )\n{\n        uv.y = mod( uv.y, 1.0 );\n        return ( ( uv.y < uv.x ) != ( 1.0 - uv.y < uv.x ) ) ? 1.0 : 0.0;\n}\n\nvec3 getNormal( in vec3 p )\n{\n    vec2 e = vec2(0.005, -0.005);\n    return normalize(\n        e.xyy * Cube(p + e.xyy) +\n        e.yyx * Cube(p + e.yyx) +\n        e.yxy * Cube(p + e.yxy) +\n        e.xxx * Cube(p + e.xxx));\n}\n\nvec4 Glenz(in vec2 uv )\n{\n    float pat = iTime*5.0;\n    float Step = 1.0;\n    float Distance = 0.0;\n    float Near = -1.0;\n    float Far = -1.0;\n    vec3 lightPos = vec3(1.5, 0, 0);\n    vec2 p = -1.0 + uv *2.0;\n    vec2 kp=uv;\n    vec4 m = iMouse / iResolution.xxxx;\n    float hd=-1.;\n    \n    vec3 ro = vec3( 0.0, 0.0, 2.1 );\n    vec3 rd = normalize( vec3( p, -2. ) );\n    for( int i = 0; i < 256; i++ )\n        {\n        \tStep = Cube( ro + rd*Distance );\n            Distance += Step*.5;\n\n            if( Distance > 4.0 ) break;\n            if( Step < 0.001 )\n            \t{\n                 \tFar = Face( cubevec.yx ) + Face( -cubevec.yx ) + Face( cubevec.xz ) + Face( -cubevec.xz ) + Face( cubevec.zy ) + Face( -cubevec.zy );\n            \t\tif(hd<0.) hd=Distance;\n                    if( Near < 0.0 ) Near = Far;\n            \t\tif(m.z<=0.0) Distance += 0.05; else break; // 0.05 is a magic number \n                }\n        }\n\n    vec3 Color=Bars(uv);\n    if( Near > 0.0 )\n    \t{\n            vec3 sp = ro + rd*hd;\n        \tvec3 ld = lightPos - sp;\n            float lDist = max(length(ld), 0.001);\n            ld /= lDist;\n            float atten = 1./(1. + lDist*.2 + lDist*.1); \n            float ambience = 0.7;\n            vec3 sn = getNormal( sp);\n            float diff = min(0.3,max( dot(sn, ld), 0.0));\n            float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n            if(m.z<=0.) Color = Color/5. + mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            else Color = mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            Color = Color*(diff+ambience)+vec3(0.78,0.5,1.)*spec/1.5;\n        }\n    return vec4( Color, 1.0 );\n}\n\n\n\nvec4 slice(float x0, float x1, vec2 uv)\n{\n    float u = (uv.x - x0)/(x1 - x0);\n    float w = (x1 - x0);\n    vec3 col = vec3(0);\n    col = mix(vec3(COLOR_1), vec3(COLOR_2), u);\n    col *= w / sqrt(2.0 * IN_RADIUS*IN_RADIUS * (1.0 - cos(tau / float(NUM_FACES))));\n    col *= smoothstep(0.05, 0.10, u) * smoothstep(0.95, 0.90, u) + 0.5;\n    uv.y += iTime * XSCROLL_SPEED; //Scrolling\n    col *= (-1.0 + 2.0 * smoothstep(-0.03, 0.03, sin(u*pi*4.0) * cos(uv.y*16.0))) * (1.0/16.0) + 0.7;\n    float clip = 0.0;\n    clip = (1.0-smoothstep(0.5 - aaSize/w, 0.5 + aaSize/w, abs(u - 0.5))) * step(x0, x1);\n    return vec4(col, clip);\n}\n\nvec4 Ring(in vec2 uv)\n{\n    aaSize = 2.0 / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n    vec2 uvr = vec2(length(uv), atan(uv.y, uv.x) + pi);\n    uvr.x -= OUT_RADIUS;\n    vec3 col = vec3(0.05);\n    float angle = uvr.y + 2.0*iTime + sin(uvr.y) * sin(iTime) * pi;\n    \n    for(int i = 0;i < NUM_FACES;i++)\n    {\n        float x0 = IN_RADIUS * sin(angle + tau * (float(i) / float(NUM_FACES)));\n        float x1 = IN_RADIUS * sin(angle + tau * (float(i + 1) / float(NUM_FACES)));\n        vec4 face = slice(x0, x1, uvr);\n        col = mix(col, face.rgb, face.a); \n    }\n\treturn vec4(col, 1.0);\n}\n\n\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i;\n    vec3 L = vec3(7.4, 5.6, 4.4);\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L);\n}\n\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat xvoronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n    \t\t\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\t\n\t    }\n\t}\n\t\n\treturn d;\n}\n\nfloat noiseLayers(in vec3 p) {\n    vec3 t = vec3(0., 0., p.z+iTime*1.5);\n\n    const int iter = 5;\n    float tot = 0., sum = 0., amp = 1.;\n\n    for (int i = 0; i < iter; i++) {\n        tot += xvoronoi(p + t) * amp;\n        p *= 2.0;\n        t *= 1.5;\n        sum += amp;\n        amp *= 0.5;\n    }\n    return tot/sum;\n}\n\nvec4 Voronoi(in vec2 uv )\n{\n    uv = uv * 2.0 - 1.0;\n\tuv += vec2(sin(iTime*0.5)*0.25, cos(iTime*0.5)*0.125);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/8.));\n\tfloat cs = cos(iTime*0.25), si = sin(iTime*0.25);\n\trd.xy = rd.xy*mat2(cs, -si, si, cs); \n\tfloat c = noiseLayers(rd*2.);\n\tc = max(c + dot(hash33(rd)*2.-1., vec3(0.015)), 0.);\n    c *= sqrt(c)*1.5;\n    vec3 col = firePalette(c);\n    col = mix(col, col.zyx*0.15+c*0.85, min(pow(dot(rd.xy, rd.xy)*1.2, 1.5), 1.));\n    col = pow(col, vec3(1.5));\n\treturn vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n\nfloat char(float ch)\n{\n  vec4 f = texture(iChannel0,clamp(xtp,0.,1.)/16.+fract(floor(vec2(ch,15.999-float(ch)/16.))/16.));\n  return f.x;\n}\n\nvec4 ScrollText(vec2 xuv)\n{\n    xtp = xuv / FONT_SIZE1;  // set font size\n    xtp.x = 2.0*(xtp.x -4. +mod(xtime*SCROLL_SPEED, SCROLL_LEN));\n    xtp.y = xtp.y +1.7 +SIN_AMP*sin(xtp.x*SIN_FREQ +xtime*SIN_SPEED);\n    float c = 0.0;\n    \n    S(32.);S(32.);S(32.);S(32.);S(32.);S(32.);S(72.);S(101.);S(108.);S(108.);S(111.);S(32.);\n    S(115.);S(104.);S(97.);S(100.);S(101.);S(114.);S(116.);S(111.);S(121.);S(32.);S(33.);S(33.);\n    S(32.);S(84.);S(104.);S(105.);S(115.);S(32.);S(105.);S(115.);S(32.);S(97.);S(32.);S(99.);\n    S(117.);S(98.);S(101.);S(32.);S(119.);S(105.);S(116.);S(104.);S(32.);S(97.);S(32.);S(115.);\n    S(104.);S(97.);S(100.);S(101.);S(114.);S(32.);S(109.);S(97.);S(112.);S(112.);S(101.);S(100.);\n    S(32.);S(111.);S(110.);S(32.);S(101.);S(97.);S(99.);S(104.);S(32.);S(102.);S(97.);S(99.);\n    S(101.);S(32.);S(99.);S(111.);S(100.);S(101.);S(100.);S(32.);S(105.);S(110.);S(32.);S(49.);\n    S(57.);S(57.);S(48.);S(32.);S(97.);S(109.);S(105.);S(103.);S(97.);S(32.);S(114.);S(101.);\n    S(116.);S(114.);S(111.);S(32.);S(115.);S(116.);S(121.);S(108.);S(101.);S(32.);S(46.);S(46.);\n    S(46.);S(46.);S(32.);S(73.);S(32.);S(106.);S(117.);S(115.);S(116.);S(32.);S(109.);S(105.);\n    S(120.);S(101.);S(100.);S(32.);S(115.);S(101.);S(118.);S(101.);S(114.);S(97.);S(108.);S(32.);\n    S(115.);S(104.);S(97.);S(100.);S(101.);S(114.);S(115.);S(32.);S(116.);S(111.);S(103.);S(101.);\n    S(116.);S(104.);S(101.);S(114.);S(32.);S(46.);S(46.);S(46.);S(46.);S(32.);S(82.);S(101.);\n    S(97.);S(100.);S(32.);S(116.);S(104.);S(101.);S(32.);S(99.);S(111.);S(100.);S(101.);S(32.);\n    S(102.);S(111.);S(114.);S(32.);S(99.);S(114.);S(101.);S(100.);S(105.);S(116.);S(115.);S(32.);\n    S(46.);S(46.);S(46.);S(46.);S(46.);S(32.);S(73.);S(32.);S(99.);S(111.);S(100.);S(101.);\n    S(100.);S(32.);S(116.);S(104.);S(105.);S(115.);S(32.);S(98.);S(101.);S(99.);S(97.);S(117.);\n    S(115.);S(101.);S(32.);S(73.);S(32.);S(108.);S(111.);S(118.);S(101.);S(32.);S(99.);S(117.);\n    S(98.);S(101.);S(115.);S(32.);S(97.);S(110.);S(100.);S(32.);S(65.);S(109.);S(105.);S(103.);\n    S(97.);S(32.);S(46.);S(46.);S(46.);S(46.);S(46.);S(32.);S(72.);S(105.);S(109.);S(114.);\n    S(101.);S(100.);S(32.);S(46.);S(46.);S(46.);S(46.);S(32.);S(69.);S(79.);S(84.);S(32.);\n    S(46.);S(46.);S(46.);S(46.);\n    return c * vec4(xpos, 0.5+0.5*sin(2.0*xtime),1.0);\n}\n\n\nvec4 Plasma(vec2 uv )\n{\n\tfloat time=iTime*1.0;\n\tuv = (uv-0.0)*6.0;\n    vec2 uv0=uv;\n\tfloat i0=1.0;\n\tfloat i1=1.0;\n\tfloat i2=1.0;\n\tfloat i4=0.0;\n\tfor(int s=0;s<7;s++)\n\t{\n\t\tvec2 r;\n\t\tr=vec2(cos(uv.y*i0-i4+time/i1),sin(uv.x*i0-i4+time/i1))/i2;\n        r+=vec2(-r.y,r.x)*0.3;\n\t\tuv.xy+=r;\n        \n\t\ti0*=1.93;\n\t\ti1*=1.15;\n\t\ti2*=1.7;\n\t\ti4+=0.05+0.1*time*i1;\n\t}\n    float r=sin(uv.x-time)*0.5+0.5;\n    float b=sin(uv.y+time)*0.5+0.5;\n    float g=sin((uv.x+uv.y+sin(time*0.5))*0.5)*0.5+0.5;\n\treturn vec4(r,g,b,1.0);\n}\n\nfloat sdBoxXY( vec3 p, vec3 b )\n{\n  vec2 d = abs(p.xy) - b.xy;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nmat2 rot(float x) {\n\treturn mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat map(vec3 p) {\n    float k = 0.5 * 2.0;\n\tvec3 q = (fract((p - vec3(0.25, 0.0, 0.25))/ k) - 0.5) * k;\n    vec3 s = vec3(q.x, p.y, q.z);\n    float d = udRoundBox(s, vec3(0.1, 1.0, 0.1), 0.05);\n    \n    k = 0.5;\n    q = (fract(p / k) - 0.5) * k;\n    s = vec3(q.x, abs(p.y) - 1.5, q.z);\n    float g = udRoundBox(s, vec3(0.17, 0.5, 0.17), 0.2);\n    \n    float sq = sqrt(0.5);\n    vec3 u = p;\n    u.xz *= mat2(sq, sq, -sq, sq);\n    d = max(d, -sdBoxXY(u, vec3(0.8, 1.0, 0.8)));\n    \n    return smin(d, g, 16.0);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvec4 Room(vec2 uv )\n{\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float gt = iTime / 5.0;\n    vec3 r = normalize(vec3(uv, 1.7 - dot(uv, uv) * 0.1));\n    float sgt = sin(gt * 3.141592 * 2.0);\n    r.xy *= rot(sgt * 3.141592 / 8.0);\n    r.xz *= rot(3.141592 * 0.0 + gt * 3.141592 * 2.0);\n    r.xz *= rot(3.141592 * -0.25);\n\n    vec3 o = vec3(0.0, 0.0, gt * 5.0 * sqrt(2.0) * 2.0);\n    o.xz *= rot(3.141592 * -0.25);\n\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    float fd = map(w);\n\n    vec3 col = vec3(0.514, 0.851, 0.933) * 0.5;\n    vec3 ldir = normalize(vec3(-1, -0.5, 1.1));\n\n    float fog = 1.0 / (1.0 + t * t * 0.1 + fd * 100.0);\n    float front = max(dot(r, -sn), 0.0);\n    float ref = max(dot(r, reflect(-ldir, sn)), 0.0);\n    float grn = pow(abs(sn.y), 3.0);\n\n    vec3 cl = vec3(grn);\n    cl += mix(col*vec3(1.5), vec3(0.25), grn) * pow(ref, 16.0);\n    cl = mix(col, cl, fog);\n\n\treturn vec4(cl, 1.0);\n}\n\nvec4 t(vec2 uv)\n{\n    float j = sin(uv.y * 3.14 + iTime * 5.0);\n    float i = sin(uv.x * 15.0 - uv.y * 2.0 * 3.14 + iTime * 3.0);\n    float n = -clamp(i, -0.2, 0.0) - 0.0 * clamp(j, -0.2, 0.0);\n    return 3.5 * (vec4(xcolor, 1.0) * n);\n}\n\nvec4 Twirl(vec2 p)\n{\n    vec2 uv;\n    p=-1.+2.*p;\n    \n    float r = sqrt(dot(p, p));\n    float a = atan(\n        p.y * (0.3 + 0.1 * cos(iTime * 2.0 + p.y)),\n        p.x * (0.3 + 0.1 * sin(iTime + p.x))\n    ) + iTime;\n    \n    uv.x = iTime + 1.0 / (r + .01);\n    uv.y = 4.0 * a / 3.1416;\n    \n    return mix(vec4(0.0), t(uv) * r * r * 2.0, 1.0);\n}\n\nvec4 MetaShader(vec2 uv,int shader)\n{\nif(uv.x<0.005 || uv.y<0.005 || uv.x>0.995 || uv.y>0.995) return vec4(0.8,0.8,0.8,1.);   \nif(shader==0) return Twirl(uv);\nif(shader==1) return Plasma(uv);\nif(shader==2) return Room(uv);\nif(shader==3) return Voronoi(uv);\nif(shader==4) return Ring(uv);\nif(shader==5) return Glenz(uv);\nreturn vec4(0);\n}\n\nvec4 inTriangle(vec2 p0, vec2 p1, vec2 p2, vec2 p)\n{\n\tfloat a = 0.5*(-p1.y*p2.x + p0.y*(-p1.x + p2.x) + p0.x*(p1.y - p2.y) + p1.x*p2.y);\n\tfloat s = 1.0/(2.0*a)*(p0.y*p2.x - p0.x*p2.y + (p2.y - p0.y)*p.x + (p0.x - p2.x)*p.y);\n\tfloat t = 1.0/(2.0*a)*(p0.x*p1.y - p0.y*p1.x + (p0.y - p1.y)*p.x + (p1.x - p0.x)*p.y);\n\t\n\tif (s > 0.0 && t > 0.0 && 1.0 - s - t > 0.0) {\n\t\treturn vec4(1.0,s,t,1.0-s-t);\n\t} else {\n\t\treturn vec4(0.0,s,t,1.0-s-t);\n\t}\n}\n\nvoid triangle(inout vec4 c, vec2 p, int shader, vec3 p0, vec3 p1, vec3 p2, vec2 t0, vec2 t1, vec2 t2)\n{\n\tfloat rx = iTime/3.;\n\tfloat ry = iTime;\n\tfloat rz = iTime;\n\t\n\tfloat cx = cos(rx); float sx = sin(rx);\n\tfloat cy = cos(ry); float sy = sin(ry);\n\tfloat cz = cos(rz); float sz = sin(rz);\n\t\n\tmat4 transform1 =\n\t\tmat4(1, 0, 0, 0,\n      \t\t 0, 1, 0, 0,\n      \t\t 0, 0, 1, 0,\n\t\t\t 0, 0, -2.5, 1);\n\t\n\tmat4 transform2 =\n\t\tmat4(cz*cy, -sz*cy, sy, 0,\n\t\t\t sz*cx + cz*sy*sx, cz*cx - sz*sy*sx, -cy*sx, 0,\n\t\t\t sz*sx - cz*sy*cx,cz*sx + sz*sy*cx, cy*cx, 0,\n\t\t\t 0, 0, 0, 1);\n\t\n\tfloat n = 1.0;\n\tfloat f = 10.0;\n\tfloat r = 1.0 * iResolution.x / iResolution.y;\n\tfloat t = 1.0;\n\tmat4 projection =\n\t\tmat4(n/r, 0, 0, 0,\n      \t\t 0, n/t, 0, 0,\n      \t\t 0, 0, -(f+n)/(f-n), -1,\n\t\t\t 0, 0, -(2.0*f*n)/(f-n), 0);\n\t\n\tvec4 pt0 = vec4(0,0,0,0);\n\tvec4 pt1 = vec4(0,0,0,0);\n\tvec4 pt2 = vec4(0,0,0,0);\n\t\n\tpt0 = projection * transform1 * transform2 * vec4(p0,1);\n\tpt1 = projection * transform1 * transform2 * vec4(p1,1);\n\tpt2 = projection * transform1 * transform2 * vec4(p2,1);\n\t\n\t\n\tvec4 test = inTriangle(pt0.xy / pt0.w, pt1.xy / pt1.w, pt2.xy / pt2.w, p);\n\t\n\tif (test.x != 0.0) {\n\t\tfloat z = ((pt1.z * test.y) / pt1.w +\n\t\t\t\t   (pt2.z * test.z) / pt2.w +\n\t\t\t\t   (pt0.z * test.w) / pt0.w) /\n\t\t\t\t\t(test.y / pt1.w +\n\t\t\t\t\t test.z / pt2.w +\n\t\t\t\t\t test.w / pt0.w);\n\t\tif (z < c.w) {\n\t\t\tfloat tx = ((t1.x * test.y) / pt1.w +\n\t\t\t\t\t\t(t2.x * test.z) / pt2.w +\n\t\t\t\t\t\t(t0.x * test.w) / pt0.w) /\n\t\t\t\t\t   (test.y / pt1.w +\n\t\t\t\t\t\ttest.z / pt2.w +\n\t\t\t\t\t\ttest.w / pt0.w);\n\t\t\t\n\t\t\tfloat ty = ((t1.y * test.y) / pt1.w +\n\t\t\t\t\t\t(t2.y * test.z) / pt2.w +\n\t\t\t\t\t\t(t0.y * test.w) / pt0.w) /\n\t\t\t\t\t   (test.y / pt1.w +\n\t\t\t\t\t\ttest.z / pt2.w +\n\t\t\t\t\t\ttest.w / pt0.w);\n\n            c=MetaShader(vec2(tx,ty),shader);\n            c.w=z;\n\t\t}\n\t}\n}\n\nvec4 pixel(vec2 p, vec4 color)\n{\n\ttriangle(color,p,0,vec3(-1,-1,-1),vec3(1,-1,-1), vec3(-1,1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,0,vec3(1,-1,-1),vec3(1,1,-1),vec3(-1,1,-1),vec2(1,0),vec2(1,1),vec2(0,1));\t\n\ttriangle(color,p,1,vec3(1,1,1),vec3(-1,1,1),vec3(1,-1,1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,1,vec3(-1,1,1),vec3(-1,-1,1),vec3(1,-1,1),vec2(1,0),vec2(1,1),vec2(0,1));   \n    triangle(color,p,2,vec3(-1,1,-1),vec3(-1,1,1),vec3(-1,-1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,2,vec3(-1,1,1),vec3(-1,-1,1),vec3(-1,-1,-1),vec2(1,0),vec2(1,1),vec2(0,1));\t\n    triangle(color,p,3,vec3(1,1,-1),vec3(1,1,1),vec3(1,-1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,3,vec3(1,1,1),vec3(1,-1,1),vec3(1,-1,-1),vec2(1,0),vec2(1,1),vec2(0,1));   \n    triangle(color,p,4,vec3(-1,1,-1),vec3(-1,1,1),vec3(1,1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,4,vec3(-1,1,1),vec3(1,1,1),vec3(1,1,-1),vec2(1,0),vec2(1,1),vec2(0,1));\n    triangle(color,p,5,vec3(-1,-1,-1),vec3(-1,-1,1),vec3(1,-1,-1),vec2(0,0),vec2(1,0),vec2(0,1));\n\ttriangle(color,p,5,vec3(-1,-1,1),vec3(1,-1,1),vec3(1,-1,-1),vec2(1,0),vec2(1,1),vec2(0,1));   \n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec4 color = mix(vec4(0.0, 0.0, 1.0, 1000), vec4(0.0, 0.0, 0.0, 1000), 1.0 - (fragCoord.y / iResolution.y));\n\tuv = uv * 2.0 - vec2(1.0,1.0);\n\tfragColor = pixel(uv, color);\n    xpos = fragCoord.xy / iResolution.xy; //  0 .. 1\n    vec4 sc = 2.*ScrollText(uv);\n    fragColor+=sc;\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfXRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[929, 929, 970, 970, 1026], [1028, 1028, 1079, 1079, 2003], [2006, 2006, 2057, 2057, 5000], [5002, 5002, 5100, 5100, 5563], [5565, 5565, 5670, 5670, 6139], [6141, 6141, 6246, 6246, 7078], [7080, 7080, 7157, 7157, 9022], [9024, 9024, 9117, 9117, 10329], [10331, 10331, 10407, 10433, 10994], [10996, 10996, 11073, 11107, 12002], [12004, 12004, 12061, 12111, 13744]], "test": "untested"}
{"id": "NslSRn", "name": "Evolutionary Cellular Automata", "author": "cornusammonis", "description": "An evolutionary cellular automata with neural network rules and reaction-diffusion pheromones.", "tags": ["diffusion", "automata", "evolution", "cellular", "reaction", "neural", "network"], "likes": 41, "viewed": 1012, "published": 3, "date": "1618187752", "time_retrieved": "2024-07-30T19:26:58.504905", "image_code": "/*\n    \n    *Hit SPACE to reset with new initial conditions.*\n    \n    Typical cellular automata systems have fixed rulesets that are set once at\n    initialization. This is an implementation of an Evolutionary Cellular Automata,\n    in which rulesets are randomized at initialization, and are modified over time\n    via an evolutionary process.\n    \n    In this implementation, cells can reproduce via sexual or asexual reproduction,\n    i.e. they can produce offspring by randomly swapping genes with a genetically-\n    related cell, or by producing a cloned offspring with random mutations.\n    Speciation is implemented here using a fixed threshold representing the maximum\n    genetic distance between two cells, under which two cells will be considered the\n    same species and are allowed to cross-breed. If two neighboring cells are above\n    the speciation threshold, they are considered to be competing species, and\n    movement by one cell into the territory of a competing species is interpreted as\n    an attempt to capture the territory for the attacking species, placing a mutated\n    offspring into the captured position if the attack is successful. Attack success\n    is deterministic, and will succeed if the sum of energy expended by attackers\n    entering a cell is larger than the sum of energy expended by defenders entering\n    or remaining in a cell.\n    \n    Rules are implemented using a simple neural network, which takes as input the \n    current 3x3 neighbor state grid, and the current 3x3 \"pheromone\" state grid.\n    Input and output layer weights are fixed, and hidden layer weights are encoded\n    in each cell's genetic code. Cell output is represented as the amount of \"energy\"\n    expended by the cell and placed into neighboring cells in order to take neighboring\n    cell positions (similar to the rules of the game \"Risk\"). In order to increase\n    the diversity of cell movement, a \"rotation\" parameter, controllable by neural\n    network output, can rotate the cell energy output positions.\n    \n    Each gene is an 8-bit value, represented as fixed point decimal number in the\n    range (-1,1). Two buffers store cell genes, and resolution of the cell grid is\n    cut in half, so that each of the two buffers can store 4 pixels for each cell\n    with genetic information. In total, this is \n    (2 buffers) * (4 pixels) * (4 float32s) * (4 int8s) = 128 genes per cell.\n    \n    Pheromones are implemented in Reaction-Diffusion fashion, with cells updating the\n    current (vec4) pheromone values by adding or subtracting some quantity according to\n    each cell's rules. Pheromones are diffused at a constant rate.\n    \n    Cell color is determined by a linear projection of the genetic code. Dissimilar\n    species may sometimes end up with similar colors by coincidence. The brightness\n    of a cell is determined by its energy level.\n    \n    A few other rendering modes are available:\n    \n    KEY   FUNCTION\n    A     Show species boundaries. Blue = Same species, Red = Boundary between different species\n    Z     Show pheromone levels (Projected from 4 components to 3 (RGB)).\n    W     Show raw genetic average, used to calculate coloring.\n    S     Show neural network activations.\n    Space Reset.\n    \n    I have had this cellular automata system kicking around for a few years, and I have\n    tried a variety of different neural network and genetic encoding configurations.\n    This particular one has yielded the most interesting results. Many other configurations are\n    possible, even within the limitations of Shadertoy, and even if, in theory, these\n    various configurations may be equivalent given the right choice of parameters in the\n    genetic code, the bias towards one type of behavior or another introduced by these \n    initial configurations results in divergent outcomes. \n*/\n#define iRes ivec2(iResolution.xy)\n\nivec2 pm(ivec2 i) {\n    return pm(i,ivec2(iResolution.xy));\n}\n\n#define C(v) texelFetch(iChannel2, pm(iuv_base + (v)), 0)\n#define D(u,v) texelFetch(iChannel0, pm(u + (v)), 0)\n#define D0(u,v) texelFetch(iChannel0, pm(u + (v)), 0)\n#define D1(u,v) texelFetch(iChannel1, pm(u + (v)), 0)\n\n\nfloat neighbor_dist(ivec2 iuv_base, ivec2 attacker_position) {\n\treturn neighbor_dist(iChannel0, iChannel1, iuv_base, attacker_position, iRes);\n}\n\nbool neighbor_is_friendly(ivec2 iuv_base, ivec2 attacker_position) {\n\t return neighbor_is_friendly(iChannel0, iChannel1, iuv_base, attacker_position, iRes);   \n}\n\nbool Q() {\n    return texture(iChannel3, vec2(KEY_Q, 1.0) ).x > 0.5;\n}\n\nbool A() {\n    return texture(iChannel3, vec2(KEY_A, 1.0) ).x > 0.5;\n}\n\nbool Z() {\n    return texture(iChannel3, vec2(KEY_Z, 1.0) ).x > 0.5;\n}\n\nbool W() {\n    return texture(iChannel3, vec2(KEY_W, 1.0) ).x > 0.5;\n}\n\nbool S() {\n    return texture(iChannel3, vec2(KEY_S, 1.0) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    ivec2 iuv = ivec2(U);\n    ivec2 iuv_off  = iuv & ivec2(1u);\n    ivec2 iuv_base = iuv - iuv_off;\n    \n\t//vec2 uv = (U - mod(floor(U),2.) )/ iResolution.xy;\n    //vec2 tx = 1.0 / iResolution.xy;\n    \n    vec4 d0 = texelFetch(iChannel0, iuv_base, 0);\n    vec4 d1 = texelFetch(iChannel0, iuv_base + ivec2(1,0), 0);\n    vec4 d2 = texelFetch(iChannel0, iuv_base + ivec2(1,1), 0);\n    vec4 d3 = texelFetch(iChannel0, iuv_base + ivec2(0,1), 0);\n    vec4 d4 = texelFetch(iChannel1, iuv_base, 0);\n    vec4 d5 = texelFetch(iChannel1, iuv_base + ivec2(1,0), 0);\n    vec4 d6 = texelFetch(iChannel1, iuv_base + ivec2(1,1), 0);\n    vec4 d7 = texelFetch(iChannel1, iuv_base + ivec2(0,1), 0);\n    \n\n    \n    vec4 u = texelFetch(iChannel2, iuv_base, 0);\n    \n    vec4 ravg = unpack(d0.x) + unpack(d1.x) +\n        \t\tunpack(d0.y) + unpack(d1.y) + \n        \t\tunpack(d0.z) + unpack(d1.z) + \n        \t    unpack(d0.w) + unpack(d1.w) + \n                unpack(d2.x) + unpack(d3.x) +\n                unpack(d2.y) + unpack(d3.y) +\n                unpack(d2.z) + unpack(d3.z) +\n                unpack(d2.w) + unpack(d3.w) +\n        \t\tunpack(d4.x) + unpack(d5.x) +\n        \t\tunpack(d4.y) + unpack(d5.y) + \n        \t\tunpack(d4.z) + unpack(d5.z) + \n        \t    unpack(d4.w) + unpack(d5.w) + \n                unpack(d6.x) + unpack(d7.x) +\n                unpack(d6.y) + unpack(d7.y) +\n                unpack(d6.z) + unpack(d7.z) +\n                unpack(d6.w) + unpack(d7.w);\n\n    vec4 col = clamp(0.05 * ravg + 0.5, 0.0, 1.0);\n    \n    vec3 hsv = rgb2hsv(col.xyz);\n    hsv.z = clamp(1.0 * u.x,0.0,1.0);\n    hsv.y = clamp(hsv.y * 2.0,0.0,1.0);\n    \n\n\n    vec4 receive_state = C(ivec2(0));\n\n    //bool attacker_success = is_attack_successful(receive_state.y);\n    ivec2 attacker_position = 2*ivec2(receive_state.yz);\n\n\n\n    if (A()){\n        \n        ivec2 offsets[8] = ivec2[](ivec2(-2, 2),ivec2( 0, 2),ivec2( 2, 2),ivec2( 2, 0),\n                                   ivec2( 2,-2),ivec2( 0,-2),ivec2(-2,-2),ivec2(-2, 0));\n\t\tfloat dist = 0.0;\n        for (int i = 0; i < 8; i++) {\n        \tdist += neighbor_dist(iuv_base, offsets[i]);\n        }\n        \n        dist /= (8.0 * SPECIATION_THRESHOLD);       \n        fragColor = mix(vec4(0,0,1,1),vec4(1,0,0,1), 0.5 * (dist - 1.0) + 0.5);\n    } else if (Z()){\n        vec4 ph = unpack(u.w);\n        vec4 sc0 = normalize(vec4(0.5,0.7,0.1,0.1));\n        vec4 sc1 = normalize(vec4(0.2,0.3,0.6,0.2));\n        vec4 sc2 = normalize(vec4(0.3,0.1,0.3,0.7));\n        vec4 ra = 0.5+0.8*vec4(dot(sc0,ph),dot(sc1,ph),dot(sc2,ph),0.0);\n        fragColor = 0.5 + 0.5 * ra;\n    } else if (W()) {\n        fragColor = 0.2 * ravg + 0.5;\n    } else if (S()) {\n        vec2 packedL2 = texelFetch(iChannel2, iuv_base, 0).yz;\n        vec4 unpackedL2_0 = unpack(packedL2.x);\n        vec4 unpackedL2_1 = unpack(packedL2.y);\n        fragColor = 2.0 * (unpackedL2_0 + unpackedL2_1);\n    \t//fragColor = vec4(0.5 + 0.5 * texelFetch(iChannel2, iuv_base, 0).yz,0.5,0);\n    } else {\n    \tfragColor = vec4(hsv2rgb(hsv),1);\n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define T(i,j) texelFetch(iChannel0, pm(iuv + 2 * ivec2(i,j)), 0).x\n#define Q(i,j) unpack(texelFetch(iChannel2, pm(iuv + 2 * ivec2(i,j)), 0).w)\n#define R() texelFetch(iChannel0, ivec2(0), 0).y\n#define D0(u,v) texelFetch(iChannel1, pm(u + (v)), 0)\n#define D1(u,v) texelFetch(iChannel3, pm(u + (v)), 0)\n#define iRes (2*(ivec2(iResolution.xy)/2))\n\nivec2 pm(ivec2 i) {\n    return pm(i,iRes);\n}\n\nbool reset() {\n    return R() == 3.0;\n}\n\nbool neighbor_is_friendly(ivec2 iuv_base, ivec2 attacker_position) {\n\t return neighbor_is_friendly(iChannel1, iChannel3, iuv_base, attacker_position, iRes);   \n}\n\nfloat neighborhoods(mat3 m, ivec2 iuv, out mat3 a, out mat3 b) {\n    ivec2 offsets[8] = ivec2[](ivec2(-2, 2),ivec2( 0, 2),ivec2( 2, 2),ivec2( 2, 0),\n                               ivec2( 2,-2),ivec2( 0,-2),ivec2(-2,-2),ivec2(-2, 0));\n    ivec2 matpos[8]  = ivec2[](ivec2(0, 0),ivec2(1, 0),ivec2(2, 0),ivec2(2, 1),\n                               ivec2(2, 2),ivec2(1, 2),ivec2(0, 2),ivec2(0, 1));\n    a = mat3(0); b = mat3(0);\n    float friends = 0.0;\n    \n    for (int i = 0; i < 8; i++) {\n       \n        bool friend = neighbor_is_friendly(iuv, offsets[i]);\n        ivec2 mi = matpos[i];\n        if (friend) {\n            friends+=1.0;\n        \ta[mi.x][mi.y] = m[mi.x][mi.y];\n        } else {\n            b[mi.x][mi.y] = m[mi.x][mi.y];\n        }\n    }\n    \n    a[1][1] = m[1][1];\n    \n    return friends;\n}\n\n#define TWO_PI 6.28318530718\n\nvoid rot_neighbors(inout vec4 n0, inout vec4 n1, vec2 r) {\n    float n[8] = float[](n0.x, n0.y, n0.z, n0.w, n1.x, n1.y, n1.z, n1.w);\n    float m[8] = float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n    float off = r == vec2(0) ? 0.0 : fract(32.0 * (0.5 + atan(r.y,r.x) / TWO_PI));\n    int ioff = int(8.0 * off);\n    float fr = fract(8.0 * off);\n    \n    \n    for (int i = 0; i < 8; i++) {\n\t\tfloat n_left  = n[pm(i + ioff, 8)];\n        float n_right = n[pm(i + ioff + 1, 8)];\n        float n_mix = mix(n_left, n_right, fr);\n        m[i] = n_mix;\n    }\n    \n    n0 = vec4(m[0],m[1],m[2],m[3]);\n    n1 = vec4(m[4],m[5],m[6],m[7]);\n    \n}\n\n\nvec4 relu(vec4 x) {\n    x = clamp(x, -80.0, 80.0);\n\treturn log(1.0 + exp(x));    \n}\n\nvec2 relu(vec2 x) {\n    x = clamp(x, -80.0, 80.0);\n\treturn log(1.0 + exp(x));    \n}\n\nfloat relu(float x) {\n    x = clamp(x, -80.0, 80.0);\n\treturn log(1.0 + exp(x));    \n}\n\n#define SCALE 3.0\nvec4 sigm(vec4 x) {\n    x = clamp(x, -80.0, 80.0);\n\treturn SCALE * tanh(x);    \n}\n\nvec2 sigm(vec2 x) {\n    x = clamp(x, -80.0, 80.0);\n\treturn SCALE * tanh(x);    \n}\n\nfloat sigm(float x) {\n    x = clamp(x, -80.0, 80.0);\n\treturn SCALE * tanh(x);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    ivec2 iuv = ivec2(U);\n    ivec2 iuv_off  = iuv & ivec2(1u);\n    ivec2 iuv_base = iuv - iuv_off;\n    \n    float energy_here = T(0,0);\n    vec4 pheromones_here = Q(0,0);\n    \n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    \n    float q_c =  T( 0, 0);\n    float q_n =  T( 0, 1);\n    float q_e =  T( 1, 0);\n    float q_s =  T( 0,-1);\n    float q_w =  T(-1, 0);\n    float q_nw = T(-1, 1);\n    float q_sw = T(-1,-1);\n    float q_ne = T( 1, 1);\n    float q_se = T( 1,-1);\n\n    float lapl  = _K0*q_c + _K1*(q_n + q_e + q_w + q_s) + _K2*(q_nw + q_sw + q_ne + q_se);\n    \n    vec4 ph_c =  Q( 0, 0);\n    vec4 ph_n =  Q( 0, 1);\n    vec4 ph_e =  Q( 1, 0);\n    vec4 ph_s =  Q( 0,-1);\n    vec4 ph_w =  Q(-1, 0);\n    vec4 ph_nw = Q(-1, 1);\n    vec4 ph_sw = Q(-1,-1);\n    vec4 ph_ne = Q( 1, 1);\n    vec4 ph_se = Q( 1,-1);\n    \n    vec4 p_lapl  = _K0*ph_c + _K1*(ph_n + ph_e + ph_w + ph_s) + _K2*(ph_nw + ph_sw + ph_ne + ph_se);\n    \n    energy_here += ENERGY_BLUR_AMOUNT * lapl;\n    pheromones_here += vec4(0.15,0.3,0.6,1.2) * PHEROMONE_BLUR_AMOUNT * p_lapl;\n    \n    if (iuv_off != ivec2(0)) {\n    \tfragColor = vec4(0);    \n    } else if (iFrame<10 || reset()) {\n        fragColor = vec4(0.5,0,0,0);\n    \t//fragColor = vec4(random(U),0,0,0);\n\t} else if (is_dead(energy_here)) {\n    \tfragColor = vec4(energy_here,0,0,0);    \n    } else {\n\n        \n        mat3 mx  = mat3(-1.0,-2.0,-1.0,\n                         0.0, 0.0, 0.0,\n                         1.0, 2.0, 1.0);\n        \n        mat3 my  = mat3( 1.0, 0.0,-1.0,\n                         2.0, 0.0,-2.0,\n                         1.0, 0.0,-1.0);\n        \n        // output kernels\n        \n        \n        #ifdef SINGLE_OUTPUT\n        mat3 mo0 = mat3( 1.0, 0.0, 0.0,\n                         0.0, 0.0, 0.0,\n                         0.0, 0.0, 0.0);\n        \n        mat3 mo1 = mat3( 0.0, 1.0, 0.0,\n                         0.0, 0.0, 0.0,\n                         0.0, 0.0, 0.0);\n        \n        mat3 mo2 = mat3( 0.0, 0.0, 1.0,\n                         0.0, 0.0, 0.0,\n                         0.0, 0.0, 0.0);\n        \n        mat3 mo3 = mat3( 0.0, 0.0, 0.0,\n                         0.0, 0.0, 1.0,\n                         0.0, 0.0, 0.0);\n        \n        mat3 mo4 = mat3( 0.0, 0.0, 0.0,\n                         0.0, 0.0, 0.0,\n                         0.0, 0.0, 1.0);\n        \n        mat3 mo5 = mat3( 0.0, 0.0, 0.0,\n                         0.0, 0.0, 0.0,\n                         0.0, 1.0, 0.0);\n        \n        mat3 mo6 = mat3( 0.0, 0.0, 0.0,\n                         0.0, 0.0, 0.0,\n                         1.0, 0.0, 0.0);\n        \n        mat3 mo7 = mat3( 0.0, 0.0, 0.0,\n                         1.0, 0.0, 0.0,\n                         0.0, 0.0, 0.0);\n        \n        #else\n        mat3 mo0 = mat3(-0.5,-0.5,-0.5,\n                         1.0, 1.0, 1.0,\n                        -0.5,-0.5,-0.5);\n        \n        mat3 mo1 = mat3(-0.5, 1.0,-0.5,\n                        -0.5, 1.0,-0.5,\n                        -0.5, 1.0,-0.5);\n        \n        mat3 mo2 = mat3( 0.0, -0.75, 1.0,\n                        -0.75, 1.0, -0.75,\n                         1.0, -0.75, 0.0);\n        \n        mat3 mo3 = mat3( 1.0, -0.75, 0.0,\n                        -0.75, 1.0, -0.75,\n                         0.0, -0.75, 1.0);\n        \n        mat3 mo4 = mat3(-2.0,-1.0, 0.0,\n                        -1.0, 0.0, 1.0,\n                         0.0, 1.0, 2.0);\n        \n        mat3 mo5 = mat3( 0.0, 1.0, 2.0,\n                        -1.0, 0.0, 1.0,\n                        -2.0,-1.0, 0.0);\n        \n        mat3 mo6 = mat3( 1.0, 2.0, 1.0,\n                         0.0, 0.0, 0.0,\n                        -1.0,-2.0,-1.0);\n        \n        mat3 mo7 = mat3(-1.0, 0.0, 1.0,\n                        -2.0, 0.0, 2.0,\n                        -1.0, 0.0, 1.0);\n        #endif\n\n        mat3 mp0 = mat3(ph_nw.x, ph_w.x, ph_sw.x,\n                         ph_n.x, ph_c.x,  ph_s.x,\n                        ph_ne.x, ph_e.x, ph_se.x);\n        \n        mat3 mp1 = mat3(ph_nw.y, ph_w.y, ph_sw.y,\n                         ph_n.y, ph_c.y,  ph_s.y,\n                        ph_ne.y, ph_e.y, ph_se.y);\n        \n        mat3 mp2 = mat3(ph_nw.z, ph_w.z, ph_sw.z,\n                         ph_n.z, ph_c.z,  ph_s.z,\n                        ph_ne.z, ph_e.z, ph_se.z);\n        \n        mat3 mp3 = mat3(ph_nw.w, ph_w.w, ph_sw.w,\n                         ph_n.w, ph_c.w,  ph_s.w,\n                        ph_ne.w, ph_e.w, ph_se.w);\n\n        \n        mat3 mh = mat3(q_nw, q_w, q_sw,\n                        q_n, q_c,  q_s,\n                       q_ne, q_e, q_se);\n        \n        mat3 a, b;\n        \n        float friends = neighborhoods(mh, iuv, a, b);\n        \n        mat3 mab = a - b;\n\n        vec4 v00 = D0(iuv, ivec2(0,0));\n        vec4 v01 = D0(iuv, ivec2(1,0));\n        vec4 v02 = D0(iuv, ivec2(0,1));\n        vec4 v03 = D0(iuv, ivec2(1,1));\n        vec4 v10 = D1(iuv, ivec2(0,0));\n        vec4 v11 = D1(iuv, ivec2(1,0));\n        vec4 v12 = D1(iuv, ivec2(0,1));\n        vec4 v13 = D1(iuv, ivec2(1,1));\n        \n        vec4 v000 = unpack(v00.x);\n        vec4 v001 = unpack(v00.y);\n        vec4 v002 = unpack(v00.z);\n        vec4 v003 = unpack(v00.w);\n        vec4 v010 = unpack(v01.x);\n        vec4 v011 = unpack(v01.y);\n        vec4 v012 = unpack(v01.z);\n        vec4 v013 = unpack(v01.w);\n        vec4 v020 = unpack(v02.x);\n        vec4 v021 = unpack(v02.y);\n        vec4 v022 = unpack(v02.z);\n        vec4 v023 = unpack(v02.w);\n        vec4 v030 = unpack(v03.x);\n        vec4 v031 = unpack(v03.y);\n        vec4 v032 = unpack(v03.z);\n        vec4 v033 = unpack(v03.w);\n        \n        vec4 v100 = unpack(v10.x);\n        vec4 v101 = unpack(v10.y);\n        vec4 v102 = unpack(v10.z);\n        vec4 v103 = unpack(v10.w);\n        vec4 v110 = unpack(v11.x);\n        vec4 v111 = unpack(v11.y);\n        vec4 v112 = unpack(v11.z);\n        vec4 v113 = unpack(v11.w);\n        vec4 v120 = unpack(v12.x);\n        vec4 v121 = unpack(v12.y);\n        vec4 v122 = unpack(v12.z);\n        vec4 v123 = unpack(v12.w);\n        vec4 v130 = unpack(v13.x);\n        vec4 v131 = unpack(v13.y);\n        vec4 v132 = unpack(v13.z);\n        vec4 v133 = unpack(v13.w);\n\n\n        #ifdef ENEMY_NEGATIVE\n            float f0 = mult(mx, mab);\n            float f1 = mult(my, mab);\n            float f2 = mult(mx, mab);\n            float f3 = mult(my, mab);\n        #else\n            float f0 = mult(mx, a);\n            float f1 = mult(my, a);\n            float f2 = mult(mx, b);\n            float f3 = mult(my, b);\n        #endif\n            float f4 = mult(mx, mp0);\n            float f5 = mult(my, mp0);\n            float f6 = mult(mx, mp1);\n            float f7 = mult(my, mp1);\n            float f8 = mult(mx, mp2);\n            float f9 = mult(my, mp2);\n            float f10= mult(mx, mp3);\n            float f11= mult(my, mp3);\n        \n        \n        vec4 l00 = relu(L0_SCALE *(v000 * f0 + v001 * f1 + v002 * f2 + v003 * f3 +\n                                   v010 * f4 + v011 * f5 + v012 * f6 + v013 * f7 + \n                                   v020 * f8 + v021 * f9 + v022 * f10+ v023 * f11+\n                                   PHEROMONE_INPUT_SCALE * v030 * pheromones_here.x + \n                                   PHEROMONE_INPUT_SCALE * v031 * pheromones_here.y + \n                                   PHEROMONE_INPUT_SCALE * v032 * pheromones_here.z + \n                                   PHEROMONE_INPUT_SCALE * v033 * pheromones_here.w +\n                                   v133 * energy_here\n                                   ));\n        \n        #define k(x) dot(x,vec4(1))\n        \n        vec4 delta_ph = vec4(k(v100 * l00),\n                             k(v101 * l00),\n                             k(v102 * l00),\n                             k(v103 * l00));\n        \n\n        \n\n        #ifdef SINGLE_OUTPUT\n            vec4 l10 = relu(L1_SCALE * \n                            vec4(\n                                k(v110 * delta_ph),\n                                k(v111 * delta_ph),\n                                k(v112 * delta_ph),\n                                k(v113 * delta_ph)\n                                )\n                            );\n            vec4 l11 = relu(L1_SCALE * \n                            vec4(\n                                k(v120 * delta_ph),\n                                k(v121 * delta_ph),\n                                k(v122 * delta_ph),\n                                k(v123 * delta_ph)\n                                )\n                            );\n\n            float l12 = relu(L1_SCALE * k(v130 * delta_ph));\n        #else\n            vec4 l10 = sigm(L1_SCALE * \n                            vec4(\n                                k(v110 * delta_ph),\n                                k(v111 * delta_ph),\n                                k(v112 * delta_ph),\n                                k(v113 * delta_ph)\n                                )\n                            );\n            vec4 l11 = sigm(L1_SCALE * \n                            vec4(\n                                k(v120 * delta_ph),\n                                k(v121 * delta_ph),\n                                k(v122 * delta_ph),\n                                k(v123 * delta_ph)\n                                )\n                            );\n\n            float l12 = sigm(L1_SCALE * k(v130 * delta_ph));\n        #endif\n        \n        vec2 r = vec2(k(v131 * delta_ph), k(v132 * delta_ph));\n        \n        //pheromones_here += PHEROMONE_OUTPUT_SCALE * vec4(delta_ph);\n        pheromones_here = (1.0 - PHEROMONE_OUTPUT_SCALE) * pheromones_here + PHEROMONE_OUTPUT_SCALE * delta_ph;\n\n        mat3 res = l10.x * mo0 + l10.y * mo1 + l10.z * mo2 + l10.w * mo3 +\n            \t   l11.x * mo4 + l11.y * mo5 + l11.z * mo6 + l11.w * mo7;\n\n        vec4  l20 = vec4(res[0][0], res[1][0], res[2][0], res[2][1]);\n        vec4  l21 = vec4(res[2][2], res[1][2], res[0][2], res[0][1]);\n        float l22 = l12;\n        \n        rot_neighbors(l20, l21, r);\n        \n        vec4 minl0 = min(l20, l21);\n        vec2 minl1 = min(minl0.xy,minl0.zw);\n        float minl = min(minl1.x,minl1.y);\n        minl = min(minl,l22);\n        \n        l20 -= minl;\n        l21 -= minl;\n        l22 -= minl;\n        \n        float lsum = dot(l20, vec4(1)) + dot(l21, vec4(1)) + l22;   \n\n        if (lsum == 0.0) {\n        \tl20 = vec4(0);\n            l21 = vec4(0);\n        } else {\n            float nrat = lsum - l22;\n            float lrat = nrat / lsum;\n            lsum = lrat > (1.0 - CENTER_MIN) ? nrat * (1.0 / (1.0 - CENTER_MIN)) : lsum;\n            l20 = l20 / lsum;\n            l21 = l21 / lsum;\n        }\n\n        \n        vec2 packed = vec2(pack(l20), pack(l21));\n\n        fragColor = vec4(energy_here,packed,pack(pheromones_here));\n\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define iRes (2*(ivec2(iResolution.xy)/2))\n\nivec2 pm(ivec2 i) {\n    return pm(i,iRes);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(KEY_SP, 0.5) ).x > 0.5;\n}\n\n#define T(v) texelFetch(iChannel0, pm(iuv + 2 * v), 0)\n#define D0(u,v) texelFetch(iChannel1, pm(u + (v)), 0)\n#define D1(u,v) texelFetch(iChannel2, pm(u + (v)), 0)\n\nbool neighbor_is_friendly(ivec2 iuv_base, ivec2 attacker_position) {\n\t return neighbor_is_friendly(iChannel1, iChannel2, iuv_base, attacker_position, iRes);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    ivec2 iuv = ivec2(U);\n    ivec2 iuv_off  = iuv & ivec2(1u);\n    ivec2 iuv_base = iuv - iuv_off;\n    \n\tif (iuv_off != ivec2(0)) {\n    \tfragColor = vec4(0);    \n    } else {       \n        vec4 state_here = T(ivec2(0));\n        vec2 receive_state = vec2(0);\n        \n        vec4 sending_attack_state_0 = unpack(state_here.y);\n        vec4 sending_attack_state_1 = unpack(state_here.z);\n        \n        float energy_here = state_here.x;\n        \n        // energy rounding adjustment\n        \n        float energy_expended_fraction = dot(sending_attack_state_0, vec4(1)) + \n            \t\t\t\t\t\t\t dot(sending_attack_state_1, vec4(1));\n        \n        float energy_expended  = energy_here * energy_expended_fraction;\n        float energy_remaining = energy_here * (1.0 - energy_expended_fraction); \n        \n        // end rounding adjustment\n        \n        \n        ivec2 offsets[8] = ivec2[](ivec2(-1, 1),ivec2( 0, 1),ivec2( 1, 1),ivec2( 1, 0),\n                                   ivec2( 1,-1),ivec2( 0,-1),ivec2(-1,-1),ivec2(-1, 0));\n        \n        float total_friend_energy = 0.0;\n        float total_foe_energy = 0.0;\n        \n        vec3 friends[8] = vec3[](vec3(0), vec3(0), vec3(0), vec3(0), \n                                 vec3(0), vec3(0), vec3(0), vec3(0));\n        \n        vec3 foes[8]    = vec3[](vec3(0), vec3(0), vec3(0), vec3(0), \n                                 vec3(0), vec3(0), vec3(0), vec3(0));\n        \n        int friend_count = 0;\n        int foe_count = 0;\n        \n        for (int i = 0; i < 8; i++) {\n            vec4 neighbor_state = T(offsets[i]);\n            vec4 t0 = unpack(neighbor_state.y);\n            vec4 t1 = unpack(neighbor_state.z);\n\n            /* \n            t0.x  t0.y  t0.z \n            t1.w        t0.w \n            t1.z  t1.y  t1.x\n            */\n            \n            float attack_fraction[8] = float[](t1.x, t1.y, t1.z, t1.w, \n                                               t0.x, t0.y, t0.z, t0.w);\n            \n            float attacker_energy = neighbor_state.x;\n            \n            if(neighbor_is_friendly(iuv_base, 2 * offsets[i])) {\n                float friend_energy   = attack_fraction[i] * attacker_energy;    \n                total_friend_energy  += friend_energy;\n                friends[friend_count] = vec3(offsets[i], friend_energy);\n                friend_count++;\n            } else {\n                float foe_energy      = attack_fraction[i] * attacker_energy;  \n                total_foe_energy     += foe_energy;\n                foes[foe_count]       = vec3(offsets[i], foe_energy);\n                foe_count++;\n            }\n        }\n        \n        bool attacker_success = false;\n        bool attacker_is_friendly = false;\n\n        energy_here = energy_remaining;\t    \n\n        \n        if (total_friend_energy >= total_foe_energy) {\n            if (total_friend_energy > energy_here) {\n                attacker_success = true;\n                attacker_is_friendly = true;\n                float max_friend_energy = 0.0;\n                for (int i = 0; i < friend_count; i++) {\n                    float friend_energy = friends[i].z;\n                    vec2 friend_position = friends[i].xy;\n                    if (friend_energy > max_friend_energy) {\n                        max_friend_energy = friend_energy;\n                        receive_state = friend_position;                                \n                    }\n                }\n            }   \n        } else {\n            if (total_foe_energy > energy_here) {\n                attacker_success = true;\n                attacker_is_friendly = false;\n                float max_foe_energy = 0.0;\n                for (int i = 0; i < foe_count; i++) {\n                    float foe_energy = foes[i].z;\n                    vec2 foe_position = foes[i].xy;\n                    if (foe_energy > max_foe_energy) {\n                        max_foe_energy = foe_energy;\n                        receive_state = foe_position;                                \n                    }\n                }\n            }\n        }\n        \n        energy_here += total_foe_energy + total_friend_energy;\n        \n        float attacker_success_state = attacker_success ? (attacker_is_friendly ? 2.0 : 1.0) : 0.0;\n\n        if (reset()) {\n        \tattacker_success_state = 3.0;    \n        }\n        \n        fragColor = vec4(energy_here, attacker_success_state, receive_state);\n\n    }\n    \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define iRes (2*(ivec2(iResolution.xy)/2))\n\n#define random4(x) random4(x, iFrame)\n\nivec2 pm(ivec2 i) {\n    return pm(i,iRes);\n}\n\n#define C(v) texelFetch(iChannel0, pm(iuv_base + (v)), 0)\n#define D(u,v) texelFetch(iChannel1, pm(u + (v)), 0)\n\nbool reset() {\n    return texture(iChannel3, vec2(KEY_SP, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    ivec2 iuv = ivec2(U);\n    ivec2 iuv_off  = iuv & ivec2(1u);\n    ivec2 iuv_base = iuv - iuv_off;\n    \n    vec4 receive_state = C(ivec2(0));\n    \n    bool attacker_success = is_attack_successful(receive_state.y);\n    ivec2 attacker_position = 2 * ivec2(receive_state.zw);\n    \n    bool friend = is_attacker_friendly(receive_state.y);\n    vec4 attacker_rules = D(iuv, attacker_position);\n    vec4 current_rules = D(iuv, ivec2(0));\n    \n    vec4 r0 = random4(U);\n    vec4 r1 = random4(U+vec2(1.518176,2.941483)*iResolution.xy);\n    vec4 r2 = random4(U+vec2(6.194379,4.813467)*iResolution.xy);\n    vec4 r3 = random4(U+vec2(1.020569,6.260691)*iResolution.xy);\n    vec4 r4 = random4(U+vec2(7.033547,2.105361)*iResolution.xy);\n    vec4 r5 = random4(U+vec2(9.835233,5.349718)*iResolution.xy);\n    vec4 r6 = random4(U+vec2(7.697952,2.850486)*iResolution.xy);\n    vec4 r7 = random4(U+vec2(8.288882,3.622455)*iResolution.xy);\n    \n\n    if (attacker_success && !friend) {\n        vec4 m0 = MUTATION_RATE * (r0 - 0.5);\n        vec4 m1 = MUTATION_RATE * (r1 - 0.5);\n        vec4 m2 = MUTATION_RATE * (r2 - 0.5);\n        vec4 m3 = MUTATION_RATE * (r3 - 0.5);\n        \n        vec4 b0 = unpack(attacker_rules.x);\n        vec4 b1 = unpack(attacker_rules.y);\n        vec4 b2 = unpack(attacker_rules.z);\n        vec4 b3 = unpack(attacker_rules.w);\n        \n        vec4 d0 = m0 + b0;\n        vec4 d1 = m1 + b1;\n        vec4 d2 = m2 + b2;\n        vec4 d3 = m3 + b3;\n        \n        vec4 new_rules = vec4(pack(d0),pack(d1),pack(d2),pack(d3));\n    \tcurrent_rules = new_rules;\n    } else if (attacker_success && friend) {\n        vec4 m0 = MUTATION_RATE * (r0 - 0.5);\n        vec4 m1 = MUTATION_RATE * (r1 - 0.5);\n        vec4 m2 = MUTATION_RATE * (r2 - 0.5);\n        vec4 m3 = MUTATION_RATE * (r3 - 0.5);\n        \n        vec4 a0 = unpack(current_rules.x);\n        vec4 a1 = unpack(current_rules.y);\n        vec4 a2 = unpack(current_rules.z);\n        vec4 a3 = unpack(current_rules.w);\n        \n        vec4 b0 = unpack(attacker_rules.x);\n        vec4 b1 = unpack(attacker_rules.y);\n        vec4 b2 = unpack(attacker_rules.z);\n        vec4 b3 = unpack(attacker_rules.w);\n        \n        vec4 d0 = m0 + mix(a0, b0, greaterThan(r4, vec4(0.5)));\n        vec4 d1 = m1 + mix(a1, b1, greaterThan(r5, vec4(0.5)));\n        vec4 d2 = m2 + mix(a2, b2, greaterThan(r6, vec4(0.5)));\n        vec4 d3 = m3 + mix(a3, b3, greaterThan(r7, vec4(0.5)));\n        \n        vec4 new_rules = vec4(pack(d0),pack(d1),pack(d2),pack(d3));\n    \tcurrent_rules = new_rules;\n    }\n    \n    if(iFrame<10 || reset()) {\n        r0 = 2.0 * r0 - 1.0;\n        r1 = 2.0 * r1 - 1.0;\n        r2 = 2.0 * r2 - 1.0;\n        r3 = 2.0 * r3 - 1.0;\n        fragColor = vec4(pack(r0),pack(r1),pack(r2),pack(r3));\n    } else {\n\t\tfragColor = vec4(current_rules);\n    }\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define iRes (2*(ivec2(iResolution.xy)/2))\n\n#define random4(x) random4(x, iFrame)\n\nivec2 pm(ivec2 i) {\n    return pm(i,iRes);\n}\n\n#define C(v) texelFetch(iChannel0, pm(iuv_base + (v)), 0)\n#define D(u,v) texelFetch(iChannel1, pm(u + (v)), 0)\n\nbool reset() {\n    return texture(iChannel3, vec2(KEY_SP, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    ivec2 iuv = ivec2(U);\n    ivec2 iuv_off  = iuv & ivec2(1u);\n    ivec2 iuv_base = iuv - iuv_off;\n    \n    vec4 receive_state = C(ivec2(0));\n    \n    bool attacker_success = is_attack_successful(receive_state.y);\n    ivec2 attacker_position = 2 * ivec2(receive_state.zw);\n    \n    bool friend = is_attacker_friendly(receive_state.y);\n    vec4 attacker_rules = D(iuv, attacker_position);\n    vec4 current_rules = D(iuv, ivec2(0));\n    \n    vec4 r0 = random4(U);\n    vec4 r1 = random4(U+vec2(2.941483,1.518176)*iResolution.xy);\n    vec4 r2 = random4(U+vec2(4.813467,6.194379)*iResolution.xy);\n    vec4 r3 = random4(U+vec2(6.260691,1.020569)*iResolution.xy);\n    vec4 r4 = random4(U+vec2(2.105361,7.033547)*iResolution.xy);\n    vec4 r5 = random4(U+vec2(5.349718,9.835233)*iResolution.xy);\n    vec4 r6 = random4(U+vec2(2.850486,7.697952)*iResolution.xy);\n    vec4 r7 = random4(U+vec2(3.622455,8.288882)*iResolution.xy);\n    \n\n    if (attacker_success && !friend) {\n        vec4 m0 = MUTATION_RATE * (r0 - 0.5);\n        vec4 m1 = MUTATION_RATE * (r1 - 0.5);\n        vec4 m2 = MUTATION_RATE * (r2 - 0.5);\n        vec4 m3 = MUTATION_RATE * (r3 - 0.5);\n        \n        vec4 b0 = unpack(attacker_rules.x);\n        vec4 b1 = unpack(attacker_rules.y);\n        vec4 b2 = unpack(attacker_rules.z);\n        vec4 b3 = unpack(attacker_rules.w);\n        \n        vec4 d0 = m0 + b0;\n        vec4 d1 = m1 + b1;\n        vec4 d2 = m2 + b2;\n        vec4 d3 = m3 + b3;\n        \n        vec4 new_rules = vec4(pack(d0),pack(d1),pack(d2),pack(d3));\n        current_rules = new_rules;\n    } else if (attacker_success && friend) {\n        vec4 m0 = MUTATION_RATE * (r0 - 0.5);\n        vec4 m1 = MUTATION_RATE * (r1 - 0.5);\n        vec4 m2 = MUTATION_RATE * (r2 - 0.5);\n        vec4 m3 = MUTATION_RATE * (r3 - 0.5);\n        \n        vec4 a0 = unpack(current_rules.x);\n        vec4 a1 = unpack(current_rules.y);\n        vec4 a2 = unpack(current_rules.z);\n        vec4 a3 = unpack(current_rules.w);\n        \n        vec4 b0 = unpack(attacker_rules.x);\n        vec4 b1 = unpack(attacker_rules.y);\n        vec4 b2 = unpack(attacker_rules.z);\n        vec4 b3 = unpack(attacker_rules.w);\n        \n        vec4 d0 = m0 + mix(a0, b0, greaterThan(r4, vec4(0.5)));\n        vec4 d1 = m1 + mix(a1, b1, greaterThan(r5, vec4(0.5)));\n        vec4 d2 = m2 + mix(a2, b2, greaterThan(r6, vec4(0.5)));\n        vec4 d3 = m3 + mix(a3, b3, greaterThan(r7, vec4(0.5)));\n        \n        vec4 new_rules = vec4(pack(d0),pack(d1),pack(d2),pack(d3));\n    \tcurrent_rules = new_rules;\n    }\n    \n    if(iFrame<10 || reset()) {\n        r0 = 2.0 * r0 - 1.0;\n        r1 = 2.0 * r1 - 1.0;\n        r2 = 2.0 * r2 - 1.0;\n        r3 = 2.0 * r3 - 1.0;\n        fragColor = vec4(pack(r0),pack(r1),pack(r2),pack(r3));\n    } else {\n\t\tfragColor = vec4(current_rules);\n    }\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPECIATION_THRESHOLD 4.0\n#define ENERGY_BLUR_AMOUNT 0.05\n#define PHEROMONE_BLUR_AMOUNT 0.2\n#define L0_SCALE 2.0\n#define L1_SCALE 2.0\n#define CENTER_MIN 0.15\n\n#define MUTATION_RATE 0.02\n\n#define PHEROMONE_OUTPUT_SCALE 0.05\n#define PHEROMONE_INPUT_SCALE 2.0\n\n//#define ENEMY_NEGATIVE\n#define SINGLE_OUTPUT\n\n\n\n\n#define KEY_SP (32.5/256.0)\n#define KEY_Q  (81.5/256.0)\n#define KEY_A  (65.5/256.0)\n#define KEY_Z  (90.5/256.0)\n#define KEY_W  (87.5/256.0)\n#define KEY_S  (83.5/256.0)\n\n\n\nuint packSnorm4x8(vec4 x) {\n\tx = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(round(abs(x)));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackSnorm4x8(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n\n#define unpack(x) unpackSnorm4x8(floatBitsToUint(x))\n#define pack(x) uintBitsToFloat(packSnorm4x8(x))\n\nfloat mult(mat3 m, mat3 x) {\n    mat3 p = matrixCompMult(m, x);\n    return p[0][0] + p[0][1] + p[0][2] +\n           p[1][0] + p[1][1] + p[1][2] +\n           p[2][0] + p[2][1] + p[2][2];\n}\n\nivec2 pm(ivec2 i, ivec2 n) {\n    return ((i % n) + n) % n;\n}\n\nint pm(int i, int m) {\n    return ((i % m) + m) % m;\n}\n\nbool is_dead(float x) {\n\treturn x <= 0.0;    \n}\n\nbool is_attack_successful(float x) {\n    return x > 0.5;\n}\n\nbool is_attacker_friendly(float x) {\n    return x > 1.5;\n}\n\nfloat pdist(vec4 a, vec4 b) {\n    return dot(pow(a-b,vec4(2)),vec4(1));\n}\n\nfloat unpackdist(vec4 a, vec4 b) {\n    vec4 a0 = unpack(a.x);\n    vec4 a1 = unpack(a.y);\n    vec4 a2 = unpack(a.z);\n    vec4 a3 = unpack(a.w);  \n    \n    vec4 b0 = unpack(b.x);\n    vec4 b1 = unpack(b.y);\n    vec4 b2 = unpack(b.z);\n    vec4 b3 = unpack(b.w);\n    \n    float d0 = pdist(a0, b0);\n    float d1 = pdist(a1, b1);\n    float d2 = pdist(a2, b2);\n    float d3 = pdist(a3, b3);\n    \n    return d0 + d1 + d2 + d3;\n}\n\n#define D0(u,v) texelFetch(channel0, pm(u + (v), iResolution), 0)\n#define D1(u,v) texelFetch(channel1, pm(u + (v), iResolution), 0)\nfloat neighbor_dist(sampler2D channel0, sampler2D channel1, ivec2 iuv_base, ivec2 attacker_position, ivec2 iResolution) {\n\tvec4 v00 = D0(iuv_base, ivec2(0,0));\n    vec4 v01 = D0(iuv_base, ivec2(1,0));\n    vec4 v02 = D0(iuv_base, ivec2(0,1));\n    vec4 v03 = D0(iuv_base, ivec2(1,1));\n\n    vec4 w00 = D0(iuv_base, attacker_position + ivec2(0,0));\n    vec4 w01 = D0(iuv_base, attacker_position + ivec2(1,0));\n    vec4 w02 = D0(iuv_base, attacker_position + ivec2(0,1));\n    vec4 w03 = D0(iuv_base, attacker_position + ivec2(1,1));\n    \n    vec4 v10 = D1(iuv_base, ivec2(0,0));\n    vec4 v11 = D1(iuv_base, ivec2(1,0));\n    vec4 v12 = D1(iuv_base, ivec2(0,1));\n    vec4 v13 = D1(iuv_base, ivec2(1,1));\n\n    vec4 w10 = D1(iuv_base, attacker_position + ivec2(0,0));\n    vec4 w11 = D1(iuv_base, attacker_position + ivec2(1,0));\n    vec4 w12 = D1(iuv_base, attacker_position + ivec2(0,1));\n    vec4 w13 = D1(iuv_base, attacker_position + ivec2(1,1));\n        \n    vec4 d0 = vec4(unpackdist(v00, w00),\n                   unpackdist(v01, w01),\n                   unpackdist(v02, w02),\n                   unpackdist(v03, w03));\n    \n    vec4 d1 = vec4(unpackdist(v10, w10),\n                   unpackdist(v11, w11),\n                   unpackdist(v12, w12),\n                   unpackdist(v13, w13));\n\n    return (dot(d0,vec4(1)) + dot(d1,vec4(1)));   \n}\n\nbool neighbor_is_friendly(sampler2D channel0, sampler2D channel1, ivec2 iuv_base, ivec2 attacker_position, ivec2 iResolution) {\n\t return neighbor_dist(channel0, channel1, iuv_base, attacker_position, iResolution) < SPECIATION_THRESHOLD;   \n}\n#undef D0\n#undef D1\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\n\n// BEGIN IQ integer noise\n// The MIT License\n// Copyright  2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// BEGIN IQ integer noise\n// The MIT License\n// Copyright  2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec4 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec4 k = n * uvec4(n,n*16807U,n*48271U,n*127051U);\n    return vec4( k & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat random(vec2 q, int seed) {\n    uvec2 p = uvec2(q);\n    return hash1( p.x + 1920U*p.y + (1920U*1080U)*uint(seed) );    \n}\n\nvec4 random4(vec2 q, int seed) {\n    uvec2 p = uvec2(q);\n    return hash3( p.x + 1920U*p.y + (1920U*1080U)*uint(seed) );    \n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3885, 3885, 3904, 3904, 3946], [4169, 4169, 4231, 4231, 4313], [4315, 4315, 4383, 4383, 4476], [4478, 4478, 4488, 4488, 4548], [4550, 4550, 4560, 4560, 4620], [4622, 4622, 4632, 4632, 4692], [4694, 4694, 4704, 4704, 4764], [4766, 4766, 4776, 4776, 4836]], "test": "untested"}
{"id": "ssBGWd", "name": "NACA00xx - 2d distance", "author": "jmpep", "description": "Signed distance field of a NACA00xx.\nWorks relatively well for the exterior, and for the interior up to a thickness of around 40%, which is its normal range.\n\nDrag vertically to change the thickness.", "tags": ["2d", "sdf", "fluid", "distance", "cfd", "naca"], "likes": 6, "viewed": 458, "published": 3, "date": "1618185179", "time_retrieved": "2024-07-30T19:26:59.269860", "image_code": "// The MIT License\n// Copyright  2021 Javier Meseguer de Paz\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Attempt to create the signed distance field of a NACA00xx.\n// https://en.wikipedia.org/wiki/NACA_airfoil#Equation_for_a_symmetrical_4-digit_NACA_airfoil\n//\n// Useful for showcasing 2d fluid simulators and the like. Or for creating wings via extrusion :)\n//\n// The NACA is defined in x=(0,1.0] as it is customary.\n//\n// Works relatively well for the exterior, and for the interior up\n// to a thickness of around 40%, which is pretty much its normal range.\n//\n// Furthermore, when it is not working inside it is still working outside,\n// and the fluid is normally there :).\n//\n// The method uses Newton-Rhapson to compute the closest point in the NACA, then the distance from there.\n// Since the NACA has an asymptote in x=0 we simply avoid it, and we approximate the very begining \n// of the leading edge (where x < EPS) by a simple segment.\n\n#define MAX_THICKNESS 0.40\n#define EPS 0.001\n#define NR_ITERATIONS 7\n#define IS_DEMO 1\n\n// segment's sdf from: https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// half thickness function\nfloat yt(float x, float sx, float t) \n{\n    x = clamp(x, 0.0, 1.0);    \n    return 5.0 * t * (0.2969*sx + x*(-0.126 + x * (-0.3516 + x * (0.2843 + x * (-0.1037)))));\n}\n\n// first derivative of yt\nfloat dyt(float x, float sx, float t)\n{\n    return t * (0.74225/sx - 0.63 + x * (-3.516 + x * (4.2645 + x * (-2.074))));\n}\n\n// second derivative of yt\nfloat ddyt(float x, float sx, float t)\n{\n    float x32 = sx * sx * sx;   \n    return t * (x32 * (-3.516 + x * (8.529 + x * (-6.222))) - 0.371125)/(x32+1e-27);\n}\n\n// NACA's sdf\nfloat sdNACA(vec2 p, float t)\n{\n    p.y = abs(p.y);\n    \n    // get where the distance from p to the NACA is the minimum\n    // (its first derivate will be zero) using Newton-Rhapson\n    float x = clamp(p.x, 0.0, 1.0); \n    float sx = sqrt(x);\n        \n    // get whether we are inside our outside the NACA\n    float s = (p.y >= yt(x, sx, t) ? +1.0 : -1.0);\n\n    // try to compute the closest point in the NACA to the current point\n    // using Newton-Rhapson\n    for (int i = 0; i < NR_ITERATIONS; ++i) {\n    \n        float eyt = yt(x, sx, t);\n        float edyt = dyt(x, sx, t);\n        float eddyt = ddyt(x, sx, t);\n    \n        float fx = -2.0*p.x + 2.0*x -2.0*(p.y - eyt)* edyt;\n        float ffx = -2.0*(p.y-eyt) * eddyt + 2.0* edyt * edyt + 2.0;\n\n        x = clamp(x - fx / ffx, EPS, 1.0);\n        sx = sqrt(x);\n    }\n\n    // once we have x of the closest point, compute the NACA's point and distance\n    vec2 naca = vec2(x, yt(x, sx, t));\n    float nacaDist =  length(p - naca);    \n\n\n    // use a segment to close the leading gap \n    // (because we are clamping x to EPS to avoid infinities)   \n    vec2 segmentEdge= vec2(EPS, yt(EPS, sqrt(EPS), t));\n    float segmentDist = sdSegment(p, segmentEdge, -segmentEdge);\n\n    // return the signed distance to either the NACA or the segment (the closest one)\n    return s * min(nacaDist, segmentDist);    \n}\n\n// from iq's signed distance field gallery\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    if (m.x < 0.001 && m.y < 0.001) m.y = 0.65;\n    \n#if IS_DEMO\n    float t = mix(0.1, MAX_THICKNESS, (0.5 + 0.5 * sin(0.5 * iTime)));\n#else\n    float t = MAX_THICKNESS * m.y;\n #endif\n    t = clamp(t, 0.0, MAX_THICKNESS);\n     \n    float d = sdNACA(0.65*(uv + vec2(0.5, 0.0)), t );\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-5.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*d/0.65);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4( col, 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBGWd.jpg", "access": "api", "license": "mit", "functions": [[2021, 2092, 2144, 2144, 2263], [2265, 2292, 2331, 2331, 2459], [2461, 2487, 2526, 2526, 2609], [2611, 2638, 2678, 2678, 2798], [2800, 2814, 2845, 2845, 4175], [4177, 4220, 4277, 4277, 4896]], "test": "ok"}
{"id": "7dfSzn", "name": "WDI 2021 Livecoding", "author": "spolsh", "description": "Effect of ~30 min Shader Livecoding session at https://warszawskiedniinformatyki.pl/, Thanks for stopping by and watching pixels bouncing to music", "tags": ["3d", "raymarching", "music", "reflections", "livecoding", "klos"], "likes": 3, "viewed": 368, "published": 3, "date": "1618175290", "time_retrieved": "2024-07-30T19:27:00.133551", "image_code": "// #version 410 core\n\n#define f float \n#define v2 vec2\n#define v3 vec3\n\n#define v2Resolution iResolution\n#define fGlobalTime iTime\n#define F gl_FragCoord\n#define R iResolution\n#define T iTime\n\n#define C(v) clamp(v, 0., 1.)\n#define N normalize\n#define H(v) fract(sin(100.0*v) * 43758.5453)\n\n// #define BI(v) (texture(texFFTIntegrated, v).x)\n// #define BS(v) (texture(texFFTSmoothed, v).x)\n// #define B(v) (texture(texFFT, v).x)\n// fake beat accumulation, next time I will save it in buffer\n#define B2(v) (0.05*T+0.005*texture(iChannel0, v2(v, 0.5)).x)\n#define B1(v) (0.005*texture(iChannel0, v2(v, 0.5)).x)\n#define B0(v)  (0.005*texture(iChannel0, v2(v, 0.5)).x)\n\n#define texNoise iChannel1\n\n// uniform float fGlobalTime; // in seconds\n// uniform vec2 v2Resolution; // viewport resolution (in pixels)\n\nv3 colA = v3(0.2, 0.5, 1.2);\nv3 cP = v3(0.);\n\nf gG = 10e8;\n\nmat2 rot(f a) {return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nvec4 plas( vec2 v, float time )\n{\n\tfloat c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n\treturn vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\n\nf map(v3 p) {\n  f s = 10e8;\n  s = -abs(p.y) + 1.5;\n  \n  v3 p2 = p;\n  p2.x = abs(p2.x) - 2.0;\n  p2.z = mod(p2.z + 5.0, 10.0) - 5.0;\n  p2.y = mod(p2.z +  .01, 0.02) - 0.01;\n  s = min(s, length(p2) - 0.5);\n  p2.x -= 2.;\n  s = min(s, length(p2) - 0.5);\n  \n  v3 p3 = p;\n  p3.y -= 0.5;\n  p3.z -= 8.0;\n  p3.z = mod(p3.z + .01, .02) - .01;\n  p3.y += 0.5 + .5*sin(0.3*p.z);\n  p3.x += 1.5*sin(0.1*p.z);  \n  f s5 = min(s, length(p3) - 0.05);\n  p3.z -= 10.0*B0(0);\n  s5 = min(s5, length(p3) - 0.05);\n  p3.x -= 10.0*B0(0.1);\n  s5 = min(s5, length(p3) - 0.1);\n  p3.x -= 10.0*B0(0.2);\n  s5 = min(s5, length(p3) - 0.1);\n  gG = min(gG, s5);  \n  s = min(s, s5);  \n  \n  v3 p1 = p - cP;\n  p1.y += 100.0*B1(0.0);\n  p1.z -= 10.0 + 5.0*sin(10.0*B2(0));\n  \n  f s3 = 10e8;\n  for (f i = 0.; i < 4.; ++i) {\n    p1 -= v3(0.1, 0.3, 0.5);   \n    p1.xz *= rot(10. * B2(0.));\n    p1.zy *= rot(-9. * B2(0.));\n    p1.xy *= rot(50. * B1(0.));\n    // p1.zy *= rot(0.5 * B2(0.) );\n    p1 = abs(p1);\n    p1 *= 0.9;\n    f s4 = length(p1) -0.1 -5.0*B0(0.);\n    vec3 p4 = p1;\n    if (i < 2. + B1(0.)) {\n      p4.y = mod(p4.y +  .01, 0.02) - 0.01;\n      f s2 = length(p4) -0.05 -1.0*B0(0.);\n      s3 = min(s3, s2);\n      s3 = min(s3, s4);\n    }      \n  }\n  gG = min(gG, s3);  \n  s = min(s, s3);\n  return s;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n  \n  out_color = vec4(0);  \n  if (abs(uv.y) > 0.35) return;\n  \n  vec3 ro = vec3(0, 0, 0);\n  ro.x += sin(20.0*B2(0.));\n  ro.y += 0.1*sin(20.0*B2(0.));\n  ro.z += 20.0*T;\n  cP = ro;\n  vec3 rd = N(vec3(uv, 2.));\n  rd.xy *= rot(0.5*sin(0.5* T));\n  v3 c = v3(0.0);\n  \n  f t = 0.1;\n  for (f i = 0.; i < 128.; ++i) {\n    f d = map(ro + rd * t);\n    if (abs(d) < 0.001 || t > 40.0) break;\n    t += d;\n  }\n  \n  if (t > 0.2 || t < 40.) {\n    v3 p = ro + rd  * t;    \n    f tex0 = texture(texNoise, floor(20.0*( vec2(1.0, 0.05) * p.xz + vec2(0, 1) * T))/20.0).x;\n    f tex1 = texture(texNoise, floor(20.0*( vec2(0.5, 0.005) * p.xz + vec2(0, 0.5) * T))/20.0).x;\n    c += 0.25 * colA.xyz * smoothstep(0.2, 0.7, tex0);\n    c += 0.25 * colA.xyz * smoothstep(0.2, 0.7, tex1);\n    \n    c += 0.1 * colA.xzy * smoothstep(0.0, 1., sin(p.z + 10.*T));\n    c += 0.5 * colA.xzy * smoothstep(0.9, 1., sin(0.5*p.z + 10.*T));\n    c += 0.5 * colA.xzy * smoothstep(0.5, 1., sin(0.5*p.z + 10.*T)) * sin(p.z + sin(100.0*p.x) + 10.*T);\n  }\n  \n  c = mix(c, 0.1*colA.yzx, 1.0 - exp(-0.005 * t*t));\n  \n  v3 colB = v3(1., 0.5, 0.5);\n  f sb = 0.01 + 20.0*B1(0.);\n  c += sb * colB.xyz * exp(gG * - 0.01);\n  c += sb * colB.xyz * exp(gG * - 0.1);\n  c += sb * colB.xyz * exp(gG * - 1.0);\n  c += sb * colB.xyz * exp(gG * - 5.0);\n  c += sb * colB.xyz * exp(gG * - 10.0);\n  \n  c += 10.0*B0(0);\n  \n  // c = v3(1) * (t/64.);\n  c = C(c / (c + 1.));  \n  c = pow(c, v3(1. -50.0*B1(0.), 1. -50.0*B1(0.25), 1. -50.0*B1(0.5)));\n  c = smoothstep(0., .6, c);\n  c = pow(c, v3(0.4545));\n  out_color = vec4(c, 1);  \n\t// out_color = vec4(rd, 1);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26619, "src": "https://soundcloud.com/inzynier/bad-dream-good-dream-podcast", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[861, 861, 876, 876, 923], [925, 925, 958, 958, 1121], [1123, 1123, 1136, 1136, 2389], [2391, 2391, 2448, 2448, 4182]], "test": "untested"}
{"id": "sdjGDt", "name": "Normals to a Conic", "author": "mla", "description": "Finding the normals from a point to a conic (so the shortest is the shortest distance to the conic), from the intersection with another conic & solving the resulting quartic equation.\n\nMouse moves point.", "tags": ["normal", "quartic", "conic", "shortestdistance"], "likes": 11, "viewed": 370, "published": 3, "date": "1618173621", "time_retrieved": "2024-07-30T19:27:01.061071", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Normals to conic, Matthew Arcus, mla, 2021.\n//\n// Normals to conic section from point. The feet (red) of normals to a conic\n// (black) from a point (also black) are the intersection of the conic with\n// another conic (blue) (Smith, 1882) & can be found as the roots of a\n// quartic equation.\n//\n// There is some numeric instability when the point is close to the x or y\n// axis and the blue conic is (nearly) degenerate. Fixing this is left to reader.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}\n\nfloat evalquadratic(float x, float A, float B, float C) {\n  return (A*x+B)*x+C;\n}\n\nfloat evalcubic(float x, float A, float B, float C, float D) {\n  return ((A*x+B)*x+C)*x+D;\n}\n\n// Quadratic solver from Kahan\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Numerical Recipes algorithm for solving general cubic equation\nint cubic0(float a, float b, float c, out vec3 roots) {\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    roots[0] = -2.0*S*cos(theta/3.0)-a/3.0;\n    roots[1] = -2.0*S*cos((theta+2.0*PI)/3.0)-a/3.0;\n    roots[2] = -2.0*S*cos((theta+4.0*PI)/3.0)-a/3.0;\n    return 3;\n  } else {\n    float alpha = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),1.0/3.0);\n    float beta = alpha == 0.0 ? 0.0 : Q/alpha;\n    roots[0] = alpha + beta - a/3.0;\n    return 1;\n  }\n}\n\nint cubic(float a, float b, float c, float d, out vec3 roots) {\n  if (a == 0.0) {\n    return quadratic(b,c,d,roots.xy);\n  }\n  if (d == 0.0) {\n    roots.x = 0.0;\n    return 1+quadratic(a,b,c,roots.yz);\n  }\n  return cubic0(b/a,c/a,d/a,roots);\n}\n\n// For the Lanczos quartic method, we want the largest\n// positive root of the cubic.\nfloat qcubic(float B, float C, float D) {\n  vec3 roots;\n  int nroots = cubic(1.0,B,C,D,roots);\n  // Sort into descending order\n  if (nroots > 1 && roots.x < roots.y) roots.xy = roots.yx;\n  if (nroots > 2) {\n    if (roots.y < roots.z) roots.yz = roots.zy;\n    if (roots.x < roots.y) roots.xy = roots.yx;\n  }\n  // And select the largest\n  float psi = roots[0];\n  // There _should_ be a positive root, but sometimes the cubic\n  // solver doesn't find it directly (probably a double root\n  // around zero).\n  // If so, nudge in the right direction\n  //psi = max(1e-6,psi);\n  // and give a quick polish with Newton-Raphson\n  for (int i = 0; i < 3; i++) {\n    float delta = evalcubic(psi,1.0,B,C,D)/evalquadratic(psi,3.0,2.0*B,C);\n    psi -= delta;\n  }\n  return psi;\n}\n\n// The Lanczos quartic method, see his \"Applied Analysis\", 1956.\nint lquartic(float c1, float c2, float c3, float c4, out vec4 res) {\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int nroots = quadratic(1.0,alpha+a,beta+b,res.xy);\n  vec2 tmp;\n  if (quadratic(1.0,alpha-a,beta-b,tmp) != 0) { \n    res.zw = res.xy;\n    res.xy = tmp;\n    nroots += 2;\n  }\n  return nroots;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Solve for the smallest cubic term, this seems to give the least wild behaviour.\n  if (abs(B/A) < abs(D/E)) {\n    nroots = lquartic(B/A,C/A,D/A,E/A,roots);\n  } else {\n    nroots = lquartic(D/E,C/E,B/E,A/E,roots);\n    for (int i = 0; i < nroots; i++) {\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  return nroots;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a, b -= a;\n  float h = clamp(dot(p,b) / dot(b,b), 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat getconicdistance(vec2 z, vec2 ab) {\n  float a = ab.x, b = ab.y, h = z.x, k = z.y;\n  float A = b*h, B = a*k, C = a-b;\n  float alpha = b*C*C;\n  float beta = -2.0*b*B*C;\n  float gamma = a*A*A+b*B*B-C*C;\n  float delta = 2.0*B*C;\n  float epsilon = -B*B;\n  vec4 roots;\n  int nroots = quartic(alpha,beta,gamma,delta,epsilon,roots);\n  float d = 1e8;\n  for (int i = 0; i < nroots; i++) {\n    float y = roots[i];\n    float x = A*y/(B-C*y);\n    vec2 q = vec2(x,y);\n    d = min(d,distance(z,q));\n  }\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec3 col = vec3(0);\n  vec2 ab = vec2(tan(0.5*iTime+3.25),1);\n  vec2 w = vec2(-1.4,0.25);\n  float scale = 3.0;\n  if (iMouse.x > 0.0) w = scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= scale;\n  float xwidth = fwidth(z.x);\n  float lwidth0 = 0.02;\n  float pwidth0 = 0.06;\n  float lwidth1 = max(2.0*lwidth0,xwidth);\n  float pwidth1 = max(pwidth0+lwidth0,xwidth);\n\n  vec3 c = vec3(0.8,1,1);\n\n  c *= 0.6+0.1*sin(10.0*PI*getconicdistance(z,ab));\n  \n  // Draw the main conic\n  float cdist = dot(z*ab,z)-1.0;\n  vec2 cgrad = 2.0*z*ab;\n  cdist /= length(cgrad);\n  c = mix(vec3(0),c,smoothstep(lwidth0,lwidth1,abs(cdist)));\n\n  // The normals from (h,k) = w intersect the conic ax+by-1 = 0\n  // at points lying on conic xy(a-b)+bhy-akx = 0\n  // (from C.Smith, \"Conic Sections\", 1882).\n\n  // Draw the second conic\n  float x = z.x, y = z.y, a = ab.x, b = ab.y, h = w.x, k = w.y;\n  cdist = x*y*(a-b)+b*h*y-a*k*x;\n  cgrad = vec2(y*(a-b)-a*k,x*(a-b)+b*h);\n  cdist /= length(cgrad);\n  c = mix(vec3(0,0,1),c,smoothstep(lwidth0,lwidth1,abs(cdist)));\n\n  // The second conic gives: x = bhy/(ak-y(a-b)) so can substitute\n  // into first & get a quartic fairly easily:\n  // Put x = Ay/(B-Cy) then:\n  // aAy+b(B-Cy)y-(B-Cy) = 0\n  // aAy + b(B-2BCy+Cy)y - B + 2BCy - Cy = 0\n  // bCy - 2bBCy + (aA+bB-C)y + 2BCy - B = 0\n  // so solve the quartic & find points of intersection\n  float A = b*h, B = a*k, C = a-b;\n  // It would be nice to use unicode variable names here\n  // but GLSL disallows it.\n  float alpha = b*C*C;\n  float beta = -2.0*b*B*C;\n  float gamma = a*A*A+b*B*B-C*C;\n  float delta = 2.0*B*C;\n  float epsilon = -B*B;\n  vec4 roots;\n  int nroots = quartic(alpha,beta,gamma,delta,epsilon,roots);\n  for (int i = 0; i < nroots; i++) {\n    float y = roots[i];\n    float x = A*y/(B-C*y);\n    vec2 q = vec2(x,y);\n    if (!isnan(dot(q,q)) && !isinf(dot(q,q))) {\n      c = mix(vec3(1,1,0),c,smoothstep(lwidth0,lwidth1,segment(z,w,q)));\n      c = mix(vec3(1,0,0),c,smoothstep(pwidth0,pwidth1,distance(z,q)));\n    }\n  }\n  c = mix(vec3(0),c,smoothstep(pwidth0,pwidth1,distance(z,w)));\n  c = pow(c,vec3(0.4545));\n  fragColor = vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[653, 653, 673, 673, 728], [730, 730, 787, 787, 811], [813, 813, 875, 875, 905], [907, 938, 994, 994, 1226], [1228, 1294, 1349, 1384, 1980], [1982, 1982, 2045, 2045, 2224], [2226, 2312, 2353, 2353, 3074], [3076, 3141, 3209, 3209, 3729], [3731, 3731, 3805, 3805, 4135], [4137, 4137, 4176, 4176, 4270], [4272, 4272, 4313, 4313, 4779], [4781, 4781, 4833, 4833, 7061]], "test": "untested"}
{"id": "sdXSRn", "name": "tres piramides", "author": "jorge2017a1", "description": "tres piramides", "tags": ["trespiramides"], "likes": 0, "viewed": 201, "published": 3, "date": "1618172068", "time_retrieved": "2024-07-30T19:27:01.957674", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\n//Referencia Iq udTriangle()\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///---------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) ) :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n\nvec3 IniciarPiramideMedida(vec3 p, vec3 medida)\n{\n    \n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    // face 1\n    vec3 f1v1=vec3(1.0,-1.0,1.0);\n    vec3 f1v2=vec3(-1.0,-1.0,-1.0);\n    vec3 f1v3=vec3(1.0,-1.0,-1.0);\n    \n     // face 2\n   vec3 f2v1=vec3(1.0,-1.0,-1.0);\n   vec3 f2v2=vec3(0.0,1.0,0.0);\n   vec3 f2v3=vec3(1.0,-1.0,1.0);\n   \n   \n    // face 3\n   vec3 f3v1=vec3(1.0,-1.0,1.0);\n   vec3 f3v2=vec3(0.0,1.0,0.0);\n   vec3 f3v3=vec3(-1.0,-1.0,1.0);\n   \n   \n   // face 4\n   vec3 f4v1=vec3(-1.0,-1.0,1.0);\n   vec3 f4v2=vec3(0.0,1.0,0.0);\n   vec3 f4v3=vec3(-1.0,-1.0,-1.0);\n   \n      // face 5\n   vec3 f5v1=vec3(0.0,1.0,0.0);\n   vec3 f5v2=vec3(1.0,-1.0,-1.0);\n   vec3 f5v3=vec3(-1.0,-1.0,-1.0);\n   \n   \n   // face 6\n   vec3 f6v1=vec3(1.0,-1.0,1.0);\n   vec3 f6v2=vec3(-1.0,-1.0,1.0);\n   vec3 f6v3=vec3(-1.0,-1.0,-1.0);\n   \n    \n   ///vec3 scala=vec3(10.0,30.0,10.0); \n   vec3 scala=medida;\n   float udt1= udTriangle(  p/scala, f1v1, f1v2, f1v3 )*scala.x;\n   float udt2= udTriangle(  p/scala, f2v1, f2v2, f2v3 )*scala.x;\n   float udt3= udTriangle(  p/scala, f3v1, f3v2, f3v3 )*scala.x;\n   float udt4= udTriangle(  p/scala, f4v1, f4v2, f4v3 )*scala.x;\n   float udt5= udTriangle(  p/scala, f5v1, f5v2, f5v3 )*scala.x;\n   float udt6= udTriangle(  p/scala, f6v1, f6v2, f6v3 )*scala.x;\n    \n   res =opU3(res, vec3(udt1,100.0,-1.0)); \n   res =opU3(res, vec3(udt2,100.0,-1.0)); \n   res =opU3(res, vec3(udt3,100.0,-1.0)); \n   res =opU3(res, vec3(udt4,100.0,-1.0)); \n   res =opU3(res, vec3(udt5,100.0,-1.0)); \n   res =opU3(res, vec3(udt6,100.0,-1.0)); \n   \n   res.x=res.x-0.01;\n   return res;\n   \n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n    \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,100.0,-1.0)); //inf\n    \n    vec3 ip1= IniciarPiramideMedida( p-vec3(-10.0,5.0,0.0), vec3(7.0) );\n    vec3 ip2= IniciarPiramideMedida( p-vec3(0.0,10.0,20.0),vec3(10.0,30.0,10.0)); \n    vec3 ip3= IniciarPiramideMedida( p-vec3(30.0,10.0,20.0),vec3(20.0,40.0,30.0)); \n    \n    res =opU3(res, ip1); \n    res =opU3(res, ip2);\n    res =opU3(res, ip3); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    float strength = 2.; // lower number makes lighting do deeper into sphere\n     //float fresnel = pow(clamp(1.0 + dot(normal, rd), 0.0, 1.0), strength);\n    float  fresnel = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), strength);\n    lin+=vec3(1.0)*fresnel;\n     \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n         if ( abs(dS.x)<MIN_DIST)\n        { mObj.hitbln = true; minDist = abs(dO);break; }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; minDist = min(minDist, dO); break; }\n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); \n      return col;\n    }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    return colobj;\n}\n////----------------------------------\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n    \n\n    vec3 ro=vec3(5.0,7.0+10.0*abs(sin(iTime)),-30.0);\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    //rd= rotate_x(rd, radians(45.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n     col= getSkyColA(rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[589, 633, 680, 680, 707], [709, 709, 752, 752, 779], [781, 781, 829, 829, 857], [858, 942, 978, 978, 1023], [1029, 1094, 1128, 1128, 1226], [1227, 1227, 1261, 1261, 1353], [1354, 1354, 1388, 1388, 1480], [1481, 1521, 1555, 1555, 1652], [1653, 1684, 1709, 1709, 1728], [1729, 1729, 1754, 1754, 1773], [1774, 1774, 1810, 1810, 1838], [1840, 1840, 1892, 1892, 2384], [2388, 2388, 2437, 2437, 3976], [3978, 4018, 4043, 4043, 4639], [4642, 4642, 4707, 4707, 5552], [5554, 5605, 5629, 5629, 5817], [5820, 5820, 5853, 5853, 6536], [6537, 6591, 6627, 6627, 6861], [6862, 6963, 7012, 7012, 7263], [7264, 7298, 7378, 7378, 7655], [7750, 7750, 7843, 7843, 8034], [8035, 8074, 8101, 8101, 8211], [8213, 8262, 8319, 8319, 9696]], "test": "untested"}
{"id": "NsXSzn", "name": "Infinite bezier curve", "author": "mrange", "description": "License CC0: Infinite bezier curve\nWhile I am sure something like this already exists on shadertoy\nI didn't find it and wanted a simple programming challenge for sunday\nevening", "tags": ["2d", "bezier"], "likes": 6, "viewed": 439, "published": 3, "date": "1618166092", "time_retrieved": "2024-07-30T19:27:02.729610", "image_code": "// License CC0: Infinite bezier curve\n//  While I am sure something like this already exists on shadertoy\n//  I didn't find it and wanted a simple programming challenge for sunday\n//  evening\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n#define L2(x)      dot(x, x)\n\nconst float lw = 0.005;\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = L2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( L2(d+(c+b*t.x)*t.x),\n                   L2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nvec2 primitive(vec2 p, vec2 a, vec2 b, vec2 c) {\n  float db = bezier(p, a, b, c)-lw;\n  float d0 = segment(p, a, b);\n  float d1 = segment(p, b, c);\n  float d3 = box(p-a, vec2(lw*4.0));\n  float d4 = box(p-b, vec2(lw*4.0));\n  float d5 = box(p-c, vec2(lw*4.0));\n  \n  float dp = d0;\n  dp = min(dp, d1);\n  dp -= lw;\n  dp = min(dp, d3);\n  dp = min(dp, d4);\n  dp = min(dp, d5);\n\n  return vec2(db, dp);\n}\n\n// The amplitude generating function, x is cell number\nfloat ampl(float x) {\n  return 0.5*hash(x)+0.5*sin(0.5*x+TIME);\n}\n\n// The derivate generating function, x is cell number\nfloat dampl(float x) {\n  // The derivate should be switching signs per cell number in order to\n  //  make the intercepting point lie in the cell\n  float m = fract(x*0.5) > 0.0 ? 1.0 : -1.0;\n  return m*(1.0+0.5*(-1.0 + 2.0*hash(x+123.0)));\n}\n\nvec2 cell(vec2 cp, float cn) {\n  float a0 = ampl(cn);\n  float a1 = ampl(cn+1.0);\n  float d0 = dampl(cn);\n  float d1 = dampl(cn+1.0);\n \n  float t = (a0-a1+d1)/(d1-d0);\n\n  vec2 p0 = vec2(-0.5, a0);\n  vec2 p1 = p0 + t*vec2(1.0, d0);\n  vec2 p2 = vec2(0.5, a1);\n \n  return primitive(cp, p0, p1, p2);\n}\n\nvec2 curve(vec2 p) {\n  vec2 cp = p;\n  float cn = mod1(cp.x, 1.0);\n\n  // Sample surrounding cells to make distance field continuous\n  // A possible optimizations is compute the surrounding cells using\n  // a segments (ie not smooth) instead as the distance field should be \n  // a close approximation at the edges to the \n  vec2 d0 = cell(cp-vec2(-1.0, 0.0), cn-1.0);\n  vec2 d1 = cell(cp, cn);\n  vec2 d2 = cell(cp-vec2(1.0, 0.0), cn+1.0);\n  \n  vec2 d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  \n  return d;\n}\n\nvec2 df(vec2 p) {\n  p.x += TIME;\n  return curve(p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  \n  float z = 0.75;\n  vec2 d = df(p/z)*z;\n  \n  vec3 col = vec3(0.0125);\n  \n  float m = smoothstep(-0.1, 0.1, sin(TIME));\n  col = mix(col, vec3(0.0, 0.75, 0.75), smoothstep(-aa, aa, -d.x));\n  col = mix(col, mix(col, vec3(0.75, 0.0, 0.0), m), smoothstep(-aa, aa, -d.y));\n \n  // Visalizes the distance field\n  // col += vec3(0.25, 0.25, 0.5)*pow((0.5+ 0.5*sin(100.0*d.x)), 20.0);\n  \n  col = pow(clamp(col, 0.0, 1.0), vec3(1.0/2.2));\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXSzn.jpg", "access": "api", "license": "cc0-1.0", "functions": [[304, 304, 326, 326, 374], [376, 407, 446, 446, 571], [573, 624, 663, 663, 782], [784, 835, 862, 862, 942], [944, 995, 1043, 1043, 2075], [2077, 2077, 2125, 2125, 2472], [2474, 2529, 2550, 2550, 2594], [2596, 2650, 2672, 2794, 2890], [2892, 2892, 2922, 2922, 3188], [3190, 3190, 3210, 3210, 3698], [3700, 3700, 3717, 3717, 3753], [3755, 3755, 3810, 3810, 4404]], "test": "error"}
{"id": "7sj3Dt", "name": "Freaky Checkers", "author": "kaihagseth", "description": "Moirepatterns", "tags": ["moire", "pattern"], "likes": 3, "viewed": 319, "published": 3, "date": "1618161996", "time_retrieved": "2024-07-30T19:27:03.513514", "image_code": "/* \n * Author: Kai Hagseth\n * Inspired by the great Tadashi Tokieda\n * https://youtu.be/QAja2jp1VjE\n*/\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define PI 3.14159265359\n#define N 30.0\n\nvec3 checker(in vec2 st)\n{\n  float checkSize = 2.0;\n  float fmodResult = mod(floor(checkSize * st.x) + floor(checkSize * st.y), 2.0);\n  return vec3(smoothstep(1.0, 0.0, sign(fmodResult)));\n}\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nvec2 rotate(in vec2 inp)\n{\n    inp *=  1.+(.05*sin(iTime/(1.618*10.)));\n    inp *= rotate2d(.15*cos(iTime/10.0));\n    return inp;\n}\n\nvec3 pattern(vec2 st, vec3 color, float n)\n{\n    st += iResolution.xy;\n    st *= n;      \n    st = fract(st);\n    return color * checker(st);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = ( fragCoord - .5* iResolution.y) / iResolution. y;\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    vec3 pattern1 = pattern(st, color, N);\n    vec2 st2 = rotate(st);\n    \n    vec3 pattern2 = pattern(st2, color, N);\n    vec3 dots = pattern1  + pattern2;\n\tdots = 1.0-(dots*1.0); //inverse\n    fragColor = vec4(dots,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sj3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 214, 214, 378], [381, 381, 409, 409, 495], [496, 496, 522, 522, 627], [629, 629, 673, 673, 772], [775, 775, 832, 832, 1160]], "test": "untested"}
{"id": "Nd2GWd", "name": "Quintic Surface Intersect I", "author": "oneshade", "description": "Numerically finding the intersections with a quintic surface.", "tags": ["raytracing", "ray", "raycasting", "surface", "intersect", "quintic", "numeric"], "likes": 10, "viewed": 189, "published": 3, "date": "1618161896", "time_retrieved": "2024-07-30T19:27:04.355264", "image_code": "#define ZERO min(iFrame, 0)\n\nstruct Params {\n    float bmin;\n    float bmax;\n    float epsilon;\n    bool wrap;\n    int searches;\n    int iters;\n};\n\nstruct Roots5 {\n    int nroots;\n    float[5] roots;\n};\n\nfloat evalQuintic(in float x, in float a, in float b, in float c, in float d, in float e, in float f) {\n    return ((((a * x + b) * x + c) * x + d) * x + e) * x + f;\n}\n\nfloat evalQuinticPrime(in float x, in float a, in float b, in float c, in float d, in float e, in float f) {\n    return (((5.0 * a * x + 4.0 * b) * x + 3.0 * c) * x + 2.0 * d) * x + e;\n}\n\n// Can be made much simpler if your only looking for the closest intersection\nRoots5 solveQuintic(in float a, in float b, in float c, in float d, in float e, in float f, in Params params) {\n    float[5] rootArray;\n    Roots5 roots = Roots5(0, rootArray);\n    float interval = 1.0 / float(params.searches);\n    float start = 0.0;\n    for (int search=ZERO; search < params.searches; search++) {\n        float root = mix(params.bmin, params.bmax, start);\n        for (int nrIter=ZERO; nrIter < params.iters; nrIter++) {\n            float nrStep = root -= evalQuintic(root, a, b, c, d, e, f) / evalQuinticPrime(root, a, b, c, d, e, f);\n            if (params.wrap) root = params.bmin + mod(root - params.bmin, params.bmax - params.bmin);\n            if (abs(nrStep) < params.epsilon) break;\n        }\n\n        bool unique = true;\n        for (int n=ZERO; n < roots.nroots; n++) {\n            if (abs(root - roots.roots[n]) < params.epsilon) {\n                unique = false;\n                break;\n            }\n        }\n\n        if (abs(evalQuintic(root, a, b, c, d, e, f)) < params.epsilon && unique) {\n            //roots.roots[roots.nroots] = root;\n            //roots.nroots++;\n            switch(roots.nroots) {\n                case 0: roots.roots[0] = root; break;\n                case 1: roots.roots[1] = root; break;\n                case 2: roots.roots[2] = root; break;\n                case 3: roots.roots[3] = root; break;\n                case 4: roots.roots[4] = root; break;\n            };\n\n            roots.nroots++;\n\n        }\n\n        start += interval; // Randomizing it works surprisingly well too\n    }\n\n    return roots;\n}\n\n// Intersection\n// Implicit equation: x^2 + y^2 + z^2 + x^2y^2z - 2\nRoots5 iQuintic(in vec3 ro, in vec3 rd) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Zero simplifications\n    float a = u * u * v * v * w;\n    float b = z * u * u * v * v + 2.0 * x * u * v * v * w + 2.0 * y * u * u * v * w;\n    float c = 2.0 * x * z * u * v * v + 2.0 * y * z * u * u * v + y * y * u * u * w + x * x * v * v * w + 4.0 * x * y * u * v * w;\n    float d = u * u + v * v + w * w + y * y * z * u * u + x * x * z * v * v + 4.0 * x * y * z * u * v + 2.0 * x * y * y * u * w + 2.0 * x * x * y * v * w;\n    float e = 2.0 * x * u + 2.0 * y * v + 2.0 * z * w + 2.0 * x * y * y * z * u + 2.0 * x * x * y * z * v + x * x * y * y * w;\n    float f = x * x + y * y + z * z + x * x * y * y * z - 2.0;\n\n    return solveQuintic(a, b, c, d, e, f, Params(3.0, 10.0, 0.001, true, 25, 10));\n}\n\n// Normal\nvec3 nQuintic(in vec3 p) {\n    return normalize(vec3(p.x + p.x * p.y * p.y * p.z, p.y + p.x * p.x * p.y * p.z, p.z + 0.5 * p.x * p.x * p.y * p.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 6.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    // Animate\n    float radius = 2.0 + cos(iTime);\n    float thickness = 1.0 + 0.5 * sin(iTime);\n\n    // Find the closest hit in front of the camera\n    Roots5 hit = iQuintic(ro, rd);\n    float t = 1000000000.0;\n    vec3 hitPos;\n    for (int n=0; n < int(hit.nroots); n++) {\n        vec3 hitCandid = ro + rd * hit.roots[n];\n        if (hit.roots[n] > 0.0 && hit.roots[n] < t) {\n            t = hit.roots[n];\n            hitPos = hitCandid;\n        }\n    }\n\n    // Render the shape if hitting\n    if (t < 1000000000.0) {\n        vec3 n = nQuintic(hitPos);\n        float diff = abs(dot(n, -rd));\n        float checkers = mod(dot(floor(hitPos * 2.0), vec3(1.0)), 2.0);\n        fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25);\n        fragColor.rgb *= diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2GWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 307, 307, 371], [373, 373, 481, 481, 559], [2203, 2271, 2312, 2312, 3101], [3103, 3113, 3139, 3139, 3262], [3264, 3264, 3319, 3319, 4817]], "test": "untested"}
{"id": "ssS3DV", "name": "Image Morph Bleed Effect (v.Fab)", "author": "FabriceNeyret2", "description": "refactoring, commenting and extending _bm' \"Image Morph Bleed Effect\" [url]https://shadertoy.com/view/NdS3WK[/url]\n\nmorphing one image into another only by swapping random pixels every frame\nBuffer A iChannel1 is the source image, it morphs into iChannel3", "tags": ["experiment", "glitch", "morph"], "likes": 14, "viewed": 739, "published": 3, "date": "1618147751", "time_retrieved": "2024-07-30T19:27:05.132186", "image_code": "// Fork of \"Image Morph Bleed Effect\" by _bm. https://shadertoy.com/view/NdS3WK\n// 2021-04-09 11:50:28\n// Refactoring, commenting and extending\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --- metrics for color similarity \n\n//#define dist(c1,c2) distance(c1,c2)\n  #define dist(c1,c2) distance(c1.rgb,c2.rgb)\n//#define dist(c1,c2) distance( c1 / max(c1.r,max(c1.g,c1.b)), c2 / max(c2.r,max(c2.g,c2.b)) )\n//#define dist(c1,c2) distance(c1.r,c2.r)\n//#define dist(c1,c2) max(0.,1.-distance(c1.rgb,c2.rgb))\n\n#define DIST 8.\n\n#define hash(s)  ( texture(iChannel2, U + iTime * s /R ).xy - .5 )\n\n#define T(s)       texture(iChannel0, U + amnt* hash(s)/R )\n \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = u/R;\n         \n    vec4 bg = texture(iChannel3, U);             // target image\n    \n    O = texture(iChannel0, U);                   // current stage\n    float amnt = DIST * dist(bg, O);             // difference to target\n    vec4 c1 = T(1.93937174e6),                   // pull alternate value\n         c2 = T(1.12380517e5);                   // as far as unconverged\n   \n    float a = dist(c1, bg),                      // difference to target\n          b = dist(c2, bg);\n    if ( b < a ) a = b, c1 = c2;                 // get the closest\n    O =  mix(c1, O, min(2.*a, 1.) );             //  is close enought, blend it weigthed by convergence\n\n    if (O==vec4(0))  O = texture(iChannel1, U);  // init texture (for the color palette)\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssS3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 202, 202, 268]], "test": "untested"}
{"id": "fd23Dd", "name": "Freaky Dots", "author": "kaihagseth", "description": "A shader for generating moire patterns", "tags": ["moire", "pattern"], "likes": 4, "viewed": 253, "published": 3, "date": "1618144708", "time_retrieved": "2024-07-30T19:27:05.948006", "image_code": "\n// Author: Kai Hagseth\n// Title: Freaky Dot Patterns\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n#define PI 3.14159265359\n#define NDOTS 35.0\n#define DOTRADIUS 0.1\n\n/* \n * Inspired by the great Tadashi Tokieda\n * https://youtu.be/QAja2jp1VjE\n*/\n\n\nvec3 circle(in vec2 _st, in float _radius, vec3 color){\n    vec2 dist = _st - vec2(0.5);\n\tfloat o = 1.-smoothstep(\n                         _radius-(_radius * 0.3),\n                         _radius+(_radius * 0.3),\n                         dot(dist, dist * 4.0));\n    return color * o;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n// Rotate rgb around green axis\nmat3 rotate3d(float _angle){\n\n    return mat3( cos(_angle), 0.0, sin(_angle),\n                 0.0          , 1.0, 0.0,\n                -sin(_angle), 0.0, cos(_angle));\n}\n\nvec2 rotate(in vec2 inp)\n{\n    inp *= 1.0 + (0.1 * sin(0.1 * (iTime * 0.618)));           //scale\n    inp *= rotate2d(0.1 * sin(0.1 * iTime)); //rotate\n    return inp;\n}\n\nvec3 dotPattern(vec2 st, vec3 color, float nDots, float dotRadius)\n{\n    st += iResolution.xy;\n    st *= nDots;      // Scale up the space by \n    st = fract(st);   // Wrap around 1.0\n\treturn vec3(circle(st, dotRadius, color));\n}\n\nvec3 color(in vec2 st, float t)\n{\n  vec3 c = vec3(0.7, 0.2, 0.4) + (vec3(0.5, 0., 0.) * rotate3d(iTime + st.x));\n  return vec3(c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = ( fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    st += vec2(1.0); // Offset origo\n    vec3 color = color(st, iTime);\n    \n    vec2 st1 = rotate(st);\n    vec3 dots1 = dotPattern(st1, color, NDOTS ,DOTRADIUS);\n    \n    vec2 st2 = rotate(st1);\n    vec3 dots2 = dotPattern(st2, color, NDOTS, DOTRADIUS);\n    \n    vec3 bg = vec3(0.0, 0.0, 0.2);\n    vec3 dots = dots1 + dots2 + bg;\n\t//dots = 1.0-(dots*1.0); //inverse B/W\n    fragColor = vec4(dots,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd23Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 304, 304, 536], [538, 538, 566, 566, 652], [654, 686, 714, 714, 856], [858, 858, 884, 884, 1027], [1029, 1029, 1097, 1097, 1258], [1260, 1260, 1293, 1293, 1392], [1395, 1395, 1452, 1452, 1925]], "test": "untested"}
{"id": "7dSGWK", "name": "Quad - distance 2D", "author": "iq", "description": "Distance to a quad. More SDFs here: [url]https://www.shadertoy.com/playlist/MXdSRf[/url] and [url]www.iquilezles.org/articles/distfunctions2d/distfunctions2d.htm[/url]", "tags": ["2d", "distancefield", "sdf", "distance", "quad"], "likes": 12, "viewed": 828, "published": 3, "date": "1618138944", "time_retrieved": "2024-07-30T19:27:06.709967", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a quad.\n//\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n//\n// Gradient of a quad here: https://www.shadertoy.com/view/WtVcD1\n\n\n// signed distance to a 2D quad\nfloat sdQuad( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n\tvec2 e0 = p1 - p0; vec2 v0 = p - p0;\n\tvec2 e1 = p2 - p1; vec2 v1 = p - p1;\n\tvec2 e2 = p3 - p2; vec2 v2 = p - p2;\n\tvec2 e3 = p0 - p3; vec2 v3 = p - p3;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    vec2 pq3 = v3 - e3*clamp( dot(v3,e3)/dot(e3,e3), 0.0, 1.0 );\n    \n    vec2 ds = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                        vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                   min( vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ),\n                        vec2( dot( pq3, pq3 ), v3.x*e3.y-v3.y*e3.x ) ));\n\n    float d = sqrt(ds.x);\n\n\treturn (ds.y>0.0) ? -d : d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n\tvec2 v1 = 0.8*cos( iTime + vec2(0.0,2.00) + 0.0 );\n\tvec2 v2 = 0.8*cos( iTime + vec2(0.0,1.50) + 1.5 );\n\tvec2 v3 = 0.8*cos( iTime + vec2(0.0,3.00) + 4.0 );\n\tvec2 v4 = 0.8*cos( iTime + vec2(1.0,3.00) + 5.0 );\n\n\tfloat d = sdQuad( p, v1, v2, v3, v4 );\n\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp2(-12.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdQuad(m, v1, v2, v3, v4 );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSGWK.jpg", "access": "api", "license": "mit", "functions": [[1298, 1330, 1405, 1405, 2157], [2159, 2159, 2216, 2216, 3074]], "test": "ok"}
{"id": "Ndj3Wt", "name": "celluar_noise_8x", "author": "penghuailiang", "description": " \n\nhttps://huailiang.github.io/blog/2021/noise/", "tags": ["noise"], "likes": 2, "viewed": 223, "published": 3, "date": "1618119926", "time_retrieved": "2024-07-30T19:27:07.537754", "image_code": "#define SCALE 8.\n\nvec2 random(vec2 st){\n    return  fract(\n        sin(\n            vec2(\n                dot(st, vec2(127.1,311.7)),\n                dot(st, vec2(269.5,183.3))\n            )\n        ) * 43758.5453\n    );\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p); // i\n    vec2 f = fract(p); // \n    float F1 = 1.;\n    // 9\n    for (int j = -1; j <= 1; j++) {\n        for (int k = -1; k <= 1; k++) {\n            vec2 neighbor = vec2(float(j), float(k));\n            vec2 point = random(i + neighbor);\n            float d = length(point + neighbor - f);\n            F1 = min(F1,d);\n        }\n    }\n    return F1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float c = noise(vec2(SCALE*uv));\n    c = pow(c, 2. * (0.5+abs(sin(iTime))));\n    vec3 color= vec3(c,c,c);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndj3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 39, 39, 222], [224, 224, 245, 245, 735], [737, 737, 792, 792, 981]], "test": "untested"}
{"id": "fd2GWt", "name": "Distance to Ellipse", "author": "oneshade", "description": "The stability is horrible.", "tags": ["2d", "sdf", "distance", "quartic", "ellipse", "unstable"], "likes": 2, "viewed": 159, "published": 3, "date": "1618117782", "time_retrieved": "2024-07-30T19:27:08.403440", "image_code": "/*\nInterestingly, the quartic equation reflects the fact\nthat b*sqrt(1-x^2/a^2) is actually representing an entire\nellipse rather than just the half that appears in the\ngraph (https://www.desmos.com/calculator/548fbp3kdv).\n*/\n\n// Can sometimes increase stability\n//#define REVERSE_COEFFICIENTS\n\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    float bb = b * b;\n    float p = c - 0.375 * bb;\n    float q = d - 0.5 * b * c + 0.125 * bb * b;\n    float r = e - 0.25 * b * d + 0.0625 * bb * c - 0.01171875 * bb * bb;\n    int n = 0;\n\n    // Solve for an arbitary root to x^3 + 2px^2 + (p^2 - 4r)x - q^2\n    float ra = 2.0 * p;\n    float rb = p * p - 4.0 * r;\n    float rc = -q * q;\n\n    float raa = ra * ra;\n    float inflect = ra / 3.0;\n\n    float rp = rb - raa / 3.0;\n    float rq = raa * ra / 13.5 - ra * rb / 3.0 + rc;\n    float rppp = rp * rp * rp, rqq = rq * rq;\n\n    float p2 = abs(rp);\n    float v1 = 1.5 / rp * rq;\n\n    float lambda;\n    if (rqq * 0.25 + rppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (rp < 0.0) lambda = sign(rq) * cosh(acosh(v2 * -sign(rq)) / 3.0);\n        else lambda = sinh(asinh(v2) / 3.0);\n        lambda = -sqrt(p2 / 3.0) * lambda;\n    }\n\n    else lambda = sqrt(-rp / 3.0) * cos(acos(v1 * sqrt(-3.0 / rp)) / 3.0);\n    lambda = 2.0 * lambda - inflect;\n\n    // Solve two quadratic equations (checking for negative sqrts which should be complex)\n    if (lambda < 0.0) return n;\n    float sqrtLambda = sqrt(lambda);\n\n    float pLambda = p + lambda, qLambda = q * inversesqrt(lambda);\n    float offs = 0.25 * b;\n\n    float foo = lambda - 2.0 * (pLambda + qLambda);\n    float bar = lambda - 2.0 * (pLambda - qLambda);\n\n    if (foo >= 0.0) {\n        roots.xy = (vec2(1.0, -1.0) * sqrt(foo) + sqrtLambda) * 0.5 - offs;\n        n += 2;\n    }\n\n    if (bar >= 0.0) {\n        vec2 others = (vec2(1.0, -1.0) * sqrt(bar) - sqrtLambda) * 0.5 - offs;\n        if (n > 0) roots.zw = others;\n        else roots.xy = others;\n        n += 2;\n    }\n\n    return n;\n}\n\n// Reverse coefficients trick increases stability\nint solveQuartic2(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    int nroots = solveQuartic(e, d, c, b, a, roots);\n    if (nroots == 0) return 0;\n    if (nroots == 2) roots.xy = 1.0 / roots.xy;\n    if (nroots == 4) roots = 1.0 / roots;\n    return nroots;\n}\n\n// Start with parametric form:\n// (a * cos(t), b * sin(t))\n//\n// Change to \"y=\"\n// b * sin(cos^-1(x / a)) --> b * sqrt(1 - x^2 / a^2)\n//\n// Squared distance:\n// (p.x - x)^2 + (p.y - b * sqrt(1 - x^2 / a^2))^2\n//\n// Find roots of derivative of the squared distance to find the minimum\n// Algebraically eliminating the square roots results in a quartic equation\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    p = abs(p);\n    vec2 qq = ab * ab, pp = p * p;\n\n    float a = 2.0 * qq.y - qq.y * qq.y / qq.x - qq.x;\n    float b = 2.0 * p.x * (qq.x - qq.y);\n    float c = dot(qq - pp, qq) - 2.0 * qq.x * qq.y;\n    float d = 2.0 * p.x * qq.x * (qq.y - qq.x);\n    float e = pp.x * qq.x * qq.x;\n\n    vec4 roots;\n\n    #ifdef REVERSE_COEFFICIENTS\n    int nroots = solveQuartic2(a, b, c, d, e, roots);\n    #else\n    int nroots = solveQuartic(a, b, c, d, e, roots);\n    #endif\n\n    float dist = dot2(p - vec2(roots[0], ab.y * sqrt(1.0 - roots[0] * roots[0] / qq.x)));\n    for (int n=1; n < nroots; n++) {\n        dist = min(dist, dot2(p - vec2(roots[n], ab.y * sqrt(1.0 - roots[n] * roots[n] / qq.x))));\n    }\n\n    return sqrt(dist) * sign(dot2(p / ab) - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.0;\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 2.0 : vec2(1.2, 0.6);\n\n    float d = sdEllipse(uv, abs(mouse));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2GWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 391, 391, 2131], [2133, 2183, 2280, 2280, 2475], [2838, 2838, 2861, 2861, 2881], [2882, 2882, 2922, 2922, 3667], [3669, 3669, 3724, 3724, 4222]], "test": "untested"}
{"id": "4tGBzy", "name": "Simple half-tone", "author": "Zavie", "description": "A quick half-tone example.", "tags": ["halftone", "postprocess"], "likes": 3, "viewed": 358, "published": 3, "date": "1618115266", "time_retrieved": "2024-07-30T19:27:09.167397", "image_code": "/*\n\nA very simple half-tone pattern.\n\n--\nZavie\n\n*/\n\n\n#define GRID_SIZE (iResolution.x/9.)\n#define PI acos(-1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = PI/6.;\n    float sine = sin(angle);\n    float cosine = cos(angle);\n    mat2 rotation = mat2(cosine, -sine, sine, cosine);\n    mat2 invRotation = mat2(cosine, sine, -sine, cosine);\n\n    vec2 grid = fract(rotation*GRID_SIZE * fragCoord/iResolution.x);\n    vec2 gridSize = GRID_SIZE * vec2(1., iResolution.y / iResolution.x);\n    vec2 uv = invRotation*floor(rotation*fragCoord/iResolution.xy * gridSize) / gridSize;\n\n    float inputColor = texture(iChannel0, uv).x;\n\n    float dist = length(grid-0.5);\n    float dd = fwidth(dist);\n    float dotPattern = 1.-dist;\n    float outputColor = clamp((inputColor - 4./PI*dotPattern*dotPattern+dd)/dd, 0., 1.);\n\n    fragColor = vec4(vec3(outputColor),1.0);\n}\n", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGBzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 169, 169, 884]], "test": "untested"}
{"id": "Wds3Rl", "name": "Canny edge detection", "author": "Zavie", "description": "An implementation of the non maximum gradient suppression in Canny edge detection.\nUse the mouse to control the line thickness.", "tags": ["filter", "edgedetection", "convolution", "gaussian", "canny", "scharr"], "likes": 22, "viewed": 840, "published": 3, "date": "1618112351", "time_retrieved": "2024-07-30T19:27:10.219584", "image_code": "/*\n\nAn (incomplete) implementation of the Canny edge detection.\n\nStep 1: Gaussian blur.\nStep 2: edge detection.\nStep 3: non max suppression.\n\nThe last steps of the Canny edge detection are missing: after the\nnon-max value suppression, lines are supposed to be connected and\npruned.\n\n--\nZavie\n\n*/\n\n#define PI acos(-1.)\n\nvec3 hue(float angle)\n{\n    float r = clamp(sin(angle), 0., 1.);\n    float g = clamp(sin(angle + 2.*PI/3.), 0., 1.);\n    float b = clamp(sin(angle + 4.*PI/3.), 0., 1.);\n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 dx = vec2(1. / iResolution.x, 0.);\n    vec2 dy = vec2(0., 1. / iResolution.y);\n\n    vec4 gradientInfo = texture(iChannel3, uv);\n\n#if VARIABLE_THICKNESS\n    float thicknessControl = fract(uv.x);\n    //float thicknessControl = abs(fract(uv.x*3.) * 2. - 1.);\n    float thickness = mix(0., float(MAX_THICKNESS), thicknessControl);\n#else\n    float thickness = float(MAX_THICKNESS) * iMouse.x/iResolution.x;\n#endif\n    for (int j = -MAX_THICKNESS; j <= +MAX_THICKNESS; ++j)\n    {\n        for (int i = -MAX_THICKNESS; i <= +MAX_THICKNESS; ++i)\n        {\n            vec2 offset = float(i)*dx + float(j)*dy;\n            float r = length(vec2(i, j));\n\n            vec4 a = texture(iChannel3, uv + offset);\n            if (a.x > gradientInfo.x)\n            {\n                gradientInfo = mix(gradientInfo, a, smoothstep(0.5, -0.5, r - thickness));\n            }\n        }\n    }\n    float amplitude = gradientInfo.x;\n\n    vec3 inputImage = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    vec3 blurredImage = texture(iChannel1, fragCoord.xy / iResolution.xy).rgb;\n    vec3 gradient = texture(iChannel2, fragCoord.xy / iResolution.xy).xxx;\n#if SHOW_GRADIENT_DIRECTION\n    gradient *= hue(gradientInfo.w);\n#endif // SHOW_GRADIENT_DIRECTION\n    vec3 maxGradient = texture(iChannel3, fragCoord.xy / iResolution.xy).xxx;\n    vec3 thicknessAdded = vec3(amplitude);\n\n#if SCALE_FIRST\n    float finalEdge = smoothstep(0.2, 0.25, amplitude);\n#else // !SCALE_FIRST\n    float finalEdge = smoothstep(0.02, 0.025, amplitude);\n#endif // !SCALE_FIRST\n    vec3 finalResult = mix(vec3(0.8, 0.77, 0.7), vec3(0.2, 0.24, 0.3), finalEdge);\n\n    fragColor = vec4(finalResult, 1.);\n\n    // Showcase the steps:\n    float t = fract(0.05*iTime+0.1*uv.x);\n    fragColor.rgb = mix(fragColor.rgb, inputImage, smoothstep(0.4, 0.405, t));\n    fragColor.rgb = mix(fragColor.rgb, blurredImage, smoothstep(0.5, 0.505, t));\n    fragColor.rgb = mix(fragColor.rgb, gradient, smoothstep(0.6, 0.605, t));\n    fragColor.rgb = mix(fragColor.rgb, maxGradient, smoothstep(0.7, 0.705, t));\n    fragColor.rgb = mix(fragColor.rgb, vec3(amplitude), smoothstep(0.8, 0.805, t));\n    fragColor.rgb = mix(fragColor.rgb, vec3(finalEdge), smoothstep(0.9, 0.905, t));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\nAn (incomplete) implementation of the Canny edge detection.\n\nSource image step.\nBlending between two fairly different videos.\n\n--\nZavie\n\n*/\n\n\nfloat luma(vec3 color)\n{\n    return dot(color, vec3(0.2116, 0.7152, 0.0722));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float image0 = luma(texture(iChannel0, uv).rgb);\n    float image1 = luma(texture(iChannel1, uv).rgb);\n\n\tfloat change = smoothstep(0.3, 0.7, abs(fract(iTime*0.2) * 2. - 1.));\n\n    fragColor = vec4(vec3(mix(image0, image1, change)), 1.);\n}\n", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n\nAn (incomplete) implementation of the Canny edge detection.\n\nStep 1: Gaussian blur.\n\n--\nZavie\n*/\n\n\n//\n//  1 | 2 | 1\n// ---+---+---\n//  2 | 4 | 2\n// ---+---+---\n//  1 | 2 | 1\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 dx = vec2(1. / iResolution.x, 0.);\n    vec2 dy = vec2(0., 1. / iResolution.y);\n\n    float a = texture(iChannel0, uv - dx - dy).x;\n    float b = texture(iChannel0, uv      - dy).x;\n    float c = texture(iChannel0, uv + dx - dy).x;\n    float d = texture(iChannel0, uv - dx     ).x;\n    float e = texture(iChannel0, uv          ).x;\n    float f = texture(iChannel0, uv + dx     ).x;\n    float g = texture(iChannel0, uv - dx + dy).x;\n    float h = texture(iChannel0, uv      + dy).x;\n    float i = texture(iChannel0, uv + dx + dy).x;\n\n    float blurred = 1./16. * (\n        1.*a + 2.*b + 1.*c +\n        2.*d + 4.*e + 2.*f +\n        1.*g + 2.*h + 1.*i\n        );\n    fragColor = vec4(vec3(blurred), 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/*\n\nAn (incomplete) implementation of the Canny edge detection.\n\nStep 2: edge detection.\n\nThe Scharr operator is used; it is similar to the Sobel operator\nbut has better rotational symmetry.\n\n--\nZavie\n*/\n\n\n//\n// Scharr operator.\n//\n// -3 | 0 | 3     -3 |-10|-3\n// ---+---+---    ---+---+---\n// -10| 0 | 10     0 | 0 | 0\n// ---+---+---    ---+---+---\n// -3 | 0 | 3      3 | 10| 3\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 dx = vec2(1. / iResolution.x, 0.);\n    vec2 dy = vec2(0., 1. / iResolution.y);\n\n    float a = texture(iChannel0, uv - dx - dy).x;\n    float b = texture(iChannel0, uv      - dy).x;\n    float c = texture(iChannel0, uv + dx - dy).x;\n    float d = texture(iChannel0, uv - dx     ).x;\n    float e = texture(iChannel0, uv          ).x;\n    float f = texture(iChannel0, uv + dx     ).x;\n    float g = texture(iChannel0, uv - dx + dy).x;\n    float h = texture(iChannel0, uv      + dy).x;\n    float i = texture(iChannel0, uv + dx + dy).x;\n\n    float Gx = 1./32. * (\n        -3. *a + 3. *c +\n        -10.*d + 10.*f +\n        -3. *g + 3. *i\n        );\n\n    float Gy = 1./32. * (\n        -3.*a + -10.*b + -3.*c +\n        3. *g + 10.*h + 3. *i\n        );\n\n    vec2 G = vec2(Gx, Gy);\n#if SCALE_FIRST\n    G *= 10.;\n#endif //SCALE_FIRST\n\n    float amplitude = sqrt(dot(G, G));\n    float theta = atan(G.y, G.x);\n\n    fragColor = vec4(amplitude, G, theta);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/*\n\nAn (incomplete) implementation of the Canny edge detection.\n\nStep 3: non max suppression.\n\n--\nZavie\n*/\n\n\n#define PI acos(-1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 dx = vec2(1. / iResolution.x, 0.);\n    vec2 dy = vec2(0., 1. / iResolution.y);\n\n    vec4 gradientInfo = texture(iChannel0, uv);\n    float amplitude = gradientInfo.x;\n    vec2 G = gradientInfo.yz;\n    float theta = gradientInfo.w;\n\n    float localMax = 0.;\n    if ((theta < 0.125 * PI && theta > -0.125 * PI) ||\n        (theta > 0.875 * PI || theta < -0.875 * PI))\n    {\n        localMax = max(localMax, texture(iChannel0, uv + dx).x);\n        localMax = max(localMax, texture(iChannel0, uv - dx).x);\n    }\n    if ((theta > 0.125 * PI && theta < 0.365 * PI) ||\n       (theta > -0.875 * PI && theta < -0.625 * PI))\n    {\n        localMax = max(localMax, texture(iChannel0, uv - dx - dy).x);\n        localMax = max(localMax, texture(iChannel0, uv + dx + dy).x);\n    }\n    if ((theta > 0.375 * PI && theta < 0.625 * PI) ||\n        (theta < -0.375 * PI && theta > -0.625 * PI))\n    {\n        localMax = max(localMax, texture(iChannel0, uv - dy).x);\n        localMax = max(localMax, texture(iChannel0, uv + dy).x);\n    }\n    if ((theta > 0.625 * PI && theta < 0.875 * PI) ||\n        (theta > -0.365 * PI && theta < -0.125 * PI))\n    {\n        localMax = max(localMax, texture(iChannel0, uv + dx - dy).x);\n        localMax = max(localMax, texture(iChannel0, uv - dx + dy).x);\n    }\n\n    if (gradientInfo.x < localMax)\n    {\n        gradientInfo.x = 0.;\n        gradientInfo.y = 0.;\n        gradientInfo.z = 0.;\n    }\n    fragColor = vec4(gradientInfo);\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n\nAn (incomplete) implementation of the Canny edge detection.\n\nMacros.\n\n--\nZavie\n\n*/\n\n#define SCALE_FIRST 1\n#define VARIABLE_THICKNESS 0\n#define MAX_THICKNESS 8\n#define SHOW_GRADIENT_DIRECTION 0\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wds3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 319, 342, 342, 515], [517, 517, 574, 574, 2844]], "test": "untested"}
{"id": "7dS3Dd", "name": "Some fuggin Water", "author": "Protowalker", "description": "stealing from SMG2", "tags": ["water", "theft"], "likes": 2, "viewed": 248, "published": 3, "date": "1618108192", "time_retrieved": "2024-07-30T19:27:11.180016", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float speed = 1.0/50.0;\n    \n    vec4 col = texture(iChannel0, (uv/5.0) + (vec2(iTime*speed)));\n    col = avg(col);\n    uv = vec2(1.0) - uv;\n    vec4 op_col = texture(iChannel0, (uv/5.0) + (vec2(iTime*speed)));\n    \n    col.a = 0.5;\n    op_col.a = 0.5;\n    col += op_col;\n \n     uv = fragCoord/iResolution.xy;\n     \n//     col *= texture(iChannel0, uv/5.0);\n    col = avg(col);\n    \n    float offset = col.x * 2.0 - 1.0;\n    \n     \n    vec2 scroll = vec2(0., iTime/3.);\n    \n    \n    \n    fragColor = texture(iChannel0, uv + vec2(offset/60.0));\n    vec4 buf_col = texture(iChannel1, uv + scroll);\n    fragColor += vec4(buf_col.rgb * buf_col.a, 0.0);\n    //fragColor = texture(iChannel1, uv);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 avg(vec2 vec) {\n    float avg = vec.x + vec.y;\n    return vec2(avg/2.0);\n}\n\nvec3 avg(vec3 vec) {\n    float avg = vec.x + vec.y + vec.z;\n    return vec3(avg/3.0);\n}\n\nvec4 avg(vec4 vec) {\n    float avg = vec.x + vec.y + vec.z + vec.z;\n    return vec4(avg/4.0);\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = (avg(texture(iChannel0, uv + (iTime/3.0))) - 0.6);\n    if(col.x > sin(avg(uv*5.0).x + iTime*3.0)/10.0)\n        col = vec4(1.0);\n    fragColor = vec4(vec3(col.x), 0.01);\n    \n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dS3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 850]], "test": "untested"}
{"id": "7dB3Wd", "name": "Twisty chocolate-bar torus", "author": "MacSlow", "description": "Just a torus with a custom cross-section, which rotates. I wish one could buy candy-bars like this :) You can orbit around the torus with the mouse.", "tags": ["3d", "phong", "torus", "candy", "cineshader"], "likes": 13, "viewed": 1167, "published": 3, "date": "1618105976", "time_retrieved": "2024-07-30T19:27:12.054677", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Twisty chocolate-bar torus - some version of eye-candy ;)\n//\n// Copyright 2021 Mirco Mller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Mller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// lower AA_SIZE to 2 or 1, if it runs too slow\nconst int AA_SIZE = 3;\nconst float PI = 3.14159265359;\nconst int MAX_ITER = 64;\nconst float STEP_BIAS = .75;\nconst float EPSILON = .0001;\nconst float MAX_DIST = 25.;\n\nmat2 r2d (float rad)\n{\n    float c = cos (rad);\n    float s = sin (rad);\n\n    return mat2 (c, s, -s, c);\n}\n\nfloat sdBox2D (vec2 p, vec2 size, float r)\n{\n    vec2 q = abs(p) - size;\n    return length(max(q,0.0)) + min(max(q.x, q.y),0.0) - r;\n}\n\nfloat sdTorus (vec3 p, vec3 q)\n{\n    float offset = q.x;\n    float r1 = q.y;\n    float r2 = q.z;\n\n    float angle = atan (p.x, p.z);\n\n    vec2 t = vec2 (length (p.xz) - r1, p.y);\n\n    t *= r2d (3.*angle);\n    t.y = abs (t.y) - offset;\n\n    float r = r2*(1. + .5*(cos(3.*angle)));\n    t *= r2d (iTime);\n    float doubleRectProfile = sdBox2D (t, vec2 (.08, .03), r*.75);\n\n    return doubleRectProfile;\n}\n\nfloat scene (vec3 p)\n{\n    float ground = p.y + 1.;\n\n    float offset = .2;\n    float r1 = 1.;\n    float r2 = .1;\n    float torus = sdTorus (p, vec3 (offset, r1, r2));\n\n    float d = min (torus, ground); \n\n    return d;\n}\n\nfloat raymarch (vec3 ro, vec3 rd)\n{\n    float t = .0;\n    float d = .0;\n    vec3 p = vec3 (.0);\n    int i = 0;\n\n    for (; i < MAX_ITER; ++i) {\n        p = ro + d*rd;\n        t = scene (p);\n        if (abs (t) < EPSILON*(1. - .125*t) || d > MAX_DIST) break;\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 e = vec2 (EPSILON, .0);\n    float d = scene (p);\n    return normalize (vec3 (scene (p + e.xyy),\n                            scene (p + e.yxy),\n                            scene (p + e.yyx)) - d);\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 camForward = normalize (aim - ro);\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = camForward*zoom + ro;\n\n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nfloat shadow (vec3 p, vec3 n, vec3 lPos, vec3 lDir)\n{\n    float distToWorld = raymarch (p + .01*n, lDir);\n    float distToLight = distance (p, lPos);\n\n    return distToWorld < distToLight ? .3 : 1.;\n}\n\nfloat ao (vec3 p, vec3 n, float stepSize, int iterations, float intensity)\n{\n  float ao = .0; \n  float dist = .0; \n\n  for (int a = 1; a <= iterations; ++a) {\n    dist = float (a)*stepSize;\n    ao += max (.0, (dist - scene (p + n*dist))/dist);\n  }\n\n  return 1. - ao*intensity;\n}\n\nvec3 shade(vec3 ro, vec3 rd, float d, vec3 n)\n{\n    vec3 p = ro + d*rd;\n\n    vec3 lPos1 = vec3 (4.*cos(iTime), 2., 4.*sin(.4*iTime));\n    vec3 lDir1 = normalize (lPos1 - p);\n    float lDist1 = distance (lPos1, p);\n    float attn1 = 50. / (lDist1*lDist1);\n    vec3 lColor1 = 5.*vec3 (1., .9, .3);\n\n    vec3 lPos2 = vec3 (6.*cos(.3*iTime), 1., 6.*sin(iTime));\n    vec3 lDir2 = normalize (lPos2 - p);\n    float lDist2 = distance (lPos2, p);\n    float attn2 = 60. / (lDist2*lDist2);\n    vec3 lColor2 = 7.*vec3 (.2, .4, 1.);\n\n    vec3 amb = vec3 (.1); \n    float diff1 = max (dot (n, lDir1), .0);\n    float diff2 = max (dot (n, lDir2), .0);\n    vec3 h1 = normalize (lDir1 - rd);\n    vec3 h2 = normalize (lDir2 - rd);\n    float spec1 = pow (max (dot (h1, n), .0), 40.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n    float s1 = shadow (p, n, lPos1, lDir1);\n    float s2 = shadow (p, n, lPos2, lDir2);\n\n    float ao = ao (p, n, .05, 12, .1);\n\n    // don't do material assignment like this, this is a super lazy-ass hack!\n    vec3 torusMaterial = 1.5*vec3(.2, .1, .05);\n    bool isFloor = (p.y < -.5);\n    float phase = cos (20.*(p.x + iTime));\n    float mask = smoothstep (.005*d, .0025*d, .5 + .5*phase);\n    vec3 floorMaterial = 1.5*mix (vec3(.9), vec3 (.1), mask);\n    vec3 diffMaterial = isFloor ? floorMaterial : torusMaterial;\n\n    return amb + ao*(attn1*s1*(diff1*diffMaterial*lColor1 + spec1) +\n                     attn2*s2*(diff2*diffMaterial*lColor2 + spec2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dist2cam = 3.;\n    float azimuthAngle = ((iMouse.x/iResolution.x) * 2. - 1.) * 179.;\n    float elevationAngle = 20. + ((iMouse.y/iResolution.y) * 2. - 1.) * -30.;\n    float x = dist2cam*cos (radians (azimuthAngle));\n    float y = dist2cam*sin (radians (elevationAngle));\n    float z = dist2cam*sin (radians (azimuthAngle));\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3 (x, y, z);\n\tfloat fog = .0;\n\tfloat d = .0;\n\tvec3 aim = vec3 (.0);\n\tfloat zoom = 2.5;\n    vec3 color = vec3 (.0);\n\n\tfor (int x = 0; x < AA_SIZE; ++x) {\n\t\tfor (int y = 0; y < AA_SIZE; ++y) {\n\n\t\t\t// anti-alias offset\n\t\t\tvec2 pixelOffset = vec2 (float (x), float (y))/float  (AA_SIZE);\n\n\t\t\t// normalize and aspect-correct UVs\n\t\t\tuv = (fragCoord.xy/iResolution.xy + pixelOffset/iResolution.xy);\n    \t\tuv = uv*2. - 1.;\n            uv.x *= iResolution.x/iResolution.y;\n\n    \t\t// create viewray\n    \t\tvec3 rd = camera (uv, ro, aim, zoom);\n\n\t\t\t// primary/view ray\n\t\t\td = raymarch (ro, rd);\n\t\t\tfog = 1. / (1. + d*d*.075);\n\t\t\tvec3 p = ro + d*rd;\n\t\t\tvec3 n = normal (p);\n\t\t\tvec3 ctmp = shade (ro, rd, d, n);\n\t\t\tctmp *= fog;\n\n\t\t\tcolor += ctmp;\n\t\t}\n\t}\n\tcolor /= float (AA_SIZE*AA_SIZE);\n\n    // distance-mist, vignette, tone-map, gamma-correct\n\tcolor = mix (color, vec3 (.2, .35, .7), pow (1. - 1./d, 90.));\n    color *= 1. - .25*dot (uv, uv);\n    color = color / (1. + color);\n    color = .2*color + .8*sqrt (color);\n\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dB3Wd.jpg", "access": "api", "license": "gpl-3.0", "functions": [[1156, 1156, 1178, 1178, 1262], [1264, 1264, 1308, 1308, 1398], [1400, 1400, 1432, 1432, 1801], [1803, 1803, 1825, 1825, 2024], [2026, 2026, 2061, 2061, 2332], [2334, 2334, 2356, 2356, 2563], [2565, 2565, 2619, 2619, 2935], [2937, 2937, 2990, 2990, 3137], [3139, 3139, 3215, 3215, 3416], [3418, 3418, 3465, 3465, 4894], [4896, 4896, 4953, 4953, 6452]], "test": "untested"}
{"id": "ssB3Wd", "name": "Quartic Test - Torus Intersect", "author": "oneshade", "description": ":)", "tags": ["raytracing", "test", "ray", "raycasting", "torus", "intersection", "quartic"], "likes": 5, "viewed": 253, "published": 3, "date": "1618104819", "time_retrieved": "2024-07-30T19:27:12.817637", "image_code": "struct Hit4 {\n    int numHits;\n    vec4 hits;\n};\n\n// Quartic solver I made here: https://www.shadertoy.com/view/fsB3Wt\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of ^3 + ra * ^2 + rb *  + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\n// Intersection\nHit4 iTorus(in vec3 ro, in vec3 rd, in float r, in float t) {\n    float oo = dot(ro, ro);\n    float dd = dot(rd, rd);\n    float od = dot(ro, rd);\n\n    float tt = t * t, rr = r * r;\n    float oottrr = oo - tt - rr;\n\n    // http://blog.marcinchwedczuk.pl/ray-tracing-torus\n    float a = dd * dd;\n    float b = 4.0 * dd * od;\n    float c = 2.0 * dd * oottrr + 4.0 * (od * od + rr * rd.y * rd.y);\n    float d = 4.0 * od * oottrr + 8.0 * rr * ro.y * rd.y;\n    float e = oottrr * oottrr - 4.0 * rr * (tt - ro.y * ro.y);\n\n    vec4 roots;\n    int numRoots = solveQuartic(a, b, c, d, e, roots);\n\n    return  Hit4(numRoots, roots);\n}\n\n// Normal\nvec3 nTorus(in vec3 p, in float r, in float t) {\n    return normalize(vec3(p.xz - normalize(p.xz) * r, p.y)).xzy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 6.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    // Animate\n    float radius = 2.0 + cos(iTime);\n    float thickness = 1.0 + 0.5 * sin(iTime);\n\n    // Find the closest hit in front of the camera\n    Hit4 hit = iTorus(ro, rd, radius, thickness);\n    float t = 1000000000.0;\n    vec3 hitPos;\n    for (int n=0; n < int(hit.numHits); n++) {\n        vec3 hitCandid = ro + rd * hit.hits[n];\n        if (hit.hits[n] > 0.0 && hit.hits[n] < t) {\n            t = hit.hits[n];\n            hitPos = hitCandid;\n        }\n    }\n\n    // Render the shape if hitting\n    if (t < 1000000000.0) {\n        vec3 n = nTorus(hitPos, radius, thickness);\n        float diff = abs(dot(n, -rd));\n        float checkers = mod(floor(atan(hitPos.y, length(hitPos.xz) - radius) * 1.57) + floor(atan(hitPos.z, hitPos.x) * 3.14), 2.0);\n        fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25);\n        fragColor.rgb *= diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssB3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 119, 143, 143, 186], [187, 187, 283, 283, 2732], [2734, 2750, 2811, 2811, 3373], [3375, 3385, 3433, 3433, 3500], [3502, 3502, 3557, 3557, 5146]], "test": "untested"}
{"id": "7dS3Dt", "name": "neuralactivity", "author": "Del", "description": "brain melting sin pattern used a transition", "tags": ["sin", "cos", "pattern"], "likes": 15, "viewed": 579, "published": 3, "date": "1618101455", "time_retrieved": "2024-07-30T19:27:13.582592", "image_code": "// neural activity? :)\n\nmat2 rot(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n\nfloat fx(vec2 uv,float fadetime)\n{\n    float tt = iTime;\n\tfloat light = 0.05;\n    float rip = 0.5+sin(length(uv)*5.0+tt)*0.5;\n    rip = 1.0+rip*0.4;\n    uv*=rip*0.5;\n    uv *= rot(tt*0.055);\n    \n    float vv2 = smoothstep(0.0,0.45,fadetime);\n    float vv = mix(0.01,0.15,fadetime);\n    \n    \n    tt*=0.5;\n\tfor (float x = 1.5; x < 24.0; x += 2.0)\n\t{\n\t\tuv *= rot(x*4.0+length(uv)*0.126*sin(tt*0.05));\n\t\tvec2 f = vec2(cos(cos(tt*0.6+x + uv.x * x) - uv.y * dot(vec2(x + uv.y), vec2(sin(x), cos(x)))));\n\t\tlight += (vv / distance(uv, f)) - (0.01 * distance(vec2((cos(tt*0.3 + uv.y))), vec2(uv)));\n\t\tlight-=x*0.001 + 0.001;\n\t}\n    \n    \n    light = clamp(light,0.0,1.0);\n    return light*vv2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float fadetime = fract(iTime*0.1);\n    \n    fadetime = 0.5+sin(iTime*0.5)*0.5;\n    \n    float fade = fx(uv,fadetime);\n    \n    uv = fragCoord/iResolution.xy;\n    vec3 c1 = texture(iChannel0, uv).xyz;\n    vec3 c2 = texture(iChannel1, uv).xyz;\n    if (iMouse.z>0.5)\n    {\n        c1 = vec3(0.0);\n        c2 = vec3(1.0);\n    }\n    c1 = mix(c1,c2,fade);\n    fragColor = vec4(c1,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dS3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 110], [113, 113, 147, 147, 801], [803, 803, 860, 860, 1320]], "test": "untested"}
{"id": "ssB3Dt", "name": "Debug pattern", "author": "Zavie", "description": "Some debug patterns for edge detection.\nTry applying various edge detection operators, and see how they behave in these different corner cases.\nApply your gradient operator and check that the value is normalized, etc.", "tags": ["gradient", "edgedetection", "pattern", "debug"], "likes": 8, "viewed": 369, "published": 3, "date": "1618100076", "time_retrieved": "2024-07-30T19:27:14.443291", "image_code": "//\n// This shader displays several patterns meant to help\n// visualize the result of an edge detection or a gradient\n// operator.\n//\n// --\n// Zavie\n//\n\n#define ANTIALISING 1\n#define PI acos(-1.)\n\nvec3 debugPattern(vec2 fragCoord, vec2 iResolution)\n{\n\tfloat x = fragCoord.x / iResolution.x;\n    if (x < 0.15)\n    {\n        // Horizontal lines:\n        float size = pow(2., 1.+floor(4. * fragCoord.y / iResolution.y));\n        float signal = fragCoord.y;\n        return vec3(fract(signal/size) > 0.5);\n    }\n    else if (x < 0.3)\n    {\n        // Vertical lines:\n        float size = pow(2., 1.+floor(4. * fragCoord.y / iResolution.y));\n        float signal = fragCoord.x;\n        return vec3(fract(signal/size) > 0.5);\n    }\n    else if (x < 0.45)\n    {\n        // Circles:\n        float size = pow(2., 1.+floor(4. * fragCoord.y / iResolution.y));\n        vec2 uv;\n        uv.x = fragCoord.x - (0.3 + 0.5*0.15) * iResolution.x;\n        uv.y = mod(fragCoord.y, 0.25 * iResolution.y) - 0.125 * iResolution.y;\n        float signal = max(abs(uv.x), abs(uv.y));\n        return vec3(fract(signal/size) > 0.5);\n    }\n    else if (x < 0.6)\n    {\n        // Squares:\n        vec2 uv = vec2((x - 0.3)/0.15, fract(4. * fragCoord.y / iResolution.y));\n        float size = pow(2., 1.+floor(4. * fragCoord.y / iResolution.y));\n        uv.x = fragCoord.x - (0.45 + 0.5*0.15) * iResolution.x;\n        uv.y = mod(fragCoord.y, 0.25 * iResolution.y) - 0.125 * iResolution.y;\n        float signal = abs(fract(length(uv)/size) * 2. - 1.)-0.5;\n        #if ANTIALISING\n        float threeshold = 0.5*fwidth(signal);\n        return vec3(smoothstep(-threeshold, threeshold, signal));\n        #else\n        return vec3(signal > 0.);\n        #endif\n    }\n    else\n    {\n        // Radial lines:\n        vec2 uv = vec2((x - 0.6)/0.4, fragCoord.y / iResolution.x/0.4-0.2);\n        vec2 p = uv-0.5;\n        float d = length(p);\n        float signal = sin(24.*2.*PI*atan(p.y,p.x));\n        #if ANTIALISING\n        float threeshold = 0.5*fwidth(signal);\n        return vec3(smoothstep(-threeshold, threeshold, signal));\n        #else\n        return vec3(signal > 0.);\n        #endif\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(debugPattern(fragCoord, iResolution.xy), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssB3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 249, 249, 2157], [2159, 2159, 2215, 2215, 2285]], "test": "untested"}
{"id": "NdSGDt", "name": "Clock Soup Vortex", "author": "Pelegefen", "description": "Add thyme...\n\nProbably not the best way to tell the time...\nThe clocks are set anyway though!", "tags": ["clock", "wip", "soup"], "likes": 10, "viewed": 411, "published": 3, "date": "1618091402", "time_retrieved": "2024-07-30T19:27:15.340891", "image_code": "\n// number of layers to render, go over 3.5 only if you have a strong GPU! \n// min is 1.1\n#define NUM_LAYERS 3.5\n\n#define S smoothstep \n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define RES iResolution.xy\n\n\n\nfloat Hash21(vec2 n){\n\n   return fract(sin(dot(n.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 ShapeN(vec2 st, int N, float w, float h){\n\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  st.x += 1.0 ;\n  st.y += .7;\n  st.y /= h;\n    st.x *= w;\n  // Number of sides of your shape\n  //int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulates the distance\n  d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  color = vec3(smoothstep(.41,.4,d));\n\n    return color;\n}\nvec2 polarMap(vec2 uv, float shift, float inner) {\n\n    uv = vec2(0.5) - uv;\n    \n    \n    float px = 1.0 - fract(atan(uv.y, uv.x) / 6.28 + 0.25) + shift;\n    float py = (length(uv) * (1.0 + inner * 2.0) - inner) * 2.0;\n    \n    return vec2(px, py);\n}\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\nfloat circle (vec2 p, float r, float g)\n{\n\n    float d = length(p / r);\n\n    float ss = S(.32,.32 - g,d);\n    \n    ss = max(0.,ss);\n    return ss;\n\n}\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, 0.7*r, d);\n}\nfloat segmentT(vec2 P, vec2 A, vec2 B, float r, float dr) \n{\n    vec2 g = B - A;\n    vec2 h = P - A ;\n    float d = length(h - g * clamp(dot(g , h ) / dot(g,g), 0.0, 1.0));\n    \n\n\treturn smoothstep(r, 0.7*r, d);\n}\n\n\n\nvec4 Hand(vec2 uv , float l, float w, float t)\n{\n    vec4 col = vec4(0.);\n    \n\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , \n    1. * RES.y/RES.x * w, .5);\n    \n    uv *= .35;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 5,/* Width*/6.,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n    \n    \n    //uv *= 2.;\n    vec4 Triangle = vec4(ShapeN(rot( uv * 3., -t* TAU/60.) , 5,/* Width*/9.,/* Height*/ l - .2),1.);\n    col += Triangle ;\n   \n    \n    \n    col.a = col.r;// at this point, each of the rgb vals is at 1. and showing the mask, so store it in the A channel.\n    \n    col = max (col,vec4(0.));\n    return col;\n}\n\nvec4 HandsShadow(vec2 uv , float l, float w, float t , float b)\n{\n    vec4 col = vec4(0.);\n    \n\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , \n      w, .5);\n    uv.y += .02;\n    uv *= .35;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 5,/* Width*/6. * w,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n    \n    \n    //uv *= 2.;\n    vec4 Triangle = vec4(ShapeN(rot( uv * 3., -t* TAU/60.) , 5,/* Width*/4. * w,/* Height*/ l - .2),1.);\n    col += Triangle ;\n    col = mix(Triangle, shape, .5);\n    \n    \n    col -= length(uv.y) * 2.; // attenuate based on height\n    \n    \n    \n    col = max (col,vec4(0.));\n    return col * .5;\n}\nvec4 Dial(vec2 uv, float m)\n{\n    \n    vec4 col = vec4(0.);\n    //uv.x = PolarCoord(uv);\n    \n    uv = polarMap(uv + .5, -.2486 , .25) * .5;\n    \n    uv.x = fract(uv.x * 24. * m ) ;\n    \n    \n    vec2 id = floor(uv * 24.  );\n    \n    float idF = (id.x / id.y);\n\n    col *= vec4(idF,idF,idF,1.)    ;\n    \n    col += circle(uv - vec2(0.,.5 ),1., .001 );\n    col += segment(uv / 60. * m ,vec2(0. ,0.0), vec2(6. ,2.),.01) * .5 ;\n    if(id.x <=  .5 && id.y <= 24.) return col = vec4(.35);\n    col += segment(uv,vec2(.0 ,0.9), vec2(.8 ,0.9),.1);\n    \n    \n    \n    float h = segment(uv,vec2(-.8 ,0.5),\n     vec2(.8 ,0.5),.2);\n    vec4 tx = texture(iChannel0,uv);\n    col +=  h; \n    col += col *  tx;\n    col = mix(col, tx, col) * .4;\n    \n    col = clamp(col,0.,1.);\n    return col;\n}\n\n\n//returns a working clock\nvec4 ClockFace(vec2 uv){\n\n    vec4 col = vec4(0.,0.,0.,1.);\n    \n    vec4 wt = texture(iChannel0,uv);// sample wood tex\n    float f = circle(uv,4.3, .001 );//clocks frame\n    float fm = 1. - (circle(uv,4.3, .025 ) );//clocks frame bevel\n    f -= fm;\n    col += f;\n    \n    //Decoration at 12 o'clock\n    col -= circle(uv + vec2(0.,-1.03),0.3, .001 ) * 0.5;\n    col += circle(uv + vec2(0.,-1.0),0.3, .5 );\n    col -= vec4(ShapeN(uv+vec2(0.,-.5) ,5  ,  5.15, 1.15 ),0.7) * .5;\n    col += circle(   uv + vec2(0.,-.8) ,0.1, .1 );\n    \n    \n    col = mix(col,wt,col - circle(uv,3.7, .001 ) * .9); // apply wood tex\n    \n    \n    col -= (circle(uv,3.6, .001 ) * .18) + (-uv.y * .2); //inset and shading\n    \n    // Shadow\n    float d = length(uv + vec2(0.,0.1 ))* 0.88;\n    float m = 1. - circle(uv,4.3,.0001);\n    m += circle(uv,3.7,.001);\n    m = 1. - m;\n    \n    col -=  smoothstep(0., pow(d,40.), m ) ;\n    \n    //col = vec4(m);\n     //add the dial and decoration\n    col -= Dial(uv/1.3, 1.);\n    col += Dial(uv , 1.5);\n    \n    \n    //---------- time is set here------------\n\n    vec4 iDate = iDate;\n    float mils = fract(iDate.w);\n\tfloat secs = mod( (iDate.w),        60.0 );\n\tfloat mins = mod( (iDate.w/60.0),   60.0 );\n\tfloat hors = mod( (iDate.w/3600.0), 24.0 );\n\n\n    vec4 ch1 = Hand(uv, 0.9,0.9, hors  * TAU * .8 );//hours hand\n    vec4 ch1m = Hand(uv, 0.6,0.1, hors  * TAU * .8 );//hours hand m\n    ch1 -= ch1m;\n    ch1 = clamp(ch1,0.,1.);\n    col -= ch1;\n    vec4 ch1s = HandsShadow(uv , 1.,.9, hors  * TAU * .8 , .5);\n    col -= ch1s;\n\n    vec4 ch2 = Hand(uv , 1.6,0.5, mins);//minutes hand\n    vec4 ch2m = Hand(uv, 1.3,0.1, mins);//minutes hand m\n    ch2 -= ch2m;\n    ch2 = clamp(ch2,0.,1.);\n    col -= ch2;\n    vec4 ch2s = HandsShadow(uv , 1.7,.7, mins , .5);\n    col -= ch2s;\n\n    vec4 ch3 = Hand(uv ,  2.0, .07 ,secs ); //secondes hand\n    vec4 ch3m = Hand(uv , 1.1, .05 ,secs ); //secondes hand m\n    ch3 -= ch3m;\n    \n\n    ch3 = clamp(ch3,0.,1.);\n    col -= ch3;\n    vec4 ch3s = HandsShadow(uv , 2.0,.8, secs , .5);\n    col -= ch3s;\n    \n    \n    vec4 tex1 = texture(iChannel0,(rot( uv * 2., -secs* TAU/60.)));\n    vec4 tex2 = texture(iChannel0,(rot( uv * 2., -mins* TAU/60.)));\n    vec4 tex3 = texture(iChannel0,(rot( uv * 2., -hors* TAU/60.)));// we also have to spin the texture per hand!\n  \n    col = mix (col, ch1 * tex3  , ch1) ;\n    col = mix (col,ch2 * tex2 ,ch2 ) ;\n    col = mix (col,ch3 * tex1 ,ch3 ) ;\n    \n    \n    //------------End of Time setting-----------------  \n    \n    float cc =  circle(uv,0.3, .001 ) ;//clocks hand cover\n    cc = ceil(cc);\n    \n    cc = max(cc,0.);\n    cc = min(cc,1.);\n    //col -= cc;\n    \n    col =  mix(cc * wt, col,1. -cc);\n    col += vec4(circle(uv,0.3, .2 ) * .3) *(fract( uv.y* 50. - .1)  ) ; // dot on the clock hand cover\n    \n    col -= circle(uv,3.7, .001 ) * .18;// glass cover\n    col += max((circle(uv,3.9, .05 ) * .3 * uv.y),0.);\n     m = 1. - circle(uv,4.3,.001);\n    col.a =  1.- m;\n    col = col - m;\n    col = max(vec4(0.),col);\n    return col;\n    \n}\n\n\n\nvec4 Layer(vec2 uv , float a)\n{\n    vec2 ouv = uv; //storing the original uvs.\n\n//if (uv.x >= 0.) uv.y += 0.5;\n    //uv.x = abs(uv.x);\n    uv.x +=  iTime * .001;\n    uv = rot(uv,a * 0.1);\n    vec2 buv = uv;\n    //buv.x = buv.x +sin( buv.y + iTime * .001);\n    \n    \n    buv *= cos(sin(  iTime * .0001)*.5+.5) * 5.;\n    vec2 mouse = iMouse.xy / iResolution.xy + .5;\n    buv *= 1.- mouse.x + 1.5;\n    \n    \n    buv = rot(buv,iTime * .0001);\n    \n    vec2 id = floor(buv);\n    vec2 fuv = fract(buv);\n    \n    buv = fuv;\n    vec4 col = vec4( 0.);\n    \n    \n    uv = buv;\n\n    \n    \n    //col -= max( 1. - length((uv + vec2(.0,.1))* .63), 0.) ;\n    vec4 cf = ClockFace(uv*2.8 /Hash21(id * 3.)- 1.5);\n    \n    \n    cf *= vec4(Hash21(id + .3),Hash21(id+ .5),Hash21(id+ .7),1.) * 1.3;\n    cf = min(cf,vec4(1.));\n    //cf = clamp(cf,.3,.9);\n    col = mix(col,cf,cf.a);\n    \n    \n\n  \n    \n\n\ncol.a = ceil(col.a);\n//\nreturn col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    vec2 ouv = uv; //storing the original uvs.\n    vec4 col = vec4( 0.);\n     if (uv.x <= 0.) uv.y += .5;\n     if (uv.y <= 0.) uv.x += .5;\n    uv.x = abs(uv.x);\n    uv.y = abs(uv.y);\n    \n    uv.x += iTime * .01;\n    uv.y += iTime * .01;\n    vec4 bg = texture(iChannel1,uv * 1.);\n     bg *= vec4(.5,.5,1.,1.);\n     col += bg;\n     \n     \n      //black in the middle\n     \n    col -=  max(.5 - length((ouv.x) * 2.0),0.) ;\n    col -=  max(.5 - length((ouv.y) * 2.0),0.) ;\n     \n     for(float i = 0.;i < NUM_LAYERS;i += 1./NUM_LAYERS)\n     {\n      vec4 l1 = Layer(ouv / i * 2., iTime * i+ (4622.2* i));\n    \n      col = mix(col, l1, l1.a);\n     }\n     //vec4 l1 = Layer(ouv, iTime * .5);\n    \n     //col = mix(col, l1, l1.a);\n\n    \n    // vec4 l2 = Layer(ouv * .5, iTime * .3+ 4622.2);\n    \n    // col = mix(col, l2, l2.a);\n     \n    // vec4 l3 = Layer(ouv * .3, iTime * .2 + 42312.2);\n    \n    // col = mix(col, l3, l3.a);\n     \n     //vignette\n     col -= vec4(pow(length(ouv),4.) );\n  \n   \n\n    \n    fragColor = col;\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 221, 242, 242, 313], [316, 316, 362, 362, 823], [824, 824, 874, 874, 1075], [1076, 1076, 1103, 1103, 1178], [1179, 1179, 1220, 1220, 1328], [1329, 1329, 1378, 1378, 1522], [1523, 1523, 1583, 1583, 1736], [1740, 1740, 1788, 1788, 2421], [2423, 2423, 2488, 2488, 3112], [3113, 3113, 3142, 3142, 3892], [3895, 3921, 3945, 3945, 6948], [6952, 6952, 6983, 6983, 7871], [7873, 7873, 7930, 7980, 9064]], "test": "untested"}
{"id": "NsS3Dt", "name": "Red Landscape", "author": "edubart", "description": "Experimenting generating terrain and simple clouds with noise, and some color grading tools.", "tags": ["procedural", "cineshader"], "likes": 51, "viewed": 8341, "published": 3, "date": "1618081018", "time_retrieved": "2024-07-30T19:27:16.224528", "image_code": "/* Generated by Nelua 0.2.0-dev */\n/* Compile command: clang \"/home/bart/projects/nelua/nelua-lang/nelua_cache/demos/redlandscape.c\" -o \"/home/bart/projects/nelua/nelua-lang/nelua_cache/demos/redlandscape\" -Wall -fwrapv -g -lm */\n/* Compile hash: 3wm5WeyBu2gJj7S5c3vNMfx1ovQd */\n/* ------------------------------ DECLARATIONS ------------------------------ */\nvec3 vec_tovec3(vec3 a);\nvec3 noise_vec2_xyx(vec2 self);\nvec2 demos_redlandscape_vec4_xy(vec4 self);\nvec2 demos_redlandscape_vec3_xz(vec3 self);\nfloat vec_smootherstep(float edge0, float edge1, float x);\nfloat vec_fastmix(float a, float b, float t);\nvec3 vec_fastmix_1(vec3 a, vec3 b, float t);\nvec2 sincos(float x);\nvec2 demos_redlandscape_vec3_xy(vec3 self);\nvec3 noise_vec3_yzx(vec3 self);\nvec2 noise_vec3_xx(vec3 self);\nvec2 noise_vec3_yz(vec3 self);\nvec2 noise_vec3_zy(vec3 self);\nfloat noise_hash1_2(vec2 v);\nvec2 noise_hash2_1(vec2 v);\nfloat noise_noisemix2(float a, float b, float c, float d, vec2 f);\nfloat noise_noise_white_1(vec2 p);\nfloat noise_noise_value_1(vec2 p);\nfloat noise_noise_gradient_1(vec2 p);\nvec3 colorgrade_colorgrade_tonemap_aces(vec3 col);\nvec3 colorgrade_colorgrade_saturate(vec3 col, float sat);\nvec3 colorgrade_colorgrade_tone_1(vec3 col, vec3 gain, vec3 lift, vec3 invgamma);\nvec3 colorgrade_colorgrade_gamma_correction(vec3 col);\nvec3 colorgrade_colorgrade_vignette(vec3 col, vec2 coord, float strength, float amount);\nvec3 colorgrade_colorgrade_dither(vec3 col, vec2 coord, float amount);\nvec3 camera_camera_perspective(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv);\nfloat demos_redlandscape_fbm_terrain(vec2 p);\nfloat demos_redlandscape_map(vec3 p);\nfloat demos_redlandscape_ray_march(vec3 ro, vec3 rd);\n/* ------------------------------ DEFINITIONS ------------------------------- */\nvec3 vec_tovec3(vec3 a) {\n  return vec3(a.x, a.y, a.z);\n}\nvec3 noise_vec2_xyx(vec2 self) {\n  return vec3(self.x, self.y, self.x);\n}\nvec2 demos_redlandscape_vec4_xy(vec4 self) {\n  return vec2(self.x, self.y);\n}\nvec2 demos_redlandscape_vec3_xz(vec3 self) {\n  return vec2(self.x, self.z);\n}\nfloat vec_smootherstep(float edge0, float edge1, float x) {\n  float t = clamp(((x - edge0) / (edge1 - edge0)), 0.0, 1.0);\n  return (((t * t) * t) * ((t * ((t * 6.0) - 15.0)) + 10.0));\n}\nfloat vec_fastmix(float a, float b, float t) {\n  return (a + ((b - a) * t));\n}\nvec3 vec_fastmix_1(vec3 a, vec3 b, float t) {\n  return (a + ((b - a) * t));\n}\nvec2 sincos(float x) {\n  return vec2(sin(x), cos(x));\n}\nvec2 demos_redlandscape_vec3_xy(vec3 self) {\n  return vec2(self.x, self.y);\n}\nvec3 noise_vec3_yzx(vec3 self) {\n  return vec3(self.y, self.z, self.x);\n}\nvec2 noise_vec3_xx(vec3 self) {\n  return vec2(self.x, self.x);\n}\nvec2 noise_vec3_yz(vec3 self) {\n  return vec2(self.y, self.z);\n}\nvec2 noise_vec3_zy(vec3 self) {\n  return vec2(self.z, self.y);\n}\nfloat noise_hash1_2(vec2 v) {\n  vec3 v3 = noise_vec2_xyx(v);\n  v3 = fract((v3 * 0.1031));\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\n  return fract(((v3.x + v3.y) * v3.z));\n}\nvec2 noise_hash2_1(vec2 v) {\n  vec3 v3 = noise_vec2_xyx(v);\n  v3 = (v3 * vec3(0.1031, 0.103, 0.0973));\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\n  return fract(((noise_vec3_xx(v3) + noise_vec3_yz(v3)) * noise_vec3_zy(v3)));\n}\nfloat noise_noisemix2(float a, float b, float c, float d, vec2 f) {\n  vec2 u = ((f * f) * (3.0 - (2.0 * f)));\n  return vec_fastmix(vec_fastmix(a, b, u.x), vec_fastmix(c, d, u.x), u.y);\n}\nfloat noise_noise_white_1(vec2 p) {\n  return noise_hash1_2(p);\n}\nfloat noise_noise_value_1(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 I = floor((i + 1.0));\n  float a = noise_hash1_2(i);\n  float b = noise_hash1_2(vec2(I.x, i.y));\n  float c = noise_hash1_2(vec2(i.x, I.y));\n  float d = noise_hash1_2(I);\n  return noise_noisemix2(a, b, c, d, f);\n}\nfloat noise_noise_gradient_1(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 I = floor((i + 1.0));\n  vec2 F = (f - 1.0);\n  float a = dot((-0.5 + noise_hash2_1(i)), f);\n  float b = dot((-0.5 + noise_hash2_1(vec2(I.x, i.y))), vec2(F.x, f.y));\n  float c = dot((-0.5 + noise_hash2_1(vec2(i.x, I.y))), vec2(f.x, F.y));\n  float d = dot((-0.5 + noise_hash2_1(I)), F);\n  return (0.5 + noise_noisemix2(a, b, c, d, f));\n}\nvec3 colorgrade_colorgrade_tonemap_aces(vec3 col) {\n  return clamp(((col * ((2.51 * col) + 0.03)) / ((col * ((2.43 * col) + 0.59)) + 0.14)), 0.0, 1.0);\n}\nvec3 colorgrade_colorgrade_saturate(vec3 col, float sat) {\n  float grey = dot(col, vec3(0.2125, 0.7154, 0.0721));\n  return (grey + (sat * (col - grey)));\n}\nvec3 colorgrade_colorgrade_tone_1(vec3 col, vec3 gain, vec3 lift, vec3 invgamma) {\n  col = pow(col, vec_tovec3(invgamma));\n  return (((gain - lift) * col) + lift);\n}\nvec3 colorgrade_colorgrade_gamma_correction(vec3 col) {\n  return ((1.12661 * sqrt(col)) - (0.12661 * col));\n}\nvec3 colorgrade_colorgrade_vignette(vec3 col, vec2 coord, float strength, float amount) {\n  return (col * ((1.0 - amount) + (amount * pow(((((16.0 * coord.x) * coord.y) * (1.0 - coord.x)) * (1.0 - coord.y)), strength))));\n}\nvec3 colorgrade_colorgrade_dither(vec3 col, vec2 coord, float amount) {\n  return clamp((col + (noise_noise_white_1(coord) * amount)), 0.0, 1.0);\n}\nvec3 camera_camera_perspective(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\n  vec2 sc = sincos(tilt);\n  vec3 vup = vec3(sc.x, sc.y, 0.0);\n  vec3 w = normalize((lookat - lookfrom));\n  vec3 u = normalize(cross(w, vup));\n  vec3 v = cross(u, w);\n  float wf = (1.0 / tan((vfov * 0.00872664626)));\n  return normalize((((uv.x * u) + (uv.y * v)) + (wf * w)));\n}\nfloat demos_redlandscape_fbm_terrain(vec2 p) {\n  float a = 1.0;\n  float t = 0.0;\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = (2.0 * p);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = (2.0 * p);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = (2.0 * p);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = (2.0 * p);\n  return t;\n}\nfloat demos_redlandscape_map(vec3 p) {\n  vec2 q = demos_redlandscape_vec3_xz(p);\n  float h = (demos_redlandscape_fbm_terrain(q) * 0.5);\n  float d = ((p.y + (h * 0.75)) + 0.0);\n  return (d * 0.5);\n}\nfloat demos_redlandscape_ray_march(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for(int i = 1; i <= 256; i = i + 1) {\n    vec3 p = (ro + (t * rd));\n    float d = demos_redlandscape_map(p);\n    if((d < (0.003 * t)) || (t >= 25.0)) {\n      break;\n    }\n    t = (t + d);\n  }\n  return t;\n}\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord) {\n  vec2 res = demos_redlandscape_vec3_xy(iResolution);\n  vec2 mouse = (demos_redlandscape_vec4_xy(iMouse) / res);\n  vec2 uv = (frag_coord / res);\n  vec2 coord = ((2.0 * (frag_coord - (res * 0.5))) / res.y);\n  float z = (iTime * 1.0);\n  vec2 sc = sincos((iTime * 0.5));\n  float y = 0.0;\n  vec3 lookat = vec3((sc.x * 0.5), y, z);\n  vec3 ro = vec3(((-sc.x) * 0.5), y, (z - 2.0));\n  vec3 rd = camera_camera_perspective(ro, lookat, 0.0, 45.0, coord);\n  vec3 col = vec3(0.0, 0.0, 0.0);\n  vec3 sun_dir = normalize(vec3(0.3, 0.07, 1.0));\n  vec3 hor_col = vec3(0.7, 0.05, 0.01);\n  vec3 sun_col = vec3(0.9, 0.8, 0.7);\n  vec3 bou_col = vec3(0.8, 0.3, 0.1);\n  float t = demos_redlandscape_ray_march(ro, rd);\n  vec3 p = (ro + (rd * t));\n  vec3 back_col;\n  {\n    back_col = vec_fastmix_1(hor_col, (hor_col * 0.3), vec_smootherstep(0.0, 0.25, rd.y));\n    back_col = vec_fastmix_1(back_col, bou_col, max((0.1 - rd.y), 0.0));\n    float sun_lightness = max(dot(rd, sun_dir), 0.0);\n    back_col = (back_col + (sun_col * pow(sun_lightness, 2000.0)));\n    back_col = (back_col + ((0.3 * sun_col) * pow(sun_lightness, 100.0)));\n    back_col = (back_col + (vec3(0.3, 0.2, 0.1) * pow(sun_lightness, 4.0)));\n  }\n  if(abs(coord.y) > 0.75) {\n    col = vec3(0.0, 0.0, 0.0);\n  } else if(t < 25.0) {\n    float decay = (1.0 - exp((-0.12 * t)));\n    col = mix(col, back_col, decay);\n  } else {\n    col = back_col;\n    float clouds_altitude = 1000.0;\n    float clouds_dist = ((1.0 - (ro.y / clouds_altitude)) / rd.y);\n    if(clouds_dist > 0.0) {\n      float clouds_zoom = 1.0;\n      vec2 clouds_pos = (demos_redlandscape_vec3_xz(ro) + ((demos_redlandscape_vec3_xz(rd) * clouds_dist) * clouds_zoom));\n      float clouds_lightness = max((noise_noise_gradient_1(clouds_pos) - 0.3), 0.0);\n      float clouds_decay = vec_smootherstep(0.0, 0.3, rd.y);\n      vec3 clouds_col = (2.0 * col);\n      col = vec_fastmix_1(col, clouds_col, (clouds_lightness * clouds_decay));\n    }\n    col = clamp(col, 0.0, 1.0);\n  }\n  col = colorgrade_colorgrade_tonemap_aces(col);\n  col = colorgrade_colorgrade_gamma_correction(col);\n  col = colorgrade_colorgrade_tone_1(col, vec3(1.3, 0.9, 0.7), (vec3(0.5, 0.1, 0.1) * 0.1), vec3(3.0, 2.0, 1.2));\n  col = colorgrade_colorgrade_saturate(col, 0.7);\n  col = colorgrade_colorgrade_vignette(col, uv, 0.25, 0.7);\n  col = colorgrade_colorgrade_dither(col, frag_coord, 0.01);\n  frag_col = vec4(col.x, col.y, col.z, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsS3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1715, 1796, 1821, 1821, 1853], [1854, 1854, 1886, 1886, 1927], [1928, 1928, 1972, 1972, 2005], [2006, 2006, 2050, 2050, 2083], [2084, 2084, 2143, 2143, 2269], [2270, 2270, 2316, 2316, 2348], [2349, 2349, 2394, 2394, 2426], [2427, 2427, 2449, 2449, 2482], [2483, 2483, 2527, 2527, 2560], [2561, 2561, 2593, 2593, 2634], [2635, 2635, 2666, 2666, 2699], [2700, 2700, 2731, 2731, 2764], [2765, 2765, 2796, 2796, 2829], [2830, 2830, 2859, 2859, 3014], [3015, 3015, 3043, 3043, 3251], [3252, 3252, 3319, 3319, 3438], [3439, 3439, 3474, 3474, 3503], [3504, 3504, 3539, 3539, 3799], [3800, 3800, 3838, 3838, 4222], [4223, 4223, 4274, 4274, 4376], [4377, 4377, 4435, 4435, 4532], [4533, 4533, 4615, 4615, 4698], [4699, 4699, 4754, 4754, 4808], [4809, 4809, 4898, 4898, 5032], [5033, 5033, 5104, 5104, 5179], [5180, 5180, 5273, 5273, 5551], [5552, 5552, 5598, 5598, 5950], [5951, 5951, 5989, 5989, 6148], [6149, 6149, 6203, 6203, 6428], [6429, 6429, 6484, 6484, 8888]], "test": "untested"}
{"id": "fsB3Wt", "name": "Quartic Equation Solver", "author": "oneshade", "description": "Using the method for solving a quartic explained by this paper: https://www.maa.org/sites/default/files/pdf/upload_library/22/Ford/auckly29.pdf\nI think I finally understand it!!!", "tags": ["math", "solver", "quartic", "equation", "paper", "polynomial"], "likes": 12, "viewed": 559, "published": 3, "date": "1618079228", "time_retrieved": "2024-07-30T19:27:16.989483", "image_code": "// My own workthrough of the solution: https://www.desmos.com/calculator/zq63cquzre\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float a = sin(iTime * 0.25) * 1.25;\n    float b = sin(iTime) * 2.0;\n    float c = sin(iTime) * 2.0;\n    float d = cos(iTime * 0.75);\n    float e = sin(iTime * 0.5);\n\n    float f = a * uv.x * uv.x * uv.x * uv.x + b * uv.x * uv.x * uv.x + c * uv.x * uv.x + d * uv.x + e;\n    float g = a * 4.0 * uv.x * uv.x * uv.x + 3.0 * b * uv.x * uv.x + 2.0 * c * uv.x + d; // Derivative for DE\n    color.r += smoothstep(unit, 0.0, abs(uv.y - f) / sqrt(1.0 + g * g));\n    color.b += smoothstep(unit, 0.0, abs(uv.y));\n\n    vec4 roots;\n    int nroots = solveQuartic(a, b, c, d, e, roots);\n\n    for (int n=0; n < nroots; n++) {\n        color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - vec2(roots[n], 0.0)) - 0.05));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "float cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of ^3 + ra * ^2 + rb *  + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsB3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 84, 139, 139, 1037]], "test": "untested"}
{"id": "7dj3Dc", "name": "elevator low", "author": "jorge2017a1", "description": "elevador baja", "tags": ["elevadorbaja"], "likes": 3, "viewed": 218, "published": 3, "date": "1618073367", "time_retrieved": "2024-07-30T19:27:17.853174", "image_code": "//por jorge2017a1- 2021-abri-10\n#define MAX_STEPS 80\n#define MAX_DIST 150.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n///-----------------------------------------------------\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n///------------------------------------\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\nvec3 figuraCuarto(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    float alto=12.5;\n    float sb1= sdBox(  p-vec3(0.0,-alto,0.0), vec3(20.0,1.0,10.0) );\n    float sb2= sdBox(  p-vec3(0.0,-alto,0.0), vec3(7.0,1.5,5.0) );\n    float dif1= differenceSDF(sb1, sb2);\n    \n    float sbf1= sdBoxFrame(p, vec3(20.0,alto,10.0), 1.0 );\n    \n    \n    vec3 p1=p;\n    p1.x=clamp(p1.x,-21.0,21.0);\n    p1.z=clamp(p1.z,-11.0,11.0);\n    \n    p1.x= opRep1D(p1.x, 3.0 );\n    p1.z= opRep1D(p1.z, 3.0 );\n     \n    \n    float sdc1= sdCylinderXZ( p1-vec3(0.0,-alto,0.0), vec2(0.9,1.5) );\n    dif1= differenceSDF(dif1, sdc1);\n    \n    res =opU3(res, vec3(sbf1,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(dif1,5.0,MATERIAL_NO)); \n    return res;\n}\n\n\nfloat repCilindroshor(vec3 p)\n{\n float numItem=8.0;\n    float tau = atan(1.0) * 8.0;\n    \n    p= rotate_x( p, radians(90.0));\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sc1=sdCylinderYZ( rep2-vec3(10.0,0.0,0.0), vec2(6.0,42.0) );\n    return sc1;\n}    \n\nvec3 anilloCilindro(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    float sdc1= sdCylinderXZ( p-vec3(0.0,0.0,0.0), vec2(41.0,20.0) );\n    float sdc2= sdCylinderXZ( p-vec3(0.0,0.0,0.0), vec2(40.0,21.0) );\n    float sdb1= sdBox( p-vec3(0.0,0.0,-18.0), vec3(31.0,41.0,25.0) );\n    \n    float rc1= repCilindroshor(p);\n    \n    float dif1= differenceSDF(sdc1, sdc2);\n    dif1= differenceSDF(dif1, sdb1);\n    dif1= differenceSDF(dif1, rc1);\n    \n    res =opU3(res, vec3(dif1, 6.0,-1.0) ); \n    \n    return res;\n      \n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    \n    vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    vec3 p1=p-vec3(0.,0.,0.);\n    vec3 p2=p-vec3(0.0,25.0,0.0) ;\n    vec3 p3=p-vec3(0.0,0.0,0.0) ;\n    \n    p1.y=opRep1D(p1.y, 50.0 );\n    p2.y=opRep1D(p2.y, 50.0 );\n    p3.y=opRep1D(p2.y, 25.0 );\n    \n    \n    p.y=p.y-12.5;\n    \n    vec3 f1=figuraCuarto(p1 );\n    vec3 f2=figuraCuarto(p2);\n    vec3 ac1= anilloCilindro( p3-vec3(0.0,0.0,10.0));\n    \n    res =opU3(res, f1 ); \n    res =opU3(res, vec3(f2.x, 32.0,-1.0) ); \n    res =opU3(res, ac1 ); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    float strength = 2.; // lower number makes lighting do deeper into sphere\n     \n    float  fresnel = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), strength);\n    lin+=vec3(1.0)*fresnel;\n     \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n         if ( abs(dS.x)<MIN_DIST)\n        { mObj.hitbln = true; minDist = abs(dO);break; }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; minDist = min(minDist, dO); break; }\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n////----------------------------------\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,500.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    \n    vec3 ro=vec3(0.0,7.0+t,-30.0);\n    vec3 rd=normalize(vec3(uv,1.0));\n    rd=rotate_x(rd, radians(45.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n     col= getSkyColA(rd);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dj3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[571, 571, 607, 607, 628], [629, 629, 661, 661, 745], [746, 746, 785, 785, 880], [881, 881, 920, 920, 1015], [1016, 1016, 1055, 1055, 1150], [1152, 1196, 1243, 1243, 1270], [1272, 1272, 1315, 1315, 1342], [1344, 1344, 1392, 1392, 1420], [1421, 1505, 1541, 1541, 1586], [1592, 1657, 1691, 1691, 1789], [1790, 1790, 1824, 1824, 1916], [1917, 1917, 1951, 1951, 2043], [2044, 2084, 2118, 2118, 2215], [2218, 2275, 2309, 2309, 2482], [2484, 2524, 2569, 2569, 2851], [2854, 2854, 2881, 2881, 3580], [3583, 3583, 3614, 3614, 3846], [3852, 3852, 3881, 3881, 4370], [4372, 4412, 4437, 4437, 5099], [5101, 5101, 5166, 5166, 5939], [5941, 5992, 6016, 6016, 6204], [6206, 6206, 6239, 6239, 6908], [6909, 6963, 6999, 6999, 7233], [7234, 7369, 7449, 7449, 7726], [7821, 7821, 7914, 7914, 8014], [8015, 8054, 8081, 8081, 8191], [8192, 8241, 8298, 8298, 9617]], "test": "untested"}
{"id": "sdj3Dc", "name": " - Reflect Test", "author": "totetmatt", "description": "First Time Implementation of Reflection. ", "tags": ["reflect"], "likes": 5, "viewed": 229, "published": 3, "date": "1618073024", "time_retrieved": "2024-07-30T19:27:18.679963", "image_code": "#define fGlobalTime iTime\nmat2 rot(float a){\n    float c=cos(a),s=sin(a);\n     return mat2(c,-s,s,c);\n     }\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBox(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,vec3(.0))) + min(max(max(q.x,q.y),q.z),.0);\n  }\nvec2 mmin(vec2 a,vec2 b){ return a.x<b.x ? a:b;}\nvec2 sdf (vec3 p){\n  vec3 bp= p;\n\n  vec3 bbp= bp;\n  bbp.xz*=rot(-fGlobalTime*.3);\n    bbp.zy*=rot(-fGlobalTime*.3);\n  vec2 h = vec2(sdBoxFrame(bbp,vec3(1.),.125),1.0);\n  vec2 bbox = vec2(-sdBox(p,vec3(10.)),3.);\n  h = mmin(h,bbox);\n  \n  \n  bp.xz *=rot(fGlobalTime);\n  float bb = 1000.;\n  for(float i=.0;i<4.;i++){\n    bp.xy= abs(bp.xy)-.5*i;\n    bp.xz = bp.x < bp.z ? bp.xz:bp.zx;\n    bp*=1.2;\n    bp.xy*=rot(.415*i*3.);\n    bb = -min(bb,sdBox(bp,vec3(.50,.5,.55))/1.5);\n  }\n vec3 pppp = p;\n  pppp.xz *=rot(fGlobalTime*.5);\n   pppp.xy *=rot(fGlobalTime*.5);\n  vec2 t = vec2(length(abs(abs(pppp)-1.5)-1.5)-.5,2.);\n  t.x = max(t.x,-bb); \n  h = mmin(h,t);\n  return h;\n}\nvec2 nv = vec2(.0001,.0);\nvec3 norm(vec3 p){\n    float d= sdf(p).x;\n    return normalize(vec3(d-sdf(p-nv.xyy).x,d-sdf(p-nv.yxy).x,d-sdf(p-nv.yyx).x));\n  }\nvec2 raym(vec3 ro,vec3 rd,float stp,inout vec3 rp,inout bool bounce){\n     float td=0.01;\n     for(float i=0.; i<=stp;i++){\n          vec2 d = sdf(rp);\n          td+=d.x;\n          rp+=rd*d.x*.7;\n          if(d.x <= 0.00001){\n            if(d.y ==2.){\n                bounce = true;\n          \n                rd = reflect(rd,norm(rp));\n                rp+=rd*.00001;\n                \n            } else {\n             return vec2(td,d.y);\n              }\n          }\n       }\n     return vec2(td,-1.);\n   }\n vec3 pal(float t){\n  return vec3(.2,.5,.7)+vec3(.7,.2,.5)*cos(2.*3.1415*(1.*t+vec3(.3,.4,.6)));\n   }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    \n    vec2 puv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\nvec3 col = vec3(.1);\n  vec3 ro = vec3(-0.5,.5,-4.);\n  ro.xy *=rot(fGlobalTime*.33);\n  bool bounce = false;\n  vec3 rd=vec3(uv,1.0),rp=ro+rd*.001;\n  vec2 d  = raym(ro,rd,69.*2.,rp,bounce);\n  vec3 light = vec3(5.,5.,-5.);\n  light = abs(light)-10.5;\n  light.xz *=rot(fGlobalTime*2.);\n  light.y = sin(fGlobalTime*2.)*10.;\n  if(d.y >0.){\n      if(d.y == 1.){\n       \n      vec3 n = norm(rp);\n      float lmb = max(0.,dot(normalize(light),n));\n      float dlight = length(rp-light)/5.;\n        if(bounce) {lmb=lmb*2.;}\n        float qq = max(rp.y/10.0,.0);\n      col =pal(length(qq*.5)*dlight+fGlobalTime)*lmb/dlight*2.;\n      \n      }  if(d.y == 3.){\n       \n      vec3 n = norm(rp);\n      float lmb = max(0.,dot(normalize(light),n));\n      float dlight = length(rp-light)/5.;\n        if(bounce) {lmb=lmb*2.;}\n        float qq = max(rp.y/10.0,.0);\n      col =col/dlight+vec3(.7,.0,.5)*lmb/dlight*2.;\n       // if(bounce) {col = pal(length(qq)+fGlobalTime)*lmb/dlight*2.;}\n      } \n       if(bounce) { \n        col = pow(col,vec3(1.5));\n         }\n    }\n\n\n   \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdj3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 44, 44, 108], [109, 109, 154, 154, 436], [438, 438, 465, 465, 560], [561, 561, 586, 586, 609], [610, 610, 628, 628, 1276], [1303, 1303, 1321, 1321, 1431], [1432, 1432, 1501, 1501, 1939], [1941, 1941, 1959, 1959, 2041], [2042, 2042, 2099, 2149, 3406]], "test": "untested"}
{"id": "sdj3Wc", "name": "Pixellerman", "author": "z0rg", "description": "There once was a ship that put to sea\nAnd the name of that ship was the Billy o' Tea\nThe winds blew hard, her bow dipped down\nBlow, me bully boys, blow (huh)", "tags": ["pixel", "boat", "retrowave"], "likes": 14, "viewed": 417, "published": 3, "date": "1618070560", "time_retrieved": "2024-07-30T19:27:19.587537", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec3 gradient(float f)\n{\n    vec3 cols[3];\n    \n    cols[0] = vec3(0.169,0.086,0.816);\n    cols[1] = vec3(0.835,0.216,0.843);\n    cols[2] = vec3(1.,1.,1.);\n    \n    float cnt = 2.;\n    float cur = f*cnt;\n    float curIdx = floor(cur);\n    return mix(cols[int(curIdx)], cols[int(min(curIdx+1., cnt))], sat(fract(cur)));\n}\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\n\nfloat _loz(vec2 p, float r)\n{\n    return lenny(p)-r;\n}\n\nfloat _cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nfloat _boat(vec2 p)\n{\n    vec2 op = p;\n    p.y = abs(p.y)-.08;\n    p.y+=sin(iTime*3.)*.005;\n    p.x = mod(p.x-iTime*.05, 2.)-1.;\n    vec2 c = vec2(0.,-.1);\n    p-=c;\n    p *= r2d(sin(iTime*2.)*.1);\n    p+=c;\n    float base = max(_cir(p, .1),p.y+.05);\n    base = min(base, _sqr(p, vec2(0.005,.1)));\n    base = min(base, max(_loz(p*vec2(3.,.75)+vec2(p.y*.75-.12,0.025),.1), -p.y-.04));\n    if (op.y < 0.)\n    base = max(max(base, sin(p.y*500.)+.8), abs(p.x)-0.05-sin(p.y*150.-iTime*2.)*.025);\n    return base;\n}\n\nfloat _fence(vec2 p)\n{\n    p -= vec2(-0.1,-.3);\n    vec2 op = p;\n    p.y = abs(p.y)-.05;\n\n    p.x = min(p.x,0.15);\n\n    float rep = .1;\n    p.x = mod(p.x+.5*rep, rep)-.5*rep;\n    float bar = _sqr(p, vec2(.01,.05));\n    \n    float top = _sqr(p-vec2(0.,.05), vec2(.4,.015));\n    \n    float base = min(bar, top);\n    base = max(base, op.x-.05);\n    if (op.y < 0.)\n        base = max(max(base, sin(op.y*500.)+.8), abs(p.x)-0.01-sin(p.y*150.-iTime*2.)*.01);\n    return base;\n}\n\n#define FFT(f) texelFetch(iChannel1, ivec2(f, 0),0).x\n\nvec3 rdr(vec2 uv, vec2 fragCoord)\n{\n    float stp = 0.005;// mix(0.005,0.1, sat(.5+.5*asin(sin(iTime*.5))/1.57));\n    uv = floor(uv/stp)*stp;\n    vec3 col;\n    \n    col = gradient(sat(-uv.y*3.+.75));\n    \n    vec2 sPos = uv*vec2(1.,sign(uv.y))-vec2(0.,.1+sin(iTime*.25)*.1);\n\n    float sun = _cir(sPos, .15);\n\n    if (uv.y < 0.)\n    {\n        float sunborder = abs(sPos.x)-.1-.05*sin(sPos.y*150.+iTime);\n        sun = max(max(sun, (sin(uv.y*500.)+.8)), sunborder);\n    }\n    \n    col = mix(col, vec3(0.055,0.408,0.867), sat(-uv.y*400.));\n    col += pow(texture(iChannel0, uv).x, 25.);\n    \n    col += 2.*pow(1.-sat(lenny((uv-vec2(.55,.25))*.25)*5.),15.)*vec3(1.)*pow(sat(FFT(50)), .75);\n    col += pow(1.-sat(lenny((uv-vec2(.35,.15))*.25)*15.),15.)*vec3(1.)*pow(sat(FFT(50)+.25), .75);\n    col += pow(1.-sat(lenny((uv-vec2(.35,.15))*.25)*15.),15.)*vec3(1.)*pow(sat(FFT(100)+.25), .75);\n    col += pow(1.-sat(lenny((uv-vec2(-.35,.25))*.25)*15.),15.)*vec3(1.)*pow(sat(FFT(150)+.25), .75);\n\n    \n    col = mix(col, mix(vec3(1.000,0.784,0.000), vec3(1.,0.,0.), 1.-sat(sPos.y*16.+1.75)), 1.-sat(sun*400.));\n    \n    float boat = _boat(uv-vec2(0.4,-0.05));\n    col = mix(col, vec3(0.), 1.-sat(boat*400.));\n    \n    float fence = _fence(uv);\n    col = mix(col, vec3(0.), 1.-sat(fence*400.));\n    \n\n\n    \n    col += (texture(iChannel0, uv*2.).x-.5)*.1;\n    vec2 uvv = uv; // vignette\n    uvv.x = mod(uvv.x-iTime*.05-.4, 2.)-1.;\n    col *= pow(sat(1.-sat(length((uvv)*2.)-.5)+.35),.5)*max(pow(FFT(10),.25),.5);\n    col += vec3(1.000,0.784,0.000)*1.5*col*pow(1.-sat(lenny(2.*sPos*vec2(1.,1.))-.35), 1.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv*1.5-vec2(-0.2,-.05), fragCoord);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28068, "src": "https://soundcloud.com/sephcarissa/the-wellerman-8-bit-version", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdj3Wc.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[430, 430, 449, 449, 507], [509, 509, 533, 533, 829], [831, 831, 852, 852, 884], [886, 886, 915, 915, 940], [942, 942, 971, 971, 997], [998, 998, 1026, 1026, 1077], [1079, 1079, 1100, 1100, 1588], [1590, 1590, 1612, 1612, 2061], [2118, 2118, 2153, 2153, 3729], [3731, 3731, 3788, 3788, 3944]], "test": "untested"}
{"id": "ssj3Wc", "name": "turbulence_texture", "author": "penghuailiang", "description": "\nfbm\n\nhttps://huailiang.github.io/blog/2021/noise/", "tags": ["fbm"], "likes": 4, "viewed": 2062, "published": 3, "date": "1618069877", "time_retrieved": "2024-07-30T19:27:20.622769", "image_code": "vec3 random_perlin( vec3 p ) {\n    p = vec3(\n            dot(p,vec3(127.1,311.7,69.5)),\n            dot(p,vec3(269.5,183.3,132.7)), \n            dot(p,vec3(247.3,108.5,96.5)) \n            );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise_perlin (vec3 p) {\n    vec3 i = floor(p);\n    vec3 s = fract(p);\n\n    // 3D8\n    float a = dot(random_perlin(i),s);\n    float b = dot(random_perlin(i + vec3(1, 0, 0)),s - vec3(1, 0, 0));\n    float c = dot(random_perlin(i + vec3(0, 1, 0)),s - vec3(0, 1, 0));\n    float d = dot(random_perlin(i + vec3(0, 0, 1)),s - vec3(0, 0, 1));\n    float e = dot(random_perlin(i + vec3(1, 1, 0)),s - vec3(1, 1, 0));\n    float f = dot(random_perlin(i + vec3(1, 0, 1)),s - vec3(1, 0, 1));\n    float g = dot(random_perlin(i + vec3(0, 1, 1)),s - vec3(0, 1, 1));\n    float h = dot(random_perlin(i + vec3(1, 1, 1)),s - vec3(1, 1, 1));\n\n    // Smooth Interpolation\n    vec3 u = smoothstep(0.,1.,s);\n\n    // \n    return mix(mix(mix( a, b, u.x),\n                mix( c, e, u.x), u.y),\n            mix(mix( d, f, u.x),\n                mix( g, h, u.x), u.y), u.z);\n}\nfloat noise_turbulence(vec3 p)\n{\n    float f = 0.0;\n    float a = 1.;\n    p = 4.0 * p;\n    for (int i = 0; i < 5; i++) {\n        f += a * abs(noise_perlin(p));\n        p = 2.0 * p;\n        a /= 2.;\n    }\n    return f;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float c1 = noise_turbulence(vec3(1.*uv, iTime/10.0));\n    vec3 color = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1*c1);\n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssj3Wc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 243], [244, 244, 273, 273, 1142], [1143, 1143, 1175, 1175, 1362], [1363, 1363, 1418, 1418, 1621]], "test": "untested"}
{"id": "7sBGDc", "name": "Day 478", "author": "jeyko", "description": "potate", "tags": ["mdtmjvm"], "likes": 31, "viewed": 529, "published": 3, "date": "1618069790", "time_retrieved": "2024-07-30T19:27:21.498428", "image_code": "\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    p.yz *= rot(1.*pow(max(sin(iTime*0.25),0.),4.));\n\n    float n = noise(p*14. + vec3(0,iTime*2.1,0));\n    \n    for(float i = 0.; i < 18.; i++){\n        vec3 q = p;\n        q.z += sin(i*5.)*0.2;\n        float dsp = sin(q.y*10. + iTime + i + sin(i*6. + iTime))*0.06 + cos(q.y*6. + iTime*1.5 + i*17.)*0.07 + sin(i*4.)*0.5;\n        q.x -= dsp;\n        float da = length(q.xz) - 0.01 - abs(sin(i +iTime*0.2))*0.02;\n        vec2 cd = vec2(da,1.);\n        cd = dminb(cd,vec2(da - n*0.04 -0.01 ,2.));\n        cd.x = fOpDifferenceRound (cd.x, -p.y + 2.*sin(iTime + 13.*i + sin(i*46. + iTime) )*0.2 + 0.3, 0.15);\n        \n        d = dmin(d,cd,q);\n    }\n    return d;  \n}\n\nvec3 pal(float m){\n    vec3 c = 0.5+0.5*sin(m + vec3(1.5,0.,-0.5));\n    c = pow(c, vec3( .5));\n    \n    return c;\n}\n\nfloat r11(float a){return fract(sin(a*142.5)*16.5);}\nfloat r21(vec2 a) {return fract(r11(a.x) + 3.*r11(a.y*1.2 - a.x + 2.));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    float pxsz = fwidth(uv.x);\n\n    vec3 col = vec3(0.95);\n    vec3 ocol = col;\n    \n    {\n        vec2 p = uv;\n        p.y += iTime*0.1 + sin(iTime)*0.05;\n        float md = 0.1;\n        vec2 id = floor(p/md);\n        p = pmod(p,md);\n        float d = abs(p.y);\n        d = min(d,abs(p.x));\n        float m = sin(id.y + iTime + cos(id.x*20. +sin(id.y + iTime*0.5)*13.))*0.04;\n        d -= m*0.03;\n        d = max(d,-abs(length(p) - 0.01 -m) + 0.04);\n        col = mix(col,vec3(0.1,0.4,0.5)*1.4,smoothstep(pxsz,0.,d));\n        //col = mix(col,vec3(0.6,0.7,0.4)*2.*col,col*smoothstep(pxsz,0.,uv.y + 0.3 + 0.04*7.*noise(vec3(uv*4.,1. + iTime))));\n        \n    }\n    \n    {\n    \n    }\n            vec2 p = uv;\n            \n            p.y += iTime*0.1;\n            float md = 0.02;\n            float mdb = 8.*md;\n            \n            vec2 ida = floor(p/md);\n            vec2 idb = floor(p/mdb);\n            \n            //p = pmod(p,md);\n            col = mix(col,pal(r21(idb)*5. + iTime) + 0.4,smoothstep(0.9,1.,\n                smoothstep(0.8,0.85,\n                    abs(ida.x*md + sin(ida.x)*.2))\n                    *sin(r21(ida)*20. + iTime*5. + cos(ida.y*20.)*6.))\n                    *sin( r21(idb)*20. + 1.*iTime)\n                    );\n            \n         \n    {\n    \n        vec3 ro = vec3(0,0,-1.);\n        vec3 rd = normalize(vec3(uv,1));\n        vec3 p = ro;\n        float t = 0.;\n        bool hit = false;\n        vec2 d;\n        for(int i = 0; i < 60; i++){\n            d = map(p);\n            if(d.x < 0.001){\n                hit = true;\n                break;\n            }\n            p = ro + rd*(t+=d.x*0.6);\n        }\n        \n        \n        if(hit){\n            vec3 ca = mix(ocol,vec3(0.1,0.4,0.5)*0.5,smoothstep(-0.1,0.6,P.x)*2.);\n            if(d.y == 1.){\n                col = ca;\n            } else if(d.y == 2.){\n               \n               //col += smoothstep(-0.1,0.6,P.x)*pal(P.y*5.);\n                \n                \n                col = mix(ca,pal(P.y*5.),smoothstep(0.01,0.16,length(P.xz)));\n            }\n            \n        }\n    }\n    \n    {\n        vec2 p = uv;\n        float md = 0.05;\n        \n        p.x -= 0.7 + md*1.;\n        p.y -= md*0.5+0.2;\n        vec2 id = floor(p/md);\n        p = pmod(p,md);\n        float d = (length(p ) - 0.02);\n        \n        float cnd = float(abs(id.x) == 0. && abs(id.y) < 4.);\n        \n        vec3 c = pal(id.y*1.5 + iTime + d*4.);\n        \n        d = 0.;\n        col = mix(col,col*0.7*c,cnd*smoothstep(0.03,-0.1,d));\n        //col *= 0. + cnd*mix(col*0.1,col,smoothstep(-0.1,0.04,d))+ (1.-cnd)*1.;\n        \n        col = mix(col,c+ 0.3,cnd*smoothstep(pxsz,0.,d));\n        \n        float db = 10e5;\n        for(float i = 0.; i <3.; i++ ){\n            float w = (sin(iTime/3.14*2.+ i ));\n            w = pow(max(w,0.),0.5);\n            db = xor(db,abs(length(uv + vec2(sin(i+iTime + sin(iTime + i)),0.)*0.4 ) - 0.2*w + 0.01)- 0.01);\n        \n        }\n        col = mix(col,6.*(1.-col + 0.1)*mix(pal(uv.x*4. + iTime + sin(iTime)),vec3(1),0.5),smoothstep(pxsz,0.,db) );\n        \n        \n        //col = mix(col,pal(uv.x*2.)*vec3(0.6,0.7,0.4)*2.*col,col*smoothstep(pxsz,0.,uv.y + 0.6 + 0.04*7.*noise(vec3(uv*9.,1. + iTime))));\n        \n        \n    }\n    \n    {\n        vec2 p = uv;\n        vec2 md = vec2(0.08,0.05);\n        \n        p.x += 0.67 + md.x*1.;\n        p.y += md.y*0.5+0.2;\n        \n        vec3 c = vec3(0.3,0.35,0.46)*col*2. + (0.4-col*0.5)*1.4;\n        c = c*2.*(1.-col);\n        c = max(c,0.6);\n        \n        vec3 oc = c*4.*(1.-col + 0.3);\n        c =  (pal(uv.y*11. + iTime*1.) + 0.5)*c*1.5*(col*1.);\n        \n        {\n            vec2 id = floor(p/md);\n            vec2 q = pmod(p,md);\n            float d = sdBox(q, vec2(0.1,0.002));\n            \n            d = xor(d,sdBox(q + vec2(+ sin(4.*id.y + iTime*3. + sin(id.y + iTime))*0.04,0.), vec2(0.02 ,0.01)));\n            \n            d = xor(d,0.0+sdBox(p - 0.01 , vec2(0.01 ,0.6)));\n            \n            \n            float cnd = float(abs(id.x) == 0. && abs(id.y) < 4.);\n            \n            col = mix(col,c,cnd*smoothstep(pxsz,0.,d));\n        \n            float od = d;\n            \n            d = sdBox(p - vec2(-0.022,0) , vec2(0.01 ,0.2));\n            \n            d = min(d,xor(d,sdBox(p - vec2(-0.022,0) , vec2(0.001 ,0.5))));\n            d = min(d,xor(d,sdBox(p - vec2(-0.06,0) , vec2(0.001 ,0.3))));\n            d = min(d,xor(d,sdBox(p - vec2(-0.05,0) , vec2(0.046 ,0.3))));\n            //d = min(d,xor(d,sdBox(p - vec2(-0.1,0.3) , vec2(0.02 ,0.1))));\n            //d = abs(d) - 0.001;\n            \n            \n            col = mix(col,c,smoothstep(pxsz,0.,d));\n        \n            float db = sdBox(uv + vec2(0.01,0.401) , vec2(0.6 ,0.015));\n            col = mix(col,oc,smoothstep(pxsz,0.,db));\n            \n        }\n        \n        //d = min(d, sdBox(uv + vec2(0.1), vec2(0.0,0.04)));\n        \n    }\n    \n    if(iMouse.z > 0. ){\n        col = max(6.*(1.-col + 0.1)*mix(pal(uv.x*4. + iTime + sin(iTime)),vec3(1),0.5),0.4);\n    \n    }\n    col =abs(col);\n    \n    //col = 1.-exp(-col*1.4);\n    //col = smoothstep(0.,1.,col);\n    //col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(0.5545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "vec3 P;\n\n#define iTime (iTime - 4.)\n#define dminb(a,b) a.x < b.x ? a : b\n\n#define xor(a,b) min(max(a,-(b)),max(b,-(a) +0.02))\n\nvec2 dmin(vec2 a, vec2 b,vec3 q){\n    vec2 d = a.x < b.x ? a : b;\n    if(d.x == a.x){\n    \n    } else {\n        P = q;\n    }\n    return d;\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,a) mod(p,a) - 0.5*a\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\nfloat sdBox(vec2 p, vec2 s){p = abs(p) -s; return max(p.y,p.x);}\n\nfloat noise(vec3 p){\n    float n = 0.;\n    float amp = 1.;\n    for(int i = 0; i < 2; i++){\n        p.xy *= rot(0.5);\n        p.yz *= rot(0.5);\n        \n        n += dot(sin(p),cos(p))*amp;\n        p *= 1.5;\n        amp *= 0.6;\n    }\n    return n;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 18, 18, 712], [714, 714, 732, 732, 829], [831, 831, 850, 850, 883], [884, 884, 903, 903, 956], [958, 958, 1015, 1015, 6291]], "test": "untested"}
{"id": "7s2GWc", "name": "perlin_noise_8x", "author": "penghuailiang", "description": "8 perlin noise ", "tags": ["perlinnoise"], "likes": 0, "viewed": 206, "published": 3, "date": "1618069020", "time_retrieved": "2024-07-30T19:27:22.549617", "image_code": "#define SCALE 8.\n\nvec3 random_perlin( vec3 p ) {\n    p = vec3(\n            dot(p,vec3(127.1,311.7,69.5)),\n            dot(p,vec3(269.5,183.3,132.7)), \n            dot(p,vec3(247.3,108.5,96.5)) \n            );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise_perlin (vec3 p) {\n    vec3 i = floor(p);\n    vec3 s = fract(p);\n\n    // 3D8\n    float a = dot(random_perlin(i),s);\n    float b = dot(random_perlin(i + vec3(1, 0, 0)),s - vec3(1, 0, 0));\n    float c = dot(random_perlin(i + vec3(0, 1, 0)),s - vec3(0, 1, 0));\n    float d = dot(random_perlin(i + vec3(0, 0, 1)),s - vec3(0, 0, 1));\n    float e = dot(random_perlin(i + vec3(1, 1, 0)),s - vec3(1, 1, 0));\n    float f = dot(random_perlin(i + vec3(1, 0, 1)),s - vec3(1, 0, 1));\n    float g = dot(random_perlin(i + vec3(0, 1, 1)),s - vec3(0, 1, 1));\n    float h = dot(random_perlin(i + vec3(1, 1, 1)),s - vec3(1, 1, 1));\n\n    // Smooth Interpolation\n    vec3 u = smoothstep(0.,1.,s);\n\n    // \n    return mix(mix(mix( a, b, u.x),\n                mix( c, e, u.x), u.y),\n            mix(mix( d, f, u.x),\n                mix( g, h, u.x), u.y), u.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float c = noise_perlin(vec3(SCALE*uv, iTime));\n    vec3 color= vec3(c,c,c);\n    fragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2GWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 48, 48, 261], [263, 263, 292, 292, 1161], [1163, 1163, 1218, 1218, 1379]], "test": "untested"}
{"id": "ss2GWc", "name": "celluar_noise_16x", "author": "penghuailiang", "description": "celluar noise texture generator\n\nBlog https://huailiang.github.io/blog/2021/noise/", "tags": ["noise", "celluar"], "likes": 0, "viewed": 1932, "published": 3, "date": "1618068933", "time_retrieved": "2024-07-30T19:27:23.364438", "image_code": "#define SCALE 16.\n\nvec2 random(vec2 st){\n    return  fract(\n        sin(\n            vec2(\n                dot(st, vec2(127.1,311.7)),\n                dot(st, vec2(269.5,183.3))\n            )\n        ) * 43758.5453\n    );\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p); // i\n    vec2 f = fract(p); // \n    float F1 = 1.;\n    // 9\n    for (int j = -1; j <= 1; j++) {\n        for (int k = -1; k <= 1; k++) {\n            vec2 neighbor = vec2(float(j), float(k));\n            vec2 point = random(i + neighbor);\n            float d = length(point + neighbor - f);\n            F1 = min(F1,d);\n        }\n    }\n    return F1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float c = noise(vec2(SCALE*uv));\n    //c = pow(c, 2.);\n    c = pow(c, 2. * (0.5+abs(sin(iTime))));\n    vec3 color= vec3(c,c,c);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2GWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 40, 40, 223], [225, 225, 246, 246, 736], [738, 738, 793, 793, 1004]], "test": "untested"}
{"id": "sdjGWc", "name": "perlin_noise_4x", "author": "penghuailiang", "description": "perlin noise genrator", "tags": ["noisetexture"], "likes": 2, "viewed": 2031, "published": 3, "date": "1618067938", "time_retrieved": "2024-07-30T19:27:24.128396", "image_code": "#define SCALE 4.\n\nvec3 random_perlin( vec3 p ) {\n    p = vec3(\n            dot(p,vec3(127.1,311.7,69.5)),\n            dot(p,vec3(269.5,183.3,132.7)), \n            dot(p,vec3(247.3,108.5,96.5)) \n            );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise_perlin (vec3 p) {\n    vec3 i = floor(p);\n    vec3 s = fract(p);\n\n    // 3D8\n    float a = dot(random_perlin(i),s);\n    float b = dot(random_perlin(i + vec3(1, 0, 0)),s - vec3(1, 0, 0));\n    float c = dot(random_perlin(i + vec3(0, 1, 0)),s - vec3(0, 1, 0));\n    float d = dot(random_perlin(i + vec3(0, 0, 1)),s - vec3(0, 0, 1));\n    float e = dot(random_perlin(i + vec3(1, 1, 0)),s - vec3(1, 1, 0));\n    float f = dot(random_perlin(i + vec3(1, 0, 1)),s - vec3(1, 0, 1));\n    float g = dot(random_perlin(i + vec3(0, 1, 1)),s - vec3(0, 1, 1));\n    float h = dot(random_perlin(i + vec3(1, 1, 1)),s - vec3(1, 1, 1));\n\n    // Smooth Interpolation\n    vec3 u = smoothstep(0.,1.,s);\n\n    // \n    return mix(mix(mix( a, b, u.x),\n                mix( c, e, u.x), u.y),\n            mix(mix( d, f, u.x),\n                mix( g, h, u.x), u.y), u.z);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float c = noise_perlin(vec3(SCALE*uv, iTime));\n    vec3 color= vec3(c,c,c);\n    fragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 48, 48, 261], [263, 263, 292, 292, 1161], [1164, 1164, 1219, 1219, 1380]], "test": "untested"}
{"id": "7dj3D3", "name": "Magic Minecraft Cube [Zherdev]", "author": "s02180426", "description": "Magic Minecraft Cube [Zherdev]\n\nMinecraft sub scene generation is inspired by https://www.shadertoy.com/view/tslGRX\n\nSee it at Github:\nhttps://github.com/Zherdev/shadertoy-magic-cube/", "tags": ["cube", "minecraft", "mashgraph", "zherdev"], "likes": 2, "viewed": 408, "published": 3, "date": "1618066424", "time_retrieved": "2024-07-30T19:27:25.075862", "image_code": "// Magic Minecraft Cube\n// https://github.com/Zherdev/shadertoy-magic-cube/\n//\n// \"Image\" module - takes mean result from Buffer B and draws it.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26834, "src": "https://soundcloud.com/minecraft-soundtrack/sweden", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// Magic Minecraft Cube\n// https://github.com/Zherdev/shadertoy-magic-cube/\n//\n// \"Buffer A\" module - renders image for each frame.\n\n\n// Common ======================================================================\n\nconst float INF = 1e10;\nconst int   LIGHTS_NUM = 2;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265359;\n\nfloat sqr(float v)\n{\n    return v * v;\n}\n\nvec2 getUV(vec2 fragCoord)\n{\n    return (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n}\n\nfloat noise(vec3 v)\n{\n    return textureLod(iChannel0, v, 0.0).x;\n}\n\nfloat noise3(vec3 p)\n{\n    vec3 size = 1.0 / vec3(textureSize(iChannel0, 0));\n    return (\n        noise(p * size * 1.0 + vec3(0.52, 0.78, 0.43)) * 0.5 +\n        noise(p * size * 2.0 + vec3(0.33, 0.30, 0.76)) * 0.25 +\n        noise(p * size * 4.0 + vec3(0.70, 0.25, 0.92)) * 0.125) * 1.14;\n}\n\nfloat rand(float frame)\n{\n    return fract(\n            sin(\n                dot(\n                    vec3(frame),\n                    vec3(12.9899,78.234,45.5433)\n                )\n            ) * 43758.5452);\n}\n\nstruct TraceResult {\n    vec3  vp;\n    vec3  p;\n    vec3  n;\n    float dist;\n    bool  hit;\n};\n\nstruct TraceSubsceneResult {\n    TraceResult globalTrace;\n    TraceResult subTrace;\n    float       sumDist;\n    bool        hit;\n};\n\nstruct RefractionResult {\n    vec3 newDir;\n    bool isReflection;\n};\n\nRefractionResult calcRefraction(vec3 v, vec3 normal, float n1, float n2) {\n    RefractionResult res;\n    \n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    \n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3  tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    \n    if (abs(sinB) > 1.0) {\n        res.newDir = reflect(v, normal);\n        res.isReflection = true;\n        return res;\n    }\n    \n    float cosB = sqrt(1.0 - sinB * sinB);\n    \n    res.newDir = sinB * tang + cosB * normal;\n    return res;\n}\n\n\n// Common ^=====================================================================\n\n// Lights ======================================================================\n\nstruct Light {\n    vec3  pos;\n    vec3  color;\n    float attBase;\n    float radius;\n};\n\nstruct TraceLightResult {\n    float dist;\n    vec3  n;\n    vec3  color;\n    bool  hit;\n};\n\nvec3 calcLight(Light lights[LIGHTS_NUM], vec3 pos, vec3 color, vec3 normal) \n{\n    vec3 sum = vec3(0.0);\n    \n    for (int i = 0; i < LIGHTS_NUM; i++) {\n        Light light = lights[i];\n        vec3 dist = light.pos - pos;\n        float distSq = dot(dist, dist);\n        float att = light.attBase / distSq;\n        sum += max(0.0, dot(normal, normalize(dist))) * light.color * att;\n    }\n    \n    return color * sum;\n}\n\nTraceResult traceLight(Light light, vec3 orig, vec3 dir)\n{\n    TraceResult res;\n    \n    vec3 pos = orig - light.pos;\n    \n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - sqr(light.radius);\n    \n    float D = sqr(b) - a * c;   \n    if (D < 0.0) {\n        return res;\n    }\n    \n    float t1 = -b - sqrt(D);\n    if (t1 < 0.0) {\n        t1 = INF;\n    }\n    \n    float t2 = -b + sqrt(D);\n    if (t1 < 0.0) {\n        t1 = INF;\n    }\n    \n    float t = min(t1, t2);\n    if (t == INF) {\n        return res;\n    }\n   \n    res.n = normalize(pos + t * dir);\n    res.dist = t;\n    res.hit = true;\n    return res;\n}\n\nTraceLightResult traceLights(Light lights[LIGHTS_NUM], vec3 orig, vec3 dir) \n{\n    TraceLightResult res;\n    res.dist = INF;\n    \n\n    for (int i = 0; i < LIGHTS_NUM; i++) {\n        Light light = lights[i];\n        TraceResult tLight = traceLight(light, orig, dir);\n        if (tLight.hit && tLight.dist < res.dist) {\n            res.color = light.color;\n            res.n = tLight.n;\n            res.dist = tLight.dist;\n        }\n    }\n    \n    res.hit = res.dist >= 0.0 && res.dist < INF;\n    return res;\n}\n\n// Lights ^=====================================================================\n\n// Cube figure =================================================================\n\nstruct Cube {\n    float size;\n    float reflectN;\n    float reflectR;\n    vec3  color;\n};\n\nfloat traceCubePlane(Cube cube, vec3 normal, vec3 orig, vec3 dir) \n{\n    // normal * (orig + t * dir) + cube.size = 0\n    // t = ?\n    float t = -(dot(normal, orig) + cube.size) / dot(normal, dir);\n    if (t < 0.0) {\n        return INF;\n    }\n    \n    vec3 pos = orig + t * dir;\n    if (abs(pos.x) > cube.size + PRECISION     ||\n            abs(pos.y) > cube.size + PRECISION ||\n            abs(pos.z) > cube.size + PRECISION) {\n        return INF;\n    }\n    \n    return t;\n}\n\nTraceResult traceCube(Cube cube, vec3 orig, vec3 dir) \n{\n    TraceResult res;\n    \n    float dist = INF;\n    vec3 normal;\n    \n    const int planesNum = 6;\n    vec3 planes[planesNum];\n    planes[0] = vec3(1, 0, 0);\n    planes[1] = vec3(-1, 0, 0);\n    planes[2] = vec3(0, 1, 0);\n    planes[3] = vec3(0, -1, 0);\n    planes[4] = vec3(0, 0, 1);\n    planes[5] = vec3(0, 0, -1);\n    \n    for (int i = 0; i < planesNum; i++) {\n        vec3 plane = planes[i];\n        float distToPlane = traceCubePlane(cube, plane, orig, dir);\n        if (distToPlane < dist) {\n            dist = distToPlane;\n            normal = plane;\n        }\n    }\n    \n    res.dist = dist;\n    res.n = -normal;\n    res.hit = dist >= 0.0 && dist < INF;\n    \n    return res;\n}\n\n// Cube figure ^================================================================\n\n// Minecraft ===================================================================\n\nstruct Minecraft {\n    Cube  subscene;\n    float size;\n    float maxHeight;\n};\n\nbool isMinecraftGrassBlock(Minecraft mine, vec3 vp)\n{\n    if (vp.y < mine.maxHeight - 2.0) {\n        const float threshold = 0.75;\n        return noise3(vp * 0.03) + vp.y * -0.015 > threshold;\n    }\n    \n    return false;\n}\n\nTraceResult traceMinecraftGrass(Minecraft mine, vec3 orig, vec3 dir)\n{\n    float maxDist = length(\n            vec2(2.0 * mine.size, 2.0 * mine.size));\n    float dist = maxDist;\n    \n    TraceResult res;\n    res.n = -dir;\n    res.dist = INF;\n\n    vec3 id = 1.0 / dir;\n    vec3 sd = sign(dir);\n    vec3 nd = max(-sd, 0.0);\n    vec3 vp = floor(orig) - nd * vec3(equal(floor(orig), orig));\n    vec3 pos = orig;\n\n    for (int i = 0; i < int(maxDist); i++) {\n        if (dist <= 0.0 || orig.y > mine.maxHeight && dir.y > 0.0) {\n        \tbreak;\n        }\n\n        if (isMinecraftGrassBlock(mine, vp)) {\n\t\t\tres.vp = vp;\n\t\t\tres.p = pos;\n\t\t\tres.dist = maxDist - dist;\n\t\t\tres.hit = true;\n\t\t\treturn res;\n        }\n\n        vec3 n = mix(floor(pos + 1.0), ceil(pos - 1.0), nd);\n\t\tvec3 ls = (n - pos) * id;\n\t\tfloat l = min(min(ls.x, ls.y), ls.z);\n\t\tvec3 a = vec3(equal(vec3(l), ls));\n\n        pos = mix(pos + dir * l, n, a);\n        vp += sd * a;\n        res.n = -sd * a;\n        dist -= l;\n    }\n\n    return res;\n}\n\nvec3 renderMinecraftGrass(Minecraft mine, TraceResult r, vec3 orig, vec3 dir)\n{\n    const vec3 grassBaseColor = vec3(0.5, 0.8, 0.25);\n    const vec3 dirtColor = vec3(0.8, 0.6, 0.4);\n    float texelNoise = textureLod(iChannel0, r.p * 0.5, 0.0).r;\n\n    // Check if block above this is grass (dirt) too.\n    float grassMix = 0.0;\n    if (!isMinecraftGrassBlock(mine, r.vp + vec3(0, 1, 0))) {\n        if (texelNoise * 4.0 + floor(fract(r.p.y) * 16.0) > 15.0) {\n            grassMix = 1.0;\n        } else {\n            grassMix = max(0.0, r.n.y);\n        }\n    }\n\n    vec3 texel = vec3(texelNoise) * 0.3 + 0.75;\n    vec3 grassColor = texel * mix(dirtColor, grassBaseColor, grassMix);\n    return grassColor;\n}\n\nvec3 toMinePos(Minecraft mine, TraceResult tMineCube, vec3 orig, vec3 dir)\n{\n    vec3 mineGlobalPos = orig + tMineCube.dist * dir;\n    vec3 minePos = mineGlobalPos * mine.size / mine.subscene.size;\n    minePos.y -= 10.0;\n    minePos.x += 45.0;\n    return minePos;\n}\n\nbool isMinecraftNoise(\n        Minecraft mine, TraceSubsceneResult t, vec3 orig, vec3 dir)\n{\n    vec3 minePos = toMinePos(mine, t.globalTrace, orig, dir);\n    vec3 globalPos = orig + t.sumDist * dir;\n    return length(globalPos) / mine.subscene.size * 3.5 - \n           minePos.y / mine.size +\n           noise(globalPos) * 2.0 < 5.0;\n}\n\nTraceSubsceneResult traceMinecraftSubscene(Minecraft mine, vec3 orig, vec3 dir)\n{\n    TraceSubsceneResult res;\n    \n    TraceResult tMineCube = traceCube(mine.subscene, orig, dir);\n    res.globalTrace = tMineCube;\n    if (tMineCube.hit) {\n        vec3 minePos = toMinePos(mine, tMineCube, orig, dir);\n        res.subTrace = traceMinecraftGrass(mine, minePos, dir);\n        res.sumDist = tMineCube.dist + res.subTrace.dist / \n                (mine.size / mine.subscene.size);\n        \n        res.subTrace.hit = res.subTrace.hit && isMinecraftNoise(mine, res, orig, dir);\n    }\n    \n    res.hit = res.globalTrace.hit && res.subTrace.hit;\n    \n    return res;\n}\n\nvec3 renderMinecraftSubscene(\n        Minecraft mine, TraceSubsceneResult t, vec3 orig, vec3 dir)\n{\n    vec3 minePos = toMinePos(mine, t.globalTrace, orig, dir);\n    return renderMinecraftGrass(mine, t.subTrace, minePos, dir);\n}\n\n// Minecraft ^==================================================================\n\n// Cylinder figure =============================================================\n\nstruct Cylinder {\n    float radius;\n    float height;\n    vec3  center;\n    vec3  color;\n};\n\nfloat traceCylinderPlane(Cylinder cyl, vec3 normal, vec3 orig, vec3 dir)\n{\n    float d = cyl.height + cyl.center.y;\n    float t = -(dot(normal, orig) + d) / dot(normal, dir);\n    if (t < 0.0) {\n        return INF;\n    }\n    \n    vec3 pos = orig + t * dir;\n    if (length(pos.xz - cyl.center.xz) > cyl.radius) {\n        return INF;\n    }\n    \n    return t;\n}\n\nvec3 calcCylSideNormal(Cylinder cyl, float dist, vec3 orig, vec3 dir)\n{\n    vec3 pos = orig + dist * dir;\n    vec3 normal = normalize(vec3(pos.x, 0.0, pos.z));\n    return normal;\n}\n\nfloat traceCylinderSide(Cylinder cyl, vec3 orig, vec3 dir)\n{\n    // length((orig + t * dir).xy) = cyl.radius\n    // t = ?\n    \n    float a = sqr(length(dir.xz));\n    float b = 2.0 * dot(dir.xz, orig.xz);\n    float c = sqr(length(orig.xz)) - sqr(cyl.radius);\n    float D = sqr(b) - 4.0 * a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    \n    float t1 = (-b + sqrt(D)) / (2.0 * a);\n    if (t1 < 0.0) {\n        t1 = INF;\n    }\n    \n    float t2 = (-b - sqrt(D)) / (2.0 * a);\n    if (t2 < 0.0) {\n        t2 = INF;\n    }\n    \n    float t = min(t1, t2);\n    vec3 pos = orig + t * dir;\n    if ((pos.y > cyl.center.y + cyl.height) ||\n             (pos.y < cyl.center.y - cyl.height)) {\n        return INF;\n    }\n    return t;\n}\n\nTraceResult traceCylinder(Cylinder cyl, vec3 orig, vec3 dir)\n{\n    TraceResult res;\n    \n    float dist = INF;\n    vec3 normal;\n    \n    vec3 plane = vec3(0, -1, 0);\n    float toPlane = traceCylinderPlane(cyl, plane, orig, dir);\n    if (toPlane < dist) {\n        dist = toPlane;\n        normal = -plane;\n    }\n    \n    float toSide = traceCylinderSide(cyl, orig, dir);\n    if (toSide < dist) {\n        dist = toSide;\n        normal = calcCylSideNormal(cyl, dist, orig, dir);\n    }\n    \n    res.dist = dist;\n    res.n = normal;\n    res.hit = dist >= 0.0 && dist < INF;\n    \n    return res;\n}\n\n// Cylinder figure ^============================================================\n\n// Main ========================================================================\n\nmat3 mainCamera(vec3 cameraPos, vec3 lookAtPoint)\n{\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\n\treturn mat3(-cr, cu, -cd);\n}\n\nmat2 mainRotate(float angle) {\n    float s = sin(angle);\n    float cs = cos(angle);\n    \n    return mat2(\n                cs, -s, \n                s,  cs\n            );\n}\n\nvec3 renderMainFrag(vec2 uv, vec2 fragCoord)\n{\n    vec3 lp = vec3(0);\n    vec3 orig = vec3(0, 1.3, 3.5);\n    orig.xz *= mainRotate(PI / 6.0);\n    \n    mat3 camera = mainCamera(orig, lp);\n    vec3 dir = camera * normalize(vec3(uv, -1));\n    \n    vec3 randVals = vec3(\n            rand(float(iFrame)), \n            rand(float(iFrame + 5)), \n            rand(float(iFrame + 15)));\n\n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float nPrev = AIR_N;\n    float GLASS_R = sqr(AIR_N - GLASS_N) / sqr(AIR_N + GLASS_N);\n    \n    // Light setup =============================================================\n    Light lights[LIGHTS_NUM];\n    \n    lights[0].pos = vec3(1.8, 1.5, 1.8);\n    lights[0].color = vec3(1, 1, 1);\n    lights[0].attBase = 20.0;\n    lights[0].radius = 0.3;\n    \n    lights[1].pos = vec3(-3.5, 0.5, -1.0);\n    lights[1].color = vec3(1.1, 0.6, 0.6);\n    lights[1].attBase = 10.0;\n    lights[1].radius = 0.2;\n    // Light setup ^============================================================\n\n    // Figures setup ===========================================================\n    Cylinder cyl;\n    cyl.radius = 1.3;\n    cyl.height = 2.15 + PRECISION;\n    cyl.center = vec3(0.0, -3, 0.0);\n    cyl.color = vec3(0.9, 1.0, 0.9);\n\n    Cube cube;\n    cube.size = 0.85;\n    cube.reflectN = GLASS_N;\n    cube.reflectR = GLASS_R;\n    cube.color = vec3(0.9, 0.7, 1.0);\n    // Figures setup ^==========================================================\n    \n    // Minecraft setup =========================================================\n    Cube mineSubscene;\n    mineSubscene.size = 0.7;\n    \n    Minecraft mine;\n    mine.subscene = mineSubscene;\n    mine.size = 15.0;\n    mine.maxHeight = 18.0;\n    // Minecraft setup ^========================================================\n    \n    \n    vec3 colorMult = vec3(1, 1, 1);\n    vec3 res = vec3(0.0);\n    \n    for (int i = 0; i < 10; i++) {\n        float t = INF;\n        int materialType = 0;\n        vec3 color = vec3(0);\n        vec3 normal = vec3(0);\n        float nNext = AIR_N;\n        \n        TraceLightResult tLight = traceLights(lights, orig, dir);\n        if (tLight.hit && tLight.dist < t) {\n            t = tLight.dist;\n            color = tLight.color;\n            normal = tLight.n;\n            materialType = EMISSION;\n        }\n        \n        TraceResult tCube = traceCube(cube, orig, dir);\n        if (tCube.hit && tCube.dist < t) {\n            t = tCube.dist;\n            normal = tCube.n;\n    \n            if (randVals.x < cube.reflectR) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= cube.color;\n                materialType = REFRACTION;\n                if (dot(dir, normal) > 0.0) {\n                    nNext = AIR_N;\n                } else {\n                    nNext = cube.reflectN;\n                }\n            }\n        }\n        \n        TraceResult tCyl = traceCylinder(cyl, orig, dir);\n        if (tCyl.hit && tCyl.dist < t) {\n            t = tCyl.dist;\n            normal = tCyl.n;\n            materialType = DIFFUSE;\n            color = cyl.color;\n        }\n        \n        TraceSubsceneResult tMine = traceMinecraftSubscene(mine, orig, dir);\n        if (tMine.hit && tMine.sumDist < t) {\n            t = tMine.sumDist;\n            materialType = DIFFUSE;\n            color = renderMinecraftSubscene(mine, tMine, orig, dir);\n            normal = tMine.subTrace.n;\n        }\n        \n        if (t != INF) {\n            vec3 gloalPos = orig + t * dir;\n            \n            if (materialType == DIFFUSE) {\n                res = calcLight(lights, gloalPos, color, normal) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                dir = reflect(dir, normal);\n                orig = gloalPos + dir * PRECISION;\n            } else if (materialType == REFRACTION) {\n                RefractionResult ref = calcRefraction(dir, normal, nPrev, nNext);\n                dir = ref.newDir;\n                orig = gloalPos + dir * 2.0 * PRECISION;\n                \n                if (!ref.isReflection) {\n                    nPrev = nNext;\n                }\n            } else if (materialType == EMISSION) {\n                res = color * colorMult;\n                break;\n            }\n        } else {\n            res = texture(iChannel1, dir).rgb * colorMult;\n            break;\n        }\n    }\n    \n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0);\n    vec2 uv = getUV(fragCoord);\n\n    const int antiAliasing = 8;\n    vec2 uvs[antiAliasing];\n    uvs[0] = vec2(0.0, 0.0);\n    uvs[1] = vec2(1.0, 1.0);\n    uvs[2] = vec2(-1.0, -1.0);\n    uvs[3] = vec2(-1.0, 1.0);\n    uvs[4] = vec2(1.0, -1.0);\n    uvs[5] = vec2(0.0, -1.0);\n    uvs[6] = vec2(1.0, 0.0);\n    uvs[7] = vec2(-1.0, 0.0);\n    \n    for (int i = 0; i < antiAliasing; i++) {\n        vec2 uvh = uv + uvs[i] / iResolution.xy;\n        col += renderMainFrag(uvh, fragCoord);\n    }\n    col /= float(antiAliasing);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n// Main ^=======================================================================\n", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Magic Minecraft Cube\n// https://github.com/Zherdev/shadertoy-magic-cube/\n//\n// \"Buffer B\" module - used for result accumulation.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dj3D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 203, 203, 307]], "test": "untested"}
{"id": "7dj3W3", "name": "cut tree", "author": "Torumu106", "description": "tree", "tags": ["tree", "shader", "cut"], "likes": 2, "viewed": 200, "published": 3, "date": "1618063973", "time_retrieved": "2024-07-30T19:27:25.846801", "image_code": "float smoothmin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(0.767,0.618,0.427);\n    \n    r.x /= 0.5;\n    float warp = smoothmin(0.0,( (r.x - 1.2)*(r.x - 1.2) + (r.y-0.1)*(r.y-0.1) - 0.4 ) * 2.0, 8.0);\n    r -= vec2(2.0,-0.5);\n    \n    float distance = sqrt(r.x*r.x+r.y*r.y +0.96 + warp + sin((atan(r.y/r.x)+0.1)*10. )* 0.02*(r.x*r.x + r.y*r.y));\n    float nyanko = mod(distance,0.2);\n    if(nyanko<=0.05){\n        col = vec3(0.6,0.419,0.246);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dj3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 114], [115, 115, 171, 171, 754]], "test": "untested"}
{"id": "sdj3W3", "name": "noisey col journey * cam", "author": "SimonOakey", "description": "licenced under love, peace and happyness ", "tags": ["noise", "color", "loop", "field", "multiple"], "likes": 6, "viewed": 552, "published": 3, "date": "1618062952", "time_retrieved": "2024-07-30T19:27:26.630706", "image_code": "/*licenced under love, peace and happyness  */\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n const float PI = 3.14159;\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution\n\nvec2 ouv;\n\n\n //generic rotation formula\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\n\n\nvec3 returnGrain(vec2 _uv, float amount){\n\t\n\t float x = (_uv.x + 4.0 ) * (_uv.y + 4.0 ) * (time * 10.0);\n\t vec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) *  amount;\n\t return grain.xyz;\n\t\n}\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    \n     vec4 cc = texture(iChannel0,ouv );\n\t\n\tfor(int i=0;i<11; i++){\n\n\n    \n    \n\tvec2 p1 = vec2(p.x*.4*float(i),p.y*.4*float(i));\n\t\t\n\tp1.x *=\tnoise(p1*.5+time*.1)*.4;\n\tp1.y *=\tnoise(p*.5-time*.1)*.4;\n    \n\n    f -=  noise(vec2(cc.r,cc.b ))*.019;\n    f +=  noise(p1); \n       \n    \n\t\n\t}\n\t\n\n    return f;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p*2.3 + fbm( p*.33 ) ) );\n}\n\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat _x = mouse.x;\n\n\tvec2 uv = gl_FragCoord.xy/resolution.y;\n\t\n\t\n\t\n\tuv.x += resolution.y/resolution.x;\n    \n    \n    ouv = gl_FragCoord.xy/resolution.xy;\n   \n    \n    \n\t\n\tuv = rot(uv,time*.03);\n\t\n\tfloat shade = pattern(uv);\n\t\n\t\n    vec2 uv_osc = vec2( \n    sin(uv.x*PI*1.+PI)*.5+.5,\n    sin(uv.y*PI*1.+PI)*.5+.5\n    );\n    \n   \n     vec4 cc = texture(iChannel0,uv_osc );\n    \n    \n   // shade += sin(fbm( vec2(cc.r,cc.b))  )*12.;\n    \n    \n\t\n\tvec3 col = vec3(\n\t\tsin(shade*.91+ time*.01)*1.75+.5 ,\n\t\tcos(shade*3.+ time*.13)*.75+.5 ,\n\t\tcos(shade*13.+ time*.13)*.5+.6 \n\t\t\t//shade*.7+.4\n\t);\n\t\n\tcol = hsv2rgb(col);\n\t\n\tcol += returnGrain(uv,9.);\n\t\n\tfragColor = vec4( col, 1.0 );\n\n}\n\n\n\n\n ", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdj3W3.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[259, 286, 312, 312, 377], [381, 381, 422, 422, 603], [606, 606, 626, 626, 696], [698, 698, 718, 718, 953], [1008, 1008, 1029, 1029, 1357], [1359, 1359, 1387, 1387, 1437], [1441, 1441, 1468, 1468, 1597], [1600, 1600, 1657, 1657, 2336]], "test": "untested"}
{"id": "ss2GW3", "name": "noisey color journey", "author": "SimonOakey", "description": "licenced under love, peace and happyness ", "tags": ["noise", "color", "loop", "field", "multiple"], "likes": 3, "viewed": 244, "published": 3, "date": "1618060111", "time_retrieved": "2024-07-30T19:27:27.403639", "image_code": "/*licenced under love, peace and happyness  */\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n \n\n\n //generic rotation formula\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\n\n\nvec3 returnGrain(vec2 _uv, float amount){\n\t\n\t float x = (_uv.x + 4.0 ) * (_uv.y + 4.0 ) * (iTime * 10.0);\n\t vec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) *  amount;\n\t return grain.xyz;\n\t\n}\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n/*\n    vec2 p1 = vec2(p.x*.6,p.y*.6 + time*.12);\n    f += 0.500000*noise( p1); p1 = mtx*p1*3.03;\n\t\n   \n\tvec2 p2 = vec2(p.x*1.6 + time*.3 ,p.y*2.6 );\n    f += 0.300000*noise( p2); \n\t\n\t\n\tvec2 p3 = vec2(p.x*3.6 - time*.6 ,p.y*6.6 );\n    f += 0.200000*noise( p3);\n\t\n vec2 p4 = vec2(p.x*13.6 - time*.6 ,p.y*16.6 );\n    f += 0.200000*noise( p4);\n\t*/\n\t\n    \n     //p.x *= texture(iChannel1, p).x*1.2;\n     //p.y *= texture(iChannel1, p).y*1.2;\n    \n\t\n\tfor(int i=0;i<11; i++){\n\n\tvec2 p1 = vec2(p.x*.4*float(i),p.y*.4*float(i));\n\t\t\n\tp1.x *=\tnoise(p1*.5+iTime*.1)*.4;\n\tp1.y *=\tnoise(p*.5-iTime*.1)*.4;\n    \n    \n\t\t\n    \tf += 0.8*noise(p1); p1 = mtx*p1*3.03;\t\n\t\t\n\t\n\t}\n\t\n\n    return f;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p*2.3 + fbm( p*.33 ) ) );\n}\n\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat _x = iMouse.x;\n\n\tvec2 uv = gl_FragCoord.xy/iResolution.y;\n\t\n\t//uv.x = sin(uv.x*5.);\n\t\n\tuv.x += iResolution.y/iResolution.x;\n\t\n\tuv = rot(uv,iTime*.03);\n\t\n\tfloat shade = pattern(uv);\n\t\n\t\n\t\n\tvec3 col = vec3(\n\t\tsin(shade*.91+ iTime*.01)*1.75+.5 ,\n\t\tcos(shade*3.+ iTime*.13)*.75+.5 ,\n\t\tcos(shade*13.+ iTime*.13)*.5+.6 \n\t\t\t//shade*.7+.4\n\t);\n\t\n\tcol = hsv2rgb(col);\n\t\n\tcol += returnGrain(uv,9.);\n\t\n\tfragColor = vec4( col, 1.0 );\n\n}\n\n\n\n\n ", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2GW3.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[106, 133, 159, 159, 224], [228, 228, 269, 269, 451], [454, 454, 474, 474, 544], [546, 546, 566, 566, 801], [856, 856, 877, 877, 1572], [1574, 1574, 1602, 1602, 1652], [1656, 1656, 1683, 1683, 1812], [1815, 1815, 1872, 1872, 2304]], "test": "untested"}
{"id": "sd2GW3", "name": "Fractal 55_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 3, "viewed": 294, "published": 3, "date": "1618059935", "time_retrieved": "2024-07-30T19:27:28.241399", "image_code": "#define PI (atan(1.)*4.)\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.2),.6)*.02*exp(-.3*i*i*e)\n    )\n    {\n        p=g*d;\n        p+=vec3(0,0,iTime*.5);\n        p=R(p,normalize(vec3(1,2,2)),.5);\n        p=sin(p+3.*sin(p*.5));\n        s=2.;\n        for(int i=0;i++<5;)\n            p=abs(p-2.7)-1.3,\n            s*=e=2./min(dot(p,p),1.5),\n            p=abs(p)*e;\n        g+=e=length(p)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2GW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 167, 167, 661]], "test": "untested"}
{"id": "Ndj3Dc", "name": "Fractal 54_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 8, "viewed": 326, "published": 3, "date": "1618054750", "time_retrieved": "2024-07-30T19:27:29.220780", "image_code": "#define PI (atan(1.)*4.)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.6)*.03*exp(-.3*i*i*e)\n    )\n    {\n        p=g*d+vec3(-.5,0,iTime*.5);\n        p=sin(p);\n        s=2.;\n        for(int i=0;i++<5;)\n            p=abs(p-1.7)-1.3,\n            s*=e=2./min(dot(p,p),1.5),\n            p=abs(p)*e;\n        g+=e=length(p.zy)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndj3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 108, 108, 540]], "test": "untested"}
{"id": "3tVBzD", "name": "Pixels3000", "author": "z0rg", "description": "This is a description", "tags": ["grid", "retro", "pixels", "pioupiou"], "likes": 20, "viewed": 970, "published": 3, "date": "1618050608", "time_retrieved": "2024-07-30T19:27:30.100428", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 postFX(vec2 uv, float blur)\n{\n    vec3 col;\n    int cnt = 20;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = (fi/fcnt);\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 2.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*an*blur*.1;\n    \tcol += texture(iChannel0, p).xyz;\n    }\n    \n    return col/float(cnt);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec3 col = postFX(uv,mix(0.01,0.05, sin(iTime)*.5+.5))*mix(1., 2., pow(FFT(5), 5.));\n    \n\tcol = pow(col*1.25, vec3(1.+length(uv)));\n\n    col *= pow(FFT(0), .1);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26606, "src": "https://soundcloud.com/plant43/interlinked-ep-plant43-recordings-005", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec2 map(vec3 p)\n{\n    vec2 gnd = vec2(_plane(-p), 0.);\n    vec2 ex = vec2(min(_sph(p+vec3(0.,2.,sin(iTime*2.)), .5), _sph(p-vec3(sin(iTime), -2.+cos(iTime*.5),0.), .5)), 1.);\n    vec2 outD = _min(ex, gnd);\n    \n    float repa = 20.;\n    vec3 pa = p+vec3(0.,3.,iTime*15.);\n    pa.z = mod(pa.z+.5*repa, repa)-repa*.5;\n    pa.x += sin(pa.z-iTime)*1.5;\n    pa.y += cos(pa.z+iTime)+sin(iTime);\n    vec2 cubeA = vec2(_cube(pa, vec3(.1,.1,5.)), 1.);\n    \n    float repb = 40.;\n    vec3 pb = p+vec3(3.,3.,iTime*25.);\n    pb.z = mod(pb.z+.5*repb, repb)-repb*.5;\n    vec2 cubeB = vec2(_cube(pb, vec3(.2,1.,15.)), 2.);\n    \n    float repc = 40.;\n    vec3 pc = p+vec3(-3.,0.,iTime*55.);\n    pc.z = mod(pc.z+.5*repc, repc)-repc*.5;\n    vec2 cubeC = vec2(_cube(pc, vec3(.5,.05,15.)), 2.);\n    \n    outD = _min(outD, cubeA);\n    outD = _min(outD, cubeB);\n    outD = _min(outD, cubeC);\n    return outD;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    uv *= 1.; // FOV\n    vec2 uvs = sign(uv);\n    //uv = uvs*pow(abs(uv), vec2(.8));\n    uv *= pow(sat(length(uv*1.)), mix(.1, 0.5, sin(iTime*.5)*.5+.5));\n    return normalize(rd+uv.x*r+uv.y*u);\n}\n\n\nvec3 normal(vec3 p, float d)\n{\n    vec3 eps = vec3(0.01, 0.,0.);\n    return normalize(vec3(map(p+eps.xyy).x, map(p+eps.yxy).x, map(p+eps.yyx).x)-vec3(d));\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.392,0.212,0.471)*(1.-sat(lenny(uv*2.)));\n    \n    vec3 ro = vec3(sin(iTime*.5)*3.,sin(iTime)*.5-1.5,-7.);\n    vec3 ta = vec3(0.,-2.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 p = ro;\n    for (int i = 0; i < 128; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n        {\n            vec3 n = normal(p, res.x);\n            col = vec3(1.)*n*0.5+0.5;\n            vec3 a = vec3(0.784,0.000,1.000);\n            vec3 b = vec3(0.000,1.000,0.569);\n            if (res.y == 2.)\n            {\n                a = vec3(1.000,0.020,0.216);\n                b = vec3(0.996,0.765,0.125);\n            }\n            \n                col = mix(a, b, sat(0.5+0.5*dot(n, normalize(vec3(1.)))));\n            if (res.y < 0.5)\n            {\n                col = vec3(.5);\n                float th = .9;\n                vec2 sine = sat(sin(p.xz*5.+vec2(0.,iTime*25.))-th)/th;\n                float dgrd = mix(40., 1., pow(sat(length(p.xz*0.01)), .05));\n\n                \n                col *= sat(max(sine.x,sine.y)*dgrd);\n                col = mix(vec3(0.212,0.227,0.490)*.5, vec3(0.102,1.000,0.655), sat(col.x*3.));\n            }\n            \n            break;\n        }\n        p += res.x * rd*.7;\n    }\n    \n    col *= (1.-sat(lenny(uv)))+.5;\n    col += vec3(0.102,1.000,0.655)*(1.-sat(lenny(uv)))*.15;\n    return col;\n}\nvec3 rdr2(vec2 uv)\n{\n\n    \n    float a = atan(uv.y, uv.x);\n    \n    vec3 cols[7];\n    cols[0] = vec3(1.000,0.898,0.914);\n    cols[1] = vec3(1.000,0.000,0.149);\n    cols[2] = vec3(1.000,0.702,0.702);\n    cols[3] = vec3(1.000,0.302,0.580);\n    cols[4] = vec3(0.431,0.165,0.576);\n    cols[5] = vec3(0.000,1.000,0.933);\n    cols[6] = vec3(0.000,0.000,0.000);\n    \n    a+= iTime+sin(length(uv)*15.-iTime*50.)*.15*pow(FFT(100), 2.);\n    float f = sat(sin(a*2.)*.5+.5);\n    float stp = 0.15;\n    f = floor(f/stp)*stp;\n    float cur = f*7.;\n    int curIdx = min(int(floor(cur)), 6);\n    int nextIdx = min(curIdx+1, 6);\n    vec3 c = mix(cols[curIdx],cols[nextIdx], sat(fract(cur)));\n return sat((length(uv)-.25)*400.)*c*pow(1.-sat(length(uv)), .5);\n}\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvec3 quantize(vec2 uv, vec3 c, float th)\n{\n    return floor((c)/th+rand(uv.xy))*th;\n}\n\nvec2 pixpix(vec2 uv, float q)\n{\n    return floor(uv/q)*q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    uv *= mix(1.,1.9, FFT(10));\n    \n    float uvpix = 0.005;\n    uv = pixpix(uv, uvpix);\n    \n    vec3 col = rdr(uv);\n    col *= 1.-pow(sat(length(uv*1.25)), 2.);\n    col = quantize(uv, col, 0.25);\n    \n    col = mix(col, col.zxy, sat(sin(iTime)));\n    col = mix(col, col.yzx, pow(sat(sin(iTime*0.05*FFT(100))), 5.));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n\n#define PI 3.14159265\n#define FFT(a) texelFetch(iChannel1, ivec2(a, 0), 0).x\n#define sat(a) clamp(a, 0., 1.)\n\nfloat lenny(vec2 uv)\n{\n    return abs(uv.x)+abs(uv.y);\n}\n\nfloat _sph(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\nfloat _plane(vec3 p)\n{\n    return p.y;\n}\n\nfloat _cyl(vec3 p, vec2 s)\n{\n    return 0.;\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\nvec2 _max(vec2 a, vec2 b)\n{\n    if (a.x > b.x)\n        return a;\n    return b;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVBzD.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 431, 431, 850], [855, 855, 912, 912, 1154]], "test": "untested"}
{"id": "3t3yRl", "name": "Shamosis - Dinopwaur", "author": "z0rg", "description": "https://www.youtube.com/watch?v=euWx4bt-HPg", "tags": ["trance", "goa", "boomboom"], "likes": 4, "viewed": 414, "published": 3, "date": "1618049906", "time_retrieved": "2024-07-30T19:27:31.032935", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFT(p) pow(texelFetch(iChannel0, ivec2(int(p), 0), 0)*.45, vec4(4.5))\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y); \n}\n#define sat(a) clamp(a, 0.,1.)\nmat2 r2d(float a) \n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca,-sa, sa, ca);\n}\nvec2 _sub(vec2 a, vec2 b)\n{\n  if (a.x > -b.x)\n    return a;\n  return b;\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// power smooth min (k = 8);\nfloat _smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nvec3 getDir(vec3 rd, vec2 uv)\n{\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(r, rd));\n  \n  return rd+ r * uv.x + u * uv.y;\n}\n\nfloat rhombus(vec3 p, float sz)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-sz)*0.577;\n}\n\n\nvec2 map(vec3 p)\n{\n  float beat = FFT(5).x*3.;\n  vec2 cyl = vec2(sdCylinder(p, vec3(1., 1., 1.)), 0.);\n  vec3 p2 = p;\n  p2.xz += vec2(sin(beat), cos(beat))*4.;\n  vec2 sph = vec2(length(p2)-2.5*max(FFT(55).x, 0.007)*70., 0.);\n  p2 = p+vec3(1.);\n  vec2 sph2 = vec2(rhombus(p2, 5.5*max(FFT(205).x, 0.005)*70.), 0.);\n  return _min(_min(sph2, sph), cyl);\n  vec2 fl = vec2(p.y, 1.);\n  return _min(cyl, fl);\n}\n\nvec3 calcNormal( in vec3 p, in float t )\n{\n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 checkerBoard(vec2 uv)\n{\n  uv.y+=iTime*5.;\n  float sz = 1.5;\n  float x = mod(uv.x, sz)-sz*.5;\n  float y = mod(uv.y, sz)-sz*.5;\n  x = sat(x*200.);\n  float res = mix(x, 1.-x, sat(y*200.));\n  return vec3(res);\n}\n\nvec3 grad(vec2 uv)\n{\n  vec3 col;\n  vec3 blue = vec3(157., 200., 255.)/255.;\n  vec3 yellow = vec3(255, 241., 187.)/255.;\n  vec3 red = vec3(255., 190., 191.)/255.;\n  \n  float sz = 19.;\n  \n  if (uv.y < 0.)\n  {\n    return mix(yellow, red, sat(-uv.y*sz));\n  }\n  \n  \n  return mix(yellow, blue, sat(uv.y*sz));\n}\n\nfloat sig(vec2 uv)\n{\n  float attenBorder = 1.;\n  float t = iTime;// iTime;\n  float tst = sin(abs(uv.x)*5.+t)*.002;\n  return uv.y -.01- (attenBorder*sat(FFT(abs(uv.x*.005)).x*5.))*.05-tst;//*(1.-sat(abs(uv.x*2.)), 5.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col;\n  col = vec3(0.123, 0.07, 0.15);\n\n  vec3 rgb = pow(grad(uv), vec3(1.45));\n  rgb.x *= .6+sat(FFT(uv.x*.1).x)*100.;\n  \n  vec2 ouv = uv;\n  uv = vec2(atan(uv.y, uv.x), length(uv));\n  float ln = abs(sig(uv))-.00001;\n\n    col = mix(col, rgb, 1.-sat(ln*800.));\n    col += rgb *pow(1.-sat(ln*10.), 5.);\n\n  \n  for (int i = 0; i < 8; ++i)\n  {\n    float fi = float(i);\n    \n    vec2 uvt = ouv * r2d(fi);\n    uvt = vec2(atan(uvt.y, uvt.x), length(uvt));\n    float ln2 = abs(sig(uvt*fi/8.))-.00001*fi*fi;\n    \n    col += .3*rgb *pow(1.-sat(ln2*950.), 5.);\n\n  }\n  \n\n  return col;\n}\n\n\n\nvec2 myPixel(vec2 uv, float k)\n{\n  vec2 pxuv = uv/k;\n  pxuv = vec2(int(pxuv.x), int(pxuv.y))*k;\n  return pxuv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy)/iResolution.xx;\n uv *= .2;\n  \n  \n  \n  float rep = 1.+(sin(iTime*.5) < 0. ? 1. : sat(FFT(5).x*50.));\n  \n  if (false)//iTime > 78.8)\n  {\n  \n  float rep2 = .1*sin(iTime*.5);\n  uv *= r2d(sin(iTime+length(uv)*145.));\n  uv.x = mod(uv.x, rep2)-.5*rep2;\n  }\n  uv *= r2d(-3.14159265/2.);\n  uv *= mod(-iTime, 2.);\n  float r = 0.05/(sin(iTime));\n  uv *= r2d(mod(length(uv), r)/r);\n  \n  vec2 uv2 = uv;\n  uv2.x = (mod(atan(uv.y, uv.x), rep)-.5*rep)*.1;\n  uv2.y = FFT(abs(uv.y)).x+length(uv)*(mod(iTime*.5, 2.5))+sin(iTime)*.05;\n  \n  uv2 = myPixel(uv2, 0.01*sin(iTime*.5));\n  \n  vec3 col =rdr(uv2)*.7;\n  col += rdr(uv)*.1*(sin(iTime*.2)*.5+.5);\n\tcol *= .5+rdr(uv*.2);\n    float a = atan(uv.y, uv.x);\n    col = mix(col, mix(col.zyx, col, 0.), sat(sin(uv.x*15.+iTime)+.1*sin(length(uv-a*3.14159265*2.-iTime))));\n  col = pow(col, vec3(1.45));\n  vec3 txt;// = texture(iChannel1, fragCoord/iResolution.xy).xyz;\n  col *= mix(vec3(1.), vec3(5.), txt.x);\n  //col *= sat(iTime-2.);\n  col *= 1.-sat(iTime-502.);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25177, "src": "https://soundcloud.com/shamosis/shamosis-dinopwaur", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3yRl.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[476, 476, 497, 497, 528], [560, 560, 580, 580, 658], [659, 659, 686, 686, 732], [734, 734, 761, 761, 806], [807, 807, 843, 843, 877], [879, 908, 950, 950, 1028], [1030, 1030, 1061, 1061, 1185], [1187, 1187, 1220, 1220, 1269], [1272, 1272, 1290, 1290, 1674], [1676, 1676, 1718, 1718, 1943], [1945, 1945, 1973, 1973, 2157], [2159, 2159, 2179, 2179, 2463], [2465, 2465, 2485, 2485, 2684], [2686, 2686, 2705, 2705, 3285], [3289, 3289, 3321, 3321, 3401], [3403, 3403, 3460, 3460, 4530]], "test": "untested"}
{"id": "Ns23W3", "name": "Fractal 53_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 14, "viewed": 663, "published": 3, "date": "1618042850", "time_retrieved": "2024-07-30T19:27:31.929538", "image_code": "#define PI (atan(1.)*4.)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.6)*.02*exp(-.3*i*i*e)\n    )\n    {\n        p=g*d+vec3(0,0,iTime*.5);\n        p=asin(cos(p*PI/3.))/PI*3.;\n        s=3.;\n        for(int i;i++<6;)\n            p=abs(p-vec3(1.5,1,1.1))-vec3(1.1,1.3,1),\n            s*=e=2.2/clamp(dot(p,p),.5,2.3),\n            p=abs(p)*e;\n        g+=e=length(p.xz)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 108, 108, 584]], "test": "untested"}
{"id": "7sSGDc", "name": "Arc Path Segment", "author": "oneshade", "description": "Arc path between two points with a starting tangent.", "tags": ["curve", "segment", "path", "arc"], "likes": 2, "viewed": 196, "published": 3, "date": "1618032473", "time_retrieved": "2024-07-30T19:27:32.696487", "image_code": "// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdPlane2D(in vec2 p, in vec2 pos, in vec2 nor) {\n    return abs(dot(p - pos, nor));\n}\n\n// p: position\n// d: direction (sin/cos of tangent)\n// t: target\nfloat getRadius(in vec2 p, in vec2 d, in vec2 t) {\n    t -= p;\n    return dot(t, t) / dot(t, d * vec2(-2, 2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float a = iTime;\n    vec2 d = vec2(sin(a), cos(a));\n    float r = getRadius(vec2(0.0), d, vec2(2.0, 0.0));\n\n    vec2 n = vec2(-d.x, d.y);\n    vec2 o = n * r;\n\n    // Circle\n    drawSDF(abs(sdDisc(uv, o, abs(r))), vec3(0.0, 0.0, 1.0));\n\n    // Draw shortest segment\n    if (0.0 < uv.x && uv.x < 2.0 && uv.y * sign(o.y) < 0.0) {\n        drawSDF(abs(sdDisc(uv, o, abs(r))) - 0.01, vec3(1.0, 0.8, 0.0));\n    }\n\n    // Tangent\n    drawSDF(sdPlane2D(uv, vec2(0.0), n), vec3(1.0, 0.0, 0.0));\n\n    // End points\n    drawSDF(sdDisc(uv, vec2(0.0), 0.05), vec3(1.0));\n    drawSDF(sdDisc(uv, vec2(2.0, 0.0), 0.05), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 110, 158, 158, 190], [192, 192, 246, 246, 283], [285, 350, 400, 400, 462], [464, 464, 519, 519, 1429]], "test": "untested"}
{"id": "7dBGW3", "name": "Double Pendulum Butterfly Effect", "author": "DJDoomz", "description": "Directly inspired by: https://www.youtube.com/watch?v=ldnEHycw40E\n\nclick to reset position", "tags": ["2d", "chaos", "pendulum", "doublependulum"], "likes": 5, "viewed": 371, "published": 3, "date": "1618012741", "time_retrieved": "2024-07-30T19:27:33.572146", "image_code": "#define PI 3.14159265\n\nfloat lineseg(vec2 u, vec2 s, vec2 e)\n{\n    //shift coords to 0,0\n    vec2 l1 = u-s;\n    vec2 e2 = e-s;\n    //formula to find nearest projection of u on se\n    vec2 l2 = e2*(clamp( dot(l1,e2) /(dot(e2,e2)), 0., 1. ) );\n    \n    return 1.-smoothstep(.0,.02,length(l1-l2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 10.4*(fragCoord-.5*iResolution.xy)/iResolution.x;\n\n    vec3 col = vec3(0);\n    \n    for(float i = 0.; i < 250.; i++)\n    {\n        vec4 p = texelFetch(iChannel0, ivec2(i,0), 0);\n\n        float x = 1.5*sin(p.x);\n        float y = -1.5*cos(p.x);\n        float x2 = x + 1.5*sin(p.y);\n        float y2 = y - 1.5*cos(p.y);\n        \n        vec3 c = 0.5 + .5 * sin(i*PI/125.0+vec3(-PI,0,PI)/1.5);\n\n        c *= .2;\n        \n        col += c*lineseg(uv, vec2(0), vec2(x,y));\n        col += c*lineseg(uv, vec2(x,y), vec2(x2,y2));\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//need to store for each pendulum:\n//theta1, theta2, v1, v2\n//x       y       z   w\n\n//https://www.myphysicslab.com/pendulum/double-pendulum-en.html\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = texelFetch(iChannel0, ivec2(fragCoord),0);\n    \n    //reset every 15 secs\n    if(iMouse.z > 0.5 || iFrame <= 1)\n    {\n        float x1 = fragCoord.x/iResolution.x;\n        \n        p = vec4(2.14+fract(x1*.1)+iTime,1,0,0);\n    }\n    else if(fragCoord.x < 250. && fragCoord.y <= 1.)\n    {\n\n        //update position based on velocities\n        p.x += p.z;\n        p.y += p.w;\n\n        //update velocities\n        float div = (2. + 1. - cos(2.*p.x-2.*p.y));\n\n        p.z += 0.00005*((-G*(2.+1.)*sin(p.x)-G*sin(p.x-2.*p.y)-2.*sin(p.x-p.y)*(p.w*p.w+p.z*cos(p.x-p.y)))/div);\n        p.w += 0.00005*((2.*sin(p.x-p.y)*(p.z*p.z*(2.)+G*(1.+1.)*cos(p.x)+p.w*p.w*cos(p.x-p.y)))/div);\n        \n        //friction...\n        p.zw /= 1.0001;\n        \n    }\n    \n    fragColor = p;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define L 1.\n#define G 6.", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 62, 88, 296], [298, 298, 355, 406, 1005]], "test": "untested"}
{"id": "MdlSWN", "name": "celestialBlob_01", "author": "entropynine", "description": "modification of \"Glass Eel\" by Kali", "tags": ["3dblob"], "likes": 5, "viewed": 318, "published": 3, "date": "1618012073", "time_retrieved": "2024-07-30T19:27:34.611367", "image_code": "//\"Glass Eel\" by Kali\n\n#define lightcol1 vec3(1.,.5,.5)\n#define lightcol2 vec3(.5,.5,1.)\n\n\n\n//Distance Field\nfloat de(vec3 p) {\n\tp+=sin(p*10.+iTime*10.)*.012;\n\tfloat rot=p.z-iTime*3.;\n\tp.x+=sin(p.z-iTime*3.)*1.1+p.z*.5;\n\tp.y+=cos(p.z*.5-iTime*2.)*.8-1.5+p.z*.4;\n\tp.z-=5.;\n\tp.xy*=mat2(cos(rot),cos(rot),-sin(rot),cos(rot));\n\tfloat sc=max(1.,pow(abs(p.z),5.)*.000002);\n\tp*=sc;\n\tfloat d=((length(p.xy)-.3)-length(cos(p*20.))*.03-length(cos(p*10.))*.05);\n\td=min(max(-p.z,d),length(p*vec3(1.,1.,1.4))-.47);\n\treturn d*.5/sc;\n}\n\n// finite difference normal\nvec3 normal(vec3 pos) {\n\tvec3 e = vec3(0.0,0.002,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(pos+e.yxx)-de(pos-e.yxx),\n\t\t\tde(pos+e.xyx)-de(pos-e.xyx),\n\t\t\tde(pos+e.xxy)-de(pos-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime*.6; \n\n\t//camera\n\tvec2 uv = fragCoord.xy / iResolution.xy *2. - vec2(1.);\n\tvec2 coord=uv;\n\tcoord.y *= iResolution.y / iResolution.x;\n\tcoord.xy*=mat2(cos(time),sin(time),-sin(time),cos(time));\n\tfloat fov=.5;\n\tvec3 from = vec3(-3.,-1.,sin(time)*4.-1.);\n\n\t//vars\n\tfloat totdist=0.;\n\tfloat distfade=1.;\n\tfloat glassfade=1.;\n\tfloat intens=1.;\n\tfloat maxdist=30.;\n\tfloat vol=0.;\n\tvec3 spec=vec3(0.);\n\tvec3 dir=normalize(vec3(coord.xy*fov,1.)); \n\tfloat ref=0.;\n\tvec3 light1=normalize(vec3(sin(time),sin(time*2.)*.5,1.5));\n\tvec3 light2=normalize(vec3(sin(time+2.),sin((time+2.)*2.)*.5,1.5));\n\n\t//march\n\tfor (int r=0; r<120; r++) {\n\t\tvec3 p=from+totdist*dir;\n\t\tfloat d=de(p);\n\t\tfloat distfade=exp(-5.*pow(totdist/maxdist,1.2));\n\t\tintens=min(distfade,glassfade);\n\n\t   if (totdist<maxdist) {\n\n\t\t// refraction\n\t\tif (d>0.0 && ref>.5) {\n\t\t\tref=0.;\n\t\t\tvec3 n=normal(p);\n\t\t\tif (dot(dir,n)<-0.5) dir=normalize(refract(dir,n,1./.85));\n\t\t\tvec3 refl=reflect(dir,-n);\n\t\t\tspec+=lightcol1*pow(max(dot(refl,light1),0.0),40.);\n\t\t\tspec+=lightcol2*pow(max(dot(refl,light2),0.0),40.);\n\t\t\tspec*=intens;\n\t\t\tspec*=glassfade;\n\t\t}\n\t\tif (d<0.0 && ref<.5) {\n\t\t\tref=1.;\n\t\t\tvec3 n=normal(p);\n\t\t\tif (dot(dir,n)<0.) dir=normalize(refract(dir,n,.85));\n\t\t\tvec3 refl=reflect(dir,n);\n\t\t\tglassfade*=.6;\n\t\t\tspec+=lightcol1*pow(max(dot(refl,light1),0.0),50.);\n\t\t\tspec+=lightcol2*pow(max(dot(refl,light2),0.0),50.);\n\t\t\tspec+=pow(max(dot(refl,vec3(0.,0.,-1.)),0.0),50.)*3.;\n\t\t\t\n\t\t}\n\t\t\n\t\ttotdist+=max(0.001,abs(d)); //advance ray \n\t   }\n\t\tvol+=max(0.,.6-d)*intens; //glow\n\t}\n\t\n\tvol*=.025;\n\tvec3 col=vec3(vol*vol,vol*.9,vol*vol*vol)+vec3(spec)*.5+.13;\n\n\t//lights\n\tvec3 tcoor=vec3((dir.xy*(2.-sin(time)*.8))+sin(coord.xy*20.+iTime*10.)*.007,1.);\n\tvec3 li=vec3(0.15);\n\tcol+=2.*lightcol1*pow(max(0.,max(0.,dot(normalize(tcoor+vec3(0.15,.1,0.)),light1))),500.)*glassfade; \n\tcol+=2.*lightcol2*pow(max(0.,max(0.,dot(normalize(tcoor+vec3(0.15,.1,0.)),light2))),500.)*glassfade; \n\tli+=lightcol1*pow(max(0.,max(0.,dot(normalize(tcoor),light1))),40.)*glassfade; \n\tli+=lightcol2*pow(max(0.,max(0.,dot(normalize(tcoor),light2))),40.)*glassfade; \n\t//background\n\tcol+=li*.3+li*5.*pow(texture(iChannel0,tcoor.xy*vec2(.5+(1.+cos(time))*.5,1.)+time).x,1.7)*glassfade*vec3(.3,1.,.3)*max(0.,1.-length(coord));\n\t\n\tcol*=1.-pow(max(0.,max(abs(uv.x),abs(uv.y))-.8)/.2,10.); //borders\n\n\t//color adjust\t\n\tcol=pow(col,vec3(1.2,1.1,1.));\n\tcol*=vec3(1.,.8,1.);\n\n\tcol*=min(1.,time); //fade in\n\tfragColor = vec4(col,1.0);\t\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 109, 127, 127, 520], [522, 550, 573, 573, 738], [741, 741, 798, 798, 3262]], "test": "untested"}
{"id": "fdB3Dc", "name": "Crystal-!t#3", "author": "entropynine", "description": "AMAZINGLY g8t-ful for the shader by tdhooper https://www.shadertoy.com/view/4tc3WB", "tags": ["crystalizze"], "likes": 1, "viewed": 239, "published": 3, "date": "1618011427", "time_retrieved": "2024-07-30T19:27:35.579778", "image_code": "// --------------------------------------------------------\n// OPTIONS\n// --------------------------------------------------------\n\n// Disable to see more colour variety\n#define SEAMLESS_LOOP\n#define COLOUR_CYCLE\n\n#define PI 3.14159265359\n#define PHI (66.618033988749895)\n\nfloat t;\n\n#define saturate(x) clamp(x, 0., 1.)\n\n\n// --------------------------------------------------------\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n// --------------------------------------------------------\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n\n// --------------------------------------------------------\n// http://math.stackexchange.com/a/897677\n// --------------------------------------------------------\n\nmat3 orientMatrix(vec3 A, vec3 B) {\n    mat3 Fi = mat3(\n        A,\n        (B - dot(A, B) * A) / length(B - dot(A, B) * A),\n        cross(B, A)\n    );\n    mat3 G = mat3(\n        dot(A, B),              -length(cross(A, B)),   0,\n        length(cross(A, B)),    dot(A, B),              0,\n        0,                      0,                      1\n    );\n    return Fi * G * inverse(Fi);\n}\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector3b normalize(vec3(-1, -1, -1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector4b normalize(vec3(-1, -1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector5b normalize(vec3(1, -1, -1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n#define GDFVector6b normalize(vec3(-1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector7b normalize(vec3(0, 1, -PHI-1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector8b normalize(vec3(0, -1, -PHI-1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector9b normalize(vec3(PHI+1., 0, -1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector10b normalize(vec3(-PHI-1., 0, -1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector11b normalize(vec3(1, -PHI-1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n#define GDFVector12b normalize(vec3(-1, -PHI-1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector13b normalize(vec3(0, PHI, -1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector14b normalize(vec3(0, -PHI, -1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector15b normalize(vec3(1, 0, -PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector16b normalize(vec3(-1, 0, -PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector17b normalize(vec3(PHI, -1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n#define GDFVector18b normalize(vec3(-PHI, -1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b + a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = sin(a)*p + atan(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(sin(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat around an axis\nvoid pModPolar(inout vec3 p, vec3 axis, float repetitions, float offset) {\n    vec3 z = vec3(0,0,3);\n\tmat3 m = orientMatrix(axis, z);\n    p *= inverse(m);\n    pR(p.xy, offset);\n    pModPolar(p.xy, repetitions);\n    pR(p.xy, -offset);\n    p *= m;\n}\n\n\n// --------------------------------------------------------\n// knighty\n// https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\nint Type=5;\nvec3 nc;\nvec3 pbc;\nvec3 pca;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n\n}\n\nvoid pModIcosahedron(inout vec3 p) {\n    p = abs(p);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n}\n\nfloat indexSgn(float s) {\n\treturn s / 2. + 1.5;\n}\n\nbool boolSgn(float s) {\n\treturn bool(s / 2. + 0.5);\n}\n\nfloat pModIcosahedronIndexed(inout vec3 p, int subdivisions) {\n\tfloat x = indexSgn(sgn(p.x));\n\tfloat y = indexSgn(sgn(p.y));\n\tfloat z = indexSgn(sgn(p.z));\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n\n\tfloat xai = sgn(p.x);\n\tfloat yai = sgn(p.y);\n    p.xy = abs(p.xy);\n\tfloat sideBB = pReflect(p, nc, 0.);\n\n\tfloat ybi = sgn(p.y);\n\tfloat xbi = sgn(p.x);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    float idx = 0.;\n\n    float faceGroupAi = indexSgn(ybi * yai * -1.);\n    float faceGroupBi = indexSgn(yai);\n    float faceGroupCi = clamp((xai - ybi -1.), 0., 1.);\n    float faceGroupDi = clamp(1. - faceGroupAi - faceGroupBi - faceGroupCi, 0., 1.);\n\n    idx += faceGroupAi * (x + (2. * y) + (4. * z));\n    idx += faceGroupBi * (8. + y + (2. * z));\n    # ifndef SEAMLESS_LOOP\n    \tidx += faceGroupCi * (12. + x + (2. * z));\n    # endif\n    idx += faceGroupDi * (12. + x + (2. * y));\n\n\treturn idx;\n}\n\n\n// --------------------------------------------------------\n// IQ\n// https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// tdhooper\n// https://www.shadertoy.com/view/Mtc3RX\n// --------------------------------------------------------\n\nvec3 vMin(vec3 p, vec3 a, vec3 b, vec3 c) {\n    float la = length(p - a);\n    float lb = length(p - b);\n    float lc = length(p - c);\n    if (la < lb) {\n        if (la < lc) {\n            return a;\n        } else {\n            return c;\n        }\n    } else {\n        if (lb < lc) {\n            return b;\n        } else {\n            return c;\n        }\n    }\n}\n\n// Nearest icosahedron vertex\nvec3 icosahedronVertex(vec3 p) {\n    if (p.z > 0.) {\n        if (p.x > 0.) {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13, GDFVector15, GDFVector17);\n            } else {\n                return vMin(p, GDFVector14, GDFVector15, GDFVector17b);\n            }\n        } else {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13, GDFVector16, GDFVector18);\n            } else {\n                return vMin(p, GDFVector14, GDFVector16, GDFVector18b);\n            }\n        }\n    } else {\n        if (p.x > 0.) {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13b, GDFVector15b, GDFVector17);\n            } else {\n                return vMin(p, GDFVector14b, GDFVector15b, GDFVector17b);\n            }\n        } else {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13b, GDFVector16b, GDFVector18);\n            } else {\n                return vMin(p, GDFVector14b, GDFVector16b, GDFVector18b);\n            }\n        }\n    }\n}\n\n// Nearest vertex and distance.\n// Distance is roughly to the boundry between the nearest and next\n// nearest icosahedron vertices, ensuring there is always a smooth\n// join at the edges, and normalised from 0 to 1\nvec4 icosahedronAxisDistance(vec3 p) {\n    vec3 iv = icosahedronVertex(p);\n    vec3 originalIv = iv;\n\n    vec3 pn = normalize(p);\n    pModIcosahedron(pn);\n    pModIcosahedron(iv);\n\n    float boundryDist = dot(pn, vec3(1, 0, 0));\n    float boundryMax = dot(iv, vec3(1, 0, 0));\n    boundryDist /= boundryMax;\n\n    float roundDist = length(iv - pn);\n    float roundMax = length(iv - vec3(0, 0, 1.));\n    roundDist /= roundMax;\n    roundDist = -roundDist + 1.;\n\n    float blend = 1. - boundryDist;\n\tblend = pow(blend, 6.);\n    \n    float dist = mix(roundDist, boundryDist, blend);\n\n    return vec4(originalIv, dist);\n}\n\n// Twists p around the nearest icosahedron vertex\nvoid pTwistIcosahedron(inout vec3 p, float amount) {\n    vec4 a = icosahedronAxisDistance(p);\n    vec3 axis = a.xyz;\n    float dist = a.a;\n    mat3 m = rotationMatrix(axis, dist * amount);\n    p *= m;\n}\n\n\n// --------------------------------------------------------\n// MAIN\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 colour;\n    float id;\n};\n     \nModel fInflatedIcosahedron(vec3 p, vec3 axis) {\n    float d = 1000.;\n    \n    # ifdef SEAMLESS_LOOP\n    \t// Radially repeat along the rotation axis, so the\n    \t// colours repeat more frequently and we can use\n    \t// less frames for a seamless loop\n    \tpModPolar(p, axis, 3., PI/2.);\n\t# endif\n    \n    // Slightly inflated icosahedron\n    float idx = pModIcosahedronIndexed(p, 0);\n    d = min(d, dot(p, pca) - .9);\n    d = mix(d, length(p) - .9, .5);\n\n    // Colour each icosahedron face differently\n    # ifdef SEAMLESS_LOOP\n    \tif (idx == 3.) {\n    \t\tidx = 2.;\n    \t}\n    \tidx /= 10.;\n   \t# else\n    \tidx /= 20.;\n    # endif\n    # ifdef COLOUR_CYCLE\n    \tidx = mod(idx + t*1.75, 1.);\n    # endif\n    vec3 colour = spectrum(idx);\n    \n    d *= .6;\n\treturn Model(d, colour, 1.);\n}\n\nvoid pTwistIcosahedron(inout vec3 p, vec3 center, float amount) {\n    p += center;\n    pTwistIcosahedron(p, 5.5);\n    p -= center;\n}\n\nModel model(vec3 p) {\n    float rate = PI/6.;\n    vec3 axis = pca;\n\n    vec3 twistCenter = vec3(0);\n    twistCenter.x = cos(t * rate * -3.) * .3;\n\ttwistCenter.y = sin(t * rate * -3.) * .3;\n\n\tmat3 m = rotationMatrix(\n        reflect(axis, vec3(0,1,0)),\n        t * -rate\n   \t);\n    p *= m;\n    twistCenter *= m;\n\n    pTwistIcosahedron(p, twistCenter, 5.5);\n\n\treturn fInflatedIcosahedron(p, axis);\n}\n\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 30.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n//--------------------------------\n// Modelling\n//--------------------------------\nModel map( vec3 p ){\n    return model(p);\n}\n\n// LIGHTING\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).dist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB)\n{\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\nvec3 doLighting(vec3 col, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n\n    // lighitng        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, 0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    //float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    //float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n    \n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n    //dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20*dif*vec3(.95,0.80,0.60);\n    //lin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n    lin += 0.80*amb*vec3(0.50,0.70,.80)*occ;\n    //lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n    lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.20*fre*vec3(1.00,1.00,1.00)*occ;\n    col = col*lin;\n\n    return col;\n}\n\nstruct Hit {\n    float len;\n    vec3 colour;\n    float id;\n};\n\nHit calcIntersection( in vec3 ro, in vec3 rd ){\n\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n    vec3 colour;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n\n        if( abs(h) < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        Model m = map( ro+rd*t );\n        h = m.dist;\n        t += h;\n        id = m.id;\n        colour = m.colour;\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n\n    return Hit( res , colour , id );\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n\n    float x = mouse.x;\n    float y = mouse.y;\n    \n    x = .65;\n    y = .44;\n    \n    float dist = 3.3;\n    float height = 0.;\n    camPos = vec3(0,0,-dist);\n    vec3 axisY = vec3(0,1,0);\n    vec3 axisX = vec3(1,0,0);\n    mat3 m = rotationMatrix(axisY, -x * PI * 2.);\n    axisX *= m;\n    camPos *= m;\n    m = rotationMatrix(axisX, -(y -.5) * PI*2.);\n    camPos *= m;\n    camPos.y += height;\n    camTar = -camPos + vec3(.0001);\n    camTar.y += height;\n    camRoll = 0.;\n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\nvec2 ffragCoord;\n\nvec3 render( Hit hit , vec3 ro , vec3 rd ){\n\n    vec3 pos = ro + rd * hit.len;\n\n    vec3 color = vec3(.04,.045,.05);\n    color = vec3(.35, .5, .65);\n    vec3 colorB = vec3(.8, .8, .9);\n    \n    vec2 pp = (-iResolution.xy + 2.0*ffragCoord.xy)/iResolution.y;\n    \n    color = mix(colorB, color, length(pp)/1.5);\n\n\n    if (hit.id == 1.){\n        vec3 norm = calcNormal( pos );\n        vec3 ref = reflect(rd, norm);\n        color = doLighting(hit.colour, pos, norm, ref, rd);\n    }\n\n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initIcosahedron();\n    t = iTime - .25;\n    //t = mod(t, 4.);\n    \n    ffragCoord = fragCoord;\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n\n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n\n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    Hit hit = calcIntersection( camPos , rd  );\n\n\n    vec3 color = render( hit , camPos , rd );\n\tcolor = linearToScreen(color);\n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdB3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[512, 512, 557, 557, 1023], [1189, 1189, 1224, 1224, 1576], [4187, 4187, 4207, 4207, 4245], [4247, 4247, 4267, 4267, 4292], [4294, 4368, 4424, 4424, 4469], [4471, 4507, 4535, 4535, 4616], [4618, 4702, 4746, 4746, 4849], [4851, 4923, 4972, 4972, 5009], [5011, 5249, 5281, 5281, 5327], [5329, 5357, 5419, 5419, 5543], [5545, 5658, 5708, 5708, 6098], [6100, 6125, 6199, 6199, 6372], [6589, 6589, 6613, 6646, 7064], [7066, 7066, 7102, 7102, 7239], [7241, 7241, 7266, 7266, 7290], [7292, 7292, 7315, 7315, 7345], [7347, 7347, 7409, 7409, 8243], [8414, 8414, 8482, 8482, 8525], [8527, 8527, 8551, 8551, 8649], [8826, 8826, 8869, 8869, 9187], [9189, 9219, 9251, 9251, 10226], [10228, 10443, 10481, 10481, 11057], [11059, 11109, 11161, 11161, 11311], [11514, 11514, 11561, 11561, 12297], [12299, 12299, 12364, 12364, 12431], [12433, 12433, 12454, 12454, 12830], [13094, 13188, 13217, 13217, 13253], [13255, 13338, 13358, 13358, 13381], [13396, 13396, 13470, 13470, 13743], [13746, 13746, 13788, 13788, 14093], [14121, 14121, 14154, 14154, 14188], [14190, 14190, 14227, 14227, 14271], [14273, 14273, 14339, 14364, 15273], [15338, 15338, 15385, 15385, 15885], [15888, 15919, 15983, 15983, 16161], [16163, 16163, 16261, 16261, 16732], [16734, 16847, 16878, 16878, 17136], [17156, 17156, 17199, 17199, 17652], [17655, 17655, 17712, 17712, 18476]], "test": "untested"}
{"id": "Xlc3zB", "name": "Planet 7120 - second commit", "author": "patu", "description": "second commit for https://www.pouet.net/prod.php?which=68093 :)\n2016(?)\n\nfollow up for https://www.shadertoy.com/view/ldVXDm", "tags": ["demoscene"], "likes": 12, "viewed": 354, "published": 3, "date": "1618010560", "time_retrieved": "2024-07-30T19:27:36.775581", "image_code": "#define getNormal getNormalHex\n#define V vec3\n#define W vec2\n#define F float\n#define FAR 330.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n\n//#define FOG 1.\n\n#define PI 3.14159265\n//#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nF \n    Z = 0., \n    J = 1., \n\tvol = 0.,\n\tnoise = 0.;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),.0);\n}\n\n\nfloat B(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n\n#define fromRGB(a, b, c) vec3(F(a), F(b), F(c)) / 255.;\n    \nvec3 \n    light = vec3(0. ,0., 1.),\n\tlightDir;\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3) ); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 Rep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k ;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    float materialIndex;\n    float specular;\n    float diffuse;\n    vec3 color;  \n    float mirror;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 ){\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n               \n               return obj;\n}\n\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n\ngeometry map(vec3 p) {\n    //p.y += sin(t * 1.+ p.z / 10.) * 3. + sin(p.x / 3.);\n    vec3 bp = p;\n    vec3 fp = p;\n    vec3 op = p;\n    float localNoise = B(p / 15.) * 5.;\n    \n    \n    p.y -= localNoise;\n    \n    // ----------\n    geometry box;\n    \n    \n    bp.y += -23.;\n    bp.z += -10. - t * 20.;\n    \n    pR(bp.xz, t);\n    pR(bp.yx, t * 4.6);\n    \n    pModPolar(bp.xy, 3.);\n    pMirrorOctant(bp.xz, vec2(.3) + sin(t / 4.) / 2.);\n    bp.x *= 1.4;\n    \n    box.dist = fBox(bp, vec3(4., 9., 1.) * .6 + vol);\n    box.dist = mix(box.dist, fSphere(bp, 2. + localNoise * .4), 1. - min(vol + t * 0.01, 1.));\n    box.materialIndex = 4.;\n   // box.space = bp;\n    box.color = vec3(1.7) + sin(t * 14.);\n    box.diffuse = 2.;\n    box.specular = 4.;\n    box.mirror = .6;\n    \n    \n\t// ------------\n    geometry floor;\n\n    vec3 floorP = p;\n    \n    floorP.y += -5. - min(floorP.z * 0.005 , 5.) - sin(p.z * 0.01) * 3.;\n    floor.dist = fBox2Cheap(floorP.xy, vec2(128., 2.5)),\n    floor.materialIndex = 0.;\n    //floor.space = p;\n    floor.color = vec3(1., .8, .6);//* localNoise;\n    floor.diffuse = 8.;\n    floor.specular = 4.0;\n    floor.mirror = 0.;\n    \n    // ------------\n    geometry water;\n    \n    fp = op;\n    fp.y -= 11. ;//+ sin(localNoise * 0.3) * 0.2 + 0.1 * (sin(fp.z + localNoise) + sin(fp.x));\n    water.dist = fBox2Cheap(fp.xy, vec2(128., 3.)),\n    water.materialIndex = 5.;\n    //water.space = fp;\n    water.color = fromRGB(126, 165, 179);\n    water.diffuse = 2.;\n    water.specular = 17.;\n    water.mirror = 0.3;\n    \n    // ----------\n    geometry obj;\n    \n    p.xz -= 25.;\n    p.y += 140. - min(p.z / 4., 140.);\n    \n    vec2 pM = pMod2(p.xz, vec2(50.));\n    \n    pMirrorOctant(p.zy, \n                  vec2(\n                      1. * mod(pM.x, 14.), \n                      5. + ceil(13. * (sin(pM.x) * 3.+ 1.)) \n                  )\n                 );\n    pMirrorOctant(p.xz, vec2(13., 18. + mod(pM.y * 5., 16.)));\n    \n    pR(p.zy, 1.17 + p.x / 10. );\n\n    p.x += 2.5 ;\n    \n    pModPolar(p.xz, 12.5 - (sin(pM.x) * 10.+ (sin(1. / 3.) * 10.)));\n\t\n    pMirrorOctant(p.zy, vec2(8.4, 6.));\n    pMirrorOctant(p.xy, vec2(3.5, 5.));\n    \n    p.yx += 2.;\n    // \n    // \n    p.x += sin(p.z / 100.) * 40.;\n    \n    obj.dist = fBox2Cheap(p.xy, vec2(4.4, 2.5));\n    obj.color = vec3(0., 1., 0.);\n    //obj.space = p;\n    obj.color = vec3(1.);\n    obj.diffuse = 5.;\n    obj.specular = 0.2;\n    obj.mirror = 0.;\n    //p.z -= 3.;\n    \n    geometry obj2;\n    obj2.dist = fBox(p, vec3(6., 7.4, 1.3));\n    obj2.color = vec3(1., 0., 1.);\n    //obj2.space = p;\n    obj2.color = vec3(1.);\n    obj2.diffuse = 8.;\n    obj2.specular = 1.;\n    obj2.mirror = 0.;\n    obj2.dist = smin(obj.dist, obj2.dist, sin(p.z / 10.) / 3. + .5);\n    \n    floor.dist = smin(obj.dist, floor.dist, .45);\n    \n    p = op;\n    p.x -= 2.;\n\n    p = mod(p, 5.);// p.z = mod(p.z, 12.) - .1;//sin(p.z);\n    p.y -= 25.;\n    //;;p.z -= 100.;\n    geometry obj3;\n    obj3.dist = fBox(p, vec3(3., 7.4,1.3));\n    obj3.color = vec3(1., 0., 1.);\n    //obj3.space = p;\n    obj3.color = vec3(1.);\n    obj3.diffuse = 8.;\n    obj3.specular = 1.;\n    obj3.mirror = 0.;\n    \n    obj = geoU(obj, obj2);\n    obj = geoU(obj, obj3);\n    obj = geoU(obj, floor);\n    obj = geoU(obj, water);\n    obj = geoU(obj, box);\n    \n    \n    //-----\n    p = op;\n    p.y -= 5.;\n    p.xz = mod(p.xz, 40.) - 20.;\n    if (op.z > 1030.) {\n        p.x += p.z * 0.1;\n    pMirrorOctant(p.yz, vec2(12.5, 20.));\n    pModPolar(p.zx, 5.);\n\n    obj2.dist = fBox(p, vec3(1., 15., 6.));\n    obj2.mirror = .2;\n    obj2.color = vec3(1., 0., 1.);\n    \n    obj2.color += ceil(sin(mod(op.x / 3. + op.z / 2.- t * 4., 5.))) * 4.;\n    obj2.specular = 3.;\n    \n    obj = geoU(obj, obj2);\n    }\n    return obj;\n}\n\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 70;\n\ngeometry trace(vec3 o, vec3 d, int maxI) {\n\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1. / 250.;\n    float functionSign = map(o).dist < 0. ? -1. : +1.;\n    geometry mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        if (maxI > 0 && i > maxI) break; \n        mp = map(d * t + o);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 4.5;\n    float end = max(length(rd), .01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.6), 1.0);\n}\n\n\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist, e = .001;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(e,0,0)).dist-d,\n                map(pos+vec3(0,e,0)).dist-d,\n                map(pos+vec3(0,0,e)).dist-d \n        \t)\n    \t);\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    return clamp(map(hitp + normal * dist).dist / dist, .4, 1.);\n}\n\nvec3 clouds(vec3 rd, vec3 ro) {\n    vec2 uv = rd.xz / rd.y;\n   //ro.z /= 2.;\n    vec3 clouds = vec3(\n        B(\n            vec3(\n                uv + vec2(0., ro.z  * .01), 9.\n            )\n        ) * 1.6\n\n    );\n \tclouds = pow(clouds, vec3(2.)) + vec3(sin(uv.y) / 2. + .5, .5, 0.);\n    clouds.b += sin(ro.z * 0.01);\n    return clouds * max(0., rd.y);\n}\n\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir, vec3 ro)\n{\n   \n    float sunSize = 3.5;\n    float sunAmount = max(dot(rd, lightDir), 0.4);\n    float v = pow(1.2 - max(rd.y, 0.0), 1.1);\n    vec3 cl = vec3(0.);//fromRGB(0,136,254);\n    //cl.b *= sin(p.z * 0.3);\n    vec3 sky = mix(cl, vec3(.1, .2, .3) * 1., v);\n \n    sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 122.0)* sunSize, 0.2 * sunSize);\n    sky += vec3(3., 0., 0.) * rd.y;\n    return clamp(sky, 0.0, 1.0) + clouds(rd, ro);;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), obj.diffuse);\n    // Standard specualr term.\n    float spec = max(dot(reflect(-ld, sn), -rd), obj.specular / 2.);\n\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = obj.color;//getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    //sceneCol += ();// * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return objCol * (diff + .15) * spec * .1;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n    F \tmat = 0.,\n        camShY = 0.;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n   \n    if (abs(uv.y) > .35) {\n     \tfragColor *= 0.;\n        return;\n    }\n    \n    uv *= 4.;\n    \n    light = vec3(0., 77., 100.);        \n    \n    vec3 \n        vuv = vec3(cos(t) / 6., 1., sin(t) * .3 ), // up\n    \tro = vec3(-2. + sin(t),  22. + camShY, t * 20.);// + vec3(iMouse.x / 20.,iMouse.y / 10. - 1., 1.); // pos\n    \n    //ro.z += camShY;\n    vec3\n        vrp =  vec3(sin(t), + sin(t * 2.), +11.) + ro + \n        \tvec3(\n                -2., \n                -4. + sin(t) / 3., \n                0. + sin(t / 3.) / 4.), // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \trd = normalize(\n            vpn + uv.x * u * iResolution.x/iResolution.y + uv.y * cross(vpn, u)\n        ),\n        hit,\n        ord = rd;\n\t\n    vec3 sceneColor = vec3(0.);\n    \n    geometry tr = trace(ro, rd, 0);    \n    \n    //float fog = smoothstep(FAR * FOG, 0., tr.dist) * 1.;\n    hit = ro + rd * tr.dist;\n    \n    vec3 sn = getNormal(hit);\t\n    \n    float sh = softShadow(hit, hit + light, 3.);\n    \n    float \n        ao = getAO(hit, sn, .2);\n\t\n    ao *= saturate(getAO(hit + sn * .2, sn, .5));\n    ao *= saturate(getAO(hit + sn * 1., sn, 3.0));\n    \n\tvec3 sky = Sky(rd, true, normalize(light), ro) * 1.;\n    \n    if (tr.dist < FAR) { \n        sceneColor = (doColor(hit, rd, sn, light, tr) * 1.) * 1.;\n        sceneColor *= ao; \n        sceneColor *= sh;\n        sceneColor = mix(sceneColor, sky, saturate(tr.dist * 4. / FAR));\n        sceneColor = mix(sceneColor, lightColour, 0.1);        \n\n        if (tr.mirror > 0.) {   \n            float mirror = tr.mirror;\n            vec3 refSceneColor = sceneColor;\n            rd = reflect(rd, sn);// + sin(t));\n\n            tr = trace(hit + rd * .02, rd, 99);\n            if (tr.dist < FAR) {\n                hit = hit + rd * tr.dist;\n                sn = getNormal(hit);\n                refSceneColor = mix(sceneColor, abs(doColor(hit, rd, sn, light, tr)), mirror);                \n            } else {\n             \tsky = Sky(rd, true, normalize(light), ro);\n                refSceneColor = mix(refSceneColor, sky, mirror * 2.);\n               \n            }\n            \n            sceneColor = mix(sceneColor, refSceneColor, mirror);\n            \n        } else {\n            sceneColor = mix(sceneColor, sky, .0);  \n        }\n\n    } else {\n        sceneColor = sky;\n    }\n\n    if (t < 20.) {\n        float ot = min(t, 20.),den1 = 0., f, distC = 1.0;\n            \n        vec3 steamColor1 = vec3(1.4);\n\n        vec3 rro;\n        \n        ro.z /= 8.;\n\n        for (float i = 0.; i <= 10.; i++) {\n\n            rro = ro + ord * distC;// + steamColor2;\n\n            f = B(rro);\n            f *= 1.8;\n            den1 += pow(f, 2.) * .004 * (20. - ot) / 3.;\n\n\n            distC += .01;\n            if (distC > tr.dist) break;// ro += rd * distC;\n        }\n\n        sceneColor = mix(sceneColor, steamColor1,  clamp(den1, 0., 1.) * 2.); \n    \n    }\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 3.5), 0.0, 1.0), 1.0);\n    fragColor = pow(fragColor, vec4(1.2));    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlc3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 308, 330, 330, 410], [411, 411, 437, 437, 1057], [1060, 1060, 1077, 1077, 1249], [1414, 1414, 1437, 1437, 1466], [1467, 1467, 1490, 1490, 1519], [1520, 1520, 1545, 1545, 1574], [1576, 1576, 1604, 1604, 1633], [1635, 1732, 1805, 1805, 2091], [2095, 2095, 2136, 2136, 2208], [2210, 2210, 2242, 2242, 2284], [2286, 2286, 2320, 2320, 2365], [2367, 2367, 2398, 2398, 2447], [2587, 2587, 2628, 2628, 2683], [2685, 2685, 2715, 2715, 2767], [2769, 2769, 2800, 2800, 2847], [2849, 2889, 2909, 2909, 2934], [2936, 2936, 2956, 2956, 2991], [2993, 2993, 3013, 3013, 3058], [3060, 3099, 3119, 3119, 3144], [3146, 3146, 3164, 3164, 3214], [3217, 3361, 3401, 3401, 3522], [3525, 3553, 3590, 3590, 3681], [3682, 3795, 3845, 3845, 4235], [4237, 4329, 4372, 4372, 4422], [4424, 4424, 4470, 4470, 4578], [4579, 4615, 4643, 4643, 4724], [4726, 4783, 4817, 4817, 4843], [4845, 4845, 4878, 4878, 5034], [5037, 5037, 5069, 5069, 5094], [5097, 5097, 5119, 5177, 8822], [8897, 8897, 8939, 8939, 10127], [10130, 10130, 10175, 10175, 10749], [10752, 10752, 10781, 10781, 11017], [11019, 11019, 11068, 11068, 11135], [11137, 11137, 11168, 11168, 11492], [11495, 11495, 11555, 11555, 12017], [12019, 12019, 12096, 12096, 13059], [13064, 13064, 13119, 13119, 16272]], "test": "untested"}
{"id": "fdS3DK", "name": "Clock Shader", "author": "Pelegefen", "description": "Well it's a clock. and i'm still working on it!", "tags": ["clock", "wip"], "likes": 9, "viewed": 815, "published": 3, "date": "1617999938", "time_retrieved": "2024-07-30T19:27:37.557490", "image_code": "#define S smoothstep \n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define RES iResolution.xy\n\nvec3 ShapeN(vec2 st, int N, float w, float h){\n\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  st.x += 1.0 ;\n  st.y += .7;\n  st.y /= h;\n    st.x *= w;\n  // Number of sides of your shape\n  //int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulates the distance\n  d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  color = vec3(smoothstep(.41,.4,d));\n\n    return color;\n}\nvec2 polarMap(vec2 uv, float shift, float inner) {\n\n    uv = vec2(0.5) - uv;\n    \n    \n    float px = 1.0 - fract(atan(uv.y, uv.x) / 6.28 + 0.25) + shift;\n    float py = (length(uv) * (1.0 + inner * 2.0) - inner) * 2.0;\n    \n    return vec2(px, py);\n}\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\nfloat circle (vec2 p, float r, float g)\n{\n\n    float d = length(p / r);\n\n    float ss = S(.32,.32 - g,d);\n    \n    ss = max(0.,ss);\n    return ss;\n\n}\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, 0.7*r, d);\n}\nfloat segmentT(vec2 P, vec2 A, vec2 B, float r, float dr) \n{\n    vec2 g = B - A;\n    vec2 h = P - A ;\n    float d = length(h - g * clamp(dot(g , h ) / dot(g,g), 0.0, 1.0));\n    \n\n\treturn smoothstep(r, 0.7*r, d);\n}\n\n\n\nvec4 Hand(vec2 uv , float l, float w, float t)\n{\n    vec4 col = vec4(0.);\n    \n\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , \n    1. * RES.y/RES.x * w, .5);\n    \n    uv *= .35;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 5,/* Width*/6.,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n    \n    \n    //uv *= 2.;\n    vec4 Triangle = vec4(ShapeN(rot( uv * 3., -t* TAU/60.) , 5,/* Width*/9.,/* Height*/ l - .2),1.);\n    col += Triangle ;\n   \n    \n    \n    col.a = col.r;// at this point, each of the rgb vals is at 1. and showing the mask, so store it in the A channel.\n    \n    col = max (col,vec4(0.));\n    return col;\n}\n\nvec4 HandsShadow(vec2 uv , float l, float w, float t , float b)\n{\n    vec4 col = vec4(0.);\n    \n\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , \n      w, .5);\n    uv.y += .02;\n    uv *= .35;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 5,/* Width*/6. * w,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n    \n    \n    //uv *= 2.;\n    vec4 Triangle = vec4(ShapeN(rot( uv * 3., -t* TAU/60.) , 5,/* Width*/4. * w,/* Height*/ l - .2),1.);\n    col += Triangle ;\n    col = mix(Triangle, shape, .5);\n    \n    \n    col -= length(uv.y) * 2.; // attenuate based on height\n    \n    \n    \n    col = max (col,vec4(0.));\n    return col * .5;\n}\nvec4 Dial(vec2 uv, float m)\n{\n    \n    vec4 col = vec4(0.);\n    //uv.x = PolarCoord(uv);\n    \n    uv = polarMap(uv + .5, -.2486 , .25) * .5;\n    \n    uv.x = fract(uv.x * 24. * m ) ;\n    \n    \n    vec2 id = floor(uv * 24.  );\n    \n    float idF = (id.x / id.y);\n\n    col *= vec4(idF,idF,idF,1.)    ;\n    \n    col += circle(uv - vec2(0.,.5 ),1., .001 );\n    col += segment(uv / 60. * m ,vec2(0. ,0.0), vec2(6. ,2.),.01) * .5 ;\n    if(id.x <=  .5 && id.y <= 24.) return col = vec4(.35);\n    col += segment(uv,vec2(.0 ,0.9), vec2(.8 ,0.9),.1);\n    \n    \n    \n    float h = segment(uv,vec2(-.8 ,0.5),\n     vec2(.8 ,0.5),.2);\n    vec4 tx = texture(iChannel0,uv);\n    col +=  h; \n    col += col *  tx;\n    col = mix(col, tx, col) * .4;\n    \n    col = clamp(col,0.,1.);\n    return col;\n}\n\n\n//returns a working clock\nvec4 ClockFace(vec2 uv){\n\n    vec4 col = vec4(0.,0.,0.,1.);\n    \n    vec4 wt = texture(iChannel0,uv);// sample wood tex\n    float f = circle(uv,4.3, .001 );//clocks frame\n    float fm = 1. - (circle(uv,4.3, .025 ) );//clocks frame bevel\n    f -= fm;\n    col += f;\n    \n    //Decoration at 12 o'clock\n    col -= circle(uv + vec2(0.,-1.03),0.3, .001 ) * 0.3;\n    col += circle(uv + vec2(0.,-1.0),0.3, .5 );\n    col -= vec4(ShapeN(uv+vec2(0.,-.5) ,5  ,  5.15, 1.15 ),0.7) * .3;\n    col += circle(   uv + vec2(0.,-.8) ,0.1, .1 );\n    \n    \n    col = mix(col,wt,col - circle(uv,3.7, .001 ) * .9); // apply wood tex\n    \n    \n    col -= (circle(uv,3.6, .001 ) * .18) + (-uv.y * .2); //inset and shading\n    \n    // Shadow\n    float d = length(uv + vec2(0.,0.1 ))* 0.88;\n    float m = 1. - circle(uv,4.3,.0001);\n    m += circle(uv,3.7,.001);\n    m = 1. - m;\n    \n    col -=  smoothstep(0., pow(d,40.), m ) ;\n    \n    //col = vec4(m);\n     //add the dial and decoration\n    col -= Dial(uv/1.3, 1.);\n    col += Dial(uv , 1.5);\n    \n    \n    //---------- time is set here------------\n\n    vec4 iDate = iDate;\n    float mils = fract(iDate.w);\n\tfloat secs = mod( (iDate.w),        60.0 );\n\tfloat mins = mod( (iDate.w/60.0),   60.0 );\n\tfloat hors = mod( (iDate.w/3600.0), 24.0 );\n\n\n    vec4 ch1 = Hand(uv, 0.9,0.9, hors  * TAU * .8 );//hours hand\n    vec4 ch1m = Hand(uv, 0.6,0.1, hors  * TAU * .8 );//hours hand m\n    ch1 -= ch1m;\n    ch1 = clamp(ch1,0.,1.);\n    col -= ch1;\n    vec4 ch1s = HandsShadow(uv , 1.,.9, hors  * TAU * .8 , .5);\n    col -= ch1s;\n\n    vec4 ch2 = Hand(uv , 1.6,0.5, mins);//minutes hand\n    vec4 ch2m = Hand(uv, 1.3,0.1, mins);//minutes hand m\n    ch2 -= ch2m;\n    ch2 = clamp(ch2,0.,1.);\n    col -= ch2;\n    vec4 ch2s = HandsShadow(uv , 1.7,.7, mins , .5);\n    col -= ch2s;\n\n    vec4 ch3 = Hand(uv ,  2.0, .07 ,secs ); //secondes hand\n    vec4 ch3m = Hand(uv , 1.1, .05 ,secs ); //secondes hand m\n    ch3 -= ch3m;\n    \n\n    ch3 = clamp(ch3,0.,1.);\n    col -= ch3;\n    vec4 ch3s = HandsShadow(uv , 2.0,.8, secs , .5);\n    col -= ch3s;\n    \n    \n    vec4 tex1 = texture(iChannel0,(rot( uv * 2., -secs* TAU/60.)));\n    vec4 tex2 = texture(iChannel0,(rot( uv * 2., -mins* TAU/60.)));\n    vec4 tex3 = texture(iChannel0,(rot( uv * 2., -hors* TAU/60.)));// we also have to spin the texture per hand!\n  \n    col = mix (col, ch1 * tex3  , ch1) ;\n    col = mix (col,ch2 * tex2 ,ch2 ) ;\n    col = mix (col,ch3 * tex1 ,ch3 ) ;\n    \n    \n    //------------End of Time setting-----------------  \n    \n    float cc =  circle(uv,0.3, .001 ) ;//clocks hand cover\n    cc = ceil(cc);\n    \n    cc = max(cc,0.);\n    cc = min(cc,1.);\n    //col -= cc;\n    \n    col =  mix(cc * wt, col,1. -cc);\n    col += vec4(circle(uv,0.3, .2 ) * .3) *(fract( uv.y* 50. - .1)  ) ; // dot on the clock hand cover\n    \n    col -= circle(uv,3.7, .001 ) * .18;// glass cover\n    col += max((circle(uv,3.9, .05 ) * .3 * uv.y),0.);\n     m = 1. - circle(uv,4.3,.001);\n    col.a =  1.- m;\n    col = col - m;\n    col = max(vec4(0.),col);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    \n    \n    vec4 col = vec4(0.0);\n    \n    //-----BG--------\n    vec4 bg = texture(iChannel0,uv);\n    bg *= .2;\n    bg -= fract(uv.y * 5. ) * .1;\n    bg += fract(uv.y * 5. ) * .2;\n    \n    float m = bg.r;\n    bg += m;\n    col += bg;\n    //------end of BG-----\n     uv *= 3.;\n    \n     col -= max( 1. - length((uv + vec2(.0,.1))* .63), 0.) ;\n    vec4 cf = ClockFace(uv);\n    col = mix(col,cf,cf.a);\n    \n    \n\n  \n\n    \n     \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdS3DK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 151, 151, 612], [613, 613, 663, 663, 864], [865, 865, 892, 892, 967], [968, 968, 1009, 1009, 1117], [1118, 1118, 1167, 1167, 1311], [1312, 1312, 1372, 1372, 1525], [1529, 1529, 1577, 1577, 2210], [2212, 2212, 2277, 2277, 2901], [2902, 2902, 2931, 2931, 3681], [3684, 3710, 3734, 3734, 6737], [6739, 6739, 6796, 6846, 7383]], "test": "untested"}
{"id": "NdjGDV", "name": "Spacemandel2", "author": "Chaotnix", "description": "playing around with mandelcube and soundcloud,\nThis shader is based on Dark Mandelbox by thiagoborn https://www.shadertoy.com/view/tsBGWw ", "tags": ["fractal", "mandelbox", "audioreactive", "soundcloud"], "likes": 2, "viewed": 261, "published": 3, "date": "1617988509", "time_retrieved": "2024-07-30T19:27:38.329426", "image_code": "\n#define ITERS 6\n\nfloat SCALE=2.0;\nfloat MR2=0.0;\n\nfloat mandelbox(vec3 position){\n  vec4 scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;\n  float C1 = abs(SCALE + 7.0), C2 = pow(abs(SCALE), float(1-ITERS));\n  vec4 p = vec4(position.xyz, 1.0) -0.3  + 0.4 * pow(texture(iChannel0, vec2(length(position.xyz), 0.26) ).x, 0.2), p0 = vec4(position.xyz, 1.0) +0.3 - 0.3 * pow(texture(iChannel0, vec2(length(position.xyz), 0.26) ).x, 0.2);  // p.w is knighty's DEfactor\n  for (int i=0; i<ITERS; i++) {\n    //p.xyz = p.xyz * vec3(0.2),p.y,smoothstep(.04,0.06, 0.01 * pow(texture(iChannel0, vec2(length(p.yz), 0.) ).x/3., 0.01)*4.);\n    p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3\n    float r2 = dot(p.xyz, p.xyz);  // dp3\n    p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4\n    p.xyzw = p*scalevec + p0/6.;  // mad4\n//    p0 = p0 - smoothstep(p.x,p.x*0.2,pow(texture(iChannel0, vec2(length(p.xy), 0.) ).x*8., 0.01)*2.);\n}\n  return (length(p.xyz) - C1) / p.w - C2;\n}\n\nfloat color(vec3 p){\n    vec3 op = p;\n    for (int i=0; i<ITERS; i++) {\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3\n        float r2 = dot(p.xyz, p.xyz);  // dp3\n        p.xyz *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4\n        p.xyz = p*SCALE/MR2 + op;  // mad4\n//        p.xyz = p - mix(vec3(0.1),p,smoothstep(.04,0.06, 0.01 * pow(texture(iChannel0, vec2(length(p.xy), 0.) ).x/3., 0.01)*4.));\n    }\n  \treturn length(p/2.);\n}\n\nfloat trace(vec3 o,vec3 d){\n    float v=0.2;\n    for(int i=0;i<34;i++){\n        vec3 p=o+d*v;\n        p=p + 1.;// + 0.2 * texture(iChannel0, vec2(length(p.xy), 1.) ).x;\n        float mv=mandelbox(p);        \n        if(mv<0.01){\n            return v;\n        }\n        v+=mv *.9;\n    }\n    return 0.;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*4.-1.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 3.0;\n   //SCALE = 2.5 + iMouse.x * 2.0;\n   // MR2 = iMouse.x * iMouse.x;\n    //SCALE = 2.9 + sin(iTime*10.0)*.0;\n    SCALE = 2.5;\n    float mr = 0.7;\n    MR2 = mr * mr - 0.1* pow(texture(iChannel0, vec2(length(uv.y),.8) ).x, 0.005);\n    \n      \n    vec3 lookingTo = vec3(3.,2.,4.);\n    float it = iTime / 5.;\n    vec3 viewer = vec3(\n        sin(iTime*.1) * 6.0,\n        cos(iTime*.17) * 5.0,\n        cos(iTime*.1) * 6.0\n    );\n    \n    vec3 forward = normalize(lookingTo-viewer);\n    vec3 rigth = cross(vec3(1.0,1.0,0.0),forward);\n    vec3 up = cross(forward,rigth);\n    \n    vec3 direction = normalize(forward/0.1 * pow(texture(iChannel0, vec2(length(uv.y),.8) ).x, 0.005) + rigth * uv.x + up * uv.y);\n    \n    float dist = trace(viewer,direction);\n    vec3 col=vec3(0.0);\n    if(dist <=0.) {\n    //    dist=dist + 2. * texture(iChannel0, vec2(length(dist),0.005) ).x;\n\t\tdist = 1. - dist + 2. * texture(iChannel0, vec2(length(dist),0.005) ).x;\t\n    };    \n     vec3 p = viewer + direction * dist ;\n    \n    \n    if(dist!=0.) {\n        \n         float c = color(p);\n        \n   \t\t col = pal(c/50.0, \n                   vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.7),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20)\n                   //vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25)\n                   //vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25)\n                  );\n\n        //col = vec3(1.0);\n    };\n\n    \n   \n   \n    float fog = .8 + .05 * texture(iChannel0, vec2(length(p),.3) ).x;\n    fragColor.rgb = vec3(col * fog);\n}", "image_inputs": [{"id": 26575, "src": "https://soundcloud.com/neelix/hello", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 82, 82, 1033], [1035, 1035, 1055, 1055, 1535], [1537, 1537, 1564, 1564, 1839], [1841, 1841, 1909, 1909, 1952], [1959, 1959, 2016, 2016, 3678]], "test": "untested"}
{"id": "Ns23WV", "name": " - Mineraball", "author": "totetmatt", "description": "Big up to evvvvil and flopine, a lot of hour learning on their stream <3\n\nOh yeah, PEGI 18:  zero optimization, dirty code and yolo implementation", "tags": ["3d", "ball", "mineral"], "likes": 2, "viewed": 244, "published": 3, "date": "1617983896", "time_retrieved": "2024-07-30T19:27:39.097374", "image_code": "#define fGlobalTime iTime\nfloat box(vec3 p, vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,vec3(.0)));\n  }\n mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat sdf(vec3 p){    \n  \n  p.xz *=rot(cos(fGlobalTime*.3)*3.1415*.5);\n  p.yz *=rot(sin(fGlobalTime)*.2);\n  vec3 op = p;\n\n\n  float q = 10000.;\n  for(float i = 0.;i<=4.;i++){\n    p.xy = abs(p.xy)-vec2(.5*(1.-i/5.),.3*(1.-i/5.));\n  \n    p.xz = p.x < p.z ? p.xz :p.zx;\n    p.yz = p.y < p.z ? p.yz :p.zy;\n    p.xy *= p.x < p.y ? rot(fGlobalTime*.0-1.66) : rot(1.166*i*.1); \n      p.xy *= 1.5+(i*.2);\n    p.xz *= p.x < p.y ? rot(-1.66) : rot(1.166*i*.1); \n  \n    \n    float h = box(p,vec3(.8));\n    float t = length(p)-1.;\n    if(mod(i,2.)==0.){\n    q = min(q,mix(t,h,.5+i*.1)/10.);\n    } else { q = max(q,-mix(t,h,.5)/10.);\n    }\n  }\n  float z = length(op)-.85432508097;\n  float zz = abs(box(abs(op)-.8,vec3(.351)))-.09;\n  float vv = max(z,-zz);\n  \n  float trans = smoothstep(0.1,0.5,sin(fGlobalTime + atan(op.z,op.y) )*.5+.5)*1.01;\n  q = mix(vv,q*2.,max(0.3,.85*trans))/.8;\n  \n  return q;\n  }\n vec2 nv= vec2(.00001,0.);\n  vec3 norm(vec3 p){\n      float d = sdf(p);\n      //return  normalize(vec3(sdf(p+nv.xyy)-sdf(p-nv.xyy),sdf(p+nv.yxy)-sdf(p-nv.yxy),sdf(p+nv.yyx)-sdf(p-nv.yyx)));\n      return normalize(vec3(d-sdf(p-nv.xyy),d-sdf(p-nv.yxy),d-sdf(p-nv.yyx)));\n    }\nvec2 raym(vec3 ro,vec3 rd,int stp, inout  vec3 rp){\n\n      float td = 0.;\n  for(int i=0;i<=stp;i++){\n         float d = sdf(rp);\n         if(d <= 0.00001) return vec2(td,1.);\n         td += d;\n         \n         rp = ro + rd*td;\n         \n    }\n    return vec2(td,0.);\n    \n  }\n  \n  vec3 pal(float t){\n    return .5+.5*cos(2.*3.141592*(1.*t+vec3(.0,.3,.7)));\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 puv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n\nvec3 ro=vec3(0.,0.,-4.),rd=vec3(uv,1.),rp=ro;\n  \tvec3 col = vec3(.1);\n  \n  vec2 td = raym(ro,rd,69*2,rp);\n  vec3 n = norm(rp);\nvec3 light = vec3(1.,1.,-5.5);\n  if(td.y == 1.){\n        float lamb =max(0.,dot(normalize(light),n));\n       float spec = 0.0;\n        float ld= pow(length(light - rp),2.);\n        if(lamb > 0.){\n         \n            vec3 viewDir = normalize(rp);\n            // BlinPhong\n            vec3 halfDir = normalize(light+viewDir);\n            float specAngle = max(dot(halfDir,n),0.);\n            spec = pow(specAngle,16.);\n        }\n    \n        col = col\n        + vec3(.1,.3,.5)* lamb *vec3(1.,.7,1.)* 20. / (ld)\n        + vec3(1.) * spec  *  pal(td.x+.5+length(rp*.09))* 20. / (ld)\n        ;\n         col*=col;\n        //col = pow(col, vec3(1.0 / 2.2)); \n    }\n    \n     \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 52, 52, 115], [117, 117, 135, 135, 182], [183, 183, 201, 201, 1072], [1102, 1102, 1120, 1120, 1347], [1348, 1348, 1399, 1399, 1625], [1631, 1631, 1649, 1649, 1712], [1713, 1713, 1770, 1820, 2832]], "test": "untested"}
{"id": "NdjGDK", "name": "The Decepticons", "author": "mrange", "description": "License CC0: The Decepticons\nFelt like creating a distance field for the decepticons logo\nThe distance field isn't perfect but the result came out kind of nice anyway", "tags": ["2d", "decepticons"], "likes": 8, "viewed": 411, "published": 3, "date": "1617978244", "time_retrieved": "2024-07-30T19:27:39.862328", "image_code": "// License CC0: The Decepticons\n//  Felt like creating a distance field for the decepticons logo\n//  The distance field isn't perfect but the result came out kind of nice anyway\n\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define TTIME           (TAU*TIME)\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define L2(x)           dot(x, x)\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat isosceles(vec2 p, vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat plane(vec2 p, vec3 plane) {\n  return dot(p, plane.xy) + plane.z;\n}\n\nvec2 refl(vec2 p, vec2 n) {\n  p -= n*min(0.0, dot(p, n))*2.0;\n  return p;\n}\n\nvec2 irefl(vec2 p, vec2 n) {\n  p -= n*max(0.0, dot(p, n))*2.0;\n  return p;\n}\n\nvec2 decepticon(vec2 p) {\n  p.x = abs(p.x);\n  \n  vec2 p0 = p;\n  p0 -= vec2(0.77, -0.68);\n  p0 = irefl(p0, normalize(vec2(1.0, 1.275)));\n  float d0 = plane(p0, vec3(normalize(vec2(-1., 2.375)), 0.0));\n\n  vec2 p1 = p;\n  p1 -= vec2(0.8, 0.68);\n  p1 = irefl(p1, normalize(vec2(1.4, 1.0)));\n  float d1 = plane(p1, vec3(normalize(vec2(-1., 2.9)), 0.0));\n\n\n  vec2 p2 = p;\n  p2 -= vec2(0.7, 0.085);\n  p2 *= ROT(2.11);\n  float d2 = isosceles(p2, vec2(0.125, 0.65));\n\n  vec2 p3 = p;\n  float d3 = plane(p3, vec3(normalize(vec2(-1.29, 1.0)), 0.635));\n  d3 = abs(d3)- 0.029;\n\n  vec2 p4 = p;\n  p4 -= vec2(0.225, 0.115);\n  p4 = refl(p4, normalize(vec2(1.0, 1.72)));\n  float d4 = plane(p4, vec3(normalize(vec2(-5.0, 1.0)), 0.0));\n  float d4_ = d4;\n  d4 = abs(d4)- 0.025;\n\n  vec2 p5 = p;\n  p5 -= vec2(0.0, 0.0395);\n  float d5 = plane(p5, vec3(normalize(vec2(-1.0, 2.8)), 0.0));\n  d5 = abs(d5) - 0.025;\n  d5 = max(d5, d4_);\n\n  vec2 p6 = p;\n  p6 -= vec2(0.0, 0.196);\n  float d6 = plane(p6, vec3(normalize(vec2(-1.0, 2.8)), 0.0));\n  d6 = abs(d6) - 0.025;\n  d6 = max(d6, d4_);\n\n  vec2 p7 = p;\n  p7 -= vec2(0.61, 0.0);\n  float d7 = plane(p7, vec3(normalize(vec2(-3.7, 1.0)), 0.0));\n  d5 = max(d5, -d7);\n  d6 = max(d6, -d7);\n\n  vec2 p8 = p;\n  p8 -= vec2(0.085, 0.585);\n  p8 = irefl(p8, normalize(vec2(2.075, 1.0)));\n  float d8 = -plane(p8, vec3(normalize(vec2(0.0, 1.0)), 0.0));\n\n  vec2 p9 = p;\n  p9 -= vec2(0.00, 0.155);\n  float d9 = isosceles(p9, vec2(0.085, 0.29));\n\n  float d = -d0; \n  d = max(d, d1);\n  d = min(d, -d4_);\n  d = max(d, -d2);\n  d = max(d, -d3);\n  d = max(d, -d4);\n  d = max(d, -d5);\n  d = max(d, -d6);\n  d = max(d, -d8);\n  d = max(d, -d9);\n  return vec2(d0, d);\n}\n\nfloat df(vec2 p) {\n  const float z = 0.9;\n  vec2 d0 = decepticon(p/z);\n  return -d0.y*z;\n}\n\nfloat hf(vec2 p) {\n  float d = df(p);\n  float height = 0.5*(smoothstep(-0.05, 0.01, d));\n  return pmax(height, 0.5, 0.125);\n}\n\nfloat height(vec2 p) {\n  return tanh_approx(hf(p));\n}\n\nvec3 normal(vec2 p) {\n  vec2 eps = vec2(4.0/RESOLUTION.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy) - height(p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx) - height(p + eps.yx);\n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  const vec3 up  = vec3(0.0, 1.0, 0.0);\n  const vec3 lp1 = 1.0*vec3(1.0, 1.25, 1.0);\n  const vec3 lp2 = 1.0*vec3(-1.0, 2.5, 1.0);\n\n  float aa = 2.0/RESOLUTION.y;\n\n  float hh = PSIN(sqrt(0.5)*TTIME/60.0);\n  float l  = length(p);\n  \n  float d  = df(p);\n  float h  = height(p);\n  vec3  n  = normal(p);\n\n  vec3 ro = vec3(0.0, mix(1.0, 10.0, PSIN(TTIME/30.0)), 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(po - ro);\n\n  // Lots of random choices below from an old shader of mine\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n\n  vec3 hsv = vec3(hh+mix(0.6, 0.9, PSIN(TIME*0.1-10.0*l+(p.x+p.y))), tanh_approx(h*h*1.0), tanh_approx(1.0*h+.1));\n  hsv.yz = clamp(hsv.yz, 0.0, 1.0);\n  vec3 baseCol1 = hsv2rgb(hsv);\n  vec3 baseCol2 = sqrt(baseCol1.zyx);\n  vec3 matCol   = 1.0-baseCol1*baseCol2;\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  baseCol1 *= mix(0.0, 4.0, 1.0/L2(lp1 - po));\n  baseCol2 *= mix(0.0, 3.0, 1.0/L2(lp2 - po));\n\n  vec3 col = vec3(0.0);\n  const float basePow = 1.25;\n  col += 1.00*matCol*baseCol1*mix(0.1, 1.0, pow(diff1, 4.0))*0.5;\n  col += 0.50*matCol*baseCol2*mix(0.1, 1.0, pow(diff2, 2.0))*0.5;\n  col = pow(col, vec3(1.25));\n  col += 4.0*baseCol1*pow(ref1, 20.0);\n  col += 2.0*baseCol2*pow(ref2, 10.0);\n\n  float gd = d;\n  const float glow_lw = 0.025;\n  gd = abs(gd)-glow_lw*2.0;\n  gd = abs(gd)-glow_lw;\n  vec3 glowCol = vec3(1.0);\n  glowCol = mix(baseCol1, glowCol, max(dot(ld1, up), 0.0));\n  glowCol = mix(baseCol2, glowCol, max(dot(ld2, up), 0.0));\n  vec3 finalGlowCol = glowCol*exp(-20.0*max(gd, 0.0));\n  finalGlowCol = mix(finalGlowCol, glowCol, smoothstep(-aa, aa, -d+glow_lw));\n  \n  float tuneOut = sqrt(q.x+(1.0-q.y))*0.85;\n  col = clamp(col, 0.0, 1.0);\n  col = mix(col, vec3(0.0), smoothstep(-aa, aa, -d));\n\n  col -= 0.5*0.125*tuneOut*finalGlowCol;\n  \n  col += vec3(0.125*0.75*((1.0-q.x)+q.y), 0.0, 0.0)*length(p);\n  p.x = abs(p.x);\n  col += smoothstep(10.0, 29.0, TIME)*vec3(mix(0.125, 0.5, PSIN(TTIME/10.0)), 0.0, 0.0)*exp(-9.0*(length(p-vec2(0.25, -0.15))));\n\n  vec3 dcol = mix(vec3(0.0), vec3(0.75), smoothstep(-aa, aa, d));\n  col = mix(dcol, col, smoothstep(5.0, 10.0, TIME));\n\n  col = postProcess(col, q);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = vec3(0.0);\n  col = effect(p, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 26573, "src": "https://soundcloud.com/gmm/ugress-decepticons", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjGDK.jpg", "access": "api", "license": "cc0-1.0", "functions": [[487, 566, 588, 588, 757], [759, 759, 787, 807, 883], [885, 925, 964, 964, 1057], [1059, 1059, 1098, 1098, 1127], [1129, 1129, 1159, 1159, 1186], [1188, 1239, 1272, 1272, 1580], [1582, 1582, 1615, 1615, 1654], [1656, 1656, 1683, 1683, 1731], [1733, 1733, 1761, 1761, 1809], [1811, 1811, 1836, 1836, 3470], [3472, 3472, 3490, 3490, 3562], [3564, 3564, 3582, 3582, 3689], [3691, 3691, 3713, 3713, 3744], [3746, 3746, 3767, 3767, 3970], [3972, 3972, 4009, 4009, 4262], [4264, 4264, 4293, 4293, 6666], [6668, 6668, 6723, 6723, 6931]], "test": "untested"}
{"id": "7sS3DV", "name": "Fractal 52_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 10, "viewed": 287, "published": 3, "date": "1617974363", "time_retrieved": "2024-07-30T19:27:40.708067", "image_code": "#define PI 3.1415\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    ;\n    for(float i=0.,s,e=1.,g=0.;\n        e>.001&&++i<70.;\n        O.rgb+=mix(vec3(1),H(length(p)*.3),.8)*.02*exp(-.01*i*i*e)\n    )\n    {\n        p=g*d-vec3(0,0,1);\n        p.y-=p.z*.6;\n        p.xz=asin(sin((p.xz+iTime*.3)*PI/2.))/PI*2.;\n        s=2.;\n        for(int i=0;i<6;i++)\n            p.xz=abs(p.xz-vec2(1,2))-1.1,\n            s*=e=2.2/clamp(dot(p.xz,p.xz),.2,3.5),\n            p.xz=p.xz*e-.6;\n        vec2 q=vec2(abs(p.z/s),p.y);\n        g+=e=.5*min(p.y,length(q-min(q,vec2(.001,.08))));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sS3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 101, 101, 694]], "test": "untested"}
{"id": "sdBGWK", "name": "Quad - closest 3D", "author": "iq", "description": "Closest point on quad. The blue sphere is the evaluation point. The orange sphere marks the point in the quad closest to the blue sphere.", "tags": ["3d", "quad", "closest"], "likes": 19, "viewed": 596, "published": 3, "date": "1617957663", "time_retrieved": "2024-07-30T19:27:41.584723", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Closest point on quad. The blue sphere is the evaluation\n// point.The orange sphere marks the point on the quad\n// closest to the blue sphere. Related shaders:\n\n// Closest points to other primitives in this list:\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n#if HW_PERFORMANCE==0\n#define AA 2\n#else\n#define AA 5\n#endif\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec3 closestQuad( in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v10 = v1 - v0; vec3 p0 = p - v0;\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v03 = v0 - v3; vec3 p3 = p - v3;\n\n    vec3 nor = cross( v10, v03 );\n\n    if( dot(cross(v10,nor),p0)<0.0 ) return v0 + v10*clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 );\n    if( dot(cross(v21,nor),p1)<0.0 ) return v1 + v21*clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 );\n    if( dot(cross(v32,nor),p2)<0.0 ) return v2 + v32*clamp( dot(p2,v32)/dot2(v32), 0.0, 1.0 );\n    if( dot(cross(v03,nor),p3)<0.0 ) return v3 + v03*clamp( dot(p3,v03)/dot2(v03), 0.0, 1.0 );\n    \n    return p - nor*dot(nor,p-v0)/dot2(nor);\n}\n\n//==================================================================\n\n// https://www.shadertoy.com/view/MlGcDz\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return t;\n}\n\n// https://www.shadertoy.com/view/4lcSRn\nfloat iCylinder( in vec3 ro, in vec3 rd, \n                 in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return t;\n    \n    return -1.0;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in float h )\n{\n    return (h-ro.y)/rd.y;\n}\n\nvec3 nPlane( void )\n{\n    return vec3(0.0,1.0,0.0);\n}\n\nvec3 nTriangle( in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    return normalize( cross( v1v0, v2v0 ) );\n}\n\nvec3 nCylinder( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\nvec3 nSphere( in vec3 pos, in vec4 sph )\n{\n    return (pos-sph.xyz)/sph.w;\n}\n\n// https://www.shadertoy.com/view/3tBBW3\nfloat oQuad( in vec3 pos, in vec3 nor, \n                     in vec3 v0, in vec3 v1,\n                     in vec3 v2, in vec3 v3 ) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    float k02 = dot( nor, normalize( cross(v3,v0)) ) * acos( dot(v0,v3) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * acos( dot(v3,v2) );\n    float k31 = dot( nor, normalize( cross(v1,v2)) ) * acos( dot(v2,v1) );\n    float k10 = dot( nor, normalize( cross(v0,v1)) ) * acos( dot(v1,v0) );\n    \n    return abs(k02+k23+k31+k10)/6.283185;\n}\n\n// https://www.shadertoy.com/view/4djSDy\nfloat oSphere( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  di = sph.xyz - pos;\n    float l  = length(di);\n    float nl = dot(nor,di/l);\n    float h  = l/sph.w;\n    float h2 = h*h;\n    float k2 = 1.0 - h2*nl*nl;\n\n    float res = max(0.0,nl)/h2;\n    if( k2 > 0.0 ) \n        res = pow( clamp(0.5*(nl*h+1.0)/h2,0.0,1.0), 1.5 );\n\n    return res;\n}\n\n//=====================================================\n\nstruct Scene\n{\n    vec3 v1;\n\tvec3 v2;\n\tvec3 v3;\n    vec3 v4;\n    vec3 pA;\n    vec3 pB;\n};\n    \nvec2 intersect( in vec3 ro, in vec3 rd, in Scene scn )\n{\n    vec2 res = vec2(1e10,-1.0);\n    \n    float t = iPlane(ro,rd,-1.5);\n    if( t>0.0 ) res = vec2( t, 1.0 );\n    \n    t = iTriangle( ro, rd, scn.v1, scn.v2, scn.v4 );\n    if( t>0.0 && t<res.x ) res = vec2( t, 2.0 );\n\n    t = iTriangle( ro, rd, scn.v3, scn.v4, scn.v2 );\n    if( t>0.0 && t<res.x ) res = vec2( t, 2.0 );\n    \n    t = iSphere( ro, rd, vec4(scn.pA,0.07) );\n    if( t>0.0 && t<res.x ) res = vec2( t, 3.0 );\n    \n    t = iSphere( ro, rd, vec4(scn.pB,0.07) );\n    if( t>0.0 && t<res.x ) res = vec2( t, 4.0 );\n                \n\tt = iCylinder( ro, rd, scn.pA, scn.pB, 0.02 );\n    if( t>0.0 && t<res.x ) res = vec2( t, 5.0 );\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float objID, in Scene scn )\n{\n    if( objID<1.5 ) return nPlane();\n    if( objID<2.5 ) return nTriangle( scn.v1, scn.v2, scn.v4 );\n    if( objID<3.5 ) return nSphere( pos, vec4(scn.pA,0.07) );\n    if( objID<4.5 ) return nSphere( pos, vec4(scn.pB,0.07) );\n    if( objID<5.5 ) return nCylinder( pos, scn.pA, scn.pB, 0.02 );\n    return vec3(0.0,1.0,0.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float objID, in Scene scn )\n{\n    float occ = 1.0;\n\n    occ *= clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    occ *= 1.0-oSphere( pos, nor, vec4(scn.pA,0.07) );\n    occ *= 1.0-oSphere( pos, nor, vec4(scn.pB,0.07) );\n\n    if( objID<1.5 ) occ *= 1.0-oQuad( pos, nor, scn.v1, scn.v2, scn.v3, scn.v4 );\n    \n    return occ;\n}\n\nconst vec3 lig = normalize(vec3(1.0,0.9,0.7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0.0);\n#if AA>1\n\t#define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // 2 pixel wide triangular kernel\n        vec2 o = 2.0*vec2(float(m),float(n)) / float(AA-1) - 1.0;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float t = iTime - 0.5*(1.0/60.0)*float(m*AA+n)/float(AA*AA-1);\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float t = iTime;\n#endif\n\n        // animate objects\n        Scene scn;\n        vec3 w = sin(0.2*t*vec3(1.0,1.1,1.2) + vec3(0.0,2.0,4.0) );\n        w /= (w.x+w.y+w.z);\n        scn.v1 = 1.5*vec3(1.0,0.4,1.0)*cos( 0.11*t + vec3(0.0,1.0,1.0) + 0.0 );\n        scn.v2 = 1.5*vec3(1.0,0.4,1.0)*cos( 0.12*t + vec3(0.0,2.0,3.0) + 2.0 );\n        scn.v3 = 1.5*vec3(1.0,0.4,1.0)*cos( 0.13*t + vec3(0.0,3.0,5.0) + 3.0 );\n        scn.v4 = scn.v1 + (scn.v3 - scn.v2)*(0.55+0.45*sin( 0.37*t + 4.0 ));\n        \n        if( dot( cross( scn.v2-scn.v1, scn.v4-scn.v1 ), \n                 cross( scn.v4-scn.v3, scn.v2-scn.v3 )) < 0.0 )\n        {\n            vec3 tmp = scn.v3;\n            scn.v3 = scn.v2;\n            scn.v2 = tmp;\n        }\n    \n        // compute closest point in quad\n        scn.pA = vec3(cos(1.5*t+1.0),0.8+0.4*cos(t*1.1),cos(1.4*t+3.0));\n        scn.pB = closestQuad( scn.v1, scn.v2, scn.v3, scn.v4, scn.pA );\n\n        // render\n        \n        vec3 ro = vec3(0.0, 0.7, 3.5 );\n        vec3 rd = normalize( vec3(p,-2.0) );\n        rd.yz = (mat2(24,-7,7,24)/25.0)*rd.yz;\n\n        vec3 col = vec3(0.0);\n\n        vec2 tm = intersect( ro, rd, scn );\n        if( tm.y>0.0 )\n        {\n            float t = tm.x;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, tm.y, scn);\n            nor *= -sign(dot(nor,rd));\n            float occ = calcOcclusion( pos, nor, tm.y, scn );\n            col += vec3(1.4)*occ;\n            \n            vec3 mate = .55+0.45*cos(tm.y*3.5+vec3(0.0,1.0,1.5));\n            \n            // show distance isolines\n            if( abs(tm.y-2.0)<0.5 )\n            {\n                float dref = length(scn.pA-closestQuad( scn.v1, scn.v2, scn.v3, scn.v4, scn.pA ));\n                float dsam = length(pos-scn.pA);\n                mate += 0.2*smoothstep(0.8,0.9,sin((dsam-dref)*75.0))*exp2(-15.0*(dsam-dref)*(dsam-dref));\n            }\n            col *= mate;\n            \n            col *= exp( -0.05*t );\n        }\n\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\n        tot += vec4(col,1.0);\n#if AA>1\n    }\n    tot.xyz /= tot.w;\n#endif\n\n    \n    fragColor = vec4( tot.xyz, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBGWK.jpg", "access": "api", "license": "mit", "functions": [[1409, 1409, 1434, 1434, 1453], [1455, 1455, 1534, 1534, 2169], [2241, 2282, 2361, 2361, 2706], [2708, 2749, 2844, 2844, 3336], [3338, 3338, 3392, 3392, 3555], [3557, 3557, 3609, 3609, 3637], [3639, 3639, 3660, 3660, 3692], [3694, 3694, 3748, 3748, 3845], [3847, 3847, 3912, 3912, 4038], [4040, 4040, 4082, 4082, 4116], [4118, 4159, 4292, 4292, 4753], [4755, 4796, 4852, 4852, 5146], [5300, 5300, 5356, 5356, 6008], [6010, 6010, 6072, 6072, 6396], [6398, 6398, 6477, 6477, 6760]], "test": "error"}
{"id": "7dBGWK", "name": "", "author": "penghuailiang", "description": " perlin ", "tags": ["shader"], "likes": 1, "viewed": 218, "published": 3, "date": "1617948622", "time_retrieved": "2024-07-30T19:27:42.370622", "image_code": "//  perlin \n\nvec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n    return 2.2 * n_xyz;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 pos, res;\n    float mDist, n, r, g, b;\n    res = gl_FragCoord.xy / 512.0;\n    pos = gl_FragCoord.xy / iResolution.xy;\n\n    mDist = 1.0 - distance(pos, iMouse.xy);\n\n    n = abs(cnoise(vec3(res, iTime))) * mDist;\n\n    for (float i = 1.0; i <= 4.0; i++) {\n        float p = pow(i, 2.0);\n        n += abs(cnoise(p * (n + vec3(res, n + iTime))) / p) * mDist;\n    }\n\n    r = abs(sin(n)) * mDist;\n    b = 0.2 * r;\n    g = mix(b, r, mDist);\n\n    fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBGWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 46, 46, 97], [99, 99, 120, 120, 171], [173, 173, 195, 195, 234], [236, 236, 264, 264, 318], [320, 320, 339, 339, 381], [384, 408, 430, 430, 2842], [2844, 2844, 2898, 2898, 3379]], "test": "untested"}
{"id": "NsSGDV", "name": "Point -> Patch UV", "author": "oneshade", "description": "My take on Inigo Quilez's article: https://iquilezles.org/articles/ibilinear/ibilinear.htm\nGoes crazy in some cases.", "tags": ["uv", "quadratic", "inverse", "interpolation", "parametric", "bilinear", "patch"], "likes": 6, "viewed": 187, "published": 3, "date": "1617939219", "time_retrieved": "2024-07-30T19:27:43.699069", "image_code": "// Set to 0 to see the whole surface\n#define ONLY_PATCH 1\n\n// Drawing utilities\n#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\n// Computes u and v for a given point and quad\n// There are two solutions\nfloat cross2D(in vec2 a, in vec2 b) { return a.y * b.x - a.x * b.y; }\nbool iBilinear(in vec2 xy, in vec2 a, in vec2 b, in vec2 c, in vec2 d, out vec4 uv) {\n    vec2 p = a - b + c - d;\n    vec2 q = b - a, r = d - a;\n\n    float c1 = cross2D(r, p);\n    float c2 = cross2D(r, q) + cross2D(a, p) + cross2D(p, xy);\n    float c3 = cross2D(a, q) + cross2D(q, xy);\n\n    float discr = c2 * c2 - 4.0 * c1 * c3;\n    if (discr > 0.0) {\n        uv.yw = (vec2(-1.0, 1.0) * sqrt(discr) - c2) / c1 * 0.5;\n        uv.xz = (xy.x - a.x - r.x * uv.yw) / (p.x * uv.yw + q.x);\n        return true;\n    }\n\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.5);\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 a = vec2(c2, s2) * 1.5 + vec2(c1, s3) * 0.5;\n    vec2 b = vec2(c2, s1) * 1.5 + vec2(s1, c2) * 0.5;\n    vec2 c = vec2(c1, c3) * 1.5 + vec2(c2, s3) * 0.5;\n    vec2 d = vec2(s2, s3) * 1.5 + vec2(c1, s2) * 0.5;\n\n    vec4 params;\n    if (iBilinear(uv, a, b, c, d, params)) {\n        float numPoints = 0.0;\n        vec3 patchColor = vec3(0.0);\n        if (ONLY_PATCH == 1 ? all(lessThan(abs(params.xy - 0.5), vec2(0.5))) : true) {\n            patchColor += texture(iChannel0, params.xy).rgb;\n            numPoints++;\n        }\n\n        if (ONLY_PATCH == 1 ? all(lessThan(abs(params.zw - 0.5), vec2(0.5))) : true) {\n            patchColor += texture(iChannel0, params.zw).rgb;\n            numPoints++;\n        }\n\n        if (numPoints > 0.0) color = patchColor / numPoints;\n    }\n\n    draw(sdLine(uv, a, b, 0.005), vec3(1.0, 0.8, 0.0));\n    draw(sdLine(uv, b, c, 0.005), vec3(1.0, 0.8, 0.0));\n    draw(sdLine(uv, c, d, 0.005), vec3(1.0, 0.8, 0.0));\n    draw(sdLine(uv, d, a, 0.005), vec3(1.0, 0.8, 0.0));\n\n    draw(sdDisc(uv, a, 0.05), vec3(1.0));\n    draw(sdDisc(uv, b, 0.05), vec3(1.0));\n    draw(sdDisc(uv, c, 0.05), vec3(1.0));\n    draw(sdDisc(uv, d, 0.05), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 156, 204, 204, 236], [238, 238, 297, 297, 409], [411, 485, 522, 522, 554], [555, 555, 640, 640, 1086], [1088, 1088, 1143, 1143, 2670]], "test": "untested"}
{"id": "NdSGDV", "name": "Honey Pot", "author": "wyatt", "description": "Fluid reaction diffusion. ", "tags": ["fluid", "automata"], "likes": 11, "viewed": 509, "published": 3, "date": "1617937085", "time_retrieved": "2024-07-30T19:27:44.473000", "image_code": "// Fork of \"Bubbles!!!\" by wyatt. https://shadertoy.com/view/sdfGWr\n// 2021-04-08 23:58:53\n\n// Fork of \"Colors!\" by wyatt. https://shadertoy.com/view/7dX3z7\n// 2021-03-14 23:43:37\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display \nMain \n{\n    vec4 a = A(U), b = B(U);\n    Q = 10.*min(a.w,1.)*(0.5+0.5*sin(1.5+8.*a.z+vec4(1,2,3,4)));\n    //Q+= .2*min(b.w,1.)*(0.5-0.5*sin(1.+8.*b.z+vec4(1,2,3,4)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 q = B(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b = B(U+u);\n        float d = dot(q,b);\n        Q.xy -= 0.1*a.w*(a.w-b.w)*u;  \n    }\n    Q.y-=2e-4;\n    Q.xy *= 1.-1e-2;\n    Q.w *= 0.99;\n    Q.w += .023*q.w*Q.w*(1.-Q.w);\n    if (iMouse.z>0.) \n    Q.xy += -1e-3*(iMouse.xy-U)/(1.+length(iMouse.xy-U));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,0,.01);\n    if (U.x < 1.||R.x-U.x<1.) Q.xy *= 0.;\n    if (U.y < 1.||R.y-U.y<1.) Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.2*max(1.-1.*Q.w*q.w,0.);\n       float k = .5+.2*max(1.-1.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Forces \nMain\n{\n    Q = A(U);\n    vec4 q = B(U);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b = B(U+u);\n        float d = dot(q,b);\n        Q.xy -= 0.05*a.w*((a.w-.8)+b.w)*u;  \n    }\n    //Q.xy *= 1.-1e-3; \n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1)Q = vec4(0,0,0,.3+.5*U.x/R.x);\n    if (U.x < 1.||R.x-U.x<1.) Q.xy *= 0.;\n    if (U.y < 1.||R.y-U.y<1.) Q.xy *= 0.;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect \nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-1.*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-1.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NsB3WV", "name": "camara v2", "author": "jorge2017a1", "description": "camara v2", "tags": ["camarav2"], "likes": 2, "viewed": 197, "published": 3, "date": "1617936562", "time_retrieved": "2024-07-30T19:27:45.236958", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 150.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n////-----------------\n\nfloat tau = atan(1.0) * 8.0;\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n\nvec3 HacerPrismagira(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    float numItem=10.0;\n    p= rotate_x( p, radians(90.0));\n    vec3 rep3 = opAngRep(p-vec3(0.0,0.0,0.0), tau / 6.0);\n    float sdp1= sdHexPrism(  rep3-vec3(10.0,0.0,0.0), vec2(5.0,10.0) );\n    \n    float sb1= sdBox(p -vec3(20,0.0,0.0), vec3(12.,11.0,12.0)  );\n    \n    float dif= differenceSDF(sb1, sdp1);\n    res =opU3(res, vec3(dif,1.0,MATERIAL_NO)); \n    \n    return res;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n    \n    float planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    \n    p.x=abs(p.x)-7.0;\n    p.z= opRep1D( p.z, 20.0 );\n    \n    vec3 hp1= HacerPrismagira( p-vec3(0.0,5.0,0.0));\n    vec3 hp2= HacerPrismagira( p-vec3(0.0,29.0,0.0));\n    vec3 hp3= HacerPrismagira( p-vec3(0.0,53.0,0.0));\n    \n    res =opU3(res, hp1); \n    res =opU3(res, vec3 (hp2.x, 6.0,-1.0)); \n    res =opU3(res, vec3 (hp3.x, 2.0,-1.0)); \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    float strength = 2.; // lower number makes lighting do deeper into sphere\n     //float fresnel = pow(clamp(1.0 + dot(normal, rd), 0.0, 1.0), strength);\n    float  fresnel = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), strength);\n    lin+=vec3(1.0)*fresnel;\n     \n    return lin*atten;\n}\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    float minDist = 999.0; \n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n         if ( abs(dS.x)<MIN_DIST)\n        { mObj.hitbln = true; minDist = abs(dO);break; }\n        \n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false; minDist = min(minDist, dO); break; }\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n\n\n\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.15;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,500.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    \n    vec3 ro=vec3(0.0,50.0,t);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    float t1=mod(iTime,1.0);\n    float t2=mod(iTime,2.0);\n    \n    if (t1<t2)\n        rd= rotate_x(rd, radians(45.0));\n    else\n    {\n        ro=vec3(0.0,10.0,t);\n        rd= rotate_z(rd, radians(45.0));\n    }    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n     col= getSkyColA(rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n///--------------------------------------------FIN\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsB3WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 559, 591, 591, 675], [677, 721, 768, 768, 795], [797, 797, 840, 840, 867], [869, 869, 917, 917, 945], [946, 1030, 1066, 1066, 1111], [1112, 1177, 1211, 1211, 1309], [1310, 1310, 1344, 1344, 1436], [1437, 1437, 1471, 1471, 1563], [1564, 1604, 1638, 1638, 1735], [1737, 1737, 1773, 1773, 2046], [2101, 2101, 2127, 2127, 2181], [2183, 2183, 2217, 2217, 2390], [2393, 2393, 2423, 2423, 2840], [2842, 2882, 2907, 2907, 3517], [3520, 3520, 3585, 3585, 4430], [4433, 4484, 4508, 4508, 4696], [4698, 4698, 4731, 4731, 5405], [5410, 5464, 5500, 5500, 5734], [5735, 5824, 5904, 5904, 6181], [6225, 6276, 6323, 6323, 6827], [6881, 6881, 6974, 6974, 7254], [7258, 7258, 7285, 7285, 7395], [7399, 7448, 7505, 7505, 9002]], "test": "untested"}
{"id": "7sB3Dy", "name": "Fractal 51_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 22, "viewed": 578, "published": 3, "date": "1617923054", "time_retrieved": "2024-07-30T19:27:46.136553", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.6)*.03*exp(-.2*i*i*e)\n    )\n    {\n        p=g*d-vec3(0,0,1.5);\n        p=R(p.zxy,normalize(vec3(1,0,10)),iTime*.3);\n        s=2.;\n        for(int i;i++<6;)\n            p=abs(p-vec3(1,2.8,1.5+sin(iTime*.5)*.2))-vec3(1,3.+sin(iTime*.7)*.3,2.1),\n            p*=(fract(iTime*.1)>.5)?-1.:1.,\n            s*=e=7./clamp(dot(p,p),1.2,7.),\n            p*=e;\n        g+=e=min(abs(p.z),length(p.xy)-.05)/s+1e-3;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sB3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 723]], "test": "untested"}
{"id": "ssBGDG", "name": "Evolving Gyroid - study 1/2", "author": "MacSlow", "description": "Study 1/2 into what can be done with all the different parameters one can tweak in a gyroid-function. You can yaw-orbit around the gyroid with the mouse.", "tags": ["3d", "phong", "sdf", "gyroid", "cineshader"], "likes": 10, "viewed": 1209, "published": 3, "date": "1617919509", "time_retrieved": "2024-07-30T19:27:47.001241", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Evolving gyroid-thing - study into what can be done with all the different\n// parameters one can tweak in a gyroid-function.\n//\n// Copyright 2021 Mirco Mller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Mller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// the HW_PERFORMANCE-check should take care of some optimization, if that does\n// not help you can still force GROUND_WAVES to 0 and/or AA_SIZE to 1 manually\n#if HW_PERFORMANCE==0\n#define GROUND_WAVES 0\nconst int AA_SIZE = 1;\n#else\n#define GROUND_WAVES 1\nconst int AA_SIZE = 2;\n#endif\n\nconst float PI = 3.14159265359;\nconst int MAX_ITER = 96;\nconst float STEP_BIAS = .5;\nconst float EPSILON = .0001;\nconst float MAX_DIST = 12.;\n\nfloat smin (float a, float b, float k)\n{\n    float h = clamp (.5 + .5*(b - a)/k, .0, 1.);\n    return mix (b, a, h) - h*k*(1. - h); \n}\n\nmat2 r2d (float deg)\n{\n    float rad = radians (deg);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{\n    p = vec2 (dot (p, vec2 (127.1, 311.7)),\n              dot (p, vec2 (269.5, 183.3)));\n\n    return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n    vec2 i = floor (p + (p.x + p.y)*K1);\n    \n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2; \n    vec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n    vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n                           dot (b, hash (i + o)),\n                           dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (70.));\n}\n\nfloat fbm (in vec2 p, in int iters)\n{\n    mat2 rot = r2d (35.);\n    float d = .0;\n    float f = 1.;\n    float fsum = .0;\n\n    for (int i = 0; i < iters; ++i) {\n        d += f*noise (p);\n        fsum += f;\n        f *= .5;\n    }\n    d /= fsum;\n\n    return d;\n}\n\nfloat plane (vec3 p, float h)\n{\n    return p.y + h;\n}\n\nfloat ball (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\nfloat cube (vec3 p, float size)\n{\n    return length (max (abs (p) - size, .0));\n}\n\nfloat gyroid (vec3 p, float scale, float thickness, float bias, vec2 modulation, vec2 offset)\n{\n    float modulate = (modulation.x > modulation.y) ? modulation.x : modulation.y;\n    p *= scale;\n    float d = dot (sin(p*modulation.x) + offset.x,\n                   cos(p.yzx*modulation.x) + offset.y) - bias;\n\n    return abs (d)/scale/modulate - thickness;\n}\n\nfloat scene (vec3 p)\n{\n    // doing the wavy ground with fbm() is a bit on the costly side\n    vec3 groundP = p;\n    groundP.x += iTime;\n    float pk = 1.5;\n    #if GROUND_WAVES \n    if( p.y<0.5 )\n    pk += .25*fbm(groundP.xz, 2);\n    #endif\n    float ground = plane (p, pk);\n\n    if (length(p) - 1.1 < ground) {\n        p.xz *= r2d (5.*iTime);\n        p.yx *= r2d (7.*iTime);\n        vec2 modulation = vec2 (2. + .75*cos(iTime),\n                                1.23 + .55*sin(iTime));\n        float thickness = .125 *(1./(1. + 5.*( cos(iTime)*.5 + .5 )));\n        float bias1 = 1.3;\n        float bias2 = .3;\n        float scale = 5.;\n        vec2 offset = vec2 (.1, .4);\n        float gyroid1 = gyroid (p, scale, thickness, bias1, modulation, offset)*.55;\n        float gyroid2 = gyroid (p, scale, thickness, bias2, modulation, offset)*.55;\n        float gyroidFinal = min (gyroid1 , gyroid2);\n        gyroidFinal = gyroid1 + gyroid2*.1;\n\n        float r = 1.125 + .05*cos (20.*p.y + 5.*iTime);\n        float ball = ball (p, r);\n\n        float g = smin (ball, gyroidFinal, -.05);\n        ground = min (g, ground);\n    }\n\n    return ground;\n}\n\nfloat raymarch (vec3 ro, vec3 rd, out int iter)\n{\n    float d = .0;\n    float t = .0;\n    int i = 0;\n    vec3 p = vec3 (.0);\n\n    for (; i < MAX_ITER; ++i) {\n        p = ro + d*rd;\n        t = scene (p);\n        if (abs (t) < EPSILON*(1. - .125*t) || d > MAX_DIST) {\n            iter = i;\n            break;\n        }\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 e = vec2 (EPSILON, .0);\n    float d = scene (p);\n    vec3 n = normalize (vec3 (scene (p + e.xyy),\n                              scene (p + e.yxy),\n                              scene (p + e.yyx)) - d);\n    return n;\n}\n\nfloat shadow (vec3 p, vec3 n, vec3 lPos, vec3 lDir)\n{\n    int ignore = 0;\n    float distToWorld = raymarch (p + .01*n, lDir, ignore);\n    float distToLight = distance (p, lPos);\n\n    return distToWorld < distToLight ? .3 : 1.;\n}\n\nfloat ao (vec3 p, vec3 n, float stepSize, int iterations, float intensity)\n{\n  float ao = .0; \n  float dist = .0; \n\n  for (int a = 1; a <= iterations; ++a) {\n    dist = float (a)*stepSize;\n    ao += max (.0, (dist - scene (p + n*dist))/dist);\n  }\n\n  return 1. - ao*intensity;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 n)\n{\n    vec3 p = ro + d*rd;\n\n    vec3 lPos1 = vec3 (3.*cos(iTime), 3., 3.*sin(.4*iTime));\n    vec3 lDir1 = normalize (lPos1 - p);\n    float lDist1 = distance (lPos1, p);\n    float attn1 = 30. / (lDist1*lDist1);\n    vec3 lColor1 = vec3 (1., .9, .3);\n\n    vec3 lPos2 = vec3 (-2.*cos(.3*iTime), 3., 4.*sin(iTime));\n    vec3 lDir2 = normalize (lPos2 - p);\n    float lDist2 = distance (lPos2, p);\n    float attn2 = 40. / (lDist2*lDist2);\n    vec3 lColor2 = vec3 (.2, .4, 1.);\n\n    vec3 amb = vec3 (.1); \n    float diff1 = max (dot (n, lDir1), .0);\n    float diff2 = max (dot (n, lDir2), .0);\n    vec3 h1 = normalize (lDir1 - rd);\n    vec3 h2 = normalize (lDir2 - rd);\n    float spec1 = pow (max (dot (h1, n), .0), 40.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n    float s1 = shadow (p, n, lPos1, lDir1);\n    float s2 = shadow (p, n, lPos2, lDir2);\n\n    float ao = ao (p, n, .05, 12, .1);\n\n    // don't do material assignment like this, this is a super lazy-ass hack!\n    vec3 gyroidMaterial = 1.5*vec3(.9, .6, .4);\n    bool isFloor = (p.y < -1.);\n    float phase = cos (20.*(p.x + iTime));\n    float mask = smoothstep (.005*d, .0025*d, .5 + .5*phase);\n    vec3 floorMaterial = 1.5*mix (vec3(.9), vec3 (.1), mask);\n    vec3 diffMaterial = isFloor ? floorMaterial : gyroidMaterial;\n\n    return amb + ao*(attn1*s1*(diff1*diffMaterial*lColor1 + spec1) +\n                     attn2*s2*(diff2*diffMaterial*lColor2 + spec2));\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 camForward = normalize (aim - ro);\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = normalize (ro + camForward*zoom);\n\n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and aspect-correct UVs\n    vec2 uv = 2.*(fragCoord/iResolution.xy) - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // allow some yaw-orbit with the mouse\n    vec2 yaw = .75*vec2 (PI*cos (4.*iMouse.x/iResolution.x),\n                         PI*sin (4.*iMouse.x/iResolution.x));\n    float pitch = 1.;\n\n    // create origin/camera/view-ray\n    vec3 ro = vec3 (yaw.x, pitch, yaw.y);\n    vec3 aim = vec3 (.0, .0, .0);\n    float zoom = 1.75;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // raymarch, shading & floor-glow\n    int iter = 0;\n    float d = .0;\n    vec3 p = vec3 (.0);\n    vec3 n = vec3 (.0);\n    vec3 color = vec3 (.0);\n    float fog = .0;\n\n    for (int x = 0; x < AA_SIZE; ++x) {\n        for (int y = 0; y < AA_SIZE; ++y) {\n\n\t\t\t// anti-alias offset\n\t\t\tvec2 pixelOffset = vec2 (float (x), float (y))/float (AA_SIZE);\n\n\t\t\t// normalize and aspect-correct UVs\n            uv = 2.*((fragCoord + pixelOffset)/iResolution.xy) - 1.;\n            uv.x *= iResolution.x/iResolution.y;\n\n    \t\t// create viewray\n    \t\trd = camera (uv, ro, aim, zoom);\n\n\t\t\t// primary/view ray\n            //iter = 0;\n\t\t\td = raymarch (ro, rd, iter);\n            p = ro + d*rd;\n            n = normal (p);\n\t\t\tvec3 ctmp = shade (ro, rd, d, n);\n            /*if (p.y < -1.) {\n                float glow = float (iter) / float (MAX_ITER);\n                ctmp += pow (glow, 1.05)*vec3 (1., .8, .2);\n            };*/\n            fog = 1. / (1. + d*d*.1);\n            ctmp *= fog;\n            ctmp = mix (ctmp, .5*vec3 (.15, .4, .9), pow (1. - 1./d, 6.));\n\n\t\t\tcolor += ctmp;\n        }\n    }\n    color /= float (AA_SIZE*AA_SIZE);\n\n    // make the final picture 'pretty'\n    color = color / (1. + color);\n    color *= 1. - .25*dot (uv, uv);\n    color = .2*color + .8*sqrt (color);\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 26571, "src": "https://soundcloud.com/weareoliver/oliver-mechanical", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBGDG.jpg", "access": "api", "license": "gpl-3.0", "functions": [[1438, 1438, 1478, 1478, 1571], [1573, 1573, 1595, 1595, 1709], [1711, 1853, 1876, 1876, 2019], [2021, 2021, 2046, 2046, 2549], [2551, 2551, 2588, 2588, 2810], [2812, 2812, 2843, 2843, 2865], [2867, 2867, 2897, 2897, 2926], [2928, 2928, 2961, 2961, 3009], [3011, 3011, 3106, 3106, 3368], [3370, 3370, 3392, 3460, 4513], [4515, 4515, 4564, 4564, 4881], [4883, 4883, 4905, 4905, 5132], [5134, 5134, 5187, 5187, 5362], [5364, 5364, 5440, 5440, 5641], [5643, 5643, 5691, 5691, 7116], [7118, 7118, 7172, 7172, 7500], [7502, 7502, 7559, 7599, 9367]], "test": "untested"}
{"id": "ssj3Dy", "name": "Breathing Gyroid - study 2/2", "author": "MacSlow", "description": "Study 2/2 into what can be done with all the different parameters one can tweak in a gyroid-function. You can yaw-orbit around the gyroid with the mouse.", "tags": ["3d", "phong", "sdf", "gyroid", "cineshader"], "likes": 10, "viewed": 1180, "published": 3, "date": "1617919500", "time_retrieved": "2024-07-30T19:27:47.787139", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Breathing Gyroid - study 2/2 into what can be done with all the different\n// parameters one can tweak in a gyroid-function.\n//\n// Copyright 2021 Mirco Mller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Mller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// the HW_PERFORMANCE-check should take care of some optimization, if that does\n// not help you can still force GROUND_WAVES to 0 and/or AA_SIZE to 1 manually\n#if HW_PERFORMANCE==0\n#define GROUND_WAVES 0\nconst int AA_SIZE = 1;\n#else\n#define GROUND_WAVES 1\nconst int AA_SIZE = 2;\n#endif\n\nconst float PI = 3.14159265359;\nconst int MAX_ITER = 96;\nconst float STEP_BIAS = .5;\nconst float EPSILON = .0001;\nconst float MAX_DIST = 12.;\n\nfloat smin (float a, float b, float k)\n{\n    float h = clamp (.5 + .5*(b - a)/k, .0, 1.);\n    return mix (b, a, h) - h*k*(1. - h); \n}\n\nmat2 r2d (float deg)\n{\n    float rad = radians (deg);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{\n    p = vec2 (dot (p, vec2 (127.1, 311.7)),\n              dot (p, vec2 (269.5, 183.3)));\n\n    return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n    vec2 i = floor (p + (p.x + p.y)*K1);\n    \n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2; \n    vec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n    vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n                           dot (b, hash (i + o)),\n                           dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (70.));\n}\n\nfloat fbm (in vec2 p, in int iters)\n{\n    mat2 rot = r2d (35.);\n    float d = .0;\n    float f = 1.;\n    float fsum = .0;\n\n    for (int i = 0; i < iters; ++i) {\n        d += f*noise (p);\n        fsum += f;\n        f *= .5;\n    }\n    d /= fsum;\n\n    return d;\n}\n\nfloat plane (vec3 p, float h)\n{\n    return p.y + h;\n}\n\nfloat ball (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\nfloat cube (vec3 p, float size)\n{\n    return length (max (abs (p) - size, .0));\n}\n\nfloat gyroid (vec3 p, float scale, float thickness, float bias, vec2 modulation, vec2 offset)\n{\n    float modulate = (modulation.x > modulation.y) ? modulation.x : modulation.y;\n    p *= scale;\n    float d = dot (sin(p*modulation.x) + offset.x,\n                   cos(p.yzx*modulation.x) + offset.y) - bias;\n\n    return abs (d)/scale/modulate - thickness;\n}\n\nfloat sMinGyroid (vec3 p,\n                  float r,\n                  float scale,\n                  float thickness,\n                  float bias,\n                  vec2 modulation,\n                  vec2 offset,\n                  float blend,\n                  float distScale)\n{\n    float ball = ball (p, r);\n    float gyroid = gyroid (p, scale, thickness, bias, modulation, offset)*distScale;\n    return  smin (ball, gyroid, blend);\n}\n\nfloat scene (vec3 p, out int id)\n{\n    // doing the wavy ground with fbm() is a bit on the costly side\n    vec3 groundP = p;\n    groundP.x += iTime;\n    float pk = 1.5;\n    #if GROUND_WAVES \n    if( p.y<0.5 )\n    pk += .25*fbm(groundP.xz, 2);\n    #endif\n    float ground = plane (p, pk);\n\n    p.xz *= r2d (5.*iTime);\n    p.yx *= r2d (7.*iTime);\n    vec2 modulation = vec2 (1.2, .8);\n    float thickness1 = .025 + .025*(cos (10.*iTime)*.5 + .5);\n    float thickness2 = .05 + .05*(cos (13.*iTime)*.5 + .5);\n    float thickness3 = .1 + .1*(cos (16.*iTime)*.5 + .5);\n    float bias1 = 1.3;\n    float bias2 = .3;\n    float bias3 = .025;\n    float scale = 7.;\n    vec2 offset = vec2 (.1, .4);\n    float sMinBlend = -.05;\n    float distScale = .55;\n\n    float r1 = 1.35 - .6*(cos (.5*iTime)*.5+.5);    // 1.35\n    float r2 = 1.1 - .4*(cos (iTime + 1.)*.5+.5);   // 1.1\n    float r3 = .7 + .2*(cos (2.*iTime + 2.)*.5+.5); // .7 + .2\n\n    float g1 = sMinGyroid (p, r1, scale, thickness1, bias1, modulation, offset, sMinBlend, distScale);\n    float g2 = sMinGyroid (p, r2, scale, thickness2, bias2, modulation, offset, sMinBlend, distScale);\n    float g3 = sMinGyroid (p, r3, scale, thickness3, bias3, modulation, offset, sMinBlend, distScale);\n\n    float d = ground;\n    d = min (d, g1);\n    d = min (d, g2);\n    d = min (d, g3);\n\n    if (d == ground) id = 0;\n    if (d == g1) id = 1;\n    if (d == g2) id = 2;\n    if (d == g3) id = 3;\n\n    return d;\n}\n\nfloat raymarch (vec3 ro, vec3 rd, out int iter, out int id)\n{\n    float d = .0;\n    float t = .0;\n    int i = 0;\n    vec3 p = vec3 (.0);\n    int ignoreId = 0;\n\n    for (; i < MAX_ITER; ++i) {\n        p = ro + d*rd;\n        t = scene (p, id);\n        if (abs (t) < EPSILON*(1. - .125*t) || d > MAX_DIST) {\n            iter = i;\n            break;\n        }\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    int ignoreId = 0;\n    vec2 e = vec2 (EPSILON, .0);\n    float d = scene (p, ignoreId);\n\n    vec3 n = normalize (vec3 (scene (p + e.xyy, ignoreId),\n                              scene (p + e.yxy, ignoreId),\n                              scene (p + e.yyx, ignoreId)) - d);\n    return n;\n}\n\nfloat shadow (vec3 p, vec3 n, vec3 lPos, vec3 lDir)\n{\n    int ignoreIter = 0;\n    int ignoreId = 0;\n    float distToWorld = raymarch (p + .01*n, lDir, ignoreIter, ignoreId);\n    float distToLight = distance (p, lPos);\n\n    return distToWorld < distToLight ? .3 : 1.;\n}\n\nfloat ao (vec3 p, vec3 n, float stepSize, int iterations, float intensity)\n{\n  float ao = .0; \n  float dist = .0; \n  int ignoreId = 0;\n\n  for (int a = 1; a <= iterations; ++a) {\n    dist = float (a)*stepSize;\n    ao += max (.0, (dist - scene (p + n*dist, ignoreId))/dist);\n  }\n\n  return 1. - ao*intensity;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 n, int id)\n{\n    vec3 p = ro + d*rd;\n\n    vec3 lPos1 = vec3 (3.*cos(iTime), 3., 3.*sin(.4*iTime));\n    vec3 lDir1 = normalize (lPos1 - p);\n    float lDist1 = distance (lPos1, p);\n    float attn1 = 30. / (lDist1*lDist1);\n    vec3 lColor1 = vec3 (1., .9, .3);\n\n    vec3 lPos2 = vec3 (-2.*cos(.3*iTime), 3., 4.*sin(iTime));\n    vec3 lDir2 = normalize (lPos2 - p);\n    float lDist2 = distance (lPos2, p);\n    float attn2 = 40. / (lDist2*lDist2);\n    vec3 lColor2 = vec3 (.2, .4, 1.);\n\n    vec3 amb = vec3 (.1); \n    float diff1 = max (dot (n, lDir1), .0);\n    float diff2 = max (dot (n, lDir2), .0);\n    vec3 h1 = normalize (lDir1 - rd);\n    vec3 h2 = normalize (lDir2 - rd);\n    float spec1 = pow (max (dot (h1, n), .0), 40.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n    float s1 = shadow (p, n, lPos1, lDir1);\n    float s2 = shadow (p, n, lPos2, lDir2);\n\n    float ao = ao (p, n, .05, 12, .1);\n\n    bool isFloor = id == 0;\n    float phase = cos (20.*(p.x + iTime));\n    float mask = smoothstep (.005*d, .0025*d, .5 + .5*phase);\n    vec3 floorMaterial = 1.5*mix (vec3(.8), vec3 (.2), mask);\n\n    vec3 gyroidMaterial = vec3(.0);\n    if (id == 1) gyroidMaterial = 1.5*vec3(.8, .2, .1);\n    if (id == 2) gyroidMaterial = 2.*vec3(.8, .7, .2);\n    if (id == 3) gyroidMaterial = 3.5*vec3(.8, .5, .3);\n\n    vec3 diffMaterial = isFloor ? floorMaterial : gyroidMaterial;\n\n    return amb + ao*(attn1*s1*(diff1*diffMaterial*lColor1 + spec1) +\n                     attn2*s2*(diff2*diffMaterial*lColor2 + spec2));\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 camForward = normalize (aim - ro);\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = normalize (ro + camForward*zoom);\n\n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and aspect-correct UVs\n    vec2 uv = 2.*(fragCoord/iResolution.xy) - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // allow some yaw-orbit with the mouse\n    vec2 yaw = .75*vec2 (PI*cos (4.*iMouse.x/iResolution.x),\n                         PI*sin (4.*iMouse.x/iResolution.x));\n    float pitch = 1.;\n\n    // create origin/camera/view-ray\n    vec3 ro = vec3 (yaw.x, pitch, yaw.y);\n    vec3 aim = vec3 (.0, .0, .0);\n    float zoom = 1.75;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // raymarch, shading & floor-glow\n    int iter = 0;\n    float d = .0;\n    vec3 p = vec3 (.0);\n    vec3 n = vec3 (.0);\n    vec3 color = vec3 (.0);\n    float fog = .0;\n\n    for (int x = 0; x < AA_SIZE; ++x) {\n        for (int y = 0; y < AA_SIZE; ++y) {\n\n\t\t\t// anti-alias offset\n\t\t\tvec2 pixelOffset = vec2 (float (x), float (y))/float (AA_SIZE);\n\n\t\t\t// normalize and aspect-correct UVs\n            uv = 2.*((fragCoord + pixelOffset)/iResolution.xy) - 1.;\n            uv.x *= iResolution.x/iResolution.y;\n\n    \t\t// create viewray\n    \t\trd = camera (uv, ro, aim, zoom);\n\n\t\t\t// primary/view ray\n            int id = 0;\n\t\t\td = raymarch (ro, rd, iter, id);\n            p = ro + d*rd;\n            n = normal (p);\n\t\t\tvec3 ctmp = shade (ro, rd, d, n, id);\n            fog = 1. / (1. + d*d*.1);\n            ctmp *= fog;\n            ctmp = mix (ctmp, .5*vec3 (.15, .4, .9), pow (1. - 1./d, 6.));\n\n\t\t\tcolor += ctmp;\n        }\n    }\n    color /= float (AA_SIZE*AA_SIZE);\n\n    // make the final picture 'pretty'\n    color = color / (1. + color);\n    color *= 1. - .25*dot (uv, uv);\n    color = .2*color + .8*sqrt (color);\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 26570, "src": "https://soundcloud.com/weareoliver/oliver-mechanical", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssj3Dy.jpg", "access": "api", "license": "gpl-3.0", "functions": [[1437, 1437, 1477, 1477, 1570], [1572, 1572, 1594, 1594, 1708], [1710, 1852, 1875, 1875, 2018], [2020, 2020, 2045, 2045, 2548], [2550, 2550, 2587, 2587, 2809], [2811, 2811, 2842, 2842, 2864], [2866, 2866, 2896, 2896, 2925], [2927, 2927, 2960, 2960, 3008], [3010, 3010, 3105, 3105, 3367], [3369, 3369, 3651, 3651, 3808], [3810, 3810, 3844, 3912, 5252], [5254, 5254, 5315, 5315, 5658], [5660, 5660, 5682, 5682, 5972], [5974, 5974, 6027, 6027, 6242], [6244, 6244, 6320, 6320, 6551], [6553, 6553, 6609, 6609, 8109], [8111, 8111, 8165, 8165, 8493], [8495, 8495, 8552, 8592, 10198]], "test": "untested"}
{"id": "7sj3Wy", "name": "BasicSphere", "author": "nialred", "description": "First try at casting sphere with lighting. Used another shader for help but can't find the link to it anymore.", "tags": ["raycast", "sphere", "raytrace"], "likes": 0, "viewed": 207, "published": 3, "date": "1617915780", "time_retrieved": "2024-07-30T19:27:48.549102", "image_code": "struct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Circle\n{\n    vec2 center;\n    float radius;\n};\n    \nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\n\nint intersect_circle(in vec2 uv, in Circle circle)\n{    \n    vec2 distance = abs(uv - circle.center);\n    \n    float radius_check = length(distance);\n    \n    /*\n    // Could use this instead to get smooth edges between sphere and background\n    float difference = radius - radius_check;\n    float color = clamp(difference / fwidth(difference), 0., 1.);\n    fragColor = vec4(color, 0.0, 1.0 - color, 1.0);\n    */\n    \n    if (radius_check < circle.radius)\n    {\n        // Inside circle\n        return 1;\n    } \n    else\n    {\n        // Outside circle\n        return 0;\n    } \n}\n\nvec4 diffuse(in vec3 surface, in vec3 center, in vec4 color, in vec3 light_pos) {\n\t// Surface normal\n\tvec3 n = normalize(surface - center);\n\t\n\t// Light direction from surface\n\tvec3 l = normalize(light_pos - surface);\n\n\t// The diffuse equation\n\treturn color * max(0.0, dot(n, l));\n}\n\nfloat intersect_sphere(in Ray ray, in Sphere sphere)\n{\n    // Sphere center to ray origin\n    vec3 co = (ray.origin - sphere.center);\n    \n    // The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance\n\tfloat discrim = dot(co, ray.direction) * dot(co, ray.direction) - \n                         (dot(co, co) - (sphere.radius * sphere.radius));\n    \n    if (discrim >= 0.0)\n    {\n        return -dot(ray.direction, co) - sqrt(discrim);\n    }\n    else\n    {\n        return -1.0;\n    }\n\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates\n    vec2 uv = fragCoord.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_norm = uv / iResolution.xy;\n    \n    // Initialize circle object\n    Circle circle = Circle(vec2(iResolution.x / 2.0, iResolution.y / 2.0), 200.0);\n    \n    // Check if current pixel position is inside the circle\n    int hit_circle = intersect_circle(uv, circle);\n    \n    // Color the pixel accordingly\n    if (hit_circle == 1)\n    {\n        fragColor = vec4(uv_norm.x, uv_norm.y, 1.0, 1.0);\n    }\n    else \n    {\n        fragColor = vec4(0.25 * uv_norm.x, 0.25 * uv_norm.y, 0.25, 1.0);\n    }\n    \n    \n    // Shift the range from [0 1] to [-1 1]\n    vec2 uv_norm_shift = uv_norm * 2.0 - 1.0;\n    \n    // Pixel position in 3D space (screen is at a z value of 0)\n    vec3 pixel_pos = vec3(uv_norm_shift.x / (iResolution.y/iResolution.x), uv_norm_shift.y, 0.0);\n    \n    // Eye position is behind the screen somewhere (hence the -4 z value)\n    vec3 eye_pos = vec3(0.0, 0.0, -4.0);\n    \n    // Ray used to see if it intersects with sphere\n    vec3 ray_dir = normalize(pixel_pos - eye_pos);\n    \n    // Define sphere with 3D center and radius values\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 7.0), 1.0);\n    \n    // Define ray\n    Ray ray = Ray(eye_pos, ray_dir);\n    \n    float surf_dist = intersect_sphere(ray, sphere);\n    \n    // If positive, then we draw a pixel of the sphere\n\tif (surf_dist >= 0.0)\n\t{\n\t\t// Choose a diffuse color\n\t\tvec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n\t\t// Choose an ambient color\n\t\tvec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n        // Position of a white light\n        vec3 light_pos = vec3(20.0, 5.0, -10.0);\n        \n\t\tfragColor = ambient_col + diffuse(eye_pos + surf_dist * ray_dir, sphere.center, diffuse_col, light_pos);\n\n\t} \n    else\n    {\n        // Otherwise we draw the color of the background\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sj3Wy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 221, 221, 748], [750, 750, 831, 850, 1031], [1033, 1033, 1087, 1122, 1557], [1564, 1564, 1621, 1646, 3523]], "test": "untested"}
{"id": "ssBGzD", "name": "to reflect upon", "author": "nabr", "description": "two circular objects, a rectangular light placed in a cube and a sphere, that act like perfect mirrors.", "tags": ["raymarch", "sound", "abstract", "pathtracing", "mirror", "synth", "whoob", "widerspiegeln"], "likes": 14, "viewed": 499, "published": 3, "date": "1617915138", "time_retrieved": "2024-07-30T19:27:49.509534", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    c.xyz = c.xyz/c.w;\n\tfragColor =   vec4((c.xyz),1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\n#define Fs iSampleRate\n#define _f(x) fract(x)\n// whoob\nfloat whb(float t)\n{\n    int it = int(t) & 3;\n    float f0 = 47.123*float(int[](44,52,50,42)[it]),\n          f1 = 47.123*float(int[](74,68,65,48)[it]);\n    return.25*clamp((sin(f0 * t)+sin(f1 * t))*sin(20.*t),-.5, .5);\n}\n// drums\nvec2 dr(float t)\n{\n    float bd = 0., sn = 0., hh = 0.;\n    t = mod(t, 8.);\n    float m = float[](.5, 2., 1.,.5, 1., 1., 1., 4.)[int(4.*t)%8];\n    float snf0 = _f(2.*t), snf1 = _f(t),snf2 = _f(3.*t),bdf0 = _f(m *t) ,bdf1 =_f(8.*t)\n    ,pf= pow(bdf1, 3.);\n    // snare\n    sn = sin(1508. * t) * cos(1508. * exp(-.06 * snf2 ) + cos(snf1 * 1500.));\n    sn *= min(1.,floor(.5+snf1)) * exp(-14. * snf0);\n    sn += .2*clamp(sn*abs(1.-cos(sn/4./snf0)),-0.1, 0.2);\n    // base drums\n    bd = sin(628.31 *  t) * cos(376.98 * exp(-0.0432 * pow(1.-bdf1, 10. )) );\n    bd *= min(1., 20. * bdf1) * max(0.,1.-bdf1) * exp(-12. * bdf0);\n    // shakers, autopan\n    hh = cos( exp(-10. * (pf-2.*floor(pf)-1.) )  * 6.2831 * 260.) \n          * exp(-45. * bdf1) * min(1., .002 + bdf1);\n    return vec2(.8 * sn, sn)  + 1. * bd + \n           vec2(hh*(cos(t)+sin(t)),hh*(-sin(t)+cos(t)));\n}\n\n//synth\nvec2 f(int s)\n{\n    vec2 y = vec2(1e-6);\n    const float w[19]=float[19](200.,401.,168.,248.,600.,0.,330.,110.,0.,500.,334.,378.,0.,596.,595.,395.,0.,0.,600.);\n    float rt = float(s) / Fs * .5,\n          frt = _f(rt),\n          pfrt = pow(min(sqrt(sqrt(1.-frt)), 100. * frt), 4.),\n          sf = 6.283185 * float(s)/Fs;\n    y.y =  sin(sf * w[int(rt) % 10]);\n    y.y += clamp(y.y+(1.-cos(9.*y.y)),-3.,.3) * pfrt;\n    y.x =  sin(sf * w[int(rt) % 9 + 10]);\n    y.x += clamp(y.x+(1.+sin(6.*y.x)),-.2,.9) * pfrt;\n    y.x += ((y.x-floor(.5*y.x)) * atan(1.-frt,25.*frt));\n    return vec2(y.x,y.y);\n}\nvec2 mainSound(int s, float t)\n{\n    // observation: \n    // the echoes, the synth itself, also introduce phase rotation \n    // with bitreduction -noise, copying, inverse multiplying, finaly adding the original sound\n    // i can control the stereowidth of the output \n    \n    \n    vec4 y = vec4(1e-6),b =y;vec2 d=(s>44100*4)?dr(t):vec2(1e-6);\n    const int k[8] = int[8](83341,68581,78517,102859,87421,95279,86813,73907);\n    int nt0 = 953, nt1 = 1571, nt11 = 1031;\n    for(int ii=0;ii<8;++ii){\n    if(ii<5)y.xw+=vec2(f((s-(nt0+=k[ii]))).x, f((s-(nt1+=k[ii]))).x);\n    if(ii>1)y.yz+=vec2(f((-s+(nt1+=k[ii]))).y, f((-s+(nt11+=k[ii]))).y);\n    }\n    b = y;\n    float bt = pow(.8, 8.);\n    b.x = (bt * floor(y.y/ bt + .5));b.y = (bt * floor(y.x/ bt + .5));\n    return mod(t,23.)<19.?((.03*((b.xy*1.-b.wz) + y.xy) )+d):d+whb(t);\n}", "sound_inputs": [], "buffer_a_code": "\n// i started here:\n// https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\nfloat hashf(inout uint state) {\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n\n#define mR(_a)(mat2(cos(_a+vec4(0,33,11,0))))\n#define repM(_x,_y)(_y*.5-mod(_x,_y))\n#define dmin(a,b)((a.x < b.x) ? a : b)\nfloat sdBox(vec3 p,vec3 s) {\n    p=abs(p)-s;\n    return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);\n}\nvec2 f(vec3 p)\n{\n    // two circular objects, a rectangular light placed in a cube and a sphere\n    float sp = length(vec3(.5 - p.x, .2 + p.y, 1.5 - p.z)) - 3.;//reflective sphere\n    float b = sdBox(vec3(.5-p.x, p.y, 1. + p.z), vec3(3, 4, 5.));//cube\n    float lt = sdBox(vec3(p.xy, 1. + p.z), vec3(.2, .2, .05));//light\n\n    //tunnel\n    vec3 k = vec3(repM(vec2(atan(p.y, p.x) *2.864788, 1.+p.z), vec2(1.1, 6.28)),length(p.xy) - 2.); \n    k = abs(k) - vec3(.1, .5, .5);\n    float fk = length(max(-vec3(-.125, .089, .25), .5 *k)) + min(max(k.x, max(k.y, k.z)), 0.) - .15;\n    \n    //circular cubes\n    float ll = 0.;\n    p.yz *= mR(.5);\n    p.xz *= mR(1.);\n    \n    vec3 vb = p;\n    vb.x = atan(p.x, p.y) * (6. / 3.14159);\n    vb.x -= floor(.5 + vb.x);\n    vb.y = length(p.xy);\n    vb.yz *= mR(0.34907);\n    vb.y -= 1.5;\n    vb.x = max(abs(vb.y), abs(vb.x));\n    vb = abs(vb) - vec3(.21, 1.5, .25);\n    ll = (max(max(vb.x, vb.y), vb.z));\n\n    return\n        dmin(vec2(fk, 3),\n             dmin(vec2(-b, 7),\n                  dmin(vec2(ll, 5),\n                       dmin(vec2(-sp, -1),\n                            vec2(lt, 11)))));\n}\n\n\n// somewhre on stackoverflow\nvec3 obd(vec3 n, vec2 rv)\n{\n    // http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    vec3 t = (n.x > n.z) ? vec3(-n.y, n.x, 0.0) : vec3(0.0, -n.z, n.y), bt = cross(n, t);\n    float ph = rv.y,th = rv.x, sth = sin(th);\n    return t * cos(ph) * sth + bt * sin(ph) * sth + n * cos(th);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(1e-3),hput=vec3(1),specrd=vec3(0);\n    vec2 R=iResolution.xy,e = vec2(1e-4, -1e-4);\n    struct M {vec3 alb, emi;float rgh;} m = M(vec3(.98), vec3(0),0.);\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    uint seed =(uint(fragCoord.x)*1973u+uint(fragCoord.y)*9277u+uint(iFrame)*2669u)|1u;\n    float cd = tan(radians(103.*.5));\n    vec2 jt = hashf(seed)+vec2(cos(hashf(seed)),2.*sin(hashf(seed)));\n    vec2 st = vec2(cd, R.y/R.x * cd) * ((fragCoord+jt)/R*2.-1.);\n    vec3 ro = vec3(vec2(.01),3.23),\n         g = normalize(vec3(.2, .1, .001) - ro),\n         u = normalize(cross(g, vec3(0, 1, 0))),\n         v = normalize(cross(u, g));\n    vec3 rd = normalize(g + st.x *u + st.y *v);\n    vec2 h = vec2(0);\n    //if(abs(st.x)<fract(R.y/R.x*cd)) //debug slow machine\n    for (int b = 1; b < 6 + min(iFrame, 0); ++b)\n    {\n\n        float t = 0.;\n        for (int i = 0; i < 60&&t<6.; i++)\n        {\n            h = f(ro + rd * t);\n            if (abs(h.x) < t * .001)\n                break;\n            t += h.x;\n        }\n\n        {\n            switch (int(h.y))\n            {\n            case 3:\n                m.alb = clamp(mix(vec3(.4, .2, .72), vec3(.86, .87, .1),fract(1.2*rd.z+t)), 0., 1.);\n                m.emi = vec3(1e-6);\n                m.rgh = .7;\n                break;\n            case 5:\n                m.alb = (vec3(.2, .9, .79));\n                m.emi = vec3(1e-6);\n                m.rgh = .5;\n                break;\n            case 7:\n                m.alb = vec3(.9);\n                m.rgh = 1e-3;\n                (b>4)?(m.emi = vec3(50.)):(m.emi = vec3(1e-3));\n                break;\n            case 11:\n                m.alb = vec3(1);\n                m.emi = vec3(100);\n                m.rgh = 1e-6;\n                break;\n            }\n            vec3 p = ro + t * rd;\n            vec3 N=normalize(e.yxx*f(p+e.yxx).x+e.xxy*f(p+e.xxy).x+e.xyx*f(p+e.xyx).x+e.yyy*f(p+e.yyy).x);\n            ro = p + N * .01;\n            specrd = mix(reflect(rd, N), obd(N, .2*p.z+vec2(6. + (2. * hashf(seed) - 1.), (6.28318 * hashf(seed)))) /*artistic*/, m.rgh * m.rgh);\n            rd = normalize(specrd);\n            col += m.emi * hput;\n            hput *= m.alb;\n        }\n    }\n    fragColor +=vec4(sqrt(col),1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 173]], "test": "untested"}
{"id": "ssjGWy", "name": "Gear Projection", "author": "dr2", "description": "Cardan straight line mechanism - a double epicycloid (mouseable)", "tags": ["mechanics", "hatch", "kinematics", "cardan"], "likes": 24, "viewed": 381, "published": 3, "date": "1617913569", "time_retrieved": "2024-07-30T19:27:50.475950", "image_code": "// \"Gear Projection\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar, dMiss;\nint idObj;\nbool isSh;\nconst int idGearB = 1, idGearS = 2, idArm = 3, idLnk = 4, idPin = 5, idAxl = 6, idFrm = 7;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GearWlDf (vec3 p, float rad, float nTh, float nSp, float aRot, float tWid, float wlThk)\n{\n  vec3 q;\n  vec2 cs;\n  float d, a, r, w;\n  p.xz = Rot2D (p.xz, aRot);\n  q = p;\n  r = length (q.xz);\n  a = atan (q.z, - q.x) / (2. * pi);\n  d = max (abs (r - 0.98 * rad + tWid) - 0.07 * rad, abs (q.y) - wlThk);\n  d = min (d, max (length (q.xz) - 0.2 * rad, abs (q.y) - 1.5 * wlThk));\n  cs = sin (2. * pi * floor (nSp * a + 0.5) / nSp + vec2 (0.5 * pi, 0.));\n  d = min (d, max (PrBox2Df (vec2 (q.y, dot (q.xz, cs.yx)),\n     vec2 (wlThk, 0.03 * rad)), r - rad + tWid));\n  q.xz = Rot2D (q.xz, 2. * pi * floor (nTh * a + 0.5) / nTh);\n  cs = sin (0.12 * pi + vec2 (0.5 * pi, 0.));\n  return abs (max (d, - max (dot (vec2 (q.x + rad, abs (q.z) - 1.3 * tWid), cs.yx),\n     abs (r - rad) - 1.8 * tWid))) - 0.01;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, nThB, nThS, radB, radS, tWid, wlThk, cRad, rRat, bLen, rAng;\n  dMin = dstFar;\n  rAng = 0.15 * tCur;\n  wlThk = 0.05;\n  cRad = 0.06;\n  nThB = 64.;\n  rRat = 0.5;\n  nThS = floor (nThB * rRat + 0.001);\n  rRat = nThS / nThB;\n  radB = 1.;\n  radS = radB * rRat;\n  q = p;\n  d = min (PrCylDf (vec3 (q - vec3 (0., 6. * wlThk, 0.)).xzy, 0.13 * radB, 4. * wlThk),\n     PrCylDf (vec3 (q - vec3 (0., 8. * wlThk, 0.)).xzy, 0.05 * radB, 10. * wlThk));\n  DMINQ (idAxl);\n  q.y -= 4. * wlThk;\n  if (! isSh) d = PrCylDf (q.xzy, radB + 0.05, wlThk + 0.05);\n  if (isSh || d < dMin + 0.1) {\n    q.xz = Rot2D (q.xz, 0.25 * pi);\n    tWid = 0.03;\n    d = GearWlDf (q, radB, nThB, 4., 0., tWid, wlThk);\n    DMINQ (idGearB);\n  } else dMin = min (dMin, d);\n  q = p;\n  q.xz = Rot2D (q.xz, - rAng / rRat);\n  bLen = 0.5 * radB + 1.5 * radS;\n  d = PrRoundBoxDf (q - vec3 (- bLen, 0., 0.), vec3 (bLen + 2. * wlThk, wlThk, 2. * wlThk), 0.01);\n  DMINQ (idArm);\n  d = PrCylDf ((q - vec3 (0.5, 16. * wlThk, 0.)).zyx, 0.04, 0.5);\n  DMINQ (idPin);\n  tWid = 0.04;\n  q.x -= - (radB + radS) + 0.2 * tWid;\n  d = PrCylDf (vec3 (q - vec3 (0., 2. * wlThk, 0.)).xzy, 0.1 * radS, 4. * wlThk);\n  DMINQ (idAxl);\n  q.y -= 4. * wlThk;\n  if (! isSh) d = PrCylDf (q.xzy, radS + 0.05, wlThk + 0.05);\n  if (isSh || d < dMin + 0.1) {\n    d = GearWlDf (q, radS, nThS, 8., - 2. * rAng / rRat + (pi / nThS), tWid, wlThk);\n    DMINQ (idGearS);\n  } else dMin = min (dMin, d);\n  q.x -= -2. * radS + tWid;\n  d = PrCylDf ((q - vec3 (0., -4. * wlThk, 0.)).xzy, 0.1 * radS, 6. * wlThk);\n  DMINQ (idAxl);\n  if (! isSh) d = PrCylDf (q.xzy, radS + 0.05, wlThk + 0.05);\n  if (isSh || d < dMin + 0.1) {\n    d = GearWlDf (q, radS, nThS, 8., 2. * rAng / rRat, tWid, wlThk);\n    DMINQ (idGearS);\n  } else dMin = min (dMin, d);\n  q.y -= -8.5 * wlThk;\n  q.xz = Rot2D (q.xz, 2. * rAng / rRat);\n  bLen = 0.5 * (radB + 3. * radS) - 0.7 * tWid;\n  q.x -= - bLen;\n  d = PrRoundBoxDf (q, vec3 (bLen + 1.5 * cRad, 0.75 * wlThk, 1.5 * cRad), 0.01);\n  DMINQ (idLnk);\n  q.xy -= vec2 (- bLen, -3. * wlThk);\n  d = PrCylDf (q.xzy, cRad, 4.5 * wlThk);\n  DMINQ (idPin);\n  q.y -= -4. * wlThk;\n  d = PrCylDf (q.xzy, 3. * cRad, wlThk);\n  DMINQ (idPin);\n  q = p;\n  d = SmoothMax (PrRoundBoxDf (q, vec3 (5.35 * radB, 9. * wlThk, 3. * cRad), 0.02),\n     - min (PrBox2Df (q.xy, vec2 (5.2 * radB, 7. * wlThk)),\n     max (PrBox2Df (q.xz, vec2 (5.1 * radB, 1.3 * cRad)), q.y)), 0.01);\n  DMINQ (idFrm);\n  dMiss = min (dMiss, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec2 ExBlkHit (vec3 ro, vec3 rd)\n{\n  vec4 vn4;\n  vec3 v, tm, tp, u, fcBlk;\n  vec2 qBlk;\n  float dn, df, bs;\n  bs = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bs / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk)) / bs;\n  }\n  return qBlk;\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, fcBlk;\n  vec2 qBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec3 SkShowScene (vec3 ro, vec3 rd, vec2 uv)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, ltDirS;\n  float dstObj;\n  dMiss = dstFar;\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn4 = ObjNfL (ro);\n    vn = vn4.xyz;\n    ltDirS = normalize (vec3 (0.5, 1.3, -1.));\n    col = vec3 (1.) * (1. - 0.5 * smoothstep (0.5, 1., abs (vn4.w) / 64.)) *\n       (0.85 + 0.15 * Noisefv2 (Rot2D (uv, -0.1 * pi) * vec2 (32., 512.))) *\n       (0.5 + 0.5 * max (dot (vn, ltDirS), 0.));\n    dMiss = dstFar;\n  } else col = vec3 (1.);\n  col = mix (col, vec3 (0.5), exp (- 64. * dMiss));\n  return clamp (col, 0., 1.);\n}\n\nvoid SkMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  vuMat = StdVuMat (-0.35 * pi, 0.);\n  ro = vuMat * vec3 (0., -5., -20.);\n  rd = vuMat * normalize (vec3 (fCoord, 4.2));\n  fCol = SkShowScene (ro, rd, fCoord);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 col, vn, bSize;\n  vec2 qBlk, q;\n  float dstObj, nDotL, sh;\n  bool isBg;\n  dMiss = dstFar;\n  isSh = false;\n  isBg = false;\n  dstObj = ObjRay (ro, rd);\n  bSize = vec3 (7.5, 0.1, 5.);\n  db4 = BlkHit (ro - vec3 (0., -1., -1.8), rd, bSize);\n  if (dstObj < min (db4.x, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    qBlk = mod (8. * ExBlkHit (ro, reflect (rd, vn)), 1.);\n    if (idObj == idGearB) col4 = vec4 (0.9, 0.9, 0.8, 0.2);\n    else if (idObj == idGearS) col4 = vec4 (1., 1., 0.7, 0.2);\n    else if (idObj == idArm) col4 = vec4 (0.8, 1., 0.8, 0.2);\n    else if (idObj == idLnk) col4 = vec4 (1., 0.7, 0.9, 0.2);\n    else if (idObj == idPin) col4 = vec4 (0.7, 1., 0.7, 0.2);\n    else if (idObj == idFrm) col4 = vec4 (0.7, 0.4, 0.1, 0.1);\n    else if (idObj == idAxl) col4 = vec4 (1., 1., 0.5, 0.2);\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj != idFrm) nDotL *= nDotL;\n  } else if (db4.x < dstFar) {\n    ro += db4.x * rd;\n    vn = db4.yzw;\n    q = ro.xz - vec2 (0., -1.8);\n    if (vn.y > 0.5 && PrBox2Df (q, bSize.xz - 0.48) < 0.) {\n      SkMain (col, q / vec2 (5.3, 6.) - vec2 (0., -1.25));\n      if (Minv3 (col) > 0.9) {\n        q = smoothstep (0.03, 0.06, abs (mod (2. * q + 0.5, 1.) - 0.5));\n        col = mix (vec3 (0.7, 0.7, 1.), vec3 (1.), min (q.x, q.y));\n      }\n    } else {\n      col = vec3 (1.) * (0.8 + 0.2 * step (0.5, vn.y));\n      sh = 1.;\n    }\n  } else {\n    isBg = true;\n    qBlk = mod (8. * ExBlkHit (ro, rd), 1.);\n    col = vec3 (0.4, 0.5, 0.4) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +\n       vec3 (0.2) * (0.9 + 0.1 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *\n       SmoothBump (0.25, 0.75, 0.1, qBlk.y));\n  }\n  if (! isBg) {\n    isSh = true;\n    sh = ObjSShadow (ro + 0.01 * ltDir, ltDir);\n    if (dstObj < min (db4.x, dstFar)) {\n      col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      col += col4.a * vec3 (0.5) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *\n         SmoothBump (0.25, 0.75, 0.05, qBlk.y));\n    } else {\n      col *= 0.4 + 0.6 * sh * max (dot (vn, ltDir), 0.);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.28 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -2.4, -20.);\n  zmFac = 4.2;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjGWy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[774, 774, 869, 869, 1573], [1575, 1575, 1597, 1597, 4067], [4069, 4069, 4102, 4102, 4286], [4288, 4288, 4309, 4309, 4564], [4566, 4566, 4588, 4588, 4917], [4919, 4919, 4956, 4956, 5185], [5187, 5187, 5221, 5221, 5642], [5644, 5644, 5688, 5688, 6044], [6046, 6046, 6092, 6092, 6681], [6683, 6683, 6728, 6728, 6919], [6921, 6921, 6956, 6956, 9144], [9188, 9188, 9244, 9244, 10208], [10210, 10210, 10243, 10243, 10332], [10334, 10334, 10380, 10380, 10427], [10429, 10429, 10471, 10471, 10522], [10524, 10524, 10546, 10546, 10584], [10586, 10586, 10608, 10608, 10646], [10648, 10648, 10693, 10693, 10796], [10798, 10798, 10843, 10843, 10881], [10883, 10883, 10940, 10940, 11023], [11025, 11025, 11061, 11061, 11267], [11269, 11269, 11299, 11299, 11412], [11446, 11446, 11470, 11470, 11600], [11602, 11602, 11627, 11627, 11813]], "test": "untested"}
{"id": "7sSGWG", "name": "atan UV seam correction", "author": "bgolus", "description": "Fixing the seam on procedural UVs, and exposing underlying differences in how derivatives are calculated for both the in shader derivative functions and the hardware texture mip calculation.\n\n", "tags": ["derivatives", "dfdx", "mip"], "likes": 12, "viewed": 1201, "published": 3, "date": "1617902931", "time_retrieved": "2024-07-30T19:27:51.248884", "image_code": "// Seam Correction for atan() Based Procedural UVs\n\n// When using atan() for uvs, there's a hard discontinuity at some point where the value\n// jumps from 0.0 to 1.0 in one pixel. This discontinuity causes the GPU to think it needs\n// to show the entire texture between those two pixels, and thus drops to the smallest mip\n// level. This causes a visible seam along the discontinuity. Marco Tarini proposed a\n// method that solved this for a similar problem case of UV mapping on a mesh with no \n// vertex seam, and instead using two offset UV sets with the discontinuity in different\n// places. Then pick the UV set with the smallest derivatives using fwidth().\n//\n// http://vcg.isti.cnr.it/~tarini/no-seams/\n// \n// This method works well, but makes two assumptions about how derivatives work.\n//\n//   A) It assumes the fwidth() function is returning coarse derivatives that are constant\n//     for the entire pixel quad.\n//\n//   B) It assumes the hardware's mip level calculation also uses those same derivatives.\n//\n// One or both of these assumptions are no longer true for modern GPUs.\n//\n// =======================================================================================\n//\n// This shader shows off Tarini's original fwidth() based approach, as well as two\n// alternatives that make use of in quad communication.\n//\n// =======================================================================================\n//\n// 0 - No correction, the seam in all it's glory.\n//\n//\n// 1 - Tarini's original fwidth() based method\n//\n// This works on desktop Nvidia and AMD GPUs when running WebGL via ANGLE. Direct3D spec\n// requires base derivative functions to use coarse derivatives, and Nvidia & AMD GPUs\n// both currently use coarse derivatives for the mip level calculation.\n//\n// This will still show a seam on any device that's running WebGL natively and which\n// defaults to fine derivatives. This means it fails on most modern GPUs, desktop or mobile.\n//\n//\n// 2 - emulated coarse derivatives\n//\n// Uses in quad communication to emulate coarse derivatives. Works regardless of if the\n// dFdx/dFdy functions default to coarse or fine derivatives, but still requires the GPU\n// to use coarse derivatives for the mip level calculation.\n//\n// Works on desktop Nvidia and AMD GPUs when running WebGL natively or via ANGLE. May work\n// on some mobile GPUs if they still use coarse derivatives for mip level calculation.\n//\n// This can still show a seam on any GPUs that don't use coarse derivatives for the mip\n// level calculation. This includes Apple's Bionic & M1 GPUs, Mali GPUs, and possibly\n// others.\n//\n//\n// 3 - full quad derivatives\n//\n// Uses in quad communication to get the derivatives for all 4 pixels in the pixel quad.\n// Then selects the worst x and y derivatives for the entire quad and uses those for the\n// fwidth() equivalent. Should work on all known hardware.\n// \n// Could show seams if in shader derivatives default to coarse but the mip level\n// calculation uses the full quad. Luckily I don't yet know of any hardware that does.\n//\n// edit: Oh no! Mali defaults to coarse shader derivatives but uses full quad derivs for\n// mip calculations! None of these will work on Mali GPUs.\n\n#define PI 3.141592\n#define TAU (PI * 2.0)\n\n// #define FORCE_METHOD 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 screen_uv = fragCoord/iResolution.xy;\n    \n    screen_uv -= 0.5;\n        \n    vec2 pos = screen_uv * 2.0;\n    #if !defined(FORCE_METHOD)\n    pos.x += screen_uv.x > 0.0 ? -0.5 : 0.5;\n    pos.y += screen_uv.y > 0.0 ? -0.5 : 0.5;\n    #endif\n    \n    if (iResolution.x > iResolution.y)\n        pos.x *= iResolution.x / iResolution.y;\n    else\n        pos.y *= iResolution.y / iResolution.x;\n        \n    float angle = fract(iTime * 0.1) * TAU;\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rotMatrix = mat2(c, -s, s, c);\n    pos = rotMatrix * pos;\n    \n    // -0.5 to 0.5 range\n    float phi = atan(pos.y, pos.x) / TAU;\n    // 0.0 to 1.0 range\n    float phi_frac = fract(phi);\n    \n    // scaled and offset to where the artifact is most obvious\n    float theta = length(pos) * 0.3 + 0.8; \n    \n    // get derivatives for phi and phi_frac\n    float phi_dx = dFdx(phi);\n    float phi_dy = dFdy(phi);\n\n    float phi_frac_dx = dFdx(phi_frac);\n    float phi_frac_dy = dFdy(phi_frac);\n        \n    // in quad position\n    ivec2 pixel_quad_pos = ivec2(fragCoord) % 2;\n    \n    // derivative direction within the quad\n    vec2 quad_dir = vec2(pixel_quad_pos) * 2.0 - 1.0;\n\n    // get derivatives the \"other\" pixel column / row in the quad\n    float phi_dxy = dFdx(phi - phi_dy * quad_dir.y);\n    float phi_dyx = dFdy(phi - phi_dx * quad_dir.x);\n\n    float phi_frac_dxy = dFdx(phi_frac - phi_frac_dy * quad_dir.y);\n    float phi_frac_dyx = dFdy(phi_frac - phi_frac_dx * quad_dir.x);\n    \n    #if !defined(FORCE_METHOD)\n    int method = (screen_uv.x > 0.0 ? 1 : 0) + (screen_uv.y < 0.0 ? 2 : 0);\n    #else\n    int method = FORCE_METHOD;\n    #endif\n    \n    vec2 uv;\n    if (method == 0)\n    {\n        // do nothing special, just show the seam in all its glory\n        \n        uv = vec2(phi, theta);\n    }\n    else if (method == 1)\n    {\n        // tarini's original fwidth based approach\n        \n        float phi_fw = fwidth(phi);\n        float phi_frac_fw = fwidth(phi_frac);\n    \n        uv = vec2(\n            phi_fw - 0.0001 < phi_frac_fw ? phi : phi_frac,\n            theta\n        );\n    }\n    else if (method == 2)\n    {\n        // coarse derivative emulation using in quad communication\n        \n        // check which column / row in the quad this is and use alternate\n        // derivatives if it's not the column / row coarse would use\n        if (pixel_quad_pos.x == 1)\n        {\n            phi_dy = phi_dyx;\n            phi_frac_dy = phi_frac_dyx;\n        }\n        if (pixel_quad_pos.y == 1)\n        {\n            phi_dx = phi_dxy;\n            phi_frac_dx = phi_frac_dxy;\n        }\n        \n        // fwidth using emulated coarse derivatives\n        float phi_fw = abs(phi_dx) + abs(phi_dy);\n        float phi_frac_fw = abs(phi_frac_dx) + abs(phi_frac_dy);\n    \n        uv = vec2(\n            phi_fw - 0.0001 < phi_frac_fw ? phi : phi_frac,\n            theta\n        );\n    }\n    else if (method == 3)\n    {\n        // get worst pair of x & y derivatives from the full quad using in quad communication\n    \n        // fwidth using worst derivatives in the quad\n        float phi_fw = max(abs(phi_dx), abs(phi_dxy))\n                     + max(abs(phi_dy), abs(phi_dyx));\n            \n        float phi_frac_fw = max(abs(phi_frac_dx), abs(phi_frac_dxy))\n                          + max(abs(phi_frac_dy), abs(phi_frac_dyx));\n    \n        uv = vec2(\n            phi_fw - 0.0001 < phi_frac_fw ? phi : phi_frac,\n            theta\n        );\n    }\n    \n    fragColor = texture(iChannel0, uv).rrrr;\n    \n    // quadrant number\n    #if defined(FORCE_METHOD)\n    vec2 num_uv = fragCoord/iResolution.xy * 20.0;\n    #else\n    vec2 num_uv = fract(fragCoord/iResolution.xy * 2.0) * 10.0;\n    #endif\n    if (iResolution.x > iResolution.y)\n        num_uv.x *= iResolution.x / iResolution.y;\n    else\n        num_uv.y *= iResolution.y / iResolution.x;\n    num_uv += vec2(0.8, -0.25);\n    \n    float num = PrintValue(num_uv, float(method), 1., 0.);\n    fragColor += num;\n    \n    #if !defined(FORCE_METHOD)\n    // quadrant lines    \n    fragColor *= smoothstep( 0.5, 2.0, abs(fragCoord.x - iResolution.x * 0.5));\n    fragColor *= smoothstep( 0.5, 2.0, abs(fragCoord.y - iResolution.y * 0.5));\n    #endif\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3379, 3379, 3436, 3486, 7703]], "test": "untested"}
{"id": "fs2GRd", "name": "Spectral 2D path-tracing test", "author": "clepirelli", "description": "Made for the willstall challenge - 1 shader a week keeps the depression meek\n\nSpectral 2D path-tracer for circles and AABBs - press space to reset the progressive rendering\n\nThank you again to Nameless#1608 on discord for all his help, IOU", "tags": ["2d", "pathtracing", "spectral"], "likes": 18, "viewed": 844, "published": 3, "date": "1617902872", "time_retrieved": "2024-07-30T19:27:52.146484", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 textureColor = texture(iChannel0, uv).xyz;\n    \n    //from: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n    textureColor *= 12.0;\n    vec3 x = max(vec3(.0), textureColor-.004);\n    vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n    fragColor = vec4(min(retColor, 1.0), 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ---- structs ----\nstruct Ray\n{\n    vec2 origin;\n    vec2 direction;\n};\n\nconst int lambertian = 0; //color is attenuation\nconst int light = 1; //color is emission\nconst int dielectric = 2; //color is attenuation\n\nstruct Material\n{\n    int type;\n    vec3 color;\n};\n\nstruct Circle\n{\n    vec2 origin;\n    float radius;\n    Material material;\n};\n\nstruct AABB\n{\n    vec2 minimum;\n    vec2 maximum;\n    Material material;\n};\n\nstruct IntersectionQuery\n{\n    bool result;\n    bool inside;\n    float nearest;\n    vec2 normal;\n    vec2 hit;\n    Material material;\n};\n\n// ---- materials ----\nvec3 saturate(vec3 a){ return clamp(a, .0, 1.0); }\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = saturate(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 applyMaterial(vec3 color, Material material)\n{\n    switch(material.type)\n    {\n        case dielectric:\n        case lambertian:\n            return color * material.color;\n        case light:\n            return material.color;   \n    }\n    return vec3(.0);\n}\n\n\n// ---- intersection queries ----\n\nvec2 pointOnRay(Ray ray, float dist)\n{\n    return ray.origin + ray.direction * dist;\n}\n\nconst IntersectionQuery miss = IntersectionQuery(false, false, -1000.0, vec2(.0), vec2(.0), Material(200, vec3(.0)));\n\nIntersectionQuery circleIntersection(Ray ray, Circle circle)\n{\n    float radius2 = circle.radius*circle.radius;\n    vec2 L = circle.origin - ray.origin; \n    float tca = dot(L, ray.direction); \n    float d2 = dot(L,L) - tca * tca; \n    if (d2 > radius2) return miss;\n    float thc = sqrt(radius2 - d2);\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    float nearest = min(t0, t1);\n    float nextNearest = max(t0, t1);\n    \n    bool inside = nearest < .0 && nextNearest > .0;\n    if(nearest < .0) \n    {\n        nearest = nextNearest;\n    }\n    \n    vec2 hit = pointOnRay(ray, nearest);\n    vec2 normal = (circle.origin - hit)/circle.radius;\n    return IntersectionQuery(nextNearest > .0, inside, nearest, inside ? -normal : normal, hit, circle.material);\n}\n\nIntersectionQuery aabbIntersection(Ray ray, AABB aabb)\n{\n    //from: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\n    bool xSign = ray.direction.x >= 0.;\n    bool ySign = ray.direction.y >= 0.;\n    vec2 inverseDir = 1.0/ray.direction;\n    \n    float nearest = ((xSign ? aabb.minimum : aabb.maximum).x - ray.origin.x) * inverseDir.x; \n    float nextNearest = ((xSign ? aabb.maximum : aabb.minimum).x - ray.origin.x) * inverseDir.x; \n    float nearestY = ((ySign ? aabb.minimum : aabb.maximum).y - ray.origin.y) * inverseDir.y; \n    float nextNearestY = ((ySign ? aabb.maximum : aabb.minimum).y - ray.origin.y) * inverseDir.y; \n \n    if (nearest > nextNearestY || nearestY > nextNearest) \n        return miss;\n    \n    nearest = max(nearestY, nearest);\n    nextNearest = min(nextNearestY, nextNearest);\n    \n    bool inside = nearest < .0 && nextNearest > .0;\n    if(nearest < .0) \n    {\n        nearest = nextNearest;\n    }\n    vec2 hit = pointOnRay(ray, nearest);\n    \n    //from: https://blog.johnnovak.net/2016/10/22/the-nim-raytracer-project-part-4-calculating-box-normals/\n    vec2 c = .5*(aabb.minimum + aabb.maximum);\n    vec2 p = hit - c;\n    vec2 d = .5*(aabb.minimum - aabb.maximum);\n    float bias = 1.0001;\n    vec2 normal = normalize(vec2(ivec2(p/abs(d)*bias)));\n    \n    return IntersectionQuery(nextNearest > .0, inside, nearest, inside ? normal : -normal, hit, aabb.material); \n}\n\n// ---- randomness and ray generation ----\n\nvec2 angleToDirection(float angle)\n{\n    return vec2(sin(angle), cos(angle));\n}\n\nfloat pseudorandScalar(vec2 randseed, vec2 uv,  sampler2D tex, int channel)\n{\n    //blue noise with toroidal shifting\n\treturn fract(texture(tex, uv)[channel] + fract(sin(dot(randseed, vec2(1.0,113.0)))*43758.5453123));\n}\n\nfloat randomRadians(vec2 randseed, vec2 uv,  sampler2D tex)\n{\n    return (pseudorandScalar(randseed, uv, tex, 0)-.5)*2.0*3.14;\n}\n\nvec2 randomDirectionInHemicircle(vec2 direction, vec2 randseed , vec2 uv,  sampler2D tex, int channel) \n{\n    float randomOffset = (pseudorandScalar(randseed, uv, tex, channel))*2.0*3.14;\n    vec2 randomDirection = vec2(sin(randomOffset), cos(randomOffset));\n    return normalize(randomDirection+direction);\n}\n\n//---- boilerplate ----\n\n#define spacePressed(sampler) texelFetch(sampler,ivec2(32, 0), 0).x > 0.0\n\n#define MAIN_FUNCTION(function) \\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\\n{\\\n    vec3 total = vec3(.0);\\\n    /*MSAA*/\\\n    for(int i = 0; i <aa;i++)\\\n    for(int j = 0; j <aa;j++)\\\n    {\\\n    \t/*offset the uv for MSAA*/\\\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\\\n    \tuv.x *= iResolution.x/iResolution.y;\\\n    \tvec2 tempUV = uv;\\\n        total += function(tempUV, fragCoord);\\\n    }\\\n    total /= float(aa*aa);\\\n    /*Output to screen*/\\\n    fragColor = vec4(total,1.0);\\\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //from: https://www.shadertoy.com/view/wlGcD1\n    uint frameCount = floatBitsToUint(texelFetch(iChannel0, ivec2(0,0), 0).x);\n    if(iFrame == 0 || spacePressed(iChannel1))\n    {\n        frameCount = 0u;\n    } else \n    {\n        frameCount = frameCount + 1u;\n    }\n\n    fragColor = vec4(uintBitsToFloat(frameCount));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const int aa = 3;\nconst int maxBounces = 10;\n\nconst int circleAmount = 5;\nCircle circles[circleAmount] = Circle[circleAmount]\n(\n\tCircle(vec2(-.6,  .25),  .2, Material(light, vec3(.2)))\n    ,Circle(vec2( .1,  .1),  .05, Material(dielectric, vec3(1.0, .4, .4)))\n\t,Circle(vec2( .4,  .1),  .10, Material(dielectric, vec3(1.0, 1.0, 1.0)))\n    ,Circle(vec2( .5, -.2),  .05, Material(light, vec3(1.0, .9, .7)*.2))\n    ,Circle(vec2(-.3, .0),  .08, Material(dielectric, vec3(1.0, .7, 1.0)))\n);\n\nconst int aabbAmount = 2;\nAABB aabbs[aabbAmount] = AABB[aabbAmount]\n(\n    AABB(vec2(-.5, -.3), vec2(.0, -.1), Material(dielectric, vec3(1.0, .9, .4)))\n    ,AABB(vec2(-.11, .2), vec2(.0, .3), Material(dielectric, vec3(.7, 1.0, .7)))\n    //,AABB(vec2(-.3, -.3), vec2(.1, .0), Material(dielectric, vec3(1.0, 1.0, 1.0)))\n);\n\nIntersectionQuery traceScene(Ray currentRay)\n{\n    IntersectionQuery finalQuery = miss;\n    for(int i = 0; i < circleAmount; i++)\n    {\n        IntersectionQuery currentQuery = circleIntersection(currentRay, circles[i]);\n        if(!finalQuery.result || (currentQuery.result && currentQuery.nearest < finalQuery.nearest))\n        {\n            finalQuery = currentQuery;\n        }\n    }\n    \n    for(int i = 0; i < aabbAmount; i++)\n    {\n        IntersectionQuery currentQuery = aabbIntersection(currentRay, aabbs[i]);\n        if(!finalQuery.result || (currentQuery.result && currentQuery.nearest < finalQuery.nearest))\n        {\n            finalQuery = currentQuery;\n        }\n    }\n\n    return finalQuery;\n}\n\nRay scatter(IntersectionQuery query, Ray ray, vec2 uv, vec2 seed, int channel, float hue)\n{\n    vec2 direction;\n    vec2 normal = query.normal;\n    switch(query.material.type)\n    {\n        case dielectric:\n            float refractiveIndex = .1+hue;//mix(.0, query.material.other, hue);\n            direction = refract(ray.direction, -normal, refractiveIndex);\n            break;\n        case lambertian:\n            direction = randomDirectionInHemicircle(query.normal, seed, uv, iChannel1, channel);\n            break;\n    }\n    vec2 origin = query.hit+normal*.001;\n    return Ray(origin, direction);\n}\n\nvec3 trace(vec2 uv, float hue)\n{\n    float currentRayAngle = randomRadians(uv+(1.+iTime*.001), uv, iChannel1);\n    Ray currentRay = Ray(uv, angleToDirection(currentRayAngle));\n    \n    IntersectionQuery queries[maxBounces];\n    int queryCount = 0;\n        \n    for(int i = 0; i < maxBounces; i++)\n    {\n        IntersectionQuery query = traceScene(currentRay);\n        queries[queryCount] = query;\n        queryCount++;\n        \n        if(query.result && query.material.type != light)\n        {\n            vec2 seed = uv+cos(iTime)+float(i)*4.1323; //this kinda works, pretty wonky though\n            int channel = int(mod(float(i+1), 3.0));\n            currentRay = scatter(query, currentRay, uv, seed, channel, hue);\n        } else break;\n    }\n    \n    vec3 col = vec3(.0); \n    for(int i = queryCount; i >= 0; i--)\n    {     \n        if(!queries[i].result)\n        {\n            col = vec3(.98, .48, .58)*.005; //ambient color, dawn-ish\n        } else\n        {\n            col = applyMaterial(col, queries[i].material);\n        }\n    }\n    return col;\n}\n\nvec3 outputCol(vec3 thisCol, vec2 fragCoord)\n{\n    uint frame = floatBitsToUint(texelFetch(iChannel2, ivec2(0,0), 0).x);\n    vec3 previousCol = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    return float(frame)/float(frame+1u)*previousCol + 1.0/float(frame+1u)*thisCol;\n}\n\nvec3 BufferB(vec2 uv, vec2 fragCoord)\n{\n    if(iFrame == 0)\n    {\n        return vec3(.0);\n    }\n    float hue = pseudorandScalar(uv+sin(iTime*.01), uv, iChannel1, 0);\n    vec3 hsbCol = trace(uv, hue);\n    \n    return outputCol(hsbCol * hsb2rgb(vec3(hue, .9,.8)), fragCoord);\n}\n\nMAIN_FUNCTION(BufferB)", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2GRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 407]], "test": "untested"}
{"id": "fsjGDy", "name": "Starry night background", "author": "mrange", "description": "License CC0: Starry night background\nCreated for another shader but thought the background could be useful to others so extracted it\n", "tags": ["stars"], "likes": 15, "viewed": 505, "published": 3, "date": "1617901952", "time_retrieved": "2024-07-30T19:27:52.918420", "image_code": "// License CC0: Starry night background\n//  Created for another shader but thought the background could be useful to others so extracted it\n\n// Controls how many layers of stars\n#define LAYERS            5.0\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)           (0.5 + 0.5*cos(x))\n#define TTIME             (TAU*TIME)\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 stars(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  vec3 srd = toSpherical(rd.xzy);\n  \n  const float m = LAYERS;\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = srd.yz+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(srd.y);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*109.0);\n    float h2 = fract(h.x*113.0);\n    float h3 = fract(h.x*127.0);\n\n    vec3 hsv = vec3(fract(0.025-0.4*h1*h1), mix(0.5, 0.125, s), 1.0);\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*hsv2rgb(hsv);\n\n    vec3 ccol = col+ exp(-(2000.0/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    col = h3 < y ? ccol : col;\n  }\n  \n  return col;\n}\n\nvec3 grid(vec3 ro, vec3 rd) {\n  vec3 srd = toSpherical(rd.xzy);\n  \n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/8.0*PI);\n  vec2 pp = srd.yz;\n  vec2 np = mod2(pp, dim);\n\n  vec3 col = vec3(0.0);\n\n  float y = sin(srd.y);\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return 0.25*tanh(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = mix(0.5, 0.25, PCOS(TTIME/120.0*sqrt(3.0)))*vec3(2.0, 0, 0.2)+vec3(0.0, -0.125, 0.0);\n  ro.yx *= ROT(TTIME/120.0*sqrt(0.5));\n  ro.xz *= ROT((TAU*(TIME-14.0)/120.0));\n  vec3 la = vec3(0.0, 0.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  const float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = stars(ro, rd);\n  col += grid(ro, rd);\n  \n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjGDy.jpg", "access": "api", "license": "cc0-1.0", "functions": [[499, 578, 600, 600, 769], [771, 802, 838, 838, 932], [934, 934, 954, 954, 1066], [1068, 1068, 1094, 1094, 1203], [1205, 1205, 1242, 1242, 1494], [1496, 1496, 1526, 1526, 2286], [2288, 2288, 2317, 2317, 2687], [2689, 2689, 2744, 2744, 3357]], "test": "untested"}
{"id": "fd23R3", "name": "fractal interiors", "author": "peabrainiac", "description": "A collection of fractals related to the mandelbrot set, each with their interior colored based on stability. See the image tab for more details.", "tags": ["fractal", "interactive", "zoomable"], "likes": 5, "viewed": 352, "published": 3, "date": "1617901042", "time_retrieved": "2024-07-30T19:27:53.934702", "image_code": "/*\n * A collection of fractals with their interior colored by stability, to show otherwise hidden structures\n * and minibrots and distinguish those stable from chaotic regions.\n * \n * The controls are:\n *  - WASD to move around\n *  - up and down arrow keys to zoom\n *  - E and Q to switch between fractals\n *  - left and right arrow keys to change formula parameters\n *  - R and F to change the iteration count (though be warned, this does not play well together with the coloring method used here)\n * Using any of those will stop the animation and reset the fractal, so you can then start to explore it on your own.\n * \n * The fractals shown here are, in order:\n *  - the mandelbrot set (boring, mainly in here for completeness)\n *  - the moebius mandelbrot set (slightly less boring)\n *  - the mandelbar set (also boring)\n *  - the perpendicular burning ship and related fractals\n *  - the burning ship and related fractals (you start here)\n *  - the buffalo fractal and related fractals\n *  - more to be implemented later...\n * \n * If you want to dig into the code, Buffer A contains the actual fractal-related code,\n * while Buffer B contains all of the controls. This whole piece of code is licensed under the unlicense (see below),\n * so feel free to fork and edit it as you like.\n * \n *  - - - - -\n * \n * This is free and unencumbered software released into the public domain.\n * \n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n * \n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * For more information, please refer to <http://unlicense.org/>.\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float color(vec2 c);\nfloat getMaxEigenvalueAbs(mat2 j);\n\n// formula functions. these all follow the same pattern: position and max iterations in, iterations and jacobian out.\n// specifically, j should indicate how z_{2*iter} reacts to slight changes to z_iter.\n// this information will then be used to estimate how sensitive the orbit is to slight perturbations,\n// and thus whether it belongs to a minibrot or a chaotic region.\nvoid mandelbrot(in vec2 c, in int iter, in float param, out int i, out mat2 j);\nvoid mandelbar(in vec2 c, in int iter, in float param, out int i, out mat2 j);\nvoid moebiusMandelbrot(in vec2 c, in int iter, in float param, out int i, out mat2 j);\nvoid burningShip(in vec2 c, in int iter, in float param, out int i, out mat2 j);\nvoid perpendicularBurningShip(in vec2 c, in int iter, in float param, out int i, out mat2 j);\nvoid buffalo(in vec2 c, in int iter, in float param, out int i, out mat2 j);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    if (texelFetch(iChannel1,ivec2(0),0).x==0.0){\n        // if the update flag in buffer B is not set, simply keep the old value\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    }else{\n        vec3 pos = texelFetch(iChannel1,ivec2(2,0),0).xyz;\n        vec2 c = 5.0*vec2(1.,-1.)*(fragCoord-iResolution.xy*0.5)/length(iResolution);\n        c = c*2.0/pos.z+pos.xy;\n        fragColor = vec4(vec3(color(c)),1.0);\n    }\n}\n\n// computes the brightness the pixel at a given fractal coordinate should have\nfloat color(vec2 c){\n    vec3 config = texelFetch(iChannel1,ivec2(1,0),0).xyz;\n    int formula = int(config.x);\n    float param = config.y;\n    int iter = int(config.z);\n    int i;\n    mat2 j;\n    if (formula==0){\n        mandelbrot(c,iter,param,i,j);\n    }else if (formula==1){\n        moebiusMandelbrot(c,iter,param,i,j);\n    }else if (formula==2){\n        mandelbar(c,iter,param,i,j);\n    }else if (formula==3){\n        perpendicularBurningShip(c,iter,param,i,j);\n    }else if (formula==4){\n        burningShip(c,iter,param,i,j);\n    }else if (formula==5){\n        buffalo(c,iter,param,i,j);\n    }else{\n        //burningShip(c,i,j);\n    }\n    if (i<2*iter){\n        return 0.25*float(i)/float(2*iter);\n    }else{\n        return max(0.25,1.0-0.25*pow(getMaxEigenvalueAbs(j),10.0/float(iter)));\n    }\n}\n\n// returns the absolute value of the larger of the two complex eigenvalues of a given matrix.\nfloat getMaxEigenvalueAbs(mat2 j){\n    float p = -j[0][0]-j[1][1];\n    float q = j[0][0]*j[1][1]-j[0][1]*j[1][0];\n    float rad = p*p*0.25-q;\n    return rad<0.0?sqrt(p*p*0.25-rad):abs(p*0.5)+sqrt(rad);\n}\n\nvoid mandelbrot(in vec2 c, in int iter, in float param, out int i, out mat2 j){\n    vec2 z = vec2(0);\n    for (i=0;i<iter&&dot(z,z)<16.0;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n    }\n    // xdx, xdy, ydx, ydy\n    vec4 d = vec4(1,0,0,1);\n    for (int iter2=2*iter;i<iter2&&dot(z,z)<16.0;i++){\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        d = 2.0*vec4(z.x*d.xy-z.y*d.zw,z.x*d.zw+z.y*d.xy);\n        z = z2;\n    }\n    j = mat2(d.xz,d.yw);\n}\n\nvoid mandelbar(in vec2 c, in int iter, in float param, out int i, out mat2 j){\n    vec2 z = vec2(0);\n    for (i=0;i<iter&&dot(z,z)<16.0;i++){\n        z = vec2(z.x*z.x-z.y*z.y,-2.0*z.x*z.y)+c;\n    }\n    // xdx, xdy, ydx, ydy\n    vec4 d = vec4(1,0,0,1);\n    for (int iter2=2*iter;i<iter2&&dot(z,z)<16.0;i++){\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,-2.0*z.x*z.y)+c;\n        d = 2.0*vec4(z.x*d.xy-z.y*d.zw,-(z.x*d.zw+z.y*d.xy));\n        z = z2;\n    }\n    j = mat2(d.xz,d.yw);\n}\n\nvoid moebiusMandelbrot(in vec2 c, in int iter, in float param, out int i, out mat2 j){\n    vec2 temp = vec2(cos(param),sin(param));\n    mat2 rot = mat2(temp.xy,vec2(-temp.y,temp.x));\n    vec2 z = vec2(0);\n    for (i=0;i<iter&&dot(z,z)<16.0;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        z = rot*z;\n        float sy = sign(abs(z.x)-1.0);\n        z.y *= -sy;\n        z.x -= (sy+1.0)*sign(z.x);\n        z = z*rot;\n    }\n    // xdx, xdy, ydx, ydy\n    vec4 d = vec4(1,0,0,1);\n    for (int iter2=2*iter;i<iter2&&dot(z,z)<16.0;i++){\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        z2 = rot*z2;\n        float sy = sign(abs(z2.x)-1.0);\n        z2.y *= -sy;\n        z2.x -= (sy+1.0)*sign(z2.x);\n        d = 2.0*vec4(z.x*d.xy-z.y*d.zw,-sy*(z.x*d.zw+z.y*d.xy));\n        z = z2*rot;\n    }\n    j = mat2(d.xz,d.yw);\n}\n\nvoid burningShip(in vec2 c, in int iter, in float param, out int i, out mat2 j){\n    vec2 temp = vec2(cos(param),sin(param));\n    mat2 rot = mat2(temp.xy,vec2(-temp.y,temp.x));\n    vec2 z = vec2(0);\n    for (i=0;i<iter&&dot(z,z)<16.0;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        z = abs(rot*z)*rot;\n    }\n    // xdx, xdy, ydx, ydy\n    vec4 d = vec4(1,0,0,1);\n    for (int iter2=2*iter;i<iter2&&dot(z,z)<16.0;i++){\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        z2 = rot*z2;\n        vec2 s = 2.0*sign(z2);\n        d = vec4(s.x*(z.x*d.xy-z.y*d.zw),s.y*(z.x*d.zw+z.y*d.xy));\n        z = abs(z2)*rot;\n    }\n    j = mat2(d.xz,d.yw);\n}\n\nvoid perpendicularBurningShip(in vec2 c, in int iter, in float param, out int i, out mat2 j){\n    vec2 temp = vec2(cos(param),sin(param));\n    mat2 rot = mat2(temp.xy,vec2(-temp.y,temp.x));\n    vec2 z = vec2(0);\n    for (i=0;i<iter&&dot(z,z)<16.0;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        z = rot*z;\n        z.y = abs(z.y);\n        z = z*rot;\n    }\n    // xdx, xdy, ydx, ydy\n    vec4 d = vec4(1,0,0,1);\n    for (int iter2=2*iter;i<iter2&&dot(z,z)<16.0;i++){\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n        z2 = rot*z2;\n        vec2 s = 2.0*vec2(1.0,sign(z2.y));\n        d = vec4(s.x*(z.x*d.xy-z.y*d.zw),s.y*(z.x*d.zw+z.y*d.xy));\n        z = vec2(z2.x,abs(z2.y))*rot;\n    }\n    j = mat2(d.xz,d.yw);\n}\n\n\nvoid buffalo(in vec2 c, in int iter, in float param, out int i, out mat2 j){\n    vec2 temp = vec2(cos(param),sin(param));\n    mat2 rot = mat2(temp.xy,vec2(-temp.y,temp.x));\n    vec2 z = vec2(0);\n    for (i=0;i<iter&&dot(z,z)<16.0;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y);\n        z = abs(rot*z)*rot+c;\n    }\n    // xdx, xdy, ydx, ydy\n    vec4 d = vec4(1,0,0,1);\n    for (int iter2=2*iter;i<iter2&&dot(z,z)<16.0;i++){\n        vec2 z2 = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y);\n        z2 = rot*z2;\n        vec2 s = 2.0*sign(z2);\n        d = vec4(s.x*(z.x*d.xy-z.y*d.zw),s.y*(z.x*d.zw+z.y*d.xy));\n        z = abs(z2)*rot+c;\n    }\n    j = mat2(d.xz,d.yw);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n * stored values, in order:\n *  - refresh flag, animation flag, reset flag\n *  - formula id, formula param, iterations\n *  - X, Y, zoom\n */\nconst vec3[] defaultValues = vec3[](vec3(1.0,1.0,0.0),vec3(4.0,0.0,50.0),vec3(0.0,0.0,1.0));\n\nfloat keysDown();\nint keyState(int key);\nivec4 keyStates(int key1, int key2, int key3, int key4);\nint keyPressed(int key);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 p = ivec2(fragCoord);\n    if (p.y>0||p.x>=3){\n        discard;\n    }else if (iFrame==0){\n        fragColor = vec4(defaultValues[p.x],1.0);\n    }else{\n        fragColor = texelFetch(iChannel0,p,0);\n        if (p==ivec2(0)){\n            // flag updates\n            float keys = keysDown();\n            if (fragColor.y==1.0){\n                if (keys/*+iMouse.x+iMouse.y*/>0.0){\n                    // animation end because of user input\n                    fragColor.xyz = vec3(1.0,0.0,1.0);\n                }\n            }else{\n                //refresh flag update\n                fragColor.x = min(1.0,keys+step(mod(float(iFrame),30.0),0.0));\n                fragColor.z = 0.0;\n            }\n        }else if(p==ivec2(1,0)){\n            // formula & iteration changes\n            vec3 flags = texelFetch(iChannel0,ivec2(0),0).xyz;\n            fragColor.x = mod(fragColor.x+float(keyPressed(KEY_E)-keyPressed(KEY_Q)),6.0);\n            if (flags.y==1.0){\n                // animation\n                fragColor.y = 0.15*iTime*iTime/(iTime+2.0);\n            }else{\n                if (flags.z==1.0){\n                    fragColor.y = 0.0;\n                }\n                // normal controls\n                float zoom = texelFetch(iChannel0,ivec2(2,0),0).z;\n                float paramChange = iTimeDelta/zoom*float(keyState(KEY_RIGHT)-keyState(KEY_LEFT));\n                fragColor.y = mod(fragColor.y+paramChange,2.0*PI);\n                fragColor.z += min(100.0,fragColor.z*(pow(2.0,iTimeDelta*float(keyState(KEY_R)-keyState(KEY_F)))-1.0));\n            }\n        }else if(p==ivec2(2,0)){\n            // zoom & position changes\n            vec3 flags = texelFetch(iChannel0,ivec2(0),0).xyz;\n            if (flags.y==1.0){\n                // animation\n                float theta = 0.3*iTime*iTime/(iTime+2.0);\n                float a = 0.5*theta-0.25*PI;\n                a = cos(a-0.5*sin(a));\n                float b = 1.0-abs(a);\n                b = b*b;\n                a = sign(a)*(1.0-b*b*b*b*b);\n                a = 0.5+0.5*a;\n                fragColor.xy = (0.625+a*0.125)*vec2(-sin(theta),-cos(theta))+vec2((a-1.0)*0.125,0.0);\n                fragColor.z = (3.0-2.0*a)*(1.0+3.0*(iTime*iTime)/((iTime*iTime)+5.0));\n            }else{\n                if (flags.z==1.0){\n                    fragColor.xyz = vec3(-0.5,-0.5,2.0);\n                }\n                // normal controls\n                fragColor.xy -= 2.0*iTimeDelta*vec2(float(keyState(KEY_A)-keyState(KEY_D)),float(keyState(KEY_W)-keyState(KEY_S)))/fragColor.z;\n                float zoomChange = iTimeDelta*float(keyState(KEY_UP)-keyState(KEY_DOWN));\n                fragColor.z *= pow(2.0,zoomChange);\n            }\n        }\n    }\n}\n\nfloat keysDown(){\n    float temp = dot(vec4(keyStates(KEY_UP,KEY_RIGHT,KEY_DOWN,KEY_LEFT)),vec4(1.0));\n    temp += dot(vec4(keyStates(KEY_W,KEY_A,KEY_S,KEY_D)),vec4(1.0));\n    temp += dot(vec4(keyStates(KEY_Q,KEY_E,KEY_R,KEY_F)),vec4(1.0));\n    return temp;\n}\n\nint keyState(int key){\n    return int(texelFetch(iChannel1,ivec2(key,0),0).x);\n}\n\nivec4 keyStates(int key1, int key2, int key3, int key4){\n    return ivec4(keyState(key1),keyState(key2),keyState(key3),keyState(key4));\n}\n\nint keyPressed(int key){\n    return int(texelFetch(iChannel1,ivec2(key,1),0).x);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_E = 69; // nice.\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_F = 70;\n\nconst float PI = 3.14159265358979323846264;\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd23R3.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[0, 2597, 2651, 2651, 2711]], "test": "untested"}
{"id": "sdBGzt", "name": "Zi7ar21's Path-Tracer", "author": "Zi7ar21", "description": "I have volumes and solids at the same time now! I guess I should keep this path-tracer and update it with new features over time. Leave a comment if you want to be notified about changes!", "tags": ["raymarching", "ray", "raymarch", "raymarched", "volumetric", "raymarcher", "pathtrace", "pathtracing", "pathtracer", "volumetrics", "pathtraced"], "likes": 21, "viewed": 559, "published": 3, "date": "1617898576", "time_retrieved": "2024-07-30T19:27:54.906105", "image_code": "// ####### Zi7ar21's Path-Tracer #######\n// Created April 8th, 2021\n// Last Updated: April 11th, 2021 at 19:35 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/sdBGzt\n\n/* This is a Path-Tracer that aims to be unbiased and somewhat fast. */\n\n// Check out my Friends:\n// LoicVDB\n// https://www.shadertoy.com/user/loicvdb\n// Michael0884\n// https://www.shadertoy.com/user/michael0884\n\n// Output the Image to the Screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get the Rendered Image\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n    // HDR Tonemapping\n    color = tonemap(color);\n\n    // Output the Image to the Screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ##### PARAMETERS #####\n// Image Gamma (Preview Only)\n#define gamma 2.2\n\n// Sensitivity of the Mouse Controls\n// A higher value increases how much the mouse controls react to movement\n#define mousesensitivity 4.0\n\n// Camera Field-of-View\n// No performance impact, just a \"zoom\" control\n#define camfov 1.2\n\n// Path-Tracing Maximum Bounces\n// More bounces increases convergence, but can delay threads if one gets stuck bouncing too long\n#define maxbounces 8U\n\n// Maximum Ray-Marching Marches\n#define maxmarches 128U\n\n// Maximum Volumetric Steps\n// More allows for the volume ray to travel further, but can delay threads if one gets stuck bouncing too long\n#define maxvolumemarches 1024U\n\n// Collision Distance\n// Smaller allows for more precise Ray-Marched surfaces, but runs slower\n#define collisiondist 1e-4\n\n// Maximum Distance from the Camera\n// A higher value allows surfaces to be rendered from further away, but runs slower\n#define maxdist 32.0\n\n// Maximum Volume Distance from the Camera\n// A higher value allows volumes to be rendered from further away, but runs slower\n#define maxvolumedist 4.0\n\n// Volumetric Ray-Marching Step Size\n// A smaller value is more detailed, but runs slower\n#define stepsize 0.05\n\n// FBM Noise Octaves\n// A higher value is more detailed, but runs slower\n#define octaves 4U\n\n// Timed-Out Samples Behavior\n// If enabled, samples that never reached a light source will not count towards the final image\n#define ignoreTimeout\n\n// Threshold for Large Things\n#define big 1e4\n\n// ##### CONSTANTS #####\n#define resolution iResolution\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n\n// ##### COLOR MANAGEMENT #####\nvec3 tonemap(vec3 color){\n    return pow(color/(color+1.0), vec3(1.0/gamma));\n}\n\n// ##### CUSTOM DATATYPES #####\n// Material Properties\nstruct material{\n    vec3 albedo;\n    vec3 normal;\n    float rough;\n};\n\n// ##### NOISE #####\n// Dave_Hoskins hash33: https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3){\n\tp3 = fract(p3*vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n// My very own Worley Noise Implementation, drastically improved by LoicVDB\n// He managed to remove artifacts from it\nfloat worley(vec3 coord){\n    vec3 cell = floor(coord);\n    float mindist = 100.0;\n    for(int z = -1; z <= 1; z++){\n    for(int y = -1; y <= 1; y++){\n    for(int x = -1; x <= 1; x++){\n        vec3 ncell = cell+vec3(x, y, z);\n        vec3 point = ncell+hash(ncell);\n        mindist = min(dot(coord-point, coord-point), mindist);\n    }\n    }\n    }\n    return sqrt(mindist);\n}\n\n// Fractal Brownian Motion (FBM) Noise\nfloat fbmWorley(vec3 pos){\n    // Set-Up Variables\n    float value = 0.0;\n    float scale = 1.0;\n    float atten = 0.5;\n\n    // Add Octaves\n    for(uint i = 0U; i < octaves; i++){\n        // Add the Octave to the Sum\n        value += worley(pos*scale)*atten;\n\n        // Scale the Next Octave\n        scale *= 2.5;\n\n        // Decrease the Effect of the Next Octave\n        atten *= 0.5;\n    }\n\n    // Return the Value\n    return value;\n}\n\n// ##### RNG #####\n// All of these are from Michael0884\n// https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = uint(resolution.x*resolution.y)*uint(iFrame)+uint(gl_FragCoord.x+gl_FragCoord.y*resolution.x);\n\n// PCG RNG\nvoid pcg(){\n    uint state = ns*747796405U+2891336453U;\n    uint word = ((state >> ((state >> 28U) + 4U)) ^ state)*277803737U;\n    ns = (word >> 22U) ^ word;\n}\n\n// Random Floating-Point Numbers\nfloat rand(){pcg(); return float(ns)/float(0xffffffffU);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x   ))*vec2(cos(twopi*Z.y), sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy ))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}\n\n// Uniform Random\nvec3 urand3(){vec4 Z = rand4(); return normalize(sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w)));}", "buffer_a_code": "// ##### DISTANCE ESTIMATORS #####\nfloat mandelbulb(in vec3 pos, out vec3 orbitTrap){\n    const float scale = 1.8;\n    pos *= scale;\n    pos = pos.xzy;\n    const float power = 8.0;\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    orbitTrap = vec3(1.0);\n\tfor(uint i = 0U; i < 4U; i++){\n\t\tr = length(z);\n\t\tif(r > 4.0){break;}\n        orbitTrap = min(orbitTrap, abs(z));\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y, z.x);\n\t\tdr = (r*r*r*r*r*r*r)/*pow(r, power-1.0)*/*power*dr+1.0;\n\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = r*r*r*r*r*r*r*r;//pow(r, power); // Power is slow\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\n\t\t// Convert back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn (0.5*log(r)*r/dr)/scale;\n}\n\n// Tetrahedron Method Normals\nvec3 mandelbulbNormal(vec3 pos){\n    vec3 lmao = vec3(0.0);\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy*mandelbulb(pos+k.xyy*collisiondist, lmao)+\n                     k.yyx*mandelbulb(pos+k.yyx*collisiondist, lmao)+\n                     k.yxy*mandelbulb(pos+k.yxy*collisiondist, lmao)+\n                     k.xxx*mandelbulb(pos+k.xxx*collisiondist, lmao));\n}\n\n// Scene Distance Estimator\nfloat de(vec3 pos, out material materialProperties){\n    float de0 = mandelbulb(pos, materialProperties.albedo);\n    materialProperties.normal = mandelbulbNormal(pos);\n    materialProperties.rough  = 0.05;\n    return de0;\n}\n\n// ##### INTERSECTION FUNCTIONS #####\n// https://iquilezles.org/articles/intersectors\n// Sphere Intersection Function\nfloat sphere(vec3 raydir, vec3 rayori, vec3 sphpos, float sphrad){\n    vec3 oc = rayori-sphpos;\n    float b = dot(oc, raydir);\n    float c = dot(oc, oc)-sphrad*sphrad;\n    float h = b*b-c;\n    if(h < 0.0){return -1.0;} // No Intersection\n    return -b-sqrt(h);\n}\n\n// Plane Intersection Function (from LoicVDB)\nfloat plane(vec3 raydir, vec3 rayori, vec3 point, vec3 norm){\n    float normdotp = dot(raydir, norm);\n    if(normdotp >= 0.0){return -1.0;}\n    return dot(point-rayori, norm)/normdotp;\n}\n\n// Scene Intersection Function\nfloat intersect(vec3 raydir, vec3 rayori, out material materialProperties){\n    const vec3 spherepos = vec3(0.0, 0.5, 0.0);\n\n    // Compute Distance Estimator Intersections\n    float rayLength = 0.0;\n    float intersection0 = -1.0;\n    for(uint i = 0U; i < maxmarches; i++){\n        if(rayLength > maxdist){\n            break;\n        }\n        float distanceEstimate = de(rayori+(raydir*rayLength), materialProperties);\n        if(distanceEstimate < collisiondist){\n            intersection0 = rayLength;\n            break;\n        }\n        rayLength += distanceEstimate;\n    }\n\n    // Compute the rest of the Intersections\n    float intersection1 = plane (raydir, rayori, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    float intersection2 = sphere(raydir, rayori, spherepos, 0.25);\n\n    // Eliminate Non-Intersections\n    intersection0 = intersection0 <= 0.0 ? big : intersection0;\n    intersection1 = intersection1 <= 0.0 ? big : intersection1;\n    intersection2 = intersection2 <= 0.0 ? big : intersection2;\n\n    // Find the closest object\n    float minimum = min(intersection0, min(intersection1, intersection2));\n    if(minimum >= big){return -1.0;}\n\n    // Find the Normal and Intersection of the Nearest Object\n    if(minimum == intersection0){\n        return intersection0;\n    }\n\n    if(minimum == intersection1){\n        materialProperties.albedo = vec3(0.4, 0.6, 0.8);\n        materialProperties.normal = vec3(0.0, 1.0, 0.0);\n        materialProperties.rough = 1.0;\n        return intersection1;\n    }\n\n    if(minimum == intersection2){\n        materialProperties.albedo = vec3(0.8, 0.6, 0.4);\n        materialProperties.normal = normalize((rayori+raydir*intersection2)-spherepos);\n        materialProperties.rough  = 0.1;\n        return intersection2;\n    }\n\n    // NULL Object (just to be safe)\n    materialProperties.albedo = vec3(0.0);\n    materialProperties.normal = vec3(0.0);\n    materialProperties.rough  = 0.0;\n    return -1.0;\n}\n\n// ##### VOLUMETRIC DENSITY FUNCTIONS #####\n// Volumetric Density Function\nfloat volume(in vec3 pos, out vec3 color){\n    color = vec3(0.8);\n\n    // If the position is far from the origin, skip sampling noise (performance increase)\n    //if(length(pos) > 0.6){return 0.0;}\n    if(length(pos*vec3(0.8, 0.9, 0.8)) > 0.7){return 0.0;}\n\n    // Return Noise\n    //if(mandelbulb((pos-vec3(0.0, -0.6, 0.0)).xzy, color) < 0.0){color *= 4.0; return 128.0;}\n    return max((1.0-fbmWorley(pos*2.0))-length(pos*vec3(0.8, 1.0, 0.8)), 0.0)*1024.0;\n    return 0.0;\n}\n\n// ##### RENDERING #####\n// Color of the Sky\nvec3 skyColor(vec3 dir){\n    // Attempt at recovering dynamic range\n    return pow(texture(iChannel1, normalize(nrand3(0.02, dir))).rgb, vec3(2.2));\n\n    // Original Skybox\n    //return texture(iChannel1, normalize(nrand3(0.01, dir))).rgb;\n}\n\n// Path-Tracing\nvec3 pathtrace(vec3 raydir, vec3 rayori){\n    // Set-Up Variables\n    vec3 raypos = rayori, attenuation = vec3(1.0), volumeColor;\n    material materialProperties;\n    for(uint bounces = 0U; bounces < maxbounces; bounces++){\n        // Calculate the Intersection of the Scene\n        float intersection = intersect(raydir, raypos, materialProperties);\n        float rayLength = stepsize*rand();\n        bool hitVolume = false;\n\n        // Volumetric Ray-Marching\n        for(uint marches; marches < maxmarches; marches++){\n            float density = volume(raypos+(raydir*rayLength), volumeColor);\n            float absorbance = exp(-density*stepsize);\n            if(absorbance < rand()){\n                hitVolume = true;\n                break;\n            }\n            rayLength += stepsize;\n            if((length(raypos+(raydir*rayLength)) > maxdist) || (rayLength > intersection && intersection > 0.0)){break;}\n        }\n\n        // Check if the Ray hit the Volume\n        if(hitVolume){\n            raypos += raydir*rayLength;\n            attenuation *= clamp(volumeColor, 0.0, 1.0);\n            raydir = urand3();\n        }\n\n        // If the Ray didn't Hit the Volume...\n        else{\n            // If it also didn't hit the scene, then it has reached the background\n            if(intersection < 0.0){\n                // Final Image\n                return attenuation*skyColor(raydir);\n\n                // Direct Lighting\n                //return bounces <= 1U ? attenuation*skyColor(raydir) : vec3(0.0);\n\n                // Indirect Lighting\n                //return bounces > 1U ? attenuation*skyColor(raydir) : vec3(0.0);\n            }\n\n            // Otherwise, it reaches the surface of the scene\n            raypos += raydir*intersection+materialProperties.normal*1e-4;\n\n            // Compute Absorbed Light\n            attenuation *= clamp(materialProperties.albedo, 0.0, 1.0);\n\n            // Compute Ray Direction after Bouncing\n            raydir = reflect(raydir, normalize(nrand3(materialProperties.rough, materialProperties.normal)));\n        }\n    }\n\n    // The Ray Took too Long\n    return vec3(-1.0);\n    //return vec3(0.0);\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    fragColor = iFrame != 0 ? texelFetch(iChannel0, ivec2(fragCoord), 0) : vec4(0.0);\n    //fragColor = iMouse.z > 0.0 ? fragColor = vec4(0.0) : fragColor;\n\n    // Initialize Random Number Generator\n    INIT_RNG;\n\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(nrand2(0.5, gl_FragCoord.xy)-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Mouse Controls\n    vec2 mouse = vec2(0.0, 0.0);\n    //vec2 mouse = mousesensitivity*(iMouse.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Target and Camera Position\n    vec3 camtarget = vec3(0.0, 0.5, 0.0);\n    //vec3 campos = vec3(-sin(mouse.x)*2.0, 0.0, -cos(mouse.x)*2.0);\n    vec3 campos = vec3(0.25, 0.25, -2.0);\n\n    // Calculate the Direction of the Ray\n    vec3 targetdir = normalize(camtarget-campos);\n    vec3 left = cross(targetdir, vec3(0.0, 0.5, 0.0));\n    vec3 up = cross(left, targetdir);\n    mat3 rotmat = mat3(left, up, targetdir);\n    vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render the Frame\n    vec3 color = pathtrace(raydir, campos)*2.0;\n\n    #ifdef ignoreTimeout\n    // Output the Rendered Frame\n    fragColor += (any(lessThan(color, vec3(0.0))) || any(isnan(color)) || any(isinf(color))) ? vec4(0.0) : vec4(color, 1.0);\n    #else\n    // Discard Glitchy Samples\n    color = (any(isnan(color)) || any(isinf(color))) ? vec3(0.0) : color;\n    \n    // Output the Rendered Frame\n    fragColor += vec4(max(color, 0.0), 1.0);\n    #endif\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ##### IMAGE EXPORT #####\n// Output the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get the Rendered Frame\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Convert Frame to Final Image\n    vec3 color = texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a;\n\n    // Output the Image (Linear Color Space)\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 531, 585, 615, 807]], "test": "untested"}
{"id": "7sS3Dy", "name": "The Monolith, take II", "author": "mrange", "description": "License CC0: The Monolith, take II\nResult of messing around with refractions and gas giants when needing a break\n", "tags": ["3d", "scifi"], "likes": 10, "viewed": 349, "published": 3, "date": "1617884629", "time_retrieved": "2024-07-30T19:27:55.995194", "image_code": "// License CC0: The Monolith, take II\n//  Result of messing around with refractions and gas giants when needing a break\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)             dot(x, x)\n#define PSIN(x)           (0.5 + 0.5*sin(x))\n#define PCOS(x)           (0.5 + 0.5*cos(x))\n#define TTIME             (TAU*TIME)\n\nconst float miss          = 1E6;\nconst float refrIndex     = 0.8;\nconst vec3  lightPos      = 200.0*vec3(1.5, 2.0, 1.0);\n\nconst vec3 skyCol1        = vec3(0.2, 0.4, 0.6);\nconst vec3 skyCol2        = vec3(0.4, 0.7, 1.0);\nconst vec3 sunCol         =  vec3(8.0,7.0,6.0)/8.0;\n\nconst vec3 boxDim         = vec3(1.0, 9.0, 4.0)/18.0;\nconst vec4 plane          = vec4(vec3(0.0, 1.0, 0.0), 0.5);\n\nconst vec4  s_giant     = vec4(vec3(-100.0, -45.0, -50.0), 40.0);\nconst vec4  s_miniGiant = vec4(vec3(0.0), 0.4);\nconst vec4  s_planet    = vec4(0.6*vec3(1.0, 0., 0.0), 0.05);\nconst vec3  p_normal    = normalize(vec3(0.4, 1.0, 0.0));\nconst vec4  p_rings     = vec4(p_normal, 0.0);\nconst vec3  innerSunDir = normalize(vec3(-0.0, 0.25, 0.5));\n\nconst mat2  rot0        = ROT(0.0);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec4 alphaBlend(vec4 a, float adist, vec4 b, float bdist, out float dist) {\n  bool t = adist < bdist;\n  vec4 c = alphaBlend(t ? b : a, t ? a : b);\n  dist = min(adist, bdist);\n  return c;\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat hash1(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3 ce = s.xyz;\n    float ra = s.w;\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(miss); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal )  {\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(miss); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n// https://iquilezles.org/articles/intersectors\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\n// https://iquilezles.org/articles/fbm\nfloat fbm(vec2 p) {    \n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n \n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 2; ++x) {\n    f += a*noise(p); \n    p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= 0.5;\n  }\n\n  return f/s;\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.0001, 0);\n  \n  vec3 n;\n  n.x = fbm(p + e.xy) - fbm(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = fbm(p + e.yx) - fbm(p - e.yx);\n  \n  return normalize(n);\n}\n\n// https://iquilezles.org/articles/warp\nfloat warp(vec2 p, float e, float ttime, out vec2 v, out vec2 w) {\n  vec2 vx = vec2(0.0, 0.5)*e;\n  vec2 vy = vec2(3.2, 1.3)*e;\n\n  vec2 wx = vec2(1.7, 9.2)*e;\n  vec2 wy = vec2(8.3, 2.8)*e;\n\n  vx *= ROT(ttime/1000.0);\n  vy *= ROT(ttime/900.0);\n\n  wx *= ROT(ttime/800.0);\n  wy *= ROT(ttime/700.0);\n\n  v = vec2(fbm(p + vx), fbm(p + vy));\n  w = vec2(fbm(p + -3.0*v + wx), fbm(p + 3.0*v + wy));\n  return fbm(p + vec2(2.25, 1.25)*w);\n}\n\nvec4 planetDim(float ttime) {\n  vec4 s_p = s_planet;\n  s_p.xz *= ROT(-(ttime-26.0*TAU)*0.01);\n  return s_p;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec4 stars(vec3 ro, vec3 rd, vec3 nrd) {\n  vec3 col = vec3(0.0);\n  vec3 srd = toSpherical(rd.xzy);\n  \n  const float m = 3.0;\n  float a = 0.0;\n  \n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = srd.yz+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 o  = hash2(np+127.0+i);\n    float y = sin(srd.y);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n    float l2 = L2(pp);\n  \n    float h1 = hash1(np+127.0+i);\n    float h2 = fract(h1*113.0);\n    float h3 = fract(h1*127.0);\n\n    vec3 hsv = vec3(fract(0.025-0.4*h1*h1), mix(0.5, 0.125, s), 1.0);\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*hsv2rgb(hsv);\n  \n    if (h3 < y) {  \n      col += exp(-(4000.0/mix(1.0, 0.2, s))*max(l-0.001, 0.0))*scol;\n    }\n  }\n  \n  return vec4(col, 1.0);\n}\n\nfloat gasGiantShade(vec4 gasGiant, vec3 p) {\n  vec2 rsi = raySphere(p, innerSunDir, gasGiant);\n\n  // Fake, fake softshadows\n  return rsi.x >= 0.0 && rsi.x < miss ? exp(-3.0*(rsi.y - rsi.x)/(rsi.x+0.1)) : 1.0;\n}\n\nfloat planetShade(vec3 p, float ttime) {\n  vec4 s_p = planetDim(ttime);\n  vec2 rsi = raySphere(p, innerSunDir, s_p);\n\n  // Fake, fake softshadows\n  return rsi.x >= 0.0 && rsi.x < miss ? exp(-3.0*(rsi.y - rsi.x)/(rsi.x+0.1)) : 1.0;\n}\n\nvec4 gasGiant(vec4 gasGiant, vec3 ro, vec3 rd, vec3 nrd, vec3 pmod, float ttime, out float dist) {\n  vec2 rsi = raySphere(ro, rd, gasGiant);\n  \n  dist = rsi.x;\n\n  if (rsi.x == miss || rsi.x <= 0.0) {\n    return vec4(0.0);\n  }\n  \n  vec3 pi = (ro + rd*rsi.x)-gasGiant.xyz;\n  vec3 ni = normalize(pi);\n  vec3 ppi = toSpherical(pi.xzy*pmod);\n\n  float rings = 1.0;\n  for (int i = 0; i < 4; ++i) {\n    rings *= sin(-ppi.z*0.825+3.*pi.y/gasGiant.w*sqrt(float(i+3)));\n  }\n\n  rings = tanh_approx((rings)*1.5);\n  float yf = smoothstep(.6, 1.0, abs(pi.y)/gasGiant.w);\n  yf *= yf;\n\n  vec2 v;\n  vec2 w;\n  float h = warp((ppi.zy+vec2(-0.005*ttime, 0.1))*2.0*vec2(1.0, 6.0), rings, ttime, v, w);\n  rings *= rings;\n\n  float ps = planetShade(pi, ttime);\n\n  vec3 col1 = mix(vec3(0.5, 0.25, 0.2), vec3(0.5, 0.15, 0.2), rings);\n  vec3 col2 = mix(vec3(0.3, 0.3, 0.15), vec3(0.3, 0.3, 0.25), rings);\n  \n  float diff = max(dot(ni, innerSunDir), 0.0);\n  vec3 ccol = pow(diff, 0.75)*tanh_approx(pow(abs(h + 0.5), 1.5)) + (length(v)*col1 + length(w)*col2);\n\n  vec3 col = vec3(0.0);\n  col += ccol;\n  col += vec3(0.7, 0.9, 0.8)*0.8*rings;\n  col = max(col, 0.0);\n  col = mix(col, vec3(0.85), yf);\n\n  col *= ps;\n  col *= mix(0.000, 1.0, diff);\n  \n  return vec4(col, smoothstep(0.0, 0.25, (rsi.y - rsi.x)/gasGiant.w));\n}\n\nvec4 planet(vec3 ro, vec3 rd, vec3 nrd, vec3 pmod, float ttime, out float dist) {\n  vec4 s_p = planetDim(ttime);\n  vec2 rsi = raySphere(ro, rd, s_p);\n  \n  dist = rsi.x;\n\n  if (rsi.x == miss || rsi.x <= 0.0) {\n    return vec4(0.0);\n  }\n  \n  vec3 pi = ro + rd*rsi.x;\n  vec3 ni = normalize(pi - s_p.xyz);\n  vec3 ppi = toSpherical((pi-s_p.xyz).zxy*pmod);\n  float h = fbm(ppi.yz*5.0);\n\n  float yf = smoothstep(.6, 1.0, abs(pi.y)/s_planet.w);\n  yf *= yf;\n\n  float gs = gasGiantShade(s_miniGiant, pi);\n\n  float diff = (pow(max(dot(ni, innerSunDir), 0.0), 1.0));\n  vec3 col = mix(0.9*vec3(0.5, 0.5, 0.45), 0.1*vec3(0.5, 0.5, 0.8), pow(h*h, 2.0)*(1.0-yf));\n  col *= mix(0.0125, 1.5, diff);\n  col *= gs;\n  \n  return vec4(col, smoothstep(0.0, 0.5, (rsi.y - rsi.x)/s_planet.w));\n}\n\n\nvec4 rings(vec3 ro, vec3 rd, vec3 nrd, float ttime, out float dist) {\n  float rpi = rayPlane(ro, rd, p_rings);\n\n  dist = rpi;\n  \n  vec3 col = vec3(0.0);\n\n  vec3 pi = ro + rd*rpi;\n  vec3 npi = ro + nrd*rpi;\n  float aa = length(npi-pi);\n\n  vec2 pp = pi.xz;\n  float r = length(pp);\n\n  vec2 npp = npi.xz;\n  float nr = length(npp);\n\n  float d = circle(pp, 0.65);\n  d = abs(d) - 0.06;\n\n  float rings = 1.0;\n  float nrings = 1.0;\n  for (int i = 0; i < 5; ++i) {\n    rings *= sin(100.0*r*sqrt(float(i+3)));\n    nrings *= sin(100.0*nr*sqrt(float(i+3)));\n  }\n\n  float diff = max(dot(p_rings.xyz, innerSunDir), 0.0);\n\n  rings = (max((rings + nrings), 0.0))/2.0;\n\n  float gs = gasGiantShade(s_miniGiant, pi);\n  float ps = planetShade(pi, ttime);\n\n  float i = mix(0.0, 1.0, smoothstep(-aa, aa, -d))*rings;\n\n  vec3 hsv = vec3(0.15+0.1*sin(-50.0*(r+nr)), 0.3*PSIN(200.0*(r+nr)), gs*ps*diff);\n  col += hsv2rgb(hsv);\n  \n  return vec4(col, tanh_approx(i));\n}\n\nvec3 innerRender(vec3 ro, vec3 rd, vec3 nrd, vec3 enor, vec2 bd) {\n  float ttime = TTIME;\n\n  vec3 pmod = mix(vec3(-1.0), vec3(1.0), step(vec3(0.0), enor));\n  ro += mix(0.2, 0.7, fract(enor.x*sqrt(3.0)+enor.y*sqrt(5.0)+enor.z*sqrt(7.0)))*enor/bd.x;\n  float gdist;  \n  vec4 gcol = gasGiant(s_miniGiant, ro, rd, nrd, pmod, ttime, gdist);\n  \n  float pdist;\n  vec4 pcol = planet(ro, rd, nrd, pmod, ttime, pdist);\n\n  float rdist;\n  vec4 rcol = rings(ro, rd, nrd, ttime, rdist);\n\n  float dist = gdist;  \n  vec4 col = gcol;\n\n  col = alphaBlend(col, dist, pcol, pdist, dist);\n  col = alphaBlend(col, dist, rcol, rdist, dist);\n  \n  return col.xyz*col.w;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd, vec3 nrd) {\n  vec3 lightDir = normalize(lightPos - ro);\n  vec3 back = vec3(0.0);\n\n  float gdist;\n  vec3 grd = rd;\n  vec3 gnrd = nrd;\n  grd.y = -grd.y;\n  gnrd.y = -gnrd.y;\n  if (rd.y > 0.0) {\n    vec4 scol = stars(ro, grd, gnrd);\n    vec4 gcol = gasGiant(s_giant, ro, grd, gnrd, vec3(1.0), 2000.0, gdist);\n    vec4 col = alphaBlend(scol, gcol);\n    return col.xyz*col.w;\n  }\n  \n  float tp  = rayPlane(ro, rd, plane);\n\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    vec3 snor;\n    vec2 rb   = rayBox(pos, ld, boxDim, snor);\n    vec3 spos = pos + ld*rb.x;\n    float it  = rb.y - rb.x;\n    float sha = rb.x == miss ? 1.0 : (1.0-tanh_approx(it*6.0/(0.1+rb.x)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec2 pos2 = pos.xz;\n    float h   = fbm(pos2)+1.0;\n    vec3 n    = normal(pos2);\n    float diff= pow(max(dot(n, ld), 0.0), 1.0);\n    vec3 icol = mix(0.5, 1.0, diff*h)*4.0*vec3(0.5, 0.5, 0.45)*sunCol*sha*dot(-rd, nor);\n\n    vec3  pcol= vec3(0.5);\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.0);\n    float f   = exp(-0.05*(max(tp, 0.0)));\n    return mix(back, col , f);\n}\n\n\nvec3 render(vec3 ro, vec3 rd, vec3 nrd) {\n  vec3 skyCol = skyColor(ro, rd, nrd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  vec3 nor;\n  vec2 rb = rayBox(ro, rd, boxDim, nor);  \n\n  if (rb.x < miss) {\n    t = rb.x;\n    float itd = rb.y - rb.x;\n    vec3 pos  = ro + t*rd;\n    vec3 anor = abs(nor);\n    vec2 tp   = anor.x == 1.0 ? pos.yz : (anor.y == 1.0 ? pos.xz : pos.xy);\n    vec2 bd   = anor.x == 1.0 ? boxDim.yz : (anor.y == 1.0 ? boxDim.xz : boxDim.xy);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 nrefr= refract(nrd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 nrefl= reflect(nrd, nor);\n    vec3 rcol = skyColor(pos, refl, nrefl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 3.0));\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 3.0);\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 50.);\n    float lin = mix(0.0, 1.0, dif);\n    vec3 lcol = 2.0*sqrt(sunCol);\n\n    col = innerRender(pos, refr, nrefr, nor, bd);\n\n    vec2 btp = (1.0*bd - abs(tp));\n    float bdd = pmin(btp.x, btp.y, 0.0125);    \n    float bddd = exp(-10000.0*bdd*bdd);\n    col *= 1.0 - bddd;\n\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n    col = mix(col, skyCol, tanh_approx(1E-5/(itd*itd)));\n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec2 np = p + 4.0/RESOLUTION.yy;\n\n  vec3 ro = mix(0.5, 0.25, PCOS(TTIME/120.0*sqrt(3.0)))*vec3(2.0, 0, 0.2)+vec3(0.0, -0.125, 0.0);\n  ro.yx *= ROT(-sin(TTIME/120.0*sqrt(0.5))*0.25);\n  ro.xz *= ROT((TAU*(TIME-14.0)/120.0));\n  vec3 la = vec3(0.0, 0.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = 2.0;\n\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd, nrd);\n  col = mix(vec3(0.0), clamp(col, 0.0, 1.0), smoothstep(5.0, 12.0, TIME));\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [{"id": 26517, "src": "https://soundcloud.com/fantasia-official-music/2001-a-space-odyssey-also", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sS3Dy.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1259, 1259, 1287, 1307, 1383], [1385, 1425, 1464, 1464, 1552], [1554, 1633, 1655, 1655, 1825], [1827, 1827, 1867, 1867, 2026], [2028, 2028, 2103, 2103, 2216], [2218, 2249, 2285, 2285, 2379], [2381, 2381, 2403, 2403, 2470], [2472, 2472, 2492, 2492, 2615], [2617, 2665, 2707, 2707, 2966], [2968, 3016, 3083, 3083, 3561], [3563, 3611, 3654, 3654, 3701], [3703, 3703, 3734, 3734, 3760], [3762, 3762, 3788, 3788, 3897], [3899, 3899, 3920, 3920, 4042], [4044, 4083, 4102, 4102, 4361], [4363, 4363, 4384, 4384, 4568], [4570, 4610, 4676, 4676, 5038], [5040, 5040, 5069, 5069, 5149], [5151, 5151, 5188, 5188, 5440], [5442, 5442, 5482, 5482, 6255], [6257, 6257, 6301, 6301, 6467], [6469, 6469, 6509, 6509, 6701], [6703, 6703, 6801, 6801, 7991], [7993, 7993, 8074, 8074, 8761], [8764, 8764, 8833, 8833, 9704], [9706, 9706, 9772, 9772, 10351], [10353, 10353, 10396, 10396, 11492], [11495, 11495, 11536, 11536, 13003], [13005, 13005, 13060, 13060, 13821]], "test": "untested"}
{"id": "sdS3Wy", "name": "", "author": "penghuailiang", "description": "\nBlog: https://huailiang.github.io/blog/2021/shadertoy/", "tags": ["sin"], "likes": 1, "viewed": 1941, "published": 3, "date": "1617879210", "time_retrieved": "2024-07-30T19:27:56.771119", "image_code": "#define PI 3.1415926\n\n\nfloat Cross(vec2 a, vec2 b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n\nbool SameSide(vec2 A, vec2 B, vec2 C, vec2 P)\n{\n    vec2 AB = B-A;\n    vec2 AC = C-A;\n    vec2 AP = P-A;\n    float c1 = Cross(AB,AC);\n    float c2 = Cross(AB,AP);\n    return c1*c2>=0.;\n}\n\nbool InTiger(vec2 A, vec2 B, vec2 C, vec2 P)\n{\n    return SameSide(A,B,C,P) &&\n        SameSide(B,C,A,P) &&\n        SameSide(C,A,B,P);\n}\n\nvoid DrawStar(vec2 uv, float rot, float r,inout vec4 color)\n{\n    //uv01-> (-1, 1)\n    uv=2.*uv-vec2(1,1);\n    // float r =0.5;\n    float R = 0.98;\n    float delta = 0.2*PI;\n    float offset = 0.05*PI;\n    for(int i=0;i<10;i++)\n    {\n        float v = float(i);\n        float ang = delta*v+rot;\n        vec2 c =vec2(R*cos(ang), R*sin(ang));\n        float an1 = ang-offset ;\n        float an2 = ang+offset ;\n        vec2 c1 = vec2(r*cos(an1),r*sin(an1));\n        vec2 c2 = vec2(r*cos(an2),r*sin(an2));\n        if(InTiger(c,c1,c2,uv))\n            color = vec4(1,0.6,.4,1);\n    }\n    if(length(uv)<r)\n    {\n        color=vec4(.92,.89,.41,1);\n    }\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    fragColor=vec4(.1,0,0.9,1.);\n    \n    DrawStar(uv,iTime, .5+.2*sin(iTime), fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3Wy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 52, 52, 82], [84, 84, 131, 131, 270], [272, 272, 318, 318, 408], [410, 410, 471, 501, 1065], [1067, 1067, 1121, 1121, 1257]], "test": "untested"}
{"id": "ssSGWG", "name": "Coriolis Effect", "author": "oneshade", "description": "A straight path across a turning disc/sphere is curved relative to it.\n[url=https://en.wikipedia.org/wiki/Coriolis_force]https://en.wikipedia.org/wiki/Coriolis_force[/url]", "tags": ["effect", "path", "weather", "curved", "coriolis"], "likes": 8, "viewed": 199, "published": 3, "date": "1617866427", "time_retrieved": "2024-07-30T19:27:57.536074", "image_code": "#define rate 3.14\n#define radius 2.0\n\n// http://marcodiiga.github.io/radial-lens-undistortion-filtering\nvec2 barrelDistort(in vec2 p, in vec2 alpha) {\n    return p / (1.0 - alpha * dot(p, p));\n}\n\n// Triangle wave\nfloat twave(in float x, in float s) {\n    s *= 2.0; x /= s;\n    float frac = fract(x);\n    float w = abs(round(frac) - frac);\n    return w * s;\n}\n\n// Drawing utilities\nvoid drawPoint(in vec2 pos, in float size, in vec3 pointColor, in vec2 p, in float unit, inout vec3 color) {\n    color = mix(color, pointColor, smoothstep(unit, 0.0, length(p - pos) - size));\n}\n\nvoid drawLine(in vec2 a, in vec2 b, in float thickness, in vec3 lineColor, in vec2 p, in float unit, inout vec3 color) {\n    vec2 pa = p - a, ba = b - a;\n    color = mix(color, lineColor, smoothstep(unit, 0.0, length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - thickness));\n}\n\n// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash21(in vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat snoise(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float bl = Hash21(cell);\n    float br = Hash21(cell + vec2(1.0, 0.0));\n    float tl = Hash21(cell + vec2(0.0, 1.0));\n    float tr = Hash21(cell + 1.0);\n\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nvec3 map(in vec2 p, in float unit) {\n    p *= 5.0;\n\n    float n = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (int o=0; o < 5; o++) {\n        n += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    n /= tscale;\n    return mix(vec3(0.0, 0.0, 1.0 - n), mix(vec3(0.0, 1.0, 0.0), vec3(0.8, 0.4, 0.0), n * n), smoothstep(0.5 - unit, 0.5 + unit, n));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float time = radius - twave(iTime, 2.0 * radius);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float unit = 8.0 / iResolution.y;\n\n    // Trig\n    float r = time * rate;\n    float c = cos(r), s = sin(r);\n    mat2 rot = mat2(c, s, -s, c);\n\n    // Rotate globe\n    uv *= rot;\n    drawPoint(vec2(0.0), radius, map(barrelDistort(uv * 0.4, vec2(0.75)), unit), uv, unit, fragColor.rgb);\n\n    // Path\n    vec2 prev; bool first = true;\n    float tStep = 2.0 * radius / 100.0;\n    for (float t=-radius; t < radius + tStep; t += tStep) {\n        float tr = t * rate;\n        c = cos(tr), s = sin(tr);\n        vec2 cur = vec2(t, 0.0) * mat2(c, s, -s, c);\n        if (first) first = false;\n        else drawLine(prev, cur, 0.01, vec3(1.0, 0.0, 0.0), uv, unit, fragColor.rgb);\n        prev = cur;\n    }\n\n    // Draw point\n    uv *= transpose(rot);\n    drawPoint(vec2(time, 0.0), 0.1, vec3(1.0), uv, unit, fragColor.rgb);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 104, 150, 150, 194], [196, 213, 250, 250, 358], [360, 381, 489, 489, 574], [576, 576, 696, 696, 863], [865, 956, 981, 981, 1099], [1101, 1101, 1126, 1126, 1450], [1452, 1452, 1488, 1488, 1863], [1865, 1865, 1920, 1920, 2906]], "test": "untested"}
{"id": "7dj3zd", "name": "Inverse Reflection - Plane II", "author": "oneshade", "description": "Inverse reflection for procedural 2D light. No randomly sampled rays and no explicitly drawn ones either. I'm trying to figure out how to do this for a sphere next.", "tags": ["2d", "reflection", "ray", "math", "physics", "optics", "inverse"], "likes": 8, "viewed": 243, "published": 3, "date": "1617845639", "time_retrieved": "2024-07-30T19:27:58.783738", "image_code": "// Fork of \"Inverse Reflection\" by oneshade\n// https://www.desmos.com/calculator/mleeqxa7k9\n\n// Drawing utilities\n#define drawSDF(dist, transp, col) color = mix(color, col, smoothstep(unit, 0.0, dist) * transp)\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdPlane2D(in vec2 p, in vec2 pos, in vec2 nor) {\n    return abs(dot(p - pos, nor));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// Computes the incident point between the point and light\n// l: light position\n// p: point position\n// o: reflector position\n// n: reflector direction\nvec2 getIncidence(in vec2 l, in vec2 p, in vec2 o, in vec2 n) {\n    l -= o; p -= o;\n    vec2 d = p - 2.0 * n * dot(p, n) - l;\n    return l - dot(l, n) / dot(d, n) * d + o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 light = iMouse.z > 0.0 ? mouse.xy : vec2(0.0, 1.0);\n    float scroll = iTime * 0.1;\n\n    vec2 reflectorPos = vec2(0.0, -1.0);\n    vec2 reflectorDir = vec2(0.0, 1.0);\n\n    float tilt = sin(iTime) * 0.5;\n    float c = cos(tilt), s = sin(tilt);\n    reflectorDir *= mat2(c, s, -s, c);\n\n    vec2 perp = vec2(reflectorDir.y, -reflectorDir.x);\n    vec2 e1 = reflectorPos + perp * 2.0;\n    vec2 e2 = reflectorPos - perp * 2.0;\n\n    // Draw the light rays if they are outside the plane\n    if (dot(light - reflectorPos, reflectorDir) > 0.0) {\n        // Draw the edges of the beam\n        if (dot(uv - reflectorPos, reflectorDir) > 0.0) {\n            drawSDF(sdPlane2D(uv, e1, (reflect(normalize(e1 - light), reflectorDir)).yx * vec2(-1.0, 1.0)), 1.0, hue2rgb(0.0));\n            drawSDF(sdPlane2D(uv, e2, (reflect(normalize(e2 - light), reflectorDir)).yx * vec2(-1.0, 1.0)), 1.0, hue2rgb(1.0));\n        }\n\n        // Draw the beam\n        vec2 i = getIncidence(light, uv, reflectorPos, reflectorDir);\n        if (dot(uv - reflectorPos, reflectorDir) > 0.0) {\n            if (abs(dot(i - reflectorPos, perp)) < 2.0) color = hue2rgb(dot(i - reflectorPos, perp) / 4.0 + 3.14);\n            vec2 rd = uv - light;\n            vec2 hit = light - rd * dot(light - reflectorPos, reflectorDir) / dot(rd, reflectorDir);\n            if (abs(dot(hit - reflectorPos, perp)) < 2.0 && dot(rd, reflectorDir) < 0.0) {\n                color = hue2rgb(dot(hit - reflectorPos, perp) / 4.0 + 3.14);\n            }\n        }\n\n        // Draw the edges of the beam\n        drawSDF(sdLine(uv, light, e1), 1.0, vec3(0.0));\n        drawSDF(sdLine(uv, light, e2), 1.0, vec3(0.0));\n    }\n\n    // Draw the light and reflector\n    drawSDF(sdDisc(uv, light, 0.05), 1.0, vec3(1.0));\n    drawSDF(sdPlane2D(uv, reflectorPos, reflectorDir) - 0.01, 1.0, vec3(0.0, 0.0, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dj3zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 357, 405, 405, 437], [439, 439, 493, 493, 530], [532, 532, 579, 579, 687], [689, 841, 904, 904, 1014], [1016, 1016, 1071, 1071, 3200]], "test": "untested"}
{"id": "7d2Gzd", "name": "rotating room", "author": "jorge2017a1", "description": "rotating room", "tags": ["rotatingroom"], "likes": 2, "viewed": 190, "published": 3, "date": "1617845098", "time_retrieved": "2024-07-30T19:27:59.678347", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 80.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n//---------------\n//Hexagonal Prism - exact\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\n////-----------------\n\nfloat tau = atan(1.0) * 8.0;\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec3 HacerCuartoyPuertas(vec3 pp)\n{\n    vec3 p=pp;\n    pp.y=pp.y+3.0;\n    p=pp;\n      \n    float numItem=10.0;\n    \n    p= rotate_x( p, radians(90.0));\n    vec3 rep2 = opAngRep(p, tau / numItem);\n    \n    \n    float sdb1a= sdBox(rep2-vec3(25.0,0.0,0.0), vec3(1.0,8.0,12.0) ); //hex rgrande \n    float sdb2a= sdBox(rep2-vec3(25.0,0.0,-2.0), vec3(6.5,2.0,10.0) );  //puertas\n    p=pp-vec3(0.0,5.0,0.0);\n    \n    \n    rep2= opAngRep(p, tau / numItem);\n    \n    p= rotate_x( pp-vec3(0.0,-5.0,0.0), radians(90.0));\n    vec3 rep3 = opAngRep(p-vec3(0.0,0.0,0.0), tau / numItem);\n    rep3= rotate_y( rep3, radians(90.0));\n    float shp1= sdHexPrism(  rep3-vec3(10.0,0.0,0.0), vec2(4.0,28.0) );\n    \n  \n    float dif;\n    dif=differenceSDF(sdb1a, sdb2a);\n    dif=differenceSDF(dif, shp1);\n    vec2 res=vec2(9999.9,-1.0);\n    res = opU2( res, vec2(dif,1.0));\n    return vec3(res,-1.0);\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    \n    vec3 pp=p;\n    \n    p= rotate_y(p-vec3(0.0,0.0,0.0), iTime*0.25);\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    \n    float sb1= sdBox(p-vec3(0.0,20.0,0.0), vec3(30.0,1.0,30.) );\n    res =opU3(res, vec3(sb1,2.0,MATERIAL_NO)); \n    \n    vec3 hc1= HacerCuartoyPuertas(p-vec3(0.0,10.0,0.0));\n    res =opU3(res, hc1); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= MAX_STEPS; i++) \n    {  \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == MAX_STEPS)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false;    minDist = dO;    break; } \n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n   vec3 p=pp; \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n        p= rotate_y(p-vec3(0.0,0.0,0.0), iTime*0.25);\n        float d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n        \n    \t//float d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, 25.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -15.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    \n    vec3 ro=vec3(0.0,5.0,-10.0);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n     col= getSkyColA(rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2Gzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 594, 594, 615], [616, 616, 648, 648, 732], [734, 778, 825, 825, 852], [854, 854, 897, 897, 924], [926, 926, 974, 974, 1002], [1004, 1042, 1078, 1078, 1123], [1124, 1189, 1223, 1223, 1321], [1322, 1322, 1356, 1356, 1448], [1449, 1449, 1483, 1483, 1575], [1576, 1616, 1650, 1650, 1747], [1794, 1794, 1830, 1830, 2103], [2105, 2105, 2141, 2141, 2224], [2280, 2280, 2306, 2306, 2360], [2362, 2362, 2396, 2396, 2569], [2571, 2571, 2606, 2606, 3448], [3450, 3490, 3515, 3515, 4045], [4049, 4049, 4114, 4114, 4698], [4700, 4751, 4775, 4775, 4963], [4965, 4965, 4998, 4998, 5709], [5711, 5765, 5801, 5801, 6035], [6092, 6126, 6206, 6206, 6483], [6485, 6536, 6583, 6583, 6923], [6977, 6977, 7070, 7070, 7345], [7349, 7349, 7376, 7376, 7486], [7489, 7538, 7595, 7595, 8925]], "test": "untested"}
{"id": "sdj3zt", "name": "Inverse Reflection - Plane I", "author": "oneshade", "description": "Finding the incident point given a light position, a point, reflector position, and reflector direction (for line reflectors). Set the light and point by dragging the mouse.", "tags": ["reflection", "ray", "math", "light", "plane", "physics", "optics", "incidence"], "likes": 7, "viewed": 180, "published": 3, "date": "1617838826", "time_retrieved": "2024-07-30T19:28:00.501146", "image_code": "// \"Inverse Reflection\" by oneshade\n// Original: https://www.desmos.com/calculator/dvs5kyylbm\n// Improvement 1: https://www.desmos.com/calculator/kvouvidoku\n// Improvement 2 (based on @mla's comment): https://www.desmos.com/calculator/li9pg9x5rj\n\n// Drawing utilities\n#define drawSDF(dist, transp, col) color = mix(color, col, smoothstep(unit, 0.0, dist) * transp)\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdPlane2D(in vec2 p, in vec2 pos, in vec2 nor) {\n    return abs(dot(p - pos, nor));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\n// Computes the incident point between a point and light\n// The line from the light to the reflection of the point over\n// the plane intersects the plane at the point of incidence\n// l: light position, p: point position\n// o: reflector position, n: reflector direction\nvec2 getIncidence(in vec2 l, in vec2 p, in vec2 o, in vec2 n) {\n    l -= o; p -= o;\n    vec2 d = p - 2.0 * n * dot(p, n) - l;\n    return l - dot(l, n) / dot(d, n) * d + o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float unit = 8.0 / iResolution.y;\n\n    // Default if mouse is not set\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        mouse = vec4(-1.0, 1.0, 1.0, 1.0);\n    }\n\n    vec2 light = mouse.zw;\n    vec2 point = mouse.xy;\n\n    vec2 reflectorPos = vec2(0.0, -1.0);\n    vec2 reflectorDir = vec2(0.0, 1.0);\n\n    float tilt = sin(iTime) * 0.5;\n    float c = cos(tilt), s = sin(tilt);\n    reflectorDir *= mat2(c, s, -s, c);\n\n    // Draw the reflector\n    drawSDF(sdPlane2D(uv, reflectorPos, reflectorDir) - 0.01, 1.0, vec3(0.0, 0.0, 1.0));\n    drawSDF(sdVectorArrow(uv - reflectorPos, reflectorDir * 0.5), 1.0, vec3(1.0));\n\n    // Draw light path\n    vec2 i = getIncidence(light, point, reflectorPos, reflectorDir);\n    vec2 fromLight = i - light;\n    vec2 toPoint = point - i;\n    drawSDF(sdVectorArrow(uv - light, fromLight - normalize(fromLight) * 0.2) + 0.01, 1.0, vec3(1.0));\n    drawSDF(sdVectorArrow(uv - i, toPoint - normalize(toPoint) * 0.2) + 0.01, 1.0, vec3(1.0));\n\n    // Draw light, point, and incident point\n    drawSDF(sdDisc(uv, light, 0.05), 1.0, vec3(0.0, 1.0, 0.0));\n    drawSDF(sdDisc(uv, point, 0.05), 1.0, vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisc(uv, i, 0.05), 1.0, vec3(1.0, 0.8, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdj3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 374, 422, 422, 454], [456, 456, 510, 510, 547], [549, 549, 596, 596, 704], [706, 706, 751, 751, 819], [821, 821, 875, 875, 1151], [1153, 1153, 1196, 1196, 1384], [1386, 1655, 1718, 1718, 1828], [1830, 1830, 1885, 1885, 3348]], "test": "untested"}
{"id": "fsB3zt", "name": "Day 475", "author": "jeyko", "description": "helou", "tags": ["design", "mdtmjvm", "acidgraphix"], "likes": 20, "viewed": 483, "published": 3, "date": "1617827620", "time_retrieved": "2024-07-30T19:28:01.452602", "image_code": "\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    C = C*.0;\n    \n    vec2 uv = (U - 0.5*R)/R.y;   \n    \n    C = T(U);\n    \n    \n    \n    \n    float n1d = texelFetch(iChannel2,ivec2(mod(U + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(U  + n1d*200. ,256.)),0).xyz;\n    \n    \n    C *= 1.  ;\n    //C = smoothstep(0.,1.,C);z\n    \n    C.xyz = pow(max(C.xyz,0.), vec3(0.55) + n*0.1);\n    \n    \n    \n    C.xyz += smoothstep(1.,0.,length(C))*n*0.15;\n    \n    C.xyz -= smoothstep(0.,1.,length(C))*n*0.05;\n    \n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\nfloat noise(vec3 p){\n    float n = 0.;\n    float amp = 1.;\n    for(int i = 0; i < 3; i++){\n    \n        p.xz *= rot(0.6);\n        p.yz *= rot(0.6);\n        \n        n += dot(sin(p),cos(p))*amp;\n        \n        amp *= 0.6;\n        p *= 1.5;\n    }\n    return n;\n}\n\nvec3 pal(vec3 p){\n    vec3 c = 0.5 + 0.5* sin(p*vec3(1.,1.,1.) + vec3(0.5,0.,-0.5));\n\n    c = pow(c,vec3(.4545));\n    c = smoothstep(0.,0.7,c);\n    return c;\n}\n\nvec3 getP(vec2 uv){\n    float n = noise(vec3(uv*5.,iTime*0.1));\n    uv -= n*0.1;\n    float nb = noise(vec3(uv*4.,iTime*0.1 + 6.));\n    float nc = noise(vec3(uv*4.,iTime*0.1));\n    \n    vec3 col = pal(vec3(1.,1. - n*0.1,1.)*nc*1.);\n    col = mix(col,pow(pal(vec3(1.5,1.5,1.4)*nb *2. + 4.6 + n),vec3(1.)),smoothstep(-0.1,-0.5,nb));\n    return col;\n}\nfloat sdBox(vec2 p, vec2 s){\n    p = abs(p) - s; return max(p.x,p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 ouv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float pxsz = fwidth(uv.x);\n        \n    uv.y += iTime*0.1;\n    \n    col = getP(uv);\n    float md = 0.04;\n    vec2 mid = floor(uv/md)*md;\n    //vec2 muv = \n    vec3 mcol = getP(mid);\n    \n    \n    {\n        for(float i = 0.; i < 7.; i++){\n        \n            vec2 p = ouv - vec2(0.5,-0.4);\n        \n            float w = sin(i*10. + iTime*0.4 + sin(i + iTime)*0.5*(sin(i)))*0.5 + .45;\n            \n            float d = length(p) - w*1.;\n            d = abs(d) - 0.04*abs(sin(i+iTime));\n            p *= rot(i*20. + sin(iTime+i));\n            d = max(d,-abs(atan(p.y,p.x)) + 0.4);\n            \n            p *= rot(i*20. + sin(iTime+i));\n            d = max(d,-abs(atan(p.y,p.x)) + 0.4);\n            \n            col *= max(smoothstep(-0.04,0.05,d),0.1);\n            \n            col = mix(col,0.4*pow(min(1.-col,1.),vec3(4.))*1.,smoothstep(pxsz,0.,d));\n            //col = 1. - col;\n    \n        }\n        \n    }\n    col = mix(col,mcol, smoothstep(1.,0.,noise(vec3(uv*4.,iTime*1.)) + 1.) );\n    \n    \n    float db = sdBox(ouv,vec2(0.48));\n    col *= smoothstep(0.02,-0.04,db);\n    \n    float sdb = smoothstep(0.,pxsz,db);\n    col = mix(col,vec3(0.004),sdb);\n    \n    float nn = noise(vec3(uv*5.,iTime));\n    {\n        vec2 p = pmod(uv,0.1);\n        col = mix(col,\n            mix(col,col-vec3(1),smoothstep(pxsz,0.,length(p))),\n            smoothstep(pxsz,0.,db));\n        col = mix(col,vec3(1.)*0.1,sdb*smoothstep(pxsz,0.,abs(sdBox(ouv + 0.01,vec2(0.48)))));\n        col = mix(col,vec3(1.)*0.1,sdb*smoothstep(pxsz,0.,abs(sdBox(ouv + 0.02,vec2(0.48)))));\n    \n        float no = max(nn,0.1);\n        col = mix(col,\n            mix(col,vec3(1)*no*0.3,smoothstep(pxsz,0.,length(p) - 0.002)),\n            smoothstep(0.,pxsz,db));\n    \n    \n    }\n    {\n        vec2 p = pmod(uv + 0.0,0.25);\n        \n        float d = abs(p.x);\n        d = min( d, abs(p.y) );\n        d = max( d, length(p) - 0.02);\n        \n        \n        col = mix(col,\n            mix(col,0.2-col*4.,nn*sdb*smoothstep(pxsz,0.,d)),\n            smoothstep(pxsz,0.,d));\n        ///col = mix(col,vec3(1.)*0.1,sdb*smoothstep(pxsz,0.,abs(sdBox(ouv + 0.01,vec2(0.48)))));\n        //col = mix(col,vec3(1.)*0.1,sdb*smoothstep(pxsz,0.,abs(sdBox(ouv + 0.02,vec2(0.48)))));\n    \n        //float no = max(noise(vec3(uv*5.,iTime)),0.1);\n        \n    \n    }\n    \n    {\n        \n        for(float i = 0.; i < 16.; i++){\n        \n            vec2 p = ouv + vec2(sin(i*1.)*0.4 + 0.4,1.5 - 2.5*mod(0.2*iTime*(1. + sin(i*6.)*0.8) + sin(i + iTime)*0.05,1.));\n            float w = sin(i*50.)*0. + 0.001;\n            \n            float d = length(p.x);\n            d = abs(d) - w;\n            d = max(d,abs(p.y) - 0.1 + sin(i)*0.05);\n            col *= smoothstep(-0.1,0.02,d);\n            \n            col = mix(col,1.*pow(min(1.-col,1.),vec3(1.))*1.,smoothstep(pxsz,0.,d));\n            //col = 1. - col;\n    \n        }\n        \n    }\n    col = mix(col,1.*pow(min(1.-col,1.),vec3(1.))*0.4 + 0.3,smoothstep(pxsz,0.,max(abs(ouv.y-.41),abs(ouv.x) - 0.2) - 0.01));\n    {\n        float id = floor(2.*ouv.y/0.2);\n        //float id = floor(2.*ouv.x/0.11);\n        \n        //col = mix(col,pal(id*vec3(1.) + iTime*0.6),smoothstep(pxsz,0.,max(abs(ouv.x-.8) - 0.01,abs(ouv.y) - 0.2)));\n        \n        float d = max(abs(ouv.x-.8 ),abs(ouv.y) - 0.25) - 0.01;\n        col *= smoothstep(-0.1,0.04,d);\n    \n        col = mix(col,1.-pal(id*vec3(1.) + sin(iTime+id*20.)*1.6),smoothstep(pxsz,0.,d));\n    \n    }       \n    {\n        \n        for(float i = 0.; i < 4.; i++){\n        \n            vec2 p = ouv + vec2(sin(i*4.)*0.5 - 0.4,-.4 - .2*sin(0.2*iTime*(1. + sin(i*6.)*0.8) + sin(i + iTime)*0.05));\n            float w = sin(i*50.)*0. + 0.001;\n            \n            float d = sdBox(p, vec2(0.1));\n            //col *= smoothstep(-0.1,0.02,d);\n            \n            //col = mix(col,0.1*pow(max(1.-col,0.),vec3(0.1))*1.,smoothstep(pxsz,0.,d));\n            //col = 1. - col;\n    \n        }\n        \n    }\n    if(iMouse.z > 0. || fract(iTime*0.1) < 0.1)\n        col = 1. - col;\n    \n    //col = pow(col,vec3(.4545));\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "#define R (iResolution.xy)\n#define T(u) texture(iChannel0,fract((u)/R))\n#define iTime (iTime + 26.)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsB3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 42, 42, 540]], "test": "untested"}
{"id": "fdj3RV", "name": "Cell Graph", "author": "wyatt", "description": "Reproducing Graph", "tags": ["mcgrath"], "likes": 32, "viewed": 561, "published": 3, "date": "1617827491", "time_retrieved": "2024-07-30T19:28:02.527727", "image_code": "Main \n{\n    vec4    aa=A(U),\n            c = C(aa.xy),\n            b = B(U),\n            a = vec4(A(b.xy).xy,A(b.zw).xy),\n            cc=C(a.zw);\n    float l = ln(U,a.xy,a.zw),\n          s = smoothstep(1.,0.,length(U-aa.xy)),\n          t = smoothstep(1.,0.,ln(U,a.xy,a.zw));\n    Q = (1.1-.5*(c+cc))*(1.-s)*(t)*exp(-3e-3*dot(a.xy-a.zw,a.xy-a.zw));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\t if (length(a-b)<1e-3||length(a)<1.||length(b)<1.) return 1e9;\n    vec2 m = 0.5*(a+b); // midpoint\n    return abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n}\nbool cmp (vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {\n    float l1 = ln(p,a,b),\n          l2 = ln(p,c,d);\n    if (l1<1.&&l2<1.) return length(a-b)<length(b-c);\n    else return l1<l2;\n\n}", "buffer_a_code": "// Sort Particles \nMain\n{\n    Q = A(U);\n    for (float x=-1.;x<=1.;x++)\n    for (float y=-1.;y<=1.;y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        if (length(U-q.xy)<length(U-Q.xy))\n            Q = q;\n    }\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Sort Graph \nMain\n{\n    Q = B(U);\n    Q.xy = A(U).xy;\n    for (float x=-1.;x<=1.;x++)\n    for (float y=-1.;y<=1.;y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4\n            aa= A(U+u),\n            b = B(U+u),\n            a = vec4(A(b.xy).xy,A(b.zw).xy),\n            q = vec4(A(Q.xy).xy,A(Q.zw).xy);\n        if (cmp(U,q.xy,aa.xy,q.xy,q.zw))\n        {\n            Q.zw = q.zw = aa.xy;\n        } else\n        if (cmp(U,a.xy,a.zw,q.xy,q.zw))\n        {\n            q = a;\n            Q = b;\n        } else\n        if (cmp(U,q.xy,a.xy,q.xy,q.zw))\n        {\n            q.zw = a.xy;\n            Q.zw = a.zw;\n        }\n    }\n    Q.xy = A(Q.xy).xy;\n    Q.zw = A(Q.zw).xy;\n    if (length(U-Q.zw)<length(U-Q.xy))\n        Q = Q.zwxy;\n    if (iFrame<1) {\n        Q = vec4(U,U+1.);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Color \nMain {\n    vec2 u = B(U).xy;\n    Q = mix(A(round(u)+.5),A(u),.1);\n    vec4 Qi = (sin(length(U-.5*R)+1.5*U.x/R.x*vec4(1,2,3,4)));\n    if (length(Q)>0.) \n        Q = mix(Q,normalize(Q),1e-3);\n     Q = mix(Q,Qi,1e-5);\n    if (iFrame < 1)\n          Q = Qi;\n}\n\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Apply Forces \nMain \n{\n    Q = A(U);\n    vec4 cQ = mix(C(Q.xy),C(U),1e-7); \n    vec2 f = -5./R.y*(Q.xy-0.5*R)/(1.+length(Q.xy-0.5*R));\n    for (float x=-2.;x<=2.;x++)\n    for (float y=-2.;y<=2.;y++)\n    {\n        vec2 u = Q.xy+vec2(x,y);\n        vec4 b = B(u),\n             c = C(b.zw),\n             a= A(b.zw);\n        vec2 r = Q.xy-a.xy;\n        float l = length(r); \n        float s = step(.75,ln(u,b.xy,b.zw));\n        if (l>2.)\n        {\n            f -= .2*r/l/sqrt(l)*s*(dot(c,cQ));\n            f += (.7*r/l/l)*s;\n            f += (8.*r/l/l/l/l)*s;\n        }\n    }\n    //if (length(f)>1.) f = normalize(f);\n    Q.zw +=   f;\n    Q.xy +=.5*f + Q.zw;\n    if (iMouse.z>0.) {\n        vec2 r = Q.xy-iMouse.xy;\n        float l = length(r);\n        if (l>0.)\n        Q.zw += 10.*r/l/l;\n    }\n    if (length(Q.zw)>.8) Q.zw = .8*normalize(Q.zw);\n    if (Q.x<1.){Q.x=1.;Q.z*=-1.;}\n    if (Q.y<1.){Q.y=1.;Q.w*=-1.;}\n    if (R.x-Q.x<1.){Q.x=R.x-1.;Q.z*=-1.;}\n    if (R.y-Q.y<1.){Q.y=R.y-1.;Q.w*=-1.;}\n    if (iFrame<1) {\n        Q = vec4(round(U/37.)*37.,0,0);\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdj3RV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fsBGRd", "name": "3D Raytracing Sandbox", "author": "oneshade", "description": "Not physically based.", "tags": ["3d", "raytracing", "ray", "sandbox", "rendering", "cg"], "likes": 11, "viewed": 322, "published": 3, "date": "1617824339", "time_retrieved": "2024-07-30T19:28:03.290687", "image_code": "// Constants\n#define EPSILON 0.001\n#define INFINITY 1000000000.0\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// Settings\n#define LIGHT_BOUNCES 3\n#define ZOOM 1.0\n#define AA 2\n\n// Convenience structs\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n\nstruct Mat {\n    vec3 color;\n    bool reflective;\n};\n\nstruct TraceInfo {\n    bool hit;\n    float dist;\n    vec3 pos;\n    vec3 nor;\n    Mat mat;\n};\n\n// Transformations\nmat2 Rotate2D(in float theta) {\n    float c = cos(theta), s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nRay Translate(in Ray ray, in vec3 t) {\n    return Ray(ray.pos - t, ray.dir);\n}\n\nRay Rotate(in Ray ray, in vec2 r) {\n    mat2 yaw = Rotate2D(-r.x);\n    mat2 pitch = Rotate2D(-r.y);\n\n    ray.pos.yz *= pitch;\n    ray.pos.xz *= yaw;\n    ray.dir.yz *= pitch;\n    ray.dir.xz *= yaw;\n\n    return ray;\n}\n\nRay Scale(in Ray ray, in vec3 s) {\n    return Ray(ray.pos / s, ray.dir / s);\n}\n\n// Primitive intersectors (an unfortunate amount of kludging in some places)\nvoid addPlane(in vec3 pos, in vec3 nor, in Mat mat, in Ray ray, inout TraceInfo scene) {\n    float d = dot(ray.dir, nor);\n    if (d != 0.0) {\n        float t = dot(pos - ray.pos, nor) / d;\n        if (t > 0.0 && (scene.hit ? t < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = t;\n            scene.pos = ray.pos + ray.dir * t;\n            scene.nor = nor;\n            scene.mat = mat;\n        }\n    }\n}\n\nvoid addTriangle(in vec3 a, in vec3 b, in vec3 c, in Mat mat, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= a; b -= a; c -= a;\n    vec3 ba = b, cb = c - b, ac = -c;\n\n    vec3 nor = cross(ba, -ac);\n    float denom = dot(ray.dir, nor);\n    if (denom != 0.0) {\n        float t = -dot(ray.pos, nor) / denom;\n        if (t > 0.0 && (scene.hit ? t < scene.dist : true)) {\n            vec3 pos = ray.pos + ray.dir * t;\n            vec3 pa = pos, pb = pos - b, pc = pos - c;\n\n            // Semibarycentric coordinates\n            float abc = length(nor);\n            float abp = length(cross( ba, pa));\n            float bcp = length(cross( cb, pb));\n            float cap = length(cross(-ac, pa));\n\n            if (abs(abp + bcp + cap - abc) < EPSILON) {\n                scene.hit = true;\n                scene.dist = t;\n                scene.pos = pos + a;\n                scene.nor = nor / abc;\n                scene.mat = mat;\n            }\n        }\n    }\n}\n\n// Box intersector adapted from https://www.shadertoy.com/view/ld23DV\nvoid addBox(in vec3 pos, in vec3 dims, in Mat mat, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n\n    vec3 m = 1.0 / ray.dir;\n    vec3 n = m * ray.pos;\n    vec3 k = abs(m) * dims;\n    vec3 t1 = -(k + n);\n    vec3 t2 = +(k - n);\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF < 0.0) tN = -1.0;\n    vec3 nor = -sign(ray.dir) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\n    if (tN > 0.0 && (scene.hit ? tN < scene.dist : true)) {\n        scene.hit = true;\n        scene.dist = tN;\n        scene.pos = ray.pos + ray.dir * tN;\n        scene.nor = nor;\n        scene.mat = mat;\n        scene.pos += pos;\n    }\n}\n\nvoid addCone(in vec3 pos, in float height, in float radius, in Mat mat, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n\n    // Reused values\n    float bb = radius * radius;\n    float bbh = bb / height;\n    float bbhh = bbh / height;\n    float bbhhy = bbhh * ray.pos.y;\n\n    // Quadratic coefficients\n    float a = dot(ray.dir.xz, ray.dir.xz) - bbhh * ray.dir.y * ray.dir.y;\n    float b = 2.0 * (dot(ray.pos.xz, ray.dir.xz) + (bbh - bbhhy) * ray.dir.y);\n    float c = dot(ray.pos.xz, ray.pos.xz) + (2.0 * bbh - bbhhy) * ray.pos.y - bb;\n\n    // Solve and include a plane for the base\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float tBase = -ray.pos.y / ray.dir.y;\n        vec3 roots = vec3(-(vec2(-1, 1) * sqrt(discr) + b) / a * 0.5, tBase);\n\n        float t = INFINITY;\n        vec3 hitPos, nor = vec3(0.0, -1.0, 0.0);\n        int nClosest;\n        for (int n=0; n < 3; n++) {\n            vec3 hitCandid = ray.pos + ray.dir * roots[n];\n            if (roots[n] > 0.0 && roots[n] < t && hitCandid.y < height && dot(hitCandid.xz, hitCandid.xz) < radius * radius) {\n                t = roots[n];\n                hitPos = hitCandid;\n                nClosest = n;\n            }\n        }\n\n        // Compute a different normal for the base\n        if (nClosest != 2) {\n            nor = normalize(vec3(hitPos.xz, radius / height * length(hitPos.xz))).xzy;\n        }\n\n        if (t > 0.0 && t < INFINITY && (scene.hit ? t < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = t;\n            scene.pos = hitPos + pos;\n            scene.nor = nor;\n            scene.mat = mat;\n        }\n    }\n}\n\nvoid addCylinder(in vec3 pos, in float height, in float radius, in Mat mat, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n\n    // Quadratic coefficients\n    float a = dot(ray.dir.xz, ray.dir.xz);\n    float b = 2.0 * dot(ray.pos.xz, ray.dir.xz);\n    float c = dot(ray.pos.xz, ray.pos.xz) - radius * radius;\n\n    // Solve with a plane for the base and top\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float hh = 0.5 * height;\n        float tBase = +(hh - ray.pos.y) / ray.dir.y;\n        float tTop  = -(hh + ray.pos.y) / ray.dir.y;\n        vec4 roots = vec4(-(vec2(-1, 1) * sqrt(discr) + b) / a * 0.5, tBase, tTop);\n\n        float t = INFINITY;\n        vec3 hitPos, nor = vec3(0.0, -1.0, 0.0);\n        int nClosest;\n        for (int n=0; n < 4; n++) {\n            vec3 hitCandid = ray.pos + ray.dir * roots[n];\n            if (roots[n] > 0.0 && roots[n] < t  && abs(hitCandid.y) < hh + EPSILON && dot(hitCandid.xz, hitCandid.xz) < radius * radius + EPSILON) {\n                t = roots[n];\n                hitPos = hitCandid;\n                nClosest = n;\n            }\n        }\n\n        if (nClosest < 2) nor = vec3(hitPos.xz / radius, 0.0).xzy; // Sides\n        else nor.y = sign(2.5 - float(nClosest)); // Base and top\n        if (t > 0.0 && t < INFINITY && (scene.hit ? t < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = t;\n            scene.pos = hitPos + pos;\n            scene.nor = nor;\n            scene.mat = mat;\n        }\n    }\n}\n\nvoid addSphere(in vec3 pos, in float radius, in Mat mat, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n\n    // Quadratic coefficients\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(ray.pos, ray.dir);\n    float c = dot(ray.pos, ray.pos) - radius * radius;\n\n    // Solve\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float t = -(b + sqrt(discr) * sign(dot(ray.pos, ray.pos) - radius * radius)) / a * 0.5;\n        if (t > 0.0 && (scene.hit ? t < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = t;\n            scene.pos = ray.pos + ray.dir * t;\n            scene.nor = scene.pos / radius;\n            scene.mat = mat;\n            scene.pos += pos;\n        }\n    }\n}\n\n// Main scene\nTraceInfo traceScene(in Ray ray) {\n    TraceInfo scene = TraceInfo(false, -1.0, vec3(0.0), vec3(0.0), Mat(vec3(0.0), false));\n\n    addPlane(vec3(0.0, -2.0, 0.0), vec3(0.0, 1.0, 0.0), Mat(vec3(1.0), false), ray, scene);\n\n    addSphere(vec3(1.0, 1.0, 1.0), 1.0, Mat(vec3(1.0, 0.0, 0.0), true), ray, scene);\n    addSphere(vec3(-1.0, 1.0, 1.0), 1.0, Mat(vec3(1.0, 1.0, 0.0), false), ray, scene);\n    addSphere(vec3(1.0, -1.0, 1.0), 1.0, Mat(vec3(1.0, 0.0, 1.0), false), ray, scene);\n    addSphere(vec3(-1.0, -1.0, 1.0), 1.0, Mat(vec3(1.0, 0.5, 0.6), false), ray, scene);\n    addSphere(vec3(1.0, 1.0, -1.0), 1.0, Mat(vec3(0.0, 1.0, 1.0), false), ray, scene);\n    addSphere(vec3(-1.0, 1.0, -1.0), 1.0, Mat(vec3(1.0, 0.8, 0.0), false), ray, scene);\n    addSphere(vec3(1.0, -1.0, -1.0), 1.0, Mat(vec3(0.0, 1.0, 0.0), false), ray, scene);\n    addSphere(vec3(-1.0, -1.0, -1.0), 1.0, Mat(vec3(0.0, 0.0, 1.0), true), ray, scene);\n\n    addTriangle(vec3(-4.0, -2.0, -0.5), vec3(-2.5, -2.0, 2.5), vec3(-1.85, 1.0, 1.5), Mat(vec3(1.0), false), ray, scene);\n    addCylinder(vec3(3.0, 0.0, -1.0), 4.0, 0.5, Mat(vec3(0.0, 0.5, 1.0), false), ray, scene);\n    addCone(vec3(4.0, -2.0, 1.0), 2.0, 1.0, Mat(vec3(1.0), true), ray, scene);\n    addBox(vec3(-4.0, -0.49, -1.5), vec3(0.75, 1.5, 0.75), Mat(vec3(1.0, 0.5, 0.0), false), ray, scene);\n\n    return scene;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = ivec2(iMouse.xy) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * PI;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    Light[] lights = Light[](Light(vec3(-10.0, 10.0, 10.0), vec3(0.8, 0.2, 0.2)),\n                             Light(vec3(10.0, 10.0, 10.0), vec3(0.2, 0.8, 0.2)),\n                             Light(vec3(0.0, 10.0, -10.0), vec3(0.2, 0.2, 0.8)));\n\n    // Mouse rotation\n    mat2 yaw = Rotate2D(-mouse.x);\n    mat2 pitch = Rotate2D(-mouse.y);\n\n    // Take multiple subsamples for antialiasing\n    float aaStep = 1.0 / float(AA);\n    for (float xOffs=0.0; xOffs < 1.0; xOffs += aaStep) {\n        for (float yOffs=0.0; yOffs < 1.0; yOffs += aaStep) {\n            vec2 uv = (fragCoord + vec2(xOffs, yOffs) - center) / iResolution.y;\n            vec3 color = vec3(0.0);\n\n            Ray camRay = Ray(vec3(0.0, 0.0, 8.0), normalize(vec3(uv, -ZOOM)));\n\n            // Rotate with mouse\n            camRay.pos.yz *= pitch;\n            camRay.pos.xz *= yaw;\n            camRay.dir.yz *= pitch;\n            camRay.dir.xz *= yaw;\n\n            // Bounce the ray around the scene\n            float weight = 1.0 / float(LIGHT_BOUNCES);\n            for (int b=0; b < LIGHT_BOUNCES; b++) {\n                TraceInfo scene = traceScene(camRay);\n                vec3 lightDir; Ray shadow;\n                bool stopBouncing = false;\n                if (scene.hit) {\n                    for (int n=0; n < lights.length(); n++) {\n                        lightDir = normalize(lights[n].pos - scene.pos);\n                        float shade = max(0.0, dot(scene.nor, lightDir));\n\n                        // Trace a shadow ray\n                        shadow = Ray(scene.pos + scene.nor * EPSILON, lightDir);\n                        TraceInfo shadowTrace = traceScene(shadow);\n                        if (shadowTrace.hit) {\n                            shade = 0.0;\n                        }\n\n                        // Shade and break out of the loop if the shape is not reflective\n                        vec3 diff = lights[n].color * scene.mat.color * shade;\n                        if (scene.mat.reflective) diff *= weight;\n                        color.rgb += diff;\n                        if (!scene.mat.reflective) stopBouncing = true;\n                    }\n                }\n\n                // Sample the cubemap instead on a miss\n                else {\n                    color.rgb += texture(iChannel0, camRay.dir).rgb;\n                    stopBouncing = true;\n                }\n\n                // Bounce\n                camRay = Ray(shadow.pos, reflect(camRay.dir, scene.nor));\n                if (stopBouncing) break;\n            }\n\n            // Tonemap\n            color.rgb = pow(color.rgb, vec3(0.75));\n\n            // Combine\n            fragColor.rgb += color;\n        }\n    }\n\n    // Average\n    fragColor.rgb /= float(AA * AA);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[450, 469, 500, 500, 574], [576, 576, 614, 614, 654], [656, 656, 691, 691, 871], [873, 873, 907, 907, 951], [953, 1030, 1118, 1118, 1461], [1463, 1463, 1561, 1561, 2424], [2426, 2496, 2583, 2583, 3178], [3180, 3180, 3288, 3288, 4828], [4830, 4830, 4942, 4942, 6336], [6338, 6338, 6431, 6431, 7077], [7079, 7093, 7127, 7127, 8432]], "test": "untested"}
{"id": "sdB3zd", "name": "Hardware Texture Derivative Test", "author": "bgolus", "description": "Testing hardware texture unit derivatives to see if it uses all 4 pixel quad UVs or only the usual \"coarse\" 3.\n\nEllipse in center shows what the texture looks like normally. Top right quadrant should match on desktop GPUs. Mobile GPUs though...", "tags": ["derivatives"], "likes": 3, "viewed": 811, "published": 3, "date": "1617818210", "time_retrieved": "2024-07-30T19:28:04.275055", "image_code": "// Hardware Texture Mapping Unit (TMU) Derivatives Test\n\n// =======================================================================================\n//\n// GPUs render pixels in 2x2 groups known as pixel quads. All 4 pixels within the quad are\n// rendered in parallel at all times. This existed purely so GPUs can use UV derivatives,\n// or the difference between one pixel and the one beside it, to calculate the mip level.\n// For performance reasons it's beneficial to use a constant mip level for the entire quad\n// as it reduces the memory bandwidth usage. If all pixels with in the pixel quad use the\n// same mip level it means it only needs to retreive the mip map(s) once per pixel quad.\n//\n// Each texture(uv) call in the quad is passing along a UV position, and the hardware TMU\n// is calculating the derivatives from those UV positions. This shader offsets one pixel's\n// UV within each pixel quad by 1.0 on the x and y to try to expose the underlying\n// hardware's derivative calculation method.\n//\n// Traditionally the derivatives were calculated using only three of the four UVs passed\n// to the TMU as an optimization. This is more formally referred to as \"coarse\"\n// derivatives. Most desktop GPUs still work this way, so one UV can be significantly\n// different from the other three and not affect the calculated mip level. On those GPUs\n// this shader will show one quadrant, likely the top right, as matching the center\n// ellipse. That center ellipse isn't modifying the UVs at all so should always show the\n// top mip. The other three quadrants should show as a solid grey color as the coarse\n// derivatives will \"see\" the offset UV and calculate a smaller mip, presumablly the 1x1\n// mip thus producing the solid grey.\n//\n// However many newer GPUs, like Mali and Apple's Bionic or M1 GPUs, use all four UVs to\n// calculate the mip level for the pixel quad. Apple seems to use the worse derivatives\n// on each axis, where as Mali is an average of the derivatives.\n//\n// Note, the OS or graphics API should not have any affect on the results of this shader,\n// and running WebGL via ANGLE to Direct3D or Vulkan should look the same as native WebGL.\n// Also the behaviour of derivative functions within the shader code aren't guaranteed to\n// match those used by the TMU. They happen to in Direct3D on some desktop GPUs, like AMD\n// and Nvidia, but they're different things.\n//\n// See this shader for more: https://www.shadertoy.com/view/7sSGWG\n//\n// =======================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 halfRes = floor(iResolution.xy * 0.25) * 2.0;\n    vec2 halfRes = iResolution.xy * 0.5;\n    \n    vec2 uv = fragCoord/64.0;   \n    \n    vec2 quadPos = mod(floor(fragCoord), 2.0);\n    \n    // kick one UV position in the quad way out to check which pixel\n    // is ignored by the texture unit, if any\n    float offset = 0.0;\n    \n    // top right\n    if (fragCoord.x > halfRes.x && fragCoord.y > halfRes.y)\n        offset = max(0.0, quadPos.x + quadPos.y - 1.0);\n    \n    // top left\n    else if (fragCoord.x < halfRes.x && fragCoord.y > halfRes.y)\n        offset = max(0.0, (1.0 - quadPos.x) + quadPos.y - 1.0);\n        \n    // bottom right\n    else if (fragCoord.x > halfRes.x && fragCoord.y < halfRes.y)\n        offset = max(0.0, quadPos.x + (1.0 - quadPos.y) - 1.0);\n        \n    // bottom left\n    else //if (fragCoord.x < halfRes.x && fragCoord.y < halfRes.y)\n        offset = max(0.0, (1.0 - quadPos.x) + (1.0 - quadPos.y) - 1.0);\n        \n    // no modifications to the uv for an ellipse in the middle\n    vec2 centeredUV = fragCoord/iResolution.xy - 0.5;\n    if (length(centeredUV) < 0.2)\n        offset = 0.0;\n        \n    uv += offset;\n\n    fragColor = texture(iChannel0, uv);\n    \n    // fragColor = vec4(offset);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdB3zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2556, 2556, 2613, 2670, 3848]], "test": "untested"}
{"id": "sdS3zt", "name": "Fractal 50_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 17, "viewed": 442, "published": 3, "date": "1617809957", "time_retrieved": "2024-07-30T19:28:05.050982", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.6),.8)*.001/e/i\n    )\n    {\n        p=g*d-vec3(0,0,1.5);\n        p=R(p,normalize(vec3(1,2.*sin(iTime*.1),3)),iTime*.2);\n        s=5.;\n        p=p/dot(p,p)+1.;\n        for(int i=0;i++<8;)\n            p=abs(p-vec3(.8,2,1.5))-vec3(1,1.5,2.5),\n            s*=e=1.6/clamp(dot(p,p),.2,1.5),\n            p*=e;\n        g+=e=abs(p.x)/s+1e-3;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 651]], "test": "untested"}
{"id": "7s2GR3", "name": "Lone Planet and the Sun", "author": "edubart", "description": "Lone Planet and the Sun\n\nThe original code was generated by a tool I am working on, but should be readable.", "tags": ["planet", "cineshader"], "likes": 16, "viewed": 7419, "published": 3, "date": "1617799280", "time_retrieved": "2024-07-30T19:28:05.872784", "image_code": "/* Generated by Nelua 0.2.0-dev */\n/* Compile command: clang \"/home/bart/projects/nelua/nelua-lang/nelua_cache/demos/glsldemo.c\" -o \"/home/bart/projects/nelua/nelua-lang/nelua_cache/demos/glsldemo\" -Wall -fwrapv -g -lm */\n/* Compile hash: ajDYp5NtwWMYTraHttzrB2DfBzo */\n/* ------------------------------ DECLARATIONS ------------------------------ */\nvec3 vec_tovec3(float a);\nvec3 noise_vec3_yzx(vec3 self);\nvec3 noise_vec2_xyx(vec2 self);\nvec2 sincos(float x);\nfloat noise_hash1_2(vec2 v);\nfloat noise_hash1_3(vec3 v);\nfloat noise_noisemix3(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2, vec3 f);\nfloat noise_noise_white_1(vec2 p);\nfloat noise_noise_value_1(vec3 p);\nfloat map(vec3 p);\nfloat ray_march(vec3 ro, vec3 rd);\nvec3 get_normal(vec3 p);\nfloat fbm3(vec3 p);\nvec3 planet_palette(float x);\nvec3 planet_color(vec3 p);\nvec3 shade(vec3 rd, vec3 p);\nvec3 perspective_camera(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv);\nfloat expstep(float x, float k);\nvec3 get_background(vec3 rd);\nvec3 color_tonemap_aces(vec3 col);\nvec3 color_saturate(vec3 col, float sat);\nvec3 color_tone_1(vec3 col, float gain, float lift, float invgamma);\nvec3 color_gamma_correction(vec3 col);\nvec3 vignette(vec3 col, vec2 coord, float strength, float amount);\nvec3 dither(vec3 col, vec2 coord, float amount);\nvec3 sun_glare(vec3 rd);\n/* ------------------------------ DEFINITIONS ------------------------------- */\nvec3 vec_tovec3(float a) {\n  return vec3(a, a, a);\n}\nvec3 noise_vec3_yzx(vec3 self) {\n  return vec3(self.y, self.z, self.x);\n}\nvec3 noise_vec2_xyx(vec2 self) {\n  return vec3(self.x, self.y, self.x);\n}\nvec2 sincos(float x) {\n  return vec2(sin(x), cos(x));\n}\nfloat noise_hash1_2(vec2 v) {\n  vec3 v3 = noise_vec2_xyx(v);\n  v3 = fract((v3 * 0.1031));\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\n  return fract(((v3.x + v3.y) * v3.z));\n}\nfloat noise_hash1_3(vec3 v) {\n  vec3 v3 = v;\n  v3 = fract((v3 * 0.1031));\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\n  return fract(((v3.x + v3.y) * v3.z));\n}\nfloat noise_noisemix3(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2, vec3 f) {\n  vec3 u = ((f * f) * (3.0 - (2.0 * f)));\n  vec3 u1 = (1.0 - u);\n  return ((((((a1 * u1.x) + (b1 * u.x)) * u1.y) + (((c1 * u1.x) + (d1 * u.x)) * u.y)) * u1.z) + (((((a2 * u1.x) + (b2 * u.x)) * u1.y) + (((c2 * u1.x) + (d2 * u.x)) * u.y)) * u.z));\n}\nfloat noise_noise_white_1(vec2 p) {\n  return noise_hash1_2(p);\n}\nfloat noise_noise_value_1(vec3 p) {\n  vec3 i = floor(p);\n  vec3 f = fract(p);\n  vec3 j = (i + 1.0);\n  float a1 = noise_hash1_3(i);\n  float b1 = noise_hash1_3(vec3(j.x, i.y, i.z));\n  float c1 = noise_hash1_3(vec3(i.x, j.y, i.z));\n  float d1 = noise_hash1_3(vec3(j.x, j.y, i.z));\n  float a2 = noise_hash1_3(vec3(i.x, i.y, j.z));\n  float b2 = noise_hash1_3(vec3(j.x, i.y, j.z));\n  float c2 = noise_hash1_3(vec3(i.x, j.y, j.z));\n  float d2 = noise_hash1_3(j);\n  return noise_noisemix3(a1, b1, c1, d1, a2, b2, c2, d2, f);\n}\nfloat sphere_intersect(vec3 ro, vec3 rd, vec3 p, float r) {\n  vec3 oc = (ro - p);\n  float b = dot(oc, rd);\n  float c = (dot(oc, oc) - (r * r));\n  float h = ((b * b) - c);\n  if(h < 0.0) {\n    return -1.0f;\n  } else {\n    return ((-b) - sqrt(h));\n  }\n}\nfloat map(vec3 p) {\n  return (length(p) - 0.6);\n}\nfloat ray_march(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for(int i = 0; i < 128; i++) {\n    vec3 p = (ro + (t * rd));\n    float d = map(p);\n    if(d <= 0.0001) {\n      return t;\n    }\n    t = (t + d);\n    if(t > 10.0) {\n      return -1.0;\n    }\n  }\n  return -1.0;\n}\nfloat fbm3(vec3 p) {\n  float a = 1.0;\n  float t = 0.0;\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  return t;\n}\nvec3 planet_palette(float x) {\n  vec3 col = vec3(0.1, 0.6, 0.9);\n  col = (col + (0.2 * sin(((6.28318531 * x) + vec3(0.3, 0.2, 0.1)))));\n  col = (col + (0.1 * sin(((14.4513262 * x) + vec3(0.1, 0.2, 0.3)))));\n  return col;\n}\nvec3 planet_color(vec3 p) {\n  p = (p * 2.0);\n  float t = iTime;\n  vec3 q = vec3((fbm3((p + (t * 0.03))) * 0.5), (fbm3(p) * 0.5), (fbm3((p + 33.33)) * 0.5));\n  vec3 r = vec3((fbm3(((p + q) + (t * 0.01))) * 0.5), (fbm3((p + q)) * 0.5), (fbm3(((p + q) + 33.33)) * 0.6));\n  float f = (fbm3(((p + (5.0 * r)) + (t * 0.02))) * 0.5);\n  vec3 col = planet_palette(r.y);\n  col = (col * ((clamp((f * f), 0.0, 1.0) * 0.9) + 0.1));\n  col = clamp(col, 0.0, 1.0);\n  return col;\n}\nvec3 shade(vec3 rd, vec3 p) {\n  vec3 normal = normalize(p);\n  float ambient_dif = 0.03;\n  vec3 dif = vec_tovec3(ambient_dif);\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\n  vec3 sun_col = (vec3(1.0, 0.9, 0.9) * 4.0);\n  float sun_dif = clamp(((dot(normal, sun_dir) * 0.9) + 0.1), 0.0, 1.0);\n  dif = (dif + (sun_col * sun_dif));\n  vec3 mate = (planet_color(p) * 0.4);\n  vec3 col = (mate * dif);\n  float fres = clamp((1.0 + dot(normal, rd)), 0.0, 1.0);\n  float sun_fres = (fres * clamp(dot(rd, sun_dir), 0.0, 1.0));\n  col = (col * (1.0 - fres));\n  col = (col + ((pow(sun_fres, 8.0) * vec3(0.4, 0.3, 0.1)) * 5.0));\n  return col;\n}\nvec3 perspective_camera(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\n  vec2 sc = sincos(tilt);\n  vec3 vup = normalize(vec3(sc.x, sc.y, 0.0));\n  vec3 w = normalize((lookat - lookfrom));\n  vec3 u = cross(w, vup);\n  vec3 v = cross(u, w);\n  float wf = (1.0 / tan(((vfov * 3.14159265) / 360.0)));\n  return normalize((((uv.x * u) + (uv.y * v)) + (wf * w)));\n}\nfloat expstep(float x, float k) {\n  return exp(((k * x) - k));\n}\nvec3 get_background(vec3 rd) {\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\n  float sun_dif = dot(rd, sun_dir);\n  vec3 col = (vec3(1.0, 0.9, 0.9) * expstep(sun_dif, 600.0));\n  col = (col + (vec3(1.0, 1.0, 0.1) * expstep(sun_dif, 100.0)));\n  col = (col + (vec3(1.0, 0.7, 0.7) * expstep(sun_dif, 50.0)));\n  col = (col + (vec3(1.0, 0.6, 0.05) * expstep(sun_dif, 10.0)));\n  return col;\n}\nvec3 color_tonemap_aces(vec3 col) {\n  return clamp(((col * ((2.51 * col) + 0.03)) / ((col * ((2.43 * col) + 0.59)) + 0.14)), 0.0, 1.0);\n}\nvec3 color_saturate(vec3 col, float sat) {\n  float grey = dot(col, vec3(0.2125, 0.7154, 0.0721));\n  return (grey + (sat * (col - grey)));\n}\nvec3 color_tone_1(vec3 col, float gain, float lift, float invgamma) {\n  col = pow(col, vec_tovec3(invgamma));\n  return (((gain - lift) * col) + lift);\n}\nvec3 color_gamma_correction(vec3 col) {\n  return pow(col, vec_tovec3(0.454545455));\n}\nvec3 vignette(vec3 col, vec2 coord, float strength, float amount) {\n  return (col * ((1.0 - amount) + (amount * pow(((((16.0 * coord.x) * coord.y) * (1.0 - coord.x)) * (1.0 - coord.y)), strength))));\n}\nvec3 dither(vec3 col, vec2 coord, float amount) {\n  return clamp((col + (noise_noise_white_1(coord) * amount)), 0.0, 1.0);\n}\nvec3 sun_glare(vec3 rd) {\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\n  vec3 glare_col = vec3(1.0, 0.6, 0.2);\n  return (glare_col * pow(max(dot(sun_dir, rd), 0.0), 2.0));\n}\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord) {\n  vec2 res = vec2(iResolution.x, iResolution.y);\n  vec2 mouse = vec2((iMouse.x / iResolution.x), (iMouse.y / iResolution.y));\n  vec2 coord = ((2.0 * (frag_coord - (res * 0.5))) / iResolution.y);\n  float theta = ((1.88495559 + (iTime * 0.2)) + (6.28318531 * mouse.x));\n  vec3 lookat = vec3(0.0, 0.0, 0.0);\n  vec2 sc = (sincos(theta) * 2.0);\n  vec3 ro = vec3(sc.x, 0.5, sc.y);\n  vec3 rd = perspective_camera(ro, lookat, 0.0, 50.0, coord);\n  float t = sphere_intersect(ro, rd, vec3(0.0, 0.0, 0.0), 0.6);\n  vec3 p = (ro + (rd * t));\n  vec3 col = get_background(rd);\n  float depth = 0.0;\n  if(t >= 0.0) {\n    col = shade(rd, p);\n  \tdepth = smoothstep(2.0, 2.0-0.6, t);\n  }\n  col = (col + (0.2 * sun_glare(rd)));\n  col = color_tonemap_aces(col);\n  col = color_tone_1(col, 1.7, 0.002, 1.2);\n  col = color_saturate(col, 0.9);\n  col = color_gamma_correction(col);\n  col = vignette(col, (frag_coord / res), 0.25, 0.7);\n  col = dither(col, frag_coord, 0.01);\n  frag_col = vec4(col.x, col.y, col.z, depth);\n}\n\n\n/** SHADERDATA\n{\n\t\"title\": \"Lone Planet and the Sun\",\n\t\"description\": \"A solitary blue planet in space\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2GR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1362, 1443, 1469, 1469, 1495], [1496, 1496, 1528, 1528, 1569], [1570, 1570, 1602, 1602, 1643], [1644, 1644, 1666, 1666, 1699], [1700, 1700, 1729, 1729, 1884], [1885, 1885, 1914, 1914, 2053], [2054, 2054, 2165, 2165, 2413], [2414, 2414, 2449, 2449, 2478], [2479, 2479, 2514, 2514, 2997], [2998, 2998, 3057, 3057, 3248], [3249, 3249, 3268, 3268, 3298], [3299, 3299, 3334, 3334, 3562], [3563, 3563, 3583, 3583, 4103], [4104, 4104, 4134, 4134, 4326], [4327, 4327, 4354, 4354, 4790], [4791, 4791, 4820, 4820, 5410], [5411, 5411, 5497, 5497, 5782], [5783, 5783, 5816, 5816, 5847], [5848, 5848, 5878, 5878, 6224], [6225, 6225, 6260, 6260, 6362], [6363, 6363, 6405, 6405, 6502], [6503, 6503, 6572, 6572, 6655], [6656, 6656, 6695, 6695, 6741], [6742, 6742, 6809, 6809, 6943], [6944, 6944, 6993, 6993, 7068], [7069, 7069, 7094, 7094, 7235], [7236, 7236, 7291, 7291, 8288]], "test": "untested"}
{"id": "fdBGzd", "name": "Tixy Land - Kaleidoscope", "author": "ern0", "description": "A surprisingly good P/P formula for Tixy\n\nTuxy engine is forked from @Xor https://www.shadertoy.com/view/3dtBDN\n256-byte intro for PC-DOS: https://www.youtube.com/watch?v=uV5qEeMlLrQ", "tags": ["tixykaleidoscope"], "likes": 1, "viewed": 314, "published": 3, "date": "1617799196", "time_retrieved": "2024-07-30T19:28:06.896048", "image_code": "// Forked from https://www.shadertoy.com/view/3dtBDN\n//   by https://www.shadertoy.com/user/Xor\n//\n// Formula by ern0\n//   sin(t*(x-7.5)*(y-7.5)/66)\n//   https://tixy.land/?code=sin%28t*%28x-7.5%29*%28y-7.5%29%2F66%29%2F%2F%65%72%6e%30\n// 256-byte intro (capture): \n//   https://www.youtube.com/watch?v=uV5qEeMlLrQ\n\n//Recreated @aemkey's \"Tixy Land\" in ShaderToy using shader syntax.\n//Play around with the original here: https://tixy.land\n\n// You can fiddle with dot count here:\n#define count 16.\n#define center ((count-1.)/2.)\n\n#define tixy(t,i,x,y) sin(t*(x-center)*(y-center)/66.)\n\n//#define tixy(t,i,x,y) (x-7.5+sin(t)*5.)*(x-7.5+sin(t)*5.)+(y-7.5+cos(t*1.7)*5.)*(y-7.5+cos(t*1.7)*5.)-8.\n\n\n//Render with the result:\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    float s = 1.2/iResolution.y;\n    vec2 u = (coord-.5*iResolution.xy)*s;\n    u.y = -u.y;\n    \n    float square = step(abs(u.x),.5)*step(abs(u.y),.5);\n    vec2 cell = floor((u+.5)*count);\n    float index = cell.x+cell.y*count;\n    float tixel = float(tixy(iTime,index,cell.x,cell.y));\n    \n    float dist = length(fract(u*count)-.5)*count/.5;\n    float radius = count*min(abs(tixel),1.);\n    \n    vec3 col = tixel<0. ? vec3(255,34,68)/255. : vec3(1);\n    col *= clamp((radius-dist)/s/count/count/2.,0.,1.)*square;\n\n    color = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBGzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[695, 721, 770, 770, 1313]], "test": "untested"}
{"id": "fdSGzt", "name": "Fractal 49_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 46, "viewed": 996, "published": 3, "date": "1617788794", "time_retrieved": "2024-07-30T19:28:07.779685", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,2));  \n    for(float i=0.,s,e,g=1.5;\n        ++i<90.;\n        O.xyz+=.1*mix(vec3(1),H(log(s)*.3),.8)*exp(-12.*i*i*e)\n    )\n    {\n        p=g*d-vec3(-.2,.3,2.5);\n        p=R(p,normalize(vec3(1,2.*sin(iTime*.1),3)),iTime*.2);\n        s=5.;\n        p=p/dot(p,p)+1.;\n        for(int i=0;i++<8;p*=e)\n            p=1.-abs(p-1.),\n            s*=e=1.6/min(dot(p,p),1.5);\n        g+=e=length(cross(p,vec3(.577)))/s-5e-4;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 640]], "test": "untested"}
{"id": "7d23R3", "name": "Clockwork Spacetime", "author": "Tater", "description": "would be cool if someone made this in 3D, maybe I should learn ray marching. ", "tags": ["2d", "gears", "warp", "rotation", "spin"], "likes": 16, "viewed": 501, "published": 3, "date": "1617763193", "time_retrieved": "2024-07-30T19:28:08.546635", "image_code": "#define pi 3.14159265359\n#define rot(a) mat2( cos(a),-sin(a),sin(a),cos(a) )\n#define a(c) float( clamp(c,0.0,1.0) )\nfloat gear(vec2 uv, float aa,float tth){ //this is a mess lol\n    float inn = 0.275; //Inner Circle Size\n    float th = atan(-uv.y,-uv.x)/(2.0*pi)+0.5;\n    float id = mod(floor(th*tth),2.0);\n    th = mod(th,1./tth)*tth;\n    float r = length(uv);\n    float c = smoothstep(r-aa,r+aa,inn);\n    th = abs(th-0.5)*1.05;\n    float end = (-pow(th,3.4)+1.0)*0.425; //Tooth Shape\n    c += smoothstep(r-aa,r+aa,end)*id*\n    smoothstep(th-aa*tth/2.5,th+aa*tth/2.5,0.5);\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    float aa = 1./R.y;\n    \n    float t = iTime*1.5;\n    //Time Warping\n    t = pow(fract(t),3.5)+floor(t);\n    \n    //Size of rotation steps\n    t*=pi/(6.0);\n    \n    //Whole Screen Rotation + direction flip\n    uv*=rot(-t*sign(sin(t)));\n    vec2 uv2 = uv;\n    \n    //Gear Tooth Count /2 (works well with 20,16,12,8,4)\n    float tth =12.0;\n    \n    //Overall Scale\n    float scl = 3.7;\n    \n    //Zoom In/Out\n    scl-=cos(t)*0.75;\n    \n    //Slight Initial Offset\n    t+=pi/tth;\n    \n    //Edge of screen warping\n    scl*=1.0+pow(length(uv),10.0);\n    \n    //The Gears\n    aa*=scl;\n    vec3 gearCol = vec3(1.0); //I like it b/w but you can change it\n    uv = 0.5-fract(uv*scl);\n    uv *= rot(-t);\n    vec3 col = gearCol*a(gear(uv,aa,tth))*(1.0-length(uv));\n    \n    t+=pi/2.;\n    uv2 += 0.5/scl;\n    uv = 0.5-fract(uv2*scl);\n    uv *= rot(t);\n    col += gearCol*a(gear(uv,aa,tth))*(0.05+length(uv));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d23R3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 156, 177, 589], [590, 590, 647, 647, 1654]], "test": "untested"}
{"id": "fs23zc", "name": "Expensive Line Fill", "author": "oneshade", "description": "Looks expensive.", "tags": ["2d", "line", "float"], "likes": 3, "viewed": 179, "published": 3, "date": "1617757557", "time_retrieved": "2024-07-30T19:28:09.385392", "image_code": "#define draw(d, t, c) color = mix(color, c, smoothstep(unit, 0.0, d) * t)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 32.0;\n    float unit = 64.0 / iResolution.y;\n    float time = iTime * 0.25;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, 1.0, vec3(0.0, 0.0, 1.0));\n    draw(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, 1.0, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), 1.0, vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), 1.0, vec3(1.0, 0.0, 0.0));\n\n    vec2 a = vec2(cos(time * 1.25) * 20.0, sin(time) * 8.0);\n    vec2 b = vec2(-sin(time * 0.75) * 12.0, sin(time * 1.5) * 16.0);\n\n    vec2 ba = b - a;\n    float l = length(ba);\n    float denom = max(abs(ba.x), abs(ba.y));\n\n    vec2 pos = a;\n    vec2 pStep = ba / denom;\n    for (float t=0.0; t < denom; t++) {\n        vec2 cell = floor(pos) + 0.5;\n        draw(max(abs(uv.x - cell.x), abs(uv.y - cell.y)) - 0.5, 0.5, vec3(0.0));\n        pos += pStep;\n    }\n\n    draw(length(uv - a) - 0.5, 1.0, vec3(1.0, 0.0, 0.0));\n    draw(length(uv - b) - 0.5, 1.0, vec3(0.0, 0.0, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs23zc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 129, 129, 1180]], "test": "untested"}
{"id": "Ns23zc", "name": " - Quicky#050", "author": "totetmatt", "description": "Training what I learn in evvvvil stream for fractalish stuff.\nTesting some color scheme also.", "tags": ["quicky"], "likes": 0, "viewed": 299, "published": 3, "date": "1617750674", "time_retrieved": "2024-07-30T19:28:10.155333", "image_code": "  #define fGlobalTime iTime\n  mat2 rot(float a){\n      float c=cos(a),s=sin(a);\n     return mat2(c,-s,s,c);\n     }\n float frbox(vec3 p,vec3 b ,float e){\n         \n      p = abs(p)-b;\n   vec3 q = abs(p+e)-e;\n    return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n   }\n  float structure(vec3 p ){\n     float t  =fGlobalTime*.01;\n     float tt = fGlobalTime*.303;\n   vec3 np=p;\n    float h = 1000.;\n \n\n     np.z = abs(np.z)-(1.5+sin(t*100.)*.5+.5);\n    for(int i=0;i<20;i++){\n\n     np /=(1.1);\n     if(i==1){   np .xy = np.x < np.y ? np.yx:np.xy;\n     np.xz*=rot(.753-float(i)-t*t);\n     } else if(i==2) { np .xy = np.x > np.y ? np.yx:np.xy;\n        np.xy*=rot(.753+t*t+float(i));\n     }else if(i==3) {   np .xy = np.x < np.y ? np.yx:np.xy;\n        np.zy*=rot(.753+float(i));\n     } else {   np .xy = np.x > np.y ? np.yx:np.xy;\n                 np.yz*=rot(.753-t+float(i));\n       }\n      h = min(h,frbox(np,vec3(1.1),.1-abs(np.x*.2)));\n    }  \n   \n  return h;\n    \n    }\n   vec2 sdf(vec3 p){\n     float t  = (fGlobalTime*.02);\n     float tt = fract(fGlobalTime*.33);\n     float h = structure(p);\n     float l = length(p-vec3(0.,0.,0.))-(.25+sin(t*200.)*.1+.1);\n      vec2 rt = l < h ? vec2(l,1.):vec2(h,2.);\n     return rt;\n  }\n  vec2 nv = vec2(.00001,.0);\nvec3 norm(vec3 p){\n     float d = sdf(p).x;\n     return normalize(\n    vec3(\n      d-sdf(p-nv.xyy).x,\n      d-sdf(p-nv.yxy).x,\n     d-sdf(p-nv.yyx).x\n  )\n  );\n    }\nvec3 pal(float t){\n  return sqrt(.5+vec3(.5,.0,.5)*cos(2.*3.141592*(1.*t+vec3(.0,.4,.6))));\n  } \n\nvec2 rayt(vec3 ro,vec3 rd,int st){\n    vec3 rp = ro;\n  float rdd= 0.;\n    for(int i=0;i<=st;i++){\n      vec2 d = sdf(rp);\n        rdd += d.x;\n         rp = ro+rdd * rd;\n        if(d.x<=0.0001){\n              return vec2(rdd,d.y);   \n        }\n    }\n    return vec2(1000.,0.);\n  }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n \n\tvec3 col = vec3(.1);\n  vec3 ro= vec3(0.,0.,-10.),rd= normalize(vec3(uv,1.)),rp = ro;\n  vec3 light = vec3(1.11,0.001,-3.);\n  \n  vec2 res = rayt(ro,rd,69);\n             rp = ro+rd*res.x;\n          if(res.y ==2.){\n              \n            col = pal(length(rp))* max(0.0,dot(normalize(light),norm(rp)));\n          } else if(res.y==1.) {\n            \n       \n            col =vec3(1.)* max(0.0,dot(normalize(light),norm(rp)));\n            } else {\n col = vec3(.1);\n              }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23zc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 48, 48, 114], [116, 116, 152, 152, 452], [455, 455, 480, 480, 1154], [1158, 1158, 1175, 1175, 1411], [1441, 1441, 1459, 1459, 1605], [1606, 1606, 1624, 1624, 1701], [1704, 1704, 1738, 1738, 1983], [1984, 1984, 2041, 2091, 2695]], "test": "untested"}
{"id": "tlKBWd", "name": "Complex Fibonacci", "author": "mla", "description": "Binet formula for Fibonacci numbers interpreted on the complex plane. Uses Newton-Raphson to solve binet(z) = w. Use mouse to select starting point.", "tags": ["complex", "fibonacci", "newtonraphson"], "likes": 27, "viewed": 678, "published": 3, "date": "1617748258", "time_retrieved": "2024-07-30T19:28:10.932257", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Complex Fibonacci, Matthew Arcus, mla, 2021\n//\n// Simply by interpreting the Binet formula, fib(n) = ( - -)/5 for a\n// complex parameter, we can extend the Fibonacci function to the complex plane.\n// As usual, to show this with domain colouring, we require the inverse function,\n// ie. given complex w, find z such that fib(z) = w. There doesn't seem to be a simple\n// analytic inverse, but we can find the inverse by solving fib(z)-w = 0\n// for z using Newton-Raphson. In fact, the inverse Binet function is multivalued\n// and which value we get depends critically on the starting value - and sometimes\n// we don't converge at all. The starting point z0 is set by the mouse or\n// automatically on the x+2i line.\n//\n// Grid lines for the z-plane are shown, together with the real and imaginary axes\n// (and integer points) for the w-plane. The thicker dark line is the real axis\n// in the z-plane - for z >= 0, it passes through w = 0,1(twice),2,3,5 etc. and\n// for negative z, -1,2,-3 etc.\n//\n// https://matthewarcus.wordpress.com/2012/12/22/complex-fibonacci/\n// https://www.youtube.com/watch?v=ghxQA3vvhsk\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\nfloat PHI = 1.6180334;\nfloat LOGPHI = 0.481211825;\nfloat ISQRT5 = 0.447213595;\n\n// The Binet formula for fib(z)\nvec2 binet(vec2 z) {\n  return ISQRT5*(cexp(PHI,z) - cexp(-PHI,-z));\n}\n\n// Exact derivative\nvec2 dbinet(vec2 z) {\n  return ISQRT5*(LOGPHI*cexp(PHI,z) + cmul(vec2(LOGPHI,PI),cexp(-PHI,-z)));\n}\n\nvec2 dbinet0(vec2 z) {\n  // Sanity check - numeric derivative\n  float eps = 0.001;\n  return (binet(z+vec2(eps,0))-binet(z-vec2(eps,0)))/(2.0*eps);\n}\n\n// Solve: binet(z)-w = 0 with Newton-Raphson, initial guess z0\nvec2 fib(vec2 w, vec2 z0) {\n  vec2 z = z0;\n  for (int i = 0; i < 10; i++) {\n    vec2 offset = cdiv(binet(z)-w,dbinet(z));\n    z -= offset;\n    if (dot(offset,offset) < 1e-6) break;\n  }\n  return z;\n}\n\nvec3 palette(float t) {\n  // iq's excellent palette technique\n  float a = 0.4, b = 0.6, c = 1.0;\n  vec3 d = vec3(0,0.333,0.666);\n  return a+b*cos(2.0*PI*(c*t+d));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 3.0;\n  // Initial value of x+2i gives nice results\n  vec2 z0 = vec2(4.7*sin(0.5*PI*0.125*iTime),2);\n  vec2 w = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  w *= scale;\n  if (iMouse.z > 0.0) {\n    // Initial value is at mouse position\n    z0 = scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  }\n  vec2 z = fib(w,z0);\n\n  vec3 color = palette(atan(z.y));\n  \n  // Draw grid lines etc.\n  float linedist;\n  float pfactor = 0.8*fwidth(z.x);\n  vec2 edges = fract(10.0*z);\n  edges = min(edges,1.0-edges);\n  linedist = min(edges.x,edges.y);\n  linedist /= 10.0;\n  color = mix(vec3(0),color,0.6+0.4*smoothstep(0.0025,max(0.005,pfactor),linedist)); // w grid\n  float mdist = min(abs(w.x),abs(w.y));\n  color = mix(vec3(0.8),color,0.5+0.5*smoothstep(0.0,0.03,mdist)); // z grid\n  float pdist = min(distance(abs(w),vec2(round(abs(w.x)),0)),\n                    distance(abs(w),vec2(0,round(abs(w.y)))));\n  color = mix(vec3(0.8),color,0.5+0.5*smoothstep(0.03,0.05,pdist)); // Points\n  linedist = abs(z.y);\n  color = mix(vec3(0),color,0.5+0.5*smoothstep(0.01,max(0.02,pfactor),linedist)); // Real axis\n  color *= sqrt(texture(iChannel0,0.5*w/scale).xyz);\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n// common\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nvec2 rotate(vec2 p, float t) {\n  vec2 r = vec2(cos(-t),sin(-t));\n  r = normalize(r);\n  return p * r.x + vec2(p.y, -p.x) * r.y;\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return z.x*w + vec2(-z.y,z.y)*w.yx;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nvec2 clog(float x) {\n  return clog(vec2(x,0));\n}\n\nvec2 cexp(vec2 z) {\n  // If cos and sin were perfect we wouldn't need normalize\n  return exp(z.x)*normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nvec2 cexp(float k, vec2 z) {\n  // return k^z\n  return cexp(cmul(clog(k),z));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1378, 1410, 1430, 1430, 1479], [1481, 1501, 1522, 1522, 1600], [1602, 1602, 1624, 1663, 1750], [1752, 1815, 1842, 1842, 2013], [2015, 2015, 2038, 2076, 2179], [2181, 2181, 2234, 2234, 3463]], "test": "untested"}
{"id": "Ns23Rc", "name": "lightcrypt hommage", "author": "MacSlow", "description": "This is a ShaderToy re-creation of \"lightcrypt\" by gopher/Alcatraz. A 256-bytes DOS demo from Revision 2021. I was totally blown away seeing 3D raymarching with lighting & shadows in a 256-bytes demo. Still some things missing, e.g. textures, proportions.", "tags": ["3d", "sdf", "demo", "revision"], "likes": 6, "viewed": 417, "published": 3, "date": "1617746694", "time_retrieved": "2024-07-30T19:28:11.706187", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// hommage to \"lightcrypt\" by gopher/Alcatraz - At Revision 2021 I was blown\n// away seeing a 256-bytes DOS demo implementing 3D raymarching with lighting\n// and shadows. I always had a huge facination for this extreme form of size-\n// -coding, but \"lightcrypt\" is on another level in my view.\n//\n// Since this sparked even more interest for that particular demoscene-discipline\n// and I really need to get back into shader-coding, I begin my ventures into\n// size-coding by getting a grip on the elements gopher probably used... only\n// less dense :)\n//\n// See http://www.pouet.net/prod.php?which=88539\n//\n// Author(s):\n//   Mirco \"MacSlow\" Mller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat opSmoothSubtract (float a, float b, float k)\n{\n    float h = clamp (.5 - .5*(a+b)/k, .0, 1.);\n    return mix (b, -a, h) + k*h*(1. - h); \n}\n\nfloat cube (vec3 p, float size)\n{\n    vec3 cube = abs (p) - size;\n    return length (max (cube, .0)) + min (max (cube.x, max (cube.y, cube.z)), .0);\n}\n\nfloat scene (vec3 p)\n{\n    float cellSize = 1.; \n    float cellSizeHalf = cellSize*.5;\n    float radius = .6; \n\n    float ground = p.y + .125;\n\n    vec3 repreatedSpace = mod (p + cellSizeHalf, cellSize) - cellSizeHalf;\n    p = repreatedSpace;\n\n    float ball =  length (p) - radius;\n    float box =  cube (p, cellSizeHalf);\n    float cell = opSmoothSubtract (ball, box, .05);\n\n    float d = min (cell, ground);\n\n    return d;\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward*zoom;\n\n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nfloat raymarch (vec3 ro, vec3 rd) \n{\n    float t = .0; \n    float d = .0; \n    vec3 p = vec3 (.0);\n    int iter = 0;\n\n    for (iter = 0; iter < 128; ++iter) {\n        p = ro + d * rd; \n        t = scene (p);\n        if (abs (t) < .0002*(1. + .125*t)) break;\n        d += t*.75;\n    }   \n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 e = vec2 (0., .001);\n\n    return normalize (vec3 (scene (p + e.yxx),\n                            scene (p + e.xyx),\n                            scene (p + e.xxy)) - scene(p));\n}\n\nfloat shadow (vec3 p, vec3 n, vec3 lPos)\n{\n  float distanceToLight = distance (lPos, p); \n  vec3 lDir = normalize (lPos - p); \n  float distanceToObject = raymarch (p + .01 * n, lDir);\n  bool isShadowed = distanceToObject < distanceToLight;\n\n  return isShadowed ? .3 : 1.; \n}\n\nfloat ao (vec3 p, vec3 n, float stepSize, int iterations, float intensity)\n{\n  float ao = .0; \n  float dist = .0; \n\n  for (int a = 1; a <= iterations; ++a) {\n    dist = float (a)*stepSize;\n    ao += max (.0, (dist - scene (p + n*dist))/dist);\n  }\n\n  return 1. - ao*intensity;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 n)\n{\n    vec3 p = ro + d*rd;\n    vec3 amb = vec3 (.15);\n    vec3 lPos = p + vec3 (1., .25, -3.*cos (.5*iTime));\n    vec3 lPos2 = p + vec3 (-1., .25, -3.*sin (.25*iTime));\n    vec3 lDir = normalize (lPos - p);\n    vec3 lDir2 = normalize (lPos2 - p);\n    //float lDist = distance (p, lPos);\n    //float attn = 1. / (lDist*lDist);\n    float diff = max (dot (n, lDir), .0);\n    float diff2 = max (dot (n, lDir2), .0);\n    vec3 diffMat = vec3 (.8, .7, .2);\n    vec3 h = normalize (ro + lDir);\n    vec3 h2 = normalize (ro + lDir2);\n    float spec = pow (max (dot (h, n), .0), 40.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n    float sha = shadow (p, n, lPos);\n    float sha2 = shadow (p, n, lPos2);\n    float ao = ao (p, n, .01, 12, .1);\n\n    return amb + sha*ao*(diff*diffMat + spec) +\n                 sha2*ao*(diff2*diffMat + spec2);\n}\n\nmat2 r2d (float deg)\n{\n  float rad = radians (deg);\n  float c = cos (rad);\n  float s = sin (rad);\n\n  return mat2 (vec2 (c, s), vec2 (-s, c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and aspect-correct UVs\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= .5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.);\n\n    // build view-ray and camera\n    vec2 offset = vec2 (.125*cos (iTime), -.3*iTime);\n    vec3 ro = vec3 (offset.x, -.025, offset.y + 2.);\n    vec3 aim = vec3 (.0, .5, offset.y);\n    float zoom = 1.25;\n    vec3 rd = camera (uv, ro, aim, zoom);\n    rd.xy *= r2d(4. + 2.*cos (1.25*iTime));\n\n    // do raymarch, normal-calc and shading\n    float d = raymarch (ro, rd);\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p);\n    vec3 color = shade (ro, rd, d, n);\n\n    // fog\n    float fog = 1. / (1. + d*d*1.);\n    color *= fog;\n\n    //colored haze\n    color = mix (color, vec3 (.99, .95, .2), pow (1. - 1. / d, 4.));\n\n    // vignette\n    color *= 1. - .625*length (fragCoord.xy/iResolution.xy*2. - 1.);\n\n    // Reinhart tone-mapping\n    color = color / (1. - color);\n\n    // Gamma-correction\n    color = pow (color, vec3 (1./2.2));\n\n    fragColor = vec4 (color, 1.);\n}", "image_inputs": [{"id": 26507, "src": "https://soundcloud.com/weareoliver/oliver-control", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23Rc.jpg", "access": "api", "license": "gpl-3.0", "functions": [[1449, 1449, 1501, 1501, 1593], [1595, 1595, 1628, 1628, 1745], [1747, 1747, 1769, 1769, 2174], [2176, 2176, 2230, 2230, 2553], [2555, 2555, 2591, 2591, 2858], [2860, 2860, 2882, 2882, 3069], [3071, 3071, 3113, 3113, 3345], [3347, 3347, 3423, 3423, 3624], [3626, 3626, 3674, 3674, 4513], [4515, 4515, 4537, 4537, 4658], [4660, 4660, 4717, 4757, 5763]], "test": "untested"}
{"id": "fs2GRc", "name": "Lemniscate Intersect 2D", "author": "oneshade", "description": "I like this shape. Set the ray with the mouse.", "tags": ["ray", "raycasting", "intersect", "bernoulli", "lemniscate"], "likes": 5, "viewed": 150, "published": 3, "date": "1617744865", "time_retrieved": "2024-07-30T19:28:12.541952", "image_code": "// Convenience struct\nstruct Hit4 {\n    int numHits;\n    vec4 hits;\n};\n\n// Drawing utilities\n#define drawSDF(dist, transp, col) color = mix(color, col, smoothstep(unit, 0.0, dist) * transp)\n#define drawImplicit(func, ss, transp, col)                                                     \\\n    float total = 0.0;                                                                          \\\n    for (float i=0.0; i < 1.0; i += 1.0 / ss) {                                                 \\\n        for (float j=0.0; j < 1.0; j += 1.0 / ss) {                                             \\\n            vec2 offs = vec2(i, j) / iResolution.xy * 4.0;                                      \\\n            total += step(0.0, -func(uv + offs));                                               \\\n        }                                                                                       \\\n    }                                                                                           \\\n                                                                                                \\\n    color = mix(color, col, total / (ss * ss) * transp);                                        \\\n\n// SDFs\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    return abs(dot(p - a, normalize(b - a).yx * vec2(-1.0, 1.0)));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\n// @mla's quartic solver (https://www.shadertoy.com/view/ltVfDK)\nfloat evalcubic(float x, float a, float b, float c, float d) {\n  return ((x * a + b) * x + c) * x + d;\n}\n\nfloat evalquad(float x, float a, float b, float c) {\n  return (x * a + b) * x + c;\n}\n\n// Solve a*x**2 + b*x + c == 0\nbool quadratic(float a, float b, float c, out vec2 t) {\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0) return false;\n    d = sqrt(d);\n    if (b < 0.0) d = -d;\n    t.x = 0.5 * (-b - d) / a;\n    t.y = c / (a * t.x);\n    if (t.x > t.y) t.xy = t.yx; // Sort results\n    return true;\n}\n\n// Find real root of x**3 + a*x**2 + b*x + c\n// Assume c < 0\nfloat cubic(float a, float b, float c) {\n    // c is always negative, but may be very\n    // small, in which case we return an\n    // approximation. Never return < 0.\n    if (c > -1e-6) {\n        if (b > 1e-10) return -c / b;\n        if (b > -1e-4) return 0.0;\n    }\n\n    // Now substitute to make c = -1\n    float k = 1.0;\n    k = pow(-c, 1.0 / 3.0);\n    a /= k; b /= k * k; c = -1.0;\n    // Now bracket a root between 0 and 1\n    // We may need to solve for 1/x\n    bool reciprocate = evalcubic(1.0, 1.0, a, b, c) < 0.0;\n    if (reciprocate) {\n        float a1 = -b;\n        float b1 = -a;\n        a = a1; b = b1;\n    }\n\n    vec2 res;\n    float x = 0.0;\n    // Chebyshev polynomial: |32x**3 - 48x**2 + 18x - 1| < 1\n    if (quadratic(a + 1.5, b - 0.5625, c + 0.03125, res)) {\n        // Find root closest to unit interval,\n        x = (abs(res[0] - 0.5) < abs(res[1] - 0.5)) ? res[0]: res[1];\n    }\n\n    // 3 rounds of Newton-Raphson\n    x -= evalcubic(x, 1.0, a, b, c) / evalquad(x, 3.0, 2.0 * a, b);\n    x -= evalcubic(x, 1.0, a, b, c) / evalquad(x, 3.0, 2.0 * a, b);\n    x -= evalcubic(x, 1.0, a, b, c) / evalquad(x, 3.0, 2.0 * a, b);\n\n    if (reciprocate) return k / x;\n    return k * x;\n}\n\nint quartic(float c1, float c2, float c3, float c4, out vec4 res) {\n    float alpha = 0.5 * c1;\n    float A = c2 - alpha * alpha;\n    float B = c3 - alpha * A;\n    float a, b, beta, psi;\n    if (B == 0.0) psi = 0.0;\n    else psi = cubic(2.0 * A - alpha * alpha, A * A + 2.0 * B * alpha - 4.0 * c4, -B * B);\n    a = sqrt(psi);\n    beta = 0.5 * (A + psi);\n    if (psi == 0.0) b = sqrt(max(beta * beta - c4, 0.0));\n    else b = 0.5 * a * (alpha - B / psi);\n\n    vec2 tmp;\n    int resn = 0;\n    if (quadratic(1.0, alpha + a, beta + b, tmp)) {\n        res.xy = tmp.xy;\n        resn += 2;\n    }\n\n    if (quadratic(1.0, alpha - a, beta - b, tmp)) {\n        res.zw = res.xy;\n        res.xy = tmp.xy;\n        resn += 2;\n    }\n\n    return resn;\n}\n\n// Intersection\nHit4 iBernoulliLemniscate(in vec2 ro, in vec2 rd) {\n    vec2 oo = ro * ro;\n    vec2 dd = rd * rd;\n    vec2 od = ro * rd;\n\n    float a = dot(dd, dd) + 2.0 * dd.y * dd.x;\n    float b = 4.0 * (od.x + od.y) * (dd.x + dd.y);\n\n    float c1 = 2.0 * ((oo.y - 1.0) * dd.x + (oo.x + 1.0) * dd.y);\n    float c2 = 6.0 * dot(oo, dd) + 8.0 * od.y * od.x;\n    float c = c1 + c2;\n\n    float sq = oo.x + oo.y;\n    float d = 4.0 * ((sq - 1.0) * od.x + (sq + 1.0) * od.y);\n    float e = dot(oo, oo) + 2.0 * ((oo.y - 1.0) * oo.x + oo.y);\n\n    vec4 roots;\n    int numRoots = quartic(b / a, c / a, d / a, e / a, roots);\n\n    return  Hit4(numRoots, roots);\n}\n\n// Implicit\nfloat deBernoulli(in vec2 p) {\n    vec2 p1 = vec2(p.x - 1.0, p.y);\n    vec2 p2 = vec2(p.x + 1.0, p.y);\n    return dot(p1, p1) * dot(p2, p2) - 1.0;\n}\n\n// Normal\nvec2 nBernoulliLemniscate(in vec2 p) {\n    return normalize(p * p * p + vec2(-p.x, p.y) + p.xx * p.yx * p.yy);\n}\n\n// Animation\nvec2 Velocity(in float t) {\n    vec2 p = vec2(0.0);\n    for (float n=0.0; n < 10.0; n++) {\n        float s = pow(2.0, n), ts = t * s;\n        p += vec2(cos(ts), sin(ts)) / s;\n    }\n\n    return p;\n}\n\n// Analytic integral\nvec2 Position(in float t) {\n    vec2 p = vec2(0.0);\n    for (float n=0.0; n < 10.0; n++) {\n        float ts = t * pow(2.0, n);\n        p += vec2(sin(ts), -cos(ts)) / pow(2.0, 2.0 * n);\n    }\n\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec3 color = vec3(0.5 + 0.5 * nBernoulliLemniscate(uv), 0.0);\n    float unit = 8.0 / iResolution.y;\n\n    vec2 ro = Position(iTime);\n    vec2 rd = Velocity(iTime);\n    if (iMouse.z > 0.0) {\n        ro = mouse.zw;\n        rd = mouse.xy - mouse.zw;\n    }\n\n    drawImplicit(deBernoulli, 8.0, 0.5, vec3(0.0, 0.0, 1.0));\n\n    drawSDF(sdInfLine(uv, ro, ro + rd) - 0.001, 1.0, vec3(0.0));\n    drawSDF(sdVectorArrow(uv - ro, rd), 1.0, vec3(1.0));\n\n    // Find the closest hit in front of the camera\n    Hit4 hit = iBernoulliLemniscate(ro, rd);\n    for (int n=0; n < int(hit.numHits); n++) {\n        vec2 pos = ro + rd * hit.hits[n];\n        drawSDF(length(uv - pos) - 0.05, 1.0, vec3(1.0, 0.0, 0.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2GRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1171, 1179, 1233, 1233, 1509], [1511, 1511, 1556, 1556, 1624], [1626, 1626, 1676, 1676, 1745], [1747, 1747, 1790, 1790, 1978], [1980, 2045, 2107, 2107, 2149], [2151, 2151, 2203, 2203, 2235], [2237, 2268, 2323, 2323, 2553], [2555, 2616, 2656, 2782, 3810], [3812, 3812, 3879, 3879, 4548], [4550, 4566, 4617, 4617, 5201], [5203, 5215, 5245, 5245, 5363], [5365, 5375, 5413, 5413, 5487], [5489, 5502, 5529, 5529, 5699], [5701, 5722, 5749, 5749, 5929], [5931, 5931, 5986, 5986, 6912]], "test": "untested"}
{"id": "Ns2Gz3", "name": "Sseraf 256-byte intro", "author": "rrrola", "description": "A faithful conversion of my DOS intro.\nhttps://www.pouet.net/prod.php?which=88536\n\nTry the other color variants!\n\nThanks to TomCat for SSE inspiration, knighty for the KIFS formulas, and the sizecoding discord for compression ideas.", "tags": ["kifs", "x86", "256bytes"], "likes": 14, "viewed": 639, "published": 3, "date": "1617742240", "time_retrieved": "2024-07-30T19:28:13.378715", "image_code": "// Inspired by:\n// - https://www.shadertoy.com/view/MdKyRw kaleidoscopic iterative function by wyatt\n// - https://www.shadertoy.com/view/ldB3Rz larval by P_Malin\n\n#define FAITHFUL true\n\nconst int Steps = FAITHFUL? 24 : 36;  // accuracy\nconst int Iterations = FAITHFUL? 16 : 20;  // shape detail\nconst float Eps = FAITHFUL? 1./16. : 1./64.;  // shading precision\n\nfloat C3,S3,C2,S2,C1,S1;\nfloat trap;\n\nfloat map(vec3 p) {\n  float len, t = 0.25;\n  trap = 0.25;\n  for (int i=0; i<Iterations; i++) {\n    p.xz = S3*p.xz + C3*vec2(-1,1)*p.zx; p = p.yzx;\n    p.xz = S2*p.xz + C2*vec2(-1,1)*p.zx; p = p.yzx;\n    p.xz = S1*p.xz + C1*vec2(-1,1)*p.zx; p = p.yzx;\n    p.xy = -abs(p.xy);\n    len = -(min(min(p.x, p.y), -abs(p.z)));  // box distance\n    trap = max(trap,len);\n    p.xy += vec2(t, t*.25);\n    t *= 0.75;\n  }\n  return len - 2.*t;\n}\n\n// Step along the ray. Return the position of the hit.\nfloat last_dist;\nvec3 trace(vec3 pos, vec3 dir) {\n  last_dist = 0.;\n  for (int i=0; i<Steps; i++) {\n    pos += dir * last_dist;\n    last_dist = map(pos);\n  }\n  return pos;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 v = (fragCoord - .5*iResolution.xy) / iResolution.y;  // v.y: -0.5..0.5\n  if (FAITHFUL) { v = floor(v*200.) / 200.; }  // quantize height to 200 pixels\n  v.y = -v.y;\n  v *= 0.78125298 / 0.5;\n\n  float time = -0.234375*iTime;\n  float t = time;     S1 = sin(t); C1 = cos(t);\n  t = time/log(2.);   S2 = sin(t); C2 = cos(t); // t*1.4427\n  t = time/log2(10.); S3 = sin(t); C3 = cos(t); // t*0.30103\n\n  vec3 p;\n  if (FAITHFUL) {\n    p = trace(vec3(v,1), vec3(0,0,-1));  // no perspective\n  }\n  else {\n    p = trace(vec3(0,0,1.25), normalize(vec3(v,-1)));  // perspective\n  }\n\n  float hue = min(trap, 1.);  // orbit trap\n  if (FAITHFUL) { hue = round(hue*32.) / 32.; }  // quantize to about 32 hues\n\n  float bri = (map(p+vec3(0,0,Eps)) - last_dist) / Eps;  // ao, brightness: smoothed normal.z\n  if (FAITHFUL) { bri = round(bri*8.) / 8.; }  // quantize to about 8 brightness levels\n\n  if (p.z<-1. || bri<0.) { fragColor = vec4(0,0,0,1); }\n  else {\n    float spe = 0.5*pow(bri,8.);  // shiny\n    if (FAITHFUL) { spe = 0.; }\n\n    fragColor = vec4(spe+bri*vec3(1,hue,0), 1);  // flame\n//    fragColor = vec4(spe+bri*vec3(0.125,hue,float(0xc8)/256.), 1);  // sky\n//    fragColor = vec4(spe+bri*vec3(1,.3+.6*hue,.25+.5*hue), 1);  // brain\n//    fragColor = vec4(spe+bri*vec3(1.-hue,.25,1), 1);  // alien\n//    fragColor = vec4(spe+bri*vec3(1,.75+hue*.25,.25+hue*.5), 1);  // platinum\n//    fragColor = vec4(spe+bri*vec3(hue*hue,.25+hue*.75,.75-hue*.25), 1);  // anodized titanium\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2Gz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[401, 401, 420, 420, 831], [905, 905, 937, 937, 1061], [1063, 1063, 1115, 1115, 2595]], "test": "untested"}
{"id": "fs2GWD", "name": "Bernoulli Lemniscate Intersect", "author": "oneshade", "description": "Ray intersection with Bernoulli's lemniscate (a special case of a Cassini oval).", "tags": ["raytracing", "ray", "raycasting", "quartic", "intersect", "bernoulli", "lemniscate"], "likes": 8, "viewed": 231, "published": 3, "date": "1617731262", "time_retrieved": "2024-07-30T19:28:14.257366", "image_code": "struct Hit4 {\n    int numHits;\n    vec4 hits;\n};\n\n// Quartic solver I made here: https://www.shadertoy.com/view/fsB3Wt\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of ^3 + ra * ^2 + rb *  + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\n// Intersection\nHit4 iBernoulliLemniscate(in vec3 ro, in vec3 rd, in float iso) {\n    vec3 oo = ro * ro;\n    vec3 dd = rd * rd;\n    vec3 od = ro * rd;\n\n    float a = dot(dd, dd) + 2.0 * ((dd.y + dd.z) * dd.x + dd.y * dd.z);\n    float b = 4.0 * (od.x + od.y + od.z) * (dd.x + dd.y + dd.z);\n\n    float c1 = 2.0 * ((oo.y + oo.z - 1.0) * dd.x + (oo.x + oo.z + 1.0) * dd.y + (oo.x + oo.y + 1.0) * dd.z);\n    float c2 = 6.0 * dot(oo, dd) + 8.0 * ((od.y + od.z) * od.x + od.y * od.z);\n    float c = c1 + c2;\n\n    float sq = oo.x + oo.y + oo.z;\n    float d = 4.0 * ((sq - 1.0) * od.x + (sq + 1.0) * (od.y + od.z));\n    float e = dot(oo, oo) + 2.0 * ((oo.y + oo.z - 1.0) * oo.x + (oo.z + 1.0) * oo.y + oo.z) - iso;\n\n    vec4 roots;\n    int numRoots = solveQuartic(a, b, c, d, e, roots);\n\n    return  Hit4(numRoots, roots);\n}\n\n// Normal\nvec3 nBernoulliLemniscate(in vec3 p, in float iso) {\n    return normalize(p * p * p + vec3(-p.x, p.yz) + p.xxx * p.yxx * p.yyz + p.xyy * p.zzy * p.zzz);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    // Animate\n    float iso = 0.0;//0.1 * sin(iTime);\n\n    // Find the closest hit in front of the camera\n    Hit4 hit = iBernoulliLemniscate(ro, rd, iso);\n    float t = 1000000000.0;\n    vec3 hitPos;\n    for (int n=0; n < int(hit.numHits); n++) {\n        vec3 hitCandid = ro + rd * hit.hits[n];\n        if (hit.hits[n] > 0.0 && hit.hits[n] < t) {\n            t = hit.hits[n];\n            hitPos = hitCandid;\n        }\n    }\n\n    // Render the shape if hitting\n    if (t < 1000000000.0) {\n        vec3 n = nBernoulliLemniscate(hitPos, iso);\n        float diff = abs(dot(n, -rd));\n        float checkers = mod(floor(atan(hitPos.y, hitPos.z) * 1.57) + floor(hitPos.x * 3.0), 2.0);\n        fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25);\n        fragColor.rgb *= diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2GWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 119, 143, 143, 186], [187, 187, 283, 283, 2732], [2734, 2750, 2815, 2815, 3549], [3551, 3561, 3613, 3613, 3715], [3717, 3717, 3772, 3772, 5283]], "test": "untested"}
{"id": "NdSGz3", "name": "The Tesseract", "author": "z0rg", "description": "Tesseract", "tags": ["3d", "tesseract", "cubeception", "cucube"], "likes": 4, "viewed": 433, "published": 3, "date": "1617730992", "time_retrieved": "2024-07-30T19:28:15.050246", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    col += .1*texture(iChannel0, ((uv-vec2(.5))*vec2(-1.,1.)*.5)+vec2(.5)).yxz;\n    col += col.xyz*(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n    fragColor = vec4(col.zxy,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n\nfloat _time;\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(uv.x*r+-uv.y*u));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.);\n    for (int i = 0; i < 5; ++i)\n    {\n        p.xy *= r2d(_time);\n        p.xz *= r2d(float(i));\n        p *= .8;\n    float cucube = _cucube(p, vec3(.5), vec3(.01));\n    acc = _min(acc, vec2(cucube, float(i)));\n    }\n    \n    return acc;\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+= rd*res.x;\n    }\n    vec3(-1.);\n}\n\nvec3 getNormal(float d, vec3 p)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d) - vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 grad(float f)\n{\n    vec3 cols[4];\n    cols[0] = vec3(0.1);\n    cols[1] = vec3(1.,0.,0.);\n    cols[2] = vec3(1.000,0.427,0.180);\n    cols[3] = vec3(1.000,0.608,0.439);\n    \n    f = f*3.0;\n    vec3 prev = cols[int(f)];\n    vec3 next = cols[int(min(f+1.,3.))];\n    return mix(prev, next, fract(f));\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;\n    float d = 11.;\n    vec3 ro = vec3(sin(_time)*d,0.,cos(_time)*d);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 256);\n    if (res.y > 0.)\n    {\n        vec3 p = ro + rd*res.y;\n        vec3 n = getNormal(res.x, p);\n        \n        col = n*.5+.5;\n        col = grad(res.z/5.);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _time = .5*iTime+texture(iChannel0, fragCoord/8.).x*iTimeDelta;\n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    col += sat(grad(1.-sat(length(uv*2.)))*2.)*(1.-sat(length(uv*4.)));\n    col = mix(col, texture(iChannel1, ouv).xyz, .99*(sin(iTime)*.5+.5));\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSGz3.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 717]], "test": "untested"}
{"id": "fsB3z3", "name": "StereoSwap Transition", "author": "turboplay", "description": "A nice transition from glsl-transitions.", "tags": ["transition", "crossfade"], "likes": 6, "viewed": 378, "published": 3, "date": "1617710609", "time_retrieved": "2024-07-30T19:28:15.913937", "image_code": "// https://gl-transitions.com/editor/StereoViewer\n// Tunable parameters\n// How much to zoom (out) for the effect ~ 0.5 - 1.0\nfloat zoom = 0.88;\n// Corner radius as a fraction of the image height\nfloat corner_radius = 0.22;\n// author: Ted Schundler\n// license: BSD 2 Clause\n// Free for use and modification by anyone with credit\n\n\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec2 c00 = vec2(0.0, 0.0); // the four corner points\nconst vec2 c01 = vec2(0.0, 1.0);\nconst vec2 c11 = vec2(1.0, 1.0);\nconst vec2 c10 = vec2(1.0, 0.0);\n\n// Check if a point is within a given corner\nbool in_corner(vec2 p, vec2 corner, vec2 radius) {\n  // determine the direction we want to be filled\n  vec2 axis = (c11 - corner) - corner;\n\n  // warp the point so we are always testing the bottom left point with the\n  // circle centered on the origin\n  p = p - (corner + axis * radius);\n  p *= axis / radius;\n  return (p.x > 0.0 && p.y > -1.0) || (p.y > 0.0 && p.x > -1.0) || dot(p, p) < 1.0;\n}\n\n// Check all four corners\n// return a float for v2 for anti-aliasing?\nbool test_rounded_mask(vec2 p, vec2 corner_size) {\n  return\n      in_corner(p, c00, corner_size) &&\n      in_corner(p, c01, corner_size) &&\n      in_corner(p, c10, corner_size) &&\n      in_corner(p, c11, corner_size);\n}\n\n// Screen blend mode - https://en.wikipedia.org/wiki/Blend_modes\n// This more closely approximates what you see than linear blending\nvec4 screen(vec4 a, vec4 b) {\n  return 1.0 - (1.0 - a) * (1.0 -b);\n}\n\n// Given RGBA, find a value that when screened with itself\n// will yield the original value.\nvec4 unscreen(vec4 c) {\n  return 1.0 - sqrt(1.0 - c);\n}\n\n// Grab a pixel, only if it isn't masked out by the rounded corners\nvec4 sample_with_corners_from(vec2 p, vec2 corner_size) {\n  p = (p - 0.5) / zoom + 0.5;\n  if (!test_rounded_mask(p, corner_size)) {\n    return black;\n  }\n  return unscreen(texture(iChannel0,p));\n}\n\nvec4 sample_with_corners_to(vec2 p, vec2 corner_size) {\n  p = (p - 0.5) / zoom + 0.5;\n  if (!test_rounded_mask(p, corner_size)) {\n    return black;\n  }\n  return unscreen(texture(iChannel1,p));\n}\n\n// special sampling used when zooming - extra zoom parameter and don't unscreen\nvec4 simple_sample_with_corners_from(vec2 p, vec2 corner_size, float zoom_amt) {\n  p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5;\n  if (!test_rounded_mask(p, corner_size)) {\n    return black;\n  }\n  return texture(iChannel0,p);\n}\n\nvec4 simple_sample_with_corners_to(vec2 p, vec2 corner_size, float zoom_amt) {\n  p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5;\n  if (!test_rounded_mask(p, corner_size)) {\n    return black;\n  }\n  return texture(iChannel1,p);\n}\n\n// Basic 2D affine transform matrix helpers\n// These really shouldn't be used in a fragment shader - I should work out the\n// the math for a translate & rotate function as a pair of dot products instead\n\nmat3 rotate2d(float angle, float ratio) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(\n    c, s ,0.0,\n    -s, c, 0.0,\n    0.0, 0.0, 1.0);\n}\n\nmat3 translate2d(float x, float y) {\n  return mat3(\n    1.0, 0.0, 0,\n    0.0, 1.0, 0,\n    -x, -y, 1.0);\n}\n\nmat3 scale2d(float x, float y) {\n  return mat3(\n    x, 0.0, 0,\n    0.0, y, 0,\n    0, 0, 1.0);\n}\n\n// Split an image and rotate one up and one down along off screen pivot points\nvec4 get_cross_rotated(vec3 p3, float angle, vec2 corner_size, float ratio) {\n  angle = angle * angle; // easing\n  angle /= 2.4; // works out to be a good number of radians\n\n  mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio);\n  mat3 unscale_and_uncenter = scale2d(1.0, 1.0/ratio) * translate2d(0.5,0.5);\n  mat3 slide_left = translate2d(-2.0,0.0);\n  mat3 slide_right = translate2d(2.0,0.0);\n  mat3 rotate = rotate2d(angle, ratio);\n\n  mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter;\n  mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter;\n\n  vec4 a = sample_with_corners_from((op_a * p3).xy, corner_size);\n  vec4 b = sample_with_corners_from((op_b * p3).xy, corner_size);\n\n  return screen(a, b);\n}\n\n// Image stays put, but this time move two masks\nvec4 get_cross_masked(vec3 p3, float angle, vec2 corner_size, float ratio) {\n  angle = 1.0 - angle;\n  angle = angle * angle; // easing\n  angle /= 2.4;\n\n  vec4 img;\n\n  mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio);\n  mat3 unscale_and_uncenter = scale2d(1.0 / zoom, 1.0 / (zoom * ratio)) * translate2d(0.5,0.5);\n  mat3 slide_left = translate2d(-2.0,0.0);\n  mat3 slide_right = translate2d(2.0,0.0);\n  mat3 rotate = rotate2d(angle, ratio);\n\n  mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter;\n  mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter;\n\n  bool mask_a = test_rounded_mask((op_a * p3).xy, corner_size);\n  bool mask_b = test_rounded_mask((op_b * p3).xy, corner_size);\n\n  if (mask_a || mask_b) {\n    img = sample_with_corners_to(p3.xy, corner_size);\n    return screen(mask_a ? img : black, mask_b ? img : black);\n  } else {\n    return black;\n  }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord / iResolution.xy;\n float ratio = iResolution.x/ iResolution.y;\n float progress = mod(iTime/10.,1.);\n float a;\n  vec2 p=uv.xy/vec2(1.0).xy;\n  vec3 p3 = vec3(p.xy, 1.0); // for 2D matrix transforms\n\n  // corner is warped to represent to size after mapping to 1.0, 1.0\n  vec2 corner_size = vec2(corner_radius / ratio, corner_radius);\n\n  if (progress <= 0.0) {\n    // 0.0: start with the base frame always\n    fragColor = texture(iChannel0,p);\n  } else if (progress < 0.1) {\n    // 0.0-0.1: zoom out and add rounded corners\n    a = progress / 0.1;\n    fragColor =  simple_sample_with_corners_from(p, corner_size * a, a);\n  } else if (progress < 0.48) {\n    // 0.1-0.48: Split original image apart\n    a = (progress - 0.1)/0.38;\n    fragColor= get_cross_rotated(p3, a, corner_size, ratio);\n  } else if (progress < 0.9) {\n    // 0.48-0.52: black\n    // 0.52 - 0.9: unmask new image\n    fragColor = get_cross_masked(p3, (progress - 0.52)/0.38, corner_size, ratio);\n  } else if (progress < 1.0) {\n    // zoom out and add rounded corners\n    a = (1.0 - progress) / 0.1;\n    fragColor = simple_sample_with_corners_to(p, corner_size * a, a);\n  } else {\n    // 1.0 end with base frame\n    fragColor = texture(iChannel1,p);\n  }\n  \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsB3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[535, 580, 630, 680, 975], [977, 1047, 1097, 1097, 1266], [1268, 1401, 1430, 1430, 1469], [1471, 1564, 1587, 1587, 1619], [1621, 1689, 1746, 1746, 1885], [1887, 1887, 1942, 1942, 2081], [2083, 2163, 2243, 2243, 2402], [2404, 2404, 2482, 2482, 2641], [2847, 2847, 2888, 2888, 3004], [3006, 3006, 3042, 3042, 3111], [3113, 3113, 3145, 3145, 3208], [3210, 3289, 3366, 3366, 4081], [4083, 4132, 4208, 4208, 5082], [5086, 5086, 5143, 5143, 6384]], "test": "untested"}
{"id": "sd23RV", "name": "Chaos Condenser", "author": "Tater", "description": "this might be my favorite shader I've made. ", "tags": ["2d", "invert", "spinning", "spikes"], "likes": 6, "viewed": 331, "published": 3, "date": "1617705020", "time_retrieved": "2024-07-30T19:28:16.689862", "image_code": "#define rot(a) mat2( cos(a),-sin(a),sin(a),cos(a) )\n#define pi 3.14159265359\nfloat sts(float x){ return x-sin(x); }\nfloat rotation (float t){\n    float r = sin(t*2.)*sin(t);\n    r += t;\n    r+=2.0*abs(t*0.2);\n    r+=smoothstep(0.0,1.0,sin(t*0.25))*15.0;\n    r+=tan(sin(t)*0.4);\n    r+=smoothstep(0.5,1.0,sin(t*0.25+2.0))*sin(floor(t*10.0)/10.0);\n    if(mod(t,20.)>10.){ r=-r; }\n    r -= sts(sts(sts(t*2.0)))*pi/8.;\n    return r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    float t = iTime*0.5;\n    \n    float aa = 1.0/R.y;\n    float th = atan(-uv.y,-uv.x)/(2.0*pi)+0.5;\n    float spks = 15.0;\n    float thin = 2.5;\n    float rt = 3.3; \n    float r = 0.2;\n    vec3 col =vec3(0);\n    t*=3.0;\n\n    vec3 glowc = vec3(0);\n    vec3 glowc1= vec3(0.875,0.000,0.000);\n    vec3 glowc2 = vec3(0.200,0.133,1.000);\n    float num =250.0+50.0*sin(t);\n    \n    for(float i = 0.0; i <spks; i++){\n        r=rotation(t+0.1*i);\n        vec2 tuv = uv*rot(((r*rt)*pi/spks));\n        \n        glowc = glowc1;\n        for(int j = 0; j<2;j++){\n            tuv*=2.0-((i)/spks);\n            aa=(1.0/R.y)*(2.0-((i)/spks));\n            float edge = abs(tuv.x)+(tuv.y+0.5)*(0.4/thin);\n            float glow = abs(1.0 / (num * edge));\n            col = mix(col,vec3(0.4),smoothstep(edge-aa,edge+aa,0.1/thin)*smoothstep(tuv.x-aa,tuv.x+aa,0.0));\n            col = mix(col,vec3(0.5),smoothstep(edge-aa,edge+aa,0.1/thin)*smoothstep(0.0-aa,0.0+aa,tuv.x));\n            col +=vec3(0.2) * smoothstep(edge-aa,edge+aa,0.1/thin) * smoothstep(edge-aa,edge+aa,0.01/thin);\n            col += glowc*smoothstep(edge-aa,edge+aa,0.1/thin) * smoothstep(-0.35-aa,-0.35+aa,tuv.y);\n            col = clamp(col,0.,1.);\n            col+= mix(col,glow*(glowc+0.2),1.0-step(length(col),0.0));\n            tuv = uv*rot(pi+((r*rt)*pi/spks));\n            glowc=glowc2;\n        }\n        col = col - 0.05;\n    }\n    col = clamp(col,0.,1.);\n    vec2 tuv = uv;\n    uv.x+=sin(uv.y*200.0+t)*0.0035;\n    uv.y+=sin(tuv.x*200.0+t)*0.0035;\n    float glow = abs(1.0 / (85.0 * length(uv)));\n    float smst= 0.0025;\n    float cscale = (sin(t)*0.5+0.5)*0.035;\n    col+=(1.0-(vec3(0.208,1.000,0.267)+1.0)*(glow))\n    *smoothstep(cscale+0.905-smst,cscale+0.905+smst,1.0-length(uv));\n    if(mod(t,8.0)>4.0)col=(1.0-col);\n    if(mod(t,3.5)>3.2)col=(1.0-col);\n    if(mod(t,4.0)>3.8+sin(t)){\n        float ring = smoothstep(1.0-0.275-aa,1.0-0.275+aa,1.0-length(tuv))\n        -smoothstep(1.0-0.175-aa,1.0-0.175+aa,1.0-length(tuv));\n        col = mix(col,1.0-col,ring);}\n    if(mod(t,5.0)>4.3+sin(t)){\n        float ring = smoothstep(1.0-0.4-aa,1.0-0.4+aa,1.0-length(tuv))\n        -smoothstep(1.0-0.35-aa,1.0-0.35+aa,1.0-length(tuv));\n        col = mix(col,1.0-col,ring);}\n    if(mod(t,8.0)>7.0+sin(t+0.3)){\n        vec2 tuv2 = tuv*3.0; tuv2.y*=1.5; tuv2.y+=0.35;\n        tuv2=fract(tuv2*1.0+0.275);\n        float inv = clamp(step(tuv2.y,0.25)-step(tuv2.x,0.55),0.0,1.0);\n        col = mix(col,1.0-col,inv);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd23RV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 96, 96, 115], [116, 116, 141, 141, 430], [431, 431, 488, 488, 3059]], "test": "untested"}
{"id": "NdBGR3", "name": "Mars Copter", "author": "dr2", "description": "First flight (more of a da Vinci design)", "tags": ["flight", "nasa", "helicopter"], "likes": 12, "viewed": 303, "published": 3, "date": "1617703788", "time_retrieved": "2024-07-30T19:28:17.530614", "image_code": "// \"Mars Copter\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm2e (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nvec2 hipPos, ftPos;\nfloat tCur, dstFar, legLenU, legLenD, aU, aD, pPitch, pRot, grndScl;\nint idObj;\nconst int idBase = 1, idLeg = 2, idAxl = 3, idProp = 4;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndDf (vec3 p)\n{\n  vec3 q;\n  float d, h, a, r, s, f;\n  q = p / grndScl;\n  r = length (q.xz);\n  d = p.y;\n  if (r > 0.) {\n    a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n    s = sqrt (r) / (2. * pi);\n    f = 32.;\n    h = 2.5 * s * mix (Fbm2e (f * vec2 (s, a + 1.)), Fbm2e (f * vec2 (s, a)), a);\n    d = max (r - 20., q.y - mix (s, h, smoothstep (1.4, 2.2, r)) * smoothstep (1.4, 2.6, r));\n  }\n  return grndScl * d;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.001, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (GrndDf (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid SetConf ()\n{\n  vec2 knPos, r, a, b;\n  float tCyc, rl, s, t;\n  legLenU = 2.;\n  legLenD = 3.;\n  tCyc = 20.;\n  t = mod (tCur / tCyc, 1.);\n  pPitch = 0.05 * pi * (1. + SmoothBump (0.1, 0.45, 0.03, t));\n  hipPos = vec2 (1.5, 0.5 * (legLenU + legLenD) + (9. + 6. * Hashff (floor (tCur / tCyc))) *\n     SmoothBump (0.3, 0.7, 0.2, t));\n  ftPos = vec2 (1.8 + 2.2 * (1. - smoothstep (0.2, 1.5, hipPos.y - (legLenU + legLenD))), 0.);\n  r = ftPos - hipPos;\n  rl = length (r);\n  b = vec2 (legLenU, legLenD);\n  if (rl < legLenU + legLenD) {\n    a = acos ((rl * rl + (b.y * b.y - b.x * b.x) * vec2 (-1., 1.)) / (2. * rl * b));\n    s = sign (r.x);\n    knPos = vec2 (hipPos.x, ftPos.y) + b * sin (vec2 ((a.x + 0.5 * pi) * s, a.y) -\n       asin (r.y / rl) * vec2 (- s, 1.));\n    r = knPos - hipPos;\n    aU = atan (r.y, r.x);\n    r = ftPos - knPos;\n    aD = atan (r.y, r.x);\n  } else {\n    aU = asin (r.x / (legLenU + legLenD)) - 0.5 * pi;\n    aD = aU;\n  }\n  pRot = 3. * pi * tCur;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 fb;\n  float dMin, d;\n  dMin = dstFar;\n  fb = normalize (vec2 (1.2, 1.));\n  for (float k = -1. + float (VAR_ZERO); k <= 1.; k += 2.) {\n    q = p;\n    q.xz = Rot2D (q.xz, k * pRot);\n    q.y -= hipPos.y + 2.4 + 1.2 * k;\n    d = PrRoundCylDf (q.xzy, 0.2 - 0.05 * k, 0.01, 1.2);\n    DMINQ (idAxl);\n    q.y -= 1.;\n    d = min (max (PrRoundCylDf (vec3 (q.x, Rot2D (q.yz, k * pPitch)).xzy, 3., 0.02, 0.01),\n       dot (vec2 (q.x, abs (q.z)), fb)),\n       max (PrRoundCylDf (vec3 (q.x, Rot2D (q.yz, - k * pPitch)).xzy, 3., 0.02, 0.01),\n       dot (vec2 (- q.x, abs (q.z)), fb)));\n    DMINQ (idProp);\n  }\n  q = p;\n  q.y -= hipPos.y + 0.1;\n  d = PrRoundCylDf (q.xzy, hipPos.x, 0.05, 0.2);\n  q.y -= 0.4;\n  d = min (d, PrRoundCylDf (q.xzy, 0.35 * hipPos.x, 0.05, 0.15));\n  DMINQ (idBase);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi)) + 0.5) / 6.);\n  q.xy -= hipPos * vec2 (-1., 1.);\n  q.xy = Rot2D (q.xy, aU);\n  q.x += 0.5 * legLenU;\n  d = PrCapsDf (q.yzx, 0.1 * (0.8 + 0.2 * q.x / (0.5 * legLenU)) / 0.6, 0.5 * legLenU);\n  DMINQ (idLeg);\n  q.x += 0.5 * legLenU;\n  q.xy = Rot2D (q.xy, aD - aU);\n  q.x += 0.5 * legLenD;\n  d = PrCapsDf (q.yzx, 0.1 * (0.9 + 0.1 * q.x / (0.5 * legLenD)), 0.5 * legLenD);\n  DMINQ (idLeg);\n  q.x += 0.5 * legLenD;\n  q.xy = Rot2D (q.xy, 0.5 * pi - aD);\n  q.x -= -0.02;\n  d = PrRoundCylDf (q.yzx, 0.3, 0.02, 0.05);\n  DMINQ (idLeg);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar ) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 2. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec4 GrndCol (vec3 ro, vec3 vn)\n{\n  vec4 col4;\n  col4 = vec4 (0.9, 0.5, 0.2, 0.) * (0.7 + 0.3 * Fbm2 (ro.xz));\n  if (ro.y > -0.1) {\n    col4 = mix (col4, 0.8 * col4, smoothstep (0.2, 0.7, 1. - vn.y));\n    col4 = mix (col4, 1.1 * col4, smoothstep (0.6, 0.9, ro.y / grndScl +\n       0.2 * sin (32. * atan (ro.z, - ro.x))));\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, sh;\n  SetConf ();\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstGrnd, dstObj) < dstFar) {\n    if (dstGrnd < dstObj) {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      vn = VaryNf (0.5 * ro, vn, 4. - 2. * smoothstep (0.7, 0.9, dstGrnd / (3. * grndScl)));\n      col4 = GrndCol (ro, vn);\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == idBase) {\n        col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.02,\n           abs (length (qHit.xz) - 1.1) - 0.1));\n      } else if (idObj == idLeg) {\n        col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * sin (8. * pi * qHit.x));\n      } else if (idObj == idAxl) {\n        col4 = vec4 (0.8, 1., 0.8, 0.2) * (1. - 0.2 * sin (4. * atan (qHit.z, qHit.x)));\n      } else if (idObj == idProp) {\n        col4 = vec4 (1., 0.9, 0.8, 0.2) * (0.9 + 0.1 * sin (8. * pi * length (qHit.xz)));\n      }\n    }\n    sh = ObjSShadow (ro + 0.001 * vn, sunDir);\n    col = col4.rgb * (0.2 + 0.1 * max (dot (vn, normalize (vec3 (- sunDir.xz, 0.)).xzy), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n  } else col = vec3 (0.3, 0.2, 0.1) + StarPat (rd, 8.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.03 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 0.5 * pi * mPtr.y;\n  } else {\n    t = mod (0.01 * tCur, 2.);\n    az = 1.5 * pi * (0.5 - abs ((floor (8. * t) + smoothstep (0.9, 1., mod (8. * t, 1.))) / 8. - 1.));\n  }\n  el = clamp (el, -0.3 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  grndScl = 50.;\n  ro = vuMat * vec3 (0., 0., -1.4) * grndScl;\n  ro.y += 0.2 * grndScl;\n  zmFac = 5.;\n  dstFar = 10. * grndScl;\n  sunDir = normalize (vec3 (0.3, 1., 1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2e (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 6; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.96875);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBGR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[778, 778, 801, 801, 1196], [1198, 1198, 1232, 1232, 1723], [1725, 1725, 1747, 1747, 2003], [2005, 2005, 2022, 2022, 2974], [2976, 2976, 2998, 2998, 4417], [4419, 4419, 4452, 4452, 4637], [4639, 4639, 4660, 4660, 4917], [4919, 4919, 4956, 4956, 5199], [5201, 5201, 5236, 5236, 5689], [5691, 5691, 5724, 5724, 6033], [6035, 6035, 6070, 6070, 7402], [7446, 7446, 7502, 7502, 8712], [8714, 8714, 8771, 8771, 8847], [8849, 8849, 8892, 8892, 8956], [8958, 8958, 8980, 8980, 9018], [9020, 9020, 9077, 9077, 9160], [9162, 9162, 9198, 9198, 9404], [9406, 9406, 9436, 9436, 9549], [9583, 9583, 9607, 9607, 9644], [9646, 9646, 9670, 9670, 9800], [9802, 9802, 9827, 9827, 10013], [10015, 10015, 10036, 10036, 10191], [10193, 10193, 10215, 10215, 10371], [10373, 10373, 10402, 10402, 10614], [10616, 10616, 10655, 10655, 10840]], "test": "untested"}
{"id": "ss2GRK", "name": "invasion UFO ", "author": "jorge2017a1", "description": "invasion Ufo", "tags": ["invasionufo"], "likes": 4, "viewed": 232, "published": 3, "date": "1617672664", "time_retrieved": "2024-07-30T19:28:18.476086", "image_code": "//por jorge2017a1-\n//Referencia dr2---cloud\n\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///-----------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n///-----------------------------------------------\n///-----------------------------------------------------\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec3 segundaNave(vec3 p)\n{\n    vec3 pp=p;\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    \n    float sp1= sdSphere( p, 12.0 );\n    float sb1= sdBox( p-vec3(0.0,-6.5,0.0), vec3(12.5,7.0,12.5) );\n    float dif= differenceSDF(sp1, sb1);\n    \n    \n    float numItemA=10.0;\n    float numItemB=6.0;\n    float tau = atan(1.0) * 8.0;\n    \n    p= rotate_x( p-vec3(0.0,1.0,0.0), radians(90.0));\n    vec3 rep2 = opAngRep(p, tau / numItemA);\n    rep2= rotate_z( rep2-vec3(10.0,0.0,0.0), radians(270.0));\n\n    pp= rotate_x( pp-vec3(0.0,-1.0,0.0), radians(90.0));\n    vec3 rep3 = opAngRep(pp, tau / numItemB);\n    rep3= rotate_x( rep3, radians(90.0));\n    rep3= rotate_z( rep3, radians(340.0));\n    \n    float scc1= sdCappedCone( rep2, 9.0, 0.025, 1.2 );\n    float scc2= sdCappedCone( rep3-vec3(7.0,1.0,0.0), 9.5, 1.2,0.025 );\n    res =opU3(res, vec3(dif,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(scc1,32.0,-1.0));\n    res =opU3(res, vec3(scc2,6.0,-1.0));\n    return res;\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n    float planeDist1 = p.y+0.0;  //piso inf\n    \n    res =opU3(res, vec3(planeDist1,-1.0,3.0)); \n    \n    \n    p.y+=4.0*sin(iTime*5.0)-10.0;\n    p.z=opRep1D( p.z+ iTime*20.0, 45.0 );\n    p.x=opRep1D( p.x, 55.0 );\n   \n    vec3 sn1= segundaNave(p-vec3(0.0,15.0,0.0));\n    res =opU3(res, sn1);\n    //return (dist, id_color, id_material)\n    return res;\n}\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= MAX_STEPS; i++) \n    {  \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == MAX_STEPS)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n\n        if(dO>MAX_DIST)\n        { mObj.hitbln = false;    minDist = dO;    break; } \n        \n        dO += dS.x;\n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n\n  if(id_material== 3.0 )\n    { \n          return checkerBoard(mObj.p.x*0.25, mObj.p.z*0.25, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n   \n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n////-----------------------------\n// Refencia dr2\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\n\nvec3 sunDir;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float cloudFac, w, f, s;float tCur;\n   \n   float  a = pi * (0.5 + 0.3 * sin (0.1 * iTime*5.0));\n    sunDir = normalize (vec3 (cos (a), 0.5, sin (a)));\n    \n     tCur = iTime*10.0;\n    if (rd.y > 0.) {\n  \t  ro.x += 2. * tCur;\n    \tp = 0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz);\n    \tw = 0.8;\n    \tf = 0.;\n    for (int j = 0; j < 4; j ++) \n    {\n    \tf += w * Noisefv2 (p);\n      \tw *= 0.5;\n      \tp *= 2.;\n    }\n        \n    cloudFac = clamp (3. * f * rd.y - 0.1, 0., 1.);\n        \n  }\n    else cloudFac = 0.;\n    \n  s = max (dot (rd, sunDir), 0.);\n    \n  col = vec3 (0.1, 0.2, 0.5) + 0.25 * pow (1. - max (rd.y, 0.), 8.) +\n     (0.35 * pow (s, 6.) + 0.65 * min (pow (s, 256.), 0.3));\n  return mix (col, vec3 (1.), cloudFac);\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n    \n    vec3 ro=vec3(15.0,4.0,-25.0+t);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro; light_pos2+=ro;\n   \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n     col = SkyCol (ro, rd);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2GRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 585, 621, 621, 642], [643, 643, 675, 675, 759], [761, 805, 852, 852, 879], [881, 881, 924, 924, 951], [953, 953, 1001, 1001, 1029], [1030, 1114, 1150, 1150, 1195], [1196, 1261, 1295, 1295, 1393], [1394, 1394, 1428, 1428, 1520], [1521, 1521, 1555, 1555, 1647], [1648, 1688, 1722, 1722, 1819], [1821, 1872, 1897, 1897, 1916], [1917, 1917, 1942, 1942, 1961], [1962, 1962, 1998, 1998, 2026], [2028, 2028, 2087, 2087, 2400], [2402, 2510, 2544, 2544, 2717], [2719, 2719, 2745, 2745, 3675], [3678, 3718, 3743, 3743, 4147], [4148, 4148, 4213, 4213, 4797], [4798, 4849, 4873, 4873, 5061], [5065, 5065, 5098, 5098, 5745], [5747, 5801, 5837, 5837, 6071], [6128, 6162, 6242, 6242, 6519], [6562, 6613, 6660, 6660, 6853], [6907, 6907, 7000, 7000, 7279], [7477, 7477, 7501, 7501, 7548], [7550, 7550, 7575, 7575, 7754], [7756, 7756, 7781, 7781, 8140], [8157, 8157, 8189, 8189, 8944], [8947, 8996, 9053, 9053, 10332]], "test": "untested"}
{"id": "fs23zV", "name": "bitwise things", "author": "percentcer", "description": "Saw tweet https://twitter.com/aemkei/status/1378106731386040322, got curious", "tags": ["masking", "xor", "bits", "bitwise"], "likes": 7, "viewed": 280, "published": 3, "date": "1617666790", "time_retrieved": "2024-07-30T19:28:19.243036", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragCoord *= .2f;\n    fragCoord += iTime * 10.f;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    int on = 1;\n    \n    int intTime = int(iTime);\n    int cycle = intTime % 16;\n    \n    if (uv.x < .5f && uv.y < .5f) {\n        on = (x | y) % cycle;\n    } else if (uv.x < .5f) {\n        on = (x ^ y) % cycle;\n    }\n    else if (uv.y < .5f) {\n        on = (x * y) & (1 << cycle);\n    }\n    else {\n        on = (x ^ y) & cycle;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col * float(on), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs23zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 108, 774]], "test": "untested"}
{"id": "Ns23RV", "name": "Bayer Matrix Zone", "author": "wilkie", "description": "A bayer matrix dithered experiment.", "tags": ["dithering"], "likes": 5, "viewed": 401, "published": 3, "date": "1617660037", "time_retrieved": "2024-07-30T19:28:20.052870", "image_code": "\nconst float ResolutionDivisor = 4.0;\nconst float PaletteRGBSize = 4.0;\n\nfloat sineWave( float y ) {\n  return sin(y * 2.0 * 3.14159);\n}\n\nfloat triangleWave( float y ) {\n  return 2.0 / 3.14159 * asin(sin(2.0 * 3.14159 * y));\n}\n\nfloat quantize(float inp, float period)\n{\n\treturn floor((inp+period/2.)/period)*period;\n}\n\nfloat bayer4x4(vec2 uvScreenSpace, float divisor)\n{\n\tvec2 bayerCoord = floor(uvScreenSpace/divisor);\n\tbayerCoord = mod(bayerCoord, 4.);\n\n\tconst mat4 bayerMat = mat4(\n\t\t\t1,9,3,11,\n\t\t\t13,5,15,7,\n\t\t\t4,12,2,10,\n\t\t\t16,8,14,6) / 16.;\n\tint bayerIndex = int(bayerCoord.x + bayerCoord.y * 4.);\n\tif(bayerIndex == 0) return bayerMat[0][0];\n\tif(bayerIndex == 1) return bayerMat[0][1];\n\tif(bayerIndex == 2) return bayerMat[0][2];\n\tif(bayerIndex == 3) return bayerMat[0][3];\n\tif(bayerIndex == 4) return bayerMat[1][0];\n\tif(bayerIndex == 5) return bayerMat[1][1];\n\tif(bayerIndex == 6) return bayerMat[1][2];\n\tif(bayerIndex == 7) return bayerMat[1][3];\n\tif(bayerIndex == 8) return bayerMat[2][0];\n\tif(bayerIndex == 9) return bayerMat[2][1];\n\tif(bayerIndex == 10) return bayerMat[2][2];\n\tif(bayerIndex == 11) return bayerMat[2][3];\n\tif(bayerIndex == 12) return bayerMat[3][0];\n\tif(bayerIndex == 13) return bayerMat[3][1];\n\tif(bayerIndex == 14) return bayerMat[3][2];\n\treturn bayerMat[3][3];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,10,10));\n    \n    float timeEase = sin(iTime) / 32.0;\n    float timeStep = iTime / 4.0;\n\n    // Output to screen\n    float triangleWavePosition = 0.25 + triangleWave((uv.y + timeStep) * 8.0) / 64.0;\n    float sineWavePosition = 0.35 + timeEase * 2.0 + sineWave((uv.x + timeStep) * 6.0) / 32.0;\n    \n    if (uv.x < triangleWavePosition) {\n        fragColor = vec4(1.0, 0.5*col.x, 0.25*col.y, 1.0);\n    }\n    else if (uv.x < triangleWavePosition + 0.01) {\n        fragColor = vec4(0.5, 0.0, 0.0, 1.0);\n    }\n    else if (uv.y < sineWavePosition) {\n        col = 0.5 + 0.5 * cos(iTime / 2.0 + vec3(0,10,10));\n        vec3 color = vec3(0.5 * col.x, 0.25 + 0.5*col.y, 1.0);\n        vec3 quantizationPeriod = vec3(1./(PaletteRGBSize-1.));\n\n        float bayerResolution = max(1.0, floor(1.0 * iResolution.x / 200.0));\n        color += (bayer4x4(fragCoord, bayerResolution) - 0.5) * (quantizationPeriod);\n        \n\t    color = vec3(\n\t\t\tquantize(color.r, quantizationPeriod.r),\n\t\t\tquantize(color.g, quantizationPeriod.g),\n\t\t\tquantize(color.b, quantizationPeriod.b)\n\t\t );\n\n        fragColor = vec4(color, 1.0);\n    }\n    else if (uv.y < sineWavePosition + 0.01) {\n        fragColor = vec4(0.0, 0.0, 0.5, 1.0);\n    }\n    else {\n        // Number of circles horizontally\n        float numCirclesX = 10.0 * aspectRatio;\n        \n        // Number of circles veritically\n        float numCirclesY = 10.0;\n        \n        // Width of a circle\n        float circleW = 1.0 / numCirclesX;\n        float circleH = 1.0 / numCirclesY;\n        \n        // Get the position in this plane\n        float ux = uv.x + iTime / 64.0;\n        float uy = uv.y + iTime / 64.0;\n        \n        // Get the coordinate within the square that the circle resides within\n        float x = mod(ux, circleW);\n        float y = mod(uy, circleH);\n        \n        // And normalize it from 0.0 to 1.0\n        x /= circleW;\n        y /= circleH;\n        \n        // Get the x position of the circle in terms of 8 by 8 circles\n        float cx = mod(ux, (circleW * 8.0)) / (circleW * 8.0);\n        cx = floor(cx / (1.0 / 8.0));        \n        float cy = mod(uy, (circleH * 8.0)) / (circleH * 8.0);\n        cy = floor(cy / (1.0 / 8.0));\n        \n        // `cx` and `cy` are now a value between 0. and 7.\n        // Add cx and cy together to step them diagonally\n        cx = mod(cx + cy, 8.0);\n        \n        // Circle radii\n        float r = 0.25 + sin(iTime + cx/2.0) * 0.1;\n                       \n        // Assign a color (between 0.0 and 0.5)\n        cx = (abs(cx - 4.0)) / 8.0;\n        \n        float bayerResolution = max(1.0, floor(1.0 * iResolution.x / 800.0));\n        \n        if (pow(x - 0.5, 2.0) + pow(y - 0.5, 2.0) < pow(r, 2.0)) {\n            // Circle interior\n            vec3 color = vec3(0.7, cx, 0.7);\n            color += (bayer4x4(vec2(uv.x * iResolution.x, uv.y * iResolution.y), bayerResolution) - 0.5) * (1.0);\n            \n            vec3 quantizationPeriod = vec3(1.0);\n            \n            color = vec3(\n                quantize(color.r, quantizationPeriod.r),\n                quantize(color.g, quantizationPeriod.g),\n                quantize(color.b, quantizationPeriod.b)\n            );\n            \n            fragColor = vec4(color, 1.0);\n        }\n        else if (pow(x - 0.5, 2.0) + pow(y - 0.5, 2.0) < pow(r + 0.025 + 0.01 * -sin(iTime), 2.0)) {\n            // Circle border\n            fragColor = vec4(0.4, 0.1, 0.4, 1.0);\n        }\n        else {\n            // Circle exterior background\n            vec3 color = vec3(0.9, 0.9, 0.9);\n            color += (bayer4x4(vec2(uv.x * iResolution.x, uv.y * iResolution.y), bayerResolution) - 0.5) * (1.0);\n            \n            vec3 quantizationPeriod = vec3(1.0);\n            \n            color = vec3(\n                quantize(color.r, quantizationPeriod.r),\n                quantize(color.g, quantizationPeriod.g),\n                quantize(color.b, quantizationPeriod.b)\n            );\n            \n            if (color.x == 1.0) {\n                fragColor = vec4(color, 1.0);\n            }\n            else {\n                fragColor = vec4(0.9, 0.9, 0.9, 1.0);\n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23RV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 100, 100, 135], [137, 137, 168, 168, 225], [227, 227, 268, 268, 316], [318, 318, 369, 369, 1293], [1295, 1295, 1352, 1402, 5739]], "test": "untested"}
{"id": "ss2GRG", "name": "Ray-Egg Intersect", "author": "oneshade", "description": "An egg.", "tags": ["3d", "raytracing", "ray", "raycasting", "intersect", "egg"], "likes": 12, "viewed": 131, "published": 3, "date": "1617659007", "time_retrieved": "2024-07-30T19:28:20.867692", "image_code": "// Hide unwanted bits (just a huge plane with a hole in it)\n#define HIDE_EXCESS\n\n// RGB to decimal conversion\n#define rgb(r, g, b) vec3(r, g, b) / 255.0\n\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d, minCplx = 1.0;\n\n    float d0 = b * b - 3.0 * a * c;\n    float d1 = (2.0 * b * b - 9.0 * a * c) * b + 27.0 * a * a * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n    a *= 3.0;\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) < 1e-3 && abs(C.y) < 1e-3) C = q < 0.0 ? vec2(d1, -j) : vec2(d1 - j, 0.0); // Switch sign if C=0\n    C = sin(atan(C.y, C.x) / 3.0 + vec2(1.57079632679, 0.0)) * pow(0.25 * dot(C, C), 1.0 / 6.0);\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, h < 0.0 ? 1 : 3);\n    vec2 e = vec2(1.0, 0.0);\n    for (int k=0; k < (h < 0.0 ? 2 : 3); k++) {\n        vec2 m = e * mat2(C.x, -C.y, C.yx); // Complex multiplication\n        e *= mat2(-0.5, -0.86602540378, 0.86602540378, -0.5); // Raise cube root of unity to next power\n        vec2 root = (vec2(-d0, d0) * m / dot(m, m) - vec2(b, 0.0) - m) / a;\n        if (h < 0.0 ? (abs(root.y) < minCplx) : true) roots[h < 0.0 ? 0 : k] = root.x, minCplx = abs(root.y);\n    }\n\n    return roots;\n}\n\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots[0] = 1.0 / roots[0];\n    if (roots[3] > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\n// Intersection\n// Implicit equation: (y + 2)(x^2 + z^2) + y^2 - 1\nvec4 iEgg(in vec3 ro, in vec3 rd) {\n    float xxzz = dot(ro.xz, ro.xz);\n    float uuww = dot(rd.xz, rd.xz);\n    float xuzw = dot(ro.xz, rd.xz);\n    float y2 = ro.y + 2.0;\n\n    float a = uuww * rd.y;\n    float b = 2.0 * (rd.y * xuzw + uuww) + uuww * ro.y + rd.y * rd.y;\n    float c = 2.0 * (y2 * xuzw + ro.y * rd.y) + xxzz * rd.y;\n    float d = y2 * xxzz + ro.y * ro.y - 1.0;\n\n    return solveCubic2(a, b, c, d);\n}\n\n// Normal\nvec3 nEgg(in vec3 p) {\n    return normalize(vec3(2.0 * p.xz + p.xy * p.yz, 0.5 * dot(p.xz, p.xz) + p.y).xzy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 4.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    // Find the closest hit\n    vec4 hit = iEgg(ro, rd);\n    float t = 1000000000.0;\n    vec3 hitPos;\n    for (int n=0; n < int(hit[3]); n++) {\n        vec3 hitCandid = ro + rd * hit[n];\n        bool notExcess = true;\n\n        #ifdef HIDE_EXCESS\n        notExcess = hitCandid.y > -1.0;\n        #endif\n\n        if (hit[n] > 0.0 && hit[n] < t && notExcess) {\n            t = hit[n];\n            hitPos = hitCandid;\n        }\n    }\n\n    // Render the shape if hitting\n    if (t < 1000000000.0) {\n        vec3 n = nEgg(hitPos);\n        float diff = abs(dot(n, -rd));\n        fragColor.rgb = rgb(64, 224, 208);\n        fragColor.rgb *= diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2GRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 219, 219, 1321], [1323, 1323, 1389, 1389, 1532], [1534, 1601, 1636, 1636, 2014], [2016, 2026, 2048, 2048, 2137], [2139, 2139, 2194, 2194, 3520]], "test": "untested"}
{"id": "7sSGRV", "name": "A Lonely Cloud", "author": "CustomPhase", "description": "Value noise is ugly, but i couldnt find any other decent noise that would be fast enough.", "tags": ["raymarching", "volumetric", "cineshader"], "likes": 47, "viewed": 9255, "published": 3, "date": "1617642719", "time_retrieved": "2024-07-30T19:28:21.643617", "image_code": "#define CAMERA_DISTANCE 2.4\n#define CAMERA_SPIN_SPEED 0.13\n#define FOV_MULTIPLIER 0.8\n#define SUN_DIR normalize(vec3(1,0.8,0))\n#define SUN_COLOR vec3(2,1.6,0.9)*2.3\n#define SCATTERING_MULTIPLIER 0.0\n#define CLOUD_SIZE vec3(2.6,1.1,2.6)\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nfloat rayPlaneIntersect(vec3 ro, vec3 rd, vec3 center, vec3 normal) {\n    float denom = dot(normal, rd);\n    if (abs(denom) > 0.0001f) // your favorite epsilon\n    {\n        float t = dot(center - ro, normal) / denom;\n        return t; // you might want to allow an epsilon here too\n    }\n    return -1.;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.-1.;\n}\n\nvec3 skyColor(vec3 viewDir, vec3 camPos) {\n    float horizonNoise = smoothstep(-0.2, 0.9, noise(viewDir * vec3(8,36,8))+noise(viewDir * vec3(28,56,28))*0.5);\n    float skyExtinction1 = exp(-max(0., abs(viewDir.y)*28. - horizonNoise*1.8));\n    float skyExtinction2 = exp(-max(0., abs(viewDir.y)*12. - horizonNoise*0.5));\n    vec3 sky =  vec3(7.5, 7.2, 7.2) * \n                mix(vec3(0.12, 0.85, 1.0) * 1.0, vec3(1), skyExtinction1) * \n                mix(vec3(0.5, 0.25, 0.52) * 0.5, vec3(1), skyExtinction2);\n    sky += vec3(3, 2, 0.5) * pow(clamp(dot(viewDir, SUN_DIR), 0., 1.), 4.);\n    sky += vec3(50, 40, 2) * smoothstep(0.991, 0.997, dot(viewDir, SUN_DIR)) * 0.3;\n    float groundD = rayPlaneIntersect(camPos, viewDir, vec3(0,-50,0), vec3(0,1,0));\n    vec3 groundPoint = camPos + viewDir * groundD;\n    float groundNoise = smoothstep(-0.5, 0.5, noise(groundPoint*0.07)*0.99 + noise(groundPoint*0.69)*0.3);\n    vec3 groundColPre = mix(vec3(0.3, 0.4, 0.6), vec3(0.45, 0.62, 0.68), groundNoise);\n    vec3 groundCol = mix(groundColPre, vec3(0.79, 1.28, 1.85), 1.-exp(-max(groundD,0.)*0.003));\n    vec3 ground = groundCol * ((1.0-pow(abs(viewDir.y),0.5))*0.8+0.2);\n    return mix(ground, sky, smoothstep(-0.04, 0.1, viewDir.y))*0.65;\n}\n\nvec3 ambientContribution(vec3 normal) {\n    vec3 ground = vec3(0.36, 0.6, 0.65)*0.4;\n    //ground *= smoothstep(-1., 0., normal.y)*0.5+0.5;\n    return mix(ground, vec3(0.4,0.8,1.1), pow(smoothstep(-1., 1., normal.y),1.0));\n}\n\nfloat density(vec3 pos) {\n    vec3 normDist = pos / (CLOUD_SIZE*0.5);\n    float topClip = smoothstep(-0.0, 1., normDist.y);\n    float sideClipX = smoothstep(0.60-topClip*0.6, 1., abs(normDist.x));\n    float sideClipZ = smoothstep(0.60-topClip*0.6, 1., abs(normDist.z));\n    float bottomClip = smoothstep(-0.5, -1.0, normDist.y);\n    float freq = 3.9;\n    float sum = 0.;\n    float amp = 0.5;\n    float d1 = distance(normDist * vec3(1.0,0.9,1.0), vec3(0, -0.65, 0) * vec3(1.0,0.8,1.0));\n    float d2 = distance(normDist * vec3(1.6,1.0,1.6), vec3(-0.3, 0.2, 0.3));\n    float dens = 1.-opSmoothUnion(\n        pow(d1*1.1, 1.2),\n        pow(d2*1.1, 1.4),\n        0.5\n    );\n    pos += vec3(1,0,2);\n    for (int i = 1; i<4; i++) {\n        float timeOffs = iTime * (1.+float(i)*1.0)*0.4;\n        if (i==1) timeOffs = 0.;\n        vec3 sineCoeff = vec3(\n            pos.z*2.4*freq,\n            pos.x*2.6*freq + timeOffs,\n            pos.y*2.8*freq\n        );\n        vec3 randOffs = sin(sineCoeff);\n        dens += (abs(noise(pos * freq + vec3(i)*167. + randOffs*0.022*freq))-0.48) * amp;\n        freq *= 2.1;\n        amp *= 0.5;\n    }\n    return  max(0., \n                0.0 + dens*0.8 - \n                pow(sideClipX,10.5)*0.4 - \n                pow(sideClipZ, 10.5)*0.4 - \n                pow(topClip,13.5)*0.3 - \n                pow(bottomClip,25.)*0.5\n            );\n}\n\nfloat blueNoise(vec2 pixelPos) {\n    const float c_goldenRatioConjugate = 0.61803398875f; // also just fract(goldenRatio)\n    float val = textureLod(iChannel0, pixelPos / 1024.0f, 0.).r;\n    int frame = iFrame % 64;\n    val = fract(val + float(frame) * c_goldenRatioConjugate);\n    return val;\n}\n\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    float camX = cos(iTime*CAMERA_SPIN_SPEED+2.0); \n    float camZ = sin(iTime*CAMERA_SPIN_SPEED+2.0);\n\n    float camYOffs = sin(iTime*0.3)*0.28;\n    vec3 cameraPos = normalize(vec3(camX,camYOffs-0.03,camZ))*CAMERA_DISTANCE;\n    vec3 cameraDir = -normalize(cameraPos+vec3(0.,cameraPos.y*0.30+0.11,0.));\n    vec3 cameraRight = normalize(cross(vec3(0,1,0), cameraDir));\n    vec3 cameraUp = normalize(cross(cameraDir, cameraRight));\n    \n    vec3 viewDir = normalize(cameraDir + cameraUp*uv.y*FOV_MULTIPLIER + cameraRight*uv.x*FOV_MULTIPLIER);\n    \n    float ao = 1.0;\n    \n    vec3 final = skyColor(viewDir, cameraPos);\n    \n    vec3 sunUp = normalize(cross(SUN_DIR, vec3(0,1,0)));\n    vec3 sunRight = normalize(cross(SUN_DIR, sunUp));\n    sunUp = normalize(cross(SUN_DIR, sunRight));\n    \n    vec2 box = intersectAABB(cameraPos, viewDir, -CLOUD_SIZE*0.5, CLOUD_SIZE*0.5); \n    vec3 hitPoint = cameraPos + viewDir*box.x;\n    \n    if (box.x<=box.y) {\n        float lightDirMult = 0.9 + blueNoise(fragCoord+50.)*0.2;\n        hitPoint += viewDir * blueNoise(fragCoord+123.) * 0.2;\n        //lightDirMult = 1.;\n        vec4 volume = vec4(0);\n        const float marchStep = 0.07;\n        for(int i = 0; i<32; i++) {\n            vec3 p = hitPoint + viewDir*float(i)*marchStep;\n            if (distance(p, cameraPos)>box.y) break;\n            float dens = density(p);\n            float light = 0.0;\n            vec3 lightP = p;\n            float lightStepInc = 2.0;\n            float lightStep = 0.002;\n            for (int n = 0; n<8; n++) {\n                float lightDens = density(lightP);\n                light += lightDens * lightStep * 20.;\n                float randUp = (blueNoise(fragCoord + vec2(n)*50.)*2.-1.) * SCATTERING_MULTIPLIER;\n                float randRight = (blueNoise(fragCoord + vec2(n)*88.)*2.-1.) * SCATTERING_MULTIPLIER;\n                vec3 scatterVec = normalize(SUN_DIR + sunUp*randUp + sunRight*randRight);\n                lightP += scatterVec * lightStep * lightDirMult;\n                if  (\n                        abs(lightP.y)>CLOUD_SIZE.y*0.5 ||\n                        abs(lightP.x)>CLOUD_SIZE.x*0.5 ||\n                        abs(lightP.z)>CLOUD_SIZE.z*0.5 \n                    ) break;\n                lightStep *= lightStepInc;\n            }\n            \n            light = exp(-light*light*12.0);\n            \n            //Ambient\n            /**/\n            float amb = 0.;\n            for (int a = 1; a<2; a++) {\n                vec3 ambP = p + \n                    normalize(vec3(\n                        blueNoise(fragCoord + vec2(a) * 120.)*2.0-1.0,\n                        blueNoise(fragCoord + vec2(a) * 151.)*2.0-1.0,\n                        blueNoise(fragCoord + vec2(a) * 199.)*2.0-1.0\n                    ))*0.10*(1.+float(a)*0.4);\n                amb += density(ambP);\n            }\n            float ambSoft = exp(-amb*5.0)*0.9+0.1;\n            vec3 ambient = mix(vec3(0.15, 0.25,0.55), vec3(0.58,0.85,1.02), ambSoft);\n            \n            amb = 0.;\n            for (int a = 1; a<2; a++) {\n                vec3 ambP = p + \n                    normalize(vec3(\n                        blueNoise(fragCoord + vec2(a) * 150.)*2.0-1.0,\n                        blueNoise(fragCoord + vec2(a) * 81.)*2.0-1.0,\n                        blueNoise(fragCoord + vec2(a) * 149.)*2.0-1.0\n                    ))*0.05*(1.+float(a)*0.4);\n                amb += density(ambP);\n            }\n            ambient *= exp(-amb*3.0)*0.8+0.2;\n            \n            vec3 newColor = vec3(0.7, 0.85, 1) * (light * SUN_COLOR + ambient*1.6);\n            volume.rgb += (1.0 - volume.a) * dens * newColor;\n            volume.a += (1.0 - volume.a) * dens;\n        }\n        if (volume.a > 0.001) volume.rgb /= volume.a;\n        final = mix(final, volume.rgb, clamp(volume.a*1.3, 0., 1.));\n    }\n\n    // Output to screen\n    uv.y *= 1.6;\n    float vignette = exp2(-length(uv*uv*uv*uv*0.6));\n    fragColor = vec4(aces_tonemap(final) * vignette,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 237, 267, 267, 714], [716, 716, 785, 785, 1022], [1025, 1025, 1077, 1077, 1176], [1178, 1178, 1204, 1204, 1417], [1419, 1419, 1461, 1461, 2656], [2658, 2658, 2697, 2697, 2882], [2884, 2884, 2909, 2909, 4250], [4252, 4252, 4284, 4284, 4547], [4549, 4549, 4624, 4624, 4903], [4905, 4905, 4962, 5013, 9054]], "test": "untested"}
{"id": "7sB3zK", "name": "Tixy Land - Lissajous", "author": "ern0", "description": "Forked from @Xor: Recreated @aemkey's \"Tixy Land\" in ShaderToy. Try the original here: https://tixy.land\n\nI've changed only the Tixy-formula to mine: https://tixy.land/?code=%28x-7.5%2Bsin%28t%29*5%29**2%2B%28y-7.5%2Bcos%28t*1.7%29*5%29**2-8\n", "tags": ["golf", "tixyland"], "likes": 3, "viewed": 278, "published": 3, "date": "1617642202", "time_retrieved": "2024-07-30T19:28:22.417548", "image_code": "// Forked from https://www.shadertoy.com/view/3dtBDN\n//   by https://www.shadertoy.com/user/Xor\n//\n// Formula by ern0\n//   (x-7.5+sin(t)*5)**2+(y-7.5+cos(t*1.7)*5)**2-8\n//   https://tixy.land/?code=%28x-7.5%2Bsin%28t%29*5%29**2%2B%28y-7.5%2Bcos%28t*1.7%29*5%29**2-8\n// \n\n//Recreated @aemkey's \"Tixy Land\" in ShaderToy using shader syntax.\n//Play around with the original here: https://tixy.land\n\n// You can fiddle with dot count here:\n#define count 32.\n// Change ball size:\n#define ballsize 24./count\n// Set border (should be auto):\n#define border count/8.\n\n#define area (count/2.-border)\n#define center ((count-1.)/2.)\n#define tixy(t,i,x,y) \\\n    (x-center+sin(t)*area) \\\n    *(x-center+sin(t)*area) \\\n    /(ballsize) \\\n    + \\\n    (y-center+cos(t*1.7)*area) \\\n    *(y-center+cos(t*1.7)*area) \\\n    /(ballsize) \\\n    - \\\n   (count/2.)\n\n//#define tixy(t,i,x,y) (x-7.5+sin(t)*5.)*(x-7.5+sin(t)*5.)+(y-7.5+cos(t*1.7)*5.)*(y-7.5+cos(t*1.7)*5.)-8.\n\n\n//Render with the result:\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    float s = 1.2/iResolution.y;\n    vec2 u = (coord-.5*iResolution.xy)*s;\n    u.y = -u.y;\n    \n    float square = step(abs(u.x),.5)*step(abs(u.y),.5);\n    vec2 cell = floor((u+.5)*count);\n    float index = cell.x+cell.y*count;\n    float tixel = float(tixy(iTime,index,cell.x,cell.y));\n    \n    float dist = length(fract(u*count)-.5)*count/.5;\n    float radius = count*min(abs(tixel),1.);\n    \n    vec3 col = tixel<0. ? vec3(255,34,68)/255. : vec3(1);\n    col *= clamp((radius-dist)/s/count/count/2.,0.,1.)*square;\n\n    color = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sB3zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[946, 972, 1021, 1021, 1564]], "test": "untested"}
{"id": "7sBGzK", "name": "Bull", "author": "EvilRyu", "description": "4k executable graphics entry for Revision 2021\n", "tags": ["procedural", "raymarching", "revision", "ox"], "likes": 53, "viewed": 814, "published": 3, "date": "1617641374", "time_retrieved": "2024-07-30T19:28:23.377980", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// PC 4k exe graphics entry of Revision 2021\n// A more verbosed version\n// Split to more passes just for reducing some compile time here\n\n// FXAA pass\n#define REDUCE_MUL (1. / 8.)\n#define REDUCE_MIN (1. / 128.)\n#define INTENSITY 3.1\n\nfloat rgb2luma(vec4 col)\n{\n\treturn col.y *(.587 / .299) + col.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec2 eps = 1. / iResolution.xy;\n\n\tfloat topLeft   = rgb2luma(texture(iChannel0, uv + vec2(-eps.x, eps.y)));\n\tfloat topRight  = rgb2luma(texture(iChannel0, uv + eps.xy));\n\tfloat downLeft  = rgb2luma(texture(iChannel0, uv - eps.xy));\n\tfloat downRight = rgb2luma(texture(iChannel0, uv + vec2(eps.x, -eps.y)));\n\tfloat center    = rgb2luma(texture(iChannel0, uv));\n\n\tvec2 dir        = vec2((topLeft + topRight) - (downLeft + downRight),\n\t\t                  (downLeft + topLeft) - (downRight + topRight));\n\tfloat dirReduce = max((downLeft + downRight + topLeft + topRight) * REDUCE_MUL * 0.25, REDUCE_MIN);\n\tfloat dirMin    = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\tdir             = min(vec2(INTENSITY), max(-vec2(INTENSITY), dir * dirMin)) * eps.xy;\n\n\tvec4 colA       = (texture(iChannel0, uv - .166667 * dir) + texture(iChannel0, uv + .166667 *dir)) *.5;\n\tvec4 colB       = colA *.5 + .25 * (texture(iChannel0, uv - .5 * dir) + texture(iChannel0, uv + .5 * dir));\n\tfloat LumB = rgb2luma(colB);\n\n\tif (LumB < min(center, min(min(downLeft, downRight), min(topLeft, topRight))) ||\n\t\tLumB > max(center, max(max(downLeft, downRight), max(topLeft, topRight))))\n\t\tfragColor = colA;\n\telse\n\t\tfragColor = colB;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// PC 4k exe graphics entry of Revision 2021\n\n// Render cloud and grass\n\nfloat mapCloud(vec3 p)\n{\n\tp += vec3(4., 2., 20.);\n\trot2d(p.xz, .9);\n\tfloat d = 6. - length(vec3(mod(p.x, 6.) - 3., p.y, p.z)) - 3. *fbm2(p) + 2. *fbm2(p *.3);\n\td *= 1. - smoothstep(3., 6., p.y);\n\treturn clamp(d, 0., 1.);\n}\n\nvec3 renderCloud(vec3 ro, vec3 rd)\n{\n\tfloat rnd = .95 + .05* fract(sin(dot(Q, vec2(12.9898, 78.233))) *43758.5453);\n\n\tvec4 sum = vec4(rnd *sky *(exp(-length(rd.xy - vec2(.4, .4)))), 1);\n\n\tfloat t = 8.;\n\tfloat dt = .2;\n\tfor (int i = 0; i < 64 + min(0, iFrame); ++i)\n\t{\n\t\tvec3 p = ro + t * rd;\n\t\tfloat d = mapCloud(p);\n\n\t\tif (d > 0.)\n\t\t{\n\t\t\tfloat s = 0.;\n\t\t\tvec3 st = normalize(p + sunDir);\n\t\t\tvec3 sp = p;\n\t\t\tfor (int j = 0; j < 10; j++)\n\t\t\t\ts += mapCloud(sp += st);\n\n\t\t\tsum.xyz += exp(-s *.15) *d* vec3(1.5) *sunCol *(1. - d) *sum.a;\n\t\t\tsum.a *= 1. - d;\n\t\t}\n\n\t\tif (sum.a < .1 || t > 500.) break;\n\n\t\tt += dt;\n\t\tdt = max(.2, .02 *t);\n\t}\n\n\treturn sum.xyz;\n}\n\nfloat mapTerrian(vec3 p)\n{\n\tvec2 q = p.xz *.5 + vec2(3);\n\tfloat f = (.9 - 1.5* sin(p.x *.1)) *noise(q);\n\tq = q *2.11;\n\tf += .5* noise(q);\n\tq = q *2.2;\n\treturn f - .3;\n}\n\nfloat blades[8];\n\n// grass based on kuvkar's Windyplains: https://www.shadertoy.com/view/ltXXRM\nfloat mapGrass(vec3 p)\n{\n\tp.xy = vec2(p.x, p.y);\n\tfloat d = noise(p.xz *(GRASS_DENSITY + 100. *smoothstep(2.5, 3., p.z)));\n\td *= mix(1., noise(p.xz *30. - 27.), .6);\n\tint i = 7;\n\tfor (; i > 0 + min(0, iFrame); --i) blades[i] = blades[i - 1];\n\tblades[0] = d;\n\tfor (; i < 8 + min(0, iFrame); ++i) d += blades[i];\n\td /= float(i + 1);\n\td *= GRASS_H* min(1., exp(-(p.z) *.08));\n\treturn d;\n}\n\nfloat intersectGrass(vec3 ro, vec3 rd)\n{\n\tfloat t = .01;\n\tvec3 p = ro + t * rd;\n\tfor (int i = 0; i < 1000 + min(0, iFrame); ++i)\n\t{\n\t\tfloat d = p.y - mapGrass(p) - mapTerrian(p);\n\t\tif (d < .005 || t >= 10.) break;\n\t\td = max(1e-4, .04 *d* exp(t *.4));\n\t\tp += d * rd;\n\t\tt += d;\n\t}\n\n\treturn t;\n}\n\nvec3 renderGrass(vec3 ro, vec3 rd, float t, vec3 col)\n{\n\tif (t < 10.)\n\t{\n\t\tvec3 p = ro + t * rd;\n\t\tcol = vec3(4.82, 2.75, 1.18) *max(0., dot(sunDir, vec3(0, .4, 1))) *2.;\n\t\tcol = mix(col, vec3(1.2, 1, 0.5), fbm(p.xz *2.));\n\t\tcol *= smoothstep(GRASS_H *.45, GRASS_H *2., p.y - mapTerrian(p));\n\t\tcol *= pow(smoothstep(-.7, 1., fbm(p.xz)), 4.);\n\t\tfloat d = p.y - mapGrass(p) - mapTerrian(p);\n\t\tcol *= .8* clamp(d / GRASS_H, .0, 1.) + .2;\n\t\tcol *= 20.;\n\t}\n\n\treturn col;\n}\n\nvec4 scene(vec3 ro, vec3 rd)\n{\n\tvec3 col = renderCloud(ro, rd);\n\n\tfloat t = intersectGrass(ro, rd);\n\n\tcol = renderGrass(ro, rd, t, col);\n\n\tif (t < 10.)\n\t\tcol = mix(col, vec3(.82), 1.0 - exp(-.002 *t *t));\n\n\treturn vec4(col, t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 ta = vec3(-.7, 2.6, 0),\n\t\tro = vec3(-2.96, 1.21, 3.8),\n\t\trd;\n\tQ = (-iResolution.xy + 2. *fragCoord) / iResolution.y;\n\trd = cam(ro, ta) *normalize(vec3(Q.xy, 1.8));\n\tfragColor = scene(ro, rd);\n}", "buffer_a_inputs": [], "buffer_b_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// PC 4k exe graphics entry of Revision 2021\n\n// Render the Bull\n\n\n#define AA 1\n\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat cap(vec3 p, float h, float r)\n{\n\tp.y -= clamp(p.y, 0.0, h);\n\treturn length(p) - r;\n}\n\nfloat roundCone(vec3 p, float r1, float r2, float h)\n{\n\tvec2 q = vec2(length(p.xz), p.y);\n\n\tfloat b = (r1 - r2) / h;\n\tfloat a = sqrt(1. - b *b);\n\tfloat k = dot(q, vec2(-b, a));\n\n\tif (k < 0.) return length(q) - r1;\n\tif (k > a *h) return length(q - vec2(.0, h)) - r2;\n\n\treturn dot(q, vec2(a, b)) - r1;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 + 0.5 *(b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k *h *(1.0 - h);\n}\n\nfloat smax(float a, float b, float k)\n{\n\treturn smin(a, b, -k);\n}\n\nfloat sabs(float x, float k)\n{\n\treturn sqrt(x *x + k) - 0.1;\n}\n\nvec3 bend(vec3 p, float k)\n{\n\tfloat c = cos(k *p.x);\n\tfloat s = sin(k *p.x);\n\treturn vec3(mat2(c, -s, s, c) *p.xy, p.z);;\n}\n\nfloat ellip(vec3 p, vec3 r)\n{\n\tfloat k0 = length(p / r);\n\treturn k0 *(k0 - 1.) / length(p / (r *r));\n}\n\nfloat cylinder(vec3 p, float h, float r)\n{\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat hoof(vec3 p)\n{\n\tp *= 6.;\n\tfloat d = cylinder(p *1.2, .7 - .4 *p.y, .4 + .2 *p.z) / 1.2 - .15;\n\tfloat d2 = box(p + vec3(0, 0, -.7), vec3(.08 - .04 *p.y, .6, .2));\n\td = smax(d, -d2, .2) / 6.;\n\treturn d;\n}\n\nfloat legs(vec3 op, float d, inout float mate)\n{\n    vec3 p=op;\n    // front left\n\t{\n\t\tp = op + vec3(.6, .5, -.6);\n\t\trot2d(p.xy, -1.6);\n\t\tfloat leg1 = cap(p, .8, .12 + .008* sin(p.x *40.));\n\n\t\tp.z += .01* sin(p.x *15. - 3.5) + .03* sin(p.y *20. - 2.);\n\t\tp.z *= 2.;\n\t\tp.z -= .1;\n\t\trot2d(p.xy, 2.);\n\t\trot2d(p.yz, -.6);\n\t\tfloat leg2 = roundCone(p + vec3(-.8, .2, 0), .2, .4, .5) / 2.;\n\t\tleg1 = smin(leg2, leg1, .16);\n\n\t\tp = op + vec3(.35, .85, -.6);\n\t\trot2d(p.xy, 1.);\n\t\tleg2 = cap(p, .4, .07 - .004* sin(p.x *50. - .5));\n\t\tleg1 = smin(leg1, leg2, .15);\n\t\td = smin(d, leg1, .06);\n\n\t\tp = op + vec3(.2, .9, -.6);\n\t\trot2d(p.xy, 1.5);\n\t\trot2d(p.xz, 1.2);\n\t\tfloat hoo = hoof(p);\n\t\tif (hoo < d) mate = HOOF;\n\t\td = smin(d, hoo, .15);\n\t}\n\n\t// front right\n\t{\n\t\tp = op + vec3(-.6, 1., 0.6);\n\t\trot2d(p.xy, .6);\n\t\tfloat leg1 = cap(p, .8, .12);\n\n\t\tp += vec3(.05, .64, 0);\n\t\tfloat leg2 = cap(p, .46, .08);\n\t\tleg1 = smin(leg1, leg2, .2);\n\n\t\tp += vec3(.1, .08, 0);\n\t\trot2d(p.xy, -.7);\n\t\trot2d(p.xz, 1.6);\n\t\tfloat hoo = hoof(p);\n\t\tif (hoo < d) mate = HOOF;\n\t\td = smin(d, hoo, .4);\n\n\t\tp = op + vec3(.6, .5, .55);\n\t\tp.z += .01* sin(p.y *15. + 2.);\n\t\tp.z *= 2.;\n\t\trot2d(p.xy, 0.4);\n\t\trot2d(p.yz, -.7);\n\t\tleg2 = roundCone(p + vec3(-.8, .2, 0), .2, .4, .5) / 2.;\n\n\t\tleg1 = smin(leg2, leg1, .2);\n\n\t\tif (leg1 < d) mate = BODY;\n\t\td = smin(d, leg1, .1);\n\t}\n\n\t// back legs\n\t{\n\t\tp = op;\n\t\tp.z *= 1.5;\n\t\tp += vec3(-2.3, 1., 0);\n\t\trot2d(p.xy, .3);\n\t\tp.z = abs(p.z) - .8;\n\t\trot2d(p.yz, -.3);\n\t\tp.z += .05* sin(p.x *15.) *(1. - smoothstep(1., 1.7, p.y)) +\n\t\t\t.02* sin(p.y *10. + 1.) *smoothstep(-1., 1., p.y);\n\t\tfloat leg2 = roundCone(p, .13, .5, 1.2) / 1.5;\n\t\td = smin(d, leg2, .15);\n\n\t\tp.z *= .5;\n\t\tp += vec3(-.08, .6, 0);\n\t\tleg2 = roundCone(p, .06, .03, .35);\n\t\td = smin(d, leg2, .3);\n\t}\n    \n    return d;\n}\n\nvec2 mapBull(vec3 p)\n{\n\tvec3 op = p;\n\tfloat d = 1e5;\n\tfloat mate = BODY;\n\n\tfloat dis2 = smoothstep(.0, 1., fbm(vec2(p.x *3., p.y *.3) *15.)) *.01 *\n\t\tsmoothstep(-.1, .2, p.y) *smoothstep(-2., -1.5, p.x) *smoothstep(3., 0., p.x);\n\n\tp.z *= 1.6;\n\tp.y -= .2;\n\trot2d(p.xy, -0.2);\n\tp.x += .03* sin(p.z *16. - 4.);\n\tp.z += .07* sin(p.x *15.) + .03* sin(p.y *15.);;\n\tfloat body = roundCone(p.yxz, 1., .6, 1.9) / 1.6;\n\td = body;\n\n\tp = op;\n\tp.z *= 1.4;\n\tp += vec3(1.4, -.2, 0);\n\trot2d(p.xy, 0.2);\n\tp.y -= .05 *(sin(p.x *6. - 1.));\n\tp.z += .1* sin(p.x *30. + 3.) *smoothstep(.5, -1., p.y);\n\tfloat neck = roundCone(p.yxz, .32, .8, 1.5) / 1.4;\n\td = smin(d, neck, .2);\n\n\tp = op + vec3(1.1, .5, 0);\n\trot2d(p.xy, 2.2);\n\tfloat head = roundCone(p.yxz - vec3(.02* sabs(sin(p.z *20.), .1) + .03, 0, 0), .12, .3, .58) / 2.;\n\thead = smin(head, cylinder(p.yzx + vec3(-.2, 0, -.65), .13, .17) / 2., .1);\n\thead = smin(head, length(vec3(p.x - .35, p.y + .05, abs(p.z) - .16)) - .1, .1);\n\thead = smin(head, length(vec3(p.x - .33, p.y - .1, abs(p.z) - .13)) - .1, .05);\n\thead = smax(head, -length(vec3(p.x - .1, p.y *2. - 0., abs(p.z) - .31)) + .1, .12);\n\n\trot2d(p.xy, -1.2);\n\tp.x *= 1.5;\n\n\tfloat jaw = roundCone(p.xyz + vec3(-.1, 0, .0), .12, .12, .5) / 2.;\n\thead = smin(head, jaw, .015);\n\td = smin(d, head, .1);\n\n\tp = op;\n\tp.z = abs(p.z) + .15;\n\tp += vec3(1.2, .62, -.24);\n\trot2d(p.xy, .7);\n\tfloat nose = roundCone(p, .04, .02, .2);\n\td = smin(d, nose, .07);\n\td = smax(d, -nose, .027);\n\n\tp = op;\n\tp.z = abs(p.z) + .13;\n\tp = p + vec3(1.45, .3, -.25);\n\tfloat eyes = (length(p* vec3(2., 1., 2.) + vec3(.2, -.2, 0)) - .3) / 2.;\n\td = smin(d, eyes, .05);\n\tp.z = abs(op.z) - .25;\n\trot2d(p.xy, .3);\n\trot2d(p.yz, .3);\n\teyes = (length(vec3(abs(p.x + .05) + .11, p.y + 0., p.z *3. + .1)) - .15) / 3.;\n\td = smax(d, -eyes, .001);\n\teyes = length(p + vec3(.04, .02, .09)) - .05;\n\tif (eyes < d) mate = EYES;\n\td = smin(d, eyes, .0);\n\n\tp = op;\n\tp.z = abs(p.z) - .14;\n\tp += vec3(1.5, .1, -.25);\n\trot2d(p.xy, 1.4);\n\tp = bend(p.yxz, -10.);\n\tp.x -= .1* sin(p.z *6.);\n\tfloat ears = ellip(p, vec3(.1 + .06* sin(p.z *20.), .02, .15));\n\n\tif (ears < d) mate = BODY;\n\td = smin(d, ears, 0.01);\n\n\tp = op + vec3(2.45, .1, 0);\n\trot2d(p.xy, .1);\n\tp.z = sabs(p.z, .1) - .7;\n\trot2d(p.xz, 1.);\n\tp.x += .3* sin(p.z *5. + 7.5);\n\tp.y -= .06* sin(p.z *7.);\n\tfloat horn = roundCone(vec3(p.x, -p.z, p.y + .1), .013, .15, .9) / 2.5;\n\tif (horn < d) mate = HORN;\n\td = min(d, horn) / 1.5;\n\n\td = legs(op,d,mate);\n\n\tp = op + vec3(-.9, .15, 0);\n\tp.z -= 0.02* sin(p.y *15. - 5.) - .02* sin(p.x *8. - 2.);\n\tfloat belly = length(p) - .7;\n\td = smin(d, belly, .3);\n\n\tfloat k = smoothstep(2.95, 3.2, op.x) *smoothstep(3.7, 3.2, op.x);\n\tp = op + vec3(-3.5, .2, -.32);\n\trot2d(p.xy, 1.2);\n\tp.x += .4* sin(p.y *4.5);\n\tp.z += .3* sin(p.y *3. + 4.);\n\tp.y += .1* sin(p.z *200.);\n\tfloat tail = roundCone(p, .023 + .06 *k, .05, 1.5) / 2.;\n\td = smin(d, tail, .1);\n\n\tp = op + vec3(-2.55, 1.7, 0);\n\tp.z = abs(p.z) - .66;\n\trot2d(p.xz, 1.3);\n\tfloat hoo = hoof(p);\n\tif (hoo < d) mate = HOOF;\n\td = smin(d, hoo, .15);\n\n\tif (mate == BODY) d -= dis2;\n\n\treturn vec2(d, mate);\n}\n\nvec2 map(vec3 p)\n{\n\trot2d(p.xy, -.11);\n\tvec2 res = mapBull((p - vec3(0, 2.68, 0)));\n\treturn res;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k)\n{\n\tfloat res = 1.;\n\tfloat t = .01;\n\tfor (int i = 0; i < 128 + min(0, iFrame); i++)\n\t{\n\t\tfloat h = map(ro + rd *t).x;\n\t\tres = min(res, k *h / t);\n\t\tt += clamp(h, .005, .1);\n\t\tif (res < .002 || t > 100.) break;\n\t}\n\n\treturn max(res, .0);\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.001*e*t).x;\n    }\n    return normalize(n);\n}\n\nvec2 intersect(vec3 ro, vec3 rd)\n{\n\tfloat t = .01;\n\tvec2 res = vec2(1e5, 0);\n\tfor (int i = 0; i < 256 + min(0, iFrame); ++i)\n\t{\n\t\tif (res.x < .002 || t > 100.) break;\n\t\tres = map(ro + t *rd);\n\t\tt += res.x;\n\t}\n\n\treturn vec2(t, res.y);\n}\n\nfloat getAO(vec3 p, vec3 n)\n{\n\tfloat occ = .0;\n\tfloat sca = 1.;\n\tfor (int i = 0; i < 5 + min(0, iFrame); i++)\n\t{\n\t\tfloat h = .01 + .12* float(i) / 4.;\n\t\tfloat d = map(p + h *n).x;\n\t\tocc += (h - d) *sca;\n\t\tsca *= .95;\n\t\tif (occ > .35) break;\n\t}\n\n\treturn clamp(1. - 3. *occ, 0., 1.) *(.5 + .5 *n.y);\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n\tp *= iResolution.x / 20.;\n\tp.y *= .5;\n\tp.xz *= 3.;\n\treturn (fbm(p.xy) *abs(n.z) + noise(p.xz) *abs(n.y) + noise(p.yz) *abs(n.x)) / 3.;\n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n\tvec2 e = vec2(2. / iResolution.y, 0);\n\tvec3 g = vec3(bump(p - e.xyy, n) - bump(p + e.xyy, n),\n\t\tbump(p - e.yxy, n) - bump(p + e.yxy, n),\n\t\tbump(p - e.yyx, n) - bump(p + e.yyx, n)) / (e.x *2.);\n\tg = (g - n* dot(g, n));\n\treturn normalize(n + g *weight);\n}\n\nvec3 BRDF(vec3 n, vec3 v, vec3 l, vec3 diffuse)\n{\n\tvec3 h = normalize(v + l);\n\t// biased a little to workaround shiny pixels on the contour\n\tvec3 b = normalize(cross(n, vec3(0, 1, -.3))),\n\t\tt = normalize(cross(b, n));\n\t//t+=.2*n;\n\tfloat NoV = abs(dot(n, v)) + 1e-2,\n\t\tNoL = max(dot(n, l), 0.),\n\t\tNoH = max(dot(n, h), 0.),\n\t\tLoH = max(dot(l, h), 0.),\n\t\tToV = max(dot(t, v), 0.),\n\t\tBoV = max(dot(b, v), 0.),\n\t\tToL = max(dot(t, l), 0.),\n\t\tBoL = max(dot(b, l), 0.);\n\n\tfloat at = .1688, ab = .956;\n\tfloat a2 = at * ab;\n\thighp vec3 w = vec3(ab* dot(t, h), at* dot(b, h), a2 *NoH);\n\thighp float v2 = dot(w, w);\n\tfloat w2 = a2 / v2;\n\n\tfloat vi = 0.5 / (NoL* length(vec3(at *ToV, ab *BoV, NoV)) +\n\t\tNoV* length(vec3(at *ToL, ab *BoL, NoL)));\n\n\treturn vec3(a2 *w2 *w2 *.318 *\n\t\tmin(vi, 65504.) *\n\t\t(.046 + .954* pow(1.0 - LoH, 5.0))) + diffuse *.318;\n}\n\nvec3 shading(vec3 pos, vec3 rd, vec3 n, float mateid)\n{\n\tvec3 baseCol;\n\tfloat bump = 100. / max(iResolution.x, iResolution.y);\n\n\tif (mateid == BODY)\n\t{\n\t\tfloat top = smoothstep(2.3, 3., pos.y);\n\t\tbaseCol = mix(vec3(.08) *(.5 + smoothstep(0., 1., pos.x) *smoothstep(1., 2., pos.y)), vec3(.098, .059, .004),\n\t\t\tsmoothstep(.1, .5, fbm(pos.xy *6.) *top)) *1.5;\n        // Pure black looks better?\n\t\t//baseCol = vec3(.01)*(.5+smoothstep(0.,1.,pos.x))*1.5;\n\n\t\tbump *= .3* smoothstep(3.5, 2.4, pos.y);\n\t}\n\telse if (mateid == HORN)\n\t{\n\t\tbaseCol = mix(vec3(.969, .89, .831), vec3(.216, .118, .004), fbm(vec2(pos.x *20., pos.y *30.))) *\n\t\t\tsmoothstep(-2.3, -1.9, pos.x);\n\t\tbump *= .05;\n\t}\n\telse if (mateid == HOOF)\n\t{\n\t\tbaseCol = noise(pos.xy *30.) *vec3(.506, .459, .416);\n\t\tbump *= 0.08;\n\t}\n\n\tn = bump_mapping(pos, n, bump);\n\n\tfloat ao = getAO(pos + .1 *n, n), sha = shadow(pos, sunDir, 10.);\n\n\tvec3 col = BRDF(n, -rd, sunDir, baseCol) *ao *sunCol* max(0., dot(sunDir, n)) *8. *sha +\n\t\tsunCol* max(0., dot(-sunDir, n)) *.015;\n\n\tif (mateid == EYES) col = vec3(1, .435, 0);\n\treturn col;\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 uv)\n{\n\tvec4 col = texture(iChannel0, uv);\n\n\tvec2 res = intersect(ro, rd);\n\tfloat t = res.x;\n\tif (t < col.w)\n\t{\n\t\tvec3 pos = ro + t * rd;\n\n\t\tvec3 n = getNormal(pos, 1.);\n\t\tcol.xyz = shading(pos, rd, n, res.y);\n\t}\n\n\tt = min(t, col.w);\n\tif (t < 10.)\n\t\tcol.xyz = mix(col.xyz, vec3(.82), 1.0 - exp(-.002 *t *t));\n\n\treturn col.xyz;\n}\n\nvec3 tonemap(vec3 x)\n{\n\tconst float a = 2.51,\n\t\tb = .03,\n\t\tc = 2.43,\n\t\td = .59,\n\t\te = .14;\n\treturn (x *(a *x + b)) / (x *(c *x + d) + e);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec3 ta = vec3(-.7, 2.6, 0),\n\t\tro = vec3(-2.96, 1.21, 3.8),\n\t\trd, col = vec3(0);\n\n\t#if AA > 1\n\tfor (int m = 0; m < AA; m++)\n\t\tfor (int n = 0; n < AA; n++)\n\t\t{\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(AA) - .5;\n\t\t\tQ = (-iResolution.xy + 2. *(fragCoord + o)) / iResolution.y;\n    #else\n\t\t\tQ = (-iResolution.xy + 2. *fragCoord) / iResolution.y;\n    #endif\n\t\t\trd = cam(ro, ta) *normalize(vec3(Q.xy, 1.8));\n\t\t\tcol += scene(ro, rd, uv);\n    #if AA > 1\n\t\t}\n\n\tcol /= float(AA *AA);\n    #endif\n\n\tcol = tonemap(col);\n\tcol = pow(clamp(col, 0., 1.), vec3(.45));\n\tcol.z = (col.z + .1) / 1.1;\n\tcol = clamp(col *.5 + .5 *col *col *1.3, 0., 1.);\n\tcol *= .5 + .5* pow(16. *uv.x *uv.y *(1. - uv.x) *(1. - uv.y), .15);\n\tfragColor = vec4(col, 0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// PC 4k exe graphics entry of Revision 2021\n#define PI 3.1415926535\n#define BODY 0.\n#define HOOF 1.\n#define HORN 2.\n#define EYES 3.\n#define GRASS_H 0.1\n#define GRASS_DENSITY 540.\n\nvec3 sunDir = normalize(vec3(1, 1, 1.5));\nvec3 sunCol = vec3(1, .9, .62) *1.3;\nvec3 sky = vec3(.071, .102, .129);\nvec2 Q;\n\nvoid rot2d(inout vec2 p, float t)\n{\n\tfloat ct = cos(t), st = sin(t);\n\tvec2 q = p;\n\tp.x = ct *q.x + st *q.y;\n\tp.y = -st *q.x + ct *q.y;\n}\n\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p *5.3983, p *5.4427));\n\tp2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x *p2.y *95.4337) *0.5 + 0.5;\n}\n\nfloat noise(vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tf = f *f *(3.0 - 2.0 *f);\n\tfloat n = p.x + p.y *57.0;\n\treturn mix(mix(hash11(n + 0.0), hash11(n + 1.0), f.x),\n\t\tmix(hash11(n + 57.0), hash11(n + 58.0), f.x), f.y);\n}\n\nfloat noise(vec3 p)\n{\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tvec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\tp = p *p *(3. - 2. *p);\n\th = mix(fract(sin(h) *43758.5453), fract(sin(h + s.x) *43758.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec2 q)\n{\n\tfloat f = 0.0;\n\tvec3 p = vec3(q, 0);\n\tf += .5* noise(p);\n\tp = p *2.01;\n\tf += .25* noise(p);\n\tp = p *2.02;\n\tf += .125* noise(p);\n\tp = p *2.03;\n\treturn f;\n}\n\nfloat fbm2(vec3 p)\n{\n\tmat3 m = mat3(.0, .8, .6,\n\t\t-.8, .36, -.48,\n\t\t-.6, -.48, .64);\n\tfloat f = 0., s = .5;\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tf += s* noise(p);\n\t\tp = m *p *2.01;\n\t\ts *= .5;\n\t}\n\n\treturn f;\n}\n\nmat3 cam(vec3 ro, vec3 ta)\n{\n\tvec3 f = normalize(ta - ro);\n\tvec3 r = normalize(cross(f, vec3(0, 1, 0)));\n\tvec3 u = normalize(cross(r, f));\n\treturn mat3(r, u, f);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBGzK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[344, 344, 370, 370, 410], [412, 412, 467, 467, 1715]], "test": "untested"}
{"id": "7sS3RK", "name": "Spacemandel1", "author": "Chaotnix", "description": "Playing around with the mandelbox fractal and audio", "tags": ["fractal", "mandelbox", "audioreactive", "soundcloud"], "likes": 2, "viewed": 274, "published": 3, "date": "1617639609", "time_retrieved": "2024-07-30T19:28:24.222721", "image_code": "\n#define ITERS 6\n\nfloat SCALE=2.0;\nfloat MR2=0.0;\n\nfloat mandelbox(vec3 position){\n  vec4 scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;\n  float C1 = abs(SCALE + 7.0), C2 = pow(abs(SCALE), float(1-ITERS));\n  vec4 p = vec4(position.xyz, 1.0) + 0.8 * pow(texture(iChannel0, vec2(length(position.xyz), 0.26) ).x, 0.2), p0 = vec4(position.xyz, 1.0) + 0.8 * pow(texture(iChannel0, vec2(length(position.xyz), 0.26) ).x, 0.2);  // p.w is knighty's DEfactor\n  //vec4 p = vec4(position.xyz, 1.0) + pow(texture(iChannel0, vec2(length(position.xyz), 0.1) ).x, 0.1)/4., p0 = vec4(position.xyz, 1.0) + pow(texture(iChannel0, vec2(length(position.xyz), 0.1) ).x, 0.1)/4.5;  // p.w is knighty's DEfactor\n  for (int i=0; i<ITERS; i++) {\n    p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3\n    float r2 = dot(p.xyz, p.xyz);  // dp3\n    p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4\n    p.xyzw = p*scalevec + p0/6.;  // mad4\n}\n  return (length(p.xyz) - C1) / p.w - C2;\n}\n\nfloat color(vec3 p){\n    vec3 op = p;\n    for (int i=0; i<ITERS; i++) {\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3\n        float r2 = dot(p.xyz, p.xyz);  // dp3\n        p.xyz *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4\n        p.xyz = p*SCALE/MR2 + op;  // mad4\n        p.xyz = p - mix(vec3(0.2),p,smoothstep(.04,0.06, 0.002 * pow(texture(iChannel0, vec2(length(p.xy), 0.) ).x/3., 0.01)*4.));\n//p; //- pow(texture(iChannel0, vec2(length(p.xy), 0.) ).x/3., 0.01)*4.;\n\n    }\n  \treturn length(p/2.);\n}\n\nfloat trace(vec3 o,vec3 d){\n    float v=0.2;\n    for(int i=0;i<34;i++){\n        vec3 p=o+d*v;\n        p=p + 1.;// + 0.2 * texture(iChannel0, vec2(length(p.xy), 1.) ).x;\n        float mv=mandelbox(p);        \n        if(mv<0.01){\n            return v;\n        }\n        v+=mv *.9;\n    }\n    return 0.;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*4.-1.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 4.0;\n   //SCALE = 2.5 + iMouse.x * 2.0;\n   // MR2 = iMouse.x * iMouse.x;\n    //SCALE = 2.9 + sin(iTime*10.0)*.0;\n    SCALE = 2.4;\n    float mr = 0.6;\n    MR2 = mr * mr;\n    \n      \n    vec3 lookingTo = vec3(3.,2.,4.);\n    float it = iTime / 5.;\n    vec3 viewer = vec3(\n        sin(iTime*.1) * 6.0,\n        cos(iTime*.17) * 5.0,\n        cos(iTime*.1) * 6.0\n    );\n    \n    vec3 forward = normalize(lookingTo-viewer);\n    vec3 rigth = cross(vec3(1.0,1.0,0.0),forward);\n    vec3 up = cross(forward,rigth);\n    \n    vec3 direction = normalize(forward/0.1 * pow(texture(iChannel0, vec2(length(uv.y),.8) ).x, 0.005) + rigth * uv.x + up * uv.y);\n    \n    float dist = trace(viewer,direction);\n    vec3 col=vec3(0.0);\n    if(dist <=0.) {\n    //    dist=dist + 2. * texture(iChannel0, vec2(length(dist),0.005) ).x;\n\t\tdist = 1. - dist + 2. * texture(iChannel0, vec2(length(dist),0.005) ).x;\t\n    };    \n     vec3 p = viewer + direction * dist ;\n    \n    \n    if(dist!=0.) {\n        \n         float c = color(p);\n        \n   \t\t col = pal(c/50.0, \n                   vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.7),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20)\n                   //vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25)\n                   //vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25)\n                  );\n\n        //col = vec3(1.0);\n    };\n\n    \n   \n   \n    float fog = .8 + .05 * texture(iChannel0, vec2(length(p),.3) ).x;\n    fragColor.rgb = vec3(col * fog);\n}", "image_inputs": [{"id": 26489, "src": "https://soundcloud.com/4i20music/4i20-thanks-for-10k-folows-dj", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sS3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 82, 82, 1028], [1030, 1030, 1050, 1050, 1603], [1605, 1605, 1632, 1632, 1907], [1909, 1909, 1977, 1977, 2020], [2027, 2027, 2084, 2084, 3682]], "test": "untested"}
{"id": "sdBGRK", "name": "Unspinning", "author": "DukeOfStraylight", "description": "a very bad model of galactic physics", "tags": ["2d", "galaxy"], "likes": 21, "viewed": 583, "published": 3, "date": "1617636541", "time_retrieved": "2024-07-30T19:28:24.993660", "image_code": "mat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 50.;\n//    uv *= rot(iTime);\n\n    vec2 id = floor(uv);\n    vec2 center = id + .5;\n    vec2 st = fract(uv);\n\n    float d = 1.;\n    const float NNEI = 1.;\n    for (float x = -NNEI; x <= NNEI; x++) {\n        for (float y = -NNEI; y <= NNEI; y++) {\n            vec2 ndiff = vec2(x, y);\n            vec2 c = center + ndiff;\n            float r = length(c);\n            float a = atan(c.y, c.x);\n            r += (sin(iTime * 5. - r*0.55 - a*2.) * min(r/5., 1.));\n            vec2 lc = vec2(r*cos(a), r*sin(a));\n            d = min(d, length(uv - lc) + 0.01 * r);\n        }\n    }\n    float w = fwidth(uv.y);\n    vec3 col = vec3(smoothstep(0.31+w, 0.31-w, d));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n// grid\n/*\n    if (st.x < 0.05 || st.y < 0.05) {\n        fragColor = vec4(vec3(0, 1, 0), 1.0);\n    }\n    */\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBGRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 85], [87, 87, 144, 144, 1035]], "test": "untested"}
{"id": "7sSGRK", "name": "Primitives, plane & shadows", "author": "EricClapton", "description": "shadows should be calculated in diffuse section.", "tags": ["raymarching"], "likes": 2, "viewed": 275, "published": 3, "date": "1617636538", "time_retrieved": "2024-07-30T19:28:25.782551", "image_code": "\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sphereSDF1(vec3 samplePoint) {\n    vec3 sft = vec3(0.6, 0.0, 0.0);\n    return length(samplePoint+sft) - 0.5;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 sft = vec3(-1.5, 0.0, 0.0);\n  vec3 q = abs(p+sft) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  vec3 sft = vec3(0.8, 0.0, -1.5);\n  p = abs(p+sft)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec3 sft = vec3(-1.25, 0.0, -1.5);\n  p = p+sft;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    float res = sphereSDF1(samplePoint);\n    \n    vec3 b = vec3(0.4, 0.2, 0.2);\n    float tmp = sdRoundBox( samplePoint, b, 0.1);\n    if(tmp < res)res = tmp;\n    \n    tmp = sdBoxFrame( samplePoint, vec3(0.5, 0.5, 0.5), 0.05);\n    if(tmp < res)res = tmp;\n    \n    tmp = sdTorus( samplePoint, vec2(0.5, 0.1));\n    if(tmp < res)res = tmp;\n    \n    float ground = samplePoint.z + 1.5;\n    float ground2 = samplePoint.y + 0.5;\n    if(ground2 < res)res = ground2;\n    return min(res, ground);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = sceneSDF( ro + rd*t );\n\n       \n        res = min( res, 10.0*h/t );\n        \n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nfloat RayCast(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    float shadow = calcSoftshadow(p, lightPos, 0.01, 3.0);\n    \n    if (dotLN < 0.0) {\n       \n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        \n        return lightIntensity * (k_d * dotLN) * shadow;\n    }\n    return lightIntensity * (k_d * dotLN * shadow + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.8 * vec3(0.8, 0.8, 0.8);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.2, 0.5, 0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.9, 0.8, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n\n    \n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(6.0*cos(iTime*0.5), 4.0, 8.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = RayCast(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.2, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    //color *= exp(-0.0005*dist*dist*dist);\n    \n    fragColor = vec4(color + vec3(0.05,0.05,0.05), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 152, 152, 171], [173, 173, 209, 209, 289], [292, 292, 337, 337, 467], [469, 469, 514, 514, 833], [835, 835, 868, 868, 983], [987, 987, 1021, 1021, 1510], [1512, 1512, 1589, 1589, 1986], [1988, 1988, 2061, 2061, 2367], [2383, 2383, 2448, 2448, 2580], [2583, 2583, 2612, 2612, 2922], [2925, 2925, 3065, 3065, 3588], [3591, 3591, 3676, 3676, 4476], [4478, 4478, 4527, 4562, 4788], [4790, 4790, 4847, 4908, 5719]], "test": "untested"}
{"id": "NdSGzV", "name": "What's going on?", "author": "EricClapton", "description": "Try to compute shadow using iq's function, weird things happened though..............", "tags": ["error"], "likes": 1, "viewed": 261, "published": 3, "date": "1617630809", "time_retrieved": "2024-07-30T19:28:26.701095", "image_code": "\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sphereSDF1(vec3 samplePoint) {\n    vec3 sft = vec3(0.6, 0.0, 0.0);\n    return length(samplePoint+sft) - 0.5;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 sft = vec3(-1.5, 0.0, 0.0);\n  vec3 q = abs(p+sft) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  vec3 sft = vec3(0.8, 0.0, -1.5);\n  p = abs(p+sft)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec3 sft = vec3(-1.25, 0.0, -1.5);\n  p = p+sft;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    float res = sphereSDF1(samplePoint);\n    \n    vec3 b = vec3(0.4, 0.2, 0.2);\n    float tmp = sdRoundBox( samplePoint, b, 0.1);\n    if(tmp < res)res = tmp;\n    \n    tmp = sdBoxFrame( samplePoint, vec3(0.5, 0.5, 0.5), 0.05);\n    if(tmp < res)res = tmp;\n    \n    tmp = sdTorus( samplePoint, vec2(0.5, 0.1));\n    if(tmp < res)res = tmp;\n    \n    float ground = samplePoint.z + 1.5;\n    float ground2 = samplePoint.y + 0.5;\n    if(ground2 < res)res = ground2;\n    return min(res, ground);\n}\n\nfloat calcSoftshadow(vec3 samplePoint)\n{\n    float mint = 0.01;\n    float tmax = 3.0;\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = sceneSDF(samplePoint);\n\n        // traditional technique\n        \tres = min( res, 10.0*h/t );        \n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nfloat CastRay(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = calcSoftshadow(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n       \n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        \n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.8 * vec3(0.8, 0.8, 0.8);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.2, 0.5, 0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.9, 0.8, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n\n    \n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(6.0*cos(iTime*0.5), 4.0, 8.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = CastRay(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.2, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color + vec3(0.05,0.05,0.05), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSGzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 152, 152, 171], [173, 173, 209, 209, 289], [292, 292, 337, 337, 467], [469, 469, 514, 514, 833], [835, 835, 868, 868, 983], [987, 987, 1021, 1021, 1510], [1512, 1512, 1552, 1552, 2019], [2021, 2021, 2094, 2094, 2406], [2422, 2422, 2487, 2487, 2619], [2622, 2622, 2651, 2651, 2961], [2964, 2964, 3104, 3104, 3550], [3553, 3553, 3638, 3638, 4438], [4440, 4440, 4489, 4524, 4750], [4752, 4752, 4809, 4870, 5637]], "test": "untested"}
{"id": "NsB3zK", "name": "Neon Wire Frame Ngon", "author": "Tater", "description": "code is not good, maybe I will come back later and make it nicer. \n\nCollab with @Drakyen\nSee their version: [url] https://www.shadertoy.com/view/NsB3zV[/url]", "tags": ["2d", "cube", "wireframe", "glow", "neon"], "likes": 9, "viewed": 690, "published": 3, "date": "1617629542", "time_retrieved": "2024-07-30T19:28:27.611660", "image_code": "#define pi 3.14159265359\n\n//taken from a comment fabrice left. \nfloat segdf(vec2 p, vec2 a, vec2 b ) {\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n\treturn length( pa - ba*h );\n}\n\nvec2 loop (float t, float div, float i){\n\nreturn 0.25*vec2(sin(t+(i+1.0)*pi/div)*2.0,0.5*cos(t+(i+1.0)*pi/div));\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    float t = iTime;\n    vec3 col =vec3(0.0);\n    float occlude = 1.0; //Change to 0.0 to see all the lines\n    \n    float sides = 3.0 + floor((sin(t*1.2)*0.5+0.5)*5.);\n   // sides =3.;\n    for(float i = 0.0; i<sides;i++){\n        float div = sides/2.0;\n\n        vec2 loop1 = loop(t,div,i-1.);\n        vec2 loop11 = loop(t,div,i);\n        vec2 loop111 = loop(t,div,i-2.);\n        loop1.y+=.30;\n        loop11.y+=.30;\n\n        vec2 loop2 = loop(t,div,i-1.);\n        vec2 loop22 = loop(t,div,i);\n        loop2.y-=.35;\n        loop22.y-=.35;\n\n        vec3 glowcol = vec3(fract(t/5.+0.333),fract(t/5.+0.666),fract(t/5.));\n        float num = 200.0+(1.0+sin(t*5.0))*200. +10.*sides;\n\n        //BOTTOM\n        float glow = abs(1.0 / (num * segdf(uv,loop2,loop22)));\n        col += (glow)*(glowcol+1.0) * (step(loop22.y+loop2.y,-.7*occlude));\n        //SIDES\n        glow = abs(1.0 / (num * segdf(uv,loop1,loop2))); \n        if((loop1.x>loop11.x || loop1.x<loop11.x && loop1.x<loop111.x)||occlude == 0.0){\n        col +=(glow)*(glowcol+1.0);\n        }\n        //TOP\n        glow = abs(1.0 / (num * segdf(uv,loop1,loop11)));\n        col +=(glow)*(glowcol+1.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsB3zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 64, 102, 102, 220], [222, 222, 262, 262, 337], [338, 338, 395, 395, 1660]], "test": "untested"}
{"id": "3ttBRB", "name": "Sanitised", "author": "Molive", "description": "A hand sanitiser bottle.\n...I tried.\n\nI _think_ this is my first properly 3d prod.\nContains code from yx, Alia, noby, Mercury, iq, and stackoverflow which has been smooshed together to create a path tracer.", "tags": ["caustics", "handsanitiser"], "likes": 14, "viewed": 538, "published": 3, "date": "1617625709", "time_retrieved": "2024-07-30T19:28:28.731666", "image_code": "//uniform sampler2D T;\n//layout(location = 2) uniform vec3 TexCoord;\n#define TexCoord vec3(iResolution.xy,0)\n#define T iChannel0\nconst float a = 3.;\n\n#define Radius 3\n\nvec3 neighborhoods[Radius*Radius];\n\n\nvoid getNeighborhoods(vec2 coord)\n{\n    vec2 step1 = vec2(1.0)/TexCoord.xy;\n    \n    for (int i = 0; i < Radius*Radius; i++)\n    {\n        vec4 color = texture(T, coord + vec2(i/Radius, mod(float(i), float(Radius)))*step1);\n        neighborhoods[i] = a*color.rgb/color.a;\n    }\n}\n\nvoid sortNeighborhoods()\n{\n    for(int i = 0; i < Radius*Radius/2-1; i++)\n    {\n         for (int j=0; j < (Radius*Radius -1-i); j++)\n         {\n              if (length(neighborhoods[j+1]) > length(neighborhoods[j]))\n              { \n                    vec3 temp = neighborhoods[j];\n                    neighborhoods[j] = neighborhoods[j+1];\n                    neighborhoods[j+1] = temp;\n              }\n          }\n     }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{  \n\tvec2 uv=fragCoord.xy/iResolution.xy;\n    vec4 tex=texture(T,uv);\n    vec3 c= a*tex.rgb/tex.a;\n\n    vec3 color = c;\n    \n        float n = length(color);\n    color*=pow(n,1.5)*6.;\n\n\tcolor=color*(1.+(color/10.))/(1.+color);\n\n\n    \n\tuv-=.5;   \n    // gamma correction and a slight blue color grading\n\tcolor=pow(color, .45*vec3(1.0,1.1,1.2))*(1.-dot(uv,uv)*.75);\n    \n\tfragColor.rgb=color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi (acos(-1.))\n\nconst int matDiffuse=0;\nconst int matMirror=1;\nconst int matBlack=2;\nconst int matLiquid=3;\nconst int matFloor=4;\nconst int matLight=5;\nconst int matPlastic=6;\nconst int matBound=7;\nconst int matPipe=8;\nconst vec3 lightpos=vec3(24.,12.,-29.);\n//const vec3 lightpos=vec3(19.,12.,-23.);\n#define Epsilon 1.000001\n#define pixelRadius 0.0001\n\n//A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n//float seed;\n//float hash() {\n//\tfloat p=fract((seed++)*.1031);\n//\tp+=(p*(p+19.19))*3.;\n//\treturn fract((p+p)*p);\n//}\n//\n//vec2 hash2() {\n//    return vec2(hash(),hash());\n//}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nvec2 random( uvec2  v ) {return vec2(floatConstruct(hash( v.x ^ hash(v.y))),floatConstruct(hash( v.y ^ hash(v.x))));}\n\nvec2 uv;\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n    /// Returns a point on a sphere, r is in 0..1 range\nvec3 pointOnSphere(vec2 r) {\n    r=vec2(6.283185*r.x,2.*r.y-1.);\n    return vec3(sqrt(Epsilon-r.y*r.y)*vec2(cos(r.x),sin(r.x)),r.y); // 1.001 required to avoid NaN\n}\n \n    /// Returns a cosine weighted sample\nvec3 lambertSample(vec3 n,vec2 r) {\n    return normalize(n*Epsilon+pointOnSphere(r)); // 1.001 required to avoid NaN\n}\n\nvec4 iCylinderInverse( in vec3 ro, in vec3 rd, \n                in vec3 cb, in vec3 ca, float ra ) // extreme a, extreme b, radius\n{\n    vec3  oc = ro - cb;\n    \n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float k2 = 1.            - card*card;\n    float k1 = dot(oc,rd) - caoc*card;\n    float k0 = dot(oc,oc) - caoc*caoc - ra*ra;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0);\n    h = sqrt(h);\n    float t = (-k1+h)/k2;\n\n    // body\n    float y = caoc + t*card;\n    return vec4( t, (oc+t*rd - ca*y)/-ra );\n}\n\nfloat iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 cb, in vec3 ca, float ra ) // extreme a, extreme b, radius\n{\n    vec3  oc = ro - cb;\n    \n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float k2 = 1.            - card*card;\n    float k1 = dot(oc,rd) - caoc*card;\n    float k0 = dot(oc,oc) - caoc*caoc - ra*ra;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    return (-k1-h)/k2;\n}\n\n// plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// sphere of size ra centered at point ce\nvec4 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec4(-1.0); // no intersection\n    h = sqrt( h );\n    float t = (-b-h);\n    return vec4( t, (oc+t*rd)/ra );\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, float c )\n{\n  return length(p.xz)-c;\n}\n\nvec2 hash2( float p ) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nvec3 opCheapBend(in vec3 p )\n{\n    const float k = 10.0; // or some other amount\n    float  c = cos(k*p.z);\n    float  s = sin(k*p.z);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.zx,p.y).yzx;\n}\n\n// hacky parameter to control the size\nfloat T=4.;\n\nint mat;\nfloat inv;\n\n// distance function\nfloat sdScene(vec3 p)\n{\n    mat = matBlack;\n    float d = 1e9;\n    \n    //d = min(d,sdSphere(p,T));\n    \n    float top = sdRoundedCylinder(p-vec3(0,10.7,0), 0.3*T, 0.1*T, 0.35*T);\n    top = fOpUnionRound(top,sdRoundedCylinder(p-vec3(0,12.5,0), 0.25*T, 0.05*T, 0.15*T),0.2);\n    top = fOpUnionRound(top,sdRoundedCylinder(p-vec3(0,15,0), 0.08*T, 0.05*T, 0.6*T),0.2);\n    top = fOpUnionRound(top,sdRoundedCylinder(p-vec3(0,16.2,0), 0.1*T, 0.05*T, 0.25*T),0.2);\n    top = fOpUnionRound(top,sdRoundedCylinder(p-vec3(0,16.7,0), 0.23*T, 0.15*T, 0.01),0.2);\n    top = fOpUnionRound(top,sdRoundedCylinder(p.xzy-vec3(0,2.5,17.-p.z*p.z*0.03), 0.06*T, 0.05*T, 0.5*T),0.2);    \n    \n    float glass = min( \n    max(\n    sdRoundedCylinder(p, 0.85*T, 0.2*T, 0.75*T),\n    -sdSphere(p+vec3(0,6.7*T,0),6.0*T)),\n    max(\n    sdSphere(p*vec3(1.0,3.6/T,1.0)-vec3(0,0.75*3.6,0),1.7*T),\n    2.0-p.y)\n    );\n    \n    float tube = sdCylinder(p+vec3(0.,0.,sin(p.y/4.)-0.9), 0.15*T);\n    //if (max(tube,glass) < d) {mat = matPipe;}  \n\n    top = max(top,-glass);   \n    glass = fOpUnionRound(glass,top,0.2);\n    top = max(top,-glass);\n    glass = max(glass,-tube);\n    \n    if (top < d) {mat = matPlastic;}\n    d=min(d,top);\n    \n    if (glass < d) {\n    /*if (abs(p.y)<2.7) mat = matPlastic;\n    else mat = matLiquid;*/\n        if (tube > glass) {\n            mat = matLiquid;\n        } else {\n        if (p.y > 8.) {\n            mat = matPlastic;\n        } else {\n            mat = matPipe;\n        }\n        }\n    }\n    d = min(d, glass);\n    //vec3 q = opCheapBend(p);\n\n    //d = min(d,max(tube,glass));\n\n    /*float top = min(\n    sdRoundedCylinder(p, 0.85*T, 0.2*T, 0.75*T),\n    );*/\n    //mat = matDiffuse;\n    float fl= fPlane(p,vec3(0,1,0),4.);\n       if (fl < d) {mat = matDiffuse;}\n    d=min(d,fl);\n    \n    return inv*d;\n}\n\n// intersection function\nvec4 iScene(vec3 ro, vec3 rd)\n{\n    mat = matBound;\n    float innerScene = iCylinder(ro,rd,vec3(0.),vec3(0.,1.,0.),1.7*T);\n    if (innerScene > 0. && (ro+rd*innerScene).y >= -4.) return vec4(innerScene,0.,0.,0.);\n    mat = matLight;\n    vec4 light = sphIntersect(ro,rd,lightpos,4.);\n    if (light.x > 0.) return light;\n    mat = matDiffuse;\n    float plane = plaIntersect(ro, rd, vec4(0,1,0,4));\n    if (plane > 0. && (ro+rd*plane).x >= -10.) return vec4(plane, 0.,1.,0.);\n    vec4 curve = iCylinderInverse(ro,rd, vec3(-10.,11.,0.), vec3(0.,0.,1.),15.);\n    if (curve.x > 0. && ro.x+rd.x*curve.x <= -10.) return curve;\n    return vec4(0);\n}\n\nfloat err(float dist){\n    dist = dist/100.0;\n    return min(0.01, dist*dist);\n}\n\nvec3 dr(vec3 origin, vec3 direction, vec3 position){\n    const int iterations = 3;\n    for(int i = 0; i < iterations; i++){\n        position = position + direction * (sdScene(position) - err(distance(origin, position)));\n    }\n    return position;\n}\n\nvec2 rv2;\nint bounce = 0;\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    const vec3 lightdir = normalize(vec3(.7,.4,-1));\n    \n    const float THRESHOLD = .02;\n\n    vec3 accum = vec3(1);\n    bool inside = false;\n    for(bounce = 0;bounce<3;bounce++)\n    {\n        float t = 0.;\n        float k = 0.;\n        vec3 n = vec3(1,0,0);\n        vec3 h = vec3(0);\n        rv2 = random(uvec2(abs(rv2*2000.)));\n        \n        while (true) {\n            t = 0.;\n            k = 0.;\n            n = vec3(1,0,0);\n            h = vec3(0);\n            mat = matBlack;\n            if (length(cam.xz) > 1.7*T+THRESHOLD) {\n                inside = false;\n                vec4 scene = iScene(cam,dir);\n                if (scene.x > 0.) \n                {\n                    t = scene.x;\n                    n = scene.yzw;\n                    h = cam+dir*t;\n                    k = THRESHOLD;\n                }\n            } else {\n                inv = inside ? -1. : 1.;\n                t = 0.;\n                k = 0.;\n                for(int i=0;i<80;++i)\n                {\n                    k = sdScene(cam+dir*t);\n                    if (abs(k) < THRESHOLD) {\n                        h = dr(cam,dir,cam+dir*t);\n                        vec2 o = vec2(.001, 0);\n                        n = normalize(vec3(\n                            sdScene(h+o.xyy)-sdScene(h-o.xyy),\n                            sdScene(h+o.yxy)-sdScene(h-o.yxy),\n                            sdScene(h+o.yyx)-sdScene(h-o.yyx)\n                        ));\n                        break;\n                    }\n                    t += k;\n                    vec3 pos = cam+dir*t;\n                    if (length(pos.xz) > 1.7*T+THRESHOLD) {\n                        h = cam+dir*(t+THRESHOLD);\n                        mat = matBound;\n                        break;\n                    }\n                    if (pos.y > 25.) {\n                    return vec3(0);\n                    }\n                }\n            }\n            if (mat == matBound) {\n                cam = h;\n                continue;\n            } else {\n                break;\n            }\n        }\n        \n\n        \n        if (abs(k)<=THRESHOLD) {\n            // if we hit something\n\n            float fresnel = pow(1.-dot(-dir,n),5.);\n            fresnel*=1.-step(.99,fresnel);\n            \n            // debug normals visualization\n            //if (mat != matBound)\n            //return (n*.5+.5) * (.7+.3*step(1.4,length(step(.1,fract(h.xz-.5)))));\n\n            if (mat == matDiffuse)\n            {\n                // bounce the ray in a random direction\n                if (rv2.x > 0.) {\n                    dir = lambertSample(n,rv2);\n                } else {\n                    dir = normalize(lightpos + lambertSample(n,rv2) * 6. - cam);\n                }\n                accum *= dot(dir,n);\n            }\n            else if (mat == matLight)\n            {\n                return accum * vec3(10.,11.,12.) * step(.8,dot(dir,lightdir));\n            }\n            else if (mat == matBlack)\n            {\n                accum *= fresnel*.99+.01;\n                dir = reflect(dir,n);\n            }\n            else if (mat == matPlastic)\n            {\n                if (rv2.y < 0.02) {\n              dir = reflect(dir, n);\n                 } else {\n                 dir = lambertSample(n, rv2.yx);\n                 }\n              accum *= fresnel*.1+.9;\n              accum *= dot(dir,n);\n            }\n            else if (mat == matMirror)\n            {\n                n += sin(h*4.).bgr*.001;\n                n += sin(h*3.77).bgr*.001;\n                n += sin(h*.737).bgr*.001;\n                \n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            }\n            else if (mat == matFloor)\n            {\n                // grid lines\n                float gridscale=2.;\n                vec3 a = 1.-step(.49,abs(fract(h*gridscale)-.5));\n                float f=min(a.z,a.x);\n            \n                // checkerboard\n                gridscale=.25;\n                h.xz++;\n                f*=.8-step(.0,(fract(h.x*gridscale)-.5)*(fract(h.z*gridscale)-.5))*.3;\n            \n                dir = lambertSample(n,rv2);\n            \taccum *= f;\n            }\n            else if (mat == matLiquid || mat == matPipe)\n            {     \n               /* if (abs(h.y)<2.7) {\n            \n                                // Find reflection angle, accounting for surface roughness\n                    vec3 dir = normalize( // Ray dir must be normalised\n                          mix( // Mix between...\n                              reflect(dir, n), // the reflected angle\n                              lambertSample(n, rv2), // and a random angle projected into the surface\n                              0.02 // based on how smooth the glass surface is\n                              )\n                          );\n                          accum *= fresnel*.7+.3;\n                          }*/\n                          \n    \n                // Randomly reflect or refract, probability based on fresnel term\n                // If non-fresnel, refract\n                if (rv2.x > fresnel) {\n                    // refraction\n                    // Index of refraction\n                    float ior = mat == matLiquid ? inside ? 1.364 : 1./1.364: inside ? 1.460/1.364 : 1.364/1.460;\n        \n                    // Find refraction angle, accounting for surface roughness\n                    vec3 rayDir = normalize( // Ray dir must be normalised\n                          mix( // Mix between...\n                              refract(dir, n, ior), // the refracted angle\n                              lambertSample(-n, rv2), // and a random angle projected into the surface\n                              mat == matLiquid ? 0.01 : 0.05 // based on how smooth the glass surface is\n                              )\n                          );\n        \n                    // Test for total internal reflection\n                    if(dot(n, dir) < 0.0) {\n                        // Not TIR, we're OK to refract\n            \n                        // Set the ray direction\n                        dir=rayDir;\n            \n                        // Flip the inside value as we pass through the surface\n                        inside=!inside;\n                        bounce--;\n                        cam = h + dir * 2. * max(THRESHOLD * 4.,abs(k));\n\n                        if (!inside) {\n                        accum *= vec3(1.) - t * vec3(0.,0., mat == matLiquid ? 0.01 : 0.02);\n                        }\n                        continue;\n                    }\n                }\n    \n                // Ray failed to refract, therefore reflection\n                accum *= fresnel*.7+.3;\n                dir = reflect(dir,n);\n            } else {\n            return vec3(0,0,1);\n            }\n            \n            cam = h + dir * THRESHOLD * 1.1 / dot(dir,n);\n        }\n        else {\n        bounce++;\n        break;\n        }\n    }\n    return vec3(0);\n}\n\nvec2 ringDof(vec2 seed)\n{\n    seed=fract(seed);\n    if (seed.y>seed.x)\n        seed=1.-seed;\n    float r=seed.x;\n    float a=(seed.y/seed.x)*pi*2.;\n    return vec2(cos(a),sin(a))*r;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // grab the previous color so we can iteratively render.\n    // in the actual executable I just rendered additively to a single framebuffer instead\n   \tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    uv = fragCoord.xy/iResolution.xy-.5;\n\n    // random function borrowed from I can't remember where\n    float seed = float(((int(iFrame*73856093))^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\trv2 = hash2( 24.4316544311+float(iFrame)+seed );\n    //rv2 = random(uvec2(normalize(abs(vec2(seed, 24.4316544311+iFrame+seed)))*20000.0));\n\n    \n    // jitter camera for antialiasing\n    uv += (rv2-.5)/iResolution.xy;\n    \n    // correct UVs for aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n    \n    // make a camera\n\tvec3 cam = vec3(1.,5.,-80.);\n    vec3 dir = normalize(vec3(uv,2.5));\n\n    // slight jitter for dof\n    //const float dofScale = .05 ;\n    //const float dofDist = 10.;\n    //vec2 dofJitter = ringDof(rv2);\n    //cam.xy += dofJitter*dofScale;\n    //dir.xy -= dofJitter*dofScale/dofDist;\n\n    // spin it to an isometric angle\n    cam.yz = rotate(cam.yz, pi/16.);\n    dir.yz = rotate(dir.yz, pi/16.);\n    \n    // debug camera rotation\n    //if (iMouse.z > 0.) {\n    //    float a = .8-2.*(iMouse.y/iResolution.y);\n    //\tcam.yz = rotate(cam.yz, a);\n    //\tdir.yz = rotate(dir.yz, a);\n    //}\n\n    // spin it to an isometric angle\n    cam.xz = rotate(cam.xz, pi/2.);\n    dir.xz = rotate(dir.xz, pi/2.);\n    \n    // debug camera rotation\n    //if (iMouse.z > 0.) {\n    //    float a = 1.-4.*(iMouse.x/iResolution.x);\n    //\tcam.xz = rotate(cam.xz, a);\n    //\tdir.xz = rotate(dir.xz, a);\n    //}\n    \n    // compute the pixel color\n    vec3 pixel = vec3(0);\n    for (int i = 0; i < 8; i++) {\n        pixel += trace(cam,dir);\n    }\n    pixel /= 8.;\n   \n    // reset buffer if we're clicking\n    // if (iMouse.z > 0.) gl_FragColor *= .1;\n\n    // accumulate the pixel\n    if(pixel.r >= 0.)\n    fragColor += vec4(pixel,1);\n    \n    //gl_FragColor = vec4(random(uvec2(abs(uv*1000.))),1.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttBRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 240, 240, 484], [486, 486, 512, 512, 913], [915, 915, 967, 967, 1358]], "test": "untested"}
{"id": "NdlGzs", "name": "Foxie", "author": "z0rg", "description": "A shader idea I had for a long time but wasn't able to reproduce a simplifies fox until now.\nHope you like it.\nYou can make it your window terminal background following link here : https://github.com/seb776/WindowsTerminalShaders", "tags": ["2d", "vector", "purple", "fox"], "likes": 23, "viewed": 566, "published": 3, "date": "1617615674", "time_retrieved": "2024-07-30T19:28:29.502604", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n//\n// You can make it your window terminal background following link here :\n// https://github.com/seb776/WindowsTerminalShaders\n//\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.141592653\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c,-s,s,c);}\nfloat lenny(vec2 v) { return abs(v.x)+abs(v.y); }\n\nfloat _cir(vec2 uv, float r)\n{\n    return length(uv)-r;\n}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nfloat _nimal(vec2 uv)\n{\n\n    uv.x+=sin(uv.y*25.+iTime*2.)*0.01*sat(uv.y*5.);\n    vec2 tuv = (uv-vec2(0.11+0.01*sin(uv.y*30.-iTime*4.),-.05)) * r2d(PI/4.);\n\n    tuv.x = abs(tuv.x);\n    tuv = (tuv-vec2(-.07,0.));\n    float tail = _cir(tuv, .1);\n    uv -= vec2(0.05,-.03);\n    float body = 10.;\n    \n    float anhears = 0.1;\n    vec2 offhears = vec2(0.01,0.);\n    body = min(body, _sqr((uv+offhears)*r2d(anhears), vec2(.025,.07)));\n    body = min(body, _sqr((uv-offhears)*r2d(-anhears), vec2(.025,.07)));\n    body = max(body, -_sqr((uv-vec2(0.,.08))*r2d(PI/4.), vec2(.03)));\n    uv.x = abs(uv.x);\n    body = min(body, _cir(uv*vec2(1.,.8)-vec2(.02,-0.04),.03));\n    body = min(body, _cir(uv*vec2(1.,.8)-vec2(.048,-0.058),.005));\n    body = min(body, tail);\n    return body;\n}\n\nfloat _star(vec2 p, vec2 s)\n{\n    float a = _sqr(p, s.xy);\n    float b = _sqr(p, s.yx);\n    return min(a, b);\n}\n\nfloat _stars(vec2 uv, vec2 szu)\n{\n    uv *= r2d(PI/4.);\n    vec2 ouv = uv;\n    float th = 0.002;\n    vec2 rep = vec2(0.1);\n\n    vec2 idx = floor((uv+rep*.5)/rep);\n    \n    uv = mod(uv+rep*.5, rep)-rep*.5;\n    float sz = sat(sin(idx.x*5.+idx.y+iTime))*sat(length(ouv*2.)-.5);\n    return _star(uv, vec2(20.*th, th)*.5*sz*szu);\n}\n\nvec3 rdr(vec2 uv)\n{\n    float shp = 400.;\n    vec3 background = vec3(0.431,0.114,0.647)*.2;\n    \n    background = mix(background, vec3(1.000,0.761,0.239), 1.-sat(_stars(uv, vec2(1.))*shp));\n    \n    vec3 sunCol = vec3(1.000,0.761,0.239);\n    vec3 foregroundBack = vec3(0.345,0.125,0.494);\n    \n    vec3 foreground;\n    \n    float sun = _cir(uv, .02);\n    float sstp = 0.05;\n    sun = floor(sun/sstp)*sstp;\n    foreground = mix(foregroundBack, sunCol, 1.-sat(sun*4.));\n    \n    float mount = uv.y-asin(sin(uv.x*25.))*.01+.1;\n    foreground = mix(foreground, foreground*.3, 1.-sat(mount*shp*.5));\n    \n    float mount2 = uv.y-(sin(uv.x*25.+2.))*.05+.1;\n    foreground = mix(foreground, foreground*.5, 1.-sat(mount2*shp*.1));\n\n    \n    float hill = _cir(uv-vec2(0.,-.9), .8);\n    foreground = mix(foreground, vec3(0.), 1.-sat(hill*shp));\n\n    float nanimal =_nimal(uv);\n    foreground = mix(foreground, vec3(0.), 1.-sat(nanimal*shp));\n    \n    \n    float mask = _cir(uv, .25);\n    \n    vec3 col = mix(background, foreground, 1.-sat(mask*shp));\n    \n    col += (1.-sat(length(uv*3.)))*sunCol*.7;\n    float flicker = .1;\n    col += pow(1.-sat(lenny(uv*vec2(1.,2.))),5.)*sunCol*.7\n        *mix(.95,1., sat(sin(iTime*25.)*2.+sin(iTime*40.)));\n    \n    col = mix(col, vec3(1.000,0.761,0.239), sat(length(uv)-.1)*(1.-sat(_stars(uv*.8, vec2(5.))*shp*.3))*.7);\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    \n    col *= mix(-1.,1.,1.-sat(lenny(uv*2.)-.5));\n    col = sat(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26496, "src": "https://soundcloud.com/aydio/deltitnu", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlGzs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[583, 583, 602, 602, 655], [656, 656, 677, 677, 705], [707, 707, 737, 737, 764], [766, 766, 794, 794, 845], [847, 847, 870, 870, 1618], [1620, 1620, 1649, 1649, 1731], [1733, 1733, 1766, 1766, 2059], [2061, 2061, 2080, 2080, 3428], [3432, 3432, 3489, 3489, 3691]], "test": "untested"}
{"id": "sd2GRy", "name": "Latin Supercube", "author": "dr2", "description": "Ancient Roman puzzle in the Rubik style", "tags": ["rubik", "puzzle", "sator", "palindrome"], "likes": 11, "viewed": 294, "published": 3, "date": "1617609018", "time_retrieved": "2024-07-30T19:28:30.403197", "image_code": "// \"Latin Supercube\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Ancient Roman puzzle in the Rubik style\n\n// Faces are (multipalindromic) Sator Squares - https://en.wikipedia.org/wiki/Sator_Square\n// (Based on extended \"Big Rubik Pseudosolver\")\n\nmat3 VToRMat (vec3 v, float a);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nint PxTextId (int txt);\nfloat PxTextAA (vec2 qBlkH, int cId);\nfloat Hashff (float p);\n\n#define VAR_ZERO min (iFrame, 0)\n\nmat3 vuMat;\nvec2 qBlk;\nfloat tCur, dstFar, bSize, rSeed;\nconst float pi = 3.1415927;\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 p, mat3 m)\n{\n  vec3 rdm, v, tm, tp, u, fcBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  rdm = m * rd;\n  if (rdm.x == 0.) rdm.x = 0.001;\n  if (rdm.y == 0.) rdm.y = 0.001;\n  if (rdm.z == 0.) rdm.z = 0.001;\n  v = (m * ro - p) / rdm;\n  tp = bSize / abs (rdm) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < min (df, dMin)) {\n    dMin = dn;\n    fcBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rdm;\n  }\n  if (dMin < dstFar) qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk));\n  return vec4 (dMin, fcBlk);\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nconst float nbE = 5.;\nconst float nTwist = 30.;\n\nmat3 RotSeq (vec3 bId, float nt, float aRot)\n{                     // Derived rotation matrix sequence from Kali's \"Rubik\"\n  mat3 rMat, m;\n  vec3 ax[3], vSlice;\n  vec2 e;\n  float s, sa;\n  e = vec2 (1., 0.);\n  ax[0] = e.xyy;\n  ax[1] = e.yxy;\n  ax[2] = e.yyx;\n  rMat = mat3 (e.xyy, e.yxy, e.yyx);\n  for (float n = float (VAR_ZERO); n < nTwist; n ++) {\n    if (n > nt) break;\n    s = mod (n + floor (6. * Hashff (99. + rSeed)), 6.);\n    sa = sign (s - 2.5);\n    s = mod (s, 3.);\n    vSlice = (s == 0.) ? e.xyy : ((s == 1.) ? e.yxy : e.yyx);\n    if (length ((bId + 0.5 * (nbE + 1.)) * vSlice) - 1. == floor (nbE * Hashff (n + rSeed))) {\n      m = VToRMat (sa * ((s == 0.) ? ax[0] : ((s == 1.) ? ax[1] : ax[2])),\n         0.5 * pi * ((n < nt) ? 1. : aRot));\n      for (int k = 0; k < 3; k ++) ax[k] = m * ax[k];\n      rMat = m * rMat;\n      if (n < nt) bId = VToRMat (sa * vSlice, -0.5 * pi) * bId;\n    }\n  }\n  return rMat;\n}\n\nvoid ExBlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, fcBlk;\n  float dn, df, bs;\n  bs = 10. * dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bs / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk)) / bs;\n  }\n}\n\nvec3 BgCol (vec3 rd)\n{\n  return vec3 (0.6, 0.6, 0.8) * (0.3 + 0.1 * rd.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  mat3 rMat, rMatH;\n  vec4 col4, d4, bs4;\n  vec3 col, vn, ltDir, fcBlk, bId, bidH, de3, ld, vnSph;\n  vec2 qBlkH, de, fc;\n  float dstBlk, dstSph, dstExtSph, d, nt, tCyc, shSpd, tWait, aRot, dSum, sSum, bMin, fcId;\n  bSize = 0.48;\n  d4 = SphHit (ro, rd, 0.9 * (2. * nbE + 1.) * bSize);\n  dstExtSph = d4.x;\n  col = BgCol (rd);\n  if (dstExtSph < dstFar) {\n    shSpd = 10.;\n    tWait = 4.;\n    tCyc = (nTwist + tWait) * (1. + 1. / shSpd) + tWait;\n    tCur += tCyc - 1.5 * tWait;\n    nt = nTwist - max (0., mod (tCur, tCyc) - tWait);\n    if (nt + tWait < 0.) nt = - shSpd * (nt + tWait);\n    aRot = smoothstep (0.1, 0.9, max (0., fract (nt) * sign (nt)));\n    nt = max (0., floor (nt));\n    rSeed = 17.77 * floor ((tCur + (nTwist + tWait) / shSpd + tWait) / tCyc + 1.);\n    bMin = 0.5 * (nbE - 1.) - 0.5;\n    dstBlk = dstFar;\n    for (float j = float (VAR_ZERO); j < nbE * nbE * nbE; j ++) {\n      bId = vec3 (mod (j, nbE), mod (floor (j / nbE), nbE), floor (j / (nbE * nbE))) - 0.5 * (nbE - 1.);\n      if (Maxv3 (abs (bId)) > bMin) {\n        rMat = RotSeq (bId, nt, aRot);\n        bs4 = BlkHit (ro, rd, bId, rMat);\n        d = bs4.x;\n        if (d < dstBlk) {\n          dstBlk = d;\n          fcBlk = bs4.yzw;\n          rMatH = rMat;\n          qBlkH = qBlk;\n          bidH = bId;\n        }\n      }\n    }\n    bs4 = SphHit (ro, rd, (nbE - 0.2) * bSize);\n    dstSph = bs4.x;\n    if (min (dstBlk, dstSph) < dstFar) {\n      if (dstBlk < dstSph) {\n        ro += dstBlk * rd;\n        de = smoothstep (-0.08, 0., abs (qBlkH.xy) - bSize);\n        de3 = vec3 (0.25 * pi * de * sign (qBlkH.xy), 0.);\n        vn = normalize (fcBlk + ((fcBlk.x != 0.) ? de3.zxy : ((fcBlk.y != 0.) ? de3.xzy : de3))) * rMatH;\n        if (length (max (abs (qBlkH) - bSize + 0.12, 0.)) < 0.07) {\n          if (abs (bidH.x) > bMin && sign (bidH.x) == fcBlk.x ||\n              abs (bidH.y) > bMin && sign (bidH.y) == fcBlk.y ||\n              abs (bidH.z) > bMin && sign (bidH.z) == fcBlk.z) {\n            if      (abs (fcBlk.x) == 1.) fcId = (fcBlk.x > 0.) ? 0. : 1.;\n            else if (abs (fcBlk.y) == 1.) fcId = (fcBlk.y > 0.) ? 2. : 3.;\n            else if (abs (fcBlk.z) == 1.) fcId = (fcBlk.z > 0.) ? 4. : 5.;\n            if (fcId == 0.) {\n              col = vec3 (1., 0., 0.);\n              fc = bidH.yz * vec2 (-1., 1.);\n            } else if (fcId == 1.) {\n              col = vec3 (1., 0.4, 0.);\n              fc = - bidH.yz;\n              qBlkH.y = - qBlkH.y;\n            } else if (fcId == 2.) {\n              col = vec3 (0., 0., 1.);\n              fc = bidH.zx * vec2 (1.,  -1.);\n              qBlkH = - qBlkH;\n            } else if (fcId == 3.) {\n              col = vec3 (0., 1., 0.);\n              fc = bidH.zx;\n              qBlkH.x = - qBlkH.x;\n            } else if (fcId == 4.) {\n              col = vec3 (1., 1., 0.);\n              fc = - bidH.yx;\n              qBlkH = qBlkH.yx * vec2 (-1., 1.);\n            } else if (fcId == 5.) {\n              col = vec3 (1., 1., 1.);\n              fc = bidH.yx * vec2 (-1., 1.);\n              qBlkH = - qBlkH.yx;\n            }\n            col *= 0.3 + 0.7 * PxTextAA (qBlkH, PxTextId (int (5. * (fc.x + 2.) + fc.y + 2.)));\n            col4 = vec4 (mix (col, vec3 (0.2, 0.2, 0.2), max (de.x, de.y)), 0.2);\n          } else {\n            col4 = vec4 (0.1, 0.1, 0.1, 0.);\n          }\n        } else {\n          col4 = vec4 (0.2, 0.2, 0.2, 0.1);\n        }\n      } else if (dstSph < dstFar) {\n        ro += dstSph * rd;\n        vn = bs4.yzw;\n        col4 = vec4 (0.1, 0.1, 0.1, 0.);\n      }\n      dSum = 0.;\n      sSum = 0.;\n      ltDir = normalize (vec3 (1., 1., -0.6));\n      for (int j = 0; j < 4; j ++) {\n        ltDir.xy = Rot2D (ltDir.xy, 0.5 * pi);\n        ld = vuMat * ltDir;\n        dSum += pow (max (dot (vn, ld), 0.), 1.5);\n        sSum += pow (max (dot (normalize (ld - rd), vn), 0.), 32.);\n      }\n      col = col4.rgb * (0.2 + 0.6 * dSum) + col4.a * sSum;\n    }\n    vnSph = d4.yzw;\n    ltDir = vuMat * normalize (vec3 (0.8, 1., -0.2));\n    col += 0.02 + 0.02 * max (dot (vnSph, ltDir), 0.) +\n       0.15 * pow (max (dot (normalize (ltDir - rd), vnSph), 0.), 32.);\n    ro += dstExtSph * rd;\n    rd = reflect (rd, vnSph);\n    ExBlkHit (ro, rd);\n    qBlk = step (0.1, mod (8. * qBlk + 0.05, 1.));\n    col = mix (col, BgCol (rd) * (0.8 + 0.2 * qBlk.x * qBlk.y), pow (1. - abs (dot (rd, vnSph)), 4.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA     0  // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 1.15 * pi;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10. * nbE / 3.);\n  zmFac = 3.7;\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.zyx * v.xzy;\n  b2 = - cs.y * v;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[1][2] = b1.x + b2.x;  m[2][1] = b1.x - b2.x;\n  m[2][0] = b1.y + b2.y;  m[0][2] = b1.y - b2.y;\n  m[0][1] = b1.z + b2.z;  m[1][0] = b1.z - b2.z;\n  return m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\n// Characters from \"Amiga Balls\" (partial)\n\n/*\n Text derived from 8x12 Font shader by Flyguy (Mt2GWD)\n Glyph bitmaps generated from 8x12 font sheet\n   http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n*/\n\n#define g_A   33\n#define g_E   37\n#define g_N   46\n#define g_O   47\n#define g_P   48\n#define g_R   50\n#define g_S   51\n#define g_T   52\n\n#define C(g) s = max (s, PxChar (p, glph[g - g_A]));\n\nvec4 glph[26];\n\nfloat PxChar (vec2 p, vec4 c)\n{\n  vec2 cb, ip, fp;\n  float pOn, b;\n  ip = floor (p);\n  if (min (ip.x, ip.y) >= 0. && max (ip.x - 8., ip.y - 12.) < 0.) {\n    b = 8. * (ip.y + 1.) - (ip.x + 1.);\n    if (b < 48.) cb = (b < 24.) ? vec2 (c.w, b) : vec2 (c.z, b - 24.);\n    else cb = (b < 72.) ? vec2 (c.y, b - 48.) : vec2 (c.x, b - 72.);\n    pOn = mod (floor (cb.x / exp2 (cb.y)), 2.);\n  } else pOn = 0.;\n  return pOn;\n}\n\nfloat PxText (vec2 p, int cId)\n{\n  float s;\n  s = 0.;\n  if      (cId == g_S) C(g_S)\n  else if (cId == g_A) C(g_A)\n  else if (cId == g_T) C(g_T) \n  else if (cId == g_O) C(g_O)\n  else if (cId == g_R) C(g_R) \n  else if (cId == g_E) C(g_E)\n  else if (cId == g_P) C(g_P)\n  else if (cId == g_N) C(g_N)\n  return s;\n}\n\nint PxTextId (int txt)\n{\n  int cId;\n  if      (txt == 0 || txt == 24) cId = g_S;\n  else if (txt == 1 || txt == 5  || txt == 19 || txt == 23) cId = g_A;\n  else if (txt == 2 || txt == 10 || txt == 14 || txt == 22) cId = g_T;\n  else if (txt == 3 || txt == 9  || txt == 15 || txt == 21) cId = g_O;\n  else if (txt == 4 || txt == 6  || txt == 18 || txt == 20) cId = g_R;\n  else if (txt == 7 || txt == 11 || txt == 13 || txt == 17) cId = g_E;\n  else if (txt == 8 || txt == 16) cId = g_P;\n  else if (txt == 12) cId = g_N;\n  return cId;\n}\n\nvoid PxInit ()\n{\n  glph[g_A - g_A] = vec4 (0x003078, 0xCCCCCC, 0xFCCCCC, 0xCC0000);\n  glph[g_E - g_A] = vec4 (0x00FE62, 0x60647C, 0x646062, 0xFE0000);\n  glph[g_N - g_A] = vec4 (0x00C6C6, 0xE6F6FE, 0xDECEC6, 0xC60000);\n  glph[g_O - g_A] = vec4 (0x00386C, 0xC6C6C6, 0xC6C66C, 0x380000);\n  glph[g_P - g_A] = vec4 (0x00FC66, 0x66667C, 0x606060, 0xF00000);\n  glph[g_R - g_A] = vec4 (0x00FC66, 0x66667C, 0x6C6666, 0xE60000);\n  glph[g_S - g_A] = vec4 (0x0078CC, 0xCCC070, 0x18CCCC, 0x780000);\n  glph[g_T - g_A] = vec4 (0x00FCB4, 0x303030, 0x303030, 0x780000);\n}\n\nfloat PxTextAA (vec2 qBlkH, int cId)\n{\n  vec3 ee;\n  vec2 qc;\n  float sc;\n  ee = 0.4 * vec3 (1., -1., 0.);\n  qc = 16. * qBlkH + 32. * vec2 (0.1, 0.2);\n  PxInit ();\n  sc = PxText (qc, cId);\n  sc = max (sc, 0.5 * PxText (qc + ee.xz, cId));\n  sc = max (sc, 0.5 * PxText (qc + ee.yz, cId));\n  sc = max (sc, 0.5 * PxText (qc + ee.zx, cId));\n  sc = max (sc, 0.5 * PxText (qc + ee.zy, cId));\n  sc = max (sc, 0.3 * PxText (qc + ee.xx, cId));\n  sc = max (sc, 0.3 * PxText (qc + ee.xy, cId));\n  sc = max (sc, 0.3 * PxText (qc + ee.yy, cId));\n  sc = max (sc, 0.3 * PxText (qc + ee.yx, cId));\n  return sc;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2GRy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[656, 656, 704, 704, 1265], [1267, 1267, 1310, 1310, 1511], [1562, 1562, 1608, 1684, 2482], [2484, 2484, 2518, 2518, 2969], [2971, 2971, 2993, 2993, 3047], [3049, 3049, 3084, 3084, 7448], [7494, 7494, 7550, 7550, 8465], [8467, 8467, 8499, 8499, 8875], [8877, 8877, 8913, 8913, 9119], [9121, 9121, 9151, 9151, 9264], [9266, 9266, 9288, 9288, 9326], [9328, 9328, 9350, 9350, 9388], [9833, 9833, 9864, 9864, 10248], [10561, 10561, 10585, 10585, 11090], [11092, 11092, 11108, 11108, 11646], [11648, 11648, 11686, 11686, 12242], [12276, 12276, 12300, 12300, 12337]], "test": "untested"}
{"id": "7d23zG", "name": "Pulsing circle weave", "author": "DukeOfStraylight", "description": "A rough reproduction of https://cdn.discordapp.com/attachments/740098399956762679/828452299100913735/giphy.gif but without that one annoying circle in the center that moves differently from the others.", "tags": ["circles"], "likes": 19, "viewed": 645, "published": 3, "date": "1617603011", "time_retrieved": "2024-07-30T19:28:31.234973", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 20.;\n\n\n    vec2 id = floor(uv);\n    vec2 center = id + .5;\n    vec2 st = fract(uv);\n\n    float d = 1.;\n    const float NNEI = 2.;\n    for (float x = -NNEI; x <= NNEI; x++) {\n        for (float y = -NNEI; y < NNEI; y++) {\n            vec2 ndiff = vec2(x, y);\n            vec2 c = center + ndiff;\n            float r = length(c);\n            float a = atan(c.y, c.x);\n            r += sin(iTime * 5. - r*0.55) * min(r/5., 1.);\n            vec2 lc = vec2(r*cos(a), r*sin(a));\n            d = min(d, length(uv - lc));\n        }\n    }\n    float w = fwidth(uv.y);\n    vec3 col = vec3(smoothstep(0.31+w, 0.31-w, d));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d23zG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 847]], "test": "untested"}
{"id": "fs23zy", "name": "Temporal Fire", "author": "Tater", "description": "fire stuck in time", "tags": ["2d", "fire"], "likes": 5, "viewed": 305, "published": 3, "date": "1617594405", "time_retrieved": "2024-07-30T19:28:32.006909", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = asin(sin(iTime*0.5)*.9)*2.2;\n    //t = iTime*0.9;\n    vec2 R = iResolution.xy;\n    vec2 ruv = (fragCoord-.5*R.xy)/R.y;\n    vec3 col = vec3(0);\n    \n    for(float i = 0.0; i<3.0;i++){\n        vec2 uv = ruv;\n        t+=0.125;\n        uv.y+=0.5;\n        uv.y*=abs(uv.x*0.1)+0.8;\n        uv*=0.5;\n        uv.x*=1.2;\n        uv.y+=abs(uv.x*uv.x);\n        uv=-uv.yx; \n        uv.y+=(uv.x*3.)*sin(sin(t*10.+uv.x*25.))/10.;\n        uv.x-=asin(sin(t+uv.y*30.))/20.;\n        vec2 d = abs(uv);\n        col.r += 0.24*(step(max(d.x,d.y),0.3)) + 0.2*(step(max(d.x,d.y),0.2));\n        col.g += 0.33*(step(max(d.x,d.y),0.2));\n        col.b += 0.33*(step(max(d.x,d.y),0.1));\n    }\n    col += 0.2*vec3(0.490,0.192,0.196);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs23zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 808]], "test": "untested"}
{"id": "Nd2Gzy", "name": "ships corona", "author": "jorge2017a1", "description": "ships corona", "tags": ["shipscorona"], "likes": 1, "viewed": 204, "published": 3, "date": "1617583629", "time_retrieved": "2024-07-30T19:28:32.844669", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 150.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///-----------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\n///-----------------------------------------------------\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec3 hacerCoronaNueva(vec3 pp  )\n{\n    vec3 p=pp;\n    float numItem=8.0;\n    float tau = atan(1.0) * 8.0;\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n     \n    p= rotate_x( p, radians(90.0));\n    \n    \n    float st1= sdTorus( p, vec2(5.0,0.5) );\n    float st2= sdTorus( p, vec2(10.0,0.5) );\n    \n    p=pp;\n    vec3 rep2 = opAngRep(p, tau / numItem);\n    rep2= rotate_z( rep2-vec3(10.0,0.0,0.0), radians(90.0));\n    rep2= rotate_x( rep2, radians(180.0));\n    \n    float scc1= sdCappedCone( rep2, 5.0, 0.025, 0.5 );\n    \n    res =opU3(res, vec3(st1,4.0,-1.0));\n    res =opU3(res, vec3(st2,32.0,-1.0));\n    res =opU3(res, vec3(scc1,32.0,-1.0));\n    \n    return res;\n    \n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    \n    p.z=opRep1D( p.z+ iTime*20.0, 20.0 );\n    p.x=opRep1D( p.x, 40.0 );\n    \n    \n    p.y=p.y-5.0;\n    vec3 c1= hacerCoronaNueva( p-vec3(0.0,10.0,0.0));\n    res =opU3(res, c1); \n    \n    \n    \n    float sp1= sdSphere(  p-vec3(0.0,10.0,0.0),4.0 );\n    res =opU3(res, vec3(sp1,2.0,MATERIAL_NO)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= MAX_STEPS; i++) \n    {  \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == MAX_STEPS)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false;    minDist = dO;    break; } \n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); \n    return col*2.0;\n    }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n  vec3 col = vec3(0);\n  vec3 p;\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n\n   float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        p = (ro + rd * d ); \n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n    else if(d>MAX_DIST)\n     col= getSkyColA(rd);\n   \n   return col;\n}    \n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    vec3 ro=vec3(15.0,10.0,-25.0+t);  \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    vec3 col= Render( ro,  rd);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define MATERIAL_NO -1.0\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2Gzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 559, 595, 595, 616], [617, 617, 651, 651, 713], [715, 753, 789, 789, 834], [835, 900, 934, 934, 1032], [1033, 1033, 1067, 1067, 1159], [1160, 1160, 1194, 1194, 1286], [1287, 1327, 1361, 1361, 1458], [1459, 1510, 1535, 1535, 1554], [1555, 1555, 1580, 1580, 1599], [1600, 1600, 1636, 1636, 1664], [1666, 1666, 1725, 1725, 2038], [2041, 2098, 2132, 2132, 2305], [2307, 2307, 2341, 2341, 2971], [2973, 3013, 3038, 3038, 3600], [3603, 3603, 3668, 3668, 4252], [4254, 4305, 4329, 4329, 4517], [4521, 4521, 4554, 4554, 5265], [5267, 5321, 5357, 5357, 5591], [5694, 5694, 5743, 5743, 5996], [5997, 6031, 6111, 6111, 6388], [6431, 6482, 6529, 6529, 6749], [6803, 6803, 6896, 6896, 7323], [7327, 7327, 7354, 7354, 7464], [7466, 7466, 7497, 7497, 8151], [8158, 8207, 8264, 8264, 8845]], "test": "untested"}
{"id": "fsj3Ry", "name": "Nodal Surface", "author": "oneshade", "description": "I was messing around with [url=https://www.math3d.org/]math3d's[/url] implicit surface feature and I found something that looks like Cayley's surface. The coefficients and normal turned out beautifully!", "tags": ["3d", "ray", "surface", "intersect", "nodal", "cayley"], "likes": 5, "viewed": 189, "published": 3, "date": "1617578755", "time_retrieved": "2024-07-30T19:28:33.612616", "image_code": "// Saving things on math3d doesn't seem to be too\n// reliable so the link might not work :(\n// https://www.math3d.org/pEE3NdnJ\n\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d, minCplx = 1.0;\n\n    float d0 = b * b - 3.0 * a * c;\n    float d1 = (2.0 * b * b - 9.0 * a * c) * b + 27.0 * a * a * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n    a *= 3.0;\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) < 1e-3 && abs(C.y) < 1e-3) C = q < 0.0 ? vec2(d1, -j) : vec2(d1 - j, 0.0); // Switch sign if C=0\n    C = sin(atan(C.y, C.x) / 3.0 + vec2(1.57079632679, 0.0)) * pow(0.25 * dot(C, C), 1.0 / 6.0);\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, h < 0.0 ? 1 : 3);\n    vec2 e = vec2(1.0, 0.0);\n    for (int k=0; k < (h < 0.0 ? 2 : 3); k++) {\n        vec2 m = e * mat2(C.x, -C.y, C.yx); // Complex multiplication\n        e *= mat2(-0.5, -0.86602540378, 0.86602540378, -0.5); // Raise cube root of unity to next power\n        vec2 root = (vec2(-d0, d0) * m / dot(m, m) - vec2(b, 0.0) - m) / a;\n        if (h < 0.0 ? (abs(root.y) < minCplx) : true) roots[h < 0.0 ? 0 : k] = root.x, minCplx = abs(root.y);\n    }\n\n    return roots;\n}\n\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots[0] = 1.0 / roots[0];\n    if (roots[3] > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\n// Intersection\n// Implicit equation: x^2 + y^2 + z^2 + xyz - c\nvec4 iNodalSurface(in vec3 ro, in vec3 rd, in float iso) {\n    float a = rd.x * rd.y * rd.z;\n    float b = dot(ro, rd.yxx * rd.zzy) + dot(rd, rd);\n    float c = dot(rd, ro.yxx * ro.zzy) + 2.0 * dot(ro, rd);\n    float d = dot(ro, ro) + ro.x * ro.y * ro.z - iso;\n    return solveCubic2(a, b, c, d);    \n}\n\n// Normal\nvec3 nNodalSurface(in vec3 p, in float iso) {\n    return normalize(2.0 * p + p.yxx * p.zzy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    float iso = 4.0 + sin(iTime);\n\n    // Find the closest hit\n    vec4 hit = iNodalSurface(ro, rd, iso);\n    float t = 1000000000.0;\n    vec3 hitPos;\n    for (int n=0; n < int(hit[3]); n++) {\n        vec3 hitCandid = ro + rd * hit[n];\n        if (hit[n] > 0.0 && hit[n] < t && length(hitCandid) < 6.0) {\n            t = hit[n];\n            hitPos = hitCandid;\n        }\n    }\n\n    // Render the shape if hitting\n    if (t < 1000000000.0) {\n        vec3 n = nNodalSurface(hitPos, iso);\n        float diff = abs(dot(n, -rd));\n        float checkers = mod(dot(floor(hitPos), vec3(1.0)), 2.0);\n        fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25) * diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsj3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 193, 193, 1295], [1297, 1297, 1363, 1363, 1506], [1508, 1572, 1630, 1630, 1874], [1876, 1886, 1931, 1931, 1980], [1982, 1982, 2037, 2037, 3436]], "test": "untested"}
{"id": "Ndj3RG", "name": "Stepped Gradient Example", "author": "worldofzero", "description": "This is intended as a simpler example of what is happening in this shader: https://www.shadertoy.com/view/NsjGRG\n\nMaps Y coordinate to a 3 color gradient.", "tags": ["example"], "likes": 1, "viewed": 1612, "published": 3, "date": "1617568854", "time_retrieved": "2024-07-30T19:28:34.441399", "image_code": "vec4 gradient(float pos)\n{\n    float step1 = 0.333;\n    float step2 = 0.667;\n    \n    vec3 result = vec3(1, 0, 0); //Step0 between 0 and step1\n    // Step through each case and choose either the previous result or the new result:\n    result = mix(result, vec3(0, 1, 0), step(step1, pos));\n    result = mix(result, vec3(0, 0, 1), step(step2, pos));\n    return vec4(result, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // In GLSL y = 0 is at the bottom of the screen\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Output to screen\n    fragColor = gradient(uv.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndj3RG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 377], [379, 379, 436, 538, 636]], "test": "untested"}
{"id": "NsjGRG", "name": "Pride / Stepped Gradient Flag", "author": "worldofzero", "description": "This is an exploration of stepped gradients that turned into a Pride flag shader. Leans heavily on the step function.\n\nYou may customize this by changing the configured COLOR1-12 definitions.", "tags": ["flag"], "likes": 6, "viewed": 3612, "published": 3, "date": "1617567960", "time_retrieved": "2024-07-30T19:28:35.261208", "image_code": "// Note this is a modification of a HLSL shader written for the Windows Terminal\n// You may swap out each of the 12 color bands to create a different flag.\n// Adjusting the two periods will change the waving effect.\n\n// Settings\n// Customize Colors (1 = TOP of screen, 12 is bottom)\n// to create a different flag. Some examples below (only uncomment one section)\n//\n// Pride:\n#define COLOR1 vec4(0.95,0.0,0.0,1.0)\n#define COLOR2 vec4(0.95,0.0,0.0,1.0)\n#define COLOR3 vec4(1.0,141.0/255.0,0.0,1.0)\n#define COLOR4 vec4(1.0,141.0/255.0,0.0,1.0)\n#define COLOR5 vec4(1.0,0.95,0.0,1.0)\n#define COLOR6 vec4(1.0,0.95,0.0,1.0)\n#define COLOR7 vec4(0.0,129.0/255.0,33.0/255.0,1.0)\n#define COLOR8 vec4(0.0,129.0/255.0,33.0/255.0,1.0)\n#define COLOR9 vec4(0.0,76.0/255.0,1.0,1.0)\n#define COLOR10 vec4(0.0,76.0/255.0,1.0,1.0)\n#define COLOR11 vec4(118.0/255.0, 1.0/255.0, 136.0/255.0, 1.0)\n#define COLOR12 vec4(118.0/255.0, 1.0/255.0, 136.0/255.0, 1.0)\n\n// Trans:\n// #define COLOR1 vec4(0.33,0.8,0.95,1.0)\n// #define COLOR2 vec4(0.33,0.8,0.95,1.0)\n// #define COLOR3 vec4(0.33,0.8,0.95,1.0)\n// #define COLOR4 vec4(0.97,0.6,0.675,1.0)\n// #define COLOR5 vec4(0.97,0.6,0.675,1.0)\n// #define COLOR6 vec4(1.0,1.0,1.0,1.0)\n// #define COLOR7 vec4(1.0,1.0,1.0,1.0)\n// #define COLOR8 vec4(0.97,0.6,0.675,1.0)\n// #define COLOR9 vec4(0.97,0.6,0.675,1.0)\n// #define COLOR10 vec4(0.33,0.8,0.95,1.0)\n// #define COLOR11 vec4(0.33,0.8,0.95,1.0)\n// #define COLOR12 vec4(0.33,0.8,0.95,1.0)\n\n// Flag Strength is the opacity of the flag (1.0 is completely opaque)\n#define FLAGSTRENGTH 1.0\n// Control the sin wave length and strength of the flag wave\n#define PERIOD1POSITION 10.0\n#define PERIOD2POSITION 0.5\n#define PERIOD1STRENGTH 0.05\n#define PERIOD2STRENGTH 0.2\n#define PERIOD1TIME 1.1\n#define PERIOD2TIME 1.0\n\nvec4 flagColor(float position) {\n    // Invert position for GLSL\n    position = 1.0 - position;\n\n    float step1 = 0.0;\n    float step2 = 0.08333;\n    float step3 = 0.1667;\n    float step4 = 0.25;\n    float step5 = 0.3333;\n    float step6 = 0.4167;\n    float step7 = 0.5;\n    float step8 = 0.5833;\n    float step9 = 0.6667;\n    float step10 = 0.75;\n    float step11 = 0.8333;\n    float step12 = 0.9167;\n    \n    vec4 result = COLOR1;\n    result = mix(result, COLOR2, step(step2, position));\n    result = mix(result, COLOR3, step(step3, position));\n    result = mix(result, COLOR4, step(step4, position));\n    result = mix(result, COLOR5, step(step5, position));\n    result = mix(result, COLOR6, step(step6, position));\n    result = mix(result, COLOR7, step(step7, position));\n    result = mix(result, COLOR8, step(step8, position));\n    result = mix(result, COLOR9, step(step9, position));\n    result = mix(result, COLOR10, step(step10, position));\n    result = mix(result, COLOR11, step(step11, position));\n    result = mix(result, COLOR12, step(step12, position));\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float height = fragCoord.y;\n    height += sin(iTime * PERIOD1TIME + fragCoord.x / iResolution.x * PERIOD1POSITION ) / PERIOD1STRENGTH;\n    height += sin(iTime * PERIOD2TIME + fragCoord.x / iResolution.x * PERIOD2POSITION ) / PERIOD2STRENGTH;\n    fragColor = flagColor(height / iResolution.y) * FLAGSTRENGTH;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjGRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1776, 1776, 1808, 1840, 2864], [2866, 2866, 2923, 2923, 3237]], "test": "untested"}
{"id": "sdjGzR", "name": "Nutrition Facts", "author": "blackle", "description": "no label since it was implemented as an svg image", "tags": ["liquid", "soda"], "likes": 35, "viewed": 1276, "published": 3, "date": "1617557705", "time_retrieved": "2024-07-30T19:28:36.131880", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat hash(float a, float b) {\n\tint x = floatBitsToInt(a*a/7.)^floatBitsToInt(a+.1);\n\tint y = floatBitsToInt(b*b/7.)^floatBitsToInt(b+.1);\n\treturn float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n\tfragColor /= fragColor.w; //\"film grain\"\n\tfragColor *= 1.0 - dot(uv,uv)*0.5; //vingetting lol\n\tfragColor = smoothstep(0.09,0.99,sqrt(fragColor))+.02; //colour grading\n\tfragColor += hash(uv.x,uv.y)*.015;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//label\n//from https://www.shadertoy.com/view/4sKyRK\nfloat distanceToBottleCurve(vec2 point) {\n    return point.y-0.1*sin(point.x*2.5 + 0.6) + 0.05*sin(5.0*point.x) + 0.04*sin(7.5*point.x);\n}\nbool texturee(vec2 uv) {\n    float ang = atan(uv.y, uv.x);\n    float len = floor(length(uv)*10.0);\n    bool val = len == 2. || len == 6. || len == 9.;\n    if (len == 3. || len == 4. || len == 5. || len == 8. || len == 10.) {\n        val = distanceToBottleCurve(vec2(ang+len,0.0))*7.99 > cos(len*7.99);\n    }\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.xy;\n\n    //I would make a better revision logo but I am too tired :(\n    fragColor = vec4(232./255., 40./255., 40./255.,1);\n    float rad1 = abs(floor(atan(uv.x,uv.y)/2.)*.04);\n    if (texturee(uv*3.5)) {\n        fragColor = vec4(1);\n    }\n}", "buffer_a_inputs": [], "buffer_b_code": "\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(b-a))/k;\n    return min(a,b) - h*h*h*k/6.;\n}\n\nfloat ss(vec2 p) {\n  return sqrt(length(p*p));\n}\n\nfloat ss(vec3 p) {\n  return sqrt(length(p*p));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return length(p-mix(a,b,clamp(k,0.,1.)));\n}\n\nvec2 kink(vec2 p, vec2 c, float k) {\n    p -= c;\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    ang -= ang/sqrt(1.+ang*ang)*(1.-k);\n    return vec2(sin(ang),cos(ang))*len + c;\n}\n\nfloat cn(vec2 p) {\n  return ss(max(p,0.)) + min(0.,max(p.x,p.y));\n}\n\n//welcome to the 4 dimensional corner function how may I take your order?\nfloat cn(vec4 p) {\n    return length(max(p,0.))+min(0.,max(max(p.x,p.y),max(p.z,p.w)));\n}\n\nfloat cylinder(vec3 p, vec2 d) {\n  return cn(vec2(length(p.xy), abs(p.z)) - d);\n}\n\nfloat chamfer(vec2 p, float st, float r, float f) {\n  return smin(-cn(-p), dot(p,normalize(vec2(st,1)))-r, r*f);\n}\n\nfloat cantab(vec3 p){\n    vec2 off=vec2(0,cos(p.r)/4.);\n    p=erot(p,vec3(1,0,0),-.1)-vec3(0,0,.4);\n    if(abs(p.r)<3.4&&p.g<0.&&p.g>-7.)p.b+=smoothstep(0.,5.,p.g+7.)*.5;\n    float connector=cn(vec2(p.b+.1+.2,cn(abs(p.rg-vec2(0,-6))-vec2(3,4)+.2+2.)-2.))-.2;\n    float tabprofile=linedist(p.rg+off,vec2(0,4.25),vec2(0,-4.25))-6.55;\n    float tab=cn(vec2(tabprofile,abs(p.b)))-.5;\n    float indent=-chamfer(vec2(tabprofile+4.,.5-p.b),.6,1.5,.5);\n    float bridge=cn(vec2(p.b+.1+.8,linedist(p.rg,vec2(-10.,2.),vec2(10.,2.))-.05))-.8;\n    indent=smin(min(bridge,connector),indent,1.3);\n    return-smin(-indent,-tab,.5);\n}\n\nfloat stex(vec3 p) {\n\treturn sin(dot(sin(p*32.),vec3(2,9,1)))*cos(dot(cos(p*43.),vec3(6,1,5)))+sin(dot(sin(p*52.),vec3(2,3,9)))*cos(dot(cos(p*73.),vec3(9,1,2)));\n}\n\nvec3 gcancoords;\nfloat thecan(vec3 p){\n    gcancoords = p;\n    if (length(p)> 1.1) return length(p)-1.; //proxy\n    p.z += stex(p*vec3(6,.2,.1))*.0001*smoothstep(.78,.8,p.z);\n    p*=80.;\n    \n    float outer1=cylinder(p,vec2(24.345,58.925))-2.;\n    float outer2=cylinder(p-vec3(0,0,3.105),vec2(23.2,64.83))-2.;\n    float rim=cylinder(p-vec3(0,0,69.63),vec2(23.88,-.75))-2.;\n    float subinner=cylinder(p-vec3(0,0,69.63),vec2(22.25,3.))-2.;\n    float addinner=cylinder(p-vec3(0,0,64.63),vec2(20.56,.5))-2.;\n    float knob=cylinder(p-vec3(0,0,67.23),vec2(1.65,.55))-.25;\n    vec3 p2=vec3(sqrt(p.r*p.r+4.),p.gb);\n    // float bumps=length(p2-vec3(4.,10.,66.13))-1.1;\n    float hole=cn(vec2(-smin(-length(p.rg-vec2(0,-9))+8.,-length(p.rg-vec2(0,-15))+11.5,3.),-p.z));\n    p2.g+=20.5;\n    p2.gr=kink(p2.gr,vec2(10,0),.1);\n    float ridge=length(vec2(p.b-66.73,linedist(p2.rg,vec2(2,-2),vec2(12,14))))-.5;\n    float fuckery=ss(p-vec3(5,-6.5,66.73))-2.;\n    float inside=cylinder(p-vec3(0,0,14.63),vec2(20.56,52.));\n    // float tab=10000.;\n    // p-=vec3(5,-4.,66.23);\n    // p=erot(p,normalize(vec3(1.5,-.5,.4)),-1.);\n    // p+=vec3(5.,-4.5,66.73);\n    float main=chamfer(vec2(outer1,outer2),.4,1.4,.9);\n    main=smin(-smin(-min(main,rim),subinner,1.),addinner,2.);\n    main=-smin(hole,-min(main,knob),.5);\n    main=-smin(-smin(main,ridge,1.),fuckery,3.);\n    main=max(main,-inside);\n    \n    if(p.b>60.)\n    \tmain=min(main,cantab(erot(gcancoords*80.,vec3(0,0,1),.2)-vec3(0.,5.5,68.13)));\n    return main/80.;\n}\n\nfloat gated_sphere(vec3 p, float scale, bool gate) {\n    if (!gate) {\n        p = abs(p);\n        if(p.x < p.y) p.xy = p.yx;\n        if(p.y < p.z) p.yz = p.zy;\n        if(p.x < p.y) p.xy = p.yx;\n        p.x -= scale;\n    }\n    return length(p)-scale/4.;\n}\n\nfloat hash(float a, float b) {\n\tint x = floatBitsToInt(a*a/7.)^floatBitsToInt(a+.1);\n\tint y = floatBitsToInt(b*b/7.)^floatBitsToInt(b+.1);\n\treturn float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\n//help... me... the SDF functions... are taking over... AAUAHGGUGHG\nfloat bubbleify(vec3 p, float sdf) {\n    float bubbles = 1e9;\n    float scale = .06;\n    for (int i = 0; i < 3; i++) { //loops in an sdf function.. please forgive me!!!\n        p = erot(p, normalize(vec3(i,2,4)), .7)+.2;\n        scale *= .8;\n\n        //ripe for minify\n        vec3 id = round(p/scale)*scale;\n        //not using hash here bc it's too different on other platforms\n        bool gated = stex(id) > .65;\n        float holes = gated_sphere(p-id, scale, gated);\n        bubbles = min(bubbles, holes);\n        \n    }\n    \n    return max(smin(-bubbles, -sdf-.002, .005), sdf);\n}\n\nfloat fractal(vec2 p, float k) {\n    vec2 cut = normalize(vec2(k,1.));\n    float scale = 1.;\n    for (int i = 0; i < 4; i++) {\n        p.x = sqrt(p.x*p.x+.05)-sqrt(.05);\n        p.y = sqrt(p.y*p.y+.05)-sqrt(.05);\n        p.x -= 1.;\n        p += smin(0.,-dot(p,cut),.5)*2.*cut;\n        p *= 2.;\n        scale *= 2.;\n    }\n    return linedist(p,vec2(1,0), vec2(-2,0))/scale;   \n}\n\nfloat splat;\nfloat scene(vec3 p) {\n    float can = 10000.;\n    if (p.y < 0.) can = thecan(erot(p-vec3(-0.2,-1.90,-1.25), vec3(0.49, 0.34, 0.8), 1.79));\n\n    p.x += cos(p.z*4.)/25.*cos(p.y*5.);\n    //p.y += 1.;\n    float fr1 = fractal(p.yz, 1.8);\n    vec3 p2 = erot(p,normalize(vec3(1)),.4);\n    float fr2 = fractal(p2.yz, 2.4);\n    //this is like, a 4 dimensional.. intersection(?) of two versions of a KIFS fractal\n    splat = cn(vec4(fr1-.045, fr2-.045, abs(p.x), p2.x)/sqrt(2.))-.008+ cos(fr1*100.)*.001+ cos(fr2*200.)*.001;\n    if (splat < 0.) splat = bubbleify(p, splat);\n    //return can;\n    //return splat;\n    return min(splat, can);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.0001);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 pixel_color( vec2 uv, float hs )\n{\n    vec3 cam = normalize(vec3(1.9,uv));\n    vec3 init = vec3(-4,-.6,-.6);\n    \n    float zrot = 4.;\n    // float yrot = .0;\n    cam = erot(cam, vec3(1,0,0), -.6);\n    //cam = erot(cam, vec3(0,1,0), yrot);\n    //init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool bounce = false;\n    float k = 1.;\n    float cola = 0.;\n    bool recalcK = false;\n    bool escape = false;\n    bool label = false;\n    vec3 cancoords;\n    vec3 n;\n    for (int i = 0; i < 150; i++) {\n        float dist = scene(p);\n        if (recalcK) { k = dist < 0. ? -1. : 1.; recalcK = false; }\n        p += cam*dist*k;\n        if (dist < 0.) cola += abs(dist);\n        if (dist*dist < 1e-9) {\n            cancoords = gcancoords; //this is a nightmare of my own creation\n            bool iscola = dist == splat;\n            if (iscola) escape=true;\n            hs = hash(hs, 9.3);\n            n = norm(p)*k;\n            float fres = abs(dot(n,cam))*.98;\n            if (hs*.5+.5 > fres || !iscola) {\n                cam = reflect(cam,n);\n                if (length(cam)==0.)cam=n;\n                if (!iscola) {\n                    if (abs(cancoords.z) < .72 && length(cancoords.xy) > .31) {\n                        label = true;\n                    }\n                }\n                cam = normalize(cam);\n                bounce = true;\n                // p += n*.0005;\n            } else {\n                cam = refract(cam,n, k < 0. ? 1.33 : 1./1.33);\n            }\n            p += n*.0005*sign(dot(cam,n));\n            recalcK = true;\n            //break;\n        }\n        if (length(p-init) > 10.) { escape=true; break; }\n    }\n    \n    \n    float fact = length(sin(cam*3.9)*.5+.5);\n    vec3 environ = vec3(smoothstep(1.,2.5,fact)+smoothstep(1.45,1.6,fact)*8.) + fact/8.;\n    //environ = 1.;\n    //environ += cola*1000.;\n    environ *= mix(vec3(1), vec3(1.,0.5,0.4), smoothstep(0.,.4,cola+.1));\n    vec3 col = (bounce&&escape) ? environ : vec3(0.0);\n    col += cola*vec3(1.,0.5,0.4)*2.;\n    if (label) {\n        //diffuse material takes too long to converge, so it's time 2 cheat :3\n        vec2 texcoords = vec2(atan(cancoords.y,cancoords.x)/3.1415-.15, cancoords.z*.7+.5);\n        float diff = length(sin(n*3.)*.5+.5)/sqrt(3.);\n        vec4 tone = pow(length(texcoords-vec2(.5, .65)) < .25 ? vec4(1) : vec4(232./255., 40./255., 40./255.,1),vec4(2.));\n        tone = texture(iChannel1, texcoords);\n        col += diff*tone.xyz*.8;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n\tfloat sd = float(iFrame);\n\tsd = hash(sd, 2.6);\n\tvec2 h2 = tan(vec2(hash(sd, 6.7), hash(sd, 3.6)));\n\tvec2 uv2 = uv + h2/iResolution.y;\n\tfragColor += vec4(pixel_color(uv2, sd), 1);\n\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjGzR.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 224, 224, 375], [377, 377, 434, 434, 760]], "test": "untested"}
{"id": "7sS3Dm", "name": "Learning via Mandelbulb SDF", "author": "piqey", "description": "This is a shader I started working on to better understand GLSL and see what I could do with it. Raymarching SDF's has been done a million times before but its simple enough and widely documented so it seemed like a great choice for a topic.", "tags": ["raymarching", "mandelbulb", "learning"], "likes": 2, "viewed": 383, "published": 3, "date": "1617557236", "time_retrieved": "2024-07-30T19:28:36.909801", "image_code": "const float PI = 3.14159265359;\nconst float PI2 = PI * 2.0;\n\nconst float blurDirections = 8.0;\nconst float blurQuality = 4.0;\nconst float blurSize = 6.0;\n\nconst float glowStrength = 1.0;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 image = texture(iChannel0, uv);\n    vec4 highPass = texture(iChannel1, uv);\n    \n    vec2 blurRadius = blurSize / iResolution.xy;\n    \n    for (float d = 0.0; d < PI2; d += PI2 / blurDirections)\n    {\n        for (float i = 1.0 / blurQuality; i <= 1.0; i += 1.0 / blurQuality)\n        {\n            highPass += texture(iChannel1, uv + vec2(cos(d), sin(d)) * blurRadius * i);\n        }\n    }\n\n    // Output\n    highPass /= blurQuality * blurDirections - 15.0;\n    highPass *= glowStrength;\n\n    fragColor = image + highPass;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Raymarching\nconst float stepSize = 0.1;\n\nconst vec3 bgCol = vec3(0.0);\n// const vec3 specularCol = vec3(0.1);\nconst vec3 diffuseCol0 = vec3(0.321, 0, 0.439); // vec3(0.811, 0.0, 0.980);\nconst vec3 diffuseCol1 = vec3(0.980, 0.0, 0.866);\n\nconst float colGradPow = 0.9;\n\nconst vec3 lightPos = vec3(2.0, 5.0, -3.0);\nconst vec3 lightColor = vec3(1.0);\n\n// Mathematics\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nconst float gradStep = 0.02;\n\n// Configuration\nconst float camFOV = 45.0;\nconst float zClip = 1000.0;\n\n\n// World-building\nfloat sdfSphere(vec3 pt, vec3 center, float radius)\n{\n    return length(pt - center) - radius;\n}\n\n/*\nfloat sdfBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat sdfUnion(float d0, float d1)\n{\n    return min(d0, d1);\n}\n*/\n\nfloat sdfInter(float d0, float d1)\n{\n    return max(d0, d1);\n}\n\n/*\nfloat sdfSub(float d0, float d1)\n{\n    return max(d0, -d1);\n}\n\nfloat sdfUnion_s(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdfDisp(vec3 p)\n{\n    return sin(p.x) * sin(p.y) * sin(p.z);\n}\n\nvec3 sdfTwist(vec3 p, float a)\n{\n    float c = cos(a * p.y);\n    float s = sin(a * p.y);\n    mat2 m = mat2(c, -s, s, c);\n\n    return vec3(m * p.xz, p.y);\n}\n\nvec3 sdfRep(vec3 p, vec3 c)\n{\n    return mod(p, c) - 0.5 * c;\n}\n*/\n\nfloat sdfMandel(vec3 p, float power)\n{\n    vec3 z = p;\n    float dr = 1.0;\n    float r;\n    \n    for (int i = 0; i < 16; i++)\n    {\n        r = length(z);\n        \n        if (r > 2.0)\n            break;\n        \n        float theta = acos(z.z / r) * power;\n        float phi = atan(z.y / z.x) * power;\n        float zr = pow(r, power);\n        \n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n        \n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    \n    return 0.5 * log(r) * r / dr;\n}\n\nfloat world(vec3 pt) // so it's easier to find <-------------------\n{\n    /*\n    float sphere0 = sdfSphere(pt, vec3(0.0), 1.0);\n    float box0 = sdfBox(pt, vec3(sin(iTime / 4.0) * 0.05 + 0.8));\n    \n    float step0 = sdfInter(sphere0, box0);\n    \n    float sphere1 = sdfSphere(pt, vec3(0.0), 0.9);\n    \n    float step1 = sdfSub(step0, sphere1);\n    \n    float sphere2 = sdfSphere(pt, vec3(0.0), sin(iTime) * 0.1 + 0.25);\n    \n    float step2 = sdfUnion(step1, sphere2);\n    \n    // float someNoise = max(0.0, texture(iChannel1, pt / 10.0 + vec3(iTime / 100.0)).x / 10.0);\n\n    return step2; // + someNoise\n    */\n    \n    float mandel = sdfMandel(pt, cos(iTime / 4.0) * 4.0 + 8.0);\n    float sphere0 = sdfSphere(pt, vec3(0.0), 1.0);\n    \n    return sdfInter(mandel, sphere0);\n}\n\n// Camera mathematics\nvec3 rayDir(float fov, vec2 size, vec2 pos)\n{\n    vec2 xy = pos - size * 0.5;\n    \n    float cotHalfFOV = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\n    float z = size.y * 0.5 * cotHalfFOV;\n    \n    return normalize(vec3(xy, -z));\n}\n\nmat3 rotXY(vec2 angle)\n{\n    vec2 c = cos(angle);\n    vec2 s = sin(angle);\n    \n    return mat3(\n        c.y, 0.0, -s.y,\n        s.y * s.x, c.x, c.y * s.x,\n        s.y * c.x, -s.x, c.y * c.x\n    );\n}\n\n// Image generation\nvec3 calcNormal(vec3 pt)\n{\n    const vec3 smallStep = vec3(gradStep, 0.0, 0.0);\n    \n    float gradX = world(pt + smallStep.xyy) - world(pt - smallStep.xyy);\n    float gradY = world(pt + smallStep.yxy) - world(pt - smallStep.yxy);\n    float gradZ = world(pt + smallStep.yyx) - world(pt - smallStep.yyx);\n\n    vec3 normal = vec3(gradX, gradY, gradZ);\n\n    return normalize(normal);\n}\n\nvec3 fresnel(vec3 F0, vec3 h, vec3 l) {\n\treturn F0 + (1.0 - F0) * pow(clamp(1.0 - dot(h, l), 0.0, 1.0), 5.0);\n}\n\nfloat colGradStep(vec3 pt, vec3 normal)\n{\n    float dotted = dot(pt, normal) / 2.0 + 1.0;\n    dotted = pow(dotted, colGradPow);\n\n    return 1.0 - dotted;\n}\n\nvec3 shade(vec3 pt, vec3 normal, vec3 dir, vec3 eye)\n{\n    // const float shininess = 16.0;\n    \n    // vec3 final = vec3(0.0);\n    // vec3 ref = reflect(dir, normal);\n    \n    // vec3 Ks = specularCol;\n    vec3 Kd = mix(diffuseCol0, diffuseCol1, colGradStep(pt, normal)); // diffuseCol;\n    \n    // Light 0 (maybe more later, need to find good way of looping)\n    /*\n    {\n        vec3 vl = normalize(lightPos - pt);\n        \n        vec3 diffuse = Kd; // Kd * vec3(max(0.0, dot(vl, normal)));\n        vec3 specular = vec3(max(0.0, dot(vl, ref)));\n        \n        vec3 F = fresnel(Ks, normalize(vl - dir), vl);\n        specular = pow(specular, vec3(shininess));\n        \n        final += lightColor * mix(diffuse, specular, F);\n    }\n    */\n    \n    // final += texture(iChannel0, ref).rgb * fresnel(Ks, normal, -dir);\n    \n    return Kd; // final;\n}\n\nbool raymarch(vec3 o, vec3 dir, inout float depth, inout vec3 n) {\n\tfloat t = 0.0;\n    float d = 10000.0;\n    float dt = 0.0;\n\n    for (int i = 0; i < 128; i++)\n    {\n        vec3 v = o + dir * t;\n        d = world(v);\n\n        if (d < 0.001)\n        {\n            break;\n        }\n\n        dt = min(abs(d), 0.1);\n        t += dt;\n\n        if (t > depth)\n        {\n            break;\n        }\n    }\n    \n    if (d >= 0.001)\n    {\n        return false;\n    }\n    \n    t -= dt;\n\n    for (int i = 0; i < 4; i++)\n    {\n        dt *= 0.5;\n        vec3 v = o + dir * (t + dt);\n\n        if (world(v) >= 0.001)\n        {\n            t += dt;\n        }\n    }\n    \n    depth = t;\n    n = normalize(calcNormal(o + dir * t));\n    \n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Default camera position\n    vec3 eye = vec3(0.0, 0.0, 3.5);\n    vec3 dir = rayDir(camFOV, iResolution.xy, fragCoord.xy);\n    \n    // Camera rotation\n    mat3 rot = rotXY((iMouse.xy - iResolution.xy * 0.5).yx * vec2(0.01, -0.01));\n    dir = rot * dir;\n    eye = rot * eye;\n\n    // Raymarch\n    float depth = zClip;\n    vec3 normal = vec3(0.0);\n    \n    if (!raymarch(eye, dir, depth, normal))\n    {\n        fragColor = vec4(bgCol, 1.0); // texture(iChannel0, dir);\n        return;\n    }\n\n    // Shading\n    vec3 pos = eye + dir * depth;\n    \n    vec3 col = shade(pos, normal, dir, eye);\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "const float pass = 0.15;\nconst vec3 noPassCol = vec3(0.0);\n\n\nvec4 threshold(vec4 px, float threshold)\n{\n   // luminosity (wtf)\n   float lum = dot(px, vec4(0.299, 0.587, 0.114, 0.0));\n   // Return color but only if it passes\n   return (lum > threshold) ? px : vec4(noPassCol, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 original = texture(iChannel0, uv);\n    vec4 highPass = threshold(original, pass);\n\n    fragColor = highPass;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sS3Dm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 244, 244, 825]], "test": "untested"}
{"id": "NsBGzy", "name": "Submit [Revision 2021]", "author": "yx", "description": "Released in the 4k Executable Graphics compo at Revision 2021.\n\nDownload the executable version here: [url]https://www.pouet.net/prod.php?which=88577[/url]\n\nNote: All comments on how to minify the shader further will be deleted.", "tags": ["sdf", "pathtracing", "revision", "sizecoding", "demoparty", "bdsm"], "likes": 30, "viewed": 837, "published": 3, "date": "1617551725", "time_retrieved": "2024-07-30T19:28:37.864248", "image_code": "float seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn fract((p+p)*p);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\t// seed the RNG (again taken from Devour)\n    seed = float((int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\n\t// readback the buffer\n\tvec4 tex = texelFetch(iChannel0,ivec2(gl_FragCoord.xy),0);\n    \n    vec2 uv = gl_FragCoord.xy/iResolution.xy;\n    uv-=.5;\n\t\n    // divide by sample-count\n\tvec3 color = tex.rgb/tex.a;\n    \n    // kinda hacky firefly denoiser\n    vec4 t0 = texelFetch(iChannel0,ivec2(gl_FragCoord.xy)+ivec2( 1,0),0); t0/=t0.w;\n\tvec4 t1 = texelFetch(iChannel0,ivec2(gl_FragCoord.xy)+ivec2(-1,0),0); t1/=t1.w;\n\tvec4 t2 = texelFetch(iChannel0,ivec2(gl_FragCoord.xy)+ivec2(0, 1),0); t2/=t2.w;\n\tvec4 t3 = texelFetch(iChannel0,ivec2(gl_FragCoord.xy)+ivec2(0,-1),0); t3/=t3.w;\n    vec4 colMax = max(max(t0,t1),max(t2,t3));\n    vec4 colMid = (t0+t1+t2+t3)*.25;\n\tif (color.r > colMax.r+.015)\n\t{\n\t\tcolor = colMid.rgb;\n\t}\n\n    // exposure and tonemap\n    color = 1.-exp(color*-2.);\n\n\t// gamma correction\n\tcolor = pow(color, vec3(.45));\n\n    // make it pop\n    color = mix(color,smoothstep(.0,1.,color),.6);\n    \n    // raise black level\n    color = mix(vec3(.04),vec3(1),color);\n\n    // grain\n    color += (vec3(hash(),hash(),hash())-.5)*.01;\n\n    // aspect ratio\n    uv*=vec2(iResolution.xy/iResolution.yx);\n    color *= step(abs(uv.y),.5/(20./9.));\n    color *= step(abs(uv.x),.5*(20./9.));\n        \n\tfragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi acos(-1.)\n#define tau (pi*2.)\n\n\nfloat seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn fract((p+p)*p);\n}\nvec2 hash2(){return vec2(hash(),hash());}\n\nmat2 rotate(float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdRoundBox2( vec2 p, vec2 b, float r )\n{\n  vec2 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k )\n{\n    return -smin(-a,-b,k);\n}\n\n\n\nint mat;\nconst int matNormal = -1;\nconst int matBall = 0;\nconst int matLeather = 1;\nconst int matMetal = 2;\nconst int matGround = 3;\n\nfloat scene_ball(vec3 p)\n{\n    float ball = length(p)-10.;\n    float seam = sdTorus(p.xzy,vec2(10.,.035));\n    return min(ball,seam);\n}\n\nfloat scene_inner_strap(vec3 p, float rivets)\n{\n    float height = 2.5;\n    float thickness = .4;\n\n    vec3 p1=p+vec3(0,0,smoothstep(20.,25.,abs(p.x))*.9);\n    float strap1 = sdRoundBox(p1,vec3(25,height,thickness),.1);\n    \n    vec3 p2=vec3(abs(p.x),p.yz)-vec3(20,0,1.+smoothstep(20.,25.,abs(p.x))*.9);\n    float strap2 = sdRoundBox(p2,vec3(5,height,thickness),.1);\n    \n    vec2 p3=vec2(length(vec2(abs(p.x)-25.,p.z-.5))-1.4,p.y);\n    float strap3 = max(sdRoundBox2(p3,vec2(thickness,height),.1),24.9-abs(p.x));\n    \n    float strap = min(min(strap1,strap2),strap3);\n    \n    strap = smax(strap,-rivets*.5,.5);\n    \n    if(abs(strap) < .025)\n    {\n        strap += (texture(iChannel1,p*.4).r-.5)*.025;\n    }\n    \n    return strap;\n}\n\nfloat scene_outer_strap(vec3 p)\n{\n    float height = 4.2;\n    float thickness = .4;\n    float loopRadius = .5;\n\n    vec3 p1=p+vec3(0,0,smoothstep(22.,25.,abs(p.x))*loopRadius);\n    float strap1 = sdRoundBox(p1,vec3(25,height,thickness),.1);\n    \n    vec3 p2=vec3(abs(p.x),p.yz)-vec3(22,0,1.+smoothstep(22.,25.,abs(p.x))*loopRadius);\n    float strap2 = sdRoundBox(p2,vec3(3,height,thickness),.1);\n    \n    vec2 p3=vec2(length(vec2(abs(p.x)-25.,p.z-.5))-(loopRadius+.5),p.y);\n    float strap3 = max(sdRoundBox2(p3,vec2(thickness,height),.1),24.9-abs(p.x));\n    \n    float strap = min(min(strap1,strap2),strap3);\n    \n    if(abs(strap) < .025)\n    {\n        strap += (texture(iChannel1,p*.4).r-.5)*.025;\n    }\n    \n    return strap;\n}\n\nfloat scene_inner_strap_rivets(vec3 p)\n{\n    p.x = abs(p.x)-18.;\n    p.z = abs(p.z-.4)-.75;\n    \n    float r = 1.5;\n    float bound = length(p)-r;\n    if (bound > .1)\n        return bound;\n    return sdEllipsoid(p,vec3(r,r,.4));\n}\n\nfloat scene_d_ring(vec3 p)\n{\n    float thickness = .6;\n    float bigradius = 6.;\n    float smallradius = 2.;\n    \n    float bigring = sdTorus(p.xzy,vec2(bigradius,thickness));\n    p.y=max(abs(p.y)-bigradius+smallradius,0.);\n    float corner = sdTorus(p.xzy,vec2(2,thickness));\n    return min(max(bigring,p.x),max(corner,-p.x));\n}\n\nfloat scene(vec3 p)\n{\n    vec3 oop=p;\n    \n    p.xz *= rotate(pi);\n    p.yz *= rotate(.5);\n    vec3 op=p;\n\n    float ball = scene_ball(p);\n    \n    vec2 pp=vec2(0,40)-p.xz;\n    p.xz = vec2(atan(pp.x,pp.y)*40.,-length(pp.xy)+40.);\n    float inner_strap_rivets = scene_inner_strap_rivets(p);\n    float inner_strap = scene_inner_strap(p,inner_strap_rivets);\n\n    p=op;\n    p.x = 58.4-abs(p.x);\n    p.xz *= rotate(1.);\n    p.xz -= vec2(-20.4,31.4);\n\n    float outer_strap = scene_outer_strap(p);\n    \n    p=op;\n    p.x=abs(p.x);\n    p.x -= 27.7;\n    p.z-=11.5;\n    p.xz*=rotate(-.7);\n    float d_ring = scene_d_ring(p);\n\n    float best = ball;\n    //best=min(best,ground);\n    best=min(best,inner_strap);\n    best=min(best,outer_strap);\n    best=min(best,inner_strap_rivets);\n    best=min(best,d_ring);\n    \n         if (best==ball)               mat=matBall;\n    else if (best==inner_strap)        mat=matLeather;\n    else if (best==outer_strap)        mat=matLeather;\n    else if (best==inner_strap_rivets) mat=matMetal;\n    else if (best==d_ring)             mat=matMetal;\n    \n    return best;\n}\n\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,-1),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// various bits of lighting code \"borrowed\" from \n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = hash2();\n\tr.x=r.x*2.*pi;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  hash2();\n\tr.x=r.x*2.*pi;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 sky(vec3 sunDir, vec3 viewDir) {\n    float side = smoothstep(.9,.98,dot(viewDir,normalize(vec3(1,.1,.5))));\n    float key = smoothstep(.99,1.,dot(viewDir,sunDir));\n    return vec3(side*.2 + key*5.) * 2.5;\n}    \n\nbool trace5(vec3 cam, vec3 dir, out vec3 h, out vec3 n, out float k) {\n\tfloat t=0.;\n    for(int i=0;i<100;++i)\n    {\n        k = scene(cam+dir*t);\n        t += k;\n        if (abs(k) < .001)\n            break;\n    }\n\n    h = cam+dir*t;\n\t\n    // if we hit something\n    if(abs(k)<.001)\n    {\n        vec2 o = vec2(.001, 0);\n        k=scene(h);\n        n = normalize(vec3(\n            scene(h+o.xyy) - k,\n            scene(h+o.yxy) - k,\n            scene(h+o.yyx) - k \n        ));\n        return true;\n    }\n    return false;\n}\n\nvec3 trace2(vec3 cam, vec3 dir)\n{\n    vec3 sunDirection = normalize(vec3(-.3,.7,1.));\n    const float sunSize = 1e-3;\n    float sunColor = 2. * 2.5;\n    \n    vec3 accum = vec3(1.);\n    vec3 direct = vec3(0.);\n    for(int ibounce=0;ibounce<10;++ibounce)\n    {\n        vec3 h,n;\n        float k;\n        if (trace5(cam,dir,h,n,k))\n        {\n\t\t\tcam = h+n*.002;\n            \n            if (mat == matNormal)\n            {\n                return n*.5+.5;\n            }\n            else if (mat == matMetal)\n            {\n                dir = reflect(dir,n);\n            }\n            else\n            {\n                if (mat == matBall)\n                    accum *= .7;\n                if (mat == matGround)\n                    accum *= .1;\n            \n                dir=getSampleBiased(n,1.);\n\n                // haaaaaacks\n                if (mat == matLeather) {\n                    float fresnel = pow(1.-min(.99,dot(dir,n)),5.);\n                    accum *= fresnel;\n                }\n\n                vec3 sunSampleDir = getConeSample(sunDirection,sunSize);\n                float sunLight = dot(n, sunSampleDir);\n                vec3 dummy0,dummy1;\n                float dummy2;\n                if (sunLight>0.0 && !trace5(h + n*.002,sunSampleDir,dummy0,dummy1,dummy2)) {\n                    direct += accum*sunLight*sunColor;\n                }\n            }\n        }\n        else if (abs(k) > .1) {\n            return direct + sky(sunDirection, dir) * accum;\n        } else {\n            break;\n        }\n    }\n    \n    // not sure about this\n    return direct + sky(sunDirection, dir) * accum;\n    \n    // deliberately fail the pixel\n    return vec3(1,0,1);\n}\n\nvec2 bokeh(){\n    // hexagon\n    vec2 a = hash2();\n    a.x=a.x*3.-1.;\n    a-=step(1.,a.x+a.y);\n\ta.x += a.y * .5;\n\ta.y *= sqrt(.75);\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // readback previous pixel color\n    fragColor = texelFetch(iChannel0,ivec2(gl_FragCoord.xy),0);\n    \n    // clear on click\n    if (iMouse.z > 0.)\n        fragColor = vec4(0);\n\n\t// seed the RNG (again taken from Devour)\n    seed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\n    // get UVs\n    vec2 uv = (gl_FragCoord.xy+hash2()-.5)/iResolution.xy-.5;\n    \n    // correct UVs for aspect ratio\n    float aspect = iResolution.x/iResolution.y;\n    uv.x*=aspect;\n\tuv *= max(1.,(20./9.)/aspect);\n\t\n    // camera params\n    const vec3 camPos = vec3(0,0,-80);\n    const vec3 lookAt = vec3(0,1,0);\n    const float focusDistance=distance(camPos,lookAt);\n    const vec2 apertureRadius=vec2(1,1)*.3;\n   \n    // make a camera\n    vec3 cam = vec3(0);\n    vec3 dir = normalize(vec3(uv,2.5));\n    \n    // slight bokeh (imperceptible in practice)\n    vec2 bokehJitter=bokeh();\n    cam.xy+=bokehJitter*apertureRadius;\n    dir.xy-=bokehJitter*apertureRadius*dir.z/focusDistance;\n\n    // rotate/move the camera\n    vec3 lookDir = lookAt-camPos;\n    float pitch = -atan(lookDir.y,length(lookDir.xz));\n    float yaw = -atan(lookDir.x,lookDir.z);\n    cam.yz *= rotate(pitch);\n    dir.yz *= rotate(pitch);\n    cam.xz *= rotate(yaw);\n    dir.xz *= rotate(yaw);\n    cam += camPos;\n    \n    // compute the pixel color\n\tvec3 pixel = trace2(cam,dir);\n        \n    fragColor += (!isnan(pixel.r) && pixel.r >= 0.) ? vec4(vec3(pixel),1) : vec4(0);\n}", "buffer_a_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n~ Submit\n  by yx\n\n~ 4kb executable graphics\n  released at Revision 2021\n\n~ content warning:\n  suggestive bdsm themes\n\n~ tools:\n  crinkler by loonies & tbc\n  shader minifier by llb\n  blossom by yx\n\n~ note:\n  the party exe runs at 1080p,\n  with a 30-second rendering limit\n  designed for Revision rules.\n  --\n  the other exe will match your\n  display's resolution, and takes\n  as long as it needs to reach\n  1024 samples.\n\n~ greetings:\n  alia\n  alkama\n  bitnenfer\n  blackle\n  cpdt\n  evvvvil\n  fizzer\n  flopine\n  iq\n  noby\n  nusan\n  slerpy\n  tdhooper\n  wrighter\n*/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBGzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 26, 26, 106]], "test": "untested"}
{"id": "fsS3Ry", "name": "Clown Fries", "author": "sp4ghet", "description": "Meme Fork of https://www.shadertoy.com/view/Ndj3Wm because FMS_Cat asked for it.\n\nVisuals Direction by FRONTL1NE discord voice chat", "tags": ["revision", "jam", "2021"], "likes": 6, "viewed": 396, "published": 3, "date": "1617549985", "time_retrieved": "2024-07-30T19:28:38.733923", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\n    vec3 c = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(c,1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.14159265\n#define TAU 2.*PI\n#define time iTime\n#define saturate(x) clamp(x, 0., 1.)\n\nmat3 getOrtho(vec3 z, vec3 up){\n  z = normalize(z);\n  vec3 cu = normalize(cross(z,up));\n  vec3 cv = cross(cu,z);\n  return mat3(cu,cv,z);\n}\n\nconst vec3 up = vec3(0,1,0);\nfloat noise(vec3 p, float t){\n  float ns=0., amp=1., trk=1.5 + t;\n  const vec3 seed = vec3(-4,-2,.5);\n  mat3 rot = getOrtho(seed, up);\n  for(int i=0; i<4; i++){\n    p += sin(p.zxy + trk)*1.6;\n    ns += sin(dot(cos(p), sin(p.zxy)))*amp;\n    p *= rot;\n    p *= 2.3;\n    trk *= 1.5;\n    amp *= .5;\n  }\n  return ns*.5;\n}\n\nfloat fs(vec2 p){\n  return fract(sin(dot(p, vec2(12.41245, 78.233))) * 421251.543123);\n}\n\nfloat random(float x){\n  return fs(vec2(x));\n}\n\nvec2 seed;\nfloat rnd(){\n  return fs(seed);\n}\n\nvec3 rndSphere(){\n  float t = PI*rnd();\n  float p = TAU*rnd();\n  return vec3(cos(t)*cos(p), sin(t), cos(t)*sin(p));\n}\n\nvec3 rndHemi(vec3 n){\n  vec3 v = rndSphere();\n  return dot(n,v) > 0. ? v : -v;\n}\n\nvoid chmin(inout vec4 a, vec4 b){\n  a = a.x < b.x ? a : b;\n}\n\nfloat box(vec3 p, vec3 b){\n  p = abs(p) - b;\n  return min(0., max(p.x, max(p.y, p.z))) + length(max(p,0.));\n}\n\nmat2 r2d(float t){\n  float c=cos(t), s=sin(t);\n  return mat2(c,s,-s,c);\n}\n\n\nfloat lng, shrt;\n\nvec4 map(vec3 q){\n  vec3 p = q;\n  vec4 d = vec4(100000, 0,0,0);\n\n\n  float bx = box(p, vec3(5, 3.25, 7));\n  float bx2 = box(p, vec3(4, 3, 6));\n  bx = max(bx, -bx2);\n  bx2 = box(p - vec3(0,5,-1), vec3(1,2,1)) - .5;\n  bx = max(bx, -bx2);\n  bx -= .05*noise(p, shrt);\n  float line = smoothstep(0.45, .5, fract(p.x+time)) - smoothstep(0.5, 0.55, fract(p.x+time));\n  line += smoothstep(0.45, .5, fract(p.y+sin(p.x+p.z))) - smoothstep(0.5, 0.55, fract(p.y+sin(p.x+p.z)));\n  line += smoothstep(0.45, .5, fract(p.z)) - smoothstep(0.5, 0.55, fract(p.z));\n  chmin(d, vec4(bx, 0,line,0));\n\n  p=q - vec3(-1., 0., -2.);\n  p.y -= shrt*2. - 1.;\n  p.xy *= r2d(PI*.2);\n  for(int i=0; i<10; i++){\n    p.zy *= r2d(-PI*.35*(.3 + shrt));\n    p.xy *= r2d(-PI*.4*(1.3 - shrt*shrt));\n    p.y -= .15;\n    p = abs(p);\n  }\n\n  bx = box(p, vec3(.01, .2, .01));\n  chmin(d, vec4(bx, 1,0,0));\n\n  return d;\n}\n\nvec3 normal(vec3 p){\n  vec2 e = vec2(0, 0.07678);\n  return normalize(vec3(\n    map(p + e.yxx).x - map(p - e.yxx).x,\n    map(p + e.xyx).x - map(p - e.xyx).x,\n    map(p + e.xxy).x - map(p - e.xxy).x\n  ));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tvec2 pt = uv - 0.5;\n\tpt /= vec2(iResolution.y / iResolution.x, 1);\n\n  seed = vec2(noise(vec3(pt*37., time), 15.3), noise(vec3(pt*25., time), 1.2));\n\n  float bps = 120./60.;\n\n  float tm = time*bps*.5;\n  float pre = random(floor(tm) - 1.);\n  float now = random(floor(tm));\n  lng = fract(tm);\n  lng = 0.5 + 0.5*cos(PI*exp(-8.*lng));\n  lng = mix(pre, now, lng);\n\n  tm = time*bps*2.;\n  pre = random(floor(tm) - 1.);\n  now = random(floor(tm));\n  shrt = fract(tm);\n  shrt = 0.5 + 0.5*cos(PI*exp(-3.*shrt));\n  shrt = mix(pre, now, shrt);\n\n  vec3 c = vec3(0.);\n\n  float longAngle = .4 * TAU * (lng - .5) + PI*.5;\n  vec3 ro = vec3(0.,0.,3.);\n\n  vec3 fo = vec3(-1., 2.*shrt - 1.,-2.);\n\n  vec3 rov = normalize(fo - ro);\n  vec2 pt2 = pt*r2d((lng - .5)*PI*.3);\n  vec3 rd = getOrtho(rov, up) * normalize(vec3(pt2, 1.));\n\n  float t=0.;\n  vec3 p=ro;\n  vec4 d;\n  for(int i=0; i<64; i++){\n    p = ro + rd*t;\n    d = map(p);\n    if(abs(d.x) < 0.01){\n      break;\n    }\n    t += d.x;\n  }\n\n  vec3 l = normalize(vec3(1,4,1));\n  if(abs(d.x) < 0.01){\n    vec3 n = normal(p);\n    c += max(0., dot(n,l));\n    float fre = pow(1. - abs(dot(n,rd)) , 5.);\n    c += fre;\n\n    float ao=0.,ss=0.;\n    vec3 h = normalize(l-rd);\n    for(int i=1;i<=10;i++){\n      float aot = 0.1*float(i) + .05*rnd();\n      float sst = 0.3*float(i) + .5*rnd();\n      vec3 nd = mix(n,rndHemi(n),.2);\n      ao += map(p+nd*aot).x/aot;\n      ss += map(p+h*sst).x/sst;\n    }\n    c += ss*.1;\n    c *= ao*.1;\n\n    if(d.y == 1.){\n      c *= 10.*vec3(1, 1, .1);\n    }else{\n      c *= 2.*vec3(1, .1, .1);\n      c += 3.*d.z*vec3(1, 0, 1);\n    }\n\n    vec3 hitp = p;\n    float sh=1., tt=.1;\n    for(int i=0; i<24; i++){\n      hitp = p + l*tt;\n      float d = map(hitp).x;\n      tt += d + .2*rnd();\n      if(d < 0.001){\n        sh = 0.;\n        break;\n      }\n      if(tt > 30.){\n        break;\n      }\n      sh = min(sh, 8.*d/tt);\n    }\n\n    c *= saturate(.2+sh);\n  }\n\n\n  float od=0.;\n  vec3 acc=vec3(0.), fogC = vec3(1, 1, 1);\n  int n=16;\n  float st=min(2., t/float(n)), tt=0.;\n  for(int i=0; i<n; i++){\n    p = ro + rd*tt;\n    tt += st*(.95+.1*rnd());\n    od += .2*(1. + abs(noise(p*3., -time))) * st;\n\n    vec3 pp=p; float t=0.1;\n    float sh=2.;\n    for(int j=0; j<24; j++){\n      pp = p + l*t;\n      float d = map(pp).x;\n      t += d;\n      if(d < 0.01){\n        sh=0.;\n        break;\n      }\n    }\n    acc += exp(-od*fogC)*sh*st;\n  }\n  c *= exp(-.3*od);\n  c += acc;\n\n  c = c/(1. + c);\n\n  c = pow(c, vec3(.4545));\n  c = smoothstep(.05, 1.4, c);\n  float lum = dot(c, vec3(.2126, .7152, .0722));\n  float shad = smoothstep(.4, .01, lum);\n  float high = smoothstep(.3, 1., lum);\n  c = c*shad*vec3(2) + c*(1.-shad*high) + c*high*vec3(.9, .8,.8);\n\n  c *= 1. - length(pt);\n  \n  \n  pt *= 0.9;\n  uv = pt * vec2(iResolution.y / iResolution.x, 1) + 0.5;\n  vec3 prev = texture(iChannel0, uv).rgb;\n  c = mix(c, prev, 0.7);\n\n  fragColor = vec4(c,1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsS3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 203]], "test": "untested"}
{"id": "fsBGRy", "name": "Complete Graph in Colour II", "author": "mla", "description": "Another version of [url]https://www.shadertoy.com/view/tstfzs[/url], with colour.\n\nSee [url]https://twitter.com/MatthewArcus/status/1378683514795790340[/url]\n\nBest viewed full screen. Mouse zooms in.", "tags": ["graph", "complete"], "likes": 8, "viewed": 400, "published": 3, "date": "1617548043", "time_retrieved": "2024-07-30T19:28:39.656456", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Triangular numbers & complete graphs\n// Matthew Arcus, mla, 2021\n//\n// Colour a complete graph with n nodes with n-1 colours, with i edges being\n// coloured by the ith colour.\n//\n// https://twitter.com/MatthewArcus/status/1378683514795790340\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 diagram(vec2 p) {\n  float N = 5.0+floor(0.5*iTime)+max(0.0,2.0*fract(0.5*iTime)-1.0);\n  p = rotate(p,0.01); // Rotate slightly to reduce artefacts\n  float lwidth = 1.2*fwidth(p.x);\n  vec3 col = vec3(0); //1.0-vec3(1,1,0.8);\n  if (dot(p,p) > 1.0+lwidth) return col;\n  float d2min = 1e8, rmin;\n  float offset = 0.5*(N-1.0);\n  for (float i = 0.0, j = 1.0; j < N; ) {\n    float ii = 2.0*PI/N*(i-offset);\n    float ij = 2.0*PI/N*(j-offset);\n    vec2 q = vec2(sin(ii),cos(ii));\n    vec2 r = vec2(sin(ij),cos(ij));\n    float d2 = segment2(p,q,r);\n    if (d2 < d2min) {\n      d2min = d2;\n      rmin = (abs(i-j)-1.0)/(N-1.0);\n    }\n    vec2 n = r-q;\n    if (dot(p-q,vec2(-n.y,n.x)) > 0.0) i++;\n    else j++;\n  }\n  col = mix(hsv2rgb(rmin,1.0,1.0),col,smoothstep(0.0,lwidth,sqrt(d2min)));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  if (false && iMouse.z > 0.0) {\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p -= mouse; // Centre on mouse\n    p *= 0.55*iResolution.y/iResolution.x; // And zoom\n  }\n  vec3 col = diagram(p);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}", "image_inputs": [], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.14159265;\n\n// Distance squared of p from line segment qr.\nfloat segment2(vec2 p, vec2 q, vec2 r) {\n  p -= q; r -= q;\n  float h = dot(p,r)/dot(r,r);\n  h = clamp(h,0.0,1.0);\n  p -= h*r;\n  return dot(p,p);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBGRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[414, 414, 436, 436, 1212], [1214, 1214, 1267, 1267, 1586]], "test": "untested"}
{"id": "fdSGRy", "name": "You Are Here", "author": "tdhooper", "description": "Slightly polished version of my Revision 2021 4k Executable Graphics entry ", "tags": ["revision2021"], "likes": 117, "viewed": 3342, "published": 3, "date": "1617546944", "time_retrieved": "2024-07-30T19:28:40.704653", "image_code": "/*\n\n    You Are Here\n    ------------\n\n    I created this sofa for the room in my Revision 2021 Animated Gif\n    entry, and went a little over the top with detailing so felt it\n    deserved its own 4k Graphics entry!\n    \n    This is modified a little but from the compo version, I've added\n    feet, and made the wood shinier.\n    \n    Massive thanks to yx for sharing her framework, Blossom, without\n    which I probably wouldn't have got this into the competition:\n    \n    https://github.com/lunasorcery/Blossom\n    \n    The edge wrinkles are created by modulating the radius of corners\n    and smooth unions, which is a technique Blackle demonstrated for\n    the welds in 'Bending an SDF':\n    \n    https://www.shadertoy.com/view/3llfRl\n    \n    Surface wrinkles use the same modulation, but as a height map; and\n    the cloth texture is created by warping the whole model with a high\n    frequency sine.\n    \n    Wood grain is concentric circles warped with more sines, which also\n    alters the specular response, as shown by LucaRood:\n    \n    https://twitter.com/LucaRood/status/1375369105327464448\n \n    Clouds are stylised as I knew I couldn't make some that looked\n    as realistic as the models. They are formed by swirling space in\n    a hexagon arrangement, at different scales, over the top of a simple\n    light-to-dark blob.\n \n*/\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// colour grading from tropical trevor's scripts\n// https://github.com/trevorvanhoof/ColorGrading\nfloat Luma(vec3 color) { return dot(color, vec3(0.2126, 0.7152, 0.0722)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 tex = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n\tvec3 col = tex.rgb / tex.a;\n\n    vec3 uGain = vec3(1.8);\n    vec3 uLift = vec3(.002,-.003,.007)/3.;\n    vec3 uOffset = vec3(.00,.00,.00);\n    vec3 uGamma = vec3(-.25);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n    col = pow( col, vec3(1./2.2) );\n    col = aces(col);\n\n    fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n//========================================================\n// Tools\n//========================================================\n\n#define PI 3.1415926\n\n// HG_SDF\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat vmax2(vec2 v) {\n\treturn max(v.x, v.y);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat vmin2(vec2 v) {\n\treturn min(v.x, v.y);\n}\nfloat sum(vec3 v) {\n    return v.x + v.y + v.z;\n}\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax2(min(d, vec2(0)));\n}\nfloat fHalfCapsule(vec2 p, float r) {\n    p.y = max(p.y, 0.);\n    return length(p) - r;\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\n// Rotate on axis, blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n\nfloat unlerp(float vmin, float vmax, float value) {\n    return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nfloat smoothbump(float a, float b, float x) {\n    float c = mix(a, b, .5);\n    return smoothstep(a, c, x) - smoothstep(c, b, x);\n}\n\n\n\n//========================================================\n// Noise\n//========================================================\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p += 1.61803398875; // fix artifacts when reseeding\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// https://suricrasia.online/demoscene/functions/\nvec3 rndunit(float seed) {\n  return normalize(tan(hash31(seed)));\n}\n\n\n\n\n//========================================================\n// Background\n//========================================================\n\nconst float sqrt3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 cart2hex = mat2(1, 0, i3, 2. * i3);\nconst mat2 hex2cart = mat2(1, 0, -.5, .5 * sqrt3);\n\nvoid swirl(inout vec2 p, float scale, float radius, float power, vec2 seed) {\n\n    p += seed;\n    \n    p *= scale;\n\n    mat2 sc = mat2(1,0,0,.785);\n    mat2 sci = inverse(sc);\n    \n    vec2 h = p * sc * cart2hex;\n    vec2 hf = floor(h);\n    float d = 1e12;\n    float c = 0.;\n    float dc;\n    \n    for (int j = -2; j <= 2; j++)\n    for (int i = -2; i <= 2; i++) {\n        vec2 cellId = hf + vec2(i,j);\n        float rnd = hash12(cellId);\n        vec2 hp = cellId * hex2cart * sci;\n    \tdc = length(p - hp);\n        if (dc < d) {\n        \td = dc;\n            c = mix(.1, 1., rnd);            \n        }\n\n        p -= hp;\n        pR(p, smoothstep(radius, 0., length(p)) * power * (rnd * 2. - 1.));\n        p += hp;\n    }\n    \n    p /= scale;\n\n    p -= seed;\n}\n\nvec4 cloudDist(vec2 p, vec2 s, float r, float blur)\n{\n    p /= s;\n    blur = mix(0., blur, smoothstep(r*2., -r*2., p.y));\n    float d = (length(p) - r + blur / 2.) / blur;\n    d = smoothstep(1., 0., d);\n    r += blur / 2.;\n    p /= r;\n    vec3 n = vec3(p, max(0., sqrt(1. - dot(p, p))));\n    return vec4(n, d);\n}\n\n\nvec4 cloud(vec2 p, vec2 s, float r, float blur) {\n    vec4 res = cloudDist(p, s, r, blur);\n    vec3 ld = normalize(vec3(.5,1,.5));\n    float l = dot(res.xyz, ld);\n    l = l * .5 + .5;\n    l = clamp(l, 0., 1.);\n    vec3 col = vec3(l);\n    float a = res.w;\n    return vec4(col, a);\n\n}\n\nvec2 warp(vec2 p, vec2 seed) {\n    p += seed;\n    swirl(p, 4., .3, 8., vec2(0));\n    swirl(p, 2., .3, 6., vec2(.9));\n    swirl(p, 2., .5, 6., vec2(.5));\n    swirl(p, .76, .75, 4., vec2(1. / 4.));\n    swirl(p, 1.72, .75, 3., vec2(1. * .1));\n    //swirl(p, 4., .75, 6., vec2(.5 + 1. / 6.));\n    swirl(p, 6., 1., 5., vec2(.5 + 1. / 6.));\n    p -= seed;\n    return p;\n}\n\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash22( n + g );\n\t    vec2  r = g - f + o;\n        float size = hash12( n + g );\n\t\tfloat d = length(r) - mix(-.05, .05, size);\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( m.x, m.y+m.z );\n}\n\nvoid scatterclouds(vec2 p, inout vec4 col) {\n    float smallestDist = 1e12;\n    vec2 closestPoint = vec2(0);\n    vec2 cellId;\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 cell = round(p) + vec2(x,y);\n            vec2 offset = hash22(cell) * 2. - 1.;\n            vec2 point = cell + offset * .5;\n            float r = hash12(cell);\n            vec4 cl = cloud(p - point, vec2(.2), mix(.5, 2., r), 5.);\n            col.rgb = mix(col.rgb, cl.rgb, cl.w);\n            col.a = max(col.a, cl.a);\n\t\t}\n    }\n}\n\nvec3 skyTex(vec2 p)\n{   \n    p = warp(p, vec2(0));\n    \n    vec2 p2 = p;\n    vec2 p3 = p;\n    \n    swirl(p2, .2, .75, 3., vec2(0.));\n    swirl(p3, .2, .75, 3., vec2(10.));\n    \n    vec4 col = vec4(.5,.5,.5,0);\n\n    vec2 sc = vec2(18.,6.);\n    scatterclouds(p2 / sc, col);\n    scatterclouds(p3 / sc, col);\n\n    return col.rgb;\n}\n\n\n\n\n\n//========================================================\n// Modelling\n//========================================================\n\nstruct Material {\n    vec3 albedo;\n    float specular;\n    float roughness;\n};\n\nstruct Model {\n    float d;\n    vec3 uvw;\n    vec3 albedo;\n    int id;\n};\n\nMaterial shadeModel(Model model, inout vec3 nor) {\n    int id = model.id;\n    vec3 p = model.uvw;\n\n    // floorboards\n    if (id == 2) {\n        vec3 col = mix(model.albedo * vec3(.5,.3,.2), model.albedo + .1, .9);\n        vec2 size = vec2(.1,.02);        \n        vec2 c = floor((p.zx + size / 2.) / size);\n        p.z += mod(c.y, 2.) * size.x * .5;\n        c = floor((p.zx + size / 2.) / size);\n        p.zx = (fract(p.zx / size + .5) - .5);\n        p.zx *= size;\n        c *= size;\n        float d = fBox2(p.zx, size / 2.);\n        float r = hash12((c+120.) * 80.);\n        float r2 = hash12((c+1.) * 60.);\n        col = mix(col / 2., col * vec3(1.05,.95,1.05), r2);\n        col *= mix(.1, 1., smoothstep(.0, -.0006, d));\n        col *= mix(.5, 1., r);\n        vec3 ax = rndunit(r * 5.);\n        //nor = erot(nor, ax, (r * 2. - 1.) * .01);\n        p /= 2.;\n        p += length(sin(sin(p * 100. + r * 10.) * 10.)) * .0005;\n        p.xz += size * (hash22(c * 20.) * 2. - 1.);\n        p.z /= 10.;\n        p = erot(p, ax, (r * 2. - 1.) * 2.2);\n        p += sin((p + r * 100.) * 200.) * .04;\n        d = length(p);\n        d = sin(d * 1500.) * .5 + .5;\n        col *= mix(.5, 1., d);\n        return Material(col, .8, mix(.4, .2, d));\n    }\n\n    return Material(model.albedo, 0., 0.);\n}\n\nvec3 sofasz = vec3(.2, .1, .1) / 2.;\n    \nModel fSofa(vec3 p) {\n    \n    p += sum(sin(erot(p, vec3(1), 1.) * 6000.)) * .000015;\n    \n    float fade, d2, d3, d4, ar, armang, ar0, ar1, arw, footh, psx, vary, baseh, cs, cr, axisx, axisz, crw, seam, buttpatch, br;\n    vec2 armtopp;\n    vec3 isofasz, pp, armsz, pc, col, backsz, cushionsz;\n\n    armsz = vec3(.012,.026,sofasz.z);\n    footh = .0075;\n    isofasz = sofasz - vec3(armsz.x * 2., 0, 0);\n\n    psx = sign(p.x);\n    vary = max(psx, 0.);\n    pp = p;\n\n    // arms\n    p.x = abs(p.x);\n    p.x -= sofasz.x - armsz.x;\n    p.y -= footh - sofasz.y + armsz.y;\n    d2 = fHalfCapsule(p.xy - vec2(0, armsz.y), armsz.x);\n    armtopp = p.xy - vec2(.004, armsz.y + .005);\n    d2 = smin(d2, length(armtopp) - armsz.x - .002, .01);\n    d3 = d2 + armsz.x * .4;\n    ar = .007;\n    armang = atan(armtopp.y, armtopp.x);\n    ar0 = sin(sin(sin(armang) * 10. - vary*2.) * 5. + length(armtopp) * 500. + p.z * 100.);\n    ar1 = sin(sin(sin((p.y + 1.) * 65.) * 10.) * 5. + p.x * 300. + p.z * 100.);\n    arw = mix(ar0, ar1, smoothstep(.01, -.01, p.y - armsz.y / 3.));\n    arw *= smoothstep(0., armsz.z, abs(p.z));\n    fade = mix(.33, 0., arw) * smoothstep(.01, .0, length(vec2(d2, 2. * abs(abs(p.z) - armsz.z + .0035)))) * smoothstep(-.03, .06, p.y);// mix(1., 0., arw) // * mix(.5, 1., smoothstep(.005, 0., abs(abs(p.z) - armsz.z + .005)));\n    d2 = smax(d2 + arw * .0001, abs(p.z) - armsz.z, ar + arw * .0005);\n    d3 = max(d3, -p.z);\n    if (d3 > 0.) {\n        fade = max(fade, smoothbump(.5, 3., mod(armang - .5, PI * 2.)) * smoothbump(-armsz.z / 2., armsz.z * 1.5, p.z)) *  mix(1., .5, arw);\n    }\n    ar = .00725;\n    d4 = smax(d3, abs(p.z) - armsz.z - .003, ar);\n    d2 = smax(d2, -d4, .001);\n    ar += sin(sin(sin((p.y + 1.) * 80.) * 10.) * 5. + p.x * 300.) * .0003;\n    d4 = smax(d3, abs(p.z) - armsz.z - .003, ar);\n    d2 = min(d2, d4);\n    d2 = smax(d2, -p.y - armsz.y, .003);\n\t\n\n    // base\n    p = pp;\n    baseh = .012;\n    p.y -= footh - sofasz.y + baseh;\n    br = .002;\n    br += sin(sin(sin(p.x * 55. + 2.) * 10.) * 5. + p.y * 100.) * .00025;\n\t\n    d3 = fBox(p, vec3(isofasz.x + .0068, baseh, isofasz.z) - br) - br;\n\n    d2 = min(d2, d3);\n    p.x = abs(p.x);\n    p.xy -= vec2(sofasz.x / 2.5, 0.);\n    p.y += sin(p.x * 250.) * .0005;\n    p.xy *= vec2(.4, 1);\n    fade = max(fade, pow(smoothstep(.025, .0, length(p.xy)), 3.)/2.);\n\n\t/*\n    // back\n    p = pp;\n    backsz = vec3(isofasz.x + .001, armsz.y + .005, .005);\n    p.y -= footh - sofasz.y + baseh + backsz.y;\n    p.z -= -sofasz.z + backsz.z;\n    d3 = fBox(p.zyx, backsz.zyx - .006) - .006;\n    d2 = min(d2, d3);\n\t*/\n    // cushion\n    p = pp;\n    p.x = abs(p.x);\n    cushionsz = vec3(isofasz.x / 2. + .001, .01, sofasz.z - .018);\n    p.y -= footh - sofasz.y + baseh * 2. - .001;\n    p.y -= cushionsz.y * 2.;\n    p.x -= isofasz.x / 2.;\n    p.z -= sofasz.z - cushionsz.z * 2. + .005;\n    vary += pReflect(p, normalize(vec3(0,-.66,1)), 0.);\n    p.y += cushionsz.y;\n    p.z -= cushionsz.z - .004;\n\n    cs = mix(.95, 1.01, length(sin(sin((p + vary * 240.) * 30.) * 3.) * .5 + .5));\n    cs = 1. + sum(sin((p + vary * 2. + 1.) * 100.) * vec3(1,0,1)) * .02;\n    cr = .008;\n    axisx = max(vmin2(p.xz), vmin2(-p.xz));\n    axisz = min(vmin2(p.xz), vmin2(-p.xz));\n\t\t\n    crw = sin(sin(sin((axisx + mix(.4, .6, vary)) * (48. + vary)) * 10.) * 5. + p.y * 300. + p.z * 300.);\n    crw *= smoothstep(0., .0005, abs(dot(abs(p.xz), cushionsz.zx * vec2(1,-1))));\n    crw *= unlerp(.5, 1., vmax2(abs(p.xz) / cushionsz.xz));\n    cr += crw * .0003;\n\n    cs += smoothstep(cushionsz.x * 1.2, 0., length(p.xz)) * .4;\n    pc = p;\n    pc.x += sin(pc.z * 150. + vary * 3.) * .02;\n    pR(pc.xz, -vary * .2 + 1.6);\n    buttpatch = sum(sin((sin(2. + vec3(pc.x, pc.y, 0) * 122. * (1. + abs(vary - 1.) * .2)) + vary * 30.) * 8.));\n    \n    buttpatch *= smoothstep(cushionsz.z, 0., length(p.xz));\n    cs += buttpatch * .03;\n\n    d3 = (fBox(p / cs, cushionsz - cr - crw * .0001) - cr) * cs* .9;\n    seam = abs(p.y) - cushionsz.y * .75;\n    d3 = smax(d3, -abs(seam), .001);\n\n    if (d3 < d2) {\n        d2 = d3;\n        fade = 0.;\n        fade += smoothbump(.0, .0015, seam) * mix(.5, .25, crw);\n        fade += smoothbump(.0, .00075, -seam) * mix(.5, .25, crw);\n        fade = max(fade, smoothstep(cushionsz.x * 1.1, 0., length(p.xz)));\n        if (psx < 0.) {\n            fade /= 3.;\n        } else {\n            fade *= 1.2;\n            fade += .1;\n        }\n    }\n    \n\n    col = pow(vec3(0.55,0.29,0.23), vec3(2.2));\n    col = mix(col, vec3(1.,.1,.0) * .05 * 6., .6);\n    col.r -= .05;\n    col.g += .006;\n    col.b += .006;\n    col = mix(col, mix(col * 1.75, vec3(.2), .04), fade);\n\n    return Model(d2, p, col, 15);\n}\n\n\nModel map(vec3 p) {\n    p.x = -p.x;\n\n    Model m = fSofa(p);\n    \n    p.y += sofasz.y;\n    float d = fBox(p, vec3(.14,.003,.14));\n        \n    Model m2 = Model(d, p, vec3(0.714,0.43,0.19), 2);\n    if (m2.d < m.d) m = m2;    \n    \n    p.y -= .0015;\n    p.xz = abs(p.xz);\n    p.xz -= sofasz.xz * vec2(.93,.68);\n    d = min(d, max(fBox(p, vec3(0,.01,0)) - .005, -p.y));  \n    m2 = Model(d, p, vec3(.01), 3);\n    if (m2.d < m.d) m = m2;    \n    \n    return m;\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).d;\n    }\n    return normalize(n);\n}\n\nvec3 sunPos = normalize(vec3(-5,4,.5)) * 100.;\nvec3 skyColor = vec3(0.50,0.70,1.00);\n\nvec3 env(vec3 dir) {\n    vec3 col = mix(vec3(.5,.7,1) * .05, vec3(.5,.7,1) * 1., smoothstep(-.4, .4, dir.y));\n    vec2 pc = vec2(atan(dir.z, dir.x), dir.y) * 30. - 28.96 * 10.;\n    vec3 cl = skyTex(pc);\n    col *= cl;\n    col += pow(cl, vec3(15.)) * 2.;\n    return col;\n}\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n};\n\nHit march(vec3 origin, vec3 rayDirection, float maxDist, float understep) {\n\n    vec3 rayPosition;\n    float rayLength, dist = 0.;\n    Model model;\n\n    for (int i = 0; i < 200; i++) {\n        rayPosition = origin + rayDirection * rayLength;\n        model = map(rayPosition);\n        rayLength += model.d * understep;\n\n        if (abs(model.d) / rayLength < .0002) break;\n\n        if (rayLength > maxDist) {\n            model.id = 0;\n            break;\n        }\n    }\n    return Hit(model, rayPosition);\n}\n\n// tracing/lighting setup from yx\n// https://www.shadertoy.com/view/ts2cWm\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// re-borrowed from yx from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = seed;\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  seed;\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\n// main path tracing loop, based on yx's\n// https://www.shadertoy.com/view/ts2cWm\n// with a bit of demofox's\n// https://www.shadertoy.com/view/WsBBR3\nvec4 draw(vec2 fragCoord) {\n\n    vec2 p = (-iResolution.xy + 2.* fragCoord) / iResolution.y;\n    //p /= 2.;\n\n    vec2 seed = hash22(fragCoord + (float(iFrame)) * sqrt3);\n    \n    // jitter for antialiasing\n    p += 2. * (seed - .5) / iResolution.xy;\n\n    vec3 col = vec3(0);\n\n    float focalLength = 6.;\n    vec3 camPos = vec3(.04, .01, .1) * focalLength * 1.2;\n    if (iMouse.x > 0.) {\n        vec2 im = (iMouse.xy / iResolution.xy) - .5;\n        pR(camPos.yz, -im.y * 1.5);\n        pR(camPos.xz, -im.x * PI * 1.5);\n    }\n\n    vec3 camTar = vec3(0);\n    \n    vec3 ww = normalize(camTar - camPos);\n    vec3 uu = normalize(cross(vec3(0,1,0),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    mat3 camMat = mat3(-uu, vv, ww);\n    \n    vec3 rayDir = normalize(camMat * vec3(p.xy, focalLength));\n    vec3 origin = camPos;\n\n    Hit hit = march(origin, rayDir, 1., .9);\n\n    vec3 nor, ref;\n    Material material;\n    vec3 accum = vec3(1);\n    vec3 bgCol = skyColor;\n\n    const int MAX_BOUNCE = 6;\n\n    for (int bounce = 0; bounce < MAX_BOUNCE; bounce++) {\n   \n        if (hit.model.id == 0) {\n            col += env(rayDir) * accum;\n            break;\n        }\n\n        nor = calcNormal(hit.pos);\n        material = shadeModel(hit.model, nor);\n\n        // calculate whether we are going to do a diffuse or specular reflection ray \n        bool doSpecular = hash12(seed) < material.specular;\n\n        // update the colorMultiplier\n       \taccum *= material.albedo;\n\n        // Calculate diffuse ray direction\n        seed = hash22(seed);\n        vec3 diffuseRayDir = getSampleBiased(nor, 1., seed);\n\n        if ( ! doSpecular) {\n            \n            // calculate direct lighting\n            vec3 directLight = vec3(0);\n            seed = hash22(seed);\n\n            vec3 lightDir = (sunPos - hit.pos);\n            vec3 lightSampleDir = getConeSample(lightDir, .005, seed);\n            float diffuse = dot(nor, lightSampleDir);\n            vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightSampleDir, nor)));\n            if (diffuse > 0.) {\n                Hit sh = march(shadowOrigin, lightSampleDir, 1., 1.);\n                if (sh.model.id == 0) {\n                    col += accum * vec3(8.10,6.00,4.20)/10. * diffuse;\n                }\n            }\n\n            rayDir = diffuseRayDir;\n        } else {\n            // Calculate specular ray direction\n            vec3 specularRayDir = reflect(rayDir, nor);\n            rayDir = normalize(mix(specularRayDir, diffuseRayDir, material.roughness * material.roughness));\n        }\n\n        // offset from sufrace https://www.shadertoy.com/view/lsXGzH\n        origin = hit.pos + nor * (.0002 / abs(dot(rayDir, nor)));\n        seed = hash22(seed);\n        hit = march(origin, rayDir, 1., 1.);\n    }\n\n\n    return vec4(col, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 col = draw(fragCoord);\n    \n    if (iFrame > 0 && iMouse.z <= 0.) {\n        vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        col += lastCol;\n    }\n    \n    fragColor = col;\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSGRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1349, 1349, 1368, 1368, 1559], [1561, 1659, 1683, 1683, 1734], [1736, 1736, 1791, 1791, 2217]], "test": "untested"}
{"id": "fdSGzG", "name": "Projective Easter Egg II", "author": "mla", "description": "Two golden eggs in a hyperboloid wrapper, undergoing a projective transformation. This brings the line at infinity into real space, which creates problems for raymarching unless it is hidden. Press 'x' to unhide. 1-4 to show/hide the various quadrics.", "tags": ["egg", "projective", "easter"], "likes": 3, "viewed": 291, "published": 3, "date": "1617545223", "time_retrieved": "2024-07-30T19:28:41.481576", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Projective Easter Egg II\n// Matthew Arcus, mla, 2021.\n//\n// Mouse, <up> and <down> to move around\n// 1-4: show/hide various quadrics\n// 'x': don't hide plane at infinity\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 lightdir = vec3(0,2,1);\n\n// 4 quadrics, adjust de of each so that the eye is on the inside,\nfloat eyesign0 = 1.0; \nfloat eyesign1 = 1.0;\nfloat eyesign2 = 1.0;\nfloat eyesign3 = 1.0;\n\nbool doquadric0 = true;\nbool doquadric1 = true;\nbool doquadric2 = true;\nbool doquadric3 = false;\n\nbool hideinfinity = true;\n\n// Implicit equation for quadric ap.p = r\nfloat quadric(vec3 p, vec3 a, float r) {\n  return dot(a*p,p) - r;\n}\n\nfloat r2 = 0.9;\nfloat scene0(vec3 p) { return quadric(p,vec3(1),r2); }\nfloat scene1(vec3 p) { return quadric(p,vec3(1,1,-1),1.0); }\nfloat scene2(vec3 p) { return quadric(p,vec3(1,-1,-1),1.0/r2); }\nfloat scene3(vec3 p) { return quadric(p,vec3(-1,-1,1),1.0/r2); }\n\nfloat scene(vec3 p, out int type) {\n  //r2 = 0.5+0.5*sin(iTime);\n  float d = 1e8,d1;\n  if (doquadric0) {\n    float d1 = eyesign0*scene0(p);\n    if (d1 < d) { d = d1; type = 2; }\n  }\n  if (doquadric1) {\n    float d1 = eyesign1*scene1(p);\n    if (d1 < d) { d = d1; type = 0; }\n  }\n  if (doquadric2) {\n    float d1 = eyesign2*scene2(p);\n    if (d1 < d) { d = d1; type = 2; }\n  }\n  if (doquadric3) {\n    float d1 = eyesign3*scene3(p);\n    if (d1 < d) { d = d1; type = 2; }\n  }\n  return d;\n}\n\nmat4 A = mat4(0.8,0,0,0,\n              0,1,0,0,\n              0,0,1,0,\n              0,0,0,1);\n\nfloat de(vec3 p3) {\n  vec4 p = vec4(p3,1);\n  p = A*p;\n  p /= p.w;\n  float t = length(p.xyz);\n  // This gets rid of \"line at infinity\", which otherwise shrinks\n  // all distances to 0.\n  if (hideinfinity && t > 100.0) p.xyz *= 100.0/t;\n  int type;\n  return scene(p.xyz,type);\n}\n\nvec3 grad(vec3 p,float d) {\n  // First order seems to be OK for our purposes.\n  float eps = 1.0/256.0;\n  vec2 e = vec2(eps, 0.0);\n  //float d = de(p); // Pass in de(p)\n  return vec3(de(p + e.xyy) - d,\n              de(p + e.yxy) - d,\n              de(p + e.yyx) - d)/eps;\n}\n\nfloat eval(vec3 p) {\n  float d = de(p);\n  vec3 g = grad(p,d);\n  d /= length(g);\n  return d;\n}\n\nfloat maxdist = 10.0;\nfloat fogdist = 4.0;\nfloat march(vec3 q, vec3 r) {\n  float t = 0.1;\n  int numsteps = 500;\n  float precis = 1e-4;\n  for (int i = 0; i < numsteps; i++) {\n    vec3 p = q+t*r;\n    float d = eval(p);\n    if (abs(d) < precis) return t;\n    t += min(0.5,0.8*d);\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\nvec3 getcolor(vec3 p, out float specfact, out float specpow) {\n  int type;\n  specfact = 0.5;\n  specpow = 2.0;\n  vec4 p4 = A*vec4(p,1);\n  p = p4.xyz/p4.w;\n  scene(p,type);\n  if (type == 0) {\n    p = p.yzx;\n    float phi = atan(p.x/length(p.yz)); //[-PI/2..+PI/2]\n    float rho = atan(p.y,p.z);\n    //vec3 color = hsv2rgb(vec3(0.3+0.4*(0.5+phi/PI),1,1));\n    vec3 color = hsv2rgb(vec3(0.5+phi/PI,1,1));\n    color *= 0.5+0.5*cos(32.0*phi+rho);\n    return color;\n  } else if (type == 2) {\n    specfact = 1.0;\n    specpow = 10.0;\n    return 0.8*vec3(1,0.75,0.25);\n  } else {\n    return vec3(0,1,1);\n  }\n}\n\nvoid init() {\n  // Use quaternion rotation?\n  float time = 0.125*PI*iTime;\n  A *= mat4(cos(time),0,0,sin(time),\n            0,1,0,0,\n            0,0,1,0,\n            -sin(time),0,0,cos(time));\n  A *= mat4(1,0,0,0,\n            0,cos(time),sin(time),0,\n            0,-sin(time),cos(time),0,\n            0,0,0,1);\n}\n\nvec3 background = vec3(0,0,0.01);\n\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return background;\n  vec3 p = q+t*r;\n  float d = de(p);\n  vec3 normal = normalize(grad(p,d));\n  float specfact, specpow;\n  vec3 color = getcolor(p,specfact,specpow);\n  vec3 speccolor = color;\n  float ambient = 0.5;\n  float diffuse = 0.3*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+diffuse;\n  float specular = pow(max(0.0,dot(reflect(lightdir,normal),r)),2.0);\n  color += specfact*specular*speccolor;\n  color = mix(color,background,clamp((t-fogdist)/(maxdist-fogdist),0.0,1.0));\n  return color;\n}\n\nvec3 rotateframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  {\n    float t = 0.0; // iTime;\n    p.yz = rotate(p.yz,0.5+t*0.125);\n    p.zx = rotate(p.zx,0.5+t*0.1);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  init();\n  doquadric0 = doquadric0 != key(CHAR_0+1);\n  doquadric1 = doquadric1 != key(CHAR_0+2);\n  doquadric2 = doquadric2 != key(CHAR_0+3);\n  doquadric3 = doquadric3 != key(CHAR_0+4);\n\n  hideinfinity = hideinfinity != key(CHAR_X);\n  \n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  float eyedist = 6.0;\n  eyedist *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  fogdist = eyedist;\n  maxdist = 2.0*eyedist;\n  vec3 eye = vec3(0,0,eyedist);\n  vec3 ray = vec3(z,-2);\n  eye = rotateframe(eye);\n  {\n    vec4 eye4 = A*vec4(eye,1);\n    vec3 eye1 = eye4.xyz/eye4.w;\n    eyesign0 = sign(scene0(eye1));\n    eyesign1 = sign(scene1(eye1));\n    eyesign2 = sign(scene2(eye1));\n    eyesign3 = sign(scene3(eye1));\n  }\n  ray = rotateframe(ray);\n  ray = normalize(ray);\n  lightdir = rotateframe(lightdir);\n  lightdir = normalize(lightdir);\n  vec3 col = raycolor(eye,ray);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\nconst int CHAR_0 = 48;\nconst int CHAR_X = 88;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel0, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel1, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nfloat PI = 3.14159;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSGzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[654, 696, 736, 736, 763], [781, 781, 803, 803, 835], [836, 836, 858, 858, 896], [897, 897, 919, 919, 961], [962, 962, 984, 984, 1026], [1028, 1028, 1063, 1092, 1514], [1612, 1612, 1631, 1631, 1888], [1890, 1890, 1917, 1967, 2163], [2165, 2165, 2185, 2185, 2258], [2303, 2303, 2332, 2332, 2596], [2598, 2598, 2660, 2660, 3197], [3199, 3199, 3212, 3242, 3511], [3548, 3548, 3579, 3579, 4126], [4128, 4128, 4154, 4154, 4494], [4496, 4496, 4547, 4547, 5482]], "test": "untested"}
{"id": "ssjGDw", "name": "Planet In Raymarching", "author": "deni_de", "description": "My first raymarching shader", "tags": ["raymarching"], "likes": 4, "viewed": 380, "published": 3, "date": "1617539534", "time_retrieved": "2024-07-30T19:28:42.247528", "image_code": "#define halftime iTime/2.0\n#define quarttime iTime/4.0\n#define eighttime iTime/8.0\n#define sixteentime iTime/16.0\n#define PI 3.14444\n#define fractime fract(iTime)\n\nvec3 SurfaceImage(vec3 normal)\n{\n    vec2 uv = normal.yz;\n    uv.x += sixteentime;\n    return texture(iChannel0, uv).rgb;\n}\n\n\nvec3 BackgroundImage(vec2 uv)\n{\n    vec3 background = texture(iChannel3,uv - sixteentime * 0.1).rgb;\n    vec3 colorOfback = background;\n    vec2 uv2 = uv * 3.0;\n    uv2.xy += 0.5 * iTime/256.0;\n    vec3 backchanges = texture(iChannel3, uv2).rgb;\n    background *= backchanges;\n    background = background.r < 0.57 ? vec3(0.0) : vec3(background.r);\n    \n    return background * colorOfback;\n}\n\nvec2 sphIntersect(in vec3 ro, in vec3 rd, float ra)\n{\n    float b = dot(ro,rd);\n    float c = dot (ro,ro) - ra * ra;\n    float h = b * b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    \n    return vec2(-b -h,-b + h);\n}\n\nvec3 Light(vec3 pos)\n{\n    return normalize(pos);\n}\n\nfloat AnmRadius(float size)\n{\n    return size;\n}\n\nvec3 RayCast(vec3 RayOrigin, vec3 RayDirection, vec2 uv)\n{\n\n    float animatedRadius = AnmRadius(1.04);\n    \n    vec2 it = sphIntersect(RayOrigin,RayDirection,1.0);\n    vec3 normal = RayOrigin + RayDirection * it.x;\n    vec2 it2 = sphIntersect(RayOrigin,RayDirection,1.02);\n    vec3 secondSphereNormal = RayOrigin + RayDirection * it2.x;\n    vec2 it3 = sphIntersect(RayOrigin,RayDirection,animatedRadius);\n    vec3 tSphereNormal = RayOrigin + RayDirection * it3.x;\n    \n    vec3 background = BackgroundImage(uv);\n    \n    vec3 view = vec3(-1,-1,0);\n    vec3 light = Light(vec3(-1,-1,0));\n    \n    vec3 image = background;\n        \n    vec3 planet_image = SurfaceImage(normal) *  (1. - it.x);\n    float diffuse = dot(light,normal);\n    planet_image *= diffuse;\n    float mask = clamp(it.x + it.y, 0.,1.);\n    image = mix(vec3(0),planet_image, mask);\n    image = mix(image,background, 1.- mask);\n    \n    \n    \n    float rim = clamp(1. - dot(view,secondSphereNormal),0.,1.);\n    float rim2 = clamp(1. - dot(view,tSphereNormal),0.,1.);\n    image += vec3(0.15,0.15,.5) * rim + vec3(0.1,0.35,.4) * rim2;\n    \n    return image;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 customUVquad = fragCoord/vec2(512.0,512.0);\n    vec2 uv = fragCoord/iResolution.xy * 1.5;\n    vec3 rayOrigin = vec3(-3.0,0.0,0.0);\n    vec3 rayDirection = normalize( vec3( 1.0, customUVquad - vec2(0.75,0.45) ) );\n    vec3 color = RayCast( rayOrigin, rayDirection, uv );\n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjGDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 196, 196, 287], [290, 290, 321, 321, 681], [683, 683, 736, 736, 914], [916, 916, 938, 938, 967], [969, 969, 998, 998, 1017], [1019, 1019, 1077, 1077, 2142], [2144, 2144, 2200, 2200, 2517]], "test": "untested"}
{"id": "sdjGWm", "name": "Revision 2021 Shader Showdown QF", "author": "anticore", "description": "coded live in 25 minutes during the revision 2021 shader showdown quarter finals", "tags": ["raymarching", "reflection", "volumetric", "shader", "glow", "revision", "finals", "showdown", "quarter", "anticore"], "likes": 14, "viewed": 915, "published": 3, "date": "1617530578", "time_retrieved": "2024-07-30T19:28:43.018467", "image_code": "vec3 cam(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 f = normalize(rd - ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.), f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l * uv.x + u * uv.y);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\nvec4 bg(vec3 rd) {\n  return rd.y * texture(iChannel0, rd.xz * 0.1 + iTime * 0.1).rrra * vec4(.2, .4, .8, 1.) * 0.5;\n}\n\nfloat sdBox(vec3 p, vec3 c) {\n    vec3 q = abs(p) - c;\n    return length(max(q, 0.));\n}\nfloat ni(float a) { \n//return texture(texFFTIntegrated, a).x; \n    return 0.;\n}\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nvoid mo(inout vec2 p, vec2 d){ p = abs(p) - d; if (p.y > p.x) p = p.yx; }\n\nfloat sdThing(vec3 p) {\n    mo(p.yz, vec2(.4));\n    mo(p.xy, vec2(.4));\n    p.xz *= rot(iTime + ni(0.2) * 2.);\n    p.zy *= rot(iTime  + ni(0.) * 2.);\n    mo(p.zx, vec2(.4));\n    mo(p.yx, vec2(.4));\n    return sdBox(p, vec3(.2, 1., .2));\n}\n\nvec3 rep(vec3 p, vec3 c) {\n    return mod(p + .5 * c, c) - .5 * c;\n}\n\nvec2 map(vec3 p) {\n    vec3 pp = p;\n    p += vec3(0., 3. - sin(p.x * .2 + p.z * .3 + iTime + ni(0.) * 10.) * .2 - cos(-p.x * 2. + p.z * .3 + iTime) * .3 - length(p) * .1, 0.);\n    p = rep(p, vec3(.4, 0., .4));\n    float s = sdSphere(p, .1);\n    float b = sdThing(pp + vec3(sin(ni(0.) * 3.), 0., cos(ni(.15) * 3.)));\n  \n    return vec2(min(s,b),s < b ? 1. : 2.);\n}\n\nvec3 norm(vec3 p) {\n    float E = 0.001; vec2 k = vec2(1, -1);\n    return normalize(\n      k.xyy * map(p + k.xyy * E).x + \n  \n      k.yyx * map(p + k.yyx * E).x + \n  \n      k.yxy * map(p + k.yxy * E).x + \n  \n      k.xxx * map(p + k.xxx * E).x\n    );\n}\n\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.283 * (c * t + d));\n}\n\nvec4 tr(vec3 ro, vec3 rd, vec2 uv) {\n    float td = 1.;\n    vec2 h;\n  \n    vec4 c = vec4(0.);\n  \n    for (int i = 0; i < 400; i++) {\n        vec3 ip = ro + rd * td;\n        h = map(ip);\n        td += h.x < 0.1 ? 0.01 : h.x;\n        int bnc = 0;\n        \n        if (h.y == 2.) {\n            c += vec4(pal(iTime , vec3(.5),vec3(.5),vec3(1., 1., .2),vec3(.8, .6, .3) ), 1.) * exp(-h.x * 5.) * 0.01;\n         }\n      \n        if (h.x < 0.01) {\n            vec3 inorm = norm(ip);\n          \n            if (h.y == 1.) {\n              c += vec4(pal(ip.x * .1 + ip.z * .2 + iTime - ip.x * .2 + ip.z * .1 + iTime, vec3(.5),vec3(.5),vec3(1., 1., .2),vec3(.8, .6, .3) ), 1.) * exp(-h.x * 20.) * (exp(-td * .1) * .1);\n            }\n            if (h.y == 2.) {\n                ro = ip;\n                rd = reflect(rd, inorm);\n                td = 0.2;\n                bnc += 1;\n            }\n        }\n    }\n    \n    return bg(rd)  + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(-10. * sin(iTime), 1. + sin(iTime + ni(0.) * .2), -5. * cos(iTime));\n    vec3 rd = cam(ro, vec3(0.,0.,0.), uv);\n\n    // Output to screen\n    fragColor = pow(tr(ro, rd, uv), vec4(1./1.5));\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 205], [207, 207, 240, 240, 268], [271, 271, 289, 289, 388], [390, 390, 419, 419, 477], [478, 478, 497, 540, 557], [558, 558, 577, 577, 625], [627, 627, 657, 657, 700], [702, 702, 725, 725, 940], [942, 942, 968, 968, 1010], [1012, 1012, 1030, 1030, 1375], [1377, 1377, 1396, 1396, 1628], [1630, 1630, 1681, 1681, 1728], [1730, 1730, 1766, 1766, 2659], [2661, 2661, 2718, 2718, 3024]], "test": "untested"}
{"id": "7d23DW", "name": "Mandelcube in Space", "author": "Chaotnix", "description": "Playing around with the mandelbox fractal and audio", "tags": ["fractal", "mandelbox", "audioreactive", "soundcloud"], "likes": 1, "viewed": 289, "published": 3, "date": "1617526907", "time_retrieved": "2024-07-30T19:28:43.830297", "image_code": "\n#define ITERS 6\n\nfloat SCALE=2.0;\nfloat MR2=0.0;\n\nfloat mandelbox(vec3 position){\n  vec4 scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;\n  float C1 = abs(SCALE + 7.0), C2 = pow(abs(SCALE), float(1-ITERS));\n  vec4 p = vec4(position.xyz, 1.0) + pow(texture(iChannel0, vec2(length(position.xyz), 0.3) ).x, 0.4), p0 = vec4(position.xyz, 1.0) + pow(texture(iChannel0, vec2(length(position.xyz), 0.3) ).x, 0.4);  // p.w is knighty's DEfactor\n  //vec4 p = vec4(position.xyz, 1.0) + pow(texture(iChannel0, vec2(length(position.xyz), 0.1) ).x, 0.1)/4., p0 = vec4(position.xyz, 1.0) + pow(texture(iChannel0, vec2(length(position.xyz), 0.1) ).x, 0.1)/4.5;  // p.w is knighty's DEfactor\n  for (int i=0; i<ITERS; i++) {\n    p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3\n    float r2 = dot(p.xyz, p.xyz);  // dp3\n    p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4\n    p.xyzw = p*scalevec + p0/6.;  // mad4\n  }\n  return (length(p.xyz) - C1) / p.w - C2;\n}\n\nfloat color(vec3 p){\n    vec3 op = p;\n    for (int i=0; i<ITERS; i++) {\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3\n        float r2 = dot(p.xyz, p.xyz);  // dp3\n        p.xyz *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4\n        p.xyz = p*SCALE/MR2 + op;  // mad4\n//        p.xyz = p - pow(texture(iChannel0, vec2(length(p.xy), 0.) ).x/3., 0.01)*4.;\n\n    }\n  \treturn length(p/2.);\n}\n\nfloat trace(vec3 o,vec3 d){\n    float v=0.0;\n    for(int i=0;i<74;i++){\n        vec3 p=o+d*v;\n//        p=p + pow(texture(iChannel0, vec2(length(p.xy), 0.) ).x, 0.1);\n        float mv=mandelbox(p);        \n        if(mv<0.01){\n            return v;\n        }\n        v+=mv *.9;\n    }\n    return 0.;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*4.-2.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 4.0;\n   //SCALE = 2.5 + iMouse.x * 2.0;\n   // MR2 = iMouse.x * iMouse.x;\n    //SCALE = 2.9 + sin(iTime*10.0)*.0;\n    SCALE = 2.5;\n    float mr = 0.6;\n    MR2 = mr * mr;\n    \n      \n    vec3 lookingTo = vec3(3.,2.,4.);\n    float it = iTime / 5.;\n    vec3 viewer = vec3(\n        sin(iTime*.1) * 6.0,\n        cos(iTime*.17) * 5.0,\n        cos(iTime*.1) * 9.0\n    );\n    \n    vec3 forward = normalize(lookingTo-viewer);\n    vec3 rigth = cross(vec3(0.0,1.0,0.0),forward);\n    vec3 up = cross(forward,rigth);\n    \n    vec3 direction = normalize(forward/0.1 * pow(texture(iChannel0, vec2(length(uv.y),.8) ).x, 0.005) + rigth * uv.x + up * uv.y);\n    \n    float dist = trace(viewer,direction);\n    vec3 col=vec3(0.0);\n    if(dist <=0.) {\n        dist=dist + 2. * pow(texture(iChannel0, vec2(length(dist),0.005) ).x , .005);\n    };    \n     vec3 p = viewer + direction * dist ;\n    \n    \n    if(dist!=0.) {\n        \n         float c = color(p);\n        \n   \t\t col = pal(c/50.0, \n                   vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20)\n                   //vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25)\n                   //vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25)\n                  );\n\n        //col = vec3(1.0);\n    };\n\n    \n   \n   \n    float fog = 1. + .04 * pow(texture(iChannel0, vec2(length(p),.2) ).x, 0.005);\n    fragColor.rgb = vec3(col * fog);\n}", "image_inputs": [{"id": 26489, "src": "https://soundcloud.com/4i20music/4i20-thanks-for-10k-folows-dj", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d23DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 82, 82, 1016], [1018, 1018, 1038, 1038, 1473], [1475, 1475, 1502, 1502, 1775], [1777, 1777, 1845, 1845, 1888], [1895, 1895, 1952, 1952, 3495]], "test": "untested"}
{"id": "NdBGzh", "name": "Path-Traced Volumetric Clouds", "author": "Zi7ar21", "description": "Path-Tracing and Volumetrics go well together with Worley Noise.", "tags": ["raymarching", "ray", "raymarch", "raymarched", "volumetric", "raymarcher", "pathtrace", "pathtracing", "pathtracer", "path", "pathtraced"], "likes": 4, "viewed": 659, "published": 3, "date": "1617523078", "time_retrieved": "2024-07-30T19:28:44.875502", "image_code": "// ######### Path-Traced Volumetric Clouds #########\n// Made by Jacob Bingham (Zi7ar21)\n// Made on April 4th, 2021\n// Last Updated: April 4th, 2021 at 02:00 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/NdBGzh\n\n// Check out my Friends:\n// Michael0884\n// https://www.shadertoy.com/user/michael0884\n// LoicVDB\n// https://www.shadertoy.com/user/loicvdb\n\n// This shader isn't as commented as well as I want it to be,\n// come back in a few days if I ever add more comments lmao\n\n// Output the Image to the Screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get the Rendered Image\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n    // HDR Tonemapping\n    color = tonemap(color);\n\n    // Output the Image to the Screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ####### COMMON #######\n/* This tab contains settings and other functions that help make this shader work. */\n\n// ##### PARAMETERS #####\n// Sensitivity of the Mouse Controls\n#define mousesensitivity 8.0\n\n// Image Gamma (Image Preview Only)\n#define gamma 2.2\n\n// Camera Field of View\n#define camfov 1.0\n\n// Fractal Brownian Motion (FBM) Noise Octaves (More = More Detail)\n#define octaves 4U\n\n// Size of the Volumetric Ray-Marching Steps\n#define stepsize 0.05\n\n// Maximum Ray-Marching Steps\n#define maxmarches 1024U\n\n// Scattering Amount\n#define scattering 1.0\n\n// Maximum Distance the Ray can Travel from (0.0, 0.0, 0.0)\n#define scenesize 32.0\n\n// Maximum Distance the Ray can Travel\n#define maxdist 32.0\n\n// Maximum Times the Ray can Bounce\n#define maxbounces 8U\n\n// ### LoicVDB Sky Parameters ###\n// Controls Sky Quality\n#define SkySamples 8\n\n// Controls Sky Color\n#define SkyColor vec3(0.25, 0.5, 1.0)\n\n// Controls Light Color\n#define LightColor vec3(1.0, 1.0, 1.0)\n\n// Controls Sky Direction\n#define SkyUp vec3(0.0, 1.0, 0.0)\n\n// Controls Light Direction\n#define LightDirection normalize(vec3(0.0, 0.25, -1.0))\n\n// Controls Sky Intensity\n#define SkyIntensity 0.2\n\n// Controls Light Intensity\n#define LightIntensity 5.0\n\n// Controls the Radius of the Light\n#define LightRadius 0.125\n\n// Controls Mie Scattering Intensity\n#define MieIntensity 0.05\n\n// Controls Mie Scattering Anisotropy\n#define MieAnisotropy 0.6\n\n// ##### CONSTANTS #####\n// Octuple Precision Pi\n// (for future-proofing, even though Shadertoy can only accurately represent pi as 3.14159265)\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n#define quarterpi pi*0.25\n\n// ##### CUSTOM DATA TYPES #####\nstruct volumesample{\n    float density;\n    vec3 color;\n};\n\n// ##### MATH #####\n// Clamps a Value to Between 0.0 and 1.0\nfloat saturate(float x){return clamp(x, 0.0, 1.0);}\nvec2  saturate(vec2  x){return clamp(x, 0.0, 1.0);}\nvec3  saturate(vec3  x){return clamp(x, 0.0, 1.0);}\nvec4  saturate(vec4  x){return clamp(x, 0.0, 1.0);}\n\n// Rotation Matrix from LoicVDB\nmat3 rotmat(vec3 rotation){\n    // Precalculate the Trig Functions\n    vec3 s = sin(rotation), c = cos(rotation);\n\n    // X Rotation\n    mat3 rx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n\n    // Y Rotation\n    mat3 ry = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n\n    // Z Rotation\n    mat3 rz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n\n    // Output the Final Matrix\n    return rx*ry*rz;\n}\n\n// Rotate a Vector\nvec3 rotate(vec3 vector, vec3 angle){\n    return vector*rotmat(angle);\n}\n\n// ##### NOISE #####\n// Dave_Hoskins Hash33: https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3){\n\tp3 = fract(p3*vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n// My very own Worley Noise Implementation, drastically improved by LoicVDB\nfloat noise(vec3 coord){\n    vec3 cell = floor(coord);\n    float mindist = 1000.0;\n    for(int z = -1; z < 2; z++){\n    for(int y = -1; y < 2; y++){\n    for(int x = -1; x < 2; x++){\n        vec3 ncell = cell+vec3(x, y, z);\n        vec3 point = ncell+hash(ncell);\n        mindist = min(dot(coord-point, coord-point), mindist);\n    }\n    }\n    }\n    return sqrt(mindist);\n}\n\n// Fractal Brownian Motion (FBM) Noise\nfloat fbm(vec3 coord){\n    float outCol      = 0.0;\n    float attenuation = 0.5;\n    for(uint i = 0U; i < octaves; i++){\n        outCol += (1.0-noise(coord))*attenuation;\n        coord  *= 2.5;\n        //coord   = rotate(coord, vec3(pi/8.0));\n        attenuation *= 0.5;\n    }\n    return outCol;\n}\n\n/*// ##### DISTANCE ESTIMATORS #####\nfloat sphere(vec3 pos, vec3 sphpos, float sphrad){\n    return length(pos-sphpos)-sphrad;\n}\n\nfloat yplane(vec3 pos, float ypos){\n    return pos.y-ypos;\n}\n\nfloat box(vec3 pos, vec3 box){\n    vec3 q = abs(pos)-box;\n    return length(max(q, 0.0))+min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat de(vec3 raypos){\n    float DE0 = yplane(raypos, 0.0);\n    return DE0;\n}\n\nvec3 calcNormal(vec3 pos){\n    const vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy*de(pos+k.xyy*collisiondist)+\n                     k.yyx*de(pos+k.yyx*collisiondist)+\n                     k.yxy*de(pos+k.yxy*collisiondist)+\n                     k.xxx*de(pos+k.xxx*collisiondist));\n}\n\nfloat de(in vec3 raypos, out uint objectid){\n    float DE0 = yplane(raypos, 0.0);\n    float DE1 = sphere(raypos, vec3(0.0, 0.5, 0.0), 0.5);\n    float minimum = min(DE0, DE1);\n    if(minimum == DE0){\n        objectid = 1U;\n        return DE0;\n    }\n    if(minimum == DE1){\n        objectid = 2U;\n        return DE1;\n    }\n    objectid = 0U;\n    return -1.0;\n}\n\n// ##### INTERSECTION FUNCTIONS #####\n// Almost everything is from the great Inigo Quilez:\n// https://iquilezles.org/articles/intersectors\n// Sphere Intersection Function\nfloat sphere(vec3 raydir, vec3 rayori, vec3 sphpos, float sphrad){\n    vec3 oc = rayori-sphpos;\n    float b = dot(oc, raydir);\n    float c = dot(oc, oc)-sphrad*sphrad;\n    float h = b*b-c;\n    if(h < 0.0){return -1.0;}\n    h = sqrt(h);\n    return -b-h;\n}\n\n// Plane Intersection Function (with help from LoicVDB)\n// https://www.shadertoy.com/user/loicvdb\nfloat plane(vec3 raydir, vec3 rayori, vec3 point, vec3 norm){\n    float normdotp = dot(raydir, norm);\n    if(normdotp >= 0.0){return -1.0;}\n    return dot(point-rayori, norm)/normdotp;\n}\n\n// Scene Intersection Function\nfloat intersect(vec3 raydir, vec3 rayori, out vec3 norm, out uint objectid){\n    // Compute all intersections, and find the closest object\n    float int0 = plane(raydir, rayori, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    float int1 = sphere(raydir, rayori, vec3(0.0, 0.5, 0.0), 0.5);\n    float minimum = min(int0, int1);\n    if(int0 <= 0.0){minimum = int1;}\n    if(int1 <= 0.0){minimum = int0;}\n\n    // Find the Normal and Intersection of the Nearest Object\n    if(minimum == int0){\n        norm = vec3(0.0, 1.0, 0.0);\n        objectid = 1U;\n        return int0;\n    }\n\n    if(minimum == int1){\n        norm = normalize((rayori+(raydir*int1))-vec3(0.0, 0.5, 0.0));\n        objectid = 2U;\n        return int1;\n    }\n\n    // NULL Object (just to be safe)\n    norm = vec3(0.0);\n    objectid = 0U;\n    return -1.0;\n}\n\n// ##### MATERIALS #####\nvoid getmat(in uint objectid, out vec3 albedo, out vec3 spec, out vec3 norm, out float rough){\n    if(objectid == 1U){\n        albedo = vec3(0.8);\n        norm   = vec3(0.0, 1.0, 0.0);\n        spec   = vec3(0.6);\n        rough  = 1.0;\n        return;\n    }\n    if(objectid == 2U){\n        albedo = vec3(0.8, 0.2, 0.2);\n        norm   = vec3(0.0, 1.0, 0.0);\n        spec   = vec3(0.6);\n        rough  = 1.0;\n        return;\n    }\n    albedo = vec3(0.0);\n    norm   = vec3(0.0);\n    spec   = vec3(0.0);\n    rough  = 0.0;\n    return;\n}*/\n\n// ##### COLOR MANAGEMENT #####\n// HDR to LDR Tonemapping\nvec3 tonemap(vec3 linearColor){\n    return pow(linearColor/(linearColor+1.0), vec3(1.0/gamma));\n}\n\n/*// All this is from LoicVDB:\nconst mat3 linear2acescg = mat3(\n    0.613117812906440, 0.341181995855625, 0.045787344282337,\n    0.069934082307513, 0.918103037508582, 0.011932775530201,\n    0.020462992637737, 0.106768663382511, 0.872715910619442);\nconst mat3 acescg2linear = inverse(linear2acescg);\n\nvec3 srgb2linear(vec3 c){\n    return pow(max(c, vec3(0.0)), vec3(gamma));\n}\n\nvec3 linear2srgb(vec3 c){\n    return pow(max(c, vec3(0.0)), vec3(1.0/gamma));\n}\n\nvec3 srgb2acescg(vec3 c){\n    return linear2acescg*srgb2linear(c);\n}\n\nvec3 acescg2srgb(vec3 c){\n    return linear2srgb(acescg2linear*c);\n}\n\nvec3 tonemapping(vec3 x){\n    // Probably not proper ACES, but it looks nice\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}*/\n\n// ##### ENVIRONMENT #####\n// LoicVDB's (Slightly Modified) Sky Functions\n// (I don't know where to link to other than his profile page, since this\n// is from a Fragmentarium shader he shared on the Marble Marcher Discord)\nfloat anisotropicWeight(vec3 dirI, vec3 dirO, float a){\n \treturn quarterpi*(1.0-a*a)/pow(1.0+a*(a-2.0*dot(dirI, dirO)), 1.5);\n}\n\nvec3 skyDirectLight(vec3 pos, int i){\n    if(dot(LightDirection, SkyUp) < 0.0){return vec3(0.0);}\n    vec3 volAbs = vec3(1.0), stepAbsRay, stepAbsMie;\n    float alt, dist, ds;\n    for(; i < SkySamples; i++){\n        alt = -log(1.0-sign(dot(LightDirection, SkyUp))*float(i)/float(SkySamples));\n    \tdist = alt/dot(LightDirection, SkyUp);\n        ds = exp(-dot(pos, SkyUp));\n        stepAbsRay = exp(-ds*dist*SkyColor*SkyIntensity);\n        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));\n        volAbs *= stepAbsMie*stepAbsRay;\n        pos += LightDirection*dist;\n    }\n    return LightColor.rgb*LightColor*volAbs;\n}\n\nvec3 backgroundDirectLight(vec3 dir){\n\tif(dot(dir, LightDirection) < cos(LightRadius)){return vec3(0.0);}\n\tfloat sphericalCapArea = sin(LightRadius)*sin(LightRadius);\n\tfloat lightStrength = LightIntensity/(sphericalCapArea);\n\treturn lightStrength*LightColor.rgb;\n}\n\nvec3 skyScatter(vec3 dir, bool hasSun){\n    vec3 pos = vec3(0.0), volCol = vec3(0.0), volAbs = vec3(1.0);\n    vec3 stepAbsRay, stepAbsMie, stepColRay, stepColMie;\n    float alt, dist, ds;\n    float aw = anisotropicWeight(dir, LightDirection, MieAnisotropy);\n    for(int i = 0; i < SkySamples; i++){\n        alt = -log(1.0-sign(dot(dir, SkyUp))*float(i)/float(SkySamples));\n    \tdist = min(alt/dot(dir, SkyUp), 5.0);\n        ds = exp(-dot(pos, SkyUp));\n        stepAbsRay = exp(-ds*dist*SkyColor.rgb*SkyIntensity);\n        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));\n        stepColRay = (1.0-stepAbsRay);\n        stepColMie = (1.0-stepAbsMie)*aw;\n        volCol += (stepColMie+stepColRay)*volAbs*skyDirectLight(pos, i);\n        volAbs *= stepAbsRay*stepAbsMie;\n        pos += dir*dist;\n    }\n    return volCol+(hasSun ? backgroundDirectLight(dir)*volAbs:vec3(0.0));\n}\n\n\n// ##### RNG #####\n// All of these are from Michael0884\n// https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = uint(iResolution.x*iResolution.y)*uint(iFrame)+uint(fragCoord.x+fragCoord.y*iResolution.x);\n\nvoid pcg(){\n    uint state = ns*747796405U+2891336453U;\n    uint word = ((state >> ((state >> 28U) + 4U)) ^ state)*277803737U;\n    ns = (word >> 22U) ^ word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffU);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random\n// https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x   ))*vec2(cos(twopi*Z.y), sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy ))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}", "buffer_a_code": "// ####### RENDERING #######\n/* This tab contains all of the Rendering magic. */\n\n// ##### NOISE #####\n// Noise from Sampler (Place Noise Volume in iChannel1)\n/*float noise(vec3 coord){\n    float param = 0.5;\n    return saturate(abs(texture(iChannel1, coord*0.125).r-param)/max(param, 1.0-param));\n}*/\n\n// Volumetric Density Function\nvolumesample densityfunction(vec3 raypos){\n    float height = abs(raypos.y);\n    if(height > 0.6){return volumesample(0.0, vec3(0.0));}\n    float density = (fbm(raypos*0.5)-0.55)-(height*height);\n    return volumesample(max(density*512.0, 0.0), vec3(0.95));\n}\n\n// Path-Tracing\nvec3 pathtrace(vec3 raydir, vec3 rayori){\n    // Set-Up Variables\n    vec3 raypos = rayori, attenuation = vec3(1.0);\n    float disttrav = 0.0, adaptivestep = 0.0;\n    uint bounces = 0U;\n\n    // Perform Ray-Marching\n    for(uint i = 0U; i < maxmarches; i++){\n        if(length(raypos.xz) > scenesize || abs(raypos.y) > 2.0 || disttrav > maxdist){break;}\n        if(bounces > maxbounces){return vec3(0.0);}\n        volumesample density = densityfunction(raypos);\n        float absorbance = exp(-density.density*(stepsize+adaptivestep));\n        if(absorbance < rand()){\n            attenuation *= saturate(density.color*scattering);\n            raydir = normalize(nrand3(1.0, vec3(0.0)));\n            bounces++;\n        }\n        raypos += raydir*(stepsize+adaptivestep);\n        disttrav += (stepsize+adaptivestep);\n        adaptivestep = max((length(raypos.xz)/10.0)-5.0, 0.0)*rand();\n    }\n    return skyScatter(raydir, true)*attenuation;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n    if(iMouse.z > 0.0){fragColor = vec4(0.0);}\n\n    // Initialize RNG\n    INIT_RNG;\n\n    // Set up Screen UV Coordinates\n    vec2 uv = 2.0*(nrand2(0.5, fragCoord.xy)-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Mouse Controls\n    //vec2 mouse = vec2(-pi*0.9, 0.0);\n    vec2 mouse = mousesensitivity*(iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Calculate the Direction of the Ray\n    vec3 camtarget = vec3(0.0, 0.5, 0.0);\n    vec3 campos = vec3(-sin(mouse.x)*4.0, 0.5, -cos(mouse.x)*4.0);\n    vec3 targetdir = normalize(camtarget-campos);\n    vec3 left = cross(targetdir, vec3(0.0, 0.5, 0.0));\n    vec3 up = cross(left, targetdir);\n    mat3 rotmat = mat3(left, up, targetdir);\n    vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render the Image\n    vec3 color = pathtrace(raydir, campos);\n\n    // Output the Image to the Screen\n    fragColor += vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ####### IMAGE EXPORT #######\n/* This tab is for exporting a 32-Bit per Channel OpenEXR Image.\nTo export, click on the little Image icon at the bottom right of the editor. */\n\n// Output the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get the Rendered Image\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Convert the Image to a Final State\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n\n    // Output the Image\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBGzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[593, 627, 681, 711, 903]], "test": "untested"}
{"id": "fsj3Dm", "name": "Seafloor fractal 2", "author": "jarble", "description": "This fractal looks like a landscape from an alien world.\nFull-screen mode recommended.", "tags": ["fractal", "grass", "mountain", "valley"], "likes": 0, "viewed": 278, "published": 3, "date": "1617510035", "time_retrieved": "2024-07-30T19:28:45.648435", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.0;\n        float scale1 = 1.5;\n        float s1 = scale1*scale;\n        for(int i=0;i<6;i++)\n        {\n            uv += uv.yy;\n            uv = fract((uv)/s1)*s1;\n            uv=-fract(uv/(3.5-abs((uv.y+uv.x)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv.y /= scale1+col.x;\n        \tuv=uv.yx+col.xy;\n            uv.x *= -(1.0+col.x/scale);\n            col[c] = fract((((1.0+col.y)*.125)*(col.x+uv.y-uv.x))/3.0);\n        }\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsj3Dm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 771]], "test": "untested"}
{"id": "NdjGDm", "name": "Pacman Petri Dish", "author": "blackle", "description": "won revision 2021 semifinals. this might be unstable but idk why", "tags": ["diffusion", "reactiondiffusion", "shadershowdown", "rd", "livecode", "revision2021"], "likes": 20, "viewed": 621, "published": 3, "date": "1617505846", "time_retrieved": "2024-07-30T19:28:46.431343", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//couldn't fix eyes during the showdown... uncomment to see how it looked at the end of showdown\n#define FIX_EYES\n\nfloat corner(vec2 p) {\n  return length(max(p,0.)) + min(0.,max(p.x,p.y));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n  p.yz += tan(asin(sin(vec2(iTime*3., iTime*2.5)))*.7)*.8;\n  vec2 dir = sign(cos(vec2(iTime*3., iTime*2.5)));\n  p.yz *= dir;\n  p.yz *= -1.;\n  p = erot(p, vec3(1,0,0), radians(-45.));\n  p.z = abs(p.z);\n  p = erot(p, vec3(1,0,0), -abs(sin(iTime*5.)));\n  float wd = length(p.yz) - .3;\n  wd = max(wd, .05- corner(p.yz*vec2(-1,1)));\n  return corner(vec2(wd,abs(p.x)))-.05;\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat redo(float x) {\n  return 1.-x;\n}\nfloat undo(float x) {\n  return 1.-x;\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat zombiegost(vec2 p) {\n  float bod = linedist(p, vec2(0,-.5), vec2(0,.5));\n  \n  float eyes = length(vec2(abs(p.x)-.2, .5+p.y))-.1;\n  p.x = asin(sin(p.x*40.+floor(iTime)*2.))/40.;\n  float dt = dot(p, vec2(1));\n  dt = max(bod,dt)-.5;\n#ifdef FIX_EYES\n  return max(-eyes,dt);\n#endif\n  return dt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 olduv = fragCoord/iResolution.xy;\n  vec2 pixelsize = 1./iResolution.xy;\n  \n  float kr = .055 + length(uv*2.)*.02 - sin(iTime)*.02;\n  float fr = .055;\n  float da = 1.;\n  float db = .1;\n  vec4 past = texture(iChannel0, olduv);\n  past.z = undo(past.z );\n  float scale = 2.5+sin(iTime*3.);\n  vec4 conv = vec4(0);\n  for (int i = -1; i <= 1; i++) {\n  for (int j = -1; j <= 1; j++) {\n    vec4 smpl = texture(iChannel0, olduv + vec2(i,j)*pixelsize*scale);\n    smpl.z = undo(smpl.z);\n    float coeff = (j == 0 && i == 0) ? -1. : ((i == 0 || j == 0 ) ? .2 : .05 );\n    conv += coeff*smpl;\n  }\n  }\n  float olda = past.z;\n  float t = .8;\n  float a = olda + (da*conv.z - olda*past.w*past.w + fr*(1.-olda))*t;\n  float b = past.w + (db*conv.w + olda*past.w*past.w - (fr+kr)*past.w)*t;\n  a = redo(a);\n  b = clamp(b,0.,1.);\n  a = clamp(a,0.,1.);\n  //if (isnan(a) || isinf(a) || isnan(b) || isinf(b)) { a = 0.; b = 1.; }\n  fragColor = vec4(0,a*.5,a,b);\n\n  vec3 cam = normalize(vec3(1,uv));\n  vec3 init = vec3(-4,0,0);\n  vec3 p = init;\n  bool hit = false;\n  for (int i = 0; i < 100; i++ ){\n    float dist = scene(p);\n    hit = dist*dist < 1e-6;\n    p+= dist*cam;\n    if (hit) break;\n  }\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float spec = length(sin(r*3.)*.3+.7)/sqrt(3.);\n  vec3 col = vec3(0.9,.7,.2)*spec + pow(spec,8.);\n  if (hit) {\n    fragColor = vec4(col, 1.);\n  }\n  if (zombiegost(uv*-3. + vec2(asin(sin(iTime*2.)), sin(iTime*2.7)*.5)) < 0.) {\n    fragColor.r = 1.;\n  }\n  if (iFrame == 0) {\n  fragColor = vec4(0,0,0,1);\n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjGDm.jpg", "access": "api", "license": "cc0-1.0", "functions": [[195, 195, 252, 252, 316]], "test": "untested"}
{"id": "Ndj3Wm", "name": "Revision 2021 DJ messy Jam", "author": "sp4ghet", "description": "Shader livecoded at Revision Shader Jam 2021 with DJ messy", "tags": ["revision", "jam", "2021"], "likes": 10, "viewed": 570, "published": 3, "date": "1617499158", "time_retrieved": "2024-07-30T19:28:47.197295", "image_code": "#define PI 3.14159265\n#define TAU 2.*PI\n#define time iTime\n#define saturate(x) clamp(x, 0., 1.)\n\nmat3 getOrtho(vec3 z, vec3 up){\n  z = normalize(z);\n  vec3 cu = normalize(cross(z,up));\n  vec3 cv = cross(cu,z);\n  return mat3(cu,cv,z);\n}\n\nconst vec3 up = vec3(0,1,0);\nfloat noise(vec3 p, float t){\n  float ns=0., amp=1., trk=1.5 + t;\n  const vec3 seed = vec3(-4,-2,.5);\n  mat3 rot = getOrtho(seed, up);\n  for(int i=0; i<4; i++){\n    p += sin(p.zxy + trk)*1.6;\n    ns += sin(dot(cos(p), sin(p.zxy)))*amp;\n    p *= rot;\n    p *= 2.3;\n    trk *= 1.5;\n    amp *= .5;\n  }\n  return ns*.5;\n}\n\nfloat fs(vec2 p){\n  return fract(sin(dot(p, vec2(12.41245, 78.233))) * 421251.543123);\n}\n\nfloat random(float x){\n  return fs(vec2(x));\n}\n\nvec2 seed;\nfloat rnd(){\n  return fs(seed);\n}\n\nvec3 rndSphere(){\n  float t = PI*rnd();\n  float p = TAU*rnd();\n  return vec3(cos(t)*cos(p), sin(t), cos(t)*sin(p));\n}\n\nvec3 rndHemi(vec3 n){\n  vec3 v = rndSphere();\n  return dot(n,v) > 0. ? v : -v;\n}\n\nvoid chmin(inout vec4 a, vec4 b){\n  a = a.x < b.x ? a : b;\n}\n\nfloat box(vec3 p, vec3 b){\n  p = abs(p) - b;\n  return min(0., max(p.x, max(p.y, p.z))) + length(max(p,0.));\n}\n\nmat2 r2d(float t){\n  float c=cos(t), s=sin(t);\n  return mat2(c,s,-s,c);\n}\n\n\nfloat lng, shrt;\n\nvec4 map(vec3 q){\n  vec3 p = q;\n  vec4 d = vec4(100000, 0,0,0);\n\n\n  float bx = box(p, vec3(5, 3.25, 7));\n  float bx2 = box(p, vec3(4, 3, 6));\n  bx = max(bx, -bx2);\n  bx2 = box(p - vec3(0,5,-1), vec3(1,2,1)) - .5;\n  bx = max(bx, -bx2);\n  bx -= .05*noise(p, shrt);\n  chmin(d, vec4(bx, 0,0,0));\n\n  p=q - vec3(-1., 0., -2.);\n  p.y -= shrt*2. - 1.;\n  p.xy *= r2d(PI*.2);\n  for(int i=0; i<10; i++){\n    p.zy *= r2d(-PI*.35*(.3 + shrt));\n    p.xy *= r2d(-PI*.4*(1.3 - shrt*shrt));\n    p.y -= .15;\n    p = abs(p);\n  }\n\n  bx = box(p, vec3(.01, .2, .01));\n  chmin(d, vec4(bx, 1,0,0));\n\n  return d;\n}\n\nvec3 normal(vec3 p){\n  vec2 e = vec2(0, 0.07678);\n  return normalize(vec3(\n    map(p + e.yxx).x - map(p - e.yxx).x,\n    map(p + e.xyx).x - map(p - e.xyx).x,\n    map(p + e.xxy).x - map(p - e.xxy).x\n  ));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tvec2 pt = uv - 0.5;\n\tpt /= vec2(iResolution.y / iResolution.x, 1);\n\n  seed = vec2(noise(vec3(pt*37., time), 15.3), noise(vec3(pt*25., time), 1.2));\n\n  float bps = 120./60.;\n\n  float tm = time*bps*.5;\n  float pre = random(floor(tm) - 1.);\n  float now = random(floor(tm));\n  lng = fract(tm);\n  lng = 0.5 + 0.5*cos(PI*exp(-8.*lng));\n  lng = mix(pre, now, lng);\n\n  tm = time*bps*2.;\n  pre = random(floor(tm) - 1.);\n  now = random(floor(tm));\n  shrt = fract(tm);\n  shrt = 0.5 + 0.5*cos(PI*exp(-3.*shrt));\n  shrt = mix(pre, now, shrt);\n\n  vec3 c = vec3(0.);\n\n  float longAngle = .4 * TAU * (lng - .5) + PI*.5;\n  vec3 ro = vec3(0.,0.,3.);\n\n  vec3 fo = vec3(-1., 2.*shrt - 1.,-2.);\n\n  vec3 rov = normalize(fo - ro);\n  vec2 pt2 = pt*r2d((lng - .5)*PI*.3);\n  vec3 rd = getOrtho(rov, up) * normalize(vec3(pt2, 1.));\n\n  float t=0.;\n  vec3 p=ro;\n  vec4 d;\n  for(int i=0; i<64; i++){\n    p = ro + rd*t;\n    d = map(p);\n    if(abs(d.x) < 0.01){\n      break;\n    }\n    t += d.x;\n  }\n\n  vec3 l = normalize(vec3(1,4,1));\n  if(abs(d.x) < 0.01){\n    vec3 n = normal(p);\n    c += max(0., dot(n,l));\n    float fre = pow(1. - abs(dot(n,rd)) , 5.);\n    c += fre;\n\n    float ao=0.,ss=0.;\n    vec3 h = normalize(l-rd);\n    for(int i=1;i<=10;i++){\n      float aot = 0.1*float(i) + .05*rnd();\n      float sst = 0.3*float(i) + .5*rnd();\n      vec3 nd = mix(n,rndHemi(n),.2);\n      ao += map(p+nd*aot).x/aot;\n      ss += map(p+h*sst).x/sst;\n    }\n    c += ss*.1;\n    c *= ao*.1;\n\n    if(d.y == 1.){\n      c *= vec3(25, 1, 1.5);\n    }\n\n    vec3 hitp = p;\n    float sh=1., tt=.1;\n    for(int i=0; i<24; i++){\n      hitp = p + l*tt;\n      float d = map(hitp).x;\n      tt += d + .2*rnd();\n      if(d < 0.001){\n        sh = 0.;\n        break;\n      }\n      if(tt > 30.){\n        break;\n      }\n      sh = min(sh, 8.*d/tt);\n    }\n\n    c *= saturate(.2+sh);\n  }\n\n\n  float od=0.;\n  vec3 acc=vec3(0.), fogC = vec3(1, .8, .8);\n  int n=16;\n  float st=min(2., t/float(n)), tt=0.;\n  for(int i=0; i<n; i++){\n    p = ro + rd*tt;\n    tt += st*(.95+.1*rnd());\n    od += .2*(1. + abs(noise(p*3., time))) * st;\n\n    vec3 pp=p; float t=0.1;\n    float sh=2.;\n    for(int j=0; j<24; j++){\n      pp = p + l*t;\n      float d = map(pp).x;\n      t += d;\n      if(d < 0.01){\n        sh=0.;\n        break;\n      }\n    }\n    acc += exp(-od*fogC)*sh*st;\n  }\n  c *= exp(-.3*od);\n  c += acc;\n\n  c = c/(1. + c);\n\n  c = pow(c, vec3(.4545));\n  c = smoothstep(.05, 1.4, c);\n  float lum = dot(c, vec3(.2126, .7152, .0722));\n  float shad = smoothstep(.4, .01, lum);\n  float high = smoothstep(.3, 1., lum);\n  c = c*shad*vec3(.4, 1.2, 1.2) + c*(1.-shad*high) + c*high*vec3(.9, .8,.8);\n\n  c *= 1. - length(pt);\n\n\tfragColor = vec4(c,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndj3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 128, 128, 235], [266, 266, 295, 295, 582], [584, 584, 601, 601, 672], [674, 674, 696, 696, 720], [733, 733, 745, 745, 766], [768, 768, 785, 785, 885], [887, 887, 908, 908, 967], [969, 969, 1002, 1002, 1029], [1031, 1031, 1057, 1057, 1140], [1142, 1142, 1160, 1160, 1215], [1236, 1236, 1253, 1253, 1825], [1827, 1827, 1847, 1847, 2031], [2034, 2034, 2089, 2089, 4833]], "test": "untested"}
{"id": "7sjGWD", "name": "GIA demo", "author": "paniq", "description": "Demonstration of Gradient Interval Arithmetic https://www.shadertoy.com/view/WsKyDW - sphere tracing left, segment tracing right", "tags": ["raymarching", "antialiasing", "silhouette", "conservative", "refinement"], "likes": 10, "viewed": 738, "published": 3, "date": "1617489626", "time_retrieved": "2024-07-30T19:28:48.163710", "image_code": "//////////////////////////////////////////////////////////\n\n// GIA scalar for rays (1D)\nstruct gia1 {\n    float f0; // sample of f(0)\n    vec2 f1; // interval of f(1) / f'(0)\n};\n    \nstruct gia1x2 {\n    gia1 x;\n    gia1 y;\n};\n\nstruct gia1x3 {\n    gia1 x;\n    gia1 y;\n    gia1 z;\n};\n\n//////////////////////////////////////////////////////////\n\ngia1 gia_const(float x) {\n    return gia1(x, vec2(x));\n}\n\ngia1x3 gia_const(vec3 v) {\n    return gia1x3(gia_const(v.x), gia_const(v.y), gia_const(v.z));\n}\n\ngia1 gia_neg(gia1 x) {\n    return gia1(-x.f0, -x.f1.yx);\n}\n\nvec2 ia_sort(vec2 ia) {\n    return (ia.x > ia.y)?ia.yx:ia;\n}\n\nvec2 ia_merge(vec2 a, vec2 b) {\n    return vec2(min(a.x, b.x), max(a.y, b.y));\n}\n\ngia1 gia_add(gia1 a, gia1 b) {\n    return gia1(a.f0 + b.f0, a.f1 + b.f1);\n}\n\ngia1 gia_add(gia1 a, float b) {\n    return gia1(a.f0 + b, a.f1 + b);\n}\n\ngia1x3 gia_add(gia1x3 a, vec3 b) {\n    return gia1x3(gia_add(a.x, b.x), gia_add(a.y, b.y), gia_add(a.z, b.z));\n}\n\ngia1 gia_sub(gia1 a, gia1 b) {\n    return gia1(a.f0 - b.f0, a.f1 - b.f1.yx);\n}\n\ngia1 gia_sub(float a, gia1 b) {\n    return gia1(a - b.f0, a - b.f1.yx);\n}\n\ngia1 gia_sub(gia1 a, float b) {\n    return gia1(a.f0 - b, a.f1 - b);\n}\n\ngia1x2 gia_sub(gia1x2 a, gia1x2 b) {\n    return gia1x2(gia_sub(a.x,b.x),gia_sub(a.y,b.y));\n}\n\ngia1x3 gia_sub(gia1x3 a, gia1x3 b) {\n    return gia1x3(gia_sub(a.x,b.x),gia_sub(a.y,b.y),gia_sub(a.z,b.z));\n}\n\ngia1x3 gia_sub(gia1x3 a, vec3 b) {\n    return gia1x3(gia_sub(a.x,b.x),gia_sub(a.y,b.y),gia_sub(a.z,b.z));\n}\n\ngia1 gia_max(gia1 a, gia1 b) {\n    vec2 f0_f1min = ((a.f0 > b.f0)?vec2(a.f0, a.f1.x):vec2(b.f0, b.f1.x));\n    return gia1(f0_f1min[0], vec2((a.f0 == b.f0)?max(a.f1.x,b.f1.x):f0_f1min[1], max(a.f1.y, b.f1.y)));\n}\n\ngia1 gia_max(gia1 a, float b) {\n    vec2 f0_f1min = ((a.f0 > b)?vec2(a.f0, a.f1.x):vec2(b));\n    return gia1(f0_f1min[0], vec2((a.f0 == b)?max(a.f1.x,b):f0_f1min[1], max(a.f1.y, b)));\n}\n\ngia1x2 gia_max(gia1x2 a, gia1x2 b) {\n    return gia1x2(gia_max(a.x,b.x),gia_max(a.y,b.y));\n}\n\ngia1x2 gia_max(gia1x2 a, vec2 b) {\n    return gia1x2(gia_max(a.x,b.x),gia_max(a.y,b.y));\n}\n\ngia1x3 gia_max(gia1x3 a, gia1x3 b) {\n    return gia1x3(gia_max(a.x,b.x),gia_max(a.y,b.y),gia_max(a.z,b.z));\n}\n\ngia1x3 gia_max(gia1x3 a, vec3 b) {\n    return gia1x3(gia_max(a.x,b.x),gia_max(a.y,b.y),gia_max(a.z,b.z));\n}\n\ngia1 gia_min(gia1 a, gia1 b) {\n    return gia_neg(gia_max(gia_neg(a), gia_neg(b)));\n}\n\ngia1 gia_min(gia1 a, float b) {\n    return gia_neg(gia_max(gia_neg(a), -b));\n}\n\ngia1 gia_clamp(gia1 x, float mn, float mx) {\n    return gia_min(gia_max(x, mn), mx);\n}\n\ngia1 gia_abs(gia1 a) {\n    float f1min = (a.f0 > 0.0)?a.f1.x:-a.f1.y;\n    return gia1(abs(a.f0), vec2((a.f0 == 0.0)?max(a.f1.x,-a.f1.y):f1min, max(a.f1.y, -a.f1.x)));\n}\n\ngia1x3 gia_abs(gia1x3 a) {\n    return gia1x3(gia_abs(a.x),gia_abs(a.y),gia_abs(a.z));\n}\n\ngia1 gia_sign(gia1 a) {\n    // approximate hack. needs a clear head.\n    float s0 = sign(a.f0);\n    vec2 s1 = sign(a.f1);\n    if ((s0 == s1.x) && (s1.x == s1.y))\n        return gia1(s0, s1);\n    vec2 b = (s0 * a.f1 - abs(a.f1 - a.f0)) / a.f0;\n    b = (b.x < b.y)?b:b.yx;\n    return gia1(s0, ia_merge(b, vec2(min(s0,s1.x),max(s0,s1.y))));\n}\n\nvec2 minmax(vec3 f) {\n\treturn \n        vec2(min(min(f[0],f[1]),f[2]),\n            max(max(f[0],f[1]),f[2])); \n}\n\nvec2 minmax(vec4 f) {\n\treturn \n        vec2(min(min(f[0],f[1]),min(f[2],f[3])),\n            max(max(f[0],f[1]),max(f[2],f[3]))); \n}\n\ngia1 gia_mul(gia1 a, gia1 b) {\n    // bound f(1)\n    vec2 f1 = minmax(a.f1.xxyy * b.f1.xyxy);\n    // bound f'(0)\n    vec2 ff0 = minmax((b.f0*(a.f1 - a.f0)).xxyy + (a.f0*(b.f1 - b.f0)).xyxy);    \n\tfloat f0 = a.f0 * b.f0;\n    return gia1(f0, ia_merge(f0 + ff0, f1));\n}\n\ngia1 gia_mul(gia1 a, float b) {    \n    vec2 q = a.f1.xy * b;\n    return gia1(a.f0 * b, (b < 0.0)?q.yx:q);\n}\n\ngia1x2 gia_mul(gia1 a, vec2 b) {\n    return gia1x2(gia_mul(a, b.x), gia_mul(a, b.y));\n}\n\ngia1x3 gia_mul(gia1 a, vec3 b) {\n    return gia1x3(gia_mul(a, b.x), gia_mul(a, b.y), gia_mul(a, b.z));\n}\n\ngia1 gia_pow2(gia1 a) {\n    // bound f(1)\n    vec2 f1 = minmax(a.f1.xxy * a.f1.xyy);\n    // bound f'(0)\n    vec2 ff0a = a.f0*(a.f1 - a.f0);\n    vec2 ff0 = minmax(ff0a.xxy + ff0a.xyy);\n\tfloat f0 = a.f0 * a.f0;\n    return gia1(f0, ia_merge(f0 + ff0, f1));\n}\n\nfloat safeinv(float x) {\n    return (x == 0.0)?0.0:1.0/x;\n}\n\ngia1 gia_sqrt(gia1 a) {\n    float d = sqrt(a.f0);\n    vec2 ia_f = sqrt(max(vec2(0.0),a.f1));\n    vec2 ia_g = 0.5 * (a.f1 - a.f0) * safeinv(d);    \n    return gia1(d, ia_merge(ia_g + max(0.0, d), ia_f));\n}\n\ngia1 gia_dot(gia1x2 a) {\n    return gia_add(gia_pow2(a.x),gia_pow2(a.y));\n}\n\ngia1 gia_dot(gia1x3 a) {\n    return gia_add(gia_add(gia_pow2(a.x),gia_pow2(a.y)),gia_pow2(a.z));\n}\n\ngia1 gia_dot(gia1x2 a, vec2 b) {\n    return gia_add(gia_mul(a.x, b.x),gia_mul(a.y, b.y));\n}\n\ngia1 gia_length(gia1x2 v) {\n    return gia_sqrt(gia_dot(v));\n}\n\ngia1 gia_length(gia1x3 v) {\n    return gia_sqrt(gia_dot(v));\n}\n\ngia1 gia_mix (gia1 a, gia1 b, gia1 x) {\n    return gia_add(a, gia_mul(gia_sub(b,a),x));\n}\n\ngia1 gia_smin( gia1 a, gia1 b, float k ) {\n    gia1 h = gia_clamp(gia_add(gia_mul(gia_sub(b, a),0.5 / k),0.5), 0.0, 1.0 );\n    return gia_sub(gia_mix( b, a, h ), gia_mul(gia_mul(h, gia_add(gia_neg(h), 1.0)), k));\n}\n\n#define MAX_STEPS 50\n\n// undef to disable hole, then parameter s.w not needed\n// #define CONVEX\n\n// sdUberprim with precomputed constants\ngia1 sdUnterprim(gia1x3 p, vec4 s, vec3 r, vec2 ba, float sz2) {\n    gia1x3 d = gia_sub(gia_abs(p), s.xyz);\n    gia1 q = gia_sub(gia_add(gia_length(gia_max(gia1x2(d.x,d.y), vec2(0.0))), gia_min(gia_max(d.x,d.y),0.0)), r.x);\n    // hole support: without this line, all results are convex\n#ifndef CONVEX    \n    q = gia_sub(gia_abs(q), s.w);\n#endif\n    \n    gia1x2 pa = gia1x2(q, gia_sub(p.z, s.z));\n    gia1x2 diag = gia_sub(pa, gia_mul(gia_clamp(gia_dot(pa,ba), 0.0, 1.0), vec2(r.z,sz2)));\n    gia1x2 h0 = gia1x2(gia_max(gia_sub(q, r.z),0.0),gia_add(p.z, s.z));\n    gia1x2 h1 = gia1x2(gia_max(q,0.0),gia_sub(p.z, s.z));\n    \n    return gia_sub(gia_mul(gia_sqrt(gia_min(gia_dot(diag),gia_min(gia_dot(h0),gia_dot(h1)))),\n        gia_sign(gia_max(gia_dot(pa,vec2(-ba.y, ba.x)), d.z))), r.y);\n}\n\n// s: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\ngia1 sdUberprim(gia1x3 p, vec4 s, vec3 r) {\n    // these operations can be precomputed\n    s.xy -= r.x;\n#ifdef CONVEX  \n    r.x -= r.y;\n#else\n    r.x -= s.w;\n    s.w -= r.y;\n#endif\n    s.z -= r.y;\n    vec2 ba = vec2(r.z, -2.0*s.z);\n    return sdUnterprim(p, s, r, ba/dot(ba,ba), ba.y);\n}\n\n// example parameters\n#define SHAPE_COUNT 9.0\nvoid getfactor (int i, out vec4 s, out vec3 r) {\n    //i = 4;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec3(0.0);\n    } else if (i == 1) { // cylinder\n        s = vec4(1.0);\n        r = vec3(1.0,0.0,0.0);\n    } else if (i == 2) { // cone\n        s = vec4(0.0,0.0,1.0,1.0);\n        r = vec3(0.0,0.0,1.0);\n\t} else if (i == 3) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec3(1.0,1.0,0.0);\n    } else if (i == 4) { // sphere\n        s = vec4(1.0);\n        r = vec3(1.0,1.0,0.0);\n    } else if (i == 5) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec3(1.0,0.25,0.0);\n    } else if (i == 6) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec3(1.0,0.25,0.0);\n    } else if (i == 7) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec3(1.0,0.1,0.0);\n    } else if (i == 8) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec3(0.1,0.1,0.0);\n\t}\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\ngia1 doobject (gia1x3 p, float k) {\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,SHAPE_COUNT));\n    int s2 = int(mod(k+1.0,SHAPE_COUNT));\n    \n    vec4 sa,sb;\n    vec3 ra,rb;\n    getfactor(s1,sa,ra);\n    getfactor(s2,sb,rb);\n    \n    return sdUberprim(gia1x3(p.z,p.y,p.x), mix(sa,sb,u), mix(ra,rb,u));\n}\n\ngia1 doModel( gia1x3 p ) {\n    float k = iTime*0.5;\n    gia1 d = doobject(gia_sub(p, vec3(0.0,0.0,-0.5)), k);\n    gia1 d2 = doobject(gia_sub(p, vec3(0.0,0.0,0.5)), k + 1.0);\n    \n    return gia_smin(d, d2, 0.4);\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd, vec2 pixel, float bias, out int steps )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tfloat aperture = max(pixel.y,pixel.x) / sqrt(2.0);        // aperture of cone\n    float C = sqrt(aperture*aperture + 1.0);\n    // radius of sphere at t=1\n    float R = aperture/C;\n    // constant adjustment factor for t so that the cone sphere touches the distance radius\n    float A = C / (C + bias*aperture);\n    // for a better demo of how the above factors work, see https://www.shadertoy.com/view/4lfBWH\n    \n    float t = 0.0;\n\tfloat res = -1.0;\n    steps = 0;\n    float tc = (bias > 0.0)?0.0:1.0;\n    for( int i=0; i<MAX_STEPS; i++ ) {\n        steps = i;\n\t\tfloat limit = bias*R*t;\n        // add small bias to reduce iteration count\n        limit += 1e-03*t;        \n\t    float h = doModel( gia_const(ro+rd*t) ).f0;\n        t = (t + h)*A;\n    \tif((h <= limit) || (t > maxd)) {\n            break;\n        }\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nfloat calcIntersectionGIA( in vec3 ro, in vec3 rd, vec2 pixel, float bias, out int steps )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tfloat aperture = max(pixel.y,pixel.x) / sqrt(2.0);        // aperture of cone\n    float C = sqrt(aperture*aperture + 1.0);\n    // radius of sphere at t=1\n    float R = aperture/C;\n    // constant adjustment factor for t so that the cone sphere touches the distance radius\n    float A = C / (C + bias*aperture);\n    // for a better demo of how the above factors work, see https://www.shadertoy.com/view/4lfBWH\n    \n    const float E = 2.718282;\n    \n    float t = 0.0;\n    float td = 1.0 / (E*E);\n\tfloat res = -1.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        //float x = float(i)/float(N);\n        steps = i;\n\t\tfloat limit = bias*R*t;\n        // add small bias to reduce iteration count\n        limit += 1e-03*t;                \n        gia1 g = doModel(gia_add(gia_mul(gia1(t, vec2(t + td)),rd),ro));\n    \tif((g.f0 <= limit) || (t > maxd)) {\n            break;\n        }\n        float stepsz = max(td / (g.f0 + max(0.0, -g.f1.x)), 1.0);\n        t += stepsz * g.f0;\n    }\n    \n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( gia_const(pos + v1*eps) ).f0 + \n\t\t\t\t\t  v2*doModel( gia_const(pos + v2*eps) ).f0 + \n\t\t\t\t\t  v3*doModel( gia_const(pos + v3*eps) ).f0 + \n\t\t\t\t\t  v4*doModel( gia_const(pos + v4*eps) ).f0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool dorender( out float dist, out int steps, out vec3 position, in vec2 fragCoord, in vec2 resolution, in float bias)\n{\n    vec2 p = (-resolution.xy + 2.0*fragCoord.xy)/resolution.y;\n    vec2 m = (-resolution.xy + 2.0*iMouse.xy)/resolution.y;\n\n    //-----------------------------------------------------\n    // camera1\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n    float w = (iMouse.z > 0.5)?m.x:0.0;\n\n\t// raymarch\n    float t;\n    if (p.x < w) {\n        t = calcIntersection( ro, rd, 1.0 / resolution, bias, steps );\n    } else {\n        t = calcIntersectionGIA( ro, rd, 1.0 / resolution, bias, steps );\n    }    \n    dist = t;\n    if( t>-0.5 )\n    {\n        // geometry\n        position = ro + t*rd;\n        return true;\n\t}\n    return false;\n}\n\nvec3 hue2rgb (float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue (float n)  {\n    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float dist;\n    float dist_inner;\n    float dist_outer;    \n    \n    vec2 resolution = iResolution.xy;\n    vec3 pos;\n    int steps;\n    bool hit = dorender(dist, steps, pos, fragCoord, resolution, 1.0);\n\n    fragColor = vec4(vec3(0.0),1.0);\n#if 0\n    if (hit) {\n        vec3 nor = calcNormal(pos);\n        fragColor = vec4((nor*0.5+0.5)*0.5,1.0);\n    }   \n#else\n    vec3 c2 = normhue(float(steps)/float(MAX_STEPS));\n    ivec3 p = ivec3(pos*10.0);\n    c2 = mix(c2, vec3(float((p.x ^ p.y ^ p.z) % 3)/2.0), 0.1);\n    \n    fragColor = vec4(c2,1.0);\n#endif\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 343, 368, 368, 399], [401, 401, 427, 427, 496], [498, 498, 520, 520, 556], [558, 558, 581, 581, 618], [620, 620, 651, 651, 700], [702, 702, 732, 732, 777], [779, 779, 810, 810, 849], [851, 851, 885, 885, 963], [965, 965, 995, 995, 1043], [1045, 1045, 1076, 1076, 1118], [1120, 1120, 1151, 1151, 1190], [1192, 1192, 1228, 1228, 1284], [1286, 1286, 1322, 1322, 1395], [1397, 1397, 1431, 1431, 1504], [1506, 1506, 1536, 1536, 1717], [1719, 1719, 1750, 1750, 1904], [1906, 1906, 1942, 1942, 1998], [2000, 2000, 2034, 2034, 2090], [2092, 2092, 2128, 2128, 2201], [2203, 2203, 2237, 2237, 2310], [2312, 2312, 2342, 2342, 2397], [2399, 2399, 2430, 2430, 2477], [2479, 2479, 2523, 2523, 2565], [2567, 2567, 2589, 2589, 2735], [2737, 2737, 2763, 2763, 2824], [2826, 2826, 2849, 2894, 3165], [3167, 3167, 3188, 3188, 3278], [3280, 3280, 3301, 3301, 3411], [3413, 3413, 3443, 3461, 3679], [3681, 3681, 3712, 3712, 3789], [3791, 3791, 3823, 3823, 3878], [3880, 3880, 3912, 3912, 3984], [3986, 3986, 4009, 4027, 4241], [4243, 4243, 4267, 4267, 4302], [4304, 4304, 4327, 4327, 4508], [4510, 4510, 4534, 4534, 4585], [4587, 4587, 4611, 4611, 4685], [4687, 4687, 4719, 4719, 4778], [4780, 4780, 4807, 4807, 4842], [4844, 4844, 4871, 4871, 4906], [4908, 4908, 4947, 4947, 4997], [4999, 4999, 5041, 5041, 5213], [5312, 5353, 5417, 5417, 6143], [6145, 6245, 6288, 6331, 6532], [6580, 6580, 6628, 6641, 7499], [7501, 7501, 7584, 7584, 7707], [7709, 7709, 7736, 7736, 7771], [7773, 7809, 7850, 7850, 7943], [7945, 7945, 7980, 7980, 8290], [8292, 8292, 8318, 8318, 8505], [8507, 8507, 8596, 8596, 9519], [9521, 9521, 9613, 9613, 10699], [10701, 10701, 10733, 10733, 11200], [11202, 11202, 11266, 11266, 11444], [11446, 11446, 11566, 11566, 12653], [12655, 12655, 12681, 12681, 12766], [12768, 12816, 12841, 12841, 12899], [12902, 12902, 12958, 12958, 13516]], "test": "untested"}
{"id": "ssB3Dm", "name": "Wavy Water", "author": "Protowalker", "description": "learning fragment shaders and tried to create water ripples", "tags": ["water", "bad"], "likes": 1, "viewed": 288, "published": 3, "date": "1617486880", "time_retrieved": "2024-07-30T19:28:48.949609", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if(uv.y > 0.51){\n        fragColor = texture(iChannel0, vec2(-1,1) * (vec2(0, 1) - uv));\n        return;\n    }\n    if(uv.y > 0.49) {\n        fragColor = vec4(1.0);\n        return;\n    }\n\n\n    float factor = sin(iTime + uv.x*50.0*sin(uv.x+iTime/80.0));\n    // Time varying pixel color\n    vec2 offset = vec2(factor, 0.0)*(uv+factor);\n    offset.x += cos(iTime + uv.y);\n    \n    \n    \n    offset = offset/100.0;\n    \n    \n    fragColor = texture(iChannel0, uv + offset);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssB3Dm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 623]], "test": "untested"}
{"id": "ssSGDm", "name": "fake pool", "author": "jorge2017a1", "description": "fake pool", "tags": ["fakepool"], "likes": 10, "viewed": 244, "published": 3, "date": "1617484714", "time_retrieved": "2024-07-30T19:28:49.918020", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opI2(d1, d2) ( d1.x > d2.x ? d1 : d2 )\n#define opS2(d1, d2) ( d1.x > -d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    \n    \n    res =opU3(res, vec3(planeDist2,14.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist4,100.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist5,100. ,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist6,16.0,MATERIAL_NO)); \n  \n  \n    p.y=p.y-5.0;\n    float sdb1= sdBox(p-vec3(0.0,-1.0,0.0), vec3(15.0,1.0,20.0));\n    float sdsp1= sdSphere( p- vec3(0.0,5.0,0.0), 2.0);\n    float sdsp2= sdSphere( p- vec3(-8.0,3.0,0.0), 2.0);\n    \n    \n     float posx=-6.5; //es el centro del objeto\n     float posz=10.0;\n     vec3 pp1=p-vec3(posx,0.0,posz);\n     pp1.xz = rotatev2(pp1.xz, iTime);\n     pp1.xy = rotatev2(pp1.xy, iTime);\n     pp1.x=pp1.x+posx;\n\n    float sdb2=  sdRoundBox( pp1-vec3(posx,8.0,0.0), vec3(2.0,1.0,2.0), 1.0 ); //3 in\n    \n    \n     posx=6.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xz = rotatev2(pp.xz, iTime);\n     pp.x=pp.x+posx;\n \n    float sdb3=  sdRoundBox( pp-vec3(posx,3.5,0.0), vec3(2.0,1.0,2.0), 1.0 ); //3 in\n    res =opU3(res, vec3(sdb1,201.0, MATERIAL_NO));   \n    res =opU3(res, vec3(sdb2,3.0, MATERIAL_NO));   \n    res =opU3(res, vec3(sdsp1,2.0,MATERIAL_NO));   \n    res =opU3(res, vec3(sdsp2,201.0,MATERIAL_NO));   \n    res =opU3(res, vec3(sdb3,4.0,MATERIAL_NO));   \n    \n    \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= MAX_STEPS; i++) \n    {  \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == MAX_STEPS)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false;    minDist = dO;    break; } \n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); \n    return col*2.0;\n    }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\nvec3 renderReflect(TObj Obj, vec3 ro, vec3 rd, vec3 col )\n{\n   vec3 p;\n   float t;\n   vec3 colobj;  vec3 n;\n    \n\n  /////-----------REFLECT--------------\n    if (int( Obj.id_color) ==201)\n    {\n       \n     vec3 colref;\n     for(int i=0; i<2; ++i)\n      {\n        t=RayMarch(ro,rd);\n        Obj=mObj;\n        \n        if(t>=MAX_DIST) return col;\n        if( t<0.0 || t>MAX_DIST ) break;\n        p=ro+rd*t;\n        \n        n=GetNormal(p);\n        //produce ondas de mar\n        n=normalize(n+0.01*sin(10.0* p+2.0*iTime));\n        \n        rd=reflect(rd,n);\n        ro =p+rd * MIN_DIST * 3.;\n        \n        colobj=GetColorYMaterial( p, n, ro, rd,  int( Obj.id_color), Obj.id_material)*2.0;\n        colref=  Getluz( p,ro,rd, n, colobj ,light_pos1);\n        colref+= Getluz( p,ro,rd, n, colobj ,light_pos2);\n        colref/=1.25;\n     }\n     col+=colref/(float(REFLECT)+0.5);\n     \n   } \n   \n   return col;\n} \n\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n\n   float d = RayMarch(ro, rd);\n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        vec3 p = (ro + rd * d ); \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result/=1.25;\n        col= result*dif1;\n\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n        col = pow(col, vec3(1.0/2.2));\n    \n    }\n     \n    col= renderReflect(Obj,  ro,  rd,  col );\n   \n   return col;\n}    \n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 3.0, 5.0 );  light_color1 =1.25*vec3( 1.0 ,0.1,0.1);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =1.25* vec3( .1 ,0.1,1.0); //light_color1; //vec3( 1.0, 1.0, 1.0 );\n \n    //vec3 ro=vec3(4.0,2.0,-25.0+t);\n    vec3 ro=vec3(0.0,15.0,-20.0);\n    vec3 rd=normalize(vec3(uv,1.0));\n    rd= rotate_x(rd, radians(20.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.) //31\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSGDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[578, 578, 614, 614, 635], [636, 636, 668, 668, 752], [753, 753, 799, 799, 886], [888, 932, 979, 979, 1006], [1008, 1008, 1051, 1051, 1078], [1080, 1080, 1128, 1128, 1156], [1204, 1229, 1263, 1263, 1361], [1362, 1362, 1396, 1396, 1488], [1489, 1489, 1523, 1523, 1615], [1616, 1656, 1690, 1690, 1787], [1788, 1828, 1853, 1853, 3655], [3658, 3658, 3723, 3723, 4307], [4309, 4360, 4384, 4384, 4572], [4576, 4576, 4609, 4609, 5320], [5322, 5376, 5412, 5412, 5646], [5703, 5703, 5752, 5752, 6005], [6006, 6040, 6120, 6120, 6397], [6399, 6450, 6497, 6497, 6707], [6761, 6761, 6854, 6854, 7276], [8192, 8192, 8223, 8223, 9050], [9057, 9106, 9163, 9163, 9803]], "test": "untested"}
{"id": "sdSGDm", "name": "Shimmering Sea", "author": "jarble", "description": "This fractal animation looks like ocean waves.", "tags": ["fractal", "waves", "sea", "water", "ocean"], "likes": 3, "viewed": 306, "published": 3, "date": "1617483596", "time_retrieved": "2024-07-30T19:28:50.726857", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    //uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.5;\n        float scale1 = 1.4;\n        float s1 = scale1*scale;\n        for(int i=0;i<6;i++)\n        {\n            uv += uv.yy;\n            uv = fract((uv+iTime)/s1)*s1;\n            uv=-fract(uv/(3.0-abs((uv.x-uv.y)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            uv.x *= -(1.0+col.x/scale);\n            col[c] = fract((((1.0+col.y)*.125)*(col.x+uv.y-uv.x))/2.25);\n        }\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSGDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 779]], "test": "untested"}
{"id": "7djGDD", "name": "Showdown Revision 2021 Final", "author": "Pixdigit", "description": "Whenever I watch a shader showdown I try to code a shader alongside to see what I manage to do. I also later decided to make a revised version which you can find on my profile.", "tags": ["circles", "tiling"], "likes": 1, "viewed": 172, "published": 3, "date": "1617482365", "time_retrieved": "2024-07-30T19:28:51.542676", "image_code": "mat2 rot(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat2(\n\t\tc, -s,\n\t\ts, c\n\t);\n}\n\nfloat rand(vec2 seed) {\n    return sin(dot(seed, seed + vec2(2., 546.345))) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float scale = 10.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    vec2 orig = (uv + vec2(sin(iTime), cos(iTime)) * 0.4);\n    vec2 cam = orig * rot(iTime / 2.) * scale;\n    vec2 guv = fract(cam);\n    vec2 gid = floor(cam);\n\n    vec3 col = vec3(0);\n    if (length(guv - 0.5) < sin(iTime + 1. - length(cam)) / 4. + 0.25) {\n        float ripples = 0.2;\n        col = vec3(abs(ripples / 2. - mod(abs(length(guv - 0.5) - iTime * 0.2), ripples)) / ripples);\n    }\n\n    // Time varying pixel color\n    col *= 0.5 +rand(vec2(floor(iTime * 2. + rand(gid)), 1.))*cos(iTime+gid.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 106], [108, 108, 131, 131, 198], [200, 200, 257, 257, 960]], "test": "untested"}
{"id": "sdS3Wm", "name": "The Internets", "author": "tungster24", "description": "idk man, one-liner!", "tags": ["colors", "rainbow", "trippy", "lsd", "lsd", "hyperbola"], "likes": 1, "viewed": 243, "published": 3, "date": "1617481840", "time_retrieved": "2024-07-30T19:28:52.312618", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord){vec2 p=fragCoord/iResolution.xy;float x=(p.x-0.5)*16.0;float y=(p.y-0.5)*9.0;float mx=5.0*(iMouse.x)/float(iResolution.x);float my=5.0*iMouse.y/float(iResolution.y);float x1=2.0;float y1=3.0;for (int i=1;i<=4;i++){x1=sin(y*(x+mx)+my+iTime);y1=sin(x*(y+my)+mx+iTime);x=x1;y=y1;}float c=sin((x+y+iTime)*3.0);fragColor=vec4(c,sin(c+iTime),sin(c+iTime*2.0),1.0);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 412]], "test": "untested"}
{"id": "ssSGWm", "name": "April Fool's 2021", "author": "morisil", "description": "joke for https://www.twitch.tv/sableraph\n\nRemember to turn on the sound on Buffer A video :) Let Van Damme speak. His round kicks produce beautiful Lissajous curves.\n", "tags": ["joke"], "likes": 2, "viewed": 327, "published": 3, "date": "1617481537", "time_retrieved": "2024-07-30T19:28:53.191268", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = (2.* fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 vanDammeUv = clamp(\n        abs(\n            st\n            * iResolution.yx / iResolution.x\n        ),\n        0., 1.\n    );\n\tvec3 vanDammeTexture = texture(iChannel0, vanDammeUv).rgb;\n    vec4 vanDammeColor = greenScreen(vanDammeTexture);\n    vec3 previousColor = texture(iChannel1, uv).rgb;\n    \n    fragColor = vec4(\n        mix(vanDammeColor.rgb, previousColor, vanDammeColor.a),\n        1.0\n    );\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 greenScreen(vec3 texel) {\n    float maxrb = max( texel.r, texel.b );\n    float k = clamp((texel.g - maxrb) * 5.0, 0.0, 1.0);\n\tfloat ll = length(texel);\n    texel.g = min(texel.g, maxrb * 0.8);\n    texel = ll * normalize(texel);\n    return clamp(vec4(texel, k), 0., 1.);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 140]], "test": "untested"}
{"id": "7sSGWm", "name": "Distance to Curved Tube", "author": "oneshade", "description": "Now its an SDF too.", "tags": ["3d", "raymarching", "sdf", "distance", "tube", "cubic", "curved"], "likes": 5, "viewed": 163, "published": 3, "date": "1617481206", "time_retrieved": "2024-07-30T19:28:54.245449", "image_code": "float sdCurvedTube(in vec3 p, in float bend, in float height, in float radius, in float thickness) {\n    vec2 pr = vec2(abs(p.y), length(p.xz) - radius);\n\n    float a = 4.0 * bend * bend;\n    float c = 2.0 - 4.0 * bend * pr.y;\n    float d = -2.0 * pr.x;\n\n    vec2 pq = vec2(c, d) / a;\n    float p2 = abs(pq.x);\n    float v1 = 1.5 / pq.x * pq.y;\n\n    if (pq.y * pq.y * 0.25 + pq.x * pq.x * pq.x / 27.0 > 0.0) {\n        float root, v2 = v1 * sqrt(3.0 / p2);\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(v2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(v2) / 3.0);\n        float x = min(-2.0 * sqrt(p2 / 3.0) * root, height);\n        return length(pr - vec2(x, bend * x * x)) - thickness;\n    }\n\n    else {\n        float x = min(2.0 * sqrt(-pq.x / 3.0) * cos(acos(v1 * sqrt(-3.0 / pq.x)) / 3.0), height);\n        return length(pr - vec2(x, bend * x * x)) - thickness;\n    }\n}\n\nfloat mapScene(in vec3 p) {\n    return sdCurvedTube(p, 0.25 + 0.2 * cos(iTime), 2.0, 1.5 + 0.5 * sin(iTime), 0.1);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    // Raymarch\n    float t = 0.0;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            float diff = sqrt(max(0.0, dot(-rd, n)));\n            fragColor.rgb = vec3(diff);\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n\n    // Ground plane\n    if (rd.y != 0.0) {\n        float tPlane = -(2.0 + ro.y) / rd.y;\n        if (tPlane > 0.0 && (t < 20.0 ? tPlane < t : true)) {\n            vec3 iPlane = ro + rd * tPlane;\n            vec3 planeColor = vec3(1.0);\n\n            // Grid\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.x + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.z + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.x) - 0.01));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.z) - 0.01));\n\n            planeColor -= 0.8 * exp(-mapScene(iPlane));\n            planeColor /= max(1.0, 0.2 * tPlane); // Fade (can hide a bit of aliasing too)\n\n            fragColor.rgb = mix(fragColor.rgb, planeColor, 0.6);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 100, 100, 890], [892, 892, 919, 919, 1008], [1010, 1010, 1037, 1037, 1284], [1286, 1286, 1341, 1341, 3316]], "test": "untested"}
{"id": "fdS3Ww", "name": "Lens Flare Fun", "author": "account", "description": "Attempt at a lens flare", "tags": ["experimentation", "lensflare"], "likes": 25, "viewed": 1209, "published": 3, "date": "1617475775", "time_retrieved": "2024-07-30T19:28:55.013396", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    vec3 rad;\n    \n    vec2 offset2 = iResolution.xy/2.0 - fragCoord.xy;\n    for(int i = 0; i < 20; i++){\n       vec2 offset = fragCoord + offset2*smoothstep(0.,4.- length(uv*2.0-1.0)*2., float(i+1)/20.);\n       rad.x += texture(iChannel0, offset/iResolution.xy).x;\n       rad.y += texture(iChannel0, (offset+vec2(5.1))/iResolution.xy).y;\n       rad.z += texture(iChannel0, (offset-vec2(10.1))/iResolution.xy).z;\n\n    }\n    rad /= 16.;\n    \n    rad = pow(rad, vec3(1.)/vec3(1.3,1.,1.3));\n    //rad = pow(rad, vec3(1.)/2.2);\n    fragColor = vec4(rad,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float ring(vec2 p, vec2 pos, float r1, float r2){\nvec2 a = normalize(p-pos);\nreturn length((pos+a*r1)-p)-r2;\n}\n\n\nconst float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nfloat l = length(a);\na/=l;\nfloat ang = (a.y < 0.)?2.0*pi - acos(a.x):acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\nvec3 lensflare(vec2 uv, vec2 mouse){\n//vec2 mouse = iMouse.xy / iResolution.xy;\n    //mouse = mouse * 2.0 - 1.0;\n    \n    vec3 col = vec3(0.);\n    float dist = length(mouse-uv);\n    vec2 pos = normalize(uv - mouse);\n   \n    //col = pow(col, vec3(1.0/2.2));\n    //col += pow(1.0-dist, texture(iChannel0, fragCoord/iResolution.xy).x)*0.1;\n    dist = length(mouse-uv);\n    vec2 mouse2 = normalize(mouse);\n    float ang = (mouse2.y < 0.)?2.0*pi - acos(mouse2.x):acos(mouse2.x);\n   // col += clamp(vec3(0.9,0.7,0.2)*(1.0-dist*0.9)*texture(iChannel0, rot(pos*0.06, -ang)).x,0.0,1.);\n   col += sin(texture(iChannel0, rot(pos*0.06, -ang)).x)\n   *cos(texture(iChannel0, rot(pos*0.04, -ang)).x)*0.2;\n   \n   col += clamp(vec3(2.)-clamp(dist*1.5,0.,1.)*2.1,0.,1.)*vec3(0.9,0.7,0.2);\n    \n   \n    dist = length(-mouse-uv)-0.05;\n    //col += smoothstep(max(dist, -dist+0.15),0.2, length(-mouse-uv));\n    col += (2.0-length(mouse-uv)-0.04)*vec3(0.9,0.6,0.2);\n    //dist = length(-mouse*0.5-uv)-0.001;\n    float rin = ring(uv, -mouse, 0.2, 0.05);\n    //if(rin < 0.01){\n      col += clamp(3.0-rin*2.,-0.4,0.4);\n    //}\n    col += clamp(vec3(1.)-clamp(dist*dist*dist+dist*1.5,0.,1.)*2.1,0.,1.)*\n    (vec3(length(mouse-uv), 1.0-length(-mouse-uv),0.2 ));\n    dist = length(-mouse*0.2-uv)-0.001;\n    col += clamp(vec3(1.)-clamp(dist*1.5,0.,1.)*4.,0.,1.)*vec3(0.9,0.6,0.3);\n    dist = length(-mouse*0.6-uv)-0.001;\n    col += clamp(vec3(3.)-clamp(dist*2.5,0.,1.)*4.,0.,1.)*vec3(0.9,0.6,0.3);\n    \n    dist = length(-mouse*0.5-uv)-0.4;\n    col += clamp(vec3(3.)-dist*dist*dist+dist*1.5,0.,1.)*vec3(0.9,0.6,0.2);\n    //col -= length(mouse-uv);\n\n    col += clamp(vec3(0.9, 0.7, 0.2)-ring(uv, mouse, 0.1,0.04)*2.-0.1,0.,1.);\n    col += clamp(1.0-ring(uv, -mouse*0.1, 0.2, 0.05)*2.,0.,1.)*0.8*vec3(0.9,0.7,0.7);  \n  \n    col/=2.0;\n    col = clamp(col, 0., 1.);\n    return col;\n}\n\n//From https://www.shadertoy.com/view/4tl3z4\n//==========================================\nfloat hash1(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2(inout float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n//==========================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    uv *= 12.0;\n    //vec3 col = lensflare(uv);\n    vec3 col;\n    vec2 p = fragCoord/iResolution.xy;\n    float seed = 3.43121412313;\n\n    \n    for(int i = 0; i < 20; i++){\n       vec2 pos = hash2(seed)*2.0-1.;\n       pos*=8.0;\n       float strength = hash1(seed);\n       col += lensflare(uv/4., (rot(pos,iTime*0.5))*vec2(cos(iTime*0.5), sin(iTime*0.5)))*strength*1.;   \n       seed += float(i+1);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdS3Ww.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 709]], "test": "untested"}
{"id": "7s23DD", "name": "Tastey Eggies", "author": "blackle", "description": "shader showdown @ revision 2021 winner :3", "tags": ["revision", "eggs", "shadershowdown", "livecode", "revision2021"], "likes": 35, "viewed": 868, "published": 3, "date": "1617465838", "time_retrieved": "2024-07-30T19:28:55.815252", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat time;\nfloat bar;\nfloat bpm = 130.;\n\n//in the showdown I added cut eggs, but tbh I don't like how it looks, so you can enable it by uncommenting the next line\n#define DISABLE_CUT\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n  int x = FK(a), y = FK(b);\n  return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nvec3 rndcol(float hs) {\n  float h = hash(hs, 420.);\n  if (h > .5) {\n    return vec3(.9,.8,.4);\n  }\n  if (h > .0) {\n    return vec3(.4,.8,.4);\n  }\n  if (h > -.5) {\n    return vec3(.4,.8,.9);\n  }\n  return vec3(.9,.3,.8);\n}\n\nfloat super(vec2 p, float k) {\n  return mix(length(p), sqrt(length(p*p)), k);\n}\n\nvec3 pattern(vec2 p, float hs) {\n  vec2 op = p;\n  if (hash(hs,399.)<0.) {\n    p.y += asin(sin(p.x*40.))/40.;\n  }\n  if (hash(hs,342.)<0.) {\n    p.y = abs(p.y)-.2;\n  }\n  if (hash(hs,934.)<0.) {\n    p.y = -p.y;\n  }\n  if (p.y < 0.) {\n    return rndcol(hash(hs,453.));\n  }\n  if (p.y > 0.) {\n    op = asin(sin(op*30.))/30.;\n    if (hash(hs,666.)<0. && super(op,hash(hs,777.)*4.-2.) < .015) {\n      return  rndcol(hash(hs,339.));\n    }\n  }\n  return vec3(1);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\nvec3 rndrot(vec3 p, float sd) {\n  float h1 = hash(sd, 43432.);\n  float h2 = hash(sd, 34332.);\n  float h3 = hash(sd, 12356.);\n  return erot(p, normalize(tan(vec3(h1,h2,h3))), h1*100.+iTime*2.);\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smiley;\nfloat egg(vec3 p, bool chopp) {\n  float eg = mix( linedist(vec2( sqrt(dot(p.xy,p.xy)+.2) -.1, p.z), vec2(-.3,.5), vec2(0,-.5)  )-.9,length(p)-1.,.3 );\n  eg = abs(eg+.01)-.02;\n#ifndef DISABLE_CUT\n  if (chopp) {\n    eg = max(eg, p.z);\n  }\n#endif\n    smiley  = length(p+vec3(cos(time*9.)*.2,sin(time*9.)*.2,sin(time*4.)*.5))-.4;\n  return min(eg,smiley);\n}\n\nvec3 glob;\nfloat idx;\nfloat scene(vec3 p) {\n  idx = round(p.y/3.)*3.;\n  bool willchop = false;\n  if (hash(bar,2313.) < 0.) {\n    idx = 0.;\n    willchop = true;\n  }\n  p.y -= idx;\n  if (hash(bar,1312.) < .0) {\n    p.x += sin(time*2.+idx);\n  } else {\n    p.z += -abs(sin(time*3.1415+idx*.1))+.5;\n  }\n  p = rndrot(p, bar+idx*100.);\n  glob = p;\n  return egg(p, willchop);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n//candy!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  time = fract(iTime*bpm/120.);\n  bar = floor(iTime*bpm/120.);\n  vec2 uv2 = uv;\n  \n  if (hash(bar,7434.) < 0.) {\n    uv2.y += sin(uv.x*8.+time)*.05;\n  }\n  fragColor.xyz = pattern(uv2,bar);\n  \n  \n  vec3 cam = normalize(vec3(1,uv));\n  vec3 init = vec3(-5,0,0);\n  \n  if (hash(bar,2341.) < 0.) {\n    cam = erot(cam, vec3(0,1,0), radians(45.));\n    init = erot(init, vec3(0,1,0), radians(45.));\n  }\n  \n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  for (int i = 0; i < 100 && !hit; i++) {\n    dist = scene(p);\n    hit = dist*dist < 1e-6;\n    p += dist*cam;\n    if (distance(p,init)>10.)break;\n  }\n  \n  \n  if (hit) {\n    bool issmiley = smiley == dist;\n    float rix = idx;\n    vec3 loc = glob;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float spec = length(sin(r*3.)*.5+.5)/sqrt(3.);\n    float fres = 1. - abs(dot(cam,n))*.98;\n    float diff = length(sin(n*2.)*.3+.7)/sqrt(3.);\n    vec2 crds = vec2(atan(loc.x,loc.y)*.8,loc.z);\n    vec3 dcol = pattern(crds/3., bar+2392.+rix*100.);\n    if (issmiley) {\n      dcol = rndcol(3485.+bar);\n    }\n    vec3 col = dcol*diff + pow(spec,7.)*fres;\n    fragColor.xyz = col;\n  }\n  \n  fragColor.xyz = sqrt(fragColor.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s23DD.jpg", "access": "api", "license": "cc0-1.0", "functions": [[434, 434, 464, 464, 536], [538, 538, 561, 561, 758], [760, 760, 790, 790, 839], [841, 841, 873, 873, 1293], [1295, 1295, 1333, 1333, 1393], [1394, 1394, 1425, 1425, 1588], [1590, 1590, 1630, 1630, 1717], [1733, 1733, 1764, 1764, 2085], [2109, 2109, 2130, 2130, 2455], [2457, 2457, 2476, 2476, 2592], [2603, 2603, 2660, 2710, 3942]], "test": "untested"}
{"id": "sdj3DD", "name": "ShSh revision 2021 final revised", "author": "Pixdigit", "description": "Whenever I watch a shader showdown I try to code a shader alongside to see what I manage to do. I made some changes after the deadline because I was unhappy with some aspects.", "tags": ["circles", "tiling"], "likes": 1, "viewed": 197, "published": 3, "date": "1617465098", "time_retrieved": "2024-07-30T19:28:56.583199", "image_code": "mat2 rot(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat2(\n\t\tc, -s,\n\t\ts, c\n\t);\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float scale = 10.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    vec2 orig = (uv + vec2(sin(iTime), cos(iTime)) * 0.4);\n    vec2 cam = orig * rot(iTime / 2.) * scale;\n    vec2 guv = fract(cam);\n    vec2 gid = floor(cam);\n\n    vec3 col = vec3(0);\n    \n    float minn = 0.1;\n    float maxx = 0.43;\n    float border = (sin(iTime - length(gid)) + 1.) / 2. * (maxx - minn) + minn;\n    float ripples = 1.;\n    float intense = abs(ripples / 2. - mod(abs(length(guv - 0.5) - iTime * 0.2 + rand(gid)), ripples)) / ripples;\n    col = vec3(smoothstep(0., .3, intense) * smoothstep(border + .1, border, length(guv - .5)));\n\n\n    // Time varying pixel color\n    col *= 0.5 +rand(vec2(floor(iTime * 2.))+gid) / 2. * cos(gid.xyx+vec3(0,2,4) + vec3(floor(iTime * 2.)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdj3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 106], [108, 108, 128, 128, 198], [200, 200, 257, 257, 1131]], "test": "untested"}
{"id": "WlGfzD", "name": "Translucent Glow Effect", "author": "oneshade", "description": "Messing with lighting effects on tdhooper's head model (I forgot about this for a while :D): [url=https://www.shadertoy.com/view/wlf3WX]https://www.shadertoy.com/view/wlf3WX[/url]", "tags": ["light", "effect", "glow", "head", "translucence"], "likes": 21, "viewed": 440, "published": 3, "date": "1617462667", "time_retrieved": "2024-07-30T19:28:57.537648", "image_code": "#define translucence 0.8\n\nstruct Light {\n    vec3 pos; // Position of the light\n    vec3 col; // Color of the light\n    float Kc; // Constant attenuation term\n    float Kl; // Linear attenuation term\n    float Kq; // Quadratic attenuation term\n};\n\nvec3 getIllumination(in vec3 p, in Light light) {\n    float d = length(p - light.pos);\n    float b = 1.0 / (light.Kc + light.Kl * d + light.Kq * d * d);\n    return light.col * b;\n}\n\nmat2 Rotate(in float a) {\n    float rad = radians(a);\n    float c = cos(rad), s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\n#define brightness 0.75\n#define light Light(vec3(0.0), vec3(2.0, 1.6, 0.0) * brightness, 1.0, 0.0, 0.5)\n\nfloat mapScene(in vec3 p) {\n    vec3 q1 = abs(p) - 2.5;\n    float box = max(abs(max(q1.x, max(q1.y, q1.z))) - 0.05, p.z - 2.0);\n\n    p.xz *= Rotate(cos(iTime * 0.25) * 50.0);\n    float head = all(lessThan(abs(p), vec3(2.0))) ? mHead(p / 2.5) * 2.5 : max(abs(p.x), max(abs(p.y), abs(p.z))) - 1.9;\n    return min(box, head);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n\n            vec3 l = normalize(light.pos - p);\n            vec3 illum = getIllumination(p, light);\n            fragColor.rgb += mix(illum * max(0.0, dot(n, -rd)), illum, translucence);\n\n            break;\n        }\n\n        float ld = length(p - light.pos) - 0.05;\n        if (ld < 0.001) {\n            fragColor.rgb = light.col;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += min(d, ld);\n    }\n}", "image_inputs": [], "common_code": "// \"Head\" by tdhooper: https://www.shadertoy.com/view/wlf3WX\n// License: Creative Commons Attribution-NonCommercial\n// https://creativecommons.org/licenses/by-nc/4.0/\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pRi(vec2 p, float a) {\n    pR(p, a);\n    return p;\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner2(vec2 p) {\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat fDisc(vec3 p, float r) {\n    float l = length(p.xz) - r;\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// IQ https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\n\nfloat ellip(vec3 p, vec3 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nbool isEye = false;\n\n\nfloat mHead(vec3 p) {\n\n    pR(p.yz, -.1);\n    p.y -= .11;\n\n    vec3 pa = p;\n    vec3 ps = p;\n    ps.x = sqrt(ps.x * ps.x + .0005);\n    p.x = abs(p.x);\n    vec3 pp = p;\n\n    float d = 1e12;\n\n    // skull back\n    p += vec3(0,-.135,.09);\n    d = ellip(p, vec3(.395, .385, .395));\n\n    // skull base\n    p = pp;\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\n\n    // forehead\n    p = pp;\n    p += vec3(0,-.145,-.175);\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\n\n    p = pp;\n    pR(p.yz, -.5);\n    float bb = fBox(p, vec3(.5,.67,.7));\n    d = smax(d, bb, .2);\n\n    // face base\n    p = pp;\n    p += vec3(0,.25,-.13);\n    d = smin(d, length(p) - .28, .1);\n\n    // behind ear\n    p = ps;\n    p += vec3(-.15,.13,.06);\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\n\n    p = ps;\n    p += vec3(-.07,.18,.1);\n    d = smin(d, length(p) - .2, .18);\n\n    // cheek base\n    p = pp;\n    p += vec3(-.2,.12,-.14);\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\n\n    // jaw base\n    p = pp;\n    p += vec3(0,.475,-.16);\n    pR(p.yz, .8);\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\n    \n    // brow\n    p = pp;\n    p += vec3(0,-.0,-.18);\n    vec3 bp = p;\n    float brow = length(p) - .36;\n    p.x -= .37;\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\n    p = bp;\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\n    p = bp;\n    pR(p.yz, -.5);\n    float peak = -p.y - .165;\n    peak += smoothstep(.0, .2, p.x) * .01;\n    peak -= smoothstep(.12, .29, p.x) * .025;\n    brow = smax(brow, peak, .07);\n    p = bp;\n    pR(p.yz, .5);\n    brow = smax(brow, -p.y - .06, .15);\n    d = smin(d, brow, .06);\n\n    // jaw\n\n    vec3 jo = vec3(-.25,.4,-.07);\n    p = ps + jo;\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\n\n    p = pp;\n    p += vec3(0,.63,-.2);\n    pR(p.yz, .15);\n    float cr = .5;\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\n\n    p = pp + jo;\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\n\n    p = pa;\n    p += vec3(.2,.5,-.1);\n    float jb = length(p);\n    jb = smoothstep(.0, .4, jb);\n    float js = mix(0., -.005, jb);\n    jb = mix(.01, .04, jb);\n\n    d = smin(d, jaw - js, jb);\n\n    // chin\n    p = pp;\n    p += vec3(0,.585,-.395);\n    p.x *= .7;\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\n\n    // nose\n    p = pp;\n    p += vec3(0,.03,-.45);\n    pR(p.yz, 3.);\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\n\n    p = pp;\n    p += vec3(0,.06,-.47);\n    pR(p.yz, 2.77);\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\n\n    // cheek\n\n    p = pp;\n    p += vec3(-.2,.2,-.28);\n    pR(p.xz, .5);\n    pR(p.yz, .4);\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.26,.02,-.1);\n    pR(p.xz, .13);\n    pR(p.yz, .5);\n    float temple = ellip(p, vec3(.1,.1,.15));\n    temple = smax(temple, p.x - .07, .1);\n    d = smin(d, temple, .1);\n\n    p = pp;\n    p += vec3(.0,.2,-.32);\n    ch = ellip(p, vec3(.1,.08,.1));\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.17,.31,-.17);\n    ch = ellip(p, vec3(.1));\n    d = smin(d, ch, .1);\n\n    // mouth base\n    p = pp;\n    p += vec3(-.0,.29,-.29);\n    pR(p.yz, -.3);\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\n\n    p = pp;\n    p += vec3(0,.37,-.4);\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\n\n    p = pp;\n    p += vec3(-.09,.37,-.31);\n    d = smin(d, ellip(p, vec3(.04)), .18);\n\n    // bottom lip\n    p = pp;\n    p += vec3(0,.455,-.455);\n    p.z += smoothstep(.0, .2, p.x) * .05;\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\n    float w = .192;\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\n    d = smin(d, bottomlip, lb);\n    \n    // top lip\n    p = pp;\n    p += vec3(0,.38,-.45);\n    pR(p.xz, -.3);\n    ls = vec3(.065,.03,.05);\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\n    vec3 pl = p * vec3(.78,1,1);\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\n    p = pp;\n    p += vec3(0,.33,-.45);\n    pR(p.yz, .7);\n    float cut;\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\n    float dip = smin(\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\n        .025\n    );\n    cut = smax(cut, dip, .04);\n    cut = smax(cut, p.x - .1, .05);\n    toplip = smax(toplip, cut, .02);\n\n    d = smin(d, toplip, .07);\n\n    // seam\n    p = pp;\n    p += vec3(0,.425,-.44);\n    lb = length(p);\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\n    pR(p.yz, .1);\n    p.y -= smoothstep(0., .03, p.x) * .002;\n    p.y += smoothstep(.03, .1, p.x) * .007;\n    p.z -= .133;\n    float seam = fDisc(p, .2);\n    seam = smax(seam, -d - .015, .01); // fix inside shape\n    d = mix(d, smax(d, -seam, lr), .65);\n\n    // nostrils base\n    p = pp;\n    p += vec3(0,.3,-.43);\n    d = smin(d, length(p) - .05, .07);\n\n    // nostrils\n    p = pp;\n    p += vec3(0,.27,-.52);\n    pR(p.yz, .2);\n    float nostrils = ellip(p, vec3(.055,.05,.06));\n\n    p = pp;\n    p += vec3(-.043,.28,-.48);\n    pR(p.xy, .15);\n    p.z *= .8;\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\n\n    d = smin(d, nostrils, .02);\n\n    p = pp;\n    p += vec3(-.033,.3,-.515);\n    pR(p.xz, .5);\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\n\n    //return d;\n\n    // eyelids\n    p = pp;\n    p += vec3(-.16,.07,-.34);\n    float eyelids = ellip(p, vec3(.08,.1,.1));\n\n    p = pp;\n    p += vec3(-.16,.09,-.35);\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\n\n    // edge top\n    p = pp;\n    p += vec3(-.173,.148,-.43);\n    p.x *= .97;\n    float et = length(p.xy) - .09;\n\n    // edge bottom\n    p = pp;\n    p += vec3(-.168,.105,-.43);\n    p.x *= .9;\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\n\n    float edge = max(max(eb, et), -d);\n\n    d = smin(d, eyelids, .01);\n    d = smin(d, eyelids2, .03);\n    d = smax(d, -edge, .005);\n\n    // eyeball\n    p = pp;\n    p += vec3(-.165,.0715,-.346);\n    float eyeball = length(p) - .088;\n\tisEye = eyeball < d;\n    d = min(d, eyeball);\n\n    // tear duct\n    p = pp;\n    p += vec3(-.075,.1,-.37);\n    d = min(d, length(p) - .05);\n\n    \n \t// ear\n    p = pp;\n    p += vec3(-.405,.12,.10);\n    pR(p.xy, -.12);\n    pR(p.xz, .35);\n    pR(p.yz, -.3);\n    vec3 pe = p;\n\n    // base\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\n\n    // inner\n    pR(p.xz, -.5);\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\n    float ridge = iear;\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\n    ear = smax2(ear, -iear, .04);\n    earback = smin(earback, iear - .04, .02);\n\n    // ridge\n    p = pe;\n    pR(p.xz, .2);\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\n\n    float ridger = .01;\n\n    ridge = max(-ridge, ridge - ridger);\n\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\n\n    ear = smin(ear, ridge, .045);\n\n    p = pe;\n\n    // outline\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\n\n    // edge\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\n\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\n    edgeo = smax(edgeo, -edgeoin, .05);\n\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\n    eedent = min(eedent, 1.);\n\n    eedge += eedent * .06;\n\n    eedge = smax(eedge, -edgeo, .01);\n    ear = smin(ear, eedge, .01);\n    ear = max(ear, earback);\n\n    ear = smax2(ear, outline, .015);\n\n    d = smin(d, ear, .015);\n\n    // targus\n    p = pp;\n    p += vec3(-.34,.2,.02);\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\n    p = pp;\n    p += vec3(-.37,.18,.03);\n    pR(p.xz, .5);\n    pR(p.yz, -.4);\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\n    \n    return d;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 297, 297, 428], [430, 430, 455, 455, 553], [660, 660, 687, 687, 984], [986, 986, 1013, 1013, 1260], [1262, 1262, 1317, 1317, 2106]], "test": "untested"}
{"id": "sd2GWD", "name": "Hex tile transition effect", "author": "mrange", "description": "License CC0: Hex tile transition effect\nResult after playing around with transition effects\n", "tags": ["transition", "hextile"], "likes": 38, "viewed": 1115, "published": 3, "date": "1617460465", "time_retrieved": "2024-07-30T19:28:58.302602", "image_code": "// License CC0: Hex tile transition effect\n//  Result after playing around with transition effects\n\n#define HEXTILE_SIZE 0.125\n#define RANDOMNESS   0.75\n\n// -\n#define PI           3.141592654\n#define TAU          (2.0*PI)\n#define RESOLUTION   iResolution\n#define TIME         iTime\n#define PERIOD       8.0\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// IQ's hex\nfloat hex(vec2 p, float r) {\n  p.xy = p.yx;\n  const vec3 k = vec3(-sqrt(3.0/4.0),1.0/2.0,1.0/sqrt(3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// See Art of Code: Hexagonal Tiling Explained!\n// https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)/2.0;\n}\n\n// IQ's polynominal soft min\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// IQ's ellipse\nfloat ellipse(vec2 p, vec2 ab) {\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nconst int N = 4;\n\n// IQ's polygon\nfloat polygon(vec2 p, vec2[N] v) {\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ ) {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nconst vec2[] wing = vec2[](vec2(0.385, 0.435), vec2(1.35, 0.435), vec2(0.92, 0.035), vec2(0.385, 0.035));\n\nfloat commodore(vec2 p, out bool isRed) {\n  vec2 op = p;\n  p.y = abs(p.y);\n  float d0 = ellipse(p, vec2(1.0, 0.865));\n  d0 = abs(d0)- 0.275;\n  float d1 = p.x-0.375;\n  float d2 = polygon(p, wing);\n  float d = d0;\n  d = pmax(d, d1, 0.025);\n  d = pmin(d, d2, 0.025);\n  isRed = op.y > 0.0 && d2 <= 0.0025;\n  return d;\n}\n\n\nvec3 hexTransition(vec2 p, float aa, vec3 from, vec3 to, float m) {\n  m = clamp(m, 0.0, 1.0);\n  const float hz = HEXTILE_SIZE;\n  const float rz = RANDOMNESS;\n  vec2 hp = p;\n  hp /= hz;\n//  hp *= ROT(0.5*(1.0-m));\n  vec2 hn = hextile(hp)*hz*-vec2(-1.0, sqrt(3.0));\n  float r = hash(hn+123.4);\n  \n  const float off = 3.0;\n  float fi = smoothstep(0.0, 0.1, m);\n  float fo = smoothstep(0.9, 1.0, m);\n\n  float sz = 0.45*(0.5+0.5*tanh_approx(((rz*r+hn.x + hn.y-off+m*off*2.0))*2.0));\n  float hd = (hex(hp, sz)-0.1*sz)*hz;\n  \n  float mm = smoothstep(-aa, aa, -hd);\n  mm = mix(0.0, mm, fi);\n  mm = mix(mm, 1.0, fo);\n  \n  vec3 col = mix(from, to, mm);\n  vec2 ahn = abs(hn);\n  return col;\n}\n\nvec3 sunset(vec2 p, float aa) {\n  const float z = 0.75;\n  const float so = 0.05;\n\n  bool isRed;\n  float d = commodore(p/z, isRed)*z;\n  bool sisRed;\n  float ds = commodore((p-so*vec2(-1.0, -1.0))/z, sisRed)*z;\n\n  vec3 col = vec3(1.0);\n\n  float sy = abs(p.y);\n\n  vec3 sky   = hsv2rgb(vec3(0.55, max(sy, 0.0), max(1.0-1.0*sy, 0.0)))*0.6;\n  vec3 sun1  = hsv2rgb(vec3(0.05, max(1.0-sy, 0.0), max(1.0-(1.0/1.25)*sy, 0.0)))*0.6;\n  vec3 sun2  = hsv2rgb(vec3(0.05, smoothstep(0.0, 0.125, sy)*0.5, (1.0-sy)*smoothstep(0.0, 0.125, sy)))*0.6;\n  vec3 venus = 1.0*exp(-300.0*(length(p - vec2(0.5))))*vec3(1.0);\n  vec3 land  = vec3(0.05);\n  vec3 sea   = hsv2rgb(vec3(0.5, 0.5*sy, sy))*1.9;\n  \n  col = sun1+sun2;\n  col = mix(col, sky, max(sy*sy, 0.0));  \n  col = mix(col, land, smoothstep(0.026, 0.0, sy));  \n  col += 0.33*(1.0-tanh_approx(8.0*length((p-vec2(0.0, 0.0125))*vec2(0.125, 1.0))));\n  col += 0.66*(1.0-tanh_approx(8.0*length((p-vec2(0.0, 0.0125))*vec2(1.0, 1.0))));\n  col += venus;\n  col += sea*sqrt(max(-p.y, 0.0));\n  \n  col = clamp(col, 0.0, 1.0);\n  \n  col = mix(col, vec3(0.25, 0.25, 0.25) , 1.0*exp(-10.0*max(ds+so*sqrt(2.0), 0.0)));\n  col = mix(col, isRed ? vec3(1.0, 0.215, 0.25) : vec3(1.0), smoothstep(-aa, aa, -d));\n\n  col = clamp(col, 0.0, 1.0);\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 dark   = vec3(0.25)*(1.0-tanh_approx(length(p)));\n  vec3 sunset = sunset(p, aa);\n\n  float nt = TIME/PERIOD;\n  float m = fract(nt)*1.25;\n  float n = mod(floor(nt), 2.0);\n  \n  vec3 from = n == 0.0 ? dark:sunset;\n  vec3 to   = n != 0.0 ? dark:sunset;\n  \n  vec3 col = hexTransition(p, aa, from, to, m);\n \n  col = postProcess(col, q);\n\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2GWD.jpg", "access": "api", "license": "cc0-1.0", "functions": [[308, 308, 329, 329, 396], [398, 398, 426, 446, 522], [524, 603, 625, 625, 794], [797, 828, 864, 864, 958], [960, 972, 1000, 1000, 1203], [1205, 1300, 1328, 1328, 1655], [1657, 1686, 1725, 1725, 1814], [1816, 1816, 1855, 1855, 1884], [1886, 1902, 1934, 1934, 2956], [3526, 3526, 3567, 3567, 3841], [3844, 3844, 3911, 3911, 4524], [4526, 4526, 4557, 4557, 5793], [5795, 5795, 5831, 5831, 6080], [6083, 6083, 6138, 6138, 6640]], "test": "error"}
{"id": "7sj3DW", "name": "Showdown Revision 2021 - Semi2", "author": "Pixdigit", "description": "Whenever I watch a shader showdown I try to code a shader alongside to see what I manage to do.", "tags": ["tiling", "cross"], "likes": 3, "viewed": 184, "published": 3, "date": "1617456818", "time_retrieved": "2024-07-30T19:28:59.068554", "image_code": "mat2 rot(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat2(\n\t\tc, -s,\n\t\ts, c\n\t);\n}\n\nvec2 rand(vec2 seed) {\n    return (cos(dot(sin(seed * 12345.345), seed + 25.) * seed + 52798753.) + 1.) / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    uv.y += sin(floor(uv.x * 10.) + iTime) * 0.1;\n    vec2 gid = floor(uv * 10.);\n    vec2 guv = (fract(uv * 10.) - 0.5) * 2.;\n    guv = rot(sin(iTime * gid.y) * 3.1415) * guv;\n\n     // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 col = vec3(0.);\n    if (min(abs(guv.x), abs(guv.y)) < 0.1 * smoothstep(0.2, 1., abs(sin(iTime * 0.2 + uv.x * 2. + uv.y * 3.)))\n            && max(abs(guv.x), abs(guv.y)) < 0.5)\n            {\n        col = vec3(1.) * (sin(iTime * 3. + 3.1415 * rand(gid).x) + 1.) / 2.;\n        if (rand(gid).x < rand(gid).y) {\n            col  *= 0.5 + 0.5*cos(gid.xyx+vec3(0,2,4));\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sj3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 106], [108, 108, 130, 130, 219], [221, 221, 278, 328, 1084]], "test": "untested"}
{"id": "7s23WW", "name": "Showdown Revision 2021 - Semi1", "author": "Pixdigit", "description": "Whenever I watch a shader showdown I try to code a shader alongside to see what I manage to do. This was the first time doing this, so this is a fairly simple shader.", "tags": ["circles", "wave", "tiling"], "likes": 1, "viewed": 166, "published": 3, "date": "1617455186", "time_retrieved": "2024-07-30T19:28:59.844479", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    vec2 wave = vec2(uv.x, sin(iTime * 2. + uv.x * 4.) * 0.1 + uv.y) * 10.;\n    vec2 guv = fract(wave);\n    vec2 gid = floor(wave - .5);\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    if (length(guv - 0.5)>0.3) {\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+gid.xyx+vec3(0,2,4));\n    } else {\n        if (length(guv - 0.5) < 0.3 * smoothstep(.5, 0., abs(sin(iTime + uv.x)))) {\n            col = vec3(1.);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s23WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 640]], "test": "untested"}
{"id": "sdBGWD", "name": "2D path-tracing test", "author": "clepirelli", "description": "Made for the willstall challenge - 1 shader a week keeps the depression meek\n\n2D path-tracer for circles - press space to reset the progressive rendering\n\nThank you to Nameless#1608 on discord for all his help, IOU", "tags": ["2d", "circle", "pathtracing"], "likes": 25, "viewed": 1437, "published": 3, "date": "1617453228", "time_retrieved": "2024-07-30T19:29:00.621402", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 textureColor = texture(iChannel0, uv).xyz;\n    \n    //from: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n    textureColor *= 12.0;\n    vec3 x = max(vec3(.0), textureColor-.004);\n    vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n    fragColor = vec4(min(retColor, 1.0), 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ---- structs ----\nstruct Ray\n{\n    vec2 origin;\n    vec2 direction;\n};\n\nconst int lambertian = 0; //color is attenuation\nconst int light = 1; //color is emission\nconst int dielectric = 2; //color is attenuation, other is refraction index\n\nstruct Material\n{\n    int type;\n    vec3 color;\n    float other;\n};\n\nstruct Circle\n{\n    vec2 origin;\n    float radius;\n    Material material;\n};\n\nstruct IntersectionQuery\n{\n    bool result;\n    bool inside;\n    float nearest;\n    vec2 normal;\n    vec2 hit;\n    Material material;\n};\n\n// ---- materials ----\n\nvec3 applyMaterial(vec3 color, Material material)\n{\n    switch(material.type)\n    {\n        case dielectric:\n        case lambertian:\n            return color * material.color;\n        case light:\n            return material.color;   \n    }\n    return vec3(.0);\n}\n\n\n// ---- intersection queries ----\n\nvec2 pointOnRay(Ray ray, float dist)\n{\n    return ray.origin + ray.direction * dist;\n}\n\nconst IntersectionQuery miss = IntersectionQuery(false, false, -1000.0, vec2(.0), vec2(.0), Material(0, vec3(.0), .0));\n\nIntersectionQuery circleIntersection(Ray ray, Circle circle)\n{\n    float radius2 = circle.radius*circle.radius;\n    vec2 L = circle.origin - ray.origin; \n    float tca = dot(L, ray.direction); \n    float d2 = dot(L,L) - tca * tca; \n    if (d2 > radius2) return miss;\n    float thc = sqrt(radius2 - d2);\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    float nearest = min(t0, t1);\n    float nextNearest = max(t0, t1);\n    \n    bool inside = nearest < .0 && nextNearest > .0;\n    if(nearest < .0) \n    {\n        nearest = nextNearest;\n    }\n    \n    vec2 hit = pointOnRay(ray, nearest);\n    vec2 normal = (circle.origin - hit)/circle.radius;\n    return IntersectionQuery(nextNearest > .0, inside, nearest, normal, hit, circle.material);\n}\n\n// ---- randomness and ray generation ----\n\nvec2 angleToDirection(float angle)\n{\n    return vec2(sin(angle), cos(angle));\n}\n\nfloat pseudorandScalar(vec2 randseed, vec2 uv,  sampler2D tex, int channel)\n{\n    //blue noise with toroidal shifting\n\treturn fract(texture(tex, uv)[channel] + fract(sin(dot(randseed, vec2(1.0,113.0)))*43758.5453123));\n}\n\nfloat randomRadians(vec2 randseed, vec2 uv,  sampler2D tex)\n{\n    return (pseudorandScalar(randseed, uv, tex, 0)-.5)*2.0*3.14;\n}\n\nvec2 randomDirectionInHemicircle(vec2 direction, vec2 randseed , vec2 uv,  sampler2D tex, int channel) \n{\n    float randomOffset = (pseudorandScalar(randseed, uv, tex, channel))*2.0*3.14;\n    vec2 randomDirection = vec2(sin(randomOffset), cos(randomOffset));\n    return normalize(randomDirection+direction);\n}\n\n//---- boilerplate ----\n\n#define spacePressed(sampler) texelFetch(sampler,ivec2(32, 0), 0).x > 0.0\n\n#define MAIN_FUNCTION(function) \\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\\n{\\\n    vec3 total = vec3(.0);\\\n    /*MSAA*/\\\n    for(int i = 0; i <aa;i++)\\\n    for(int j = 0; j <aa;j++)\\\n    {\\\n    \t/*offset the uv for MSAA*/\\\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\\\n    \tuv.x *= iResolution.x/iResolution.y;\\\n    \tvec2 tempUV = uv;\\\n        total += function(tempUV, fragCoord);\\\n    }\\\n    total /= float(aa*aa);\\\n    /*Output to screen*/\\\n    fragColor = vec4(total,1.0);\\\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //from: https://www.shadertoy.com/view/wlGcD1\n    uint frameCount = floatBitsToUint(texelFetch(iChannel0, ivec2(0,0), 0).x);\n    if(iFrame == 0 || spacePressed(iChannel1))\n    {\n        frameCount = 0u;\n    } else \n    {\n        frameCount = frameCount + 1u;\n    }\n\n    fragColor = vec4(uintBitsToFloat(frameCount));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const int aa = 3;\nconst int maxBounces = 7;\n\nconst int circleAmount = 5;\nCircle circles[circleAmount] = Circle[circleAmount]\n(\n\tCircle(vec2(-.4,  .1),  .2, Material(light, vec3(.1), .0)),\n    Circle(vec2( .2,  .1),  .05, Material(dielectric, vec3(1.0, .47,.0), .25)),\n\tCircle(vec2( .2, -.1),  .10, Material(dielectric, vec3(1.0, 1.0, .9), .9)),\n    Circle(vec2( .5, -.2),  .05, Material(dielectric, vec3(1.0, 0.4, .4), .2)),\n    Circle(vec2( -.1, -.2),  .08, Material(dielectric, vec3(1.0, .0, .0), .2))\n);\n\nIntersectionQuery traceScene(Ray currentRay)\n{\n    IntersectionQuery finalQuery = miss;\n    for(int i = 0; i < circleAmount; i++)\n    {\n        IntersectionQuery currentQuery = circleIntersection(currentRay, circles[i]);\n        if(!finalQuery.result || (currentQuery.result && currentQuery.nearest < finalQuery.nearest))\n        {\n            finalQuery = currentQuery;\n        }\n    }\n\n    return finalQuery;\n}\n\nRay scatter(IntersectionQuery query, Ray ray, vec2 uv, vec2 seed, int channel)\n{\n    vec2 direction, origin;\n    vec2 normal = query.inside ? -query.normal : query.normal;\n    switch(query.material.type)\n    {\n        case dielectric:\n            float refractionIndex = query.material.other;\n            direction = refract(ray.direction, -normal, refractionIndex);\n            origin = query.hit+normal*.1; //technically should be less but it looks cool\n            break;\n        case lambertian:\n            direction = randomDirectionInHemicircle(query.normal, seed, uv, iChannel1, channel);\n            origin = query.hit+normal*.001;\n            break;\n    }\n    return Ray(origin, direction);\n}\n\nvec3 trace(vec2 uv)\n{\n    float currentRayAngle = randomRadians(uv+iTime, uv, iChannel1);\n    Ray currentRay = Ray(uv, angleToDirection(currentRayAngle));\n    \n    IntersectionQuery queries[maxBounces];\n    int queryCount = 0;\n        \n    for(int i = 0; i < maxBounces; i++)\n    {\n        IntersectionQuery query = traceScene(currentRay);\n        queries[queryCount] = query;\n        queryCount++;\n        \n        if(query.result && query.material.type != light)\n        {\n            vec2 seed = uv+iTime+float(i)*4.1323; //this kinda works, pretty wonky though\n            int channel = int(mod(float(i+1), 3.0));\n            currentRay = scatter(query, currentRay, uv, seed, channel);\n        } else break;\n    }\n    \n    vec3 col = vec3(.0); \n    for(int i = queryCount; i >= 0; i--)\n    {     \n        if(!queries[i].result)\n        {\n            col = vec3(.98, .48, .38)*.01; //ambient color, dawn-ish\n        } else\n        {\n            col = applyMaterial(col, queries[i].material);\n        }\n    }\n    return col;\n}\n\nvec3 outputCol(vec3 thisCol, vec2 fragCoord)\n{\n    uint frame = floatBitsToUint(texelFetch(iChannel2, ivec2(0,0), 0).x);\n    vec3 previousCol = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    return float(frame)/float(frame+1u)*previousCol + 1.0/float(frame+1u)*thisCol;\n}\n\nvec3 BufferB(vec2 uv, vec2 fragCoord)\n{\n    if(iFrame == 0)\n    {\n        return vec3(.0);\n    }\n    return outputCol(trace(uv), fragCoord);\n}\n\nMAIN_FUNCTION(BufferB)", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 407]], "test": "untested"}
{"id": "fdS3DW", "name": "Trail 1.5.2 - DualFractal", "author": "Leasel", "description": "Use function to determine next spot to look and if that spot is lit then lit me too.\nUncomment the other fractals in buffer A. \nAlso pretty funny how the fractal deforms at the border of the screen.", "tags": ["fractals", "buffer"], "likes": 1, "viewed": 251, "published": 3, "date": "1617448134", "time_retrieved": "2024-07-30T19:29:01.400319", "image_code": "\n//Read Descrition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = SI(fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 T(float x, float y)\n{\n    float Zoom = -sin(iTime*0.1 + 3.5)*3.;\n    //return (vec2(y,x) * vec2(x,y) * Zoom*(sin(4.56)*0.5 + 0.5) + vec2(x, y));\n    //return (vec2(y,x) * vec2(x,y) * Zoom*(sin(4.56)*0.5 + 0.5));\n    //return (vec2(mod(sin(x),y), cos(y)) + vec2(x*x - y*y + 1., 2.*x*y)*(sin(4.56)*0.5 + 0.5));\n    //return (vec2(mod(sin(x),y), cos(y)) + vec2(x,y));\n    //return (vec2((fract(sin(x)*600.)*2. - 1.)*Zoom, cos(y)) + vec2(x,y));\n    //return (vec2(fract(sin(x)*600.)*2. - 1., cos(y)) + vec2(x,y));\n    //return (vec2(tan(y), tan(x)) + vec2(x,y));\n    //return (vec2(tan(x), tan(y)) + vec2(x,y));\n    //return (vec2(cos(x), sin(y)) + vec2(x,y));//What is this\n    //\n    //return (vec2(x*x - y*y + 1., 2.*x*y)*(sin(4.56)*0.5 + 0.5)*Zoom + abs(vec2(x,y)) + vec2(1.,1.));\n    //return (abs(vec2(x,y)) + vec2(1.,1.));\n    //return ((vec2(x*x + y*y, 2.*x*y)*(sin(4.56)*0.5 + 0.5))*Zoom + abs(vec2(x,y)));\n    //return (vec2(x,y)*Zoom + vec2(x,y));\n    //return (vec2(x + 1.0,y*Zoom));\n    //return vec2(length(vec2(x,y))*cos(iTime)*y*0.001, length(vec2(x,y))*sin(iTime)*x);\n    //return (vec2(x*x + y*y + 1., x*y)*(sin(4.56)*0.5 + 0.5) + vec2(x,y))*Zoom;\n    //return (vec2(x*x - y*y + 1., x*y)*(sin(4.56)*0.5 + 0.5) + vec2(x,y))*Zoom;\n    //return (vec2(x*x - y*y, x*y)*(sin(4.56)*0.5 + 0.5))*Zoom;\n    //return (vec2(x*x + y*y, 2.*x*y)*(sin(4.56)*0.5 + 0.5))*Zoom + ;\n    //return (vec2(x*x*x*x + y*y*y*y + 2.*x*x - 2.*y*y - x*x*y*y + 2., x*y*4.*(1. - y*y + x*x))*0.0000001)*Zoom;\n    \n    //I recommend turning this one on\n    //return (vec2(x*x*x*x + y*y*y*y + 2.*x*x - 2.*y*y - x*x*y*y + 2., x*y*4.*(1. - y*y + x*x))*0.0000001 + vec2(x,y))*Zoom;\n    \n    //return (vec2(x*x - y*y + 1., 2.*x*y)*(sin(4.56)*0.5 + 0.5)*Zoom + vec2(x,y));\n    return (vec2(x*x - y*y + 1., 2.*x*y)*(sin(4.56)*0.5 + 0.5) + vec2(x,y))*Zoom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fgi )\n{\n    vec2 offset = iMouse.xy == vec2(0.) ? iResolution.xy*0.5 : iMouse.xy;\n    float Zoom = 1.;\n\n    fgi -= offset;\n    fgi *= Zoom;\n    vec2 tfgi = T(fgi.x, fgi.y);\n    \n    fgi /= Zoom;\n    tfgi /= Zoom;\n    \n    fgi += offset;\n    tfgi += offset;\n    \n    fragColor = vec4(SI(tfgi).x == 1. ? RCooling : SI(fgi).x);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat Rand(float t)\n{\n    return fract(600.*(sin(mod(t, 50000.))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = Rand(fragCoord.x * fragCoord.y + iDate.w + iTime)-0.998 > 0.0001 ? vec4(1.) : SI(fragCoord)*Cooling;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SI(uv) texelFetch(iChannel0, ivec2(uv), 0)\n#define OI(uv) texelFetch(iChannel1, ivec2(uv), 0)\n#define S(uv) texelFetch(iChannel0, uv, 0)\n\n#define Cooling 0.95\n#define RCooling 1./Cooling", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdS3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 19, 76, 76, 109]], "test": "untested"}
{"id": "fd2GDD", "name": "Swap Transition", "author": "turboplay", "description": "Another nice one from glsl-transitions", "tags": ["transition"], "likes": 6, "viewed": 442, "published": 3, "date": "1617443827", "time_retrieved": "2024-07-30T19:29:02.190207", "image_code": "\n// https://gl-transitions.com/editor/swap\n\nfloat reflection = 0.4;\nfloat perspective = 0.2;\nfloat depth = 3.0;\nfloat speed = 2.0f; // 1-max\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\n\nbool inBounds (vec2 p) {\nconst vec2 boundMin = vec2(0.0, 0.0);\nconst vec2 boundMax = vec2(1.0, 1.0);\n\n  return all(lessThan(boundMin, p)) && all(lessThan(p, boundMax));\n}\n \n \nvec4 bgColor (vec2 p, vec2 pfr, vec2 pto) {\n  vec4 c = black;\n  if (inBounds(pfr)) {\n    c += mix(black, texture(iChannel0,pfr), reflection * mix(1.0, 0.0, pfr.y));\n  }\n  if (inBounds(pto)) {\n    c += mix(black, texture(iChannel1,pto), reflection * mix(1.0, 0.0, pto.y));\n  }\n  return c;\n}\n \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      vec2 pfr, pto = vec2(-1.);\n      float progress = mod(iTime/speed,1.0);\n    vec2 p = fragCoord/iResolution.xy;\n    \n  float size = mix(1.0, depth, progress);\n  float persp = perspective * progress;\n  pfr = (p + vec2(-0.0, -0.5)) * vec2(size/(1.0-perspective*progress), size/(1.0-size*persp*p.x)) + vec2(0.0, 0.5);\n \n  size = mix(1.0, depth, 1.-progress);\n  persp = perspective * (1.-progress);\n  pto = (p + vec2(-1.0, -0.5)) * vec2(size/(1.0-perspective*(1.0-progress)), size/(1.0-size*persp*(0.5-p.x))) + vec2(1.0, 0.5);\n\n  if (progress < 0.5) \n  {\n    if (inBounds(pfr)) \n    {\n      fragColor = texture(iChannel0,pfr);\n    }\n    else\n    if (inBounds(pto))\n    {\n      fragColor = texture(iChannel1,pto);\n    }  \n  }\n  else\n  if (inBounds(pto)) \n  {\n    fragColor = texture(iChannel1,pto);\n  }\n  else\n  if (inBounds(pfr)) {\n    fragColor = texture(iChannel0,pfr);\n  }\n//fragColor = bgColor(p, pfr, pto);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2GDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 212, 212, 358], [363, 363, 406, 406, 652], [657, 657, 714, 714, 1629]], "test": "untested"}
{"id": "fs2GDW", "name": "rotate goku", "author": "jorge2017a1", "description": "rotate goku", "tags": ["rotategoku"], "likes": 1, "viewed": 214, "published": 3, "date": "1617422335", "time_retrieved": "2024-07-30T19:29:03.024975", "image_code": "//por jorge2017a1 ----jorgeFloresP\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n//----------\nfloat sdBox( in vec2 p, in vec2 b )\n{  vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n////-------------------\n\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\nfloat sdPoly11 POLY(11)\nfloat sdPoly28 POLY(28)\nfloat sdPoly17 POLY(17)\nfloat sdPoly09 POLY(9)\nfloat sdPoly25 POLY(25)\n\n\nvec2 pt25[ 25]=vec2[](  \nvec2(.52,.01),vec2(.21,.14),vec2(.29,.17),vec2(.12,.34),vec2(.26,.34),\nvec2(.12,.54),vec2(.09,.58),vec2(.05,.61),vec2(.01,.64),vec2(.04,.67),\nvec2(.11,.70),vec2(.17,.71),vec2(.21,.71),vec2(.25,.69),vec2(.31,.65),\nvec2(.27,.82),vec2(.26,.86),vec2(.22,.95),vec2(.19,1.00),vec2(.26,1.00),\nvec2(.35,.98),vec2(.44,.93),vec2(.49,.86),vec2(.55,.72),vec2(.52,.01) );\n\nfloat sdPoly15 POLY(15)\nvec2 pt15[ 15]=vec2[](  \nvec2(.53,.03),vec2(.82,.08),vec2(.76,.13),vec2(.91,.19),vec2(.80,.23),\nvec2(.97,.37),vec2(.92,.41),vec2(.88,.43),vec2(.84,.44),vec2(.98,.59),\nvec2(.91,.60),vec2(.82,.60),vec2(.73,.58),vec2(.55,.72),vec2(.53,.03) );\n\n\n//float sdPoly15 POLY(15)\nvec2 pt15b[ 15]=vec2[](  \nvec2(.38,.11),vec2(.35,.29),vec2(.32,.53),vec2(.53,.61),vec2(.73,.50),\nvec2(.67,.12),vec2(.66,.10),vec2(.62,.06),vec2(.56,.02),vec2(.55,.01),\nvec2(.52,.00),vec2(.48,.02),vec2(.43,.05),vec2(.39,.09),vec2(.38,.11) );\n\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.35,.29),vec2(.37,.27),vec2(.36,.34),vec2(.39,.32),vec2(.38,.42),\nvec2(.38,.45),vec2(.41,.50),vec2(.42,.41),vec2(.42,.38),vec2(.44,.33),\nvec2(.45,.39),vec2(.46,.44),vec2(.47,.47),vec2(.51,.52),vec2(.55,.56),\nvec2(.53,.61),vec2(.32,.53),vec2(.35,.29) );\n\n\nfloat sdPoly20 POLY(20)\nvec2 pt20[ 20]=vec2[](  \nvec2(.70,.28),vec2(.68,.26),vec2(.69,.33),vec2(.66,.30),vec2(.67,.35),\nvec2(.68,.40),vec2(.68,.45),vec2(.67,.48),vec2(.66,.45),vec2(.65,.42),\nvec2(.62,.38),vec2(.59,.35),vec2(.59,.39),vec2(.59,.45),vec2(.58,.50),\nvec2(.57,.53),vec2(.55,.56),vec2(.53,.61),vec2(.73,.50),vec2(.70,.28) );\n\n\n//float sdPoly11 POLY(11)\nvec2 pt11[ 11]=vec2[](  \nvec2(.38,.12),vec2(.36,.12),vec2(.34,.14),vec2(.31,.18),vec2(.31,.19),\nvec2(.31,.27),vec2(.31,.30),vec2(.32,.30),vec2(.34,.29),vec2(.35,.28),\nvec2(.38,.12) );\n\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.67,.12),vec2(.69,.12),vec2(.71,.13),vec2(.74,.18),vec2(.74,.18),\nvec2(.75,.22),vec2(.75,.26),vec2(.75,.29),vec2(.74,.30),vec2(.73,.31),\nvec2(.70,.28),vec2(.67,.12) );\n\n\nfloat sdPoly13 POLY(13)\nvec2 pt13[ 13]=vec2[](  \nvec2(.41,.40),vec2(.39,.42),vec2(.41,.46),vec2(.42,.46),vec2(.44,.47),\nvec2(.47,.46),vec2(.47,.44),vec2(.49,.40),vec2(.48,.40),vec2(.47,.43),\nvec2(.45,.44),vec2(.43,.44),vec2(.41,.40) );\n\n\n//float sdPoly13 POLY(13)\nvec2 pt13b[ 13]=vec2[](  \nvec2(.56,.41),vec2(.58,.44),vec2(.59,.45),vec2(.61,.47),vec2(.64,.46),\nvec2(.65,.44),vec2(.67,.42),vec2(.65,.39),vec2(.64,.42),vec2(.62,.43),\nvec2(.61,.43),vec2(.59,.42),vec2(.56,.41) );\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.40,.18),vec2(.39,.23),vec2(.39,.24),vec2(.39,.28),vec2(.40,.31),\nvec2(.42,.34),vec2(.43,.35),vec2(.45,.35),vec2(.46,.34),vec2(.48,.32),\nvec2(.49,.28),vec2(.49,.20),vec2(.46,.18),vec2(.40,.18) );\n\n\n//float sdPoly15 POLY(15)\nvec2 pt15c[ 15]=vec2[](  \nvec2(.57,.19),vec2(.56,.22),vec2(.56,.25),vec2(.56,.28),vec2(.57,.31),\nvec2(.58,.33),vec2(.60,.34),vec2(.62,.35),vec2(.64,.34),vec2(.65,.30),\nvec2(.65,.26),vec2(.64,.19),vec2(.62,.19),vec2(.59,.18),vec2(.57,.19) );\n\n\nfloat sdPoly6 POLY(6)\nvec2 pt6[ 6]=vec2[](  \nvec2(.51,.15),vec2(.51,.16),vec2(.52,.18),vec2(.52,.16),vec2(.52,.16),\nvec2(.51,.15) );\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.48,.13),vec2(.51,.12),vec2(.53,.12),vec2(.55,.13),vec2(.58,.15),\nvec2(.55,.13),vec2(.52,.12),vec2(.51,.12),vec2(.48,.13) );\n\nvec2 RotarPuntoPivote(vec2 p,vec2 pXrYr, float theta)\n{\n     vec2 pp=p;\n     vec2 pos=pXrYr;\n     pp=pp-pos;\n     pp.xy = rotatev2(pp.xy, theta);\n     pp=pp+pos;   \n     return pp;\n}    \n\nvec3 RostroGoku(in vec2 ppp, vec3 col) \n{\n  vec2 pp=ppp;\n      float xr=0.5; float yr=0.25;\n     \n     \n     pp= RotarPuntoPivote(pp,vec2(xr,yr), iTime);\n     \n     //p=pp;    \n   \n  vec2 p=pp;\n  float sd1 = sdPoly25(p-vec2(0.0,-0.2), pt25);\n  float sd2 = sdPoly15(p-vec2(0.0,-0.2), pt15);\n  float sd3 = sdPoly15(p-vec2(0.0,-0.2), pt15b);\n  float sd4 = sdPoly18(p-vec2(0.0,-0.2), pt18);\n  float sd5 = sdPoly20(p-vec2(0.0,-0.2), pt20);\n  float sd6 = sdPoly11(p-vec2(0.0,-0.2), pt11); //orejas izq\n  float sd7 = sdPoly12(p-vec2(0.0,-0.2), pt12); //orejas der\n  float sd8 = sdPoly13(p-vec2(0.0,-0.2), pt13); //ceja izq\n  float sd9 = sdPoly13(p-vec2(0.0,-0.2), pt13b); //ceja der\n  float sd10 = sdPoly14(p-vec2(0.0,-0.2), pt14);\n  float sd11 = sdPoly15(p-vec2(0.0,-0.2), pt15c);\n  //nariz\n  float sd12 = sdPoly6(p-vec2(0.0,-0.2), pt6);\n  float sd13 = sdPoly9(p-vec2(0.0,-0.2), pt9);\n  float ojo1= sdCircle(  p-vec2(0.44+0.03*sin(iTime),0.05), 0.022 );\n  float ojo2= sdCircle(  p-vec2(0.59+0.03*sin(iTime),0.05), 0.022 );\n  \n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd1,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd2,0.0));\n  col = mix(col,vec3(0.98, 0.82,0.720),S(sd3,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd4,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd5,0.0));\n  //orejas\n  col = mix(col,vec3(0.92, 0.82,0.720),S(sd6,0.0));\n  col = mix(col,vec3(0.92, 0.82,0.720),S(sd7,0.0));\n  //cejas\n  col = mix(col,vec3(0.3, 0.3,0.3),S(sd8,0.0));\n  col = mix(col,vec3(0.3, 0.3,0.3),S(sd9,0.0));\n  col = mix(col,vec3(1.0, 1.0,1.0),S(sd10,0.0));\n  col = mix(col,vec3(1.0, 1.0,1.0),S(sd11,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd12,0.0));\n  //boca\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd13,0.0));\n  //ojos\n  col = mix(col,vec3(0.3, 0.2,0.2),S(ojo1,0.0));\n  col = mix(col,vec3(0.3, 0.2,0.2),S(ojo2,0.0));\n  \n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    //posicion\n    vec2 p=uv+vec2(1.5,0.7);\n    // escala\n    p.x*=0.7;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n     col= RostroGoku( p,col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2GDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 395, 395, 417], [418, 418, 451, 451, 473], [474, 474, 507, 507, 528], [530, 568, 604, 604, 649], [650, 663, 700, 700, 773], [775, 775, 810, 810, 834], [836, 836, 870, 870, 963], [4837, 4837, 4892, 4892, 5019], [5025, 5025, 5066, 5066, 6840], [6843, 6843, 6900, 6900, 7174]], "test": "untested"}
{"id": "fsjGDW", "name": "rotate house", "author": "jorge2017a1", "description": "rotate house", "tags": ["rotatehouse"], "likes": 2, "viewed": 225, "published": 3, "date": "1617422308", "time_retrieved": "2024-07-30T19:29:03.803893", "image_code": "//por jfp\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n//Constants\nconst float tau = atan(1.0)*8.0;\nconst float pi = atan(1.0)*4.0;\n\n\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat line(in vec2 p, in vec2 a, in vec2 b, in float thick)\n{\n    return 1.-smoothstep(thick - 1.5/iResolution.y, thick, sdSegment(p,a,b));   \n}\n\nconst int N1 =6;\n\n\nvec2 pt1[6]=vec2[](vec2(.4,.2),vec2(.8,.2),vec2(.8,.5),vec2(.6,.7),vec2(.4,.5),\nvec2(.4,.2));\n\nfloat sdPolygonA( in vec2 p, in vec2[N1] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\nvec3 LineasCuadriculado(vec2 p, vec3 col)\n{\n    \n    vec2 a1=vec2(0.0,-1.5);\n    vec2 b1=vec2(0.0,1.5);\n  \n    vec2 a2=vec2(-2.0, 0.0);\n    vec2 b2=vec2( 2.0, 0.0);\n    \n    float thick = 3./iResolution.y;\n    \n    float ds2= line(p, a1, b1, thick);  //vertical\n    float ds3= line(p, a2, b2, thick);  //horizontal\n    col = mix(col,vec3(0.0, 0.0,0.0)*1.2,ds2);\n    col = mix(col,vec3(0.0, 0.0,0.0)*1.2,ds3);\n    return col;\n}   \n\n\nvec2 RotarPuntoPivote(vec2 p,vec2 pXrYr, float theta)\n{\n     vec2 pp=p;\n     vec2 pos=pXrYr;\n     pp=pp-pos;\n     pp.xy = rotatev2(pp.xy, theta);\n     pp=pp+pos;   \n     return pp;\n}    \n\nvec3 casa1(vec2 p, vec3 col )\n{\n    float xr=pt1[5].x;\n    float yr=pt1[5].y;\n    vec2 tmp2;\n    \n    \n    float dc1= sdCircle(  p-vec2(xr, yr), 0.02 );\n    float dc2= sdCircle(  p-vec2(0, 0), 0.02 );\n   \n    \n     vec2 pp=p;\n    \n    p= RotarPuntoPivote(pp,vec2(xr,yr),iTime);\n    \n    float d1 = sdPolygonA(p, pt1);\n    \n    col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(d1,0.0));\n    col = mix(col,vec3(1.0, 0.0,0.0)*1.2,S(dc1,0.0));\n    col = mix(col,vec3(1.0, 0.0,1.0)*1.2,S(dc2,0.0));\n    \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 p=uv;\n    \n\n    vec3 col=vec3(0.65);\n    col= LineasCuadriculado(p, col);\n    col= casa1( p,  col );\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 91, 91, 113], [114, 114, 147, 147, 169], [170, 170, 203, 203, 224], [586, 586, 620, 620, 717], [719, 719, 756, 756, 836], [838, 838, 873, 873, 901], [904, 904, 956, 956, 1075], [1077, 1077, 1138, 1138, 1221], [1989, 1989, 2032, 2032, 2415], [2421, 2421, 2476, 2476, 2603], [2609, 2609, 2640, 2640, 3120], [3123, 3123, 3180, 3180, 3415]], "test": "untested"}
{"id": "fd23WW", "name": "Curved Tube Ray Intersect", "author": "oneshade", "description": "Curved tube intersector.", "tags": ["raytracing", "ray", "raycasting", "tube", "quadratic", "intersect", "curved"], "likes": 8, "viewed": 145, "published": 3, "date": "1617414171", "time_retrieved": "2024-07-30T19:29:04.580816", "image_code": "// Intersection (note: the clipping is done in mainImage, not here)\n// Funny thing is, when the bending is flipped, the tube becomes an ellipse\nvec3 iCurvedTube(in vec3 ro, in vec3 rd, in float bend, in float radius) {\n    float a = dot(rd, rd) - bend * rd.y * rd.y;\n    float b = 2.0 * (dot(ro, rd) - bend * ro.y * rd.y);\n    float c = dot(ro, ro) - bend * ro.y * ro.y - radius * radius;\n\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * a;\n\n        float t1 = +(root - b) / denom;\n        float t2 = -(root + b) / denom;\n\n        return vec3(t1, t2, 2.0); // vecN(hit 1, hit 2, hit 3, ... , number of hits)\n    }\n\n    return vec3(0.0);\n}\n\n// Normal\nvec3 nCurvedTube(in vec3 p, in float bend, in float radius) {\n    return normalize(vec3(p.x, (1.0 - bend) * p.y, p.z));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    float bend = 2.0 + cos(iTime);\n    float radius = 2.0 + sin(iTime);\n\n    // Find the closest hit in front of the camera with |y| < 3\n    vec3 hit = iCurvedTube(ro, rd, bend, radius);\n    float t = 1000000000.0;\n    vec3 hitPos;\n    for (int n=0; n < int(hit[2]); n++) {\n        vec3 hitCandid = ro + rd * hit[n];\n        if (hit[n] > 0.0 && hit[n] < t && abs(hitCandid.y) < 3.0) {\n            t = hit[n];\n            hitPos = hitCandid;\n        }\n    }\n\n    // Render the shape if hitting\n    if (t < 1000000000.0) {\n        vec3 n = nCurvedTube(hitPos, bend, radius);\n        float diff = abs(dot(n, -rd));\n        float checkers = mod(floor(atan(hitPos.z, hitPos.x) * 3.14) + floor(hitPos.y), 2.0);\n        fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25);\n        fragColor.rgb += 0.5 * step(0.0, dot(n, rd));\n        fragColor.rgb *= diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd23WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 144, 218, 218, 714], [716, 726, 787, 787, 847], [849, 849, 904, 904, 2495]], "test": "untested"}
{"id": "Nd2GWW", "name": "Rainbow feathers 2", "author": "jarble", "description": "A simple fractal formula.\nFull-screen mode recommended.", "tags": ["fractal", "rainbow", "feather"], "likes": 2, "viewed": 265, "published": 3, "date": "1617411022", "time_retrieved": "2024-07-30T19:29:05.447499", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.5;\n        float scale1 = 1.4;\n        float s1 = scale1*scale;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.0-abs((uv.x-uv.y)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            uv.x *= -(1.0+col.x/scale);\n            col[c] = fract((.25*col.x+uv.y-uv.x)/2.5);\n        }\n     \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2GWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 737]], "test": "untested"}
{"id": "sdB3DD", "name": "Fractal 48_gaz", "author": "gaz", "description": "julia", "tags": ["fractal"], "likes": 13, "viewed": 395, "published": 3, "date": "1617410493", "time_retrieved": "2024-07-30T19:29:06.281269", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define hue(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define hash(x)fract(sin(x*5555.5))\n\nvoid mainImage(out vec4 O, in vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1.5));  \n    for(float i=0.,j,g=0.,e,m,n;i++<100.;){\n        vec3 p=d*g;\n        p=R(p,normalize(vec3(1,2,3)),.5);\n        p-=vec3(-.3,.2,-iTime*.3);\n        n=hash(floor(p.z)+234.5);\n        p.z=fract(p.z)-.5;     \n        m=.1;\n        vec2 z=p.xy;\n        for(j=0.;\n            length(vec2(dot(z,z),p.z))<4.&&j++<100.;\n            m=min(m,length(vec2(dot(z,z),p.z)))\n        )\n            z=mat2(z,-z.y,z.x)*z-vec2(.8,.18)+n*.05;\n        g+=e=.5*m;\n        e<.01?O.xyz+=mix(vec3(1),hue(log(j)*.6+n),.7)*.3*exp(-5e-4*i*i):p;\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdB3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 184, 184, 795]], "test": "untested"}
{"id": "7sBGWW", "name": "Raymarching Creation #?", "author": "oneshade", "description": "Something cool.", "tags": ["3d", "raymarching", "creation", "smoothmod"], "likes": 7, "viewed": 148, "published": 3, "date": "1617410120", "time_retrieved": "2024-07-30T19:29:07.125013", "image_code": "#define TAU 6.28318530718 // 2 * pi\n#define RHO 1.57079632679 // pi / 2\n\n// SDFs\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\n// Distance operators\nfloat smoothMod(in float x, in float size, in float smoothness) {\n    return asin(sin(x / size) * (1.0 - smoothness)) * size;\n}\n\n// r: vec2(horizontal repeats, vertical repeats)\n// Not sure if this actually \"works\"\nvoid pSmoothModSpherical(inout vec3 p, in vec2 r, in float s) {\n    vec2 a = TAU / r, ha = 0.5 * a;\n    p.xz = sin(smoothMod(atan(p.z, p.x) + ha.x, a.x, s) - ha.x + vec2(RHO, 0.0)) * length(p.xz);\n    p.xy = sin(smoothMod(atan(p.y, p.x) + ha.y, a.y, s) - ha.y + vec2(RHO, 0.0)) * length(p.xy);\n}\n\n// Scene\nfloat mapScene(in vec3 p) {\n    float c = cos(244.18), s = sin(244.18);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n\n    pSmoothModSpherical(p, vec2(100.0), 0.5);\n    p.yz *= mat2(c, -s, s, c);\n    vec3 q = abs(p - vec3(2.0, 0.0, 0.0)) - 0.1;\n    float boxes = max(q.x, max(q.y, q.z));\n\n    return boxes;\n}\n\n// Gradient\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = true ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 6.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    // Raymarch\n    float t = 0.0, d;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            vec3 color = abs(n) * 1.25;\n            fragColor.rgb = color * max(0.2, dot(n, l));\n\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 81, 116, 116, 211], [213, 235, 300, 300, 362], [364, 450, 513, 513, 745], [747, 756, 783, 783, 1080], [1082, 1094, 1121, 1121, 1368], [1370, 1370, 1425, 1425, 2485]], "test": "untested"}
{"id": "ssS3WW", "name": "Recursive Spike Cross", "author": "nbardy", "description": "Large cutouts of sphere to create cross like objects. \n\nCode forked from Otavio Good. Check out his shaders below.\n\nBase shape: \nhttps://www.shadertoy.com/view/XljGDz\n\nRaymarcher:\nhttps://www.shadertoy.com/view/3tVSRh", "tags": ["fractal", "raymarch", "stochastic", "cineshader"], "likes": 4, "viewed": 7224, "published": 3, "date": "1617405100", "time_retrieved": "2024-07-30T19:29:08.502332", "image_code": "// Fork of \"Fractured Protophore\" by otaviogood. https://shadertoy.com/view/3tVSRh\n// 2021-03-30 23:47:16\n\n/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nThis is the latest iteration of my stochastic ray tracer.\nFor materials, it supports:\n- Proper reflection / refraction, with total internal reflection.\n- Filtered light rays like in the red glass.\n- Gold has rgb reflectance.\n- Emission.\n- Diffuse / specular.\n- Sub surface scattering, like in water.\n- Scattering in air or whereever for fog.\n\n- Support for ray traced and ray marched geometry in the same scene.\n- Antialiasing.\n- Depth of field\n\nRandom number generation and hashes were cleaned up and now feel pretty good.\n\n-Otavio Good\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tvec4 c=texture(iChannel0,uv);\n\tfragColor=vec4(sqrt((c.xyz*4096.0) / c.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This is a fork of Otavio Good's hysphere.\n// It uses his raymarcher and a derivative of his base shape.\n\n/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nThis is the latest iteration of my stochastic ray tracer.\nFor materials, it supports:\n- Proper reflection / refraction, with total internal reflection.\n- Filtered light rays like in the red glass.\n- Gold has rgb reflectance.\n- Emission.\n- Diffuse / specular.\n- Sub surface scattering, like in water.\n- Scattering in air or whereever for fog.\n\n- Support for ray traced and ray marched geometry in the same scene.\n- Antialiasing.\n- Depth of field\n\nRandom number generation and hashes were cleaned up and now feel pretty good.\n\n-Otavio Good\n*/\n\n// --------------------------------------------------------------------------\n// 1 for fast GPUs, 0 for slow.\n#define HIGH_QUALITY 0\n// --------------------------------------------------------------------------\n\n// Number of samples per pixel - bigger takes more compute\n#define NUM_SAMPLES 4\n\n\n#define NUM_ITERS 6\n\n\n// ---- general helper functions / constants ----\n#define saturate(a) clamp(a, 0.0, 1.0)\n// Weird for loop trick so compiler doesn't unroll loop\n// By making the zero a variable instead of a constant, the compiler can't unroll the loop and\n// that speeds up compile times by a lot.\n#define ZERO_TRICK max(0, -iFrame)\nconst int BIG_INT = 2000000000;\nconst float PI = 3.14159265;\nconst float farPlane = 64.0;\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n// Find 2 perpendicular vectors to the input vector.\nmat3 MakeBasis(vec3 normal) {\n\tmat3 result;\n    result[0] = normal;\n    if (abs(normal.y) > 0.5) {\n        result[1] = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));\n    } else {\n        result[1] = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n    }\n    result[2] = normalize(cross(normal, result[1]));\n    return result;\n}\n\nvec3 diagN = normalize(vec3(-1.0));\n\n\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\nvec2 matmax(vec2 a, vec2 b)\n{\n    if (a.x > b.x) return a;\n    else return b;\n}\n\nfloat sdSphere(in vec3 p, float r) { \n\n    float d = length(p) -r;\n    return d;\n}\n\nfloat sdNuts(in vec3 p, float r) {\n    return max(sdSphere(p - vec3(0.0,0.2,0.0), 0.4), sdSphere(p - vec3(0.0,0.2,0.0), 0.4));\n}\n\n\nvec2 map( in vec3 pos )\n{   \n    vec3 p = pos;\n    float rad = 0.0;\n    float h = 1.0;\n    //float d = sdPyramid(pos,hei) - rad;\n    vec3 p_s = vec3(0.0,-0.0,0.00);\n    float r = h * 0.5;\n   \n    int RECURSION_LEVELS = 6; \n    float radius = 4.0;\n    float subR = 0.68;\n    float addR = 0.27;\n    \n    vec2 final = vec2(10000.0, 0.0);\n    for (int i = 0; i < RECURSION_LEVELS; i++) {\n        float d = sdSphere(p, radius);\n        \n        vec3 corner = abs(p) + diagN * radius;\n        float lenCorners = length(corner);\n        float subSpheres = sdSphere(corner, radius * subR);\n        //float addSpheres = sdSphere(corner, radius * addR);\n        \n        p = corner;\n     \n        d = max(d,-subSpheres);\n        //d = min(d, addSpheres);\n        float t;\n        if(i > 4) { t = 5.0; }\n        final = matmin(vec2(d, t), final); \n        radius *= addR;\n    }  \n   \n    return final;\n}\n\n// ---- Random functions use one 32 bit state var to change things up ----\n// This is the single state variable for the random number generator.\nuint randomState = 4056649889u;\n// 0xffffff is biggest 2^n-1 that 32 bit float does exactly.\n// Check with Math.fround(0xffffff) in javascript.\nconst float invMax24Bit = 1.0 / float(0xffffff);\n\n// This is the main hash function that should produce a non-repeating\n// pseudo-random sequence for 2^31 iterations.\nuint SmallHashA(in uint seed) {\n    return (seed ^ 1057926937u) * 3812423987u ^\n            ((seed*seed) * 4000000007u);\n}\n// This is an extra hash function to clean things up a little.\nuint SmallHashB(in uint seed) {\n    return (seed ^ 2156034509u) * 3699529241u;\n}\n\n// Hash the random state to get a random float ranged [0..1]\nfloat RandFloat() {\n    randomState = SmallHashA(randomState);\n    // Add these 2 lines for extra randomness. And change last line to tempState.\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return float((tempState>>8) & 0xffffffu) * invMax24Bit;\n}\n// Hash the random state to get 2 random floats ranged [0..1]\n// Reduced precision to 16 bits per component.\nvec2 RandVec2() {\n    randomState = SmallHashA(randomState);\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return vec2(tempState & 0xffffu,\n                (tempState >> 16) & 0xffffu) / float(0xffff);\n}\n// Hash the random state to get 3 random floats ranged [0..1]\n// Reduced precision to 10 bits per component.\nvec3 RandVec3() {\n    randomState = SmallHashA(randomState);\n    uint tempState = (randomState << 13) | (randomState >> 19);\n    tempState = SmallHashB(tempState);\n    return vec3((tempState >> 2) & 0x3ffu,\n                (tempState >> 12) & 0x3ffu,\n                (tempState >> 22) & 0x3ffu) / float(0x3ffu);\n}\n\n// Returns a random float from [0..1]\nfloat HashFloat(uint seed) {\n    seed = SmallHashA(seed);\n    return float((seed >> 8) & 0xffffffu) * invMax24Bit;\n}\nvec2 HashVec2(uint seed) {\n    seed = SmallHashA(seed);\n    seed = (seed << 13) | (seed >> 19);\n    seed = SmallHashB(seed);\n    return vec2(seed & 0xffffu,\n                (seed >> 16) & 0xffffu) / float(0xffff);\n}\nvec3 HashVec3(uint seed) {\n    seed = SmallHashA(seed);\n    seed = (seed << 13) | (seed >> 19);\n    seed = SmallHashB(seed);\n    return vec3((seed >> 2) & 0x3ffu,\n                (seed >> 12) & 0x3ffu,\n                (seed >> 22) & 0x3ffu) / float(0x3ffu);\n}\nfloat HashFloatI2(ivec2 seed) {\n    uint seedB = SmallHashA(uint(seed.x ^ (seed.y * 65537)));\n    //seedB ^= SmallHashB(uint(seed.y));\n    return float(seedB & 0xffffffu) * invMax24Bit;\n}\n\nvoid SetRandomSeed(in vec2 fragCoord, in vec2 iResolution,\n                  in int iFrame) {\n    uint primex = max(uint(iResolution.x), 5003u);  // This prime is far from any 2^x\n    randomState = uint(fragCoord.x);\n    randomState += uint(fragCoord.y) * primex;\n    randomState += uint(iFrame) * primex * uint(iResolution.y);\n    RandFloat();\n}\n\n// Returns random number sampled from a circular gaussian distribution\n// https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\nvec2 RandGaussianCircle() {\n    vec2 u = RandVec2();\n    u.x = max(u.x, 0.00000003); // We don't want log() to fail because it's 0.\n    float a = sqrt(-2.0 * log(u.x));\n    return vec2(a * cos(2.0*PI*u.y), a * sin(2.0 * PI * u.y));\n}\n// Randomly sample the lifetime of a ray moving through particles\n// p = prob. of collision with particle per unit distance traveled\nfloat RayLifetime(float p) {\n    if (p < 0.00000003) return farPlane;  // Lower than this and the math seems to fail.\n    float unif = RandFloat();  // uniform(0, 1)\n    // This random shouldn't be allowed to hit 0 because log() is undefined.\n    unif = max(0.00000000000001, unif);\n    // p can't be 0 because log(1) == 0 and it divides by 0. Can't be 1 because log(0) is undefined.\n    p = min(p, .999999);\n    //float g = math.floor(math.log(unif) / math.log(1 - p))  # natural logs\n    // g = number of successes before failure\n    float g = log(unif) / log(1.0 - p);\n    return g;\n}\n\nvec3 HashPointOnSphere(uint seed) {\n    vec2 uv = HashVec2(seed);\n    float theta = 2.0 * PI * uv.x;\n    float psi = acos(2.0 * uv.y - 1.0);\n    float x = cos(theta) * sin(psi);\n    float y = sin(theta) * sin(psi);\n    float z = cos(psi);\n    return vec3(x, y, z);\n}\n\n// Random point *ON* sphere\nvec3 RandPointOnSphere() {\n    vec2 uv = RandVec2();\n    float theta = 2.0 * PI * uv.x;\n    float psi = acos(2.0 * uv.y - 1.0);\n    float x = cos(theta) * sin(psi);\n    float y = sin(theta) * sin(psi);\n    float z = cos(psi);\n    return vec3(x, y, z);\n}\n// Random point *IN* sphere\n// This is biased!!! About 1/32 of the time, it will return a point in box instead of a sphere.\n/*vec3 RandPointInSphere() {\n    return RandPointOnSphere();\n    vec3 p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    p = Randf3i1(seed) * 2.0 - 1.0;\n    if (length(p) <= 1.0) return p;\n    return p;\n}*/\n\n// ---- Environment maps - a few to choose from ----\n// Make a procedural environment map with a giant softbox light and 4 lights around the sides.\nvec3 GetEnvMap3(vec3 rayDir)\n{\n    // Just some basic fades for the background\n    return vec3(rayDir.y*0.5+0.5)*1.25 + vec3(1.0,0.7,0.1)*(rayDir.z*0.5+0.5) + vec3(0.1,0.4,0.61)*(-rayDir.z*0.5+0.5)*0.5;\n\n/*    // fade bottom to top so it looks like the softbox is casting light on a floor\n    // and it's bouncing back\n    vec3 final = vec3(1.0) * dot(rayDir, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5;\n    final *= 0.125;\n    // overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    // fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    // purple lights from side\n    final += vec3(8.0,6.0,7.0) * saturate(0.001/(1.0 - abs(rayDir.x)));\n    // yellow lights from side\n    final += vec3(8.0,7.0,6.0) * saturate(0.001/(1.0 - abs(rayDir.z)));\n    return vec3(final);*/\n}\n\nvec3 GetEnvMap2(vec3 rayDir) {\n    //return vec3(0.0);\n    return vec3(rayDir.y*0.5+0.5);// * vec3(1.0, 0.5, 0.7);\n}\n\n// ---- Ray intersection functions and data structures ----\nstruct Ray\n{\n    vec3 p0, dirNormalized;\n    int outside;  // 1 ray is outside, -1 ray is inside, 0 terminate ray tracing iteration\n};\nstruct SceneHit\n{\n    vec3 hitPos;\n    vec3 hitNormal;\n    float pt;  // parametric t variable - how far along the ray vector is the intersection\n    int objIndex;  // unique index per object - used for material tricks like hashing colors\n    int materialIndex;  // Which material are we using\n};\n\n// As the ray bounces, it records hits in these vars.\nstruct ColorHit {\n    vec3 diffuse;\n    vec3 emission;\n};\nColorHit colorHits[NUM_ITERS];\nint colorHitIndex;\nvoid ResetColorHitList() {\n    colorHitIndex = 0;\n    for (int i = 0; i < NUM_ITERS; i++) {\n        colorHits[i].emission.x = -1.0;\n    }\n}\nvoid SaveHit(in vec3 diffuse, in vec3 emission) {\n    colorHits[colorHitIndex] = ColorHit(diffuse, emission);\n    colorHitIndex++;\n}\n\n\n//-- Scattering (fog) vars ----\n// Scattering needs a stack because it's all about what you're moving through.\n// So if you move through fog and then through glass, when you come out of the glass,\n// you're back into the fog.\n\n// This is the scatter var for the outer-most place. RGB fog diffuse, fog density.\n// **** Set fog here ****\nconst vec4 globalScatter = vec4(0.3, 0.4, 0.6, 0.005);//.5\n// Scatter stack\nvec4 scatterStack[NUM_ITERS*2];  // Size correct?\nint scatterStackIndex;\nvec4 PeekScatter() {\n    return scatterStack[scatterStackIndex-1];\n}\nvoid PushScatter(in vec4 s) {\n    if (s != PeekScatter())\n    {\n        scatterStack[scatterStackIndex] = s;\n        scatterStackIndex++;\n    }\n}\nvec4 PopScatter(in vec4 s) {\n    if (s != PeekScatter())\n    {\n        scatterStackIndex--;\n        return scatterStack[scatterStackIndex];\n    }\n}\nvoid InitScatterStack(in vec4 s) {\n    scatterStack[0] = s;\n    scatterStackIndex = 1;\n}\n\n// ---- Materials ----\n\n// List of refraction values for different materials\n// Linear reflectance values from http://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notes.pdf\n// In w, refrective index - https://en.wikipedia.org/wiki/List_of_refractive_indices\n// These can be calculated from each other: https://en.wikipedia.org/wiki/Schlick%27s_approximation\nconst vec4 refDebug = vec4(1.0,1.0,1.0, 1.005);\nconst vec4 refNone = vec4(0.0,0.0,0.0, 1.0);\nconst vec4 refWater = vec4(0.02,0.02,0.02, 1.330);\nconst vec4 refPlasticGlassLow = vec4(0.03,0.03,0.03, 1.42);\nconst vec4 refGlassWindow = vec4(0.043,0.043,0.043,1.52);\nconst vec4 refPlasticHigh = vec4(0.05,0.05,0.05, 1.58);\nconst vec4 refGlassHigh = vec4(0.08,0.08,0.08,1.79);  // Ruby\nconst vec4 refDiamond = vec4(0.172,0.172,0.172,2.417);\n// Metals - refractive index is placeholder and shouldn't be used I guess\nconst vec4 refIron = vec4(0.56,0.57,0.58,1.0);\nconst vec4 refCopper = vec4(0.95,0.64,0.54,1.0);\nconst vec4 refGold = vec4(0.995, 0.71, 0.29,1.0);\nconst vec4 refAluminum = vec4(0.91,0.92,0.92,1.0);\nconst vec4 refSilver = vec4(0.95,0.93,0.88,1.0);\nconst vec4 refSimpleMetal = vec4(0.92,0.92,0.92,1.0);  // rgb is same for better performance\n\nstruct Material {\n\tvec4 reflectRefract;\n    float refMult;\n    bool doRefraction;\n    vec3 diffuse;\n    vec3 emission;\n    vec3 filterDiffuseDensity;  // This is like a cheap scatter. Not sure I like it.\n    vec4 scatter;  // Diffuse in xyz, scatter probability in w.\n};\nconst int defaultMaterialIndex = 3;\nconst int NUM_MATERIALS = 7;\nMaterial materials[NUM_MATERIALS] = Material[NUM_MATERIALS](\n    // water (refraction broken, so just glossy black)\n    Material(refWater, 1.0, true, vec3(1.0), vec3(0.0), vec3(1.0), vec4(0.1, 0.7, 0.99, 0.0)),\n    // (refraction broken, so just glossy black)\n    Material(refGlassWindow, 1.0, true, vec3(0.0), vec3(0.0), vec3(1.0), vec4(0.99, 0.2, 0.05, 0.001)),\n    //Material(refPlasticGlassLow, 1.0, false, vec3(1.0), vec3(0.0), vec3(1.0), vec4(0.0)),\n    // gold\n    Material(refGold, 1.0, false, vec3(0.0), vec3(0.0), vec3(0.0), vec4(0.0)),\n    // colored plastic\n    Material(refPlasticGlassLow, 1.0, false, vec3(0.5,0.8,0.92), vec3(0.0), vec3(0.0), vec4(0.0)),\n    // non-shiny whatever\n    Material(refNone, 1.0, false, vec3(0.5), vec3(0.0), vec3(1.0), vec4(0.0)),\n    // light\n    Material(refNone, 0.0, true, vec3(1.0), vec3(14.0, 12.0, 7.0)*0.1, vec3(0.02), vec4(0.0)),\n    // light\n    Material(refNone, 0.0, false, vec3(1.0), vec3(200.0, 250.0, 300.0), vec3(0.0), vec4(0.0))\n);\n\n\n// ---- Also support ray marching, not just ray tracing. ----\n// k should be negative. -4.0 works nicely.\n// smooth blending function\n//float smin(float a, float b, float k)\n//{\n//\treturn log2(exp2(k*a)+exp2(k*b))/k;\n//}\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat spinTime;\nfloat cut = 0.77;\nfloat inner = 0.333;\nfloat outness = 1.414;\nfloat finWidth;\nfloat teeth;\nfloat globalTeeth;\n\n\n\n// This is the distance function that defines the ray marched scene's geometry.\n// The input is a position in space.\n// outside is 1 if the ray is intersecting with the outside of objects, -1 for insides (backface)\n// The output is the distance to the nearest surface, and a material index\nvec2 DistanceToObject(vec3 p, int outside)\n{\n\t//float d = length(p) - 4.0;\n    //return vec2(d, 1.0);\n    //float d = map(p);\n    return map(p);\n}\n\nSceneHit SceneMarch(const in Ray ray) {\n    SceneHit result;\n    result.hitNormal = vec3(0.0);\n    //result.pt = farPlane;\n    result.objIndex = BIG_INT;\n    result.materialIndex = defaultMaterialIndex;\n    vec2 distAndMat = vec2(0.0, -1.0);  // Distance and material\n\t// ----------------------------- Ray march the scene ------------------------------\n\tconst float maxDepth = 28.0; // farthest distance rays will travel\n    const float smallVal = 0.0625*0.125*0.0625;\n\tresult.pt = 0.0;\n    const float safety =1.0;// 0.975;\n    // First, escape if we are touching a surface already.\n    // Get the ray out of the negative part of the distance field. (rough hack)\n    float jump = smallVal;\n    for (int i = ZERO_TRICK; i < 16; i++) {  // Weird for loop trick so compiler doesn't unroll loop\n        // Step along the ray.\n        result.hitPos = (ray.p0 + ray.dirNormalized * result.pt);\n        distAndMat = DistanceToObject(result.hitPos, ray.outside);\n\n        if (abs(distAndMat.x) >= smallVal) break;\n        // move down the ray a safe amount\n        result.pt += jump;//safety;//* float(ray.outside);\n        //result.pt += distAndMat.x*2.0;//safety;//* float(ray.outside);\n        jump *= 2.0;  // This is not super good. Fix me eventually.\n        if (result.pt > maxDepth) break;\n    }\n\t// ray marching time\n    for (int i = 300; i >= 0; i--)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        result.hitPos = (ray.p0 + ray.dirNormalized * result.pt);\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(result.hitPos, ray.outside);\n\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if (abs(distAndMat.x) < smallVal) break;\n        // move down the ray a safe amount\n        result.pt += distAndMat.x*safety;\n        if (i == 0) result.pt = maxDepth+0.01;\n        if (result.pt > maxDepth) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// If a ray hit an object, calculate the normal and save the hit info.\n    if ((result.pt <= maxDepth) && (result.pt > 0.0))\n\t{\n        float dist = distAndMat.x;\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        // Normals still point out even if we're on the inside.\n        //float mid = DistanceToObject(result.hitPos, 1).x;\n        //vec3 normalU = vec3(mid - DistanceToObject(result.hitPos - smallVec.xyy, 1).x,\n        //                   mid - DistanceToObject(result.hitPos - smallVec.yxy, 1).x,\n        //                   mid - DistanceToObject(result.hitPos - smallVec.yyx, 1).x);\n        vec3 normalU = vec3(0.0);\n        for( int i=min(0,iFrame); i<4; i++ )\n        {\n            vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n            normalU += e*DistanceToObject(result.hitPos+smallVal*e, 1).x;\n        }\n        result.hitNormal = normalize(normalU);\n        result.objIndex = int(distAndMat.y);\n        result.materialIndex = int(distAndMat.y);\n\t}\n    else\n    {\n        // Our ray trace hit nothing. Set object index to big int.\n        result.hitNormal = vec3(0.0);\n        result.pt = farPlane;\n        result.objIndex = BIG_INT;\n        result.materialIndex = BIG_INT;\n    }\n    return result;\n}\n\n// ---- Main ray trace function ----\n// Trace a ray, hit, apply material, save hit, and return the bounced ray\nRay TraceOneRay(const in Ray ray) {\n    vec3 diffuse = vec3(1.0);\n    vec3 emission = vec3(0.0);\n\n    // Send a ray out into the scene. Combine both ray marching and ray tracing.\n    Ray newRay;\n    newRay.outside = ray.outside;\n    SceneHit resultB = SceneMarch(ray);\n    SceneHit result;\n \n    result = resultB;// ***** HACK GOT RID OF RAY TRACING... *****\n\n    vec4 currentScatter = PeekScatter();\n    Material material = materials[result.materialIndex % materials.length()];\n    // Calculate how far the ray goes before hitting a random scattering particle.\n    float lifetime = RayLifetime(currentScatter.w);\n    // If we hit an object instead of a scatter-particle or the far-plane...\n    if (result.pt < min(farPlane, lifetime)) {\n\n        // Debug normal visualization\n        //emission = result.hitNormal * 0.5 + 0.5;\n        //newRay.outside = 0;\n        //SaveHit(diffuse, emission);\n        //return newRay;\n\n        //mat3 basis = MakeBasis(result.hitNormal);\n        newRay.p0 = result.hitPos;\n\n        vec4 refMaterial = material.reflectRefract;\n        float reflectance = material.refMult;\n        float fresnel = refMaterial.z;\n        // If reflectance is different for different wavelengths, then let's change from\n        // rgb to r, g, or b stochastically while not losing energy. So we will end up\n        // tracing a ray representing a single wavelength of light.\n        // This can be done unconditionally because if xyz are the same, it doesn't matter anyway.\n        float choice = RandFloat();\n        if ((refMaterial.x != refMaterial.y) || (refMaterial.y != refMaterial.z)) {\n            // If we have already split to single wavelength, don't do it again.\n            /*if ( ((refMaterial.x == 0.0) && (refMaterial.y == 0.0)) ||\n                ((refMaterial.y == 0.0) && (refMaterial.z == 0.0)) ||\n                ((refMaterial.z == 0.0) && (refMaterial.x == 0.0)) ) {\n                // Take the non-zero component as the fresnel value.\n                fresnel = dot(refMaterial.xyz, vec3(1.0));\n            } else {\n                // .333 chance of switching to each single channel - r, g, or b.\n                if (choice < 0.33333) {\n                    fresnel = refMaterial.x;\n                    diffuse *= vec3(1.0, 0.0, 0.0);\n                } else if (choice < 0.66666) {\n                    fresnel = refMaterial.y;\n                    diffuse *= vec3(0.0, 1.0, 0.0);\n                } else diffuse *= vec3(0.0, 0.0, 1.0);\n                diffuse *= 3.0;  // To make up for stochastically dropping 2 out of 3 channels\n            }*/\n            fresnel = max(max(refMaterial.x, refMaterial.y), refMaterial.z);\n            diffuse *= refMaterial.xyz / fresnel;\n        }\n        // Figure out if we should reflect, or if the ray should go into the object (diffuse or refraction)\n        // Schlick's approximation\n        float oneMinusCos = 1.0 - saturate(dot(ray.dirNormalized, -result.hitNormal* float(ray.outside)));\n        float reflectProb = fresnel + (1.0-fresnel) * pow(oneMinusCos, 5.0);\n        reflectProb *= reflectance;\n        if (RandFloat() < reflectProb) {\n\t        //if ((refMaterial.x != refMaterial.y) || (refMaterial.y != refMaterial.z)) diffuse *= refMaterial.xyz * fresnel;\n            // reflect\n\t        vec3 reflection = reflect(ray.dirNormalized, result.hitNormal);// * float(ray.outside));\n            newRay.dirNormalized = normalize(reflection);\n            // Already did the probability of reflection before, so no need to multiply anything.\n            //diffuse *= vec3(1.0);\n        } else {\n            //if ((refMaterial.x != refMaterial.y) || (refMaterial.y != refMaterial.z)) diffuse *= 1000000.0;\n            if (material.doRefraction) {\n                // refract\n                float refractionIndex = 1.0 / refMaterial.w;  // 1.33 is water, 1.5 is glass.\n                if (ray.outside == -1) refractionIndex = 1.0 / refractionIndex;\n\n                vec3 refraction = refract(ray.dirNormalized, result.hitNormal * float(ray.outside), refractionIndex);\n                if (dot(refraction, refraction) > 0.0) {\n                    // Standard refraction\n\t                newRay.dirNormalized = normalize(refraction);\n                } else {\n                    // Special case - total internal reflection.\n                    // This is where at glancing angles, the surface will act like a mirror.\n                    // It's what makes fiber optics work. :D\n                    vec3 reflection = reflect(ray.dirNormalized, result.hitNormal * float(ray.outside));\n                    newRay.dirNormalized = normalize(reflection);\n                }\n                if (ray.outside == 1) {\n                    PushScatter(material.scatter);\n                } else {\n                    PopScatter(material.scatter);\n                }\n                newRay.outside = -ray.outside;\n            } else {\n                // Diffuse light\n                // Get a random vector in the hemisphere pointing along the normal.\n\t            vec3 rand = RandPointOnSphere();\n                vec3 bounce = rand * sign(dot(result.hitNormal, rand));\n                newRay.dirNormalized = bounce;\n                // Lambert shading model\n                //float intensity = dot(bounce, result.hitNormal);\n                diffuse *= material.diffuse;// * intensity;\n                emission = material.emission;\n            }\n\n        }\n    } else {\n        if (lifetime < farPlane) {\n            // Scattering (fog)\n            newRay.p0 = ray.p0 + ray.dirNormalized * lifetime;\n            newRay.dirNormalized = RandPointOnSphere();\n            diffuse *= currentScatter.xyz;\n            //emission = material.emission;\n        } else {\n            // Hit the background image. Let's be done ray tracing.\n            emission = GetEnvMap3(ray.dirNormalized);\n            newRay.outside = 0;  // This terminates the ray.\n        }\n    }\n    // Filtering\n    // Filter proportional to how long the ray moves inside the object\n    // This can also be done with scattering, but this should converge quicker.\n    if (ray.outside == -1) {\n        vec3 internal = material.filterDiffuseDensity.xyz;\n        diffuse *= pow(internal, vec3(abs(result.pt)));\n        emission = material.emission * pow(internal, vec3(abs(result.pt)));\n    }\n\n    // Save the ray hit in a list so we can calculate color of the pixel later on.\n    SaveHit(diffuse, emission);\n    return newRay;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SetRandomSeed(fragCoord.xy, iResolution.xy, iFrame);\n    vec2 position = (gl_FragCoord.xy / iResolution.xy);\n    // read original buffer so we can accumulate pixel values into back it.\n\tvec4 backpixel = texture(iChannel0, position);\n    // If we use the mouse to change the view, reset the pixel accumulation buffer\n    if (iMouse.z > 0.0) backpixel = vec4(0.0);\n\n\t// ----------------------------------- Animate ------------------------------------\n    float localTime = 3.99;// iTime*0.5;\n    // This is a wave function like a triangle wave, but with flat tops and bottoms.\n    // period is 1.0\n    float rampStep = min(3.0,max(1.0, abs((fract(localTime)-0.5)*1.0)*8.0))*0.5-0.5;\n    rampStep = smoothstep(0.0, 1.0, rampStep);\n    // lopsided triangle wave - goes up for 3 time units, down for 1.\n    float step31 = (max(0.0, (fract(localTime+0.125)-0.25)) - min(0.0,(fract(localTime+0.125)-0.25))*3.0)*0.333;\n\n    spinTime = step31 + localTime;\n    //globalTeeth = 0.0 + max(0.0, sin(localTime*3.0))*0.9;\n    globalTeeth = rampStep*0.99;\n    cut = max(0.48, min(0.77, localTime));\n\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv_orig = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 2.4;\n    vec2 uv = uv_orig / zoom;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\n\t//vec3 camLookat=vec3(0,0.91,0);\n\n    // camera orbit with mouse movement\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7;\n\tfloat my=-iMouse.y/iResolution.y*10.0;\n\tvec3 camPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(16.0);\n    // If mouse is in bottom left corner, then use pre-set camera angle.\n    //if ((dot(iMouse.xy, vec2(1.0)) <= 64.0)) camPos = vec3(-4.0, 0.1, 7.1);\n    if ((dot(iMouse.xy, vec2(1.0)) <= 64.0)) camPos = vec3(-7.0, 6.6, 7.0)*1.25;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\n    // Depth of field hack... I think the math is all wrong.\n    const float depthOfFieldAmount = 0.0003;\n    vec2 rg = RandGaussianCircle()*depthOfFieldAmount;\n    camPos += sideNorm * rg.x;\n    camPos += upNorm * rg.y;\n    camVec=normalize(camLookat - camPos);\n    sideNorm=normalize(cross(upNorm, camVec));\n    upNorm=cross(camVec, sideNorm);\n\n    // More camera setup\n    vec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// --------------------------------------------------------------------------------\n    vec3 colorSum = vec3(0.0);\n    // Loop through for a few samples and average the pixel colors from ray tracing.\n    for (int s = ZERO_TRICK; s < NUM_SAMPLES; s++) {  // Weird for loop trick so compiler doesn't unroll loop\n        InitScatterStack(globalScatter);\n        ResetColorHitList();\n        Ray ray;\n        ray.outside = 1;\n        ray.p0 = camPos;\n        // Anti-aliasing: Randomly jitter the ray direction by a gaussian distribution.\n        vec2 gauss = RandGaussianCircle();\n        float antialias = dFdx(uv.xy).x/1.5;\n        ray.dirNormalized = normalize(rayVec +\n                                      sideNorm*gauss.x*antialias +\n                                      upNorm * gauss.y*antialias);\n\n        // Trace a ray from the camera outwards, bounce the ray off objects and keep\n        // tracing until NUM_ITERS or until it hits the background.\n        for (int i = ZERO_TRICK; i < NUM_ITERS; i++) {\n            if (i == (NUM_ITERS-1)) break;\n            ray = TraceOneRay(ray);\n            if (ray.outside == 0) break;\n        }\n        /*int i = 0;\n        do {\n            ray = TraceOneRay(ray);\n            i++;\n        } while ((ray.outside != 0) && (i < NUM_ITERS-1));*/\n\n        // Once we're done iterating through rays from the camera outwards, we have a\n        // list of hits. Now we can go from the light source toward the camera and apply\n        // the color filters and emissions as we go.\n\t    vec4 finalColor = vec4(0.0, 0.0, 0.0, 0.0);\n        for (int i = NUM_ITERS-1; i >= ZERO_TRICK; i--) {\n            if (colorHits[i].emission.x != -1.0) {\n                finalColor.xyz *= colorHits[i].diffuse;\n                finalColor.xyz += colorHits[i].emission;\n                //finalColor.xyzw = finalColor.yzwx;  // Debug ray depth\n            }\n        }\n        colorSum += finalColor.xyz;\n    }\n    colorSum /= float(NUM_SAMPLES);\n\n    // output the final color\n\tfragColor = vec4(saturate(colorSum/4096.0),1.0) + backpixel;\n}\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssS3WW.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1194, 1194, 1250, 1250, 1371]], "test": "untested"}
{"id": "7sS3WD", "name": "Robot Dance", "author": "blackle", "description": "for the revision 2021 shader showdown\n\nUPDATE: added a crummy revision logo", "tags": ["revision", "shadershowdown", "livecode"], "likes": 28, "viewed": 644, "published": 3, "date": "1617403353", "time_retrieved": "2024-07-30T19:29:09.392950", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat box(vec3 p, vec3 d) {\n  p = abs(p) - d;\n  return length(max(p,0.)) + min(0.,max(max(p.x,p.y),p.z));\n}\n\nfloat joint(vec3 p, vec3 d) {\n  return min(length(p - vec3(0,0,d.z))-d.y*1.5-.02, box(p,d)-.02);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\n//from https://www.shadertoy.com/view/4sKyRK\nfloat distanceToBottleCurve(vec2 point) {\n    return point.y-0.1*sin(point.x*2.5 + 0.6) + 0.05*sin(5.0*point.x) + 0.04*sin(7.5*point.x);\n}\nbool texturee(vec2 uv) {\n    float ang = atan(uv.y, uv.x);\n    float len = floor(length(uv)*10.0);\n    bool val = len == 2. || len == 6. || len == 9.;\n    if (len == 3. || len == 4. || len == 5. || len == 8. || len == 10.) {\n        val = distanceToBottleCurve(vec2(ang+len,0.0))*7.99 > cos(len*7.99);\n    }\n    return val;\n}\n\nfloat r1;\nfloat r2;\nfloat r3;\nfloat r4;\nfloat r5;\nfloat r6;\nfloat arm;\nfloat fl;\nfloat scene(vec3 p) {\n  float dist = joint(p, vec3(.1,.1,.4));\n  fl = p.z+.4;\n  dist = min(dist,fl);\n  p = erot(erot(p,vec3(0,0,1),r2)-vec3(0.,0.,.4), vec3(1,0,0), r1) - vec3(0,0,0.3);\n  dist = min(dist, joint(p, vec3(.1,.1,.3)));\n  p = erot(erot(p,vec3(0,0,1),r4)-vec3(0.,0.,.3), vec3(1,0,0), r3) - vec3(0,0,0.3);\n  dist = min(dist, joint(p, vec3(.1,.1,.3)));\n  p -= vec3(0,0,.32);\n  p = erot(p,vec3(0,0,1),r6);\n  arm = box(p, vec3(.09,.3,.09))-.02;\n  p.y = abs(p.y);\n  p -= vec3(0,.3,.12);\n  p = erot(p-vec3(0,0,-.2), vec3(1,0,0), r5);\n  arm = min(arm, length(p+vec3(0,0,-.1))-.15);\n  arm = min(arm, joint(p-vec3(0,0,.3), vec3(.05,.05,.2)));\n  return min(dist,arm);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n  int x = FK(a), y = FK(b);\n  return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat spring(float x) {\n  return smoothstep(-.1,.1,x) + smoothstep(-.2,.2,x) - smoothstep(-.3,.3,x);\n}\n\nfloat bpm = 130.;\nfloat mayhem(float sd) {\n  float off = hash(sd,sd)*99.;\n  float idx = floor((iTime+off)*bpm/240.+.5);\n  float interp = iTime + off - idx*240./bpm;\n  float start = hash(idx, sd);\n  float end = hash(round(idx+1.), sd);\n  return mix(start, end, spring(interp));\n}\n\nfloat revisionTexture(vec2 p) {\n    return texturee(p*2.5) ? 0.:1.;\n    return step(0., sin(length(p*40.)+atan(p.x,p.y)));\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n      r1 = mayhem(12.);\n  r3 = mayhem(32.);\n  r5 = mayhem(72.)*.5+.5;\n  r2 = mayhem(92.);\n  r4 = mayhem(78.);\n  r6 = mayhem(89.);\n  float hs = mayhem(45.);\n  \n  vec3 cam = normalize(vec3(1.+hs*.5+.5,uv));\n  vec3 init = vec3(-5,0,.5+hs*.2);\n  \n  float yrot = .5+mayhem(85.)*.3;\n  float zrot = iTime+mayhem(98.);\n  cam = erot(cam, vec3(0,1,0), yrot);\n  init = erot(init, vec3(0,1,0), yrot);\n  cam = erot(cam, vec3(0,0,1), zrot);\n  init = erot(init, vec3(0,0,1), zrot);\n  \n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  for (int i = 0; i<150 && !hit; i++) {\n    dist = scene(p);\n    hit = dist*dist < 1e-6;\n    p += cam*dist;\n    if (distance(p,init)>10.) break;\n  }\n  bool isfl = fl == dist;\n  bool isarm = arm == dist;\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float fres = 1. - abs(dot(cam,n))*.98;\n  float spec = length(sin(r*3.)*.5+.5)/length(3.);\n  spec = pow(spec, 3.)*2. + spec*.2;\n  spec *= fres;\n  vec3 col = vec3(spec);\n  if (isarm) {\n    col += vec3(.8,.3,.1)*length(sin(n*2.)*.3+.7)/sqrt(3.);\n  }\n  if (isfl) {\n    col = vec3(1);\n    if(length(p.xy) < 3.) {\n      if (length(p.xy) < 1.5) {\n        p = erot(p, vec3(0,0,1), mayhem(78.));\n      } else {\n        p = erot(p, vec3(0,0,1), mayhem(99.));\n      }\n      col = vec3(revisionTexture(p.xy/6.));\n    }\n  }\n\n\tfragColor.xyz = smoothstep(0.,1.,sqrt(hit ? col : vec3(1)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sS3WD.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 221, 221, 301], [303, 303, 332, 332, 401], [403, 403, 441, 441, 505], [507, 552, 593, 593, 690], [691, 691, 715, 715, 1016], [1099, 1099, 1120, 1120, 1768], [1825, 1825, 1855, 1855, 1927], [1929, 1929, 1952, 1952, 2031], [2051, 2051, 2075, 2075, 2311], [2313, 2313, 2344, 2344, 2437], [2439, 2439, 2458, 2458, 2572], [2574, 2574, 2631, 2681, 4090]], "test": "ok"}
{"id": "sdS3WD", "name": "Flowers and foliage 5", "author": "jarble", "description": "A simple fractal formula.\nFull-screen mode recommended.", "tags": ["fractal", "flower", "rainbow"], "likes": 2, "viewed": 265, "published": 3, "date": "1617402080", "time_retrieved": "2024-07-30T19:29:10.244672", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.0;\n        float scale1 = 1.4;\n        float s1 = scale1*scale;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.0-abs((uv.x-uv.y)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            uv.x *= -(1.0+col.x/scale);\n            col[c] = fract((.25*col[c]+col.x+(uv.y)-(uv.x))/(2.5+fract(uv.x+uv.y)));\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 761]], "test": "untested"}
{"id": "7sSGWD", "name": "Rainbow Feathers", "author": "jarble", "description": "A simple fractal formula.\nFull-screen mode recommended.", "tags": ["fractal", "rainbow", "feather"], "likes": 3, "viewed": 227, "published": 3, "date": "1617400569", "time_retrieved": "2024-07-30T19:29:11.063483", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.5;\n        float scale1 = 1.4;\n        float s1 = scale1*scale;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.0-abs((uv.x-uv.y)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            uv.x *= -(1.0+col.x/scale);\n            col[c] = fract((.25*col[c]+col.x+(uv.y)-(uv.x))/2.5);\n        }\n     \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 748]], "test": "untested"}
{"id": "7sSGDW", "name": "MSAA, gamma and UV boilerplate", "author": "clepirelli", "description": "Boilerplate for a main function with brute-force msaa, gamma correction and UV coordinates calculation\n\nThe boilerplate calls a function returning a vec3 and taking in uv as a vec2", "tags": ["template", "gammacorrection", "boilerplate", "msaa"], "likes": 1, "viewed": 452, "published": 3, "date": "1617395792", "time_retrieved": "2024-07-30T19:29:11.937147", "image_code": "\nvec3 Image(vec2 uv)\n{\n    return 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n}\n\nMAIN_FUNCTION(Image)", "image_inputs": [], "common_code": "const int aa = 2;\nconst float aperture = 1.0;\n\nvec4 colorCorrect(vec3 color)\n{\n    vec3 x = max(vec3(.0), color*aperture-.004);\n    vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n    return vec4(min(retColor, 1.0), 1.0);\n}\n\n#define MAIN_FUNCTION(function) \\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\\n{\\\n    vec3 total = vec3(.0);\\\n    /*MSAA*/\\\n    for(int i = 0; i <aa;i++)\\\n    for(int j = 0; j <aa;j++)\\\n    {\\\n    \t/*offset the uv for MSAA*/\\\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\\\n    \tuv.x *= iResolution.x/iResolution.y;\\\n    \t\\\n        total+= function(uv);\\\n    }\\\n    total /= float(aa*aa);\\\n    \\\n    /*Output to screen*/\\\n    fragColor = colorCorrect(total);\\\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 76]], "test": "untested"}
{"id": "ssB3WW", "name": "xor noise thing", "author": "Azorlogh", "description": "Cool noise-ish thing I stumbled upon", "tags": ["xornoise"], "likes": 4, "viewed": 267, "published": 3, "date": "1617393876", "time_retrieved": "2024-07-30T19:29:12.750971", "image_code": "vec3 rotateXY(vec3 v, float a) { float c = cos(a), s = sin(a); return mat3( c, s, 0, -s, c, 0, 0, 0, 1 )*v; }\nvec3 rotateXZ(vec3 v, float a) { float c = cos(a), s = sin(a); return mat3( c, 0, s, 0, 1, 0, -s, 0, c )*v; }\nvec3 rotateYZ(vec3 v, float a) { float c = cos(a), s = sin(a); return mat3( 1, 0, 0, 0, c, s, 0, -s, c )*v; }\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n// change to NOISE_0 for greyscale\n#define NOISE_1\n\nvec3 noise(ivec2 pos) {\n    #ifdef NOISE_0\n    vec3 p = vec3(pos, uint(iTime*1.0));\n\tp=rotateXZ(p, 0.4+iTime*0.0123);\n\tp=rotateYZ(p, 0.3232+iTime*0.1);\n    return vec3(\n        hash11(uint(int(p.x) ^ int(p.y) ^ int(p.z)))\n    );\n    #elif defined NOISE_1\n    vec3 p = vec3(pos, iTime*5.0);\n\tp=rotateXZ(p, 0.5+iTime*0.123);\n\tp=rotateYZ(p, 0.3232+iTime*0.05);\n\tvec3 col = vec3(0);\n\tcol.r = hash11(uint(int(p.x) ^ int(p.y) ^ int(p.z)));\n\tp=rotateXZ(p, 0.02);\n\tp=rotateYZ(p, 0.04232);\n\tcol.g = hash11(uint(int(p.x) ^ int(p.y) ^ int(p.z)));\n\tp=rotateXZ(p, 0.01);\n\tp=rotateYZ(p, 0.02);\n\tcol.b = hash11(uint(int(p.x) ^ int(p.y) ^ int(p.z)));\n    return col;\n    #endif\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    U -= iResolution.xy/2.;\n    U /= iResolution.y/2.;\n\n\tO.xyz = vec3(noise(ivec2(U*200.0)));\n    O.w = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssB3WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 109], [110, 110, 142, 142, 219], [220, 220, 252, 252, 329], [486, 486, 508, 508, 578], [632, 632, 655, 655, 1295], [1297, 1297, 1338, 1338, 1448]], "test": "untested"}
{"id": "fsB3WD", "name": "Reduce tangent-grazing artifacts", "author": "elenzil", "description": "Exp. to reduce artifacts when the ray is nearly tangent to surface.\n--> If we happen to be on the last iteration of marching, then use a much larger epsilon. <--\nL: No fix\nR: Fix\nT: 150 iters steps\nB: 70 iters\n\noriginal: https://shadertoy.com/view/fdBGWD", "tags": ["tangents", "artifacts"], "likes": 11, "viewed": 310, "published": 3, "date": "1617382296", "time_retrieved": "2024-07-30T19:29:13.598705", "image_code": "/*\n * oxe:\n * An experiment using oneshade's beautiful \"Limited Smooth Mod\" shader https://shadertoy.com/view/fdBGWD .\n * \n * The idea here is to reduce those annoying sky-showing-through artifacts we always get near edge-on surfaces\n * when the ray has marched out to its maximum number of steps and we're spending our time\n * running parallel to a surface.\n *\n * --> When checking if we're \"close enough\" to the surface to call it a hit,\n * --> if we happen to be on the last iteration, then use a much wider threshhold.\n * --> ie, on the last step check for say epsilon 2.0 instead of epsilon 0.001.\n * \n * This introduces some inaccuracies where actual surfaces blend together.\n *\n */\n\n\n\n// Fork of \"Limited Smooth Mod\" by oneshade. \n// 2021-04-02 16:24:13\n\n// SDFs\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\n// Distance operators\n// Use continuous! It will look a lot nicer.\nfloat smoothModLim(in float x, in float span, in float size, in float smoothness, in bool continuous) {\n    float m = 1.0 - smoothness;\n    float ss = span / size;\n\n    float sModX = asin(sin(x / size) * m) * size;\n\n    float slope = 1.0;\n    float offs = asin(sin(ss) * m) * size;\n\n    if (continuous) {\n        float s = sin(ss);\n        slope = m * cos(ss) / sqrt(1.0 - m * m * s * s);\n    }\n\n    float sModLimX = mix(sModX, (x - span) * slope + offs, step(span, x));\n    sModLimX = mix(sModLimX, (x + span) * slope - offs, 1.0 - step(-span, x));\n\n    return sModLimX;\n}\n\n// Scene\nfloat mapScene(in vec3 p) {\n    p.x = smoothModLim(p.x, 6.0, 1.5, 0.3, true);\n    p.y = smoothModLim(p.y, 6.0, 1.5, 0.3, true);\n    p.z = smoothModLim(p.z, 6.0, 1.5, 0.3, true);\n    \n    float t = iTime * 0.03 + 13.5;\n\n    float c = cos(t), s = sin(t);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n\n    return sdBox(p, vec3(1.0, 0.25, 1.5));\n}\n\n// Gradient\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nint iterMax(in vec2 fragCoord) {\n    // oxe: 70 iterations is a bit artifically low here, to exaggerate the effect.\n    // oneshade's original value is 150.\n    return fragCoord.y > iResolution.y / 2.0 ? 150 : 70;\n}\n\nbool closeEnough(in vec2 fragCoord, in float d, in int iter) {\n    if (fragCoord.x < iResolution.x / 2.0) {\n        return d < 0.001;\n    }\n    else {\n        return (d < 0.001) || (iter == iterMax(fragCoord) && d < 2.0);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = true ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 25.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    // Raymarch\n    float t = 0.0, d;\n    for (int i=0; i <= iterMax(fragCoord); i++) {\n        vec3 p = ro + rd * t;\n        d = mapScene(p);\n        if (closeEnough(fragCoord, d, i)) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            vec3 color = abs(n) * 1.25;\n            fragColor.rgb = color * max(0.2, dot(n, l));\n\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n    \n    // oxe: screen-split lines\n    fragColor = mix(fragColor, vec4(1.0), 0.5 * floor(mod((fragCoord.x - iResolution.x / 2.0 + 10.0) / 20.0, 2.0)) * smoothstep(2.0, 0.0, abs(fragCoord.y - iResolution.y / 2.0)));\n    fragColor = mix(fragColor, vec4(1.0), 0.5 * floor(mod((fragCoord.y - iResolution.y / 2.0 + 10.0) / 20.0, 2.0)) * smoothstep(2.0, 0.0, abs(fragCoord.x - iResolution.x / 2.0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsB3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[762, 770, 805, 805, 900], [902, 969, 1072, 1072, 1542], [1544, 1553, 1580, 1580, 1913], [1915, 1927, 1954, 1954, 2201], [2203, 2203, 2235, 2359, 2418], [2420, 2420, 2482, 2482, 2649], [2651, 2651, 2706, 2706, 4193]], "test": "untested"}
{"id": "NdB3WD", "name": "Mandelbrot Set Smooth 2", "author": "me_123", "description": "This is just a little test to see how fast my GPU can render a Mandelbrot Set. It works much better than i expected!", "tags": ["fractal"], "likes": 0, "viewed": 265, "published": 3, "date": "1617381917", "time_retrieved": "2024-07-30T19:29:14.439457", "image_code": "vec4 load(in int x, in int y) {\n\treturn texelFetch(iChannel0, ivec2(x, y), 0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 mouse = iMouse.xy/iResolution.xy;\n    vec2 uv = (fragCoord.xy/iResolution.xy)-0.5;\n    float zoom = 2.;//10.-iTime;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= zoom;\n    //uv -= vec2(0., 0.)+load(1, 0).xy*vec2(iResolution.x/iResolution.y, 1)*zoom;\n    vec2 z = vec2(0, 0);\n    vec2 c = uv;\n    float itr = 1.;\n    int m = clamp(iFrame, 1, 100);\n    for (int i = 0; i < m; i += 1) {\n    \tz = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y)+c;\n        if (length(z) > clamp(iTime, 0.0, 2.0)){\n            break;\n\t\t}\n        itr *= length(z)/2.0;\n    }\n    vec3 col = vec3(pow((itr*10.0)/5.0, 0.1));\n    uv -= load(1, 0).xy*vec2((iResolution.x/iResolution.y), 1);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdB3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 80], [81, 81, 138, 138, 836]], "test": "untested"}
{"id": "fdBGWD", "name": "Limited Smooth Mod", "author": "oneshade", "description": "A limited smooth mod operator based on the infinite one by @blackle in this shadertoy: [url=https://www.shadertoy.com/view/wlyBWm]https://www.shadertoy.com/view/wlyBWm[/url]", "tags": ["sdf", "mod", "smooth", "repeat", "operator", "limited", "smod"], "likes": 13, "viewed": 263, "published": 3, "date": "1617378359", "time_retrieved": "2024-07-30T19:29:15.227350", "image_code": "// SDFs\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\n// Distance operators\n// Use continuous! It will look a lot nicer.\n// Be sure to choose a span that that is a close multiple of the\n// repeat size (times pi because of the trig) otherwise the edges\n// will get really stretched due to the space distortions by the smooth mod.\nfloat smoothModLim(in float x, in float span, in float size, in float smoothness, in bool continuous) {\n    float m = 1.0 - smoothness;\n    float ss = span / size;\n\n    float sModX = asin(sin(x / size) * m) * size;\n\n    float slope = 1.0;\n    float offs = asin(sin(ss) * m) * size;\n\n    if (continuous) {\n        float s = sin(ss);\n        slope = m * cos(ss) / sqrt(1.0 - m * m * s * s);\n    }\n\n    // The mixes are a (shorter) alternative for ifs and elses\n    float sModLimX = mix(sModX, (x - span) * slope + offs, step(span, x));\n    sModLimX = mix(sModLimX, (x + span) * slope - offs, step(span, -x));\n\n    return sModLimX;\n}\n\n// Overloading for vec2\nvec2 smoothModLim(in vec2 x, in vec2 span, in vec2 size, in float smoothness, in bool continuous) {\n    x.x = smoothModLim(x.x, span.x, size.x, smoothness, continuous);\n    x.y = smoothModLim(x.y, span.y, size.y, smoothness, continuous);\n    return x;\n}\n\n// Overloading for vec3\nvec3 smoothModLim(in vec3 x, in vec3 span, in vec3 size, in float smoothness, in bool continuous) {\n    x.xy = smoothModLim(x.xy, span.xy, size.xy, smoothness, continuous);\n    x.z = smoothModLim(x.z, span.z, size.z, smoothness, continuous);\n    return x;\n}\n\n// Scene\nfloat mapScene(in vec3 p) {\n    p = smoothModLim(p, vec3(6.0), vec3(1.5), 0.3, true);\n\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n\n    return sdBox(p, vec3(1.0, 0.25, 1.5)) - 0.2;\n}\n\n// Gradient\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = true ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 25.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    // Raymarch\n    float t = 0.0, d;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            vec3 color = abs(n) * 1.25;\n            fragColor.rgb = color * max(0.2, dot(n, l));\n\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 8, 43, 43, 138], [140, 415, 518, 518, 1045], [1047, 1071, 1170, 1170, 1324], [1326, 1350, 1449, 1449, 1607], [1609, 1618, 1645, 1645, 1860], [1862, 1874, 1901, 1901, 2148], [2150, 2150, 2205, 2205, 3266]], "test": "untested"}
{"id": "tl2fDR", "name": "asdkfjhaskjdhfaksjdhfaklsjhdfasj", "author": "lennyjpg", "description": "sdfasdfasdf", "tags": ["dfsdf"], "likes": 0, "viewed": 232, "published": 3, "date": "1617377670", "time_retrieved": "2024-07-30T19:29:16.056134", "image_code": "vec3 rgb2hsl(vec3 color) {\n \tvec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n\n \tfloat fmin = min(min(color.r, color.g), color.b); //Min. value of RGB\n \tfloat fmax = max(max(color.r, color.g), color.b); //Max. value of RGB\n \tfloat delta = fmax - fmin; //Delta RGB value\n\n \thsl.z = (fmax + fmin) / 2.0; // Luminance\n\n \tif (delta == 0.0) //This is a gray, no chroma...\n \t{\n \t\thsl.x = 0.0; // Hue\n \t\thsl.y = 0.0; // Saturation\n \t} else //Chromatic data...\n \t{\n \t\tif (hsl.z < 0.5)\n \t\t\thsl.y = delta / (fmax + fmin); // Saturation\n \t\telse\n \t\t\thsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\n \t\tfloat deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n \t\tfloat deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n \t\tfloat deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\n \t\tif (color.r == fmax)\n \t\t\thsl.x = deltaB - deltaG; // Hue\n \t\telse if (color.g == fmax)\n \t\t\thsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n \t\telse if (color.b == fmax)\n \t\t\thsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\n \t\tif (hsl.x < 0.0)\n \t\t\thsl.x += 1.0; // Hue\n \t\telse if (hsl.x > 1.0)\n \t\t\thsl.x -= 1.0; // Hue\n \t}\n\n \treturn hsl;\n }\nvec3 rgb2hsv(vec3 rgb) {\n \tfloat Cmax = max(rgb.r, max(rgb.g, rgb.b));\n \tfloat Cmin = min(rgb.r, min(rgb.g, rgb.b));\n \tfloat delta = Cmax - Cmin;\n\n \tvec3 hsv = vec3(0., 0., Cmax);\n\n \tif (Cmax > Cmin) {\n \t\thsv.y = delta / Cmax;\n\n \t\tif (rgb.r == Cmax)\n \t\t\thsv.x = (rgb.g - rgb.b) / delta;\n \t\telse {\n \t\t\tif (rgb.g == Cmax)\n \t\t\t\thsv.x = 2. + (rgb.b - rgb.r) / delta;\n \t\t\telse\n \t\t\t\thsv.x = 4. + (rgb.r - rgb.g) / delta;\n \t\t}\n \t\thsv.x = fract(hsv.x / 6.);\n \t}\n \treturn hsv;\n }\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/max(iResolution.x,iResolution.y);\n    float t = iMouse.x + iTime * 0.02;\n    vec2 u = uv * 1.3;\n   \n    u+=200.0;\n    float d = snoise(vec3(-u.x,-u.y,t+55.0)*0.1);\n    /*\n    float f = 0.5;\n    float angle = d*2.0;\n    u.x+=sin(angle)*f;\n    u.y+=cos(angle)*f;\n*/\n    \n    float r = snoise(vec3(u.x,u.y,t));\n    u+=123.45;\n    float g = snoise(vec3(u.x,u.y,t+10.0));\n    u+=1123.45;\n    float b = snoise(vec3(u.x,-u.y,t+50.0));\n    vec3 off = vec3(1.0, 0.6, 0.37);\n    vec3 rgb = 0.5-vec3(r,g,b)*off;\n    vec3 col = rgb2hsv(rgb);\n    //col*=0.9;\n   // col.b-=d*3.0;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 1167], [1168, 1168, 1192, 1192, 1638], [1640, 1640, 1661, 1661, 1710], [1712, 1712, 1733, 1733, 1782], [1784, 1784, 1806, 1806, 1846], [1848, 1848, 1876, 1876, 1928], [1930, 1930, 1954, 1954, 4100], [4103, 4103, 4160, 4160, 4783]], "test": "untested"}
{"id": "WddyRs", "name": "edgedirt", "author": "lennyjpg", "description": "dfgsdgsdfgsdfgsdf", "tags": ["dfgsdg"], "likes": 1, "viewed": 256, "published": 3, "date": "1617377407", "time_retrieved": "2024-07-30T19:29:16.954732", "image_code": "vec3 rgb2hsl(vec3 color) {\n \tvec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n\n \tfloat fmin = min(min(color.r, color.g), color.b); //Min. value of RGB\n \tfloat fmax = max(max(color.r, color.g), color.b); //Max. value of RGB\n \tfloat delta = fmax - fmin; //Delta RGB value\n\n \thsl.z = (fmax + fmin) / 2.0; // Luminance\n\n \tif (delta == 0.0) //This is a gray, no chroma...\n \t{\n \t\thsl.x = 0.0; // Hue\n \t\thsl.y = 0.0; // Saturation\n \t} else //Chromatic data...\n \t{\n \t\tif (hsl.z < 0.5)\n \t\t\thsl.y = delta / (fmax + fmin); // Saturation\n \t\telse\n \t\t\thsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\n \t\tfloat deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n \t\tfloat deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n \t\tfloat deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\n \t\tif (color.r == fmax)\n \t\t\thsl.x = deltaB - deltaG; // Hue\n \t\telse if (color.g == fmax)\n \t\t\thsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n \t\telse if (color.b == fmax)\n \t\t\thsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\n \t\tif (hsl.x < 0.0)\n \t\t\thsl.x += 1.0; // Hue\n \t\telse if (hsl.x > 1.0)\n \t\t\thsl.x -= 1.0; // Hue\n \t}\n\n \treturn hsl;\n }\nvec3 rgb2hsv(vec3 rgb) {\n \tfloat Cmax = max(rgb.r, max(rgb.g, rgb.b));\n \tfloat Cmin = min(rgb.r, min(rgb.g, rgb.b));\n \tfloat delta = Cmax - Cmin;\n\n \tvec3 hsv = vec3(0., 0., Cmax);\n\n \tif (Cmax > Cmin) {\n \t\thsv.y = delta / Cmax;\n\n \t\tif (rgb.r == Cmax)\n \t\t\thsv.x = (rgb.g - rgb.b) / delta;\n \t\telse {\n \t\t\tif (rgb.g == Cmax)\n \t\t\t\thsv.x = 2. + (rgb.b - rgb.r) / delta;\n \t\t\telse\n \t\t\t\thsv.x = 4. + (rgb.r - rgb.g) / delta;\n \t\t}\n \t\thsv.x = fract(hsv.x / 6.);\n \t}\n \treturn hsv;\n }\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/max(iResolution.x,iResolution.y);\n    float t = iMouse.x + iTime * 0.02;\n    vec2 u = uv * 1.;\n   \n    u+=200.0;\n    float d = snoise(vec3(-u.x,-u.y,t+55.0)*0.1);\n    /*\n    float f = 0.5;\n    float angle = d*2.0;\n    u.x+=sin(angle)*f;\n    u.y+=cos(angle)*f;\n*/\n    \n    float r = snoise(vec3(u.x,u.y,t));\n    u+=123.45;\n    float g = snoise(vec3(u.x,u.y,t+10.0));\n    u+=1123.45;\n    float b = snoise(vec3(u.x,-u.y,t+50.0));\n    vec3 off = vec3(.7, 0.2, 0.7);\n    vec3 rgb = 0.5-vec3(r,g,b)*off;\n    rgb.b+=uv.y;\n    vec3 col = rgb2hsv(rgb);\n    //col*=0.9;\n   // col.b-=d*3.0;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 1167], [1168, 1168, 1192, 1192, 1638], [1640, 1640, 1661, 1661, 1710], [1712, 1712, 1733, 1733, 1782], [1784, 1784, 1806, 1806, 1846], [1848, 1848, 1876, 1876, 1928], [1930, 1930, 1954, 1954, 4100], [4103, 4103, 4160, 4160, 4797]], "test": "untested"}
{"id": "ltyBWG", "name": "okgo", "author": "lennyjpg", "description": "asdfasdfasdfasdfasdf", "tags": ["asd"], "likes": 0, "viewed": 209, "published": 3, "date": "1617375708", "time_retrieved": "2024-07-30T19:29:17.741628", "image_code": "#define SC(a)  vec2(sin(a),cos(a))\nvoid mainImage( out vec4 O, in vec2 f ){\n    vec2 U = (f-iMouse.xy) / iResolution.y;\n    for(float i=2., t = iTime*.7;i<38.;i++){\n        U += i/5. * SC(i*11.1+t*.1);\n\t\tO[int(i)%3] += sin(atan(U.x,U.y) + i * 11.32 + t) * 0.33;\n    }\n    O += vec4(.7,.4,.4,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 75, 75, 296]], "test": "untested"}
{"id": "NdBGDW", "name": "Trail 1.5 - Fractal", "author": "Leasel", "description": "Use function to determine next spot to look and if that spot is lit then lit me too.", "tags": ["fractals", "buffer"], "likes": 2, "viewed": 234, "published": 3, "date": "1617374613", "time_retrieved": "2024-07-30T19:29:18.569415", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = SI(fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 T(float x, float y)\n{\n    return vec2(x*x - y*y, 2.*x*y)*(sin(iTime*0.1 + 4.)*0.5 + 0.5) + vec2(x,y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fgi )\n{\n    fgi -= iResolution.xy*0.5;\n    vec2 tfgi = T(fgi.x, fgi.y);\n    \n    fgi += iResolution.xy*0.5;\n    tfgi += iResolution.xy*0.5;\n    fragColor = vec4(SI(tfgi).x == 1. ? RCooling : SI(fgi).x);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat Rand(float t)\n{\n    return fract(600.*(sin(mod(t, 50000.))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = distance(iMouse.xy, fragCoord) < 5. || Rand(fragCoord.x * fragCoord.y + iTime + iDate.w)-0.99 > 0.0008? vec4(1.) : SI(fragCoord)*Cooling;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SI(uv) texelFetch(iChannel0, ivec2(uv), 0)\n#define OI(uv) texelFetch(iChannel1, ivec2(uv), 0)\n#define S(uv) texelFetch(iChannel0, uv, 0)\n\n#define Cooling 0.95\n#define RCooling 1./Cooling", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 90]], "test": "untested"}
{"id": "fdBGDW", "name": "Trail 1.4", "author": "Leasel", "description": "Use function to determine next spot to look and if that spot is lit then lit me too.", "tags": ["fractals", "buffer"], "likes": 1, "viewed": 274, "published": 3, "date": "1617374478", "time_retrieved": "2024-07-30T19:29:19.399196", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = SI(fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 T(float x, float y)\n{\n    return vec2(x*x - y*y, 2.*x*y)*0.0001 + vec2(x,y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fgi )\n{\n    fgi -= iResolution.xy*0.5;\n    vec2 tfgi = T(fgi.x, fgi.y);\n    \n    fgi += iResolution.xy*0.5;\n    tfgi += iResolution.xy*0.5;\n    fragColor = vec4(SI(tfgi).x == 1. ? RCooling : SI(fgi).x);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat Rand(float t)\n{\n    return fract(600.*(sin(mod(t, 50000.))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = distance(iMouse.xy, fragCoord) < 5. || Rand(fragCoord.x * fragCoord.y + iTime + iDate.w)-0.999 > 0.0008? vec4(1.) : SI(fragCoord)*Cooling;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SI(uv) texelFetch(iChannel0, ivec2(uv), 0)\n#define OI(uv) texelFetch(iChannel1, ivec2(uv), 0)\n#define S(uv) texelFetch(iChannel0, uv, 0)\n\n#define Cooling 0.95\n#define RCooling 1./Cooling", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 90]], "test": "untested"}
{"id": "NdSGDW", "name": "Trail 1.3", "author": "Leasel", "description": "Use function to determine next spot to look and if that spot is lit then lit me too.", "tags": ["fractals", "buffer"], "likes": 0, "viewed": 284, "published": 3, "date": "1617374333", "time_retrieved": "2024-07-30T19:29:20.501250", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = SI(fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 T(float x, float y)\n{\n    return vec2(x*x - y*y + 1., 2.*x*y)*0.001 + vec2(x,y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fgi )\n{\n    fgi -= iResolution.xy*0.5;\n    vec2 tfgi = T(fgi.x, fgi.y);\n    \n    fgi += iResolution.xy*0.5;\n    tfgi += iResolution.xy*0.5;\n    fragColor = vec4(SI(tfgi).x == 1. ? RCooling : SI(fgi).x);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat Rand(float t)\n{\n    return fract(600.*(sin(mod(t, 50000.))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = distance(iMouse.xy, fragCoord) < 5. || Rand(fragCoord.x * fragCoord.y + iTime + iDate.w)-0.999 > 0.0008? vec4(1.) : SI(fragCoord)*Cooling;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SI(uv) texelFetch(iChannel0, ivec2(uv), 0)\n#define OI(uv) texelFetch(iChannel1, ivec2(uv), 0)\n#define S(uv) texelFetch(iChannel0, uv, 0)\n\n#define Cooling 0.95\n#define RCooling 1./Cooling", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 90]], "test": "untested"}
{"id": "NdS3WW", "name": "The Monolith, 1x4x9", "author": "mrange", "description": "The Monolith", "tags": ["raytracing3d"], "likes": 7, "viewed": 304, "published": 3, "date": "1617371541", "time_retrieved": "2024-07-30T19:29:21.281164", "image_code": "// License CC0: The monolith, 1x4x9\n\n#define TOLERANCE         0.0001\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)             dot(x, x)\n#define PCOS(x)           (0.5 + 0.5*cos(x))\n#define SKYCOLOR(ro, rd)  skyColor(ro, rd)\n\nconst float miss          = 1E4;\nconst float refrIndex     = 0.8;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\n\nconst vec3 skyCol1        = vec3(0.2, 0.4, 0.6);\nconst vec3 skyCol2        = vec3(0.4, 0.7, 1.0);\nconst vec3 sunCol         =  vec3(8.0,7.0,6.0)/8.0;\n\nconst vec3 boxDim         = vec3(1.0, 9.0, 4.0)/18.0;\nconst vec4 plane          = vec4(vec3(0.0, 1.0, 0.0), 0.5);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3 ce = s.xyz;\n    float ra = s.w;\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(miss); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal )  {\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(miss); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, plane);\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    vec3 snor;\n    vec2 rb   = rayBox(pos, ld, boxDim, snor);\n    vec3 spos = pos + ld*rb.x;\n    float it  = rb.y - rb.x;\n    // Extremely fake soft shadows\n    float sha = rb.x == miss ? 1.0 : (1.0-1.0*tanh_approx(it*6.0/(0.1+rb.x)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75+0.23;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3, 0.3, 0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n\nvec3 innerRender(vec3 ro, vec3 rd, vec3 enor) {\n  const float spr = 0.25;\n\n  vec3 spc = vec3(-enor*spr);\n  vec4 sp  = vec4(spc, spr);\n  vec2 rs = raySphere(ro,rd, sp);\n  vec3 bhsv = vec3(fract(0.05*TIME+dot(enor, rd)*2.0), 0.5, 1.0);\n  vec3 bcol = hsv2rgb(bhsv);\n\n  vec3 col = vec3(0.0);\n  \n  if (rs.x < miss) {\n    float t = rs.x;\n    vec3 pos = ro + rd*t;\n    vec3 nor = normalize(pos - sp.xyz);\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 2.0);\n    float l   = dif;\n    float lin = mix(0.005, 1.0, l);\n    float itd = rs.y - rs.x;\n    col += lin*bcol;\n    col = mix(col, vec3(0.0), tanh_approx(1E-3/(itd*itd)));\n  }\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = SKYCOLOR(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  vec3 nor;\n  vec2 rb = rayBox(ro, rd, boxDim, nor);  \n\n  if (rb.x < miss) {\n    t = rb.x;\n    float itd = rb.y - rb.x;\n    vec3 pos  = ro + t*rd;\n    vec3 anor = abs(nor);\n    vec2 tp   = anor.x == 1.0 ? pos.yz : (anor.y == 1.0 ? pos.xz : pos.xy);\n    vec2 bd   = anor.x == 1.0 ? boxDim.yz : (anor.y == 1.0 ? boxDim.xz : boxDim.xy);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = SKYCOLOR(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 3.0));\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 3.0);\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 50.);\n    float lin = mix(0.0, 1.0, dif);\n    vec3 lcol = 2.0*sqrt(sunCol);\n\n    col = innerRender(pos, refr, nor);\n\n    vec2 btp = (1.0*bd - abs(tp));\n    float bdd = pmin(btp.x, btp.y, 0.0125);    \n    float bddd = exp(-10000.0*bdd*bdd);\n//    col += vec3(0.5, 0.5, 1.0)*bddd*10;\n    col *= 1.0 - bddd;\n\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n    col = mix(col, skyCol, tanh_approx(1E-5/(itd*itd)));\n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  const float mul = 0.05;\n  float mm = mix(0.25, 0.5, PCOS(TIME*mul*sqrt(3.0)));\n  vec3 ro = mm*vec3(2.0, 0, 0.2);\n  ro.xz *= ROT((TIME*mul));\n  ro.yz *= ROT(sin(TIME*mul*sqrt(0.5))*0.5);\n  ro += vec3(0.0, mm, 0.0);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  const float rdd = 2.00;\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdS3WW.jpg", "access": "api", "license": "cc0-1.0", "functions": [[715, 715, 743, 763, 839], [841, 865, 904, 904, 992], [994, 1073, 1095, 1095, 1264], [1266, 1298, 1340, 1340, 1599], [1601, 1630, 1697, 1697, 2175], [2177, 2177, 2220, 2220, 2267], [2269, 2269, 2306, 2306, 2558], [2560, 2560, 2593, 2593, 3661], [3664, 3664, 3711, 3711, 4340], [4342, 4342, 4373, 4373, 5778], [5780, 5780, 5835, 5835, 6447]], "test": "ok"}
{"id": "ssj3Dh", "name": "Crosswarp transition", "author": "turboplay", "description": "Another nice one from glsl-transitions", "tags": ["transition"], "likes": 22, "viewed": 925, "published": 3, "date": "1617359047", "time_retrieved": "2024-07-30T19:29:22.053100", "image_code": "\n// https://gl-transitions.com/editor/crosswarp\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = fragCoord/iResolution.xy;\n  float x = mod(iTime,2.); // change this to alter the speed\n   \n  x=smoothstep(.0,1.0,(x*2.0+p.x-1.0));\n  fragColor= mix(texture(iChannel0,(p-.5)*(1.-x)+.5), texture(iChannel1,(p-.5)*x+.5), x);  \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssj3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 106, 106, 342]], "test": "untested"}
{"id": "7dj3Dh", "name": "Wind Transition", "author": "turboplay", "description": "Another nice one from glsl-transitions", "tags": ["transition"], "likes": 4, "viewed": 502, "published": 3, "date": "1617358794", "time_retrieved": "2024-07-30T19:29:22.894850", "image_code": "\n// Variables\nfloat size = 0.2; \nfloat speed = 1.f;\n\nfloat rand (vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n   float time = mod(iTime,speed);\n  \n   float r = rand(vec2(0, uv.y));\n   float m = smoothstep(0.0, -size, uv.x*(1.0-size) + size*r - (time * (1.0 + size)));\n   fragColor = mix(\n    texture(iChannel0,uv),\n    texture(iChannel1,uv),\n    m\n  );\n  \n  \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dj3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 75, 75, 145], [149, 149, 206, 206, 497]], "test": "untested"}
{"id": "ssjGWh", "name": "Trail 1.1 - Fractal", "author": "Leasel", "description": "Thought this was a fractal at first sight, but propably float precision error.", "tags": ["fractals", "buffer"], "likes": 0, "viewed": 245, "published": 3, "date": "1617351750", "time_retrieved": "2024-07-30T19:29:23.694711", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = SI(fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fgi )\n{\n    fgi -= iResolution.xy*0.5;\n    fgi = abs(fgi);\n\n    fragColor = SI(fgi);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat Rand(float t)\n{\n    return fract(600.*(sin(mod(t, 50000.))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float id = fragCoord.x * fragCoord.y + iTime + iDate.w;\n\n    vec3 col = vec3(\n        Rand(id + iDate.w*iDate.z),\n        Rand(id + iDate.w+iDate.z),\n        Rand(id + iDate.w-iDate.z)\n        );\n\n    fragColor = distance(iMouse.xy, fragCoord) < 5. || Rand(id)-0.99 > 0.00099? vec4(col, 1.) : SI(fragCoord)*Cooling;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SI(uv) texelFetch(iChannel0, ivec2(uv), 0)\n#define OI(uv) texelFetch(iChannel1, ivec2(uv), 0)\n#define S(uv) texelFetch(iChannel0, uv, 0)\n\n#define Cooling 0.99\n#define RCooling 1./Cooling", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 90]], "test": "untested"}
{"id": "fdB3RD", "name": "Trail 1.0", "author": "Leasel", "description": "Use function to determine next spot to look and if that spot is lit then lit me too.", "tags": ["fractals", "buffer"], "likes": 0, "viewed": 222, "published": 3, "date": "1617351400", "time_retrieved": "2024-07-30T19:29:24.475623", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = SI(fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 T(float x, float y)\n{\n    return vec2(x + cos(iTime) + 0.1, y + sin(iTime));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fgi )\n{\n    vec2 tfgi = T(fgi.x, fgi.y);\n    \n    fragColor = vec4(SI(tfgi).x == 1. ? RCooling : SI(fgi).x);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat Rand(float t)\n{\n    return fract(600.*(sin(mod(t, 50000.))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = distance(iMouse.xy, fragCoord) < 5. && Rand(fragCoord.x * fragCoord.y + iTime + iDate.w)-0.99 > 0.00099? vec4(1.) : SI(fragCoord)*Cooling;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SI(uv) texelFetch(iChannel0, ivec2(uv), 0)\n#define OI(uv) texelFetch(iChannel1, ivec2(uv), 0)\n#define S(uv) texelFetch(iChannel0, uv, 0)\n\n#define Cooling 0.95\n#define RCooling 1./Cooling", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdB3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 90]], "test": "untested"}
{"id": "fd2GD1", "name": "Shimmy", "author": "Kali", "description": "Music by Tony Leys https://soundcloud.com/tonileys", "tags": ["raymarching", "audioreactive"], "likes": 68, "viewed": 7031, "published": 3, "date": "1617348172", "time_retrieved": "2024-07-30T19:29:25.561719", "image_code": "#define iTime iChannelTime[0]\nfloat det=.005, maxdist=50., pi=3.1416, gl=0.;\nvec2 id;\n\n\nfloat hash12(vec2 p)\n{\n    p*=1000.;\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat box(vec3 p, vec3 c)\n{\n    vec3 pc=abs(p)-c;\n    return length(max(vec3(0.),pc))-min(0.,max(pc.z,max(pc.x,pc.y)));\n}\n\nvec2 amod(vec2 p, float n, float off, out float i)\n{\n    float l=length(p)-off;\n    float at=atan(p.x,p.y)/pi*n*.5;\n    i=abs(floor(at));\n    float a=fract(at)-.5;\n    return vec2(a,l);\n}\n\nfloat ring(vec3 p,inout vec2 id)\n{\n    p.xy=amod(p.xy*rot(iTime*0.), 20., 2., id.x);\n    float h=max(0.,texture(iChannel0,vec2(.5+fract(id.x*.2+id.y*.1),0.)*.5).r*3.-.5);\n    h+=sin(iTime*10.+id.x)*.2;\n    float d=box(p+vec3(0.,-h*1.5,0.),vec3(.1,h,.1));\n    return d*.5;\n}\n\nfloat de(vec3 p)\n{\n    float d=100.,ii=0.;\n    p.xz*=rot(iTime);\n    p.yz*=rot(sin(iTime));\n    float r=4.;\n    vec2 ids;\n    for (float i=0.; i<r; i++)\n    {\n        p.xz*=rot(pi/r);\n        ids.y=i;\n        float r=ring(p,ids);\n        if (r<d)\n        {\n            d=r;\n            id=ids;\n        }\n    }\n    d=min(d,length(p)-1.5);\n    return d*.7;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e=vec2(0.,det);\n    return normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\n}\n\n\nvec3 march(vec3 from, vec3 dir)\n{\n    float d, td=0.;\n    vec3 p, col=vec3(0.);\n    for (int i=0; i<100; i++)\n    {\n        p=from+td*dir;\n        d=de(p);\n        if (d<det || td>maxdist) break;\n        td+=d;\n        gl+=.1/(10.+d*d*10.)*step(.7,hash12(id+floor(iTime*5.)));\n    }\n    if (d<det)\n    {\n        //id+=floor(iTime*5.);\n        vec3 colid=vec3(hash12(id),hash12(id+123.123),1.);\n        p-=dir*det;\n        vec3 n=normal(p);\n        vec2 e=vec2(0.,.05);\n        col=.1+max(0.,dot(-dir,n))*colid;\n        col*=.5+step(.7,hash12(id+floor(iTime*5.)));\n    } \n    else\n    {\n        dir.xz*=rot(iTime*.5);\n        dir.yz*=rot(iTime*.25);\n        vec2 p2=abs(.5-fract(dir.yz));\n        float d2=100.,is=0.;\n        for(int i=0; i<10; i++)\n        {\n            p2=abs(p2*1.3)*rot(radians(45.))-.5;\n            float sh=length(max(vec2(0.),abs(p2)-.05));\n            if (sh<d2)\n            {\n                d2=sh;\n                is=float(i);\n            }\n        }\n        col+=smoothstep(.05,.0,d2)*fract(is*.1+iTime)*normalize(p+50.);\n    }\n    return col*mod(gl_FragCoord.y,4.)*.5+gl;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 from = vec3(0.,0.,-8.);\n    vec3 dir = normalize(vec3(uv,.7));\n    vec3 col = march(from, dir);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26471, "src": "https://soundcloud.com/tonileys/through-a-cardboard-world", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2GD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 110, 110, 244], [247, 247, 266, 266, 325], [327, 327, 354, 354, 448], [450, 450, 502, 502, 637], [639, 639, 673, 673, 912], [914, 914, 932, 932, 1270], [1272, 1272, 1293, 1293, 1391], [1394, 1394, 1427, 1427, 2495], [2499, 2499, 2556, 2556, 2753]], "test": "untested"}
{"id": "fs23Wh", "name": "Square Cycler", "author": "Tater", "description": "code is a bit of a mess but I really wanted to try this trick. Maybe I'll make a better thing with it later. ", "tags": ["2d", "squares", "overlapping"], "likes": 9, "viewed": 372, "published": 3, "date": "1617341045", "time_retrieved": "2024-07-30T19:29:26.472285", "image_code": "#define rot(a) mat2( cos(a),-sin(a),sin(a),cos(a) )\n#define pi 3.141592653\nfloat smoothtrig(float b, float wv){\nreturn sqrt((1.0+b*b)/(1.0+b*b*wv*wv))*wv;\n}\n\nfloat squares(vec2 uv, float t)\n{  \n    float wdth = .5*iResolution.x/iResolution.y-0.1;\n    \n    vec2 cent = vec2(wdth,0.38)\n                *clamp(vec2(smoothtrig(4.0,sin(t*2.0)),smoothtrig(4.0,cos(t*2.0))),-.95,.95);\n    vec2 d = abs(uv+cent);\n    \n    float o = step(max(d.x,d.y),0.15);\nreturn o;\n}\nfloat rects(vec2 uv, float t)\n{\n    uv*=rot(t);\n    vec2 cent = vec2(sin(t*3.5)+1.5,cos(t*3.5)+1.5);\n    vec2 d = abs(uv*cent);\n    \n    float o = step(max(d.x,d.y),0.3);\n          o -= step(max(d.x,d.y),0.15);        \nreturn o;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    vec2 uv2 = uv;\n    //uv = abs(uv);\n    //uv*=length(uv)*3.0;\n    float c = 10.0;\n    vec3 col= 0.5*vec3(30.,14.,256.)/256.*length(uv*0.6);\n    \n    for(float i = 0.; i<c; i++){\n        uv2*=rot(-i*-0.03);\n        uv*=1.0+(i/c)*0.1;\n        col.r += (1.3/c)*rects(uv2,t+i*0.1)*2.0;\n        col.g += (1.3/c)*rects(uv2,t+i*0.1);\n        \n        col.r += (1.2/c)*squares(uv,t+i*0.01)+(1.2/c)\n                        *squares(uv,t+i*0.01+pi/2.0); \n        col   +=((1.2/c)*squares(uv,t+i*0.01+pi/4.0)+(1.2/c)\n                        *squares(uv,t+i*0.01+pi*0.75))\n                        *vec3(31.,255.,255.)/256.; \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs23Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 111, 111, 156], [158, 158, 191, 191, 460], [461, 461, 492, 492, 691], [692, 692, 749, 749, 1493]], "test": "untested"}
{"id": "Ns23Wh", "name": "Fake 3D fractal", "author": "jarble", "description": "This is a 2D fractal formula, but it looks almost like a 3D rendered scene!", "tags": ["2d", "3d", "fractal", "illusion"], "likes": 3, "viewed": 227, "published": 3, "date": "1617331049", "time_retrieved": "2024-07-30T19:29:27.308050", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.6;\n        float scale1 = 1.6;\n        float s1 = scale1*scale;\n        for(int i=0;i<9;i++)\n        {\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.5-abs((uv.x-uv.y)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            uv.x *= -1.0;\n            col[c] = fract((.5*col[c]+col.x+(uv.y)-(uv.x))/2.0);\n        }\n     \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 733]], "test": "untested"}
{"id": "fs2GWh", "name": " Quartz - wip ", "author": "patu", "description": "wip for https://www.pouet.net/prod.php?which=82780\nmusic is https://soundcloud.com/neurofunksocietyofpoland/dronehead-02-hexyll-original-mix", "tags": ["demoscene"], "likes": 45, "viewed": 4063, "published": 3, "date": "1617324275", "time_retrieved": "2024-07-30T19:29:28.362231", "image_code": "// Fork of \" Quartz - wip - private\" by patu. https://shadertoy.com/view/3tjXRW\n// 2021-04-02 00:42:21\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      //vec2  r = g - f + o;\n\t    vec2  r = g - f + (0.5+0.5*sin(iTime+6.2831*o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n\nvec3 res;\n\nmat2 rot = mat2(cos(2.399),sin(2.399),-sin(2.399),cos(2.399));\n\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.002*res.y/res.x,.002),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<50;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/50.;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    res = iResolution;\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n    vec2 c = voronoi( (14.0+6.0*abs(sin(1.2*iTime))) * uv / res.x * res.y / 4.);\n    \n    float cell = max(0., floor(abs(sin(iTime)) - fract(c.y * 0.1) + .1));\n    //uv += texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0).b * .04;\n    \n    //float cell = max(0., floor(abs(sin(iTime + fract(c.y * 0.1) + .9))));\n    float sh = (cell / 50.) / texelFetch(iChannel1, ivec2(9, 0), 0).r;//cell > .2 ? c.y * 0.5 : 0.;\n    uv.x += sh * 3.;//* hash(uv).x * 2.2;\n    \n    float a = abs(.7 - pow(texture(iChannel0,uv).w * 1.2, 1.4));\n\tfragColor=vec4(dof(iChannel0,uv,a),1.);\n    fragColor = mix(fragColor, pow(\n        max(\n            vec4(0.), \n            1.-normalize(fragColor)), vec4(4.)), sh * 40.);\n    //fragColor.rbg -= cell * .1;\n    //fragColor.rgb -= vec3(.2, .1, 0.) * cell * .5 + (cell > 0.5 ? pow(abs(cell * -c.x * 2.), 10.) : 0.);\n    //fragColor = vec4(a);\n    \n   // fragColor = texelFetch(iChannel1, ivec2(0, 0), 0).aaaa;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define getNormal getNormalHex\n#define V vec3\n#define W vec2\n#define F float\n#define FAR 330.\n#define INF 1e32\n//#define IT iTime\n#define mt iChannelTime[1]\n\n#define PI 3.14159265\n#define PHI (1.618033988749895)\n\nstruct Timeline {\n    float songTime;\n    float rPatternTime;\n    float nPatternTime;\n    float smoothNPatternTime;\n    \n    float patternNum;\n} timeline;\n\nstruct SdfMixer {\n \tfloat ifs1;\n    float grid;        \n    float star;\n} sdfMixer;\n\nF \n    Z = 0., \n    J = 1., \n\tvol = 0.,\n\tnoise = 0.;\n \n\n#define H(P) fract(sin(dot(P,vec2(127.1,311.7)))*43758.545)\nF n(in vec3 p) {\n    V \ti = floor(p), \n        f = fract(p), \t\n\t    u = f*f*(3.-f-f);\n    \n    W   ii = i.xy + i.z * 5. + 5.;\n    \n    #define II(a,b) H(i.xy + i.z * W(5.0) + W(a,b))\n    \n    F \tv1 = mix(mix(II(Z,Z),II(J,Z),u.x), mix(\n            II(Z,J),II(J,J),u.x), u.y);\n    \n    #define I2(a,b) H(ii + W(a,b))\n    return max(mix(v1,mix(mix(I2(Z,Z),I2(J,Z),u.x), \n        \t\tmix(I2(Z,J),I2(J,J),u.x), \n        \t\tu.y),u.z),Z);\n}\n#define A w *= .5; s *= 2.; r += w * n(s * x);\nF B(vec3 x) {\n    F \tr = Z, w = J, s = J;\n    A A A A;\n    return r;\n}\n\n#define fromRGB(a, b, c) vec3(F(a), F(b), F(c)) / 255.;\n    \nvec3 \n    light = vec3(0. ,1., 1.),\n\tlightDir,\n\tlightColour = normalize(vec3(0.5, .6, .5) ); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k ;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    float materialIndex;\n    float specular;\n    float diffuse;\n    vec3 color;  \n    vec3 space;\n    float mirror;\n    vec3 index;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 ){\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1.);\n\treturn c;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n               \n               return obj;\n}\n\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nmat2x2 rot(float angle)\n{\n    return mat2x2(cos(angle), -sin(angle),\n\t\t\t\t  sin(angle), cos(angle));\n}\n//IFS iterations : try 2 or 3\n#define NIFS 4\n//scale and translate for the IFS in-loop transformation\n#define SCALE 1.2\n#define TRANSLATE 4.2\nvec3 sd2d(vec2 p, float o)\n{\n    p *= 1.7;\n    float time = o * .2;//0.2*o+0.6*iTime;\n \tfloat s =.45, d, d2 = 1., d3= 0.;\n    p*= s;\n    float RADIUS =2.5;//(1.+sin(iTime));\n    \n    int i;\n    vec3 col;  \n    \n    p = p*rot((mod(timeline.patternNum, 4.) > 1. ? -1. : 1.) * -0.9 * time);// twist\n\n    for ( i = 0; i<NIFS; i++)\n    {        \n        if (p.x < 0.) { p.x = -p.x; col.r++;}\n\t\t//p = p*rot(0.1*sin(time));\n        if (p.y < 0.) {p.y = -p.y; col.g++; }\n        if (p.x-p.y < 0.){ p.xy = p.yx; col.b++;}        \n        \n      \tp = p * SCALE - TRANSLATE;\n        //p = p * rot(0.1 * iTime);\n        d = 0.25 * (length(p) - RADIUS) * pow(SCALE, float(-i)) / s;\n\n        if (d < 1.1) {\n         \td2 = float(i);\n            d3 = 1.;\n            break;\n        }\n    }\n    \n    \n    \n    //d = fCross(vec3(p.xy, 1.), vec3(1.)) - RADIUS * pow(SCALE, float(-i)) * 2.;\n    //col/=float(NIFS);\n    //vec3 oc = mix(vec3(0.7,col.g,0.2),vec3(0.2,col.r,0.7), col.b);\n    \n    return vec3(d, d2, d3);\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\nvec3 opTwist(in vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    \n    return q;\n}\n\nvec3 discoBall(vec3 p, float spikes) {\n    \n    //p -= ballPos;\n    \n    //p = opTwist(p, .1);\n    //p = opTwist(p.yxz, .1);//sin(length(p) * .01));\n    \n    //pR(p.xz, iTime * .3 - min(1., iTime) * vol * 1.5);\n    //pR(p.yz, iTime * .24 - min(1., iTime) * vol * .5);\n    \n    //dpb = p;\n    \n    \n    float pxz = pModPolar(p.xz, 7.);//ceil(vol2 * 10.));// * hash12(vec2(floor(part2Time * 3.55))) * min(part2Time, 30.));\n    float pyz = pModPolar(p.xy, 7.);\n    \n    //pR(p.xz, length(p) * .01);\n    //pR(p.xy, length(p) * .01);\n    \n    \n    return vec3(\n        fCone(p.zxy, 4., spikes), \n        8., 16.\n    );\n\n}\n\ngeometry map(vec3 p) {\n    geometry box, fl;\n    vec3 bp = p, bp2 = p;\n\t//p.x *= sin(timeline.smoothNPatternTime + p.x);\n    p *= (sin(length(bp)) * .2 - 1.) * (1. + timeline.nPatternTime);\n    \n    //p += sin(iTime);\n    \n    //pR(bp.yx, p.y * .2 + sin(iTime));\n    \n    //pR(bp.xy, PI / 4.);\n    pR(bp.xy, timeline.songTime * .02 + n(vec3(iTime * .1)) * 5.);\n    //pModPolar(p.xy, 4.);\n    //pModPolar(p.xz, 4.);\n    vec3 tb = bp;\n    vec3 reps = vec3(\n        pModInterval1(bp.x, 5., -2., 2.),\n        pModInterval1(bp.y, 5., -2., 2.),\n        pModInterval1(bp.z, 5., -2., 2.)\n    );\n    \n    box.dist = fSphere(bp, 1.5);\n    \n    bp = tb;\n    \n    vec3 reps2 = vec3(\n        pModInterval1(bp.x, 5., -1.5, 1.5),\n        pModInterval1(bp.y, 5., -1.5, 1.5),\n        pModInterval1(bp.z, 5., -1.5, 1.5)\n    );\n    \n    box.dist = mix(box.dist, fBox(bp, vec3(1.5)), mod(timeline.patternNum, 2.));//fSphere(bp, 1.5);\n \n\tbox.diffuse = 4.;\n    box.specular = 5.;\n    box.mirror = 1.;\n    box.color = vec3(0.0);\n    \n    //pR(p.xz, timeline.songTime * .1);\n    //p = mix(p, p.xzy, .9);\n    vec3 s = sd2d(p.xz, p.y) * .9;\n    \n    float a = smin(s.x, box.dist, pow(sin(iTime / 2.) / 2. + .5, 3.) + .8);\n    \n    box.dist = mix(box.dist, a, sdfMixer.ifs1);    \n    \n    reps = vec3(s.y);\n    \n    //box.dist = smin(box.dist, fSphere(p, 5.), abs(sin(iTime * .1)));\n    box.index = ceil(reps + (n(reps + timeline.patternNum + timeline.nPatternTime * 10.) - .5) * 3.);\n    \n    \n  \t//box.dist = mix(box.dist, fBox(p, vec3(10.)), sin(iTime) / 2. + .5);\n    //!!!  box.dist = mix(box.dist, fBox(p, vec3(10.)), 1.-n(vec3(p) * .5));\n    //pR(bp2.zx, p.y * .2 + sin(iTime));\n    \n    //db.yzx = opTwist(db.yzx, sin(length(db)) * .001);\n    float di = discoBall(bp2, 25. * (1.-timeline.smoothNPatternTime / 4.)).x;\n    box.dist = smin(box.dist, di, .9);\n    \n   // box.dist = min(box.dist, -(length(bp2) -140.));\n    box.dist = mix(fSphere(bp2, 15.), box.dist, min(timeline.songTime * .1, 1.));\n    \n    p= bp2;\n    //p.zxy = opTwist(p.zxy, .03);\n    //float m = pModPolar(p.xz, 10.);\n    //p.x -= 35. ;//+ sin(p.y * .3+ IT) * 3.;;\n    float ss = sd2d(-p.zx * 1.4, p.y).x;\n    //p.y += sin(m + IT) * 10.;\n    box.dist = mix(ss, box.dist, min(1., timeline.songTime*.1));\n    \n    return box;\n    box.diffuse = 4.;\n    box.specular = 5.;\n    box.mirror = 1.;\n    box.color = vec3(.0, .0, .0);\n    box.index = vec3(1.);\n    \n    bp.x += sin(timeline.songTime * .04) * 20.;\n    pR(bp.zy, sin(timeline.songTime * .03));\n    pModPolar(bp.xy, 5.);\n    box.dist = discoBall(bp * 2., 25.).x;\n    bp = bp2;\n    bp.x += sin(timeline.songTime * .02) * 20.;\n    bp.y += cos(timeline.songTime * .02) * 20.;\n    pR(bp.xy, sin(timeline.songTime * .1));\n    pR(bp.zy, sin(timeline.songTime * .1));\n    \n    box.dist = smin(box.dist, discoBall(bp * 2., 25.).x,.1);\n    \n    \n    return box;\n}\n\n\n\nfloat t_max = FAR;\n\nfloat minDist = 1e3;\nfloat glow = 0.;\nbool firstpass = true;\n\ngeometry trace(vec3 o, vec3 d, int maxI) {\n    float omega = .3;\n    float t = .01;\n    float candidate_error = INF;\n    float candidate_t = t;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1. / 250.;\n    float functionSign = map(o).dist < 0. ? -1. : +1.;\n    \n    geometry mp;\n\n    for (int i = 0; i < 200; ++i) {\n        if (maxI > 0 && i > maxI) break; \n        mp = map(d * t + o);\n        \n        if (mp.index.x == 0. && firstpass) {\n            minDist = min(minDist, mp.dist * 1.);\n            glow = pow( 1. / minDist, .5);\n        } \n        \n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        \n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = .1;\n        } else {\n            stepLength = signedRadius * omega;\n        }\n        \n        previousRadius = radius;\n        \n        float error = radius / t;\n        \n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        \n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        \n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INF;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 15;\n    vec3 rd = (lp - ro); \n\n    float shade = 1.;\n    float dist = 2.05;\n    float end = max(length(rd), .01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        shade = min(shade, k*h/dist);\n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.0), 1.0);\n}\n\n\n//\tnormal calculation\nvec3 normal(vec3 p) {\n    float e=.001, d = map(p).dist; return normalize(vec3(map(p+vec3(e,0,0)).dist-d,map(p+vec3(0,e,0)).dist-d,map(p+vec3(0,0,e)).dist-d));\n}\n\nfloat getAO(vec3 h, vec3 n, float d) { return clamp(map(h + n * d).dist / d, .3, 1.); }\n\nvec3 clouds(vec3 d, vec3 o) {\n    vec2 u = d.xz / d.y;\n   \n    return vec3(\n        B(\n            vec3(\n                u + vec2(0., o.z  * .05), 9.\n            )\n        ) * vec3(1., .5, 0.)\n\n    ) * max(0., d.y); \t\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir, vec3 ro)\n{\n   \n    float sunSize = .5;\n    float sunAmount = max(dot(rd, lightDir), 0.);\n    float v = pow(1. - max(rd.y, 0.0), 1.1);\n    vec3 cl = vec3(1.);//fromRGB(0,136,254);\n    //cl.b *= sin(p.z * 0.3);\n    vec3 sky = mix(cl, vec3(.1, .2, .3), v);\n \t//vec3 lightColour = vec3(.1, .2, .3);\n    \n    sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 122.0)* sunSize, 1.2 * sunSize);\n    //sky += vec3(0., 0., 0.) * max(0.,rd.y);\n    return clamp(sky, 0.3, 1.0) + clouds(rd, ro);// * H(vec2(IT)) * floor(B(rd * 12.1) * 1.+ .5) * 1.;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = obj.color;\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.01); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.5);\n\n    float diff = max(dot(sn, ld), obj.diffuse);\n    float spec = max(dot(reflect(-ld, sn), -rd), obj.specular);\n\n    \n    vec3 objCol = obj.color;//getObjectColor(sp, sn, obj);\n\treturn objCol * (diff + .15) * spec * .1;\n}\n\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir ) {  // camera to point vector\n    \n    float c = .08;\n    float b = .1;\n    //rayOri.y -= 14.;\n    float fogAmount = c * exp(-rayOri.y * b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    \n    vec3  fogColor  = vec3(1., 1., 1.);//Sky(rayDir, false, normalize(light)) * 1.;//\n    \n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    timeline.songTime = texelFetch(iChannel0, ivec2(0, 0), 0).r;\n    timeline.rPatternTime = texelFetch(iChannel0, ivec2(0, 0), 0).g;\n    timeline.nPatternTime = texelFetch(iChannel0, ivec2(0, 0), 0).b;\n    timeline.smoothNPatternTime = texelFetch(iChannel0, ivec2(0, 0), 0).a;\n    \n    timeline.patternNum = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n    \n    vec3 campos = texelFetch(iChannel0, ivec2(5, 0), 0).rgb;\n    sdfMixer.grid = texelFetch(iChannel0, ivec2(11, 0), 0).r;\n    sdfMixer.star = texelFetch(iChannel0, ivec2(13, 0), 0).g;\n    sdfMixer.ifs1 = texelFetch(iChannel0, ivec2(15, 0), 0).r;\n    \n    \n    //if (fragCoord.x < 100.) {\n        //fragColor = vec4(timeline.rPatternTime);\n        //return;\n    //}\n    F \tmat = 0.,\n        camShY = 0.;\n    \n    //vol = (texture(iChannel0, vec2(.92, .15)).r) * 2.;\n    \n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.x * 1.5;\n    //if (length(uv) < .9) pR(uv, PI);\n    light = vec3(0., 0., 100.);        \n    float rr = timeline.songTime + (n(vec3(timeline.songTime * .4)) * 2.) - .5;\n    vec3 \n        vuv = vec3(0., 1., 0.4 ), // up\n    \t\n        ro = campos;\n    \n    vec3\n        vrp =  vec3(0., 0., 0.),//+ ro,\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \trd = normalize(\n            vpn + uv.x * u  + uv.y * cross(vpn, u)\n        ),\n        hit,\n        ord = rd;\n        \n\t\n    vec3 sceneColor = vec3(1.);\n    \n    geometry tr = trace(ro, rd, 90);    \n    \n    //float fog = smoothstep(FAR * FOG, 0., tr.dist) * 1.;\n    hit = ro + rd * tr.dist;\n\t\n    float odist = tr.dist;\n    \n    vec3 sn = normal(hit);\t\n    \n   // float sh = softShadow(hit, hit + light, 3.);\n    \n    float \n        ao = getAO(hit, sn, .6);\n\t\n    //ao *= saturate(getAO(hit + sn * .2, sn, .5));\n    //ao *= saturate(getAO(hit + sn * 1., sn, 3.0));\n    \n    float alpha = 1.;\n\tvec3 sky = Sky(rd, true, normalize(light), ro);\n    \n    if (tr.dist < FAR) { \n        sceneColor = (doColor(hit, rd, sn, light, tr) * 1.) * 1.;\n       // sceneColor *= ao; \n        //sceneColor *= sh;\n        sceneColor = mix(sceneColor, sky, saturate(tr.dist * 2. / FAR));\n        //sceneColor = mix(sceneColor, lightColour, 0.1);        \n        sceneColor *= 0.9 + vec3(length(\n            max(\n                vec2(.0),\n                .7 * max(\n                    0.,\n                    length(normalize(light.y) * max(0., sn.y))\n                )\n            )\n        ));\n        \n        firstpass = false;\n        \n        glow *= 1.- timeline.nPatternTime;\n        \n        sceneColor += pow(glow, 2.);\n        \n        if (glow < 1.) {\n            if (tr.mirror > 0.) {   \n                float mirror = tr.mirror;\n                vec3 refSceneColor = sceneColor;\n                rd = reflect(rd, sn);// + sin(t));\n                //hit += rd * 3.;\n                //rd += n(rd * 3.) * .2;\n                //rd = normalize(rd);\n\n                tr = trace(hit, rd, 69);\n                hit = hit + rd * tr.dist;\n                \n                if (tr.dist < FAR) {\n                    sn = normal(hit);\n                    refSceneColor = mix(sceneColor, abs(doColor(hit, rd, sn, light, tr)), mirror);                \n                } else {\n                    sky = mix(Sky(rd, true, normalize(light), hit), vec3(0.), .3);\n                    sky = Sky(rd, true, normalize(light), hit);\n                    refSceneColor = mix(refSceneColor, sky, mirror);\n                }\n\n                sceneColor = mix(sceneColor, refSceneColor, mirror);\n                \n            } else {\n                sceneColor = mix(sceneColor, sky, 1.0);\n            }\n        }\n\t sceneColor *= ao; \n    \t//sceneColor = mix(sceneColor, vec3(sceneColor.r + sceneColor.g + sceneColor.b)/ 3., odist / 10.);\n    \n    \talpha = odist / 25.;        \n    } else {\n        alpha = 1.;\n        sceneColor = sky;        \n    }\n\n    sceneColor += pow(glow, 3.) * vec3(1., .5, 0.);\n    \n    \n    vec3 bsceneColor = texture(iChannel1, (fragCoord.xy + vec2(1., 0.)) / iResolution.xy).rgb;\n    \n    sceneColor = mix(sceneColor, bsceneColor, .2);\n    //sceneColor *= timeline.smoothNPatternTime;\n    //if (length(uv) < .5) sceneColor = 1.- sceneColor;//pR(uv, PI);\n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.), 0.0, 1.0), 1.0) * 1.4;\n    //fragColor = pow(fragColor, 1./vec4(1.2));\n\tfragColor.a = alpha;\n    \n    //fragColor.rgb = vec3(timeline.nPatternTime);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec3 U[2] = vec3[2](vec3(0), vec3(0));\n\nvoid compute(in ivec2 coord, out vec4 color) {\n    float time = U[0].x,\n          pt = mod(time, PATTERN_TIME),\n          pt2 = mod(pt - PATTERN_TIME / 4., PATTERN_TIME) / 3.,\n          npt = pt / PATTERN_TIME,\n    \t  pn = floor(time / PATTERN_TIME); // pattern num\n                \n    switch (coord.x) {\n        // R - songtime, G - pattern time (1->0), B - pattern time(0->1), smootstep patterntime) \n        case 0:\n        \tcolor = vec4(U[1].x, (PATTERN_TIME - pt) / PATTERN_TIME, npt, smoothstep(0., 1., pt / PATTERN_TIME));\n            \n        \tbreak;\n        case 1:\n            // R - pattern number;\n        \tcolor = vec4(pn, 0., 0., 0.);\n        \tbreak;\n        case 5: \n        \t// RG - cam position \n        \tvec2 x = texture(iChannel1, vec2(.5, fract(time * .2))).rg * 0.4 * npt;\n        \tvec2 r = (time * .095 + x - sin(npt) * npt * 6.14 * x) / PATTERN_TIME;\n        \n        \tr += pn * .5;\n        \n        \tcolor = vec4(\n                sin(r.x) * 26., \n                -10., \n                cos(r.x) * 26., \n                0.\n            );\n        \t\n        \tbreak;\n\n        case 9:\n        \tcolor = vec4(pt);\n        \tbreak;\n        case 11:\n        \t/// sdf mixer GRID,\n        \tcolor = vec4(pt, sin(pt), 0., 0.);\n        \tbreak;\n        case 13: \n        \tbreak;\n        \n        case 15:\n        \t/// sdf mixer IFS1\n        \tcolor = vec4(max(0., 1.- pt2));\n        \tbreak;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tU[1].x = float(iFrame);\n    U[0].x = max(22., iChannelTime[0]);\n    \n    ivec2 store = ivec2(fragCoord.xy);\n\tvec2 uv = gl_FragCoord.xy / U[0].yz;   \n    \n    fragColor = vec4(0.0);\n\n    float ck = cos(iTime * .1) * .1;\n    int index = 0;\n\n    if (store.y != 0 || store.x > 15) {        \n        if (U[1].x < 10.) {\n            fragColor.r = noiseLayers(vec3(fragCoord * .03, 2.));\n            fragColor.b = noiseFF(fragCoord * .01);\n            return;\n        } else {\n        \tdiscard;\n        }\n    } else {\n        compute(store, fragColor);         \n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26467, "src": "https://soundcloud.com/neurofunksocietyofpoland/dronehead-02-hexyll-original-mix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define PATTERN_TIME (5.485714 / 4.)\n\nvec3 hash33_(vec3 p){     \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n#define M0 1597334673U\n#define M1 3812015801U\n#define M2 uvec2(M0, M1)\n#define M3 uvec3(M0, M1, 2798796413U)\n\nfloat hash11( float q )\n{\n    uvec2 n = uint(q) * M2;\n    return float((n.x ^ n.y) * M0) * (1.0/float(0xffffffffU));\n}\n\nfloat hash12( vec2 p ) { uvec2 q = uvec2(ivec2(p)) * M2; uint n = (q.x ^ q.y) * M0; return float(n) * (1./float(0xffffffffU)); }\nvec3 hash33(vec3 p) { uvec3 q = uvec3(ivec3(p)) * M3; q = (q.x ^ q.y ^ q.z)*M3; return vec3(q) * (1.0/float(0xffffffffU)); }\n\nfloat voronoi(vec3 p){\n\tvec3 b, r, g = floor(p);\n\tp = fract(p); \n\tfloat d = 1.;      \n    for(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {    \t\t\n\t\t    b = vec3(i, j, -1); r = b - p + hash33(g+b); d = min(d, dot(r,r));    \t\t\n\t\t    b.z = 0.0; r = b - p + hash33(g+b); d = min(d, dot(r,r)); \n            b.z = 1.; r = b - p + hash33(g+b); d = min(d, dot(r,r));    \t\t\t\n\t    }\n\t}\t\n\treturn d;\n}\n\nfloat noiseLayers(in vec3 p) {\n    vec3 t = vec3(0., 0., p.z);    \n    float tot = 0., sum = 0., amp = 1.;\n    for (int i = 0; i < 2; i++) { tot += voronoi(p + t) * amp; p *= 2.0; t *= 1.5; sum += amp; amp *= 0.5; }    \n    return tot / sum;\n}\n\nfloat noiseF( in vec2 p )\n{\n    vec2 i = floor( p ), f = fract( p ), u = f*f*f*(3.-2.*f);\n\n    return mix( mix( hash12( i + vec2(0.,0.) ), \n                     hash12( i + vec2(1.,0.) ), u.x),\n                mix( hash12( i + vec2(0.,1.) ), \n                     hash12( i + vec2(1.,1.) ), u.x), u.y);\n}\n\nfloat noiseFF(in vec2 uv) {\n    uv *= 2.;\n    \n \tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 ) * 1.25;\n    \n    float f  = .5*noiseF( uv ); uv = m*uv;\n    f += .2500*noiseF( uv ); uv = m*uv;\n    f += .1250*noiseF( uv ); uv = m*uv;\n    f += .0625*noiseF( uv ); uv = m*uv;   \n    \n    return f;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2GWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 128, 128, 219], [221, 253, 280, 280, 707], [785, 785, 828, 828, 1087], [1089, 1183, 1237, 1237, 2230]], "test": "untested"}
{"id": "sdS3D1", "name": "Jiggly Blob", "author": "oneshade", "description": "Mixing coefficients seems to result in a morphing shape!", "tags": ["mix", "raycast", "raytrace", "blob", "lerp", "shape", "jiggly"], "likes": 4, "viewed": 155, "published": 3, "date": "1617318750", "time_retrieved": "2024-07-30T19:29:29.166082", "image_code": "#define mixing 0.9 + 0.1 * sin(iTime * 15.0)\n\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d, minCplx = 1.0;\n\n    float d0 = b * b - 3.0 * a * c;\n    float d1 = (2.0 * b * b - 9.0 * a * c) * b + 27.0 * a * a * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n    a *= 3.0;\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) < 1e-3 && abs(C.y) < 1e-3) C = q < 0.0 ? vec2(d1, -j) : vec2(d1 - j, 0.0); // Switch sign if C=0\n    C = sin(atan(C.y, C.x) / 3.0 + vec2(1.57079632679, 0.0)) * pow(0.25 * dot(C, C), 1.0 / 6.0);\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, h < 0.0 ? 1 : 3);\n    vec2 e = vec2(1.0, 0.0);\n    for (int k=0; k < (h < 0.0 ? 2 : 3); k++) {\n        vec2 m = e * mat2(C.x, -C.y, C.yx); // Complex multiplication\n        e *= mat2(-0.5, -0.86602540378, 0.86602540378, -0.5); // Raise cube root of unity to next power\n        vec2 root = (vec2(-d0, d0) * m / dot(m, m) - vec2(b, 0.0) - m) / a;\n        if (h < 0.0 ? (abs(root.y) < minCplx) : true) roots[h < 0.0 ? 0 : k] = root.x, minCplx = abs(root.y);\n    }\n\n    return roots;\n}\n\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots[0] = 1.0 / roots[0];\n    if (roots[3] > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\nvec4 IntersectBlob(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Reused values (reusing themselves too :D)\n    float ba = b - a, ca = c - a, ea = e - a;\n    float q = ba + c - d + e - f - g + h;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n    float xy = x * y, uv = u * v;\n    float xvuy = x * v + u * y;\n\n    // Coefficients of the cubic intersection function\n    float coeff1 = q * uv * w;\n    float coeff2 = dbac * uv + (fbae * u + gcae * v) * w + (xvuy * w + uv * z) * q;\n    float coeff3 = ba * u + ca * v + ea * w + xvuy * dbac + (x * w + u * z) * fbae + (y * w + v * z) * gcae + (xy * w + xvuy * z) * q;\n    float coeff4 = a + ba * x + ca * y + ea * z + dbac * xy + (fbae * x + gcae * y) * z + q * xy * z;\n\n    // Blend with sphere coefficients\n    coeff1 = mix(coeff1, 0.0, mixing);\n    coeff2 = mix(coeff2, dot(rd, rd), mixing);\n    coeff3 = mix(coeff3, 2.0 * dot(ro, rd), mixing);\n    coeff4 = mix(coeff4, dot(ro, ro) - 10.0, mixing);\n\n    return solveCubic2(coeff1, coeff2, coeff3, coeff4);\n}\n\nvec3 getBlobNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = p.x, y = p.y, z = p.z;\n\n    float ba = b - a, ca = c - a;\n    float q = ba + c - d + e - f - g + h, qx = q * x;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n\n    float dx = ba + dbac * y + (fbae + q * y) * z;\n    float dy = ca + dbac * x + (gcae + qx) * z;\n    float dz = e - a + fbae * x + (gcae + qx) * y;\n\n    return normalize(mix(vec3(dx, dy, dz), 2.0 * p, mixing));\n}\n\nbool intersectIsValid(in vec3 p, in float t) {\n    return t > 0.0 && length(p - 0.5) < 5.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(-0.85, -0.5);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    ro += 0.5;\n\n    // Isovalues\n    float a = sin(time * 0.5) * 2.0;\n    float b = -cos(time);\n    float c = cos(time * 1.25);\n    float d = sin(time * 2.0) * 0.5;\n    float e = cos(time * 0.5) * 1.5;\n    float f = -sin(time * 1.5) * 0.25;\n    float g = sin(time);\n    float h = cos(time) * 0.75;\n\n    vec4 intersect = IntersectBlob(ro, rd, a, b, c, d, e, f, g, h);\n    int numIntersects = int(intersect[3]);\n\n    // Find closest valid intersection\n    vec3 hitPos;\n    float tMin = 1000000.0;\n    bool intersecting = false;\n    for (int i=0; i < numIntersects; i++) {\n        vec3 posCandid = ro + rd * intersect[i];\n        float tCandid = intersect[i];\n        if (intersectIsValid(posCandid, tCandid) && tCandid < tMin) {\n            hitPos = posCandid;\n            tMin = tCandid;\n            intersecting = true;\n        }\n    }\n\n    if (intersecting) {\n        vec3 n = getBlobNormal(hitPos, a, b, c, d, e, f, g, h);\n        n *= sign(dot(-rd, n));\n        float diff = max(0.0, dot(n, -rd));\n        float checkers = mod(floor(hitPos.x) + floor(hitPos.y) + floor(hitPos.z), 2.0);\n        fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25) * diff;\n    }\n\n    else {\n        fragColor = texture(iChannel0, rd);\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 111, 111, 1213], [1215, 1215, 1281, 1281, 1424], [1426, 1426, 1566, 1566, 2616], [2618, 2618, 2745, 2745, 3154], [3156, 3156, 3202, 3202, 3249], [3251, 3251, 3306, 3306, 5239]], "test": "untested"}
{"id": "NdS3Dh", "name": "Smooth Symmetric Polar Mod", "author": "PauloFalcao", "description": "This a new technique I was working on, it's a Smooth Symmetric Polar Mod.\nIt's based on the Blackle Mori asinsin smooth repetition but for polar repetitions - shadertoy.com/view/wlyBWm\nYouTube video about it here youtube.com/watch?v=27V8FOGmohQ", "tags": ["raymarching", "polar", "smooth"], "likes": 31, "viewed": 1176, "published": 3, "date": "1617313463", "time_retrieved": "2024-07-30T19:29:29.981901", "image_code": "// Smooth Symmetric Polar Mod\n// by @paulofalcao\n//\n// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//\n// Twitter: @paulofalcao\n// https://twitter.com/paulofalcao/status/1377738344021512196\n//\n// YouTube playing with this and Material Maker\n// https://www.youtube.com/watch?v=27V8FOGmohQ\n//\n// This a new technique that I was working on.\n// It's based on the Blackle Mori asin sin smooth repetition but for polar repetitions.\n//\n// In the technique the hard part was creating a distortion correction\n// because a simple use of asin_sin on polar gives a distorted \"round\" result\n// even when no smooth is used.\n// So I added a correction, this way objects would still be planar\n// even when no smooth ou little smooth is used.\n// It's more noticeble with few polar repetitions.\n// The correction is not perfect, but I have already spended way to much time\n// trying to came up with this one... lol\n//\n// Blackle Mori asin sin smooth repetition is here\n// https://www.shadertoy.com/view/wlyBWm\n//\n// Gaz made a more correct version without the need of approximation here\n// https://www.shadertoy.com/view/7sKGzR\n//\n// There was also a similar function done by mrange\n// https://www.shadertoy.com/view/wtSBWh\n//\n// And a similar function by Gaz\n// https://www.shadertoy.com/view/WdfcWr\n//\n\n//.the.real.deal. :)\n//\n//SmoothSymmetricPolarMod aka smoothRot\n//\n//s repetitions\n//m smoothness (0-1)\n//c correction (0-1)\n//d object displace from center\n//\nvec2 smoothRot(vec2 p,float s,float m,float c,float d){\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\n//Rotation\nvec2 rot(vec2 p,float f){\n    float s=sin(f);float c=cos(f);\n    return p*mat2(c,-s,s,c);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//Test Object\nfloat sdf_a(vec3 p){\n\n    //animate the parameters\n    float repetitions=floor(mod((iTime+2.0)*0.5,8.0))*2.0+4.0;\n    float smoothness=(cos(iTime*0.1+3.1415)*0.1+0.1)*(cos(iTime*0.01)*5.0+5.0);\n    float correction=1.0;\n    float displace=2.0+sin(iTime)*0.6;\n    \n    //The Smooth Symmetric Polar Mod operation aka smoothRot\n    p.xz=smoothRot(p.xz,repetitions,smoothness,correction,displace);\n    \n    //Rotate the object\n    p.yz=rot(p.yz,sin(iTime*0.5)*2.0);\n    p.xz=rot(p.xz,sin(iTime*0.2)*0.5);\n    p.xy=rot(p.xy,sin(iTime*0.03)*2.0);\n\n    //draw a rounded box\n    float b=sdRoundBox(p,vec3(1.3,0.5,0.1),0.05);\n    \n    return b;\n}\n\n//Object Color\nvec3 tex3d_a(vec3 p){\n    return vec3(1.0,0.0,0.0);\n}\n\n//Floor\nfloat sdf_b(vec3 p){\n    return max(p.y+1.0,length(p)-6.0);\n}\n\n//Floor color\nvec3 tex3d_b(vec3 p){\n    p*=2.0;\n\tvec2 w=max(abs(dFdx(p.xz)),abs(dFdy(p.xz)))+1e-5;\n\tif (max(w.x,w.y)>0.5) {\n\t\treturn vec3(mod(floor(p.x)+floor(p.z),2.0));\n\t}\n\tvec2 i=((1.-abs(2.*fract((p.xz+.5*w)/2.)-1.))-(1.-abs(2.*fract((p.xz-.5*w)/2.)-1.)))/w;\n\treturn vec3(.5-.5*i.x*i.y);\n}\n\n\n//Combine the 2 SDFs\nvec2 sdf(vec3 p) {\n    float sdfa=sdf_a(p);\n\tfloat sdfb=sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\n\n//definition\nvec3 raymarch(vec2 uv,vec3 camera,float cameraZoom,vec3 lookAt,\n    float cameraDistance,vec3 sun,float ambOcclusion,float shadowIntensity,\n    float ambLightIntensity,float lightPow,float lightSpecular,float reflection);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //setup uv\n    vec2 uv=fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    //rendering parameters\n    vec3 camera=vec3(sin(sin(iTime*0.3)*0.5+0.5)*4.0,2.0,cos(cos(iTime*0.2)*0.5+0.5)*4.0);\n    float cameraZoom=1.5;\n    vec3 lookAt=vec3(0.0,0.0,0.0);\n    float cameraDistance=1.1;\n    vec3 sun=vec3(0.0,2.0,2.5);\n    float ambOcclusion=1.0;\n    float shadowIntensity=1.0;\n    float ambLightIntensity=0.25;\n    float lightPow=128.0;\n    float lightSpecular=0.7;\n    float reflection=0.2;\n    vec3 col = raymarch(uv,camera,cameraZoom,lookAt,cameraDistance,sun,\n        ambOcclusion,shadowIntensity,ambLightIntensity,lightPow,lightSpecular,reflection);\n\n    fragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n}\n\n\n//************************* Rendering framework ****************************************\n\nvec3 normal(vec3 p){  \n  const vec2 e=vec2(0.001,-0.001);\n  float x=sdf(p+e.xyy).x;\n  float y=sdf(p+e.yxy).x;\n  float z=sdf(p+e.yyx).x;\n  return normalize(vec3(x-y-z,-x+y-z,-x-y+z)+sdf(p+e.xxx).x);\n}\n\nvoid march(inout float d,out vec3 p,out vec2 dS,in vec3 ro,in vec3 rd){\n    for (int i=0; i < 100; i++) {\n    \tp = ro + rd*d;\n        dS = sdf(p);\n        d += dS.x;\n        if (d > 20.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = sdf( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = sdf( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 hdri(vec3 p,float v) {\n\treturn pow(texture(iChannel0, p).xyz, vec3(2.2))\n    + pow(texture(iChannel0, p).xxx, vec3(16.0)) * v;\n}\n\nvec3 raymarch(\n        vec2 uv,\n        vec3 camera,\n        float cameraZoom,\n        vec3 lookAt,\n        float cameraDistance,\n        vec3 sun,\n        float ambOcclusion,\n        float shadowIntensity,\n        float ambLightIntensity,\n        float lightPow,\n        float lightSpecular,\n        float reflection) {\n\tvec3 cam=camera*cameraZoom;\n\tvec3 ray=normalize(lookAt-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(ray,cX));\n\tvec3 rd = normalize(ray*cameraDistance+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0.);\n\tvec2 dS=vec2(0.);\n\tmarch(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.);\n\tvec3 objColor=(dS.y<0.5)?tex3d_a(p):tex3d_b(p);\n\tvec3 light=normalize(sun);\n\tif (d<20.0) {\n\t    vec3 n=normal(p);\n\t\tfloat l=clamp(dot(-light,-n),0.,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.,1.0);\n\t\tfloat cAO=mix(1.0,calcAO(p,n),ambOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow(p,light,0.05,5.),shadowIntensity);\n\t\tcolor=min(\n            vec3(max(shadow,ambLightIntensity)),\n            max(l,ambLightIntensity))*max(cAO,ambLightIntensity)*objColor+\n                pow(r,lightPow)*lightSpecular;\n\t\t//reflection\n        d=0.01;\n\t\tmarch(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0.);\n\t\tif (d<20.0) {\n\t\t\tobjColorRef=(dS.y<0.5)?tex3d_a(p):tex3d_b(p);\n\t\t\tn=normal(p);\n\t\t\tl=clamp(dot(-light,-n),0.,1.);\n\t\t\tobjColorRef=max(l,ambLightIntensity)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=hdri(ref.zyx,1.0);\n\t\t}\n\t\tcolor=mix(color,objColorRef,reflection);\n\t} else {\n\t\tcolor=hdri(rd.zyx,0.0);\n\t}\n\treturn color;\n}\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdS3Dh.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1311, 1471, 1526, 1526, 1693], [1695, 1706, 1731, 1731, 1797], [1799, 1847, 1892, 1892, 1983], [1985, 1999, 2019, 2049, 2636], [2638, 2653, 2674, 2674, 2706], [2708, 2716, 2736, 2736, 2777], [2779, 2793, 2814, 2814, 3072], [3075, 3096, 3114, 3114, 3246], [3485, 3485, 3541, 3556, 4269], [4362, 4362, 4382, 4382, 4561], [4563, 4563, 4634, 4634, 4787], [4789, 4834, 4875, 4875, 5133], [5135, 5180, 5256, 5256, 5564], [5566, 5566, 5593, 5593, 5699], [5701, 5701, 6021, 6021, 7279]], "test": "untested"}
{"id": "fsBGDh", "name": "Fractal 47_gaz", "author": "gaz", "description": "inspired https://twitter.com/zozuar/status/1370468539526742022", "tags": ["fractal"], "likes": 17, "viewed": 355, "published": 3, "date": "1617286219", "time_retrieved": "2024-07-30T19:29:30.793730", "image_code": "#define hue(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define rot(a)mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvoid mainImage(out vec4 O, in vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,j,g,e;i++<99.;){\n        vec3 p=d*g;\n        p.z-=-1.;\n        p.y-=p.z*.6;\n        p.xz*=rot(iTime*.1);\n        // https://www.shadertoy.com/view/MlfXW7\n        vec2 z=p.xz;\n        for(j=5.;dot(z,z)<4.&&j++<99.;)\n            z=mat2(z,-z.y,z.x)*z+vec2(.3,.48)*rot(sin(iTime)*.1);       \n        e=p.y+log2(log(j))*exp(-.002*j*j)*.1;\n        g+=e*.5;\n        O.rgb+=mix(vec3(1),hue(log(j)),.8)*log(1./abs(e))/1000.;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBGDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 138, 138, 666]], "test": "untested"}
{"id": "7dj3Wz", "name": "Nautilus Egg", "author": "dr2", "description": "The Nautilus Egg (possibly a gift from Faberge to Verne)", "tags": ["submarine", "faberge", "verne"], "likes": 13, "viewed": 275, "published": 3, "date": "1617274344", "time_retrieved": "2024-07-30T19:29:31.767129", "image_code": "// \"Nautilus Egg\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 6 in \"Egg\" series:\n    \"Lost Egg\"             (ls3XDn)\n    \"Faberge Balls\"        (MsdXWn)\n    \"Golden Dolphin\"       (MtsBWX)\n    \"Ship in a Shell\"      (XlBfRR)\n    \"Fibonacci Polyhedra\"  (llyfRh)\n    \n  No. 8 in \"Nautilus\" series:\n    \"The Nautilus, Part 1\" (tlVGDd)\n    \"The Nautilus, Part 2\" (WlcXzN)\n    \"The Nautilus, Part 3\" (wltSWH)\n    \"The Nautilus, Part 4\" (3ttSzX)\n    \"Nautilus: The Book\"   (3lVSWw)\n    \"Nautilus Submerging\"  (WtXfR2)\n    \"Nautilus Interior\"    (wt2fzz)\n*/\n\n#define AA  0\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noiseff (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, sbPos, hingSz, qHit;\nvec2 opCs;\nfloat tCur, dstFar, sbRot, sbLen, prpRot, szFac, rShell, opPhs, dGlow;\nint idObj;\nbool isSh;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idShell = 20, idHing = 21, idArm = 22;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat NautDf (vec3 p, float dMin)\n{\n  vec3 q, qe;\n  float d, rad, s, dph, suLen;\n  p.z -= -0.5;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  qHit = p;\n  if (! isSh) dGlow = min (dGlow, dMin);\n  return 0.7 * dMin;\n}\n\nfloat ShRad (vec3 p)\n{\n  return 0.5 * rShell + 0.02 * (1. - p.y / length (p)) * cos (64. * atan (p.x, p.z));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, ds, r;\n  dMin = dstFar;\n  q = p;\n  q -= sbPos;\n  q.xz = Rot2D (q.xz, sbRot);\n  if (! isSh) d = szFac * PrCylDf (q / szFac, 2.3, sbLen + 2.);\n  if (isSh || d < 0.2) dMin = szFac * NautDf (q / szFac, dMin / szFac);\n  else dMin = d;\n  q = p;\n  q.z -= - rShell + 0.1 - 2. * hingSz.z;\n  d = PrCapsDf (q.yzx, hingSz.y + 0.02, hingSz.x);\n  DMINQ (idHing);\n  q.yz = Rot2Cs (q.yz, opCs);\n  q.y = abs (q.y);\n  q.yz = Rot2Cs (q.yz, opCs);\n  q.z -= rShell - 0.1 + 2. * hingSz.z;\n  r = ShRad (q);\n  ds = length (max (vec2 (length (q.xz) - r, abs (q.y)), 0.)) - r;\n  d = 0.9 * SmoothMax (abs (ds) - 0.05, -0.01 - q.y, 0.01);\n  DMINQ (idShell);\n  q.z -= - rShell + 0.1 - hingSz.z;\n  d = max (PrRoundBoxDf (q, vec3 (hingSz.xy, hingSz.z + 0.01) - 0.02, 0.02), max (- ds, 0.05 - q.y));\n  DMINQ (idArm);\n  q = p;\n  q.y -= -0.5 * rShell + 0.1;\n  d = PrCylDf (q.xzy, 0.3, 0.05);\n  q.y -= 0.5 * sbPos.y + 0.6;\n  d = min (d, PrCylDf (q.xzy, 0.07, 0.5 * sbPos.y + 0.7));\n  DMINQ (idArm);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.04, h);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 NautColN (vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (qHit.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * qHit))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (qHit.y, - qHit.x) / pi, 2. * qHit.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (qHit.z + 1.)), smoothstep (0.01, 0.012, abs (qHit.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 = (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    col4 = cc;\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.02, 0.02, 0.005, qHit.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (qHit.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * qHit.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.2, 0.8, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      qHit = vec3 (abs (qHit.x), qHit.yz) - vec3 (0.25, 1.7, 1.95);\n      qHit.xy = Rot2D (qHit.xy, -0.05 * pi);\n      qHit.xz = Rot2D (qHit.xz, -0.05 * pi);\n      t = length (qHit.yz) - 0.17;\n    } else {\n      t = length (qHit.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (qHit.y + qHit.z), abs (qHit.y - qHit.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (1, 0., 0., -1.);\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, r, s, y, sh;\n  hingSz = vec3 (1., 0.2, 0.4);\n  rShell = 4.;\n  sbLen = 6.;\n  szFac = 0.45;\n  isSh = false;\n  dGlow = dstFar / szFac;\n  dstObj = ObjRay (ro, rd);\n  dGlow *= szFac;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj < idShell) {\n      vn.xz = Rot2D (vn.xz, sbRot);\n      col4 = NautColN (vn);\n      if (col4.a >= 0.) vn = VaryNf (32. * qHit, vn, 0.5);\n      vn.xz = Rot2D (vn.xz, - sbRot);\n      if (col4.a >= 0.) col4.rgb = sqrt (Maxv3 (col4.rgb)) * mix (vec3 (0.9, 1., 0.9),\n         vec3 (0.9, 0.9, 1.), - dot (vn, rd));\n    } else {\n      col4 = vec4 (1., 1., 0.9, 0.1);\n      if (idObj == idShell) {\n        r = ShRad (qHit);\n        s = length (max (vec2 (length (qHit.xz) - r, abs (qHit.y)), 0.)) - r;\n        if (s < 0. && qHit.y > 0.01) {\n          y = 1. - qHit.y / length (qHit);\n          col4 = mix (vec4 (0.5, 0.5, 1., 0.1), vec4 (0.95, 0.95, 1., 0.1),\n             smoothstep (0.1, 0.3, y) * smoothstep (-0.2, 0.2, (r - 0.5 * rShell) / (0.02 * y)));\n        } else if (s > 0.) {\n           col4 = mix (col4, vec4 (1., 0.9, 0.9, 0.1), smoothstep (0.5, 0.7, cos (32. *\n              asin (qHit.y / length (qHit)) + 8. * atan (qHit.x, qHit.z) * sign (ro.y))));\n        }\n      } else if (idObj == idHing) {\n        col4 *= 0.95 * (1. - 0.4 * SmoothBump (-0.04, 0.04, 0.02, mod (4. * qHit.x / hingSz.x +\n           0.5, 1.) - 0.5));\n      } else if (idObj == idArm) {\n        col4 *= 0.95;\n      }\n    }\n    if (idObj < idShell) dGlow = dstFar;\n    if (col4.a >= 0.) {\n      if (idObj < idShell || idObj == idShell && s < 0.) col4 *= 0.1 + 0.9 * smoothstep (0.05, 0.3, opPhs);\n      isSh = true;\n      sh = ObjSShadow (ro + 0.01 * ltDir, ltDir);\n      col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    } else {\n      col = col4.rgb * (0.2 - 0.8 * dot (vn, rd)) * (1. - 0.2 * Noiseff (8. * tCur));\n    }\n  } else {\n    col = vec3 (0.08, 0., 0.) * (0.85 + 0.15 * SmoothBump (0.3, 0.7, 0.15,\n       mod (32. * atan (rd.z, rd.x) / pi, 1.))) + 80. * pow (1. - 0.6 * abs (dot (rd,\n       VaryNf (512. * vec3 (rd.xz, rd.y / length (rd.xz) + 0.01 * tCur).xzy, rd, 2.))), 8.);\n  }\n  col = mix (col, vec3 (0.7, 0.6, 0.2) * (1. - 0.2 * Noiseff (16. * tCur)), exp (- 12. * dGlow));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  opPhs = SmoothBump (0.25, 0.85, 0.15, mod (0.1 * tCur, 1.));\n  opCs = sin (0.2 * pi * opPhs + vec2 (0.5 * pi, 0.));\n  sbPos = vec3 (0., -0.6 + 1.4 * opPhs, 0.);\n  sbRot = 0.1 * pi * tCur;\n  prpRot = 0.5 * 2. * pi * tCur;\n  az = pi;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.5 * pi * (2. * mod (floor (0.04 * tCur), 2.) - 1.) *\n       SmoothBump (0.25, 0.65, 0.1, mod (0.04 * tCur, 1.));\n    el -= 0.05 * pi * sin (0.05 * pi * tCur);\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  vuMat = StdVuMat (el, az);\n  dstFar = 60.;\n  zmFac = 5.;\n  ro = vuMat * vec3 (0., 0.5, -24.);\n  ltDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dj3Wz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1847, 1847, 1882, 1882, 4808], [4810, 4810, 4832, 4832, 4920], [4922, 4922, 4944, 4944, 5952], [5954, 5954, 5987, 5987, 6171], [6173, 6173, 6194, 6194, 6449], [6451, 6451, 6488, 6488, 6729], [6731, 6731, 6756, 6756, 8700], [8702, 8702, 8737, 8737, 11182], [11184, 11184, 11240, 11240, 12649], [12651, 12651, 12684, 12684, 12773], [12775, 12775, 12821, 12821, 12868], [12870, 12870, 12903, 12903, 12930], [12932, 12932, 12974, 12974, 13025], [13027, 13027, 13086, 13086, 13176], [13178, 13178, 13231, 13231, 13292], [13294, 13294, 13337, 13337, 13410], [13412, 13412, 13434, 13434, 13472], [13474, 13474, 13510, 13510, 13716], [13718, 13718, 13763, 13763, 13866], [13868, 13868, 13913, 13913, 13951], [13953, 13953, 14010, 14010, 14093], [14095, 14095, 14125, 14125, 14238], [14240, 14240, 14271, 14271, 14335], [14369, 14369, 14393, 14393, 14446], [14448, 14448, 14472, 14472, 14602], [14604, 14604, 14628, 14628, 14848], [14850, 14850, 14875, 14875, 15021], [15023, 15023, 15048, 15048, 15234], [15236, 15236, 15261, 15261, 15486], [15488, 15488, 15509, 15509, 15664], [15666, 15666, 15687, 15687, 15842], [15844, 15844, 15873, 15873, 16085], [16087, 16087, 16126, 16126, 16311]], "test": "untested"}
{"id": "7d2GWz", "name": "Metaballs Inside", "author": "TimurAB", "description": "Double raymarching function to get interesting 'shape inside a shape' effect.", "tags": ["raymarching", "metaballs", "cube"], "likes": 2, "viewed": 329, "published": 3, "date": "1617273395", "time_retrieved": "2024-07-30T19:29:32.539064", "image_code": "float _pi = 3.14159265358979;\n\nvec3 hsv_to_rgb (float h, float s, float v)\n{\n    if (s == 0.0) {\n        return vec3(v);\n    }\n    float i = floor(h * 6.0);\n    float f = h * 6.0 - i;\n    float p = v * (1.0 - s);\n    float q = v * (1.0 - f * s);\n    float t = v * (1.0 - (1.0 - f) * s);\n    if (i >= 6.0 || i < 1.0) return vec3(v,t,p);\n    else if (i >= 1.0 && i < 2.0) return vec3(q,v,p);\n    else if (i >= 2.0 && i < 3.0) return vec3(p,v,t);\n    else if (i >= 3.0 && i < 4.0) return vec3(p,q,v);\n    else if (i >= 4.0 && i < 5.0) return vec3(t,p,v);\n    else if (i >= 5.0 && i < 6.0) return vec3(v,p,q);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));\n}\n\nfloat smoothmin (float a, float b, float k) {\n    float h = clamp(0.5 * (1.0 + (a-b)/k),0.0,1.0);\n    return mix(a,b,h)-k*h*(1.0-h);\n}\n\nfloat cubeDist (vec3 point) {\n    vec3 q = abs(point - vec3(0.0)) - 0.8;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sphereDist (vec3 point) {\n    float _t = iTime;\n    vec4 s0 = vec4(sin(_t),-sin(_t),cos(_t), 0.9);\n    vec4 s1 = vec4(0.5,-0.5,0.5, 1.1);\n    float d0 = length(point - s0.xyz) - s0.w;\n    float d1 = length(point - s1.xyz) - s1.w;\n    return smoothmin(d0, d1, 0.5);\n}\n\nvec3 cubeNormal (vec3 p) {\n    vec2 c = vec2(0.01, 0.0);\n    float d = cubeDist(p);\n    return normalize(vec3(\n        d - cubeDist(p - c.xyy),\n        d - cubeDist(p - c.yxy),\n        d - cubeDist(p - c.yyx)\n    ));\n}\n\nvec3 sphereNormal (vec3 p) {\n    vec2 c = vec2(0.01, 0.0);\n    float d = sphereDist(p);\n    return normalize(vec3(\n        d - sphereDist(p - c.xyy),\n        d - sphereDist(p - c.yxy),\n        d - sphereDist(p - c.yyx)\n    ));\n}\n\nvec3 rmcube (vec3 ro, vec3 rd) {\n    vec3 v0 = ro;\n    vec3 dir = rd;\n    float d = cubeDist(v0), total = d;\n    float eps = 0.01, max_dist = 100.0;\n    for(int n = 0; n < 1000; n ++) {\n        dir *= d / length(dir);\n        v0 += dir;\n        d = cubeDist(v0);\n        total += d;\n        if (d < eps || total > max_dist) break;\n    }\n    if (total >= max_dist) v0.x = -1000.0;\n    return v0;\n}\nvec3 rmsphere (vec3 ro, vec3 rd) {\n    vec3 v0 = ro;\n    vec3 dir = rd;\n    float d = sphereDist(v0), total = d;\n    float eps = 0.01, max_dist = 100.0;\n    for(int n = 0; n < 1000; n ++) {\n        dir *= d / length(dir);\n        v0 += dir;\n        d = sphereDist(v0);\n        total += d;\n        if (d < eps || total > max_dist) break;\n    }\n    if (total >= max_dist) v0.x = -1000.0;\n    return v0;\n}\n\nvec3 grayscale (vec3 col) {\n    vec3 g = vec3(0.299, 0.587, 0.114);\n    g = g * col;\n    float c = g.r + g.g + g.b;\n    return mix(vec3(0.0,0.0,c), hsv_to_rgb(fract(iTime * 0.05),1.,1.), 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= aspect;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = 2.0 * mouse - 1.0;\n    float _t = iTime;\n    float a0 = _t, a1 = 0.0;\n    if (iMouse.z > 0.0) {\n        a0 = -1.0 * mouse.x * _pi;\n        a1 = mouse.y * _pi;\n    }\n    vec3 camera = vec3(0.0, 0.0, -2.5);\n    vec3 ro = vec3(uv + camera.xy, 1.0 + camera.z);\n    camera.yz *= rotate2d(a1);\n    camera.xz *= rotate2d(a0);\n    ro.yz *= rotate2d(a1);\n    ro.xz *= rotate2d(a0);\n    vec3 rd = ro - camera;\n\n    vec3 col = 0.5 * vec3(uv.y - a1) + 0.5;\n    vec3 pos = rmcube(ro, rd);\n    if (pos.x != -1000.0) {\n        vec3 norm = cubeNormal(pos);\n        norm = 0.5 * ( 1.0 + norm);\n        col = grayscale(norm);\n        rd = rd + 0.2 * norm;\n        ro = ro + pos;\n        col *= clamp(length(pos + rd)*0.4, .0, 1.0);\n        pos = rmsphere(ro, rd);\n        if (pos.x != -1000.0) {\n            norm = sphereNormal(pos);\n            col = 0.5 * (1.0 + norm);\n            col *= hsv_to_rgb(fract(0.2 * _t), 1., 1.);\n        }\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2GWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 76, 76, 607], [609, 609, 637, 637, 706], [708, 708, 753, 753, 842], [844, 844, 873, 873, 986], [988, 988, 1019, 1019, 1260], [1262, 1262, 1288, 1288, 1480], [1482, 1482, 1510, 1510, 1710], [1712, 1712, 1744, 1744, 2108], [2109, 2109, 2143, 2143, 2511], [2513, 2513, 2540, 2540, 2707], [2709, 2709, 2766, 2766, 3907]], "test": "untested"}
{"id": "7d23DR", "name": "2D amoebas", "author": "mrange", "description": "License CC0: 2D Amoebas\nWhile messing around I stumbled on a simple \"amoeba\" lika effect.\nNothing complicated but nice IMHO so I shared\n", "tags": ["2d"], "likes": 13, "viewed": 525, "published": 3, "date": "1617269072", "time_retrieved": "2024-07-30T19:29:33.324962", "image_code": "// License CC0: 2D Amoebas\n//  While messing around I stumbled on a simple \"amoeba\" lika effect.\n//  Nothing complicated but nice IMHO so I shared\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nfloat df(vec2 p) {\n  // Generates a grid of dots\n  vec2 dp = p;\n  vec2 dn = mod2(dp, vec2(0.25));\n  float ddots = length(dp);\n  \n  // Blobs\n  float dblobs = 1E6;\n  for (int i = 0; i < 5; ++i) {\n    float dd = circle(p-1.0*vec2(sin(TIME+float(i)), sin(float(i*i)+TIME*sqrt(0.5))), 0.1);\n    dblobs = pmin(dblobs, dd, 0.35);\n  }\n\n  float d = 1E6;\n  d = min(d, ddots);\n  // Smooth min between blobs and dots makes it look somewhat amoeba like\n  d = pmin(d, dblobs, 0.35);\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n \n  const float z = 1.4;\n  float d = df(p/z)*z; \n  \n  vec3 col = vec3(0.33);\n  col = mix(col, vec3(.0), smoothstep(-aa, aa, -d));\n\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d23DR.jpg", "access": "api", "license": "cc0-1.0", "functions": [[205, 205, 236, 236, 262], [264, 288, 327, 327, 420], [422, 453, 489, 489, 583], [586, 586, 604, 634, 1068], [1070, 1070, 1107, 1107, 1359], [1361, 1361, 1416, 1416, 1736]], "test": "ok"}
{"id": "sd2GRm", "name": "Quaternion Twister", "author": "mla", "description": "Twisting space with quaternions (& performing the Dirac belt trick).\n\nMouse to rotate.", "tags": ["twister", "quaternion", "interpolation"], "likes": 31, "viewed": 811, "published": 3, "date": "1617267117", "time_retrieved": "2024-07-30T19:29:34.088920", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Quaternion Twister, Matthew Arcus, mla, 2020\n//\n// Divide space into a series of concentric spheres, centred on the\n// origin, apply to each sphere a rotation that varies smoothly with\n// radial distance. This defines a path in the space of unit quaternions,\n// which is the hypersphere. Now vary the path smoothly over time,\n// giving a smooth bijective distortion of space with no discontinuities.\n//\n// In the code, vec4(x,y,z,w) represents quaternion w+ix+jy+kz, and\n// we go from no rotation (w=1) at r >= 1, to a steady rotation in the\n// xw plane at the origin. The path in between is mapped to a circular\n// path on the hypersphere (in the xyw subspace in fact) giving a smooth\n// transition of paths as the central rotation varies & gives a nice\n// demonstration of \"Dirac's belt trick\".\n//\n// Useful video from Jason Hise: https://youtu.be/zAvaCPmgdf0\n// Some of the maths: https://arxiv.org/abs/1001.1778\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#if HW_PERFORMANCE==0\nconst int AA = 1;\n#else\nconst int AA = 2;\n#endif\n\nint Q = 3, R = 5; // Symmetry group\nfloat lradius = 0.025,pradius = 0.2; // Line and point radius\nfloat PI = 3.1415927;\n\nfloat eyedist = 2.0;  // Eye is at (0,0,eyedist);\nvec3 light = vec3(0,1,2); //Position of light\n\n// Raymarching configuration.\nint maxsteps = 200;\nfloat precis = 1e-4; \nfloat lfactor = 0.2; // \"Lipschitz adjustment factor\"\n\n// R3 rotation of p with quaternion q\nvec3 qrot(vec3 p, vec4 q) {\n  return p + 2.0*cross(q.xyz,cross(q.xyz,p)+q.w*p);\n}\n\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  p -= q; r -= q; // q is origin\n  float h = clamp(dot(p,r)/dot(r,r),0.0,1.0);\n  return length(p-h*r);\n}\n\nvec3 A,B,C,a,b,c;\n\nvoid init(int Q, int R) {\n  // Setup folding planes\n  //float p = PI/float(P);\n  float q = PI/float(Q);\n  float r = PI/float(R);\n  A = vec3(1,0,0);\n  // A.B = -cos(p)\n  //B = vec3(-cos(p),sin(p),0);\n  B = vec3(0,1,0);\n  // A.C = -cos(r)\n  float x = -cos(r);\n  // B.C = -cos(q) = cos(p)cos(r) + y sin(p)\n  float y = -cos(q);\n  // |C| = 1\n  float z = sqrt(1.0-x*x-y*y);\n  C = vec3(x,y,z);\n  a = normalize(cross(B,C));\n  b = normalize(cross(C,A));\n  c = normalize(cross(A,B));\n}\n\nint NFOLDS = 8;\nvec3 fold(vec3 pos) {\n  // We want to know the number of actual reflections made\n  // so keep track of that in flips.\n  for (int i = 0; i < NFOLDS; i++) {\n    pos.xy = abs(pos.xy);\n    float k = dot(pos,C);\n    if (k > 0.0) break;\n    pos -= 2.0*k*C;\n  }\n  return pos;\n}\n\nfloat de(vec3 p, out int type) {\n  float t = 0.2*iTime;\n  vec4 quat = vec4(sin(PI*t),0,0,cos(PI*t)); // Central rotation\n\n  // Interpolation etc. done in quaternion space ie. on the hypersphere\n  float s = max(0.0,1.0-(length(p)-pradius)/(1.0-pradius)); // Distance to central sphere\n  s = 0.5-0.5*cos(PI*s); // Circle distance to line distance\n  quat = mix(vec4(0,0,0,1),quat,s); // Interpolate\n  quat.y = sqrt(max(0.0,(1.0-dot(quat,quat)))); // Project to sphere along y\n  if (mod(t,4.0) > 2.0) quat.y = -quat.y; // Change hemisphere\n  p = qrot(p,quat); // Apply rotation\n  vec3 p0 = p;\n  p = fold(p);\n\n  float d = 1e8, d0;\n  d0 = segment(p,vec3(0),a)-lradius;\n  if (d0 < d) { type = 1; d = d0; }\n  d0 = segment(p,vec3(0),b)-lradius;\n  if (d0 < d) { type = 2; d = d0; }\n  d0 = segment(p,vec3(0),c)-lradius;\n  if (d0 < d) { type = 3; d = d0; }\n  d0 = length(p)-pradius;\n  if (d0 < d) { type = 4; d = d0; }\n  d *= lfactor; // Attenuate distance estimate\n  d = max(d,length(p0)-1.1);\n  return d;\n}\n\nfloat de(vec3 p) {\n  int type;\n  return de(p,type);\n}\n\nfloat maxdist = 10.0;\nfloat march(vec3 q, vec3 r) {\n  float t = 0.0;\n\n  // Start from intersection with sphere.\n  float R = 1.0+lradius;\n  float B = dot(q,r), C = dot(q,q)-R*R;\n  float D = B*B - C;\n  // No intersection, so give up.\n  if (D < 0.0) return -1.0;\n  D = sqrt(D);\n  float t0 = -B-D;\n  maxdist = -B+D; // nice idea from iq\n  // If t0 < 0, then we are inside sphere\n  if (t0 > 0.0) t = t0;\n  \n  for (int i = 0; i < maxsteps; i++) {\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t; // Close enough to the surface.\n    t += d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p) {\n  float eps = 0.001;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  p.zx = rotate(p.zx,0.25*PI);\n  p.xy = rotate(p.xy,0.25*PI);\n  return p;\n}\n\nvec3 getbasecolor(int type) {\n  if (type == 1) return vec3(1,1,0);\n  if (type == 2) return vec3(0,1,0);\n  if (type == 3) return vec3(0,0,1);\n  if (type == 4) return vec3(1,0,0);\n  return vec3(0.75,1,0.75);\n}\n\nvec3 getbackground(vec3 r) {\n  return mix(vec3(1),pow(r,vec3(2)),0.5); // Colourful fun\n  return vec3(0,0,0.1); // The more sober option.\n}\n\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  // Get the surface point that has been hit,\n  vec3 p = q+t*r;\n  // and the normal at that point.\n  vec3 normal = getnormal(p);\n\n  // Call de again to find what we've hit.\n  int type;\n  de(p,type);\n  \n  // Apply lighting. This is a basic \"Lambertian\" model.\n  vec3 lightdir = normalize(light-p);\n  vec3 color = mix(vec3(1),getbasecolor(type),0.6);\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  init(Q,R);\n  maxdist = eyedist + 1.0;\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = transformframe(light);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      vec3 ray = vec3(z,-2);\n      ray = transformframe(ray);\n      ray = normalize(ray);\n      col += raycolor(eye,ray);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545)); // Gamma\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2GRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1505, 1543, 1570, 1570, 1624], [1626, 1626, 1665, 1665, 1770], [1791, 1791, 1816, 1869, 2266], [2284, 2284, 2305, 2401, 2554], [2556, 2556, 2588, 2588, 3552], [3554, 3554, 3572, 3572, 3607], [3631, 3631, 3660, 3660, 4218], [4220, 4265, 4289, 4289, 4503], [4505, 4536, 4566, 4566, 4611], [4613, 4651, 4680, 4680, 5022], [5024, 5024, 5053, 5053, 5231], [5233, 5233, 5261, 5261, 5372], [5374, 5374, 5405, 5405, 5947], [5949, 5949, 6000, 6000, 6531]], "test": "untested"}
{"id": "7s2GWR", "name": "Simple Topdown Circular Waves", "author": "yinkar", "description": "Simple circular waves", "tags": ["wave", "water", "blue", "topdown"], "likes": 2, "viewed": 316, "published": 3, "date": "1617261953", "time_retrieved": "2024-07-30T19:29:34.860856", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= (iResolution.x / iResolution.y);\n\n\tvec3 color = vec3(0.0, 0.2, 0.5);\n\t\n\t\n\tif (mod(length(vec2(uv.x - 0.85, uv.y - 0.5)) - iTime / 9.0, 0.05) < \n        0.01 / length(vec2(uv.x - 0.85, uv.y - 0.5)) * 0.04) {\n\t\tcolor += 0.25;\n\t}\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2GWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 379]], "test": "untested"}
{"id": "sd2GWR", "name": "Simple Water Waves", "author": "yinkar", "description": "Waves", "tags": ["simple", "wave", "sea", "water", "ocean"], "likes": 4, "viewed": 352, "published": 3, "date": "1617261072", "time_retrieved": "2024-07-30T19:29:35.759453", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = vec3(0.0, 0.1, 0.3);\n    \n    const int waveCount = 6;\n    float yDir = cos(iTime * 3.0) * 0.08;\n    \n    for (int i = 0; i < waveCount; i++) {\n        if (mod(float(i), 2.0) == 0.0) {\n            yDir *= -1.0;\n        }\n        \n        if (uv.y < \n        sin(\n            uv.x * 60.0 / (1.0 + (float(i) / 10.0)) - iTime\n            * (float(waveCount * 3) - float(i) * 3.0)\n        )\n        * 0.01\n        + 0.2\n        + (float(i) + yDir * (float(i) * 0.8))\n        / 25.0) {\n            color.bg +=  0.01 + float(i) / 25.0;\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2GWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sdjGWR", "name": "Flowers and foliage 4", "author": "jarble", "description": "A simple fractal formula.\nFull-screen mode recommended.", "tags": ["fractal", "feather", "coral"], "likes": 2, "viewed": 223, "published": 3, "date": "1617255191", "time_retrieved": "2024-07-30T19:29:36.676003", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.6;\n        float scale1 = 1.5;\n        float s1 = scale1*scale;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.0-abs((uv.x-uv.y)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            uv.x /= -1.1;\n            col[c] = fract((.25*col[c]+col.x+(uv.y)-(uv.x))/2.0);\n        }\n     \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjGWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 734]], "test": "untested"}
{"id": "fs23Wz", "name": "Frosty Fir Forest", "author": "jarble", "description": "A simple fractal formula.\nFull-screen mode recommended.", "tags": ["fractal", "feather", "coral"], "likes": 2, "viewed": 290, "published": 3, "date": "1617243428", "time_retrieved": "2024-07-30T19:29:37.492819", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    float x1 = 1.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0/x1;\n    uv += vec2(t/2.0,t/3.0)/4.0/x1;\n    for(int c=0;c<3;c++){\n        float scale = 4.5;\n        float scale1 = 1.5;\n        float s1 = scale1*scale;\n        for(int i=0;i<9;i++)\n        {\n            uv += uv.xx;\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.0-abs((uv.x-uv.y)/(12.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            uv.x /= -scale1;\n            col = (col.yzx+col)/2.0;\n        }\n     col[c] = fract(((uv.y)+(uv.x))/(2.0));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs23Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 797]], "test": "untested"}
{"id": "Ns23Wz", "name": "Fake turbulent flow", "author": "jarble", "description": "A simple fractal formula.\nFull-screen mode recommended.", "tags": ["fractal", "water", "turbulence"], "likes": 4, "viewed": 269, "published": 3, "date": "1617243421", "time_retrieved": "2024-07-30T19:29:38.256776", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime/2.0/4.5;\n    float x1 = 1.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0/x1;\n    //uv += vec2(t/2.0,t/3.0)/4.0/x1;\n    for(int c=0;c<3;c++){\n        float scale = 4.5;\n        float scale1 = 1.5;\n        float s1 = scale1*scale;\n        for(int i=0;i<9;i++)\n        {\n            uv += uv.xx-t;\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.0-abs((uv.x-uv.y)/(12.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.yx;\n            uv.x /= -scale1;\n            col = (col.yzx+col)/2.0;\n        }\n     col[c] = fract(((uv.y)+(uv.x))/2.0);\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 807]], "test": "untested"}
{"id": "NsS3zh", "name": "random octree (traversal)", "author": "ch3coohlink", "description": "fork from https://www.shadertoy.com/view/4sVfWw", "tags": ["octree"], "likes": 0, "viewed": 101, "published": 3, "date": "1617242470", "time_retrieved": "2024-07-30T19:29:39.035694", "image_code": "#define detail 20\n// int(floor((sin(iTime)*0.5+0.5)*6.+6.))\n#define steps 60\n#define maxdistance 1.5\n#define emptycell 0.3\n#define subdivisions 1.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define sqr(a) (a*a)\n#define pi 3.1415926535\n#define outof1(a) a < -1.0 || 1.0 <= a\n#define samples 2\n#define scale .1\n\nfloat rnd(vec4 v) {\n  v = fract(v  * vec4(.1031, .1030, .0973, .1099));\n  v += dot(v, v.wzxy+33.33);\n  return fract((v.x + v.y) * (v.z + v.w));\n  // return fract(4e4 * sin(dot(v, vec4(13.46, 41.74, -73.36, 14.24)) + 17.34));\n}\nint getvoxel(vec3 p, float size) {\n  //if(outof1(p.x) || outof1(p.y) || outof1(p.z)) { return 0; }\n  float val = rnd(vec4(p, size));\n  if(val < emptycell) { return 0; }\n  else { return 1; }\n  //else if(val < subdivisions) { return 1; }\n  //else { return 2; }\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  int i, j;\n  vec3 sp;\n  int spc = samples;\n  float t = iTime * 0.1;\n  for(j = 0; j < spc * spc; j++) {\n    float d = 1. / float(spc), radius = 2.;\n    vec2 spv = vec2(float(j % spc) * d - 0.5, float(j / spc) * d - 0.5);\n    vec2 uv = ((fragCoord.xy + spv) * 2.0 - iResolution.xy) / iResolution.y * scale;\n    vec3 ro = vec3(radius * sin(t), t, radius * cos(t)), rd = normalize(vec3(uv, 1.0));\n    rd.xz *= rot(t - pi);\n    \n    ro = ro + rd * (2.0 * sin(t * 2.0) + 2.0);\n    \n    vec3 sc = vec3(0), mask;\n    float size = 1., dist = 0.;\n    vec3 lro = mod(ro, size);\n    vec3 fro = ro - lro;\n    vec3 ird = 1.0 / max(abs(rd), 1e-10);\n    bool exit = false;\n    int level = 0;\n    \n    for(i = 0; i < steps;) {\n      //if(dist > maxdistance) { break; }\n      \n      if(exit) {\n        level--;\n        size *= 2.0;\n        vec3 newfro = floor(fro / size) * (size);\n        lro += fro - newfro;\n        fro = newfro;\n        exit = (level > 0) && (abs(dot(mod(fro / size + 0.5, 2.0) - 1.0 + mask * sign(rd) * 0.5, mask)) < 0.1);\n        continue;\n      }\n      \n      int v = getvoxel(fro, size); if(v == 1 && level >= detail) { v = 2; }\n      \n      if(v == 1) {\n        level++;\n        size *= 0.5;\n        vec3 mask2 = step(vec3(size), lro);\n        fro += mask2 * size;\n        lro -= mask2 * size;\n      } else if(v == 2) {\n        sc = vec3(float(i) * 0.02);\n        break;\n      } else { //move forward\n        float s = size * 0.5;\n        vec3 hit = -(sign(rd) * (lro - s) - s) * ird;\n        mask = hit.x < min(hit.y, hit.z) ? vec3(1, 0, 0) \n          : hit.y < hit.z ? vec3(0, 1, 0) : vec3(0, 0, 1);\n        float len = dot(hit, mask);\n        dist += len;\n        vec3 newfro = fro + mask * sign(rd) * size;\n        lro += rd * len - mask * sign(rd) * size;\n        exit = (level > 0) && (floor(newfro / size * 0.5 + 0.25) != floor(fro / size * 0.5 + 0.25));\n        fro = newfro;\n        \n        i++;\n      }\n    }\n    sc = i >= steps ? vec3(1, 0, 0) : sc;\n    sp += sc;\n  }\n  fragColor = vec4(sp / float(spc * spc), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsS3zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[333, 333, 352, 352, 559], [560, 560, 594, 658, 820], [821, 821, 873, 873, 2910]], "test": "untested"}
{"id": "NdjGWz", "name": "Cubic Bezier vs. Line Intersect", "author": "oneshade", "description": "Bezier curves are turning out to be quite fun.", "tags": ["bezier", "line", "intersection", "cubic", "parametric"], "likes": 6, "viewed": 325, "published": 3, "date": "1617240974", "time_retrieved": "2024-07-30T19:29:39.805635", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nstruct Intersect {\n    int count;\n    vec2[3] p;\n};\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nconst vec2 eta = vec2(-0.5, sqrt(0.75));\nint solveCubic(in float a, in float b, in float c, in float d, out vec3 roots) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d;\n\n    b /= a, c /= a, d /= a;\n    float d0 = b * b - 3.0 * c;\n    float d1 = (2.0 * b * b - 9.0 * c) * b + 27.0 * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) + abs(C.y) < 1e-3) C = vec2(d1 - j, 0.0);\n    float t = atan(C.y, C.x) / 3.0, r = pow(0.25 * dot(C, C), 1.0 / 6.0);\n    C = vec2(cos(t), sin(t));\n\n    float w = -d0 / r - r;\n    roots.x = (C.x * w - b) / 3.0;\n    roots.y = (dot(vec2(C.x, -C.y), eta) * w - b) / 3.0;\n    if (h > 0.0) roots.z = (dot(C, eta) * w - b) / 3.0;\n    else if (abs(dot(C.yx, eta)) < abs(C.y)) roots.x = roots.y;\n\n    return h < 0.0 ? 1 : 3;\n}\n\nvec2 BezierCurvePoint(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv * tInv +\n           b * 3.0 * t * tInv * tInv +\n           c * 3.0 * tInv * t * t +\n           d * t * t * t;\n}\n\nIntersect BezierLineIntersect(in vec2 ca, in vec2 cb, in vec2 cc, in vec2 cd, in vec2 la, in vec2 lb) {\n    vec2 ba = lb - la;\n    float baba = dot(ba, ba);\n    vec2 ld = normalize(ba);\n\n    mat2 invRot = mat2(ld, -ld.y, ld.x);\n    mat2 rot = transpose(invRot);\n\n    ca = (ca - la) * invRot;\n    cb = (cb - la) * invRot;\n    cc = (cc - la) * invRot;\n    cd = (cd - la) * invRot;\n\n    float coeff1 = 3.0 * cb.y - 3.0 * cc.y - ca.y + cd.y;\n    float coeff2 = 3.0 * ca.y - 6.0 * cb.y + 3.0 * cc.y;\n    float coeff3 = 3.0 * cb.y - 3.0 * ca.y;\n    float coeff4 = ca.y;\n\n    vec3 t;\n    int nroots = solveCubic(coeff1, coeff2, coeff3, coeff4, t);\n\n    vec2[3] intersects;\n    int count = 0;\n    for (int n=0; n < nroots; n++) {\n        if (abs(t[n] - 0.5) <= 0.5) {\n            vec2 p = BezierCurvePoint(ca, cb, cc, cd, t[n]) * rot;\n            if (abs(dot(p, ba) / baba - 0.5) <= 0.5) {\n                intersects[count] = p + la;\n                count++;\n            }\n        }\n    }\n\n    return Intersect(count, intersects);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.25);\n\n    float time = iTime;\n\n    float t1 = time * 0.5, t2 = time, t3 = time * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 ca = vec2(c2, s3) * 0.5;\n    vec2 cb = vec2(s1, s2) * 0.5;\n    vec2 cc = vec2(c3, c1) * 0.5;\n    vec2 cd = vec2(c2, s1) * 0.5;\n\n    vec2 la = vec2(c3, s2) * 0.5;\n    vec2 lb = vec2(s2, c1) * 0.5;\n\n    draw(sdLine(uv, la, lb) - 0.01, vec3(0.0, 0.0, 1.0));\n\n    float tStep = 0.01;\n    vec2 prev = ca;\n    for (float t=tStep; t < 1.0 + tStep; t += tStep) {\n        vec2 cur = BezierCurvePoint(ca, cb, cc, cd, t);\n        draw(sdLine(uv, prev, cur) - 0.01, vec3(1.0, 0.8, 0.0));\n        prev = cur;\n    }\n\n    Intersect intersects = BezierLineIntersect(ca, cb, cc, cd, la, lb);\n    for (int n=0; n < intersects.count; n++) {\n        draw(length(uv - intersects.p[n]) - 0.015, vec3(1.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 168, 168, 276], [319, 319, 399, 399, 1187], [1189, 1189, 1268, 1268, 1433], [2461, 2461, 2516, 2516, 3584]], "test": "untested"}
{"id": "ldVXDm", "name": " Planet 7120 - initial commit", "author": "patu", "description": "Initial commit for https://www.pouet.net/prod.php?which=68093 :)\n2016(?)", "tags": ["demoscene"], "likes": 8, "viewed": 378, "published": 3, "date": "1617235465", "time_retrieved": "2024-07-30T19:29:40.753102", "image_code": "#define getNormal getNormalHex\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 110.0\n#define FOG 1.\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nfloat noise = 0.;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n    p = vec3(0.),\n    p2 = vec3(0.),\n\tlightDir = vec3(0.);\n\n\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k ;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    float materialIndex;\n    float specular;\n    float diffuse;\n    vec3 space;\n    vec3 color;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 ){\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n               \n               return obj;\n}\n\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nvec4 texture3d (sampler2D t, vec3 p, vec3 n, float scale) {\n\t\n    return \n\t\ttexture(t, p.yz * scale) * abs (n.x) +\n\t\ttexture(t, p.zx * scale) * abs (n.y) +\n\t\ttexture(t, p.xy * scale) * abs (n.z);\n}\n\nvec4 boxmap(sampler2D t, in vec3 p, vec3 n, in float k ) {\n    vec3 m = pow( abs(p), vec3(k) );\n\tvec4 x = texture(t, p.yz);\n\tvec4 y = texture(t, p.zx);\n\tvec4 z = texture(t, p.xy);\n\treturn (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);\n}\n\ngeometry map(vec3 p) {\n    //p.y += sin(t * 1.+ p.z / 10.) * 3. + sin(p.x / 3.);\n    vec3 bp = p;\n    vec3 fp = p;\n    \n    float localNoise = fbm(p / 10.) * 2.;;\n    \n    p.y -= 11. + sin(p.z / 15. + p.x / 14.2) * 2.6;\n    p.y -= localNoise;//, p.xz / 20.).r / 2.;\n    \n    // ----------\n    geometry box;\n    //bp.xz += sin(vec2(t)) * 15.;\n    \n    //bp.z += 22. ;\n    bp.y -= (min(27., t / 2.));\n    bp.y += -4. - sin(t * 3.) * 1.4;\n    \n    //bp.xz = mod(p.xz, 70.) - 35.;\n    \n    pR(bp.xz, t);\n        //pR(bp.zy, t * 2.);\n    pR(bp.yx, t * 4.6);\n    \n    bp.z += 2.;\n    \n    pModPolar(bp.xy, 3.);\n    pMirrorOctant(bp.xz, vec2(1.) + sin(t / 4.) / 3.);\n    //pMirrorOctant(bp.xz, vec2(5.));\n    box.dist = fBox(bp, vec3(4., 9., 1.));\n    box.materialIndex = 4.;\n    box.space = bp;\n    box.color = vec3(1.);\n    box.diffuse = 0.;\n    box.specular = 22.1;\n    \n\t// ------------\n    geometry floor;\n\n    vec3 floorP = p;\n    //floorP.y += fbm(p / 370.) * 110.;\n    floor.dist = fBox2Cheap(floorP.xy, vec2(100., 2.5)),\n    floor.materialIndex = 0.;\n    floor.space = p;\n    floor.color = vec3(1., .8, .6) ;//* localNoise;\n    floor.diffuse = 8.;\n    floor.specular = 4.0;\n    \n    // ------------\n    geometry water;\n    \n\n    \n    // ----------\n    geometry obj;\n    /*\n    p.xz -= 25.;\n    \n    vec2 pM = pMod2(p.xz, vec2(50.));\n    \n    pMirrorOctant(p.zy, \n                  vec2(\n                      1. * mod(pM.x, 14.), \n                      5. + ceil(13. * (sin(pM.x) * 3.+ 1.)) \n                  )\n                 );\n    pMirrorOctant(p.xz, vec2(13., 18. + mod(pM.y * 5., 16.)));\n    \n    pR(p.zy, 1.17 + p.x / 10. );\n\n    p.x += 2.5 ;//* localNoise / 10.;\n    \n    pModPolar(p.xz, 12.5 - (sin(pM.x) * 10.+ (sin(1. / 3.) * 10.)));\n\t\n    pMirrorOctant(p.zy, vec2(8.4, 6.));\n    pMirrorOctant(p.xy, vec2(3.5, 5.));\n    \n    \n*/\n\tfloor.dist = smin(floor.dist, box.dist * localNoise / 2., 0.21 ) ;\n    //box.dist -= 0.2;\n    \n    box.dist = fBox(bp, vec3(4., 9., 1.) * vec3(1., 1., pow(vol / 2., 4.) / 2.).zyx);\n    box.color = vec3(0.) + pow(vol / 3., 4.) * 2. + box.dist;\n    \n    obj = geoU(box, floor);\n    //obj = geoU(obj, water);\n    //obj = geoU(obj, box);\n    \n    \n    return obj;\n}\n\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 290;\n\ngeometry trace(vec3 o, vec3 d, int maxI) {\n    float omega = 1.2;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = //tan(radians (FOV) / 2.0) \n        1. / 250.;\n    float functionSign = map(o).dist < 0. ? -1. : +1.;\n    geometry mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        if (maxI > 0 && i > maxI) break; \n        mp = map(d * t + o);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 25;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 1.5;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.6), 1.0);\n}\n\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                map(pos+vec3(0,EPSILON,0)).dist-d,\n                map(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\n#define delta vec3(.001, 0., 0.)\nvec3 getNormalCube(vec3 pos)   \n{    \n   vec3 n;  \n   n.x = map( pos + delta.xyy ).dist - map( pos - delta.xyy ).dist;\n   n.y = map( pos + delta.yxy ).dist - map( pos - delta.yxy ).dist;\n   n.z = map( pos + delta.yyx ).dist - map( pos - delta.yyx ).dist;\n   \n   return normalize(n);\n}\n\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, 0.4, 1.0);\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n//   rd = sin(rd) * 1.5;\n   \n   float sunSize = 2.;\n   float sunAmount = max(dot(rd, lightDir), .1);\n   float v = pow(1.2 - max(rd.y, .5), 1.1);\n   vec3 sky = mix(fromRGB(255,200,100), vec3(1.1, 1.2, 1.3) / 10., v);\n   sky += pow(fbm(rd * 1. + vec3(t / 3., t, t).yxz / 3.) * .4, 1.2);\n   sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 128.0)* sunSize,1233. * sunSize);\n\n\treturn clamp(sky, 0.0, 1.0);\n    \n   \n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), obj.diffuse);\n    // Standard specualr term.\n    float spec = max(dot(reflect(-ld, sn), -rd), obj.specular / 2.);\n\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = obj.color;//getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * 0.1);// * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvec3 LensFlare( vec3 ray, vec3 light, vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture( iChannel1, dirtuv ).r;\n\t\n\tfloat l = max(.0,dot(light,ray));\n\t\n\treturn (pow(l,20.0)*dirt*.1 + 1.0*pow(l,100.0))*vec3(1.05,1,.95);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //lightColour = normalize(fromRGB(133,7,142)) * 2.; \n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    //vec3 rd = normalize(vec3(uv, 1.0));\n//uv.x *= iResolution.y / iResolution.x;\n    \n    if (abs(uv.y) > .35) {\n     \tfragColor *= 0.;\n        return;\n    }\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    uv.y *= 1.2;\n    vol = texture(iChannel0, vec2(.5, .25)).r  * 4.; \n    float t2 = t;\n    float \n        sk = sin(-t2 * .1) * 32.0, \n        ck = cos(-t2 * .1) * 22.0,\n        \n        mat = 0.;\n    \n    //uv.x *= 2. - abs(cos(uv.y)) / 2.; // fisheye\n    \n    light = vec3(0., 77., 100.);        \n    lightDir = light;\n    \n    \n    vec3 \n        vuv = vec3(cos(t) / 6., 1., sin(t) * .2 ), // up\n    \tro = vec3(ck, 32. - ck /2., sk + 10.);// + vec3(iMouse.x / 20.,iMouse.y / 10. - 1., 1.); // pos\n    \n    vec3\n        vrp =  vec3(10., 10. + ck, 0.),// vec3(sin(iMouse.x / 10.) * 50., 0., cos(iMouse.x/ 10.) * 50.), // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        hit;        \n\t\n    vec3 sceneColor = vec3(0.);\n    \n    // Light position. Set in the vicinity the ray origin.\n    //vec3 lp = light ;\n\t//lightDir = lp;\n\t\n    //vec3 ray_start = ro;\n    \n    // FIRST PASS.\n\t\n    geometry tr = trace(ro, rd, 0);    \n    \n    float fog = smoothstep(FAR * FOG, 0., tr.dist) * 1.;\n    hit = ro + rd * tr.dist;\n    \n    vec3 sn = getNormal(hit);\t\n    \n    float sh = softShadow(hit, hit + light, 6.);\n    \n    float \n        ao = getAO(hit, sn, .2);\n\t\n    ao *= saturate(getAO(hit + sn * .2, sn, 0.5));\n    //p = tr.space;\n    ao *= saturate(getAO(hit + sn * 1.03, sn, 3.05));\n    //p = p2;\n    \n    //vec3 tp = hit;\n    //ro = p2; \n\n    noise = fbm(mod(hit + 20. + hit.yzx* 4., 40.) / 1.);\n\tvec3 sky = Sky(rd, true, normalize(light)) * 1.;\n    \n    if (tr.dist < FAR) { \n        sceneColor = (doColor(hit, rd, sn, light, tr) * 1.) * 1.;\n        sceneColor *= ao; \n        sceneColor *= sh;\n        sceneColor = mix(sceneColor, sky, saturate(tr.dist * 3. / FAR));\n        sceneColor = mix(sceneColor, lightColour, 0.1);        \n        /*sceneColor *= 0.9 + vec3(length(\n            max(\n                vec2(0.),\n                .6 * max(\n                    0.,\n                    length(normalize(light.y) * max(0., sn.y))\n                )\n            )\n        ));\n        */\n        //sceneColor.rgb += LensFlare(rd, normalize(light), fragCoord)/ 2.;\n    \n        if (tr.materialIndex == 5.) {         \t\n            vec3 refSceneColor =sceneColor;\n            rd = reflect(rd, sn);// + sin(t));\n            tr = trace(hit + rd * .02, rd, 99);\n            if (tr.dist < FAR) {\n                hit = hit + rd * tr.dist;\n                sn = getNormal(hit);\n                refSceneColor = mix(sceneColor, abs(doColor(hit, rd, sn, light, tr)), .7);                \n            } else {\n             \tsky = Sky(rd, true, normalize(light)) * 1.;\n                refSceneColor = mix(refSceneColor, sky, saturate(tr.dist * 5. / FAR));\n                refSceneColor = mix(refSceneColor, lightColour, 0.1);   \n            }\n            \n            sceneColor = mix(sceneColor, refSceneColor, .5);\n            \n        } else {\n            //sceneColor = mix(sceneColor, sky, .0);  \n        }\n        \n        //sceneColor *= 1. + length(saturate(sn) * normalize(light));\n    } else {\n        //sceneColor.r = .3;\n        //sceneColor += debug_plane(ro, rd, -4.85, tr.dist).rgb * 2.;\n        //sceneColor = vec3(1., .5, 0.) * cos(uv.y * 3.) / 3.;\n        //sky += max(0., max(0., rd.y) * spherical_texturing(rd, 1.)) * 1.;\n        sceneColor = sky;\n        \n        //fog = smoothstep(FAR * FOG, 0., tr.x * 2.);\n    \t//sceneColor *= fog;\n    }\n    \n    //sceneColor = mix(sceneColor, sky, min(1., noise * tr.dist / 90.));\n    // tonemapping\n    //sceneColor = vec3(1., 1.2, 1.3) * sceneColor / (1. + sceneColor);\n\n   // sceneColor *= 1. + float(tr.iterations) / 96.;\n    \n    // some kind of vinetting.\n    //sceneColor = saturate(sceneColor * (1.5 - length(ouv - .5) * 2.));\n    \n    //gamma\n    //sceneColor = pow(sceneColor, vec3(2.4)) + sceneColor / 1.;\n    \n    //if (tr.materialIndex != 4.) sceneColor *= 1. + 1.- abs(fract(t / 2.)) / 3.;\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 3.5), 0.0, 1.0), 1.0);\n    fragColor = pow(fragColor, vec4(1.2));\n    //fragColor = vec4(fbm(vec3(0.4) * uv.x));\n}\n", "image_inputs": [{"id": 3500, "src": "https://soundcloud.com/dj-blackley/prohibited-free-download", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 279, 279, 359], [361, 373, 399, 399, 1020], [1022, 1022, 1041, 1041, 1213], [1215, 1215, 1250, 1250, 1307], [1457, 1457, 1480, 1480, 1509], [1510, 1510, 1533, 1533, 1562], [1563, 1563, 1588, 1588, 1617], [1621, 1621, 1651, 1651, 1680], [1682, 1779, 1852, 1852, 2138], [2142, 2142, 2183, 2183, 2255], [2257, 2257, 2289, 2289, 2331], [2333, 2333, 2367, 2367, 2412], [2414, 2414, 2445, 2445, 2494], [2630, 2630, 2671, 2671, 2726], [2728, 2728, 2758, 2758, 2810], [2812, 2812, 2843, 2843, 2890], [2892, 2932, 2952, 2952, 2977], [2979, 2979, 2999, 2999, 3034], [3036, 3036, 3056, 3056, 3101], [3103, 3142, 3162, 3162, 3187], [3189, 3189, 3207, 3207, 3257], [3260, 3404, 3444, 3444, 3565], [3568, 3596, 3633, 3633, 3724], [3725, 3838, 3888, 3888, 4278], [4280, 4372, 4415, 4415, 4465], [4467, 4467, 4513, 4513, 4621], [4622, 4658, 4686, 4686, 4767], [4769, 4826, 4860, 4860, 4886], [4888, 4888, 4921, 4921, 5077], [5080, 5080, 5112, 5112, 5137], [5139, 5139, 5198, 5198, 5336], [5338, 5338, 5396, 5396, 5578], [5580, 5580, 5602, 5660, 7785], [7861, 7861, 7903, 7903, 9126], [9129, 9129, 9174, 9174, 9750], [9774, 9774, 9803, 9803, 10047], [10082, 10082, 10115, 10115, 10366], [10369, 10369, 10418, 10418, 10534], [10536, 10536, 10587, 10612, 11034], [11036, 11036, 11113, 11113, 12084], [12086, 12086, 12142, 12142, 12345], [12347, 12347, 12402, 12464, 16950]], "test": "untested"}
