{"id": "wltSzH", "name": "fractal path marcher", "author": "unnick", "description": "i made a pathmarcher that uses next-event estimation and is straight up sphagetti", "tags": ["raytracing", "raymarching", "fractal"], "likes": 12, "viewed": 547, "published": 3, "date": "1580506767", "time_retrieved": "2024-07-30T21:26:47.052492", "image_code": "//parameters in the common tab\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    col = texelFetch(iChannel0, pos, 0);\n    col /= col.w + .001;\n    col += (texelFetch(iChannel3, pos&7, 0).x - .5) / 256.;\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define res iResolution.xy\n#define tau 6.283\n\n//runs at about ~38 fps on my nvidia gt 610\n//feel free to crank up these parameters if\n//you have a more powerful gpu\n\n//...which you probably do, since a low end gpu\n//from 8 years ago isnt a very high bar...\n\n//0 = cubic kifs\n//1 = pow 8 mandelbulb\n#define FRACT 0\n\n//maximum number of light bounces (duh)\n#define MAX_BOUNCES 4\n\n//maximum raymarching steps\n#define MAX_STEPS 128\n//maximum for shadows\n#define MAX_SHADOWSTEPS 256\n\n//number of samples\n#define NSAMPLES 1\n//how much the renderer reuses previous frames\n//the lower it is, the less of a trail there is behind the fractal\n//but it also increases noise\n//also it breaks if you set it to 0, use a small value like .1 instead.\n#define REUSE_FACTOR .7\n\nmat2 rotmat(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\n//sequence of quasirandom 2d points\nvec2 quasirand(int i) { // i is supposed to be an int\n    return fract(float(i) * vec2(1.618028, 1.324717));\n}\n\n//low-bias hash\n//from https://nullprogram.com/blog/2018/07/31/\nuint hash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n//hashes an uvec4 and returns a float that ranges from 0 to 1\nfloat rand1u(uvec4 p) {\n    return (float(hash(hash(hash(p.x) ^ p.y) ^ (hash(p.z) ^ p.w)) >> 8) + .5) / 16777216.;\n}\n\n//returns 4 random floats\nvec4 rand4u(uvec4 p) {\n    return vec4(\n        rand1u(p+uvec2(0,0).xxxy),\n        rand1u(p+uvec2(0,1).xxxy),\n        rand1u(p+uvec2(0,2).xxxy),\n        rand1u(p+uvec2(0,3).xxxy)\n    );\n}\n\n//returns a point on the surface of a sphere\n//it does this by generating 3 gaussian distributed\n//floats using the box-mueller transform\n//then normalizes the result\nvec3 rand3s(uvec4 p) {\n    vec4 tmp = rand4u(p);\n    vec3 gauss = sin((tmp.xxz + vec2(0,.25).xyx) * tau) * sqrt(-log(tmp.yw)).xxy;\n    return normalize(gauss.xyz);\n}\n\n//returns an orthogonal matrix where the first column is the normal\nmat3 ortho(vec3 n) {\n    vec3 bt = n.x>.7 ? vec3(0,1,0) : vec3(1,0,0);\n    vec3 t = normalize(cross(bt, n));\n    bt = cross(t, n);\n    return mat3(n, t, bt);\n}\n", "buffer_a_code": "float sdf(vec3 p) {\n    \n    #if FRACT==0\n    vec3 x = p;\n    for(int i = 0; i < 8; i++) {\n        x.xy *= rotmat(iTime*.3);\n        x.xz *= rotmat(iTime*.3*1.618028);\n        x.yz *= rotmat(iTime*.3*1.324717);\n        x = abs(x);\n        x -= 1.;\n        x *= 2.;\n    }\n    return (length(x) - 3.) / pow(2., 8.);\n    #endif\n    \n    #if FRACT==1\n    //sort-of copied from https://www.shadertoy.com/view/ltfSWn\n    //but mixed with spaghetti :D\n    p.xz *= rotmat(iTime*.5);\n    vec3 a = p;\n    float d = 1.;\n    for(int i = 0; i < 8; i++) {\n        float r2 = dot(a,a); if(r2 > 256.) break;\n        float r4 = r2*r2;\n        float r8 = r4*r4;\n        d *= 8. * sqrt(r2*r4*r8); d += 1.;\n        vec3 a2 = a *a ;\n        vec3 a4 = a2*a2;\n        float k1 = a2.x + a2.z;\n        float k2 = 1. / (k1*k1*k1*sqrt(k1));\n        float k3 = a4.x + a4.y + a4.z - 6.*a2.x*a2.y + 2.*a2.x*a2.z - 6.*a2.y*a2.z;\n        float k4 = a2.x + a2.z - a2.y;\n        a = vec3( 64. * a.x*a.y*a.z * (a2.x-a2.z) * k4 * (a4.x - 6.*a2.x*a2.z + a4.z) * k3*k2\n                , k3*k3 - 16.*a2.y*k1*k4*k4\n                ,-8.*a.y*k4*(a4.x*a4.x - 28.*a4.x*a2.x*a2.z + 70.*a4.x*a4.z - 28.*a2.x*a4.z*a2.z + a4.z*a4.z) * k3*k2);\n        a += p;\n    }\n    float t = dot(a,a);\n    return .25 * log(t) * sqrt(t) / d;\n    #endif\n    \n}\n\n//tetrahedral numerical normals from\n//https://iquilezles.org/articles/normalsSDF\nvec3 sdf_normal(vec3 p) {\n    const float h = 0.01;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for(int i=ZERO; i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdf(p+e*h);\n    }\n    return normalize(n);\n}\n\n//raymarching function\nbool intersect(int maxsteps, vec3 ro, vec3 rd, out float ot) {\n    float t = .01;\n    for(int i = 0; i < maxsteps; i++) {\n        float d = sdf(ro + rd*t);\n        t += d;\n        if(abs(d) < .001) {ot=t; return true;}\n        if(d > 10.) break;\n    }\n    return false;\n}\n\n//point of no return :DDD\n//the only thing missing in this function\n//are meatballs\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    col = vec4(0.);\n    for(int s = 0; s < NSAMPLES; s++) {\n        vec2 pos = ((_pos + quasirand(iFrame) - .5)*2. - res) / res.y;\n\n        #if FRACT==0\n        vec3 ro = vec3(0,0,-5);\n        #endif\n        #if FRACT==1\n        vec3 ro = vec3(0,0,-2);\n        #endif\n        vec3 rd = normalize(vec3(pos,1));\n\n        float importance = 1.;\n        vec3 add[MAX_BOUNCES];\n\n        int bounce = 0;\n        for(bounce = 0; bounce < MAX_BOUNCES; bounce++) {\n            uvec4 seed = uvec4(ivec2(_pos), iFrame, 0) + uint(bounce << 4);\n\n            float t;\n            if(!intersect(MAX_STEPS,ro,rd,t)) break;\n            ro += rd*t;\n\n            vec3 normal = sdf_normal(ro);\n\n            vec3 shadowray;\n            {\n                float c = pow(rand1u(seed+2u), .5/5.);\n                float s = sqrt(1.-c*c);\n                float phi = rand1u(seed+3u) * tau;\n                shadowray = ortho(vec3(0,1,0)) * vec3(c, s*sin(phi), s*cos(phi));\n            }\n\n            bool hit = intersect(MAX_SHADOWSTEPS, ro, shadowray, t);\n            add[bounce] = hit ? vec3(0.) : vec3(dot(normal, shadowray));\n\n            {\n                float c = sqrt(sqrt(rand1u(seed+0u)));\n                float s = sqrt(1.-c*c);\n                float phi = rand1u(seed+1u) * tau;\n                rd = ortho(normal) * vec3(c, s*sin(phi), s*cos(phi));\n                importance /= c;\n            }\n        }\n        \n        vec3 tmp = vec3(0,.5,.7);\n        tmp = rd.y>=0. ? mix(vec3(.3,.7,1), vec3(1), rd.y) : mix(vec3(0), vec3(.3,.7,1), rd.y+1.);\n        for(int i = bounce-1; i >= 0; i--) {\n            tmp *= .7;\n            tmp += add[i];\n        }\n        \n        col.rgb += tmp * importance;\n        col.w += importance;\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 col, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    col  = texelFetch(iChannel0, pos, 0);\n    col += texelFetch(iChannel1, pos, 0);\n    col *= REUSE_FACTOR;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltSzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 76, 76, 233]], "test": "untested"}
{"id": "WtdXR4", "name": "impossible ring", "author": "FabriceNeyret2", "description": "reference anim gif: [url]https://twistedsifter.files.wordpress.com/2020/01/super-bowl-shirk-35.gif[/url]", "tags": ["illusion", "ring", "fake3d", "gif", "reproduction"], "likes": 10, "viewed": 592, "published": 3, "date": "1580506643", "time_retrieved": "2024-07-30T21:26:47.870305", "image_code": "// Fork of https://www.shadertoy.com/view/3ttSz4\n\n#define T(V)  ( T = texture(iChannel0, V-vec2(acos(U.x/.9),0)), \\\n                T * T * smoothstep( w, -w, abs(V).y - .4 )   )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y, D;\n    vec4 T,S;\n    float y = .3* ( 1. - U.x*U.x/.8 ), w = 2./R.y;\n    O -= O;\n    if ( y > 0. )\n        D = vec2(iTime,sqrt(y)), \n        O = T(U-D),\n        T = T(U+D),\n        U.x < 0. ?  S=O,O=T,T=S : O ,\n        y = 1. - .7*abs(U.x),               // also nice without abs\n        O =  O / y + (1.-O.a) * T * y;\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 218, 218, 601]], "test": "untested"}
{"id": "3ttSz4", "name": "ring (fake3D)   (253 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["illusion", "ring", "fake3d", "2tweets", "gif", "golf"], "likes": 3, "viewed": 346, "published": 3, "date": "1580506264", "time_retrieved": "2024-07-30T21:26:48.740977", "image_code": "#define T(V)  ( T = texture(iChannel0, V - vec2(acos(x/.9), 0) ),  \\\n                T * T * smoothstep( w, -w, abs(V).y - .4 )   ) //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y, D;\n    vec4 T;\n    float x = U.x, y = .3 - x*x/2.7, w = 2./R.y;\n     y > 0. ? D = vec2( iTime , sqrt(y) ),\n              O = T(U-D),\n              O = O / .5 + (1.-O.a) * T(U+D) * .7\n            : O;\n} /*\n\n\n\n\n\n// --- 277 chars\n\n#define T(V)  ( T = texture(iChannel0, V - vec2(acos(U.x/.9), 0) ), \\\n                T * T * smoothstep( w, -w, abs(V).y - .4 )   )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y, D;\n    vec4 T;\n    float y = .3* ( 1. - U.x*U.x/.8 ), w = 2./R.y;\n    O -= O;\n    if ( y > 0. )\n        D = vec2( iTime , sqrt(y) ), \n        O = T(U-D),\n        O = O / .5 + (1.-O.a) * T(U+D) * .7;\n} /*\n\n/**/\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 171, 171, 436]], "test": "untested"}
{"id": "WldXR4", "name": "Hilbert Noise", "author": "TinyTexel", "description": "Slightly optimized version of paniq's hilbert curve based noise 3tB3z3 plugged into nimitz's signal inspector template llKyWc.\nNoise function in Buffer A.", "tags": ["noise", "blue", "hilbert", "dithering"], "likes": 15, "viewed": 719, "published": 3, "date": "1580506026", "time_retrieved": "2024-07-30T21:26:49.557793", "image_code": "// Slightly optimized version of paniq's blue noise ( https://www.shadertoy.com/view/3tB3z3 )\n// plugged into nimitz's signal inspector template ( https://www.shadertoy.com/view/llKyWc ).\n// Noise function in Buffer A.\n\n\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n    }\t\n    else\n#endif\n    {\n        float n = textureLod(iChannel0, q, 0.).r;\n        col = pow(vec3(n), vec3(1.0/2.2));\n        \n        #ifdef SHOW_1BITGRADIENT\n        if(q.y < 0.25)\n        col = vec3(n < q.x * 2.0 ? 0.0 : 1.0);\n        #endif\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n  #define SHOW_1BITGRADIENT\n  #define SHOW_FOURIER\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\nconst float globalScale = 1.;\n", "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n #define ANIMATE_NOISE\n\n#if 0\n// slightly optimized version of paniq's blue noise: https://www.shadertoy.com/view/3tB3z3\nfloat HilbertNoise(uvec2 uv)\n{\n    // Hilbert curve:\n    uint C = 0xB4361E9Cu;// cost lookup\n    uint P = 0xEC7A9107u;// pattern lookup\n\n    uint c = 0u;// accumulated cost\n    uint p = 0u;// current pattern\n\n    const uint N = 10u;// tile size = 2^N\n    for(uint i = N; --i < N;)\n    {\n        uvec2 m = (uv >> i) & 1u;// local uv\n\n        uint n = m.x ^ (m.y << 1u);// linearized local uv\n\n        uint o = (p << 3u) ^ (n << 1u);// offset into lookup tables\n\n        c += ((C >> o) & 3u) << (i << 1u);// accu cost (scaled by layer)\n\n        p = (P >> o) & 3u;// update pattern\n    }\n\n    // Noise (via fibonacci hashing):\n    #ifdef ANIMATE_NOISE\n    c += uint(iFrame);\n    #endif\n    \n    //  2^32-1        = 4294967295\n    // (2^32-1) / phi = 2654435769\n    return float(c * 2654435769u) * (1.0 / 4294967295.0);\n}\n#else\n// further optimized version that functions even with small tile sizes (N = 5, 4, 3)\n// related: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nfloat HilbertNoise(uvec2 uv)\n{\n    // Hilbert curve:\n    uint C = 0xB4361E9Cu;// cost lookup\n    uint P = 0xEC7A9107u;// pattern lookup\n    \n    #ifdef ANIMATE_NOISE\n\tuv += uint(iFrame) * uvec2(2447445397u, 3242174893u);\n    #endif\n    \n    uint c = 0u;// accumulated cost\n    uint p = 0u;// current pattern\n\n    const uint N = 4u;// tile size = 2^N\n    for(uint i = N; --i < N;)\n    {\n        uvec2 m = (uv >> i) & 1u;// local uv\n\n        uint n = m.x ^ (m.y << 1u);// linearized local uv\n\n        uint o = (p << 3u) ^ (n << 1u);// offset into lookup tables\n\n        c += ((C >> o) & 3u) << (i << 1u);// accu cost (scaled by layer)\n\n        p = (P >> o) & 3u;// update pattern\n    }\n\n    // add white noise at tile scale:\n    const uint r  = 2654435761u;// prime[(2^32-1) / phi_1  ]\n    const uint r0 = 3242174893u;// prime[(2^32-1) / phi_2  ]\n    const uint r1 = 2447445397u;// prime[(2^32-1) / phi_2^2]\n    \n    uv = uv >> N;    \n    uint h = ((uv.x * r0) ^ (uv.y * r1)) * r;\n    \n    c += h;\n\n    // fibonacci hashing (aka 1d Roberts):\n    //  2^32-1 = 4294967295\n    return float(c * r) * (1.0 / 4294967295.0);\n}\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    \n    uvec2 uv = uvec2(fragCoord);\n    \n    fragColor = vec4(vec3(HilbertNoise(uv)), 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WttSR4", "name": "Tunnel warping", "author": "Roninkoi", "description": "Playing around with mod", "tags": ["tunnel", "warping"], "likes": 4, "viewed": 293, "published": 3, "date": "1580503232", "time_retrieved": "2024-07-30T21:26:50.447415", "image_code": "#define PI 3.14159265\n\nfloat f(vec2 u)\n{\n    return mod(abs(u.y*sin(iTime*0.21) + \n                   u.x*u.y*sin(iTime*0.13+2.) + \n                   u.y*u.y*sin(iTime*0.14+3.) + \n                   u.x*u.x*sin(iTime*0.22+4.)), 0.3*length(u*u*u));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n    uv *= 2.5;\n        \n    vec3 ca = (iTime +uv.x+vec3(0,2.*PI/3.,4.*PI/3.));\n    ca.g = 0.;\n    \n    vec3 col = 0.525 + 0.625*cos(ca);\n    col /= exp(length(uv*uv));\n    col = col * 10.;\n    \n    float p = 2.0 / iResolution.x;\n    \n    float ssx = smoothstep(uv.x-p, uv.x+p, uv.x);\n    float ssy = smoothstep(uv.y-p, uv.y+p, uv.y);\n    \n    vec3 col1 = col * mix(vec3(f(vec2(uv.x-p, uv.y))), vec3(f(vec2(uv.x+p, uv.y))), ssx);\n    vec3 col2 = col * mix(vec3(f(vec2(uv.x, uv.y-p))), vec3(f(vec2(uv.x, uv.y+p))), ssy);\n    vec3 col3 = col * mix(vec3(f(vec2(uv.x-p, uv.y-p))), vec3(f(vec2(uv.x+p, uv.y+p))), sqrt(ssx*ssx + ssy*ssy));\n    vec3 col4 = col * mix(vec3(f(vec2(uv.x-p, uv.y+p))), vec3(f(vec2(uv.x+p, uv.y-p))), sqrt(ssx*ssx + (1.-ssy)*(1.-ssy)));\n    \n    col = (col1 + col2 + col3 + col4) * 0.25;\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttSR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 40, 40, 250], [252, 252, 309, 309, 1249]], "test": "untested"}
{"id": "Wt3XRN", "name": "Mirror Reflections", "author": "kstyler", "description": "Practicing reflections, learned from yx. Thanks Luna.", "tags": ["raymarching", "reflections", "mirror"], "likes": 7, "viewed": 520, "published": 3, "date": "1580502555", "time_retrieved": "2024-07-30T21:26:51.268220", "image_code": "int mat;\nfloat random(vec2 p){\n\treturn(fract(sin(p.x*431.+p.y*707.)*7443.));\n}\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p ){\n    \n    float ink = length((p))-1.;\n\n\n    float gold = (length((p+vec3(0)))-2.);\n   \n    float b1 = sdBox(p,vec3(2.));\n\n    p.xz*=rot(0.9);\n   \n    gold = max(-b1,sdBox(p,vec3(2.)));\n    float outer1 = sdBox(p,vec3(20));\n    p.yz*=rot(3.+iTime);\n\n    float outer=max(-outer1,sdBox(p,vec3(21)));\n    \n    float best = min(outer,min(ink,gold));\n    \n    if(best == gold){\n        mat=1;\n    }else if(best ==ink){\n        mat = 0;\n    }else{mat = 2;}\n    return best;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0,-0.2,-10);\n    vec3 rd = normalize(vec3(uv+random(uv)/iResolution.x,1));\n    ro.zy*=rot(-0.1);\n    rd.zy*=rot(-0.1);\n    ro.zx*=rot(iTime/5.);\n    rd.zx*=rot(iTime/5.);\n    float tot = 0.;\n    float dist = 0.;\n    vec3 p;\n    vec3 color = vec3(1);\n    \n    for(int i = 0; i<200;i++){\n        p = ro+rd*tot;\n        dist = map(p);\n        tot+=dist;\n        if(abs(dist)<0.0001){\n            vec2 e = vec2(0.001,0.);\n            vec3 n = normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                        map(p+e.yxy)-map(p-e.yxy),\n                        map(p+e.yyx)-map(p-e.yyx)));\n            if(mat == 0){\n                float fresnel = pow(1.-dot(- rd,n),5.);\n                color*=fresnel;  \n\n            } else if(mat == 1){\n                color*=vec3(1.0,0.5,0.1);\n               \n            }else if(mat == 2){\n                color*=vec3(0.5,0.4,0.5);\n               \n            }\n            ro = p+n*0.01;\n            rd = reflect(rd,n);\n            tot = 0.;\n\n        }\n    }\n                        \n   \n    color = pow(color,vec3(0.25));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3XRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 30, 30, 78], [79, 79, 97, 97, 163], [164, 164, 195, 195, 282], [284, 284, 303, 303, 771], [773, 773, 827, 827, 2003]], "test": "untested"}
{"id": "wtcSzN", "name": "DVD Bounce", "author": "tdhooper", "description": "Something for [url]https://cineshader.com/view/wtcSzN[/url]", "tags": ["waves", "logo", "bounce", "dvd", "cineshader"], "likes": 213, "viewed": 270175, "published": 3, "date": "1580500099", "time_retrieved": "2024-07-30T21:26:52.110967", "image_code": "\n#define PI 3.14159265359\n\n\n//#define DEBUG\n\n  \n    \nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float m = vmin(s);\n\treturn (length(p / s) * m) - m;\n}\n\nfloat halfEllip(vec2 p, vec2 s) {\n    p.x = max(0., p.x);\n    float m = vmin(s);\n\treturn (length(p / s) * m) - m;\n}\n\n\nfloat fBox(vec2 p, vec2 b) {\n\treturn vmax(abs(p) - b);\n}\n\nfloat dvd_d(vec2 p) {\n    float d = halfEllip(p, vec2(.8, .5));\n    d = max(d, -p.x - .5);\n    float d2 = halfEllip(p, vec2(.45, .3));\n    d2 = max(d2, min(-p.y + .2, -p.x - .15));\n    d = max(d, -d2);\n    return d;\n}\n\nfloat dvd_v(vec2 p) {\n    vec2 pp = p;\n    p.y += .7;\n    p.x = abs(p.x);\n    vec2 a = normalize(vec2(1,-.55));\n    float d = dot(p, a);\n    float d2 = d + .3;\n    p = pp;\n    d = min(d, -p.y + .3);\n    d2 = min(d2, -p.y + .5);\n    d = max(d, -d2);\n    d = max(d, abs(p.x + .3) - 1.1);\n\treturn d;\n}\n\n\nfloat dvd_c(vec2 p) {\n    p.y += .95;\n\tfloat d = ellip(p, vec2(1.8,.25));\n    float d2 = ellip(p, vec2(.45,.09));\n    d = max(d, -d2);\n    return d;\n}\n\nfloat dvd(vec2 p) {\n    p.y -= .345;\n    p.x -= .035;\n    p *= mat2(1,-.2,0,1);\n\tfloat d = dvd_v(p);\n    d = min(d, dvd_c(p));\n    p.x += 1.3;\n    d = min(d, dvd_d(p));\n    p.x -= 2.4;\n    d = min(d, dvd_d(p));\n    return d;\n}\n\n\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\nvoid drawHit(inout vec4 col, vec2 p, vec2 hitPos, float hitDist) {\n\n    float d = length(p - hitPos);\n    \n    #ifdef DEBUG\n    col = mix(col, vec4(0,1,1,0), step(d, .1)); return;\n    #endif\n    \n    float wavefront = d - hitDist * 1.5;\n    float freq = 2.;\n    \n    vec3 spec = (1. - spectrum(-wavefront * freq + hitDist * freq));\n    float ripple = sin((wavefront * freq) * PI*2. - PI/2.);\n    \n    float blend = smoothstep(3., 0., hitDist);\n    blend *= smoothstep(.2, -.5, wavefront);\n    blend *= rangec(-4., .0, wavefront);\n    \n    col.rgb *= mix(vec3(1), spec, pow(blend, 4.));\n    float height = (ripple * blend);\n    col.a -= height * 1.9 / freq;\n}\n\nvec2 ref(vec2 p, vec2 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal) + offset;\n\tp -= (2. * t) * planeNormal;\n    return p;\n}\n\nvoid drawReflectedHit(inout vec4 col, vec2 p, vec2 hitPos, float hitDist, vec2 screenSize) {\n    col.a += length(p) * .0001; // fix normal when flat\n\t//drawHit(col, p, hitPos, hitDist); return;\n    drawHit(col, p, ref(hitPos, vec2(0,1), 1.), hitDist);\n    drawHit(col, p, ref(hitPos, vec2(0,-1), 1.), hitDist);\n    drawHit(col, p, ref(hitPos, vec2(1,0), screenSize.x/screenSize.y), hitDist);\n    drawHit(col, p, ref(hitPos, vec2(-1,0), screenSize.x/screenSize.y), hitDist);\n}\n\n\n// Flip every second cell to create reflection\nvoid flip(inout vec2 pos) {\n    vec2 flip = mod(floor(pos), 2.);\n    pos = abs(flip - mod(pos, 1.));\n}\n\nfloat stepSign(float a) {\n    //return sign(a);\n\treturn step(0., a) * 2. - 1.;\n}\n\nvec2 compassDir(vec2 p) {\n    //return sign(p - sign(p) * vmin(abs(p))); // this caused problems on some GPUs\n    vec2 a = vec2(stepSign(p.x), 0);\n    vec2 b = vec2(0, stepSign(p.y));\n    float s = stepSign(p.x - p.y) * stepSign(-p.x - p.y);\n    return mix(a, b, s * .5 + .5);\n}\n\nvec2 calcHitPos(vec2 move, vec2 dir, vec2 size) {\n    vec2 hitPos = mod(move, 1.);\n    vec2 xCross = hitPos - hitPos.x / (size / size.x) * (dir / dir.x);\n    vec2 yCross = hitPos - hitPos.y / (size / size.y) * (dir / dir.y);\n   \thitPos = max(xCross, yCross);\n    hitPos += floor(move);\n    return hitPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    #ifdef DEBUG\n    \t//p.xy += vec2(1.2, .6);\n    \t//p *= 3.5;\n    \tp *= 2.;\n   \t#endif\n    \n    vec2 screenSize = vec2(iResolution.x/iResolution.y, 1.) * 2.;\n\n    float t = iTime;\n    vec2 dir = normalize(vec2(9.,16) * screenSize );\n    vec2 move = dir * t / 1.5;\n    float logoScale = .1;\n    vec2 logoSize = vec2(2.,.85) * logoScale * 1.;\n\n    vec2 size = screenSize - logoSize * 2.;\n    \n    // Remap so (0,0) is bottom left, and (1,1) is top right\n    move = move / size + .5;\n\n    // Calculate the point we last crossed a cell boundry\n    vec2 lastHitPos = calcHitPos(move, dir, size);\n    vec4 col = vec4(1,1,1,0);\n    vec4 colFx = vec4(1,1,1,0);\n    vec4 colFy = vec4(1,1,1,0);\n    vec2 e = vec2(.8,0)/iResolution.y;\n\n    #ifdef DEBUG\n\t\tcol.rgb = vec3(0.);\n    #endif\n    \n   \t#ifdef DEBUG\n\t\tconst int limit = 1;\n   \t#else\n    \tconst int limit = 5;\n    #endif\n\t\n    for (int i = 0; i < limit; i++) {\n        vec2 hitPos = lastHitPos;\n \n        if (i > 0) {\n            // Nudge it before the boundry to find the previous hit point\n            hitPos = calcHitPos(hitPos - .00001/size, dir, size);\n        }\n        \n        lastHitPos = hitPos;\n        \n    \t// How far are we from the hit point\n    \tfloat hitDist = distance(hitPos, move);\n        \n        // Flip every second cell to create reflection\n        flip(hitPos);\n\n\t\t// Remap back to screen space\n    \thitPos = (hitPos - .5) * size;\n\t\t\n        // Push the hits to the edges of the screen\n        hitPos += logoSize * compassDir(hitPos / size);\n    \n\t    drawReflectedHit(col, p, hitPos, hitDist, screenSize);\n \t   \tdrawReflectedHit(colFx, p + e, hitPos, hitDist, screenSize);\n    \tdrawReflectedHit(colFy, p + e.yx, hitPos, hitDist, screenSize);\n    }\n        \n    // Flip every second cell to create reflection\n    flip(move);\n\n    // Remap back to screen space\n    move = (move - .5) * size;\n    \n    // Calc normals\n\tfloat bf = .1; // Bump factor\n    float fx = (col.a - colFx.a) * 2.; // Nearby horizontal samples.\n    float fy = (col.a - colFy.a) * 2.; // Nearby vertical samples.\n    vec3 nor = normalize(vec3(fx, fy, e.x/bf)); // Bumped normal.\n    float ff = length(vec2(fx, fy));\n    float ee = rangec(0., 10./iResolution.y, ff);\n    nor = normalize(vec3(vec2(fx, fy)*ee, ff));\n\n    // invert colours\n    col.rgb = clamp(1. - col.rgb, vec3(0), vec3(1));\n    col.rgb /= 3.;\n    \n\n    #ifndef DEBUG\n\t\n    \t// lighting\n    \t// iq https://www.shadertoy.com/view/Xds3zN\n        vec3 lig = normalize(vec3(1,2,2.));\n        vec3 rd = normalize(vec3(p, -10.));\n        vec3  hal = normalize( lig - rd );\n\n        float dif = clamp(dot(lig, nor), 0., 1.);\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                        dif *\n                        (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.);\n        lin += 5. * dif;\n        lin += .2;\n        col.rgb = col.rgb * lin;\n        col.rgb += 5. * spe;\n\t#endif\n    \n    #ifdef DEBUG\n        float b = vmin(abs(fract(p / screenSize) - .5) * 2.);\n        b /= fwidth(b) * 2.;\n        b = clamp(b, 0., 1.);\n        b = 1. - b;\n        col.rgb = mix(col.rgb, vec3(0), b);\n    #endif\n    \n    // dvd logo\n\tfloat d = dvd((p - move) / logoScale);\n    d /= fwidth(d);\n    d = 1. - clamp(d, 0., 1.);\n    col.rgb = mix(col.rgb, vec3(1), d);\n    \n    // banding be gone\n    col += (texture(iChannel0, fragCoord / iChannelResolution[0].xy) * 2. - 1.) * .005;\n\n    // gamma\n    col.rgb = pow(col.rgb, vec3(1./1.5));\n\n    col.a = col.a * .5 + .5;\n\tcol.a *= .3;\n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"DVD\",\n\t\"description\": \"\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcSzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 73, 73, 98], [100, 100, 120, 120, 145], [147, 147, 176, 176, 234], [236, 236, 269, 269, 351], [354, 354, 382, 382, 410], [412, 412, 433, 433, 629], [631, 631, 652, 652, 929], [932, 932, 953, 953, 1082], [1084, 1084, 1103, 1103, 1310], [1314, 1314, 1364, 1364, 1407], [1409, 1409, 1450, 1450, 1494], [1496, 1537, 1605, 1605, 1648], [1649, 1649, 1673, 1673, 1771], [1774, 1774, 1840, 1840, 2432], [2434, 2434, 2484, 2484, 2571], [2573, 2573, 2665, 2665, 3048], [3051, 3098, 3125, 3125, 3200], [3202, 3202, 3227, 3249, 3282], [3284, 3284, 3309, 3393, 3562], [3564, 3564, 3613, 3613, 3870], [3872, 3872, 3929, 3929, 7551]], "test": "untested"}
{"id": "wtcXz4", "name": "Real time path tracing", "author": "loicvdb", "description": "Testing reprojection for real time denoising, kinda blurry unfortunately. Looks better in fullscreen", "tags": ["raymarching", "fractal", "gi", "globalillumination", "pathtracing", "depthoffield", "ao", "reprojection"], "likes": 75, "viewed": 1710, "published": 3, "date": "1580496061", "time_retrieved": "2024-07-30T21:26:53.259895", "image_code": "//second DoF pass\n\n#define dir normalize(vec2(1.0, -1.0))\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        p = texture(iChannel0, (fragCoord + d*iResolution.y*cam.aperture)/iResolution.xy);\n        dr = min(abs(p.a-cam.focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*cam.aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = vec4(ACESFilm(col.rgb), 1.);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//increase this number for a better GI\n#define IndirectSamples 1\n\n//increase to remove more noise, but might make the result blurrier\n#define SamplesLimit 40\n\n//GI bounces\n#define Bounces 1\n\n\n#define PixelAcceptance 1.5\n#define PixelCheckDistance .5\n\n\n\n#define Pi 3.14159265359\n\n#define MaxStepsDirect 128\n#define MaxStepsIndirect 32\n#define MaxShadowSteps 32\n#define MaxDist 4.\n#define MinDist .015\n\n#define DoFClamping .3\n#define DoFSamples 32\n\nstruct Camera {\n    vec3 pos, rot;\n    float focalLength, focalDistance, aperture;\n};\n\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nCamera getCam(float time){\n    vec3 rot = vec3(0., (sin(time*.75)+time*.75)/4., .3);\n    return Camera(vec3(0., 0., -20.) * rotationMatrix(rot), rot, 2., 17.5, .04);\n}\n\nvec3 uv2dir(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\nvec2 pos2uv(Camera cam, vec3 pos){\n    vec3 dir = normalize(pos - cam.pos) * inverse(rotationMatrix(cam.rot));\n    return dir.xy * cam.focalLength / dir.z;\n}\n\nvec3 dirFromUv(Camera cam, vec2 uv){\n    return normalize(vec3(uv, cam.focalLength)) * rotationMatrix(cam.rot);\n}\n\n    \n\nfloat sdf(vec3 position){\n    float Scale = 2.25;\n    float Radius = .25;\n    int Iterations = 6;\n    mat3 Rotation;\n    \n    //float time = 75.;\n    float time = 104.;\n    //float time = 120.;\n    \n    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);\n    Scale += sin(time*.5)*.25;\n    Radius += cos(time) *.25;\n    \n    position *= Rotation;\n\tvec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;\n\tfloat C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1-Iterations));\n\tvec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);\n\tfor (int i=0; i< Iterations; i++) {\n    \tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n    \tp.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);\n        if(i < 3) p.xyz *= Rotation;\n    \tp.xyzw = p*scalevec + p0;\n\t}\n\treturn (length(p.xyz) - C1) / p.w - C2;\n}\n\nvec3 normalEstimation(vec3 pos){\n  vec2 k = vec2(MinDist, 0);\n  return normalize(vec3(sdf(pos + k.xyy) - sdf(pos - k.xyy),\n\t  \t\t\t\t\tsdf(pos + k.yxy) - sdf(pos - k.yxy),\n  \t\t\t\t\t\tsdf(pos + k.yyx) - sdf(pos - k.yyx)));\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "bool trace(inout vec3 pos, in vec3 dir, out vec3 normal){\n    pos += dir*sdf(pos);\n    pos += dir*sdf(pos);\n    for(int i = 0; i < MaxStepsDirect; i++){\n        float dist = sdf(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            normal = normalEstimation(pos);\n            pos -= (2.*MinDist-dist) * dir;\n            return true;\n        }\n        pos += dir*dist;\n    }\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    Camera cam = getCam(iTime);\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    vec3 dir = uv2dir(cam, uv);\n    fragColor = vec4(0.);\n    vec3 pos = cam.pos, normal;\n    if(trace(pos, dir, normal)) fragColor = vec4(pos, 1.);\n}", "buffer_b_inputs": [], "buffer_c_code": "float seed;\n\nvec3 LightDir = vec3(.0, -1, .0);\nvec3 LightColor = vec3(.7, .5, .3) * 13.;\nfloat LightRadius = .05;\n\nfloat randomFloat(){\n    return fract(sin(seed++)*43758.54536156);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(randomFloat(), randomFloat());\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\nvec3 directLight(vec3 pos, vec3 normal){\n    float dotLight = -dot(normal, LightDir);\n    if(dotLight < 0.0) return vec3(0);\n    vec3 pos0 = pos;\n    float minAngle = LightRadius;\n    for(int i = 0; i < MaxShadowSteps; i++){\n        float dist = sdf(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist) return vec3(0.0);\n        pos -= LightDir * dist * 3.0;\t//goes 3 times faster since we don't need details\n        minAngle = min(asin(dist/length(pos-pos0)), minAngle);\n    }\n    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);\n}\n\n\nvec3 background(vec3 dir){\n    vec3 col = texture(iChannel3, dir).rgb;\n    return col*col + col;\n}\n\n\n\nbool trace(inout vec3 pos, in vec3 dir, out vec3 normal){\n    for(int i = 0; i < MaxStepsIndirect; i++){\n        float dist = sdf(pos);\n        if(dist > MaxDist) break;\n        if(dist < MinDist){\n            normal = normalEstimation(pos);\n            pos -= (2.*MinDist-dist) * dir;\n            return true;\n        }\n        pos += dir*dist;\n    }\n    return false;\n}\n\nvec3 sampleIndirectLight(vec3 pos, vec3 normal){\n    vec3 dir = getCosineWeightedSample(normal);\n    vec3 light = vec3(0.);\n    for(int i = 0; i < Bounces; i++){\n        if(!trace(pos, dir, normal)) return light+background(dir);\n        else light += directLight(pos, normal);\n    }\n    return light;\n}\n\nfloat distancePixel(vec2 prevFragCoord, vec4 hit){\n    if(  min(iResolution.xy, prevFragCoord) != prevFragCoord\n      && max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MaxDist;\n    vec4 prevPos = texture(iChannel2, prevFragCoord/iResolution.xy);\n    Camera cam = getCam(iTime);\n    return length(prevPos-hit);\n}\n\nvec4 previousSample(vec4 hit){\n    vec2 prevUv = pos2uv(getCam(iTime-iTimeDelta), hit.xyz);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    \n    vec2 pfc, finalpfc;\n    float dist, finaldist = MaxDist;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            dist = distancePixel(pfc, hit);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n    \t}\n    }\n    \n    Camera cam = getCam(iTime);\n    if(finaldist < PixelAcceptance*length(hit.xyz-cam.pos)/cam.focalLength/iResolution.y)\n        return texture(iChannel0, finalpfc/iResolution.xy);\n    return vec4(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    seed = .256435865*fragCoord.x+.316548465*fragCoord.y+sin(iTime)*16886.3158915;\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 hit = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(hit.a == 0.){\n        vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n        fragColor = vec4(background(uv2dir(cam, uv)), 1.);\n    } else {\n        \n        #if 0\n        fragColor = previousSample(hit);\n        fragColor.rgb = fragColor.a == 0. ? vec3(1., 0., 0.) : vec3(0., 1., 0.);\n        fragColor.a = 1.;\n        #else\n        vec3 normal = normalEstimation(hit.xyz);\n        \n        vec3 dLight = directLight(hit.xyz, normal);\n        vec3 iLight = vec3(0.);\n        for(int i = 0; i < IndirectSamples; i++)\n            iLight += sampleIndirectLight(hit.xyz, normal)/float(IndirectSamples);\n        \n        fragColor = previousSample(hit);\n        if(fragColor.a < 1.) iLight = clamp(iLight, vec3(.1), vec3(.4)); // clamp gi for low sample count\n        fragColor.a += fragColor.a > float(SamplesLimit) ? 0. : float(IndirectSamples);\n        fragColor.rgb = mix(fragColor.rgb, iLight + dLight, 1.0/(fragColor.a/float(IndirectSamples)));\n        #endif\n    }\n}", "buffer_c_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//first DoF pass\n\n#define dir normalize(vec2(1.0, 1.0))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    Camera cam = getCam(iTime);\n    \n    vec4 col = vec4(0);\n    float samples = 0.0, dr, influence, depth;\n    vec2 d, de;\n    vec4 p;\n    for(int i = 0; i < DoFSamples; i++){\n        d = dir * float(2*i-DoFSamples)/float(DoFSamples) * DoFClamping;\n        vec2 de = (fragCoord + d*iResolution.y*cam.aperture)/iResolution.xy;\n        p.rgb = texture(iChannel0, de).rgb;\n        p.a = length(texture(iChannel1, de).rgb - cam.pos);\n        dr = min(abs(p.a-cam.focalDistance)/p.a, DoFClamping);\n        influence = clamp((dr - length(d))*iResolution.y*cam.aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p;\n        samples += influence;\n    }\n    \n    col /= samples;\n    \n    fragColor = col;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcXz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 82, 82, 222], [225, 225, 281, 281, 931]], "test": "untested"}
{"id": "tlcSRN", "name": "ceva lejer", "author": "alinres", "description": "dsadas", "tags": ["cineshader"], "likes": 3, "viewed": 22165, "published": 3, "date": "1580495516", "time_retrieved": "2024-07-30T21:26:54.077708", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * 25.0 - iTime * 3.0;\n    \n    // Calculate the ripple thickness\n    d = (cos(t) * 0.5 + 0.5) * (1.0 - d);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\n    // Set the output color to rgb channels and the thickness to alpha channel\n    // AO is automatically calculated\n    fragColor = vec4(col, d);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"RD Design\",\n\t\"description\": \"We design for future\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 655]], "test": "untested"}
{"id": "Wt3XR8", "name": "Apollonian Zoom", "author": "mla", "description": "Zooming in to an Apollonian Gasket. Mouse moves centre of image.\n\na: disable mouse\nv: vary circle radius\nz: disable zoom\n", "tags": ["2d", "zoom", "apollonian"], "likes": 13, "viewed": 421, "published": 3, "date": "1580487748", "time_retrieved": "2024-07-30T21:26:54.824711", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Apollonian circles. Iterated inversion in a ring of circles.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float N = 5.0; // Number of circles\nconst int max_iterations = 40;\nconst float pi = 3.14159265;\n\n// Circles are represented as vec3(x,y,r2) where\n// (x,y) is the centre and r2 is the squared radius.\n\n// Invert pos in circle c\nvec2 invert(vec2 pos, vec3 c) {\n  vec2 p = pos-c.xy;\n  float p2 = dot(p,p);\n  return p*c.z/p2 + c.xy;\n}\n  \n// Invert pos in circle if it is inside \nbool checkinverse(inout vec2 pos, vec3 c, inout float r2min) {\n  vec2 p = pos-c.xy; \n  float p2 = dot(p,p);\n  r2min = min(r2min,abs(p2-c.z));\n  if (p2 > c.z) {\n    return false;\n  } else {\n    pos = p*c.z/p2 + c.xy;\n    return true;\n  }\n}\n\nbool checkinverse2(inout vec2 pos, vec3 c, inout float r2min) {\n  vec2 p = pos-c.xy; \n  float p2 = dot(p,p);\n  r2min = min(r2min,abs(p2-c.z));\n  if (p2 < c.z) {\n    return false;\n  } else {\n    pos = p*c.z/p2 + c.xy;\n    return true;\n  }\n}\n\n// N circles in a ring, with tangency points on unit circle,\n// plus a central circle, tangent to the others, plus an\n// surrounding circle, tangent to the ring circles.\n// The radius of the ring circles can vary so as to overlap\n// or to leave a gap.\nvec4 gasket(vec2 pos, bool varyradius){\n  float theta = pi/N;\n  float r = 1.0/cos(theta);\n  float s = tan(theta);\n  float r2min = 1e10;\n  float t = -0.2*iTime;\n  float rfactor = !varyradius?1.0:0.95 + 0.26*(1.0+cos(0.5*iTime));\n  for(int n = 0; n < max_iterations; n++){\n    vec3 c = vec3(0,0,pow(r-s,2.0));\n    // Try inverting in central circle\n    if (!checkinverse(pos,c,r2min) &&\n        !checkinverse2(pos,vec3(0.0,0.0,pow(r+s,2.0)),r2min)) {\n      bool found = false;\n      // else try in the circles of the ring.\n      for (float i = 0.0; i < N; i++) {\n        vec3 c = vec3(r*sin(2.0*i*theta+t),\n                      r*cos(2.0*i*theta+t),\n                      rfactor*s*s);\n        if (checkinverse(pos,c,r2min)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) return vec4(pos,n,r2min);\n    }\n  }\n  return vec4(pos,max_iterations,r2min);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getCol(vec4 n){\n  vec3 col = hsv2rgb(vec3(mod(n.z/20.0,1.0),0.8,0.8));\n  col *= 0.6+0.4*smoothstep(0.05,0.1,sqrt(n.w));\n  return col;\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_D = 68;\nconst int CHAR_H = 72;\nconst int CHAR_J = 74;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90;\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  return z/dot(z,z)*vec2(1,-1);\n}\n\nvec2 csqrt(vec2 z) {\n  float r = length(z);\n  return vec2(sqrt(0.5*(r+z.x)),sign(z.y)*sqrt(0.5*(r-z.x)));\n}\n\n#define AA 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  fragColor.xyz = vec3(0);\n  vec2 z0 = 2.0 * fragCoord.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n  float zoom = 1.0; \n  if (!keypress(CHAR_Z)) zoom = exp(45.0-mod(0.4*iTime,60.0));\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      float delta = 1.0/(AA*iResolution.y);\n      vec2 z = z0 + delta*vec2(i,j);\n      z *= zoom;\n      if (keypress(CHAR_H)) {\n        z.y += 1.0;\n        z = invert(z,vec3(0,-1,2)); // Map half plane to unit disk.\n      }\n      if (keypress(CHAR_D)) {\n        z = invert(z,vec3(0,0,1)); // Invert in unit disk\n      }\n      if (!keypress(CHAR_A) && iMouse.x != 0.0) {\n        vec2 m = 2.0 * iMouse.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n        //m = 1.2*vec2(cos(0.0789*iTime),sin(0.0789*iTime));\n        m *= zoom;\n        // Map origin to m with an inversion\n        vec2 c = m/dot(m,m); // m inverted in unit circle\n        z = invert(z,vec3(c,dot(c,c)-1.0));\n      }\n      bool varyradius = !keypress(CHAR_V);\n      vec4 data = gasket(z,varyradius);\n             \n      fragColor.xyz += getCol(data);\n    }\n  }\n  fragColor.xyz /= AA*AA;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3XR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 465, 496, 496, 568], [572, 613, 675, 675, 851], [853, 853, 916, 916, 1092], [1094, 1346, 1385, 1385, 2227], [2229, 2324, 2351, 2351, 2527], [2529, 2529, 2549, 2549, 2669], [2671, 2671, 2696, 2696, 2756], [2897, 2897, 2924, 2924, 2979], [2981, 2981, 3000, 3000, 3034], [3036, 3036, 3056, 3056, 3143], [3161, 3161, 3217, 3217, 4365]], "test": "untested"}
{"id": "3ty3Wt", "name": "[♪]Caged Star", "author": "Catzpaw", "description": "inside of mandelbox", "tags": ["raymarching", "music", "mandelbox"], "likes": 16, "viewed": 867, "published": 3, "date": "1580481533", "time_retrieved": "2024-07-30T21:26:55.758215", "image_code": "//---Caged Star\n// by Catzpaw 2020\n\n//Image:post effect\n\n#define ITER   20.\n#define RADIUS 0.05\n\nvec4 tx(vec2 uv){return texture(iChannel0,uv);}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    vec2 m=vec2(1,iResolution.x/iResolution.y);\n    vec4 c=tx(uv);\n    float a=sin(iTime*.1)*6.283,v=0.,b=1./ITER;\n    for(int j=ZERO;j<6;j++){\n        float r=RADIUS/ITER;\n        vec2 d=(vec2(0,1)*rot(a))*m;\n        for(int i=ZERO;i<int(ITER);i++){\n            v+=tx(uv+d*r*RADIUS).w*(1.-r);\n            r+=b;\n        }\n        a+=1.047;\n    }\n    v*=6e-3;\n    c+=v;\n    c.w=1.;\n\tfragColor=c;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//---Caged Star\n// by Catzpaw 2020\n\n//BufferA:scene\n\n#define ITER 120\n#define NEAR .01\n#define FAR 13.\n#define EPS 1e-5\n\n//OBJECTS\nfloat cube(vec3 p){\n    p=abs(p)-.1;\n    return length(max(p,0.)+min(max(p.x,max(p.y,p.z)),0.));\n}\nfloat mandelbox(vec3 p){\n    float s=2.,r=.7;\n\tvec3 o=p;\n\tfor(int i=ZERO;i<8;i++){\n\t\tp=clamp(p,-1.008,1.008)*2.03-p; //boxfold\n        float l=cube(p);\n        if(l<.5){p*=2.1;r*=2.1;}else if(l<3.8){p/=l;r/=l;} //ballfold\n        p=o+p*s;r=r*abs(s)+1.;\n\t}\n\treturn .25-length(p)/abs(r);\n}\n\n//SCENE\nfloat map(vec3 p){\n    return min(mandelbox(p),length(p)-1.2);\n}\n// \"Log-Bisection Tracing\" by Nimitz\n// https://www.shadertoy.com/view/4sSXzD\nfloat trace(vec3 ro,vec3 rd){\n    float t=NEAR,lt=t;\n    vec3 p=ro+rd*t;\n    float d=map(p);\n    bool s=d>0.?true:false;\n    bool b=false;\n    for(int i=ZERO;i<ITER;i++){\n        if(abs(d)<EPS*t||t>FAR)break;            \n       \tif((d>0.)!=s){b=true;break;}\n        lt=t;\n        t+=d>1.?d*.5:log(abs(d)+1.);\n        p=ro+rd*t;\n       \td=map(p);\n    }\n    if(b){\n        float m=0.;\n        p=ro+lt*rd;\n        s=map(p)>0.?true:false;;\n        for(int i=ZERO;i<6;i++){ \n            m=(lt+t)*.5;\n            p=ro+rd*m;\n            d=map(p);\n            if(abs(d)<EPS*t)break;\n            (d<0.)==s?t=m:lt=m;\n        }\n        t=(lt+t)*.5;\n    }\n    return t;\n}\n\n//MATERIALS & SHADING\nvec3 normal(vec3 p){\n    const vec2 d=vec2(1,-1);\n    const float e=5e-3;\n    return normalize(\n        d.xyy*mandelbox(p+d.xyy*e)+\n        d.yxy*mandelbox(p+d.yxy*e)+\n        d.yyx*mandelbox(p+d.yyx*e)+\n        d.xxx*mandelbox(p+d.xxx*e));\n}\nvec3 light(vec3 ld,vec3 rd,vec3 v,vec3 c,vec3 no){\n    float ph=pow(max(dot(reflect(ld,no),-rd),0.),4.);\n    return v*(c*pow(.5+dot(no,-ld)*.5,2.)+ph)+pow(ph,10.);\n}\nfloat reflection(vec3 ro,vec3 no,vec3 rd){\n    vec3 rr=normalize(reflect(rd,no));\n    float t=.92,n=1.;\n    for(int i=ZERO;i<10;i++){float d=mandelbox(ro+rr*t);if(d<1e-3)break;t+=d;n+=1.;}\n    return pow(.22-dot(normal(ro+rr*t),no)*(n*.078),4.);\n}\nfloat shadow(vec3 ro){\n    vec3 rr=normalize(-ro);\n    float t=2.2;\n    for(int i=ZERO;i<10;i++){float d=mandelbox(ro+rr*t);if(d<1e-2)return .3;t+=d*2.5;}\n    return 2.5;\n}\nfloat ao(vec3 p,vec3 no){\n\tfloat o=1.,s=1.;\n    for(float i=1.;i<3.;i++){float r=.3*i;o+=(mandelbox(no*r+p)-r)*s;s*=.9;}\n    return clamp(o,.2,1.);\n}\nvec4 material(in vec3 p,in vec3 rd){\n    const vec3 ld=vec3(.577);\n    float l=floor(length(p)*.411);\n    vec3 c=l<1.?vec3(.85):vec3(sin(l)*.6,sin(l*.6)*.6,sin(l*4.4));\n\tvec3 no=normal(p);\n    vec3 l1=light(ld,rd, vec3(.9,.95,1.),c,no);\n    vec3 l2=light(-ld,rd,vec3(.7,.65,.6),c,no);\n    vec3 l3=l<1.?c:light(normalize(p),rd,vec3(.6),c,no);\n    vec3 l4=(l==1.)?vec3(reflection(p,no,rd)):vec3(0);\n         l4=(l==3.)?vec3(reflection(p,no+sin(p*15.+iTime*10.)*sin(p*7.+iTime*8.),rd)):l4;\n    float s=l>1.?shadow(p):4.;\n    c=clamp(ao(p,no)*(l1+l2+l3*s+l4*s*.2)*.4,-1.,2.8); ////\n    return vec4(c,pow(length(c+.1),2.+hash(p+iTime)*2.5));\n}\n\n//MAIN\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=(fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 ro=vec3(0,0,-3.8+clamp(sin(3.14+iTime*.1)*30.,-1.,1.));\n    ro.xz*=rot(iTime*.2);\n    ro.xy*=rot(iTime*.35);\n\tvec3 rd=vec3(uv.x,uv.y,.6);\n    rd.xz*=rot(iTime*.2);\n    rd.xy*=rot(iTime*.43);\n    rd=normalize(rd);\n\tfragColor=material(ro+trace(ro,rd)*rd,rd);\n}\n", "buffer_a_inputs": [], "sound_code": "//---Scale Sequencer 2\n// by Catzpaw 2020\n// https://www.shadertoy.com/view/3tVGz3\n\n//SETUP\nconst float base =432.;\t//A tuning (Hz)\nconst float bpm  =98.;\t//beats per minute\nconst float steps=240.;\t//block length\nconst float start=1.;   //start count (beats)\nconst float fade =10.;  //fade out time (sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\nconst float gateseed=441.;\nconst float noteseed=849.;\nconst int chord3=4; //3rd tone(default:2)\nconst int chord5=7; //5th tone(default:4)\n\n//SCALE\nint key=2; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\nint scale=0;\nconst uint[12] scl=uint[](\n    0xcb975420u, //0:major\n    0xca875320u, //1:natural minor\n    0xcb875320u, //2:harmonic minor\n    0xcb975320u, //3:melodic minor\n    0xa9765320u, //4:blues octatonic\n    0xa9764310u, //5:blues diminished octatonic\n    0xc9974420u, //6:major pentatonic (to heptatonic)\n    0xca775530u, //7:minor pentatonic (to heptatonic)\n    0xcb775540u, //8:ryukyu pentatonic (to heptatonic)\n    0xcb755420u, //9:ryukyu hexatonic (to heptatonic)\n    0xba875410u, //10:maqam hijaz octatonic\n    0xba876320u);//11:gypsy minor octatonic\nint scalenote(int y){\n    return y<0?-999:key+((int(scl[scale])>>(y&7)*4)&15);\n}\n\n//PATTERN\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\nconst uint[36] pat=uint[](\n    0x37000000u,0x37011171u,0x47012172u,0x37011773u,  //00-   melody\n    0x37054394u,0x37054c95u,0x44226166u,0x34617167u,\n    0x34028168u,0x34019119u,0x4401a11au,0x3440417cu,  //  -0B\n    0x44001434u,0x44001491u,0x44001022u,0x44001022u,  //0C-0F backing\n    0x1162a000u,0x2162a803u,0x4162a802u,0x4162a801u,  //10-13 chord\n    0x12118151u,0x1761a890u,0x17143327u,0x17957631u,  //14-17 bass\n    0x3a3a3a3au,0x393a393au,0x39393939u,0x99999999u,  //18-1B sd+hh\n    0x00000000u,0xb9b979b9u,0xb9b979b9u,0x55555555u,  //1C-1F bd+conga\n    0x10000100u,0x10000100u,0x10000100u,0x10000100u); //20-23 chord\n\n//SEQUENCE\n// speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n// speed    0:0.5x 1:1x 2:2x 3:4x\n// degree   0:mute 1:I  2:II 3:III 4:IV 5:V 6:VI 7:VII\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2)\nconst uint[8] seq1=uint[]( //snare+hihat\n    0x11000119u,0x11000119u,0x11000119u,0x1119711bu,\n    0x11000119u,0x11000119u,0x11000119u,0x1119711au);\nconst uint[8] seq2=uint[]( //bassdrum+conga\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111ee11fu);\nconst uint[4] seq3=uint[]( //bass\n    0x11000414u,0x11000214u,0x11000714u,0x11000114u);\nconst uint[4] seq4=uint[]( //arpeggio\n    0x11000410u,0x11000410u,0x11000310u,0x11000110u);\nconst uint[4] seq5=uint[]( //backing\n    0x1100010cu,0x1100010cu,0x1100040cu,0x150d810eu);\nconst uint[24] seq6=uint[]( //melody\n    0x10000000u,0x10000000u,0x10000000u,0x10000000u,\n    0x11000101u,0x11000102u,0x11000703u,0x11000104u,\n    0x11000101u,0x11000102u,0x11000703u,0x11000105u,\n    0x11000106u,0x11000107u,0x11000708u,0x11000109u,\n    0x11000106u,0x11000107u,0x1100070au,0x1100010bu,\n    0x11000702u,0x11000501u,0x11000203u,0x1104c000u);\nconst uint[4] seq7=uint[]( //chord\n    0x11000520u,0x11000520u,0x11000420u,0x11000220u);\n\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint imod(uint x,uint y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\n//float osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float[16] nt=float[](2.,4.,8.,16.,32.,48.,64.,80.,101.,127.,190.,254.,381.,508.,1017.,2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*1789772.5/nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\n/*\nconst uint[24] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*24.,24.))]>>(i*4))&15u)/15.-.5);}\n*/\n\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x),vec2(1./p.y)),-1.,1.)*p.z;}\n\n//FOLDBACK DISTORTION\nfloat fbdist(float v){return abs(v)>1.?sign(v)*2.-v:v;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nfloat freq(float n){return pow(2.,(n-69.)/12.)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//FM INSTRUMENTS (freq,time)\nfloat fmbass(float f,float x){f*=6.283;return fbdist(sin(f*2.03)*.5+sin(f*2.+sin(f+sin(f*7.51)*env_d(x,.07))*env_d(x,.2)))*env_d(x,.5);}\nfloat fmharpsi(float f,float x){f*=6.283;return (sin(f+sin(f*5.+sin(f*9.))))*env_d(x,.7);}\nfloat fmvibe(float f,float x){f*=6.283;return (sin(f+sin(f*9.)))*env_d(x,.9);}\nfloat fmep(float f,float x){f*=6.283;return (sin(f+sin(f*15.)*env_d(x,.5)*.6))*env_d(x,.7);}\nfloat fmmarimba(float f,float x){f*=6.283;return (sin(f+sin(f*3.99+sin(f*5.3)*env_d(x,.08))*env_d(x,.3)))*env_d(x,.4);}\nfloat fmguitar(float f,float x){f*=6.283;return fbdist(sin(f+sin(f*3.01+sin(f*3.49)*env_d(x,.4))*env_d(x,.7)*.6)*1.3*env_d(x,.9));}\nfloat fmpad(float f,float x){f*=6.283;return sin(f+sin(f*1.01))*(.9+sin(x*60.)*.1);}\n\n//PERCUSSION INSTRUMENTS (time)\nfloat bd(float x){return sin(x*freq(82./(1.+x*.7)))*env_d(x,.5);}\nfloat sd(float x){return (osc_nesnoise(x,10)*.8*env_d(x,.2)+sin(x*freq(83./(1.+x*.05)))*env_d(x,.4));}\n//float hh(float x,float d){return osc_nesnoise(x,3)*env_d(x,d);}\n\n/*\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(1.+detune),.5),osc_duty(f*(1.-detune),.5))*env_d(x,.2);}\nvec2 tri4bass(float f,float x){return vec2(osc_tri4(f*(.5+detune)),osc_tri4(f*(.5-detune)));}\nvec2 tri4lead(float f,float x){return vec2(osc_tri4(f*(1.-detune)),osc_tri4(f*(1.+detune)));}\nvec2 c30bass(float f,float x){return vec2(osc_c30(f*(1.+detune),5),osc_c30(f*(1.-detune),5))*env_d(x,.5);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\nvec2 c30lead(float f,float x){return vec2(osc_c30(f*(1.-detune),4),osc_c30(f*(1.+detune),4))*env_d(x,.5);}\n*/\n\n//CHIPTUNE PERCUSSION (time)\n//float nessd(float x){return osc_nesnoise(x,11)*env_d(x,.2);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\n//float nesbd(float x){return osc_duty(2./(x*.5+.1),.5)*env_d(x,.1);}\nfloat neslc(float x){return osc_duty(4./(x*.5+.1),.5)*env_d(x,.05);}\nfloat neshc(float x){return osc_duty(5./(x*.5+.1),.5)*env_d(x,.05);}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   dg=0;  //degree now playing\nuint  pt=0u;  //pattern now playing\nint   st=0;  //step now playing\nbool getpattern(float t,uint sq){\n    // speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n    mp=pow(2.,float(get4(sq,7)-1))*16.;\n    st=int(mod(t*bpm*mp/steps,16.));\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,3);\n    dg=di?get4(sq,6):get4(sq,2);\n    pt=di?pat[get8(sq,4)]:pat[get8(sq,0)];\n    return dg==0?false:true;\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateseed)*50.)<(float(get4(pt,6))*.0625)?-1:\n    imod(int(abs(sin(float(s+s1+s*s2)*noteseed)*float(s2))),get4(pt,7));\n}\nvec4 getnote(float t,float l){\n    // melodic:range(4),rest(4),seed1(12),seed2(12)\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n<0)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<0?0:dg-1;\n    return (dg<1)||(n<0)?vec4(x,-1,-1,-1):vec4(x,scalenote(n),scalenote(n+chord3),scalenote(n+chord5));\n}\nvec4 getgate(float t,float l){\n    // percussive:note(2x16)\n    int n=get2(pt,st);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return dg<1?vec4(x,-1,-1,-1):vec4(x,n,n,n);\n}\n\n//RENDERER\nvec2 track1(float t,float l,int s){//TRACK 1 snaredrum,closehh,openhh\n    vec2 o=vec2(0);\n    getpattern(t,seq1[imod(s,8)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?sd(n.x)*.8:0.;\n    o+=(n.y==2.)?neshh(n.x,.08)*.4:0.;\n    o+=(n.y==3.)?neshh(n.x,.2)*.5:0.;\n    return s>1?o:vec2(0);\n}\nvec2 track2(float t,float l,int s){//TRACK 2 bassdrum,lowconga,highconga\n    vec2 o=vec2(0);\n    getpattern(t,seq2[imod(s,8)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?bd(n.x)*.8:0.;\n    o+=(n.y==2.)?neslc(n.x)*.3:0.;\n    o+=(n.y==3.)?neshc(n.x)*.3:0.;\n    return o;\n}\nfloat range(float n,float l){return n<=l?n:n-12.;}\nvec2 track3(float t,float l,int s){//TRACK 3 bass\n    vec2 o=vec2(0);\n    getpattern(t,seq3[imod(s,4)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?vec2(.8)*fmbass(freq(range(n.y+24.,36.))*n.x,n.x):vec2(0);\n    return s>2?o*.8:vec2(0);\n}\nvec2 track4(float t,float l,int s){//TRACK 4 arpeggio\n    vec2 o=vec2(0);\n    getpattern(t,seq4[imod(s,4)]);\n    vec4 n=getnote(t,l);\n    int g=imod(1+imod(int(t*32./l),4),3);\n    o+=(n.y>=0.)&&(g==0)?vec2(.8,.8)*fmvibe(freq(n.y+48.)*n.x,n.x):vec2(0);\n    o+=(n.y>=0.)&&(g==1)?vec2(.6,1.)*fmvibe(freq(n.z+48.)*n.x,n.x):vec2(0);\n    o+=(n.y>=0.)&&(g==2)?vec2(1.,.6)*fmvibe(freq(n.w+48.)*n.x,n.x):vec2(0);\n    return s>2?o*.13:vec2(0);\n}\nvec2 track5(float t,float l,int s){//TRACK 5 backing\n    vec2 o=vec2(0);\n    getpattern(t,seq5[imod(s,4)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?vec2(fmharpsi(freq(n.y+59.97)*n.x,n.x),fmharpsi(freq(n.y+60.03)*n.x,n.x)):vec2(0);\n    return o*.17;\n}\nvec2 track6(float t,float l,int s){//TRACK 6 melody\n    vec2 o=vec2(0);\n    getpattern(t,seq6[imod(s,24)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?vec2(fmguitar(freq(n.y+60.03)*n.x,n.x),fmguitar(freq(n.y+59.97)*n.x,n.x)):vec2(0);\n    return o*.45;\n}\nvec2 track7(float t,float l,int s){//TRACK 4 chord\n    vec2 o=vec2(0);\n    getpattern(t,seq7[imod(s,4)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?vec2(1.,.6)*fmpad(freq(n.y+48.)*n.x,n.x):vec2(0);\n    o+=(n.y>=0.)?vec2(.8,.8)*fmpad(freq(n.z+48.)*n.x,n.x):vec2(0);\n    o+=(n.y>=0.)?vec2(.6,1.)*fmpad(freq(n.w+48.)*n.x,n.x):vec2(0);\n    return s>1?o*.2:vec2(0);\n}\nvoid render(float t,float l,inout vec2 o){\n    float c=0.;       //render target\n    int   s=int(t/l); //sequence number now playing\n    vec4  n=vec4(0);  //chord info x:gate yzw:notes\n    o+=track1(t,l,s); //TRACK 1 snaredrum,closehh,openhh\n    o+=track2(t,l,s); //TRACK 2 bassdrum,lowconga,highconga\n    o+=track3(t,l,s); //TRACK 3 bass\n    o+=track4(t,l,s); //TRACK 4 arpeggio\n    o+=track5(t,l,s); //TRACK 5 backing\n    o+=track6(t,l,s); //TRACK 6 melody\n    o+=track7(t,l,s); //TRACK 7 chord\n}\n\n//MASTER SECTION\n#define MASTER_DRIVE    0.3\n#define MASTER_PRESSURE 1.0\n#define DELAY_REPEAT    6\n#define DELAY_WET       0.20\n#define DELAY_FEEDBACK  0.95\n#define DELAY_TIME      0.05\nfloat mvol=0.; //for indicator\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o);\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a);\n        d*=DELAY_FEEDBACK;\n        r+=DELAY_TIME;\n        o+=a*d;\n    }\n    mvol=vol;\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n", "sound_inputs": [], "common_code": "//---Caged Star\n// by Catzpaw 2020\n\n//Common:utils\n\n#define ZERO min(0,iFrame)\n\n//UTILS\nfloat hash(vec3 p){return fract(sin(p.x*200.1+p.y*100.3)*p.z*300.7);}\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\n", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ty3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 114, 114, 144], [146, 146, 199, 199, 634]], "test": "untested"}
{"id": "MtcBRs", "name": "Ripple Bounce", "author": "cherpumples", "description": "Test shader, randomizers over time", "tags": ["ripples"], "likes": 2, "viewed": 293, "published": 3, "date": "1580481074", "time_retrieved": "2024-07-30T21:26:56.500231", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*10.;\n\n    // Time varying pixel color\n    vec3 col = 0.3 + 0.5*cos(uv.xxx+vec3(2,0,-2));\n    col += 0.3 + 0.3*sin(2.*iTime+uv.xxx+vec3(2,0,4));\n    col += 0.5 + 0.5*sin(5.+iTime+uv.xyx+vec3(4,5,2));\n    col += 0.5 + 0.7*cos(1.-iTime*uv.xyy+vec3(2,0,4));\n \n    col -= 0.5 + 0.7*sin(2.+iTime*uv.xyy+vec3(2,0,4));\n   \n     \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 531]], "test": "untested"}
{"id": "wt3XR4", "name": "Day 43", "author": "jeyko", "description": "Just fyi, i make these pretty fast, so don't expect clean code.", "tags": ["mdtmjvm"], "likes": 92, "viewed": 6800, "published": 3, "date": "1580477500", "time_retrieved": "2024-07-30T21:26:57.258204", "image_code": "\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define mx (10.*iMouse.x/iResolution.x)\n#define my (10.*iMouse.y/iResolution.x)\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + uv.x*right + uv.y*up);\n}\nvec3 glowA = vec3(0);\nvec3 glowB = vec3(0);\nvec3 glowC = vec3(0);\nvec3 glowD = vec3(0);\n\n\n#define ITERS 4\n#define ZOOM (1. + my)\n#define pmod(p, x) mod(p,x) - 0.5*x\nfloat[] WS = float[ITERS](1.,1.,1.,1.);\n\nfloat id;\nfloat sd(vec3 q){\n\t#define repD 3.97\n    id = floor(q.z/repD);\n    q.z = pmod(q.z, repD);\n    q.xy -= 2.;\n    q.xy = pmod(q.xy, 4.);\n    vec4 p = vec4(q.xyz, 1.);\n    vec4 c = vec4(0.9,0.77,0.4,0.2);\n    vec4 u = vec4(0.4,0.54,0.7,0.4);\n    for(int i = 0; i < ITERS; i++){\n        p.xyz = abs(p.xyz) - c.xyz;\n        float dpp = dot(p.xyz,p.xyz);\n        p=p*(1.5 + u)/clamp(dpp,.4,1.)- mix(p,c,0.9)*0.9;\n        if(i==1)\n\t\t\tp.xy += 0.4;\n        p.xy *= rot(-0.1 + sin(id)*0.9);\n        \n        p.xz *= rot(0.9);\n        //if(i == 2)\n        //\tp.y += 0.9;\n        WS[i] = p.w;\n    }\n    //w = p.z;\n    p.xyz = abs(p.xyz);\n    \n    p.xz *= rot(0.2);\n    float fr =  max(p.x - 0., max(p.y - 2.4 + sin(id)*0.7, p.z - 2.9))/p.w;\n    float d = fr;\n        \n\treturn d*0.5;\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e5);\n    \n    d.x = min(d.x, sd(p));\n    //d.x = min(d.x, length(p) - 0.6);\n    return d;\n}\nfloat D;\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e5);\n    hit = false;\n    p = ro;\n    t = 0.;\n    for(int i = 0; i < 90; i++){\n    \td = map(p);\n        d.x *= D;\n        glowA += exp(-d.x*20.)*WS[0];\n        glowB += exp(-d.x*05.)*WS[1]*0.5;\n        glowC += exp(-d.x*10.)*WS[2];\n        glowD += exp(-d.x*50.)*WS[3]*0.7;\n        if (d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0002, 0);\n\treturn normalize(\n    \tmap(p).x - vec3(\n        \tmap(p - t.xyy).x,\n        \tmap(p - t.yxy).x,\n        \tmap(p - t.yyx).x\n        )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 S = texture(iChannel0, vec2(0.01,0.0));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. + dot(uv,uv)*1.;\n    \n    vec3 col = vec3(0);\n    \n    \n    D = mix(0.8,1.,texture(iChannel0,20.*uv*256. + iTime*2.).x);\n    vec3 ro = vec3(0);\n    //ro.x += sin(mx)*ZOOM;\n    //ro.z += cos(mx)*ZOOM;\n    float m = sin(iTime*0.2);\n    ro.x += m*0.25;\n    ro.z += iTime + 14.;\n    vec3 lookAt = vec3(0);\n    lookAt.z = ro.z +1.;\n    //lookAt.x += m*3.;\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 p;float t; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    #define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n    if(hit){\n\t\tvec3 n = getNormal(p);\n        vec3 lD = normalize(vec3(1));\n        vec3 h = normalize(lD - rd);\n        float diff = max(dot(n, lD),0.);\n        float spec = pow(max(dot(n, h),0.), 20.);\n        float fres = pow(1. - max(dot(n, -rd),0.), 5.);\n    \t//col += diff*fres*4.;\n        \n        vec3 CA = WS[0]*vec3(0.6,0.2,0.7)*0.01;\n        vec3 CB = WS[1]*vec3(0.6,0.2,0.7)*0.01;\n        vec3 CC = WS[2]*vec3(0.6,0.2,0.7)*0.01;\n        //vec3 CD = WS[3]*vec3(0.1,0.9,0.4)*0.01;\n        //vec3 CD = 0.05*WS[2]*pal(0.2, 0.6, vec3(0.8,0.4,0.7), 5.9 + sin(id)*0.2, 2.4);\n        vec3 CD = 0.05*WS[2]*pal(0.2, 0.6, vec3(0.8,0.4,0.7), 5.9 , 0.2 + S.x);\n        vec3 C = CA + CB + CC + CD; \n        \n        col += diff * 0.2;\n        col += pow(CD*0.9,vec3(2.));\n    } else {\n    \n    }\n    \n    vec3 G = vec3(0);\n    G += pow(glowD*0.004,vec3(1.))*pal(0.2, 0.6, vec3(0.8,0.4,0.7), 0.6, 2.4);\n    G -= pow(glowC*0.005, vec3(1.1))*pal(0.2, 0.4, vec3(0.8,0.4,0.7), 9.6, 2.4);\n    \n    G += glowB*0.002 *pal(0.2, 0.6, vec3(0.8,0.4,0.7), 5.99 - sin(iTime), 2.4);\n    G *= 1. + pow(S.x,5.)*0.2;\n    \n    col += G;\n    uv.y *= 1.5;\n    col *= 1. - dot(uv,uv)*0.1;\n    col = mix(col, vec3(0.5,0.4,0.35)*0.3, smoothstep(0.,1.,t*0.1 - 0.1));\n    //col += glowB*0.004;\n    //col += glow*0.006;\n    col = clamp(col, 0., 1.);\n    col = pow(col, vec3(0.7));\n    col = smoothstep(0.,0.94, col);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3XR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 176, 176, 352], [569, 569, 586, 586, 1339], [1341, 1341, 1358, 1358, 1467], [1477, 1477, 1548, 1548, 1983], [1985, 1985, 2008, 2008, 2175], [2177, 2177, 2234, 2234, 4301]], "test": "untested"}
{"id": "wl3SR4", "name": "Crash and crumble", "author": "TimoKinnunen", "description": "Verlet softbody simulation with permanent deformation based on impact strength.", "tags": ["collision", "simulation", "deformation", "physics", "verlet", "softbody"], "likes": 12, "viewed": 544, "published": 3, "date": "1580474334", "time_retrieved": "2024-07-30T21:26:58.048092", "image_code": "////////////////////////////////////\n//\n// Crash and crumble\n// by Timo Kinnunen 2020\n//\n// I attempted to model a collision with physically-based\n// impact damage that changes the shape of the box object\n// permanently, a short of half-way between softbody and rigid-body \n// simulation.\n//\n// The simulation keeps an extra set of vertices to record\n// the shape of the object model, in addition to vertex positions at \n// the current and previous timesteps.\n//\n// On penetrating inside the rigid ground plane, instead of the full\n// force being deflected at the vertex to bounce the object outside\n// again, a portion of the force is used to nudge the corresponding\n// model vertex instead. This allows the movement to continue while\n// slowing down, leading to further penetrations and crumbling.\n//\n// The difference between the current model vertex position and\n// the original analytical position of the vertex is used to offset\n// the vertex position in subsequent simulation timesteps.\n//\n// The orientation of the box is not tracked. Instead the rotation\n// angle is estimated from the average position of the current vertex\n// and its 3 \"diagonal\" neighbours that correspond to\n// 90/180/270 degree rotations.\n//\n//\n// Fork of \"Jello!\" by qwertsol. https://shadertoy.com/view/ldKBWd\n// 2020-01-31 11:47:47\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(0), 1);\n    vec2 uv = fragCoord;\n    \n    fragColor = vec4(vec3(0.9 - distance(iResolution.xy / 2.0, uv) / iResolution.y / 10.0), 1.0);\n    fragColor.rgb += hash(uvec3(fragCoord, 29.0)) / 50.0;\n    \n    fragCoord.x -= iResolution.x / 2.0;\n\tuv = fragCoord;\n    \n    float scale = iResolution.y / 500.0;\n    \n    vec4 color = texelFetch(iChannel0, ivec2(0, 1), 0);\n    \n    int j, c = 0;\n  \tfor (int i=0, j=N*4-1; i<N*4; j=i, i+=1) \n    {\n        vec2 a = (getBody(i, iChannel0).xy+vec2(0,10)) * scale;\n        vec2 b = (getBody(j, iChannel0).xy+vec2(0,10)) * scale;\n        \n    \tif (((a.y > uv.y) != (b.y > uv.y)) &&\n     \t\t(uv.x < (b.x-a.x) * (uv.y-a.y) / (b.y-a.y) + a.x))\n      \t c++;\n  \t}\n    \n    bool isIn = (c % 2 == 1);\n\n    float totalDist = 0.0;\n    float closeDist = 9e10;\n    vec4 colors = vec4(0);\n    for (int i=0; i<4*N; i++) {\n        vec2 p1 = getBody(i, iChannel0).xy+vec2(0,10);\n        float sD = distance(fragCoord, p1.xy * scale);\n        if(sD<closeDist){\n        color = texelFetch(iChannel0, ivec2(i, 1), 0);\n            closeDist=sD;\n        }\n        const float gain =50./800.0*2.0;\n        colors = mix(texelFetch(iChannel0, ivec2(i, 1), 0),colors,fract(gain*sD*sD/(totalDist+gain*sD*sD)));\n        totalDist = mix(sqrt(sD),totalDist,fract(gain*sD*sD/(totalDist+gain*sD*sD)));\n    }\n    if (isIn)\n        fragColor = colors;\n\n    \n    vec2 p0 = getBody(0, iChannel0).xy+vec2(0,10);\n    for (int i=1; i<4*N+1; i++)\n    {\n        vec2 p1 = getBody(i, iChannel0).xy+vec2(0,10);\n        drawLine(fragCoord, p0.xy * scale, p1.xy * scale, 1.0, colors, fragColor);\n        p0 = p1;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const vec2 g = vec2(0, -9.8) * 100.0;\nconst float td = 1.0 / 60.0; \nconst float m = 0.1;\nconst float k = 5.0;\nconst float b = 0.02;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 random =  hash(uvec3(iFrame>>9, 13, 29));\n    if ((iFrame&0x1FF) == 0 || texelFetch(iChannel1, ivec2(32, 0), 0).r > 0.0) \n    {\n        vec2 start = vec2(0, 900);\n        \n        int i = int(fragCoord.x);\n        if (i < 4*N && fragCoord.y < 3.0) \n        {\n            vec2 coords = initBodyCoords(i);\n            vec2 pos = rotate(coords * R - vec2(float(N/2)) * R, random.x * 100.0) + start;\n        \n            if (fragCoord.y > 2.0) {\n                fragColor = vec4(coords, 0, 0);\n            } else if (fragCoord.y > 1.0) {\n                if (iFrame > 0)\n                    fragColor = vec4(hue(random.y).rgb * .7, 1.0);\n                else\n                    fragColor = vec4(1, 0, 0, 1);\n            } else {\n                fragColor = vec4(pos, pos);\n                float rand = random.y*2.0-1.0;\n                fragColor.xz += sign(rand)*((0.5+0.5*abs(rand))*250.0+vec2(0,0.05/td));\n            }\n        }\n    }\n    else\n    {\n        vec2 params = (iMouse.x<10.0||iMouse.y<10.0) ? random.xy : clamp((iMouse.xy-30.0)/(iResolution.xy-50.0),0.,1.);\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        int i = int(fragCoord.x);  \n        if (i<4*N && fragCoord.y < 3.0)\n        {\n            vec4 p0 = getBody(i, iChannel0);\n            vec2 pc0 = getBodyCoords(i, iChannel0);\n            vec2 f = vec2(0);\n\n            const int S = int(float(4*N) / 2.8);\n            for (int j=-S; j<=S; j++)\n            {\n                if (j == 0)\n                    continue;\n                \n                vec4 p1 = getBody(i+j, iChannel0);\n                vec2 pc1 = getBodyCoords(i+j, iChannel0);\n                float len = distance(pc0, pc1);\n                float deformed = clamp(1./5.*(distance(initBodyCoords(i+j),pc1)+distance(initBodyCoords(i),pc0)),0.,1.);\n                f += hookesLaw(p1-initBodyCoords(i+j).xyxy+pc1.xyxy, p0-initBodyCoords(i).xyxy+pc0.xyxy, len * R,\n                               k+1.*k*deformed, b+2.*b*deformed, td);\n            }\n            \n            if (p0.y < 1.0)\n            {\n                vec2 v = (p0.xy - p0.zw) / td;\n                vec2 n = g*m + f; \n                if (n.y < 0.0)\n                \tf += -v.x * m * vec2(1, 0) * .02 * (-n.y);\n            }\n\n            vec2 newPos = p0.xy + (p0.xy - p0.zw) * .9999 + (g + f/m) * td * td;\n            vec2 oldPos = p0.xy;\n            vec2 displacement = vec2(0);\n            if (newPos.y < 0.0) {\n                if(abs(-p0.y * .3-newPos.y) > 2.5) {\n                    displacement=vec2(0,-p0.y * .3-newPos.y);\n                    vec2 cmc = 0.25*(pc0+getBodyCoords(i+N, iChannel0)+getBodyCoords(i+2+N, iChannel0)+getBodyCoords(i+3*N, iChannel0));\n                    vec2 mc = 0.25*(oldPos+getBody(i+N, iChannel0).xy+getBody(i+2+N, iChannel0).xy+getBody(i+3*N, iChannel0).xy);\n                    float srcAngle = atan(mc.y-p0.y,mc.x-p0.x);\n                    float dstAngle = atan(cmc.y-pc0.y,cmc.x-pc0.x);\n                    float srcLen = distance(mc,p0.xy);\n                    float dstLen = distance(cmc,pc0);\n                    float c = cos(dstAngle-srcAngle),s=sin(dstAngle-srcAngle);\n                    mat2 rot=mat2(c,s,-s,c);\n                    displacement = rot*displacement;\n                    //displacement*=srcLen/dstLen;\n                    displacement*=0.125;\n                }\n                newPos.y = -p0.y * .3;\n            }\n            if(fragCoord.y > 2.0) {\n                fragColor.xy += (300./450.*8.0-4.0)*displacement;\n            } else if(fragCoord.y > 1.0) {\n                float oldDmg = 0.5+0.5*smoothstep(5.,0.5,distance(initBodyCoords(i),pc0));\n                float newDmg = 0.5+0.5*smoothstep(5.,0.5,\n                                                  distance(initBodyCoords(i),pc0+\n                                                           (iMouse.y/iResolution.y*8.0-4.0)*displacement));\n                \n                fragColor.rgb *= clamp(newDmg/oldDmg,0.5,1.0);\n            } else {\n                fragColor.xy = newPos + ((450.-params.x*250.)/800.0*8.0-4.0)*displacement;\n                fragColor.zw = oldPos + ((params.y*150.+150.)/450.0*8.0-4.0)*displacement;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define normalize(x) normalize(x+1e-6) \n\nconst int N = 20;\nconst float R = 10.0;\n\nconst uint hk = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*hk;\n    x = ((x>>8U)^x.yzx)*hk;\n    x = ((x>>8U)^x.yzx)*hk;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec4 hue( float x )\n{\n    return .6 + .6 * cos(6.3 * x  + vec4(0,23,21,0));\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat segmentDistance( vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nvoid drawLine( vec2 coords, vec2 p0, vec2 p1, float thickness, vec4 color, inout vec4 outputColor )\n{\n    float sD = segmentDistance(coords, p0, p1);\n\tfloat a = 1.0 - clamp(sD - thickness / 2.0 + .5, 0.0, 1.0);\n    \n    outputColor = mix(outputColor, color, a * color.a);\n}\n\nvoid drawCircle( vec2 coords, vec2 center, float radius, vec4 color, inout vec4 outputColor )\n{\n    float sD = distance(coords, center);\n\tfloat a = 1.0 - clamp(sD - radius + .5, 0.0, 1.0);\n    \n    outputColor = mix(outputColor, color, a * color.a);\n}\n\nvoid drawSpring( vec2 coords, vec2 p0, vec2 p1, \n                 float thickness, int loops, vec4 color, inout vec4 outputColor )\n{\n    vec2 d = p1 - p0;\n    if (length(d) < 0.001)\n        return;\n    \n    vec2 dir = normalize(d);\n    vec2 per = vec2(dir.y, -dir.x);\n    \n    vec2 st = d / float(loops * 2);\n    vec2 last = p0 + per * thickness / 2.0 + st / 2.0;\n    vec2 sw = -thickness * per;\n    float th = 1.0;\n    \n    drawLine(coords, p0, last, th, color, outputColor);\n    \n    for (int i=0; i<loops*2-1; i++)\n    {\n        vec2 next = last + st + sw;\n        sw = -sw;\n        drawLine(coords, last, next, th, color, outputColor);\n        last = next;\n    }\n    \n    drawLine(coords, last, p1, th, color, outputColor);\n}\n\nvec2 hookesLaw( vec4 anchor, vec4 body, float len, float stiffness, float damping, float dt ) \n{\n    vec2 dx = anchor.xy - body.xy;\n    float x = len - length(dx);\n            \n    vec2 d = normalize(dx);\n    vec2 v0 = (anchor.xy - anchor.zw) / dt;\n    vec2 v1 = (body.xy - body.zw) / dt;\n    vec2 dv = v0 - v1;\n    float v = dot(dv, d);\n    \n    vec2 f = (-stiffness*x) * d;\n    f += damping * v * d;\n    return f;\n}\n\nvec2 getBodyCoords(int i, sampler2D iChannel0)\n{\n    i = (i % (4*N) + 4*N) % (4*N);\n    \n    return texelFetch(iChannel0, ivec2(i, 2), 0).xy;\n}\nvec2 initBodyCoords( int i )\n{\n    i = (i % (4*N) + 4*N) % (4*N);\n    \n    if (i<N)\n        return vec2(i, 0);\n    else if (i<2*N)\n        return vec2(N, i-N);\n    else if (i<3*N)\n        return vec2(N-(i-2*N), N);\n    else\n        return vec2(0, N-(i-3*N));    \n}\n\nvec4 getBody( int i, sampler2D iChannel0 )\n{   \n    i = (i % (4*N) + 4*N) % (4*N);\n    \n    return texelFetch(iChannel0, ivec2(i, 0), 0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3SR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1317, 1317, 1374, 1374, 3012]], "test": "untested"}
{"id": "wt3SR4", "name": "大龙猫 - On the train to fosdem", "author": "totetmatt", "description": "Killing time on the train to Fosdem !", "tags": ["fosdem"], "likes": 3, "viewed": 462, "published": 3, "date": "1580473210", "time_retrieved": "2024-07-30T21:26:58.852940", "image_code": "#define cTime floor(iTime) + pow(fract(iTime),.5 + (sin(iTime*10.)*.5+.5)+.1)\nmat2 r(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=r(iTime*.1+smoothstep(5.9,.1,length(uv)));\n    \n    uv = abs(uv);\n   \n    uv*=10.;\n    uv*=sin(length(cos(uv)*.5+cTime));\n    uv*=r(length(uv*.1-iTime*.1)+iTime*.12);\n    vec2 id= floor(uv);\n     uv = fract(uv+cTime*.13)-.5;\n    float d = 0.;\n       \n    if(mod(id.x,2.) - mod(id.y,2.) == 0.) {\n        d = min(abs(uv.x+uv.y),.1);\n    } else {   \n        d = min(abs(uv.y-uv.x),.1);\n    }\n    d = smoothstep(0.2,.09-length(uv+sin(iTime)*.4),d);\n    vec3 col;\n    if( mod(id.x,2.) - mod(id.y,2.) == 0.) {\n        col = mix(vec3(.1),vec3(.9,.3,.2*(1.-d)),vec3(d));\n    } else {\n        col = mix(vec3(.1),vec3(.2,.3*(1.-d),.9),vec3(d));\n    }\n       \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3SR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 94, 94, 138], [139, 139, 194, 194, 942]], "test": "untested"}
{"id": "WlcXzN", "name": "The Nautilus, Part 2", "author": "dr2", "description": "From Jules Verne's \"20K Leagues Under The Seas\"; part 2 of a series", "tags": ["water", "submarine", "sciencefiction", "verne"], "likes": 2, "viewed": 349, "published": 3, "date": "1580470612", "time_retrieved": "2024-07-30T21:26:59.859250", "image_code": "// \"The Nautilus, Part 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// From Jules Verne's \"20K Leagues Under The Seas\"; part 2 of a series.\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, sbPos;\nfloat tCur, dstFar, sbRot, sbLen, prpRot, cvSize, msAz, msEl;\nint idObj;\nbool bmOn;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idCav = 14, idGrnd = 15;\nconst float pi = 3.14159;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 TrackPathCv (float t)\n{\n  return vec3 ((4.7 * sin (t * 0.15 / cvSize) + 2.7 * cos (t * 0.19 / cvSize)) * cvSize, 0., t);\n}\n\nfloat CaveDf (vec3 p)\n{\n  float s, d;\n  p.x -= TrackPathCv (p.z).x;\n  p /= cvSize;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  d = 0.6 * cvSize * (length (cos (0.6 * p - 0.5 * sin (1.4 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1);\n  return d;\n}\n\nfloat CaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 250; j ++) {\n    p = ro + dHit * rd;\n    d = CaveDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat CaveAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 8.;\n    ao += max (0., d - 3. * CaveDf (ro + d * rd));\n  }\n  return clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 CaveNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = CaveDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat CaveSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 16; j ++) {\n    h = CaveDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nfloat GrndHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec2 q;\n  float ht, wAmp;\n  q = 0.2 * p;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    ht += wAmp * Noisefv2 (q);\n    q *= qRot;\n    wAmp *= 0.5;\n  }\n  return ht - 8.;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.x + 1.5 * Fbm2 (0.5 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.x + 1.9 * Fbm2 (0.3 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e = vec2 (0.002, 0.);\n  float h;\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  if (rd.y == 0.) rd.y = 0.0001;\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (2. * p.x + 0.77 * t + sin (0.73 * p.y - t)) + sin (0.81 * p.y - 0.89 * t +\n     sin (0.33 * p.x + 0.34 * t)) + 0.5 * (sin (1.43 * p.x - t) + sin (0.63 * p.y + t));\n  h *= 0.04 * smoothstep (0.5, 1., rd.y);\n  return h;\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.8), vec3 (0.25, 0.4, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + gd * 0.07);\n}\n\nfloat NautDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  d = PrCylDf (p, 2.3, sbLen + 2.);\n  dMin = d;\n  if (d < 0.1) dMin = NautDf (p);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.02, h);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec2 LBeamDf (vec3 p)\n{\n  vec3 q;\n  float d, bz;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, 2.35);\n  q.yz = Rot2D (q.yz, -0.04 * pi);\n  q.xz = Rot2D (q.xz, 0.01 * pi);\n  bz = q.z / 20.;\n  d = length (q.xy) - 0.08 * (1. + 3. * bz);\n  d = 0.9 * max (d, - min (20. * (1. - bz), q.z));\n  return vec2 (d, bz);\n}\n\nvec2 LBeamRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 d2;\n  float dHit;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d2 = LBeamDf (ro + dHit * rd);\n    dHit += d2.x;\n    if (d2.x < 0.001 || dHit > dstFar) break;\n  }\n  return vec2 (dHit, d2.y);\n}\n\nvec3 LBeamNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = LBeamDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx))).x;\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 NautColN (vec3 p, inout vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  vn.xz = Rot2D (vn.xz, sbRot);\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (0.5, 0.4, 0.3, -1.);\n  }\n  if (col4.a >= 0.) {\n    vn = VaryNf (32. * p, vn, 0.5);\n  }\n  vn.xz = Rot2D (vn.xz, - sbRot);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, vno, vnb, rob[1], rdb[1];\n  vec2 lbDist, ws;\n  float dstObj, dstCave, dstGrnd, sh;\n  dstObj = ObjRay (ro, rd);\n  dstCave = CaveRay (ro, rd);\n  if (dstCave < min (dstObj, dstFar)) {\n    dstObj = dstCave;\n    idObj = idCav;\n  }\n  dstGrnd = (rd.y < 0.) ? GrndRay (ro, rd) : dstFar;\n  if (dstGrnd < min (dstObj, dstFar)) {\n    dstObj = dstGrnd;\n    idObj = idGrnd;\n  }\n  sh = 1.;\n  if (bmOn) {\n    rob[0] = ro;\n    rdb[0] = rd;\n  }\n  if (dstObj < dstFar) {\n    if (idObj == idGrnd) {\n      ro += dstObj * rd;\n      col4 = mix (vec4 (0.4, 0.3, 0.3, 0.), vec4 (0.3, 0.3, 0.2, 0.),\n         0.3 + 0.4 * smoothstep (0.4, 0.6, Fbm2 (2. * ro.xz))) * (1. +\n         0.2 * smoothstep (0.3, 0.7, Fbm2 (0.5 * ro.xz)));\n      vn = GrndNf (ro);\n      vno = vec3 (0., 1., 0.);\n      if (vn.y > 0.85) {\n        vn4 = RippleNorm (0.25 * ro.xz, vn, 8. * (1. - smoothstep (-0.4, -0.2, dot (rd, vn))));\n        vn = vn4.xyz;\n        col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w);\n      }\n      vn = VaryNf (4. * ro, vn, 4. - 3.5 * smoothstep (0.2, 0.5, dstObj / dstFar));\n      ws = ro.xz - sbPos.xz;\n      ws = Rot2D (ws, sbRot);\n      sh = 0.6 + 0.4 * smoothstep (-0.2, 0.8, length (ws -\n         vec2 (0., clamp (ws.y, - sbLen, sbLen))) -\n         1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, ws.y / sbLen)) *\n         (1. - 0.85 * smoothstep (0.6, 1.1, - ws.y / sbLen)));\n      sh = min (sh, min (CaveSShadow (ro, vec3 (0., 1., 0.)), \n         0.5 + 0.5 * CaveAO (ro, vec3 (0., 1., 0.))));\n      col = col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, sunDir), 0.));\n      col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (- dstObj / dstFar));\n      col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));\n    } else if (idObj == idCav) {\n      ro += dstObj * rd;\n      vn = CaveNf (ro);\n      vno = vn;\n      col = vec3 (0.4, 0.4, 0.4);\n      col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (-4. * dstObj / dstFar));\n      vn = VaryNf (ro, vn, 12.);\n      col *= (0.2 + 0.8 * max (dot (vn, sunDir), 0.) +\n         0.5 * pow (max (dot (reflect (sunDir, vn), rd), 0.0), 128.));\n      col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      vno = vn;\n      col4 = NautColN (ro, vn);\n      sh = ObjSShadow (ro, vec3 (0., 1., 0.));\n      if (col4.a >= 0.) {\n        col = col4.rgb * (0.5 + 0.5 * sh * max (vn.y, 0.) + 0.2 * UnwCol (rd));\n        col *= vec3 (0.7, 0.9, 1.);\n      } else {\n        col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n      }\n    }\n    col += 0.2 * step (0.95, sh) * TurbLt (0.02 * ro, abs (vno), 0.2 * tCur) *\n       (1. - smoothstep (0.5, 0.8, dstObj / dstFar)) * smoothstep (-0.2, -0.1, vno.y);\n  } else {\n    col = UnwCol (rd) + WatShd (rd);\n  }\n  if (bmOn) {\n    lbDist = LBeamRay (rob[0], rdb[0]);\n    vnb = LBeamNf (rob[0] + lbDist.x * rdb[0]);\n    if (lbDist.x < min (dstObj, dstFar))\n       col = mix (col, vec3 (1., 1., 1.), 0.5 * (1. - lbDist.y) * (0.7 - 0.3 * dot (vnb, rd)));\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid ExMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 col, ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, dVu, tVuCyc;\n  uv = fCoord;\n  cvSize = 7.;\n  bmOn = true;\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  t = 3. * tCur;\n  az = 0.;\n  el = 0.;\n  fpF = TrackPathCv (t + 0.1);\n  fpB = TrackPathCv (t - 0.1);\n  sbPos = 0.5 * (fpF + fpB);\n  sbPos.y = 0.09;\n  vd = fpF - fpB;\n  sbRot = atan (vd.x, vd.z);\n  az += (msAz > -999.) ? msAz : 0.;\n  el += (msEl > -999.) ? msEl : 0.;\n  dVu = 2. * SmoothBump (0.25, 0.75, 0.15, mod (tCur / 40., 1.)) - 1.;\n  t += 20. * dVu;\n  fpF = TrackPathCv (t + 0.1 * sign (dVu));\n  fpB = TrackPathCv (t - 0.1 * sign (dVu));\n  ro = 0.5 * (fpF + fpB);\n  ro.x += 2. * (1. - abs (dVu));\n  ro.y = 2. + 2. * (1. - abs (dVu));\n  vd = sbPos - ro;\n  vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n  dstFar = 50. * cvSize;\n  zmFac = 1.4;\n  sunDir = normalize (vec3 (1., 3., -1.));\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  uv *= vec2 (9./16., 1./0.85);\n  col *= 1. - 0.8 * smoothstep (0.9, 1., length (uv));\n  fCol = col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n    msAz = 2. * pi * mPtr.x;\n    msEl = 0.5 * pi * mPtr.y;\n  }\n  if (abs (uv.y) < 0.85) ExMain (col, uv);\n  else col = vec3 (0.05);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 i, f, t1, t2;\n  i = floor (p);\n  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  t1 = Hashv4f (dot (i.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (i.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n               mix (mix (t2.x, t2.y, f.z), mix (t2.z, t2.w, f.z), f.w));\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcXzN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1288, 1288, 1316, 1316, 1415], [1417, 1417, 1440, 1440, 1701], [1703, 1703, 1737, 1737, 1942], [1944, 1944, 1977, 1977, 2168], [2170, 2170, 2192, 2192, 2448], [2450, 2450, 2488, 2488, 2734], [2736, 2736, 2759, 2759, 3001], [3003, 3003, 3037, 3037, 3516], [3518, 3518, 3540, 3540, 3679], [3681, 3681, 3706, 3706, 4085], [4087, 4087, 4131, 4131, 4325], [4327, 4327, 4351, 4351, 4682], [4684, 4684, 4724, 4724, 5184], [5186, 5186, 5209, 5209, 5629], [5631, 5631, 5654, 5654, 8535], [8537, 8537, 8559, 8559, 8719], [8721, 8721, 8754, 8754, 8937], [8939, 8939, 8960, 8960, 9215], [9217, 9217, 9254, 9254, 9495], [9497, 9497, 9520, 9520, 9856], [9858, 9858, 9892, 9892, 10114], [10116, 10116, 10139, 10139, 10398], [10400, 10400, 10439, 10439, 13077], [13079, 13079, 13114, 13114, 16230], [16232, 16232, 16277, 16277, 17372], [17374, 17374, 17430, 17430, 17903], [17905, 17905, 17938, 17938, 18027], [18029, 18029, 18075, 18075, 18122], [18124, 18124, 18157, 18157, 18184], [18186, 18186, 18228, 18228, 18279], [18281, 18281, 18340, 18340, 18471], [18473, 18473, 18526, 18526, 18587], [18589, 18589, 18611, 18611, 18649], [18651, 18651, 18687, 18687, 18893], [18895, 18895, 18940, 18940, 19043], [19045, 19045, 19102, 19102, 19185], [19187, 19187, 19217, 19217, 19330], [19364, 19364, 19388, 19388, 19441], [19443, 19443, 19467, 19467, 19597], [19599, 19599, 19623, 19623, 19686], [19688, 19688, 19712, 19712, 19932], [19934, 19934, 19959, 19959, 20145], [20147, 20147, 20172, 20172, 20397], [20399, 20399, 20424, 20424, 20745], [20747, 20747, 20772, 20772, 20918], [20920, 20920, 20942, 20942, 21096], [21098, 21098, 21119, 21119, 21274], [21276, 21276, 21297, 21297, 21452], [21454, 21454, 21483, 21483, 21695], [21697, 21697, 21736, 21736, 21921]], "test": "untested"}
{"id": "3l3SzN", "name": "Complex numbers", "author": "hazenn", "description": "basic operations, trig functions, hyperbolic trig functions.", "tags": ["complex"], "likes": 5, "viewed": 423, "published": 3, "date": "1580465254", "time_retrieved": "2024-07-30T21:27:00.726930", "image_code": "\n//A few functions that implement complex number operations for vec2\n\nconst vec2 c_i = vec2(0,1);\nconst float PI = 3.1415926535897;\nvec2 c_cjg(in vec2 c) {\n\treturn vec2(c.x, -c.y);\n}\n\nvec2 c_mul(in vec2 a, in vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 c_pow(in vec2 c, int p) {\n    vec2 temp = vec2(1.0,0.0);\n\tfor (int i = 0; i < p; ++i) {\n\t\ttemp = c_mul(temp, c);\n\t}\n    return temp;\n}\nvec2 c_div(in vec2 a, in vec2 b) {\n    return\n        vec2(a.x*b.x + a.y*b.y,\n             a.y*b.x - a.x * b.y)\n        / (b.x * b.x + b.y * b.y)\n        ;\n}\nvec2 c_exp(in vec2 c) {\n    return exp(c.x) * vec2(cos(c.y),sin(c.y));\n}\n//uses the even-odd split formula, there are probably better ways\nvec2 c_sin(in vec2 c) {\n    return \n        c_div(\n        \tc_exp(c_mul(c_i , c))\n            -c_exp(c_mul(-c_i , c))\n            ,\n            2.*c_i\n\n        );\n}\nvec2 c_cos(in vec2 c) {\n    return \n        c_div(\n        \tc_exp(c_mul(c_i , c))\n            +c_exp(c_mul(-c_i , c))\n            ,\n            2. * vec2(1.,0.)\n\n        );\n}\nvec2 c_sinh(in vec2 c) {\n    return \n        c_div(\n        \tc_exp(c)\n            -c_exp(-c)\n            ,\n            2. * vec2(1.,0.)\n\n        );\n}\nvec2 c_cosh(in vec2 c) {\n    return \n        c_div(\n        \tc_exp(c)\n            +c_exp(-c)\n            ,\n            2. * vec2(1.,0.)\n\n        );\n}\n\n//below is an use case : displaying various mandelbrot-style fractals i found on wikipedia\n\n\nvec2 uv_scaled(vec2 uv, vec2 top_left, vec2 bot_right)\n{\n    return mix(top_left.xy,bot_right.xy,uv.xy);\n}\nfloat F (float x)\n{\n\treturn (cos(PI * (x+1.0))+1.0)/2.0;\n}\nvec2 f(vec2 c,vec2 z, float t)\n{\n    //the function used to define the sequence\n\treturn\n        c_sinh(z + c_div(c_i.yx * t, c_mul(c,c)));\n        \n}\n/*\nreturn \n        c_cjg(\n            c_pow(z,2)\n            +\n            c_sin(c_pow(c,3) + c_i * t)\n            )\n        ; \n*/\nfloat fractal(vec2 c, int n, float t)\n{\n    vec2 z = vec2(1.,0.1);\n    for (int i = 0; i < n;i++)\n    {\n        if (sqrt(z.x*z.x + z.y*z.y)  > 200.0)\n        {\n            return (1.0-float(i)*float(i)/float(n)*float(n));\n\t\t}\n        z = f(c,z,t);\n        \n    }\n    return 0.0;\n}\nvec3 colorA = vec3(0.03137254901,0.05882352941,0.05882352941);\nvec3 colorB = vec3(0.6431372549,0.7294117647,0.7294117647);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 c = uv_scaled(uv,vec2(-1.5,1.5),vec2(1.5,-1.5));\n    vec3 col = vec3(0.0,0.0,0.0);\n    col = mix(colorA,colorB,F(fractal(c/(0.15*0.15) + vec2(0.25,0.),300,iTime)));\n    //col.x = c.x;\n    //col.y = c.y;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3SzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 155, 155, 182], [184, 184, 218, 218, 280], [282, 282, 312, 312, 421], [422, 422, 456, 456, 579], [580, 580, 603, 603, 652], [653, 719, 742, 742, 883], [884, 884, 907, 907, 1058], [1059, 1059, 1083, 1083, 1208], [1209, 1209, 1233, 1233, 1358], [1453, 1453, 1509, 1509, 1559], [1560, 1560, 1579, 1579, 1618], [1619, 1619, 1651, 1698, 1768], [1769, 1900, 1939, 1939, 2180], [2304, 2304, 2361, 2411, 2717]], "test": "untested"}
{"id": "3t3SzN", "name": "Logistic Map Bifurcation", "author": "Txoka", "description": "Bifurcation diagram for the Logistic Map.", "tags": ["2d", "fractal", "map", "chaos", "logistic", "bifurcation", "logisticmap"], "likes": 3, "viewed": 337, "published": 3, "date": "1580462773", "time_retrieved": "2024-07-30T21:27:01.582642", "image_code": "void mainImage( out vec4 Q, in vec2 U ){\n    float y=U.y/iResolution.y;\n\tint id=int(U.x);\n    float mindist=1e10;\n    for(int i=0;i<int(iResolution.y);i++){\n    \tfloat n=texelFetch(iChannel0,ivec2(id,i),0).x;\n    \tfloat dist=abs(n-y);\n   \t\tmindist=min(mindist,dist);\n    }\n    Q=vec4(1.-exp(-100.*mindist));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 Q, in vec2 U ){\n    float e=U.x/iResolution.x*4.;\n    float n=U.y/iResolution.y;\n    for(int i=0;i<400;i++)n=next(e,n);\n\tQ=vec4(n);\n}", "buffer_b_inputs": [], "common_code": "float next(float e, float x){\n    return e*x*(1.-x);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3SzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 309]], "test": "untested"}
{"id": "3l3XRN", "name": "GLSL bug (OpenGL)", "author": "FabriceNeyret2", "description": "on linux, this is black with loop up to 32 > i while white with i < 32 !!!", "tags": ["glsl", "bug", "opengl"], "likes": 0, "viewed": 292, "published": 3, "date": "1580460363", "time_retrieved": "2024-07-30T21:27:02.644802", "image_code": "void mainImage( out vec4 O, vec2 U )\n{    \n\n#if 1\n    for (int i = 0; 32 > i; i++) \n#else\n    for (int i = 0; i < 32; i++) \n#endif\n        O = vec4(i); \n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3XRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3lcSRN", "name": "sketch_1_30_20", "author": "ianwall", "description": "asd", "tags": ["sketch"], "likes": 2, "viewed": 79, "published": 3, "date": "1580457294", "time_retrieved": "2024-07-30T21:27:03.651112", "image_code": "/// params:\n\n\nint seed = 2111;\nfloat sharpness = 1.1;\nfloat movement = 1.0;\nfloat curvyness = 0.0;//3.8;//1.5;\nint num = 5;\nint type = 2; // 0, random, 1, diamond, 2, triangle\nfloat time = 0.0;\n// Palette:\nvec3 a = vec3(0.5, 0.5, 0.5);\nvec3 b = vec3(0.5, 0.5, 0.5);\nvec3 c = vec3(1.0, 1.0, 1.0);\nvec3 d = vec3(0.00, 0.10, 0.20);\n\n/////\n\n//uint type[] = uint[](1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u);\n//vec2 off[3] = vec2[3](vec2(1.0, 0.0), vec2(1.0, sqrt(3.0)), vec2(-1.0, sqrt(3.0)));\n\nfloat hash1( uint n ) \n{\n    n += uint(seed);\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat leftOf(vec2 a, vec2 b, vec2 p) {\n\tvec2 e0 = b - a;\n\tvec2 v0 = p - a;\n\tvec2 pq0 = v0 - e0*( dot(v0,e0)/dot(e0,e0) );\n    vec2 d = vec2( dot( pq0, pq0 ), (v0.x*e0.y-v0.y*e0.x) );\n\t\n    // sdf distance to line\n    float dist = -sqrt(d.x)*sign(d.y);\n\n    float edge = mix(0.2, 0.005, sharpness);\n    return 2.0*smoothstep(-edge, edge, dist + movement*sin(6.28318*time/10.0 + curvyness*dot(p,p))) - 1.0;\n}\n\nvec4 palette( float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return vec4(a + b*cos( 6.28318*(c*t+d) ), 1.0);\n}\n\nvec4 color(float z) {\n    return palette( z/float(num), a, b, c, d);\n    //return palette( mod(z/float(num), 1.0), a, b, c, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n     time = iTime+0.1*uv.x;//+3.1*uv.y;\nvec4 ui = texture(iChannel0, fragCoord/iResolution.xy);    \n    uint size = uint(num);\n    float c = 0.0;\n    float d = 1.0;//0.25/float(size);\n    for(uint i = 0u; i < size; ++i) {\n        vec2 a = vec2(hash1(i), hash1(i+111u));\n        float angle = 6.283*hash1(i+222u);\n        float z = sign(mod(float(i), 2.0)-0.5);\n        vec2 b = a;\n        if(type == 0)\n\t        b += vec2(sin(angle), cos(angle));\n        else if(type == 1)\n        \tb += vec2(z, sqrt(3.0));\n        else if(type == 2)\n        \tb += vec2(z, ((i % 3u)==0u) ? 0.0 : sqrt(3.0));\n            \n        c += d*leftOf(a,b,uv);\n\n        a.y = -a.y;\n        b.y = -b.y;\n        c += d*leftOf(b,a,uv);\n\n        a.x = -a.x;\n        b.x = -b.x;\n        c += d*leftOf(a,b,uv);\n\n        a.y = -a.y;\n        b.y = -b.y;\n        c += d*leftOf(b,a,uv);\n    }\n    \n    // Output to screen\n    fragColor = vec4(mix( color(c).rgb, ui.rgb, ui.a*0.8), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Thx to :\n// Smooth HSV - iq : https://www.shadertoy.com/view/MsS3Wc\n// Rounded box - iq : https://www.shadertoy.com/view/4llXD7\n// 96-Bit 8x12 font - Flyguy : https://www.shadertoy.com/view/Mt2GWD\n\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(.3,1.,.3)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n\nvoid setCursor(int x, int y)\n{\n    pos = vec2(float(x),iResolution.y-float(y));\n}\n\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\nfloat char(vec4 ch)\n{\n    float px = sprite(ch, vec2(8, 12), uv - pos);\n    pos.x += 8.;\n    return px;\n}\n\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return ch_0;\n}\n\nfloat print_float(float number)\n{\n    float result = 0.0;\n    \n    for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1)\n        {\n            result += char(ch_per);\n        }\n        \n        if((abs(number) > pow(10.0, float(i))) || i <= 0)\n        {\n            result += char(get_digit(digit));\n        }\n    } \n    return result;\n}\n\nfloat print_int(float number)\n{\n    float result = 0.0;\n    \n    for(int i = MAX_DIGIT;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || i == 0)\n        {\n            result += char(get_digit(digit));\n        }\n    }   \n    return result;\n}\n\n\nvec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}\n\nvec3 widgetSelected()\n{\n    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;\n}\nvec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}\nvec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}\n\nfloat roundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p) - b;\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    float d = (m.x > 0.0) ? length(q) : m.y; \n    return d - r;\n}\n\n\nvoid print_slider( int id, float v )\n{\n    vec2 puv = uv-vec2(.5);\n    vec3 select = widgetSelected();\n    float sl2 = SLIDER_LENGTH/2.;\n    vec4 value = uiSlider(id);\n    if(value.a == 0.)\n        value.r = v;\n    \n    //Check if value changed\n    bool selected = ( select.r == .1 && select.g*255. == float(id) );\n    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.; \n    \n    if(mouseAndNoSelect || selected)\n    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);\n\n    //Draw slider\n    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);\n    float layer = clamp(sign(-d),0.,1.);\n    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );\n    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );\n    col.a += layer + clamp( 1.-abs(d) , 0., 1.);\n    \n    //Draw value\n    float oldx = pos.x;\n    pos.x += SLIDER_LENGTH-8.*4.;\n    _float(value.r)\n    pos.x = oldx;\n    \n    //Save value\n    if(puv.x == float(id) && puv.y==0.)\n        col = vec4(value.r,0.,0.,1.);\n    \n    //Save selection\n    if(puv.x == 0. && puv.y == 2.)\n    {\n        if(iMouse.w<.5)\n            col = vec4(0.);\n        else if(mouseAndNoSelect)\n        \tcol = vec4(.1,float(id)/255.,0.,0.);\n    }\n}\nvoid print_color( int id, vec3 v)\n{\n    vec2 puv = uv-vec2(.5);\n    vec3 select = widgetSelected();\n    float sl2 = SLIDER_LENGTH/2.;\n    vec4 color = uiColor(id);\n    if(color.a == 0.)\n        color.rgb = v;\n    \n    //Check if value changed\n    bool selected = ( select.r == .2 && select.g*255. == float(id) );\n    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.; \n    \n    if(mouseAndNoSelect || selected)\n    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );\n\n    //Draw slider\n    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);\n    float layer = clamp(sign(-d),0.,1.);\n    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));\n    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );\n    col.a += layer + clamp( 1.-abs(d) , 0., 1.);\n    \n    if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)\n        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );\n    \n    \n    //Save value\n    if(puv.x == float(id) && puv.y==1.)\n        col = vec4(color.rgb,1.);\n    \n    //Save selection\n    if(puv.x == 0. && puv.y == 2.)\n    {\n        if(iMouse.w<.5)\n            col = vec4(0.);\n        else if(mouseAndNoSelect)\n        \tcol = vec4(.2,float(id)/255.,0.,0.);\n    }\n}\n\n\nvoid print_box(vec2 p, vec2 s, vec4 c)\n{\n    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)\n        col += c;\n}\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n\n//_[a..Z] : write a character at the position of the cursor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    \n    _box(vec2(10,10),vec2(148,iResolution.y-20.),vec4(0.,0.,0.,.25))\n    float t = mod(iTime,10.);\n    _cursor(42,30) _T _I _M _E _spc _spc _float(t)\n    _slider(20,50, 0, .75) _A\n    _slider(20,80, 1, 0.) _B\n    //_color (20,110, 0, vec3(1.,.7,.0)) _M _a _t _e _r _i _a _l _spc  _c _o _l _o _r\n    \n    fragColor = min(col.rgba,1.);\n}\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcSRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[480, 480, 504, 504, 706], [708, 708, 746, 746, 1114], [1116, 1116, 1185, 1185, 1239], [1241, 1241, 1262, 1262, 1370], [1372, 1372, 1429, 1479, 2493]], "test": "untested"}
{"id": "WlcSz4", "name": "Magnetic Field Lines #2", "author": "adasba", "description": "A modified version of my others \"magnetic field lines\" shader.", "tags": ["2d", "physics", "magnet"], "likes": 4, "viewed": 394, "published": 3, "date": "1580448886", "time_retrieved": "2024-07-30T21:27:04.703299", "image_code": "//I didn't make this. Credit to:\n//https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//I didn't make this either. Credit to:\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nconst int pointCount = 32;\n    \n#define PI 3.1415926535897932384626433832795\n    \nvec2 magneticField(vec3[pointCount] pts, vec2 position) {\n    vec2 netForce = vec2(0, 0);\n    for (int i = 0; pointCount > i; i++) {\n    \tnetForce += (position - pts[i].xy) / pow(distance(position, pts[i].xy), 3.0) * pts[i].z;\n    }\n    return netForce;\n}\n\nfloat modsign(float a, float b) {\n\treturn mod(a, b) * sign(a);\n}\n\nvec3 points[pointCount];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 m = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    \n    for (int i = 0; pointCount > i; i++) {\n        int pc = pointCount;\n    \tpoints[i] = vec3(0.0);\n        points[i].x = rand(vec2(i, i + pc)) + sin(iTime * rand(vec2(i + pc * 5, i + pc * 6)) * 0.25) * 0.6;\n        points[i].y = rand(vec2(i + pc * 2, i + pc * 3)) + sin(iTime * rand(vec2(i + pc * 7, i + pc * 8)) * 0.25) * 0.6;\n        points[i].z = rand(vec2(i + pc * 4)) * 2.0 - 1.0;\n    }\n    \n    points[1].x = m.x;\n    points[1].y = m.y;\n    points[1].z = -1.0;\n    \n    //points[0] = vec3(0.25, 0.25, 1.0);\n    \n    //points[2] = vec3(0.75, 0.75, 1.0);\n\t//points[1] = vec3(m.x, m.y, -1.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    vec2 mField = magneticField(points, uv);\n    float fieldMag = distance(vec2(0, 0), mField);\n    float fieldDir = atan(mField.y, mField.x);\n    //fragColor = vec4(log(fieldMag * 5.2) * 0.2, fieldDir / (2.0 * PI) + 0.5, 0.0, 1.0);\n    vec2 mField2 = magneticField(points, uv + vec2(0.005));\n    vec2 mDeriv = mField - mField2;\n    \n    float logmag2 = log(distance(vec2(0), mField2)) * 5.0;\n    \n    //fragColor = vec4(hsv2rgb(vec3(fieldDir / (PI * 2.0), 1.0, log(fieldMag * 20.0) * 0.1)), 1.0);\n    float logmag = log(fieldMag) * 5.0;\n    //float threshold = pow(distance(vec2(0.0), mDeriv), 0.33);\n    //float col = (mod(5.0 * logmag, 2.0) > threshold) ? 0.0 : 1.0;\n    float col = (abs(mod(logmag, 2.0) - mod(logmag2, 2.0)) > 1.0) ? 1.0 : 0.0;\n    fragColor = vec4(hsv2rgb(vec3(fieldDir / (PI * 2.0), 1.0, col)), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcSz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 87, 109, 109, 278], [280, 398, 418, 418, 490], [832, 832, 865, 865, 896], [925, 925, 982, 982, 2730]], "test": "untested"}
{"id": "WlcXR4", "name": "Fractal.4", "author": "gaetanThiesson", "description": "Old fractal exploration for CineShader", "tags": ["fractal", "cineshader"], "likes": 20, "viewed": 27661, "published": 3, "date": "1580444051", "time_retrieved": "2024-07-30T21:27:05.450302", "image_code": "vec2 f(vec2 x, vec2 c) {\n    return mat2(x,-x.y,x.x)*x + c;\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;uv *= 1.3;uv += 0.5;\n    vec4 col = vec4(1.0);\n    float time = iTime;\n    \n    int u_maxIterations = 75;\n    \n    float r = 0.7885*(sin((time/3.) - 1.57)*0.2+0.85);\n\tvec2 c = vec2(r*cos((time/3.)), r*sin((time/3.)));\n    \n    vec2 z = vec2(0.);\n    z.x = 3.0 * (uv.x - 0.5);\n    z.y = 2.0 * (uv.y - 0.5);\n    bool escaped = false;\n    int iterations;\n    for (int i = 0; i < 10000; i++) {\n        if (i > u_maxIterations) break;\n        iterations = i;\n        z = f(z, c);\n        if (dot(z,z) > 4.0) {\n            escaped = true;\n            break;\n        }\n    }\n\t\t\t\n    vec3 iterationCol = vec3(palette(float(iterations)/ float(u_maxIterations),\n                                     vec3(0.5),\n                                     vec3(0.5),\n                                     vec3(1.0, 1.0, 0.0),\n                                     vec3(0.3 + 0.3 * sin(time),\n                                          0.2 + 0.2 * sin(1. + time),\n                                          0.2  + 0.2 * sin(1.5 + time))));\n\t\t\n\tvec3 coreCol = vec3(0.);\n\t\n    float f_ite = float(iterations);\n    float f_maxIte = float(u_maxIterations);\n    fragColor = vec4(escaped ? iterationCol : coreCol, f_ite/f_maxIte );\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Fractal.4\",\n\t\"description\": \"Old fractal exploration https://codepen.io/gThiesson/pen/PowYRqg\",\n\t\"model\": \"nothing\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 61], [63, 63, 118, 118, 161], [163, 163, 220, 220, 1478]], "test": "untested"}
{"id": "3lcXR4", "name": "Magnetic Field Lines", "author": "adasba", "description": "These are magnetic fields with random charges, both positive and negative. Lines and colors are determined by the direction of the force acting on a particle at that point.", "tags": ["2d", "physics", "magnet"], "likes": 7, "viewed": 645, "published": 3, "date": "1580443692", "time_retrieved": "2024-07-30T21:27:06.508472", "image_code": "//I didn't make this. Credit to:\n//https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//I didn't make this either. Credit to:\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nconst int pointCount = 32;\n    \n#define PI 3.1415926535897932384626433832795\n    \nvec2 magneticField(vec3[pointCount] pts, vec2 position) {\n    vec2 netForce = vec2(0, 0);\n    for (int i = 0; pointCount > i; i++) {\n    \tnetForce += (position - pts[i].xy) / pow(distance(position, pts[i].xy), 3.0) * pts[i].z;\n    }\n    return netForce;\n}\n\nfloat modsign(float a, float b) {\n\treturn mod(a, b) * sign(a);\n}\n\nvec3 points[pointCount];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 m = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    \n    for (int i = 0; pointCount > i; i++) {\n        int pc = pointCount;\n    \tpoints[i] = vec3(0.0);\n        points[i].x = rand(vec2(i, i + pc)) + sin(iTime * rand(vec2(i + pc * 5, i + pc * 6)) * 0.25) * 0.6;\n        points[i].y = rand(vec2(i + pc * 2, i + pc * 3)) + sin(iTime * rand(vec2(i + pc * 7, i + pc * 8)) * 0.25) * 0.6;\n        points[i].z = rand(vec2(i + pc * 4)) * 2.0 - 1.0;\n    }\n    \n    points[1].x = m.x;\n    points[1].y = m.y;\n    points[1].z = -1.0;\n    \n    //points[0] = vec3(0.25, 0.25, 1.0);\n    \n    //points[2] = vec3(0.75, 0.75, 1.0);\n\t//points[1] = vec3(m.x, m.y, -1.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    vec2 mField = magneticField(points, uv);\n    float fieldMag = distance(vec2(0, 0), mField);\n    float fieldDir = atan(mField.y, mField.x);\n    //fragColor = vec4(log(fieldMag * 5.2) * 0.2, fieldDir / (2.0 * PI) + 0.5, 0.0, 1.0);\n    vec2 mDeriv = mField - magneticField(points, uv + vec2(0.0001));\n    \n    //fragColor = vec4(hsv2rgb(vec3(fieldDir / (PI * 2.0), 1.0, log(fieldMag * 20.0) * 0.1)), 1.0);\n    float logmag = log(fieldMag);\n    //float threshold = (1.0 / (1.0 + pow(3.0, -logmag)));\n    float threshold = pow(distance(vec2(0.0), mDeriv), 0.33);//pow((pow(2.0, 0.333) / (1.0 + pow(2.0, -distance(vec2(0.0), mDeriv)))), 3.0);\n    //vec3 col = vec3((mod(logmag * 4.0, 2.0) > threshold * 0.5) ? 0.0 : 1.0);\n    float col = (mod(fieldDir / PI * 24.0, 2.0) > threshold * 0.5) ? 0.0 : 1.0;\n    fragColor = vec4(hsv2rgb(vec3(fieldDir / (PI * 2.0), 1.0, col)), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 87, 109, 109, 278], [280, 398, 418, 418, 490], [832, 832, 865, 865, 896], [925, 925, 982, 982, 2781]], "test": "untested"}
{"id": "wldSzH", "name": "Slapping Fractal (mandelbrot)", "author": "hazenn", "description": "Just tinkering with the mandelbrot set to learn glsl", "tags": ["fractal"], "likes": 2, "viewed": 291, "published": 3, "date": "1580424223", "time_retrieved": "2024-07-30T21:27:07.400088", "image_code": "//made by hazenn :p\nconst float PI = 3.14159265358979;\nvec2 cmpxcjg(in vec2 c) {\n\treturn vec2(c.x, -c.y);\n}\n\nvec2 cmpxmul(in vec2 a, in vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 cmpxpow(in vec2 c, int p) {\n    vec2 temp = vec2(1.0,0.0);\n\tfor (int i = 0; i < p; ++i) {\n\t\ttemp = cmpxmul(temp, c);\n\t}\n    return temp;\n}\n\nvec2 cmpxdiv(in vec2 a, in vec2 b) {\n    return cmpxmul(a, cmpxcjg(b));\n}\n\nfloat cmpxmag(in vec2 c) {\n    return sqrt(c.x * c.x + c.y * c.y);\n}\n\nvec2 uv_scaled(vec2 uv, vec2 top_left, vec2 bot_right)\n{\n    return mix(top_left.xy,bot_right.xy,uv.xy);\n}\nfloat F (float x)\n{\n\treturn (cos(PI * (x+1.0))+1.0)/2.0;\n}\nfloat mandelbrot(vec2 c, int n)\n{\n    vec2 z = vec2(0,0);\n    for (int i = 0; i < n;i++)\n    {\n        if (sqrt(z.x*z.x + z.y*z.y)  > 2.0)\n        {\n            return (1.0-float(i)/float(n));\n\t\t}\n        z = cmpxmul(z,z) + c;\n        \n    }\n    return 0.0;\n}\nvec2 f(vec2 c,vec2 z, float t)\n{\n    //the function used to define the sequence\n\treturn cmpxpow(z,3) * t + cmpxpow(c,1) + t * z;\n}\nfloat fractal(vec2 c, int n, float t)\n{\n    vec2 z = vec2(0,0);\n    for (int i = 0; i < n;i++)\n    {\n        if (sqrt(z.x*z.x + z.y*z.y)  > 2.0)\n        {\n            return (1.0-float(i)/float(n));\n\t\t}\n        z = f(c,z,t);\n        \n    }\n    return 0.0;\n}\nvec3 colorA = vec3(0.03137254901,0.05882352941,0.05882352941);\nvec3 colorB = vec3(0.6431372549,0.7294117647,0.7294117647);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 c = uv_scaled(uv,vec2(-1.5,1.5),vec2(1.5,-1.5));\n    vec3 col = vec3(0.0,0.0,0.0);\n    col = mix(colorA,colorB,F(fractal(c,200,sin(iTime))));\n    //col.x = c.x;\n    //col.y = c.y;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldSzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 80, 80, 107], [109, 109, 145, 145, 207], [209, 209, 241, 241, 352], [354, 354, 390, 390, 427], [429, 429, 455, 455, 497], [499, 499, 555, 555, 605], [606, 606, 625, 625, 664], [665, 665, 698, 698, 924], [925, 925, 957, 1004, 1055], [1056, 1056, 1095, 1095, 1313], [1437, 1437, 1494, 1544, 1827]], "test": "untested"}
{"id": "wltXR8", "name": "Day 42 - Part 2", "author": "jeyko", "description": "code messy yo", "tags": ["mdtmjvm"], "likes": 5, "viewed": 387, "published": 3, "date": "1580418109", "time_retrieved": "2024-07-30T21:27:08.483192", "image_code": "// Fork of \"Day 42 - Magma\" by jeyko. https://shadertoy.com/view/WltXR8\n// 2020-01-30 18:18:08\n\n//Code is messy!\n// Kinda looked better with no post hmm\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec4 tA = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 tB = texture(iChannel0, fragCoord/iResolution.xy, 6.);\n             \n    //tB = pow(tB*1., vec4(4.));\n    tB = smoothstep(0.,2.,tB);\n    fragColor = tA +tB*2.6;\n    fragColor *= 1.2;\n    fragColor = smoothstep(0.,1.,fragColor);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 r22(vec2 x){return vec2(\n\tfract(sin(x.y*213.124)*214.),\n\tfract(sin(x.x*513.524)*614.5)\n);}\nfloat voronoi (vec2 uv){\n    vec2 fuv = fract(uv) - 0.5;\n    vec2 uvid = floor(uv);\n    \n    vec2 me = r22(uvid);\n    vec2 u = r22(uvid + vec2(0,1)) + vec2(0,1);\n    vec2 d = r22(uvid - vec2(0,1)) - vec2(0,1);\n    vec2 l = r22(uvid - vec2(1,0)) - vec2(1,0);\n    vec2 r = r22(uvid + vec2(1,0)) + vec2(1,0);\n    \n    vec2 ul = r22(uvid + vec2(1,-1))+ vec2(1,-1);\n    vec2 ur = r22(uvid + vec2(1,1))+ vec2(1,1);\n    vec2 dl = r22(uvid + vec2(-1,-1))+ vec2(-1,-1);\n    vec2 dr = r22(uvid + vec2(-1,1)) + vec2(-1,1);\n    \n    vec3 col = vec3(0);\n\n    \n    float Di = distance(me,fuv);\n    float Du = distance(u,fuv);\n    float Dd = distance(d,fuv);\n    float Dl = distance(l,fuv);\n    float Dr = distance(r,fuv);\n    \n    float Dul = distance(ul,fuv);\n    float Dur = distance(ur,fuv);\n    float Ddl = distance(dl,fuv);\n    float Ddr = distance(dr,fuv);\n    \n    \n    float ddd = min(Di, Du);\n    ddd = min(ddd, Dd);\n    ddd = min(ddd, Dl);\n    ddd = min(ddd, Dr);\n    \n    ddd = min(ddd, Dul);\n    ddd = min(ddd, Dur);\n    ddd = min(ddd, Ddl);\n    ddd = min(ddd, Ddr);\n    \n    float c =  ddd;\n    \n    return  c;\n}", "buffer_a_code": "\nvec3 glow = vec3(0);\n#define fov 0.9\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt -ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + right*uv.x*fov + up*uv.y*fov);\n    //return (dir + right*uv.x*fov + up*uv.y*fov);\n}\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define mx (iTime*0.5 + 10.*iMouse.x/iResolution.y)\n\nfloat w = 0.;\n\n#define ITERS 4\n#define pmod(p, x) mod(p,x) - 0.5*x\nfloat[] WS = float[ITERS](1.,1.,1.,1.);\n\nfloat id;\nvec2 map(vec3 q){\n\tvec2 d = vec2(10e5);\n    #define repD 3.7\n    \n    id = floor(q.z/repD);\n\tq.z = pmod(q.z, repD);\n    q.xy -= 2.;\n\tq.xy = pmod(q.xy, 4.);\n    #define ZOOM 4.\n    //d.x = min(d.x, length(p) - 0.);\n    \n    vec4 p = vec4(q.xyz, 1.);\n    vec4 c = vec4(0.5,1.,0.4,0.);\n    vec4 u = vec4(0.4,0.44,0.7,0.4);\n    \n    \n    for(int i = 0; i < ITERS; i++){\n        p.xyz = abs(p.xyz) - vec3(0.78,0.9,0.4 + sin(id)*0.0);\n        float dpp = dot(p.xyz,p.xyz);\n        p=p*(1.5 + u)/clamp(dpp,.4,1.)-c;\n\t\t\n        p.xy *= rot(-0.8 + sin(id)*0.7);\n        if(i < 2)\n        \tp.z -= 0.5;\n        WS[i] = p.w;\n    }\n    w = p.z;\n    p.xyz = abs(p.xyz);\n    \n    p.xz *= rot(0.2);\n    float fr =  max(p.x - 0., max(p.y - 2.4 + sin(id)*0.7, p.z - 2.9))/p.w;\n    d.x = min(d.x, fr );\n\n    d.x *= 0.5;\n\treturn d;\n}\n\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\t\n    vec2 d = vec2(10e5);\n    hit = false;\n    t = 0.;\n    p = ro;\n    for(int i = 0; i < 180 ; i++){\n    \td = map(p);\n        \n        glow += exp(-d.x*20.);\n        \n        if(d.x < 0.001){\n            hit = true;\n        \tbreak;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    /*\n    vec3 ro = vec3(0,1,0);\n\n    ro.x += sin(iTime)*ZOOM;\n    ro.z += cos(iTime)*ZOOM;\n    */\n    uv.xy *= rot(iTime*0.1);\n    vec3 ro = vec3(0);\n    ro.z += mx;\n    bool hit;\n    vec3 lookAt = vec3(0.001);\n    lookAt.z = ro.z + 2.;\n    //lookAt.y -= 0.7;\n    uv *= 1. + dot(uv,uv)*0.9;\n    vec3 rd = getRd(ro, lookAt, uv);\n    vec3 p; float t;\n    vec2 d = march( ro, rd,p,t, hit);\n\n    vec3 CA, CB, CC, CD;\n    if (hit){\n        vec3 lD = normalize(vec3(1));\n        vec3 h = normalize(lD - rd);\n        vec3 n = getNormal(p);\n        float diff = max(dot(n,lD),0.);\n        float spec = pow(max(dot(n,h),0.), 50.);\n        float fres = pow(1. - max(dot(n,-rd),0.), 5.);\n        //diff = w*0.1;\n        CA = vec3(0.2,0.0,0.2)*(pow(1. - WS[0]*(0.15 + sin(id*1.5)*0.1), 7.));\n         CB = vec3(1.,1,0.4 + sin(iTime)*0.2)*pow(WS[1]*0.05, 4.);\n         CC = vec3(0.,0.4,0.2)*pow(WS[2]*0.02, 2.);\n         CD = vec3(0.9,0.4,0.2 + 0.2*abs(sin(id*0.1 - 0.2)))*pow(WS[3]*0.01, 2.);\n        \n        vec3 C =  CD + CC - CB + CA*0.5;\n    \tcol += mix(C, spec*vec3(1.0,.7,.1)*1., 0.3);\n        col += diff*0.1;\n        \n    }\n    vec3 g = glow*pal(0.2,0.5,vec3(2.9,5.4,0.7),0.5,4.7  - t*0.1 );\n    \n    //col = mix(col, vec3(0.8,1,1)*0.2,smoothstep(0.,1.,t*0.08 ));\n    //col *= 2.0;\n    col *= 1.8;\n    col = smoothstep(0.,1.,col);\n    //col = smoothstep(0.,0.4,col);\n\n    col = clamp(col*1., 0., 1.);\n    //col *= 1.;\n    col = pow(col, vec3(0.45));\n    col = mix(col, vec3(0.9,1,0.8)*0.2,smoothstep(0.,1.,t*0.08 ));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltXR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 212, 212, 521]], "test": "untested"}
{"id": "tl3Sz8", "name": "Triangulation!", "author": "wyatt", "description": "I did it :D That was a good challenge. This will allow for some cool things...\n\nThe trick was to use the perpendicular bisector distance normalized to the length of the segment. \n\nA lot of wrong guesses came first!", "tags": ["triangulation"], "likes": 9, "viewed": 434, "published": 3, "date": "1580415834", "time_retrieved": "2024-07-30T21:27:09.697944", "image_code": "Main {\n    vec4 bb = B(U), cc = C(U),\n         a = A(bb.xy), b = A(cc.xy);\n\tQ = smoothstep(5.,6.,length(U-a.xy))*vec4(1);\n\tQ *= smoothstep(0.,1.,sg(U,a.xy,b.xy))*vec4(1);\n\tQ *= smoothstep(1.,2.,mp(U,a.xy,b.xy)*length(a.xy-b.xy))*vec4(1);\n\tQ.xy *= 0.5+0.5*cc.xy/R;\n    Q.yz *= 0.5+0.5*bb.xy/R;\n   \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,floor(U)/R)\n#define B(U) texture(iChannel1,floor(U)/R)\n#define C(U) texture(iChannel2,floor(U)/R)\n#define D(U) texture(iChannel3,floor(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nfloat mp (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b);\n    if (length(a-b)<1e-3) return 1e3;\n    float o = (dot(p-m,b-m))/dot(b-m,b-m);\n\tfloat x = abs(o*length(b-m)), y = length(p-m-(b-m)*clamp(o,-1.,1.));\n\treturn x/length(a-b);\n}", "buffer_a_code": "// Information Storage\nMain {\n\tQ = A(U);\n    \n    if (iMouse.z<1.) Q.xy += .25*Q.zw+.1*sin(.1*Q.yx*vec2(-1,1));\n    \n    \n    if (Q.x<2.) {Q.x = 2.; Q.z *= -1.;}\n    if (R.x-Q.x<2.) {Q.x = R.x-2.; Q.z *= -1.;}\n    if (Q.y<2.) {Q.y = 2.; Q.w *= -1.;}\n    if (R.y-Q.y<2.) {Q.y = R.y-2.; Q.w *= -1.;}\n    \n    \n    Init {\n    \tU = floor(U/50.+0.5)*50.;\n        Q = vec4(U,1,1);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Nearest Individual\nvoid X (inout vec4 Q, inout vec4 a, vec2 U, vec2 r) {\n    vec4 b = B(U+r);\n    vec4 n = A(b.xy);\n    if (length(n.xy-U)<length(a.xy-U)) {\n    \tQ = b;\n        a = n;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, vec2 U, float r) {\n\t X(Q,a,U,vec2(r,0));\n     X(Q,a,U,vec2(0,r));\n     X(Q,a,U,vec2(0,-r));\n     X(Q,a,U,vec2(-r,0));\n}\nMain {\n\tQ = B(U);\n    vec4 a = A(Q.xy);\n    Xr(Q,a,U,1.);\n    Xr(Q,a,U,2.);\n    Xr(Q,a,U,4.);\n    Xr(Q,a,U,8.);\n    Init {\n    \tQ = A(U);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Nearest Normalized Bisector\nvoid X (inout vec4 Q, inout vec4 a, inout vec4 b, vec2 U, vec2 r) {\n    vec4 Qn = C(U+r), qn = B(U+r), na = A(qn.xy), nb = A(Qn.xy);\n   \tfloat l = mp(U,a.xy,b.xy);\n    \n    if (mp(U,a.xy,na.xy)<l) {\n    \tQ = qn;\n        b = na;\n    }\n    if (mp(U,a.xy,nb.xy)<l) {\n        Q = Qn;\n        b = nb;\n    }\n}\nvoid Xr (inout vec4 Q, inout vec4 a, inout vec4 b, vec2 U, float r) {\n\t X(Q,a,b,U,vec2(r,0));\n     X(Q,a,b,U,vec2(0,r));\n     X(Q,a,b,U,vec2(0,-r));\n     X(Q,a,b,U,vec2(-r,0));\n}\nMain {\n\tQ = C(U);\n    vec4 q = B(U),\n         a = A(q.xy),\n         b = A(Q.xy);\n    Xr (Q,a,b,U,1.);\n    Xr (Q,a,b,U,2.);\n    Xr (Q,a,b,U,4.);\n    Xr (Q,a,b,U,8.);\n    \n    Init Q = A(U);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3Sz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wttXz8", "name": "Domain warped FBM noise", "author": "liamegan", "description": "FBM noise domain warped several times", "tags": ["noise", "fbm", "warped", "cineshader"], "likes": 60, "viewed": 47590, "published": 3, "date": "1580414943", "time_retrieved": "2024-07-30T21:27:10.852856", "image_code": "\n\n\n\n\n\n\n    const int octaves = 6;\n\n\n\n    vec2 random2(vec2 st){\n      vec2 t = vec2(texture(iChannel0, st/1023.).x, texture(iChannel0, st/1023.+.5).x);\n      return t*t*4.;\n    }\n\n    // Value Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/lsf3WH\n    float noise(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        vec2 u = f*f*(3.0-2.0*f);\n\n        return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                         dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                         dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n  \n    float fbm1(in vec2 _st) {\n      float v = 0.0;\n      float a = 0.5;\n      vec2 shift = vec2(100.0);\n      // Rotate to reduce axial bias\n      mat2 rot = mat2(cos(0.5), sin(0.5),\n                      -sin(0.5), cos(0.50));\n      for (int i = 0; i < octaves; ++i) {\n          v += a * noise(_st);\n          _st = rot * _st * 2.0 + shift;\n          a *= 0.4;\n      }\n      return v;\n    }\n  \n    float pattern(vec2 uv, float time, inout vec2 q, inout vec2 r) {\n\n      q = vec2( fbm1( uv * .1 + vec2(0.0,0.0) ),\n                     fbm1( uv + vec2(5.2,1.3) ) );\n\n      r = vec2( fbm1( uv * .1 + 4.0*q + vec2(1.7 - time / 2.,9.2) ),\n                     fbm1( uv + 4.0*q + vec2(8.3 - time / 2.,2.8) ) );\n\n      vec2 s = vec2( fbm1( uv + 5.0*r + vec2(21.7 - time / 2.,90.2) ),\n                     fbm1( uv * .05 + 5.0*r + vec2(80.3 - time / 2.,20.8) ) ) * .25;\n\n      return fbm1( uv * .05 + 4.0 * s );\n    }\n\n\n  vec2 getScreenSpace() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    return uv;\n  }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = getScreenSpace();\n\n      \n      float time = iTime / 10.;\n      \n      mat2 rot = mat2(cos(time / 10.), sin(time / 10.),\n                      -sin(time / 10.), cos(time / 10.));\n      \n      uv = rot * uv;\n      uv *= 0.9 * (sin(time)) + 3.;\n      uv.x -= time / 5.;\n      \n      vec2 q = vec2(0.,0.);\n      vec2 r = vec2(0.,0.);\n      \n      float _pattern = 0.;\n      \n      \n    _pattern = pattern(uv, time, q, r);\n    \n      vec3 colour = vec3(_pattern) * 2.;\n      colour.r -= dot(q, r) * 15.;\n      colour = mix(colour, vec3(pattern(r, time, q, r), dot(q, r) * 15., -0.1), .5);\n      colour -= q.y * 1.5;\n      colour = mix(colour, vec3(.2, .2, .2), (clamp(q.x, -1., 0.)) * 3.);\n      \n      fragColor = vec4(-colour + (abs(colour) * 2.), 1./length(q));\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Domain Warped FBM noise\",\n\t\"description\": \"\",\n\t\"model\": \"person\"\n}\n*/\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttXz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 63, 63, 178], [184, 274, 296, 296, 734], [742, 742, 767, 767, 1129], [1137, 1137, 1201, 1201, 1648], [1653, 1653, 1676, 1676, 1792], [1793, 1793, 1850, 1900, 2677]], "test": "untested"}
{"id": "tttXR8", "name": "Highly suspicious", "author": "samhattangady", "description": "The blending led to this. Simplest emotion I could think of.\nNeed to work on the lighting in the eyes. \n\nOn Android chrome, (and maybe other platforms), eyes are not \nrendering correctly. They move along with the light, and not with\nthe head. Any guidance", "tags": ["3d", "animation", "face"], "likes": 6, "viewed": 545, "published": 3, "date": "1580407579", "time_retrieved": "2024-07-30T21:27:12.074590", "image_code": "/*\nday004: \n30 Jan 2020\n\nThe blending led to this. Simplest emotion I could think of.\nNeed to work on the lighting in the eyes. Want to make that\na little more \"glossy\"? Also shadows may help.\n\n*/\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\n\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\nfloat sdfEllipsoid(vec3 position, vec3 center, vec3 radii) {\n    position -= center;\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfEllipsoidRotated(vec3 position, vec3 center, vec3 radii, vec3 rotation) {\n\tposition -= center;\n    position = rotate3D(position, rotation);\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdfPlane( vec3 position, vec4 n ) {\n    return dot(position, normalize(n.xyz)) + n.w;\n}\nfloat sdfRoundBoxRotated(vec3 position, vec3 center, vec3 box, vec3 rotation, float radius) {\n    position -= center;\n    position = rotate3D(position, rotation);\n    vec3 q = abs(position) - box;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\n\nfloat dot2(vec2 v) {\n\treturn dot(v, v);\n}\nvec4 sdfJoint3DSphere(vec3 position, vec3 start, vec3 rotation, float len, float angle, float thickness) {\n    vec3 p = position;\n    float l = len;\n    float a = angle;\n    float w = thickness;\n    p -= start;\n    p = rotate3D(p, rotation);\n\n    \n    if( abs(a)<0.001 ) {\n        return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    }\n    \n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    p.x -= ra;\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n               (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n               (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n               p.z );\n}\n\nfloat smin(float d1, float d2, float k) {\n    //float res = exp2( -k*d1 ) + exp2( -k*d2 );\n    //return -log2( res )/k;\n    \n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\nfloat smax(float d1, float d2, float k) {  \n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n}\n\nfloat pow5Timing(float i) {\n\tfloat cosPiCycle = -1.0 + 2.0*step(0.0, cos(i*3.14159));\n    float sin2PiCycle = -1.0 + 2.0*step(0.0, sin(i*3.14159*2.0));\n    float pow5 = 1.0 - (pow(fract(i*2.0*sin2PiCycle), 6.0));\n    return pow5 * cosPiCycle;\n}\n\nvec4 faceField(vec3 position) {\n    float animTime = sin(iTime*1.8);\n    float lagAnimTime = sin((iTime-0.1)*1.8);\n    //float posTiming = (abs(animTime) / animTime) * abs(pow(animTime, 0.4));\n    //float lagTiming = (abs(lagAnimTime) / lagAnimTime) * abs(pow(lagAnimTime, 0.4));\n    \n    float speedUp = 0.6;\n    float posTiming = pow5Timing(iTime*speedUp);\n    float lagTiming = pow5Timing((iTime-0.1)*speedUp);\n    position = rotate3D(position, vec3(-0.1+(abs(lagTiming)*0.1), 0.0+(0.13*lagTiming), 0.0));\n\tvec3 symPosX = vec3(abs(position.x), position.yz);\n    float material = 1.0;\n    \n    float d = sdfSphere(position, vec3(0.0), 0.55);\n    float d1 = sdfSphere(position, vec3(0.0, -0.55, -.15), 0.4);\n    d = smin(d, d1, 0.5);   \n    // brow\n    d1 = sdfEllipsoid(position, vec3(0.0, 0.04, -0.35), vec3(0.35, 0.2, 0.2));\n    d = smin(d, d1, 0.1);\n    // eye socket\n    d1 = sdfSphere(symPosX, vec3(0.4, -0.08, -.55), 0.1);\n    d = smax(d, -d1, 0.3);\n    \n    \n    // right eyebrow\n    d1 = sdfJoint3DSphere(position, vec3(-0.15, 0.03+(0.05*lagTiming), -0.535+(0.015*lagTiming)), vec3(0.5, 0.0, 1.75), 0.2-(0.05*lagTiming), 0.4, 0.01).x;\n    d = smin(d, d1, 0.2);\n    // left eyebrow\n    d1 = sdfJoint3DSphere(position, vec3(0.15, 0.03-(0.05*lagTiming), -0.535-(0.015*lagTiming)), vec3(0.5, 0.0, -1.75), 0.2+(0.05*lagTiming), -0.4, 0.01).x;\n    d = smin(d, d1, 0.2);\n    \n    \n    // bottom eyebrow?\n    d1 = sdfJoint3DSphere(symPosX, vec3(0.2, -0.25, -0.48), vec3(0.52, 0.0, -1.95), 0.15, -0.4, 0.001).x;\n    d = smin(d, d1, 0.22);\n    \n    \n    // nose\n    d1 = sdfEllipsoidRotated(position, vec3(0.0, -0.28, -0.55), vec3(0.07, 0.15, 0.1), vec3(3.14159/4.0, 0.0, 0.0));\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.28, -0.49), vec3(0.03, 0.19, 0.1), vec3(3.14159/6.0, 0.0, 0.0), 0.02);\n    d = smin(d, d1, 0.1);\n    \n    // eye\n    d1 = sdfSphere(symPosX, vec3(0.18, -0.12, -.38), 0.2);\n    if (d1 < d) {\n    \td = d1;\n        material = 2.0;\n    }\n    // iris\n    vec3 irisPos = position;\n    irisPos.x += posTiming * 0.06;\n    d1 = sdfSphere(irisPos, vec3(0.23, -0.12, -0.545), 0.06);\n    if (d1 < d) {\n    \td = d1;\n        material = 3.0;\n    }\n    d1 = sdfSphere(irisPos, vec3(-0.23, -0.12, -0.545), 0.06);\n    if (d1 < d) {\n    \td = d1;\n        material = 3.0;\n    }\n    return vec4(d, material, 0.0, 0.0);\n}\n\nvec4 distanceField(vec3 position) {\n\tvec4 d = faceField(position);\n    return d;\n}\n\nvec3 calcNormal( vec3 p ) \n{\n    // We calculate the normal by finding the gradient of the field at the\n    // point that we are interested in. We can find the gradient by getting\n    // the difference in field at that point and a point slighttly away from it.\n    const float h = 0.0001;\n    return normalize( vec3(\n        \t\t\t       -distanceField(p).x+ distanceField(p+vec3(h,0.0,0.0)).x,\n                           -distanceField(p).x+ distanceField(p+vec3(0.0,h,0.0)).x,\n                           -distanceField(p).x+ distanceField(p+vec3(0.0,0.0,h)).x \n    \t\t\t\t ));\n}\n\nvec4 raymarch(vec3 direction, vec3 start) {\n    // We need to cast out a ray in the given direction, and see which is\n    // the closest object that we hit. We then move forward by that distance,\n    // and continue the same process. We terminate when we hit an object\n    // (distance is very small) or at some predefined distance.\n    float far = 15.0;\n    vec3 pos = start;\n    float d = 0.0;\n    vec4 obj = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i=0; i<100; i++) {\n    \tobj = distanceField(pos);\n        float dist = obj.x;\n        pos += dist*direction;\n        d += dist;\n        if (dist < 0.01) {\n        \tbreak;\n        }\n        if (d > far) {\n        \tbreak;\n        }\n    }\n    return vec4(d, obj.yzw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalise and set center to origin.\n    vec2 p = fragCoord/iResolution.xy;\n    p -= 0.5;\n    p.y *= iResolution.y/iResolution.x;\n    \n    float mouseX = ((iMouse.x/iResolution.x)-0.5) * 2.0 * 3.14159/2.0;\n    mouseX = 0.0;\n    vec3 cameraPosition = vec3(0.0, 0.0, -3.0);\n    vec3 planePosition = vec3(p, 1.0) + cameraPosition;\n\n    mat2 camRotate = mat2(cos(mouseX), -sin(mouseX), sin(mouseX), cos(mouseX));\n    cameraPosition.xz = camRotate * cameraPosition.xz;    \n    planePosition.xz = camRotate * planePosition.xz;    \n    vec3 lookingDirection = (planePosition - cameraPosition);\n    \n    // This was fun to sort out, but is it the best way?\n    float lightTime = iTime/3.0;\n    float multiplier = -1.0 + (step(-0.0, sin(lightTime*3.14159)) *2.0);\n    float parabola = (4.0 * fract(lightTime) * (1.0-fract(lightTime)));\n    float lightX = multiplier*parabola *-1.2;\n    vec3 lightPoint = normalize(vec3(lightX, 1.0, -1.0));\n    vec3 lightFacing = lightPoint - vec3(0.0);\n    //lightFacing = vec3(1.0, 1.0, -0.3) - vec3(0.0);\n    \n    // raymarch to check for colissions.\n    vec4 obj = raymarch(lookingDirection, planePosition);\n    float dist = obj.x;\n    vec3 color = vec3(0.01);\n    if (dist < 15.0) {\n        vec3 normal = calcNormal(planePosition+ dist*lookingDirection);\n        float light = dot(lightFacing, normal);\n        light = max(light, 0.0);\n        if (obj.y < 1.5) {\n            // skin\n        \tcolor = vec3(0.505, 0.205, 0.105);\n            color += 0.4* smoothstep(0.3, 1.0, light);\n        } else if (obj.y < 2.5) {\n            //eyes\n        \tcolor = vec3(0.55, 0.55, 0.65);\n            color += 0.3 * smoothstep(0.5, 1.0, light);\n            color += 0.7 * pow(light, 15.0);\n        } else if (obj.y < 3.5) {\n        \tcolor = vec3(0.01);\n            color += 0.7 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        }\n    }\n    \n    // gamma correction\n    color = pow( color, vec3(1.0/2.2) );\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttXR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 197, 239, 239, 684], [686, 686, 745, 745, 795], [796, 796, 856, 856, 995], [996, 996, 1078, 1078, 1259], [1261, 1261, 1302, 1302, 1354], [1355, 1355, 1448, 1448, 1626], [1628, 1628, 1648, 1648, 1669], [1670, 1670, 1776, 1776, 2448], [2450, 2450, 2491, 2569, 2650], [2651, 2651, 2692, 2692, 2770], [2772, 2772, 2799, 2799, 3016], [3018, 3018, 3049, 3049, 5345], [5347, 5347, 5382, 5382, 5429], [5431, 5431, 5459, 5691, 6005], [6007, 6007, 6050, 6339, 6723], [6725, 6725, 6782, 6825, 8744]], "test": "untested"}
{"id": "wtdSR8", "name": "Parallax view on Cineshader", "author": "edankwan", "description": "It uses the iCamPos for parallax view but it cause issues on the reflection. Still fun to mess with it though. [url]https://cineshader.com/view/wtdSR8[/url]", "tags": ["cineshader"], "likes": 33, "viewed": 256065, "published": 3, "date": "1580405870", "time_retrieved": "2024-07-30T21:27:12.936286", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opRep( in vec3 p, in vec3 c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat map(vec3 p)\n{\n    p.z += 5.0;\n    p = opRep(p, vec3(4.0), vec3(1.0));\n    return sdBox(p, vec3(1.0));\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // use different camera setting for CineShader\n    #ifdef IS_CINESHADER\n    \n    // use the relative position of the camera to the center of the screen as ray origin\n\tvec3 rayOri = iCamPos;\n    \n    // screen size is 6m x 6m, or you can use iScreenSize.xy(CineShader only) to get the screen size\n\tvec3 rayDir = normalize(vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 0.0) - iCamPos);\n    \n    // make the maxDepth further\n    float maxDepth = 30.0;\n    #else\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n    float maxDepth = 6.0;\n    #endif\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(maxDepth, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth / maxDepth );\n\t\n    #ifdef IS_CINESHADER\n    // set the screen thickness to zero in CineShader\n    fragColor = vec4(col, 0.0);\n    #else\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n    #endif\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Parallax view on Cineshader\",\n\t\"description\": \"It uses the iCamPos for parallax view but it cause issues on the reflection. Still fun to mess with it though.\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 118], [120, 120, 166, 166, 207], [209, 209, 228, 228, 318], [320, 320, 350, 350, 632], [634, 634, 691, 691, 2038]], "test": "untested"}
{"id": "WldXRH", "name": "Truchet Tiles Test", "author": "tonywu", "description": "for test", "tags": ["cineshader"], "likes": 6, "viewed": 16824, "published": 3, "date": "1580400667", "time_retrieved": "2024-07-30T21:27:13.963539", "image_code": "#define PI 3.14159265358979323846\n\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 rotateTilePattern(vec2 _st){\n\n    //  Scale the coordinate system by 2x2\n    _st *= 2.0;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(_st.x,2.0));\n    index += step(1., mod(_st.y,2.0))*2.0;\n\n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n\n    // Make each cell between 0.0 - 1.0\n    _st = fract(_st);\n\n    // Rotate each cell according to the index\n    if(index == 1.0){\n        //  Rotate cell 1 by 90 degrees\n        _st = rotate2D(_st,PI*0.5);\n    } else if(index == 2.0){\n        //  Rotate cell 2 by -90 degrees\n        _st = rotate2D(_st,PI*-0.5);\n    } else if(index == 3.0){\n        //  Rotate cell 3 by 180 degrees\n        _st = rotate2D(_st,PI);\n    }\n\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n  \n    uv = tile(uv,6.0);\n    uv = rotateTilePattern(uv);\n\n    // Make more interesting combinations\n    //uv *= tile(uv,2.0);\n    //uv *= rotate2D(uv,-PI*sin(iTime));\n    //uv = rotateTilePattern(uv*2.);\n    uv *= rotate2D(uv,PI*iTime*0.25);\n\n    // step(st.x,st.y) just makes a b&w triangles\n    // but you can use whatever design you want.\n    float f = step(uv.x,uv.y);\n    fragColor = vec4(vec3(f*.5,f*cos(iTime), f*sin(iTime)),1.0);\n    float gamma = 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldXRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 76, 76, 216], [218, 218, 253, 253, 296], [298, 298, 331, 375, 1127], [1129, 1129, 1186, 1236, 1798]], "test": "untested"}
{"id": "WdKSRc", "name": "Codevember #24 - Reflex", "author": "desertsky", "description": "reflecting on the past", "tags": ["reflections"], "likes": 2, "viewed": 319, "published": 3, "date": "1580398973", "time_retrieved": "2024-07-30T21:27:14.959875", "image_code": "float smoothMin(float distA, float distB, float k){\n\tfloat h = max(k-abs(distA - distB),0.0)/k;\n    return min(distA, distB) - h*h*h*k*1.0/6.0;\n}\n\nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\nmat2 im2 = mat2(0.8,  -0.6, 0.6,  0.8);\n\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/3.;\n}\n\nfloat fbmabs( vec2 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(noise( p*f )+.5)/f;       \n\t    f *=2.;\n        p=im2*p;    \n\t}\n\treturn 1.-r*.5;\n}\n//courtesy of https://www.shadertoy.com/view/4l23Rh\nvec3 sky(in vec2 p)\n{\t\nreturn sin(vec3(1.7,1.5,1)+ .7+ .9*fbmabs(p*4.-.02*iTime))+.25;\n}\n\nvec2 r(vec2 ax, float a) {return mat2(cos(a),-sin(a),sin(a),cos(a))*ax;}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat checkers( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod(q.x+q.y,2.);\n}\n\nvec2 map(vec3 pos)\n{\n    vec3 boxpos = pos;\n    boxpos/=1.25;\n    boxpos.xy = r(boxpos.xy,1.); \n    boxpos.xz -=.025*sin(pos.x*20.*(mod(sin(iTime/8.)*1.2,2.4)-1.2)*1.25);\n    boxpos*=2.;\n    float sphere2 = float(length(vec3(sin(iTime)*1.25,-.90-sin(iTime),cos(iTime)*1.25)-pos)-.35);\n    float sphere3 = float(length(vec3(cos(iTime+1.43)*1.25,-.90-cos(iTime),sin(iTime)*1.25)-pos)-.35);\n    float box = length(boxpos)-1.25;\n    float plane = float(pos.y+1.5);\n    \n    vec2 scene = vec2(10.);\n\n    //SDF+materials\n    scene = vec2(smoothMin(scene.x,sphere2,0.4), scene.x<sphere2 ? scene.y:2.);\n    scene = vec2(smoothMin(scene.x,box,0.4), scene.x<box ? scene.y:3.);\n    scene = vec2(smoothMin(scene.x,sphere3,0.4), scene.x<sphere3 ? scene.y:4.);\n    scene = vec2(smoothMin(scene.x,plane,.4),scene.x<plane ? scene.y:1.);\n    return scene;\n}\n\nvec2 rm(vec3 ro, vec3 rd)\n{\n    vec2 dO = vec2(0.);\n    \n    for (int i = 0; i < 128; i++)\n    {\n    \tvec2 t = map(ro + dO.x * rd);\n        dO.x += t.x;\n        dO.y = t.y;\n        if(t.x < .01 || dO.x > 50.) break;\n    }\n    return dO;\n}\n\nvec3 n(vec3 pos)\n{\n    float d = map(pos).x;\n    vec2 e = vec2(.001,.0);\n    vec3 pn = d - vec3(\n        map(pos-e.xyy).x,\n        map(pos-e.yxy).x,\n        map(pos-e.yyx).x\n        );\n\treturn normalize(pn);\n}\n\nvec3 l(vec3 pos)\n{\n    vec3 total = vec3(0.);\n    vec3 nor = n(pos);\n    vec3 sundir = normalize(vec3(6.0,5.,0.)); \n    vec3 sundif = clamp(dot(nor,sundir),.0,1.)*vec3(.67);  \n    vec3 skydif = clamp(dot(nor,vec3(.0,1.,.0)),.0,1.)*vec3(.5,.0,.5);\n    vec3 bounce = clamp(dot(nor,-sundir),.0,1.)*vec3(.15);  \n    total+=sundif+bounce+skydif;  \n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;   \n    \n    //bg\n    vec3 col = vec3(.5,-.5+uv.y,uv.y+.75)*sky(vec2(uv.x/3.+iTime/14.,uv.y/3.));\n    \n    vec3 ro = vec3(3.*sin(10.*iMouse.x/iResolution.x+0.),-1.,3.*cos(10.*iMouse.x/iResolution.x));\n    vec3 ta = vec3(.0,.0,.0);\n    \n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww,vec3(.0,1.,.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    vec3 rd = normalize(uv.x*uu+uv.y*vv+ww*1.5);\n    vec2 r = rm(ro,rd);\n    vec3 pos = ro+rd*r.x;\n    \n    if(r.x < 50.)\n    {\n        //floor\n        if(r.y == 1.) \n        {            \n            vec3 ro = pos+n(pos)*.02;\n            vec3 rd = normalize(reflect(rd,n(pos)));\n            vec2 r = rm(ro,rd);\n            vec3 prf = ro+rd*r.x;\n\t\t\tfloat f = checkers(pos.xz);\n            if(r.y == 2.) {\n            col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(.1,.1,2.9);   \n                } \n            else if(r.y == 4.) {\n            col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(2.1,.1,.6);   \n            } else {\n\t\t\t\tcol=l(prf*vec3(f))*sky(vec2(iTime/4.+uv.x,uv.y))*vec3(.5,.0+uv.y,.5);\n               }\n        }\n        \n        //ballz\n        if(r.y == 2.) {  \n            col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(.1,.1,2.9);   \n        }\n        if(r.y == 4.) {  \n            col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(2.1,.1,.6);   \n        }\n\n        //glass sphere\n        if(r.y == 3.) \n        {\n            col = vec3(.05,.06,.02);\n            vec3 ro = pos+n(pos)*.02;\n            vec3 rd = normalize(reflect(rd,n(pos)));\n            vec2 r = rm(ro,rd);\n            vec3 prf = ro+rd*r.x;  \n               if(r.y == 2.) {\n            col = l(pos)*vec3(2)+fbmabs(pos.xy*10.)*vec3(.1,.1,2.9);   \n               } else if(r.y == 4.) {\n\t            col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(2.1,.1,.6);   \n               } else if(r.y ==1.) {\n                   float f = checkers(prf.xz);\n                   col+=l(prf*vec3(f))*sky(-iTime/4.+prf.xz)*(vec3(.5+uv.y))*vec3(.75,.50+uv.y,.75);\n               }  \n               else\n               {\n                col+=l(prf)*vec3(.5,.5,uv.y+.75)/1.+sky(vec2(uv.x+-iTime/8.,uv.y))/2.*vec3(.5,.0+uv.y,.5);\n               }\n        }      \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKSRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 145], [228, 228, 251, 251, 426], [428, 428, 452, 452, 610], [611, 663, 684, 684, 751], [753, 753, 779, 779, 825], [827, 827, 872, 872, 963], [965, 965, 994, 994, 1047], [1049, 1049, 1069, 1069, 1889], [1891, 1891, 1918, 1918, 2129], [2131, 2131, 2149, 2149, 2340], [2342, 2342, 2360, 2360, 2704], [2706, 2706, 2763, 2763, 5040]], "test": "untested"}
{"id": "WtdXR8", "name": "glowingMarblingBlack", "author": "nasana", "description": "https://twitter.com/nasana_x", "tags": ["cineshader"], "likes": 157, "viewed": 52732, "published": 3, "date": "1580392673", "time_retrieved": "2024-07-30T21:27:15.982142", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv =  (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    for(float i = 1.0; i < 10.0; i++){\n        uv.x += 0.6 / i * cos(i * 2.5* uv.y + iTime);\n        uv.y += 0.6 / i * cos(i * 1.5 * uv.x + iTime);\n    }\n    \n    fragColor = vec4(vec3(0.1)/abs(sin(iTime-uv.y-uv.x)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 368]], "test": "untested"}
{"id": "WltXR8", "name": "Day 42 - Magma", "author": "jeyko", "description": "Code is messy!\nKinda looked better with no post hmm", "tags": ["mdtmjvm"], "likes": 8, "viewed": 605, "published": 3, "date": "1580392371", "time_retrieved": "2024-07-30T21:27:16.882734", "image_code": "//Code is messy!\n// Kinda looked better with no post hmm\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragCoord += sin(40.*fragCoord/iResolution.xy + iTime*1.5)*2.;\n    \n    vec4 tA = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 bA = texture(iChannel0, (fragCoord)/iResolution.xy, 5.);\n    vec4 bB = texture(iChannel0, (fragCoord + vec2(0,iTime*3.4) + sin(iTime + 10.*fragCoord/iResolution.xy))/iResolution.xy, 5.);\n    \n    bA = pow(bA, vec4(1.4));\n    bA.r *= 0.7;\n    \n    fragColor = tA ;\n    fragColor -= bB *(0.5 + sin(iTime*0.5)*0.15)*0.8;\n    fragColor*= 1.8;\n    fragColor.b = min(fragColor.b, 0.1);\n    \n    float f = pow( (1. - fragColor.r), 9.);\n    fragColor.g -= f;\n    //fragColor += 0.2;\n    fragColor *= 1.3;\n    //fragColor.g *= 1. - length(vec2(1) - fragColor.rb);\n    //fragColor = bB;\n    //fragColor = tA;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 r22(vec2 x){return vec2(\n\tfract(sin(x.y*213.124)*214.),\n\tfract(sin(x.x*513.524)*614.5)\n);}\nfloat voronoi (vec2 uv){\n    \n    uv += sin(uv*2.)*0.2;\n    vec2 fuv = fract(uv) - 0.5;\n    vec2 uvid = floor(uv);\n    \n    vec2 me = r22(uvid);\n    vec2 u = r22(uvid + vec2(0,1)) + vec2(0,1);\n    vec2 d = r22(uvid - vec2(0,1)) - vec2(0,1);\n    vec2 l = r22(uvid - vec2(1,0)) - vec2(1,0);\n    vec2 r = r22(uvid + vec2(1,0)) + vec2(1,0);\n    \n    vec2 ul = r22(uvid + vec2(1,-1))+ vec2(1,-1);\n    vec2 ur = r22(uvid + vec2(1,1))+ vec2(1,1);\n    vec2 dl = r22(uvid + vec2(-1,-1))+ vec2(-1,-1);\n    vec2 dr = r22(uvid + vec2(-1,1)) + vec2(-1,1);\n    \n    vec3 col = vec3(0);\n\n    \n    float Di = distance(me,fuv);\n    float Du = distance(u,fuv);\n    float Dd = distance(d,fuv);\n    float Dl = distance(l,fuv);\n    float Dr = distance(r,fuv);\n    \n    float Dul = distance(ul,fuv);\n    float Dur = distance(ur,fuv);\n    float Ddl = distance(dl,fuv);\n    float Ddr = distance(dr,fuv);\n    \n    \n    float ddd = min(Di, Du);\n    ddd = min(ddd, Dd);\n    ddd = min(ddd, Dl);\n    ddd = min(ddd, Dr);\n    \n    ddd = min(ddd, Dul);\n    ddd = min(ddd, Dur);\n    ddd = min(ddd, Ddl);\n    ddd = min(ddd, Ddr);\n    \n    float c =  ddd;\n    \n    return  c;\n}", "buffer_a_code": "\nvec3 glow = vec3(0);\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt -ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn dir + right*uv.x + up*uv.y;\n}\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define mx (iTime*0.5 + 10.*iMouse.x/iResolution.y)\n\n\n\n// noise from IQ\nvec2 r22t(vec2 x){\n\treturn texture(iChannel0, (x)).xy; \n}\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0. ).x;\n}\n\n\nfloat noiseC(in vec2 x){\n\tfloat n = noise(x)*0.5;\n\tn += noise(x*0.5)*0.5;\n\tn += noise(x*2.02)*0.3;\n\tn += noise(x*3.05)*0.2;\n\t//n += noise(x*5.05)*0.02;\n    n = smoothstep(0.,1.,n);\n        \n    return n;\n}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\nfloat sdPyra(vec3 p){\n    float d;\n    d = sdBox(p, vec3(5));\n    //p = abs(p) - 2.4;\n    for (int i = 0; i < 3; i++){\n        p.xz *= rot(tau/3.);\n        //d.x = max(d.x, dot(p, normalize(vec3(2.5,1.,0))));\n        d = max(d, dot(p, normalize(vec3(2.5,1.,0))));\n    }\n    //d.x = max(d.x,-p.y - 0.7);\n    d = max(d,-p.y - 1.);\n\treturn d;\n}\nfloat noi;\nfloat v;\nfloat vB;\n\nfloat r21(vec2 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125)*124115.125235);\n}\nfloat valueNoise(vec2 uv){\n    vec2 id = floor(uv);\n    vec2 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float tl = r21(id);\n    float tr = r21(id + vec2(1,0));\n    float bl = r21(id + vec2(0,-1));\n    float br = r21(id + vec2(1,-1));\n    \n    float c = \n        mix(\n            mix(\n\t\t\t\tbl,                \n                br,\n                fd.x\n    \t\t),\n            mix(\n\t\t\t\ttl,                \n                tr,\n                fd.x\n    \t\t), fd.y\n           );\n    return c;\n}\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e5);\n\n    //d.x = min(d.x, length(p) - 0.5);\n\n    //p = abs(p);\n    \n\tvec2 offs =vec2(0. + iTime*0.1,0.2);\n    float dG = p.y + 0.5;\n    dG += valueNoise(p.xz)*0.4;\n    p.xz += offs;\n    v = voronoi(p.xz*1.5);\n    vB = voronoi(p.xz*2.5 ); \n    noi = noiseC(p.xz*20.);\n    dG += clamp(pow(v*1.12 + noi*0.17, 11.), 0., 0.3)*0.6;\n    dG += (1. - v) * 0.1;\n    dG -= (1. + vB*0.6 + noi*0.06)* 0.089;\n    dG += 0.04;\n    \n    dG -= noi*0.01;\n    //dG ;\n    //dG +=noiseC(p.xz*2.)*0.2;\n    dG -= 0.22; \n    d.x = min(d.x, dG);\n    \n    //d.x = min(d.x, sdPyra(p));\n    //p.x -= 0.6;\n    //d.x = min(d.x, sdPyramid( p*1.3, 1.));\n    d.x *= 0.4;\n    //d.x = min(d.x, max(valueNoise(p*1.)*0.1, 0.1)); \n    //d.x = min(d.x, max(noise(p*1.)*0.1, 0.1));\n\treturn d;\n}\n\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\t\n    vec2 d = vec2(10e5);\n    hit = false;\n    t = 0.;\n    p = ro + rd;\n    for(int i = 0; i < 150 ; i++){\n    \td = map(p);\n        \n        glow += exp(-d.x*20.);\n        \n        if(d.x < 0.002){\n            hit = true;\n        \tbreak;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1,0);\n    \n    ro.z += mx;\n    \n    //ro.x += sin(iTime)*3.;\n    //ro.z += cos(iTime)*3.;\n    \n    bool hit;\n    vec3 lookAt = vec3(0.001);\n    lookAt. y -= 0.7;\n    lookAt.z = ro.z + 2.;\n    //lookAt.y -= 0.7;\n    uv.xy *= rot(0.2 + sin(iTime*0.2)*0.2);\n    uv *= 1. + dot(uv,uv)*0.2;\n    vec3 rd = getRd(ro, lookAt, uv);\n    vec3 p; float t;\n    vec2 d = march( ro, rd,p,t, hit);\n\n    if (hit){\n        vec3 lD = normalize(vec3(0.4,1,1));\n        vec3 h = normalize(lD - rd);\n        vec3 n = getNormal(p);\n        float diff = max(dot(n,lD),0.);\n        float spec = pow(max(dot(n,h),0.), 20.);\n        float fres = pow(1. - max(dot(n,-rd),0.), 5.);\n        noi = pow(noi, 3.);\n        //noi = smoothstep(0.,1.,noi);\n        noi *= 0.2; \n        diff =diff*noi*0.3;\n    \tcol += mix(diff*vec3(1), spec*vec3(1.4,0.7,0.1)*0.5, 0.4 - noi*0.2);\n    }\n    vec3 g = glow*0.1*pal(0.5,0.5,vec3(4.7,2.4,0.7),0.5,4.7  );\n    \n    g.r *= 0. + (2.)*pow(v,2.);\n    //g.r -= noi;//\n    g.g *= 0. + 2.*pow(v*0.97,2.);\n    \n    col += g;\n    col += max(-p.y - 0.5,0.);\n    uv.y *= 1.7;\n    col *= 1. - dot(uv*1.1,uv*1.1)*0.4;\n    col = max(col, vec3(0));\n    col = smoothstep(0.,1.2,col); // wtf, this makes the image\n    \n    col *= 1.4;\n    //col = mix(col, vec3(1.3,0.7,00)*0.5,smoothstep(0.,1.6,t*0.15 - 0.6));\n    col = pow(col, vec3(0.4545));\n    //col.b *= 0.86;\n\tcol.r *= 1.1;\n    //col.g -= col.r;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltXR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 116, 116, 863]], "test": "untested"}
{"id": "tlcSzH", "name": "March from the Nutcracker", "author": "EFHIII", "description": "March from the Nutcracker, by Tchaikovsky played with what might sound like a trumpet and piano?\nI basically just guessed when it comes to the instruments, and I certainly didn't do a full range sampling; only doing tests with C4 or A4. It's not too great", "tags": ["sound", "music", "audio", "piano", "synth", "song", "trumpet", "nutcracker", "tchaikovsky"], "likes": 11, "viewed": 781, "published": 3, "date": "1580379741", "time_retrieved": "2024-07-30T21:27:18.414638", "image_code": "/*\nSound text copied from\nhttps://www.shadertoy.com/view/MtyXRW\n*/\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nfloat func(in float x){\n    float Tau = 6.2831853;\n    float t = (x+iTime/6.)*Tau*2.;\n    float val = -sin(x*10.+iTime*3.);\n\treturn val/2.1+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iResolution.y<2000.) {\n        float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);\n    \tif(c>=0.){\n            fragColor=vec4(c);return;\n        }\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n   \tfloat mag=50.;\n    float maxV=0.;\n    \n    float val = func(uv.x);\n    if(uv.y>val-0.02&&uv.y<val+0.02){\n\t\tval = (abs(uv.y-val))*mag;\n    \tfragColor = vec4(1.-val,0.,val,1.);\n    }\n    else{\n    \tfragColor=vec4(0.,0.,0.2,1.);\n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "/*\nADSR- Attack Decay Sustain Release\nNote range- A-440, C0-c6\n\nNote adding\n\n\n*/\n\n/*\nThis is a bare-bones MIDI:\nTime(sec), MIDI(0-88), velocity(0-1), duration(sec)\n*/\n// trumpet\nconst float midia[860] = float[860](0.,72.,0.5196850393700787,0.14535713125000002,0.46678538125,72.,0.5354330708661418,0.14241057187500006,0.6091959531250001,72.,0.5511811023622047,0.14241057187499995,0.751606525,72.,0.6377952755905512,0.14374985625000003,0.89535638125,74.,0.6535433070866141,0.10714274999999995,1.32392738125,74.,0.5196850393700787,0.10714274999999995,1.7524983812500001,76.,0.5275590551181102,0.10714275000000018,2.1810693812500004,72.,0.5354330708661418,0.10714274999999995,2.60964038125,74.,0.5590551181102362,0.8571420000000001,3.4667823812500003,72.,0.5748031496062992,0.21428550000000035,3.8953533812500005,72.,0.5669291338582677,0.14241057187499973,4.037763953125,72.,0.5590551181102362,0.14241057187499973,4.180174525,72.,0.6535433070866141,0.14374985625000036,4.32392438125,74.,0.6456692913385826,0.2142854999999999,4.75249538125,74.,0.5511811023622047,0.2142855000000008,5.181066381250001,76.,0.5433070866141733,0.2142854999999999,5.609637381250001,72.,0.5354330708661418,0.2142854999999999,6.0382083812500005,74.,0.5511811023622047,0.8571420000000005,6.895350381250001,70.,0.5511811023622047,0.3214282499999994,7.21677863125,72.,0.6377952755905512,0.1071427500000004,7.323921381250001,70.,0.5826771653543307,0.3214282500000003,7.645349631250001,69.,0.5748031496062992,0.10714274999999951,7.752492381250001,67.,0.5511811023622047,0.3214282500000003,8.073920631250001,65.,0.5275590551181102,0.10714274999999951,8.18106338125,64.,0.5354330708661418,0.3214282500000003,8.50249163125,60.,0.5118110236220472,0.10714274999999951,8.60963438125,69.,0.7559055118110236,0.3214282500000003,8.93106263125,70.,0.6535433070866141,0.10714274999999951,9.03820538125,69.,0.5669291338582677,0.3214282500000003,9.35963363125,67.,0.5196850393700787,0.10714274999999951,9.46677638125,65.,0.5275590551181102,0.3214282500000003,9.78820463125,64.,0.5748031496062992,0.10714274999999951,9.89534738125,62.,0.5590551181102362,0.3214282500000003,10.21677563125,65.,0.6141732283464567,0.10714274999999951,10.32391838125,64.,0.5669291338582677,0.3214282500000003,10.64534663125,62.,0.5590551181102362,0.10714274999999951,10.75248938125,61.,0.5433070866141733,0.3214282500000003,11.07391763125,67.,0.7401574803149606,0.10714275000000129,11.181060381250001,65.,0.5433070866141733,0.3214282499999985,11.50248863125,64.,0.5669291338582677,0.10714275000000129,11.60963138125,62.,0.5984251968503937,0.3214282500000003,11.931059631250001,69.,0.7086614173228346,0.10714274999999951,12.03820238125,70.,0.6456692913385826,0.3214282500000003,12.35963063125,69.,0.5826771653543307,0.10714274999999951,12.46677338125,67.,0.6220472440944882,0.3214282500000003,12.78820163125,65.,0.5826771653543307,0.10714274999999951,12.89534438125,72.,0.7086614173228346,0.2142855000000008,13.32391538125,72.,0.6456692913385826,0.2142855000000008,13.75248638125,72.,0.5433070866141733,0.21428549999999902,14.18105738125,72.,0.5354330708661418,0.1424105718750006,14.323467953125,72.,0.6062992125984252,0.1424105718750024,14.465878525000003,72.,0.5826771653543307,0.1437498562499968,14.60962838125,74.,0.6220472440944882,0.21428549999999902,15.03819938125,74.,0.5354330708661418,0.21428549999999902,15.466770381249999,76.,0.5511811023622047,0.2142855000000008,15.895341381249999,72.,0.5118110236220472,0.21428550000000257,16.32391238125,74.,0.5275590551181102,0.8571419999999996,17.18105438125,72.,0.5590551181102362,0.21428549999999902,17.609625381249998,72.,0.5433070866141733,0.14241057187500417,17.752035953125002,72.,0.6377952755905512,0.1424105718750006,17.894446525000003,72.,0.5905511811023622,0.1437498562499968,18.03819638125,74.,0.6220472440944882,0.21428549999999902,18.466767381249998,74.,0.5433070866141733,0.21428550000000257,18.89533838125,76.,0.5590551181102362,0.21428549999999902,19.32390938125,72.,0.5669291338582677,0.21428549999999902,19.75248038125,74.,0.5511811023622047,0.8571419999999996,20.60962238125,70.,0.5196850393700787,0.3214282500000003,20.93105063125,72.,0.6377952755905512,0.10714275000000129,21.03819338125,70.,0.5354330708661418,0.3214282500000003,21.35962163125,69.,0.5590551181102362,0.10714274999999773,21.466764381249998,67.,0.5748031496062992,0.3214282500000003,21.78819263125,65.,0.5275590551181102,0.10714275000000129,21.89533538125,64.,0.5669291338582677,0.3214282500000003,22.21676363125,67.,0.6456692913385826,0.10714274999999773,22.323906381249998,72.,0.6850393700787402,0.3214282500000003,22.645334631249998,74.,0.6220472440944882,0.10714275000000129,22.75247738125,72.,0.5590551181102362,0.3214282500000003,23.07390563125,70.,0.5433070866141733,0.10714275000000129,23.18104838125,69.,0.5826771653543307,0.3214282500000003,23.50247663125,67.,0.5669291338582677,0.10714274999999773,23.60961938125,65.,0.5748031496062992,0.3214282500000003,23.93104763125,69.,0.6771653543307087,0.10714275000000129,24.03819038125,74.,0.6929133858267716,0.3214282500000003,24.35961863125,72.,0.5748031496062992,0.10714274999999773,24.46676138125,70.,0.5511811023622047,0.3214282500000003,24.78818963125,74.,0.6771653543307087,0.10714275000000129,24.89533238125,76.,0.6456692913385826,0.3214282500000003,25.21676063125,74.,0.5590551181102362,0.10714274999999773,25.32390338125,72.,0.5748031496062992,0.3214282500000003,25.64533163125,76.,0.6771653543307087,0.10714275000000129,25.75247438125,77.,0.6299212598425197,0.3214282500000003,26.07390263125,76.,0.6141732283464567,0.10714275000000129,26.18104538125,74.,0.5433070866141733,0.32142824999999675,26.502473631249998,76.,0.6614173228346457,0.10714275000000129,26.60961638125,73.,0.5748031496062992,0.21428549999999902,27.03818738125,69.,0.6377952755905512,0.10714274999999773,30.895326381250005,77.,0.5511811023622047,0.8571419999999996,31.752468381250004,74.,0.5748031496062992,0.8571419999999961,32.60961038125,74.,0.7007874015748031,0.8571420000000032,33.466752381250004,76.,0.84251968503937,0.8571420000000032,37.109605881250005,69.,0.6929133858267716,0.21428550000000257,37.32389138125001,68.,0.6850393700787402,0.21428549999999547,37.53817688125,67.,0.7322834645669292,0.21428550000000257,37.752462381250005,65.,0.7165354330708661,0.21428549999999547,37.96674788125,76.,0.9291338582677166,0.21428550000000257,38.18103338125,74.,0.7637795275590551,0.21428550000000257,38.395318881250006,72.,0.7007874015748031,0.21428549999999547,38.60960438125,70.,0.7086614173228346,0.21428550000000257,38.823889881250004,69.,0.7165354330708661,0.21428550000000257,39.03817538125001,67.,0.6929133858267716,0.21428549999999547,39.25246088125,65.,0.7401574803149606,0.21428550000000257,39.466746381250005,64.,0.7165354330708661,0.21428550000000257,39.68103188125001,74.,0.905511811023622,0.21428549999999547,39.89531738125,72.,0.6929133858267716,0.21428550000000257,40.109602881250005,70.,0.7086614173228346,0.21428549999999547,40.32388838125,69.,0.7007874015748031,0.21785692499999953,40.53817388125,67.,0.6456692913385826,0.21785692499999953,40.752459381250006,65.,0.7165354330708661,0.21785692499999243,40.96674488125,64.,0.6692913385826772,0.20267836875,41.181030381250004,72.,0.8661417322834646,0.21428550000000257,41.60960138125,72.,0.6929133858267716,0.14241057187500417,41.752011953125006,72.,0.7322834645669292,0.14241057187499706,41.894422525,72.,0.7559055118110236,0.14374985625000392,42.03817238125001,74.,0.8346456692913385,0.21428549999999547,42.466743381250005,74.,0.6535433070866141,0.21428550000000257,42.89531438125,76.,0.6220472440944882,0.21428550000000257,43.32388538125,72.,0.7007874015748031,0.21428550000000257,43.752456381250006,74.,0.7086614173228346,0.8571419999999961,44.60959838125,72.,0.7244094488188977,0.21428550000000257,45.03816938125001,72.,0.6929133858267716,0.14241057187499706,45.180579953125005,72.,0.7007874015748031,0.14241057187499706,45.322990525,72.,0.7559055118110236,0.14374985625000392,45.466740381250005,74.,0.8110236220472441,0.21428550000000257,45.89531138125,74.,0.6929133858267716,0.21428550000000257,46.32388238125,76.,0.6850393700787402,0.21428550000000257,46.75245338125001,72.,0.7165354330708661,0.21428549999999547,47.181024381250005,74.,0.6929133858267716,0.8571420000000032,48.03816638125001,70.,0.6692913385826772,0.32142824999999675,48.359594631250005,72.,0.8031496062992126,0.10714275000000129,48.466737381250006,70.,0.7165354330708661,0.32142824999999675,48.78816563125,69.,0.7007874015748031,0.10714275000000129,48.895308381250004,67.,0.7244094488188977,0.32142825000000386,49.21673663125001,65.,0.7244094488188977,0.10714274999999418,49.32387938125,64.,0.7401574803149606,0.32142825000000386,49.645307631250006,60.,0.6850393700787402,0.10714275000000129,49.75245038125001,69.,0.9133858267716536,0.32142824999999675,50.073878631250004,70.,0.7795275590551181,0.10714275000000129,50.181021381250005,69.,0.6614173228346457,0.32142824999999675,50.50244963125,67.,0.7165354330708661,0.10714275000000129,50.60959238125,65.,0.7244094488188977,0.32142825000000386,50.93102063125001,64.,0.7322834645669292,0.10714275000000129,51.03816338125001,62.,0.7716535433070866,0.32142824999999675,51.359591631250005,65.,0.8267716535433071,0.10714275000000129,51.466734381250006,64.,0.7716535433070866,0.32142824999999675,51.78816263125,62.,0.6929133858267716,0.10714275000000129,51.895305381250004,61.,0.6850393700787402,0.32142825000000386,52.21673363125001,67.,0.8346456692913385,0.10714274999999418,52.32387638125,65.,0.7086614173228346,0.32142825000000386,52.645304631250006,64.,0.7322834645669292,0.10714275000000129,52.75244738125001,62.,0.6929133858267716,0.32142824999999675,53.073875631250004,69.,0.8582677165354331,0.10714275000000129,53.181018381250006,70.,0.84251968503937,0.32142824999999675,53.50244663125,69.,0.7007874015748031,0.10714275000000129,53.609589381250004,67.,0.7401574803149606,0.32142825000000386,53.93101763125001,65.,0.7165354330708661,0.10714274999999418,54.03816038125,72.,0.889763779527559,0.21428550000000257,54.46673138125001,72.,0.7952755905511811,0.21428549999999547,54.895302381250005,72.,0.7007874015748031,0.21428550000000257,55.32387338125,72.,0.6850393700787402,0.14241057187500417,55.46628395312501,72.,0.7716535433070866,0.14241057187499706,55.608694525000004,72.,0.7480314960629921,0.14374985625000392,55.75244438125001,74.,0.8031496062992126,0.21428549999999547,56.181015381250006,74.,0.6850393700787402,0.21428550000000257,56.609586381250004,76.,0.6850393700787402,0.21428550000000257,57.03815738125,72.,0.6771653543307087,0.21428550000000257,57.46672838125001,74.,0.6771653543307087,0.8571419999999961,58.32387038125,72.,0.7165354330708661,0.21428550000000257,58.75244138125001,72.,0.6771653543307087,0.14241057187499706,58.894851953125006,72.,0.7165354330708661,0.14241057187499706,59.037262525,72.,0.7637795275590551,0.14374985625000392,59.18101238125001,74.,0.8031496062992126,0.21428550000000257,59.609583381250005,74.,0.7086614173228346,0.21428550000000257,60.03815438125,76.,0.6929133858267716,0.21428550000000257,60.46672538125001,72.,0.6614173228346457,0.21428549999999547,60.895296381250006,74.,0.6535433070866141,0.8571420000000032,61.75243838125001,70.,0.6535433070866141,0.32142824999999675,62.073866631250006,72.,0.7716535433070866,0.10714275000000129,62.18100938125001,70.,0.6929133858267716,0.32142824999999675,62.502437631250004,69.,0.7086614173228346,0.10714275000000129,62.609580381250005,67.,0.7322834645669292,0.32142825000000386,62.93100863125001,65.,0.7165354330708661,0.10714274999999418,63.03815138125,64.,0.7322834645669292,0.32142825000000386,63.35957963125001,67.,0.8031496062992126,0.10714275000000129,63.46672238125001,72.,0.8661417322834646,0.32142824999999675,63.788150631250005,74.,0.8188976377952756,0.10714275000000129,63.895293381250006,72.,0.7007874015748031,0.32142825000000386,64.21672163125001,70.,0.7322834645669292,0.10714275000000839,64.32386438125002,69.,0.7007874015748031,0.32142824999999675,64.64529263125002,67.,0.7244094488188977,0.10714274999999418,64.75243538125001,65.,0.7086614173228346,0.32142824999999675,65.07386363125,69.,0.84251968503937,0.10714275000000839,65.18100638125001,74.,0.8818897637795275,0.32142824999999675,65.50243463125001,72.,0.7165354330708661,0.10714275000000839,65.60957738125002,70.,0.7401574803149606,0.32142824999999675,65.93100563125002,74.,0.8267716535433071,0.10714274999999418,66.03814838125001,76.,0.8188976377952756,0.32142824999999675,66.35957663125001,74.,0.7244094488188977,0.10714275000000839,66.46671938125002,72.,0.6929133858267716,0.32142824999999675,66.78814763125001,76.,0.8346456692913385,0.10714274999999418,66.89529038125,77.,0.7952755905511811,0.32142825000001096,67.21671863125002,76.,0.7401574803149606,0.10714274999999418,67.32386138125001,74.,0.7007874015748031,0.32142824999999675,67.64528963125001,76.,0.7874015748031497,0.10714275000000839,67.75243238125002,77.,0.7637795275590551,0.21428550000000257,68.18100338125001,77.,0.7874015748031497,0.21428550000000257);\n// piano\nconst float midib[1484] = float[1484](0.,69.,0.5275590551181102,0.14535713125000002,0.,53.,0.36220472440944884,0.25249988125,0.,65.,0.36220472440944884,0.25249988125,0.46678538125,69.,0.5669291338582677,0.14241057187500006,0.6091959531250001,69.,0.5984251968503937,0.14241057187499995,0.751606525,69.,0.5748031496062992,0.14374985625000003,0.89535638125,69.,0.5826771653543307,0.10714274999999995,0.89535638125,50.,0.33070866141732286,0.10714274999999995,0.89535638125,53.,0.33070866141732286,0.10714274999999995,1.32392738125,69.,0.5511811023622047,0.10714274999999995,1.7524983812500001,69.,0.5039370078740157,0.10714275000000018,1.7524983812500001,72.,0.5039370078740157,0.10714275000000018,1.7524983812500001,45.,0.3937007874015748,0.10714275000000018,1.7524983812500001,52.,0.3937007874015748,0.10714275000000018,2.1810693812500004,69.,0.5275590551181102,0.10714274999999995,2.60964038125,69.,0.5590551181102362,0.8571420000000001,2.60964038125,50.,0.3228346456692913,0.8571420000000001,2.60964038125,53.,0.3228346456692913,0.8571420000000001,3.4667823812500003,69.,0.6062992125984252,0.21428550000000035,3.4667823812500003,53.,0.4645669291338583,0.21428550000000035,3.4667823812500003,65.,0.4645669291338583,0.21428550000000035,3.8953533812500005,69.,0.5590551181102362,0.14241057187499973,4.037763953125,69.,0.5748031496062992,0.14241057187499973,4.180174525,69.,0.5905511811023622,0.14374985625000036,4.32392438125,69.,0.5984251968503937,0.2142854999999999,4.32392438125,50.,0.33070866141732286,0.2142854999999999,4.32392438125,53.,0.33070866141732286,0.2142854999999999,4.75249538125,69.,0.5196850393700787,0.2142855000000008,5.181066381250001,69.,0.5433070866141733,0.2142854999999999,5.181066381250001,72.,0.5433070866141733,0.2142854999999999,5.181066381250001,45.,0.33858267716535434,0.2142854999999999,5.181066381250001,52.,0.33858267716535434,0.2142854999999999,5.609637381250001,69.,0.5433070866141733,0.2142854999999999,6.0382083812500005,69.,0.5590551181102362,0.8571420000000005,6.0382083812500005,50.,0.3543307086614173,0.6428565000000006,6.0382083812500005,53.,0.3543307086614173,0.6428565000000006,6.895350381250001,62.,0.6377952755905512,1.2857129999999994,6.895350381250001,70.,0.6377952755905512,1.2857129999999994,6.895350381250001,43.,0.31496062992125984,0.4285709999999998,7.323921381250001,45.,0.3858267716535433,0.4285709999999998,7.752492381250001,46.,0.3700787401574803,0.4285709999999998,8.18106338125,60.,0.5354330708661418,0.4285709999999998,8.18106338125,67.,0.5354330708661418,0.4285709999999998,8.18106338125,48.,0.41732283464566927,0.4285709999999998,8.60963438125,60.,0.6535433070866141,1.2857129999999994,8.60963438125,69.,0.6535433070866141,1.2857129999999994,8.60963438125,41.,0.3700787401574803,0.4285709999999998,9.03820538125,43.,0.3700787401574803,0.4285709999999998,9.46677638125,45.,0.4251968503937008,0.4285709999999998,9.89534738125,62.,0.5196850393700787,0.4285709999999998,9.89534738125,65.,0.5196850393700787,0.4285709999999998,9.89534738125,46.,0.3700787401574803,0.2142855000000008,10.32391838125,55.,0.5590551181102362,0.4285709999999998,10.32391838125,64.,0.5590551181102362,0.4285709999999998,10.32391838125,43.,0.30708661417322836,0.4285709999999998,10.75248938125,57.,0.5433070866141733,0.4285710000000016,10.75248938125,61.,0.5433070866141733,0.4285710000000016,10.75248938125,45.,0.3937007874015748,0.2142855000000008,11.181060381250001,57.,0.6220472440944882,0.4285709999999998,11.181060381250001,65.,0.6220472440944882,0.4285709999999998,11.181060381250001,47.,0.4330708661417323,0.3214282499999985,11.50248863125,49.,0.5590551181102362,0.10714275000000129,11.60963138125,62.,0.5984251968503937,0.4285709999999998,11.60963138125,65.,0.5984251968503937,0.4285709999999998,11.60963138125,50.,0.6220472440944882,0.21428549999999902,12.03820238125,62.,0.5748031496062992,0.8571419999999996,12.03820238125,65.,0.5748031496062992,0.8571419999999996,12.03820238125,43.,0.5669291338582677,0.3214282500000003,12.35963063125,45.,0.7322834645669292,0.10714274999999951,12.46677338125,46.,0.7637795275590551,0.3214282500000003,12.78820163125,47.,0.8188976377952756,0.10714274999999951,12.89534438125,60.,0.5669291338582677,0.4285709999999998,12.89534438125,64.,0.5669291338582677,0.4285709999999998,12.89534438125,48.,0.8267716535433071,0.2142855000000008,13.32391538125,64.,0.8503937007874016,0.2142855000000008,13.32391538125,72.,0.8503937007874016,0.2142855000000008,13.32391538125,48.,0.84251968503937,0.2142855000000008,13.75248638125,69.,0.5118110236220472,0.10714274999999951,13.75248638125,65.,0.3543307086614173,0.21428549999999902,14.18105738125,69.,0.5196850393700787,0.1424105718750006,14.323467953125,69.,0.5669291338582677,0.1424105718750024,14.465878525000003,69.,0.5748031496062992,0.1437498562499968,14.60962838125,69.,0.6220472440944882,0.10714274999999951,14.60962838125,62.,0.33858267716535434,0.21428549999999902,14.60962838125,65.,0.33858267716535434,0.21428549999999902,15.03819938125,69.,0.5590551181102362,0.10714274999999951,15.466770381249999,69.,0.5354330708661418,0.10714274999999951,15.466770381249999,72.,0.5354330708661418,0.10714274999999951,15.466770381249999,57.,0.33070866141732286,0.2142855000000008,15.466770381249999,64.,0.33070866141732286,0.2142855000000008,15.895341381249999,69.,0.5354330708661418,0.10714275000000129,16.32391238125,69.,0.5196850393700787,0.8571419999999996,16.32391238125,62.,0.33070866141732286,0.8571419999999996,16.32391238125,65.,0.33070866141732286,0.8571419999999996,17.18105438125,69.,0.5669291338582677,0.21428549999999902,17.18105438125,65.,0.36220472440944884,0.21428549999999902,17.609625381249998,69.,0.5433070866141733,0.14241057187500417,17.752035953125002,69.,0.5748031496062992,0.1424105718750006,17.894446525000003,69.,0.6377952755905512,0.1437498562499968,18.03819638125,69.,0.6141732283464567,0.21428549999999902,18.03819638125,62.,0.30708661417322836,0.21428549999999902,18.03819638125,65.,0.30708661417322836,0.21428549999999902,18.466767381249998,69.,0.5590551181102362,0.21428550000000257,18.89533838125,69.,0.5590551181102362,0.21428549999999902,18.89533838125,72.,0.5590551181102362,0.21428549999999902,18.89533838125,57.,0.36220472440944884,0.21428549999999902,18.89533838125,64.,0.36220472440944884,0.21428549999999902,19.32390938125,69.,0.5590551181102362,0.21428549999999902,19.75248038125,69.,0.5354330708661418,0.8571419999999996,19.75248038125,62.,0.3700787401574803,0.8571419999999996,19.75248038125,65.,0.3700787401574803,0.8571419999999996,20.60962238125,62.,0.6614173228346457,1.2857130000000012,20.60962238125,70.,0.6614173228346457,1.2857130000000012,20.60962238125,43.,0.33070866141732286,0.4285710000000016,21.03819338125,45.,0.3464566929133858,0.42857099999999804,21.466764381249998,46.,0.3937007874015748,0.4285710000000016,21.89533538125,60.,0.5590551181102362,0.42857099999999804,21.89533538125,67.,0.5590551181102362,0.42857099999999804,21.89533538125,48.,0.41732283464566927,0.21428549999999902,22.323906381249998,64.,0.7165354330708661,1.2857130000000012,22.323906381249998,72.,0.7165354330708661,1.2857130000000012,22.323906381249998,45.,0.3228346456692913,0.4285710000000016,22.75247738125,46.,0.3700787401574803,0.4285710000000016,23.18104838125,48.,0.4094488188976378,0.42857099999999804,23.60961938125,62.,0.5511811023622047,0.4285710000000016,23.60961938125,69.,0.5511811023622047,0.4285710000000016,23.60961938125,50.,0.4015748031496063,0.21428549999999902,24.03819038125,70.,0.6771653543307087,0.8571419999999996,24.03819038125,74.,0.6771653543307087,0.8571419999999996,24.03819038125,46.,0.3464566929133858,0.3214282500000003,24.35961863125,45.,0.33858267716535434,0.10714274999999773,24.46676138125,43.,0.33070866141732286,0.21428550000000257,24.89533238125,72.,0.6377952755905512,0.8571419999999996,24.89533238125,76.,0.6377952755905512,0.8571419999999996,24.89533238125,48.,0.33070866141732286,0.3214282500000003,25.21676063125,46.,0.36220472440944884,0.10714274999999773,25.32390338125,45.,0.3543307086614173,0.21428550000000257,25.75247438125,74.,0.6771653543307087,0.8571419999999996,25.75247438125,77.,0.6771653543307087,0.8571419999999996,25.75247438125,50.,0.3779527559055118,0.8571419999999996,26.60961638125,73.,0.5433070866141733,0.21428549999999902,26.60961638125,57.,0.3937007874015748,0.21428549999999902,27.03818738125,73.,0.6456692913385826,0.10714274999999773,27.03818738125,81.,0.6456692913385826,0.10714274999999773,27.03818738125,57.,0.4094488188976378,0.10714274999999773,27.46675838125,69.,0.5433070866141733,0.42857100000000514,27.46675838125,61.,0.33070866141732286,0.8741062687500012,27.895329381250004,69.,0.5984251968503937,0.14241057187499706,28.037739953125,69.,0.6299212598425197,0.14241057187499706,28.180150525,69.,0.5748031496062992,0.14374985625000392,28.323900381250002,65.,0.5275590551181102,0.21428550000000257,28.323900381250002,62.,0.33070866141732286,0.20267836875,28.752471381250004,62.,0.5196850393700787,0.21428549999999902,29.181042381250002,58.,0.5196850393700787,0.21428550000000257,29.181042381250002,43.,0.33858267716535434,0.8571419999999996,29.181042381250002,50.,0.33858267716535434,0.8571419999999996,29.609613381250004,55.,0.5433070866141733,0.21428549999999902,30.03818438125,45.,0.3779527559055118,0.4285710000000016,30.03818438125,49.,0.3779527559055118,0.4285710000000016,30.03818438125,52.,0.3779527559055118,0.4285710000000016,30.466755381250003,47.,0.33858267716535434,0.21428549999999902,30.681040881250002,49.,0.4015748031496063,0.21428550000000257,30.895326381250005,69.,0.5275590551181102,0.8571419999999996,30.895326381250005,50.,0.3858267716535433,0.21428549999999902,31.109611881250004,52.,0.3700787401574803,0.21428549999999902,31.323897381250003,53.,0.3779527559055118,0.21428549999999902,31.538182881250002,54.,0.3858267716535433,0.21428550000000257,31.752468381250004,70.,0.6692913385826772,0.8571419999999961,31.752468381250004,55.,0.3700787401574803,0.21428549999999902,31.966753881250003,57.,0.4094488188976378,0.21428549999999902,32.18103938125,58.,0.36220472440944884,0.21428550000000257,32.395324881250005,57.,0.4015748031496063,0.21428549999999547,32.60961038125,70.,0.7322834645669292,0.8571420000000032,32.60961038125,55.,0.3700787401574803,0.21428550000000257,32.82389588125,53.,0.3779527559055118,0.21428550000000257,33.038181381250006,52.,0.3858267716535433,0.21428549999999547,33.25246688125,50.,0.3700787401574803,0.21428550000000257,33.466752381250004,69.,0.7165354330708661,0.8571420000000032,33.466752381250004,49.,0.3858267716535433,0.21428550000000257,33.681037881250006,47.,0.33070866141732286,0.21428549999999547,33.89532338125,45.,0.36220472440944884,0.21428550000000257,34.32389438125001,69.,0.3858267716535433,0.42857099999999804,34.32389438125001,61.,0.3779527559055118,0.8741062687499905,34.752465381250005,69.,0.3700787401574803,0.14241057187499706,34.894875953125,69.,0.3779527559055118,0.14241057187499706,35.037286525,69.,0.3700787401574803,0.14374985625000392,35.18103638125,65.,0.3464566929133858,0.10714275000000129,35.18103638125,62.,0.3700787401574803,0.20267836875,35.60960738125,62.,0.33858267716535434,0.10714275000000129,36.038178381250006,58.,0.3464566929133858,0.10714274999999418,36.038178381250006,43.,0.2992125984251969,0.8571419999999961,36.038178381250006,50.,0.2992125984251969,0.8571419999999961,36.466749381250004,55.,0.33858267716535434,0.10714275000000129,36.89532038125,45.,0.3937007874015748,0.42857100000000514,36.89532038125,49.,0.3937007874015748,0.42857100000000514,36.89532038125,52.,0.3937007874015748,0.42857100000000514,37.752462381250005,62.,0.33070866141732286,0.8571419999999961,37.752462381250005,65.,0.33070866141732286,0.8571419999999961,37.752462381250005,69.,0.33070866141732286,0.8571419999999961,37.752462381250005,50.,0.3228346456692913,0.8571419999999961,38.60960438125,62.,0.3858267716535433,0.8571420000000032,38.60960438125,67.,0.3858267716535433,0.8571420000000032,38.60960438125,70.,0.3858267716535433,0.8571420000000032,38.60960438125,55.,0.4251968503937008,0.8571420000000032,39.466746381250005,64.,0.41732283464566927,1.7142839999999993,39.466746381250005,67.,0.41732283464566927,1.7142839999999993,39.466746381250005,72.,0.41732283464566927,1.7142839999999993,39.466746381250005,60.,0.41732283464566927,0.8571419999999961,40.32388838125,48.,0.33070866141732286,0.8571420000000032,41.181030381250004,69.,0.3858267716535433,0.21428550000000257,41.181030381250004,41.,0.7952755905511811,0.10714275000000129,41.181030381250004,53.,0.7952755905511811,0.10714275000000129,41.60960138125,69.,0.30708661417322836,0.14241057187500417,41.752011953125006,69.,0.3779527559055118,0.14241057187499706,41.894422525,69.,0.36220472440944884,0.14374985625000392,42.03817238125001,69.,0.3779527559055118,0.21428549999999547,42.03817238125001,50.,0.31496062992125984,0.21428549999999547,42.03817238125001,53.,0.31496062992125984,0.21428549999999547,42.466743381250005,69.,0.31496062992125984,0.21428550000000257,42.89531438125,69.,0.3464566929133858,0.21428550000000257,42.89531438125,72.,0.3464566929133858,0.21428550000000257,42.89531438125,45.,0.33858267716535434,0.21428550000000257,42.89531438125,52.,0.33858267716535434,0.21428550000000257,43.32388538125,69.,0.31496062992125984,0.21428550000000257,43.752456381250006,69.,0.3779527559055118,0.8571419999999961,43.752456381250006,50.,0.31496062992125984,0.8571419999999961,43.752456381250006,53.,0.31496062992125984,0.8571419999999961,44.60959838125,69.,0.41732283464566927,0.21428550000000257,44.60959838125,72.,0.41732283464566927,0.21428550000000257,44.60959838125,41.,0.36220472440944884,0.21428550000000257,44.60959838125,53.,0.36220472440944884,0.21428550000000257,45.03816938125001,69.,0.3543307086614173,0.14241057187499706,45.03816938125001,72.,0.3543307086614173,0.14241057187499706,45.180579953125005,69.,0.3543307086614173,0.14241057187499706,45.180579953125005,72.,0.3543307086614173,0.14241057187499706,45.322990525,69.,0.3700787401574803,0.14374985625000392,45.322990525,72.,0.3700787401574803,0.14374985625000392,45.466740381250005,69.,0.4015748031496063,0.21428550000000257,45.466740381250005,74.,0.4015748031496063,0.21428550000000257,45.466740381250005,50.,0.36220472440944884,0.21428550000000257,45.466740381250005,53.,0.36220472440944884,0.21428550000000257,45.89531138125,69.,0.3700787401574803,0.21428550000000257,45.89531138125,74.,0.3700787401574803,0.21428550000000257,46.32388238125,69.,0.3779527559055118,0.21428550000000257,46.32388238125,72.,0.3779527559055118,0.21428550000000257,46.32388238125,76.,0.3779527559055118,0.21428550000000257,46.32388238125,45.,0.3464566929133858,0.21428550000000257,46.32388238125,52.,0.3464566929133858,0.21428550000000257,46.75245338125001,69.,0.2992125984251969,0.21428549999999547,46.75245338125001,72.,0.2992125984251969,0.21428549999999547,47.181024381250005,69.,0.33070866141732286,0.8571420000000032,47.181024381250005,74.,0.33070866141732286,0.8571420000000032,47.181024381250005,50.,0.3779527559055118,0.6428565000000006,47.181024381250005,53.,0.3779527559055118,0.6428565000000006,48.03816638125001,62.,0.3228346456692913,1.285712999999994,48.03816638125001,70.,0.3228346456692913,1.285712999999994,48.03816638125001,43.,0.31496062992125984,0.42857099999999804,48.466737381250006,45.,0.3543307086614173,0.42857099999999804,48.895308381250004,46.,0.41732283464566927,0.42857099999999804,49.32387938125,60.,0.3543307086614173,0.42857100000000514,49.32387938125,67.,0.3543307086614173,0.42857100000000514,49.32387938125,48.,0.4330708661417323,0.42857100000000514,49.75245038125001,60.,0.3858267716535433,1.2857130000000012,49.75245038125001,69.,0.3858267716535433,1.2857130000000012,49.75245038125001,41.,0.33858267716535434,0.42857099999999804,50.181021381250005,43.,0.3937007874015748,0.42857099999999804,50.60959238125,45.,0.4015748031496063,0.42857100000000514,51.03816338125001,62.,0.33858267716535434,0.42857099999999804,51.03816338125001,65.,0.33858267716535434,0.42857099999999804,51.03816338125001,46.,0.3937007874015748,0.21428549999999547,51.466734381250006,55.,0.3464566929133858,0.42857099999999804,51.466734381250006,64.,0.3464566929133858,0.42857099999999804,51.466734381250006,43.,0.33858267716535434,0.42857099999999804,51.895305381250004,57.,0.2992125984251969,0.42857099999999804,51.895305381250004,61.,0.2992125984251969,0.42857099999999804,51.895305381250004,45.,0.41732283464566927,0.21428550000000257,52.32387638125,57.,0.4251968503937008,0.42857100000000514,52.32387638125,65.,0.4251968503937008,0.42857100000000514,52.32387638125,47.,0.48031496062992124,0.32142825000000386,52.645304631250006,49.,0.6850393700787402,0.10714275000000129,52.75244738125001,62.,0.3700787401574803,0.42857099999999804,52.75244738125001,65.,0.3700787401574803,0.42857099999999804,52.75244738125001,50.,0.7165354330708661,0.21428549999999547,53.181018381250006,62.,0.3937007874015748,0.8571419999999961,53.181018381250006,65.,0.3937007874015748,0.8571419999999961,53.181018381250006,43.,0.7480314960629921,0.32142824999999675,53.50244663125,45.,0.8503937007874016,0.10714275000000129,53.609589381250004,46.,0.8503937007874016,0.32142825000000386,53.93101763125001,47.,0.8110236220472441,0.10714274999999418,54.03816038125,60.,0.3700787401574803,0.42857100000000514,54.03816038125,64.,0.3700787401574803,0.42857100000000514,54.03816038125,48.,0.8346456692913385,0.21428550000000257,54.46673138125001,64.,0.5511811023622047,0.21428549999999547,54.46673138125001,72.,0.5511811023622047,0.21428549999999547,54.46673138125001,48.,0.84251968503937,0.21428549999999547,54.895302381250005,69.,0.33070866141732286,0.10714275000000129,54.895302381250005,65.,0.3543307086614173,0.21428550000000257,55.32387338125,69.,0.33858267716535434,0.14241057187500417,55.46628395312501,69.,0.41732283464566927,0.14241057187499706,55.608694525000004,69.,0.3779527559055118,0.14374985625000392,55.75244438125001,69.,0.3700787401574803,0.10714274999999418,55.75244438125001,62.,0.2992125984251969,0.21428549999999547,55.75244438125001,65.,0.2992125984251969,0.21428549999999547,56.181015381250006,69.,0.3543307086614173,0.10714275000000129,56.609586381250004,69.,0.3228346456692913,0.10714275000000129,56.609586381250004,72.,0.3228346456692913,0.10714275000000129,56.609586381250004,57.,0.3543307086614173,0.21428550000000257,56.609586381250004,64.,0.3543307086614173,0.21428550000000257,57.03815738125,69.,0.3464566929133858,0.10714275000000129,57.46672838125001,69.,0.3228346456692913,0.8571419999999961,57.46672838125001,62.,0.31496062992125984,0.8571419999999961,57.46672838125001,65.,0.31496062992125984,0.8571419999999961,58.32387038125,69.,0.3779527559055118,0.21428550000000257,58.32387038125,65.,0.4015748031496063,0.21428550000000257,58.75244138125001,69.,0.3464566929133858,0.14241057187499706,58.894851953125006,69.,0.3937007874015748,0.14241057187499706,59.037262525,69.,0.41732283464566927,0.14374985625000392,59.18101238125001,69.,0.4015748031496063,0.21428550000000257,59.18101238125001,62.,0.36220472440944884,0.21428550000000257,59.18101238125001,65.,0.36220472440944884,0.21428550000000257,59.609583381250005,69.,0.3543307086614173,0.21428550000000257,60.03815438125,69.,0.3228346456692913,0.21428550000000257,60.03815438125,72.,0.3228346456692913,0.21428550000000257,60.03815438125,57.,0.3700787401574803,0.21428550000000257,60.03815438125,64.,0.3700787401574803,0.21428550000000257,60.46672538125001,69.,0.3464566929133858,0.21428549999999547,60.895296381250006,69.,0.3228346456692913,0.8571420000000032,60.895296381250006,62.,0.3464566929133858,0.8571420000000032,60.895296381250006,65.,0.3464566929133858,0.8571420000000032,61.75243838125001,62.,0.3543307086614173,1.285712999999994,61.75243838125001,70.,0.3543307086614173,1.285712999999994,61.75243838125001,43.,0.3464566929133858,0.42857099999999804,62.18100938125001,45.,0.3858267716535433,0.42857099999999804,62.609580381250005,46.,0.3779527559055118,0.42857099999999804,63.03815138125,60.,0.33858267716535434,0.42857100000000514,63.03815138125,67.,0.33858267716535434,0.42857100000000514,63.03815138125,48.,0.3937007874015748,0.21428550000000257,63.46672238125001,64.,0.4094488188976378,1.2857130000000012,63.46672238125001,72.,0.4094488188976378,1.2857130000000012,63.46672238125001,45.,0.36220472440944884,0.42857099999999804,63.895293381250006,46.,0.4094488188976378,0.42857100000001225,64.32386438125002,48.,0.4330708661417323,0.42857099999999093,64.75243538125001,62.,0.3464566929133858,0.42857100000000514,64.75243538125001,69.,0.3464566929133858,0.42857100000000514,64.75243538125001,50.,0.3858267716535433,0.21428550000000257,65.18100638125001,70.,0.4094488188976378,0.8571419999999961,65.18100638125001,74.,0.4094488188976378,0.8571419999999961,65.18100638125001,46.,0.33858267716535434,0.32142824999999675,65.50243463125001,45.,0.3700787401574803,0.10714275000000839,65.60957738125002,43.,0.3779527559055118,0.21428549999998836,66.03814838125001,72.,0.4015748031496063,0.8571419999999961,66.03814838125001,76.,0.4015748031496063,0.8571419999999961,66.03814838125001,48.,0.33070866141732286,0.32142824999999675,66.35957663125001,50.,0.4015748031496063,0.10714275000000839,66.46671938125002,52.,0.3779527559055118,0.21428550000000257,66.89529038125,69.,0.4015748031496063,0.21428550000000257,66.89529038125,72.,0.4015748031496063,0.21428550000000257,66.89529038125,77.,0.4015748031496063,0.21428550000000257,66.89529038125,53.,0.33070866141732286,0.21428550000000257,67.32386138125001,67.,0.3543307086614173,0.21428550000000257,67.32386138125001,70.,0.3543307086614173,0.21428550000000257,67.32386138125001,76.,0.3543307086614173,0.21428550000000257,67.32386138125001,48.,0.33858267716535434,0.21428550000000257,67.75243238125002,69.,0.36220472440944884,0.21428550000000257,67.75243238125002,72.,0.36220472440944884,0.21428550000000257,67.75243238125002,77.,0.36220472440944884,0.21428550000000257,67.75243238125002,53.,0.3228346456692913,0.21428550000000257,68.18100338125001,69.,0.41732283464566927,0.21428550000000257,68.18100338125001,77.,0.41732283464566927,0.21428550000000257,68.18100338125001,41.,0.84251968503937,0.21428550000000257,68.18100338125001,53.,0.84251968503937,0.21428550000000257);\n\nfloat g1(float x, float a){\n\treturn 0.25/(a-0.5)+0.5+sqrt(\n        x*(-0.5/(a-0.5))+\n        (-0.5+-0.25/(a-0.5))*(-0.5+-0.25/(a-0.5))\n        );\n}\nfloat g2(float x,float a){\n    return 0.25/(a-0.5)+0.5-sqrt(\n        x*(-0.5/(a-0.5))+\n        (-0.5+-0.25/(a-0.5))*(-0.5+-0.25/(a-0.5))\n        );\n}\n\nfloat bez(float x,float a){\n    if(a==0.5){return x;}\n    float b=1.-a;\n    if(a>0.5){\n        float g=g2(x,a);\n    \treturn 2.*g*b-2.*g*g*b+g*g;\n    }\n    float g=g1(x,a);\n    return 2.*g*b-2.*g*g*b+g*g;\n}\n\n// Attack Decay Sustain Release\nfloat ADSR(float time, float[3] A, float[3] D, float[3] S, float[3] R){\n    float b=0.;\n\tif(time<A[0]){\n    \treturn A[1]*bez((time)/A[0],A[2]);\n    }\n\tb+=A[0];\n    if(time<b+D[0]){\n    \treturn (A[1]+(D[1]-A[1])*bez((time-b)/D[0],D[2]));\n    }\n\tb+=D[0];\n    if(time<b+S[0]){\n    \treturn (D[1]+(S[1]-D[1])*bez((time-b)/S[0],S[2]));\n    }\n\tb+=S[0];\n    if(time<b+R[0]){\n    \treturn (S[1]+(R[1]-S[1])*bez((time-b)/R[0],R[2]));\n    }\n    return 0.;\n}\n\nfloat notePitch(float mid){\n    /*\n    switch(int(mid)){\n        case(21):\n        \treturn 27.5;\n        case(22):\n        \treturn 29.135;\n        case(23):\n        \treturn 30.868;\n        case(60):\n        \treturn 261.63;\n        case(61):\n        \treturn 277.18;\n        case(62):\n        \treturn 293.67;\n        case(63):\n        \treturn 311.13;\n        case(64):\n        \treturn 328.63;\n        case(65):\n        \treturn \n\t\tdefault:\n\t\t\treturn 0.;\n\t}\n\tI got lazy and just put in the formula\n\t*/\n    return (440./32.)*(pow(2.,(mid-9.)/12.));\n}\n\n\n// Should make a piano tone\nfloat pianoTone(float t,float hz){\n    float time=t;\n    float freq[9];\n    freq[0]=hz;\n    freq[1]=hz*2.;\n    freq[2]=hz*3.;\n    freq[3]=hz*4.;\n    freq[4]=hz*5.;\n    freq[5]=hz*6.;\n    freq[6]=hz*8.;\n    freq[7]=hz*9.;\n    freq[8]=hz*9.;\n    \n    float mag[9];\n    mag[0]=0.45;\n    mag[1]=0.814;\n    mag[2]=0.061;\n    mag[3]=0.209;\n    mag[4]=0.161;\n    mag[5]=0.022;\n    mag[6]=0.036;\n    mag[7]=0.018;\n    mag[8]=0.009;\n    float val=0.;\n    for(int i=0;i<9;i++){\n    \tval+=sin(freq[i]*time)*mag[i]+cos(freq[i]*time)*mag[i];\n    }\n    return val;\n}\n\nfloat piano(float time, float MIDI, float dur){\n    float noteP=notePitch(MIDI);\n    float A[3]=float[3](0.01,1.,0.4);\n    float D[3]=float[3](0.01,0.85,0.7);\n    float S[3]=float[3](dur-0.12,0.85/(pow(1.001,(500.+noteP)*dur)),0.2);\n    float R[3]=float[3](0.1,0.,0.);\n\treturn pianoTone(time,6.2831853*notePitch(MIDI))*ADSR(time,A,D,S,R);\n}\n\n// Should make a trumpet tone\nfloat trumpetTone(float t,float hz){\n    float time=t+sin(t*16.)*0.0001;\n    float freq[8];\n    freq[0]=hz;\n    freq[1]=hz*2.;\n    freq[2]=hz*3.;\n    freq[3]=hz*4.;\n    freq[4]=hz*5.;\n    freq[5]=hz*6.;\n    freq[6]=hz*7.;\n    freq[7]=hz*8.;\n    \n    float mag[8];\n    mag[0]=0.1155;\n    mag[1]=0.3417;\n    mag[2]=0.1789;\n    mag[3]=0.1232;\n    mag[4]=0.0678;\n    mag[5]=0.0473;\n    mag[6]=0.0260;\n    mag[7]=0.0045;\n    float val=0.;\n    for(int i=0;i<8;i++){\n    \tval+=sin(freq[i]*time)*mag[i]+cos(freq[i]*time)*mag[i];\n    }\n    return val*(0.98+cos(time*30.)*0.02);\n}\n\nfloat trumpet(float time, float MIDI, float dur){\n    float A[3]=float[3](0.05,0.7,0.5);\n    float D[3]=float[3](dur*0.5,1.,0.3);\n    float S[3]=float[3](dur*0.5-0.06,0.5,0.8);\n    float R[3]=float[3](0.1,0.,0.2);\n\treturn trumpetTone(time,6.2831853*notePitch(MIDI))*ADSR(time,A,D,S,R);\n}\n\nvec2 mainSound( in int samp, float time ){\n    //midi[0]=0.;\n\tfloat sum=0.;\n    for(int i=0; i<860; i+=4){\n        if(time>=midia[i]){\n\t\t\tsum+=trumpet(time-midia[i],midia[i+1],midia[i+3])*midia[i+2]*(0.98+cos(time*30.)*0.02)*2.;\n        }\n\t}\n    \n    for(int i=0; i<1484; i+=4){\n        if(time>=midib[i]){\n\t\t\tsum+=piano(time-midib[i],midib[i+1],midib[i+3])*midib[i+2];\n        }\n\t}\n\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sum/8. );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 309, 332, 379, 558], [560, 560, 583, 583, 706], [708, 708, 765, 765, 1356]], "test": "untested"}
{"id": "wtcSzH", "name": "Bricks takeoff", "author": "joynes", "description": "Playing with the simple bricks example from bookofshaders along with antialiasing.", "tags": ["bricks"], "likes": 1, "viewed": 340, "published": 3, "date": "1580378246", "time_retrieved": "2024-07-30T21:27:19.276334", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 t = fragCoord/iResolution.y - .5;\n    \n  float x = iTime*.1;\n  float zoom = 10.;\n  float rad = .5*(sin((x-.25)*3.1416*2.)+1.)/2.;\n  rad = -rad*rad;\n  t = mat2(cos(rad), sin(rad), -sin(rad), cos(rad))*t;\n  zoom += 3.*sin((x-.25)*3.1416*2.);\n  t *= zoom;\n  float move = (sin((fract(x)-.5)*3.1416)+1.)/2.+floor(x) + x*.4;\n  t += vec2(move*50., -rad*40.);\n\n  t.x = t.x + mod(floor(t.y), 2.);\n  float enable = mod(floor(t.x), 2.);\n  t = fract(t)-.5;\n  float r = zoom*1.*1.5/iResolution.y;\n  float w = .45;\n  float c = enable*(smoothstep(w+r, w-r, t.x) * smoothstep(w+r, w-r, abs(t.y)));\n  c += (1. - enable)*(smoothstep(-w-r, -w+r, t.x) * smoothstep(w+r, w-r, abs(t.y)));\n  vec3 col = mix(vec3(.4), vec3(.81, .45, .33), c);\n  fragColor = vec4(col, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcSzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 816]], "test": "untested"}
{"id": "wt3XRH", "name": "Banana", "author": "scottdarby", "description": "art", "tags": ["art"], "likes": 2, "viewed": 409, "published": 3, "date": "1580373425", "time_retrieved": "2024-07-30T21:27:20.123070", "image_code": "#define I_MAX\t100\n#define E\t\t0.002\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Forked from https://www.shadertoy.com/view/XttXRX\n*/\n\nvoid\tinit_vars();\nfloat\tde(vec3 pos);\nfloat\tde(vec3 pos, vec4 rad);\nfloat\tsdTorus( vec3 p, vec2 t );\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nfloat\tsmin(float a, float b, float k);\nvec2\tuv;\n\n/*\n* Distances\n*/\n\tfloat\tup_cap;\n\tfloat\tbt_cap;\n\n/*\n* Distance functions taken from iq\n*/\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\n\n\nfloat\tscene(vec3 p)\n{\n    up_cap = sdCapsule(vec3(p.y-2.4, p.z, p.x-.6), vec3(-.3, -.0, .33), vec3(.1, .0, -.31), .15);\n    bt_cap = sdCapsule(vec3(p.y+2.4, p.z, p.x-.6), vec3(.3, -.0, .33), vec3(.1, .0, .0), .15);\n\n   \n    float banana = sdTorus(p, vec2(2.4, cos(-(p.y)/1.50)));\n    if (p.x < -.45)\n        banana = 2.;\n   \n    banana = min(banana, up_cap);\n    banana = min(banana, bt_cap);\n\n    return(banana);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec4\tstep = vec4(0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E || dist.y > 20.)\n           break;\n        step.x++;\n    }\n    step.y = dist.x;\n    step.w = dist.y;\n    return (step);\n}\n\n\n//taken from an iq shader\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, 1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x-1.) * right + (uv.y-0.5) * up + fov * forw));\n}\n\nvoid\tinit_vars()\n{\n\tup_cap = 1e5;\n\tbt_cap = 1e5;\n}\n\n//https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n\tfloat res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tinit_vars(); // init skeleton and distances\n    uv  = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\tvec3\tdir = camera(uv);\n    vec4\tcol = vec4(0.0);\n    vec3\tpos = vec3(7.0, 0.0, -15.0);\n\n    vec4\tinter = (march(pos, dir));\n\n    vec3\tv = pos+inter.w*dir;\n\tvec3\tobj_color;\n    if (inter.w <= 17.)\n\t{\n        obj_color = vec3(251.0/255.0, 236.0/255.0, 93.0/255.);\n        /*\n\t\t* taken from here : https://www.shadertoy.com/view/XsB3Rm\n\t\t*/\n        vec3\tn = calcNormal(pos, E, dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(-20.0, 10.0, -25.0);\n\n        vec3\tvl = normalize(light_pos - v);\n\t\tfloat\tdiffuse  = max(0.0, dot(vl, n));\n\t\tfloat\tspecular = pow(max(0.0, dot(vl, ref_ev)), 42.);\n        col.xyz = obj_color * (diffuse + specular);\n        \n        col.a = diffuse*0.2;\n    }\n    \n   \tfragColor = vec4(0.1)+col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3XRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[525, 525, 577, 577, 691], [693, 693, 726, 726, 792], [796, 796, 817, 817, 1211], [1213, 1213, 1245, 1245, 1594], [1597, 1623, 1673, 1673, 1933], [1935, 1935, 1957, 1957, 2170], [2172, 2172, 2190, 2190, 2222], [2224, 2263, 2304, 2304, 2372], [2374, 2374, 2430, 2430, 3339]], "test": "untested"}
{"id": "tlcSRH", "name": "HSB test", "author": "tonywu", "description": "for test", "tags": ["hsb"], "likes": 2, "viewed": 326, "published": 3, "date": "1580371978", "time_retrieved": "2024-07-30T21:27:20.970804", "image_code": "#define PI 3.1415926\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 brickTile(vec2 _st, float _zoom){\n    _st *= _zoom;\n\n    // Here is where the offset is happening\n    _st.x += step(1., mod(_st.y,2.0)) * 0.5 *iTime;\n\n    return fract(_st);\n}\n\nvec2 brickTile2(vec2 _st, float _zoom){\n    _st *= _zoom;\n\n    // Here is where the offset is happening\n    _st.y += step(1., mod(_st.x,2.0)) * 0.5 *iTime;\n\n    return fract(_st);\n}\n\nvec2 movingTiles(vec2 _st, float _zoom, float _speed){\n    _st *= _zoom;\n    float time = iTime*_speed;\n    if( fract(time)>0.5 ){\n        if (fract( _st.y * 0.5) > 0.5){\n            _st.x += fract(time)*2.0;\n        } else {\n            _st.x -= fract(time)*2.0;\n        }\n    } else {\n        if (fract( _st.x * 0.5) > 0.5){\n            _st.y += fract(time)*2.0;\n        } else {\n            _st.y -= fract(time)*2.0;\n        }\n    }\n    return fract(_st);\n}\n\n\nfloat rectShape(vec2 position, vec2 scale){\n    scale = vec2(0.5) - scale * 0.5;\n    vec2 shaper = vec2(step(scale.x, position.x), step(scale.y, position.y));\n    shaper *= vec2(step(scale.x, 1.0 - position.x), step(scale.y, 1.0 - position.y));\n    return shaper.x * shaper.y;\n}\n\nfloat circleShape(vec2 position, float radius){\n    return step(radius, length(position - vec2(0.5)));\n}\n\nfloat polygonShape(vec2 position, float radius, float sides){\n    position = position * 2.0 - 1.0;\n    float angle = atan(position.x, position.y);\n    float slice = PI * 2.0 / sides;\n    return step(radius, cos(floor(0.5 + angle / slice) * slice - angle) * length(position));\n}\n\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 position = fragCoord/iResolution.xy;\n    // Divide the space in 4\n    //uv = tile(uv,4.);\n    //uv = brickTile2(uv, 4.);\n    uv = movingTiles(uv,4.,0.5);\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    \n    \n    //int tx = int(uv.x*512.0);\n    int tx = 3;\n     \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    \n    position -= vec2(0.5);\n    // rotate the space\n    position = rotate2d( sin(iTime)*PI*fft ) * uv;\n    position = scale(vec2(0.8*sin(fft))) * position;\n    // move it back to the original place\n    position += vec2(0.5);\n    \n  \n    \n    vec3 color = vec3(0.0);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0.)-uv;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*2.0;\n    \n\n\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    color = hsb2rgb(vec3(radius-iTime,abs(sin(angle+fft*iTime)),1.));\n       \n    color -= vec3(0.,0.,rectShape(position,vec2(1.,abs(sin(fft))-0.5)));\n    color -= vec3(rectShape(position,vec2(abs(sin(fft))-0.5,1.)),0.,0.);\n    \n\n\n    fragColor = vec4(color*1.5*cos(fft),1.0);\n    //fragColor.rgb = pow(color, vec3(1./2.2));\n    // apply gamma correction\n    float gamma = 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));\n}", "image_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 50, 50, 136], [138, 138, 162, 162, 225], [227, 227, 260, 260, 303], [305, 305, 343, 343, 485], [487, 487, 526, 526, 668], [670, 670, 724, 724, 1130], [1133, 1133, 1176, 1176, 1411], [1413, 1413, 1460, 1460, 1517], [1519, 1519, 1580, 1580, 1796], [1799, 1799, 1825, 1825, 2058], [2060, 2060, 2117, 2167, 3632]], "test": "untested"}
{"id": "ttG3WK", "name": "Follow BigWings's tutorial", "author": "firegump", "description": "just learning", "tags": ["raymarching"], "likes": 1, "viewed": 683, "published": 3, "date": "1580369585", "time_retrieved": "2024-07-30T21:27:22.117738", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n  \tvec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap)/dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + t * ab;\n    \n    return length(p - c) - r;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){\n  \tvec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap)/dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    vec3 c = a + t * ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t- .5) - .5) * length(ab);\n    float e = length(max(vec2(x,y), 0.));\n    float i = min(max(x,y), 0.);\n        \n    return e + i ;\n}\nfloat sdTorus(vec3 p, vec2 r){\n\tfloat x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\nfloat sdBox(vec3 p, vec3 s){\n    return length(max(abs(p) - s, 0.));\n}\n\nfloat GetDist(vec3 p){ //p is the sample point\n    vec4 s = vec4(0, 1, 6, 1);\n    float sphereDist = length(p - s.xyz) - s.w;\n    float planeDist = p.y;\n    float CapDist = sdCapsule(p, vec3(2, 1.5,5), vec3(3, 3,5), 0.3);\n    float TurDist = sdTorus(p - vec3(-3, 0.5 , 5), vec2(1.5, 0.3));\n    float BoxDist = sdBox(p - vec3(1.5,0.5 , 4), vec3(0.5));\n    float CylDist = sdCylinder(p, vec3(2, 0.3,2), vec3(6, 0.3,5), 0.3);\n    \n    float d= min(sphereDist, planeDist); \n    d = min(CapDist, d);\n    d = min(TurDist, d);\n    d = min(BoxDist, d);\n    d = min(CylDist, d);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    \n    for(int i = 0 ; i < MAX_STEPS; i++){\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\n\n\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d - vec3(GetDist(p - e.xyy),//same to vec3(d- d1, d- d2, d- d3);\n                      GetDist(p - e.yxy),\n                      GetDist(p - e.yyx));\n    \n   \n    return normalize(n);\n}\n\nvec3 GetLight(vec3 p){\n\tvec3 lightPos = vec3(0, 5, 6);\n    vec3 ligthCol = vec3(1, 1 ,1);\n    \n    float MoveRadius = 3.;\n    float MoveSpeed = 2.;\n    \n    float t = iTime * MoveSpeed;\n    lightPos.xz += vec2(sin(t), cos(t)) * MoveRadius;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    float NdotL = dot(n, l);\n    //NdotL = NdotL*.5 + .5;\n    float dif = clamp(NdotL, 0. , 1.);\n    \n    //shadow\n    float d = RayMarch(p + n * SURF_DIST *2. , l);// 2. is fixed the center of the sphere sample\n    if(d < length(lightPos - p))\n    {\n        dif *= 0.1;\n    }\n    return dif * ligthCol;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    //camera position\n    vec3 ro = vec3(0,2,-3);\n    \n    vec3 rd = normalize(vec3(uv.x,uv.y, 1));\n    \n\tfloat d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    vec3 dif = GetLight(p);\n    \n    \n    col = vec3(dif);\n    \n    \n    \n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttG3WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 117, 117, 290], [291, 291, 341, 341, 668], [669, 669, 699, 699, 771], [772, 772, 800, 800, 842], [844, 844, 866, 890, 1434], [1436, 1436, 1470, 1470, 1689], [1693, 1693, 1716, 1716, 1966], [1968, 1968, 1990, 1990, 2578], [2579, 2579, 2636, 2686, 3101]], "test": "untested"}
{"id": "wlcSz8", "name": "Better Trumpet tone", "author": "EFHIII", "description": "I'm playing around with generating sound using pure sine waves. This is a vast improvement on\nhttps://www.shadertoy.com/view/3tV3Wc Including a better attack, and overall envelope/ADSR, and some other things.", "tags": ["wave", "audio", "tone", "trumpet"], "likes": 6, "viewed": 386, "published": 3, "date": "1580363067", "time_retrieved": "2024-07-30T21:27:23.129033", "image_code": "/*\nSound text copied from\nhttps://www.shadertoy.com/view/MtyXRW\n*/\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\n/*\nADSR- Attack Decay Sustain Release\nNote range- A-440, C0-c6\n\nNote adding\n\n\n*/\n\n/*\nThis is a bare-bones MIDI:\nTime(sec), MIDI(0-88), velocity(0-1), duration(sec)\n*/\n// piano\nconst float midi[4] = float[4](0.3,58.,0.5,2.);\nfloat g1(float x, float a){\n\treturn 0.25/(a-0.5)+0.5+sqrt(\n        x*(-0.5/(a-0.5))+\n        (-0.5+-0.25/(a-0.5))*(-0.5+-0.25/(a-0.5))\n        );\n}\nfloat g2(float x,float a){\n    return 0.25/(a-0.5)+0.5-sqrt(\n        x*(-0.5/(a-0.5))+\n        (-0.5+-0.25/(a-0.5))*(-0.5+-0.25/(a-0.5))\n        );\n}\n\nfloat bez(float x,float a){\n    if(a==0.5){return x;}\n    float b=1.-a;\n    if(a>0.5){\n        float g=g2(x,a);\n    \treturn 2.*g*b-2.*g*g*b+g*g;\n    }\n    float g=g1(x,a);\n    return 2.*g*b-2.*g*g*b+g*g;\n}\n\n// Attack Decay Sustain Release\nfloat ADSR(float time, float[3] A, float[3] D, float[3] S, float[3] R){\n    float b=0.;\n\tif(time<A[0]){\n    \treturn A[1]*bez((time)/A[0],A[2]);\n    }\n\tb+=A[0];\n    if(time<b+D[0]){\n    \treturn (A[1]+(D[1]-A[1])*bez((time-b)/D[0],D[2]));\n    }\n\tb+=D[0];\n    if(time<b+S[0]){\n    \treturn (D[1]+(S[1]-D[1])*bez((time-b)/S[0],S[2]));\n    }\n\tb+=S[0];\n    if(time<b+R[0]){\n    \treturn (S[1]+(R[1]-S[1])*bez((time-b)/R[0],R[2]));\n    }\n    return 0.;\n}\n\nfloat notePitch(float mid){\n    return (440./32.)*(pow(2.,(mid-9.)/12.));\n}\n\nfloat trumpetTone(float t,float hz){\n    float time=t+sin(t*16.)*0.0001;\n    float freq[8];\n    freq[0]=hz;\n    freq[1]=hz*2.;\n    freq[2]=hz*3.;\n    freq[3]=hz*4.;\n    freq[4]=hz*5.;\n    freq[5]=hz*6.;\n    freq[6]=hz*7.;\n    freq[7]=hz*8.;\n    \n    float mag[8];\n    mag[0]=0.1155;\n    mag[1]=0.3417;\n    mag[2]=0.1789;\n    mag[3]=0.1232;\n    mag[4]=0.0678;\n    mag[5]=0.0473;\n    mag[6]=0.0260;\n    mag[7]=0.0045;\n    float val=0.;\n    for(int i=0;i<8;i++){\n    \tval+=sin(freq[i]*time)*mag[i];\n    }\n    return val*(0.98+cos(time*30.)*0.02)*2.;\n}\n\n// Should make a piano tone\nfloat trumpet(float time, float MIDI, float dur){\n    float A[3]=float[3](0.005,0.7,1.);\n    float D[3]=float[3](dur*0.55,1.,0.3);\n    float S[3]=float[3](dur*0.5-0.06,0.5,0.8);\n    float R[3]=float[3](0.05,0.,0.);\n\treturn trumpetTone(time,6.2831853*notePitch(MIDI))*ADSR(time,A,D,S,R);\n}\n\nfloat getWave(in float time){\n    float sum=0.;\n    for(int i=0; i<1; i+=4){\n        if(time>=midi[i]){\n\t\t\tsum+=trumpet(time-midi[i],midi[i+1],midi[i+3])*midi[i+2];\n        }\n        else if(time>midi[i]+midi[i+3]){\n\t\t\ti=10000;\n        }\n\t}\n    return sum;\n}\n\nfloat func(in float x){\n    float val = -getWave(x*0.06+iTime);\n\treturn val/2.1+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iResolution.y<2000.) {\n        float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);\n    \tif(c>=0.){\n            fragColor=vec4(c);return;\n        }\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    \n    float max=1.;\n    for(float i=-.005;i<=.005;i+=0.0002){\n\t    float val = func(uv.x+i);\n        //float v = (abs(uv.y-val))*mag;\n        float v=50.*sqrt((uv.y-val)*(uv.y-val)+10.*i*i);\n        \n        if(v<max){\n            max=v;\n\t\t\tfragColor = vec4(1.-v,0.,v,1.);\n\t\t}\n    }\n    if(max==1.){\n    \tfragColor=vec4(0.,0.,0.2,1.);\n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "/*\nADSR- Attack Decay Sustain Release\nNote range- A-440, C0-c6\n\nNote adding\n\n\n*/\n\n/*\nThis is a bare-bones MIDI:\nTime(sec), MIDI(0-88), velocity(0-1), duration(sec)\n*/\n// piano\nconst float midi[4] = float[4](0.3,58.,0.5,2.);\nfloat g1(float x, float a){\n\treturn 0.25/(a-0.5)+0.5+sqrt(\n        x*(-0.5/(a-0.5))+\n        (-0.5+-0.25/(a-0.5))*(-0.5+-0.25/(a-0.5))\n        );\n}\nfloat g2(float x,float a){\n    return 0.25/(a-0.5)+0.5-sqrt(\n        x*(-0.5/(a-0.5))+\n        (-0.5+-0.25/(a-0.5))*(-0.5+-0.25/(a-0.5))\n        );\n}\n\nfloat bez(float x,float a){\n    if(a==0.5){return x;}\n    float b=1.-a;\n    if(a>0.5){\n        float g=g2(x,a);\n    \treturn 2.*g*b-2.*g*g*b+g*g;\n    }\n    float g=g1(x,a);\n    return 2.*g*b-2.*g*g*b+g*g;\n}\n\n// Attack Decay Sustain Release\nfloat ADSR(float time, float[3] A, float[3] D, float[3] S, float[3] R){\n    float b=0.;\n\tif(time<A[0]){\n    \treturn A[1]*bez((time)/A[0],A[2]);\n    }\n\tb+=A[0];\n    if(time<b+D[0]){\n    \treturn (A[1]+(D[1]-A[1])*bez((time-b)/D[0],D[2]));\n    }\n\tb+=D[0];\n    if(time<b+S[0]){\n    \treturn (D[1]+(S[1]-D[1])*bez((time-b)/S[0],S[2]));\n    }\n\tb+=S[0];\n    if(time<b+R[0]){\n    \treturn (S[1]+(R[1]-S[1])*bez((time-b)/R[0],R[2]));\n    }\n    return 0.;\n}\n\nfloat notePitch(float mid){\n    /*\n    switch(int(mid)){\n        case(21):\n        \treturn 27.5;\n        case(22):\n        \treturn 29.135;\n        case(23):\n        \treturn 30.868;\n        case(60):\n        \treturn 261.63;\n        case(61):\n        \treturn 277.18;\n        case(62):\n        \treturn 293.67;\n        case(63):\n        \treturn 311.13;\n        case(64):\n        \treturn 328.63;\n        case(65):\n        \treturn \n\t\tdefault:\n\t\t\treturn 0.;\n\t}\n\tI got lazy and just put in the formula\n\t*/\n    return (440./32.)*(pow(2.,(mid-9.)/12.));\n}\n\nfloat trumpetTone(float t,float hz){\n    float time=t+sin(t*16.)*0.0001;\n    float freq[8];\n    freq[0]=hz;\n    freq[1]=hz*2.;\n    freq[2]=hz*3.;\n    freq[3]=hz*4.;\n    freq[4]=hz*5.;\n    freq[5]=hz*6.;\n    freq[6]=hz*7.;\n    freq[7]=hz*8.;\n    \n    float mag[8];\n    mag[0]=0.1155;\n    mag[1]=0.3417;\n    mag[2]=0.1789;\n    mag[3]=0.1232;\n    mag[4]=0.0678;\n    mag[5]=0.0473;\n    mag[6]=0.0260;\n    mag[7]=0.0045;\n    float val=0.;\n    for(int i=0;i<8;i++){\n    \tval+=sin(freq[i]*time)*mag[i];\n    }\n    return val*(0.98+cos(time*30.)*0.02)*2.;\n}\n\n// Should make a piano tone\nfloat trumpet(float time, float MIDI, float dur){\n    float A[3]=float[3](0.005,0.7,1.);\n    float D[3]=float[3](dur*0.55,1.,0.3);\n    float S[3]=float[3](dur*0.5-0.06,0.5,0.8);\n    float R[3]=float[3](0.05,0.,0.);\n\treturn trumpetTone(time,6.2831853*notePitch(MIDI))*ADSR(time,A,D,S,R);\n}\n\nvec2 mainSound( in int samp, float time ){\n    //midi[0]=0.;\n\tfloat sum=0.;\n    for(int i=0; i<1; i+=4){\n        if(time>=midi[i]){\n\t\t\tsum+=trumpet(time-midi[i],midi[i+1],midi[i+3])*midi[i+2];\n        }\n        else if(time>midi[i]+midi[i+3]){\n\t\t\ti=10000;\n        }\n\t}\n\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sum/3. );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 309, 332, 379, 558], [784, 784, 811, 811, 931], [932, 932, 958, 958, 1081], [1083, 1083, 1110, 1110, 1288], [1769, 1769, 1796, 1796, 1844], [1846, 1846, 1882, 1882, 2394], [2396, 2424, 2473, 2473, 2712], [2714, 2714, 2743, 2743, 2972], [2974, 2974, 2997, 2997, 3060], [3062, 3062, 3119, 3119, 3818]], "test": "untested"}
{"id": "ttcSz8", "name": "Generative Color with Music", "author": "tonywu", "description": "color", "tags": ["music"], "likes": 2, "viewed": 274, "published": 3, "date": "1580360225", "time_retrieved": "2024-07-30T21:27:24.041593", "image_code": "// HSB to RGB\nvec3 hsb2rgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n        // the sound texture is 512x2\n    int tx = int(uv.x*512.0)/10;\n    //int tx = 1;\n     \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n\n    // Calculate hue based on current horizontal pixel\n    // and cursor position.\n    float stepX = fft*9.0;\n    float hue = floor(stepX * uv.x) / stepX;\n\n    // Calculate saturation based on current vertical\n    // pixel and cursor position.\n    float stepY = fft*5.;\n    float sat = 1.0 - floor(stepY * uv.y)/ stepY;\n    \n    // Generate HSB color.\n    vec3 col = hsb2rgb(vec3(\n        hue,\n        sat,\n        1.0\n    ));\n    float y = fft*cos(uv.x*50.*fft+iTime*50.)*0.5+0.5;\n\n    vec3 color = vec3(y);\n    float pct = plot(uv,y);\n    color = pct*vec3(0.0,1.0,0.0);\n    \n    col -= color;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 14, 39, 39, 217], [219, 219, 250, 250, 341], [343, 343, 400, 450, 1385]], "test": "untested"}
{"id": "tlcSR8", "name": "de_ko_bo_ko", "author": "zephyran", "description": "life", "tags": ["cineshader"], "likes": 0, "viewed": 12550, "published": 3, "date": "1580355575", "time_retrieved": "2024-07-30T21:27:24.806548", "image_code": "float Hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uv2 = uv;\n    \n    uv2 *= 16.;\n    \n    vec2 gv = fract(uv2);\n    vec2 id = floor(uv2);\n    \n    float r = Hash21(id);\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * 25.0 - iTime * 4.0;\n    \n    // Calculate the ripple thickness\n    d = (cos(t) * 0.5 + 0.5) * (1.0 - d);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\n    // Set the output color to rgb channels and the thickness to alpha channel\n    // AO is automatically calculated\n    fragColor = vec4(col, r+(sin(iTime*r)*.5));\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"dekoboko\",\n\t\"description\": \"life\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 116], [118, 118, 175, 225, 919]], "test": "untested"}
{"id": "3tV3Wd", "name": "Ringworld", "author": "Plento", "description": " I wanted to render something large scale and play around with camera animations. It's far from perfect, but I have some ideas on how to do it way better. I wanna make this thing look HUGE.", "tags": ["3d", "color", "space", "animation", "ring", "glow", "world"], "likes": 15, "viewed": 413, "published": 3, "date": "1580352445", "time_retrieved": "2024-07-30T21:27:25.876687", "image_code": "// Plento\nvec2 R;\n\nvec3 cm(vec3 p){p.yz *= rot(-0.6); return texture(iChannel2, p).xyz;}\nvec3 t1(vec2 p){return texture(iChannel1, p).xyz;}\n\n//  from iQ's website\nvec2 opRevolution( in vec3 p, float w ){\n    return vec2( length(p.xz) - w, p.y );\n}\n\nfloat sdBox2D( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n// the ring\nfloat ring(vec3 rp){\n    rp.xy *= rot(pi/2.);\n    return sdBox2D(opRevolution(rp,180.0), vec2(0.1, 16.0));\n}\n\n\nfloat map(vec3 rp){\n    float d = 999.0;\n   \n    vec3 p0 = rp - vec3(16.25, 0.25, 0.);\n    vec3 p1 = rp - vec3(-16.25, 0.25, 0.);\n    \n    // main ring\n    d = ring(rp);\n    \n\t// outer walls\n    p0.xy*=rot(pi/2.); p1.xy*=rot(pi/2.);\n    d = min(d, sdBox2D(opRevolution(p0,180.0), vec2(.4, .25)));\n    d = min(d, sdBox2D(opRevolution(p1,180.0), vec2(.4, .25)));\n    \n    return d;\n}\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nvec2 march(vec3 rd, vec3 ro){\n    float t = 0., d = 0., md = 999.;\n   \n    for(int i = 0; i < 100; i++){\n    \td = map(ro + rd*t); \t   \n        md = min(d, md);\n        \n        if(abs(d) < 0.002){break;}\n        if(t >= FAR){t = FAR; break;}\n      \t\n        t += d * 0.75;\n    }   \n    return vec2(t, md);\n}\n\n// Bump map stuff\nfloat height(vec2 p){\t\n    return t1(p).r;\n}\n\nvec3 TextureBump(vec2 uv, float strength){\n    float h = 0.002;\n    vec3 p = vec3(0);\n    \n    p = t1(uv);\n    \n    float dx = height(uv) - height(uv + vec2(h, .0));\n    float dy = height(uv) - height(uv + vec2(0., h));\n    \n    return normalize( vec3(0., 0., -1.) + vec3(dx, dy, 0.)*strength);\n}\n\n// inside or outside ring\nfloat checkside(vec3 rd, vec3 ro){\n    float d = 0., t = 0.;\n    \n    for(int i = 0; i < 10; i++){\n    \td = ring(ro + rd*t); \t   \n        if(abs(d) < .0001){break;}\n        t += d;\n    }   \n    return t;\n}\n\n// Stars and dust\nvec3 space(vec3 rd){\n    float star = smoothstep(.55,.62, simplex3d(rd*150.));\n    float dust = texture(iChannel0, vec3(rd.x, rd.y-.2, rd.z) + simplex3d(rd*10.)*.22 ).r;\n    return mix(vec3(star), vec3(dust), .07);\n}\n\n// Object color\nvec3 render(vec3 ro, vec3 rd, vec3 n, float t, float md){\n    vec3 p = ro + rd*t;\n    vec3 ref = reflect( rd, n );\n    \n    // Light direction for water (we need a real sun)\n    vec3 ld = vec3(0., 7., 3.5);\n    ld = max(normalize(ld), vec3(.001));\n    \n    vec3 col = vec3(0);\n    \n    if(t < FAR){\n    \t// uvs for ring\n    \tfloat theta = atan(p.y, p.z);\n    \tvec2 uv = vec2(p.x, theta * 100.) * .095;\n    \n    \t// bumpy normals for water\n    \tvec3 bnw = TextureBump((3.*vec2(uv.x, uv.y*2. +iTime*.02) * .35), 5.);\n    \t\n    \t// Water specular\n    \tfloat spec = pow(max(dot(reflect(-ld,normalize(n+bnw)), -rd ),.0),8.);\n        \n        // Diffuse walls\n        float waldif = clamp(dot(n,ld), 0.17, 1.0 );\n        \n    \t// noise values\n    \tfloat nse = 1.-exp(-octnse(vec2(0.4, 1.)*uv + vec2(0.6, 5.4), 7)); \n    \tfloat nse2 = 1.-exp(-octnse(3.*vec2(uv.x, uv.y*2.), 4)); \n    \t\n    \t// land blend value\n    \tfloat ls = ss(.62, .62 + .004, nse); \n    \n    \t// textures\n    \tvec3 dirt = mix(vec3(0.4, 0.1, 0.)*.4, vec3(0.2, 0.2, 0.2), nse2);\n    \tvec3 grass = mix(vec3(0.4, 0.6, 0.), vec3(0.2, 0.2, 0.), nse2);\n        vec3 water = mix(vec3(.0, .21, .6), cm(abs(rd) + bnw*.4), 0.23);\n    \tvec3 wall = vec3(0.8);\n        \n    \t// dirt grass blend value\n    \tfloat ds = ss(.534, .534 + .1, nse);\n    \n    \t// land color\n    \tvec3 land = mix(grass, dirt, ds);\n        \n    \t// add specular to water\n    \twater += vec3(0.7, 0.5, 0.1) * spec*.75;\n        \n    \t// main color for water, land and walls\n    \tcol = mix(mix(land, water, ls), wall, step(16., abs(p.x)));\n    \t\n        // distance blueing\n        col = mix( col, vec3(0.4, 0.6, 0.9), min(.7,1. - exp( -0.000001*t*t*t)));     \n        float dom = ss(-0.1, 0.1, ref.y);\n        col += .05*dom*vec3(0.4,0.6,1.3)*dom;\n        \n    \t// ring side color\n    \tcol = mix(col, wall*waldif, step(.9, abs(n.x)));\n    \n        // underside color\n    \trd = normalize(-p);\n    \tfloat undr = checkside(rd, p);\n        col = mix(wall*(.06+bnw.x*.6), col, step(.009, undr));\n         \n    }\n    else\n    \tcol = space(rd);\n    \n    \n\treturn col;   \n}\n\n// Perhaps not the most optimal way to do camera animation but I'll keep it till I come up with a better way \nmat2x3 camera(vec2 uv, float t){\n    vec3 forward = vec3(0., 0., 1.);\n    vec3 rd = normalize(vec3(uv, .75));\n    \n    vec3 pos = cs1;\n    vec3 lookAt = vec3(0);\n    \n    // v = 0-1 smoothstep based on time, r = rotation animation based on v, z = fov animation based on v\n    float v = 0., r = 0., z = 0.;\n    \n    t = mod(t, 18.);\n    \n    if(t < 1.){\n     \tv = ss(0., 1., t);\n        z = mix(.05, .75, v);\n        rd = normalize(vec3(uv, z));\n    }\n    if(t <= 5.){ \n     \tpos = mix(mix(cs1, cs1, ss(0., 1., t)), cs2, ss(1., 5., t));\n        // simple pointing camera towards origin. Only works for xz rotations lol\n        lookAt = normalize(-pos);\n        float ct = dot(forward, lookAt);\n        float aX = acos(ct);\n        rd.xz *= rot(aX * sign(pos.x));\n    }\n    if(t >= 5. ){ \n     \tpos = mix(cs3, cs4, ss(5., 7., t));\n        rd.yz *= rot(-.4);\n    }\n    if(t >= 7. ){ \n        v = ss(7., 9., t); // Interp value\n        z = mix(.75, .55, v); // new fov\n     \tpos = mix(cs4, cs5, v); // new position\n        \n        rd = normalize(vec3(uv, z)); // set fov\n        rd.yz *= rot(-.4); // do rotations\n        rd.yz *= rot(-v*.2);\n    }\n\tif(t >= 9. ){ \n        v = ss(9., 11., t);\n        r = mix(0., 1.17, v);\n        \n        rd.yz *= rot(-r);\n        rd.xz *= rot(-r*1.34);\n    }\n\tif(t >= 11. ){ \n        v = ss(11., 13., t);\n        r = mix(0., 1.17, v);\n        \n        rd.xz *= rot(-r*1.34);\n        rd.yz *= rot(-r*1.2);\n    }\n    if(t >= 14. ){ \n        v = ss(14., 20., t);\n        \n        rd = normalize(vec3(uv, 1.));\n        rd.xz *= rot(-1.1);\n        pos = mix(cs6, cs7, v);\n    }\n    \n\treturn mat2x3 (pos, rd);\n}\n\n// Simple lil fade in out\nfloat fade(float time, float x, float dur){\n \treturn 1.-exp(-dur*pow(time - x, 2.));\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n  \t\n    float time = mod(iTime, 18.);\n    \n    vec3 col = vec3(0);\n\t\n    // Camera stuff\n    mat2x3 cam = camera(uv, iTime);\n    \n    vec3 ro = cam[0];\n    vec3 rd = cam[1];\n    \n    // March stuff\n    vec2 t = march(rd, ro);\n    vec3 n = normal(ro + rd*t.x);\n    \n    // Object color\n    col = render(ro, rd, n, t.x, t.y);\n    \n    // cloud noise and color\n    float clouds = 1.-exp(-octnse3D(3.*vec3(rd.x, rd.y, rd.z-time*.16), 4));\n    vec3 blue = mix(vec3(0., 0., 0.9), vec3(0.3, 0.3, 0.9), step(6., time)-step(14., time));\n    vec3 skycol = mix(blue, vec3(1), clouds);\n    \n    // Change amout of glow depending on x position which gives transition from space to sky\n    float dcs = mix(20., ro.x, step(4., time));\n    float gval = mix(1., .00001, ss(30., 0., abs(dcs)));\n    float glow = exp(-t.y*gval);\n    \n    \n    vec3 closecol = mix(skycol, col, exp(-.006*t.x)); // clouds + geometry\n    vec3 farcol = vec3(0);\n    \n    // add glow if miss object\n    if(t.y > .01)farcol = mix(col, skycol, exp(-t.y*.23));else farcol = col;\n    \n    // Determine final color based on where we are \n    col = mix(closecol, farcol, ss(0., 10., abs(dcs)));\n    \n    // Do fades\n    col *= fade(time, 0., 8.);\n    col *= fade(time, 5., 8.);\n    col *= fade(time, 14., 8.);\n    col *= fade(time, 18., 6.);\n    \n    //col = pow(col,vec3(1./2.2));\n    \n    f = vec4(col, 1.0);\n    \n}\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ss(a, b, t) smoothstep(a, b, t)\n#define FAR 800.\n\n#define cs1 vec3(-300., 0., -310.)\n#define cs2 vec3(300., 0., -310.)\n#define cs3 vec3(50., -178., 0.)\n#define cs4 vec3(0., -178., 0.)\n#define cs5 vec3(0., -175., 20.)\n#define cs6 vec3(-60., 0., 100.)\n#define cs7 vec3(-60., 0., 170.)\n\nconst float pi = 3.14159;\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\n// Lots of noise \n\nvec2 hash22( vec2 x ){\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// Gradient noise\nfloat gdns(vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = ss(0., 1., f);\n    \n    vec2 a = hash22(i);\n    vec2 b = hash22( i + vec2(1.,0.));\n    vec2 c = hash22( i + vec2(.0,1.));\n    vec2 d = hash22( i + vec2(1));\n    \n    float nse = mix( mix( dot( a, f - vec2(0.0,0.0) ), \n                     dot( b, f - vec2(1.0,0.0) ), u.x),\n                mix( dot( c, f - vec2(0.0,1.0) ), \n                     dot( d, f - vec2(1) ), u.x), u.y);\n    return nse + 0.5;\n}\n\n\n// 3D simplex noise stuff from: https://www.shadertoy.com/view/XsX3zB\nconst float F3 =  .3333333;\nconst float G3 =  .1666667;\nvec3 random3(vec3 c) {\n\tfloat j = 4096.*sin(dot(c,vec3(17., 59.4, 15.)));\n\tvec3 r;\n\tr.z = fract(512.*j);\n\tj *= .125;\n\tr.x = fract(512.*j);\n\tj *= .125;\n\tr.y = fract(512.*j);\n\treturn r-.5;\n}\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t vec3 e = step(vec3(0.), x - x.yzx);\n\t vec3 i1 = e*(1. - e.zxy);\n\t vec3 i2 = 1. - e.zxy*(1. - e);\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.*G3;\n\t vec3 x3 = x - 1. + 3.*G3;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(.6 - w, 0.);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n    \n     float nse = dot(d, vec4(52.));\n    \n\t return 1.-exp(-(nse+1.)*.5);\n  \n}\n\n// octave noise for 2d and 3d. Coulda done with 1 but oh well\nfloat octnse(vec2 p, int oct){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n     \tn += gdns(p) * a;\t\n        p*=2.;\n        a *= .5;\n    }\n    \n    return n;\n}\nfloat octnse3D(vec3 p, int oct){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n     \tn += simplex3d(p) * a;\n        p*=2.;\n        a *= .35;\n    }\n    \n    return n;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tV3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 35, 35, 88], [89, 89, 105, 105, 139], [141, 163, 203, 203, 247], [249, 249, 287, 287, 371], [373, 385, 405, 405, 493], [496, 496, 515, 515, 877], [880, 880, 907, 907, 1108], [1110, 1110, 1139, 1139, 1417], [1419, 1437, 1458, 1458, 1481], [1483, 1483, 1525, 1525, 1779], [1781, 1807, 1841, 1841, 2012], [2014, 2032, 2052, 2052, 2248], [2250, 2266, 2323, 2323, 4352], [4354, 4464, 4496, 4496, 6102], [6104, 6130, 6173, 6173, 6216], [6218, 6218, 6258, 6258, 7694]], "test": "untested"}
{"id": "wlV3Dc", "name": "Greensleeves", "author": "EFHIII", "description": "Greensleeves is a classic medieval song. This is a sound shader that plays it based on some MIDI data I had using what's effectively a MIDI player I wrote.", "tags": ["sound", "audio", "midi"], "likes": 4, "viewed": 334, "published": 3, "date": "1580349981", "time_retrieved": "2024-07-30T21:27:26.935855", "image_code": "/*\nSound text copied from\nhttps://www.shadertoy.com/view/MtyXRW\n*/\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nfloat getWave(in float time){\n\tfloat Tau=6.2831853;\n \n    float C=Tau*261.6256;\n    \n    return sin(time*C);\n}\n\nfloat func(in float x){\n    float Tau = 6.2831853;\n    float t = (x+iTime/6.)*Tau*2.;\n    float val = -getWave(x*0.01+iTime);\n\treturn val/2.1+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iResolution.y<2000.) {\n        float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);\n    \tif(c>=0.){\n            fragColor=vec4(c);return;\n        }\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n   \tfloat mag=50.;\n    float maxV=0.;\n    \n    float val = func(uv.x);\n    if(uv.y>val-0.02&&uv.y<val+0.02){\n\t\tval = (abs(uv.y-val))*mag;\n    \tfragColor = vec4(1.-val,0.,val,1.);\n    }\n    else{\n    \tfragColor=vec4(0.,0.,0.2,1.);\n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "/*\nADSR- Attack Decay Sustain Release\nNote range- A-440, C0-c6\n\nNote adding\n\n\n*/\n\n/*\nThis is a bare-bones MIDI:\nTime(sec), MIDI(0-88), velocity(0-1), duration(sec)\n*/\n// piano\nconst float midi[1832] = float[1832](0.,64.,0.5039370078740157,0.49895833333333334,0.5,67.,0.5039370078740157,0.9989583333333334,0.5,52.,0.3858267716535433,0.4989583333333333,1.,55.,0.3858267716535433,0.4989583333333334,1.5,69.,0.5039370078740157,0.4989583333333334,1.5,59.,0.3858267716535433,0.4989583333333334,2.,71.,0.5039370078740157,0.7489583333333334,2.,52.,0.3858267716535433,0.4989583333333334,2.5,55.,0.3858267716535433,0.4989583333333334,2.75,72.,0.5039370078740157,0.2489583333333334,3.,71.,0.5039370078740157,0.4989583333333334,3.,59.,0.3858267716535433,0.4989583333333334,3.5,69.,0.5039370078740157,0.9989583333333334,3.5,50.,0.3858267716535433,0.4989583333333334,4.,54.,0.3858267716535433,0.4989583333333334,4.5,66.,0.5039370078740157,0.4989583333333334,4.5,57.,0.3858267716535433,0.4989583333333334,5.,62.,0.5039370078740157,0.7489583333333334,5.,50.,0.3858267716535433,0.4989583333333334,5.5,54.,0.3858267716535433,0.4989583333333334,5.75,64.,0.5039370078740157,0.2489583333333334,6.,66.,0.5039370078740157,0.4989583333333334,6.,57.,0.3858267716535433,0.4989583333333334,6.5,67.,0.5039370078740157,0.9989583333333334,6.5,48.,0.3858267716535433,0.4989583333333334,7.,52.,0.3858267716535433,0.4989583333333334,7.5,64.,0.5039370078740157,0.4989583333333334,7.5,55.,0.3858267716535433,0.4989583333333334,8.,64.,0.5039370078740157,0.7489583333333325,8.,48.,0.3858267716535433,0.4989583333333325,8.5,52.,0.3858267716535433,0.4989583333333325,8.75,63.,0.5039370078740157,0.2489583333333325,9.,64.,0.5039370078740157,0.4989583333333325,9.,55.,0.3858267716535433,0.4989583333333325,9.5,66.,0.5039370078740157,0.9989583333333325,9.5,47.,0.3858267716535433,0.4989583333333325,10.,51.,0.3858267716535433,0.4989583333333325,10.5,63.,0.5039370078740157,0.4989583333333325,10.5,54.,0.3858267716535433,0.4989583333333325,11.,59.,0.5039370078740157,0.9989583333333325,11.,47.,0.3858267716535433,0.4989583333333325,11.5,54.,0.3858267716535433,0.4989583333333325,12.,64.,0.5039370078740157,0.4989583333333325,12.,57.,0.3858267716535433,0.4989583333333325,12.5,67.,0.5039370078740157,0.9989583333333325,12.5,52.,0.3858267716535433,0.4989583333333325,13.,55.,0.3858267716535433,0.4989583333333325,13.5,69.,0.5039370078740157,0.4989583333333325,13.5,59.,0.3858267716535433,0.4989583333333325,14.,71.,0.5039370078740157,0.7489583333333325,14.,52.,0.3858267716535433,0.4989583333333325,14.5,55.,0.3858267716535433,0.4989583333333325,14.75,72.,0.5039370078740157,0.2489583333333325,15.,71.,0.5039370078740157,0.4989583333333325,15.,59.,0.3858267716535433,0.4989583333333325,15.5,69.,0.5039370078740157,0.9989583333333343,15.5,50.,0.3858267716535433,0.4989583333333325,16.,54.,0.3858267716535433,0.4989583333333343,16.5,66.,0.5039370078740157,0.4989583333333343,16.5,57.,0.3858267716535433,0.4989583333333343,17.,62.,0.5039370078740157,0.7489583333333343,17.,50.,0.3858267716535433,0.4989583333333343,17.5,54.,0.3858267716535433,0.4989583333333343,17.75,64.,0.5039370078740157,0.24895833333333428,18.,66.,0.5039370078740157,0.4989583333333343,18.,57.,0.3858267716535433,0.4989583333333343,18.5,67.,0.5039370078740157,0.7489583333333343,18.5,48.,0.3858267716535433,0.4989583333333343,19.,52.,0.3858267716535433,0.4989583333333343,19.25,66.,0.5039370078740157,0.24895833333333428,19.5,64.,0.5039370078740157,0.4989583333333343,19.5,55.,0.3858267716535433,0.4989583333333343,20.,63.,0.5039370078740157,0.7489583333333343,20.,47.,0.3858267716535433,0.4989583333333343,20.5,54.,0.3858267716535433,0.4989583333333343,20.75,61.,0.5039370078740157,0.24895833333333428,21.,63.,0.5039370078740157,0.4989583333333343,21.,59.,0.3858267716535433,0.4989583333333343,21.5,64.,0.5039370078740157,0.9989583333333343,21.5,52.,0.3858267716535433,0.7489583333333343,22.25,57.,0.3858267716535433,0.24895833333333428,22.5,64.,0.5039370078740157,0.4989583333333343,22.5,54.,0.3858267716535433,0.4989583333333343,23.,64.,0.5039370078740157,1.4989583333333343,23.,59.,0.3858267716535433,1.4989583333333343,23.,55.,0.3858267716535433,1.4989583333333343,23.,52.,0.3858267716535433,1.4989583333333343,24.5,74.,0.5039370078740157,1.4989583333333343,24.5,55.,0.3858267716535433,0.4989583333333343,25.,59.,0.3858267716535433,0.4989583333333343,25.5,62.,0.3858267716535433,0.4989583333333343,26.,74.,0.5039370078740157,0.7489583333333343,26.,55.,0.3858267716535433,0.4989583333333343,26.5,59.,0.3858267716535433,0.4989583333333343,26.75,73.,0.5039370078740157,0.24895833333333428,27.,71.,0.5039370078740157,0.4989583333333343,27.,62.,0.3858267716535433,0.4989583333333343,27.5,69.,0.5039370078740157,0.9989583333333343,27.5,50.,0.3858267716535433,0.4989583333333343,28.,54.,0.3858267716535433,0.4989583333333343,28.5,66.,0.5039370078740157,0.4989583333333343,28.5,57.,0.3858267716535433,0.4989583333333343,29.,62.,0.5039370078740157,0.7489583333333343,29.,50.,0.3858267716535433,0.4989583333333343,29.5,54.,0.3858267716535433,0.4989583333333343,29.75,64.,0.5039370078740157,0.24895833333333428,30.,66.,0.5039370078740157,0.4989583333333343,30.,57.,0.3858267716535433,0.4989583333333343,30.5,67.,0.5039370078740157,0.9989583333333343,30.5,48.,0.3858267716535433,0.4989583333333343,31.,52.,0.3858267716535433,0.4989583333333343,31.5,64.,0.5039370078740157,0.4989583333333343,31.5,55.,0.3858267716535433,0.4989583333333343,32.,64.,0.5039370078740157,0.7489583333333343,32.,48.,0.3858267716535433,0.4989583333333343,32.5,52.,0.3858267716535433,0.4989583333333343,32.75,63.,0.5039370078740157,0.24895833333333428,33.,64.,0.5039370078740157,0.4989583333333343,33.,55.,0.3858267716535433,0.4989583333333343,33.5,66.,0.5039370078740157,0.9989583333333343,33.5,47.,0.3858267716535433,0.4989583333333343,34.,51.,0.3858267716535433,0.4989583333333343,34.5,63.,0.5039370078740157,0.4989583333333343,34.5,54.,0.3858267716535433,0.4989583333333343,35.,59.,0.5039370078740157,1.4989583333333343,35.,47.,0.3858267716535433,0.4989583333333343,35.5,54.,0.3858267716535433,0.4989583333333343,36.,57.,0.3858267716535433,0.4989583333333343,36.5,74.,0.5039370078740157,1.4989583333333343,36.5,55.,0.3858267716535433,0.4989583333333343,37.,59.,0.3858267716535433,0.4989583333333343,37.5,62.,0.3858267716535433,0.4989583333333343,38.,74.,0.5039370078740157,0.7489583333333343,38.,55.,0.3858267716535433,0.4989583333333343,38.5,59.,0.3858267716535433,0.4989583333333343,38.75,73.,0.5039370078740157,0.24895833333333428,39.,71.,0.5039370078740157,0.4989583333333343,39.,62.,0.3858267716535433,0.4989583333333343,39.5,69.,0.5039370078740157,0.9989583333333343,39.5,50.,0.3858267716535433,0.4989583333333343,40.,54.,0.3858267716535433,0.4989583333333343,40.5,66.,0.5039370078740157,0.4989583333333343,40.5,57.,0.3858267716535433,0.4989583333333343,41.,62.,0.5039370078740157,0.7489583333333343,41.,50.,0.3858267716535433,0.4989583333333343,41.5,54.,0.3858267716535433,0.4989583333333343,41.75,64.,0.5039370078740157,0.24895833333333428,42.,66.,0.5039370078740157,0.4989583333333343,42.,57.,0.3858267716535433,0.4989583333333343,42.5,67.,0.5039370078740157,0.7489583333333343,42.5,48.,0.3858267716535433,0.4989583333333343,43.,52.,0.3858267716535433,0.4989583333333343,43.25,66.,0.5039370078740157,0.24895833333333428,43.5,64.,0.5039370078740157,0.4989583333333343,43.5,55.,0.3858267716535433,0.4989583333333343,44.,63.,0.5039370078740157,0.7489583333333343,44.,47.,0.3858267716535433,0.4989583333333343,44.5,54.,0.3858267716535433,0.4989583333333343,44.75,61.,0.5039370078740157,0.24895833333333428,45.,63.,0.5039370078740157,0.4989583333333343,45.,59.,0.3858267716535433,0.4989583333333343,45.5,64.,0.5039370078740157,1.4989583333333343,45.5,52.,0.3858267716535433,0.4989583333333343,46.,55.,0.3858267716535433,0.4989583333333343,46.5,59.,0.3858267716535433,0.4989583333333343,47.,64.,0.5039370078740157,0.9989583333333343,47.,59.,0.3858267716535433,1.4989583333333343,47.,55.,0.3858267716535433,1.4989583333333343,47.,52.,0.3858267716535433,1.4989583333333343,48.,76.,0.5039370078740157,0.4989583333333343,48.5,79.,0.5039370078740157,0.9989583333333343,48.5,52.,0.3858267716535433,0.4989583333333343,49.,55.,0.3858267716535433,0.4989583333333343,49.5,81.,0.5039370078740157,0.4989583333333343,49.5,59.,0.3858267716535433,0.4989583333333343,50.,83.,0.5039370078740157,0.7489583333333343,50.,52.,0.3858267716535433,0.4989583333333343,50.5,55.,0.3858267716535433,0.4989583333333343,50.75,84.,0.5039370078740157,0.24895833333333428,51.,83.,0.5039370078740157,0.24895833333333428,51.,59.,0.3858267716535433,0.4989583333333343,51.25,79.,0.5039370078740157,0.24895833333333428,51.5,81.,0.5039370078740157,0.9989583333333343,51.5,50.,0.3858267716535433,0.4989583333333343,52.,54.,0.3858267716535433,0.24895833333333428,52.25,57.,0.3858267716535433,0.24895833333333428,52.5,78.,0.5039370078740157,0.24895833333333428,52.5,62.,0.3858267716535433,0.24895833333333428,52.75,76.,0.5039370078740157,0.24895833333333428,52.75,57.,0.3858267716535433,0.24895833333333428,53.,74.,0.5039370078740157,0.7489583333333343,53.,50.,0.3858267716535433,0.4989583333333343,53.5,54.,0.3858267716535433,0.4989583333333343,53.75,76.,0.5039370078740157,0.24895833333333428,54.,78.,0.5039370078740157,0.24895833333333428,54.,57.,0.3858267716535433,0.4989583333333343,54.25,81.,0.5039370078740157,0.24895833333333428,54.5,79.,0.5039370078740157,0.9989583333333343,54.5,48.,0.3858267716535433,0.4989583333333343,55.,52.,0.3858267716535433,0.24895833333333428,55.25,55.,0.3858267716535433,0.24895833333333428,55.5,76.,0.5039370078740157,0.4989583333333343,55.5,60.,0.3858267716535433,0.24895833333333428,55.75,55.,0.3858267716535433,0.24895833333333428,56.,76.,0.5039370078740157,0.7489583333333343,56.,48.,0.3858267716535433,0.4989583333333343,56.5,52.,0.3858267716535433,0.4989583333333343,56.75,75.,0.5039370078740157,0.24895833333333428,57.,76.,0.5039370078740157,0.24895833333333428,57.,55.,0.3858267716535433,0.4989583333333343,57.25,79.,0.5039370078740157,0.24895833333333428,57.5,78.,0.5039370078740157,0.9989583333333343,57.5,47.,0.3858267716535433,0.4989583333333343,58.,51.,0.3858267716535433,0.24895833333333428,58.25,54.,0.3858267716535433,0.24895833333333428,58.5,75.,0.5039370078740157,0.4989583333333343,58.5,59.,0.3858267716535433,0.24895833333333428,58.75,54.,0.3858267716535433,0.24895833333333428,59.,71.,0.5039370078740157,0.9989583333333343,59.,47.,0.3858267716535433,0.4989583333333343,59.5,54.,0.3858267716535433,0.4989583333333343,60.,76.,0.5039370078740157,0.4989583333333343,60.,57.,0.3858267716535433,0.4989583333333343,60.5,79.,0.5039370078740157,0.9989583333333343,60.5,52.,0.3858267716535433,0.4989583333333343,61.,55.,0.3858267716535433,0.4989583333333343,61.5,81.,0.5039370078740157,0.4989583333333343,61.5,59.,0.3858267716535433,0.4989583333333343,62.,83.,0.5039370078740157,0.7489583333333343,62.,52.,0.3858267716535433,0.4989583333333343,62.5,55.,0.3858267716535433,0.4989583333333343,62.75,84.,0.5039370078740157,0.24895833333333428,63.,83.,0.5039370078740157,0.24895833333333428,63.,59.,0.3858267716535433,0.4989583333333343,63.25,79.,0.5039370078740157,0.24895833333333428,63.5,81.,0.5039370078740157,0.9989583333333343,63.5,50.,0.3858267716535433,0.4989583333333343,64.,54.,0.3858267716535433,0.24895833333333428,64.25,57.,0.3858267716535433,0.24895833333333428,64.5,78.,0.5039370078740157,0.24895833333333428,64.5,62.,0.3858267716535433,0.24895833333333428,64.75,76.,0.5039370078740157,0.24895833333333428,64.75,57.,0.3858267716535433,0.24895833333333428,65.,74.,0.5039370078740157,0.7489583333333343,65.,50.,0.3858267716535433,0.4989583333333343,65.5,54.,0.3858267716535433,0.4989583333333343,65.75,76.,0.5039370078740157,0.24895833333333428,66.,78.,0.5039370078740157,0.24895833333333428,66.,57.,0.3858267716535433,0.4989583333333343,66.25,81.,0.5039370078740157,0.24895833333333428,66.5,79.,0.5039370078740157,0.7489583333333343,66.5,48.,0.3858267716535433,0.4989583333333343,67.,52.,0.3858267716535433,0.4989583333333343,67.25,78.,0.5039370078740157,0.24895833333333428,67.5,76.,0.5039370078740157,0.24895833333333428,67.5,55.,0.3858267716535433,0.4989583333333343,67.75,79.,0.5039370078740157,0.24895833333333428,68.,75.,0.5039370078740157,0.7489583333333343,68.,47.,0.3858267716535433,0.4989583333333343,68.5,51.,0.3858267716535433,0.24895833333333428,68.75,73.,0.5039370078740157,0.24895833333333428,68.75,54.,0.3858267716535433,0.24895833333333428,69.,75.,0.5039370078740157,0.4989583333333343,69.,59.,0.3858267716535433,0.24895833333333428,69.25,54.,0.3858267716535433,0.24895833333333428,69.5,76.,0.5039370078740157,0.9989583333333343,69.5,52.,0.3858267716535433,0.4989583333333343,70.,57.,0.3858267716535433,0.4989583333333343,70.5,76.,0.5039370078740157,0.4989583333333343,70.5,59.,0.3858267716535433,0.4989583333333343,71.,76.,0.5039370078740157,1.4989583333333343,71.,59.,0.3858267716535433,1.4989583333333343,71.,55.,0.3858267716535433,1.4989583333333343,71.,52.,0.3858267716535433,1.4989583333333343,72.5,86.,0.5039370078740157,1.4989583333333343,72.5,55.,0.3858267716535433,0.4989583333333343,73.,59.,0.3858267716535433,0.4989583333333343,73.5,62.,0.3858267716535433,0.4989583333333343,74.,86.,0.5039370078740157,0.7489583333333343,74.,55.,0.3858267716535433,0.4989583333333343,74.5,59.,0.3858267716535433,0.4989583333333343,74.75,85.,0.5039370078740157,0.24895833333333428,75.,83.,0.5039370078740157,0.24895833333333428,75.,62.,0.3858267716535433,0.4989583333333343,75.25,79.,0.5039370078740157,0.24895833333333428,75.5,81.,0.5039370078740157,0.9989583333333343,75.5,50.,0.3858267716535433,0.4989583333333343,76.,54.,0.3858267716535433,0.24895833333333428,76.25,57.,0.3858267716535433,0.24895833333333428,76.5,78.,0.5039370078740157,0.4989583333333343,76.5,62.,0.3858267716535433,0.24895833333333428,76.75,57.,0.3858267716535433,0.24895833333333428,77.,74.,0.5039370078740157,0.7489583333333343,77.,50.,0.3858267716535433,0.4989583333333343,77.5,54.,0.3858267716535433,0.4989583333333343,77.75,76.,0.5039370078740157,0.24895833333333428,78.,78.,0.5039370078740157,0.24895833333333428,78.,57.,0.3858267716535433,0.4989583333333343,78.25,81.,0.5039370078740157,0.24895833333333428,78.5,79.,0.5039370078740157,0.9989583333333343,78.5,48.,0.3858267716535433,0.4989583333333343,79.,52.,0.3858267716535433,0.4989583333333343,79.5,76.,0.5039370078740157,0.4989583333333343,79.5,55.,0.3858267716535433,0.4989583333333343,80.,76.,0.5039370078740157,0.7489583333333343,80.,48.,0.3858267716535433,0.4989583333333343,80.5,52.,0.3858267716535433,0.4989583333333343,80.75,75.,0.5039370078740157,0.24895833333333428,81.,76.,0.5039370078740157,0.24895833333333428,81.,55.,0.3858267716535433,0.4989583333333343,81.25,79.,0.5039370078740157,0.24895833333333428,81.5,78.,0.5039370078740157,0.9989583333333343,81.5,47.,0.3858267716535433,0.4989583333333343,82.,51.,0.3858267716535433,0.24895833333333428,82.25,54.,0.3858267716535433,0.24895833333333428,82.5,75.,0.5039370078740157,0.4989583333333343,82.5,59.,0.3858267716535433,0.24895833333333428,82.75,54.,0.3858267716535433,0.24895833333333428,83.,71.,0.5039370078740157,1.4989583333333343,83.,47.,0.3858267716535433,0.4989583333333343,83.5,54.,0.3858267716535433,0.4989583333333343,84.,59.,0.3858267716535433,0.4989583333333343,84.5,86.,0.5039370078740157,1.4989583333333343,84.5,55.,0.3858267716535433,0.4989583333333343,85.,59.,0.3858267716535433,0.4989583333333343,85.5,62.,0.3858267716535433,0.4989583333333343,86.,86.,0.5039370078740157,0.7489583333333343,86.,55.,0.3858267716535433,0.4989583333333343,86.5,59.,0.3858267716535433,0.4989583333333343,86.75,85.,0.5039370078740157,0.24895833333333428,87.,83.,0.5039370078740157,0.24895833333333428,87.,62.,0.3858267716535433,0.4989583333333343,87.25,79.,0.5039370078740157,0.24895833333333428,87.5,81.,0.5039370078740157,0.9989583333333343,87.5,50.,0.3858267716535433,0.4989583333333343,88.,54.,0.3858267716535433,0.24895833333333428,88.25,57.,0.3858267716535433,0.24895833333333428,88.5,78.,0.5039370078740157,0.4989583333333343,88.5,62.,0.3858267716535433,0.24895833333333428,88.75,57.,0.3858267716535433,0.24895833333333428,89.,74.,0.5039370078740157,0.7489583333333343,89.,50.,0.3858267716535433,0.4989583333333343,89.5,54.,0.3858267716535433,0.4989583333333343,89.75,76.,0.5039370078740157,0.24895833333333428,90.,78.,0.5039370078740157,0.24895833333333428,90.,57.,0.3858267716535433,0.4989583333333343,90.25,81.,0.5039370078740157,0.24895833333333428,90.5,79.,0.5039370078740157,0.7489583333333343,90.5,48.,0.3858267716535433,0.4989583333333343,91.,52.,0.3858267716535433,0.4989583333333343,91.25,78.,0.5039370078740157,0.24895833333333428,91.5,76.,0.5039370078740157,0.24895833333333428,91.5,55.,0.3858267716535433,0.4989583333333343,91.75,79.,0.5039370078740157,0.24895833333333428,92.,75.,0.5039370078740157,0.7489583333333343,92.,47.,0.3858267716535433,0.4989583333333343,92.5,51.,0.3858267716535433,0.24895833333333428,92.75,73.,0.5039370078740157,0.24895833333333428,92.75,54.,0.3858267716535433,0.24895833333333428,93.,75.,0.5039370078740157,0.4989583333333343,93.,59.,0.3858267716535433,0.24895833333333428,93.25,54.,0.3858267716535433,0.24895833333333428,93.5,76.,0.5039370078740157,1.4989583333333343,93.5,52.,0.3858267716535433,0.4989583333333343,94.,60.,0.3858267716535433,0.4989583333333343,94.,57.,0.3858267716535433,0.4989583333333343,94.5,54.,0.3858267716535433,0.4989583333333343,95.,76.,0.5039370078740157,0.9989583333333343,95.,59.,0.3858267716535433,0.9989583333333343,95.,55.,0.3858267716535433,0.9989583333333343,95.,52.,0.3858267716535433,0.9989583333333343,96.,64.,0.5039370078740157,0.4989583333333343,96.5,67.,0.5039370078740157,0.9989583333333343,96.5,52.,0.3858267716535433,0.4989583333333343,97.,55.,0.3858267716535433,0.4989583333333343,97.5,69.,0.5039370078740157,0.4989583333333343,97.5,59.,0.3858267716535433,0.4989583333333343,98.,71.,0.5039370078740157,0.7489583333333343,98.,52.,0.3858267716535433,0.4989583333333343,98.5,55.,0.3858267716535433,0.4989583333333343,98.75,72.,0.5039370078740157,0.24895833333333428,99.,71.,0.5039370078740157,0.4989583333333343,99.,59.,0.3858267716535433,0.4989583333333343,99.5,69.,0.5039370078740157,0.9989583333333343,99.5,50.,0.3858267716535433,0.4989583333333343,100.,54.,0.3858267716535433,0.4989583333333343,100.5,66.,0.5039370078740157,0.4989583333333343,100.5,57.,0.3858267716535433,0.4989583333333343,101.,62.,0.5039370078740157,0.7489583333333343,101.,50.,0.3858267716535433,0.4989583333333343,101.5,54.,0.3858267716535433,0.4989583333333343,101.75,64.,0.5039370078740157,0.24895833333333428,102.,66.,0.5039370078740157,0.4989583333333343,102.,57.,0.3858267716535433,0.4989583333333343,102.5,67.,0.5039370078740157,0.9989583333333343,102.5,48.,0.3858267716535433,0.4989583333333343,103.,52.,0.3858267716535433,0.4989583333333343,103.5,64.,0.5039370078740157,0.4989583333333343,103.5,55.,0.3858267716535433,0.4989583333333343,104.,64.,0.5039370078740157,0.7489583333333343,104.,48.,0.3858267716535433,0.4989583333333343,104.5,52.,0.3858267716535433,0.4989583333333343,104.75,63.,0.5039370078740157,0.24895833333333428,105.,64.,0.5039370078740157,0.4989583333333343,105.,55.,0.3858267716535433,0.4989583333333343,105.5,66.,0.5039370078740157,0.9989583333333343,105.5,47.,0.3858267716535433,0.4989583333333343,106.,51.,0.3858267716535433,0.4989583333333343,106.5,63.,0.5039370078740157,0.4989583333333343,106.5,54.,0.3858267716535433,0.4989583333333343,107.,59.,0.5039370078740157,0.9989583333333343,107.,47.,0.3858267716535433,0.4989583333333343,107.5,54.,0.3858267716535433,0.4989583333333343,108.,64.,0.5039370078740157,0.4989583333333343,108.,57.,0.3858267716535433,0.4989583333333343,108.5,67.,0.5039370078740157,0.9989583333333343,108.5,52.,0.3858267716535433,0.4989583333333343,109.,55.,0.3858267716535433,0.4989583333333343,109.5,69.,0.5039370078740157,0.4989583333333343,109.5,59.,0.3858267716535433,0.4989583333333343,110.,71.,0.5039370078740157,0.7489583333333343,110.,52.,0.3858267716535433,0.4989583333333343,110.5,55.,0.3858267716535433,0.4989583333333343,110.75,72.,0.5039370078740157,0.24895833333333428,111.,71.,0.5039370078740157,0.4989583333333343,111.,59.,0.3858267716535433,0.4989583333333343,111.5,69.,0.5039370078740157,0.9989583333333343,111.5,50.,0.3858267716535433,0.4989583333333343,112.,54.,0.3858267716535433,0.4989583333333343,112.5,66.,0.5039370078740157,0.4989583333333343,112.5,57.,0.3858267716535433,0.4989583333333343,113.,62.,0.5039370078740157,0.7489583333333343,113.,50.,0.3858267716535433,0.4989583333333343,113.5,54.,0.3858267716535433,0.4989583333333343,113.75,64.,0.5039370078740157,0.24895833333333428,114.,66.,0.5039370078740157,0.4989583333333343,114.,57.,0.3858267716535433,0.4989583333333343,114.5,67.,0.5039370078740157,0.7489583333333343,114.5,48.,0.3858267716535433,0.4989583333333343,115.,52.,0.3858267716535433,0.4989583333333343,115.25,66.,0.5039370078740157,0.24895833333333428,115.5,64.,0.5039370078740157,0.4989583333333343,115.5,55.,0.3858267716535433,0.4989583333333343,116.,63.,0.5039370078740157,0.7489583333333343,116.,47.,0.3858267716535433,0.4989583333333343,116.5,54.,0.3858267716535433,0.4989583333333343,116.75,61.,0.5039370078740157,0.24895833333333428,117.,63.,0.5039370078740157,0.4989583333333343,117.,59.,0.3858267716535433,0.4989583333333343,117.5,64.,0.5039370078740157,0.9989583333333343,117.5,52.,0.3858267716535433,0.7489583333333343,118.25,57.,0.3858267716535433,0.24895833333333428,118.5,64.,0.5039370078740157,0.4989583333333343,118.5,54.,0.3858267716535433,0.4989583333333343,119.,64.,0.5039370078740157,1.4989583333333343,119.,59.,0.3858267716535433,1.4989583333333343,119.,55.,0.3858267716535433,1.4989583333333343,119.,52.,0.3858267716535433,1.4989583333333343);\n\nfloat g1(float x, float a){\n\treturn 0.25/(a-0.5)+0.5+sqrt(\n        x*(-0.5/(a-0.5))+\n        (-0.5+-0.25/(a-0.5))*(-0.5+-0.25/(a-0.5))\n        );\n}\nfloat g2(float x,float a){\n    return 0.25/(a-0.5)+0.5-sqrt(\n        x*(-0.5/(a-0.5))+\n        (-0.5+-0.25/(a-0.5))*(-0.5+-0.25/(a-0.5))\n        );\n}\n\nfloat bez(float x,float a){\n    if(a==0.5){return x;}\n    float b=1.-a;\n    if(a>0.5){\n        float g=g2(x,a);\n    \treturn 2.*g*b-2.*g*g*b+g*g;\n    }\n    float g=g1(x,a);\n    return 2.*g*b-2.*g*g*b+g*g;\n}\n\n// Attack Decay Sustain Release\nfloat ADSR(float time, float[3] A, float[3] D, float[3] S, float[3] R){\n    float b=0.;\n\tif(time<A[0]){\n    \treturn A[1]*bez((time)/A[0],A[2]);\n    }\n\tb+=A[0];\n    if(time<b+D[0]){\n    \treturn (A[1]+(D[1]-A[1])*bez((time-b)/D[0],D[2]));\n    }\n\tb+=D[0];\n    if(time<b+S[0]){\n    \treturn (D[1]+(S[1]-D[1])*bez((time-b)/S[0],S[2]));\n    }\n\tb+=S[0];\n    if(time<b+R[0]){\n    \treturn (S[1]+(R[1]-S[1])*bez((time-b)/R[0],R[2]));\n    }\n    return 0.;\n}\n\nfloat notePitch(float mid){\n    /*\n    switch(int(mid)){\n        case(21):\n        \treturn 27.5;\n        case(22):\n        \treturn 29.135;\n        case(23):\n        \treturn 30.868;\n        case(60):\n        \treturn 261.63;\n        case(61):\n        \treturn 277.18;\n        case(62):\n        \treturn 293.67;\n        case(63):\n        \treturn 311.13;\n        case(64):\n        \treturn 328.63;\n        case(65):\n        \treturn \n\t\tdefault:\n\t\t\treturn 0.;\n\t}\n\t*/\n    return (440./32.)*(pow(2.,(mid-9.)/12.));\n}\n\n// Should make a piano tone\nfloat piano(float time, float MIDI, float dur){\n    float A[3]=float[3](0.02,0.3,1.);\n    float D[3]=float[3](0.02,1.,0.2);\n    float S[3]=float[3](dur-0.05,0.5,0.3);\n    float R[3]=float[3](0.16,0.,0.);\n\t//return sin(6.2831853*notePitch(MIDI)*time)*ADSR(time,A,D,S,R);\n    return sin(6.2831853*notePitch(MIDI)*time+  cos(6.2831853*notePitch(MIDI)*time) )*ADSR(time,A,D,S,R);\n}\n\nvec2 mainSound( in int samp, float time ){\n    //midi[0]=0.;\n\tfloat sum=0.;\n    for(int i=0; i<1832; i+=4){\n        if(time>=midi[i]){\n\t\t\tsum+=piano(time-midi[i],midi[i+1],midi[i+3])*midi[i+2];\n        }\n        else if(time>midi[i]+midi[i+3]){\n\t\t\ti=10000;\n        }\n\t}\n\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sum*0.4 );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlV3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 309, 332, 379, 558], [560, 560, 589, 589, 670], [672, 672, 695, 695, 820], [822, 822, 879, 879, 1470]], "test": "untested"}
{"id": "WtcSRH", "name": "Attraction-1", "author": "timF", "description": "Based off user  alijaya's ray marching phong template.\nStill learning..", "tags": ["raymarching"], "likes": 1, "viewed": 272, "published": 3, "date": "1580348380", "time_retrieved": "2024-07-30T21:27:27.782591", "image_code": "#define EPSILON 0.01\n#define MIN_DISTANCE 0.0\n#define MAX_DISTANCE 2000.0\n#define MAX_MARCHING_STEP 256\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction, always normalized\n};\n\nstruct Camera {\n\tvec3 pos;\n    vec3 lookAt;\n    float focal;\n    vec2 sensorSize;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n    \nvec3 xe = vec3(EPSILON, 0., 0.);\nvec3 ye = vec3(0., EPSILON, 0.);\nvec3 ze = vec3(0., 0., EPSILON);\n\n// get corresponding ray from uv (0.0 -> 1.0)\nRay getRay( Camera cam, vec2 uv ) {\n    vec3 camDir = normalize(cam.lookAt - cam.pos); // the camera direction\n    vec3 center = cam.pos + cam.focal * camDir; // get the coordinate of the screen center\n    vec2 coord = (uv - 0.5) * cam.sensorSize; // convert from 0.0 -> 1.0 to -sensorSize / 2. -> sensorSize / 2.\n    \n    // axis relative to camera\n    vec3 zpos = -camDir; // k hat, outward the screen\n    vec3 xpos = cross(vec3(0., 1., 0.), zpos); // i hat, cross from ypos global and zpos local\n    vec3 ypos = cross(zpos, xpos); // j hat, cross from zpos local and xpos local\n    \n    // target in screen\n    vec3 target = center + coord.x * xpos + coord.y * ypos; // get pixel target coordinate from the screen\n    \n    Ray ray;\n    ray.o = cam.pos; // the origin of the ray is from the camera duh\n    ray.d = normalize(target - cam.pos); // the direction is from the camera to the target\n    \n    return ray;\n}\n\n// project point to ray\nvec3 projPoint2Ray( vec3 point, Ray ray ) {\n    vec3 rel = point - ray.o; // get relative vector from the point to the ray origin\n    float len = dot(rel, ray.d); // project that vector to vector direction of the ray, we get the length\n    return len * ray.d + ray.o; // multiply the length with unit vector direction and add to ray origin\n}\n\n// get the distance from point to ray (or line)\nfloat distPoint2Ray( vec3 point, Ray ray ) {\n    vec3 proj = projPoint2Ray(point, ray); // project it first to the ray\n    return distance(proj, point); // get the distance from the projected position to the original position\n}\n\n// just linear interpolation, map value v between fromA and fromB to between toA and toB\nfloat lerp( float v, float fromA, float fromB, float toA, float toB ) {\n    return (v - fromA) / (fromB - fromA) * (toB - toA) + toA;\n}\n\n// sphere function\nfloat sdSphere( vec3 p, float radius ) {\n    return length(p) - radius;\n}\n\n// Octahedron function\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n// smooth union function\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n\n// box function\nfloat sdBox( vec3 p, float width, float height, float depth ) {\n    vec3 d = abs(p) - vec3(width, height, depth);\n    return max(d.x, max(d.y, d.z));\n}\n\n// cylinder function\nfloat sdCylinder( vec3 p, float radius, float height ) {\n    return max(length(p.xz) - radius, abs(p.y) - height);\n}\n\nfloat sdUnion( float sd1, float sd2 ) {\n    return min(sd1, sd2);\n}\n\nfloat sdIntersect( float sd1, float sd2 ) {\n    return max(sd1, sd2);\n}\n\nfloat sdSubstract( float sd1, float sd2 ) {\n    return max(sd1, -sd2);\n}\n\nmat4 rotationMatrix(float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n// change this\nfloat sdScene( vec3 p ) {\n    float finalShape = 0.0;\n    float sphereTest = sdSphere(p, 200.0);\n    float sphereTest2 = sdSphere(p, 200.0);\n    vec4 spherePos = vec4(p,0.0); // the center sphere position\n    \n    float sphereScale = 1.0;\n    \n    \n    float sphere1 = sdSphere( spherePos.xyz, sphereScale); // center sphere\n    \n    //offsets of the left and right octa so they are uniform\n    vec2 octaOffset = vec2(4.8+sin(iTime*2.)*.2,.4);\n    \n    //sizeing\n    float octaSize = 2.0;\n    float boxSize = .95;\n    \n    float leftOcta = sdOctahedron(p - vec3(octaOffset.x,octaOffset.y,0.0), octaSize);\n    float leftOctaSub = sdBox(p - vec3(octaOffset.x,octaOffset.y,0.0),boxSize,boxSize,boxSize);\n    float rightOcta = sdOctahedron(p + vec3(octaOffset.x,octaOffset.y-1.,0.0), octaSize);\n    float rightOctaSub = sdBox(p + vec3(octaOffset.x,octaOffset.y-1.,0.0),boxSize,boxSize,boxSize);\n    \n    leftOcta = sdSubstract(leftOcta,leftOctaSub);\n    rightOcta = sdSubstract(rightOcta,rightOctaSub);\n    float lConnection = 3.2 + sin(iTime*120.)*.08;\n    float rConnection = 3. + sin(iTime*120.)*.08;\n    \n    \n    \n    finalShape = opSmoothUnion(opSmoothUnion(sphere1, leftOcta,lConnection),rightOcta,rConnection);\n    //finalShape = min(sphereTest,finalShape );\n    \n    //finalShape = min(sphereTest, sphereTest2);\n    \n    return finalShape;\n}\n\n// estimate normal with nudging\nvec3 estimateNormal( vec3 p ) {\n    return normalize(vec3(\n    \tsdScene(p+xe) - sdScene(p-xe),\n        sdScene(p+ye) - sdScene(p-ye),\n        sdScene(p+ze) - sdScene(p-ze)\n    ));\n}\n\n// ray marching algorithm\nfloat getSDF( Ray r ) {\n    float depth = MIN_DISTANCE;\n    for (int i=0; i<MAX_MARCHING_STEP; i++) {\n        float dist = sdScene( r.o + depth * r.d );\n        \n        if (dist < EPSILON) { // inside a scene\n            return depth;\n        }\n        \n        depth += dist; // circle marching!\n        \n        if (depth >= MAX_DISTANCE) {\n            return MAX_DISTANCE;\n        }\n    }\n    \n    return MAX_DISTANCE;\n}\n\nvec3 ambientLight( vec3 ambientColor ) {\n    return ambientColor;\n}\n\nvec3 phongLight( vec3 diffuseColor, vec3 specularColor, float shininess, Ray ray, float dist, Light light ) {\n    vec3 p = ray.o + dist * ray.d;\n    \n    vec3 N = estimateNormal(p); // surface normal\n    vec3 L = normalize(light.pos - p); // surface to light direction\n    vec3 V = -ray.d; // surface to camera direction\n    vec3 R = reflect(-L, N); // mirror of L by the axis N\n    \n    float dotLN = dot(L, N); // project light direction to surface normal\n    float dotRV = dot(R, V); // project light reflection direction to direction to camera\n    \n    vec3 color = vec3(0.);\n    if (dotLN > 0.) { // we can see the diffuse\n        color += diffuseColor * dotLN;\n    }\n    if (dotRV > 0.) { // we can see the specular\n        color += specularColor * pow(dotRV, shininess);\n    }\n    color *= light.color; // influence of color of the light\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert from fragCoord (0.0 -> iResolution.xy) to uv (0.0 -> 1.0)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 circleMovement = vec3(0.0,3.0 + sin(iTime*.2)*4.,-4.0);\n    \n    // set camera\n    Camera cam;\n    cam.sensorSize = iResolution.xy; // set sensor size to the screenSize\n    cam.focal = 200.; // set the focal length (distance between sensor (screen) to the aperture\n    cam.lookAt = vec3(0., 0., 0.); // where to look at (this camera use two point system)\n    cam.pos = circleMovement; // the position of the camera\n    \n    // get ray\n    Ray ray = getRay(cam, uv); // get corresponding ray, given the uv\n    \n    // create 8 points of cube\n    vec3 points[8];\n    for (int i=0; i<2; i++) {\n        for (int j=0; j<2; j++) {\n            for (int k=0; k<2; k++) {\n                points[i*4+j*2+k] = vec3(float(i) * 2. - 1., float(j) * 2. - 1., float(k) * 2. - 1.);\n            }\n        }\n    }\n    \n    // render\n    float dist = getSDF(ray);\n    if (dist > MAX_DISTANCE - EPSILON) { // don't hit anything, set to background\n        fragColor = vec4(0.);\n        return; // or discard?\n    }\n    \n    vec3 ambientColor = vec3(0.1, 0.1, 0.2);\n    vec3 diffuseColor = vec3(0.7, 0.2, 0.2);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 50.0;\n    \n    Light light1;\n    light1.pos = vec3(-2,2,-3);\n    light1.color = vec3(1., 0.5, 0.3);\n    \n    Light light2;\n    light2.pos = vec3(2,2,3);\n    light2.color = vec3(1., 0.8, 0.5);\n    \n    vec3 color = vec3(0.);\n    color += ambientLight(ambientColor);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light1);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light2);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcSRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[427, 473, 508, 508, 1390], [1392, 1416, 1459, 1459, 1757], [1759, 1807, 1851, 1851, 2034], [2036, 2125, 2196, 2196, 2260], [2262, 2281, 2321, 2321, 2354], [2356, 2379, 2417, 2417, 2470], [2472, 2497, 2549, 2549, 2648], [2652, 2668, 2731, 2731, 2819], [2821, 2842, 2898, 2898, 2958], [2960, 2960, 2999, 2999, 3027], [3029, 3029, 3072, 3072, 3100], [3102, 3102, 3145, 3145, 3174], [3176, 3176, 3221, 3221, 3849], [3852, 3867, 3892, 3892, 5213], [5215, 5247, 5278, 5278, 5428], [5430, 5456, 5479, 5479, 5880], [5882, 5882, 5922, 5922, 5949], [5951, 5951, 6060, 6060, 6815], [6817, 6817, 6874, 6947, 8627]], "test": "untested"}
{"id": "Wl3Xz8", "name": "sketch_01_29_20", "author": "ianwall", "description": "sketch", "tags": ["sketch"], "likes": 0, "viewed": 82, "published": 3, "date": "1580340313", "time_retrieved": "2024-07-30T21:27:28.525604", "image_code": "/// params:\n\nint seed = 101;\nfloat sharpness = 0.95;\nfloat movement = 0.2;\nfloat curvyness = 0.5;//1.5;\nint num = 11;\n\n// Palette:\nvec3 a = vec3(0.5, 0.5, 0.5);\nvec3 b = vec3(0.5, 0.5, 0.5);\nvec3 c = vec3(1.0, 1.0, 1.0);\nvec3 d = vec3(0.00, 0.10, 0.20);\n\n/////\n\n//uint type[] = uint[](1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u);\n//vec2 off[3] = vec2[3](vec2(1.0, 0.0), vec2(1.0, sqrt(3.0)), vec2(-1.0, sqrt(3.0)));\n\nfloat hash1( uint n ) \n{\n    n += uint(seed);\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat leftOf(vec2 a, vec2 b, vec2 p) {\n\tvec2 e0 = b - a;\n\tvec2 v0 = p - a;\n\tvec2 pq0 = v0 - e0*( dot(v0,e0)/dot(e0,e0) );\n    vec2 d = vec2( dot( pq0, pq0 ), (v0.x*e0.y-v0.y*e0.x) );\n\t\n    // sdf distance to line\n    float dist = -sqrt(d.x)*sign(d.y);\n\n    float edge = mix(0.2, 0.005, sharpness);\n    return 2.0*smoothstep(-edge, edge, dist + movement*sin(6.28318*iTime/5.0 + curvyness*dot(p,p))) - 1.0;\n}\n\nvec4 palette( float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return vec4(a + b*cos( 6.28318*(c*t+d) ), 1.0);\n}\n\nvec4 color(float z) {\n    return palette( z/float(num), a, b, c, d);\n    //return palette( mod(z/float(num), 1.0), a, b, c, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    uint size = uint(num);\n    float c = 0.0;\n    float d = 1.0;//0.25/float(size);\n    for(uint i = 0u; i < size; ++i) {\n        vec2 a = vec2(hash1(i), hash1(i+111u));\n        \n        float z = sign(mod(float(i), 2.0)-0.5);\n        vec2 b = a + vec2(z, sqrt(3.0));\n        c += d*leftOf(a,b,uv);\n\n        a.y = -a.y;\n        b.y = -b.y;\n        c += d*leftOf(b,a,uv);\n\n        a.x = -a.x;\n        b.x = -b.x;\n        c += d*leftOf(a,b,uv);\n\n        a.y = -a.y;\n        b.y = -b.y;\n        c += d*leftOf(b,a,uv);\n    }\n    \n    // Output to screen\n    fragColor = color(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3Xz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[405, 405, 429, 429, 631], [633, 633, 671, 671, 1039], [1041, 1041, 1110, 1110, 1164], [1166, 1166, 1187, 1187, 1295], [1297, 1297, 1354, 1404, 2043]], "test": "untested"}
{"id": "Wt3Xz8", "name": "Horizontal Loading Bar", "author": "BackwardsCap", "description": "A quick example for a friend!\nA loading bar with a texture scrolling to the right", "tags": ["loadingbar", "repeating"], "likes": 7, "viewed": 400, "published": 3, "date": "1580339866", "time_retrieved": "2024-07-30T21:27:29.433178", "image_code": "#define PI 3.1415927\n\n//the size of a pixel for anti-aliasing purposes\n#define PX 3./iResolution.y\n\n//our rotation matrix\nmat2 rot(float x)\n{\n    float s = sin(x);\n    float c = cos(x);\n    return mat2(c,-s,s,c);\n}\n\n//the mask for our loading bar\nfloat mask(vec2 uv, float w, float h)\n{\n    float caps = smoothstep(PX,0.,length(abs(uv)-vec2(w,0))- h);\n    vec2 box =smoothstep(PX,.0,abs(uv)-vec2(w-h,0.)-h);\n    return clamp(caps+(box.x*box.y),0.,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalize our coordinates\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y, \n         //sample the uv for the stationary mask\n         u = uv;\n    \n    //move along x axis\n    uv.x-=mod(iTime/5.,sqrt(2.));\n    \n    //rotate by 45 degrees\n    uv*=rot(PI/4.);\n    \n    //sample a horizontal slice of texture 0\n    fragColor.rgb = texture(iChannel0,vec2(uv.x,.5)).rgb;\n    \n    //apply the loading bar mask\n    fragColor.rgb*=mask(u,1.,.1);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3Xz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 122, 141, 141, 214], [216, 247, 286, 286, 453], [456, 456, 513, 545, 969]], "test": "untested"}
{"id": "wtdXRr", "name": "Day 41", "author": "jeyko", "description": "code is messy", "tags": ["mdtmjvm"], "likes": 9, "viewed": 402, "published": 3, "date": "1580338497", "time_retrieved": "2024-07-30T21:27:30.482373", "image_code": "#define pmod(p,x) mod(p,x) - 0.5*x\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define mx (iTime*0.4 + 20.*iMouse.x/iResolution.y)\n#define my (1.*iMouse.y/iResolution.y)\n\n#define dmin(a,b) a.x < b.x ? a : b\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n// check these out for more beastly stuff\n// https://www.shadertoy.com/view/3dXSDH \n// https://www.shadertoy.com/view/XsKGRW\n\n\nvec3 glow = vec3(0);\n// Noise (from iq)\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n#if 1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel2,(uv+0.5)/256.0,0.0).yx;\n#else\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\n\tvec2 rg = mix(mix(texelFetch(iChannel2,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel2,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel2,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel2,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n#endif    \n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat noiseB (vec3 p) {\n\tvec3 f = fract (p);\n\tp = floor (p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tf.xy += p.xy + p.z * vec2 (37.0, 17.0);\n\tf.xy = texture (iChannel2, (f.xy + 0.5) / 256.0, -256.0).yx;\n\treturn mix (f.x, f.y, f.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\nvec3 guide (vec3 p){\n\treturn vec3(\n    \tsin(p.z*0.5) + sin(p.z*0.3) + cos(p.z*0.3),\n    \tcos(p.z*0.8) + sin(p.z*1.3)*0.5,\n        0.\n    )*1.2;\n}\n#define W 1.\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e4);\n    /*\n    for (int i = 0; i < 3; i++){\n    \tp = abs(p);\n        p.y -= 0.25;\n        p.xy *= rot(0.125*3.14);\n    }*/\n    p.xy -= 4.;\n    vec2 id = floor(p.xy/8.);\n    \n    p.xy = pmod(p.xy, 8.);\n    //p.xy *= 1. - pow(fract(sin(iTime + id.x + p.z)), 1.)*0.1;\n    p.xy += normalize(p.xy)*0.1*(sin(iTime + id.x + p.z));\n    p += guide(p + id.x)*0.4;\n    vec3 t = tex3D(iChannel0,p*0.1, normalize(vec3(p.x,p.y, 0.)));\n    vec3 tB = tex3D(iChannel0,p*0.2+ 1., normalize(vec3(p.x,p.y, 0.)));\n    //t.x = 1. - t.x; \n    //t.x *= 0.4;\n    //t.x = pow(smoothstep(0.,1.5,t.x*3.), 1.)*0.4;\n    \n    t.x *= 0.6;\n    float dPlant = length(p.xy) - W - t.x - tB.x*0.4;\n    \n    \n    //dPlant = max(dPlant, sin(p.z)*0.4 + 0.2);\n    \n    p.z = pmod(p.z, 4.);\n    for (float i = 0.; i < 3.; i++){\n        vec3 q = p;\n        q.z += 4.*i/3.;\n        pmod(q.z, 4.);\n        q.xy *= rot(0.7 + i);\n        q.y -= W;\n        dPlant = opSmoothUnion( dPlant, sdTorus( q, vec2(0.25,0.12) ), 0.2 );\n        //q.z -= exp(-clamp(length(q.xy)*20.,0., 20.)*1.) ;\n        q.z -= clamp(pow(length(q.xy)*0.8,3.),0., 1.) ;\n        d = dmin(d, vec2( (sdRoundCone( q, 0.2, 0.007, 1. )- tB.x*0.15)*0.6, 1.) );\n    }\n    d= dmin(d, vec2(dPlant*0.6, 2.));\n\n    d.x *= 0.5;\n    return d;\n}\n\n\n\nvec2 march(vec3 ro, vec3 rd,inout vec3 p ,inout float t, inout bool hit){\n\t\n\thit = false;\n    t = 0.;\n    vec2 d;\n    p = ro + rd*1.;\n    for(int i = 0; i < 150; i++){\n    \td = map(p);\n        glow += exp(-d.x*5.);\n        if(d.x < 0.001){\n        \thit = true;\n        \tbreak;\n        }\n        if(t > 30.){\n        \tbreak;\n        }\n        t += d.x;\n    \tp = ro + rd*t;\n    }\n\treturn d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross( dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    //ro.z += mx;\n    ro.z += mx;\n    //ro.y += 2.2;\n    //ro.xy -= normalize(guide(ro ).xy)*4.;\n    ro.xy += vec2(\n    \tcos(sin(mx*0.5)*1.14 + 0.3),\n    \tsin(sin(mx*0.5)*1.14 + 0.3)\n    )*4.;\n    vec3 lookAt = vec3(0,0,ro.z + 4. + sin(iTime*0.4)*0.2);\n    lookAt -= guide(lookAt)*1.;\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    float t = 0.;\n    bool hit = false;\n    vec3 p =ro + rd*t;\n    vec3 lightCol = vec3(1.,0.6,0.3)*1.32;\n\n     \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if(hit){\n        vec3 n = getNormal(p);\n        vec3 l = normalize(vec3(1));\n        vec3 h = normalize(l - rd);\n        \n        float diff = max(dot(n, l),0.);\n        float spec = pow(max(dot(n, h),0.), 60.);\n        float fres = pow(1. - max(dot(n,-rd),0.), 5.);\n        \n        if (d.y == 1.){\n        \t//col += diff;\n        \tcol += mix(vec3(diff),fres*lightCol + spec*lightCol, 0.2);\n        \t//col += 2.4;\n        }\n        if (d.y == 2.){    \n            vec3 tex = tex3D(iChannel1,p*0.8, n);\n\t\t\ttex = pow(tex, vec3(0.4 ,0.8,0.5));\n        \tcol += mix(diff*tex, 1.* vec3(spec)*lightCol, 0.7)*2.;\n        }\n        col += 0.08*lightCol;\n        \n        //col += max(dot(n, normalize(vec3(1,-2,-1))),0.)* lightCol*0.09;\n        ///col += 1.;\n        //col += 0.02;\n        \n    } else {\n    \n    }\n    #define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\n    \n    col = max(col, 0.);\n    //col += lightCol*(glow*0.04)*0.7;\n    \n    if (t > 20.){\n    \tp = normalize(ro + rd)*20.;\n    }\n                //col -= vec3(1.,1.9,1.5)*lightCol*(1. -glow*0.05)*0.1;\n\n    float n = noise(p*0.9);\n    vec3 c = col;\n    col.r = c.b;\n    col.b = c.r;\n\n    //col = mix(col,vec3(0.6+ length(p) *0.09,0.24+ n * 0.02,0.08 )*4. , smoothstep(0.,1., clamp(t*0.03 - 0.2, 0., 1.) - n*0.0));\n    col = mix(col,vec3(0.2 - length(p) *0.0002,0.24+ n * 0.02,0.38 )*4. , smoothstep(0.,1., clamp(t*0.03 - 0.2, 0., 1.) - n*0.0));\n    //col = mix(col,pal(0.5, 0.5, vec3(2.5,0.3,0.6), 0.5 , 9. + p.z*0.2 ) , smoothstep(0., 1.,t*0.1));\n    col.b *= 1.2;\n            //col -= vec3(1.,1.9,3.9)*lightCol*(1. -glow*0.05)*0.1;\n    col -= vec3(1.,1.9,3.9)*lightCol*(1. -glow*0.05)*0.03;\n    \n\n    col *= 1. - pow(length(uv)*0.8,1.1)*1.2;\n    col = smoothstep(0.,0.9,col);\n    col *= 1.1;\n    col = pow(col, vec3(0.4545));\n    col.r *= 1.5;\n    col.g *= 1.3;\n    col.b *= 0.9 ;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdXRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[419, 419, 445, 445, 1000], [1002, 1002, 1025, 1025, 1226], [1228, 1228, 1280, 1280, 1379], [1381, 1381, 1439, 1439, 1703], [1704, 1704, 1737, 1737, 1802], [1804, 1804, 1854, 1854, 2039], [2041, 2041, 2061, 2061, 2186], [2200, 2200, 2217, 2217, 3491], [3495, 3495, 3568, 3568, 3885], [3887, 3887, 3910, 3910, 4050], [4052, 4052, 4094, 4094, 4277], [4279, 4279, 4336, 4336, 6812]], "test": "untested"}
{"id": "3lcSR8", "name": "TEST 2", "author": "andypicci", "description": "tes ", "tags": ["cineshader"], "likes": 8, "viewed": 17194, "published": 3, "date": "1580326484", "time_retrieved": "2024-07-30T21:27:31.336090", "image_code": "\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 2\",\n\t\"description\": \"OMG\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 53, 152], [154, 154, 189, 189, 213], [216, 216, 235, 235, 571], [573, 573, 603, 603, 885], [887, 887, 944, 944, 1662]], "test": "untested"}
{"id": "ttcSzr", "name": "Stanford Bunny ZMAABB.", "author": "BrunoLevy", "description": "Mesh ray-tracing using Terdiman's zero-byte AABB (http://www.codercorner.com/ZeroByteBVH.pdf)", "tags": ["raytracing", "aabb", "mesh"], "likes": 32, "viewed": 1185, "published": 3, "date": "1580320805", "time_retrieved": "2024-07-30T21:27:33.519254", "image_code": "// A more efficient version of https://www.shadertoy.com/view/wtG3z3\n// This one uses a version of Terdiman's zero-memory AABB\n//      and loads mesh data in Buffer A.\n\n// Uncomment next line to deactivate acceleration structure.\n// #define NAIVE\n \n \nivec3 get_facet(in int f) {\n    return ivec3(\n        get_data(MESH_DATA_OFFSET,3*f),\n        get_data(MESH_DATA_OFFSET,3*f+1),\n        get_data(MESH_DATA_OFFSET,3*f+2)\n    );\n}\n\nconst float FARAWAY=1e30;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.Obs+C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Material {\n   vec3 Ka;\n   vec3 Kd;\n   vec3 Ks;\n   float s;\n   vec3 Ke;\n};\n\nstruct Intersection {\n   float t;\n   Material material;\n   vec3 P;\n   vec3 N;\n};\n \nIntersection intersection() {\n   Intersection I;\n   I.t = FARAWAY;\n   return I;\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return (t > 0.0);\n}\n\nvoid sphere(in Ray R, in Sphere S, in Material M, inout Intersection I) {\n   float t;\n   if(intersect_sphere(R, S, t) && t < I.t) {\n      I.t = t;\n      I.material = M;\n      I.P = R.Origin + t*R.Dir;\n      I.N = normalize(I.P - S.Center);\n   }\n}\n\n\nbool intersect_triangle(\n    in Ray R, in vec3 A, in vec3 B, in vec3 C, out float t, \n    out float u, out float v, out vec3 N\n) { \n   // Möller et Trumbore, « Fast, Minimum Storage Ray-Triangle Intersection », \n   // Journal of Graphics Tools, vol. 2,‎ 1997, p. 21–28 \n   // https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm \n   // (with small adaptations: branchless, and reusing the normal vector)\n   // \n   // Notation: O = R.Origin; D = R.Dir)\n   //           E1 = B-A; E2 = C-A\n   // \n   // (1) O + tD = A + uE1 + vE2 \n   // (2) uE1 + vE2 -tD = O-A\n   // \n   //                [u]\n   // (3) [E1|E2|-D] [v] = O-A\n   //                [t]\n   // \n   //  (where [E1|E2|-D] is the 3x3 matrix with E1,E2,-D as its columns)\n   //\n   //  Using Cramer's formula for the solution of:\n   //\n   //    [a11 a12 a13][x1]   [b1]\n   //    [a12 a22 a23][x2] = [b2]\n   //    [a31 a32 a33][x3]   [b3]\n   //\n   //  gives: \n   // \n   //        |b1 a12 a13|   |a11 a12 a13|\n   //   x1 = |b2 a22 a23| / |a21 a22 a23|\n   //        |b3 a32 a33|   |a31 a32 a33|\n   //\n   //        |a11 b1 a13|   |a11 a12 a13|\n   //   x2 = |a21 b2 a23| / |a21 a22 a23|\n   //        |a31 b3 a33|   |a31 a32 a33|\n   //\n   //        |a11 a12 b1|   |a11 a12 a13|\n   //   x3 = |a21 a22 b2| / |a21 a22 a23|\n   //        |a31 a32 b3|   |a31 a32 a33|\n   // \n   // Now we get:\n   //\n   //   u = (O-A,E2,-D) / (E1,E2,-D)\n   //   v = (E1,O-A,-D) / (E1,E2,-D)\n   //   t = (E1,E2,O-A) / (E1,E2,-D)\n   // \n   // where (A,B,C) denotes the determinant of the 3x3 matrix with A,B,C as its\n   //  column vectors.\n   // \n   // Now we use the following identities:\n   //   (A,B,C) = dot(A,cross(B,C))  (develop the determinant w.r.t. first column)\n   //   (B,A,C) = -(A,B,C)           (swapping two vectors changes the sign)\n   //   (B,C,A) =  (A,B,C)           (circular permutation does not change the sign)\n   // \n   // Now we get:\n   //\n   // u = -(E2,O-A,D)  / (D,E1,E2)\n   // v =  (E1,O-A,D)  / (D,E1,E2)\n   // t = -(O-A,E1,E2) / (D,E1,E2)  \n   //\n   // Using N=cross(E1,E2); AO = O-A; DAO = cross(D,AO)\n   //  gives the following code : \n   vec3 E1 = B-A;\n   vec3 E2 = C-A;\n         N = cross(E1,E2);\n   float det = -dot(R.Dir, N);\n   float invdet = 1.0/det;\n   vec3 AO  = R.Origin - A;\n   vec3 DAO = cross(AO, R.Dir);\n   u =  dot(E2,DAO) * invdet;\n   v = -dot(E1,DAO) * invdet;\n   t =  dot(AO,N)  * invdet; \n   return (det >= 1e-6 && t >= 0.0 && u >= 0.0 && v >= 0.0 && (u+v) <= 1.0);\n}\n\nvoid triangle(in Ray R, vec3 A, vec3 B, vec3 C, in Material M, inout Intersection I) {\n   float t,u,v;\n   vec3 N;\n   if(intersect_triangle(R, A,B,C, t, u, v, N) && t < I.t) {\n      I.t = t;\n      I.material = M;\n      I.P = R.Origin + t*R.Dir;\n      I.N = normalize(N);\n   }\n}\n \nbool segment_box_intersection(\n  in vec3 q1,\n  in vec3 dirinv,\n  in vec3 boxmin,\n  in vec3 boxmax,\n  in float t // t of current intersection, used for pruning, see iq's comment.\n) {  \n   // References: \n   //    https://tavianator.com/fast-branchless-raybounding-box-intersections/ \n   vec3 T1 = dirinv*(boxmin - q1);\n   vec3 T2 = dirinv*(boxmax - q1);\n   vec3 Tmin = min(T1,T2);\n   vec3 Tmax = max(T1,T2);\n   float tmin = max(max(Tmin.x, Tmin.y),Tmin.z);\n   float tmax = min(min(Tmax.x, Tmax.y),Tmax.z);    \n   return (tmax >= 0.0) && (tmin <= tmax) && (tmin <= t);\n}\n\nint stack_top = -1;\nint stack_b[10];\nint stack_e[10];\n\nbool stack_empty() {\n  return (stack_top < 0);\n}\n\nvoid stack_push(in int b, in int e) {\n  stack_top++;\n  stack_b[stack_top] = b;\n  stack_e[stack_top] = e;  \n}\n\nvoid stack_pop(out int b, out int e) {\n  b = stack_b[stack_top];\n  e = stack_e[stack_top];\n  --stack_top;\n}\n\nvec3 decode_vertex(int xyz) {\n   int x = (xyz & 1023);\n   int y = (xyz & (1023 << 10)) >> 10;\n   int z = (xyz & (1023 << 20)) >> 20;\n   return bbox_min + vec3(float(x), float(y), float(z)) / 1023.0 * (bbox_max - bbox_min);\n}\n\nvec3 min3(in vec3 p1, in vec3 p2, in vec3 p3) {\n    return min(min(p1,p2),p3);\n}\n\nvec3 max3(in vec3 p1, in vec3 p2, in vec3 p3) {\n    return max(max(p1,p2),p3);\n}\n\nvoid mesh_AABB(in Ray R, in Material M, inout Intersection I) {\n  // References:\n  //   http://www.codercorner.com/ZeroByteBVH.pdf \n  // With some adaptations:\n  //   a) here the tree is balanced\n  //   b) sorting coord. simply cycles between X,Y,Z   \n  //   c) for now I always use 6 triangles to compute bbox\n  // Consequence of a,b,c: the AABB is fully implicit, fully described by\n  //  the order of the triangles in the mesh.\n  // Mesh sorting program will be posted here shortly.\n    \n#ifdef NAIVE    \n  for(int i=0; i<facets_data_size; ++i) {\n      ivec3 F = get_facet(i);\n      vec3 p1 = decode_vertex(F.x);\n      vec3 p2 = decode_vertex(F.y);\n      vec3 p3 = decode_vertex(F.z);\n      triangle(R, p1, p2, p3, M, I);      \n  }\n#else    \n    vec3 invDir = vec3(1.0/R.Dir.x, 1.0/R.Dir.y, 1.0/R.Dir.z);\n    stack_push(0, facets_data_size);\n    while(!stack_empty()) {\n        int b,e;\n        stack_pop(b,e);\n        if(e-b <= 16) {\n            for(int i=b; i<e; ++i) {\n                ivec3 F = get_facet(i);\n                vec3 p1 = decode_vertex(F.x);\n                vec3 p2 = decode_vertex(F.y);\n                vec3 p3 = decode_vertex(F.z);\n                triangle(R, p1, p2, p3, M, I);\n            }\n        } else {\n           ivec3 F = get_facet(b);\n           vec3 p1 = decode_vertex(F.x);\n           vec3 p2 = decode_vertex(F.y);\n           vec3 p3 = decode_vertex(F.z);\n           const int nbb = 6; // Number of triangles used to compute the bbox\n                              // (for now fixed, could be stored in the mesh as well).\n            \n           // Compute bbox (and test triangles used to compute the bbox, they\n           // are not part of the tree).\n           triangle(R, p1, p2, p3, M, I);\n           vec3 bbox_min = min3(p1,p2,p3); \n           vec3 bbox_max = max3(p1,p2,p3);\n           for(int i=b+1; i<b+nbb; ++i) {\n              ivec3 F = get_facet(i);\n              vec3 p1 = decode_vertex(F.x);\n              vec3 p2 = decode_vertex(F.y);\n              vec3 p3 = decode_vertex(F.z);\n              triangle(R, p1, p2, p3, M, I);\n              bbox_min = min(bbox_min, min3(p1,p2,p3)); \n              bbox_max = max(bbox_max, max3(p1,p2,p3));\n           }\n            \n           if(segment_box_intersection(R.Origin, invDir, bbox_min, bbox_max, I.t)) { \n              b += nbb;\n              int m = b + (e-b)/2;\n              // Small optimization: traverse nearest child first (so that pruning is\n              // more likely to occur).\n              int coord = (stack_top + 1)%3; // coord along which current node is split\n              if(R.Dir[coord] < 0.0) {\n                stack_push(b,m);\n                stack_push(m,e);                  \n              } else {\n                stack_push(m,e);\n                stack_push(b,m); // positive -> process this child first                                    \n              } \n              // TODO: elimination of the terminal recursion (latest pushed node is\n              // popped immediatly after, see iq's comment).\n           }     \n        }\n    }\n#endif    \n}  \n\n\nvoid sky(out vec4 fragColor, in Ray R) {\n   vec3 V = normalize(R.Dir);\n   float s = 0.5 * (V.z + 1.0);\n   fragColor = mix( \n      vec4(0.0, 0.0, 0.0, 1.0),\n      vec4(1.0, 1.0, 2.0, 1.0),\n      s\n   );\n}\n\n\nvec3 lighting( in Intersection I, in vec3 LightPos) {\n   vec3 L = LightPos - I.P;\n   float diffuse = max(dot(I.N, L)/length(L),0.0);\n   return diffuse * I.material.Kd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   float alpha = float(iFrame)/30.0;\n   float c = cos(alpha);\n   float s = sin(alpha);\n   Camera C = camera(\n       vec3(2.0*c, 2.0*s, 1.5),\n       vec3(0.0, 0.0, 0.0),\n       30.0       \n   );\n   Ray R = launch(C, fragCoord);\n   Intersection I = intersection();\n\n   const Material WHITE = Material(\n      vec3(0.0, 0.0, 0.0),\n      vec3(1.0, 1.0, 1.0),\n      vec3(0.0, 0.0, 0.0),\n      0.0,\n      vec3(0.0, 0.0, 0.0)\n   );\n\n   const Material RED = Material(\n      vec3(0.0, 0.0, 0.0),\n      vec3(1.0, 0.0, 0.0),\n      vec3(0.0, 0.0, 0.0),\n      0.0,\n      vec3(0.0, 0.0, 0.0)\n   );\n\n   mesh_AABB(R, WHITE, I);\n   sphere(R, Sphere(vec3(0.0, 0.0, -1001.0), 1000.0), WHITE, I);\n\n   if(I.t == FARAWAY) {\n      sky(fragColor, R);\n   } else {\n      fragColor.xyz = I.material.Ka;\n      fragColor.xyz += lighting(I, vec3(0.5, 1.3, 0.5));\n   }\n}\n\n\n ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#pragma optimize(off)\n\n// An array implemented as a huge switch() statement.\n// Inspired from https://www.shadertoy.com/view/tlX3W7 (see 'microcode RAM')\n// See also my earlier experiment here: https://www.shadertoy.com/view/3lK3Wd\n//   I did not find a better way of sending a large array,\n//   * using a big const array eats up all the registers in some implementations,\n//      See for instance my previous version: https://www.shadertoy.com/view/wtG3z3\n//        Works well on my Linux box (driver probably uses a SSBO), \n//           but lags at 0.5 FPS :-( under windows. \n//   * using a function instead stores all the values in the code segment. The function\n//      is only called at the first frame to send all the data to BufferA. Then all this\n//      code is probably evicted from the GPU code cache.\n//   * one can send large arrays using this trick \n//   * note the #pragma optimize(off) (since this shader is only executed once, it is OK),\n//     without it compilation time becomes veeeery long !\n//     (https://shadertoyunofficial.wordpress.com/2017/11/19/avoiding-compiler-crash-or-endless-compilation/)\n//     ... argh, under windows, even with the flag, it takes ages (100 seconds if THE_BIG_ONE is defined)\n//     Got it: it is the angle GLSL to HLSL transpiler that takes all the time. \n//      You can try disable it and using OpenGL directly instead (about:config in firefox).\n\n/*\n// MeshCompiler [Bruno Levy Jan 2020]\n// Converts a .obj (Alias|Wavefront) tri mesh into an AABB, encoded in GLSL, for ShaderToy.\n//\n// Fits in 256 lines :-)\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Sorts a vector and removes duplicated entries.\ntemplate <typename VECTOR> inline void sort_unique(VECTOR& v) {\n    std::sort(v.begin(), v.end()); v.erase(std::unique(v.begin(), v.end()), v.end());\n}\n\n// -------- GLSL-compatible types //-----------------------------------------------------\n\ntemplate <class T> class gvec3 {\npublic:\n    gvec3() {  }\n    gvec3(T x_in, T y_in, T z_in) : x(x_in), y(y_in), z(z_in) {  }\n    T& operator[](int i)             { return (&x)[i]; }\n    const T& operator[](int i) const { return (&x)[i]; }\n    T x,y,z;\n};\n\ntemplate <class T> inline gvec3<T> operator+(gvec3<T> u, gvec3<T> v) {\n    return gvec3<T>(u.x+v.x,u.y+v.y,u.z+v.z);\n}\n\ntemplate <class T> inline gvec3<T> min(gvec3<T> u, gvec3<T> v) {\n    return gvec3<T>(std::min(u.x,v.x),std::min(u.y,v.y),std::min(u.z,v.z));\n}\n\ntemplate <class T> inline gvec3<T> max(gvec3<T> u, gvec3<T> v) {\n    return gvec3<T>(std::max(u.x,v.x),std::max(u.y,v.y),std::max(u.z,v.z));\n}\n\ntypedef gvec3<double> vec3; typedef gvec3<int> ivec3;\n\n// -------- Encode/Decode //----------------------------------------------------------\n\n// Encodes a vertex, using 10 bits per coordinate, relative to bbox\nint encode_vertex(vec3 p, vec3 bbox_min, vec3 bbox_max) {\n    double x = (p.x - bbox_min.x) / (bbox_max.x - bbox_min.x);\n    double y = (p.y - bbox_min.y) / (bbox_max.y - bbox_min.y);\n    double z = (p.z - bbox_min.z) / (bbox_max.z - bbox_min.z);\n    int ix = int(x * 1023.0); int iy = int(y * 1023.0); int iz = int(z * 1023.0);\n    return ix | (iy << 10) | (iz << 20);\n}\n\n// Decodes the three integer coordinates of a vertex (10 bits per coordinate)\nivec3 decode_vertex(int xyz) {\n   return ivec3( \n       (xyz & 1023),\t\n       (xyz & (1023 << 10)) >> 10, \n       (xyz & (1023 << 20)) >> 20\n   );\n}\n\n// Encodes the coordinates of the three vertices of a triangle in an ivec3\nivec3 encode_facet(vec3 p1, vec3 p2, vec3 p3, vec3 bbox_min, vec3 bbox_max) {\n    return ivec3(\n\tencode_vertex(p1, bbox_min, bbox_max),\n\tencode_vertex(p2, bbox_min, bbox_max),\n\tencode_vertex(p3, bbox_min, bbox_max)\t    \n    );\n}\n\n// -------- Mesh geometry //-------------------------------------------------------------------\n\n// Computes (three times) the barycenter of a facet\nivec3 facet_center(ivec3 f) {\n    return decode_vertex(f.x) + decode_vertex(f.y) + decode_vertex(f.z);\n}\n\n// Computes the (floating-point) bbox of a pointset\nvoid get_bbox(const std::vector<vec3>& pts, vec3& bbox_min, vec3& bbox_max) {\n    bbox_min = pts[0]; bbox_max = pts[0];\n    for(int i=1; i<pts.size(); ++i) {\n\tbbox_min = min(bbox_min, pts[i]); bbox_max = max(bbox_max, pts[i]);\t\n    }\n}\n\n// Computes the (integer) bbox of a triangle\nvoid get_facet_bbox(ivec3 f, ivec3& bbox_min, ivec3& bbox_max) {\n    bbox_min = decode_vertex(f.x); bbox_max = decode_vertex(f.x);\n     ivec3 p = decode_vertex(f.y); bbox_min = min(bbox_min, p); bbox_max = max(bbox_max, p);\n           p = decode_vertex(f.z); bbox_min = min(bbox_min, p); bbox_max = max(bbox_max, p);\n}\n\n// -------- I/O //---------------------------------------------------------------------------\n\n// Outputs a floating point number, 6.6 digits\nstd::string format(double x) {\n    static char buff[300]; sprintf(buff,\"%-6.6f\",x); return std::string(buff);\n}\n\n// Outputs an integer in hexa, 8 digits\nstd::string format_int(int x) {\n    static char buff[300]; sprintf(buff,\"0x%08x\",x); return buff;\n}\n\n// Outputs an integer in hexa, 4 digits\nstd::string format_small_int(int x) {\n    static char buff[300]; sprintf(buff,\"0x%04x\",x); return buff;\n}\n\n// Generates a GLSL function that encodes an array of ivec3, as a (huge) switch statement\n// (It is stupid, I know, but this is the only way I found to send a big array to ShaderToy).\nvoid gen_ivec3_func(std::ostream& out, const std::vector<ivec3>& array, std::string name) {\n    out << \"#pragma optimize(off)\" << std::endl;\n    out << \"const int \" << name << \"_size = \" << array.size() << \";\" << std::endl;\n    out << \"ivec3 \" << name << \"(in int i) {\" << std::endl;\n    out << \"#  ifdef R\"   << std::endl;\n    out << \"#    undef R\" << std::endl;\n    out << \"#  endif\"     << std::endl;\n    out << \"#  define R(i,a,b,c) case i: r=ivec3(a,b,c); break;\" << std::endl;\n    out << \"  ivec3 r;\" << std::endl;\n    out << \"  switch(i) {\" << std::endl;\n    for(int i=0; i<int(array.size()); ++i) {\n       out << \"    R(\" << format_small_int(i) << \",\"\n\t               << format_int(array[i].x) << \",\" << format_int(array[i].y) << \",\" << format_int(array[i].z) << \")\";\n       if(!((i+1)%10)) { out << std::endl; }\n    }\n    out << \"  }\" << std::endl;\n    out << \"  return r;\" << std::endl;\n    out << \"}\" << std::endl;\n}\n\n// Loads a mesh from a .obj (Alias|Wavefront) file. Gets the point coordinates and triangle vertex indices.\nbool load_mesh(const std::string& filename, std::vector<vec3>& points, std::vector<ivec3>& triangles) {\n    points.clear();\n    triangles.clear();\n    FILE* F = fopen(filename.c_str(),\"r\");\n    if(!F) { return false;  }\n    char* line=nullptr;\n    size_t linelen=0;\n    int lineno = 0;\n    while(getline(&line,&linelen,F) >= 0) {\n\t++lineno;\n\tswitch(line[0]) {\n\t    case 'v': {\n\t\tfloat x,y,z;\n\t\tbool ok = (sscanf(line+1, \"%f %f %f\", &x, &y, &z) == 3);\n\t\tif(!ok) {\n\t\t    std::cerr << lineno << \": malformed vertex\" << std::endl;\n\t\t    std::cerr << line << std::endl;\n\t\t    return false;\n\t\t}\n\t\tpoints.push_back(vec3(double(x),double(y),double(z)));\n\t    } break;\n\t    case 'f': {\n\t\tint v1 =-1,v2 =-1,v3 =-1;\n\t\tint vt1=-1,vt2=-1,vt3=-1;\n\t\tint vn1=-1,vn2=-1,vn3=-1;\n\t\tbool ok = false;\n\t\tok = ok || (sscanf(line+1,\"%d %d %d\",                   &v1,&v2,&v3                              ) == 3);\n\t\tok = ok || (sscanf(line+1,\"%d/%d %d/%d %d/%d\",          &v1,&vn1,&v2,&vn2,&v3,&vn3               ) == 6);\n\t\tok = ok || (sscanf(line+1,\"%d/%d/%d %d/%d/%d %d/%d/%d\", &v1,&vn1,&vt1,&v2,&vn2,&vt2,&v3,&vn3,&vt3) == 9);\n\t\tok = ok || (sscanf(line+1,\"%d//%d %d//%d %d//%d\",       &v1,&vt1,&v2,&vt2,&v3,&vt3               ) == 6);\n\t\tif(!ok || v1 < 1 || v2 < 1 || v3 < 1) {\n\t\t    std::cerr << lineno << \": malformed facet\" << std::endl;\n\t\t    std::cerr << line << std::endl;\n\t\t    return false;\n\t\t}\n\t\ttriangles.push_back(ivec3(v1-1,v2-1,v3-1));\n\t    } break;\n\t}\n    }\n    free(line);\n    fclose(F);\n    return true;\n}\n\n// Loads a mesh from a .obj (Alias|Wavefront) file. Gets the bbox and for each triangle its vertices coordinates packed\n// in a single integer (10 bits per component).\nbool load_and_convert_mesh(const std::string& filename, std::vector<ivec3>& triangles_out, vec3& bbox_min, vec3& bbox_max) {\n    std::vector<vec3> points;\n    std::vector<ivec3> triangles;\n    if(!load_mesh(filename, points, triangles)) { return false; }\n    get_bbox(points, bbox_min, bbox_max);\n    triangles_out.resize(triangles.size());\n    for(int t=0; t<triangles.size(); ++t) {\n\tivec3 T = triangles[t];\n\ttriangles_out[t] = ivec3(\n\t    encode_vertex(points[T.x], bbox_min, bbox_max),\n\t    encode_vertex(points[T.y], bbox_min, bbox_max),\n\t    encode_vertex(points[T.z], bbox_min, bbox_max)\n\t);\n    }\n    return true;\n}\n\n// -------- Zero-memory AABB //----------------------------------------------------------------\n\n// Creates a zero-memory Axis-Aligned Bounding Box tree.\n// Nothing needs to be stored, it is completely defined by the order of the triangles.\n//  - The sequence [b,e[ of triangles is processed\n//  - coord: the axis along which bboxes are sorted (one of 0,1,2)\nvoid init_ZMAABB(std::vector<ivec3>& mesh, int b, int e, int coord) {\n    if(e-b <= 8) { return; }\n    // Sort facets along coord\n    std::sort(\n\tmesh.begin() + b, mesh.begin() + e,\n\t[coord](const ivec3& F1, const ivec3& F2) {\n\t    return (facet_center(F1)[coord] < facet_center(F2)[coord]);\n\t}\n    );\n    // Get sequence's bbox, and the indices of the triangles that touch the bbox\n    ivec3 bbox_min, bbox_max;\n    get_facet_bbox(mesh[b], bbox_min, bbox_max);\n    ivec3 index_bbox_min(b,b,b), index_bbox_max(b,b,b);\n    for(int i=b+1; i<e; ++i) {\n\tivec3 cur_bbox_min, cur_bbox_max;\n\tget_facet_bbox(mesh[i], cur_bbox_min, cur_bbox_max);\n\tfor(int coord=0; coord<3; ++coord) {\n\t    if(cur_bbox_min[coord] < bbox_min[coord]) {\n\t\tbbox_min[coord] = cur_bbox_min[coord];\n\t\tindex_bbox_min[coord] = i;\n\t    }\n\t    if(cur_bbox_max[coord] > bbox_max[coord]) {\n\t\tbbox_max[coord] = cur_bbox_max[coord];\n\t\tindex_bbox_max[coord] = i;\n\t    }\n\t}\n    }\n    // Put the triangles that touch the bbox first (there are at most 6 of them)\n    std::vector<int> box_indices;\n    box_indices.push_back(index_bbox_min.x); box_indices.push_back(index_bbox_min.y); box_indices.push_back(index_bbox_min.z);\n    box_indices.push_back(index_bbox_max.x); box_indices.push_back(index_bbox_max.y); box_indices.push_back(index_bbox_max.z);\n    sort_unique(box_indices);\n    int nbb = int(box_indices.size());\n    for(int i=0; i<nbb; ++i) {\n\tstd::swap(mesh[b+i], mesh[box_indices[i]]);\n    }\n    b += 6; // The triangles that touch the bbox are no longer in the tree\n    // Recurse in the rest of the triangles\n    int m = b + (e-b)/2; // We use a balanced tree (a bit less efficient, but then we do not need storing number of triangles)\n    init_ZMAABB(mesh, b, m, (coord + 1)%3);\n    init_ZMAABB(mesh, m, e, (coord + 1)%3);\t\n}\n\nint main(int argc, char** argv) {\n    if(argc != 2) {\n\tstd::cerr << \"Usage: \" << argv[0] << \" <filename>\" << std::endl;\n\treturn -1;\n    }\n    vec3 bbox_min, bbox_max;\n    std::vector<ivec3> facets;\n    load_and_convert_mesh(argv[1], facets, bbox_min, bbox_max);\n    init_ZMAABB(facets, 0, int(facets.size()), 0);\n    std::cout << \"const vec3 bbox_min = vec3(\" << bbox_min.x << \",\" << bbox_min.y << \",\" << bbox_min.z << \");\" << std::endl;\n    std::cout << \"const vec3 bbox_max = vec3(\" << bbox_max.x << \",\" << bbox_max.y << \",\" << bbox_max.z << \");\" << std::endl;\n    gen_ivec3_func(std::cout, facets, \"facets_data\");\n    return 0;\n}\n*/\n\n// Output of C++ the program above, applied to two meshes (1K and 2K vertices respectively)\n//\n#ifdef THE_BIG_ONE\nivec3 facets_data(in int i) {\n#  ifdef R\n#    undef R\n#  endif\n#  define R(i,a,b,c) case i: r=ivec3(a,b,c); break;\n  ivec3 r;\n  switch(i) {\n    R(0x0000,0x38a14c02,0x3ae13804,0x39d15400)    R(0x0001,0x3ad00099,0x3c002072,0x3b200c82)    R(0x0002,0x3ff6e0f3,0x3f470ccd,0x3f66fccf)    R(0x0003,0x0d1ffd9f,0x0c6ff573,0x0eaff982)    R(0x0004,0x000309dc,0x0032d5be,0x002371b0)    R(0x0005,0x2842ebf0,0x29a277e7,0x27129fff)    R(0x0006,0x3ad00099,0x3b200c82,0x399008b2)    R(0x0007,0x39d15400,0x3ba1380a,0x3a315c02)    R(0x0008,0x001299f0,0x0032d5be,0x000309dc)    R(0x0009,0x3fe6bd20,0x3ff6e0f3,0x3fc6a91e)\n    R(0x000a,0x0288720f,0x029811d5,0x02b8c9cd)    R(0x000b,0x0c3fddc5,0x0d1ffd9f,0x0eafe5b4)    R(0x000c,0x0013b5ea,0x000309dc,0x002371b0)    R(0x000d,0x02865188,0x0295f954,0x02b6b950)    R(0x000e,0x263605d1,0x26e55dd6,0x26e5e608)    R(0x000f,0x37f15c06,0x38a14c02,0x39d15400)    R(0x0010,0x392010ca,0x3ad00099,0x399008b2)    R(0x0011,0x3ed66144,0x3f469112,0x3df63935)    R(0x0012,0x10c67c4f,0x11f60461,0x13a6744e)    R(0x0013,0x02b6b950,0x0295f954,0x02c67126)\n    R(0x0014,0x0013b5ea,0x002371b0,0x00341db4)    R(0x0015,0x2c728dd3,0x2ce259c4,0x2d8295c5)    R(0x0016,0x18d10ddc,0x16613dbd,0x1650e9f7)    R(0x0017,0x0803c1fe,0x0953c1d8,0x0793bddb)    R(0x0018,0x13a33d3f,0x1342995e,0x15b2e948)    R(0x0019,0x00c4515a,0x00b46d35,0x00845560)    R(0x001a,0x01b56169,0x0094f149,0x01b57d3c)    R(0x001b,0x00e5f0ec,0x00c5fcc9,0x00e6acd7)    R(0x001c,0x23d66d56,0x21f67528,0x2295cd47)    R(0x001d,0x16465458,0x13a6744e,0x1475f064)\n    R(0x001e,0x0094f149,0x00849140,0x0094d50e)    R(0x001f,0x0115a8aa,0x00e514bb,0x015540ad)    R(0x0020,0x13a33d3f,0x1153015d,0x1342995e)    R(0x0021,0x1e45d100,0x1c951511,0x1f152d22)    R(0x0022,0x2295cd47,0x21752d3f,0x23752564)    R(0x0023,0x0094d50e,0x00b4e0db,0x00a558e1)    R(0x0024,0x027564ac,0x015540ad,0x01d4ecbf)    R(0x0025,0x0715a928,0x064570f2,0x06151931)    R(0x0026,0x12147936,0x0f94cd3e,0x0fa42d57)    R(0x0027,0x00b46d35,0x00849140,0x00845560)\n    R(0x0028,0x0f94cd3e,0x0d451d4f,0x0cd47962)    R(0x0029,0x057578c9,0x04458cb2,0x037514c0)    R(0x002a,0x01c46d01,0x01047102,0x01345d33)    R(0x002b,0x01047102,0x00a48908,0x00b46d35)    R(0x002c,0x00e4a0dd,0x0114d8c3,0x00e514bb)    R(0x002d,0x064570f2,0x0474f8dd,0x0534e108)    R(0x002e,0x00c578bb,0x00b4e0db,0x00e514bb)    R(0x002f,0x00d55111,0x0094d50e,0x00a558e1)    R(0x0030,0x00a48908,0x00e4a0dd,0x00b4e0db)    R(0x0031,0x01d4ecbf,0x0114d8c3,0x015490dc)\n    R(0x0032,0x02746933,0x03549503,0x01c46d01)    R(0x0033,0x0474f8dd,0x0284acdb,0x03549503)    R(0x0034,0x0534e108,0x0474f8dd,0x03549503)    R(0x0035,0x015490dc,0x0114d8c3,0x00e4a0dd)    R(0x0036,0x03549503,0x0284acdb,0x01c46d01)    R(0x0037,0x01c46d01,0x0284acdb,0x015490dc)    R(0x0038,0x0284acdb,0x01d4ecbf,0x015490dc)    R(0x0039,0x00a558e1,0x00b4e0db,0x00c578bb)    R(0x003a,0x01c46d01,0x015490dc,0x01047102)    R(0x003b,0x057578c9,0x0474f8dd,0x064570f2)\n    R(0x003c,0x064570f2,0x0534e108,0x06151931)    R(0x003d,0x00b4e0db,0x00e4a0dd,0x00e514bb)    R(0x003e,0x037514c0,0x01d4ecbf,0x0284acdb)    R(0x003f,0x037514c0,0x0284acdb,0x0474f8dd)    R(0x0040,0x057578c9,0x037514c0,0x0474f8dd)    R(0x0041,0x01047102,0x00e4a0dd,0x00a48908)    R(0x0042,0x015490dc,0x00e4a0dd,0x01047102)    R(0x0043,0x0f94cd3e,0x0cd47962,0x0fa42d57)    R(0x0044,0x0094f149,0x0094d50e,0x00d55111)    R(0x0045,0x11d51528,0x0f255534,0x0f94cd3e)\n    R(0x0046,0x027564ac,0x01d4ecbf,0x037514c0)    R(0x0047,0x0715a928,0x06151931,0x06d55954)    R(0x0048,0x01345d33,0x01047102,0x00b46d35)    R(0x0049,0x01345d33,0x00b46d35,0x00c4515a)    R(0x004a,0x015540ad,0x0114d8c3,0x01d4ecbf)    R(0x004b,0x03447961,0x0464a537,0x02746933)    R(0x004c,0x06151931,0x0534e108,0x0464a537)    R(0x004d,0x0464a537,0x03549503,0x02746933)    R(0x004e,0x0464a537,0x0534e108,0x03549503)    R(0x004f,0x0574cd5d,0x0464a537,0x03447961)\n    R(0x0050,0x0174595b,0x01345d33,0x00c4515a)    R(0x0051,0x0574cd5d,0x06151931,0x0464a537)    R(0x0052,0x01b57d3c,0x0094f149,0x00d55111)    R(0x0053,0x02746933,0x01345d33,0x0174595b)    R(0x0054,0x03447961,0x02746933,0x0174595b)    R(0x0055,0x04458cb2,0x027564ac,0x037514c0)    R(0x0056,0x0f255534,0x0cb59943,0x0d451d4f)    R(0x0057,0x10756917,0x0f255534,0x11d51528)    R(0x0058,0x06d55954,0x06151931,0x0574cd5d)    R(0x0059,0x00e514bb,0x0114d8c3,0x015540ad)\n    R(0x005a,0x0f255534,0x0d451d4f,0x0f94cd3e)    R(0x005b,0x02746933,0x01c46d01,0x01345d33)    R(0x005c,0x148568ab,0x123570ac,0x13c550e0)    R(0x005d,0x00849140,0x00a48908,0x0094d50e)    R(0x005e,0x2075d122,0x1f152d22,0x21752d3f)    R(0x005f,0x18633538,0x15b2e948,0x1832ad59)    R(0x0060,0x23752564,0x21752d3f,0x2294715f)    R(0x0061,0x13c550e0,0x116564e9,0x1305490b)    R(0x0062,0x16f43120,0x1653892f,0x19b3cd29)    R(0x0063,0x1b746d1f,0x19b3cd29,0x1ca3c134)\n    R(0x0064,0x0094d50e,0x00a48908,0x00b4e0db)    R(0x0065,0x1f152d22,0x1c951511,0x1e04692d)    R(0x0066,0x1be5b4f4,0x19c528fe,0x1c951511)    R(0x0067,0x15f564d9,0x148568ab,0x13c550e0)    R(0x0068,0x14650512,0x11d51528,0x14b49520)    R(0x0069,0x14b49520,0x1433ed2f,0x16f43120)    R(0x006a,0x19148911,0x16f43120,0x19b3cd29)    R(0x006b,0x19c528fe,0x16f4e107,0x19148911)    R(0x006c,0x1c951511,0x1b746d1f,0x1e04692d)    R(0x006d,0x16f4e107,0x14b49520,0x16f43120)\n    R(0x006e,0x19c528fe,0x19148911,0x1b746d1f)    R(0x006f,0x1c951511,0x19c528fe,0x1b746d1f)    R(0x0070,0x16f4e107,0x14650512,0x14b49520)    R(0x0071,0x1305490b,0x116564e9,0x10756917)    R(0x0072,0x15853cf6,0x13c550e0,0x1305490b)    R(0x0073,0x1b746d1f,0x19148911,0x19b3cd29)    R(0x0074,0x1305490b,0x10756917,0x11d51528)    R(0x0075,0x15853cf6,0x1305490b,0x14650512)    R(0x0076,0x16f4e107,0x15853cf6,0x14650512)    R(0x0077,0x179554ee,0x15853cf6,0x16f4e107)\n    R(0x0078,0x19148911,0x16f4e107,0x16f43120)    R(0x0079,0x19c528fe,0x179554ee,0x16f4e107)    R(0x007a,0x14650512,0x1305490b,0x11d51528)    R(0x007b,0x1653892f,0x13a33d3f,0x15b2e948)    R(0x007c,0x20549141,0x1ff3dd4f,0x2294715f)    R(0x007d,0x00b46d35,0x00a48908,0x00849140)    R(0x007e,0x13c550e0,0x123570ac,0x116564e9)    R(0x007f,0x19b3cd29,0x1653892f,0x18633538)    R(0x0080,0x1433ed2f,0x13a33d3f,0x1653892f)    R(0x0081,0x12147936,0x0fa42d57,0x11c3b949)\n    R(0x0082,0x11c3b949,0x1153015d,0x13a33d3f)    R(0x0083,0x1e04692d,0x1b746d1f,0x1ca3c134)    R(0x0084,0x20549141,0x1e04692d,0x1ff3dd4f)    R(0x0085,0x16f43120,0x1433ed2f,0x1653892f)    R(0x0086,0x1ca3c134,0x19b3cd29,0x1b032943)    R(0x0087,0x12147936,0x11c3b949,0x1433ed2f)    R(0x0088,0x1e04692d,0x1ca3c134,0x1ff3dd4f)    R(0x0089,0x1ff3dd4f,0x1ca3c134,0x1e534d55)    R(0x008a,0x1433ed2f,0x11c3b949,0x13a33d3f)    R(0x008b,0x11d51528,0x0f94cd3e,0x12147936)\n    R(0x008c,0x15f564d9,0x13c550e0,0x15853cf6)    R(0x008d,0x19b3cd29,0x18633538,0x1b032943)    R(0x008e,0x21752d3f,0x20549141,0x2294715f)    R(0x008f,0x179554ee,0x15f564d9,0x15853cf6)    R(0x0090,0x14b49520,0x12147936,0x1433ed2f)    R(0x0091,0x1ca3c134,0x1b032943,0x1e534d55)    R(0x0092,0x1f152d22,0x1e04692d,0x20549141)    R(0x0093,0x21752d3f,0x1f152d22,0x20549141)    R(0x0094,0x14b49520,0x11d51528,0x12147936)    R(0x0095,0x00a558e1,0x00c578bb,0x00c5fcc9)\n    R(0x0096,0x01d670fd,0x00e5f0ec,0x00e6acd7)    R(0x0097,0x0295f954,0x01b56169,0x01b57d3c)    R(0x0098,0x0e06a059,0x0c86547b,0x0f562869)    R(0x0099,0x1b032943,0x18633538,0x1832ad59)    R(0x009a,0x2295cd47,0x2075d122,0x21752d3f)    R(0x009b,0x0c86547b,0x09a68091,0x0b161ca6)    R(0x009c,0x05569ca8,0x03b608a8,0x059618b5)    R(0x009d,0x00e5f0ec,0x00a558e1,0x00c5fcc9)    R(0x009e,0x0be5d4fd,0x0b35d135,0x0dd5a122)    R(0x009f,0x0905ed43,0x07c5d54d,0x08a5d15a)\n    R(0x00a0,0x0cb59943,0x0b358159,0x0d451d4f)    R(0x00a1,0x01d5d4a6,0x015540ad,0x027564ac)    R(0x00a2,0x00d55111,0x00a558e1,0x00e5f0ec)    R(0x00a3,0x0cb5d4c4,0x09c600d7,0x0be5d4fd)    R(0x00a4,0x09a68091,0x08663cb9,0x0b161ca6)    R(0x00a5,0x05569ca8,0x059618b5,0x06b650bb)    R(0x00a6,0x059618b5,0x04458cb2,0x057578c9)    R(0x00a7,0x010620b0,0x00c578bb,0x0115a8aa)    R(0x00a8,0x0115a8aa,0x015540ad,0x01d5d4a6)    R(0x00a9,0x06a5f8d2,0x064570f2,0x0745e0f6)\n    R(0x00aa,0x0cb5d4c4,0x0b161ca6,0x09c600d7)    R(0x00ab,0x03b608a8,0x04458cb2,0x059618b5)    R(0x00ac,0x077614d4,0x06a5f8d2,0x0745e0f6)    R(0x00ad,0x077614d4,0x0745e0f6,0x0835f8f5)    R(0x00ae,0x09c600d7,0x077614d4,0x0835f8f5)    R(0x00af,0x06a5f8d2,0x059618b5,0x057578c9)    R(0x00b0,0x018660a6,0x010620b0,0x0115a8aa)    R(0x00b1,0x018660a6,0x01d5d4a6,0x02c684a3)    R(0x00b2,0x03b608a8,0x027564ac,0x04458cb2)    R(0x00b3,0x06a5f8d2,0x057578c9,0x064570f2)\n    R(0x00b4,0x07269ca4,0x06b650bb,0x08663cb9)    R(0x00b5,0x0b161ca6,0x08663cb9,0x09c600d7)    R(0x00b6,0x06b650bb,0x059618b5,0x06a5f8d2)    R(0x00b7,0x08663cb9,0x06b650bb,0x077614d4)    R(0x00b8,0x09c600d7,0x08663cb9,0x077614d4)    R(0x00b9,0x077614d4,0x06b650bb,0x06a5f8d2)    R(0x00ba,0x01b57d3c,0x00d55111,0x0205e119)    R(0x00bb,0x0cb59943,0x0a45cd53,0x0b358159)    R(0x00bc,0x0905ed43,0x08a5d15a,0x0a45cd53)    R(0x00bd,0x02c684a3,0x01d5d4a6,0x03b608a8)\n    R(0x00be,0x0205e119,0x00d55111,0x00e5f0ec)    R(0x00bf,0x0b35d135,0x0a45cd53,0x0cb59943)    R(0x00c0,0x0295f954,0x01b57d3c,0x0205e119)    R(0x00c1,0x03b608a8,0x01d5d4a6,0x027564ac)    R(0x00c2,0x07c5d54d,0x0715a928,0x06d55954)    R(0x00c3,0x0be5d4fd,0x0995ed15,0x0b35d135)    R(0x00c4,0x07f5ed27,0x0715a928,0x07c5d54d)    R(0x00c5,0x07f5ed27,0x07c5d54d,0x0905ed43)    R(0x00c6,0x0995ed15,0x0905ed43,0x0b35d135)    R(0x00c7,0x0b35d135,0x0905ed43,0x0a45cd53)\n    R(0x00c8,0x0745e0f6,0x0715a928,0x07f5ed27)    R(0x00c9,0x018660a6,0x0115a8aa,0x01d5d4a6)    R(0x00ca,0x0205e119,0x00e5f0ec,0x01d670fd)    R(0x00cb,0x0295f954,0x0205e119,0x02c67126)    R(0x00cc,0x0745e0f6,0x064570f2,0x0715a928)    R(0x00cd,0x09c600d7,0x0995ed15,0x0be5d4fd)    R(0x00ce,0x0835f8f5,0x0745e0f6,0x07f5ed27)    R(0x00cf,0x0835f8f5,0x07f5ed27,0x0995ed15)    R(0x00d0,0x0995ed15,0x07f5ed27,0x0905ed43)    R(0x00d1,0x09c600d7,0x0835f8f5,0x0995ed15)\n    R(0x00d2,0x02c67126,0x0205e119,0x01d670fd)    R(0x00d3,0x1475f064,0x11f60461,0x13459c81)    R(0x00d4,0x0115a8aa,0x00c578bb,0x00e514bb)    R(0x00d5,0x00e698be,0x00c5fcc9,0x010620b0)    R(0x00d6,0x21f67528,0x2075d122,0x2295cd47)    R(0x00d7,0x1e534d55,0x1b032943,0x1ce2c563)    R(0x00d8,0x1876546f,0x16c5f06f,0x1815e08c)    R(0x00d9,0x16f594ad,0x148568ab,0x15f564d9)    R(0x00da,0x0fa5a0b7,0x0cb5d4c4,0x0ec5a0f0)    R(0x00db,0x00c5fcc9,0x00c578bb,0x010620b0)\n    R(0x00dc,0x11f60461,0x0f562869,0x10c5bc85)    R(0x00dd,0x0c86547b,0x0b161ca6,0x0e05f494)    R(0x00de,0x1a564cca,0x19b64c96,0x1905e0bd)    R(0x00df,0x0fa5a0b7,0x0e05f494,0x0cb5d4c4)    R(0x00e0,0x123570ac,0x0fa5a0b7,0x116564e9)    R(0x00e1,0x1815e08c,0x16c5f06f,0x15a5a084)    R(0x00e2,0x1905e0bd,0x16f594ad,0x17d598d9)    R(0x00e3,0x13459c81,0x10c5bc85,0x123570ac)    R(0x00e4,0x123570ac,0x10c5bc85,0x0fa5a0b7)    R(0x00e5,0x1815e08c,0x15a5a084,0x16f594ad)\n    R(0x00e6,0x10c5bc85,0x0e05f494,0x0fa5a0b7)    R(0x00e7,0x1905e0bd,0x1815e08c,0x16f594ad)    R(0x00e8,0x0e05f494,0x0b161ca6,0x0cb5d4c4)    R(0x00e9,0x0f562869,0x0c86547b,0x0e05f494)    R(0x00ea,0x16c5f06f,0x1475f064,0x15a5a084)    R(0x00eb,0x17d598d9,0x16f594ad,0x15f564d9)    R(0x00ec,0x19b64c96,0x1876546f,0x1815e08c)    R(0x00ed,0x0f562869,0x0e05f494,0x10c5bc85)    R(0x00ee,0x16f594ad,0x15a5a084,0x148568ab)    R(0x00ef,0x148568ab,0x13459c81,0x123570ac)\n    R(0x00f0,0x15a5a084,0x13459c81,0x148568ab)    R(0x00f1,0x19b64c96,0x1815e08c,0x1905e0bd)    R(0x00f2,0x1653892f,0x15b2e948,0x18633538)    R(0x00f3,0x0dd5a122,0x0b35d135,0x0cb59943)    R(0x00f4,0x13459c81,0x11f60461,0x10c5bc85)    R(0x00f5,0x1d667ce2,0x1be5b4f4,0x1e45d100)    R(0x00f6,0x21f67528,0x1fe670ff,0x2075d122)    R(0x00f7,0x0dd5a122,0x0cb59943,0x0f255534)    R(0x00f8,0x0ec5a0f0,0x0be5d4fd,0x0dd5a122)    R(0x00f9,0x15a5a084,0x1475f064,0x13459c81)\n    R(0x00fa,0x1e45d100,0x1be5b4f4,0x1c951511)    R(0x00fb,0x2075d122,0x1e45d100,0x1f152d22)    R(0x00fc,0x1995c4e4,0x17d598d9,0x179554ee)    R(0x00fd,0x1995c4e4,0x1905e0bd,0x17d598d9)    R(0x00fe,0x1995c4e4,0x179554ee,0x19c528fe)    R(0x00ff,0x1be5b4f4,0x1995c4e4,0x19c528fe)    R(0x0100,0x116564e9,0x0fa5a0b7,0x0ec5a0f0)    R(0x0101,0x0ec5a0f0,0x0dd5a122,0x10756917)    R(0x0102,0x0cb5d4c4,0x0be5d4fd,0x0ec5a0f0)    R(0x0103,0x10756917,0x0dd5a122,0x0f255534)\n    R(0x0104,0x1a564cca,0x1905e0bd,0x1995c4e4)    R(0x0105,0x1d667ce2,0x1b363cdd,0x1be5b4f4)    R(0x0106,0x1fe670ff,0x1e45d100,0x2075d122)    R(0x0107,0x1b363cdd,0x1a564cca,0x1995c4e4)    R(0x0108,0x1b363cdd,0x1995c4e4,0x1be5b4f4)    R(0x0109,0x17d598d9,0x15f564d9,0x179554ee)    R(0x010a,0x1fe670ff,0x1d667ce2,0x1e45d100)    R(0x010b,0x116564e9,0x0ec5a0f0,0x10756917)    R(0x010c,0x16613dbd,0x144129dd,0x1650e9f7)    R(0x010d,0x2be301dc,0x2c728dd3,0x2d82cdde)\n    R(0x010e,0x0b0361fb,0x0c1359cc,0x0ad3a9de)    R(0x010f,0x0013b5ea,0x00341db4,0x00347df4)    R(0x0110,0x13a6744e,0x11f60461,0x1475f064)    R(0x0111,0x0176a5ef,0x007601eb,0x01c625c0)    R(0x0112,0x00730da7,0x00536d96,0x0032d5be)    R(0x0113,0x184175a4,0x16613dbd,0x18d10ddc)    R(0x0114,0x1b032943,0x1832ad59,0x1a92756e)    R(0x0115,0x1d51a9bc,0x1c6131e6,0x1f015df5)    R(0x0116,0x1ff3dd4f,0x1e534d55,0x20e32d72)    R(0x0117,0x2c41d1df,0x2d41a9c7,0x2cc205c7)\n    R(0x0118,0x1832ad59,0x15b2e948,0x15a2416a)    R(0x0119,0x03a3cd92,0x0183b184,0x024339a6)    R(0x011a,0x00730da7,0x0032d5be,0x0092a5c3)    R(0x011b,0x1aa15dbe,0x18d10ddc,0x1c6131e6)    R(0x011c,0x0673a5f4,0x0613b1c9,0x054359e6)    R(0x011d,0x1832ad59,0x1822057f,0x1a92756e)    R(0x011e,0x15c1a98f,0x16613dbd,0x184175a4)    R(0x011f,0x1ab1d596,0x184175a4,0x1aa15dbe)    R(0x0120,0x00e319a4,0x00a39587,0x00730da7)    R(0x0121,0x11c3b949,0x0f837d6a,0x1153015d)\n    R(0x0122,0x045365ba,0x03a3cd92,0x024339a6)    R(0x0123,0x1371f980,0x11a1d5a6,0x13f181a9)    R(0x0124,0x0f62d583,0x0fb245aa,0x11425d7c)    R(0x0125,0x1342995e,0x11425d7c,0x1371f980)    R(0x0126,0x1822057f,0x184175a4,0x1ab1d596)    R(0x0127,0x11425d7c,0x0fb245aa,0x11a1d5a6)    R(0x0128,0x15a2416a,0x1342995e,0x1371f980)    R(0x0129,0x15a2416a,0x1371f980,0x15c1a98f)    R(0x012a,0x15a2416a,0x15c1a98f,0x1822057f)    R(0x012b,0x1371f980,0x11425d7c,0x11a1d5a6)\n    R(0x012c,0x1a92756e,0x1822057f,0x1ab1d596)    R(0x012d,0x0183b184,0x00a39587,0x00e319a4)    R(0x012e,0x0f837d6a,0x0f62d583,0x1153015d)    R(0x012f,0x15c1a98f,0x13f181a9,0x16613dbd)    R(0x0130,0x1822057f,0x15c1a98f,0x184175a4)    R(0x0131,0x0dc2cdb9,0x0fb245aa,0x0f62d583)    R(0x0132,0x024339a6,0x0183b184,0x00e319a4)    R(0x0133,0x1153015d,0x0f62d583,0x11425d7c)    R(0x0134,0x1371f980,0x13f181a9,0x15c1a98f)    R(0x0135,0x0f62d583,0x0dd36197,0x0dc2cdb9)\n    R(0x0136,0x0f837d6a,0x0dd36197,0x0f62d583)    R(0x0137,0x11a1d5a6,0x121165db,0x13f181a9)    R(0x0138,0x1832ad59,0x15a2416a,0x1822057f)    R(0x0139,0x15b2e948,0x1342995e,0x15a2416a)    R(0x013a,0x0e2249e5,0x0dc2cdb9,0x0c22c5f0)    R(0x013b,0x0092a5c3,0x0032d5be,0x005279df)    R(0x013c,0x0c1359cc,0x0dd36197,0x0c43b5aa)    R(0x013d,0x0162a9c3,0x0092a5c3,0x00d269e4)    R(0x013e,0x00e319a4,0x0092a5c3,0x0162a9c3)    R(0x013f,0x03d2d1e7,0x02d2d5c5,0x020281e6)\n    R(0x0140,0x1001c1db,0x121165db,0x11a1d5a6)    R(0x0141,0x1153015d,0x11425d7c,0x1342995e)    R(0x0142,0x1001c1db,0x0fb245aa,0x0e2249e5)    R(0x0143,0x11a1d5a6,0x0fb245aa,0x1001c1db)    R(0x0144,0x02d2d5c5,0x0162a9c3,0x020281e6)    R(0x0145,0x020281e6,0x0162a9c3,0x00d269e4)    R(0x0146,0x024339a6,0x00e319a4,0x0162a9c3)    R(0x0147,0x0c1359cc,0x0c43b5aa,0x0ad3a9de)    R(0x0148,0x0c22c5f0,0x0dc2cdb9,0x0c1359cc)    R(0x0149,0x0dc2cdb9,0x0dd36197,0x0c1359cc)\n    R(0x014a,0x0e2249e5,0x0fb245aa,0x0dc2cdb9)    R(0x014b,0x0613b1c9,0x045365ba,0x054359e6)    R(0x014c,0x024339a6,0x0162a9c3,0x02d2d5c5)    R(0x014d,0x045365ba,0x024339a6,0x02d2d5c5)    R(0x014e,0x045365ba,0x02d2d5c5,0x03d2d1e7)    R(0x014f,0x054359e6,0x045365ba,0x03d2d1e7)    R(0x0150,0x1b032943,0x1a92756e,0x1ce2c563)    R(0x0151,0x00a39587,0x00536d96,0x00730da7)    R(0x0152,0x24c3a1a5,0x253339be,0x2673d1c8)    R(0x0153,0x1d51a9bc,0x1aa15dbe,0x1c6131e6)\n    R(0x0154,0x1d51a9bc,0x1f015df5,0x2021d5cf)    R(0x0155,0x2c41d1df,0x2d218de6,0x2d41a9c7)    R(0x0156,0x1d51a9bc,0x1ab1d596,0x1aa15dbe)    R(0x0157,0x2c1235d4,0x2cc205c7,0x2ce259c4)    R(0x0158,0x1e534d55,0x1ce2c563,0x1f42b57d)    R(0x0159,0x00e319a4,0x00730da7,0x0092a5c3)    R(0x015a,0x2673d1c8,0x253339be,0x27836dcc)    R(0x015b,0x21a295a8,0x2021d5cf,0x22521dce)    R(0x015c,0x1f42b57d,0x1cf2358b,0x1f6235a7)    R(0x015d,0x1f6235a7,0x1d51a9bc,0x2021d5cf)\n    R(0x015e,0x20e32d72,0x1f42b57d,0x21a295a8)    R(0x015f,0x23d2a9bf,0x25221dce,0x2692b5c6)    R(0x0160,0x21a295a8,0x1f42b57d,0x1f6235a7)    R(0x0161,0x21a295a8,0x22521dce,0x23d2a9bf)    R(0x0162,0x2323219d,0x21a295a8,0x23d2a9bf)    R(0x0163,0x23d2a9bf,0x22521dce,0x25221dce)    R(0x0164,0x1f6235a7,0x2021d5cf,0x21a295a8)    R(0x0165,0x1a92756e,0x1ab1d596,0x1cf2358b)    R(0x0166,0x1cf2358b,0x1ab1d596,0x1d51a9bc)    R(0x0167,0x1e534d55,0x1f42b57d,0x20e32d72)\n    R(0x0168,0x24c3a1a5,0x2273b571,0x2323219d)    R(0x0169,0x253339be,0x2692b5c6,0x27836dcc)    R(0x016a,0x1f6235a7,0x1cf2358b,0x1d51a9bc)    R(0x016b,0x2323219d,0x23d2a9bf,0x253339be)    R(0x016c,0x24c3a1a5,0x2323219d,0x253339be)    R(0x016d,0x253339be,0x23d2a9bf,0x2692b5c6)    R(0x016e,0x2323219d,0x20e32d72,0x21a295a8)    R(0x016f,0x286221d2,0x269191e2,0x296185ef)    R(0x0170,0x22521dce,0x211191f2,0x238199e3)    R(0x0171,0x2c1235d4,0x2ce259c4,0x2c728dd3)\n    R(0x0172,0x1ce2c563,0x1a92756e,0x1cf2358b)    R(0x0173,0x00d269e4,0x0092a5c3,0x005279df)    R(0x0174,0x2273b571,0x20e32d72,0x2323219d)    R(0x0175,0x2021d5cf,0x211191f2,0x22521dce)    R(0x0176,0x2692b5c6,0x25221dce,0x286221d2)    R(0x0177,0x2942e5ce,0x286221d2,0x2af26dd4)    R(0x0178,0x2c1235d4,0x2c41d1df,0x2cc205c7)    R(0x0179,0x25221dce,0x238199e3,0x269191e2)    R(0x017a,0x286221d2,0x2b01ede0,0x2af26dd4)    R(0x017b,0x2af26dd4,0x2b01ede0,0x2c1235d4)\n    R(0x017c,0x2b01ede0,0x2c41d1df,0x2c1235d4)    R(0x017d,0x2af26dd4,0x2c1235d4,0x2c728dd3)    R(0x017e,0x22521dce,0x238199e3,0x25221dce)    R(0x017f,0x1ce2c563,0x1cf2358b,0x1f42b57d)    R(0x0180,0x286221d2,0x296185ef,0x2b01ede0)    R(0x0181,0x2a139ddf,0x2be301dc,0x2cb3a1f2)    R(0x0182,0x2692b5c6,0x286221d2,0x2942e5ce)    R(0x0183,0x27836dcc,0x2942e5ce,0x2a139ddf)    R(0x0184,0x25221dce,0x269191e2,0x286221d2)    R(0x0185,0x2942e5ce,0x2be301dc,0x2a139ddf)\n    R(0x0186,0x2942e5ce,0x2af26dd4,0x2be301dc)    R(0x0187,0x27836dcc,0x2692b5c6,0x2942e5ce)    R(0x0188,0x2af26dd4,0x2c728dd3,0x2be301dc)    R(0x0189,0x00536d96,0x0053f585,0x002371b0)    R(0x018a,0x10c67c4f,0x0f562869,0x11f60461)    R(0x018b,0x1aa15dbe,0x184175a4,0x18d10ddc)    R(0x018c,0x25d681bd,0x25165d8b,0x25b5bda5)    R(0x018d,0x272455d5,0x281405dc,0x28147df9)    R(0x018e,0x281405dc,0x27836dcc,0x2a139ddf)    R(0x018f,0x0064857a,0x00849140,0x0094f149)\n    R(0x0190,0x0ab4f966,0x09358563,0x0834f56d)    R(0x0191,0x0083fd73,0x00845560,0x0053f585)    R(0x0192,0x02865188,0x0225b590,0x0295f954)    R(0x0193,0x05f3fda2,0x03a3cd92,0x045365ba)    R(0x0194,0x0793bddb,0x0613b1c9,0x0673a5f4)    R(0x0195,0x0183b184,0x00d41d6b,0x00a39587)    R(0x0196,0x0053f585,0x00845560,0x0064857a)    R(0x0197,0x00a5118a,0x0064857a,0x0094f149)    R(0x0198,0x0225b590,0x01b56169,0x0295f954)    R(0x0199,0x0a45cd53,0x08a5d15a,0x09358563)\n    R(0x019a,0x02343570,0x0174595b,0x00d41d6b)    R(0x019b,0x00d41d6b,0x0083fd73,0x00a39587)    R(0x019c,0x0174595b,0x00c4515a,0x00d41d6b)    R(0x019d,0x0834f56d,0x0684e96b,0x07147585)    R(0x019e,0x09a47d78,0x0834f56d,0x07147585)    R(0x019f,0x04b4697a,0x0574cd5d,0x03447961)    R(0x01a0,0x0684e96b,0x0574cd5d,0x04b4697a)    R(0x01a1,0x07147585,0x0684e96b,0x04b4697a)    R(0x01a2,0x03447961,0x0174595b,0x02343570)    R(0x01a3,0x04b4697a,0x03447961,0x02343570)\n    R(0x01a4,0x00c4515a,0x00845560,0x0083fd73)    R(0x01a5,0x00a5118a,0x0094f149,0x01b56169)    R(0x01a6,0x02343570,0x00d41d6b,0x0183b184)    R(0x01a7,0x07c5d54d,0x06d55954,0x07b57961)    R(0x01a8,0x09358563,0x07b57961,0x0834f56d)    R(0x01a9,0x00d41d6b,0x00c4515a,0x0083fd73)    R(0x01aa,0x0834f56d,0x07b57961,0x0684e96b)    R(0x01ab,0x08a5d15a,0x07c5d54d,0x07b57961)    R(0x01ac,0x07b57961,0x06d55954,0x0684e96b)    R(0x01ad,0x08a5d15a,0x07b57961,0x09358563)\n    R(0x01ae,0x00a39587,0x0083fd73,0x00536d96)    R(0x01af,0x0613b1c9,0x05f3fda2,0x045365ba)    R(0x01b0,0x0a53d5af,0x07d3e5b6,0x0953c1d8)    R(0x01b1,0x00845560,0x00849140,0x0064857a)    R(0x01b2,0x007601eb,0x005559e8,0x00b581bb)    R(0x01b3,0x01c625c0,0x0225b590,0x02865188)    R(0x01b4,0x03a3cd92,0x02343570,0x0183b184)    R(0x01b5,0x0953c1d8,0x07d3e5b6,0x0793bddb)    R(0x01b6,0x09a47d78,0x07147585,0x08b42596)    R(0x01b7,0x0a53d5af,0x08b42596,0x07d3e5b6)\n    R(0x01b8,0x08b42596,0x07147585,0x05f3fda2)    R(0x01b9,0x08b42596,0x05f3fda2,0x07d3e5b6)    R(0x01ba,0x04b4697a,0x02343570,0x03a3cd92)    R(0x01bb,0x05f3fda2,0x04b4697a,0x03a3cd92)    R(0x01bc,0x07147585,0x04b4697a,0x05f3fda2)    R(0x01bd,0x0054d1bc,0x0064857a,0x00a5118a)    R(0x01be,0x007601eb,0x00b581bb,0x01c625c0)    R(0x01bf,0x0684e96b,0x06d55954,0x0574cd5d)    R(0x01c0,0x07d3e5b6,0x05f3fda2,0x0613b1c9)    R(0x01c1,0x00b581bb,0x00a5118a,0x0225b590)\n    R(0x01c2,0x0225b590,0x00a5118a,0x01b56169)    R(0x01c3,0x01c625c0,0x00b581bb,0x0225b590)    R(0x01c4,0x00b581bb,0x0054d1bc,0x00a5118a)    R(0x01c5,0x005559e8,0x0054d1bc,0x00b581bb)    R(0x01c6,0x0793bddb,0x07d3e5b6,0x0613b1c9)    R(0x01c7,0x16465458,0x1475f064,0x16c5f06f)    R(0x01c8,0x00341db4,0x0053f585,0x0064857a)    R(0x01c9,0x25d681bd,0x25b5bda5,0x263605d1)    R(0x01ca,0x13f181a9,0x144129dd,0x16613dbd)    R(0x01cb,0x2673d1c8,0x27836dcc,0x281405dc)\n    R(0x01cc,0x25d681bd,0x263605d1,0x264681f8)    R(0x01cd,0x1ff3dd4f,0x20e32d72,0x2273b571)    R(0x01ce,0x0083fd73,0x0053f585,0x00536d96)    R(0x01cf,0x2504ad81,0x24541981,0x26143dab)    R(0x01d0,0x2435cd74,0x2295cd47,0x23752564)    R(0x01d1,0x25165d8b,0x23d66d56,0x2435cd74)    R(0x01d2,0x0dc3ed7c,0x0b741585,0x0c43b5aa)    R(0x01d3,0x0b741585,0x09a47d78,0x08b42596)    R(0x01d4,0x0ab4f966,0x09a47d78,0x0cd47962)    R(0x01d5,0x0f837d6a,0x0dc3ed7c,0x0dd36197)\n    R(0x01d6,0x2294715f,0x1ff3dd4f,0x2273b571)    R(0x01d7,0x2504ad81,0x2294715f,0x24541981)    R(0x01d8,0x0cd47962,0x09a47d78,0x0b741585)    R(0x01d9,0x0cd47962,0x0b741585,0x0dc3ed7c)    R(0x01da,0x2294715f,0x2273b571,0x24541981)    R(0x01db,0x0fa42d57,0x0cd47962,0x0dc3ed7c)    R(0x01dc,0x0ab4f966,0x0834f56d,0x09a47d78)    R(0x01dd,0x0d451d4f,0x0ab4f966,0x0cd47962)    R(0x01de,0x0fa42d57,0x0dc3ed7c,0x0f837d6a)    R(0x01df,0x24541981,0x2273b571,0x24c3a1a5)\n    R(0x01e0,0x25165d8b,0x2435cd74,0x25b5bda5)    R(0x01e1,0x0b358159,0x09358563,0x0ab4f966)    R(0x01e2,0x2435cd74,0x23752564,0x2555418a)    R(0x01e3,0x2555418a,0x23752564,0x2504ad81)    R(0x01e4,0x23752564,0x2294715f,0x2504ad81)    R(0x01e5,0x25b5bda5,0x2435cd74,0x2555418a)    R(0x01e6,0x121165db,0x144129dd,0x13f181a9)    R(0x01e7,0x272455d5,0x2673d1c8,0x281405dc)    R(0x01e8,0x00347df4,0x00341db4,0x0054d1bc)    R(0x01e9,0x23d66d56,0x2295cd47,0x2435cd74)\n    R(0x01ea,0x1876546f,0x16465458,0x16c5f06f)    R(0x01eb,0x0c43b5aa,0x0b741585,0x0a53d5af)    R(0x01ec,0x00341db4,0x0064857a,0x0054d1bc)    R(0x01ed,0x0dd36197,0x0dc3ed7c,0x0c43b5aa)    R(0x01ee,0x2684ddb2,0x2504ad81,0x26143dab)    R(0x01ef,0x2684ddb2,0x272455d5,0x2754cdee)    R(0x01f0,0x26143dab,0x24541981,0x24c3a1a5)    R(0x01f1,0x26143dab,0x24c3a1a5,0x2673d1c8)    R(0x01f2,0x0ad3a9de,0x0c43b5aa,0x0a53d5af)    R(0x01f3,0x26143dab,0x2673d1c8,0x272455d5)\n    R(0x01f4,0x2684ddb2,0x26143dab,0x272455d5)    R(0x01f5,0x0a53d5af,0x0b741585,0x08b42596)    R(0x01f6,0x00347df4,0x0054d1bc,0x005559e8)    R(0x01f7,0x0fa42d57,0x0f837d6a,0x11c3b949)    R(0x01f8,0x25b5bda5,0x26e55dd6,0x263605d1)    R(0x01f9,0x26e55dd6,0x2684ddb2,0x2754cdee)    R(0x01fa,0x0ad3a9de,0x0a53d5af,0x0953c1d8)    R(0x01fb,0x2555418a,0x2504ad81,0x2684ddb2)    R(0x01fc,0x25b5bda5,0x2555418a,0x2684ddb2)    R(0x01fd,0x0a45cd53,0x09358563,0x0b358159)\n    R(0x01fe,0x25b5bda5,0x2684ddb2,0x26e55dd6)    R(0x01ff,0x0d451d4f,0x0b358159,0x0ab4f966)    R(0x0200,0x37f15c06,0x39d15400,0x3a315c02)    R(0x0201,0x3bc00c87,0x3ad00099,0x3a700cb2)    R(0x0202,0x3dc62971,0x3f26854a,0x3ed66144)    R(0x0203,0x351635b9,0x3596b58e,0x36e63589)    R(0x0204,0x005279df,0x0032d5be,0x001299f0)    R(0x0205,0x335229e1,0x34c1d1c7,0x3341fdfe)    R(0x0206,0x392010ca,0x399008b2,0x37d028e6)    R(0x0207,0x39c12406,0x3ae13804,0x38a14c02)\n    R(0x0208,0x2e81715b,0x2f51111c,0x2f015925)    R(0x0209,0x32625139,0x3422351a,0x32e26967)    R(0x020a,0x35461d4a,0x3725fd36,0x3646a12e)    R(0x020b,0x3df63935,0x3e1688fb,0x3ca62923)    R(0x020c,0x2f51111c,0x2ff0e8dd,0x2fa10ce9)    R(0x020d,0x2f512954,0x2ff0f94b,0x2fc0ed12)    R(0x020e,0x36507134,0x36205d20,0x34e09557)    R(0x020f,0x37d028e6,0x399008b2,0x38004cc6)    R(0x0210,0x38a10017,0x3b80cc24,0x39c12406)    R(0x0211,0x3c80d859,0x3cb10c2a,0x3d20c43d)\n    R(0x0212,0x3700e83a,0x38a10017,0x35c0fc25)    R(0x0213,0x37b0c46a,0x39d0c43e,0x3700e83a)    R(0x0214,0x37703901,0x392010ca,0x37d028e6)    R(0x0215,0x2f51111c,0x2fc0ed12,0x2ff0e8dd)    R(0x0216,0x3820d131,0x37c06918,0x36e0a94b)    R(0x0217,0x3360ec4c,0x35c0fc25,0x34d10c2b)    R(0x0218,0x36a068f6,0x38004cc6,0x3630b4cc)    R(0x0219,0x34b0dc6c,0x37b0c46a,0x3700e83a)    R(0x021a,0x2ff0e8dd,0x3080d8d6,0x3100d8a5)    R(0x021b,0x3080ecaf,0x31c0e87b,0x31610885)\n    R(0x021c,0x3450dcde,0x3630b4cc,0x3590d09f)    R(0x021d,0x3590d09f,0x37b0c46a,0x34b0dc6c)    R(0x021e,0x3080d8d6,0x32a0d8a2,0x3100d8a5)    R(0x021f,0x3080d8d6,0x3220e4de,0x32a0d8a2)    R(0x0220,0x32a0d8a2,0x34b0dc6c,0x3260dc73)    R(0x0221,0x3630b4cc,0x38004cc6,0x37e0a098)    R(0x0222,0x3100d8a5,0x32a0d8a2,0x3260dc73)    R(0x0223,0x3450dcde,0x3590d09f,0x32a0d8a2)    R(0x0224,0x32a0d8a2,0x3590d09f,0x34b0dc6c)    R(0x0225,0x3630b4cc,0x37e0a098,0x3590d09f)\n    R(0x0226,0x3220e4de,0x3450dcde,0x32a0d8a2)    R(0x0227,0x2ff0e8dd,0x3100d8a5,0x3080ecaf)    R(0x0228,0x31c0e87b,0x32d10454,0x31610885)    R(0x0229,0x34b0dc6c,0x3700e83a,0x3460e445)    R(0x022a,0x3590d09f,0x37e0a098,0x37b0c46a)    R(0x022b,0x3260dc73,0x3360ec4c,0x31c0e87b)    R(0x022c,0x31c0e87b,0x3360ec4c,0x32d10454)    R(0x022d,0x3260dc73,0x3460e445,0x3360ec4c)    R(0x022e,0x3260dc73,0x34b0dc6c,0x3460e445)    R(0x022f,0x3100d8a5,0x3260dc73,0x31c0e87b)\n    R(0x0230,0x3100d8a5,0x31c0e87b,0x3080ecaf)    R(0x0231,0x38c030e7,0x392010ca,0x37703901)    R(0x0232,0x36e0a94b,0x37c06918,0x36507134)    R(0x0233,0x2fc0ed12,0x30e0e913,0x3080d8d6)    R(0x0234,0x3460e445,0x3700e83a,0x35c0fc25)    R(0x0235,0x3360ec4c,0x34d10c2b,0x32d10454)    R(0x0236,0x36507134,0x37703901,0x36205d20)    R(0x0237,0x3440bd44,0x3510b111,0x3330f51c)    R(0x0238,0x3510b111,0x3630b4cc,0x3450dcde)    R(0x0239,0x37703901,0x37d028e6,0x36205d20)\n    R(0x023a,0x3820d131,0x38d07900,0x37c06918)    R(0x023b,0x36a068f6,0x3630b4cc,0x3510b111)    R(0x023c,0x36205d20,0x3510b111,0x3440bd44)    R(0x023d,0x37c06918,0x37703901,0x36507134)    R(0x023e,0x36205d20,0x36a068f6,0x3510b111)    R(0x023f,0x38d07900,0x38c030e7,0x37c06918)    R(0x0240,0x2ff0f94b,0x31710549,0x30e0e913)    R(0x0241,0x3460e445,0x35c0fc25,0x3360ec4c)    R(0x0242,0x36205d20,0x37d028e6,0x36a068f6)    R(0x0243,0x37c06918,0x38c030e7,0x37703901)\n    R(0x0244,0x3330f51c,0x3450dcde,0x3220e4de)    R(0x0245,0x3330f51c,0x3510b111,0x3450dcde)    R(0x0246,0x30e0e913,0x3220e4de,0x3080d8d6)    R(0x0247,0x31710549,0x3330f51c,0x30e0e913)    R(0x0248,0x37d028e6,0x38004cc6,0x36a068f6)    R(0x0249,0x30e0e913,0x3330f51c,0x3220e4de)    R(0x024a,0x3b80cc24,0x3bd10011,0x39c12406)    R(0x024b,0x3cb10c2a,0x3cb1081b,0x3d20c43d)    R(0x024c,0x399008b2,0x39a03899,0x38004cc6)    R(0x024d,0x2ff0e8dd,0x3080ecaf,0x2fa10ce9)\n    R(0x024e,0x39b11cbc,0x3a50b8c8,0x391128f4)    R(0x024f,0x2ff0f94b,0x30e0e913,0x2fc0ed12)    R(0x0250,0x3ca04861,0x3c002072,0x3bc00c87)    R(0x0251,0x3cd0846a,0x3d20c43d,0x3d108050)    R(0x0252,0x3b90ac91,0x3c80d859,0x3cd0846a)    R(0x0253,0x3d20c43d,0x3cb1081b,0x3d10c82b)    R(0x0254,0x3700e83a,0x39d0c43e,0x38a10017)    R(0x0255,0x3c90f818,0x3bd10011,0x3cc0c028)    R(0x0256,0x3a40746b,0x3be06053,0x39d0c43e)    R(0x0257,0x3c002072,0x3be06053,0x3b200c82)\n    R(0x0258,0x3b80cc24,0x3be06053,0x3cb07048)    R(0x0259,0x3d108050,0x3ca04861,0x3c703c78)    R(0x025a,0x3cd0846a,0x3d108050,0x3c703c78)    R(0x025b,0x3d10943c,0x3cb07048,0x3ca04861)    R(0x025c,0x3d10943c,0x3cc0c028,0x3cb07048)    R(0x025d,0x3d108050,0x3d10943c,0x3ca04861)    R(0x025e,0x3d108050,0x3d10c82b,0x3d10943c)    R(0x025f,0x37b0c46a,0x3a40746b,0x39d0c43e)    R(0x0260,0x3b200c82,0x3be06053,0x3a40746b)    R(0x0261,0x3c703c78,0x3ca04861,0x3bc00c87)\n    R(0x0262,0x3c80d859,0x3d20c43d,0x3cd0846a)    R(0x0263,0x3d10c82b,0x3c90f818,0x3d10943c)    R(0x0264,0x3cb07048,0x3cc0c028,0x3b80cc24)    R(0x0265,0x3ca04861,0x3cb07048,0x3c002072)    R(0x0266,0x3cb07048,0x3be06053,0x3c002072)    R(0x0267,0x39d0c43e,0x3be06053,0x3b80cc24)    R(0x0268,0x3d20c43d,0x3d10c82b,0x3d108050)    R(0x0269,0x39a03899,0x3b200c82,0x3a40746b)    R(0x026a,0x3940c8fe,0x38d07900,0x3820d131)    R(0x026b,0x3d10943c,0x3c90f818,0x3cc0c028)\n    R(0x026c,0x3cc0c028,0x3bd10011,0x3b80cc24)    R(0x026d,0x391128f4,0x3a50b8c8,0x3940c8fe)    R(0x026e,0x2fc0ed12,0x3080d8d6,0x2ff0e8dd)    R(0x026f,0x37e0a098,0x3a40746b,0x37b0c46a)    R(0x0270,0x3940c8fe,0x3a506cce,0x38d07900)    R(0x0271,0x3bb0589b,0x3c703c78,0x3b5020a2)    R(0x0272,0x3b90ac91,0x3cd0846a,0x3bb0589b)    R(0x0273,0x3a506cce,0x39d034d0,0x38d07900)    R(0x0274,0x3a50b8c8,0x3a506cce,0x3940c8fe)    R(0x0275,0x3a50b8c8,0x3bb0589b,0x3a506cce)\n    R(0x0276,0x3b90ac91,0x3bb0589b,0x3a50b8c8)    R(0x0277,0x37e0a098,0x39a03899,0x3a40746b)    R(0x0278,0x38004cc6,0x39a03899,0x37e0a098)    R(0x0279,0x3861252f,0x3940c8fe,0x3820d131)    R(0x027a,0x39d0c43e,0x3b80cc24,0x38a10017)    R(0x027b,0x3a506cce,0x3b5020a2,0x39d034d0)    R(0x027c,0x3cb1081b,0x3c90f818,0x3d10c82b)    R(0x027d,0x39b11cbc,0x3b90ac91,0x3a50b8c8)    R(0x027e,0x39b11cbc,0x3aa11882,0x3b90ac91)    R(0x027f,0x3bb0589b,0x3b5020a2,0x3a506cce)\n    R(0x0280,0x3aa11882,0x3c80d859,0x3b90ac91)    R(0x0281,0x3cd0846a,0x3c703c78,0x3bb0589b)    R(0x0282,0x38d07900,0x39d034d0,0x38c030e7)    R(0x0283,0x2f015925,0x2f915cf5,0x2f01b933)    R(0x0284,0x3721280f,0x38a14c02,0x36613c12)    R(0x0285,0x37f18525,0x3861252f,0x3731895e)    R(0x0286,0x3725fd36,0x39763119,0x38269d10)    R(0x0287,0x399008b2,0x3b200c82,0x39a03899)    R(0x0288,0x3ca62923,0x3e1688fb,0x3bb65d05)    R(0x0289,0x35d14c1a,0x36613c12,0x37f15c06)\n    R(0x028a,0x3080ecaf,0x31610885,0x304120bb)    R(0x028b,0x3601f8fd,0x38118ce6,0x36d1d91d)    R(0x028c,0x32625139,0x32b21cff,0x3422351a)    R(0x028d,0x2f820537,0x2ff1bd05,0x30c2292a)    R(0x028e,0x34e2313f,0x36d1d91d,0x3641e955)    R(0x028f,0x31610885,0x32d10454,0x3271245f)    R(0x0290,0x304120bb,0x31610885,0x31213c93)    R(0x0291,0x35d14c1a,0x37f15c06,0x3621601d)    R(0x0292,0x31d184ae,0x33d1988d,0x3341d8c7)    R(0x0293,0x31610885,0x3271245f,0x31213c93)\n    R(0x0294,0x3271245f,0x34412433,0x3411443d)    R(0x0295,0x31d184ae,0x31213c93,0x32814c72)    R(0x0296,0x32d10454,0x34412433,0x3271245f)    R(0x0297,0x3411443d,0x34412433,0x35d14c1a)    R(0x0298,0x34916851,0x3621601d,0x36917833)    R(0x0299,0x32814c72,0x3411443d,0x34916851)    R(0x029a,0x32814c72,0x3271245f,0x3411443d)    R(0x029b,0x3411443d,0x3621601d,0x34916851)    R(0x029c,0x3411443d,0x35d14c1a,0x3621601d)    R(0x029d,0x31213c93,0x3271245f,0x32814c72)\n    R(0x029e,0x31d184ae,0x32814c72,0x33d1988d)    R(0x029f,0x32d10454,0x34d10c2b,0x34412433)    R(0x02a0,0x3341d8c7,0x33d1988d,0x3571c8a8)    R(0x02a1,0x35e19c6f,0x36917833,0x37f18c53)    R(0x02a2,0x33d1988d,0x34916851,0x35e19c6f)    R(0x02a3,0x33d1988d,0x35e19c6f,0x3571c8a8)    R(0x02a4,0x34916851,0x36917833,0x35e19c6f)    R(0x02a5,0x3571c8a8,0x35e19c6f,0x3761a48c)    R(0x02a6,0x3571c8a8,0x3761a48c,0x36e1c4c6)    R(0x02a7,0x32814c72,0x34916851,0x33d1988d)\n    R(0x02a8,0x2fa10ce9,0x3080ecaf,0x304120bb)    R(0x02a9,0x35c0fc25,0x3721280f,0x34d10c2b)    R(0x02aa,0x2fa10ce9,0x304120bb,0x2f915cf5)    R(0x02ab,0x34e2313f,0x3601f8fd,0x36d1d91d)    R(0x02ac,0x30c2292a,0x32b21cff,0x32625139)    R(0x02ad,0x34412433,0x36613c12,0x35d14c1a)    R(0x02ae,0x2f915cf5,0x30716ccd,0x2ff1bd05)    R(0x02af,0x2f915cf5,0x304120bb,0x30716ccd)    R(0x02b0,0x304120bb,0x31213c93,0x30716ccd)    R(0x02b1,0x3341d8c7,0x3571c8a8,0x34c200df)\n    R(0x02b2,0x34c200df,0x3571c8a8,0x36e1c4c6)    R(0x02b3,0x3141d8ec,0x30716ccd,0x31d184ae)    R(0x02b4,0x3141d8ec,0x31d184ae,0x3341d8c7)    R(0x02b5,0x2ff1bd05,0x30716ccd,0x3141d8ec)    R(0x02b6,0x30716ccd,0x31213c93,0x31d184ae)    R(0x02b7,0x30c2292a,0x2ff1bd05,0x3141d8ec)    R(0x02b8,0x32b21cff,0x34c200df,0x3422351a)    R(0x02b9,0x3422351a,0x3601f8fd,0x34e2313f)    R(0x02ba,0x34d10c2b,0x36613c12,0x34412433)    R(0x02bb,0x34d10c2b,0x3721280f,0x36613c12)\n    R(0x02bc,0x3422351a,0x34c200df,0x3601f8fd)    R(0x02bd,0x3141d8ec,0x3341d8c7,0x32b21cff)    R(0x02be,0x32b21cff,0x3341d8c7,0x34c200df)    R(0x02bf,0x34c200df,0x36e1c4c6,0x3601f8fd)    R(0x02c0,0x30c2292a,0x3141d8ec,0x32b21cff)    R(0x02c1,0x36613c12,0x38a14c02,0x37f15c06)    R(0x02c2,0x3c703c78,0x3bc00c87,0x3b5020a2)    R(0x02c3,0x2f015925,0x2fa10ce9,0x2f915cf5)    R(0x02c4,0x3aa5e530,0x3bb65d05,0x39763119)    R(0x02c5,0x36d1d91d,0x37f18525,0x3641e955)\n    R(0x02c6,0x3df63935,0x3ca62923,0x3bf5c54f)    R(0x02c7,0x3b813049,0x3cb10c2a,0x3c80d859)    R(0x02c8,0x35c0fc25,0x38a10017,0x3721280f)    R(0x02c9,0x3ae13804,0x3bd10011,0x3c90f818)    R(0x02ca,0x38b174a7,0x39616c6c,0x3aa11882)    R(0x02cb,0x3761a48c,0x39616c6c,0x38b174a7)    R(0x02cc,0x3cb10c2a,0x3bc1400e,0x3cb1081b)    R(0x02cd,0x39616c6c,0x3a116c34,0x3b813049)    R(0x02ce,0x39616c6c,0x3b813049,0x3aa11882)    R(0x02cf,0x3aa11882,0x3b813049,0x3c80d859)\n    R(0x02d0,0x3b813049,0x3bb1481e,0x3cb10c2a)    R(0x02d1,0x3bc1400e,0x3ba1380a,0x3cb1081b)    R(0x02d2,0x3a116c34,0x3a61640b,0x3bb1481e)    R(0x02d3,0x3a116c34,0x3bb1481e,0x3b813049)    R(0x02d4,0x3a61640b,0x3bc1400e,0x3bb1481e)    R(0x02d5,0x3bb1481e,0x3bc1400e,0x3cb10c2a)    R(0x02d6,0x3621601d,0x38516c08,0x36917833)    R(0x02d7,0x35e19c6f,0x37f18c53,0x3761a48c)    R(0x02d8,0x3ba1380a,0x3c90f818,0x3cb1081b)    R(0x02d9,0x36917833,0x38516c08,0x3891781d)\n    R(0x02da,0x3761a48c,0x37f18c53,0x39616c6c)    R(0x02db,0x37f18c53,0x3891781d,0x3a116c34)    R(0x02dc,0x38516c08,0x3a61640b,0x3891781d)    R(0x02dd,0x37f18c53,0x3a116c34,0x39616c6c)    R(0x02de,0x3891781d,0x3a61640b,0x3a116c34)    R(0x02df,0x36917833,0x3891781d,0x37f18c53)    R(0x02e0,0x38c030e7,0x3a700cb2,0x392010ca)    R(0x02e1,0x2f512954,0x2fc0ed12,0x2f51111c)    R(0x02e2,0x2f51111c,0x2fa10ce9,0x2f015925)    R(0x02e3,0x3a315c02,0x3bc1400e,0x3a61640b)\n    R(0x02e4,0x3bf5c54f,0x3ca62923,0x3aa5e530)    R(0x02e5,0x3aa5e530,0x3ca62923,0x3bb65d05)    R(0x02e6,0x3621601d,0x37f15c06,0x38516c08)    R(0x02e7,0x38118ce6,0x391128f4,0x37f18525)    R(0x02e8,0x37f18525,0x391128f4,0x3861252f)    R(0x02e9,0x39d034d0,0x3a700cb2,0x38c030e7)    R(0x02ea,0x39c12406,0x3bd10011,0x3ae13804)    R(0x02eb,0x3ba1380a,0x3ae13804,0x3c90f818)    R(0x02ec,0x38118ce6,0x38b174a7,0x39b11cbc)    R(0x02ed,0x38b174a7,0x3aa11882,0x39b11cbc)\n    R(0x02ee,0x391128f4,0x3940c8fe,0x3861252f)    R(0x02ef,0x38118ce6,0x39b11cbc,0x391128f4)    R(0x02f0,0x2f01b933,0x2ff1bd05,0x2f820537)    R(0x02f1,0x3885a93f,0x39763119,0x3725fd36)    R(0x02f2,0x38a10017,0x39c12406,0x3721280f)    R(0x02f3,0x3b5020a2,0x3a700cb2,0x39d034d0)    R(0x02f4,0x36e1c4c6,0x3761a48c,0x38b174a7)    R(0x02f5,0x36e1c4c6,0x38b174a7,0x38118ce6)    R(0x02f6,0x2f01b933,0x2f915cf5,0x2ff1bd05)    R(0x02f7,0x3601f8fd,0x36e1c4c6,0x38118ce6)\n    R(0x02f8,0x3885a93f,0x3aa5e530,0x39763119)    R(0x02f9,0x36d1d91d,0x38118ce6,0x37f18525)    R(0x02fa,0x34e09557,0x36205d20,0x3440bd44)    R(0x02fb,0x3721280f,0x39c12406,0x38a14c02)    R(0x02fc,0x0032d5be,0x00536d96,0x002371b0)    R(0x02fd,0x3553d9fd,0x368425d5,0x3483e1e0)    R(0x02fe,0x31f5f9a5,0x3336998b,0x326635b2)    R(0x02ff,0x3df64976,0x3f26854a,0x3dc62971)    R(0x0300,0x002371b0,0x0053f585,0x00341db4)    R(0x0301,0x33a1bdf8,0x34f189c7,0x338181f0)\n    R(0x0302,0x3550b56d,0x36507134,0x34e09557)    R(0x0303,0x368425d5,0x37c481ad,0x358449b0)    R(0x0304,0x37f15c06,0x3a315c02,0x38516c08)    R(0x0305,0x3a315c02,0x3ba1380a,0x3bc1400e)    R(0x0306,0x2e81715b,0x2f512954,0x2f51111c)    R(0x0307,0x30c1157e,0x32f0e96d,0x31710549)    R(0x0308,0x2ce259c4,0x2d821da2,0x2df2619f)    R(0x0309,0x3103d1e0,0x333409c6,0x319445be)    R(0x030a,0x302145f4,0x323119cd,0x303131b8)    R(0x030b,0x2e81715b,0x2f015925,0x2e31c56a)\n    R(0x030c,0x3221019d,0x32f0e96d,0x30c1157e)    R(0x030d,0x2e5165bd,0x2f712989,0x2e416d8e)    R(0x030e,0x2d91bd9e,0x2e31c56a,0x2d821da2)    R(0x030f,0x2f424568,0x2f820537,0x30c2292a)    R(0x0310,0x30c2899a,0x30c26566,0x32e26967)    R(0x0311,0x303131b8,0x30c1157e,0x2f712989)    R(0x0312,0x2d821da2,0x2e31c56a,0x2e62116c)    R(0x0313,0x2e31c56a,0x2f01b933,0x2e62116c)    R(0x0314,0x2e62116c,0x2f820537,0x2f424568)    R(0x0315,0x2f712989,0x30c1157e,0x2ff0f94b)\n    R(0x0316,0x30c1157e,0x31710549,0x2ff0f94b)    R(0x0317,0x2e416d8e,0x2f712989,0x2f512954)    R(0x0318,0x2d91bd9e,0x2e416d8e,0x2e81715b)    R(0x0319,0x2d91bd9e,0x2e81715b,0x2e31c56a)    R(0x031a,0x2e416d8e,0x2f512954,0x2e81715b)    R(0x031b,0x2d821da2,0x2e62116c,0x2df2619f)    R(0x031c,0x2f712989,0x2ff0f94b,0x2f512954)    R(0x031d,0x2f02819b,0x30c26566,0x30c2899a)    R(0x031e,0x2f424568,0x30c2292a,0x30c26566)    R(0x031f,0x303131b8,0x3221019d,0x30c1157e)\n    R(0x0320,0x30c26566,0x32625139,0x32e26967)    R(0x0321,0x2df2619f,0x2e62116c,0x2f424568)    R(0x0322,0x2f02819b,0x2f424568,0x30c26566)    R(0x0323,0x2df2619f,0x2f424568,0x2f02819b)    R(0x0324,0x30c2899a,0x32e26967,0x327275a1)    R(0x0325,0x323119cd,0x3221019d,0x303131b8)    R(0x0326,0x302145f4,0x303131b8,0x2ea155e2)    R(0x0327,0x2e31c56a,0x2f015925,0x2f01b933)    R(0x0328,0x2ce259c4,0x2df2619f,0x2d8295c5)    R(0x0329,0x3082a1cc,0x327275a1,0x321271d8)\n    R(0x032a,0x2f8411df,0x3103d1e0,0x319445be)    R(0x032b,0x2d218de6,0x2e5165bd,0x2d41a9c7)    R(0x032c,0x2e5165bd,0x303131b8,0x2f712989)    R(0x032d,0x30c2899a,0x327275a1,0x3082a1cc)    R(0x032e,0x30c26566,0x30c2292a,0x32625139)    R(0x032f,0x2e62116c,0x2f01b933,0x2f820537)    R(0x0330,0x2ea155e2,0x303131b8,0x2e5165bd)    R(0x0331,0x2d41a9c7,0x2e416d8e,0x2d91bd9e)    R(0x0332,0x2d218de6,0x2ea155e2,0x2e5165bd)    R(0x0333,0x2d8295c5,0x2df2619f,0x2f02819b)\n    R(0x0334,0x2d41a9c7,0x2e5165bd,0x2e416d8e)    R(0x0335,0x2f33a9f1,0x3103d1e0,0x2f8411df)    R(0x0336,0x2f32cde7,0x3082a1cc,0x30d2a5f4)    R(0x0337,0x3082a1cc,0x321271d8,0x30d2a5f4)    R(0x0338,0x2ed2adc6,0x3082a1cc,0x2f32cde7)    R(0x0339,0x2ed2adc6,0x2f02819b,0x30c2899a)    R(0x033a,0x2d82cdde,0x2d8295c5,0x2ed2adc6)    R(0x033b,0x2ed2adc6,0x30c2899a,0x3082a1cc)    R(0x033c,0x2d8295c5,0x2f02819b,0x2ed2adc6)    R(0x033d,0x2d82cdde,0x2ed2adc6,0x2f32cde7)\n    R(0x033e,0x38516c08,0x3a315c02,0x3a61640b)    R(0x033f,0x36e0a94b,0x36507134,0x3550b56d)    R(0x0340,0x34c1d1c7,0x34f189c7,0x33a1bdf8)    R(0x0341,0x372445ef,0x385481c8,0x368425d5)    R(0x0342,0x2be301dc,0x2d82cdde,0x2e8311f6)    R(0x0343,0x3641e955,0x37f18525,0x3731895e)    R(0x0344,0x3550b56d,0x34e09557,0x33b0d18e)    R(0x0345,0x33b0d18e,0x32f0e96d,0x3221019d)    R(0x0346,0x3731895e,0x3861252f,0x37713d63)    R(0x0347,0x35a1e18e,0x36318d95,0x34c1d1c7)\n    R(0x0348,0x32e26967,0x3422351a,0x34e2313f)    R(0x0349,0x327275a1,0x34723d78,0x34022dad)    R(0x034a,0x33b0d18e,0x34e09557,0x32f0e96d)    R(0x034b,0x349135be,0x35a0f188,0x3410fdac)    R(0x034c,0x36318d95,0x37713d63,0x36114596)    R(0x034d,0x3820d131,0x36e0a94b,0x3700f965)    R(0x034e,0x36114596,0x35a0f188,0x349135be)    R(0x034f,0x37713d63,0x3700f965,0x36114596)    R(0x0350,0x3731895e,0x37713d63,0x36318d95)    R(0x0351,0x36114596,0x3700f965,0x35a0f188)\n    R(0x0352,0x37713d63,0x3820d131,0x3700f965)    R(0x0353,0x32e26967,0x34723d78,0x327275a1)    R(0x0354,0x32e26967,0x34e2313f,0x34723d78)    R(0x0355,0x34723d78,0x35a1e18e,0x34022dad)    R(0x0356,0x35a1e18e,0x3731895e,0x36318d95)    R(0x0357,0x3700f965,0x36e0a94b,0x35a0f188)    R(0x0358,0x34e2313f,0x3641e955,0x34723d78)    R(0x0359,0x34723d78,0x3641e955,0x35a1e18e)    R(0x035a,0x3410fdac,0x3550b56d,0x33b0d18e)    R(0x035b,0x3641e955,0x3731895e,0x35a1e18e)\n    R(0x035c,0x3410fdac,0x35a0f188,0x3550b56d)    R(0x035d,0x32f0e96d,0x3440bd44,0x3330f51c)    R(0x035e,0x3861252f,0x3820d131,0x37713d63)    R(0x035f,0x338181f0,0x349135be,0x32f141e3)    R(0x0360,0x2c728dd3,0x2d8295c5,0x2d82cdde)    R(0x0361,0x319445be,0x333409c6,0x33c4799e)    R(0x0362,0x32f141e3,0x3410fdac,0x323119cd)    R(0x0363,0x2cc205c7,0x2d41a9c7,0x2d91bd9e)    R(0x0364,0x323119cd,0x3410fdac,0x33b0d18e)    R(0x0365,0x34022dad,0x34c1d1c7,0x335229e1)\n    R(0x0366,0x34f189c7,0x349135be,0x338181f0)    R(0x0367,0x34c1d1c7,0x36318d95,0x34f189c7)    R(0x0368,0x32f141e3,0x349135be,0x3410fdac)    R(0x0369,0x34022dad,0x35a1e18e,0x34c1d1c7)    R(0x036a,0x34f189c7,0x36114596,0x349135be)    R(0x036b,0x2cc205c7,0x2d91bd9e,0x2d821da2)    R(0x036c,0x36318d95,0x36114596,0x34f189c7)    R(0x036d,0x2cc205c7,0x2d821da2,0x2ce259c4)    R(0x036e,0x3243a1f0,0x333409c6,0x3103d1e0)    R(0x036f,0x32f0e96d,0x3330f51c,0x31710549)\n    R(0x0370,0x323119cd,0x33b0d18e,0x3221019d)    R(0x0371,0x333409c6,0x358449b0,0x33c4799e)    R(0x0372,0x368425d5,0x358449b0,0x3483e1e0)    R(0x0373,0x3243a1f0,0x3483e1e0,0x333409c6)    R(0x0374,0x327275a1,0x34022dad,0x321271d8)    R(0x0375,0x3483e1e0,0x358449b0,0x333409c6)    R(0x0376,0x321271d8,0x34022dad,0x335229e1)    R(0x0377,0x2e6491f6,0x2eb451e5,0x2f94d5cf)    R(0x0378,0x2f950de3,0x30e599ce,0x300535f9)    R(0x0379,0x31f5f9a5,0x3316517d,0x3336998b)\n    R(0x037a,0x34e09557,0x3440bd44,0x32f0e96d)    R(0x037b,0x3a157158,0x3aa5e530,0x3885a93f)    R(0x037c,0x3dc62971,0x3ed66144,0x3d15e963)    R(0x037d,0x36655d57,0x3885a93f,0x3725fd36)    R(0x037e,0x3395e96b,0x35461d4a,0x34769155)    R(0x037f,0x35a0f188,0x36e0a94b,0x3550b56d)    R(0x0380,0x2eb451e5,0x304499c1,0x2f94d5cf)    R(0x0381,0x300535f9,0x30e599ce,0x31c5c9d9)    R(0x0382,0x367551f2,0x378591cb,0x38b57de6)    R(0x0383,0x319445be,0x33c4799e,0x3244c59d)\n    R(0x0384,0x304499c1,0x3244c59d,0x31251da7)    R(0x0385,0x35b4cd7e,0x3734b18c,0x37f52964)    R(0x0386,0x34d5915d,0x36655d57,0x3725fd36)    R(0x0387,0x3395e96b,0x34769155,0x3316517d)    R(0x0388,0x33c4799e,0x35b4cd7e,0x3425017a)    R(0x0389,0x31251da7,0x32d55581,0x3215b192)    R(0x038a,0x33c4799e,0x358449b0,0x35b4cd7e)    R(0x038b,0x3425017a,0x36655d57,0x34d5915d)    R(0x038c,0x35b4cd7e,0x37f52964,0x36655d57)    R(0x038d,0x31251da7,0x3244c59d,0x32d55581)\n    R(0x038e,0x3244c59d,0x3425017a,0x32d55581)    R(0x038f,0x35b4cd7e,0x36655d57,0x3425017a)    R(0x0390,0x32d55581,0x3425017a,0x34d5915d)    R(0x0391,0x37c481ad,0x3734b18c,0x358449b0)    R(0x0392,0x30c565b9,0x31251da7,0x3215b192)    R(0x0393,0x3215b192,0x3316517d,0x31f5f9a5)    R(0x0394,0x32d55581,0x34d5915d,0x3395e96b)    R(0x0395,0x358449b0,0x3734b18c,0x35b4cd7e)    R(0x0396,0x3625c1b5,0x36e63589,0x37c5e996)    R(0x0397,0x33c4799e,0x3425017a,0x3244c59d)\n    R(0x0398,0x30c565b9,0x3215b192,0x31f5f9a5)    R(0x0399,0x351635b9,0x36e63589,0x3625c1b5)    R(0x039a,0x3215b192,0x32d55581,0x3395e96b)    R(0x039b,0x3215b192,0x3395e96b,0x3316517d)    R(0x039c,0x2f8411df,0x319445be,0x304499c1)    R(0x039d,0x2f8411df,0x304499c1,0x2eb451e5)    R(0x039e,0x37f52964,0x3885a93f,0x36655d57)    R(0x039f,0x354565dd,0x378591cb,0x367551f2)    R(0x03a0,0x34d5915d,0x3725fd36,0x35461d4a)    R(0x03a1,0x33f609e5,0x34868dbc,0x351635b9)\n    R(0x03a2,0x2f950de3,0x30c565b9,0x30e599ce)    R(0x03a3,0x30e599ce,0x326635b2,0x31c5c9d9)    R(0x03a4,0x3395e96b,0x34d5915d,0x35461d4a)    R(0x03a5,0x385481c8,0x37c481ad,0x368425d5)    R(0x03a6,0x319445be,0x3244c59d,0x304499c1)    R(0x03a7,0x3485c5df,0x3625c1b5,0x354565dd)    R(0x03a8,0x354565dd,0x3625c1b5,0x378591cb)    R(0x03a9,0x3625c1b5,0x37c5e996,0x378591cb)    R(0x03aa,0x30c565b9,0x31f5f9a5,0x30e599ce)    R(0x03ab,0x2f94d5cf,0x304499c1,0x31251da7)\n    R(0x03ac,0x30e599ce,0x31f5f9a5,0x326635b2)    R(0x03ad,0x31c5c9d9,0x33565dbf,0x3335f1e5)    R(0x03ae,0x33f609e5,0x340671c5,0x34868dbc)    R(0x03af,0x3485c5df,0x351635b9,0x3625c1b5)    R(0x03b0,0x33565dbf,0x340671c5,0x3335f1e5)    R(0x03b1,0x3335f1e5,0x340671c5,0x33f609e5)    R(0x03b2,0x31c5c9d9,0x326635b2,0x33565dbf)    R(0x03b3,0x33f609e5,0x351635b9,0x3485c5df)    R(0x03b4,0x2f94d5cf,0x31251da7,0x30c565b9)    R(0x03b5,0x3bf5c54f,0x3aa5e530,0x3a157158)\n    R(0x03b6,0x3d15e963,0x3ed66144,0x3df63935)    R(0x03b7,0x38d65964,0x3b068d46,0x3a06217c)    R(0x03b8,0x3934d1d0,0x385481c8,0x372445ef)    R(0x03b9,0x2e6491f6,0x2f94d5cf,0x2f950de3)    R(0x03ba,0x392511e2,0x3934d1d0,0x37d499f8)    R(0x03bb,0x37c481ad,0x39450180,0x3734b18c)    R(0x03bc,0x37c5e996,0x3a06217c,0x3955d5af)    R(0x03bd,0x3c65fd9f,0x3df64976,0x3c65e19b)    R(0x03be,0x36e63589,0x38d65964,0x37c5e996)    R(0x03bf,0x3a06217c,0x3b068d46,0x3c46616b)\n    R(0x03c0,0x39450180,0x3a157158,0x37f52964)    R(0x03c1,0x3734b18c,0x39450180,0x37f52964)    R(0x03c2,0x3994dda1,0x39450180,0x37c481ad)    R(0x03c3,0x3955d5af,0x3a06217c,0x3bb6199a)    R(0x03c4,0x3d15e963,0x3bf5c54f,0x3b35617a)    R(0x03c5,0x3c65e19b,0x3dc62971,0x3c25a58c)    R(0x03c6,0x3b35617a,0x3a157158,0x39450180)    R(0x03c7,0x3c25a58c,0x3d15e963,0x3b35617a)    R(0x03c8,0x3c25a58c,0x3b35617a,0x3a9521a5)    R(0x03c9,0x3c25a58c,0x3dc62971,0x3d15e963)\n    R(0x03ca,0x37c5e996,0x38d65964,0x3a06217c)    R(0x03cb,0x3b35617a,0x39450180,0x3994dda1)    R(0x03cc,0x3a9521a5,0x3b35617a,0x3994dda1)    R(0x03cd,0x3a06217c,0x3c46616b,0x3bb6199a)    R(0x03ce,0x3c65e19b,0x3df64976,0x3dc62971)    R(0x03cf,0x3bb6199a,0x3c46616b,0x3d966175)    R(0x03d0,0x3c360d9f,0x3de65976,0x3c65fd9f)    R(0x03d1,0x3c360d9f,0x3d966175,0x3de65976)    R(0x03d2,0x3bb6199a,0x3d966175,0x3c360d9f)    R(0x03d3,0x3c65fd9f,0x3de65976,0x3df64976)\n    R(0x03d4,0x385481c8,0x3994dda1,0x37c481ad)    R(0x03d5,0x2f950de3,0x2f94d5cf,0x30c565b9)    R(0x03d6,0x38e551e9,0x3ab595c3,0x392511e2)    R(0x03d7,0x3d15e963,0x3df63935,0x3bf5c54f)    R(0x03d8,0x3934d1d0,0x3a9521a5,0x385481c8)    R(0x03d9,0x3ac555b7,0x3a9521a5,0x3934d1d0)    R(0x03da,0x37f52964,0x3a157158,0x3885a93f)    R(0x03db,0x378591cb,0x3a55c9c3,0x38b57de6)    R(0x03dc,0x38b57de6,0x3a85b9c6,0x38e551e9)    R(0x03dd,0x3a9521a5,0x3994dda1,0x385481c8)\n    R(0x03de,0x3ab595c3,0x3c65e19b,0x3ac555b7)    R(0x03df,0x392511e2,0x3ab595c3,0x3ac555b7)    R(0x03e0,0x3b35617a,0x3bf5c54f,0x3a157158)    R(0x03e1,0x3ac555b7,0x3c25a58c,0x3a9521a5)    R(0x03e2,0x38e551e9,0x3a85b9c6,0x3ab595c3)    R(0x03e3,0x3ac555b7,0x3c65e19b,0x3c25a58c)    R(0x03e4,0x378591cb,0x37c5e996,0x3955d5af)    R(0x03e5,0x392511e2,0x3ac555b7,0x3934d1d0)    R(0x03e6,0x38b57de6,0x3a55c9c3,0x3a85b9c6)    R(0x03e7,0x3955d5af,0x3bb6199a,0x3a55c9c3)\n    R(0x03e8,0x3a85b9c6,0x3c65fd9f,0x3ab595c3)    R(0x03e9,0x3a55c9c3,0x3c360d9f,0x3a85b9c6)    R(0x03ea,0x378591cb,0x3955d5af,0x3a55c9c3)    R(0x03eb,0x3a55c9c3,0x3bb6199a,0x3c360d9f)    R(0x03ec,0x3a85b9c6,0x3c360d9f,0x3c65fd9f)    R(0x03ed,0x3ab595c3,0x3c65fd9f,0x3c65e19b)    R(0x03ee,0x00e6acd7,0x00c5fcc9,0x00e698be)    R(0x03ef,0x0c3fddc5,0x0adfe99b,0x0d1ffd9f)    R(0x03f0,0x1478843e,0x1327d03e,0x15a7d43d)    R(0x03f1,0x196e5209,0x189e69ce,0x1b1e45da)\n    R(0x03f2,0x3a700cb2,0x3ad00099,0x392010ca)    R(0x03f3,0x3fe6e8f5,0x3f470ccd,0x3ff6e0f3)    R(0x03f4,0x11d87840,0x1097c046,0x1327d03e)    R(0x03f5,0x13cb2063,0x106b1c5d,0x125a9c56)    R(0x03f6,0x05569ca8,0x02c684a3,0x03b608a8)    R(0x03f7,0x00e6acd7,0x00e698be,0x01173cbd)    R(0x03f8,0x0adfe99b,0x0c6ff573,0x0d1ffd9f)    R(0x03f9,0x02a92e03,0x02b8c9cd,0x028969cd)    R(0x03fa,0x0146dcad,0x010620b0,0x018660a6)    R(0x03fb,0x01d670fd,0x00e6acd7,0x01e710f4)\n    R(0x03fc,0x1327d03e,0x1097c046,0x11f70c44)    R(0x03fd,0x018a891a,0x01ba2ce8,0x019a98e1)    R(0x03fe,0x124ba870,0x106b1c5d,0x13cb2063)    R(0x03ff,0x0bbeb4e1,0x0c7f4100,0x0aaef4f3)    R(0x0400,0x01e710f4,0x00e6acd7,0x011768d3)    R(0x0401,0x0328b117,0x025868ef,0x028918ed)    R(0x0402,0x10c67c4f,0x0e06a059,0x0f562869)    R(0x0403,0x1059ac47,0x10790c44,0x1329343f)    R(0x0404,0x125a9c56,0x101a604c,0x12c9ec4b)    R(0x0405,0x11f70c44,0x10c67c4f,0x13a6744e)\n    R(0x0406,0x065a1c76,0x03d9c88b,0x06296c7c)    R(0x0407,0x05e71c9b,0x05569ca8,0x07269ca4)    R(0x0408,0x01e72ca6,0x018660a6,0x02c684a3)    R(0x0409,0x0127e8ba,0x01173cbd,0x015794ac)    R(0x040a,0x01ba2ce8,0x018a04bc,0x019a98e1)    R(0x040b,0x02a9f90f,0x0299acf1,0x01ba2ce8)    R(0x040c,0x03e710a2,0x02c684a3,0x05569ca8)    R(0x040d,0x01c9d49f,0x016954b3,0x01990ca1)    R(0x040e,0x042a7088,0x03d9c88b,0x065a1c76)    R(0x040f,0x029a7c9a,0x01c9d49f,0x026a0490)\n    R(0x0410,0x03e7aca0,0x01e72ca6,0x03e710a2)    R(0x0411,0x0597f88f,0x03e7aca0,0x05e71c9b)    R(0x0412,0x01990ca1,0x017850a8,0x0218b09a)    R(0x0413,0x02296093,0x01990ca1,0x0218b09a)    R(0x0414,0x0207f4a3,0x01e72ca6,0x03e7aca0)    R(0x0415,0x03d91891,0x03d86498,0x05c8bc86)    R(0x0416,0x0218b09a,0x0207f4a3,0x03d86498)    R(0x0417,0x03d86498,0x0207f4a3,0x03e7aca0)    R(0x0418,0x03d91891,0x0218b09a,0x03d86498)    R(0x0419,0x03d86498,0x03e7aca0,0x0597f88f)\n    R(0x041a,0x0218b09a,0x017850a8,0x0207f4a3)    R(0x041b,0x01c9d49f,0x01990ca1,0x02296093)    R(0x041c,0x01ca78b1,0x01c9d49f,0x029a7c9a)    R(0x041d,0x01e72ca6,0x02c684a3,0x03e710a2)    R(0x041e,0x06296c7c,0x03d91891,0x05c8bc86)    R(0x041f,0x026a0490,0x02296093,0x03d9c88b)    R(0x0420,0x026a0490,0x01c9d49f,0x02296093)    R(0x0421,0x03d9c88b,0x02296093,0x03d91891)    R(0x0422,0x03e7aca0,0x03e710a2,0x05e71c9b)    R(0x0423,0x05e71c9b,0x03e710a2,0x05569ca8)\n    R(0x0424,0x02296093,0x0218b09a,0x03d91891)    R(0x0425,0x01e72ca6,0x0146dcad,0x018660a6)    R(0x0426,0x0227b8f2,0x01e710f4,0x011768d3)    R(0x0427,0x03d9c88b,0x03d91891,0x06296c7c)    R(0x0428,0x01ca78b1,0x018a04bc,0x01c9d49f)    R(0x0429,0x0227b8f2,0x011768d3,0x013820d1)    R(0x042a,0x013820d1,0x011768d3,0x0127e8ba)    R(0x042b,0x017850a8,0x0127e8ba,0x015794ac)    R(0x042c,0x0158d8cd,0x01489cb8,0x016954b3)    R(0x042d,0x025868ef,0x0227b8f2,0x013820d1)\n    R(0x042e,0x05c8bc86,0x03d86498,0x0597f88f)    R(0x042f,0x017850a8,0x015794ac,0x0207f4a3)    R(0x0430,0x025868ef,0x013820d1,0x0158d8cd)    R(0x0431,0x016954b3,0x01489cb8,0x01990ca1)    R(0x0432,0x028918ed,0x025868ef,0x0158d8cd)    R(0x0433,0x01990ca1,0x01489cb8,0x017850a8)    R(0x0434,0x015794ac,0x0146dcad,0x01e72ca6)    R(0x0435,0x01ba2ce8,0x0299acf1,0x01898cce)    R(0x0436,0x042a7088,0x026a0490,0x03d9c88b)    R(0x0437,0x018a04bc,0x016954b3,0x01c9d49f)\n    R(0x0438,0x01ba2ce8,0x01898cce,0x018a04bc)    R(0x0439,0x0207f4a3,0x015794ac,0x01e72ca6)    R(0x043a,0x028918ed,0x0158d8cd,0x01898cce)    R(0x043b,0x01898cce,0x016954b3,0x018a04bc)    R(0x043c,0x0299acf1,0x028918ed,0x01898cce)    R(0x043d,0x01898cce,0x0158d8cd,0x016954b3)    R(0x043e,0x1329343f,0x10790c44,0x11d87840)    R(0x043f,0x0b3a6455,0x0b09c455,0x0db9fc50)    R(0x0440,0x09a68091,0x07269ca4,0x08663cb9)    R(0x0441,0x015794ac,0x01173cbd,0x0146dcad)\n    R(0x0442,0x013820d1,0x0127e8ba,0x01489cb8)    R(0x0443,0x0ef87849,0x0de7c84d,0x1097c046)    R(0x0444,0x0f47144a,0x0e06a059,0x10c67c4f)    R(0x0445,0x0ca72c54,0x0b36c46b,0x0e06a059)    R(0x0446,0x0a892058,0x07d8fc66,0x09a87c5f)    R(0x0447,0x12c9ec4b,0x1059ac47,0x1329343f)    R(0x0448,0x08ea6461,0x0889b45f,0x0b09c455)    R(0x0449,0x0b77e057,0x0a074c65,0x0ca72c54)    R(0x044a,0x09a87c5f,0x08f7d865,0x0b77e057)    R(0x044b,0x0d993c4d,0x0c688c4d,0x0ef87849)\n    R(0x044c,0x11f70c44,0x0f47144a,0x10c67c4f)    R(0x044d,0x0c688c4d,0x0b77e057,0x0de7c84d)    R(0x044e,0x0b77e057,0x0ca72c54,0x0de7c84d)    R(0x044f,0x0a892058,0x09a87c5f,0x0c688c4d)    R(0x0450,0x0c688c4d,0x0de7c84d,0x0ef87849)    R(0x0451,0x1097c046,0x0de7c84d,0x0f47144a)    R(0x0452,0x0c688c4d,0x09a87c5f,0x0b77e057)    R(0x0453,0x0b09c455,0x0889b45f,0x0a892058)    R(0x0454,0x08ea6461,0x0b09c455,0x0b3a6455)    R(0x0455,0x0f47144a,0x0ca72c54,0x0e06a059)\n    R(0x0456,0x1059ac47,0x0db9fc50,0x0d993c4d)    R(0x0457,0x12c9ec4b,0x101a604c,0x1059ac47)    R(0x0458,0x0de7c84d,0x0ca72c54,0x0f47144a)    R(0x0459,0x0d993c4d,0x0b09c455,0x0a892058)    R(0x045a,0x0d993c4d,0x0a892058,0x0c688c4d)    R(0x045b,0x101a604c,0x0db9fc50,0x1059ac47)    R(0x045c,0x0db9fc50,0x0b09c455,0x0d993c4d)    R(0x045d,0x0866f881,0x07269ca4,0x09a68091)    R(0x045e,0x1097c046,0x0f47144a,0x11f70c44)    R(0x045f,0x01489cb8,0x0127e8ba,0x017850a8)\n    R(0x0460,0x0158d8cd,0x013820d1,0x01489cb8)    R(0x0461,0x08ea6461,0x065a1c76,0x0889b45f)    R(0x0462,0x0727887e,0x05e71c9b,0x0866f881)    R(0x0463,0x05c8bc86,0x0597f88f,0x0738506f)    R(0x0464,0x0866f881,0x05e71c9b,0x07269ca4)    R(0x0465,0x0866f881,0x09a68091,0x0b36c46b)    R(0x0466,0x0b77e057,0x08f7d865,0x0a074c65)    R(0x0467,0x0738506f,0x0727887e,0x08f7d865)    R(0x0468,0x0a074c65,0x0727887e,0x0866f881)    R(0x0469,0x09a87c5f,0x0738506f,0x08f7d865)\n    R(0x046a,0x08f7d865,0x0727887e,0x0a074c65)    R(0x046b,0x0738506f,0x0597f88f,0x0727887e)    R(0x046c,0x0597f88f,0x05e71c9b,0x0727887e)    R(0x046d,0x06296c7c,0x05c8bc86,0x07d8fc66)    R(0x046e,0x065a1c76,0x06296c7c,0x0889b45f)    R(0x046f,0x0a074c65,0x0866f881,0x0b36c46b)    R(0x0470,0x0d993c4d,0x0ef87849,0x10790c44)    R(0x0471,0x07d8fc66,0x0738506f,0x09a87c5f)    R(0x0472,0x0889b45f,0x07d8fc66,0x0a892058)    R(0x0473,0x07d8fc66,0x05c8bc86,0x0738506f)\n    R(0x0474,0x0a074c65,0x0b36c46b,0x0ca72c54)    R(0x0475,0x0889b45f,0x06296c7c,0x07d8fc66)    R(0x0476,0x1059ac47,0x0d993c4d,0x10790c44)    R(0x0477,0x019a98e1,0x018a04bc,0x01ca78b1)    R(0x0478,0x07269ca4,0x05569ca8,0x06b650bb)    R(0x0479,0x0aaef4f3,0x08ff2111,0x08eea8f1)    R(0x047a,0x0d7efcf4,0x0c7f4100,0x0bbeb4e1)    R(0x047b,0x0dcab456,0x0db9fc50,0x101a604c)    R(0x047c,0x132ddd0a,0x108db901,0x126d64d9)    R(0x047d,0x0b0af45b,0x08ea6461,0x0b3a6455)\n    R(0x047e,0x029a7c9a,0x026a0490,0x042a7088)    R(0x047f,0x019a98e1,0x01ca78b1,0x01faf0da)    R(0x0480,0x0aaef4f3,0x08eea8f1,0x09ce54dc)    R(0x0481,0x01ab0510,0x019a98e1,0x01faf0da)    R(0x0482,0x08db9080,0x08db006b,0x0b0b7473)    R(0x0483,0x067ab87e,0x042a7088,0x065a1c76)    R(0x0484,0x08db006b,0x08ea6461,0x0b0af45b)    R(0x0485,0x03bb34cc,0x01faf0da,0x02bad8b1)    R(0x0486,0x050ba8e8,0x03bb34cc,0x05fb7cb5)    R(0x0487,0x09cdccd6,0x09ce54dc,0x081dc0dd)\n    R(0x0488,0x070b408e,0x04aaf498,0x067ab87e)    R(0x0489,0x02bad8b1,0x029a7c9a,0x04aaf498)    R(0x048a,0x03bb34cc,0x02bad8b1,0x04aaf498)    R(0x048b,0x04aaf498,0x042a7088,0x067ab87e)    R(0x048c,0x07dbdca2,0x05fb7cb5,0x070b408e)    R(0x048d,0x0b0b7473,0x08db006b,0x0b0af45b)    R(0x048e,0x05fb7cb5,0x03bb34cc,0x04aaf498)    R(0x048f,0x070b408e,0x067ab87e,0x08db006b)    R(0x0490,0x08db9080,0x070b408e,0x08db006b)    R(0x0491,0x05fb7cb5,0x04aaf498,0x070b408e)\n    R(0x0492,0x04aaf498,0x029a7c9a,0x042a7088)    R(0x0493,0x072c1cd3,0x050ba8e8,0x05fb7cb5)    R(0x0494,0x0afcccce,0x086c90e3,0x095c54bd)    R(0x0495,0x0a4bf895,0x08db9080,0x0b0b7473)    R(0x0496,0x095c54bd,0x072c1cd3,0x07dbdca2)    R(0x0497,0x086c90e3,0x072c1cd3,0x095c54bd)    R(0x0498,0x0a4bf895,0x07dbdca2,0x08db9080)    R(0x0499,0x095c54bd,0x07dbdca2,0x0a4bf895)    R(0x049a,0x072c1cd3,0x05fb7cb5,0x07dbdca2)    R(0x049b,0x07dbdca2,0x070b408e,0x08db9080)\n    R(0x049c,0x067ab87e,0x065a1c76,0x08ea6461)    R(0x049d,0x02bb58fe,0x01faf0da,0x03bb34cc)    R(0x049e,0x0a3cfce5,0x086c90e3,0x0afcccce)    R(0x049f,0x08eea8f1,0x073ead0f,0x078e30ed)    R(0x04a0,0x03abd10d,0x02bb58fe,0x050ba8e8)    R(0x04a1,0x05ec20f4,0x03abd10d,0x050ba8e8)    R(0x04a2,0x067c9cf1,0x043c650b,0x05ec20f4)    R(0x04a3,0x069d3ceb,0x04cd0d03,0x067c9cf1)    R(0x04a4,0x08db006b,0x067ab87e,0x08ea6461)    R(0x04a5,0x0a3cfce5,0x086d04e4,0x086c90e3)\n    R(0x04a6,0x086c90e3,0x05ec20f4,0x072c1cd3)    R(0x04a7,0x086d04e4,0x069d3ceb,0x067c9cf1)    R(0x04a8,0x086d04e4,0x067c9cf1,0x086c90e3)    R(0x04a9,0x05ec20f4,0x050ba8e8,0x072c1cd3)    R(0x04aa,0x086c90e3,0x067c9cf1,0x05ec20f4)    R(0x04ab,0x050ba8e8,0x02bb58fe,0x03bb34cc)    R(0x04ac,0x060dacf9,0x04cd0d03,0x069d3ceb)    R(0x04ad,0x09ce54dc,0x08eea8f1,0x078e30ed)    R(0x04ae,0x0a2d44e2,0x086d04e4,0x0a3cfce5)    R(0x04af,0x081dc0dd,0x069d3ceb,0x086d04e4)\n    R(0x04b0,0x09ce54dc,0x078e30ed,0x081dc0dd)    R(0x04b1,0x081dc0dd,0x060dacf9,0x069d3ceb)    R(0x04b2,0x09cdccd6,0x081dc0dd,0x086d04e4)    R(0x04b3,0x09cdccd6,0x086d04e4,0x0a2d44e2)    R(0x04b4,0x081dc0dd,0x078e30ed,0x060dacf9)    R(0x04b5,0x106b1c5d,0x101a604c,0x125a9c56)    R(0x04b6,0x0e06a059,0x0b36c46b,0x0c86547b)    R(0x04b7,0x106cf4b4,0x118c5493,0x12dcd8b5)    R(0x04b8,0x0f4f0505,0x0d7efcf4,0x0d7e98e9)    R(0x04b9,0x01ab0510,0x01faf0da,0x02bb58fe)\n    R(0x04ba,0x0dab4c69,0x0dcab456,0x106b1c5d)    R(0x04bb,0x0b36c46b,0x09a68091,0x0c86547b)    R(0x04bc,0x02bad8b1,0x01ca78b1,0x029a7c9a)    R(0x04bd,0x106b1c5d,0x0dcab456,0x101a604c)    R(0x04be,0x01faf0da,0x01ca78b1,0x02bad8b1)    R(0x04bf,0x126d64d9,0x106cf4b4,0x12dcd8b5)    R(0x04c0,0x0b0b7473,0x0b0af45b,0x0dab4c69)    R(0x04c1,0x0a4bf895,0x0b0b7473,0x0cfbec85)    R(0x04c2,0x0c2c6ca5,0x0a4bf895,0x0cfbec85)    R(0x04c3,0x0fbbc87b,0x0dab4c69,0x106b1c5d)\n    R(0x04c4,0x0fbbc87b,0x106b1c5d,0x124ba870)    R(0x04c5,0x0edc6c98,0x0cfbec85,0x0fbbc87b)    R(0x04c6,0x0cfbec85,0x0b0b7473,0x0dab4c69)    R(0x04c7,0x0edc6c98,0x0fbbc87b,0x118c5493)    R(0x04c8,0x0cfbec85,0x0dab4c69,0x0fbbc87b)    R(0x04c9,0x118c5493,0x0fbbc87b,0x124ba870)    R(0x04ca,0x0c2c6ca5,0x095c54bd,0x0a4bf895)    R(0x04cb,0x0dcab456,0x0b3a6455,0x0db9fc50)    R(0x04cc,0x0f4d5cda,0x0dbce8bb,0x106cf4b4)    R(0x04cd,0x0f4d5cda,0x106cf4b4,0x126d64d9)\n    R(0x04ce,0x0c2c6ca5,0x0cfbec85,0x0edc6c98)    R(0x04cf,0x0dbce8bb,0x0c2c6ca5,0x0edc6c98)    R(0x04d0,0x0dbce8bb,0x0edc6c98,0x106cf4b4)    R(0x04d1,0x0dbce8bb,0x0afcccce,0x0c2c6ca5)    R(0x04d2,0x106cf4b4,0x0edc6c98,0x118c5493)    R(0x04d3,0x0afcccce,0x095c54bd,0x0c2c6ca5)    R(0x04d4,0x0b0af45b,0x0b3a6455,0x0dcab456)    R(0x04d5,0x108db901,0x0f4d5cda,0x126d64d9)    R(0x04d6,0x0bbdb0e6,0x09cdccd6,0x0a2d44e2)    R(0x04d7,0x0f6e8907,0x0d7e98e9,0x0d8e14f3)\n    R(0x04d8,0x0f6e8907,0x0f4f0505,0x0d7e98e9)    R(0x04d9,0x0c1d5cef,0x0a3cfce5,0x0c8d38e2)    R(0x04da,0x0c1d5cef,0x0a2d44e2,0x0a3cfce5)    R(0x04db,0x0dab4c69,0x0b0af45b,0x0dcab456)    R(0x04dc,0x0dcdb900,0x0d8e14f3,0x0bbdb0e6)    R(0x04dd,0x108db901,0x0e1d98fb,0x0f4d5cda)    R(0x04de,0x0bbdb0e6,0x0a2d44e2,0x0c1d5cef)    R(0x04df,0x0e1d98fb,0x0c1d5cef,0x0c8d38e2)    R(0x04e0,0x0c8d38e2,0x0afcccce,0x0dbce8bb)    R(0x04e1,0x0dcdb900,0x0c1d5cef,0x0e1d98fb)\n    R(0x04e2,0x0e1d98fb,0x0c8d38e2,0x0f4d5cda)    R(0x04e3,0x0dcdb900,0x0bbdb0e6,0x0c1d5cef)    R(0x04e4,0x0b9e40d9,0x09ce54dc,0x09cdccd6)    R(0x04e5,0x0c8d38e2,0x0a3cfce5,0x0afcccce)    R(0x04e6,0x0d7e98e9,0x0d7efcf4,0x0bbeb4e1)    R(0x04e7,0x0f4d5cda,0x0c8d38e2,0x0dbce8bb)    R(0x04e8,0x0bbeb4e1,0x0aaef4f3,0x09ce54dc)    R(0x04e9,0x0d7e98e9,0x0bbeb4e1,0x0b9e40d9)    R(0x04ea,0x0d8e14f3,0x0b9e40d9,0x0bbdb0e6)    R(0x04eb,0x0d8e14f3,0x0d7e98e9,0x0b9e40d9)\n    R(0x04ec,0x0bbdb0e6,0x0b9e40d9,0x09cdccd6)    R(0x04ed,0x0b9e40d9,0x0bbeb4e1,0x09ce54dc)    R(0x04ee,0x0266c9bc,0x01c625c0,0x02865188)    R(0x04ef,0x11d87840,0x0ef87849,0x1097c046)    R(0x04f0,0x0209d1fb,0x028969cd,0x0149f9c7)    R(0x04f1,0x012a65f4,0x0149f9c7,0x015a95bf)    R(0x04f2,0x137e353f,0x11fe5950,0x118e1929)    R(0x04f3,0x0eafe5b4,0x0d1ffd9f,0x0eaff982)    R(0x04f4,0x016b0df1,0x012a65f4,0x015a95bf)    R(0x04f5,0x0176a5ef,0x01c625c0,0x0266c9bc)\n    R(0x04f6,0x039d99fa,0x025d15dc,0x035dc5ca)    R(0x04f7,0x035dc5ca,0x03be0993,0x048e65bc)    R(0x04f8,0x10790c44,0x0ef87849,0x11d87840)    R(0x04f9,0x118e1929,0x108db901,0x132ddd0a)    R(0x04fa,0x018a891a,0x019a98e1,0x01ab0510)    R(0x04fb,0x022c8d4f,0x02ac252c,0x034cd524)    R(0x04fc,0x020cf977,0x02fd3d45,0x031da16c)    R(0x04fd,0x02865188,0x02b6b950,0x02971584)    R(0x04fe,0x014a3192,0x0219a19a,0x01d9e56b)    R(0x04ff,0x016b0df1,0x015a95bf,0x01db51b5)\n    R(0x0500,0x02c67126,0x01d670fd,0x02d72d1b)    R(0x0501,0x0219a19a,0x02e9258f,0x03197d52)    R(0x0502,0x015a7156,0x01d9e56b,0x023a0537)    R(0x0503,0x018a891a,0x02a9f90f,0x01ba2ce8)    R(0x0504,0x027d61a2,0x020cf977,0x031da16c)    R(0x0505,0x0219a19a,0x03197d52,0x01d9e56b)    R(0x0506,0x01cad182,0x015a7156,0x018b194a)    R(0x0507,0x01cad182,0x018b194a,0x01fb8d7a)    R(0x0508,0x02d72d1b,0x01e710f4,0x0227b8f2)    R(0x0509,0x01d9e56b,0x03197d52,0x023a0537)\n    R(0x050a,0x0307f118,0x0227b8f2,0x025868ef)    R(0x050b,0x023a0537,0x02a9f90f,0x018a891a)    R(0x050c,0x015a7156,0x023a0537,0x018a891a)    R(0x050d,0x018b194a,0x01ab0510,0x020b8929)    R(0x050e,0x018b194a,0x018a891a,0x01ab0510)    R(0x050f,0x01fb8d7a,0x018b194a,0x01bbd94f)    R(0x0510,0x01ac497d,0x01fb8d7a,0x01bbd94f)    R(0x0511,0x02d72d1b,0x01d670fd,0x01e710f4)    R(0x0512,0x020cf977,0x022c8d4f,0x02fd3d45)    R(0x0513,0x01ac497d,0x022c8d4f,0x020cf977)\n    R(0x0514,0x020b8929,0x01ab0510,0x02bb58fe)    R(0x0515,0x01bbd94f,0x020b8929,0x02ac252c)    R(0x0516,0x01bbd94f,0x02ac252c,0x022c8d4f)    R(0x0517,0x01bbd94f,0x018b194a,0x020b8929)    R(0x0518,0x01ac497d,0x01bbd94f,0x022c8d4f)    R(0x0519,0x02574def,0x0176a5ef,0x0266c9bc)    R(0x051a,0x0307f118,0x02d72d1b,0x0227b8f2)    R(0x051b,0x0149f9c7,0x028969cd,0x0219a19a)    R(0x051c,0x01abc5ec,0x016b0df1,0x01db51b5)    R(0x051d,0x01ccb9ae,0x020cf977,0x027d61a2)\n    R(0x051e,0x0266c9bc,0x02971584,0x028779b7)    R(0x051f,0x015a95bf,0x0149f9c7,0x014a3192)    R(0x0520,0x01db51b5,0x01cad182,0x01fb8d7a)    R(0x0521,0x02574def,0x0266c9bc,0x028779b7)    R(0x0522,0x028969cd,0x02e9258f,0x0219a19a)    R(0x0523,0x01db51b5,0x015a95bf,0x01cad182)    R(0x0524,0x0149f9c7,0x0219a19a,0x014a3192)    R(0x0525,0x029811d5,0x028779b7,0x02b7d985)    R(0x0526,0x028779b7,0x02971584,0x02b7d985)    R(0x0527,0x02b8c9cd,0x029811d5,0x02d87d91)\n    R(0x0528,0x01abc5ec,0x020c05b1,0x01bc65e3)    R(0x0529,0x01ccb9ae,0x01ac497d,0x020cf977)    R(0x052a,0x025d15dc,0x01ccb9ae,0x027d61a2)    R(0x052b,0x02574def,0x028779b7,0x029811d5)    R(0x052c,0x01bc65e3,0x020c05b1,0x01ccb9ae)    R(0x052d,0x020c05b1,0x01fb8d7a,0x01ac497d)    R(0x052e,0x01db51b5,0x01fb8d7a,0x020c05b1)    R(0x052f,0x025d15dc,0x01bc65e3,0x01ccb9ae)    R(0x0530,0x01ccb9ae,0x020c05b1,0x01ac497d)    R(0x0531,0x01abc5ec,0x01db51b5,0x020c05b1)\n    R(0x0532,0x03495d1b,0x028918ed,0x0299acf1)    R(0x0533,0x118e1929,0x0faded17,0x108db901)    R(0x0534,0x02d77d4a,0x02b6b950,0x02d72d1b)    R(0x0535,0x014a3192,0x01d9e56b,0x015a7156)    R(0x0536,0x035dc5ca,0x048e65bc,0x04be41eb)    R(0x0537,0x039d99fa,0x035dc5ca,0x04be41eb)    R(0x0538,0x02d77d4a,0x02d72d1b,0x0307f118)    R(0x0539,0x03495d1b,0x0328b117,0x028918ed)    R(0x053a,0x03197d52,0x03495d1b,0x023a0537)    R(0x053b,0x020b8929,0x02bb58fe,0x03abd10d)\n    R(0x053c,0x10fe3d31,0x0f7e1117,0x0faded17)    R(0x053d,0x118e1929,0x10fe3d31,0x0faded17)    R(0x053e,0x02ac252c,0x020b8929,0x03abd10d)    R(0x053f,0x0328b117,0x0307f118,0x025868ef)    R(0x0540,0x02f83d4c,0x0307f118,0x0328b117)    R(0x0541,0x04cd0d03,0x034cd524,0x043c650b)    R(0x0542,0x043d7d1a,0x034cd524,0x04cd0d03)    R(0x0543,0x034cd524,0x02ac252c,0x043c650b)    R(0x0544,0x043c650b,0x02ac252c,0x03abd10d)    R(0x0545,0x023a0537,0x03495d1b,0x02a9f90f)\n    R(0x0546,0x03495d1b,0x0299acf1,0x02a9f90f)    R(0x0547,0x02f83d4c,0x02d77d4a,0x0307f118)    R(0x0548,0x0318e951,0x0328b117,0x03495d1b)    R(0x0549,0x078e30ed,0x05be2114,0x060dacf9)    R(0x054a,0x0faded17,0x0e1d98fb,0x108db901)    R(0x054b,0x043d7d1a,0x05be2114,0x042de93d)    R(0x054c,0x060dacf9,0x043d7d1a,0x04cd0d03)    R(0x054d,0x060dacf9,0x05be2114,0x043d7d1a)    R(0x054e,0x02fd3d45,0x034cd524,0x043d7d1a)    R(0x054f,0x0faded17,0x0f7e1117,0x0dcdb900)\n    R(0x0550,0x02fd3d45,0x043d7d1a,0x042de93d)    R(0x0551,0x02971584,0x02b6b950,0x02d77d4a)    R(0x0552,0x01cad182,0x014a3192,0x015a7156)    R(0x0553,0x067c9cf1,0x04cd0d03,0x043c650b)    R(0x0554,0x025d15dc,0x027d61a2,0x035dc5ca)    R(0x0555,0x0faded17,0x0dcdb900,0x0e1d98fb)    R(0x0556,0x031da16c,0x042de93d,0x049e5965)    R(0x0557,0x015a95bf,0x014a3192,0x01cad182)    R(0x0558,0x028969cd,0x02b8c9cd,0x02e9258f)    R(0x0559,0x02b7d985,0x02971584,0x02d77d4a)\n    R(0x055a,0x05ec20f4,0x043c650b,0x03abd10d)    R(0x055b,0x02b8c9cd,0x02d87d91,0x02e9258f)    R(0x055c,0x02e9258f,0x02d87d91,0x0318e951)    R(0x055d,0x02e9258f,0x0318e951,0x03197d52)    R(0x055e,0x0318e951,0x02f83d4c,0x0328b117)    R(0x055f,0x03197d52,0x0318e951,0x03495d1b)    R(0x0560,0x015a7156,0x018a891a,0x018b194a)    R(0x0561,0x029811d5,0x02b7d985,0x02d87d91)    R(0x0562,0x022c8d4f,0x034cd524,0x02fd3d45)    R(0x0563,0x02b7d985,0x02d77d4a,0x02f83d4c)\n    R(0x0564,0x03be0993,0x031da16c,0x049e5965)    R(0x0565,0x0f7e1117,0x0d8e14f3,0x0dcdb900)    R(0x0566,0x027d61a2,0x031da16c,0x03be0993)    R(0x0567,0x035dc5ca,0x027d61a2,0x03be0993)    R(0x0568,0x031da16c,0x02fd3d45,0x042de93d)    R(0x0569,0x02d87d91,0x02b7d985,0x02f83d4c)    R(0x056a,0x02d87d91,0x02f83d4c,0x0318e951)    R(0x056b,0x0266c9bc,0x02865188,0x02971584)    R(0x056c,0x078e30ed,0x073ead0f,0x05be2114)    R(0x056d,0x0eaff982,0x0c6ff573,0x0e0fe552)\n    R(0x056e,0x0e1f59f7,0x0d4fb9e0,0x0eefadd8)    R(0x056f,0x131e6570,0x120e857a,0x11fe5950)    R(0x0570,0x04be41eb,0x048e65bc,0x05fee5ca)    R(0x0571,0x08eea8f1,0x08ff2111,0x073ead0f)    R(0x0572,0x02b6b950,0x02c67126,0x02d72d1b)    R(0x0573,0x0eaff982,0x0e0fe552,0x0fdfd961)    R(0x0574,0x0eafe5b4,0x0eaff982,0x103fd58d)    R(0x0575,0x0e1f59f7,0x0eefadd8,0x0fff69d5)    R(0x0576,0x0b0f6d19,0x08ff2111,0x0aaef4f3)    R(0x0577,0x042de93d,0x05be2114,0x05be9138)\n    R(0x0578,0x054ebd93,0x049e5965,0x063ef965)    R(0x0579,0x0c7f4100,0x0b0f6d19,0x0aaef4f3)    R(0x057a,0x0fdfd961,0x0e0fe552,0x0f2fa934)    R(0x057b,0x0a0fc56c,0x0bbfc544,0x0c6ff573)    R(0x057c,0x063ef965,0x05be9138,0x077f1937)    R(0x057d,0x049e5965,0x05be9138,0x063ef965)    R(0x057e,0x063ef965,0x077f1937,0x07ef7568)    R(0x057f,0x0d3fa524,0x0b0f6d19,0x0c7f4100)    R(0x0580,0x0f4f0505,0x0eaf6110,0x0d7efcf4)    R(0x0581,0x077f1937,0x08ff2111,0x095f813c)\n    R(0x0582,0x095f813c,0x08ff2111,0x0b0f6d19)    R(0x0583,0x073ead0f,0x08ff2111,0x077f1937)    R(0x0584,0x0eaf6110,0x0d3fa524,0x0c7f4100)    R(0x0585,0x07ef7568,0x077f1937,0x095f813c)    R(0x0586,0x05be2114,0x073ead0f,0x05be9138)    R(0x0587,0x0c6ff573,0x0bbfc544,0x0e0fe552)    R(0x0588,0x0e0fe552,0x0d3fa524,0x0f2fa934)    R(0x0589,0x0a0fc56c,0x095f813c,0x0bbfc544)    R(0x058a,0x095f813c,0x0b0f6d19,0x0bbfc544)    R(0x058b,0x0bbfc544,0x0b0f6d19,0x0d3fa524)\n    R(0x058c,0x05be9138,0x073ead0f,0x077f1937)    R(0x058d,0x0e0fe552,0x0bbfc544,0x0d3fa524)    R(0x058e,0x07ef7568,0x095f813c,0x0a0fc56c)    R(0x058f,0x0f2fa934,0x0d3fa524,0x0eaf6110)    R(0x0590,0x0f7e1117,0x0f6e8907,0x0d8e14f3)    R(0x0591,0x03be0993,0x049e5965,0x054ebd93)    R(0x0592,0x093f61ef,0x074f15eb,0x07ef6dc1)    R(0x0593,0x0adfe99b,0x0a0fc56c,0x0c6ff573)    R(0x0594,0x05fee5ca,0x054ebd93,0x06df4198)    R(0x0595,0x054ebd93,0x063ef965,0x06df4198)\n    R(0x0596,0x048e65bc,0x03be0993,0x054ebd93)    R(0x0597,0x093f61ef,0x07ef6dc1,0x09efb9c4)    R(0x0598,0x0eaf6110,0x0c7f4100,0x0d7efcf4)    R(0x0599,0x074f15eb,0x05fee5ca,0x07ef6dc1)    R(0x059a,0x07ef6dc1,0x06df4198,0x08bfad97)    R(0x059b,0x06df4198,0x07ef7568,0x08bfad97)    R(0x059c,0x05fee5ca,0x06df4198,0x07ef6dc1)    R(0x059d,0x093f61ef,0x09efb9c4,0x0b3f99ed)    R(0x059e,0x06df4198,0x063ef965,0x07ef7568)    R(0x059f,0x05fee5ca,0x048e65bc,0x054ebd93)\n    R(0x05a0,0x08bfad97,0x07ef7568,0x0a0fc56c)    R(0x05a1,0x09efb9c4,0x08bfad97,0x0adfe99b)    R(0x05a2,0x0b3f99ed,0x09efb9c4,0x0c3fddc5)    R(0x05a3,0x0d4fb9e0,0x0eafe5b4,0x0eefadd8)    R(0x05a4,0x09efb9c4,0x0adfe99b,0x0c3fddc5)    R(0x05a5,0x07ef6dc1,0x08bfad97,0x09efb9c4)    R(0x05a6,0x0b3f99ed,0x0c3fddc5,0x0d4fb9e0)    R(0x05a7,0x0d4fb9e0,0x0c3fddc5,0x0eafe5b4)    R(0x05a8,0x08bfad97,0x0a0fc56c,0x0adfe99b)    R(0x05a9,0x10bf0522,0x0f4f0505,0x0f6e8907)\n    R(0x05aa,0x049e5965,0x042de93d,0x05be9138)    R(0x05ab,0x103fd58d,0x0eaff982,0x0fdfd961)    R(0x05ac,0x124e8d9a,0x120e857a,0x131e6570)    R(0x05ad,0x0eee95f6,0x0f7ef1ea,0x108ea5cf)    R(0x05ae,0x103f5d22,0x0f2fa934,0x0eaf6110)    R(0x05af,0x10fe3d31,0x10de7d2d,0x0f7e1117)    R(0x05b0,0x120e857a,0x119e7553,0x11fe5950)    R(0x05b1,0x11bef99b,0x11df3572,0x11dead79)    R(0x05b2,0x10bf0522,0x103f5d22,0x0f4f0505)    R(0x05b3,0x103f5d22,0x0eaf6110,0x0f4f0505)\n    R(0x05b4,0x112fa16b,0x0fdfd961,0x108f9d44)    R(0x05b5,0x10de7d2d,0x0f6e8907,0x0f7e1117)    R(0x05b6,0x119ed94d,0x115f5546,0x10bf0522)    R(0x05b7,0x120e857a,0x11dead79,0x119e7553)    R(0x05b8,0x119e7553,0x119ed94d,0x10de7d2d)    R(0x05b9,0x11fe5950,0x119e7553,0x10fe3d31)    R(0x05ba,0x11df3572,0x115f5546,0x119ed94d)    R(0x05bb,0x11dead79,0x119ed94d,0x119e7553)    R(0x05bc,0x11dead79,0x11df3572,0x119ed94d)    R(0x05bd,0x119ed94d,0x10bf0522,0x10de7d2d)\n    R(0x05be,0x0fdfd961,0x0f2fa934,0x108f9d44)    R(0x05bf,0x108f9d44,0x0f2fa934,0x103f5d22)    R(0x05c0,0x116f8990,0x112fa16b,0x11df3572)    R(0x05c1,0x11fe5950,0x10fe3d31,0x118e1929)    R(0x05c2,0x115f5546,0x103f5d22,0x10bf0522)    R(0x05c3,0x112fa16b,0x108f9d44,0x115f5546)    R(0x05c4,0x119e7553,0x10de7d2d,0x10fe3d31)    R(0x05c5,0x11df3572,0x112fa16b,0x115f5546)    R(0x05c6,0x103fd58d,0x0fdfd961,0x112fa16b)    R(0x05c7,0x115f5546,0x108f9d44,0x103f5d22)\n    R(0x05c8,0x113e81ec,0x113e95c1,0x12de8dc1)    R(0x05c9,0x0fde89ec,0x0eee95f6,0x108ea5cf)    R(0x05ca,0x10de7d2d,0x10bf0522,0x0f6e8907)    R(0x05cb,0x0eefadd8,0x0eafe5b4,0x103fb5b4)    R(0x05cc,0x113e81ec,0x0fde89ec,0x113e95c1)    R(0x05cd,0x0fde89ec,0x108ea5cf,0x113e95c1)    R(0x05ce,0x0f7ef1ea,0x0fff69d5,0x10deedc4)    R(0x05cf,0x118ea5a2,0x11bef99b,0x11dead79)    R(0x05d0,0x118ea5a2,0x11dead79,0x120e857a)    R(0x05d1,0x12de8dc1,0x113e95c1,0x124e8d9a)\n    R(0x05d2,0x10deedc4,0x112f69b2,0x11bef99b)    R(0x05d3,0x118ea5a2,0x10deedc4,0x11bef99b)    R(0x05d4,0x113e95c1,0x118ea5a2,0x124e8d9a)    R(0x05d5,0x108ea5cf,0x0f7ef1ea,0x10deedc4)    R(0x05d6,0x108ea5cf,0x10deedc4,0x118ea5a2)    R(0x05d7,0x113e95c1,0x108ea5cf,0x118ea5a2)    R(0x05d8,0x0eefadd8,0x103fb5b4,0x0fff69d5)    R(0x05d9,0x103fb5b4,0x0eafe5b4,0x103fd58d)    R(0x05da,0x116f8990,0x103fd58d,0x112fa16b)    R(0x05db,0x124e8d9a,0x118ea5a2,0x120e857a)\n    R(0x05dc,0x10deedc4,0x0fff69d5,0x112f69b2)    R(0x05dd,0x112f69b2,0x103fb5b4,0x116f8990)    R(0x05de,0x0fff69d5,0x103fb5b4,0x112f69b2)    R(0x05df,0x11bef99b,0x112f69b2,0x116f8990)    R(0x05e0,0x11bef99b,0x116f8990,0x11df3572)    R(0x05e1,0x116f8990,0x103fb5b4,0x103fd58d)    R(0x05e2,0x1327d03e,0x14873042,0x15a7d43d)    R(0x05e3,0x3bc00c87,0x3c002072,0x3ad00099)    R(0x05e4,0x0146dcad,0x00e698be,0x010620b0)    R(0x05e5,0x3ff6e0f3,0x3f66fccf,0x3fd6ccf5)\n    R(0x05e6,0x147e7597,0x124e8d9a,0x131e6570)    R(0x05e7,0x270be602,0x25bc69d6,0x26fbddc5)    R(0x05e8,0x3b5020a2,0x3bc00c87,0x3a700cb2)    R(0x05e9,0x01173cbd,0x00e698be,0x0146dcad)    R(0x05ea,0x3db71ced,0x3f66fcef,0x3f06d91c)    R(0x05eb,0x3f66fcef,0x3f1718cc,0x3fe6e8f5)    R(0x05ec,0x15a7d43d,0x14873042,0x17677849)    R(0x05ed,0x132ddd0a,0x126d64d9,0x155d98ed)    R(0x05ee,0x011768d3,0x00e6acd7,0x01173cbd)    R(0x05ef,0x1478843e,0x15a7d43d,0x17185844)\n    R(0x05f0,0x18d8d451,0x17185844,0x18f81051)    R(0x05f1,0x1b86d4ce,0x1a564cca,0x1b363cdd)    R(0x05f2,0x22282cf1,0x20c7a0eb,0x2377c117)    R(0x05f3,0x3fe6e8f5,0x3f1718cc,0x3f470ccd)    R(0x05f4,0x17185844,0x15a7d43d,0x17677849)    R(0x05f5,0x19d6d876,0x1876546f,0x19b64c96)    R(0x05f6,0x1c68b4ae,0x1bc82898,0x1ca800ba)    R(0x05f7,0x011768d3,0x01173cbd,0x0127e8ba)    R(0x05f8,0x3847a8e1,0x3a2794bf,0x38a7ace4)    R(0x05f9,0x3757a514,0x38a7ace4,0x39579ceb)\n    R(0x05fa,0x1ad6dcaa,0x19b64c96,0x1a564cca)    R(0x05fb,0x1b86d4ce,0x1ad6dcaa,0x1a564cca)    R(0x05fc,0x1e1890bd,0x1ca800ba,0x1e87ccca)    R(0x05fd,0x1478843e,0x11d87840,0x1327d03e)    R(0x05fe,0x19d6d876,0x1826d058,0x1876546f)    R(0x05ff,0x1ad6dcaa,0x19d6d876,0x19b64c96)    R(0x0600,0x17677849,0x14873042,0x1626d847)    R(0x0601,0x17677849,0x1626d847,0x1826d058)    R(0x0602,0x1bd77cb7,0x1ad6dcaa,0x1b86d4ce)    R(0x0603,0x1ca800ba,0x1bd77cb7,0x1cf740ce)\n    R(0x0604,0x1af77088,0x1967645e,0x19d6d876)    R(0x0605,0x1af77088,0x19d6d876,0x1ad6dcaa)    R(0x0606,0x1bd77cb7,0x1af77088,0x1ad6dcaa)    R(0x0607,0x1967645e,0x17677849,0x1826d058)    R(0x0608,0x1967645e,0x1826d058,0x19d6d876)    R(0x0609,0x1826d058,0x1626d847,0x16465458)    R(0x060a,0x1a589063,0x18f81051,0x1a87f46b)    R(0x060b,0x1ca800ba,0x1bc82898,0x1bd77cb7)    R(0x060c,0x1a87f46b,0x18f81051,0x1967645e)    R(0x060d,0x1826d058,0x16465458,0x1876546f)\n    R(0x060e,0x1a87f46b,0x1967645e,0x1af77088)    R(0x060f,0x1bc82898,0x1a589063,0x1a87f46b)    R(0x0610,0x1bc82898,0x1a87f46b,0x1af77088)    R(0x0611,0x1bc82898,0x1af77088,0x1bd77cb7)    R(0x0612,0x18f81051,0x17677849,0x1967645e)    R(0x0613,0x1f4710e7,0x1d667ce2,0x1fe670ff)    R(0x0614,0x14873042,0x13a6744e,0x1626d847)    R(0x0615,0x11f70c44,0x13a6744e,0x14873042)    R(0x0616,0x38e720e3,0x39f760bb,0x381774e1)    R(0x0617,0x3707a50f,0x3847a8e1,0x38a7ace4)\n    R(0x0618,0x206840ce,0x1e1890bd,0x1e87ccca)    R(0x0619,0x1cf740ce,0x1bd77cb7,0x1b86d4ce)    R(0x061a,0x1e87ccca,0x1cf740ce,0x1f4710e7)    R(0x061b,0x21b7150a,0x1f4710e7,0x1fe670ff)    R(0x061c,0x381774e1,0x394788c3,0x37f798e2)    R(0x061d,0x20c7a0eb,0x1f4710e7,0x21b7150a)    R(0x061e,0x3707250a,0x381774e1,0x36a77d0a)    R(0x061f,0x36a77d0a,0x381774e1,0x37f798e2)    R(0x0620,0x3707250a,0x38e720e3,0x381774e1)    R(0x0621,0x20c7a0eb,0x1e87ccca,0x1f4710e7)\n    R(0x0622,0x17185844,0x17677849,0x18f81051)    R(0x0623,0x1cf740ce,0x1b86d4ce,0x1d667ce2)    R(0x0624,0x36a77d0a,0x37f798e2,0x36c7990c)    R(0x0625,0x37f798e2,0x399794c0,0x3847a8e1)    R(0x0626,0x206840ce,0x1e87ccca,0x20c7a0eb)    R(0x0627,0x22282cf1,0x206840ce,0x20c7a0eb)    R(0x0628,0x1e87ccca,0x1ca800ba,0x1cf740ce)    R(0x0629,0x36c7990c,0x37f798e2,0x3847a8e1)    R(0x062a,0x1f4710e7,0x1cf740ce,0x1d667ce2)    R(0x062b,0x37f798e2,0x394788c3,0x399794c0)\n    R(0x062c,0x1626d847,0x13a6744e,0x16465458)    R(0x062d,0x38a7ace4,0x3a2794bf,0x3ae78cc4)    R(0x062e,0x3fd6ccf5,0x3f66fccf,0x3f56d0e1)    R(0x062f,0x3c56ed16,0x3ba764dd,0x3db71ced)    R(0x0630,0x3ae770ae,0x3c7758a6,0x3b6778ac)    R(0x0631,0x3c7758a6,0x3e472cb5,0x3d0754a9)    R(0x0632,0x3c86c4d8,0x3d071cb2,0x3b171cc0)    R(0x0633,0x3f470ccd,0x3e472cb5,0x3f66fccf)    R(0x0634,0x3d6738ab,0x3e472cb5,0x3c7758a6)    R(0x0635,0x39f760bb,0x3ae770ae,0x394788c3)\n    R(0x0636,0x3a2794bf,0x3b6778ac,0x3c4770af)    R(0x0637,0x3e9710bc,0x3d6738ab,0x3d071cb2)    R(0x0638,0x3b171cc0,0x3bd74ca9,0x39f760bb)    R(0x0639,0x3c4770af,0x3e1740b5,0x3d8750c0)    R(0x063a,0x3e46e0cc,0x3e9710bc,0x3d071cb2)    R(0x063b,0x3e1740b5,0x3e472cb5,0x3f470ccd)    R(0x063c,0x3d0754a9,0x3e472cb5,0x3e1740b5)    R(0x063d,0x3d071cb2,0x3d6738ab,0x3bd74ca9)    R(0x063e,0x3e9710bc,0x3e472cb5,0x3d6738ab)    R(0x063f,0x3d8750c0,0x3e1740b5,0x3f1718cc)\n    R(0x0640,0x3b171cc0,0x3d071cb2,0x3bd74ca9)    R(0x0641,0x394788c3,0x3ae770ae,0x399794c0)    R(0x0642,0x39f760bb,0x3bd74ca9,0x3ae770ae)    R(0x0643,0x3f66fccf,0x3e472cb5,0x3e9710bc)    R(0x0644,0x399794c0,0x3b6778ac,0x3a2794bf)    R(0x0645,0x3a2794bf,0x3c4770af,0x3ae78cc4)    R(0x0646,0x3b6778ac,0x3d0754a9,0x3c4770af)    R(0x0647,0x3ae78cc4,0x3c4770af,0x3d8750c0)    R(0x0648,0x3c4770af,0x3d0754a9,0x3e1740b5)    R(0x0649,0x399794c0,0x3ae770ae,0x3b6778ac)\n    R(0x064a,0x3f1718cc,0x3e1740b5,0x3f470ccd)    R(0x064b,0x3e1688fb,0x3c86c4d8,0x3bb65d05)    R(0x064c,0x3f469112,0x3fd6ccf5,0x3f56d0e1)    R(0x064d,0x3a574505,0x3ba764dd,0x3c56ed16)    R(0x064e,0x3bd74ca9,0x3d6738ab,0x3c7758a6)    R(0x064f,0x381774e1,0x39f760bb,0x394788c3)    R(0x0650,0x38a7ace4,0x3ae78cc4,0x39579ceb)    R(0x0651,0x38269d10,0x3a46b4f0,0x38e720e3)    R(0x0652,0x38e720e3,0x3b171cc0,0x39f760bb)    R(0x0653,0x3e46e0cc,0x3d071cb2,0x3c86c4d8)\n    R(0x0654,0x3db71ced,0x3d8750c0,0x3f66fcef)    R(0x0655,0x3f469112,0x3f56d0e1,0x3e1688fb)    R(0x0656,0x3a46b4f0,0x3c86c4d8,0x3b171cc0)    R(0x0657,0x3d8750c0,0x3f1718cc,0x3f66fcef)    R(0x0658,0x3f56d0e1,0x3e9710bc,0x3e46e0cc)    R(0x0659,0x3a46b4f0,0x3b171cc0,0x38e720e3)    R(0x065a,0x3f56d0e1,0x3f66fccf,0x3e9710bc)    R(0x065b,0x3847a8e1,0x399794c0,0x3a2794bf)    R(0x065c,0x39579ceb,0x3ba764dd,0x3a574505)    R(0x065d,0x3bb65d05,0x3c86c4d8,0x3a46b4f0)\n    R(0x065e,0x3bd74ca9,0x3c7758a6,0x3ae770ae)    R(0x065f,0x3f56d0e1,0x3e46e0cc,0x3e1688fb)    R(0x0660,0x3ae78cc4,0x3d8750c0,0x3ba764dd)    R(0x0661,0x3b6778ac,0x3c7758a6,0x3d0754a9)    R(0x0662,0x3ba764dd,0x3d8750c0,0x3db71ced)    R(0x0663,0x3e1688fb,0x3e46e0cc,0x3c86c4d8)    R(0x0664,0x39579ceb,0x3ae78cc4,0x3ba764dd)    R(0x0665,0x118c5493,0x124ba870,0x13fc2887)    R(0x0666,0x1329343f,0x11d87840,0x1478843e)    R(0x0667,0x17fdc100,0x155d98ed,0x17bd58cf)\n    R(0x0668,0x1d667ce2,0x1b86d4ce,0x1b363cdd)    R(0x0669,0x227c5110,0x208c60ec,0x229bc4f7)    R(0x066a,0x2579e506,0x2359ecdd,0x23f958ed)    R(0x066b,0x16491047,0x1478843e,0x17185844)    R(0x066c,0x18d8d451,0x18f81051,0x1a589063)    R(0x066d,0x1c5b4497,0x19ab3881,0x1b2a9c88)    R(0x066e,0x12dcd8b5,0x118c5493,0x13fc2887)    R(0x066f,0x17fdc100,0x17bd58cf,0x1a1d64e9)    R(0x0670,0x18598853,0x16491047,0x18d8d451)    R(0x0671,0x1b78d887,0x1a589063,0x1bc82898)\n    R(0x0672,0x1589b44c,0x1329343f,0x16491047)    R(0x0673,0x156ba478,0x124ba870,0x13cb2063)    R(0x0674,0x169c4c8c,0x156ba478,0x181bc082)    R(0x0675,0x18598853,0x18d8d451,0x1a394c66)    R(0x0676,0x1a394c66,0x18d8d451,0x1a589063)    R(0x0677,0x152a7458,0x12c9ec4b,0x1589b44c)    R(0x0678,0x16cb086a,0x152a7458,0x178a2858)    R(0x0679,0x19f9fc71,0x18598853,0x1a394c66)    R(0x067a,0x19f9fc71,0x1a394c66,0x1b897c90)    R(0x067b,0x19f9fc71,0x178a2858,0x18598853)\n    R(0x067c,0x18da9870,0x178a2858,0x19f9fc71)    R(0x067d,0x152a7458,0x1589b44c,0x178a2858)    R(0x067e,0x1b2a9c88,0x18da9870,0x19f9fc71)    R(0x067f,0x178a2858,0x1589b44c,0x18598853)    R(0x0680,0x13fc2887,0x124ba870,0x156ba478)    R(0x0681,0x16cb086a,0x13cb2063,0x152a7458)    R(0x0682,0x1a394c66,0x1a589063,0x1b78d887)    R(0x0683,0x1b897c90,0x1a394c66,0x1b78d887)    R(0x0684,0x16cb086a,0x178a2858,0x18da9870)    R(0x0685,0x181bc082,0x16cb086a,0x19ab3881)\n    R(0x0686,0x19ab3881,0x16cb086a,0x18da9870)    R(0x0687,0x19ab3881,0x18da9870,0x1b2a9c88)    R(0x0688,0x156ba478,0x13cb2063,0x16cb086a)    R(0x0689,0x181bc082,0x156ba478,0x16cb086a)    R(0x068a,0x16491047,0x17185844,0x18d8d451)    R(0x068b,0x12c9ec4b,0x1329343f,0x1589b44c)    R(0x068c,0x1acbd899,0x19ab3881,0x1c5b4497)    R(0x068d,0x155d98ed,0x153d2cc3,0x17bd58cf)    R(0x068e,0x155d98ed,0x126d64d9,0x153d2cc3)    R(0x068f,0x1acbd899,0x181bc082,0x19ab3881)\n    R(0x0690,0x12dcd8b5,0x13fc2887,0x150cac9e)    R(0x0691,0x169c4c8c,0x13fc2887,0x156ba478)    R(0x0692,0x199cf0c0,0x18fc689b,0x1b9c68b8)    R(0x0693,0x174ce0a7,0x150cac9e,0x169c4c8c)    R(0x0694,0x174ce0a7,0x169c4c8c,0x18fc689b)    R(0x0695,0x18fc689b,0x169c4c8c,0x181bc082)    R(0x0696,0x18fc689b,0x181bc082,0x1acbd899)    R(0x0697,0x150cac9e,0x13fc2887,0x169c4c8c)    R(0x0698,0x1b9c68b8,0x18fc689b,0x1acbd899)    R(0x0699,0x153d2cc3,0x12dcd8b5,0x150cac9e)\n    R(0x069a,0x18598853,0x1589b44c,0x16491047)    R(0x069b,0x1a1d64e9,0x17bd58cf,0x199cf0c0)    R(0x069c,0x1a1d64e9,0x199cf0c0,0x1c3cf0da)    R(0x069d,0x17bd58cf,0x174ce0a7,0x199cf0c0)    R(0x069e,0x199cf0c0,0x174ce0a7,0x18fc689b)    R(0x069f,0x153d2cc3,0x150cac9e,0x174ce0a7)    R(0x06a0,0x17bd58cf,0x153d2cc3,0x174ce0a7)    R(0x06a1,0x1b2a9c88,0x19f9fc71,0x1c2a0c96)    R(0x06a2,0x199cf0c0,0x1b9c68b8,0x1c3cf0da)    R(0x06a3,0x152a7458,0x125a9c56,0x12c9ec4b)\n    R(0x06a4,0x1e1890bd,0x1c68b4ae,0x1ca800ba)    R(0x06a5,0x126d64d9,0x12dcd8b5,0x153d2cc3)    R(0x06a6,0x23f958ed,0x2268d0de,0x23e89908)    R(0x06a7,0x246a70f1,0x2359ecdd,0x2579e506)    R(0x06a8,0x1b897c90,0x1b78d887,0x1c68b4ae)    R(0x06a9,0x1c68b4ae,0x1b78d887,0x1bc82898)    R(0x06aa,0x21f968cb,0x1f3968bd,0x2068e0ca)    R(0x06ab,0x13cb2063,0x125a9c56,0x152a7458)    R(0x06ac,0x216b44d6,0x1ecb4cb6,0x1fdaacc0)    R(0x06ad,0x1e3c70cd,0x1d7be4b2,0x200be0d0)\n    R(0x06ae,0x1d0958b0,0x1c68b4ae,0x1e1890bd)    R(0x06af,0x1c2a0c96,0x19f9fc71,0x1b897c90)    R(0x06b0,0x1c2a0c96,0x1b897c90,0x1d0958b0)    R(0x06b1,0x1daaac9e,0x1c2a0c96,0x1e5a08b1)    R(0x06b2,0x20ea04c2,0x1f3968bd,0x21f968cb)    R(0x06b3,0x1e5a08b1,0x1d0958b0,0x1f3968bd)    R(0x06b4,0x1fdaacc0,0x1daaac9e,0x1e5a08b1)    R(0x06b5,0x20ea04c2,0x1e5a08b1,0x1f3968bd)    R(0x06b6,0x1fdaacc0,0x1e5a08b1,0x20ea04c2)    R(0x06b7,0x1e5a08b1,0x1c2a0c96,0x1d0958b0)\n    R(0x06b8,0x1b9c68b8,0x1acbd899,0x1d7be4b2)    R(0x06b9,0x1d0958b0,0x1b897c90,0x1c68b4ae)    R(0x06ba,0x1e3c70cd,0x1b9c68b8,0x1d7be4b2)    R(0x06bb,0x1f3968bd,0x1d0958b0,0x1e1890bd)    R(0x06bc,0x200be0d0,0x1d7be4b2,0x1ecb4cb6)    R(0x06bd,0x1f3968bd,0x1e1890bd,0x2068e0ca)    R(0x06be,0x1d7be4b2,0x1acbd899,0x1c5b4497)    R(0x06bf,0x1ecb4cb6,0x1daaac9e,0x1fdaacc0)    R(0x06c0,0x1d7be4b2,0x1c5b4497,0x1ecb4cb6)    R(0x06c1,0x1ecb4cb6,0x1c5b4497,0x1daaac9e)\n    R(0x06c2,0x2268d0de,0x206840ce,0x22282cf1)    R(0x06c3,0x2268d0de,0x22282cf1,0x23e89908)    R(0x06c4,0x246a70f1,0x225a98d5,0x2359ecdd)    R(0x06c5,0x1daaac9e,0x1b2a9c88,0x1c2a0c96)    R(0x06c6,0x1a1d64e9,0x1c3cf0da,0x1cad6106)    R(0x06c7,0x23f958ed,0x21f968cb,0x2268d0de)    R(0x06c8,0x1c5b4497,0x1b2a9c88,0x1daaac9e)    R(0x06c9,0x2068e0ca,0x1e1890bd,0x206840ce)    R(0x06ca,0x216b44d6,0x225a98d5,0x23bb14f2)    R(0x06cb,0x23bb14f2,0x225a98d5,0x246a70f1)\n    R(0x06cc,0x216b44d6,0x1fdaacc0,0x225a98d5)    R(0x06cd,0x2359ecdd,0x20ea04c2,0x21f968cb)    R(0x06ce,0x225a98d5,0x20ea04c2,0x2359ecdd)    R(0x06cf,0x225a98d5,0x1fdaacc0,0x20ea04c2)    R(0x06d0,0x2359ecdd,0x21f968cb,0x23f958ed)    R(0x06d1,0x2268d0de,0x2068e0ca,0x206840ce)    R(0x06d2,0x1c3cf0da,0x1b9c68b8,0x1e3c70cd)    R(0x06d3,0x1cad6106,0x1c3cf0da,0x1eace4f4)    R(0x06d4,0x200be0d0,0x1ecb4cb6,0x216b44d6)    R(0x06d5,0x21f968cb,0x2068e0ca,0x2268d0de)\n    R(0x06d6,0x229bc4f7,0x216b44d6,0x23bb14f2)    R(0x06d7,0x1eace4f4,0x1c3cf0da,0x1e3c70cd)    R(0x06d8,0x208c60ec,0x200be0d0,0x229bc4f7)    R(0x06d9,0x229bc4f7,0x200be0d0,0x216b44d6)    R(0x06da,0x1eace4f4,0x1e3c70cd,0x208c60ec)    R(0x06db,0x208c60ec,0x1e3c70cd,0x200be0d0)    R(0x06dc,0x3725fd36,0x38269d10,0x3646a12e)    R(0x06dd,0x3fc6a91e,0x3ff6e0f3,0x3fd6ccf5)    R(0x06de,0x1327d03e,0x11f70c44,0x14873042)    R(0x06df,0x16be7201,0x15ae81cd,0x189e69ce)\n    R(0x06e0,0x15ae81cd,0x12de8dc1,0x147e7597)    R(0x06e1,0x13ce7df9,0x113e81ec,0x12de8dc1)    R(0x06e2,0x16491047,0x1329343f,0x1478843e)    R(0x06e3,0x26970dda,0x25d681bd,0x264681f8)    R(0x06e4,0x39763119,0x3a46b4f0,0x38269d10)    R(0x06e5,0x3fe6bd20,0x3fe6e8f5,0x3ff6e0f3)    R(0x06e6,0x2377c117,0x21b7150a,0x23971536)    R(0x06e7,0x23971536,0x21f67528,0x23d66d56)    R(0x06e8,0x23e89908,0x22282cf1,0x2377c117)    R(0x06e9,0x21b7150a,0x1fe670ff,0x21f67528)\n    R(0x06ea,0x25592119,0x23e89908,0x25785130)    R(0x06eb,0x34769155,0x3646a12e,0x35871d34)    R(0x06ec,0x326635b2,0x3336998b,0x33b6cd94)    R(0x06ed,0x28083dd5,0x2727a5b8,0x2757a1f8)    R(0x06ee,0x3316517d,0x34769155,0x3436ed60)    R(0x06ef,0x34d73d6b,0x3537416f,0x3456e19a)    R(0x06f0,0x34d73d6b,0x35f7813f,0x3537416f)    R(0x06f1,0x2517b14a,0x2377c117,0x23971536)    R(0x06f2,0x25785130,0x23e89908,0x2377c117)    R(0x06f3,0x26d8e547,0x25785130,0x26e8415f)\n    R(0x06f4,0x2517b14a,0x23971536,0x2517096a)    R(0x06f5,0x3316517d,0x3436ed60,0x3336998b)    R(0x06f6,0x33b6cd94,0x34672166,0x34d73d6b)    R(0x06f7,0x34672166,0x35a7753b,0x34d73d6b)    R(0x06f8,0x3436ed60,0x35871d34,0x35675d38)    R(0x06f9,0x3436ed60,0x35675d38,0x34672166)    R(0x06fa,0x3336998b,0x3436ed60,0x34672166)    R(0x06fb,0x2517096a,0x23d66d56,0x25165d8b)    R(0x06fc,0x34672166,0x35675d38,0x35a7753b)    R(0x06fd,0x2517096a,0x23971536,0x23d66d56)\n    R(0x06fe,0x26e8415f,0x25785130,0x2517b14a)    R(0x06ff,0x27b84596,0x26e8415f,0x2667a97f)    R(0x0700,0x27f8e179,0x26d8e547,0x26e8415f)    R(0x0701,0x34d73d6b,0x35a7753b,0x35f7813f)    R(0x0702,0x26e8415f,0x2517b14a,0x2667a97f)    R(0x0703,0x27f8e179,0x26e8415f,0x27b84596)    R(0x0704,0x3336998b,0x34672166,0x33b6cd94)    R(0x0705,0x34769155,0x35871d34,0x3436ed60)    R(0x0706,0x2667a97f,0x2517b14a,0x2517096a)    R(0x0707,0x326635b2,0x33b6cd94,0x33565dbf)\n    R(0x0708,0x34868dbc,0x3596b58e,0x351635b9)    R(0x0709,0x2757a1f8,0x2727a5b8,0x26970dda)    R(0x070a,0x25785130,0x2377c117,0x2517b14a)    R(0x070b,0x26d8e547,0x25592119,0x25785130)    R(0x070c,0x33565dbf,0x33b6cd94,0x3456e19a)    R(0x070d,0x2617099e,0x2517096a,0x25165d8b)    R(0x070e,0x26970dda,0x2617099e,0x25d681bd)    R(0x070f,0x2727a5b8,0x2617099e,0x26970dda)    R(0x0710,0x34868dbc,0x35471d82,0x3596b58e)    R(0x0711,0x3456e19a,0x34a6e19f,0x340671c5)\n    R(0x0712,0x3456e19a,0x3537416f,0x34a6e19f)    R(0x0713,0x34868dbc,0x34a6e19f,0x35471d82)    R(0x0714,0x34a6e19f,0x3537416f,0x35471d82)    R(0x0715,0x33b6cd94,0x34d73d6b,0x3456e19a)    R(0x0716,0x2617099e,0x25165d8b,0x25d681bd)    R(0x0717,0x2667a97f,0x2517096a,0x2617099e)    R(0x0718,0x2888ddb5,0x27f8e179,0x27b84596)    R(0x0719,0x2898ddf5,0x2888ddb5,0x28083dd5)    R(0x071a,0x340671c5,0x34a6e19f,0x34868dbc)    R(0x071b,0x2727a5b8,0x2667a97f,0x2617099e)\n    R(0x071c,0x2888ddb5,0x27b84596,0x28083dd5)    R(0x071d,0x27b84596,0x2667a97f,0x2727a5b8)    R(0x071e,0x33565dbf,0x3456e19a,0x340671c5)    R(0x071f,0x28083dd5,0x27b84596,0x2727a5b8)    R(0x0720,0x36c7990c,0x3847a8e1,0x3707a50f)    R(0x0721,0x3fc6c921,0x3f66fcef,0x3fe6e8f5)    R(0x0722,0x2377c117,0x20c7a0eb,0x21b7150a)    R(0x0723,0x36e63589,0x3796b55b,0x38d65964)    R(0x0724,0x3596b58e,0x36472d60,0x3796b55b)    R(0x0725,0x38178d14,0x39579ceb,0x3a574505)\n    R(0x0726,0x3ed66144,0x3fc6a91e,0x3f469112)    R(0x0727,0x3f26854a,0x3fe6bd20,0x3fc6a91e)    R(0x0728,0x3f26954c,0x3fc6c921,0x3fe6bd20)    R(0x0729,0x23971536,0x21b7150a,0x21f67528)    R(0x072a,0x35a7753b,0x3707a50f,0x35f7813f)    R(0x072b,0x3757a514,0x39579ceb,0x38178d14)    R(0x072c,0x3646a12e,0x3707250a,0x35871d34)    R(0x072d,0x35871d34,0x3707250a,0x36a77d0a)    R(0x072e,0x3c56ed16,0x3db71ced,0x3f06d91c)    R(0x072f,0x3c56ed16,0x3f06d91c,0x3dc6a943)\n    R(0x0730,0x3fc6a91e,0x3fd6ccf5,0x3f469112)    R(0x0731,0x3fc6c921,0x3fe6e8f5,0x3fe6bd20)    R(0x0732,0x3f06d91c,0x3f66fcef,0x3fc6c921)    R(0x0733,0x37e74132,0x3a574505,0x39a6d932)    R(0x0734,0x39a6d932,0x3a574505,0x3c56ed16)    R(0x0735,0x35871d34,0x36a77d0a,0x35675d38)    R(0x0736,0x35a7753b,0x36c7990c,0x3707a50f)    R(0x0737,0x3646a12e,0x38269d10,0x3707250a)    R(0x0738,0x38178d14,0x3a574505,0x37e74132)    R(0x0739,0x3ef6a14c,0x3f06d91c,0x3fc6c921)\n    R(0x073a,0x35675d38,0x36a77d0a,0x36c7990c)    R(0x073b,0x36577946,0x3757a514,0x38178d14)    R(0x073c,0x36577946,0x38178d14,0x37e74132)    R(0x073d,0x35675d38,0x36c7990c,0x35a7753b)    R(0x073e,0x35f7813f,0x3707a50f,0x3757a514)    R(0x073f,0x3596b58e,0x3796b55b,0x36e63589)    R(0x0740,0x3f26954c,0x3fe6bd20,0x3f26854a)    R(0x0741,0x38269d10,0x38e720e3,0x3707250a)    R(0x0742,0x3537416f,0x36577946,0x35471d82)    R(0x0743,0x3707a50f,0x38a7ace4,0x3757a514)\n    R(0x0744,0x3de65976,0x3ef6a14c,0x3f26954c)    R(0x0745,0x3796b55b,0x39a6d932,0x38d65964)    R(0x0746,0x39a6d932,0x3c56ed16,0x3b068d46)    R(0x0747,0x3d966175,0x3ef6a14c,0x3de65976)    R(0x0748,0x3de65976,0x3f26954c,0x3df64976)    R(0x0749,0x3ef6a14c,0x3fc6c921,0x3f26954c)    R(0x074a,0x3d966175,0x3dc6a943,0x3ef6a14c)    R(0x074b,0x38d65964,0x39a6d932,0x3b068d46)    R(0x074c,0x3b068d46,0x3dc6a943,0x3c46616b)    R(0x074d,0x3dc6a943,0x3f06d91c,0x3ef6a14c)\n    R(0x074e,0x3b068d46,0x3c56ed16,0x3dc6a943)    R(0x074f,0x35471d82,0x36472d60,0x3596b58e)    R(0x0750,0x3537416f,0x35f7813f,0x36577946)    R(0x0751,0x35f7813f,0x3757a514,0x36577946)    R(0x0752,0x3df64976,0x3f26954c,0x3f26854a)    R(0x0753,0x3f26854a,0x3fc6a91e,0x3ed66144)    R(0x0754,0x36472d60,0x37e74132,0x3796b55b)    R(0x0755,0x3796b55b,0x37e74132,0x39a6d932)    R(0x0756,0x3c46616b,0x3dc6a943,0x3d966175)    R(0x0757,0x35471d82,0x36577946,0x36472d60)\n    R(0x0758,0x36577946,0x37e74132,0x36472d60)    R(0x0759,0x137e353f,0x118e1929,0x132ddd0a)    R(0x075a,0x12de8dc1,0x124e8d9a,0x147e7597)    R(0x075b,0x13ce7df9,0x12de8dc1,0x15ae81cd)    R(0x075c,0x1a7dc51c,0x17fdc100,0x1a1d64e9)    R(0x075d,0x35461d4a,0x3646a12e,0x34769155)    R(0x075e,0x3f469112,0x3e1688fb,0x3df63935)    R(0x075f,0x1a7dc51c,0x1a1d64e9,0x1cad6106)    R(0x0760,0x227c5110,0x229bc4f7,0x244bf92a)    R(0x0761,0x131e6570,0x11fe5950,0x137e353f)\n    R(0x0762,0x15ae81cd,0x147e7597,0x173e619b)    R(0x0763,0x205da9f4,0x1f3dcdc5,0x217d69be)    R(0x0764,0x229d45f3,0x23acf1b7,0x245cd9f2)    R(0x0765,0x232c993f,0x227c5110,0x244bf92a)    R(0x0766,0x20dccd18,0x1eace4f4,0x208c60ec)    R(0x0767,0x15de455e,0x15bdfd22,0x184e0d36)    R(0x0768,0x15de455e,0x137e353f,0x15bdfd22)    R(0x0769,0x1a6e3d99,0x18ae3d6c,0x1ade0953)    R(0x076a,0x1efd4927,0x1eace4f4,0x20dccd18)    R(0x076b,0x15bdfd22,0x155d98ed,0x17fdc100)\n    R(0x076c,0x215d154d,0x1efd4927,0x20dccd18)    R(0x076d,0x218d4585,0x1f4d8d5b,0x215d154d)    R(0x076e,0x218d4585,0x215d154d,0x237ccd78)    R(0x076f,0x1f4d8d5b,0x1cfdb93b,0x1efd4927)    R(0x0770,0x1f4d8d5b,0x1efd4927,0x215d154d)    R(0x0771,0x1a7dc51c,0x1cad6106,0x1cfdb93b)    R(0x0772,0x1cfdb93b,0x1cad6106,0x1efd4927)    R(0x0773,0x1cedf175,0x1cfdb93b,0x1f4d8d5b)    R(0x0774,0x184e0d36,0x15bdfd22,0x17fdc100)    R(0x0775,0x18ae3d6c,0x15de455e,0x184e0d36)\n    R(0x0776,0x232c993f,0x20dccd18,0x227c5110)    R(0x0777,0x237ccd78,0x215d154d,0x232c993f)    R(0x0778,0x1ade0953,0x184e0d36,0x1a7dc51c)    R(0x0779,0x1ade0953,0x1a7dc51c,0x1cfdb93b)    R(0x077a,0x1ade0953,0x1cfdb93b,0x1cedf175)    R(0x077b,0x215d154d,0x20dccd18,0x232c993f)    R(0x077c,0x184e0d36,0x17fdc100,0x1a7dc51c)    R(0x077d,0x18ae3d6c,0x184e0d36,0x1ade0953)    R(0x077e,0x20dccd18,0x208c60ec,0x227c5110)    R(0x077f,0x23acf1b7,0x218d4585,0x237ccd78)\n    R(0x0780,0x205da9f4,0x217d69be,0x229d45f3)    R(0x0781,0x147e7597,0x131e6570,0x15de455e)    R(0x0782,0x189e69ce,0x15ae81cd,0x173e619b)    R(0x0783,0x1efd4927,0x1cad6106,0x1eace4f4)    R(0x0784,0x15bdfd22,0x132ddd0a,0x155d98ed)    R(0x0785,0x1a6e3d99,0x1ade0953,0x1cedf175)    R(0x0786,0x1dae01ec,0x1f3dcdc5,0x205da9f4)    R(0x0787,0x1f4db190,0x1f4d8d5b,0x218d4585)    R(0x0788,0x1f3dcdc5,0x1cde0daf,0x1f4db190)    R(0x0789,0x1f4db190,0x1cedf175,0x1f4d8d5b)\n    R(0x078a,0x1cde0daf,0x1cedf175,0x1f4db190)    R(0x078b,0x1f3dcdc5,0x1f4db190,0x217d69be)    R(0x078c,0x1dae01ec,0x1cde0daf,0x1f3dcdc5)    R(0x078d,0x217d69be,0x1f4db190,0x218d4585)    R(0x078e,0x173e619b,0x147e7597,0x15de455e)    R(0x078f,0x217d69be,0x218d4585,0x23acf1b7)    R(0x0790,0x229d45f3,0x217d69be,0x23acf1b7)    R(0x0791,0x1a6e3d99,0x173e619b,0x18ae3d6c)    R(0x0792,0x1b1e45da,0x189e69ce,0x1a6e3d99)    R(0x0793,0x1b1e45da,0x1a6e3d99,0x1cde0daf)\n    R(0x0794,0x1a6e3d99,0x1cedf175,0x1cde0daf)    R(0x0795,0x1b1e45da,0x1cde0daf,0x1dae01ec)    R(0x0796,0x173e619b,0x15de455e,0x18ae3d6c)    R(0x0797,0x189e69ce,0x173e619b,0x1a6e3d99)    R(0x0798,0x2579e506,0x23f958ed,0x25592119)    R(0x0799,0x39763119,0x3bb65d05,0x3a46b4f0)    R(0x079a,0x15de455e,0x131e6570,0x137e353f)    R(0x079b,0x29097dd6,0x2888ddb5,0x2898ddf5)    R(0x079c,0x23f958ed,0x23e89908,0x25592119)    R(0x079d,0x25baa117,0x246a70f1,0x2579e506)\n    R(0x079e,0x27e98960,0x26d8e547,0x27f8e179)    R(0x079f,0x288a1579,0x272a313c,0x27e98960)    R(0x07a0,0x23bb14f2,0x246a70f1,0x25baa117)    R(0x07a1,0x269bd58a,0x25fba14f,0x277b3d78)    R(0x07a2,0x137e353f,0x132ddd0a,0x15bdfd22)    R(0x07a3,0x272a313c,0x2579e506,0x26b99530)    R(0x07a4,0x24eb5d19,0x23bb14f2,0x25baa117)    R(0x07a5,0x26b99530,0x25592119,0x26d8e547)    R(0x07a6,0x27eaa164,0x272a313c,0x288a1579)    R(0x07a7,0x24eb5d19,0x25baa117,0x269b0141)\n    R(0x07a8,0x269b0141,0x25baa117,0x272a313c)    R(0x07a9,0x27e98960,0x26b99530,0x26d8e547)    R(0x07aa,0x269b0141,0x272a313c,0x27eaa164)    R(0x07ab,0x277b3d78,0x269b0141,0x27eaa164)    R(0x07ac,0x25baa117,0x2579e506,0x272a313c)    R(0x07ad,0x237ccd78,0x232c993f,0x24ec3d61)    R(0x07ae,0x244bf92a,0x229bc4f7,0x24eb5d19)    R(0x07af,0x24ec3d61,0x25fba14f,0x269bd58a)    R(0x07b0,0x2579e506,0x25592119,0x26b99530)    R(0x07b1,0x272a313c,0x26b99530,0x27e98960)\n    R(0x07b2,0x25fba14f,0x24eb5d19,0x269b0141)    R(0x07b3,0x232c993f,0x244bf92a,0x24ec3d61)    R(0x07b4,0x244bf92a,0x24eb5d19,0x25fba14f)    R(0x07b5,0x25fba14f,0x269b0141,0x277b3d78)    R(0x07b6,0x24ec3d61,0x244bf92a,0x25fba14f)    R(0x07b7,0x28c97d97,0x27f8e179,0x2888ddb5)    R(0x07b8,0x292a1df4,0x291a19b5,0x29097dd6)    R(0x07b9,0x229bc4f7,0x23bb14f2,0x24eb5d19)    R(0x07ba,0x23acf1b7,0x254c699d,0x25bc69d6)    R(0x07bb,0x288a1579,0x27e98960,0x28c97d97)\n    R(0x07bc,0x291a19b5,0x288a1579,0x28c97d97)    R(0x07bd,0x277b3d78,0x27eaa164,0x289aad99)    R(0x07be,0x28c97d97,0x27e98960,0x27f8e179)    R(0x07bf,0x281b4def,0x27fb45b2,0x28dab5d5)    R(0x07c0,0x29097dd6,0x28c97d97,0x2888ddb5)    R(0x07c1,0x28dab5d5,0x291a19b5,0x292a1df4)    R(0x07c2,0x27fb45b2,0x289aad99,0x28dab5d5)    R(0x07c3,0x289aad99,0x288a1579,0x291a19b5)    R(0x07c4,0x27fb45b2,0x277b3d78,0x289aad99)    R(0x07c5,0x28dab5d5,0x289aad99,0x291a19b5)\n    R(0x07c6,0x289aad99,0x27eaa164,0x288a1579)    R(0x07c7,0x23acf1b7,0x237ccd78,0x254c699d)    R(0x07c8,0x237ccd78,0x24ec3d61,0x254c699d)    R(0x07c9,0x245cd9f2,0x23acf1b7,0x25bc69d6)    R(0x07ca,0x291a19b5,0x28c97d97,0x29097dd6)    R(0x07cb,0x25bc69d6,0x254c699d,0x26fbddc5)    R(0x07cc,0x254c699d,0x269bd58a,0x26fbddc5)    R(0x07cd,0x26fbddc5,0x269bd58a,0x27fb45b2)    R(0x07ce,0x269bd58a,0x277b3d78,0x27fb45b2)    R(0x07cf,0x26fbddc5,0x27fb45b2,0x281b4def)\n    R(0x07d0,0x254c699d,0x24ec3d61,0x269bd58a)    R(0x07d1,0x26303ed8,0x26203e99,0x23d02ebf)    R(0x07d2,0x39d15400,0x3ae13804,0x3ba1380a)    R(0x07d3,0x27129fff,0x27a21ff2,0x25823bf8)    R(0x07d4,0x00128e26,0x001299f0,0x00031e17)    R(0x07d5,0x0c6f6602,0x0d4fb9e0,0x0e1f59f7)    R(0x07d6,0x21c04edb,0x23d02ebf,0x21b046a3)    R(0x07d7,0x001426b8,0x0004366e,0x0004baa4)    R(0x07d8,0x0064e267,0x00749a34,0x00f56e44)    R(0x07d9,0x23d02ebf,0x23b04681,0x21b046a3)\n    R(0x07da,0x27129fff,0x25823bf8,0x24a2dbf9)    R(0x07db,0x3341fdfe,0x34c1d1c7,0x33a1bdf8)    R(0x07dc,0x37d499f8,0x3934d1d0,0x372445ef)    R(0x07dd,0x0c22c5f0,0x0c1359cc,0x0b0361fb)    R(0x07de,0x0013ee27,0x00031e17,0x0013b5ea)    R(0x07df,0x00f56e44,0x00749a34,0x00c52214)    R(0x07e0,0x1f90da5b,0x2140ce37,0x1fc12626)    R(0x07e1,0x1e90de91,0x1ff09e89,0x1f90da5b)    R(0x07e2,0x1f9343b4,0x20732bd8,0x1f62b7b9)    R(0x07e3,0x1fe09eb8,0x1ff09e89,0x1e90de91)\n    R(0x07e4,0x1f015df5,0x1fc12626,0x211191f2)    R(0x07e5,0x2021d5cf,0x1f015df5,0x211191f2)    R(0x07e6,0x1041eae8,0x10b17ead,0x0e820abb)    R(0x07e7,0x00128e26,0x00031e17,0x0012f64a)    R(0x07e8,0x0004baa4,0x0064e267,0x0065668e)    R(0x07e9,0x0042660a,0x001299f0,0x00128e26)    R(0x07ea,0x0b52e693,0x0aa32a62,0x0a939696)    R(0x07eb,0x0ec1d612,0x1001c1db,0x0e2249e5)    R(0x07ec,0x1ec0faca,0x1d70e2b6,0x1dc122e6)    R(0x07ed,0x1ec0faca,0x1fe09eb8,0x1e90de91)\n    R(0x07ee,0x00826634,0x00128e26,0x0052a651)    R(0x07ef,0x00d269e4,0x005279df,0x00a2520b)    R(0x07f0,0x0aa32a62,0x0b42e628,0x0a638a30)    R(0x07f1,0x0052a651,0x00128e26,0x0012f64a)    R(0x07f2,0x0e820abb,0x10b17ead,0x0eb1c683)    R(0x07f3,0x0cc2aec2,0x0b52e693,0x0ba352c6)    R(0x07f4,0x00a2520b,0x005279df,0x0042660a)    R(0x07f5,0x0d82064f,0x0f918642,0x0ec1d612)    R(0x07f6,0x0d82064f,0x0cb2561e,0x0bc28e59)    R(0x07f7,0x0172560e,0x00d269e4,0x00a2520b)\n    R(0x07f8,0x00826634,0x00a2520b,0x0042660a)    R(0x07f9,0x05d37e11,0x04b2ee12,0x05133637)    R(0x07fa,0x0ec1d612,0x0e2249e5,0x0cb2561e)    R(0x07fb,0x01025a35,0x00a2520b,0x00826634)    R(0x07fc,0x00c28654,0x01025a35,0x00826634)    R(0x07fd,0x020281e6,0x00d269e4,0x0172560e)    R(0x07fe,0x03e2b634,0x03328610,0x02326e36)    R(0x07ff,0x0d82064f,0x0ec1d612,0x0cb2561e)    R(0x0800,0x03328610,0x020281e6,0x0172560e)    R(0x0801,0x03328610,0x0172560e,0x02326e36)\n    R(0x0802,0x02326e36,0x0172560e,0x01025a35)    R(0x0803,0x02326e36,0x01025a35,0x01827a50)    R(0x0804,0x0172560e,0x00a2520b,0x01025a35)    R(0x0805,0x03d2d1e7,0x020281e6,0x03328610)    R(0x0806,0x0b42e628,0x0c22c5f0,0x0b0361fb)    R(0x0807,0x0bc28e59,0x0cb2561e,0x0b42e628)    R(0x0808,0x04b2ee12,0x03328610,0x03e2b634)    R(0x0809,0x05133637,0x03e2b634,0x03f30e54)    R(0x080a,0x05133637,0x04b2ee12,0x03e2b634)    R(0x080b,0x03e2b634,0x02326e36,0x02c2a64f)\n    R(0x080c,0x04b2ee12,0x03d2d1e7,0x03328610)    R(0x080d,0x0cb2561e,0x0c22c5f0,0x0b42e628)    R(0x080e,0x0eb1c683,0x0f918642,0x0d82064f)    R(0x080f,0x0cc2aec2,0x0e820abb,0x0ce2568b)    R(0x0810,0x0cb2561e,0x0e2249e5,0x0c22c5f0)    R(0x0811,0x0052a651,0x0012f64a,0x00433e73)    R(0x0812,0x02531a6f,0x0122da6b,0x01537e8e)    R(0x0813,0x01827a50,0x01025a35,0x00c28654)    R(0x0814,0x00c28654,0x00826634,0x0052a651)    R(0x0815,0x00c28654,0x0052a651,0x0082fa70)\n    R(0x0816,0x0cc2aec2,0x0ce2568b,0x0b52e693)    R(0x0817,0x0e820abb,0x0eb1c683,0x0ce2568b)    R(0x0818,0x02c2a64f,0x01827a50,0x0122da6b)    R(0x0819,0x02c2a64f,0x02326e36,0x01827a50)    R(0x081a,0x0ce2568b,0x0bc28e59,0x0b52e693)    R(0x081b,0x0122da6b,0x00c28654,0x0082fa70)    R(0x081c,0x0122da6b,0x01827a50,0x00c28654)    R(0x081d,0x0082fa70,0x0052a651,0x00433e73)    R(0x081e,0x0122da6b,0x0082fa70,0x00c35a88)    R(0x081f,0x054359e6,0x03d2d1e7,0x04b2ee12)\n    R(0x0820,0x0b52e693,0x0bc28e59,0x0aa32a62)    R(0x0821,0x0ce2568b,0x0eb1c683,0x0d82064f)    R(0x0822,0x02531a6f,0x02c2a64f,0x0122da6b)    R(0x0823,0x0bc28e59,0x0b42e628,0x0aa32a62)    R(0x0824,0x03f30e54,0x02c2a64f,0x02531a6f)    R(0x0825,0x0ce2568b,0x0d82064f,0x0bc28e59)    R(0x0826,0x03f30e54,0x03e2b634,0x02c2a64f)    R(0x0827,0x10d1520b,0x121165db,0x1001c1db)    R(0x0828,0x0042660a,0x005279df,0x001299f0)    R(0x0829,0x1f015df5,0x1da0fe1d,0x1fc12626)\n    R(0x082a,0x1680a26a,0x1870ae48,0x15d0ba2c)    R(0x082b,0x1b80e6e2,0x1d70e2b6,0x1ab0aeaf)    R(0x082c,0x0ec1d612,0x10d1520b,0x1001c1db)    R(0x082d,0x1680a26a,0x15d0ba2c,0x1430d254)    R(0x082e,0x1e20e252,0x1f90da5b,0x1fc12626)    R(0x082f,0x12910686,0x1430d254,0x11d11a43)    R(0x0830,0x1370fe13,0x144129dd,0x121165db)    R(0x0831,0x00826634,0x0042660a,0x00128e26)    R(0x0832,0x1860c214,0x1650e9f7,0x15d0ba2c)    R(0x0833,0x1430d254,0x1370fe13,0x11d11a43)\n    R(0x0834,0x1870ae48,0x1860c214,0x15d0ba2c)    R(0x0835,0x18d10ddc,0x1650e9f7,0x1860c214)    R(0x0836,0x1da0fe1d,0x1b50be42,0x1e20e252)    R(0x0837,0x1650e9f7,0x1370fe13,0x15d0ba2c)    R(0x0838,0x18d10ddc,0x1860c214,0x1ae0e209)    R(0x0839,0x1b50be42,0x1860c214,0x1870ae48)    R(0x083a,0x1ae0e209,0x1b50be42,0x1da0fe1d)    R(0x083b,0x15d0ba2c,0x1370fe13,0x1430d254)    R(0x083c,0x0f918642,0x10d1520b,0x0ec1d612)    R(0x083d,0x10d1520b,0x1370fe13,0x121165db)\n    R(0x083e,0x1ae0e209,0x1860c214,0x1b50be42)    R(0x083f,0x1e20e252,0x1b50be42,0x1ca0c280)    R(0x0840,0x1da0fe1d,0x1e20e252,0x1fc12626)    R(0x0841,0x0f918642,0x11d11a43,0x10d1520b)    R(0x0842,0x1c6131e6,0x1ae0e209,0x1da0fe1d)    R(0x0843,0x11d11a43,0x1370fe13,0x10d1520b)    R(0x0844,0x1c6131e6,0x1da0fe1d,0x1f015df5)    R(0x0845,0x10915272,0x11d11a43,0x0f918642)    R(0x0846,0x17c0a6a1,0x19c0a27a,0x1680a26a)    R(0x0847,0x1b80e6e2,0x1ab0aeaf,0x18c0c6d7)\n    R(0x0848,0x1e90de91,0x1f90da5b,0x1e20e252)    R(0x0849,0x1650e9f7,0x144129dd,0x1370fe13)    R(0x084a,0x10b17ead,0x10915272,0x0eb1c683)    R(0x084b,0x18c0c6d7,0x1ab0aeaf,0x17c0a6a1)    R(0x084c,0x1520c690,0x1430d254,0x12910686)    R(0x084d,0x1680a26a,0x1430d254,0x1520c690)    R(0x084e,0x18c0c6d7,0x17c0a6a1,0x1620d2c9)    R(0x084f,0x1ca0c280,0x1b50be42,0x19c0a27a)    R(0x0850,0x1e90de91,0x1ca0c280,0x1d70e2b6)    R(0x0851,0x1ab0aeaf,0x19c0a27a,0x17c0a6a1)\n    R(0x0852,0x17c0a6a1,0x1520c690,0x1620d2c9)    R(0x0853,0x1d70e2b6,0x1ca0c280,0x1ab0aeaf)    R(0x0854,0x19c0a27a,0x1870ae48,0x1680a26a)    R(0x0855,0x1e90de91,0x1e20e252,0x1ca0c280)    R(0x0856,0x0eb1c683,0x10915272,0x0f918642)    R(0x0857,0x12216edf,0x138112be,0x10b17ead)    R(0x0858,0x17c0a6a1,0x1680a26a,0x1520c690)    R(0x0859,0x1ec0faca,0x1e90de91,0x1d70e2b6)    R(0x085a,0x138112be,0x12910686,0x10b17ead)    R(0x085b,0x138112be,0x1520c690,0x12910686)\n    R(0x085c,0x1620d2c9,0x1520c690,0x138112be)    R(0x085d,0x12910686,0x11d11a43,0x10915272)    R(0x085e,0x1ab0aeaf,0x1ca0c280,0x19c0a27a)    R(0x085f,0x10b17ead,0x12910686,0x10915272)    R(0x0860,0x00038a55,0x00031e17,0x0013ee27)    R(0x0861,0x0024aae7,0x001426b8,0x0004baa4)    R(0x0862,0x0024aae7,0x0004baa4,0x00355ecd)    R(0x0863,0x0963c201,0x0953c1d8,0x0803c1fe)    R(0x0864,0x1b50be42,0x1870ae48,0x19c0a27a)    R(0x0865,0x0013ee27,0x0013b5ea,0x00347df4)\n    R(0x0866,0x0673a5f4,0x054359e6,0x05d37e11)    R(0x0867,0x00c52214,0x00347df4,0x005559e8)    R(0x0868,0x0004366e,0x0013ee27,0x00749a34)    R(0x0869,0x06c49a5c,0x0584425a,0x0534a677)    R(0x086a,0x0122da6b,0x00c35a88,0x01537e8e)    R(0x086b,0x03240ebc,0x0193deb3,0x0263bee3)    R(0x086c,0x05d37e11,0x054359e6,0x04b2ee12)    R(0x086d,0x00433e73,0x00038a55,0x0023ca89)    R(0x086e,0x001426b8,0x0023ca89,0x0004366e)    R(0x086f,0x00749a34,0x00347df4,0x00c52214)\n    R(0x0870,0x0674d676,0x0534a677,0x0594c299)    R(0x0871,0x02531a6f,0x01537e8e,0x0283b689)    R(0x0872,0x00639691,0x00433e73,0x0023ca89)    R(0x0873,0x0082fa70,0x00433e73,0x00639691)    R(0x0874,0x0283b689,0x01537e8e,0x0133d2a0)    R(0x0875,0x05d3c636,0x05133637,0x0453ae62)    R(0x0876,0x0584425a,0x05d3c636,0x0453ae62)    R(0x0877,0x0453ae62,0x02531a6f,0x0283b689)    R(0x0878,0x0453ae62,0x0283b689,0x03c43283)    R(0x0879,0x01537e8e,0x00c35a88,0x00b3b69e)\n    R(0x087a,0x03c43283,0x0283b689,0x0253fe9d)    R(0x087b,0x0004baa4,0x0004366e,0x0064e267)    R(0x087c,0x0013ee27,0x00347df4,0x00749a34)    R(0x087d,0x00c35a88,0x0082fa70,0x00639691)    R(0x087e,0x0594c299,0x0534a677,0x04046e99)    R(0x087f,0x0453ae62,0x03f30e54,0x02531a6f)    R(0x0880,0x0534a677,0x03c43283,0x04046e99)    R(0x0881,0x0453ae62,0x05133637,0x03f30e54)    R(0x0882,0x0584425a,0x0453ae62,0x03c43283)    R(0x0883,0x0584425a,0x03c43283,0x0534a677)\n    R(0x0884,0x0004366e,0x00749a34,0x0064e267)    R(0x0885,0x05d3c636,0x05d37e11,0x05133637)    R(0x0886,0x0193deb3,0x0113aad5,0x0263bee3)    R(0x0887,0x0043d6aa,0x0023ca89,0x001426b8)    R(0x0888,0x06b4d6c8,0x0594c299,0x051486c8)    R(0x0889,0x00c3caac,0x0083b6ca,0x0113aad5)    R(0x088a,0x0073caa6,0x00639691,0x0043d6aa)    R(0x088b,0x00639691,0x0023ca89,0x0043d6aa)    R(0x088c,0x0083b6ca,0x0043d6aa,0x0043ceda)    R(0x088d,0x00b3b69e,0x00c35a88,0x00639691)\n    R(0x088e,0x0193deb3,0x00c3caac,0x0113aad5)    R(0x088f,0x0073caa6,0x0043d6aa,0x0083b6ca)    R(0x0890,0x00b3b69e,0x0073caa6,0x00c3caac)    R(0x0891,0x0133d2a0,0x00b3b69e,0x00c3caac)    R(0x0892,0x00c3caac,0x0073caa6,0x0083b6ca)    R(0x0893,0x0133d2a0,0x00c3caac,0x0193deb3)    R(0x0894,0x0043ceda,0x0043d6aa,0x001426b8)    R(0x0895,0x0133d2a0,0x01537e8e,0x00b3b69e)    R(0x0896,0x04046e99,0x03c43283,0x0253fe9d)    R(0x0897,0x0594c299,0x04046e99,0x051486c8)\n    R(0x0898,0x0253fe9d,0x0283b689,0x0133d2a0)    R(0x0899,0x03240ebc,0x0253fe9d,0x0193deb3)    R(0x089a,0x04046e99,0x0253fe9d,0x03240ebc)    R(0x089b,0x00b3b69e,0x00639691,0x0073caa6)    R(0x089c,0x051486c8,0x04046e99,0x03240ebc)    R(0x089d,0x0253fe9d,0x0133d2a0,0x0193deb3)    R(0x089e,0x0ad3a9de,0x0953c1d8,0x0963c201)    R(0x089f,0x0b42e628,0x0b0361fb,0x0a638a30)    R(0x08a0,0x00433e73,0x0012f64a,0x00038a55)    R(0x08a1,0x0ba352c6,0x0b52e693,0x0a939696)\n    R(0x08a2,0x08b4d29a,0x0754da97,0x0864e6c9)    R(0x08a3,0x0a04dacc,0x09b4b29d,0x08b4d29a)    R(0x08a4,0x0aa32a62,0x0a638a30,0x09f3e263)    R(0x08a5,0x0a638a30,0x0b0361fb,0x0a23b20f)    R(0x08a6,0x0803c1fe,0x0793bddb,0x0673a5f4)    R(0x08a7,0x06f4123a,0x05d3c636,0x0584425a)    R(0x08a8,0x07f4ca69,0x0914624d,0x08245246)    R(0x08a9,0x0a638a30,0x0a23b20f,0x09c3fa3a)    R(0x08aa,0x06d3c618,0x05d37e11,0x05d3c636)    R(0x08ab,0x06f4123a,0x06d3c618,0x05d3c636)\n    R(0x08ac,0x0833ea21,0x0803c1fe,0x06d3c618)    R(0x08ad,0x09f3e263,0x0a638a30,0x09c3fa3a)    R(0x08ae,0x0833ea21,0x0963c201,0x0803c1fe)    R(0x08af,0x0943f228,0x0963c201,0x0833ea21)    R(0x08b0,0x0a23b20f,0x0963c201,0x0943f228)    R(0x08b1,0x09c3fa3a,0x0a23b20f,0x0943f228)    R(0x08b2,0x0833ea21,0x06d3c618,0x06f4123a)    R(0x08b3,0x06c49a5c,0x06f4123a,0x0584425a)    R(0x08b4,0x07f4ca69,0x08245246,0x06c49a5c)    R(0x08b5,0x0b0361fb,0x0ad3a9de,0x0a23b20f)\n    R(0x08b6,0x08245246,0x0833ea21,0x06f4123a)    R(0x08b7,0x08245246,0x0943f228,0x0833ea21)    R(0x08b8,0x0914624d,0x0943f228,0x08245246)    R(0x08b9,0x09c3fa3a,0x0943f228,0x0914624d)    R(0x08ba,0x09846e66,0x09c3fa3a,0x0914624d)    R(0x08bb,0x09f3e263,0x09c3fa3a,0x09846e66)    R(0x08bc,0x08245246,0x06f4123a,0x06c49a5c)    R(0x08bd,0x0a939696,0x0aa32a62,0x09f3e263)    R(0x08be,0x0ba352c6,0x0a939696,0x0b141ac5)    R(0x08bf,0x0a23b20f,0x0ad3a9de,0x0963c201)\n    R(0x08c0,0x0023ca89,0x00038a55,0x0004366e)    R(0x08c1,0x0ad4aac9,0x09b4b29d,0x0a04dacc)    R(0x08c2,0x0a04dacc,0x08b4d29a,0x0864e6c9)    R(0x08c3,0x06c49a5c,0x0534a677,0x0674d676)    R(0x08c4,0x08f4ba70,0x0914624d,0x07f4ca69)    R(0x08c5,0x0a939696,0x09f3e263,0x0a045296)    R(0x08c6,0x0ad4aac9,0x0a045296,0x09b4b29d)    R(0x08c7,0x0b141ac5,0x0a939696,0x0a045296)    R(0x08c8,0x0a045296,0x09f3e263,0x09846e66)    R(0x08c9,0x09846e66,0x0914624d,0x08f4ba70)\n    R(0x08ca,0x09b4b29d,0x09846e66,0x08f4ba70)    R(0x08cb,0x0a045296,0x09846e66,0x09b4b29d)    R(0x08cc,0x0b141ac5,0x0a045296,0x0ad4aac9)    R(0x08cd,0x06d3c618,0x0673a5f4,0x05d37e11)    R(0x08ce,0x0754da97,0x0674d676,0x0594c299)    R(0x08cf,0x0864e6c9,0x0754da97,0x06b4d6c8)    R(0x08d0,0x09b4b29d,0x08f4ba70,0x08b4d29a)    R(0x08d1,0x0803c1fe,0x0673a5f4,0x06d3c618)    R(0x08d2,0x07f4ca69,0x0674d676,0x0754da97)    R(0x08d3,0x0754da97,0x0594c299,0x06b4d6c8)\n    R(0x08d4,0x08b4d29a,0x07f4ca69,0x0754da97)    R(0x08d5,0x08b4d29a,0x08f4ba70,0x07f4ca69)    R(0x08d6,0x07f4ca69,0x06c49a5c,0x0674d676)    R(0x08d7,0x2020baee,0x1fe09eb8,0x1ec0faca)    R(0x08d8,0x1c6131e6,0x18d10ddc,0x1ae0e209)    R(0x08d9,0x1f62b7b9,0x20732bd8,0x20c293d5)    R(0x08da,0x2103eb79,0x20039b96,0x1f336b6c)    R(0x08db,0x0053bb0b,0x0043ceda,0x00140efe)    R(0x08dc,0x1b956f59,0x1da4af58,0x1b14bb6e)    R(0x08dd,0x0113aad5,0x0083b6ca,0x00b39f00)\n    R(0x08de,0x12216edf,0x10b17ead,0x1041eae8)    R(0x08df,0x1ab40b79,0x1c93636a,0x1a13577b)    R(0x08e0,0x20910728,0x2020baee,0x1f114303)    R(0x08e1,0x1f62b7b9,0x20c293d5,0x1fb20fbd)    R(0x08e2,0x20039b96,0x20d39fcb,0x1f9343b4)    R(0x08e3,0x0e727ef2,0x0e820abb,0x0cc2aec2)    R(0x08e4,0x18c0c6d7,0x1620d2c9,0x1700f6f7)    R(0x08e5,0x0193a309,0x00b39f00,0x00e3af28)    R(0x08e6,0x19c18f32,0x1be1470f,0x19510f08)    R(0x08e7,0x1133fb67,0x11d34763,0x0fa37749)\n    R(0x08e8,0x15a3cb8a,0x1513177a,0x13739f7b)    R(0x08e9,0x19510f08,0x1b80e6e2,0x18c0c6d7)    R(0x08ea,0x0e727ef2,0x1041eae8,0x0e820abb)    R(0x08eb,0x0ee2ef24,0x0e727ef2,0x0d3326f7)    R(0x08ec,0x0fa37749,0x10e2c745,0x0ee2ef24)    R(0x08ed,0x0dd3a725,0x0ee2ef24,0x0d3326f7)    R(0x08ee,0x14b146fa,0x138112be,0x12216edf)    R(0x08ef,0x1271c314,0x1041eae8,0x10724f1c)    R(0x08f0,0x1271c314,0x12216edf,0x1041eae8)    R(0x08f1,0x16f1db43,0x1721571f,0x1491b32d)\n    R(0x08f2,0x19c18f32,0x1721571f,0x16f1db43)    R(0x08f3,0x19c18f32,0x19510f08,0x1721571f)    R(0x08f4,0x1721571f,0x14b146fa,0x1491b32d)    R(0x08f5,0x14b146fa,0x12216edf,0x1271c314)    R(0x08f6,0x1491b32d,0x1271c314,0x12a22f3f)    R(0x08f7,0x1491b32d,0x14b146fa,0x1271c314)    R(0x08f8,0x0fa37749,0x0ee2ef24,0x0dd3a725)    R(0x08f9,0x1700f6f7,0x1620d2c9,0x14b146fa)    R(0x08fa,0x19510f08,0x1700f6f7,0x1721571f)    R(0x08fb,0x19510f08,0x18c0c6d7,0x1700f6f7)\n    R(0x08fc,0x12a22f3f,0x10724f1c,0x10e2c745)    R(0x08fd,0x12a22f3f,0x1271c314,0x10724f1c)    R(0x08fe,0x0ee2ef24,0x10724f1c,0x0e727ef2)    R(0x08ff,0x1721571f,0x1700f6f7,0x14b146fa)    R(0x0900,0x10724f1c,0x1041eae8,0x0e727ef2)    R(0x0901,0x10e2c745,0x10724f1c,0x0ee2ef24)    R(0x0902,0x14b146fa,0x1620d2c9,0x138112be)    R(0x0903,0x1b523750,0x19c18f32,0x18c22756)    R(0x0904,0x0d3326f7,0x0e727ef2,0x0cc2aec2)    R(0x0905,0x17733782,0x1513177a,0x15a3cb8a)\n    R(0x0906,0x13739f7b,0x11d34763,0x1133fb67)    R(0x0907,0x18c22756,0x16f1db43,0x16b2936e)    R(0x0908,0x1362b762,0x12a22f3f,0x10e2c745)    R(0x0909,0x16f1db43,0x1491b32d,0x14d23756)    R(0x090a,0x1982bf6f,0x16b2936e,0x17733782)    R(0x090b,0x1982bf6f,0x1b523750,0x18c22756)    R(0x090c,0x14d23756,0x12a22f3f,0x1362b762)    R(0x090d,0x16b2936e,0x16f1db43,0x14d23756)    R(0x090e,0x16b2936e,0x14d23756,0x1362b762)    R(0x090f,0x1982bf6f,0x18c22756,0x16b2936e)\n    R(0x0910,0x16b2936e,0x1362b762,0x1513177a)    R(0x0911,0x11d34763,0x10e2c745,0x0fa37749)    R(0x0912,0x14d23756,0x1491b32d,0x12a22f3f)    R(0x0913,0x17f3ef87,0x17733782,0x15a3cb8a)    R(0x0914,0x18c22756,0x19c18f32,0x16f1db43)    R(0x0915,0x1a13577b,0x17733782,0x17f3ef87)    R(0x0916,0x17733782,0x16b2936e,0x1513177a)    R(0x0917,0x1513177a,0x1362b762,0x11d34763)    R(0x0918,0x1513177a,0x11d34763,0x13739f7b)    R(0x0919,0x1362b762,0x10e2c745,0x11d34763)\n    R(0x091a,0x1a13577b,0x1982bf6f,0x17733782)    R(0x091b,0x0d3326f7,0x0cc2aec2,0x0ba352c6)    R(0x091c,0x1be1470f,0x1dc122e6,0x1b80e6e2)    R(0x091d,0x0193a309,0x0113aad5,0x00b39f00)    R(0x091e,0x1fc3e350,0x1ee3675f,0x1e939b5b)    R(0x091f,0x20513396,0x20d10361,0x1fa16b62)    R(0x0920,0x1ec25792,0x1fb20fbd,0x1f51af97)    R(0x0921,0x1f114303,0x1ec0faca,0x1dc122e6)    R(0x0922,0x1f41a736,0x20910728,0x1f114303)    R(0x0923,0x1c52cb63,0x1b523750,0x1982bf6f)\n    R(0x0924,0x0dd3a725,0x0d3326f7,0x0c53def8)    R(0x0925,0x1fa16b62,0x20910728,0x1f41a736)    R(0x0926,0x1cb1cb31,0x1df17b10,0x1be1470f)    R(0x0927,0x1b523750,0x1cb1cb31,0x19c18f32)    R(0x0928,0x1d524b4d,0x1e51d72f,0x1cb1cb31)    R(0x0929,0x1e51d72f,0x1f114303,0x1df17b10)    R(0x092a,0x1ec20763,0x1f41a736,0x1e323b4f)    R(0x092b,0x1ec20763,0x1fa16b62,0x1f41a736)    R(0x092c,0x1e323b4f,0x1f41a736,0x1e51d72f)    R(0x092d,0x1e51d72f,0x1df17b10,0x1cb1cb31)\n    R(0x092e,0x1f41a736,0x1f114303,0x1e51d72f)    R(0x092f,0x1cb1cb31,0x1be1470f,0x19c18f32)    R(0x0930,0x1c52cb63,0x1d524b4d,0x1b523750)    R(0x0931,0x1df17b10,0x1dc122e6,0x1be1470f)    R(0x0932,0x1e42936b,0x1e323b4f,0x1db2ab62)    R(0x0933,0x1f114303,0x1dc122e6,0x1df17b10)    R(0x0934,0x1ee3675f,0x1dd30f63,0x1e939b5b)    R(0x0935,0x1e323b4f,0x1e51d72f,0x1d524b4d)    R(0x0936,0x1db2ab62,0x1d524b4d,0x1c52cb63)    R(0x0937,0x1d524b4d,0x1cb1cb31,0x1b523750)\n    R(0x0938,0x1e42936b,0x1ec20763,0x1e323b4f)    R(0x0939,0x1db2ab62,0x1e323b4f,0x1d524b4d)    R(0x093a,0x1be1470f,0x1b80e6e2,0x19510f08)    R(0x093b,0x1f51af97,0x20513396,0x1fa16b62)    R(0x093c,0x1fb20fbd,0x205187bb,0x1f51af97)    R(0x093d,0x0d3326f7,0x0ba352c6,0x0c53def8)    R(0x093e,0x1f51af97,0x205187bb,0x20513396)    R(0x093f,0x1ec25792,0x1f51af97,0x1ec20763)    R(0x0940,0x1a13577b,0x1c52cb63,0x1982bf6f)    R(0x0941,0x1dd30f63,0x1db2ab62,0x1c52cb63)\n    R(0x0942,0x1ec25792,0x1ec20763,0x1e42936b)    R(0x0943,0x1f62b7b9,0x1fb20fbd,0x1ec25792)    R(0x0944,0x1ec2f385,0x1e42936b,0x1e62f369)    R(0x0945,0x1e62f369,0x1db2ab62,0x1dd30f63)    R(0x0946,0x1ec2f385,0x1ec25792,0x1e42936b)    R(0x0947,0x1ec2f385,0x1f62b7b9,0x1ec25792)    R(0x0948,0x1ec2f385,0x1f9343b4,0x1f62b7b9)    R(0x0949,0x1e62f369,0x1e42936b,0x1db2ab62)    R(0x094a,0x1c93636a,0x1c52cb63,0x1a13577b)    R(0x094b,0x1f51af97,0x1fa16b62,0x1ec20763)\n    R(0x094c,0x20039b96,0x1f9343b4,0x1ec2f385)    R(0x094d,0x2043db59,0x1f336b6c,0x1ee3675f)    R(0x094e,0x1f336b6c,0x1ec2f385,0x1e62f369)    R(0x094f,0x1f336b6c,0x1e62f369,0x1ee3675f)    R(0x0950,0x1dd30f63,0x1c52cb63,0x1c93636a)    R(0x0951,0x1f336b6c,0x20039b96,0x1ec2f385)    R(0x0952,0x1e939b5b,0x1dd30f63,0x1c93636a)    R(0x0953,0x1ee3675f,0x1e62f369,0x1dd30f63)    R(0x0954,0x00140efe,0x001426b8,0x0024aae7)    R(0x0955,0x13b4f376,0x1114b765,0x12556f62)\n    R(0x0956,0x15a3cb8a,0x13739f7b,0x1374437b)    R(0x0957,0x1dc122e6,0x1d70e2b6,0x1b80e6e2)    R(0x0958,0x1f114303,0x2020baee,0x1ec0faca)    R(0x0959,0x2104673c,0x1fc3e350,0x1fa44b44)    R(0x095a,0x051486c8,0x03240ebc,0x0413faf4)    R(0x095b,0x0664def0,0x051486c8,0x055466fe)    R(0x095c,0x00454b0f,0x0024aae7,0x00355ecd)    R(0x095d,0x00b39f00,0x0083b6ca,0x0053bb0b)    R(0x095e,0x0124ef7f,0x00849775,0x00750b73)    R(0x095f,0x0263bee3,0x0113aad5,0x0193a309)\n    R(0x0960,0x00b39f00,0x0073cb34,0x00e3af28)    R(0x0961,0x0073cb34,0x0053bb0b,0x00240b37)    R(0x0962,0x03240ebc,0x0263bee3,0x0413faf4)    R(0x0963,0x00352b50,0x00348b60,0x0024932c)    R(0x0964,0x0024932c,0x0024aae7,0x00454b0f)    R(0x0965,0x06452f22,0x05d4b322,0x0574df48)    R(0x0966,0x00542359,0x0073cb34,0x00240b37)    R(0x0967,0x00b39f00,0x0053bb0b,0x0073cb34)    R(0x0968,0x0413faf4,0x0263bee3,0x0333cf1a)    R(0x0969,0x04a4232a,0x0413faf4,0x0333cf1a)\n    R(0x096a,0x01e3cf39,0x00e3af28,0x00d3eb4d)    R(0x096b,0x0193a309,0x00e3af28,0x01e3cf39)    R(0x096c,0x0333cf1a,0x01e3cf39,0x03741347)    R(0x096d,0x00d3eb4d,0x0073cb34,0x00542359)    R(0x096e,0x00e3af28,0x0073cb34,0x00d3eb4d)    R(0x096f,0x00352b50,0x0024932c,0x00454b0f)    R(0x0970,0x0083b6ca,0x0043ceda,0x0053bb0b)    R(0x0971,0x0333cf1a,0x0193a309,0x01e3cf39)    R(0x0972,0x05d4b322,0x04a4232a,0x04b46b50)    R(0x0973,0x04a4232a,0x0333cf1a,0x03741347)\n    R(0x0974,0x04a4232a,0x03741347,0x04b46b50)    R(0x0975,0x055466fe,0x0413faf4,0x04a4232a)    R(0x0976,0x0333cf1a,0x0263bee3,0x0193a309)    R(0x0977,0x05d4b322,0x055466fe,0x04a4232a)    R(0x0978,0x05d4b322,0x04b46b50,0x0574df48)    R(0x0979,0x01e3cf39,0x00d3eb4d,0x01c41f5e)    R(0x097a,0x00542359,0x00240b37,0x00348b60)    R(0x097b,0x051486c8,0x0413faf4,0x055466fe)    R(0x097c,0x0574df48,0x04b46b50,0x0404c76c)    R(0x097d,0x01748b78,0x00849775,0x0124ef7f)\n    R(0x097e,0x0264db7e,0x0124ef7f,0x01c5437c)    R(0x097f,0x00849775,0x00542359,0x00348b60)    R(0x0980,0x01c41f5e,0x00d3eb4d,0x00c43f68)    R(0x0981,0x0264db7e,0x03146f6a,0x01748b78)    R(0x0982,0x04b46b50,0x03741347,0x03146f6a)    R(0x0983,0x01748b78,0x01c41f5e,0x00c43f68)    R(0x0984,0x03146f6a,0x01c41f5e,0x01748b78)    R(0x0985,0x01748b78,0x00c43f68,0x00849775)    R(0x0986,0x00c43f68,0x00542359,0x00849775)    R(0x0987,0x04b46b50,0x03146f6a,0x0404c76c)\n    R(0x0988,0x00750b73,0x00348b60,0x00352b50)    R(0x0989,0x0264db7e,0x01748b78,0x0124ef7f)    R(0x098a,0x03741347,0x01e3cf39,0x01c41f5e)    R(0x098b,0x03353b75,0x0404c76c,0x0264db7e)    R(0x098c,0x0574df48,0x0404c76c,0x04a52f5e)    R(0x098d,0x03741347,0x01c41f5e,0x03146f6a)    R(0x098e,0x0404c76c,0x03146f6a,0x0264db7e)    R(0x098f,0x00849775,0x00348b60,0x00750b73)    R(0x0990,0x04a52f5e,0x0404c76c,0x03353b75)    R(0x0991,0x00c43f68,0x00d3eb4d,0x00542359)\n    R(0x0992,0x0c53def8,0x0ba352c6,0x0b141ac5)    R(0x0993,0x00140efe,0x0043ceda,0x001426b8)    R(0x0994,0x1114b765,0x0ea4e73c,0x1045634e)    R(0x0995,0x2043db59,0x2103eb79,0x1f336b6c)    R(0x0996,0x16047385,0x15a3cb8a,0x1374437b)    R(0x0997,0x0b550ef5,0x0ad4aac9,0x0a04dacc)    R(0x0998,0x0f243349,0x0fa37749,0x0dd3a725)    R(0x0999,0x00240b37,0x0053bb0b,0x00140efe)    R(0x099a,0x0c53def8,0x0b141ac5,0x0be49ef3)    R(0x099b,0x1114b765,0x0f243349,0x0ea4e73c)\n    R(0x099c,0x1ff4df33,0x1fa44b44,0x1da4af58)    R(0x099d,0x1ff4df33,0x1da4af58,0x1e155344)    R(0x099e,0x0024932c,0x00140efe,0x0024aae7)    R(0x099f,0x00348b60,0x00240b37,0x0024932c)    R(0x09a0,0x06b4d6c8,0x051486c8,0x0664def0)    R(0x09a1,0x0cb51714,0x0d446721,0x0be49ef3)    R(0x09a2,0x0dd3a725,0x0c53def8,0x0d446721)    R(0x09a3,0x0f243349,0x0dd3a725,0x0d446721)    R(0x09a4,0x0d446721,0x0c53def8,0x0be49ef3)    R(0x09a5,0x0664def0,0x055466fe,0x05d4b322)\n    R(0x09a6,0x0f243349,0x0d446721,0x0ea4e73c)    R(0x09a7,0x0024932c,0x00240b37,0x00140efe)    R(0x09a8,0x06e52b08,0x05d4b322,0x06452f22)    R(0x09a9,0x07950aeb,0x06b4d6c8,0x0664def0)    R(0x09aa,0x0ea4e73c,0x0d446721,0x0cb51714)    R(0x09ab,0x07950aeb,0x0664def0,0x06e52b08)    R(0x09ac,0x097516ed,0x0864e6c9,0x07950aeb)    R(0x09ad,0x0b550ef5,0x0a04dacc,0x097516ed)    R(0x09ae,0x0be49ef3,0x0ad4aac9,0x0b550ef5)    R(0x09af,0x0cb51714,0x0be49ef3,0x0b550ef5)\n    R(0x09b0,0x06e52b08,0x0664def0,0x05d4b322)    R(0x09b1,0x2043db59,0x1ee3675f,0x1fc3e350)    R(0x09b2,0x1ab40b79,0x1a13577b,0x17f3ef87)    R(0x09b3,0x17f3ef87,0x15a3cb8a,0x16047385)    R(0x09b4,0x0be49ef3,0x0b141ac5,0x0ad4aac9)    R(0x09b5,0x1b14bb6e,0x18549b82,0x18d5476e)    R(0x09b6,0x0864e6c9,0x06b4d6c8,0x07950aeb)    R(0x09b7,0x1114b765,0x1133fb67,0x0f243349)    R(0x09b8,0x18549b82,0x17f3ef87,0x16047385)    R(0x09b9,0x1b14bb6e,0x1ab40b79,0x18549b82)\n    R(0x09ba,0x1e939b5b,0x1c93636a,0x1d640f64)    R(0x09bb,0x1fa44b44,0x1d640f64,0x1da4af58)    R(0x09bc,0x1374437b,0x13739f7b,0x1133fb67)    R(0x09bd,0x1b14bb6e,0x1d640f64,0x1ab40b79)    R(0x09be,0x1374437b,0x1133fb67,0x1114b765)    R(0x09bf,0x1ab40b79,0x17f3ef87,0x18549b82)    R(0x09c0,0x1fa44b44,0x1e939b5b,0x1d640f64)    R(0x09c1,0x0a04dacc,0x0864e6c9,0x097516ed)    R(0x09c2,0x16047385,0x1374437b,0x13b4f376)    R(0x09c3,0x18d5476e,0x18549b82,0x16253377)\n    R(0x09c4,0x1d640f64,0x1c93636a,0x1ab40b79)    R(0x09c5,0x1fc3e350,0x1e939b5b,0x1fa44b44)    R(0x09c6,0x16253377,0x18549b82,0x16047385)    R(0x09c7,0x13b4f376,0x1374437b,0x1114b765)    R(0x09c8,0x1133fb67,0x0fa37749,0x0f243349)    R(0x09c9,0x1da4af58,0x1d640f64,0x1b14bb6e)    R(0x09ca,0x16253377,0x16047385,0x13b4f376)    R(0x09cb,0x31414a04,0x32f141e3,0x323119cd)    R(0x09cc,0x3744ce0b,0x38e551e9,0x392511e2)    R(0x09cd,0x00031e17,0x000309dc,0x0013b5ea)\n    R(0x09ce,0x23d02ebf,0x26203e99,0x23b04681)    R(0x09cf,0x29a277e7,0x27a21ff2,0x27129fff)    R(0x09d0,0x2754cdee,0x272455d5,0x28147df9)    R(0x09d1,0x26303ed8,0x28705ab1,0x26203e99)    R(0x09d2,0x302145f4,0x31414a04,0x323119cd)    R(0x09d3,0x001299f0,0x000309dc,0x00031e17)    R(0x09d4,0x322392ad,0x3242deb3,0x321362e7)    R(0x09d5,0x3744ce0b,0x392511e2,0x37d499f8)    R(0x09d6,0x37352205,0x38e551e9,0x3744ce0b)    R(0x09d7,0x0012f64a,0x00031e17,0x00038a55)\n    R(0x09d8,0x21c04edb,0x21b046a3,0x1fe09eb8)    R(0x09d9,0x26203e99,0x2620665b,0x23b04681)    R(0x09da,0x2be301dc,0x2e8311f6,0x2cb3a1f2)    R(0x09db,0x30d2a5f4,0x321271d8,0x32125a0d)    R(0x09dc,0x32720627,0x33a1bdf8,0x3261b623)    R(0x09dd,0x2b01ede0,0x2bf175f8,0x2c41d1df)    R(0x09de,0x2e8311f6,0x30232a06,0x2e8361f8)    R(0x09df,0x2ea0f653,0x30b15231,0x2f613a22)    R(0x09e0,0x1f90da5b,0x21a07668,0x2140ce37)    R(0x09e1,0x28705ab1,0x28a06a72,0x26203e99)\n    R(0x09e2,0x2eb07eb3,0x2fa08aca,0x2fa0be8b)    R(0x09e3,0x23a0ba21,0x23b06e49,0x25e09e27)    R(0x09e4,0x2880aa3c,0x2b40c255,0x2a411218)    R(0x09e5,0x2de15605,0x2f613a22,0x302145f4)    R(0x09e6,0x211191f2,0x21f12e0a,0x238199e3)    R(0x09e7,0x2bf175f8,0x2d218de6,0x2c41d1df)    R(0x09e8,0x2e8311f6,0x2f32cde7,0x2ff2ddfe)    R(0x09e9,0x21f12e0a,0x23a0ba21,0x24f11a00)    R(0x09ea,0x24f11a00,0x25e09e27,0x27910a0a)    R(0x09eb,0x269191e2,0x24f11a00,0x27910a0a)\n    R(0x09ec,0x2a411218,0x2b40c255,0x2cb11627)    R(0x09ed,0x2cb11627,0x2f613a22,0x2de15605)    R(0x09ee,0x27910a0a,0x2880aa3c,0x2a411218)    R(0x09ef,0x2a411218,0x2cb11627,0x2bf175f8)    R(0x09f0,0x296185ef,0x27910a0a,0x2a411218)    R(0x09f1,0x2cb11627,0x2ea0f653,0x2f613a22)    R(0x09f2,0x21f12e0a,0x2140ce37,0x23a0ba21)    R(0x09f3,0x2140ce37,0x23b06e49,0x23a0ba21)    R(0x09f4,0x238199e3,0x21f12e0a,0x24f11a00)    R(0x09f5,0x238199e3,0x24f11a00,0x269191e2)\n    R(0x09f6,0x2bf175f8,0x2cb11627,0x2de15605)    R(0x09f7,0x27910a0a,0x25e09e27,0x2880aa3c)    R(0x09f8,0x269191e2,0x27910a0a,0x296185ef)    R(0x09f9,0x296185ef,0x2a411218,0x2bf175f8)    R(0x09fa,0x24f11a00,0x23a0ba21,0x25e09e27)    R(0x09fb,0x2bf175f8,0x2de15605,0x2d218de6)    R(0x09fc,0x21b046a3,0x23b04681,0x21a07668)    R(0x09fd,0x28705ab1,0x2a6086ca,0x2ae09a90)    R(0x09fe,0x1ff09e89,0x21a07668,0x1f90da5b)    R(0x09ff,0x2ea0f653,0x2fa0be8b,0x3051125e)\n    R(0x0a00,0x296185ef,0x2bf175f8,0x2b01ede0)    R(0x0a01,0x23b04681,0x23b06e49,0x21a07668)    R(0x0a02,0x1fe09eb8,0x21b046a3,0x1ff09e89)    R(0x0a03,0x21a07668,0x23b06e49,0x2140ce37)    R(0x0a04,0x25e09e27,0x2620665b,0x2880aa3c)    R(0x0a05,0x2a6086ca,0x2cb086bd,0x2ae09a90)    R(0x0a06,0x2d70ba84,0x2cb086bd,0x2eb07eb3)    R(0x0a07,0x28a06a72,0x2ae09a90,0x2b40c255)    R(0x0a08,0x2880aa3c,0x2620665b,0x28a06a72)    R(0x0a09,0x2ae09a90,0x2cb086bd,0x2d70ba84)\n    R(0x0a0a,0x2880aa3c,0x28a06a72,0x2b40c255)    R(0x0a0b,0x21b046a3,0x21a07668,0x1ff09e89)    R(0x0a0c,0x2de15605,0x2ea155e2,0x2d218de6)    R(0x0a0d,0x2d70ba84,0x2eb07eb3,0x2fa0be8b)    R(0x0a0e,0x2de15605,0x302145f4,0x2ea155e2)    R(0x0a0f,0x2b40c255,0x2ea0f653,0x2cb11627)    R(0x0a10,0x2b40c255,0x2d70ba84,0x2ea0f653)    R(0x0a11,0x25e09e27,0x23b06e49,0x2620665b)    R(0x0a12,0x2d70ba84,0x2fa0be8b,0x2ea0f653)    R(0x0a13,0x28705ab1,0x2ae09a90,0x28a06a72)\n    R(0x0a14,0x2b40c255,0x2ae09a90,0x2d70ba84)    R(0x0a15,0x321271d8,0x335229e1,0x32125a0d)    R(0x0a16,0x33a1bdf8,0x338181f0,0x3261b623)    R(0x0a17,0x211191f2,0x1fc12626,0x21f12e0a)    R(0x0a18,0x322392ad,0x32333677,0x3242deb3)    R(0x0a19,0x2fa0be8b,0x2fa08aca,0x3090e2a5)    R(0x0a1a,0x2e8311f6,0x2ff2ddfe,0x3062f60b)    R(0x0a1b,0x1fc12626,0x2140ce37,0x21f12e0a)    R(0x0a1c,0x338181f0,0x32f141e3,0x32017616)    R(0x0a1d,0x31618245,0x32017616,0x30b15231)\n    R(0x0a1e,0x3341fdfe,0x33a1bdf8,0x32720627)    R(0x0a1f,0x30232a06,0x31834a0e,0x30736dfb)    R(0x0a20,0x2f613a22,0x30b15231,0x31414a04)    R(0x0a21,0x2ff2ddfe,0x30d2a5f4,0x3122ae11)    R(0x0a22,0x30b15231,0x32017616,0x31414a04)    R(0x0a23,0x3261b623,0x32017616,0x31618245)    R(0x0a24,0x3261b623,0x338181f0,0x32017616)    R(0x0a25,0x3122ae11,0x32125a0d,0x31e2723b)    R(0x0a26,0x30d2a5f4,0x32125a0d,0x3122ae11)    R(0x0a27,0x32125a0d,0x32720627,0x31e2723b)\n    R(0x0a28,0x32125a0d,0x3341fdfe,0x32720627)    R(0x0a29,0x3122ae11,0x31e2723b,0x3152d224)    R(0x0a2a,0x2e8311f6,0x3062f60b,0x30232a06)    R(0x0a2b,0x2f32cde7,0x30d2a5f4,0x2ff2ddfe)    R(0x0a2c,0x2f613a22,0x31414a04,0x302145f4)    R(0x0a2d,0x30232a06,0x31430e1d,0x31834a0e)    R(0x0a2e,0x3152d224,0x31e2f245,0x31430e1d)    R(0x0a2f,0x31430e1d,0x3233362b,0x31834a0e)    R(0x0a30,0x2ff2ddfe,0x3122ae11,0x3062f60b)    R(0x0a31,0x3062f60b,0x3152d224,0x31430e1d)\n    R(0x0a32,0x3062f60b,0x31430e1d,0x30232a06)    R(0x0a33,0x3062f60b,0x3122ae11,0x3152d224)    R(0x0a34,0x3051125e,0x2fa0be8b,0x3090e2a5)    R(0x0a35,0x2ea0f653,0x3051125e,0x30b15231)    R(0x0a36,0x317156c3,0x31314e7d,0x3090e2a5)    R(0x0a37,0x32125a0d,0x335229e1,0x3341fdfe)    R(0x0a38,0x32835649,0x31e2f245,0x32333677)    R(0x0a39,0x30b15231,0x3051125e,0x31618245)    R(0x0a3a,0x31e1c290,0x31314e7d,0x317156c3)    R(0x0a3b,0x3212767b,0x31f1ea55,0x31e1c290)\n    R(0x0a3c,0x32017616,0x32f141e3,0x31414a04)    R(0x0a3d,0x321222bf,0x31e1c290,0x317156c3)    R(0x0a3e,0x31f1ea55,0x3261b623,0x31618245)    R(0x0a3f,0x31f1ea55,0x31618245,0x31314e7d)    R(0x0a40,0x3212767b,0x31e1c290,0x321222bf)    R(0x0a41,0x31f1ea55,0x31314e7d,0x31e1c290)    R(0x0a42,0x31e2723b,0x32720627,0x31f1ea55)    R(0x0a43,0x32720627,0x3261b623,0x31f1ea55)    R(0x0a44,0x31314e7d,0x3051125e,0x3090e2a5)    R(0x0a45,0x31e2f245,0x3233362b,0x31430e1d)\n    R(0x0a46,0x3242deb3,0x3212767b,0x321222bf)    R(0x0a47,0x32835649,0x3233362b,0x31e2f245)    R(0x0a48,0x31e2f245,0x31e2723b,0x3212767b)    R(0x0a49,0x31e2723b,0x31f1ea55,0x3212767b)    R(0x0a4a,0x32333677,0x31e2f245,0x3212767b)    R(0x0a4b,0x3152d224,0x31e2723b,0x31e2f245)    R(0x0a4c,0x32333677,0x3212767b,0x3242deb3)    R(0x0a4d,0x31618245,0x3051125e,0x31314e7d)    R(0x0a4e,0x0004366e,0x00038a55,0x0013ee27)    R(0x0a4f,0x28a06a72,0x2620665b,0x26203e99)\n    R(0x0a50,0x27654617,0x2754cdee,0x2804e222)    R(0x0a51,0x310446c8,0x31b406a1,0x31a3fede)    R(0x0a52,0x372445ef,0x368425d5,0x3553d9fd)    R(0x0a53,0x3624561a,0x37d499f8,0x3583fe16)    R(0x0a54,0x281405dc,0x2a139ddf,0x29b439fc)    R(0x0a55,0x2cb3a1f2,0x2e8311f6,0x2e8361f8)    R(0x0a56,0x2e8361f8,0x30736dfb,0x2f33a9f1)    R(0x0a57,0x27953a7f,0x28f4ea58,0x2974ee96)    R(0x0a58,0x2974ee96,0x2bb49aa6,0x29a4d6d4)    R(0x0a59,0x273532be,0x2974ee96,0x29a4d6d4)\n    R(0x0a5a,0x30232a06,0x30736dfb,0x2e8361f8)    R(0x0a5b,0x2df3e1f6,0x2f33a9f1,0x2f8411df)    R(0x0a5c,0x2804e222,0x28147df9,0x29649e27)    R(0x0a5d,0x2e74b60f,0x300535f9,0x2ea4b22c)    R(0x0a5e,0x2cb3a1f2,0x2e8361f8,0x2df3e1f6)    R(0x0a5f,0x2b840e00,0x2cb3a1f2,0x2cf41602)    R(0x0a60,0x29b439fc,0x2a139ddf,0x2b840e00)    R(0x0a61,0x29b439fc,0x2b840e00,0x2b146a26)    R(0x0a62,0x2df3e1f6,0x2f8411df,0x2eb451e5)    R(0x0a63,0x2b840e00,0x2cf41602,0x2c844a18)\n    R(0x0a64,0x2c844a18,0x2cf41602,0x2d745a0f)    R(0x0a65,0x2cf41602,0x2dc431fd,0x2d745a0f)    R(0x0a66,0x2cf41602,0x2df3e1f6,0x2dc431fd)    R(0x0a67,0x2df3e1f6,0x2eb451e5,0x2dc431fd)    R(0x0a68,0x2b146a26,0x2b840e00,0x2c844a18)    R(0x0a69,0x28147df9,0x29b439fc,0x29649e27)    R(0x0a6a,0x2e8361f8,0x2f33a9f1,0x2df3e1f6)    R(0x0a6b,0x2e74b60f,0x2e6491f6,0x2f950de3)    R(0x0a6c,0x2e74b60f,0x2f950de3,0x300535f9)    R(0x0a6d,0x2ea4b22c,0x300535f9,0x3025061a)\n    R(0x0a6e,0x2d745a0f,0x2e6491f6,0x2e74b60f)    R(0x0a6f,0x29649e27,0x29b439fc,0x2b146a26)    R(0x0a70,0x2cb3a1f2,0x2df3e1f6,0x2cf41602)    R(0x0a71,0x2d74762a,0x2d745a0f,0x2e74b60f)    R(0x0a72,0x2d745a0f,0x2dc431fd,0x2e6491f6)    R(0x0a73,0x2a139ddf,0x2cb3a1f2,0x2b840e00)    R(0x0a74,0x28147df9,0x281405dc,0x29b439fc)    R(0x0a75,0x2d94767e,0x2fb466a5,0x2df472c9)    R(0x0a76,0x2ea4b22c,0x3025061a,0x2fd4aa44)    R(0x0a77,0x2804e222,0x29649e27,0x28f4ea58)\n    R(0x0a78,0x2c847a43,0x2c844a18,0x2d74762a)    R(0x0a79,0x2b14aa61,0x2b146a26,0x2c847a43)    R(0x0a7a,0x2bb49aa6,0x2d94767e,0x2df472c9)    R(0x0a7b,0x2dc431fd,0x2eb451e5,0x2e6491f6)    R(0x0a7c,0x2d94767e,0x2e247e50,0x2fe46e6b)    R(0x0a7d,0x2c847a43,0x2e247e50,0x2d94767e)    R(0x0a7e,0x2b14aa61,0x2c847a43,0x2d94767e)    R(0x0a7f,0x2c847a43,0x2d74762a,0x2e247e50)    R(0x0a80,0x2d94767e,0x2fe46e6b,0x2fb466a5)    R(0x0a81,0x2e247e50,0x2fd4aa44,0x2fe46e6b)\n    R(0x0a82,0x28f4ea58,0x29649e27,0x2b14aa61)    R(0x0a83,0x28f4ea58,0x2b14aa61,0x2974ee96)    R(0x0a84,0x2974ee96,0x2b14aa61,0x2bb49aa6)    R(0x0a85,0x2b146a26,0x2c844a18,0x2c847a43)    R(0x0a86,0x2c844a18,0x2d745a0f,0x2d74762a)    R(0x0a87,0x2e247e50,0x2ea4b22c,0x2fd4aa44)    R(0x0a88,0x29649e27,0x2b146a26,0x2b14aa61)    R(0x0a89,0x2d74762a,0x2ea4b22c,0x2e247e50)    R(0x0a8a,0x2d74762a,0x2e74b60f,0x2ea4b22c)    R(0x0a8b,0x2b14aa61,0x2d94767e,0x2bb49aa6)\n    R(0x0a8c,0x30736dfb,0x3243a1f0,0x3103d1e0)    R(0x0a8d,0x37d499f8,0x372445ef,0x3583fe16)    R(0x0a8e,0x27953a4f,0x2804e222,0x28f4ea58)    R(0x0a8f,0x2620665b,0x23b06e49,0x23b04681)    R(0x0a90,0x31b406a1,0x322392ad,0x31a3fede)    R(0x0a91,0x30736dfb,0x3103d1e0,0x2f33a9f1)    R(0x0a92,0x3233362b,0x3343820b,0x31834a0e)    R(0x0a93,0x3744ce0b,0x37d499f8,0x3624561a)    R(0x0a94,0x31649e4a,0x3314f624,0x33347647)    R(0x0a95,0x2754cdee,0x28147df9,0x2804e222)\n    R(0x0a96,0x3564c623,0x37352205,0x3744ce0b)    R(0x0a97,0x3553d9fd,0x3343820b,0x33b38625)    R(0x0a98,0x32835649,0x33b38625,0x3233362b)    R(0x0a99,0x3583fe16,0x372445ef,0x3553d9fd)    R(0x0a9a,0x35046631,0x3744ce0b,0x3624561a)    R(0x0a9b,0x33347647,0x3564c623,0x35046631)    R(0x0a9c,0x3583fe16,0x3553d9fd,0x33b38625)    R(0x0a9d,0x35046631,0x3624561a,0x3434023d)    R(0x0a9e,0x3624561a,0x3583fe16,0x3434023d)    R(0x0a9f,0x3583fe16,0x33b38625,0x33c3aa3a)\n    R(0x0aa0,0x3434023d,0x3583fe16,0x33c3aa3a)    R(0x0aa1,0x2fd4aa44,0x3025061a,0x31951224)    R(0x0aa2,0x2fd4aa44,0x31951224,0x31649e4a)    R(0x0aa3,0x31834a0e,0x3343820b,0x3243a1f0)    R(0x0aa4,0x33b38625,0x3343820b,0x3233362b)    R(0x0aa5,0x34e5120c,0x37352205,0x3564c623)    R(0x0aa6,0x3564c623,0x3744ce0b,0x35046631)    R(0x0aa7,0x3314f624,0x3564c623,0x33347647)    R(0x0aa8,0x3314f624,0x34e5120c,0x3564c623)    R(0x0aa9,0x31649e4a,0x31951224,0x3314f624)\n    R(0x0aaa,0x33c3aa3a,0x33b38625,0x32835649)    R(0x0aab,0x32b3ae5b,0x32835649,0x32333677)    R(0x0aac,0x3343820b,0x3483e1e0,0x3243a1f0)    R(0x0aad,0x3553d9fd,0x3483e1e0,0x3343820b)    R(0x0aae,0x30e43e88,0x31b406a1,0x310446c8)    R(0x0aaf,0x2fb466a5,0x30e43e88,0x310446c8)    R(0x0ab0,0x2fe46e6b,0x2fd4aa44,0x31649e4a)    R(0x0ab1,0x30e43e88,0x31d41274,0x31b406a1)    R(0x0ab2,0x31b406a1,0x3223ca7b,0x322392ad)    R(0x0ab3,0x3223ca7b,0x32333677,0x322392ad)\n    R(0x0ab4,0x35046631,0x3434023d,0x32e41258)    R(0x0ab5,0x31d41274,0x3223ca7b,0x31b406a1)    R(0x0ab6,0x32e41258,0x3223ca7b,0x31d41274)    R(0x0ab7,0x32e41258,0x32b3ae5b,0x3223ca7b)    R(0x0ab8,0x32e41258,0x3434023d,0x32b3ae5b)    R(0x0ab9,0x3434023d,0x33c3aa3a,0x32b3ae5b)    R(0x0aba,0x31844e64,0x32e41258,0x31d41274)    R(0x0abb,0x2fe46e6b,0x30e43e88,0x2fb466a5)    R(0x0abc,0x2fe46e6b,0x31649e4a,0x31844e64)    R(0x0abd,0x31834a0e,0x3243a1f0,0x30736dfb)\n    R(0x0abe,0x32b3ae5b,0x32333677,0x3223ca7b)    R(0x0abf,0x33347647,0x35046631,0x32e41258)    R(0x0ac0,0x31649e4a,0x33347647,0x31844e64)    R(0x0ac1,0x31844e64,0x31d41274,0x30e43e88)    R(0x0ac2,0x33347647,0x32e41258,0x31844e64)    R(0x0ac3,0x32b3ae5b,0x33c3aa3a,0x32835649)    R(0x0ac4,0x2fe46e6b,0x31844e64,0x30e43e88)    R(0x0ac5,0x23e042f8,0x26303ed8,0x23d02ebf)    R(0x0ac6,0x3242deb3,0x321222bf,0x32129ef0)    R(0x0ac7,0x25d32bf4,0x27129fff,0x24a2dbf9)\n    R(0x0ac8,0x2d82cdde,0x2f32cde7,0x2e8311f6)    R(0x0ac9,0x20d39fcb,0x20732bd8,0x1f9343b4)    R(0x0aca,0x21b5370d,0x2184cf22,0x1ff4df33)    R(0x0acb,0x1fa16b62,0x20d10361,0x20910728)    R(0x0acc,0x22230bef,0x24a2dbf9,0x22f263e7)    R(0x0acd,0x23e042f8,0x26206312,0x26303ed8)    R(0x0ace,0x3090e2a5,0x2fa08aca,0x3070d2e0)    R(0x0acf,0x31b31b1a,0x31724b25,0x30e2cb48)    R(0x0ad0,0x32129ef0,0x31b1daf6,0x31724b25)    R(0x0ad1,0x28d082f3,0x2a6086ca,0x28705ab1)\n    R(0x0ad2,0x22008314,0x24007f31,0x23e042f8)    R(0x0ad3,0x2b112f84,0x2a50ff50,0x2841036f)    R(0x0ad4,0x1fb20fbd,0x2121efd9,0x205187bb)    R(0x0ad5,0x20c293d5,0x22230bef,0x22f263e7)    R(0x0ad6,0x24a2dbf9,0x25823bf8,0x22f263e7)    R(0x0ad7,0x24007f31,0x25f0b34f,0x26206312)    R(0x0ad8,0x26206312,0x2870bb2b,0x28d082f3)    R(0x0ad9,0x20513396,0x21d0e789,0x20d10361)    R(0x0ada,0x2b112f84,0x2841036f,0x28713fa6)    R(0x0adb,0x2ae187ad,0x28713fa6,0x28019bcf)\n    R(0x0adc,0x2250c34a,0x23c0cb70,0x24007f31)    R(0x0add,0x20d10361,0x21d0e789,0x2250c34a)    R(0x0ade,0x21d0e789,0x2370f3ab,0x23c0cb70)    R(0x0adf,0x23c0cb70,0x25c0f390,0x25f0b34f)    R(0x0ae0,0x2a50ff50,0x2b00bb1c,0x2870bb2b)    R(0x0ae1,0x21d0e789,0x23c0cb70,0x2250c34a)    R(0x0ae2,0x25c0f390,0x2841036f,0x25f0b34f)    R(0x0ae3,0x25f0b34f,0x2841036f,0x2870bb2b)    R(0x0ae4,0x2841036f,0x2a50ff50,0x2870bb2b)    R(0x0ae5,0x2370f3ab,0x25c0f390,0x23c0cb70)\n    R(0x0ae6,0x20513396,0x21a11fb4,0x21d0e789)    R(0x0ae7,0x2370f3ab,0x25b13bbf,0x25c0f390)    R(0x0ae8,0x25f0b34f,0x2870bb2b,0x26206312)    R(0x0ae9,0x2ae187ad,0x2b112f84,0x28713fa6)    R(0x0aea,0x23c0cb70,0x25f0b34f,0x24007f31)    R(0x0aeb,0x20d10361,0x2250c34a,0x20910728)    R(0x0aec,0x25b13bbf,0x28713fa6,0x25c0f390)    R(0x0aed,0x21a11fb4,0x2370f3ab,0x21d0e789)    R(0x0aee,0x28713fa6,0x2841036f,0x25c0f390)    R(0x0aef,0x2250c34a,0x24007f31,0x22008314)\n    R(0x0af0,0x22008314,0x21c04edb,0x2020baee)    R(0x0af1,0x2870bb2b,0x2b00bb1c,0x28d082f3)    R(0x0af2,0x25823bf8,0x25a1afe1,0x2351c7e4)    R(0x0af3,0x20c293d5,0x2121efd9,0x1fb20fbd)    R(0x0af4,0x2a92dbd8,0x29a277e7,0x2842ebf0)    R(0x0af5,0x21c177d1,0x238147ce,0x21a11fb4)    R(0x0af6,0x2121efd9,0x21c177d1,0x205187bb)    R(0x0af7,0x205187bb,0x21c177d1,0x21a11fb4)    R(0x0af8,0x2121efd9,0x2351c7e4,0x21c177d1)    R(0x0af9,0x28019bcf,0x28713fa6,0x25b13bbf)\n    R(0x0afa,0x29d1f7d5,0x2ae187ad,0x28019bcf)    R(0x0afb,0x25a1afe1,0x25b13bbf,0x238147ce)    R(0x0afc,0x28019bcf,0x25b13bbf,0x25a1afe1)    R(0x0afd,0x2351c7e4,0x238147ce,0x21c177d1)    R(0x0afe,0x2351c7e4,0x25a1afe1,0x238147ce)    R(0x0aff,0x20c293d5,0x22f263e7,0x2121efd9)    R(0x0b00,0x20910728,0x2250c34a,0x22008314)    R(0x0b01,0x22f263e7,0x25823bf8,0x2351c7e4)    R(0x0b02,0x29d1f7d5,0x28019bcf,0x27a21ff2)    R(0x0b03,0x22f263e7,0x2351c7e4,0x2121efd9)\n    R(0x0b04,0x238147ce,0x25b13bbf,0x2370f3ab)    R(0x0b05,0x27a21ff2,0x25a1afe1,0x25823bf8)    R(0x0b06,0x27a21ff2,0x28019bcf,0x25a1afe1)    R(0x0b07,0x21a11fb4,0x238147ce,0x2370f3ab)    R(0x0b08,0x29a277e7,0x29d1f7d5,0x27a21ff2)    R(0x0b09,0x317156c3,0x3090e2a5,0x3070d2e0)    R(0x0b0a,0x321222bf,0x317156c3,0x31b1daf6)    R(0x0b0b,0x2020baee,0x21c04edb,0x1fe09eb8)    R(0x0b0c,0x31b31b1a,0x32129ef0,0x31724b25)    R(0x0b0d,0x2c72a3bf,0x2be227bf,0x29a277e7)\n    R(0x0b0e,0x2e306ee5,0x2fa08aca,0x2eb07eb3)    R(0x0b0f,0x2bd07af0,0x2e306ee5,0x2cb086bd)    R(0x0b10,0x20910728,0x22008314,0x2020baee)    R(0x0b11,0x2ca0eb4c,0x2b00bb1c,0x2a50ff50)    R(0x0b12,0x32129ef0,0x321222bf,0x31b1daf6)    R(0x0b13,0x2f3092fd,0x2fa08aca,0x2e306ee5)    R(0x0b14,0x2f3092fd,0x2e306ee5,0x2d909316)    R(0x0b15,0x28d082f3,0x2b00bb1c,0x2bd07af0)    R(0x0b16,0x2ca0eb4c,0x2d909316,0x2b00bb1c)    R(0x0b17,0x2d909316,0x2e306ee5,0x2bd07af0)\n    R(0x0b18,0x2ff0f317,0x2f3092fd,0x2e70db34)    R(0x0b19,0x3070d2e0,0x2fa08aca,0x2f3092fd)    R(0x0b1a,0x2e70db34,0x2f3092fd,0x2d909316)    R(0x0b1b,0x2b00bb1c,0x2d909316,0x2bd07af0)    R(0x0b1c,0x2e70db34,0x2d909316,0x2ca0eb4c)    R(0x0b1d,0x2ff0f317,0x3070d2e0,0x2f3092fd)    R(0x0b1e,0x28d082f3,0x2bd07af0,0x2a6086ca)    R(0x0b1f,0x2bd07af0,0x2cb086bd,0x2a6086ca)    R(0x0b20,0x2f414748,0x2ff0f317,0x2e70db34)    R(0x0b21,0x31b1daf6,0x31014b01,0x30a1af34)\n    R(0x0b22,0x31724b25,0x31b1daf6,0x30a1af34)    R(0x0b23,0x30a1af34,0x31014b01,0x2ff0f317)    R(0x0b24,0x317156c3,0x3070d2e0,0x31014b01)    R(0x0b25,0x30a1af34,0x2ff0f317,0x2f414748)    R(0x0b26,0x31014b01,0x3070d2e0,0x2ff0f317)    R(0x0b27,0x31b1daf6,0x317156c3,0x31014b01)    R(0x0b28,0x2cb086bd,0x2e306ee5,0x2eb07eb3)    R(0x0b29,0x205187bb,0x21a11fb4,0x20513396)    R(0x0b2a,0x31724b25,0x30a1af34,0x30123760)    R(0x0b2b,0x29a277e7,0x2be227bf,0x29d1f7d5)\n    R(0x0b2c,0x2e12fb9a,0x2e425396,0x2c72a3bf)    R(0x0b2d,0x2d614770,0x2e70db34,0x2ca0eb4c)    R(0x0b2e,0x2be227bf,0x2ae187ad,0x29d1f7d5)    R(0x0b2f,0x2b112f84,0x2ca0eb4c,0x2a50ff50)    R(0x0b30,0x2e425396,0x2ef1bf70,0x2d01bf98)    R(0x0b31,0x30a1af34,0x2f414748,0x2ef1bf70)    R(0x0b32,0x2d01bf98,0x2d614770,0x2ae187ad)    R(0x0b33,0x2ef1bf70,0x2d614770,0x2d01bf98)    R(0x0b34,0x2ae187ad,0x2d614770,0x2b112f84)    R(0x0b35,0x2ef1bf70,0x2f414748,0x2d614770)\n    R(0x0b36,0x2be227bf,0x2d01bf98,0x2ae187ad)    R(0x0b37,0x30123760,0x30a1af34,0x2ef1bf70)    R(0x0b38,0x2a92dbd8,0x2c72a3bf,0x29a277e7)    R(0x0b39,0x2f414748,0x2e70db34,0x2d614770)    R(0x0b3a,0x2fa2db74,0x2e425396,0x2e12fb9a)    R(0x0b3b,0x30e2cb48,0x31724b25,0x30123760)    R(0x0b3c,0x2d614770,0x2ca0eb4c,0x2b112f84)    R(0x0b3d,0x2c72a3bf,0x2e425396,0x2be227bf)    R(0x0b3e,0x30123760,0x2ef1bf70,0x2e425396)    R(0x0b3f,0x2fa2db74,0x30123760,0x2e425396)\n    R(0x0b40,0x30e2cb48,0x30123760,0x2fa2db74)    R(0x0b41,0x2e425396,0x2d01bf98,0x2be227bf)    R(0x0b42,0x2184cf22,0x1fa44b44,0x1ff4df33)    R(0x0b43,0x21b5370d,0x23152ef7,0x2184cf22)    R(0x0b44,0x2842ebf0,0x27129fff,0x25d32bf4)    R(0x0b45,0x26206312,0x28d082f3,0x26303ed8)    R(0x0b46,0x2df472c9,0x2fb466a5,0x301462eb)    R(0x0b47,0x321362e7,0x3242deb3,0x32129ef0)    R(0x0b48,0x26303ed8,0x28d082f3,0x28705ab1)    R(0x0b49,0x273532be,0x29a4d6d4,0x27b4fafd)\n    R(0x0b4a,0x2184cf22,0x2104673c,0x1fa44b44)    R(0x0b4b,0x2773ef81,0x2a03bf7c,0x28839bb2)    R(0x0b4c,0x23736bf2,0x24a2dbf9,0x22230bef)    R(0x0b4d,0x23152ef7,0x23850713,0x2184cf22)    R(0x0b4e,0x22008314,0x23e042f8,0x21c04edb)    R(0x0b4f,0x2304238a,0x21a3ebb3,0x2103eb79)    R(0x0b50,0x2104673c,0x2043db59,0x1fc3e350)    R(0x0b51,0x27b4fafd,0x29e4930d,0x27d4a730)    R(0x0b52,0x273532be,0x27b4fafd,0x25552af1)    R(0x0b53,0x22544b5c,0x2304238a,0x2103eb79)\n    R(0x0b54,0x2104673c,0x22544b5c,0x2043db59)    R(0x0b55,0x22f4bf38,0x22544b5c,0x2104673c)    R(0x0b56,0x24747b62,0x24f41f8f,0x2304238a)    R(0x0b57,0x2674635e,0x29542348,0x2773ef81)    R(0x0b58,0x27d4a730,0x29542348,0x2674635e)    R(0x0b59,0x24747b62,0x2674635e,0x24f41f8f)    R(0x0b5a,0x2674635e,0x2773ef81,0x24f41f8f)    R(0x0b5b,0x24747b62,0x2304238a,0x22544b5c)    R(0x0b5c,0x22f4bf38,0x24747b62,0x22544b5c)    R(0x0b5d,0x22544b5c,0x2103eb79,0x2043db59)\n    R(0x0b5e,0x24007f31,0x26206312,0x23e042f8)    R(0x0b5f,0x25552af1,0x2594db30,0x23850713)    R(0x0b60,0x2594db30,0x27d4a730,0x2674635e)    R(0x0b61,0x22f4bf38,0x2594db30,0x24747b62)    R(0x0b62,0x2184cf22,0x22f4bf38,0x2104673c)    R(0x0b63,0x2184cf22,0x23850713,0x22f4bf38)    R(0x0b64,0x2594db30,0x2674635e,0x24747b62)    R(0x0b65,0x23850713,0x2594db30,0x22f4bf38)    R(0x0b66,0x27b4fafd,0x27d4a730,0x2594db30)    R(0x0b67,0x20732bd8,0x22230bef,0x20c293d5)\n    R(0x0b68,0x25d32bf4,0x24a2dbf9,0x23736bf2)    R(0x0b69,0x26e36bdd,0x29a343cf,0x2842ebf0)    R(0x0b6a,0x21a3ebb3,0x20d39fcb,0x20039b96)    R(0x0b6b,0x25552af1,0x27b4fafd,0x2594db30)    R(0x0b6c,0x23736bf2,0x22230bef,0x21c37be7)    R(0x0b6d,0x2273cbdb,0x21c37be7,0x20d39fcb)    R(0x0b6e,0x2463afe3,0x25d32bf4,0x23736bf2)    R(0x0b6f,0x25c3d7bf,0x26e36bdd,0x2463afe3)    R(0x0b70,0x26e36bdd,0x2842ebf0,0x25d32bf4)    R(0x0b71,0x25c3d7bf,0x28839bb2,0x26e36bdd)\n    R(0x0b72,0x28839bb2,0x29a343cf,0x26e36bdd)    R(0x0b73,0x2273cbdb,0x23736bf2,0x21c37be7)    R(0x0b74,0x2463afe3,0x23736bf2,0x2273cbdb)    R(0x0b75,0x26e36bdd,0x25d32bf4,0x2463afe3)    R(0x0b76,0x21c37be7,0x22230bef,0x20732bd8)    R(0x0b77,0x2304238a,0x2383ffc0,0x21a3ebb3)    R(0x0b78,0x24f41f8f,0x2773ef81,0x25c3d7bf)    R(0x0b79,0x2773ef81,0x28839bb2,0x25c3d7bf)    R(0x0b7a,0x2383ffc0,0x2463afe3,0x2273cbdb)    R(0x0b7b,0x24f41f8f,0x2383ffc0,0x2304238a)\n    R(0x0b7c,0x25c3d7bf,0x2463afe3,0x2383ffc0)    R(0x0b7d,0x24f41f8f,0x25c3d7bf,0x2383ffc0)    R(0x0b7e,0x2383ffc0,0x2273cbdb,0x21a3ebb3)    R(0x0b7f,0x21a3ebb3,0x2273cbdb,0x20d39fcb)    R(0x0b80,0x2fb466a5,0x310446c8,0x301462eb)    R(0x0b81,0x31a3fede,0x322392ad,0x321362e7)    R(0x0b82,0x29a4d6d4,0x29e4930d,0x27b4fafd)    R(0x0b83,0x321362e7,0x32129ef0,0x31b31b1a)    R(0x0b84,0x2103eb79,0x21a3ebb3,0x20039b96)    R(0x0b85,0x29a343cf,0x2a92dbd8,0x2842ebf0)\n    R(0x0b86,0x30c36f44,0x31b31b1a,0x30e2cb48)    R(0x0b87,0x3163cf14,0x321362e7,0x31b31b1a)    R(0x0b88,0x2ff43726,0x3073f738,0x2ef3e356)    R(0x0b89,0x29e4930d,0x29542348,0x27d4a730)    R(0x0b8a,0x2bb49aa6,0x2df472c9,0x2bc48ae8)    R(0x0b8b,0x29a4d6d4,0x2bc48ae8,0x29e4930d)    R(0x0b8c,0x2bb4471c,0x2b53ef4c,0x29542348)    R(0x0b8d,0x2ff43726,0x2ef3e356,0x2de41f3e)    R(0x0b8e,0x301462eb,0x31043705,0x2ff43726)    R(0x0b8f,0x3163cf14,0x31b31b1a,0x30c36f44)\n    R(0x0b90,0x31043705,0x31a3fede,0x3163cf14)    R(0x0b91,0x2e245f08,0x2de41f3e,0x2bb4471c)    R(0x0b92,0x2ff43726,0x31043705,0x3073f738)    R(0x0b93,0x2e245f08,0x2ff43726,0x2de41f3e)    R(0x0b94,0x2bb4471c,0x2de41f3e,0x2b53ef4c)    R(0x0b95,0x29e4930d,0x2bb4471c,0x29542348)    R(0x0b96,0x29a4d6d4,0x2bb49aa6,0x2bc48ae8)    R(0x0b97,0x31a3fede,0x321362e7,0x3163cf14)    R(0x0b98,0x2bc48ae8,0x2e245f08,0x2bb4471c)    R(0x0b99,0x2bc48ae8,0x2df472c9,0x2e245f08)\n    R(0x0b9a,0x2df472c9,0x301462eb,0x2e245f08)    R(0x0b9b,0x2e245f08,0x301462eb,0x2ff43726)    R(0x0b9c,0x3073f738,0x3163cf14,0x30c36f44)    R(0x0b9d,0x31043705,0x3163cf14,0x3073f738)    R(0x0b9e,0x2bc48ae8,0x2bb4471c,0x29e4930d)    R(0x0b9f,0x2c232bb6,0x2c72a3bf,0x2a92dbd8)    R(0x0ba0,0x20d39fcb,0x21c37be7,0x20732bd8)    R(0x0ba1,0x310446c8,0x31a3fede,0x31043705)    R(0x0ba2,0x301462eb,0x310446c8,0x31043705)    R(0x0ba3,0x2f737369,0x2fa2db74,0x2e12fb9a)\n    R(0x0ba4,0x2db3738a,0x2e12fb9a,0x2c232bb6)    R(0x0ba5,0x28839bb2,0x2b5383a4,0x29a343cf)    R(0x0ba6,0x2c232bb6,0x2e12fb9a,0x2c72a3bf)    R(0x0ba7,0x30c36f44,0x2fa2db74,0x2f737369)    R(0x0ba8,0x3073f738,0x30c36f44,0x2f737369)    R(0x0ba9,0x2cd3bb72,0x2db3738a,0x2b5383a4)    R(0x0baa,0x2a03bf7c,0x2b5383a4,0x28839bb2)    R(0x0bab,0x2f737369,0x2e12fb9a,0x2db3738a)    R(0x0bac,0x2ef3e356,0x2f737369,0x2db3738a)    R(0x0bad,0x2b5383a4,0x2c232bb6,0x29a343cf)\n    R(0x0bae,0x2b5383a4,0x2db3738a,0x2c232bb6)    R(0x0baf,0x29542348,0x2a03bf7c,0x2773ef81)    R(0x0bb0,0x29a343cf,0x2c232bb6,0x2a92dbd8)    R(0x0bb1,0x3073f738,0x2f737369,0x2ef3e356)    R(0x0bb2,0x30c36f44,0x30e2cb48,0x2fa2db74)    R(0x0bb3,0x2b53ef4c,0x2cd3bb72,0x2a03bf7c)    R(0x0bb4,0x2de41f3e,0x2cd3bb72,0x2b53ef4c)    R(0x0bb5,0x2ef3e356,0x2db3738a,0x2cd3bb72)    R(0x0bb6,0x2de41f3e,0x2ef3e356,0x2cd3bb72)    R(0x0bb7,0x29542348,0x2b53ef4c,0x2a03bf7c)\n    R(0x0bb8,0x2a03bf7c,0x2cd3bb72,0x2b5383a4)    R(0x0bb9,0x00355ecd,0x0004baa4,0x0065668e)    R(0x0bba,0x0c6f6602,0x0b3f99ed,0x0d4fb9e0)    R(0x0bbb,0x13d9238f,0x11692380,0x1299bf82)    R(0x0bbc,0x23e042f8,0x23d02ebf,0x21c04edb)    R(0x0bbd,0x270be602,0x26fbddc5,0x281b4def)    R(0x0bbe,0x37352205,0x38b57de6,0x38e551e9)    R(0x0bbf,0x012a65f4,0x0209d1fb,0x0149f9c7)    R(0x0bc0,0x0a4f320f,0x093f61ef,0x0b3f99ed)    R(0x0bc1,0x00660eed,0x00355ecd,0x007606ac)\n    R(0x0bc2,0x0fa5ff44,0x0e358331,0x0d061334)    R(0x0bc3,0x0124ef7f,0x00750b73,0x00d56b72)    R(0x0bc4,0x03353b75,0x0264db7e,0x01c5437c)    R(0x0bc5,0x0065668e,0x0064e267,0x00f56e44)    R(0x0bc6,0x00c52214,0x005559e8,0x00d5da17)    R(0x0bc7,0x00e8d318,0x022852f9,0x02490eea)    R(0x0bc8,0x0d4c9af4,0x0ccd06cc,0x0f7d06d1)    R(0x0bc9,0x063e9e03,0x04be41eb,0x05fee5ca)    R(0x0bca,0x0a4f320f,0x0b3f99ed,0x0c6f6602)    R(0x0bcb,0x00d5da17,0x005559e8,0x007601eb)\n    R(0x0bcc,0x00f98efd,0x00e8d318,0x02490eea)    R(0x0bcd,0x015bce64,0x013b729b,0x025b3a74)    R(0x0bce,0x0257be1d,0x02574def,0x029811d5)    R(0x0bcf,0x0b550ef5,0x097516ed,0x0a55670c)    R(0x0bd0,0x0c671f14,0x0a275ef7,0x0c378efb)    R(0x0bd1,0x00867e1a,0x007601eb,0x0176a5ef)    R(0x0bd2,0x00f56e44,0x00c52214,0x00d5da17)    R(0x0bd3,0x02aaca50,0x022a4227,0x015ae221)    R(0x0bd4,0x015bce64,0x025b3a74,0x01cb524d)    R(0x0bd5,0x0065668e,0x00f56e44,0x00f5ea6c)\n    R(0x0bd6,0x00768f16,0x00660eed,0x0096f2f5)    R(0x0bd7,0x00f56e44,0x00d5da17,0x00e64e42)    R(0x0bd8,0x007606ac,0x00f5ea6c,0x00a6867c)    R(0x0bd9,0x01b73ac9,0x0137068d,0x02279692)    R(0x0bda,0x01cb524d,0x02aaca50,0x015ae221)    R(0x0bdb,0x015b8a23,0x016b0df1,0x01abc5ec)    R(0x0bdc,0x00b6da51,0x00e64e42,0x00867e1a)    R(0x0bdd,0x0086a2be,0x00a6867c,0x0137068d)    R(0x0bde,0x00f5ea6c,0x00f56e44,0x00e64e42)    R(0x0bdf,0x01970e21,0x00867e1a,0x0176a5ef)\n    R(0x0be0,0x0137068d,0x00b6da51,0x02176656)    R(0x0be1,0x01970e21,0x0176a5ef,0x02574def)    R(0x0be2,0x0137068d,0x00a6867c,0x00b6da51)    R(0x0be3,0x00b6da51,0x00867e1a,0x01970e21)    R(0x0be4,0x02176656,0x00b6da51,0x01970e21)    R(0x0be5,0x00a6867c,0x00e64e42,0x00b6da51)    R(0x0be6,0x00e64e42,0x00d5da17,0x00867e1a)    R(0x0be7,0x015ae221,0x012a65f4,0x016b0df1)    R(0x0be8,0x015b8a23,0x015ae221,0x016b0df1)    R(0x0be9,0x013b729b,0x01faee9a,0x025b3a74)\n    R(0x0bea,0x01cb524d,0x015ae221,0x015b8a23)    R(0x0beb,0x015ae221,0x022a4227,0x012a65f4)    R(0x0bec,0x022a4227,0x0209d1fb,0x012a65f4)    R(0x0bed,0x02279692,0x0137068d,0x02176656)    R(0x0bee,0x00f5ea6c,0x00e64e42,0x00a6867c)    R(0x0bef,0x02176656,0x01970e21,0x0257be1d)    R(0x0bf0,0x00867e1a,0x00d5da17,0x007601eb)    R(0x0bf1,0x00660eed,0x0086a2be,0x0096f2f5)    R(0x0bf2,0x01679afc,0x01b73ac9,0x0267e2cf)    R(0x0bf3,0x00f9ff0c,0x00f98efd,0x00fa36e6)\n    R(0x0bf4,0x015b22e8,0x012b4ecb,0x016bbec9)    R(0x0bf5,0x0096f2f5,0x0086a2be,0x01b73ac9)    R(0x0bf6,0x00f9ff0c,0x00fa36e6,0x010aaaec)    R(0x0bf7,0x010aaaec,0x00fa36e6,0x011adac6)    R(0x0bf8,0x01b73ac9,0x0086a2be,0x0137068d)    R(0x0bf9,0x01679afc,0x0267e2cf,0x022852f9)    R(0x0bfa,0x00f98efd,0x0239becf,0x00fa36e6)    R(0x0bfb,0x00fa36e6,0x021a5ab5,0x011adac6)    R(0x0bfc,0x00fa36e6,0x0239becf,0x021a5ab5)    R(0x0bfd,0x00f98efd,0x02490eea,0x0239becf)\n    R(0x0bfe,0x014a7b07,0x00f9ff0c,0x010aaaec)    R(0x0bff,0x014a7b07,0x010aaaec,0x015b22e8)    R(0x0c00,0x01679afc,0x0096f2f5,0x01b73ac9)    R(0x0c01,0x011adac6,0x01faee9a,0x013b729b)    R(0x0c02,0x01fb9add,0x015b22e8,0x016bbec9)    R(0x0c03,0x011adac6,0x021a5ab5,0x01faee9a)    R(0x0c04,0x015b22e8,0x010aaaec,0x012b4ecb)    R(0x0c05,0x01cad2fd,0x014a7b07,0x015b22e8)    R(0x0c06,0x010aaaec,0x011adac6,0x012b4ecb)    R(0x0c07,0x01cad2fd,0x015b22e8,0x01fb9add)\n    R(0x0c08,0x012b4ecb,0x011adac6,0x013b729b)    R(0x0c09,0x0257be1d,0x029811d5,0x0288720f)    R(0x0c0a,0x007606ac,0x0065668e,0x00f5ea6c)    R(0x0c0b,0x035b36ee,0x01cad2fd,0x01fb9add)    R(0x0c0c,0x0c378efb,0x09d7aaf3,0x0c47cb02)    R(0x0c0d,0x061b1f13,0x04facafd,0x053b7aec)    R(0x0c0e,0x02a9a230,0x0288e642,0x02a92e03)    R(0x0c0f,0x007606ac,0x00a6867c,0x0086a2be)    R(0x0c10,0x0257be1d,0x01970e21,0x02574def)    R(0x0c11,0x02989ec8,0x02683299,0x0288ce83)\n    R(0x0c12,0x02fa9a7d,0x02d9f698,0x02da2a5c)    R(0x0c13,0x025b3a74,0x02aaca50,0x01cb524d)    R(0x0c14,0x02582256,0x0257be1d,0x0288720f)    R(0x0c15,0x02279692,0x02176656,0x02582256)    R(0x0c16,0x02582256,0x0288720f,0x0288e642)    R(0x0c17,0x02b94ab1,0x0288ce83,0x02a97a6f)    R(0x0c18,0x02da2a5c,0x02a97a6f,0x02a9a230)    R(0x0c19,0x0288ce83,0x0288e642,0x02a97a6f)    R(0x0c1a,0x02a97a6f,0x0288e642,0x02a9a230)    R(0x0c1b,0x02683299,0x02582256,0x0288ce83)\n    R(0x0c1c,0x0288ce83,0x02582256,0x0288e642)    R(0x0c1d,0x02b94ab1,0x02a97a6f,0x02d9f698)    R(0x0c1e,0x02582256,0x02176656,0x0257be1d)    R(0x0c1f,0x01faee9a,0x021a5ab5,0x02fa9a7d)    R(0x0c20,0x01faee9a,0x02fa9a7d,0x025b3a74)    R(0x0c21,0x02683299,0x02279692,0x02582256)    R(0x0c22,0x02da2a5c,0x02a9a230,0x022a4227)    R(0x0c23,0x02aaca50,0x02da2a5c,0x022a4227)    R(0x0c24,0x021a5ab5,0x02d9f698,0x02fa9a7d)    R(0x0c25,0x025b3a74,0x02fa9a7d,0x02aaca50)\n    R(0x0c26,0x02d9f698,0x02a97a6f,0x02da2a5c)    R(0x0c27,0x02fa9a7d,0x02da2a5c,0x02aaca50)    R(0x0c28,0x00660eed,0x007606ac,0x0086a2be)    R(0x0c29,0x0c47cb02,0x09d7aaf3,0x0a480b0c)    R(0x0c2a,0x02a9a230,0x02a92e03,0x0209d1fb)    R(0x0c2b,0x04facafd,0x035b36ee,0x053b7aec)    R(0x0c2c,0x0a275ef7,0x088766f1,0x09d7aaf3)    R(0x0c2d,0x0c378efb,0x0a275ef7,0x09d7aaf3)    R(0x0c2e,0x01b73ac9,0x02279692,0x0267e2cf)    R(0x0c2f,0x0288e642,0x0288720f,0x02a92e03)\n    R(0x0c30,0x0826fb08,0x07171b06,0x088766f1)    R(0x0c31,0x09d7aaf3,0x08880308,0x0a480b0c)    R(0x0c32,0x0267e2cf,0x02683299,0x02989ec8)    R(0x0c33,0x0267e2cf,0x02279692,0x02683299)    R(0x0c34,0x02490eea,0x022852f9,0x02989ec8)    R(0x0c35,0x088766f1,0x08279ef6,0x09d7aaf3)    R(0x0c36,0x09d7aaf3,0x08279ef6,0x08880308)    R(0x0c37,0x022852f9,0x0267e2cf,0x02989ec8)    R(0x0c38,0x022a4227,0x02a9a230,0x0209d1fb)    R(0x0c39,0x037a8f09,0x01cad2fd,0x035b36ee)\n    R(0x0c3a,0x0a275ef7,0x0826fb08,0x088766f1)    R(0x0c3b,0x02490eea,0x02989ec8,0x02b94ab1)    R(0x0c3c,0x0239becf,0x02b94ab1,0x02d9f698)    R(0x0c3d,0x02989ec8,0x0288ce83,0x02b94ab1)    R(0x0c3e,0x0239becf,0x02d9f698,0x021a5ab5)    R(0x0c3f,0x04facafd,0x037a8f09,0x035b36ee)    R(0x0c40,0x088766f1,0x07171b06,0x08279ef6)    R(0x0c41,0x02490eea,0x02b94ab1,0x0239becf)    R(0x0c42,0x012b4ecb,0x013b729b,0x014be2a0)    R(0x0c43,0x063e9e03,0x05fee5ca,0x074f15eb)\n    R(0x0c44,0x08255707,0x07950aeb,0x06e52b08)    R(0x0c45,0x0b4c1b11,0x08ac26fa,0x0a9c9eeb)    R(0x0c46,0x0b6ef61c,0x0a4f320f,0x0c6f6602)    R(0x0c47,0x0d5ed60b,0x0e1f59f7,0x0f7ef1ea)    R(0x0c48,0x032d0e19,0x025d15dc,0x039d99fa)    R(0x0c49,0x063e9e03,0x074f15eb,0x081eee11)    R(0x0c4a,0x065d1681,0x060d5e4d,0x085d8665)    R(0x0c4b,0x016bbec9,0x012b4ecb,0x014be2a0)    R(0x0c4c,0x035b36ee,0x01fb9add,0x042bd6d8)    R(0x0c4d,0x06fbaf09,0x053b7aec,0x068c12d7)\n    R(0x0c4e,0x015bce64,0x01cb524d,0x015b8a23)    R(0x0c4f,0x018c262b,0x01abc5ec,0x01bc65e3)    R(0x0c50,0x065d1681,0x043cf67c,0x060d5e4d)    R(0x0c51,0x060d5e4d,0x064dce2a,0x081dc63a)    R(0x0c52,0x06ce6e23,0x063e9e03,0x081eee11)    R(0x0c53,0x018c262b,0x01bc65e3,0x021ca20a)    R(0x0c54,0x019c466d,0x015bce64,0x018c262b)    R(0x0c55,0x025c9e42,0x018c262b,0x021ca20a)    R(0x0c56,0x043cf67c,0x029cae78,0x03ed064a)    R(0x0c57,0x03ed064a,0x032d0e19,0x04bd6e25)\n    R(0x0c58,0x043cf67c,0x03ed064a,0x060d5e4d)    R(0x0c59,0x03ed064a,0x025c9e42,0x032d0e19)    R(0x0c5a,0x029cae78,0x019c466d,0x025c9e42)    R(0x0c5b,0x025c9e42,0x021ca20a,0x032d0e19)    R(0x0c5c,0x029cae78,0x025c9e42,0x03ed064a)    R(0x0c5d,0x018c262b,0x015b8a23,0x01abc5ec)    R(0x0c5e,0x019c466d,0x018c262b,0x025c9e42)    R(0x0c5f,0x06ce6e23,0x051e0611,0x063e9e03)    R(0x0c60,0x081e2a2f,0x064dce2a,0x06ce6e23)    R(0x0c61,0x060d5e4d,0x03ed064a,0x04bd6e25)\n    R(0x0c62,0x04bd6e25,0x051e0611,0x064dce2a)    R(0x0c63,0x060d5e4d,0x04bd6e25,0x064dce2a)    R(0x0c64,0x04bd6e25,0x032d0e19,0x039d99fa)    R(0x0c65,0x064dce2a,0x051e0611,0x06ce6e23)    R(0x0c66,0x04bd6e25,0x039d99fa,0x051e0611)    R(0x0c67,0x053b7aec,0x035b36ee,0x042bd6d8)    R(0x0c68,0x01bc4ea2,0x014be2a0,0x019c466d)    R(0x0c69,0x085c9ecb,0x068c12d7,0x06ccaaa8)    R(0x0c6a,0x032d0e19,0x021ca20a,0x025d15dc)    R(0x0c6b,0x051e0611,0x04be41eb,0x063e9e03)\n    R(0x0c6c,0x01fc26c3,0x016bbec9,0x01bc4ea2)    R(0x0c6d,0x01fb9add,0x016bbec9,0x01fc26c3)    R(0x0c6e,0x029cae78,0x01bc4ea2,0x019c466d)    R(0x0c6f,0x054c56c2,0x030c4ac4,0x047cbea5)    R(0x0c70,0x053b7aec,0x042bd6d8,0x068c12d7)    R(0x0c71,0x068c12d7,0x054c56c2,0x06ccaaa8)    R(0x0c72,0x02dc9aa4,0x01fc26c3,0x01bc4ea2)    R(0x0c73,0x030c4ac4,0x01fc26c3,0x02dc9aa4)    R(0x0c74,0x068c12d7,0x042bd6d8,0x054c56c2)    R(0x0c75,0x042bd6d8,0x030c4ac4,0x054c56c2)\n    R(0x0c76,0x01fb9add,0x01fc26c3,0x030c4ac4)    R(0x0c77,0x02dc9aa4,0x01bc4ea2,0x029cae78)    R(0x0c78,0x039d99fa,0x04be41eb,0x051e0611)    R(0x0c79,0x06ccaaa8,0x054c56c2,0x047cbea5)    R(0x0c7a,0x047cbea5,0x030c4ac4,0x02dc9aa4)    R(0x0c7b,0x047cbea5,0x02dc9aa4,0x043cf67c)    R(0x0c7c,0x042bd6d8,0x01fb9add,0x030c4ac4)    R(0x0c7d,0x065d1681,0x047cbea5,0x043cf67c)    R(0x0c7e,0x043cf67c,0x02dc9aa4,0x029cae78)    R(0x0c7f,0x06ccaaa8,0x047cbea5,0x065d1681)\n    R(0x0c80,0x081eee11,0x074f15eb,0x093f61ef)    R(0x0c81,0x0d5ed60b,0x0c6f6602,0x0e1f59f7)    R(0x0c82,0x014be2a0,0x013b729b,0x015bce64)    R(0x0c83,0x0f7d06d1,0x0ccd06cc,0x0ead6ea6)    R(0x0c84,0x097516ed,0x07950aeb,0x08255707)    R(0x0c85,0x0d4c9af4,0x0b4c1b11,0x0a9c9eeb)    R(0x0c86,0x015bce64,0x015b8a23,0x018c262b)    R(0x0c87,0x0ddde27c,0x0c6e1256,0x0e7e3e40)    R(0x0c88,0x0e7e3e40,0x0c5e4227,0x0f1e6210)    R(0x0c89,0x0c0e6a1c,0x0b6ef61c,0x0d5ed60b)\n    R(0x0c8a,0x08dec625,0x081eee11,0x0a4f320f)    R(0x0c8b,0x0a3df247,0x081dc63a,0x0a5e1e2e)    R(0x0c8c,0x085d8665,0x060d5e4d,0x081dc63a)    R(0x0c8d,0x0a5e1e2e,0x081e2a2f,0x0a0e6e2a)    R(0x0c8e,0x0a5e1e2e,0x0a0e6e2a,0x0c0e6a1c)    R(0x0c8f,0x0e7e3e40,0x0c6e1256,0x0c5e4227)    R(0x0c90,0x085d8665,0x081dc63a,0x0a3df247)    R(0x0c91,0x0c5e4227,0x0a3df247,0x0a5e1e2e)    R(0x0c92,0x0c5e4227,0x0a5e1e2e,0x0c0e6a1c)    R(0x0c93,0x0c6e1256,0x0a3df247,0x0c5e4227)\n    R(0x0c94,0x0a5e1e2e,0x081dc63a,0x081e2a2f)    R(0x0c95,0x081dc63a,0x064dce2a,0x081e2a2f)    R(0x0c96,0x0b6ef61c,0x08dec625,0x0a4f320f)    R(0x0c97,0x0addb27b,0x0a3df247,0x0c6e1256)    R(0x0c98,0x0c5e4227,0x0c0e6a1c,0x0dbe6a0d)    R(0x0c99,0x0c5e4227,0x0dbe6a0d,0x0f1e6210)    R(0x0c9a,0x081e2a2f,0x06ce6e23,0x08dec625)    R(0x0c9b,0x0c0e6a1c,0x0a0e6e2a,0x0b6ef61c)    R(0x0c9c,0x06ce6e23,0x081eee11,0x08dec625)    R(0x0c9d,0x081e2a2f,0x08dec625,0x0a0e6e2a)\n    R(0x0c9e,0x0a0e6e2a,0x08dec625,0x0b6ef61c)    R(0x0c9f,0x0a55670c,0x097516ed,0x08255707)    R(0x0ca0,0x016bbec9,0x014be2a0,0x01bc4ea2)    R(0x0ca1,0x0dbe6a0d,0x0d5ed60b,0x0eee95f6)    R(0x0ca2,0x0b6ef61c,0x0c6f6602,0x0d5ed60b)    R(0x0ca3,0x0a4f320f,0x081eee11,0x093f61ef)    R(0x0ca4,0x0a9c9eeb,0x08ac26fa,0x085c9ecb)    R(0x0ca5,0x08ed2697,0x06ccaaa8,0x065d1681)    R(0x0ca6,0x08ed2697,0x065d1681,0x085d8665)    R(0x0ca7,0x0d4c9af4,0x0a9c9eeb,0x0ccd06cc)\n    R(0x0ca8,0x0ead6ea6,0x0ccd06cc,0x0bfd72a0)    R(0x0ca9,0x0a9c9eeb,0x085c9ecb,0x0a6d06c1)    R(0x0caa,0x0bfd72a0,0x0a6d06c1,0x08ed2697)    R(0x0cab,0x0a9c9eeb,0x0a6d06c1,0x0ccd06cc)    R(0x0cac,0x0ccd06cc,0x0a6d06c1,0x0bfd72a0)    R(0x0cad,0x085c9ecb,0x06ccaaa8,0x08ed2697)    R(0x0cae,0x0a6d06c1,0x085c9ecb,0x08ed2697)    R(0x0caf,0x019c466d,0x014be2a0,0x015bce64)    R(0x0cb0,0x08ac26fa,0x06fbaf09,0x068c12d7)    R(0x0cb1,0x0c0e6a1c,0x0d5ed60b,0x0dbe6a0d)\n    R(0x0cb2,0x0ead6ea6,0x0bfd72a0,0x0ddde27c)    R(0x0cb3,0x0addb27b,0x085d8665,0x0a3df247)    R(0x0cb4,0x0bfd72a0,0x08ed2697,0x0addb27b)    R(0x0cb5,0x0bfd72a0,0x0addb27b,0x0ddde27c)    R(0x0cb6,0x0ddde27c,0x0addb27b,0x0c6e1256)    R(0x0cb7,0x08ac26fa,0x068c12d7,0x085c9ecb)    R(0x0cb8,0x08ed2697,0x085d8665,0x0addb27b)    R(0x0cb9,0x06452f22,0x0574df48,0x05b57f36)    R(0x0cba,0x01c5437c,0x0124ef7f,0x00d56b72)    R(0x0cbb,0x0085af5c,0x00750b73,0x00352b50)\n    R(0x0cbc,0x0fa5ff44,0x0d061334,0x0dd68735)    R(0x0cbd,0x02a92e03,0x0288720f,0x02b8c9cd)    R(0x0cbe,0x021ca20a,0x01bc65e3,0x025d15dc)    R(0x0cbf,0x00352b50,0x00454b0f,0x0055d730)    R(0x0cc0,0x0055d730,0x00660eed,0x00768f16)    R(0x0cc1,0x01c5437c,0x00d56b72,0x0145cb65)    R(0x0cc2,0x0a480b0c,0x08880308,0x08f8872c)    R(0x0cc3,0x0ee70326,0x0dd68735,0x0c671f14)    R(0x0cc4,0x0e358331,0x0ea4e73c,0x0cb51714)    R(0x0cc5,0x00875b25,0x0096f2f5,0x01679afc)\n    R(0x0cc6,0x00a64f3a,0x0055d730,0x00768f16)    R(0x0cc7,0x05c5ff2e,0x0435b751,0x0396533e)    R(0x0cc8,0x00d56b72,0x00750b73,0x0085af5c)    R(0x0cc9,0x0295bf62,0x01c5437c,0x0145cb65)    R(0x0cca,0x02d80f7a,0x01a7e777,0x01e86779)    R(0x0ccb,0x00e6274f,0x0085af5c,0x00a64f3a)    R(0x0ccc,0x0396533e,0x0295bf62,0x01d65348)    R(0x0ccd,0x0576ff24,0x0356c334,0x03f7334c)    R(0x0cce,0x00c81721,0x00875b25,0x01679afc)    R(0x0ccf,0x0396533e,0x01d65348,0x02669f36)\n    R(0x0cd0,0x0136933a,0x00e6274f,0x00d6ab36)    R(0x0cd1,0x00d6ab36,0x00a64f3a,0x0096ef31)    R(0x0cd2,0x0166cb3c,0x00d6ab36,0x00e71b48)    R(0x0cd3,0x0356c334,0x0166cb3c,0x0257034a)    R(0x0cd4,0x04b6ab27,0x02669f36,0x0356c334)    R(0x0cd5,0x02669f36,0x01d65348,0x0136933a)    R(0x0cd6,0x0136933a,0x00d6ab36,0x0166cb3c)    R(0x0cd7,0x02669f36,0x0166cb3c,0x0356c334)    R(0x0cd8,0x02669f36,0x0136933a,0x0166cb3c)    R(0x0cd9,0x04b6ab27,0x0396533e,0x02669f36)\n    R(0x0cda,0x0096ef31,0x00875b25,0x00a78750)    R(0x0cdb,0x00a7ff45,0x00875b25,0x00c81721)    R(0x0cdc,0x00e6274f,0x00a64f3a,0x00d6ab36)    R(0x0cdd,0x0166cb3c,0x00e71b48,0x0177575d)    R(0x0cde,0x0356c334,0x0257034a,0x03f7334c)    R(0x0cdf,0x00a78750,0x00875b25,0x00a7ff45)    R(0x0ce0,0x00e71b48,0x0096ef31,0x00a78750)    R(0x0ce1,0x01d65348,0x00e6274f,0x0136933a)    R(0x0ce2,0x0166cb3c,0x0177575d,0x0257034a)    R(0x0ce3,0x00d6ab36,0x0096ef31,0x00e71b48)\n    R(0x0ce4,0x0435b751,0x04a52f5e,0x03353b75)    R(0x0ce5,0x03353b75,0x01c5437c,0x0295bf62)    R(0x0ce6,0x00a64f3a,0x00768f16,0x0096ef31)    R(0x0ce7,0x04b6ab27,0x0356c334,0x0576ff24)    R(0x0ce8,0x00c81721,0x01679afc,0x022852f9)    R(0x0ce9,0x0407bf68,0x02d80f7a,0x0488576e)    R(0x0cea,0x00e6274f,0x00d56b72,0x0085af5c)    R(0x0ceb,0x00e71b48,0x00a78750,0x00f7bf6a)    R(0x0cec,0x0435b751,0x03353b75,0x0295bf62)    R(0x0ced,0x01d65348,0x0145cb65,0x00e6274f)\n    R(0x0cee,0x0295bf62,0x0145cb65,0x01d65348)    R(0x0cef,0x0257034a,0x0177575d,0x02978b6c)    R(0x0cf0,0x03f7334c,0x0257034a,0x02978b6c)    R(0x0cf1,0x00e71b48,0x00f7bf6a,0x0177575d)    R(0x0cf2,0x03f7334c,0x02978b6c,0x0407bf68)    R(0x0cf3,0x00c83765,0x00a78750,0x00a7ff45)    R(0x0cf4,0x01284f75,0x00f7bf6a,0x00c83765)    R(0x0cf5,0x0145cb65,0x00d56b72,0x00e6274f)    R(0x0cf6,0x02978b6c,0x01a7e777,0x02d80f7a)    R(0x0cf7,0x0435b751,0x0295bf62,0x0396533e)\n    R(0x0cf8,0x0177575d,0x00f7bf6a,0x01a7e777)    R(0x0cf9,0x02978b6c,0x0177575d,0x01a7e777)    R(0x0cfa,0x00f7bf6a,0x00a78750,0x00c83765)    R(0x0cfb,0x0407bf68,0x02978b6c,0x02d80f7a)    R(0x0cfc,0x01a7e777,0x00f7bf6a,0x01284f75)    R(0x0cfd,0x0c15931e,0x0b550ef5,0x0a55670c)    R(0x0cfe,0x0ee70326,0x0c671f14,0x0ea76b0d)    R(0x0cff,0x0085af5c,0x0055d730,0x00a64f3a)    R(0x0d00,0x05a80f58,0x0407bf68,0x0488576e)    R(0x0d01,0x0a16e715,0x0826fb08,0x0a275ef7)\n    R(0x0d02,0x08279ef6,0x07378311,0x07a81f13)    R(0x0d03,0x0e358331,0x0cb51714,0x0c15931e)    R(0x0d04,0x00768f16,0x0096f2f5,0x00875b25)    R(0x0d05,0x0ea76b0d,0x0c671f14,0x0c378efb)    R(0x0d06,0x0e67fb21,0x0c47cb02,0x0c284726)    R(0x0d07,0x08c5b31c,0x08255707,0x06f58b1e)    R(0x0d08,0x0c15931e,0x0a55670c,0x0a360729)    R(0x0d09,0x07171b06,0x04b6ab27,0x0576ff24)    R(0x0d0a,0x0a360729,0x0a55670c,0x08c5b31c)    R(0x0d0b,0x0c671f14,0x0b467f2d,0x0a16e715)\n    R(0x0d0c,0x08b66b22,0x0785ff23,0x06968b1d)    R(0x0d0d,0x08c5b31c,0x06f58b1e,0x0785ff23)    R(0x0d0e,0x08b66b22,0x06968b1d,0x0826fb08)    R(0x0d0f,0x0a16e715,0x08b66b22,0x0826fb08)    R(0x0d10,0x06968b1d,0x04b6ab27,0x07171b06)    R(0x0d11,0x0826fb08,0x06968b1d,0x07171b06)    R(0x0d12,0x07171b06,0x0576ff24,0x07378311)    R(0x0d13,0x06f58b1e,0x06e52b08,0x06452f22)    R(0x0d14,0x07378311,0x06f81b31,0x07a81f13)    R(0x0d15,0x07171b06,0x07378311,0x08279ef6)\n    R(0x0d16,0x0c47cb02,0x0a480b0c,0x0c284726)    R(0x0d17,0x0e97a30b,0x0c378efb,0x0c47cb02)    R(0x0d18,0x0c671f14,0x0a16e715,0x0a275ef7)    R(0x0d19,0x08255707,0x06e52b08,0x06f58b1e)    R(0x0d1a,0x0a55670c,0x08255707,0x08c5b31c)    R(0x0d1b,0x0e97a30b,0x0c47cb02,0x0e67fb21)    R(0x0d1c,0x06f58b1e,0x06452f22,0x05b57f36)    R(0x0d1d,0x0096ef31,0x00768f16,0x00875b25)    R(0x0d1e,0x03f7334c,0x0407bf68,0x05a7833e)    R(0x0d1f,0x0ea76b0d,0x0c378efb,0x0e97a30b)\n    R(0x0d20,0x08279ef6,0x07a81f13,0x08880308)    R(0x0d21,0x0785ff23,0x06f58b1e,0x05c5ff2e)    R(0x0d22,0x05c5ff2e,0x0396533e,0x04b6ab27)    R(0x0d23,0x0b467f2d,0x08b66b22,0x0a16e715)    R(0x0d24,0x0d061334,0x0c15931e,0x0a360729)    R(0x0d25,0x0dd68735,0x0d061334,0x0b467f2d)    R(0x0d26,0x0a360729,0x08c5b31c,0x0785ff23)    R(0x0d27,0x06968b1d,0x05c5ff2e,0x04b6ab27)    R(0x0d28,0x0b467f2d,0x0a360729,0x08b66b22)    R(0x0d29,0x0d061334,0x0a360729,0x0b467f2d)\n    R(0x0d2a,0x0785ff23,0x05c5ff2e,0x06968b1d)    R(0x0d2b,0x0a360729,0x0785ff23,0x08b66b22)    R(0x0d2c,0x05b57f36,0x04a52f5e,0x0435b751)    R(0x0d2d,0x0576ff24,0x03f7334c,0x05a7833e)    R(0x0d2e,0x05a7833e,0x0407bf68,0x05a80f58)    R(0x0d2f,0x05a7833e,0x05a80f58,0x06f81b31)    R(0x0d30,0x0576ff24,0x05a7833e,0x07378311)    R(0x0d31,0x0e358331,0x0c15931e,0x0d061334)    R(0x0d32,0x06f58b1e,0x05b57f36,0x05c5ff2e)    R(0x0d33,0x07378311,0x05a7833e,0x06f81b31)\n    R(0x0d34,0x0dd68735,0x0b467f2d,0x0c671f14)    R(0x0d35,0x05c5ff2e,0x05b57f36,0x0435b751)    R(0x0d36,0x00b8b744,0x00a7ff45,0x00c81721)    R(0x0d37,0x0209d1fb,0x02a92e03,0x028969cd)    R(0x0d38,0x03587f76,0x02d80f7a,0x01e86779)    R(0x0d39,0x05b57f36,0x0574df48,0x04a52f5e)    R(0x0d3a,0x0e0c2f1e,0x0b4c1b11,0x0d4c9af4)    R(0x0d3b,0x0fa99b72,0x0cf99368,0x0d9a2b6a)    R(0x0d3c,0x061b1f13,0x053b7aec,0x06fbaf09)    R(0x0d3d,0x075aa73a,0x05da7718,0x061b1f13)\n    R(0x0d3e,0x00c83765,0x00a7ff45,0x00b8b744)    R(0x0d3f,0x0488576e,0x02d80f7a,0x03587f76)    R(0x0d40,0x01e86779,0x01a7e777,0x01284f75)    R(0x0d41,0x00f9ff0c,0x00d95b22,0x00f98efd)    R(0x0d42,0x00c81721,0x022852f9,0x00e8d318)    R(0x0d43,0x00b8b744,0x00c81721,0x00e8d318)    R(0x0d44,0x04195f48,0x02498342,0x03b9ff26)    R(0x0d45,0x075aa73a,0x0699eb30,0x05da7718)    R(0x0d46,0x05da7718,0x057a1717,0x04facafd)    R(0x0d47,0x0649732d,0x06a90b30,0x0589932c)\n    R(0x0d48,0x00e9533b,0x00d95b22,0x00f9ff0c)    R(0x0d49,0x01ca2320,0x01496b43,0x0139e724)    R(0x0d4a,0x0589932c,0x04195f48,0x03b9ff26)    R(0x0d4b,0x06f8a72e,0x05d9173f,0x06a90b30)    R(0x0d4c,0x02498342,0x01496b43,0x01ca2320)    R(0x0d4d,0x01496b43,0x00e9533b,0x0139e724)    R(0x0d4e,0x0649732d,0x0589932c,0x057a1717)    R(0x0d4f,0x0649732d,0x057a1717,0x0699eb30)    R(0x0d50,0x0139e724,0x00e9533b,0x00f9ff0c)    R(0x0d51,0x00d95b22,0x00e8d318,0x00f98efd)\n    R(0x0d52,0x03b9ff26,0x02498342,0x01ca2320)    R(0x0d53,0x057a1717,0x037a8f09,0x04facafd)    R(0x0d54,0x06a90b30,0x05d9173f,0x0589932c)    R(0x0d55,0x03b9ff26,0x01ca2320,0x037a8f09)    R(0x0d56,0x057a1717,0x03b9ff26,0x037a8f09)    R(0x0d57,0x01ca2320,0x0139e724,0x014a7b07)    R(0x0d58,0x0589932c,0x03b9ff26,0x057a1717)    R(0x0d59,0x0699eb30,0x057a1717,0x05da7718)    R(0x0d5a,0x0139e724,0x00f9ff0c,0x014a7b07)    R(0x0d5b,0x06f81b31,0x05a80f58,0x0628974e)\n    R(0x0d5c,0x01e86779,0x01284f75,0x0188df65)    R(0x0d5d,0x00f8cf5e,0x00c83765,0x00b8b744)    R(0x0d5e,0x01ca2320,0x014a7b07,0x01cad2fd)    R(0x0d5f,0x05da7718,0x04facafd,0x061b1f13)    R(0x0d60,0x01284f75,0x00c83765,0x00f8cf5e)    R(0x0d61,0x00f8cf5e,0x00b8b744,0x00e9533b)    R(0x0d62,0x0188df65,0x01284f75,0x00f8cf5e)    R(0x0d63,0x0188df65,0x00f8cf5e,0x01496b43)    R(0x0d64,0x02c8f363,0x01e86779,0x0188df65)    R(0x0d65,0x06f8a72e,0x0628974e,0x05d9173f)\n    R(0x0d66,0x04a8d363,0x03587f76,0x02c8f363)    R(0x0d67,0x0628974e,0x0488576e,0x04a8d363)    R(0x0d68,0x0628974e,0x04a8d363,0x05d9173f)    R(0x0d69,0x03587f76,0x01e86779,0x02c8f363)    R(0x0d6a,0x01496b43,0x00f8cf5e,0x00e9533b)    R(0x0d6b,0x037a8f09,0x01ca2320,0x01cad2fd)    R(0x0d6c,0x0488576e,0x03587f76,0x04a8d363)    R(0x0d6d,0x0628974e,0x05a80f58,0x0488576e)    R(0x0d6e,0x04195f48,0x02c8f363,0x02498342)    R(0x0d6f,0x04195f48,0x04a8d363,0x02c8f363)\n    R(0x0d70,0x02c8f363,0x0188df65,0x02498342)    R(0x0d71,0x05d9173f,0x04a8d363,0x04195f48)    R(0x0d72,0x0589932c,0x05d9173f,0x04195f48)    R(0x0d73,0x02498342,0x0188df65,0x01496b43)    R(0x0d74,0x0cb51714,0x0b550ef5,0x0c15931e)    R(0x0d75,0x0e0c2f1e,0x0c6baf3c,0x0b4c1b11)    R(0x0d76,0x00b8b744,0x00e8d318,0x00d95b22)    R(0x0d77,0x0fa99b72,0x0eb9076e,0x0cf99368)    R(0x0d78,0x07fb3b32,0x061b1f13,0x06fbaf09)    R(0x0d79,0x08f8872c,0x08880308,0x07888f27)\n    R(0x0d7a,0x0e67fb21,0x0c284726,0x0e089351)    R(0x0d7b,0x00e9533b,0x00b8b744,0x00d95b22)    R(0x0d7c,0x094bbb24,0x06fbaf09,0x08ac26fa)    R(0x0d7d,0x0f4bc73f,0x0c6baf3c,0x0e0c2f1e)    R(0x0d7e,0x06f8a72e,0x06f81b31,0x0628974e)    R(0x0d7f,0x0c284726,0x08f8872c,0x0b38b744)    R(0x0d80,0x0778f334,0x06a90b30,0x0649732d)    R(0x0d81,0x07d97742,0x0649732d,0x0699eb30)    R(0x0d82,0x08f8872c,0x0778f334,0x09790f4b)    R(0x0d83,0x0c284726,0x0a480b0c,0x08f8872c)\n    R(0x0d84,0x07888f27,0x06a90b30,0x0778f334)    R(0x0d85,0x08f8872c,0x07888f27,0x0778f334)    R(0x0d86,0x07888f27,0x06f8a72e,0x06a90b30)    R(0x0d87,0x0b38b744,0x08f8872c,0x09790f4b)    R(0x0d88,0x07d97742,0x0778f334,0x0649732d)    R(0x0d89,0x075aa73a,0x061b1f13,0x07fb3b32)    R(0x0d8a,0x07a81f13,0x06f81b31,0x06f8a72e)    R(0x0d8b,0x089a274c,0x0699eb30,0x075aa73a)    R(0x0d8c,0x0b4c1b11,0x094bbb24,0x08ac26fa)    R(0x0d8d,0x0a9b4741,0x094bbb24,0x0c6baf3c)\n    R(0x0d8e,0x095abf4c,0x075aa73a,0x07fb3b32)    R(0x0d8f,0x0a9b4741,0x07fb3b32,0x094bbb24)    R(0x0d90,0x07888f27,0x07a81f13,0x06f8a72e)    R(0x0d91,0x07fb3b32,0x06fbaf09,0x094bbb24)    R(0x0d92,0x0c6baf3c,0x094bbb24,0x0b4c1b11)    R(0x0d93,0x08880308,0x07a81f13,0x07888f27)    R(0x0d94,0x0eb9076e,0x0e089351,0x0c39175d)    R(0x0d95,0x07d97742,0x0699eb30,0x089a274c)    R(0x0d96,0x0e2b4353,0x0c6baf3c,0x0f4bc73f)    R(0x0d97,0x0c39175d,0x0b38b744,0x09790f4b)\n    R(0x0d98,0x09790f4b,0x0778f334,0x07d97742)    R(0x0d99,0x0a89a35b,0x07d97742,0x089a274c)    R(0x0d9a,0x0b1a3f5e,0x089a274c,0x095abf4c)    R(0x0d9b,0x0e089351,0x0b38b744,0x0c39175d)    R(0x0d9c,0x0eb9076e,0x0c39175d,0x0cf99368)    R(0x0d9d,0x0c39175d,0x09790f4b,0x0a89a35b)    R(0x0d9e,0x0cf99368,0x0a89a35b,0x0b1a3f5e)    R(0x0d9f,0x0cf99368,0x0c39175d,0x0a89a35b)    R(0x0da0,0x0a89a35b,0x09790f4b,0x07d97742)    R(0x0da1,0x0cf99368,0x0b1a3f5e,0x0d9a2b6a)\n    R(0x0da2,0x0a89a35b,0x089a274c,0x0b1a3f5e)    R(0x0da3,0x095abf4c,0x089a274c,0x075aa73a)    R(0x0da4,0x0d9a2b6a,0x0b1a3f5e,0x0c2ae35b)    R(0x0da5,0x0e2b4353,0x0a9b4741,0x0c6baf3c)    R(0x0da6,0x0c284726,0x0b38b744,0x0e089351)    R(0x0da7,0x0ebab366,0x0d9a2b6a,0x0c2ae35b)    R(0x0da8,0x0c2ae35b,0x0a9b4741,0x0e2b4353)    R(0x0da9,0x0c2ae35b,0x095abf4c,0x0a9b4741)    R(0x0daa,0x0c2ae35b,0x0b1a3f5e,0x095abf4c)    R(0x0dab,0x095abf4c,0x07fb3b32,0x0a9b4741)\n    R(0x0dac,0x0ebab366,0x0c2ae35b,0x0e2b4353)    R(0x0dad,0x0e1f59f7,0x0fff69d5,0x0f7ef1ea)    R(0x0dae,0x16be7201,0x13ce7df9,0x15ae81cd)    R(0x0daf,0x367551f2,0x38b57de6,0x37352205)    R(0x0db0,0x00355ecd,0x0065668e,0x007606ac)    R(0x0db1,0x1e155344,0x1da4af58,0x1b956f59)    R(0x0db2,0x16587f81,0x14784f81,0x14b8b78f)    R(0x0db3,0x26e55dd6,0x2754cdee,0x27654617)    R(0x0db4,0x34e5120c,0x367551f2,0x37352205)    R(0x0db5,0x2455d6cb,0x237562e0,0x2235cef8)\n    R(0x0db6,0x196e5209,0x16be7201,0x189e69ce)    R(0x0db7,0x0d5ed60b,0x0f7ef1ea,0x0eee95f6)    R(0x0db8,0x27953a4f,0x28f4ea58,0x27953a7f)    R(0x0db9,0x218abedb,0x1f3a7ef2,0x1f2b0ed8)    R(0x0dba,0x23667ad5,0x2455d6cb,0x2235cef8)    R(0x0dbb,0x259ae69a,0x26cb4e67,0x270a9e7d)    R(0x0dbc,0x264681f8,0x263605d1,0x26e5e608)    R(0x0dbd,0x27654617,0x2804e222,0x27953a4f)    R(0x0dbe,0x34e5120c,0x354565dd,0x367551f2)    R(0x0dbf,0x26970dda,0x264681f8,0x2686fe18)\n    R(0x0dc0,0x2768264d,0x26076e65,0x2638067e)    R(0x0dc1,0x239b1eb2,0x259ae69a,0x239a7ac9)    R(0x0dc2,0x24d54ecb,0x273532be,0x25552af1)    R(0x0dc3,0x237562e0,0x24d54ecb,0x23152ef7)    R(0x0dc4,0x2127d6f3,0x23379ecc,0x21c726e6)    R(0x0dc5,0x26b58675,0x26355a9c,0x251576b5)    R(0x0dc6,0x25d5ca99,0x251576b5,0x2455d6cb)    R(0x0dc7,0x2686fe18,0x264681f8,0x26866633)    R(0x0dc8,0x27093e8d,0x26589a94,0x2528d2bd)    R(0x0dc9,0x239a7ac9,0x259ae69a,0x257a32ad)\n    R(0x0dca,0x25066ea8,0x2656466f,0x25d5ca99)    R(0x0dcb,0x24c77a9b,0x2526ea83,0x23c706b9)    R(0x0dcc,0x2638067e,0x26076e65,0x24c77a9b)    R(0x0dcd,0x25d5ca99,0x26b58675,0x251576b5)    R(0x0dce,0x26f78a32,0x2686fe18,0x2626e64f)    R(0x0dcf,0x23c706b9,0x2526ea83,0x25066ea8)    R(0x0dd0,0x26076e65,0x2626e64f,0x2526ea83)    R(0x0dd1,0x24c77a9b,0x26076e65,0x2526ea83)    R(0x0dd2,0x2526ea83,0x2626e64f,0x2656466f)    R(0x0dd3,0x2526ea83,0x2656466f,0x25066ea8)\n    R(0x0dd4,0x25066ea8,0x25d5ca99,0x2455d6cb)    R(0x0dd5,0x25897eb8,0x27093e8d,0x2528d2bd)    R(0x0dd6,0x259ae69a,0x270a9e7d,0x257a32ad)    R(0x0dd7,0x2656466f,0x26b58675,0x25d5ca99)    R(0x0dd8,0x24d81ab2,0x2638067e,0x24c77a9b)    R(0x0dd9,0x257a32ad,0x2709de8b,0x25897eb8)    R(0x0dda,0x2528d2bd,0x26589a94,0x24d81ab2)    R(0x0ddb,0x26589a94,0x2638067e,0x24d81ab2)    R(0x0ddc,0x270a9e7d,0x2709de8b,0x257a32ad)    R(0x0ddd,0x2709de8b,0x27093e8d,0x25897eb8)\n    R(0x0dde,0x26355a9c,0x273532be,0x24d54ecb)    R(0x0ddf,0x21c726e6,0x23667ad5,0x21667ef5)    R(0x0de0,0x2686fe18,0x26866633,0x2626e64f)    R(0x0de1,0x218abedb,0x239b1eb2,0x239a7ac9)    R(0x0de2,0x25066ea8,0x2455d6cb,0x23667ad5)    R(0x0de3,0x2626e64f,0x26866633,0x2656466f)    R(0x0de4,0x23379ecc,0x23c706b9,0x21c726e6)    R(0x0de5,0x234852db,0x24d81ab2,0x23379ecc)    R(0x0de6,0x251576b5,0x24d54ecb,0x237562e0)    R(0x0de7,0x26f78a32,0x2626e64f,0x26076e65)\n    R(0x0de8,0x23c706b9,0x25066ea8,0x23667ad5)    R(0x0de9,0x24d81ab2,0x24c77a9b,0x23379ecc)    R(0x0dea,0x23c706b9,0x23667ad5,0x21c726e6)    R(0x0deb,0x251576b5,0x26355a9c,0x24d54ecb)    R(0x0dec,0x23379ecc,0x24c77a9b,0x23c706b9)    R(0x0ded,0x218abedb,0x239a7ac9,0x21aa1eec)    R(0x0dee,0x23b9cad7,0x239912dd,0x219962f5)    R(0x0def,0x239a7ac9,0x257a32ad,0x23b9cad7)    R(0x0df0,0x23b9cad7,0x25897eb8,0x239912dd)    R(0x0df1,0x2455d6cb,0x251576b5,0x237562e0)\n    R(0x0df2,0x239912dd,0x2528d2bd,0x234852db)    R(0x0df3,0x239a7ac9,0x23b9cad7,0x21aa1eec)    R(0x0df4,0x2528d2bd,0x24d81ab2,0x234852db)    R(0x0df5,0x25897eb8,0x2528d2bd,0x239912dd)    R(0x0df6,0x257a32ad,0x25897eb8,0x23b9cad7)    R(0x0df7,0x33a55e02,0x3485c5df,0x354565dd)    R(0x0df8,0x281b4def,0x28dab5d5,0x28babe12)    R(0x0df9,0x3314f624,0x33058a05,0x33a55e02)    R(0x0dfa,0x234852db,0x23379ecc,0x2127d6f3)    R(0x0dfb,0x239912dd,0x234852db,0x2168a2f7)\n    R(0x0dfc,0x2898ddf5,0x28083dd5,0x27f83a15)    R(0x0dfd,0x31951224,0x33058a05,0x3314f624)    R(0x0dfe,0x33a55e02,0x354565dd,0x34e5120c)    R(0x0dff,0x264681f8,0x26e5e608,0x26866633)    R(0x0e00,0x27f83a15,0x26f78a32,0x2768264d)    R(0x0e01,0x27f83a15,0x28083dd5,0x2757a1f8)    R(0x0e02,0x27db4e2c,0x28babe12,0x281ac64c)    R(0x0e03,0x2757a1f8,0x26970dda,0x2686fe18)    R(0x0e04,0x26866633,0x26e5e608,0x2715be45)    R(0x0e05,0x27f83a15,0x2757a1f8,0x26f78a32)\n    R(0x0e06,0x300535f9,0x31a575fd,0x3025061a)    R(0x0e07,0x33058a05,0x3335f1e5,0x33f609e5)    R(0x0e08,0x26e5e608,0x27654617,0x2715be45)    R(0x0e09,0x31a575fd,0x3335f1e5,0x33058a05)    R(0x0e0a,0x2757a1f8,0x2686fe18,0x26f78a32)    R(0x0e0b,0x33058a05,0x33f609e5,0x33a55e02)    R(0x0e0c,0x26e5e608,0x26e55dd6,0x27654617)    R(0x0e0d,0x281ac64c,0x28babe12,0x28ca222f)    R(0x0e0e,0x3025061a,0x31a575fd,0x31951224)    R(0x0e0f,0x31951224,0x31a575fd,0x33058a05)\n    R(0x0e10,0x28d97e17,0x29097dd6,0x2898ddf5)    R(0x0e11,0x28babe12,0x292a1df4,0x28ca222f)    R(0x0e12,0x28ca222f,0x292a1df4,0x28d97e17)    R(0x0e13,0x292a1df4,0x29097dd6,0x28d97e17)    R(0x0e14,0x2848da33,0x2898ddf5,0x27f83a15)    R(0x0e15,0x28d97e17,0x2898ddf5,0x2848da33)    R(0x0e16,0x26355a9c,0x27953a7f,0x273532be)    R(0x0e17,0x33a55e02,0x33f609e5,0x3485c5df)    R(0x0e18,0x2768264d,0x26f78a32,0x26076e65)    R(0x0e19,0x28babe12,0x28dab5d5,0x292a1df4)\n    R(0x0e1a,0x26cb4e67,0x281ac64c,0x270a9e7d)    R(0x0e1b,0x26b58675,0x27953a4f,0x27953a7f)    R(0x0e1c,0x2798c667,0x2638067e,0x26589a94)    R(0x0e1d,0x26b58675,0x27953a7f,0x26355a9c)    R(0x0e1e,0x28397657,0x2798c667,0x27093e8d)    R(0x0e1f,0x2848da33,0x2768264d,0x2798c667)    R(0x0e20,0x2848da33,0x27f83a15,0x2768264d)    R(0x0e21,0x2798c667,0x2768264d,0x2638067e)    R(0x0e22,0x26866633,0x2715be45,0x2656466f)    R(0x0e23,0x2656466f,0x2715be45,0x26b58675)\n    R(0x0e24,0x27093e8d,0x2798c667,0x26589a94)    R(0x0e25,0x28397657,0x2848da33,0x2798c667)    R(0x0e26,0x2715be45,0x27953a4f,0x26b58675)    R(0x0e27,0x2715be45,0x27654617,0x27953a4f)    R(0x0e28,0x2709de8b,0x28397657,0x27093e8d)    R(0x0e29,0x281ac64c,0x280a2260,0x270a9e7d)    R(0x0e2a,0x28397657,0x28d97e17,0x2848da33)    R(0x0e2b,0x280a2260,0x28397657,0x2709de8b)    R(0x0e2c,0x281ac64c,0x28ca222f,0x280a2260)    R(0x0e2d,0x280a2260,0x28ca222f,0x28397657)\n    R(0x0e2e,0x270a9e7d,0x280a2260,0x2709de8b)    R(0x0e2f,0x28ca222f,0x28d97e17,0x28397657)    R(0x0e30,0x0dbe6a0d,0x0eee95f6,0x0fde89ec)    R(0x0e31,0x177ce2eb,0x14dd16e9,0x16fd5ac3)    R(0x0e32,0x245cd9f2,0x25bc69d6,0x25bc6a11)    R(0x0e33,0x27953a7f,0x2974ee96,0x273532be)    R(0x0e34,0x3314f624,0x33a55e02,0x34e5120c)    R(0x0e35,0x0e7e3e40,0x0f1e6210,0x118e5a27)    R(0x0e36,0x1bfe1e15,0x1b1e45da,0x1dae01ec)    R(0x0e37,0x0f1e6210,0x0fde89ec,0x113e81ec)\n    R(0x0e38,0x0f1e6210,0x0dbe6a0d,0x0fde89ec)    R(0x0e39,0x1bfe1e15,0x1dae01ec,0x1ebdd21c)    R(0x0e3a,0x199d2aca,0x177ce2eb,0x16fd5ac3)    R(0x0e3b,0x1e0beadf,0x1c4c4ee9,0x1e4c66c2)    R(0x0e3c,0x1d5d7277,0x1addca78,0x1cbdd649)    R(0x0e3d,0x190da6a0,0x185e0273,0x1addca78)    R(0x0e3e,0x1cbdd649,0x1bfe1e15,0x1ebdd21c)    R(0x0e3f,0x106e1a5f,0x0e7e3e40,0x118e5a27)    R(0x0e40,0x118e5a27,0x0f1e6210,0x113e81ec)    R(0x0e41,0x1addca78,0x1a1e1a44,0x1cbdd649)\n    R(0x0e42,0x135dde8d,0x106e1a5f,0x130e2a5a)    R(0x0e43,0x15ae1667,0x130e2a5a,0x14ae5a2e)    R(0x0e44,0x164dca98,0x15ae1667,0x185e0273)    R(0x0e45,0x1a1e1a44,0x196e5209,0x1bfe1e15)    R(0x0e46,0x1cbdd649,0x1a1e1a44,0x1bfe1e15)    R(0x0e47,0x185e0273,0x177e423a,0x1a1e1a44)    R(0x0e48,0x1addca78,0x185e0273,0x1a1e1a44)    R(0x0e49,0x135dde8d,0x130e2a5a,0x15ae1667)    R(0x0e4a,0x185e0273,0x15ae1667,0x177e423a)    R(0x0e4b,0x135dde8d,0x109dca88,0x106e1a5f)\n    R(0x0e4c,0x14ae5a2e,0x118e5a27,0x13ce7df9)    R(0x0e4d,0x164dca98,0x135dde8d,0x15ae1667)    R(0x0e4e,0x1a1e1a44,0x177e423a,0x196e5209)    R(0x0e4f,0x14ae5a2e,0x13ce7df9,0x16be7201)    R(0x0e50,0x130e2a5a,0x118e5a27,0x14ae5a2e)    R(0x0e51,0x15ae1667,0x14ae5a2e,0x177e423a)    R(0x0e52,0x177e423a,0x14ae5a2e,0x16be7201)    R(0x0e53,0x177e423a,0x16be7201,0x196e5209)    R(0x0e54,0x106e1a5f,0x118e5a27,0x130e2a5a)    R(0x0e55,0x1e4c66c2,0x1c4c4ee9,0x1c2cd6c8)\n    R(0x0e56,0x19eca2e9,0x177ce2eb,0x199d2aca)    R(0x0e57,0x1c2cd6c8,0x1b9d56a2,0x1e5ce69d)    R(0x0e58,0x118d72b1,0x0f7d06d1,0x0ead6ea6)    R(0x0e59,0x1bfe1e15,0x196e5209,0x1b1e45da)    R(0x0e5a,0x118e5a27,0x113e81ec,0x13ce7df9)    R(0x0e5b,0x123d1ae2,0x0f7d06d1,0x118d72b1)    R(0x0e5c,0x14dd16e9,0x123d1ae2,0x143d7abb)    R(0x0e5d,0x1c4c4ee9,0x19eca2e9,0x1c2cd6c8)    R(0x0e5e,0x1b9d56a2,0x1addca78,0x1d5d7277)    R(0x0e5f,0x1e5ce69d,0x1b9d56a2,0x1d5d7277)\n    R(0x0e60,0x199d2aca,0x190da6a0,0x1b9d56a2)    R(0x0e61,0x143d7abb,0x123d1ae2,0x118d72b1)    R(0x0e62,0x16fd5ac3,0x14dd16e9,0x143d7abb)    R(0x0e63,0x199d2aca,0x16fd5ac3,0x190da6a0)    R(0x0e64,0x118d72b1,0x0ead6ea6,0x109dca88)    R(0x0e65,0x190da6a0,0x164dca98,0x185e0273)    R(0x0e66,0x1c2cd6c8,0x19eca2e9,0x199d2aca)    R(0x0e67,0x143d7abb,0x135dde8d,0x164dca98)    R(0x0e68,0x16fd5ac3,0x143d7abb,0x164dca98)    R(0x0e69,0x16fd5ac3,0x164dca98,0x190da6a0)\n    R(0x0e6a,0x118d72b1,0x109dca88,0x135dde8d)    R(0x0e6b,0x1b9d56a2,0x190da6a0,0x1addca78)    R(0x0e6c,0x143d7abb,0x118d72b1,0x135dde8d)    R(0x0e6d,0x1c2cd6c8,0x199d2aca,0x1b9d56a2)    R(0x0e6e,0x25bc6a11,0x25bc69d6,0x270be602)    R(0x0e6f,0x27db4e2c,0x281b4def,0x28babe12)    R(0x0e70,0x106e1a5f,0x0ddde27c,0x0e7e3e40)    R(0x0e71,0x1f2b0ed8,0x1deb4ee6,0x1fcbbebf)    R(0x0e72,0x27db4e2c,0x270be602,0x281b4def)    R(0x0e73,0x23acf626,0x245cd9f2,0x25bc6a11)\n    R(0x0e74,0x26cb4e67,0x27db4e2c,0x281ac64c)    R(0x0e75,0x236c3682,0x238ca25a,0x254bfa66)    R(0x0e76,0x1d5d7277,0x1cbdd649,0x1f6d8249)    R(0x0e77,0x1ebdd21c,0x1dae01ec,0x205da9f4)    R(0x0e78,0x269bd63a,0x25bc6a11,0x270be602)    R(0x0e79,0x254bfa66,0x252c6a3e,0x269bd63a)    R(0x0e7a,0x1fcd2a75,0x21dd1e4f,0x216cbe7c)    R(0x0e7b,0x21dd1e4f,0x215d6e22,0x23acf626)    R(0x0e7c,0x23acf626,0x25bc6a11,0x252c6a3e)    R(0x0e7d,0x26cb4e67,0x269bd63a,0x27db4e2c)\n    R(0x0e7e,0x238ca25a,0x23acf626,0x252c6a3e)    R(0x0e7f,0x238ca25a,0x252c6a3e,0x254bfa66)    R(0x0e80,0x216cbe7c,0x21dd1e4f,0x238ca25a)    R(0x0e81,0x252c6a3e,0x25bc6a11,0x269bd63a)    R(0x0e82,0x21dd1e4f,0x23acf626,0x238ca25a)    R(0x0e83,0x1cbdd649,0x1ebdd21c,0x1f6d8249)    R(0x0e84,0x1d5d7277,0x1f6d8249,0x1fcd2a75)    R(0x0e85,0x215d6e22,0x205da9f4,0x229d45f3)    R(0x0e86,0x254bfa66,0x269bd63a,0x26cb4e67)    R(0x0e87,0x269bd63a,0x270be602,0x27db4e2c)\n    R(0x0e88,0x1f6d8249,0x215d6e22,0x21dd1e4f)    R(0x0e89,0x1f6d8249,0x1ebdd21c,0x215d6e22)    R(0x0e8a,0x215d6e22,0x229d45f3,0x23acf626)    R(0x0e8b,0x1ebdd21c,0x205da9f4,0x215d6e22)    R(0x0e8c,0x1fcd2a75,0x1f6d8249,0x21dd1e4f)    R(0x0e8d,0x218abedb,0x1f2b0ed8,0x214b4ec0)    R(0x0e8e,0x24eb8a8c,0x26cb4e67,0x259ae69a)    R(0x0e8f,0x1deb4ee6,0x1e0beadf,0x1fcbbebf)    R(0x0e90,0x23acf626,0x229d45f3,0x245cd9f2)    R(0x0e91,0x0ead6ea6,0x0ddde27c,0x109dca88)\n    R(0x0e92,0x109dca88,0x0ddde27c,0x106e1a5f)    R(0x0e93,0x1fcbbebf,0x1e0beadf,0x1e4c66c2)    R(0x0e94,0x236c3682,0x254bfa66,0x24eb8a8c)    R(0x0e95,0x239b1eb2,0x24eb8a8c,0x259ae69a)    R(0x0e96,0x24eb8a8c,0x254bfa66,0x26cb4e67)    R(0x0e97,0x208c569f,0x236c3682,0x226bcaa1)    R(0x0e98,0x226bcaa1,0x236c3682,0x24eb8a8c)    R(0x0e99,0x226bcaa1,0x24eb8a8c,0x239b1eb2)    R(0x0e9a,0x1e4c66c2,0x208c569f,0x1fcbbebf)    R(0x0e9b,0x1fcbbebf,0x208c569f,0x226bcaa1)\n    R(0x0e9c,0x1fcbbebf,0x226bcaa1,0x214b4ec0)    R(0x0e9d,0x1e4c66c2,0x1c2cd6c8,0x1e5ce69d)    R(0x0e9e,0x1e5ce69d,0x1d5d7277,0x1fcd2a75)    R(0x0e9f,0x214b4ec0,0x239b1eb2,0x218abedb)    R(0x0ea0,0x216cbe7c,0x238ca25a,0x236c3682)    R(0x0ea1,0x1f2b0ed8,0x1fcbbebf,0x214b4ec0)    R(0x0ea2,0x1e5ce69d,0x216cbe7c,0x208c569f)    R(0x0ea3,0x208c569f,0x216cbe7c,0x236c3682)    R(0x0ea4,0x1e4c66c2,0x1e5ce69d,0x208c569f)    R(0x0ea5,0x214b4ec0,0x226bcaa1,0x239b1eb2)\n    R(0x0ea6,0x1e5ce69d,0x1fcd2a75,0x216cbe7c)    R(0x0ea7,0x12556f62,0x1114b765,0x1045634e)    R(0x0ea8,0x300535f9,0x31c5c9d9,0x31a575fd)    R(0x0ea9,0x0085af5c,0x00352b50,0x0055d730)    R(0x0eaa,0x31c5c9d9,0x3335f1e5,0x31a575fd)    R(0x0eab,0x14b8b78f,0x14784f81,0x12c8a786)    R(0x0eac,0x12dcbb0b,0x101cb2ff,0x123d1ae2)    R(0x0ead,0x00454b0f,0x00355ecd,0x00660eed)    R(0x0eae,0x16587f81,0x14b8b78f,0x1639078c)    R(0x0eaf,0x1ac89b2d,0x19889b56,0x1ab90f42)\n    R(0x0eb0,0x1b956f59,0x1b14bb6e,0x18d5476e)    R(0x0eb1,0x23152ef7,0x25552af1,0x23850713)    R(0x0eb2,0x24d54ecb,0x25552af1,0x23152ef7)    R(0x0eb3,0x0055d730,0x00454b0f,0x00660eed)    R(0x0eb4,0x1485bf63,0x13b4f376,0x12556f62)    R(0x0eb5,0x16e5db5d,0x18d5476e,0x16253377)    R(0x0eb6,0x18083f60,0x16587f81,0x1808d77b)    R(0x0eb7,0x12c8a786,0x12683b6d,0x1078a36d)    R(0x0eb8,0x11572725,0x0ee70326,0x0ea76b0d)    R(0x0eb9,0x0fa5ff44,0x1045634e,0x0e358331)\n    R(0x0eba,0x10c68f3c,0x0fa5ff44,0x0dd68735)    R(0x0ebb,0x13f73b2a,0x11572725,0x11276f1b)    R(0x0ebc,0x18b7bb3d,0x16676b38,0x1777c343)    R(0x0ebd,0x10c7ab22,0x10582747,0x12a7c340)    R(0x0ebe,0x18366f47,0x15264f49,0x1636ef3f)    R(0x0ebf,0x11572725,0x10c68f3c,0x0ee70326)    R(0x0ec0,0x1266134b,0x0fa5ff44,0x10c68f3c)    R(0x0ec1,0x16676b38,0x1636ef3f,0x13f73b2a)    R(0x0ec2,0x18872b45,0x1636ef3f,0x16676b38)    R(0x0ec3,0x1636ef3f,0x1396d33d,0x13f73b2a)\n    R(0x0ec4,0x1636ef3f,0x15264f49,0x1396d33d)    R(0x0ec5,0x1396d33d,0x10c68f3c,0x11572725)    R(0x0ec6,0x13f73b2a,0x1396d33d,0x11572725)    R(0x0ec7,0x18872b45,0x18366f47,0x1636ef3f)    R(0x0ec8,0x10c7ab22,0x0e67fb21,0x10582747)    R(0x0ec9,0x13776f2b,0x11276f1b,0x10c7ab22)    R(0x0eca,0x1396d33d,0x1266134b,0x10c68f3c)    R(0x0ecb,0x16676b38,0x1547973f,0x1777c343)    R(0x0ecc,0x13f73b2a,0x11276f1b,0x13776f2b)    R(0x0ecd,0x15264f49,0x1266134b,0x1396d33d)\n    R(0x0ece,0x13776f2b,0x12a7c340,0x1547973f)    R(0x0ecf,0x16676b38,0x13f73b2a,0x13776f2b)    R(0x0ed0,0x16676b38,0x13776f2b,0x1547973f)    R(0x0ed1,0x13776f2b,0x10c7ab22,0x12a7c340)    R(0x0ed2,0x16253377,0x13b4f376,0x1485bf63)    R(0x0ed3,0x18366f47,0x16e5db5d,0x15264f49)    R(0x0ed4,0x11276f1b,0x0ea76b0d,0x0e97a30b)    R(0x0ed5,0x14784f81,0x12683b6d,0x12c8a786)    R(0x0ed6,0x10582747,0x0e089351,0x1078a36d)    R(0x0ed7,0x16e5db5d,0x1485bf63,0x15264f49)\n    R(0x0ed8,0x10c7ab22,0x0e97a30b,0x0e67fb21)    R(0x0ed9,0x1547973f,0x1447eb5e,0x16380362)    R(0x0eda,0x16e5db5d,0x16253377,0x1485bf63)    R(0x0edb,0x1777c343,0x1547973f,0x16380362)    R(0x0edc,0x15264f49,0x1485bf63,0x1266134b)    R(0x0edd,0x1547973f,0x12a7c340,0x1447eb5e)    R(0x0ede,0x11276f1b,0x0e97a30b,0x10c7ab22)    R(0x0edf,0x11572725,0x0ea76b0d,0x11276f1b)    R(0x0ee0,0x12556f62,0x1045634e,0x0fa5ff44)    R(0x0ee1,0x12683b6d,0x10582747,0x1078a36d)\n    R(0x0ee2,0x1266134b,0x12556f62,0x0fa5ff44)    R(0x0ee3,0x12a7c340,0x10582747,0x12683b6d)    R(0x0ee4,0x1447eb5e,0x12683b6d,0x14784f81)    R(0x0ee5,0x18083f60,0x16380362,0x16587f81)    R(0x0ee6,0x1485bf63,0x12556f62,0x1266134b)    R(0x0ee7,0x16380362,0x1447eb5e,0x14784f81)    R(0x0ee8,0x16380362,0x14784f81,0x16587f81)    R(0x0ee9,0x12a7c340,0x12683b6d,0x1447eb5e)    R(0x0eea,0x1777c343,0x16380362,0x18083f60)    R(0x0eeb,0x23667ad5,0x2235cef8,0x21667ef5)\n    R(0x0eec,0x237562e0,0x23152ef7,0x21b5370d)    R(0x0eed,0x21b5370d,0x1ff4df33,0x20159323)    R(0x0eee,0x10c68f3c,0x0dd68735,0x0ee70326)    R(0x0eef,0x1078a36d,0x0e089351,0x0eb9076e)    R(0x0ef0,0x19889b56,0x18083f60,0x1808d77b)    R(0x0ef1,0x2235cef8,0x237562e0,0x21b5370d)    R(0x0ef2,0x1cd72f2b,0x1d368f29,0x1a96cb40)    R(0x0ef3,0x2168a2f7,0x234852db,0x2127d6f3)    R(0x0ef4,0x1ab82333,0x19381b3e,0x1ac89b2d)    R(0x0ef5,0x2168a2f7,0x1f384b10,0x1f58ff0c)\n    R(0x0ef6,0x1f963f18,0x1db5f73d,0x1d368f29)    R(0x0ef7,0x1cf7eb28,0x1a97833c,0x1ab82333)    R(0x0ef8,0x21c726e6,0x1f76f30c,0x1f179710)    R(0x0ef9,0x2235cef8,0x21b5370d,0x20159323)    R(0x0efa,0x1f76f30c,0x1d368f29,0x1cd72f2b)    R(0x0efb,0x1f179710,0x1f76f30c,0x1cd72f2b)    R(0x0efc,0x1f76f30c,0x1f963f18,0x1d368f29)    R(0x0efd,0x1cf7eb28,0x1cd72f2b,0x1a97833c)    R(0x0efe,0x21667ef5,0x1f963f18,0x1f76f30c)    R(0x0eff,0x1f179710,0x1cd72f2b,0x1cf7eb28)\n    R(0x0f00,0x1cb8a71e,0x1ab82333,0x1ac89b2d)    R(0x0f01,0x1f58ff0c,0x1f384b10,0x1cb8a71e)    R(0x0f02,0x1f963f18,0x20159323,0x1db5f73d)    R(0x0f03,0x2127d6f3,0x1f179710,0x1f384b10)    R(0x0f04,0x2235cef8,0x20159323,0x1f963f18)    R(0x0f05,0x1f384b10,0x1cf7eb28,0x1cb8a71e)    R(0x0f06,0x1f384b10,0x1f179710,0x1cf7eb28)    R(0x0f07,0x2168a2f7,0x2127d6f3,0x1f384b10)    R(0x0f08,0x1cb8a71e,0x1cf7eb28,0x1ab82333)    R(0x0f09,0x21667ef5,0x2235cef8,0x1f963f18)\n    R(0x0f0a,0x1045634e,0x0ea4e73c,0x0e358331)    R(0x0f0b,0x1b956f59,0x18d5476e,0x1975e358)    R(0x0f0c,0x21c726e6,0x21667ef5,0x1f76f30c)    R(0x0f0d,0x0e67fb21,0x0e089351,0x10582747)    R(0x0f0e,0x19381b3e,0x18083f60,0x19889b56)    R(0x0f0f,0x1b563344,0x1b956f59,0x1975e358)    R(0x0f10,0x18366f47,0x1975e358,0x16e5db5d)    R(0x0f11,0x1a97833c,0x1a96cb40,0x18872b45)    R(0x0f12,0x1d368f29,0x1b563344,0x1a96cb40)    R(0x0f13,0x1db5f73d,0x1e155344,0x1b956f59)\n    R(0x0f14,0x1a96cb40,0x1b563344,0x18366f47)    R(0x0f15,0x1cd72f2b,0x1a96cb40,0x1a97833c)    R(0x0f16,0x1b563344,0x1975e358,0x18366f47)    R(0x0f17,0x1db5f73d,0x1b956f59,0x1b563344)    R(0x0f18,0x1d368f29,0x1db5f73d,0x1b563344)    R(0x0f19,0x1a96cb40,0x18366f47,0x18872b45)    R(0x0f1a,0x18b7bb3d,0x18872b45,0x16676b38)    R(0x0f1b,0x1975e358,0x18d5476e,0x16e5db5d)    R(0x0f1c,0x1ac89b2d,0x19381b3e,0x19889b56)    R(0x0f1d,0x2127d6f3,0x21c726e6,0x1f179710)\n    R(0x0f1e,0x1a97833c,0x18872b45,0x18b7bb3d)    R(0x0f1f,0x1ab82333,0x18b7bb3d,0x19381b3e)    R(0x0f20,0x19381b3e,0x1777c343,0x18083f60)    R(0x0f21,0x1ab82333,0x1a97833c,0x18b7bb3d)    R(0x0f22,0x20159323,0x1e155344,0x1db5f73d)    R(0x0f23,0x18b7bb3d,0x1777c343,0x19381b3e)    R(0x0f24,0x101cb2ff,0x0e0c2f1e,0x0d4c9af4)    R(0x0f25,0x101cb2ff,0x0d4c9af4,0x0f7d06d1)    R(0x0f26,0x101cb2ff,0x0f7d06d1,0x123d1ae2)    R(0x0f27,0x13d9238f,0x12c8a786,0x11692380)\n    R(0x0f28,0x20159323,0x1ff4df33,0x1e155344)    R(0x0f29,0x21aa1eec,0x23b9cad7,0x219962f5)    R(0x0f2a,0x12dcbb0b,0x123d1ae2,0x14dd16e9)    R(0x0f2b,0x17ec530c,0x177ce2eb,0x19eca2e9)    R(0x0f2c,0x105a3f79,0x0d9a2b6a,0x0ebab366)    R(0x0f2d,0x1808d77b,0x16587f81,0x1639078c)    R(0x0f2e,0x15799f86,0x13d9238f,0x1299bf82)    R(0x0f2f,0x12dcbb0b,0x10fc4f23,0x101cb2ff)    R(0x0f30,0x190a9760,0x178a1f77,0x16cacf67)    R(0x0f31,0x16cacf67,0x14fa4778,0x140afb67)\n    R(0x0f32,0x10fc4f23,0x0e0c2f1e,0x101cb2ff)    R(0x0f33,0x13ac3f29,0x10fc4f23,0x12dcbb0b)    R(0x0f34,0x16cacf67,0x140afb67,0x168b6f54)    R(0x0f35,0x111ad770,0x0e2b4353,0x116b5356)    R(0x0f36,0x116b5356,0x0e2b4353,0x0f4bc73f)    R(0x0f37,0x140afb67,0x116b5356,0x144b974c)    R(0x0f38,0x168b6f54,0x144b974c,0x162c0332)    R(0x0f39,0x18bb334c,0x16cacf67,0x168b6f54)    R(0x0f3a,0x168b6f54,0x140afb67,0x144b974c)    R(0x0f3b,0x144b974c,0x116b5356,0x11fbdf40)\n    R(0x0f3c,0x183bcf33,0x168b6f54,0x162c0332)    R(0x0f3d,0x116b5356,0x0f4bc73f,0x11fbdf40)    R(0x0f3e,0x18bb334c,0x168b6f54,0x183bcf33)    R(0x0f3f,0x11fbdf40,0x0f4bc73f,0x10fc4f23)    R(0x0f40,0x140afb67,0x111ad770,0x116b5356)    R(0x0f41,0x155c970a,0x13ac3f29,0x12dcbb0b)    R(0x0f42,0x190a9760,0x16cacf67,0x18bb334c)    R(0x0f43,0x13ac3f29,0x11fbdf40,0x10fc4f23)    R(0x0f44,0x162c0332,0x144b974c,0x13ac3f29)    R(0x0f45,0x162c0332,0x13ac3f29,0x155c970a)\n    R(0x0f46,0x17ec530c,0x162c0332,0x155c970a)    R(0x0f47,0x183bcf33,0x162c0332,0x17ec530c)    R(0x0f48,0x144b974c,0x11fbdf40,0x13ac3f29)    R(0x0f49,0x12c8a786,0x1078a36d,0x11692380)    R(0x0f4a,0x14b8b78f,0x12c8a786,0x13d9238f)    R(0x0f4b,0x1969436c,0x1808d77b,0x17e97b81)    R(0x0f4c,0x0fa99b72,0x0d9a2b6a,0x105a3f79)    R(0x0f4d,0x155c970a,0x12dcbb0b,0x14dd16e9)    R(0x0f4e,0x11692380,0x1078a36d,0x0eb9076e)    R(0x0f4f,0x11692380,0x0eb9076e,0x0fa99b72)\n    R(0x0f50,0x15799f86,0x1299bf82,0x14fa4778)    R(0x0f51,0x1639078c,0x14b8b78f,0x13d9238f)    R(0x0f52,0x1959ef6c,0x17e97b81,0x178a1f77)    R(0x0f53,0x1299bf82,0x11692380,0x0fa99b72)    R(0x0f54,0x1639078c,0x13d9238f,0x15799f86)    R(0x0f55,0x178a1f77,0x15799f86,0x14fa4778)    R(0x0f56,0x17e97b81,0x1639078c,0x15799f86)    R(0x0f57,0x17e97b81,0x15799f86,0x178a1f77)    R(0x0f58,0x1299bf82,0x0fa99b72,0x105a3f79)    R(0x0f59,0x111ad770,0x105a3f79,0x0ebab366)\n    R(0x0f5a,0x155c970a,0x14dd16e9,0x177ce2eb)    R(0x0f5b,0x1808d77b,0x1639078c,0x17e97b81)    R(0x0f5c,0x140afb67,0x129a677b,0x111ad770)    R(0x0f5d,0x14fa4778,0x1299bf82,0x129a677b)    R(0x0f5e,0x14fa4778,0x129a677b,0x140afb67)    R(0x0f5f,0x129a677b,0x105a3f79,0x111ad770)    R(0x0f60,0x178a1f77,0x14fa4778,0x16cacf67)    R(0x0f61,0x17ec530c,0x155c970a,0x177ce2eb)    R(0x0f62,0x1299bf82,0x105a3f79,0x129a677b)    R(0x0f63,0x1f2b0ed8,0x1cfaa6f7,0x1deb4ee6)\n    R(0x0f64,0x219962f5,0x239912dd,0x2168a2f7)    R(0x0f65,0x1a1c1308,0x19eca2e9,0x1c4c4ee9)    R(0x0f66,0x1cb8a71e,0x1ac89b2d,0x1be92f1a)    R(0x0f67,0x10fc4f23,0x0f4bc73f,0x0e0c2f1e)    R(0x0f68,0x1969436c,0x17e97b81,0x1959ef6c)    R(0x0f69,0x219962f5,0x2168a2f7,0x1f58ff0c)    R(0x0f6a,0x21aa1eec,0x219962f5,0x1fa9c304)    R(0x0f6b,0x1f3a7ef2,0x1cfaa6f7,0x1f2b0ed8)    R(0x0f6c,0x1a1c1308,0x183bcf33,0x17ec530c)    R(0x0f6d,0x1a1c1308,0x17ec530c,0x19eca2e9)\n    R(0x0f6e,0x1d596f10,0x1be92f1a,0x1c59f309)    R(0x0f6f,0x1c59f309,0x1be92f1a,0x1bb98325)    R(0x0f70,0x1c59f309,0x1bca1726,0x1bea9b15)    R(0x0f71,0x1cfaa6f7,0x1c59f309,0x1bea9b15)    R(0x0f72,0x1f58ff0c,0x1cb8a71e,0x1d596f10)    R(0x0f73,0x21aa1eec,0x1fa9c304,0x1f3a7ef2)    R(0x0f74,0x1d7a1704,0x1c59f309,0x1cfaa6f7)    R(0x0f75,0x1fa9c304,0x1d596f10,0x1d7a1704)    R(0x0f76,0x1f3a7ef2,0x1fa9c304,0x1d7a1704)    R(0x0f77,0x1d7a1704,0x1d596f10,0x1c59f309)\n    R(0x0f78,0x1c1bbb01,0x1a2b8723,0x1a1c1308)    R(0x0f79,0x1c1bbb01,0x1a1c1308,0x1c4c4ee9)    R(0x0f7a,0x1deb4ee6,0x1beb2708,0x1c1bbb01)    R(0x0f7b,0x1d596f10,0x1cb8a71e,0x1be92f1a)    R(0x0f7c,0x219962f5,0x1f58ff0c,0x1fa9c304)    R(0x0f7d,0x1cfaa6f7,0x1bea9b15,0x1beb2708)    R(0x0f7e,0x1cfaa6f7,0x1beb2708,0x1deb4ee6)    R(0x0f7f,0x1f3a7ef2,0x1d7a1704,0x1cfaa6f7)    R(0x0f80,0x1fa9c304,0x1f58ff0c,0x1d596f10)    R(0x0f81,0x1beb2708,0x1a2b8723,0x1c1bbb01)\n    R(0x0f82,0x19889b56,0x1808d77b,0x1969436c)    R(0x0f83,0x218abedb,0x21aa1eec,0x1f3a7ef2)    R(0x0f84,0x111ad770,0x0ebab366,0x0e2b4353)    R(0x0f85,0x1c1bbb01,0x1c4c4ee9,0x1e0beadf)    R(0x0f86,0x1ab90f42,0x1969436c,0x1aa9bb52)    R(0x0f87,0x1bb98325,0x1ab90f42,0x1aa9bb52)    R(0x0f88,0x1959ef6c,0x178a1f77,0x190a9760)    R(0x0f89,0x1aaa634c,0x190a9760,0x1a9af73a)    R(0x0f8a,0x1be92f1a,0x1ac89b2d,0x1ab90f42)    R(0x0f8b,0x1c59f309,0x1bb98325,0x1bca1726)\n    R(0x0f8c,0x1aa9bb52,0x1959ef6c,0x1aaa634c)    R(0x0f8d,0x1bca1726,0x1aa9bb52,0x1aaa634c)    R(0x0f8e,0x1aa9bb52,0x1969436c,0x1959ef6c)    R(0x0f8f,0x1bb98325,0x1aa9bb52,0x1bca1726)    R(0x0f90,0x1bca1726,0x1aaa634c,0x1bea9b15)    R(0x0f91,0x1aaa634c,0x1959ef6c,0x190a9760)    R(0x0f92,0x1a2b8723,0x18bb334c,0x183bcf33)    R(0x0f93,0x1a2b8723,0x183bcf33,0x1a1c1308)    R(0x0f94,0x1ab90f42,0x19889b56,0x1969436c)    R(0x0f95,0x1deb4ee6,0x1c1bbb01,0x1e0beadf)\n    R(0x0f96,0x1a9af73a,0x190a9760,0x18bb334c)    R(0x0f97,0x1beb2708,0x1a9af73a,0x1a2b8723)    R(0x0f98,0x1bea9b15,0x1aaa634c,0x1a9af73a)    R(0x0f99,0x1be92f1a,0x1ab90f42,0x1bb98325)    R(0x0f9a,0x1bea9b15,0x1a9af73a,0x1beb2708)    R(0x0f9b,0x1a9af73a,0x18bb334c,0x1a2b8723)  }\n  return r;\n}\n#else\nivec3 facets_data(in int i) {\n#  ifdef R\n#    undef R\n#  endif\n#  define R(i,a,b,c) case i: r=ivec3(a,b,c); break;\n  ivec3 r;\n  switch(i) {\n    R(0x0000,0x3a113c00,0x3af14803,0x38315c03)    R(0x0001,0x3b500087,0x3ca0584f,0x3af05065)    R(0x0002,0x3ff6c907,0x3f2710c8,0x3f86e8d9)    R(0x0003,0x0daffd68,0x0c2fb932,0x0eefa52a)    R(0x0004,0x0002e604,0x002305bc,0x0013bddd)    R(0x0005,0x29a27be7,0x2811dfe3,0x26b2a7ff)    R(0x0006,0x3a700cb4,0x3b500087,0x393008c2)    R(0x0007,0x3c40e017,0x3c810015,0x3a113c00)    R(0x0008,0x00326df8,0x002305bc,0x0002e604)    R(0x0009,0x3ee6714a,0x3ff6c907,0x3f168514)\n    R(0x000a,0x26bc05da,0x284b19c4,0x27eb5a11)    R(0x000b,0x0fffd95f,0x0daffd68,0x0eefa52a)    R(0x000c,0x0013bddd,0x002305bc,0x0043f192)    R(0x000d,0x01c6d0a4,0x0105c8ac,0x0215f0a5)    R(0x000e,0x180135be,0x14611ddf,0x17a0c60b)    R(0x000f,0x3691380f,0x3a113c00,0x38315c03)    R(0x0010,0x393008c2,0x3b500087,0x3950349f)    R(0x0011,0x3db63d7b,0x3f86a539,0x3ee6714a)    R(0x0012,0x14e64055,0x11065852,0x1305bc74)    R(0x0013,0x0466c8a2,0x0215f0a5,0x05061cad)\n    R(0x0014,0x0054c9ab,0x0013bddd,0x0043f192)    R(0x0015,0x2882a5cb,0x29c1e5dc,0x2bf269d3)    R(0x0016,0x26a521be,0x27344dd7,0x2794f60b)    R(0x0017,0x180135be,0x17a0c60b,0x1b6109ee)    R(0x0018,0x15531d3c,0x14c24d67,0x1872c550)    R(0x0019,0x2004bd36,0x1f73c94c,0x22b3d970)    R(0x001a,0x00a4810f,0x0074a554,0x00844d5c)    R(0x001b,0x0116bcb3,0x00b5b8ce,0x0105c8ac)    R(0x001c,0x24469160,0x21668518,0x2265b145)    R(0x001d,0x11065852,0x0d16a85e,0x0f260079)\n    R(0x001e,0x0094f505,0x0074a554,0x00a4810f)    R(0x001f,0x0105c8ac,0x00c4f4ca,0x01451cb3)    R(0x0020,0x04f49d6c,0x04349d33,0x02145d54)    R(0x0021,0x1823c128,0x15531d3c,0x1872c550)    R(0x0022,0x2265b145,0x2004bd36,0x2334c562)    R(0x0023,0x011490df,0x00c4f4ca,0x00a4810f)    R(0x0024,0x02e558ae,0x01451cb3,0x0254c4cc)    R(0x0025,0x00b5b8ce,0x0094f505,0x00c4f4ca)    R(0x0026,0x12953117,0x0f059102,0x0f255133)    R(0x0027,0x0645293d,0x04349d33,0x04f49d6c)\n    R(0x0028,0x1184a933,0x0db49156,0x1053c958)    R(0x0029,0x05256cc4,0x02e558ae,0x0254c4cc)    R(0x002a,0x02247105,0x011490df,0x01045d30)    R(0x002b,0x00c4f4ca,0x0094f505,0x00a4810f)    R(0x002c,0x01451cb3,0x00c4f4ca,0x011490df)    R(0x002d,0x069590fa,0x0474dcee,0x0645293d)    R(0x002e,0x01659919,0x0094f505,0x00b5b8ce)    R(0x002f,0x011490df,0x00a4810f,0x01045d30)    R(0x0030,0x0254c4cc,0x011490df,0x02247105)    R(0x0031,0x0474dcee,0x02247105,0x04349d33)\n    R(0x0032,0x05256cc4,0x0474dcee,0x069590fa)    R(0x0033,0x0254c4cc,0x02247105,0x0474dcee)    R(0x0034,0x02145d54,0x01045d30,0x00c42168)    R(0x0035,0x0254c4cc,0x01451cb3,0x011490df)    R(0x0036,0x12953117,0x0f255133,0x1184a933)    R(0x0037,0x0155455f,0x0094f505,0x01659919)    R(0x0038,0x1184a933,0x0f255133,0x0db49156)    R(0x0039,0x0645293d,0x0474dcee,0x04349d33)    R(0x003a,0x05256cc4,0x0254c4cc,0x0474dcee)    R(0x003b,0x04349d33,0x02247105,0x02145d54)\n    R(0x003c,0x0f255133,0x0be55d55,0x0db49156)    R(0x003d,0x02145d54,0x02247105,0x01045d30)    R(0x003e,0x176590c8,0x148568af,0x157540f1)    R(0x003f,0x2265b145,0x1f75ad16,0x2004bd36)    R(0x0040,0x1823c128,0x1872c550,0x1b93513e)    R(0x0041,0x0155455f,0x0074a554,0x0094f505)    R(0x0042,0x182548f0,0x157540f1,0x15b4b514)    R(0x0043,0x126558e9,0x0f059102,0x12953117)    R(0x0044,0x1823c128,0x15b4b514,0x1403e92f)    R(0x0045,0x2004bd36,0x1c653d08,0x1c743d26)\n    R(0x0046,0x15b4b514,0x12953117,0x1184a933)    R(0x0047,0x182548f0,0x15b4b514,0x19549d0f)    R(0x0048,0x1f75ad16,0x1c653d08,0x2004bd36)    R(0x0049,0x19549d0f,0x15b4b514,0x1823c128)    R(0x004a,0x1c653d08,0x19549d0f,0x1c743d26)    R(0x004b,0x1c653d08,0x182548f0,0x19549d0f)    R(0x004c,0x157540f1,0x12953117,0x15b4b514)    R(0x004d,0x1c743d26,0x19549d0f,0x1823c128)    R(0x004e,0x1823c128,0x1403e92f,0x15531d3c)    R(0x004f,0x2004bd36,0x1c743d26,0x1f73c94c)\n    R(0x0050,0x01045d30,0x00a4810f,0x00844d5c)    R(0x0051,0x148568af,0x126558e9,0x157540f1)    R(0x0052,0x176590c8,0x157540f1,0x182548f0)    R(0x0053,0x1c743d26,0x1b93513e,0x1f73c94c)    R(0x0054,0x15b4b514,0x1184a933,0x1403e92f)    R(0x0055,0x157540f1,0x126558e9,0x12953117)    R(0x0056,0x1403e92f,0x1184a933,0x1053c958)    R(0x0057,0x1c743d26,0x1823c128,0x1b93513e)    R(0x0058,0x00b5b8ce,0x00c4f4ca,0x0105c8ac)    R(0x0059,0x00e6a4d2,0x00b5b8ce,0x0116bcb3)\n    R(0x005a,0x1935fcad,0x18165868,0x1675bc7e)    R(0x005b,0x1f73c94c,0x1b93513e,0x1ef2f968)    R(0x005c,0x21668518,0x1f75ad16,0x2265b145)    R(0x005d,0x02961150,0x0155455f,0x01659919)    R(0x005e,0x0b563893,0x07067cab,0x08e618c7)    R(0x005f,0x0215f0a5,0x01451cb3,0x02e558ae)    R(0x0060,0x0f255133,0x0c05b93b,0x0be55d55)    R(0x0061,0x07655161,0x07b5d141,0x0645293d)    R(0x0062,0x05061cad,0x02e558ae,0x05256cc4)    R(0x0063,0x07067cab,0x05061cad,0x06c60cce)\n    R(0x0064,0x06c60cce,0x05256cc4,0x069590fa)    R(0x0065,0x0f059102,0x0b15dcfc,0x0c05b93b)    R(0x0066,0x06c60cce,0x05061cad,0x05256cc4)    R(0x0067,0x08e618c7,0x07067cab,0x06c60cce)    R(0x0068,0x0d35d0bc,0x0b15dcfc,0x0f059102)    R(0x0069,0x0b15dcfc,0x07f5f0ff,0x0935e938)    R(0x006a,0x0d35d0bc,0x08e618c7,0x0b15dcfc)    R(0x006b,0x08e618c7,0x07f5f0ff,0x0b15dcfc)    R(0x006c,0x08e618c7,0x06c60cce,0x07f5f0ff)    R(0x006d,0x06c60cce,0x069590fa,0x07f5f0ff)\n    R(0x006e,0x07b5d141,0x069590fa,0x0645293d)    R(0x006f,0x0c05b93b,0x0935c15a,0x0be55d55)    R(0x0070,0x02961150,0x01659919,0x01f65d02)    R(0x0071,0x0d35d0bc,0x0b563893,0x08e618c7)    R(0x0072,0x05061cad,0x0215f0a5,0x02e558ae)    R(0x0073,0x0935e938,0x07b5d141,0x0935c15a)    R(0x0074,0x0b15dcfc,0x0935e938,0x0c05b93b)    R(0x0075,0x07f5f0ff,0x07b5d141,0x0935e938)    R(0x0076,0x07f5f0ff,0x069590fa,0x07b5d141)    R(0x0077,0x0c05b93b,0x0935e938,0x0935c15a)\n    R(0x0078,0x1a36a893,0x18165868,0x1935fcad)    R(0x0079,0x01f65d02,0x00b5b8ce,0x00e6a4d2)    R(0x007a,0x21668518,0x1dc664e7,0x1f75ad16)    R(0x007b,0x1403e92f,0x1202fd55,0x15531d3c)    R(0x007c,0x1403e92f,0x1053c958,0x1202fd55)    R(0x007d,0x10f58ca7,0x0f260079,0x0d35d0bc)    R(0x007e,0x10f58ca7,0x0f059102,0x126558e9)    R(0x007f,0x176590c8,0x1675bc7e,0x148568af)    R(0x0080,0x0215f0a5,0x0105c8ac,0x01451cb3)    R(0x0081,0x1b26a8cc,0x1935fcad,0x1a75e0e3)\n    R(0x0082,0x1dc664e7,0x1b26a8cc,0x1a75e0e3)    R(0x0083,0x1935fcad,0x1675bc7e,0x176590c8)    R(0x0084,0x1a75e0e3,0x1935fcad,0x176590c8)    R(0x0085,0x148568af,0x10f58ca7,0x126558e9)    R(0x0086,0x10f58ca7,0x0d35d0bc,0x0f059102)    R(0x0087,0x1b26a8cc,0x1a36a893,0x1935fcad)    R(0x0088,0x1a75e0e3,0x182548f0,0x1c653d08)    R(0x0089,0x0f059102,0x0c05b93b,0x0f255133)    R(0x008a,0x148568af,0x1305bc74,0x10f58ca7)    R(0x008b,0x1dc664e7,0x1c653d08,0x1f75ad16)\n    R(0x008c,0x01f65d02,0x01659919,0x00b5b8ce)    R(0x008d,0x1305bc74,0x0f260079,0x10f58ca7)    R(0x008e,0x1a75e0e3,0x176590c8,0x182548f0)    R(0x008f,0x1dc664e7,0x1a75e0e3,0x1c653d08)    R(0x0090,0x1675bc7e,0x1305bc74,0x148568af)    R(0x0091,0x0f260079,0x0b563893,0x0d35d0bc)    R(0x0092,0x1bc19dae,0x180135be,0x1b6109ee)    R(0x0093,0x27538dcc,0x2882a5cb,0x2b0331db)    R(0x0094,0x00348604,0x0013bddd,0x0054c9ab)    R(0x0095,0x26c5c5f2,0x26a521be,0x2794f60b)\n    R(0x0096,0x1305bc74,0x11065852,0x0f260079)    R(0x0097,0x2656b9ee,0x25962dab,0x26c5c5f2)    R(0x0098,0x00738d8a,0x002305bc,0x0072b5be)    R(0x0099,0x00c42168,0x00738d8a,0x00e34d96)    R(0x009a,0x0653a5dc,0x042315d0,0x05132207)    R(0x009b,0x15531d3c,0x1202fd55,0x14c24d67)    R(0x009c,0x14c19197,0x14611ddf,0x180135be)    R(0x009d,0x27538dcc,0x2b0331db,0x297405eb)    R(0x009e,0x1872c550,0x14c24d67,0x1831e185)    R(0x009f,0x02540978,0x00e34d96,0x02b345a5)\n    R(0x00a0,0x11c19dbd,0x0f2239c3,0x10816a04)    R(0x00a1,0x0d324e07,0x0f2239c3,0x0c6321cd)    R(0x00a2,0x00b259f3,0x0072b5be,0x00326df8)    R(0x00a3,0x14c24d67,0x11923581,0x14c19197)    R(0x00a4,0x11923581,0x11c19dbd,0x14c19197)    R(0x00a5,0x14c24d67,0x14c19197,0x1831e185)    R(0x00a6,0x0c6321cd,0x0f2239c3,0x0f02f586)    R(0x00a7,0x00e34d96,0x00738d8a,0x0072b5be)    R(0x00a8,0x1053c958,0x0f02f586,0x1202fd55)    R(0x00a9,0x02b345a5,0x00e34d96,0x0182a1c6)\n    R(0x00aa,0x0f02f586,0x0f2239c3,0x11923581)    R(0x00ab,0x11923581,0x0f2239c3,0x11c19dbd)    R(0x00ac,0x0d73c589,0x0c6321cd,0x0f02f586)    R(0x00ad,0x0d73c589,0x0b13b9b9,0x0c6321cd)    R(0x00ae,0x1202fd55,0x11923581,0x14c24d67)    R(0x00af,0x0182a1c6,0x0072b5be,0x00b259f3)    R(0x00b0,0x0553e1a3,0x02b345a5,0x042315d0)    R(0x00b1,0x0c6321cd,0x0b13b9b9,0x0a53a9f8)    R(0x00b2,0x042315d0,0x0182a1c6,0x02a281f7)    R(0x00b3,0x02b345a5,0x0182a1c6,0x042315d0)\n    R(0x00b4,0x02a281f7,0x0182a1c6,0x00b259f3)    R(0x00b5,0x1202fd55,0x0f02f586,0x11923581)    R(0x00b6,0x1053c958,0x0d73c589,0x0f02f586)    R(0x00b7,0x0553e1a3,0x042315d0,0x0653a5dc)    R(0x00b8,0x1b93513e,0x1872c550,0x1bc26974)    R(0x00b9,0x1f73c94c,0x1ef2f968,0x22b3d970)    R(0x00ba,0x1831e185,0x180135be,0x1bc19dae)    R(0x00bb,0x00e34d96,0x0072b5be,0x0182a1c6)    R(0x00bc,0x2882a5cb,0x25c1fdd1,0x29c1e5dc)    R(0x00bd,0x25c1fdd1,0x271139f7,0x29c1e5dc)\n    R(0x00be,0x1f2239a0,0x1bc19dae,0x1f5185e3)    R(0x00bf,0x1bc26974,0x1831e185,0x1bc19dae)    R(0x00c0,0x1b93513e,0x1bc26974,0x1ef2f968)    R(0x00c1,0x2523a9ad,0x2242f995,0x24e2ddbe)    R(0x00c2,0x22b3d970,0x2242f995,0x2523a9ad)    R(0x00c3,0x2242f995,0x223231c7,0x24e2ddbe)    R(0x00c4,0x1ef2f968,0x1f2239a0,0x2242f995)    R(0x00c5,0x1bc26974,0x1bc19dae,0x1f2239a0)    R(0x00c6,0x1872c550,0x1831e185,0x1bc26974)    R(0x00c7,0x2242f995,0x1f2239a0,0x223231c7)\n    R(0x00c8,0x25c1fdd1,0x22f179ec,0x271139f7)    R(0x00c9,0x24e2ddbe,0x25c1fdd1,0x2882a5cb)    R(0x00ca,0x1ef2f968,0x1bc26974,0x1f2239a0)    R(0x00cb,0x22b3d970,0x1ef2f968,0x2242f995)    R(0x00cc,0x24e2ddbe,0x223231c7,0x25c1fdd1)    R(0x00cd,0x223231c7,0x1f5185e3,0x22f179ec)    R(0x00ce,0x223231c7,0x22f179ec,0x25c1fdd1)    R(0x00cf,0x27538dcc,0x24e2ddbe,0x2882a5cb)    R(0x00d0,0x1f2239a0,0x1f5185e3,0x223231c7)    R(0x00d1,0x2523a9ad,0x24e2ddbe,0x27538dcc)\n    R(0x00d2,0x0054c9ab,0x0043f192,0x0074a554)    R(0x00d3,0x0f260079,0x0d16a85e,0x0b563893)    R(0x00d4,0x14611ddf,0x11c19dbd,0x10816a04)    R(0x00d5,0x1675bc7e,0x14e64055,0x1305bc74)    R(0x00d6,0x1bc19dae,0x1b6109ee,0x1f5185e3)    R(0x00d7,0x27344dd7,0x27538dcc,0x297405eb)    R(0x00d8,0x07655161,0x0645293d,0x04f49d6c)    R(0x00d9,0x0be55d55,0x0935c15a,0x09750169)    R(0x00da,0x02869d92,0x01b5b1a0,0x02961150)    R(0x00db,0x01b5b1a0,0x0054c9ab,0x0155455f)\n    R(0x00dc,0x0553e1a3,0x02540978,0x02b345a5)    R(0x00dd,0x0b13b9b9,0x0893bde6,0x0a53a9f8)    R(0x00de,0x02540978,0x00c42168,0x00e34d96)    R(0x00df,0x0aa43d7f,0x07447d81,0x0833edae)    R(0x00e0,0x0935c15a,0x07b5d141,0x07655161)    R(0x00e1,0x01b5b1a0,0x0155455f,0x02961150)    R(0x00e2,0x09750169,0x07447d81,0x0aa43d7f)    R(0x00e3,0x07655161,0x04f49d6c,0x07447d81)    R(0x00e4,0x09750169,0x07655161,0x07447d81)    R(0x00e5,0x09750169,0x0935c15a,0x07655161)\n    R(0x00e6,0x04f49d6c,0x02540978,0x0553e1a3)    R(0x00e7,0x07447d81,0x04f49d6c,0x0553e1a3)    R(0x00e8,0x0833edae,0x0653a5dc,0x0893bde6)    R(0x00e9,0x0b13b9b9,0x0833edae,0x0893bde6)    R(0x00ea,0x02145d54,0x00c42168,0x02540978)    R(0x00eb,0x006591e2,0x0054c9ab,0x01b5b1a0)    R(0x00ec,0x015669e1,0x01b5b1a0,0x02869d92)    R(0x00ed,0x0833edae,0x0553e1a3,0x0653a5dc)    R(0x00ee,0x04f49d6c,0x02145d54,0x02540978)    R(0x00ef,0x0aa43d7f,0x0833edae,0x0b13b9b9)\n    R(0x00f0,0x015669e1,0x006591e2,0x01b5b1a0)    R(0x00f1,0x07447d81,0x0553e1a3,0x0833edae)    R(0x00f2,0x18165868,0x14e64055,0x1675bc7e)    R(0x00f3,0x24469160,0x2265b145,0x24c58180)    R(0x00f4,0x0074a554,0x0043f192,0x00844d5c)    R(0x00f5,0x14c19197,0x11c19dbd,0x14611ddf)    R(0x00f6,0x27344dd7,0x2523a9ad,0x27538dcc)    R(0x00f7,0x25962dab,0x26a521be,0x26c5c5f2)    R(0x00f8,0x00844d5c,0x0043f192,0x00738d8a)    R(0x00f9,0x2334c562,0x22b3d970,0x25a47d96)\n    R(0x00fa,0x2004bd36,0x22b3d970,0x2334c562)    R(0x00fb,0x0054c9ab,0x0074a554,0x0155455f)    R(0x00fc,0x24469160,0x24c58180,0x25962dab)    R(0x00fd,0x1053c958,0x0db49156,0x0d73c589)    R(0x00fe,0x0db49156,0x09750169,0x0aa43d7f)    R(0x00ff,0x0db49156,0x0aa43d7f,0x0d73c589)    R(0x0100,0x24c58180,0x2334c562,0x25a47d96)    R(0x0101,0x00c42168,0x00844d5c,0x00738d8a)    R(0x0102,0x1831e185,0x14c19197,0x180135be)    R(0x0103,0x25a47d96,0x2523a9ad,0x27344dd7)\n    R(0x0104,0x01045d30,0x00844d5c,0x00c42168)    R(0x0105,0x25962dab,0x24c58180,0x26a521be)    R(0x0106,0x25a47d96,0x22b3d970,0x2523a9ad)    R(0x0107,0x26a521be,0x25a47d96,0x27344dd7)    R(0x0108,0x0db49156,0x0be55d55,0x09750169)    R(0x0109,0x24c58180,0x25a47d96,0x26a521be)    R(0x010a,0x2265b145,0x2334c562,0x24c58180)    R(0x010b,0x0d73c589,0x0aa43d7f,0x0b13b9b9)    R(0x010c,0x3c810015,0x3af14803,0x3a113c00)    R(0x010d,0x3c402476,0x3ca0584f,0x3b500087)\n    R(0x010e,0x3905f927,0x3b56a4ea,0x3856b907)    R(0x010f,0x3d35fd51,0x3f168514,0x3c863917)    R(0x0110,0x0043f192,0x002305bc,0x00738d8a)    R(0x0111,0x006591e2,0x00348604,0x0054c9ab)    R(0x0112,0x3a700cb4,0x3c402476,0x3b500087)    R(0x0113,0x3891180a,0x3a113c00,0x3691380f)    R(0x0114,0x2f412158,0x2f21351c,0x2e11a578)    R(0x0115,0x35f6313d,0x3905f927,0x3856b907)    R(0x0116,0x3ee6714a,0x3f168514,0x3d35fd51)    R(0x0117,0x390074fa,0x3b2044ac,0x3a700cb4)\n    R(0x0118,0x2f412158,0x2fc0e501,0x2f21351c)    R(0x0119,0x3390c95f,0x34f0a519,0x3100f541)    R(0x011a,0x3790dc37,0x3891180a,0x34e0f42d)    R(0x011b,0x39315c8d,0x3be10054,0x3af0c09f)    R(0x011c,0x3cc07c68,0x3c402476,0x3b2044ac)    R(0x011d,0x3d10903c,0x3c810015,0x3c40e017)    R(0x011e,0x34e0f42d,0x3691380f,0x33910c40)    R(0x011f,0x370068d9,0x3950349f,0x3730b484)    R(0x0120,0x2fc0e501,0x3020ecc2,0x2f21351c)    R(0x0121,0x3390c95f,0x35a0854b,0x34f0a519)\n    R(0x0122,0x33e0d464,0x3730b484,0x3790dc37)    R(0x0123,0x3210e46f,0x33910c40,0x31310c8b)    R(0x0124,0x34f0a519,0x370068d9,0x3430d4b8)    R(0x0125,0x2fc0e501,0x31c0e0f5,0x3120d0aa)    R(0x0126,0x33e0d464,0x3790dc37,0x34e0f42d)    R(0x0127,0x3020ecc2,0x3210e46f,0x31310c8b)    R(0x0128,0x31c0e0f5,0x3430d4b8,0x3120d0aa)    R(0x0129,0x3120d0aa,0x33e0d464,0x3210e46f)    R(0x012a,0x370068d9,0x3730b484,0x3430d4b8)    R(0x012b,0x3120d0aa,0x3210e46f,0x3020ecc2)\n    R(0x012c,0x3430d4b8,0x3730b484,0x33e0d464)    R(0x012d,0x3120d0aa,0x3430d4b8,0x33e0d464)    R(0x012e,0x35a0854b,0x381038fa,0x36f03d07)    R(0x012f,0x37c1094e,0x390074fa,0x3730993d)    R(0x0130,0x33e0d464,0x34e0f42d,0x3210e46f)    R(0x0131,0x2f412158,0x3100f541,0x2fc0e501)    R(0x0132,0x34f0a519,0x36f03d07,0x370068d9)    R(0x0133,0x34f0a519,0x3430d4b8,0x31c0e0f5)    R(0x0134,0x3100f541,0x34f0a519,0x31c0e0f5)    R(0x0135,0x3730993d,0x381038fa,0x35a0854b)\n    R(0x0136,0x3210e46f,0x34e0f42d,0x33910c40)    R(0x0137,0x35a0854b,0x36f03d07,0x34f0a519)    R(0x0138,0x3b30bc29,0x3c40e017,0x3891180a)    R(0x0139,0x3d00d830,0x3c810015,0x3d10903c)    R(0x013a,0x3d10903c,0x3ca0584f,0x3c402476)    R(0x013b,0x38c154d9,0x3af0c09f,0x3990c8eb)    R(0x013c,0x2fc0e501,0x3120d0aa,0x3020ecc2)    R(0x013d,0x37c1094e,0x3990c8eb,0x390074fa)    R(0x013e,0x3cc07c68,0x3d10903c,0x3c402476)    R(0x013f,0x3950349f,0x3af05065,0x3730b484)\n    R(0x0140,0x3790dc37,0x3b30bc29,0x3891180a)    R(0x0141,0x3c40e017,0x3ca0584f,0x3d10903c)    R(0x0142,0x3730b484,0x3af05065,0x3790dc37)    R(0x0143,0x3d00d830,0x3d10903c,0x3cc07c68)    R(0x0144,0x3790dc37,0x3af05065,0x3b30bc29)    R(0x0145,0x3af0c09f,0x3be10054,0x3cc07c68)    R(0x0146,0x3be10054,0x3d00d830,0x3cc07c68)    R(0x0147,0x3af05065,0x3ca0584f,0x3b30bc29)    R(0x0148,0x390074fa,0x381038fa,0x3730993d)    R(0x0149,0x3100f541,0x31c0e0f5,0x2fc0e501)\n    R(0x014a,0x3bf13419,0x3c810015,0x3d00d830)    R(0x014b,0x38414926,0x3990c8eb,0x37c1094e)    R(0x014c,0x3b30bc29,0x3ca0584f,0x3c40e017)    R(0x014d,0x3af0c09f,0x3cc07c68,0x3b2044ac)    R(0x014e,0x3990c8eb,0x3b2044ac,0x390074fa)    R(0x014f,0x3be10054,0x3bf13419,0x3d00d830)    R(0x0150,0x3af0c09f,0x3b2044ac,0x3990c8eb)    R(0x0151,0x3020ecc2,0x31310c8b,0x2fe148db)    R(0x0152,0x2e11a578,0x2f21351c,0x2f01c132)    R(0x0153,0x35314825,0x38315c03,0x36e1702b)\n    R(0x0154,0x3b500087,0x3af05065,0x3950349f)    R(0x0155,0x3905f927,0x3c863917,0x3b56a4ea)    R(0x0156,0x3ab5994e,0x3d35fd51,0x3c863917)    R(0x0157,0x2fe148db,0x31916ca8,0x30c1ccf5)    R(0x0158,0x34e0f42d,0x3891180a,0x3691380f)    R(0x0159,0x2f21351c,0x2fe148db,0x2f01c132)    R(0x015a,0x3565615d,0x3905f927,0x35f6313d)    R(0x015b,0x34c2296b,0x36d1cd21,0x36a1a16d)    R(0x015c,0x32a1305f,0x35314825,0x3431786d)    R(0x015d,0x3431786d,0x36e1702b,0x36c1a07d)\n    R(0x015e,0x31310c8b,0x33910c40,0x32a1305f)    R(0x015f,0x2fe148db,0x31310c8b,0x31916ca8)    R(0x0160,0x33f1d8c3,0x3431786d,0x36c1a07d)    R(0x0161,0x34a22117,0x33f1d8c3,0x36a1c8cd)    R(0x0162,0x30c1ccf5,0x33f1d8c3,0x32422513)    R(0x0163,0x31310c8b,0x32a1305f,0x31916ca8)    R(0x0164,0x30c1ccf5,0x31916ca8,0x33f1d8c3)    R(0x0165,0x33f1d8c3,0x36c1a07d,0x36a1c8cd)    R(0x0166,0x31916ca8,0x32a1305f,0x3431786d)    R(0x0167,0x31916ca8,0x3431786d,0x33f1d8c3)\n    R(0x0168,0x33910c40,0x35314825,0x32a1305f)    R(0x0169,0x33910c40,0x3691380f,0x35314825)    R(0x016a,0x3431786d,0x35314825,0x36e1702b)    R(0x016b,0x34c2296b,0x34a22117,0x36d1cd21)    R(0x016c,0x2ff22d49,0x30c1ccf5,0x32422513)    R(0x016d,0x32526564,0x32422513,0x34a22117)    R(0x016e,0x34a22117,0x36a1c8cd,0x36d1cd21)    R(0x016f,0x32422513,0x33f1d8c3,0x34a22117)    R(0x0170,0x32526564,0x34a22117,0x34c2296b)    R(0x0171,0x2ff22d49,0x32422513,0x32526564)\n    R(0x0172,0x38315c03,0x3af14803,0x39a1640a)    R(0x0173,0x370068d9,0x393008c2,0x3950349f)    R(0x0174,0x2f01c132,0x2fe148db,0x30c1ccf5)    R(0x0175,0x3ab5994e,0x3c863917,0x3905f927)    R(0x0176,0x36d1cd21,0x38414926,0x36a1a16d)    R(0x0177,0x39a16840,0x3bf13419,0x3be10054)    R(0x0178,0x36f03d07,0x393008c2,0x370068d9)    R(0x0179,0x2f21351c,0x3020ecc2,0x2fe148db)    R(0x017a,0x39a1640a,0x3af14803,0x3bf13419)    R(0x017b,0x36a1c8cd,0x39315c8d,0x38c154d9)\n    R(0x017c,0x39315c8d,0x39a16840,0x3be10054)    R(0x017d,0x390074fa,0x3a700cb4,0x381038fa)    R(0x017e,0x36c1a07d,0x39a16840,0x39315c8d)    R(0x017f,0x36c1a07d,0x36e1702b,0x39a16840)    R(0x0180,0x38c154d9,0x39315c8d,0x3af0c09f)    R(0x0181,0x36a1c8cd,0x36c1a07d,0x39315c8d)    R(0x0182,0x38c154d9,0x3990c8eb,0x38414926)    R(0x0183,0x36a1a16d,0x38414926,0x37c1094e)    R(0x0184,0x39a16840,0x39a1640a,0x3bf13419)    R(0x0185,0x36e1702b,0x38315c03,0x39a1640a)\n    R(0x0186,0x2f01c132,0x30c1ccf5,0x2ff22d49)    R(0x0187,0x3565615d,0x37b5415a,0x3905f927)    R(0x0188,0x36d1cd21,0x36a1c8cd,0x38c154d9)    R(0x0189,0x36e1702b,0x39a1640a,0x39a16840)    R(0x018a,0x36d1cd21,0x38c154d9,0x38414926)    R(0x018b,0x37b5415a,0x3ab5994e,0x3905f927)    R(0x018c,0x3730993d,0x35a0854b,0x35d0f586)    R(0x018d,0x3bf13419,0x3af14803,0x3c810015)    R(0x018e,0x0072b5be,0x002305bc,0x00326df8)    R(0x018f,0x2da2d5e2,0x2f72b1d1,0x2ff2ea02)\n    R(0x0190,0x3cb5dd87,0x3ee6714a,0x3d35fd51)    R(0x0191,0x3215f59c,0x3376b58b,0x322605c4)    R(0x0192,0x2882a5cb,0x2bf269d3,0x2b0331db)    R(0x0193,0x29c1e5dc,0x2b114e01,0x2c11d9de)    R(0x0194,0x324431bb,0x3433edd4,0x35549d8e)    R(0x0195,0x33f0d998,0x35a0854b,0x3390c95f)    R(0x0196,0x3691380f,0x38315c03,0x35314825)    R(0x0197,0x35a3e9f7,0x38c49dbd,0x36c451b9)    R(0x0198,0x2e222984,0x2f01c132,0x2ff22d49)    R(0x0199,0x2f412158,0x31310593,0x3100f541)\n    R(0x019a,0x2fa27d93,0x2ff22d49,0x32526564)    R(0x019b,0x2f73bdeb,0x324431bb,0x30046dca)    R(0x019c,0x2b0331db,0x2da2d5e2,0x2e1361f6)    R(0x019d,0x2e11a578,0x2e8155a8,0x2f412158)    R(0x019e,0x2e8155a8,0x31310593,0x2f412158)    R(0x019f,0x2ff139d6,0x31310593,0x2e8155a8)    R(0x01a0,0x2bf269d3,0x2cf225bd,0x2d8285c0)    R(0x01a1,0x2f72b1d1,0x2fa27d93,0x324271b2)    R(0x01a2,0x2cf225bd,0x2e11a578,0x2e222984)    R(0x01a3,0x2cf225bd,0x2e222984,0x2d8285c0)\n    R(0x01a4,0x2d31adc2,0x2e8155a8,0x2e11a578)    R(0x01a5,0x2d8285c0,0x2e222984,0x2fa27d93)    R(0x01a6,0x2cf225bd,0x2d31adc2,0x2e11a578)    R(0x01a7,0x2d8285c0,0x2fa27d93,0x2f72b1d1)    R(0x01a8,0x2d9169f0,0x2ff139d6,0x2e8155a8)    R(0x01a9,0x2e11a578,0x2f01c132,0x2e222984)    R(0x01aa,0x2f72b1d1,0x324271b2,0x30e29df2)    R(0x01ab,0x2bf269d3,0x2d8285c0,0x2da2d5e2)    R(0x01ac,0x2df409f5,0x2f73bdeb,0x30046dca)    R(0x01ad,0x2c11d9de,0x2d9169f0,0x2d31adc2)\n    R(0x01ae,0x2d9169f0,0x2e8155a8,0x2d31adc2)    R(0x01af,0x2da2d5e2,0x2d8285c0,0x2f72b1d1)    R(0x01b0,0x2f73bdeb,0x31739ded,0x324431bb)    R(0x01b1,0x2e222984,0x2ff22d49,0x2fa27d93)    R(0x01b2,0x37c1094e,0x3730993d,0x35d0f586)    R(0x01b3,0x35d0f586,0x35a0854b,0x33f0d998)    R(0x01b4,0x3433edd4,0x36c451b9,0x35549d8e)    R(0x01b5,0x324271b2,0x34a1f1b6,0x32c229f9)    R(0x01b6,0x29c1e5dc,0x2c11d9de,0x2bf269d3)    R(0x01b7,0x34c2296b,0x36a1a16d,0x34a1f1b6)\n    R(0x01b8,0x32512de1,0x33f0d998,0x31310593)    R(0x01b9,0x36a1a16d,0x37c1094e,0x35d16da2)    R(0x01ba,0x34a1f1b6,0x35d16da2,0x33c1b5f2)    R(0x01bb,0x2fa27d93,0x32526564,0x324271b2)    R(0x01bc,0x35d16da2,0x35d0f586,0x340149d3)    R(0x01bd,0x35d0f586,0x33f0d998,0x340149d3)    R(0x01be,0x36a1a16d,0x35d16da2,0x34a1f1b6)    R(0x01bf,0x340149d3,0x33f0d998,0x32512de1)    R(0x01c0,0x324271b2,0x34c2296b,0x34a1f1b6)    R(0x01c1,0x2ff139d6,0x32512de1,0x31310593)\n    R(0x01c2,0x37c1094e,0x35d0f586,0x35d16da2)    R(0x01c3,0x34a1f1b6,0x33c1b5f2,0x32c229f9)    R(0x01c4,0x2b0331db,0x2bf269d3,0x2da2d5e2)    R(0x01c5,0x35a3e9f7,0x36c451b9,0x3433edd4)    R(0x01c6,0x2bf269d3,0x2c11d9de,0x2cf225bd)    R(0x01c7,0x324271b2,0x32526564,0x34c2296b)    R(0x01c8,0x324271b2,0x32c229f9,0x30e29df2)    R(0x01c9,0x2c11d9de,0x2d31adc2,0x2cf225bd)    R(0x01ca,0x31739ded,0x3433edd4,0x324431bb)    R(0x01cb,0x35d16da2,0x340149d3,0x33c1b5f2)\n    R(0x01cc,0x2df409f5,0x30046dca,0x2ec499e7)    R(0x01cd,0x305555d3,0x322605c4,0x30b551fa)    R(0x01ce,0x31310593,0x3390c95f,0x3100f541)    R(0x01cf,0x3215f59c,0x33e68d65,0x3376b58b)    R(0x01d0,0x3345b174,0x35f6313d,0x33e68d65)    R(0x01d1,0x3db63d7b,0x3ee6714a,0x3cb5dd87)    R(0x01d2,0x3345b174,0x3565615d,0x35f6313d)    R(0x01d3,0x35549d8e,0x38b4e585,0x37b5415a)    R(0x01d4,0x31310593,0x33f0d998,0x3390c95f)    R(0x01d5,0x35c6b18a,0x3866516b,0x36a5d1a9)\n    R(0x01d6,0x2ec499e7,0x30046dca,0x30e529ad)    R(0x01d7,0x30b551fa,0x322605c4,0x3305c9f0)    R(0x01d8,0x30046dca,0x324431bb,0x32c4e190)    R(0x01d9,0x36c451b9,0x38b4e585,0x35549d8e)    R(0x01da,0x35549d8e,0x37b5415a,0x3565615d)    R(0x01db,0x30e529ad,0x3215f59c,0x305555d3)    R(0x01dc,0x34e61dc3,0x35c6b18a,0x36a5d1a9)    R(0x01dd,0x32c4e190,0x3565615d,0x3345b174)    R(0x01de,0x324431bb,0x35549d8e,0x32c4e190)    R(0x01df,0x30e529ad,0x3345b174,0x3215f59c)\n    R(0x01e0,0x30e529ad,0x32c4e190,0x3345b174)    R(0x01e1,0x344671c6,0x35c6b18a,0x34e61dc3)    R(0x01e2,0x32c4e190,0x35549d8e,0x3565615d)    R(0x01e3,0x2ec499e7,0x30e529ad,0x305555d3)    R(0x01e4,0x34258df0,0x36a5d1a9,0x36955de8)    R(0x01e5,0x322605c4,0x33d6a1ae,0x3305c9f0)    R(0x01e6,0x34258df0,0x34e61dc3,0x36a5d1a9)    R(0x01e7,0x3305c9f0,0x344671c6,0x34258df0)    R(0x01e8,0x344671c6,0x34e61dc3,0x34258df0)    R(0x01e9,0x3345b174,0x33e68d65,0x3215f59c)\n    R(0x01ea,0x305555d3,0x3215f59c,0x322605c4)    R(0x01eb,0x3305c9f0,0x33d6a1ae,0x344671c6)    R(0x01ec,0x3b054d86,0x3d35fd51,0x3ab5994e)    R(0x01ed,0x3b763d79,0x3e467963,0x3c1605a0)    R(0x01ee,0x30046dca,0x32c4e190,0x30e529ad)    R(0x01ef,0x37b475f0,0x38c49dbd,0x35a3e9f7)    R(0x01f0,0x38b4e585,0x3ab5994e,0x37b5415a)    R(0x01f1,0x3c1605a0,0x3e467963,0x3db63d7b)    R(0x01f2,0x38c49dbd,0x38b4e585,0x36c451b9)    R(0x01f3,0x3b55b9b4,0x3db63d7b,0x3cb5dd87)\n    R(0x01f4,0x36a5d1a9,0x3866516b,0x3925c9b2)    R(0x01f5,0x3a6529ba,0x3cb5dd87,0x3b054d86)    R(0x01f6,0x3b55b9b4,0x3cb5dd87,0x3a6529ba)    R(0x01f7,0x38c49dbd,0x3b054d86,0x38b4e585)    R(0x01f8,0x3a6529ba,0x3b054d86,0x38c49dbd)    R(0x01f9,0x3c1605a0,0x3db63d7b,0x3b55b9b4)    R(0x01fa,0x3925c9b2,0x3b763d79,0x3c1605a0)    R(0x01fb,0x3925c9b2,0x3866516b,0x3b763d79)    R(0x01fc,0x37b475f0,0x3a6529ba,0x38c49dbd)    R(0x01fd,0x3b054d86,0x3ab5994e,0x38b4e585)\n    R(0x01fe,0x36955de8,0x3925c9b2,0x398591d8)    R(0x01ff,0x3cb5dd87,0x3d35fd51,0x3b054d86)    R(0x0200,0x398591d8,0x3c1605a0,0x3b55b9b4)    R(0x0201,0x38e519e8,0x3a6529ba,0x37b475f0)    R(0x0202,0x36955de8,0x36a5d1a9,0x3925c9b2)    R(0x0203,0x38e519e8,0x3b55b9b4,0x3a6529ba)    R(0x0204,0x398591d8,0x3b55b9b4,0x38e519e8)    R(0x0205,0x3925c9b2,0x3c1605a0,0x398591d8)    R(0x0206,0x00e6a4d2,0x0116bcb3,0x011790c3)    R(0x0207,0x02ed0a11,0x020cfdc1,0x036dc5d7)\n    R(0x0208,0x0daffd68,0x0a8fd96e,0x0c2fb932)    R(0x0209,0x1197e840,0x13270443,0x1537f43b)    R(0x020a,0x381038fa,0x393008c2,0x36f03d07)    R(0x020b,0x3f86a539,0x3ff6c907,0x3ee6714a)    R(0x020c,0x13a9083e,0x1028b043,0x1197e840)    R(0x020d,0x0466c8a2,0x01c6d0a4,0x0215f0a5)    R(0x020e,0x01f65d02,0x00e6a4d2,0x02074cf4)    R(0x020f,0x0f3ff199,0x0daffd68,0x0fffd95f)    R(0x0210,0x0298d20e,0x029835c6,0x02b921bb)    R(0x0211,0x10499045,0x0cc9304d,0x1028b043)\n    R(0x0212,0x07067cab,0x0466c8a2,0x05061cad)    R(0x0213,0x0177cca9,0x0116bcb3,0x01c6d0a4)    R(0x0214,0x03391d25,0x021834ec,0x023910e5)    R(0x0215,0x13a9083e,0x10499045,0x1028b043)    R(0x0216,0x0aeea0df,0x0acf4507,0x089ec4f8)    R(0x0217,0x06c73c8a,0x0466c8a2,0x07067cab)    R(0x0218,0x011790c3,0x0116bcb3,0x0177cca9)    R(0x0219,0x03391d25,0x023910e5,0x0239dcec)    R(0x021a,0x0b563893,0x0976c07f,0x07067cab)    R(0x021b,0x112b0c5a,0x0eca584d,0x130a144c)\n    R(0x021c,0x13270443,0x0ee72c49,0x11065852)    R(0x021d,0x1197e840,0x0ee72c49,0x13270443)    R(0x021e,0x070a086e,0x0399648d,0x06790076)    R(0x021f,0x057ad487,0x038a2c88,0x070a086e)    R(0x0220,0x06c73c8a,0x0387a49f,0x0466c8a2)    R(0x0221,0x011790c3,0x0177cca9,0x014878bc)    R(0x0222,0x018a9907,0x0239dcec,0x019a4cbe)    R(0x0223,0x0688107d,0x0387a49f,0x06c73c8a)    R(0x0224,0x0387a49f,0x01c6d0a4,0x0466c8a2)    R(0x0225,0x03788496,0x0177cca9,0x0387a49f)\n    R(0x0226,0x070a086e,0x038a2c88,0x0399648d)    R(0x0227,0x057ad487,0x027a9ca1,0x038a2c88)    R(0x0228,0x0399648d,0x01a8d09e,0x03788496)    R(0x0229,0x01d9c099,0x01a8d09e,0x0399648d)    R(0x022a,0x038a2c88,0x01d9c099,0x0399648d)    R(0x022b,0x03788496,0x0387a49f,0x0688107d)    R(0x022c,0x027a9ca1,0x01d9c099,0x038a2c88)    R(0x022d,0x01a8d09e,0x0177cca9,0x03788496)    R(0x022e,0x0177cca9,0x01c6d0a4,0x0387a49f)    R(0x022f,0x02074cf4,0x011790c3,0x021834ec)\n    R(0x0230,0x06790076,0x03788496,0x0688107d)    R(0x0231,0x019a4cbe,0x01d9c099,0x027a9ca1)    R(0x0232,0x0399648d,0x03788496,0x06790076)    R(0x0233,0x023910e5,0x014878bc,0x016964b7)    R(0x0234,0x01d9c099,0x016964b7,0x01a8d09e)    R(0x0235,0x023910e5,0x016964b7,0x0239dcec)    R(0x0236,0x0239dcec,0x016964b7,0x019a4cbe)    R(0x0237,0x021834ec,0x014878bc,0x023910e5)    R(0x0238,0x1028b043,0x0cc9304d,0x0d38184b)    R(0x0239,0x130a144c,0x0eca584d,0x10499045)\n    R(0x023a,0x0c5b005b,0x0b0a3054,0x0eca584d)    R(0x023b,0x0d16a85e,0x0976c07f,0x0b563893)    R(0x023c,0x021834ec,0x011790c3,0x014878bc)    R(0x023d,0x0cc9304d,0x09986c5d,0x0d38184b)    R(0x023e,0x0ee72c49,0x0d16a85e,0x11065852)    R(0x023f,0x09986c5d,0x0688107d,0x0a77705e)    R(0x0240,0x0959605a,0x06790076,0x09986c5d)    R(0x0241,0x0eca584d,0x0cc9304d,0x10499045)    R(0x0242,0x08eae066,0x070a086e,0x0b0a3054)    R(0x0243,0x0cc9304d,0x0959605a,0x09986c5d)\n    R(0x0244,0x0b0a3054,0x0959605a,0x0cc9304d)    R(0x0245,0x0d38184b,0x09986c5d,0x0a77705e)    R(0x0246,0x070a086e,0x0959605a,0x0b0a3054)    R(0x0247,0x0ee72c49,0x0a77705e,0x0d16a85e)    R(0x0248,0x0a77705e,0x0976c07f,0x0d16a85e)    R(0x0249,0x0d38184b,0x0a77705e,0x0ee72c49)    R(0x024a,0x014878bc,0x0177cca9,0x01a8d09e)    R(0x024b,0x019a4cbe,0x016964b7,0x01d9c099)    R(0x024c,0x0eca584d,0x0b0a3054,0x0cc9304d)    R(0x024d,0x06790076,0x0688107d,0x09986c5d)\n    R(0x024e,0x016964b7,0x014878bc,0x01a8d09e)    R(0x024f,0x070a086e,0x06790076,0x0959605a)    R(0x0250,0x0a77705e,0x0688107d,0x06c73c8a)    R(0x0251,0x0a77705e,0x06c73c8a,0x0976c07f)    R(0x0252,0x018a9907,0x019a4cbe,0x020afcde)    R(0x0253,0x066ea521,0x071e08ee,0x089ec4f8)    R(0x0254,0x0976c07f,0x06c73c8a,0x07067cab)    R(0x0255,0x0d2f3cfd,0x0acf4507,0x0aeea0df)    R(0x0256,0x112b0c5a,0x0c5b005b,0x0eca584d)    R(0x0257,0x0f5dd50c,0x0e9d48d4,0x121d8ce5)\n    R(0x0258,0x08eae066,0x0b0a3054,0x0c5b005b)    R(0x0259,0x08eae066,0x057ad487,0x070a086e)    R(0x025a,0x020afcde,0x019a4cbe,0x027a9ca1)    R(0x025b,0x0aeea0df,0x089ec4f8,0x08fdf4d8)    R(0x025c,0x069d1cec,0x071e08ee,0x04fdc513)    R(0x025d,0x09bc44ae,0x077b8490,0x0aabac7e)    R(0x025e,0x020afcde,0x027a9ca1,0x045b38bb)    R(0x025f,0x0aabac7e,0x08eae066,0x0c5b005b)    R(0x0260,0x084c94e3,0x06abf4cd,0x09bc44ae)    R(0x0261,0x0aeea0df,0x08fdf4d8,0x0b3dd0dd)\n    R(0x0262,0x09bc44ae,0x06abf4cd,0x077b8490)    R(0x0263,0x077b8490,0x045b38bb,0x057ad487)    R(0x0264,0x0b6cf4d2,0x084c94e3,0x09bc44ae)    R(0x0265,0x097d2ce1,0x084c94e3,0x0b6cf4d2)    R(0x0266,0x0b3dd0dd,0x08fdf4d8,0x097d2ce1)    R(0x0267,0x06abf4cd,0x045b38bb,0x077b8490)    R(0x0268,0x077b8490,0x057ad487,0x08eae066)    R(0x0269,0x0aabac7e,0x077b8490,0x08eae066)    R(0x026a,0x053c3cfc,0x038b9900,0x06abf4cd)    R(0x026b,0x069d1cec,0x041cf50e,0x053c3cfc)\n    R(0x026c,0x089ec4f8,0x071e08ee,0x08fdf4d8)    R(0x026d,0x084c94e3,0x053c3cfc,0x06abf4cd)    R(0x026e,0x097d2ce1,0x069d1cec,0x084c94e3)    R(0x026f,0x097d2ce1,0x08fdf4d8,0x069d1cec)    R(0x0270,0x08fdf4d8,0x071e08ee,0x069d1cec)    R(0x0271,0x069d1cec,0x053c3cfc,0x084c94e3)    R(0x0272,0x0e5ba876,0x0c5b005b,0x112b0c5a)    R(0x0273,0x045b38bb,0x027a9ca1,0x057ad487)    R(0x0274,0x121d8ce5,0x0e9d48d4,0x119cd8af)    R(0x0275,0x038b9900,0x020afcde,0x045b38bb)\n    R(0x0276,0x0d3ea4e6,0x0d2f3cfd,0x0aeea0df)    R(0x0277,0x0f9e6d10,0x0d3ea4e6,0x0dbdf8f9)    R(0x0278,0x0aabac7e,0x0c5b005b,0x0e5ba876)    R(0x0279,0x038b9900,0x045b38bb,0x06abf4cd)    R(0x027a,0x116c1482,0x0e5ba876,0x112b0c5a)    R(0x027b,0x119cd8af,0x0dac7c9d,0x116c1482)    R(0x027c,0x0d3ea4e6,0x0aeea0df,0x0b3dd0dd)    R(0x027d,0x0b6cf4d2,0x09bc44ae,0x0dac7c9d)    R(0x027e,0x0e9d48d4,0x0dac7c9d,0x119cd8af)    R(0x027f,0x0e9d48d4,0x0b6cf4d2,0x0dac7c9d)\n    R(0x0280,0x0c8d70f0,0x0b6cf4d2,0x0e9d48d4)    R(0x0281,0x0dac7c9d,0x0aabac7e,0x0e5ba876)    R(0x0282,0x0dac7c9d,0x0e5ba876,0x116c1482)    R(0x0283,0x0c8d70f0,0x097d2ce1,0x0b6cf4d2)    R(0x0284,0x0f9e6d10,0x0f9f2d0d,0x0d3ea4e6)    R(0x0285,0x0f9f2d0d,0x0d2f3cfd,0x0d3ea4e6)    R(0x0286,0x0f5dd50c,0x0c8d70f0,0x0e9d48d4)    R(0x0287,0x0dbdf8f9,0x0b3dd0dd,0x0c8d70f0)    R(0x0288,0x0f5dd50c,0x0dbdf8f9,0x0c8d70f0)    R(0x0289,0x0d3ea4e6,0x0b3dd0dd,0x0dbdf8f9)\n    R(0x028a,0x0dac7c9d,0x09bc44ae,0x0aabac7e)    R(0x028b,0x0c8d70f0,0x0b3dd0dd,0x097d2ce1)    R(0x028c,0x02c70138,0x02961150,0x01f65d02)    R(0x028d,0x1197e840,0x0d38184b,0x0ee72c49)    R(0x028e,0x0219c5f8,0x0189ddb2,0x013ab9ff)    R(0x028f,0x12ce6967,0x110e4132,0x129e1122)    R(0x0290,0x10ee760c,0x104e9dda,0x123e95c0)    R(0x0291,0x0c3ff9a8,0x0a8fd96e,0x0daffd68)    R(0x0292,0x013ab9ff,0x016a91b0,0x01bb71d7)    R(0x0293,0x02869d92,0x02961150,0x02c70138)\n    R(0x0294,0x04fdc513,0x071e08ee,0x066ea521)    R(0x0295,0x1028b043,0x0d38184b,0x1197e840)    R(0x0296,0x110e4132,0x0f5dd50c,0x129e1122)    R(0x0297,0x01bb71d7,0x016a91b0,0x01eb4178)    R(0x0298,0x01bb4d29,0x020afcde,0x038b9900)    R(0x0299,0x015a755f,0x0279fd2a,0x018a9907)    R(0x029a,0x01ecc972,0x030d3d3f,0x02dd9d88)    R(0x029b,0x026745d6,0x015669e1,0x02869d92)    R(0x029c,0x01bc59fc,0x01ec25a9,0x020cfdc1)    R(0x029d,0x01bb4d29,0x038b9900,0x02ac392d)\n    R(0x029e,0x02c70138,0x02074cf4,0x0308112b)    R(0x029f,0x0279a16e,0x0279fd2a,0x015a755f)    R(0x02a0,0x01bb4d29,0x018a9907,0x020afcde)    R(0x02a1,0x01ec25a9,0x01eb4178,0x01bbf55d)    R(0x02a2,0x01ecc972,0x02ac392d,0x030d3d3f)    R(0x02a3,0x0308112b,0x02074cf4,0x021834ec)    R(0x02a4,0x01bbf55d,0x01bb4d29,0x02ac392d)    R(0x02a5,0x01ec25a9,0x01bbf55d,0x01ecc972)    R(0x02a6,0x01ecc972,0x01bbf55d,0x02ac392d)    R(0x02a7,0x01eb4178,0x01bb4d29,0x01bbf55d)\n    R(0x02a8,0x029835c6,0x026745d6,0x02b7a17d)    R(0x02a9,0x03391d25,0x0239dcec,0x0279fd2a)    R(0x02aa,0x0189ddb2,0x0279a16e,0x015a755f)    R(0x02ab,0x01bc59fc,0x01bb71d7,0x01ec25a9)    R(0x02ac,0x020cfdc1,0x01ecc972,0x02dd9d88)    R(0x02ad,0x0279fd2a,0x0239dcec,0x018a9907)    R(0x02ae,0x01bb71d7,0x01eb4178,0x01ec25a9)    R(0x02af,0x02b921bb,0x0279a16e,0x0189ddb2)    R(0x02b0,0x020cfdc1,0x01ec25a9,0x01ecc972)    R(0x02b1,0x0219c5f8,0x02b921bb,0x0189ddb2)\n    R(0x02b2,0x129e1122,0x0f5dd50c,0x121d8ce5)    R(0x02b3,0x0f9e6d10,0x0dbdf8f9,0x0f5dd50c)    R(0x02b4,0x015a755f,0x018a9907,0x01bb4d29)    R(0x02b5,0x02b7a17d,0x02c70138,0x0308112b)    R(0x02b6,0x036dc5d7,0x02dd9d88,0x047e6d9e)    R(0x02b7,0x0308112b,0x021834ec,0x03391d25)    R(0x02b8,0x02f8b171,0x0308112b,0x03391d25)    R(0x02b9,0x01eb4178,0x015a755f,0x01bb4d29)    R(0x02ba,0x069d1cec,0x04fdc513,0x041cf50e)    R(0x02bb,0x110e4132,0x0f9e6d10,0x0f5dd50c)\n    R(0x02bc,0x02ac392d,0x038b9900,0x053c3cfc)    R(0x02bd,0x02ac392d,0x041cf50e,0x030d3d3f)    R(0x02be,0x0279a16e,0x03391d25,0x0279fd2a)    R(0x02bf,0x041cf50e,0x04fdc513,0x030d3d3f)    R(0x02c0,0x030d3d3f,0x04fdc513,0x044e2150)    R(0x02c1,0x02f8b171,0x03391d25,0x0279a16e)    R(0x02c2,0x02f8b171,0x02b7a17d,0x0308112b)    R(0x02c3,0x0189ddb2,0x015a755f,0x016a91b0)    R(0x02c4,0x053c3cfc,0x041cf50e,0x02ac392d)    R(0x02c5,0x020cfdc1,0x02dd9d88,0x036dc5d7)\n    R(0x02c6,0x02dd9d88,0x044e2150,0x047e6d9e)    R(0x02c7,0x016a91b0,0x015a755f,0x01eb4178)    R(0x02c8,0x02b921bb,0x029835c6,0x02f8b171)    R(0x02c9,0x02b921bb,0x02f8b171,0x0279a16e)    R(0x02ca,0x02dd9d88,0x030d3d3f,0x044e2150)    R(0x02cb,0x029835c6,0x02b7a17d,0x02f8b171)    R(0x02cc,0x02c70138,0x01f65d02,0x02074cf4)    R(0x02cd,0x0f3ff199,0x0c3ff9a8,0x0daffd68)    R(0x02ce,0x0c5f6204,0x0ddfd1d2,0x0eff7de5)    R(0x02cf,0x12ce6967,0x11de8163,0x110e4132)\n    R(0x02d0,0x047e6d9e,0x044e2150,0x05feed63)    R(0x02d1,0x044e2150,0x04fdc513,0x066ea521)    R(0x02d2,0x0acf4507,0x089f6134,0x089ec4f8)    R(0x02d3,0x02b7a17d,0x02869d92,0x02c70138)    R(0x02d4,0x092fb9b2,0x0a8fd96e,0x0c3ff9a8)    R(0x02d5,0x026745d6,0x02869d92,0x02b7a17d)    R(0x02d6,0x07ef35ec,0x066f25b0,0x092fb9b2)    R(0x02d7,0x0eff7de5,0x0ddfd1d2,0x107fa5b5)    R(0x02d8,0x044e2150,0x066ea521,0x05feed63)    R(0x02d9,0x0eefa52a,0x0d2f3cfd,0x0f9f2d0d)\n    R(0x02da,0x07ef8579,0x089f6134,0x0a8fd96e)    R(0x02db,0x092fb9b2,0x07ef8579,0x0a8fd96e)    R(0x02dc,0x05feed63,0x089f6134,0x07ef8579)    R(0x02dd,0x047e6d9e,0x05feed63,0x066f25b0)    R(0x02de,0x0c2fb932,0x0acf4507,0x0d2f3cfd)    R(0x02df,0x05feed63,0x066ea521,0x089f6134)    R(0x02e0,0x0a8fd96e,0x089f6134,0x0c2fb932)    R(0x02e1,0x066f25b0,0x05feed63,0x07ef8579)    R(0x02e2,0x055e89e8,0x047e6d9e,0x066f25b0)    R(0x02e3,0x089f6134,0x066ea521,0x089ec4f8)\n    R(0x02e4,0x055e89e8,0x066f25b0,0x07ef35ec)    R(0x02e5,0x0aefa9e5,0x092fb9b2,0x0c3ff9a8)    R(0x02e6,0x0ddfd1d2,0x0c3ff9a8,0x0f3ff199)    R(0x02e7,0x07ef35ec,0x092fb9b2,0x0aefa9e5)    R(0x02e8,0x0eefa52a,0x0c2fb932,0x0d2f3cfd)    R(0x02e9,0x0c2fb932,0x089f6134,0x0acf4507)    R(0x02ea,0x0aefa9e5,0x0c3ff9a8,0x0ddfd1d2)    R(0x02eb,0x066f25b0,0x07ef8579,0x092fb9b2)    R(0x02ec,0x112ec934,0x0f9f2d0d,0x0f9e6d10)    R(0x02ed,0x11cea19b,0x11de8163,0x12ce6967)\n    R(0x02ee,0x0f3ff199,0x0fffd95f,0x114fa17f)    R(0x02ef,0x036dc5d7,0x047e6d9e,0x055e89e8)    R(0x02f0,0x104e9dda,0x0e1ed9ff,0x106ef9d1)    R(0x02f1,0x11de8163,0x112ec934,0x110e4132)    R(0x02f2,0x110e4132,0x112ec934,0x0f9e6d10)    R(0x02f3,0x11cea19b,0x11df016a,0x11de8163)    R(0x02f4,0x10ff753e,0x0eefa52a,0x0f9f2d0d)    R(0x02f5,0x107fa5b5,0x0f3ff199,0x114fa17f)    R(0x02f6,0x11df016a,0x10ff753e,0x112ec934)    R(0x02f7,0x119f05a0,0x114fa17f,0x11df016a)\n    R(0x02f8,0x114fa17f,0x10ff753e,0x11df016a)    R(0x02f9,0x11df016a,0x112ec934,0x11de8163)    R(0x02fa,0x114fa17f,0x0fffd95f,0x10ff753e)    R(0x02fb,0x119f05a0,0x11df016a,0x11cea19b)    R(0x02fc,0x104e9dda,0x11cea19b,0x123e95c0)    R(0x02fd,0x0e1ed9ff,0x0eff7de5,0x106ef9d1)    R(0x02fe,0x10ff753e,0x0f9f2d0d,0x112ec934)    R(0x02ff,0x107fa5b5,0x0ddfd1d2,0x0f3ff199)    R(0x0300,0x106ef9d1,0x119f05a0,0x11cea19b)    R(0x0301,0x106ef9d1,0x107fa5b5,0x119f05a0)\n    R(0x0302,0x106ef9d1,0x0eff7de5,0x107fa5b5)    R(0x0303,0x107fa5b5,0x114fa17f,0x119f05a0)    R(0x0304,0x0fffd95f,0x0eefa52a,0x10ff753e)    R(0x0305,0x104e9dda,0x106ef9d1,0x11cea19b)    R(0x0306,0x13a9083e,0x1197e840,0x1537f43b)    R(0x0307,0x3a700cb4,0x393008c2,0x381038fa)    R(0x0308,0x02074cf4,0x00e6a4d2,0x011790c3)    R(0x0309,0x3fd6e8f4,0x3f2710c8,0x3ff6c907)    R(0x030a,0x123e95c0,0x11cea19b,0x12ce6967)    R(0x030b,0x10ee760c,0x123e95c0,0x14ee85ef)\n    R(0x030c,0x3b2044ac,0x3c402476,0x3a700cb4)    R(0x030d,0x0116bcb3,0x0105c8ac,0x01c6d0a4)    R(0x030e,0x3f76d51a,0x3e3734c5,0x3fd6e8f4)    R(0x030f,0x1537f43b,0x13270443,0x16c70c47)    R(0x0310,0x36679520,0x3897a4d7,0x3837acf3)    R(0x0311,0x192de91d,0x160db8f7,0x192d4cd4)    R(0x0312,0x13270443,0x11065852,0x14e64055)    R(0x0313,0x13a9083e,0x1537f43b,0x16e8d046)    R(0x0314,0x1b99288e,0x1ae83c74,0x1c6848b0)    R(0x0315,0x3c863917,0x3e56c8d8,0x3b56a4ea)\n    R(0x0316,0x3d2714f9,0x3e3734c5,0x3f76d51a)    R(0x0317,0x3e3734c5,0x3f2710c8,0x3fd6e8f4)    R(0x0318,0x16c70c47,0x13270443,0x14e64055)    R(0x0319,0x1dd910b6,0x1c6848b0,0x1f282cc6)    R(0x031a,0x3837acf3,0x3ae780d7,0x38d7750e)    R(0x031b,0x206750ee,0x1dc664e7,0x21668518)    R(0x031c,0x1ae83c74,0x1898004d,0x19873c62)    R(0x031d,0x19873c62,0x18165868,0x1a36a893)    R(0x031e,0x1b67789f,0x1a36a893,0x1b26a8cc)    R(0x031f,0x3a373cc1,0x396788c1,0x37c75cec)\n    R(0x0320,0x19a90458,0x16e8d046,0x1898004d)    R(0x0321,0x217910cc,0x1dd910b6,0x1f282cc6)    R(0x0322,0x1ae83c74,0x19873c62,0x1b67789f)    R(0x0323,0x1c6848b0,0x1b67789f,0x1d175cca)    R(0x0324,0x1f282cc6,0x1c6848b0,0x1d175cca)    R(0x0325,0x1c6848b0,0x1ae83c74,0x1b67789f)    R(0x0326,0x1d175cca,0x1b67789f,0x1b26a8cc)    R(0x0327,0x1b67789f,0x19873c62,0x1a36a893)    R(0x0328,0x1d175cca,0x1b26a8cc,0x1dc664e7)    R(0x0329,0x3856b907,0x3a373cc1,0x37c75cec)\n    R(0x032a,0x1898004d,0x16c70c47,0x19873c62)    R(0x032b,0x217910cc,0x1f282cc6,0x223834f1)    R(0x032c,0x37c75cec,0x396788c1,0x36e79101)    R(0x032d,0x36e79101,0x396788c1,0x3897a4d7)    R(0x032e,0x1f282cc6,0x1d175cca,0x206750ee)    R(0x032f,0x223834f1,0x1f282cc6,0x206750ee)    R(0x0330,0x19a90458,0x1898004d,0x1ae83c74)    R(0x0331,0x206750ee,0x1d175cca,0x1dc664e7)    R(0x0332,0x16e8d046,0x1537f43b,0x1898004d)    R(0x0333,0x16c70c47,0x14e64055,0x18165868)\n    R(0x0334,0x3f86e8d9,0x3f2710c8,0x3e1728b1)    R(0x0335,0x38d7750e,0x3ae780d7,0x3d2714f9)    R(0x0336,0x3bf758a6,0x3e1728b1,0x3d4750ab)    R(0x0337,0x3cc718b3,0x3e1728b1,0x3bf758a6)    R(0x0338,0x3e56c8d8,0x3e1728b1,0x3cc718b3)    R(0x0339,0x3e1728b1,0x3f2710c8,0x3d4750ab)    R(0x033a,0x3a373cc1,0x3cc718b3,0x3bf758a6)    R(0x033b,0x3897a4d7,0x3af77cae,0x3b2788b8)    R(0x033c,0x3b2788b8,0x3d4750ab,0x3e3734c5)    R(0x033d,0x3a373cc1,0x3bf758a6,0x396788c1)\n    R(0x033e,0x3af77cae,0x3d4750ab,0x3b2788b8)    R(0x033f,0x396788c1,0x3bf758a6,0x3af77cae)    R(0x0340,0x3d4750ab,0x3f2710c8,0x3e3734c5)    R(0x0341,0x396788c1,0x3af77cae,0x3897a4d7)    R(0x0342,0x3856b907,0x3b56a4ea,0x3a373cc1)    R(0x0343,0x19873c62,0x16c70c47,0x18165868)    R(0x0344,0x3e56c8d8,0x3f86e8d9,0x3e1728b1)    R(0x0345,0x3837acf3,0x3b2788b8,0x3ae780d7)    R(0x0346,0x3b56a4ea,0x3cc718b3,0x3a373cc1)    R(0x0347,0x3ae780d7,0x3e3734c5,0x3d2714f9)\n    R(0x0348,0x3bf758a6,0x3d4750ab,0x3af77cae)    R(0x0349,0x3b2788b8,0x3e3734c5,0x3ae780d7)    R(0x034a,0x3b56a4ea,0x3e56c8d8,0x3cc718b3)    R(0x034b,0x3897a4d7,0x3b2788b8,0x3837acf3)    R(0x034c,0x116c1482,0x112b0c5a,0x143b946f)    R(0x034d,0x160db8f7,0x121d8ce5,0x158d20ba)    R(0x034e,0x16f9d04f,0x130a144c,0x13a9083e)    R(0x034f,0x3f168514,0x3f86e8d9,0x3e56c8d8)    R(0x0350,0x143b946f,0x112b0c5a,0x156ac05d)    R(0x0351,0x153c7090,0x116c1482,0x143b946f)\n    R(0x0352,0x16f9d04f,0x13a9083e,0x16e8d046)    R(0x0353,0x1b99288e,0x19a90458,0x1ae83c74)    R(0x0354,0x1cca009e,0x1a09f470,0x1b99288e)    R(0x0355,0x119cd8af,0x116c1482,0x153c7090)    R(0x0356,0x160db8f7,0x158d20ba,0x192d4cd4)    R(0x0357,0x1c3d7105,0x192d4cd4,0x1c8c9cc7)    R(0x0358,0x16f9d04f,0x16e8d046,0x19a90458)    R(0x0359,0x156ac05d,0x130a144c,0x16f9d04f)    R(0x035a,0x1c1ae88f,0x18bac871,0x1a09f470)    R(0x035b,0x18bc9ca2,0x153c7090,0x17cbb87f)\n    R(0x035c,0x17cbb87f,0x156ac05d,0x18bac871)    R(0x035d,0x1b1bd09a,0x18bac871,0x1c1ae88f)    R(0x035e,0x17cbb87f,0x143b946f,0x156ac05d)    R(0x035f,0x1b1bd09a,0x17cbb87f,0x18bac871)    R(0x0360,0x153c7090,0x143b946f,0x17cbb87f)    R(0x0361,0x1a09f470,0x19a90458,0x1b99288e)    R(0x0362,0x1a09f470,0x16f9d04f,0x19a90458)    R(0x0363,0x1c8c9cc7,0x18bc9ca2,0x1b1bd09a)    R(0x0364,0x158d20ba,0x119cd8af,0x153c7090)    R(0x0365,0x121d8ce5,0x119cd8af,0x158d20ba)\n    R(0x0366,0x18bac871,0x16f9d04f,0x1a09f470)    R(0x0367,0x158d20ba,0x153c7090,0x18bc9ca2)    R(0x0368,0x18bac871,0x156ac05d,0x16f9d04f)    R(0x0369,0x192d4cd4,0x18bc9ca2,0x1c8c9cc7)    R(0x036a,0x192d4cd4,0x158d20ba,0x18bc9ca2)    R(0x036b,0x18bc9ca2,0x17cbb87f,0x1b1bd09a)    R(0x036c,0x156ac05d,0x112b0c5a,0x130a144c)    R(0x036d,0x23f928f3,0x217910cc,0x223834f1)    R(0x036e,0x1c3d7105,0x1c8c9cc7,0x1efce4f8)    R(0x036f,0x2549f900,0x22ca2cd6,0x23f928f3)\n    R(0x0370,0x20ac30e3,0x220b40db,0x23abdd11)    R(0x0371,0x1dd910b6,0x1b99288e,0x1c6848b0)    R(0x0372,0x1ff9d4bc,0x1dd910b6,0x217910cc)    R(0x0373,0x22ca2cd6,0x1ff9d4bc,0x217910cc)    R(0x0374,0x1e7bb4b7,0x1c1ae88f,0x1f5ac0b8)    R(0x0375,0x1c8c9cc7,0x1b1bd09a,0x1e7bb4b7)    R(0x0376,0x20ac30e3,0x1c8c9cc7,0x1e7bb4b7)    R(0x0377,0x220b40db,0x1f5ac0b8,0x22ca2cd6)    R(0x0378,0x1ff9d4bc,0x1cca009e,0x1dd910b6)    R(0x0379,0x1e7bb4b7,0x1f5ac0b8,0x220b40db)\n    R(0x037a,0x1f5ac0b8,0x1cca009e,0x1ff9d4bc)    R(0x037b,0x1f5ac0b8,0x1ff9d4bc,0x22ca2cd6)    R(0x037c,0x1cca009e,0x1b99288e,0x1dd910b6)    R(0x037d,0x1c1ae88f,0x1a09f470,0x1cca009e)    R(0x037e,0x24cae103,0x22ca2cd6,0x2549f900)    R(0x037f,0x23abdd11,0x220b40db,0x24cae103)    R(0x0380,0x1efce4f8,0x1c8c9cc7,0x20ac30e3)    R(0x0381,0x220b40db,0x22ca2cd6,0x24cae103)    R(0x0382,0x22ca2cd6,0x217910cc,0x23f928f3)    R(0x0383,0x1e7bb4b7,0x1b1bd09a,0x1c1ae88f)\n    R(0x0384,0x20ac30e3,0x1e7bb4b7,0x220b40db)    R(0x0385,0x1c1ae88f,0x1cca009e,0x1f5ac0b8)    R(0x0386,0x322605c4,0x3376b58b,0x33d6a1ae)    R(0x0387,0x3ff6c907,0x3f86e8d9,0x3f168514)    R(0x0388,0x1898004d,0x1537f43b,0x16c70c47)    R(0x0389,0x013ab9ff,0x0189ddb2,0x016a91b0)    R(0x038a,0x1f5dce0a,0x1eade5c8,0x220d59ce)    R(0x038b,0x123e95c0,0x12ce6967,0x152e7999)    R(0x038c,0x23776126,0x206750ee,0x21668518)    R(0x038d,0x26995534,0x2549f900,0x23f928f3)\n    R(0x038e,0x262719a3,0x24469160,0x25962dab)    R(0x038f,0x28f995fc,0x28a919ae,0x285895f8)    R(0x0390,0x36e79101,0x3897a4d7,0x36679520)    R(0x0391,0x3f86a539,0x3fd6e8f4,0x3ff6c907)    R(0x0392,0x223834f1,0x206750ee,0x23776126)    R(0x0393,0x35f6313d,0x35c70d2c,0x33e68d65)    R(0x0394,0x2859b971,0x26995534,0x2788a568)    R(0x0395,0x262719a3,0x25962dab,0x2656b9ee)    R(0x0396,0x28a919ae,0x279815aa,0x285895f8)    R(0x0397,0x26995534,0x25385d2a,0x2788a568)\n    R(0x0398,0x33e68d65,0x34f7414a,0x3376b58b)    R(0x0399,0x33e68d65,0x35c70d2c,0x34f7414a)    R(0x039a,0x33d6a1ae,0x34d73969,0x35071d82)    R(0x039b,0x25385d2a,0x223834f1,0x23776126)    R(0x039c,0x2859b971,0x2788a568,0x28a919ae)    R(0x039d,0x3376b58b,0x34f7414a,0x34d73969)    R(0x039e,0x2788a568,0x25d7ad64,0x279815aa)    R(0x039f,0x2788a568,0x25385d2a,0x25d7ad64)    R(0x03a0,0x26995534,0x23f928f3,0x25385d2a)    R(0x03a1,0x25d7ad64,0x24469160,0x262719a3)\n    R(0x03a2,0x33d6a1ae,0x35071d82,0x344671c6)    R(0x03a3,0x344671c6,0x35071d82,0x35c6b18a)    R(0x03a4,0x23776126,0x21668518,0x24469160)    R(0x03a5,0x285895f8,0x279815aa,0x274799f5)    R(0x03a6,0x28a919ae,0x2788a568,0x279815aa)    R(0x03a7,0x279815aa,0x262719a3,0x274799f5)    R(0x03a8,0x279815aa,0x25d7ad64,0x262719a3)    R(0x03a9,0x25385d2a,0x23776126,0x25d7ad64)    R(0x03aa,0x3376b58b,0x34d73969,0x33d6a1ae)    R(0x03ab,0x274799f5,0x262719a3,0x2656b9ee)\n    R(0x03ac,0x23f928f3,0x223834f1,0x25385d2a)    R(0x03ad,0x35c70d2c,0x37c75cec,0x36e79101)    R(0x03ae,0x3f76d51a,0x3fd6e8f4,0x3f86a539)    R(0x03af,0x35f6313d,0x3856b907,0x35c70d2c)    R(0x03b0,0x35c6b18a,0x36f7294d,0x3866516b)    R(0x03b1,0x3856b907,0x37c75cec,0x35c70d2c)    R(0x03b2,0x3e467963,0x3f76d51a,0x3f86a539)    R(0x03b3,0x35c70d2c,0x36e79101,0x34f7414a)    R(0x03b4,0x36679520,0x3837acf3,0x3657853a)    R(0x03b5,0x3d66a541,0x3d2714f9,0x3f76d51a)\n    R(0x03b6,0x38d7750e,0x3d2714f9,0x3a46cd30)    R(0x03b7,0x36f7294d,0x38d7750e,0x3a46cd30)    R(0x03b8,0x3d66a541,0x3f76d51a,0x3e467963)    R(0x03b9,0x3657853a,0x38d7750e,0x36f7294d)    R(0x03ba,0x34f7414a,0x36e79101,0x36679520)    R(0x03bb,0x3a46cd30,0x3d2714f9,0x3d66a541)    R(0x03bc,0x3e467963,0x3f86a539,0x3db63d7b)    R(0x03bd,0x35071d82,0x36f7294d,0x35c6b18a)    R(0x03be,0x25d7ad64,0x23776126,0x24469160)    R(0x03bf,0x3657853a,0x3837acf3,0x38d7750e)\n    R(0x03c0,0x36f7294d,0x3a46cd30,0x3866516b)    R(0x03c1,0x35071d82,0x3657853a,0x36f7294d)    R(0x03c2,0x34d73969,0x3657853a,0x35071d82)    R(0x03c3,0x34f7414a,0x36679520,0x34d73969)    R(0x03c4,0x34d73969,0x36679520,0x3657853a)    R(0x03c5,0x3b763d79,0x3d66a541,0x3e467963)    R(0x03c6,0x130a144c,0x10499045,0x13a9083e)    R(0x03c7,0x14ee85ef,0x123e95c0,0x152e7999)    R(0x03c8,0x28ea8605,0x284b19c4,0x290a25b6)    R(0x03c9,0x3c863917,0x3f168514,0x3e56c8d8)\n    R(0x03ca,0x152e7999,0x12ce6967,0x15be3143)    R(0x03cb,0x15be3143,0x129e1122,0x160db8f7)    R(0x03cc,0x192de91d,0x192d4cd4,0x1c3d7105)    R(0x03cd,0x21fcb125,0x20ac30e3,0x23abdd11)    R(0x03ce,0x220d59ce,0x225d1174,0x24bca1a8)    R(0x03cf,0x14ee85ef,0x152e7999,0x187e6dc8)    R(0x03d0,0x1bce35f8,0x1bbe2da0,0x1eade5c8)    R(0x03d1,0x1f5d653c,0x1efce4f8,0x21fcb125)    R(0x03d2,0x225d1174,0x21fcb125,0x249c4956)    R(0x03d3,0x1c4de94f,0x1c3d7105,0x1f5d653c)\n    R(0x03d4,0x1bbe2da0,0x18ce416e,0x1c4de94f)    R(0x03d5,0x152e7999,0x15be3143,0x18ce416e)    R(0x03d6,0x1f6dad85,0x1c4de94f,0x1f5d653c)    R(0x03d7,0x1c4de94f,0x192de91d,0x1c3d7105)    R(0x03d8,0x18ce416e,0x192de91d,0x1c4de94f)    R(0x03d9,0x1f6dad85,0x1f5d653c,0x225d1174)    R(0x03da,0x18ce416e,0x15be3143,0x192de91d)    R(0x03db,0x225d1174,0x1f5d653c,0x21fcb125)    R(0x03dc,0x21fcb125,0x1efce4f8,0x20ac30e3)    R(0x03dd,0x220d59ce,0x1f6dad85,0x225d1174)\n    R(0x03de,0x1bce35f8,0x187e6dc8,0x1bbe2da0)    R(0x03df,0x187e6dc8,0x152e7999,0x18ce416e)    R(0x03e0,0x1eade5c8,0x1bbe2da0,0x1f6dad85)    R(0x03e1,0x1bbe2da0,0x1c4de94f,0x1f6dad85)    R(0x03e2,0x15be3143,0x160db8f7,0x192de91d)    R(0x03e3,0x1f5d653c,0x1c3d7105,0x1efce4f8)    R(0x03e4,0x187e6dc8,0x18ce416e,0x1bbe2da0)    R(0x03e5,0x1eade5c8,0x1f6dad85,0x220d59ce)    R(0x03e6,0x129e1122,0x121d8ce5,0x160db8f7)    R(0x03e7,0x12ce6967,0x129e1122,0x15be3143)\n    R(0x03e8,0x3b763d79,0x3a46cd30,0x3d66a541)    R(0x03e9,0x28ea8605,0x290a25b6,0x28f995fc)    R(0x03ea,0x263b5943,0x24cae103,0x270a593b)    R(0x03eb,0x21fcb125,0x23abdd11,0x249c4956)    R(0x03ec,0x3866516b,0x3a46cd30,0x3b763d79)    R(0x03ed,0x24cae103,0x2549f900,0x270a593b)    R(0x03ee,0x225d1174,0x249c4956,0x24bca1a8)    R(0x03ef,0x2859b971,0x270a593b,0x26995534)    R(0x03f0,0x263b5943,0x270a593b,0x282ac57b)    R(0x03f1,0x26cbbd8b,0x263b5943,0x282ac57b)\n    R(0x03f2,0x23abdd11,0x24cae103,0x263b5943)    R(0x03f3,0x249c4956,0x263b5943,0x26cbbd8b)    R(0x03f4,0x249c4956,0x23abdd11,0x263b5943)    R(0x03f5,0x282ac57b,0x270a593b,0x2859b971)    R(0x03f6,0x290a25b6,0x28a919ae,0x28f995fc)    R(0x03f7,0x270a593b,0x2549f900,0x26995534)    R(0x03f8,0x24bcc1fd,0x24bca1a8,0x26bc05da)    R(0x03f9,0x220d59ce,0x24bca1a8,0x24bcc1fd)    R(0x03fa,0x284b19c4,0x282ac57b,0x290a25b6)    R(0x03fb,0x26cbbd8b,0x282ac57b,0x284b19c4)\n    R(0x03fc,0x26bc05da,0x26cbbd8b,0x284b19c4)    R(0x03fd,0x24bca1a8,0x26cbbd8b,0x26bc05da)    R(0x03fe,0x24bca1a8,0x249c4956,0x26cbbd8b)    R(0x03ff,0x290a25b6,0x2859b971,0x28a919ae)    R(0x0400,0x290a25b6,0x282ac57b,0x2859b971)    R(0x0401,0x227042e4,0x25502eb0,0x22703e93)    R(0x0402,0x3891180a,0x3c40e017,0x3a113c00)    R(0x0403,0x26b2a7ff,0x2811dfe3,0x25321bf3)    R(0x0404,0x00326df8,0x0002e604,0x0022b243)    R(0x0405,0x0c5f6204,0x0aefa9e5,0x0ddfd1d2)\n    R(0x0406,0x25502eb0,0x29006ac6,0x27e05679)    R(0x0407,0x00039e40,0x0002e604,0x0013bddd)    R(0x0408,0x01b50b80,0x0094bf78,0x00c59f68)    R(0x0409,0x10816a04,0x0f2239c3,0x0d324e07)    R(0x040a,0x25502eb0,0x24d05e54,0x22703e93)    R(0x040b,0x24734ff3,0x26b2a7ff,0x22c2cfef)    R(0x040c,0x36f50a09,0x38e519e8,0x36547e19)    R(0x040d,0x0b033214,0x0c6321cd,0x0a53a9f8)    R(0x040e,0x00e5561e,0x00348604,0x006591e2)    R(0x040f,0x0022b243,0x0002e604,0x00039e40)\n    R(0x0410,0x1fd09a9f,0x2100a255,0x1e20d26c)    R(0x0411,0x1f752336,0x2134a72d,0x1ec43751)    R(0x0412,0x1f232b91,0x206317d6,0x1f125fa8)    R(0x0413,0x1fc0c2e3,0x1fd09a9f,0x1e00e2b4)    R(0x0414,0x1e20d26c,0x2100a255,0x1e710624)    R(0x0415,0x15013f00,0x1730b6be,0x134112b9)    R(0x0416,0x0b033214,0x0d324e07,0x0c6321cd)    R(0x0417,0x00336a7d,0x0022b243,0x00039e40)    R(0x0418,0x0014f2b6,0x00549e59,0x00b58e72)    R(0x0419,0x00925e33,0x00326df8,0x0022b243)\n    R(0x041a,0x05132207,0x042315d0,0x02a281f7)    R(0x041b,0x0d131ef2,0x0ba2e2a3,0x0b03cab8)    R(0x041c,0x1e113af6,0x1e00e2b4,0x1b40dadd)    R(0x041d,0x1e00e2b4,0x1fd09a9f,0x1e20d26c)    R(0x041e,0x1e710624,0x2100a255,0x20f11a1a)    R(0x041f,0x02a281f7,0x00b259f3,0x01725627)    R(0x0420,0x0a538667,0x0ba29a50,0x0b033214)    R(0x0421,0x0092ce67,0x00925e33,0x0022b243)    R(0x0422,0x11612259,0x0e81c645,0x1001869c)    R(0x0423,0x0d131ef2,0x0e4246d3,0x0ba2e2a3)\n    R(0x0424,0x0ba29a50,0x0d324e07,0x0b033214)    R(0x0425,0x0d622687,0x0e81c645,0x0ba29a50)    R(0x0426,0x00b259f3,0x00925e33,0x01725627)    R(0x0427,0x0092ce67,0x0022b243,0x00336a7d)    R(0x0428,0x01725627,0x00925e33,0x01828252)    R(0x0429,0x03629630,0x01725627,0x01828252)    R(0x042a,0x03629630,0x01828252,0x0332ee5a)    R(0x042b,0x05132207,0x02a281f7,0x03629630)    R(0x042c,0x05234a37,0x03629630,0x0332ee5a)    R(0x042d,0x0ba29a50,0x0e81c645,0x0d324e07)\n    R(0x042e,0x05132207,0x03629630,0x05234a37)    R(0x042f,0x1151b2ed,0x1001869c,0x0e4246d3)    R(0x0430,0x0e81c645,0x10816a04,0x0d324e07)    R(0x0431,0x02a281f7,0x01725627,0x03629630)    R(0x0432,0x01533e81,0x01828252,0x0092ce67)    R(0x0433,0x0ba2e2a3,0x0ba29a50,0x0a538667)    R(0x0434,0x1001869c,0x0e81c645,0x0d622687)    R(0x0435,0x0ba2e2a3,0x0d622687,0x0ba29a50)    R(0x0436,0x0e4246d3,0x1001869c,0x0d622687)    R(0x0437,0x0332ee5a,0x01828252,0x01533e81)\n    R(0x0438,0x0e4246d3,0x0d622687,0x0ba2e2a3)    R(0x0439,0x1420da28,0x14611ddf,0x10816a04)    R(0x043a,0x00b259f3,0x00326df8,0x00925e33)    R(0x043b,0x1f5185e3,0x1e710624,0x20f11a1a)    R(0x043c,0x17709e5f,0x17a0c60b,0x1420da28)    R(0x043d,0x01533e81,0x0092ce67,0x00839a97)    R(0x043e,0x1e113af6,0x1fc0c2e3,0x1e00e2b4)    R(0x043f,0x1aa0a294,0x1b00b63d,0x17709e5f)    R(0x0440,0x1e710624,0x1b00b63d,0x1e20d26c)    R(0x0441,0x17a0c60b,0x14611ddf,0x1420da28)\n    R(0x0442,0x01828252,0x00925e33,0x0092ce67)    R(0x0443,0x1b00b63d,0x17a0c60b,0x17709e5f)    R(0x0444,0x1e20d26c,0x1b00b63d,0x1aa0a294)    R(0x0445,0x14b0c27a,0x1420da28,0x11612259)    R(0x0446,0x11612259,0x1420da28,0x10816a04)    R(0x0447,0x11612259,0x10816a04,0x0e81c645)    R(0x0448,0x17709e5f,0x1420da28,0x14b0c27a)    R(0x0449,0x1aa0a294,0x17709e5f,0x1730b6be)    R(0x044a,0x1b6109ee,0x17a0c60b,0x1b00b63d)    R(0x044b,0x1b6109ee,0x1b00b63d,0x1e710624)\n    R(0x044c,0x134112b9,0x11612259,0x1001869c)    R(0x044d,0x134112b9,0x1001869c,0x1151b2ed)    R(0x044e,0x1730b6be,0x14b0c27a,0x134112b9)    R(0x044f,0x1e00e2b4,0x1e20d26c,0x1aa0a294)    R(0x0450,0x134112b9,0x14b0c27a,0x11612259)    R(0x0451,0x1e00e2b4,0x1aa0a294,0x1b40dadd)    R(0x0452,0x1730b6be,0x17709e5f,0x14b0c27a)    R(0x0453,0x00141296,0x00039e40,0x00549e59)    R(0x0454,0x00549e59,0x00348604,0x00e5561e)    R(0x0455,0x0893bde6,0x0653a5dc,0x06d3ba13)\n    R(0x0456,0x09e4daca,0x07c4dab4,0x087522f3)    R(0x0457,0x1b40dadd,0x1aa0a294,0x1730b6be)    R(0x0458,0x00549e59,0x00039e40,0x00348604)    R(0x0459,0x06d3ba13,0x05132207,0x05234a37)    R(0x045a,0x07444245,0x0593fa4c,0x04f48a76)    R(0x045b,0x00839a97,0x0092ce67,0x00336a7d)    R(0x045c,0x001422f0,0x00141296,0x0014f2b6)    R(0x045d,0x05234a37,0x0332ee5a,0x0323be7f)    R(0x045e,0x07444245,0x04f48a76,0x0704ce6f)    R(0x045f,0x0323be7f,0x0332ee5a,0x01533e81)\n    R(0x0460,0x00839a97,0x00336a7d,0x0043c6bc)    R(0x0461,0x0593fa4c,0x05234a37,0x0323be7f)    R(0x0462,0x0704ce6f,0x04f48a76,0x0594baa1)    R(0x0463,0x0323be7f,0x01533e81,0x0143caa0)    R(0x0464,0x0304269f,0x0323be7f,0x0143caa0)    R(0x0465,0x0593fa4c,0x0323be7f,0x04f48a76)    R(0x0466,0x04f48a76,0x0323be7f,0x0304269f)    R(0x0467,0x0594baa1,0x04f48a76,0x0304269f)    R(0x0468,0x0143caa0,0x01533e81,0x00839a97)    R(0x0469,0x06d3ba13,0x05234a37,0x0593fa4c)\n    R(0x046a,0x00b3c2b0,0x00839a97,0x0043c6bc)    R(0x046b,0x00b3c2b0,0x0043c6bc,0x00c39eec)    R(0x046c,0x0694e2e7,0x0594baa1,0x04843eda)    R(0x046d,0x0213cacd,0x00b3c2b0,0x00c39eec)    R(0x046e,0x0143caa0,0x00b3c2b0,0x0213cacd)    R(0x046f,0x0304269f,0x0143caa0,0x0213cacd)    R(0x0470,0x04843eda,0x0304269f,0x0213cacd)    R(0x0471,0x0594baa1,0x0304269f,0x04843eda)    R(0x0472,0x0143caa0,0x00839a97,0x00b3c2b0)    R(0x0473,0x0a53a9f8,0x0893bde6,0x08c3de1b)\n    R(0x0474,0x0014f2b6,0x00141296,0x00549e59)    R(0x0475,0x0b03cab8,0x0ba2e2a3,0x0a538667)    R(0x0476,0x0043c6bc,0x00141296,0x001422f0)    R(0x0477,0x08c3de1b,0x06d3ba13,0x07444245)    R(0x0478,0x09d3ea36,0x08c3de1b,0x08d46a4f)    R(0x0479,0x0a538667,0x0b033214,0x09d3ea36)    R(0x047a,0x08c3de1b,0x0893bde6,0x06d3ba13)    R(0x047b,0x0b03cab8,0x0a538667,0x09b46e81)    R(0x047c,0x07444245,0x06d3ba13,0x0593fa4c)    R(0x047d,0x08d46a4f,0x07444245,0x0704ce6f)\n    R(0x047e,0x08d46a4f,0x08c3de1b,0x07444245)    R(0x047f,0x09b46e81,0x09d3ea36,0x08d46a4f)    R(0x0480,0x0a538667,0x09d3ea36,0x09b46e81)    R(0x0481,0x09b46e81,0x08d46a4f,0x08d4c686)    R(0x0482,0x08d46a4f,0x0704ce6f,0x08d4c686)    R(0x0483,0x0b033214,0x0a53a9f8,0x09d3ea36)    R(0x0484,0x0043c6bc,0x00336a7d,0x00141296)    R(0x0485,0x0b03cab8,0x09b46e81,0x0b24a2d5)    R(0x0486,0x07c4dab4,0x0594baa1,0x0694e2e7)    R(0x0487,0x0b24a2d5,0x09b46e81,0x09e4daca)\n    R(0x0488,0x09b46e81,0x08d4c686,0x09e4daca)    R(0x0489,0x07c4dab4,0x0704ce6f,0x0594baa1)    R(0x048a,0x08d4c686,0x0704ce6f,0x07c4dab4)    R(0x048b,0x09d3ea36,0x0a53a9f8,0x08c3de1b)    R(0x048c,0x09e4daca,0x08d4c686,0x07c4dab4)    R(0x048d,0x1b40dadd,0x1730b6be,0x18310304)    R(0x048e,0x206317d6,0x20a22bd2,0x1f125fa8)    R(0x048f,0x06d3ba13,0x0653a5dc,0x05132207)    R(0x0490,0x0043c317,0x0043c6bc,0x001422f0)    R(0x0491,0x2134a72d,0x2013ef50,0x1ec43751)\n    R(0x0492,0x1bb4bf69,0x18348b83,0x18a58f66)    R(0x0493,0x00c39eec,0x0043c317,0x00c3bb32)    R(0x0494,0x0ca41308,0x0d131ef2,0x0b03cab8)    R(0x0495,0x17d39385,0x14b33f7c,0x14e42b85)    R(0x0496,0x18310304,0x1730b6be,0x15013f00)    R(0x0497,0x1f125fa8,0x20a22bd2,0x202177b1)    R(0x0498,0x20a3a7bb,0x206317d6,0x1f232b91)    R(0x0499,0x15013f00,0x134112b9,0x1151b2ed)    R(0x049a,0x0213cacd,0x00c39eec,0x01d3ab12)    R(0x049b,0x1b415f1e,0x1b40dadd,0x18310304)\n    R(0x049c,0x11a3db6b,0x11c2df56,0x0ee36f39)    R(0x049d,0x1b22fb6e,0x17c29f70,0x17d39385)    R(0x049e,0x1b83db75,0x1b22fb6e,0x17d39385)    R(0x049f,0x1741b33b,0x18310304,0x15013f00)    R(0x04a0,0x1b415f1e,0x18310304,0x1741b33b)    R(0x04a1,0x1741b33b,0x1311e730,0x14b25b5d)    R(0x04a2,0x1311e730,0x1151b2ed,0x0fd27f1d)    R(0x04a3,0x11c2df56,0x0fd27f1d,0x0ee36f39)    R(0x04a4,0x0ee36f39,0x0fd27f1d,0x0d131ef2)    R(0x04a5,0x14b25b5d,0x1311e730,0x11c2df56)\n    R(0x04a6,0x11c2df56,0x1311e730,0x0fd27f1d)    R(0x04a7,0x1741b33b,0x15013f00,0x1311e730)    R(0x04a8,0x1b02234f,0x1b415f1e,0x1741b33b)    R(0x04a9,0x15013f00,0x1151b2ed,0x1311e730)    R(0x04aa,0x0fd27f1d,0x1151b2ed,0x0e4246d3)    R(0x04ab,0x1b22fb6e,0x1b02234f,0x17c29f70)    R(0x04ac,0x17d39385,0x17c29f70,0x14b33f7c)    R(0x04ad,0x14b33f7c,0x11c2df56,0x11a3db6b)    R(0x04ae,0x01d3ab12,0x00c39eec,0x00c3bb32)    R(0x04af,0x14b33f7c,0x14b25b5d,0x11c2df56)\n    R(0x04b0,0x17c29f70,0x1741b33b,0x14b25b5d)    R(0x04b1,0x1b02234f,0x1741b33b,0x17c29f70)    R(0x04b2,0x17c29f70,0x14b25b5d,0x14b33f7c)    R(0x04b3,0x0fd27f1d,0x0e4246d3,0x0d131ef2)    R(0x04b4,0x0ee36f39,0x0d131ef2,0x0ca41308)    R(0x04b5,0x1ef1df71,0x20312b69,0x1f716726)    R(0x04b6,0x2083cf71,0x20a3a7bb,0x1f232b91)    R(0x04b7,0x1db1d731,0x1b415f1e,0x1b02234f)    R(0x04b8,0x1e422b4d,0x1f716726,0x1db1d731)    R(0x04b9,0x1db1d731,0x1e113af6,0x1b415f1e)\n    R(0x04ba,0x1e422b4d,0x1ef1df71,0x1f716726)    R(0x04bb,0x1d72a760,0x1db1d731,0x1b02234f)    R(0x04bc,0x2013ef50,0x1eb33b64,0x1e035f60)    R(0x04bd,0x2013ef50,0x2083cf71,0x1eb33b64)    R(0x04be,0x1d72a760,0x1b02234f,0x1b22fb6e)    R(0x04bf,0x1e035f60,0x1d72a760,0x1b22fb6e)    R(0x04c0,0x1e035f60,0x1eb33b64,0x1d72a760)    R(0x04c1,0x1d72a760,0x1e422b4d,0x1db1d731)    R(0x04c2,0x1d72a760,0x1e52a770,0x1e422b4d)    R(0x04c3,0x1db1d731,0x1f716726,0x1e113af6)\n    R(0x04c4,0x1ef1df71,0x202177b1,0x20312b69)    R(0x04c5,0x1e035f60,0x1b22fb6e,0x1b83db75)    R(0x04c6,0x2083cf71,0x1f232b91,0x1eb33b64)    R(0x04c7,0x1e52a770,0x1f125fa8,0x1ef1df71)    R(0x04c8,0x1f232b91,0x1f125fa8,0x1e52a770)    R(0x04c9,0x1eb33b64,0x1e52a770,0x1d72a760)    R(0x04ca,0x1eb33b64,0x1f232b91,0x1e52a770)    R(0x04cb,0x1f125fa8,0x202177b1,0x1ef1df71)    R(0x04cc,0x1e52a770,0x1ef1df71,0x1e422b4d)    R(0x04cd,0x00244b48,0x001422f0,0x00350311)\n    R(0x04ce,0x14e42b85,0x11a3db6b,0x11e4e76a)    R(0x04cf,0x18a58f66,0x18348b83,0x15351b77)    R(0x04d0,0x1f5185e3,0x1b6109ee,0x1e710624)    R(0x04d1,0x1ec43751,0x2013ef50,0x1e035f60)    R(0x04d2,0x1f716726,0x1fc0c2e3,0x1e113af6)    R(0x04d3,0x087522f3,0x07c4dab4,0x0694e2e7)    R(0x04d4,0x0ae53701,0x09e4daca,0x087522f3)    R(0x04d5,0x00c39eec,0x0043c6bc,0x0043c317)    R(0x04d6,0x0574f745,0x0364c374,0x03e56764)    R(0x04d7,0x03e56764,0x0364c374,0x01b50b80)\n    R(0x04d8,0x087522f3,0x0694e2e7,0x06d54312)    R(0x04d9,0x01d3ab12,0x00c3bb32,0x0213f74e)    R(0x04da,0x03e3eb1c,0x0213cacd,0x01d3ab12)    R(0x04db,0x00c3bb32,0x0043c317,0x00841b5b)    R(0x04dc,0x06d54312,0x0694e2e7,0x05a4931b)    R(0x04dd,0x03e3eb1c,0x0213f74e,0x04344f53)    R(0x04de,0x05a4931b,0x04843eda,0x03e3eb1c)    R(0x04df,0x05a4931b,0x03e3eb1c,0x04344f53)    R(0x04e0,0x05a4931b,0x04344f53,0x0574f745)    R(0x04e1,0x03e3eb1c,0x01d3ab12,0x0213f74e)\n    R(0x04e2,0x06d54312,0x05a4931b,0x0574f745)    R(0x04e3,0x0213f74e,0x00c3bb32,0x00841b5b)    R(0x04e4,0x04843eda,0x0213cacd,0x03e3eb1c)    R(0x04e5,0x0694e2e7,0x04843eda,0x05a4931b)    R(0x04e6,0x01b50b80,0x01846f73,0x0094bf78)    R(0x04e7,0x01846f73,0x00841b5b,0x0094bf78)    R(0x04e8,0x04344f53,0x01846f73,0x0364c374)    R(0x04e9,0x0213f74e,0x00841b5b,0x01846f73)    R(0x04ea,0x0574f745,0x04344f53,0x0364c374)    R(0x04eb,0x04344f53,0x0213f74e,0x01846f73)\n    R(0x04ec,0x0364c374,0x01846f73,0x01b50b80)    R(0x04ed,0x0ca41308,0x0b03cab8,0x0b24a2d5)    R(0x04ee,0x1e113af6,0x1b40dadd,0x1b415f1e)    R(0x04ef,0x00244b48,0x0043c317,0x001422f0)    R(0x04f0,0x1f752336,0x1ec43751,0x1bb4bf69)    R(0x04f1,0x1f752336,0x1bb4bf69,0x1c458f51)    R(0x04f2,0x15351b77,0x14e42b85,0x11e4e76a)    R(0x04f3,0x11a3db6b,0x0ee36f39,0x0ef46b46)    R(0x04f4,0x00841b5b,0x0043c317,0x00244b48)    R(0x04f5,0x0094bf78,0x00841b5b,0x00244b48)\n    R(0x04f6,0x0b24a2d5,0x09e4daca,0x0ae53701)    R(0x04f7,0x11e4e76a,0x0ef46b46,0x0f456b40)    R(0x04f8,0x0ca41308,0x0b24a2d5,0x0cc4ff16)    R(0x04f9,0x00451b60,0x00244b48,0x00350311)    R(0x04fa,0x0ef46b46,0x0ee36f39,0x0ca41308)    R(0x04fb,0x0ef46b46,0x0ca41308,0x0cc4ff16)    R(0x04fc,0x0ef46b46,0x0cc4ff16,0x0f456b40)    R(0x04fd,0x14e42b85,0x14b33f7c,0x11a3db6b)    R(0x04fe,0x1ec43751,0x1e035f60,0x1b83db75)    R(0x04ff,0x0094bf78,0x00244b48,0x00451b60)\n    R(0x0500,0x0cc4ff16,0x0b24a2d5,0x0ae53701)    R(0x0501,0x1ec43751,0x1b83db75,0x1bb4bf69)    R(0x0502,0x1bb4bf69,0x1b83db75,0x18348b83)    R(0x0503,0x11e4e76a,0x11a3db6b,0x0ef46b46)    R(0x0504,0x18348b83,0x14e42b85,0x15351b77)    R(0x0505,0x1b83db75,0x17d39385,0x18348b83)    R(0x0506,0x18348b83,0x17d39385,0x14e42b85)    R(0x0507,0x2f72b1d1,0x30e29df2,0x2ff2ea02)    R(0x0508,0x36547e19,0x38e519e8,0x37b475f0)    R(0x0509,0x00039e40,0x0013bddd,0x00348604)\n    R(0x050a,0x2745664e,0x2794f60b,0x2904e657)    R(0x050b,0x25703efa,0x29006ac6,0x25502eb0)    R(0x050c,0x27e327e7,0x29a27be7,0x26b2a7ff)    R(0x050d,0x227042e4,0x22703e93,0x1fd09a9f)    R(0x050e,0x31816acc,0x3060caaa,0x3030d2f9)    R(0x050f,0x32017e1f,0x340149d3,0x32512de1)    R(0x0510,0x00336a7d,0x00039e40,0x00141296)    R(0x0511,0x34e3e627,0x37b475f0,0x35a3e9f7)    R(0x0512,0x2ec499e7,0x305555d3,0x2e94be0b)    R(0x0513,0x1f5185e3,0x20f11a1a,0x22f179ec)\n    R(0x0514,0x22703e93,0x24d05e54,0x2100a255)    R(0x0515,0x2e1361f6,0x30533606,0x2f73bdeb)    R(0x0516,0x32122e98,0x31816acc,0x32026aee)    R(0x0517,0x33c1b5f2,0x340149d3,0x32017e1f)    R(0x0518,0x2100a255,0x24d05e54,0x2460ba1d)    R(0x0519,0x2da2d5e2,0x2ff2ea02,0x2e1361f6)    R(0x051a,0x2d9169f0,0x30214215,0x2ff139d6)    R(0x051b,0x2ff2ea02,0x30e29df2,0x3182921f)    R(0x051c,0x20f11a1a,0x2100a255,0x2460ba1d)    R(0x051d,0x2870b630,0x27e05679,0x2b20a272)\n    R(0x051e,0x2ea0ae89,0x2ef072dd,0x3060caaa)    R(0x051f,0x2460ba1d,0x24d05e54,0x2870b630)    R(0x0520,0x29c1e5dc,0x271139f7,0x2b114e01)    R(0x0521,0x2ff2ea02,0x3172fe23,0x30533606)    R(0x0522,0x271139f7,0x2870b630,0x2b114e01)    R(0x0523,0x2d510633,0x30411a53,0x30214215)    R(0x0524,0x2d510633,0x30214215,0x2d9169f0)    R(0x0525,0x2b114e01,0x2d510633,0x2d9169f0)    R(0x0526,0x271139f7,0x2460ba1d,0x2870b630)    R(0x0527,0x2b114e01,0x2d9169f0,0x2c11d9de)\n    R(0x0528,0x2b114e01,0x2870b630,0x2d510633)    R(0x0529,0x27e05679,0x29006ac6,0x2b20a272)    R(0x052a,0x2ea0ae89,0x2ca07ebe,0x2ef072dd)    R(0x052b,0x30411a53,0x3060caaa,0x3171766d)    R(0x052c,0x22f179ec,0x2460ba1d,0x271139f7)    R(0x052d,0x2e1361f6,0x2ff2ea02,0x30533606)    R(0x052e,0x2ea0ae89,0x3060caaa,0x30411a53)    R(0x052f,0x2d510633,0x2ea0ae89,0x30411a53)    R(0x0530,0x2b20a272,0x2ca07ebe,0x2ea0ae89)    R(0x0531,0x2d510633,0x2b20a272,0x2ea0ae89)\n    R(0x0532,0x2870b630,0x2b20a272,0x2d510633)    R(0x0533,0x30214215,0x32512de1,0x2ff139d6)    R(0x0534,0x30533606,0x3293660d,0x31739ded)    R(0x0535,0x32c229f9,0x33c1b5f2,0x3241f638)    R(0x0536,0x32333ead,0x32122e98,0x32026aee)    R(0x0537,0x1fc0c2e3,0x227042e4,0x1fd09a9f)    R(0x0538,0x22f179ec,0x20f11a1a,0x2460ba1d)    R(0x0539,0x30214215,0x30411a53,0x32017e1f)    R(0x053a,0x3241f638,0x32017e1f,0x3171766d)    R(0x053b,0x3241f638,0x33c1b5f2,0x32017e1f)\n    R(0x053c,0x2ff2ea02,0x3182921f,0x3172fe23)    R(0x053d,0x30533606,0x3172fe23,0x3293660d)    R(0x053e,0x3182921f,0x3202d25a,0x3172fe23)    R(0x053f,0x3182921f,0x32c229f9,0x3241f638)    R(0x0540,0x3202d25a,0x32f35e31,0x3172fe23)    R(0x0541,0x3182921f,0x3241f638,0x3202d25a)    R(0x0542,0x3172fe23,0x32f35e31,0x3293660d)    R(0x0543,0x3171766d,0x3060caaa,0x31816acc)    R(0x0544,0x32017e1f,0x32512de1,0x30214215)    R(0x0545,0x3293865b,0x3202d25a,0x32333ead)\n    R(0x0546,0x3293865b,0x32f35e31,0x3202d25a)    R(0x0547,0x3241f638,0x3171766d,0x32122e98)    R(0x0548,0x3202d25a,0x3241f638,0x32122e98)    R(0x0549,0x30e29df2,0x32c229f9,0x3182921f)    R(0x054a,0x3202d25a,0x32122e98,0x32333ead)    R(0x054b,0x32017e1f,0x30411a53,0x3171766d)    R(0x054c,0x32122e98,0x3171766d,0x31816acc)    R(0x054d,0x1fd09a9f,0x22703e93,0x2100a255)    R(0x054e,0x2a44c6ba,0x2e246eaa,0x2ca476f2)    R(0x054f,0x2e94be0b,0x305555d3,0x30b551fa)\n    R(0x0550,0x36547e19,0x37b475f0,0x34e3e627)    R(0x0551,0x2794f60b,0x28d48e11,0x2904e657)    R(0x0552,0x27344dd7,0x297405eb,0x28d48e11)    R(0x0553,0x297405eb,0x2b0331db,0x2c43f5fd)    R(0x0554,0x2e94be0b,0x30b551fa,0x2f14ba2f)    R(0x0555,0x2870b630,0x24d05e54,0x27e05679)    R(0x0556,0x2f447663,0x30d43e93,0x2e246eaa)    R(0x0557,0x2e246eaa,0x30d43e93,0x306456e2)    R(0x0558,0x2c43f5fd,0x2df409f5,0x2d444e0e)    R(0x0559,0x2e1361f6,0x2f73bdeb,0x2df409f5)\n    R(0x055a,0x28d48e11,0x297405eb,0x2b545e22)    R(0x055b,0x2b545e22,0x2d547236,0x2bd49669)    R(0x055c,0x28d48e11,0x2b545e22,0x2904e657)    R(0x055d,0x2b545e22,0x2d444e0e,0x2d547236)    R(0x055e,0x2b545e22,0x2c43f5fd,0x2d444e0e)    R(0x055f,0x2d444e0e,0x2e94be0b,0x2d547236)    R(0x0560,0x2d547236,0x2f14ba2f,0x2f447663)    R(0x0561,0x297405eb,0x2c43f5fd,0x2b545e22)    R(0x0562,0x2d547236,0x2e94be0b,0x2f14ba2f)    R(0x0563,0x29006ac6,0x2ca07ebe,0x2b20a272)\n    R(0x0564,0x2d444e0e,0x2df409f5,0x2ec499e7)    R(0x0565,0x2bd49669,0x2f447663,0x2e246eaa)    R(0x0566,0x2904e657,0x2a44c6ba,0x27653695)    R(0x0567,0x2d547236,0x2f447663,0x2bd49669)    R(0x0568,0x2d444e0e,0x2ec499e7,0x2e94be0b)    R(0x0569,0x2bd49669,0x2e246eaa,0x2a44c6ba)    R(0x056a,0x2904e657,0x2b545e22,0x2bd49669)    R(0x056b,0x2904e657,0x2bd49669,0x2a44c6ba)    R(0x056c,0x2c43f5fd,0x2e1361f6,0x2df409f5)    R(0x056d,0x35a3e9f7,0x3433edd4,0x3293660d)\n    R(0x056e,0x30533606,0x31739ded,0x2f73bdeb)    R(0x056f,0x33951217,0x36f50a09,0x34348a37)    R(0x0570,0x2f14ba2f,0x30b551fa,0x3134ea2f)    R(0x0571,0x27653695,0x2a44c6ba,0x270516eb)    R(0x0572,0x2794f60b,0x27344dd7,0x28d48e11)    R(0x0573,0x32f35e31,0x35a3e9f7,0x3293660d)    R(0x0574,0x31b45a5d,0x33951217,0x34348a37)    R(0x0575,0x34348a37,0x36f50a09,0x36547e19)    R(0x0576,0x2f14ba2f,0x3134ea2f,0x2f447663)    R(0x0577,0x31b45a5d,0x34348a37,0x33740a4e)\n    R(0x0578,0x34348a37,0x36547e19,0x33740a4e)    R(0x0579,0x34e3e627,0x32f35e31,0x3293865b)    R(0x057a,0x33740a4e,0x34e3e627,0x3293865b)    R(0x057b,0x33740a4e,0x36547e19,0x34e3e627)    R(0x057c,0x3134ea2f,0x33951217,0x31b45a5d)    R(0x057d,0x31f3ea7e,0x3293865b,0x32333ead)    R(0x057e,0x34e3e627,0x35a3e9f7,0x32f35e31)    R(0x057f,0x30d43e93,0x31a3fed0,0x306456e2)    R(0x0580,0x2f447663,0x31b45a5d,0x30d43e93)    R(0x0581,0x2f447663,0x3134ea2f,0x31b45a5d)\n    R(0x0582,0x31b45a5d,0x33740a4e,0x31f3ea7e)    R(0x0583,0x31b45a5d,0x31f3ea7e,0x30d43e93)    R(0x0584,0x31f3ea7e,0x32333ead,0x31a3fed0)    R(0x0585,0x33740a4e,0x3293865b,0x31f3ea7e)    R(0x0586,0x30d43e93,0x31f3ea7e,0x31a3fed0)    R(0x0587,0x25703efa,0x25502eb0,0x227042e4)    R(0x0588,0x22c2cfef,0x26b2a7ff,0x25321bf3)    R(0x0589,0x3293660d,0x3433edd4,0x31739ded)    R(0x058a,0x00350311,0x001422f0,0x0014f2b6)    R(0x058b,0x24c54ecc,0x270516eb,0x23d50710)\n    R(0x058c,0x2ef072dd,0x2ca07ebe,0x2bd08700)    R(0x058d,0x1f716726,0x21b0af2a,0x1fc0c2e3)    R(0x058e,0x22c2cfef,0x25321bf3,0x2261b3df)    R(0x058f,0x24208f3f,0x25703efa,0x227042e4)    R(0x0590,0x3060caaa,0x2ef072dd,0x3030d2f9)    R(0x0591,0x30636f50,0x30f28f42,0x2f02c386)    R(0x0592,0x30f28f42,0x32026aee,0x3101ab1f)    R(0x0593,0x28509316,0x2bd08700,0x29006ac6)    R(0x0594,0x21b0af2a,0x227042e4,0x1fc0c2e3)    R(0x0595,0x20312b69,0x21b0af2a,0x1f716726)\n    R(0x0596,0x27e327e7,0x2bd2e7c4,0x29a27be7)    R(0x0597,0x25321bf3,0x25115bd0,0x2261b3df)    R(0x0598,0x21b0af2a,0x24208f3f,0x227042e4)    R(0x0599,0x21f0db80,0x24208f3f,0x21b0af2a)    R(0x059a,0x2740db62,0x2af0ef4f,0x28509316)    R(0x059b,0x202177b1,0x22211fbd,0x21f0db80)    R(0x059c,0x25115bd0,0x28c13fa5,0x2490e79a)    R(0x059d,0x22211fbd,0x2490e79a,0x21f0db80)    R(0x059e,0x2490e79a,0x28c13fa5,0x2740db62)    R(0x059f,0x28c13fa5,0x2af0ef4f,0x2740db62)\n    R(0x05a0,0x21f0db80,0x2490e79a,0x24208f3f)    R(0x05a1,0x202177b1,0x21f0db80,0x20312b69)    R(0x05a2,0x2490e79a,0x2740db62,0x24208f3f)    R(0x05a3,0x28509316,0x2af0ef4f,0x2bd08700)    R(0x05a4,0x2261b3df,0x22211fbd,0x202177b1)    R(0x05a5,0x25321bf3,0x2811dfe3,0x25115bd0)    R(0x05a6,0x22c2cfef,0x2261b3df,0x20a22bd2)    R(0x05a7,0x24208f3f,0x2740db62,0x28509316)    R(0x05a8,0x2811dfe3,0x28c13fa5,0x25115bd0)    R(0x05a9,0x2b41b7b6,0x28c13fa5,0x2811dfe3)\n    R(0x05aa,0x25115bd0,0x2490e79a,0x22211fbd)    R(0x05ab,0x29a27be7,0x2b41b7b6,0x2811dfe3)    R(0x05ac,0x2261b3df,0x25115bd0,0x22211fbd)    R(0x05ad,0x32026aee,0x31816acc,0x3101ab1f)    R(0x05ae,0x3030d2f9,0x2ef072dd,0x2e20ab26)    R(0x05af,0x31c35f09,0x32026aee,0x30f28f42)    R(0x05b0,0x20a22bd2,0x2261b3df,0x202177b1)    R(0x05b1,0x22c2cfef,0x20a22bd2,0x206317d6)    R(0x05b2,0x3101ab1f,0x3030d2f9,0x2f412b41)    R(0x05b3,0x2af0ef4f,0x2e20ab26,0x2bd08700)\n    R(0x05b4,0x3030d2f9,0x2e20ab26,0x2f412b41)    R(0x05b5,0x20312b69,0x21f0db80,0x21b0af2a)    R(0x05b6,0x2cc1437a,0x2af0ef4f,0x28c13fa5)    R(0x05b7,0x3101ab1f,0x2f412b41,0x2f01df74)    R(0x05b8,0x30f28f42,0x2f01df74,0x2f02c386)    R(0x05b9,0x2f01df74,0x2f412b41,0x2cc1437a)    R(0x05ba,0x2f412b41,0x2e20ab26,0x2cc1437a)    R(0x05bb,0x30f28f42,0x3101ab1f,0x2f01df74)    R(0x05bc,0x2cc1437a,0x2e20ab26,0x2af0ef4f)    R(0x05bd,0x2e20ab26,0x2ef072dd,0x2bd08700)\n    R(0x05be,0x31816acc,0x3030d2f9,0x3101ab1f)    R(0x05bf,0x2b41b7b6,0x2cc1437a,0x28c13fa5)    R(0x05c0,0x29a27be7,0x2cd24bb3,0x2b41b7b6)    R(0x05c1,0x2dd35b8d,0x2f02c386,0x2bd2e7c4)    R(0x05c2,0x2f01df74,0x2cc1437a,0x2b41b7b6)    R(0x05c3,0x2f02c386,0x2f01df74,0x2cd24bb3)    R(0x05c4,0x2bd2e7c4,0x2cd24bb3,0x29a27be7)    R(0x05c5,0x2f02c386,0x2cd24bb3,0x2bd2e7c4)    R(0x05c6,0x2cd24bb3,0x2f01df74,0x2b41b7b6)    R(0x05c7,0x22453303,0x2134a72d,0x1f752336)\n    R(0x05c8,0x24208f3f,0x28509316,0x25703efa)    R(0x05c9,0x27e327e7,0x26b2a7ff,0x24734ff3)    R(0x05ca,0x2b0331db,0x2e1361f6,0x2c43f5fd)    R(0x05cb,0x31a3fed0,0x32333ead,0x31c35f09)    R(0x05cc,0x228403a7,0x22239be3,0x20a3a7bb)    R(0x05cd,0x270516eb,0x2a44c6ba,0x29849315)    R(0x05ce,0x28509316,0x29006ac6,0x25703efa)    R(0x05cf,0x22453303,0x23d50710,0x2134a72d)    R(0x05d0,0x22e47355,0x2083cf71,0x2013ef50)    R(0x05d1,0x2884175a,0x2b33b37e,0x2783b7ab)\n    R(0x05d2,0x2483cbd6,0x24734ff3,0x22239be3)    R(0x05d3,0x2b33b37e,0x2a935fba,0x2783b7ab)    R(0x05d4,0x22e47355,0x228403a7,0x2083cf71)    R(0x05d5,0x270516eb,0x29849315,0x2604ab43)    R(0x05d6,0x22e47355,0x24f42789,0x228403a7)    R(0x05d7,0x2604ab43,0x2884175a,0x24f42789)    R(0x05d8,0x2604ab43,0x24f42789,0x22e47355)    R(0x05d9,0x29849315,0x2884175a,0x2604ab43)    R(0x05da,0x23d50710,0x2604ab43,0x22e47355)    R(0x05db,0x2884175a,0x2783b7ab,0x24f42789)\n    R(0x05dc,0x270516eb,0x2604ab43,0x23d50710)    R(0x05dd,0x22239be3,0x22c2cfef,0x206317d6)    R(0x05de,0x22239be3,0x24734ff3,0x22c2cfef)    R(0x05df,0x2783b7ab,0x2a935fba,0x27e327e7)    R(0x05e0,0x23d50710,0x22e47355,0x2134a72d)    R(0x05e1,0x22239be3,0x206317d6,0x20a3a7bb)    R(0x05e2,0x2783b7ab,0x27e327e7,0x2483cbd6)    R(0x05e3,0x228403a7,0x2483cbd6,0x22239be3)    R(0x05e4,0x24f42789,0x2783b7ab,0x2483cbd6)    R(0x05e5,0x24f42789,0x2483cbd6,0x228403a7)\n    R(0x05e6,0x2483cbd6,0x27e327e7,0x24734ff3)    R(0x05e7,0x2e246eaa,0x306456e2,0x2ca476f2)    R(0x05e8,0x2bd08700,0x2ca07ebe,0x29006ac6)    R(0x05e9,0x32333ead,0x32026aee,0x31c35f09)    R(0x05ea,0x2a44c6ba,0x2ca476f2,0x29849315)    R(0x05eb,0x2134a72d,0x22e47355,0x2013ef50)    R(0x05ec,0x2a935fba,0x2bd2e7c4,0x27e327e7)    R(0x05ed,0x30636f50,0x31c35f09,0x30f28f42)    R(0x05ee,0x31a3fed0,0x31c35f09,0x30e40f1c)    R(0x05ef,0x29849315,0x2c140f3b,0x2884175a)\n    R(0x05f0,0x30e40f1c,0x31c35f09,0x30636f50)    R(0x05f1,0x2f443f1f,0x30e40f1c,0x2ee3df56)    R(0x05f2,0x2c140f3b,0x2f443f1f,0x2ee3df56)    R(0x05f3,0x306456e2,0x30e40f1c,0x2f443f1f)    R(0x05f4,0x2ee3df56,0x30e40f1c,0x30636f50)    R(0x05f5,0x2ca476f2,0x2f443f1f,0x2c140f3b)    R(0x05f6,0x29849315,0x2ca476f2,0x2c140f3b)    R(0x05f7,0x30636f50,0x2f02c386,0x2dd35b8d)    R(0x05f8,0x2dd35b8d,0x2bd2e7c4,0x2a935fba)    R(0x05f9,0x228403a7,0x20a3a7bb,0x2083cf71)\n    R(0x05fa,0x306456e2,0x31a3fed0,0x30e40f1c)    R(0x05fb,0x2ca476f2,0x306456e2,0x2f443f1f)    R(0x05fc,0x2b33b37e,0x2dd35b8d,0x2a935fba)    R(0x05fd,0x2c140f3b,0x2ee3df56,0x2b33b37e)    R(0x05fe,0x2c140f3b,0x2b33b37e,0x2884175a)    R(0x05ff,0x2ee3df56,0x30636f50,0x2dd35b8d)    R(0x0600,0x2ee3df56,0x2dd35b8d,0x2b33b37e)    R(0x0601,0x00350311,0x0014f2b6,0x0055eecd)    R(0x0602,0x0219c5f8,0x0298d20e,0x02b921bb)    R(0x0603,0x098f1615,0x07ef35ec,0x0aefa9e5)\n    R(0x0604,0x1598eb8e,0x12790388,0x1429b386)    R(0x0605,0x27e05679,0x24d05e54,0x25502eb0)    R(0x0606,0x36955de8,0x398591d8,0x36f50a09)    R(0x0607,0x02ed0a11,0x01bc59fc,0x020cfdc1)    R(0x0608,0x098f1615,0x0aefa9e5,0x0c5f6204)    R(0x0609,0x00b58e72,0x00549e59,0x00e5561e)    R(0x060a,0x0c3dde78,0x0d9e423b,0x107e2260)    R(0x060b,0x0055d333,0x00350311,0x0055eecd)    R(0x060c,0x03e56764,0x01b50b80,0x01f5b368)    R(0x060d,0x0ae53701,0x087522f3,0x0895af1c)\n    R(0x060e,0x0055eecd,0x00b58e72,0x00a67a74)    R(0x060f,0x0257d221,0x026745d6,0x029835c6)    R(0x0610,0x00c90326,0x0238eeeb,0x0179bee7)    R(0x0611,0x104d9a9b,0x0d1d52b2,0x0c3dde78)    R(0x0612,0x0e1ed9ff,0x0c5f6204,0x0eff7de5)    R(0x0613,0x0076a30b,0x0055eecd,0x0106eeb8)    R(0x0614,0x00c62e2a,0x00e5561e,0x006591e2)    R(0x0615,0x00f9b71f,0x0179bee7,0x010a8ef0)    R(0x0616,0x014b96ca,0x011b22bd,0x015bd27d)    R(0x0617,0x0298d20e,0x0257d221,0x029835c6)\n    R(0x0618,0x0df77f07,0x0bd70717,0x0a478af3)    R(0x0619,0x0146f227,0x015669e1,0x026745d6)    R(0x061a,0x00b58e72,0x00e5561e,0x00c62e2a)    R(0x061b,0x00a67a74,0x00c62e2a,0x0146f227)    R(0x061c,0x015bd27d,0x023b1686,0x022b1a4f)    R(0x061d,0x016a5712,0x010a8ef0,0x018b32eb)    R(0x061e,0x034ad6fe,0x016a5712,0x018b32eb)    R(0x061f,0x0106eeb8,0x00a67a74,0x01c74e72)    R(0x0620,0x0257d221,0x0146f227,0x026745d6)    R(0x0621,0x0179bee7,0x02a93ea4,0x020a56b6)\n    R(0x0622,0x015bd27d,0x011b22bd,0x023b1686)    R(0x0623,0x02681ab8,0x0106eeb8,0x01c74e72)    R(0x0624,0x01c74e72,0x00a67a74,0x0146f227)    R(0x0625,0x024a5230,0x0219c5f8,0x013ab9ff)    R(0x0626,0x011b22bd,0x020a56b6,0x023b1686)    R(0x0627,0x016bba2d,0x013ab9ff,0x01bb71d7)    R(0x0628,0x01c74e72,0x0146f227,0x0257d221)    R(0x0629,0x018772eb,0x0106eeb8,0x02681ab8)    R(0x062a,0x0178330b,0x018772eb,0x02681ab8)    R(0x062b,0x0179bee7,0x0238eeeb,0x02a93ea4)\n    R(0x062c,0x022b1a4f,0x024a5230,0x013ab9ff)    R(0x062d,0x016bba2d,0x022b1a4f,0x013ab9ff)    R(0x062e,0x010a8ef0,0x020a56b6,0x011b22bd)    R(0x062f,0x0178330b,0x02681ab8,0x0238eeeb)    R(0x0630,0x010a8ef0,0x011b22bd,0x014b96ca)    R(0x0631,0x018b32eb,0x010a8ef0,0x014b96ca)    R(0x0632,0x010a8ef0,0x0179bee7,0x020a56b6)    R(0x0633,0x0146f227,0x00c62e2a,0x015669e1)    R(0x0634,0x018772eb,0x0076a30b,0x0106eeb8)    R(0x0635,0x034ad6fe,0x018b32eb,0x03bba6df)\n    R(0x0636,0x0df77f07,0x0a478af3,0x0c37df08)    R(0x0637,0x09380308,0x08077af7,0x07984f1b)    R(0x0638,0x02ea3677,0x02a96a4c,0x024a5230)    R(0x0639,0x02686268,0x01c74e72,0x0257d221)    R(0x063a,0x0238eeeb,0x02681ab8,0x02a93ea4)    R(0x063b,0x02a93ea4,0x02a96a4c,0x02ea3677)    R(0x063c,0x022b1a4f,0x02ea3677,0x024a5230)    R(0x063d,0x02a93ea4,0x02686268,0x02a96a4c)    R(0x063e,0x02a93ea4,0x02681ab8,0x02686268)    R(0x063f,0x020a56b6,0x02a93ea4,0x02ea3677)\n    R(0x0640,0x02681ab8,0x01c74e72,0x02686268)    R(0x0641,0x020a56b6,0x02ea3677,0x023b1686)    R(0x0642,0x023b1686,0x02ea3677,0x022b1a4f)    R(0x0643,0x0886ff07,0x0606df18,0x08077af7)    R(0x0644,0x0c37df08,0x0a478af3,0x09380308)    R(0x0645,0x02a96a4c,0x0298d20e,0x0219c5f8)    R(0x0646,0x05bb170a,0x034ad6fe,0x03bba6df)    R(0x0647,0x0bd70717,0x0886ff07,0x0a478af3)    R(0x0648,0x02686268,0x0257d221,0x0298d20e)    R(0x0649,0x02a96a4c,0x02686268,0x0298d20e)\n    R(0x064a,0x0a478af3,0x0886ff07,0x08077af7)    R(0x064b,0x024a5230,0x02a96a4c,0x0219c5f8)    R(0x064c,0x0a478af3,0x08077af7,0x09380308)    R(0x064d,0x0106eeb8,0x0055eecd,0x00a67a74)    R(0x064e,0x00a67a74,0x00b58e72,0x00c62e2a)    R(0x064f,0x016bba2d,0x01bb71d7,0x01bc59fc)    R(0x0650,0x0b6e9e1f,0x098f1615,0x0c5f6204)    R(0x0651,0x0d7c4714,0x09cc0712,0x0b5cc2e3)    R(0x0652,0x0f8ceee1,0x0b5cc2e3,0x0d1d52b2)    R(0x0653,0x04adbe13,0x036dc5d7,0x055e89e8)\n    R(0x0654,0x04adbe13,0x055e89e8,0x06be9219)    R(0x0655,0x083d925f,0x04bd2e4e,0x06edd62f)    R(0x0656,0x023c2ac4,0x014b96ca,0x01ac4a99)    R(0x0657,0x05bb170a,0x03bba6df,0x069bd2f6)    R(0x0658,0x04bd2e4e,0x02ed0a11,0x04adbe13)    R(0x0659,0x022c8e50,0x016bba2d,0x01bc59fc)    R(0x065a,0x01ac4a99,0x015bd27d,0x022c8e50)    R(0x065b,0x04ec5ec1,0x032cc291,0x05ecee92)    R(0x065c,0x05ecee92,0x04bd2e4e,0x083d925f)    R(0x065d,0x02ed0a11,0x036dc5d7,0x04adbe13)\n    R(0x065e,0x04bd2e4e,0x04adbe13,0x06edd62f)    R(0x065f,0x05ecee92,0x032cc291,0x04bd2e4e)    R(0x0660,0x032cc291,0x01ac4a99,0x022c8e50)    R(0x0661,0x032cc291,0x022c8e50,0x04bd2e4e)    R(0x0662,0x04bd2e4e,0x022c8e50,0x02ed0a11)    R(0x0663,0x018b32eb,0x014b96ca,0x023c2ac4)    R(0x0664,0x069bd2f6,0x03bba6df,0x04ec5ec1)    R(0x0665,0x069bd2f6,0x04ec5ec1,0x080c86cd)    R(0x0666,0x022c8e50,0x01bc59fc,0x02ed0a11)    R(0x0667,0x06edd62f,0x04adbe13,0x06be9219)\n    R(0x0668,0x023c2ac4,0x01ac4a99,0x032cc291)    R(0x0669,0x04ec5ec1,0x023c2ac4,0x032cc291)    R(0x066a,0x080c86cd,0x04ec5ec1,0x05ecee92)    R(0x066b,0x03bba6df,0x023c2ac4,0x04ec5ec1)    R(0x066c,0x03bba6df,0x018b32eb,0x023c2ac4)    R(0x066d,0x06be9219,0x055e89e8,0x07ef35ec)    R(0x066e,0x0b6e9e1f,0x0c5f6204,0x0e1ed9ff)    R(0x066f,0x015bd27d,0x022b1a4f,0x016bba2d)    R(0x0670,0x01ac4a99,0x014b96ca,0x015bd27d)    R(0x0671,0x0d7c4714,0x0b5cc2e3,0x0f8ceee1)\n    R(0x0672,0x08ce5a2c,0x098f1615,0x0b6e9e1f)    R(0x0673,0x022c8e50,0x015bd27d,0x016bba2d)    R(0x0674,0x0d9e423b,0x0a9e1637,0x0dce6e0d)    R(0x0675,0x06be9219,0x07ef35ec,0x098f1615)    R(0x0676,0x0c3dde78,0x0a9e1637,0x0d9e423b)    R(0x0677,0x0a9e1637,0x06edd62f,0x08ce5a2c)    R(0x0678,0x06edd62f,0x06be9219,0x08ce5a2c)    R(0x0679,0x083d925f,0x06edd62f,0x0a9e1637)    R(0x067a,0x0a9e1637,0x08ce5a2c,0x0b6e9e1f)    R(0x067b,0x0a9e1637,0x0b6e9e1f,0x0dce6e0d)\n    R(0x067c,0x0c3dde78,0x083d925f,0x0a9e1637)    R(0x067d,0x09cc0712,0x069bd2f6,0x080c86cd)    R(0x067e,0x080c86cd,0x05ecee92,0x09ad32a1)    R(0x067f,0x0dce6e0d,0x0b6e9e1f,0x0e1ed9ff)    R(0x0680,0x08ce5a2c,0x06be9219,0x098f1615)    R(0x0681,0x0b5cc2e3,0x09ad32a1,0x0d1d52b2)    R(0x0682,0x09ad32a1,0x05ecee92,0x083d925f)    R(0x0683,0x0d1d52b2,0x09ad32a1,0x0c3dde78)    R(0x0684,0x09ad32a1,0x083d925f,0x0c3dde78)    R(0x0685,0x0b5cc2e3,0x080c86cd,0x09ad32a1)\n    R(0x0686,0x09cc0712,0x080c86cd,0x0b5cc2e3)    R(0x0687,0x00c59f68,0x0094bf78,0x00451b60)    R(0x0688,0x00451b60,0x00350311,0x0055d333)    R(0x0689,0x01f5b368,0x01b50b80,0x00c59f68)    R(0x068a,0x00c62e2a,0x006591e2,0x015669e1)    R(0x068b,0x0e2aaf66,0x0c7b8745,0x107b4f57)    R(0x068c,0x0c7b8745,0x09cc0712,0x0d7c4714)    R(0x068d,0x00b6673b,0x0055d333,0x0076a30b)    R(0x068e,0x00977f28,0x0076a30b,0x018772eb)    R(0x068f,0x0227f77a,0x01476b60,0x00f80f71)\n    R(0x0690,0x01989b72,0x0227f77a,0x00f80f71)    R(0x0691,0x06d54312,0x0574f745,0x05e5a72f)    R(0x0692,0x10070329,0x0bd70717,0x0df77f07)    R(0x0693,0x00977f28,0x018772eb,0x0178330b)    R(0x0694,0x06e7ab22,0x04b71f3b,0x0457db66)    R(0x0695,0x05e5a72f,0x03e56764,0x03d6433d)    R(0x0696,0x00c59f68,0x0055d333,0x00b6673b)    R(0x0697,0x02973757,0x01476b60,0x0227f77a)    R(0x0698,0x0457db66,0x0227f77a,0x03b87774)    R(0x0699,0x03d6433d,0x01766344,0x02d6af35)\n    R(0x069a,0x0606df18,0x02d6af35,0x04b71f3b)    R(0x069b,0x00b73344,0x0076a30b,0x00977f28)    R(0x069c,0x00b73344,0x01476b60,0x0136c73c)    R(0x069d,0x00a82b50,0x00977f28,0x0178330b)    R(0x069e,0x01766344,0x00b6673b,0x0136c73c)    R(0x069f,0x02d6af35,0x02973757,0x04b71f3b)    R(0x06a0,0x01766344,0x0136c73c,0x02d6af35)    R(0x06a1,0x0136c73c,0x00b6673b,0x00b73344)    R(0x06a2,0x02d6af35,0x0136c73c,0x02973757)    R(0x06a3,0x03d6433d,0x03e56764,0x01f5b368)\n    R(0x06a4,0x03d6433d,0x02d6af35,0x0606df18)    R(0x06a5,0x00b6673b,0x0076a30b,0x00b73344)    R(0x06a6,0x00f80f71,0x01476b60,0x00b73344)    R(0x06a7,0x0457db66,0x02973757,0x0227f77a)    R(0x06a8,0x03d6433d,0x01f5b368,0x01766344)    R(0x06a9,0x0136c73c,0x01476b60,0x02973757)    R(0x06aa,0x04b71f3b,0x02973757,0x0457db66)    R(0x06ab,0x01766344,0x00c59f68,0x00b6673b)    R(0x06ac,0x01f5b368,0x00c59f68,0x01766344)    R(0x06ad,0x08077af7,0x0606df18,0x06e7ab22)\n    R(0x06ae,0x0cc4ff16,0x0ae53701,0x0c45c328)    R(0x06af,0x0b588f39,0x0c37df08,0x09380308)    R(0x06b0,0x10070329,0x0e165339,0x0bd70717)    R(0x06b1,0x00a82b50,0x00b73344,0x00977f28)    R(0x06b2,0x00f80f71,0x00b73344,0x00a82b50)    R(0x06b3,0x0895af1c,0x06d54312,0x05e5a72f)    R(0x06b4,0x07063f23,0x03d6433d,0x0606df18)    R(0x06b5,0x08077af7,0x06e7ab22,0x07984f1b)    R(0x06b6,0x0f97b719,0x0c37df08,0x0e984f41)    R(0x06b7,0x0895af1c,0x05e5a72f,0x07063f23)\n    R(0x06b8,0x0a26572a,0x07063f23,0x0886ff07)    R(0x06b9,0x0bd70717,0x0a26572a,0x0886ff07)    R(0x06ba,0x0606df18,0x04b71f3b,0x06e7ab22)    R(0x06bb,0x0c45c328,0x0895af1c,0x0a26572a)    R(0x06bc,0x0a26572a,0x0895af1c,0x07063f23)    R(0x06bd,0x0f456b40,0x0cc4ff16,0x0c45c328)    R(0x06be,0x0c45c328,0x0ae53701,0x0895af1c)    R(0x06bf,0x07063f23,0x05e5a72f,0x03d6433d)    R(0x06c0,0x0df77f07,0x0c37df08,0x0f97b719)    R(0x06c1,0x06e7ab22,0x0457db66,0x06686b46)\n    R(0x06c2,0x0e165339,0x0a26572a,0x0bd70717)    R(0x06c3,0x0886ff07,0x07063f23,0x0606df18)    R(0x06c4,0x0f456b40,0x0c45c328,0x0e165339)    R(0x06c5,0x0e165339,0x0c45c328,0x0a26572a)    R(0x06c6,0x07984f1b,0x06e7ab22,0x06686b46)    R(0x06c7,0x00e8df56,0x00a82b50,0x00c90326)    R(0x06c8,0x00f9b71f,0x00c90326,0x0179bee7)    R(0x06c9,0x03b87774,0x0227f77a,0x01989b72)    R(0x06ca,0x05e5a72f,0x0574f745,0x03e56764)    R(0x06cb,0x103c0b33,0x0c7b8745,0x0d7c4714)\n    R(0x06cc,0x01697342,0x00e8df56,0x00f9b71f)    R(0x06cd,0x00c90326,0x0178330b,0x0238eeeb)    R(0x06ce,0x054a3315,0x034ad6fe,0x05bb170a)    R(0x06cf,0x06ea7332,0x054a3315,0x05bb170a)    R(0x06d0,0x00a82b50,0x0178330b,0x00c90326)    R(0x06d1,0x06686b46,0x03b87774,0x0568f74f)    R(0x06d2,0x06686b46,0x0457db66,0x03b87774)    R(0x06d3,0x00e8df56,0x00c90326,0x00f9b71f)    R(0x06d4,0x06e98336,0x06b8ff30,0x05099b31)    R(0x06d5,0x05099b31,0x02f92359,0x029a0b27)\n    R(0x06d6,0x029a0b27,0x016a5712,0x034ad6fe)    R(0x06d7,0x06e98336,0x05099b31,0x054a3315)    R(0x06d8,0x01697342,0x00f9b71f,0x016a5712)    R(0x06d9,0x029a0b27,0x01697342,0x016a5712)    R(0x06da,0x054a3315,0x05099b31,0x029a0b27)    R(0x06db,0x06ea7332,0x06e98336,0x054a3315)    R(0x06dc,0x06b8ff30,0x0568f74f,0x05099b31)    R(0x06dd,0x01989b72,0x00f80f71,0x00e8df56)    R(0x06de,0x02f92359,0x03b87774,0x01989b72)    R(0x06df,0x06b8ff30,0x06686b46,0x0568f74f)\n    R(0x06e0,0x016a5712,0x00f9b71f,0x010a8ef0)    R(0x06e1,0x054a3315,0x029a0b27,0x034ad6fe)    R(0x06e2,0x02f92359,0x01989b72,0x01697342)    R(0x06e3,0x05099b31,0x0568f74f,0x02f92359)    R(0x06e4,0x029a0b27,0x02f92359,0x01697342)    R(0x06e5,0x0568f74f,0x03b87774,0x02f92359)    R(0x06e6,0x01697342,0x01989b72,0x00e8df56)    R(0x06e7,0x0895af1c,0x087522f3,0x06d54312)    R(0x06e8,0x086b4f32,0x069bd2f6,0x09cc0712)    R(0x06e9,0x0e984f41,0x0c37df08,0x0b588f39)\n    R(0x06ea,0x00e8df56,0x00f80f71,0x00a82b50)    R(0x06eb,0x06ea7332,0x05bb170a,0x086b4f32)    R(0x06ec,0x0b588f39,0x09380308,0x0818c333)    R(0x06ed,0x07984f1b,0x06686b46,0x06b8ff30)    R(0x06ee,0x0b588f39,0x0818c333,0x0a793b55)    R(0x06ef,0x0a5ac351,0x086b4f32,0x0c7b8745)    R(0x06f0,0x086b4f32,0x05bb170a,0x069bd2f6)    R(0x06f1,0x0c7b8745,0x086b4f32,0x09cc0712)    R(0x06f2,0x097a0753,0x06e98336,0x06ea7332)    R(0x06f3,0x0a5ac351,0x06ea7332,0x086b4f32)\n    R(0x06f4,0x0818c333,0x07984f1b,0x06b8ff30)    R(0x06f5,0x0818c333,0x06b8ff30,0x06e98336)    R(0x06f6,0x0a793b55,0x0818c333,0x06e98336)    R(0x06f7,0x09380308,0x07984f1b,0x0818c333)    R(0x06f8,0x0e59076a,0x0e984f41,0x0b588f39)    R(0x06f9,0x0a793b55,0x06e98336,0x097a0753)    R(0x06fa,0x0e2aaf66,0x0a5ac351,0x0c7b8745)    R(0x06fb,0x0e59076a,0x0b588f39,0x0a793b55)    R(0x06fc,0x0cd9db69,0x0a793b55,0x097a0753)    R(0x06fd,0x0cd9db69,0x097a0753,0x0a5ac351)\n    R(0x06fe,0x0a5ac351,0x097a0753,0x06ea7332)    R(0x06ff,0x0e2aaf66,0x0cd9db69,0x0a5ac351)    R(0x0700,0x0e59076a,0x0a793b55,0x0cd9db69)    R(0x0701,0x36f50a09,0x398591d8,0x38e519e8)    R(0x0702,0x27eb5a11,0x284b19c4,0x28ea8605)    R(0x0703,0x0dce6e0d,0x0e1ed9ff,0x104e9dda)    R(0x0704,0x0055eecd,0x0014f2b6,0x00b58e72)    R(0x0705,0x1c458f51,0x1bb4bf69,0x18a58f66)    R(0x0706,0x1868fb79,0x16d83f6e,0x1598eb8e)    R(0x0707,0x33951217,0x36955de8,0x36f50a09)\n    R(0x0708,0x2745664e,0x2904e657,0x27653695)    R(0x0709,0x22e6aad9,0x23d5a6d6,0x2115f309)    R(0x070a,0x104d9a9b,0x0c3dde78,0x107e2260)    R(0x070b,0x1bce35f8,0x1eade5c8,0x1f5dce0a)    R(0x070c,0x10ee760c,0x0dce6e0d,0x104e9dda)    R(0x070d,0x1e7b1add,0x1f3beac5,0x219b3ec1)    R(0x070e,0x23777ac4,0x22e6aad9,0x20070303)    R(0x070f,0x26672241,0x2656b9ee,0x2696462c)    R(0x0710,0x26c5c5f2,0x2794f60b,0x2745664e)    R(0x0711,0x3305c9f0,0x34258df0,0x33951217)\n    R(0x0712,0x24a86abf,0x2167f2f1,0x22b8dae8)    R(0x0713,0x26672241,0x2646466c,0x24e6fe8f)    R(0x0714,0x25abbe6b,0x279b0656,0x24bb3a9d)    R(0x0715,0x24a86abf,0x23777ac4,0x2167f2f1)    R(0x0716,0x23d5a6d6,0x24c54ecc,0x22453303)    R(0x0717,0x24e6fe8f,0x2646466c,0x25163eae)    R(0x0718,0x2646466c,0x26058694,0x25163eae)    R(0x0719,0x26058694,0x27653695,0x24c54ecc)    R(0x071a,0x24e6fe8f,0x25163eae,0x22e6aad9)    R(0x071b,0x25b7c683,0x24e6fe8f,0x23777ac4)\n    R(0x071c,0x24bb3a9d,0x266a7a90,0x23ba66ca)    R(0x071d,0x24a86abf,0x25b7c683,0x23777ac4)    R(0x071e,0x26c8ba87,0x25b7c683,0x24a86abf)    R(0x071f,0x25197ebf,0x26c8ba87,0x24a86abf)    R(0x0720,0x2749a283,0x26c8ba87,0x25197ebf)    R(0x0721,0x266a7a90,0x2749a283,0x25197ebf)    R(0x0722,0x25163eae,0x26058694,0x23d5a6d6)    R(0x0723,0x23d5a6d6,0x26058694,0x24c54ecc)    R(0x0724,0x25b7c683,0x26672241,0x24e6fe8f)    R(0x0725,0x25197ebf,0x22b8dae8,0x21e9b2ef)\n    R(0x0726,0x24bb3a9d,0x279b0656,0x266a7a90)    R(0x0727,0x219b3ec1,0x24bb3a9d,0x23ba66ca)    R(0x0728,0x23777ac4,0x24e6fe8f,0x22e6aad9)    R(0x0729,0x23ba66ca,0x25197ebf,0x21e9b2ef)    R(0x072a,0x23ba66ca,0x266a7a90,0x25197ebf)    R(0x072b,0x22e6aad9,0x25163eae,0x23d5a6d6)    R(0x072c,0x25197ebf,0x24a86abf,0x22b8dae8)    R(0x072d,0x2656b9ee,0x26c5c5f2,0x2696462c)    R(0x072e,0x28f995fc,0x285895f8,0x28491e43)    R(0x072f,0x279b0656,0x27eb5a11,0x28ea8605)\n    R(0x0730,0x24c54ecc,0x27653695,0x270516eb)    R(0x0731,0x203a82ec,0x1e7b1add,0x219b3ec1)    R(0x0732,0x23ba66ca,0x21e9b2ef,0x203a82ec)    R(0x0733,0x2696462c,0x26c5c5f2,0x2745664e)    R(0x0734,0x27781e41,0x26672241,0x25b7c683)    R(0x0735,0x28491e43,0x27781e41,0x26c8ba87)    R(0x0736,0x286a1e48,0x28f995fc,0x28491e43)    R(0x0737,0x279b0656,0x28ea8605,0x286a1e48)    R(0x0738,0x28491e43,0x285895f8,0x27781e41)    R(0x0739,0x26672241,0x2696462c,0x2646466c)\n    R(0x073a,0x27781e41,0x274799f5,0x26672241)    R(0x073b,0x286a1e48,0x28491e43,0x2749a283)    R(0x073c,0x2696462c,0x2745664e,0x2646466c)    R(0x073d,0x2745664e,0x27653695,0x26058694)    R(0x073e,0x274799f5,0x2656b9ee,0x26672241)    R(0x073f,0x28ea8605,0x28f995fc,0x286a1e48)    R(0x0740,0x219b3ec1,0x23ba66ca,0x203a82ec)    R(0x0741,0x26c8ba87,0x27781e41,0x25b7c683)    R(0x0742,0x2749a283,0x28491e43,0x26c8ba87)    R(0x0743,0x266a7a90,0x286a1e48,0x2749a283)\n    R(0x0744,0x2646466c,0x2745664e,0x26058694)    R(0x0745,0x279b0656,0x286a1e48,0x266a7a90)    R(0x0746,0x285895f8,0x274799f5,0x27781e41)    R(0x0747,0x0f8ceee1,0x0d1d52b2,0x104d9a9b)    R(0x0748,0x144e523c,0x10ee760c,0x14ee85ef)    R(0x0749,0x192c6afb,0x18ad26d3,0x1bccfec1)    R(0x074a,0x227d3e22,0x1f5dce0a,0x220d59ce)    R(0x074b,0x30b551fa,0x3305c9f0,0x3134ea2f)    R(0x074c,0x33951217,0x34258df0,0x36955de8)    R(0x074d,0x144e523c,0x14ee85ef,0x183e5a1b)\n    R(0x074e,0x1b8dfe47,0x1bce35f8,0x1f5dce0a)    R(0x074f,0x0d9e423b,0x0dce6e0d,0x10ee760c)    R(0x0750,0x1c5c42ea,0x192c6afb,0x1bccfec1)    R(0x0751,0x1cab7afb,0x1c5c42ea,0x1f3beac5)    R(0x0752,0x107e2260,0x0d9e423b,0x10ee760c)    R(0x0753,0x1bccfec1,0x1a0db292,0x1d5d6680)    R(0x0754,0x1d5d6680,0x1b8dfe47,0x1f5d8a46)    R(0x0755,0x13ddee86,0x107e2260,0x144e523c)    R(0x0756,0x17ae1667,0x183e5a1b,0x1b8dfe47)    R(0x0757,0x168d9aae,0x13ddee86,0x17ae1667)\n    R(0x0758,0x1a0db292,0x17ae1667,0x1b8dfe47)    R(0x0759,0x17ae1667,0x13ddee86,0x144e523c)    R(0x075a,0x1a0db292,0x1b8dfe47,0x1d5d6680)    R(0x075b,0x1a0db292,0x168d9aae,0x17ae1667)    R(0x075c,0x17ae1667,0x144e523c,0x183e5a1b)    R(0x075d,0x1c5c42ea,0x1bccfec1,0x1efcaaa5)    R(0x075e,0x159cd2fa,0x168d9aae,0x18ad26d3)    R(0x075f,0x132d52ce,0x104d9a9b,0x13ddee86)    R(0x0760,0x1b8dfe47,0x1f5dce0a,0x1f5d8a46)    R(0x0761,0x1b8dfe47,0x183e5a1b,0x1bce35f8)\n    R(0x0762,0x18ad26d3,0x168d9aae,0x1a0db292)    R(0x0763,0x1bccfec1,0x1d5d6680,0x1efcaaa5)    R(0x0764,0x132d52ce,0x13ddee86,0x168d9aae)    R(0x0765,0x159cd2fa,0x132d52ce,0x168d9aae)    R(0x0766,0x1bccfec1,0x18ad26d3,0x1a0db292)    R(0x0767,0x227d3e22,0x220d59ce,0x24bcc1fd)    R(0x0768,0x3134ea2f,0x3305c9f0,0x33951217)    R(0x0769,0x144e523c,0x107e2260,0x10ee760c)    R(0x076a,0x132d52ce,0x0f8ceee1,0x104d9a9b)    R(0x076b,0x1e7b1add,0x1cab7afb,0x1f3beac5)\n    R(0x076c,0x1f5d8a46,0x1f5dce0a,0x227d3e22)    R(0x076d,0x265c122a,0x27eb5a11,0x279b0656)    R(0x076e,0x265c122a,0x26bc05da,0x27eb5a11)    R(0x076f,0x228c1e91,0x242c9251,0x25abbe6b)    R(0x0770,0x213cfa6e,0x1f5d8a46,0x227d3e22)    R(0x0771,0x1d5d6680,0x1f5d8a46,0x213cfa6e)    R(0x0772,0x242c9251,0x24bcc1fd,0x265c122a)    R(0x0773,0x228c1e91,0x213cfa6e,0x242c9251)    R(0x0774,0x213cfa6e,0x227d3e22,0x242c9251)    R(0x0775,0x242c9251,0x265c122a,0x25abbe6b)\n    R(0x0776,0x25abbe6b,0x265c122a,0x279b0656)    R(0x0777,0x219b3ec1,0x228c1e91,0x24bb3a9d)    R(0x0778,0x1f3beac5,0x1c5c42ea,0x1efcaaa5)    R(0x0779,0x24bcc1fd,0x26bc05da,0x265c122a)    R(0x077a,0x104d9a9b,0x107e2260,0x13ddee86)    R(0x077b,0x228c1e91,0x25abbe6b,0x24bb3a9d)    R(0x077c,0x1f3beac5,0x228c1e91,0x219b3ec1)    R(0x077d,0x1efcaaa5,0x213cfa6e,0x228c1e91)    R(0x077e,0x227d3e22,0x24bcc1fd,0x242c9251)    R(0x077f,0x1efcaaa5,0x1d5d6680,0x213cfa6e)\n    R(0x0780,0x1f3beac5,0x1efcaaa5,0x228c1e91)    R(0x0781,0x24c54ecc,0x23d50710,0x22453303)    R(0x0782,0x15351b77,0x11e4e76a,0x11b5f34f)    R(0x0783,0x00c59f68,0x00451b60,0x0055d333)    R(0x0784,0x16d83f6e,0x14285380,0x1598eb8e)    R(0x0785,0x183e5a1b,0x187e6dc8,0x1bce35f8)    R(0x0786,0x183e5a1b,0x14ee85ef,0x187e6dc8)    R(0x0787,0x0055d333,0x0055eecd,0x0076a30b)    R(0x0788,0x15351b77,0x11b5f34f,0x1515e75c)    R(0x0789,0x1598eb8e,0x14285380,0x12790388)\n    R(0x078a,0x1ac9173f,0x19685f4a,0x1868fb79)    R(0x078b,0x23777ac4,0x20070303,0x2167f2f1)    R(0x078c,0x23d5a6d6,0x22453303,0x2115f309)    R(0x078d,0x12676323,0x10070329,0x0df77f07)    R(0x078e,0x11b5f34f,0x0f456b40,0x0e165339)    R(0x078f,0x1a765345,0x18a58f66,0x17067749)    R(0x0790,0x11487f70,0x0e984f41,0x0e59076a)    R(0x0791,0x12790388,0x11487f70,0x0e59076a)    R(0x0792,0x1507b348,0x12676323,0x1237db44)    R(0x0793,0x1515e75c,0x11b5f34f,0x13a6d33b)\n    R(0x0794,0x19073345,0x17067749,0x15f74b37)    R(0x0795,0x12676323,0x0f97b719,0x1237db44)    R(0x0796,0x1237db44,0x0e984f41,0x11487f70)    R(0x0797,0x17067749,0x1515e75c,0x13a6d33b)    R(0x0798,0x13a6d33b,0x10070329,0x12676323)    R(0x0799,0x19073345,0x15f74b37,0x17c7c342)    R(0x079a,0x17c7c342,0x15f74b37,0x1507b348)    R(0x079b,0x13a6d33b,0x11b5f34f,0x10070329)    R(0x079c,0x17067749,0x13a6d33b,0x15f74b37)    R(0x079d,0x18a58f66,0x1515e75c,0x17067749)\n    R(0x079e,0x15f74b37,0x13a6d33b,0x12676323)    R(0x079f,0x19685f4a,0x17c7c342,0x16d83f6e)    R(0x07a0,0x14285380,0x1237db44,0x11487f70)    R(0x07a1,0x14285380,0x11487f70,0x12790388)    R(0x07a2,0x16d83f6e,0x1507b348,0x14285380)    R(0x07a3,0x15f74b37,0x12676323,0x1507b348)    R(0x07a4,0x17c7c342,0x1507b348,0x16d83f6e)    R(0x07a5,0x19685f4a,0x16d83f6e,0x1868fb79)    R(0x07a6,0x1507b348,0x1237db44,0x14285380)    R(0x07a7,0x22e6aad9,0x2115f309,0x20070303)\n    R(0x07a8,0x2115f309,0x22453303,0x1f752336)    R(0x07a9,0x12676323,0x0df77f07,0x0f97b719)    R(0x07aa,0x1be88f26,0x19685f4a,0x1ac9173f)    R(0x07ab,0x1c458f51,0x18a58f66,0x1a765345)    R(0x07ac,0x22b8dae8,0x2167f2f1,0x1f68d30c)    R(0x07ad,0x2115f309,0x1f752336,0x1e26372c)    R(0x07ae,0x2167f2f1,0x20070303,0x1e47db1b)    R(0x07af,0x1237db44,0x0f97b719,0x0e984f41)    R(0x07b0,0x1be88f26,0x1a57d737,0x19685f4a)    R(0x07b1,0x1f68d30c,0x1e47db1b,0x1be88f26)\n    R(0x07b2,0x1e26372c,0x1a765345,0x1c670730)    R(0x07b3,0x20070303,0x1e26372c,0x1c670730)    R(0x07b4,0x1e47db1b,0x1a57d737,0x1be88f26)    R(0x07b5,0x20070303,0x1c670730,0x1e47db1b)    R(0x07b6,0x1e47db1b,0x1c670730,0x1a57d737)    R(0x07b7,0x1e26372c,0x1f752336,0x1c458f51)    R(0x07b8,0x11b5f34f,0x0e165339,0x10070329)    R(0x07b9,0x2167f2f1,0x1e47db1b,0x1f68d30c)    R(0x07ba,0x1e26372c,0x1c458f51,0x1a765345)    R(0x07bb,0x1a765345,0x17067749,0x19073345)\n    R(0x07bc,0x1c670730,0x1a765345,0x19073345)    R(0x07bd,0x1c670730,0x19073345,0x1a57d737)    R(0x07be,0x1a57d737,0x19073345,0x17c7c342)    R(0x07bf,0x1a57d737,0x17c7c342,0x19685f4a)    R(0x07c0,0x20070303,0x2115f309,0x1e26372c)    R(0x07c1,0x107b4f57,0x0c7b8745,0x103c0b33)    R(0x07c2,0x11e4e76a,0x0f456b40,0x11b5f34f)    R(0x07c3,0x122cb70b,0x0f8ceee1,0x132d52ce)    R(0x07c4,0x1799bf7e,0x1598eb8e,0x1429b386)    R(0x07c5,0x21e9b2ef,0x22b8dae8,0x1f68d30c)\n    R(0x07c6,0x121a9378,0x1059d378,0x0e2aaf66)    R(0x07c7,0x159cd2fa,0x122cb70b,0x132d52ce)    R(0x07c8,0x199a9b59,0x162a8771,0x179b4753)    R(0x07c9,0x18a58f66,0x15351b77,0x1515e75c)    R(0x07ca,0x1059d378,0x0cd9db69,0x0e2aaf66)    R(0x07cb,0x1868fb79,0x1598eb8e,0x1799bf7e)    R(0x07cc,0x16fc0b2d,0x13ac1b31,0x159cd2fa)    R(0x07cd,0x121a9378,0x0e2aaf66,0x107b4f57)    R(0x07ce,0x162a8771,0x144b575a,0x179b4753)    R(0x07cf,0x122cb70b,0x0d7c4714,0x0f8ceee1)\n    R(0x07d0,0x192c6afb,0x159cd2fa,0x18ad26d3)    R(0x07d1,0x144b575a,0x107b4f57,0x13ac1b31)    R(0x07d2,0x13ac1b31,0x107b4f57,0x103c0b33)    R(0x07d3,0x16fc0b2d,0x144b575a,0x13ac1b31)    R(0x07d4,0x13ac1b31,0x103c0b33,0x122cb70b)    R(0x07d5,0x121a9378,0x107b4f57,0x144b575a)    R(0x07d6,0x179b4753,0x144b575a,0x16fc0b2d)    R(0x07d7,0x12790388,0x0e59076a,0x1059d378)    R(0x07d8,0x1059d378,0x0e59076a,0x0cd9db69)    R(0x07d9,0x199a9b59,0x1799bf7e,0x162a8771)\n    R(0x07da,0x16fc0b2d,0x159cd2fa,0x192c6afb)    R(0x07db,0x1429b386,0x1059d378,0x121a9378)    R(0x07dc,0x162a8771,0x1429b386,0x121a9378)    R(0x07dd,0x1429b386,0x12790388,0x1059d378)    R(0x07de,0x162a8771,0x121a9378,0x144b575a)    R(0x07df,0x1799bf7e,0x1429b386,0x162a8771)    R(0x07e0,0x13ac1b31,0x122cb70b,0x159cd2fa)    R(0x07e1,0x203a82ec,0x1cda5eff,0x1e7b1add)    R(0x07e2,0x21e9b2ef,0x1e79bf09,0x203a82ec)    R(0x07e3,0x1f68d30c,0x1be88f26,0x1c596314)\n    R(0x07e4,0x103c0b33,0x0d7c4714,0x122cb70b)    R(0x07e5,0x19e9c364,0x1799bf7e,0x199a9b59)    R(0x07e6,0x19fb9b25,0x192c6afb,0x1c5c42ea)    R(0x07e7,0x1e79bf09,0x1f68d30c,0x1c596314)    R(0x07e8,0x203a82ec,0x1e79bf09,0x1cda5eff)    R(0x07e9,0x1cda5eff,0x1cab7afb,0x1e7b1add)    R(0x07ea,0x19fb9b25,0x16fc0b2d,0x192c6afb)    R(0x07eb,0x1cda5eff,0x1bb9f728,0x1b8acf1f)    R(0x07ec,0x1cda5eff,0x1b8acf1f,0x1cab7afb)    R(0x07ed,0x1cda5eff,0x1c596314,0x1bb9f728)\n    R(0x07ee,0x1b8acf1f,0x19fb9b25,0x1cab7afb)    R(0x07ef,0x1cab7afb,0x19fb9b25,0x1c5c42ea)    R(0x07f0,0x1e79bf09,0x1c596314,0x1cda5eff)    R(0x07f1,0x1c596314,0x1be88f26,0x1ac9173f)    R(0x07f2,0x21e9b2ef,0x1f68d30c,0x1e79bf09)    R(0x07f3,0x19e9c364,0x1868fb79,0x1799bf7e)    R(0x07f4,0x19fb9b25,0x179b4753,0x16fc0b2d)    R(0x07f5,0x1ac9173f,0x1868fb79,0x19e9c364)    R(0x07f6,0x1bb9f728,0x1ac9173f,0x19e9c364)    R(0x07f7,0x1bb9f728,0x19e9c364,0x199a9b59)        \n    R(0x07f8,0x1bb9f728,0x199a9b59,0x1b8acf1f)    R(0x07f9,0x1b8acf1f,0x199a9b59,0x19fb9b25)    R(0x07fa,0x199a9b59,0x179b4753,0x19fb9b25)    R(0x07fb,0x1c596314,0x1ac9173f,0x1bb9f728)  \n    }\n  return r;\n}\n#endif\n\nvec4 encode_int(in int x) {\n    ivec4 col = (ivec4(x)>>ivec4(0,8,16,24))&255;\n    return vec4(col)/255.0;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Test whether data should be sent. Data is sent if:\n    //  this is the first frame or\n    //  rendering area was resized (previous width/height stored in first pixel)\n    bool reset = (iFrame < 10);\n    reset = reset || (get_data(RESOLUTION_OFFSET,0) != int(iChannelResolution[0].x));\n    reset = reset || (get_data(RESOLUTION_OFFSET,1) != int(iChannelResolution[0].y));\n    if(reset) {  \n       ivec2 uv = ivec2(fragCoord); \n       int index = uv.x + uv.y * int(iResolution.x); \n       if(index < 2) {\n           fragColor = encode_int(int(iResolution[index]));\n       } else {\n          index -= MESH_DATA_OFFSET;\n          if(index < facets_data_size*3) {\n            int comp = index % 3;\n            index = index / 3;\n            ivec3 P = facets_data(index);\n            fragColor = encode_int(P[comp]);    \n          } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n       }\n    } else {\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    }\n}\n ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Mesh data description: bbox and number of facets\n\n// #define THE_BIG_ONE  // uncomment for 4K facets (default = 2K facets)\n                        // (can take 100 seconds to compile under Windows)\n                        // Try this: disable angle (in firefox: about:config)\n\n#ifdef THE_BIG_ONE\nconst vec3 bbox_min = vec3(-0.254081,-0.34176,-0.346805);\nconst vec3 bbox_max = vec3(0.25292,0.341409,0.345904);\nconst int facets_data_size = 3996;\n#else\nconst vec3 bbox_min = vec3(-0.253035,-0.340497,-0.346693);\nconst vec3 bbox_max = vec3(0.252403,0.340004,0.345965);\nconst int facets_data_size = 2044;\n#endif\n\n// Reads a 32 bits integer encoded in a pixel of BufferA\n// (implementation of get_data(), do not call directly)\nint get_data_raw(in sampler2D channel, in int width, in int index) {\n   vec4 col = 255.0*vec4(texelFetch(channel, ivec2(index%width,index/width), 0));\n   return (int(col.r)      ) | \n          (int(col.g) << 8 ) |\n          (int(col.b) << 16) |\n          (int(col.a) << 24) ;\n}\n\n\n// Reads a 32 bits integer encoded in a pixel of BufferA\n//  offset: one of RESOLUTION_OFFSET, MESH_DATA_OFFSET\n//  index: the index of the data to be read\n#define get_data(offset, index) \\\n    get_data_raw(iChannel0, int(iChannelResolution[0].x), (offset)+(index))\n\n// In BufferA, data is organized in sections\n// RESOLUTION_OFFSET: 2 integers (previous width and height, used to detect win resize)\n// MESH_DATA_OFFSET: facets_data_size * 3 integers. Each integer encores the x,y,z \n//                    coordinates of a vertex (x:10 bits, y:10 bits, z:10 bits). \nconst int RESOLUTION_OFFSET=0;\nconst int MESH_DATA_OFFSET=2;\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcSzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 278, 278, 428], [622, 622, 685, 685, 983], [985, 985, 1022, 1022, 1125], [1292, 1292, 1321, 1321, 1373], [1423, 1423, 1482, 1482, 1753], [1755, 1755, 1828, 1828, 2001], [2004, 2004, 2134, 4130, 4480], [4482, 4482, 4568, 4568, 4758], [4761, 4761, 4942, 5043, 5329], [5386, 5386, 5406, 5406, 5434], [5436, 5436, 5473, 5473, 5544], [5546, 5546, 5584, 5584, 5653], [5655, 5655, 5684, 5684, 5879], [5881, 5881, 5928, 5928, 5961], [5963, 5963, 6010, 6010, 6043], [6045, 6045, 6108, 6530, 9111], [9116, 9116, 9156, 9156, 9319], [9322, 9322, 9375, 9375, 9491], [9493, 9493, 9550, 9550, 10389]], "test": "untested"}
{"id": "wttXRr", "name": "Globules", "author": "samhattangady", "description": "Just playing around with the smooth blending functions, and a little bit of randomness... kinda.\nReally need to work on lighting though...", "tags": ["smoothblending"], "likes": 2, "viewed": 299, "published": 3, "date": "1580313225", "time_retrieved": "2024-07-30T21:27:34.277226", "image_code": "/*\nday003: Globules\n29 Jan 2020\n\nJust playing around with the smooth blending functions,\nand a little bit of randomness... kinda.\nReally need to work on lighting though...\n*/\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\n\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\n\nfloat sdfPlane( vec3 position, vec4 n ) {\n    return dot(position, normalize(n.xyz)) + n.w;\n}\n\nfloat smin(float d1, float d2, float k) {\n    float res = exp2( -k*d1 ) + exp2( -k*d2 );\n    return -log2( res )/k;\n}\n\n\nfloat distanceField(vec3 position) {\n    float d = sdfSphere(position, vec3(0.35*sin(iTime*0.5), 0.2*cos(iTime*0.8), 0.0), 0.55);\n    \n    vec3 moon = vec3(0.95*cos(iTime*0.4), 0.85*sin(iTime*1.4), -0.85*cos(iTime));\n    float d1 = sdfSphere(position, moon, 0.2);\n    d = smin(d, d1, 3.0);\n    \n    d1 = sdfSphere(position, vec3(0.95*cos(iTime*2.3), 0.95*sin(iTime*3.4), 0.95*cos(iTime*1.5)), 0.05);\n    d = smin(d, d1, 3.0);\n    \n    d1 = sdfSphere(position, moon+vec3(0.35*cos(iTime*1.3), 0.49*sin(iTime*2.4), 0.35*cos(iTime*2.8)), 0.01);\n    d = smin(d, d1, 8.0);\n    \n    float d2 = sdfPlane(position, vec4(0.1*sin(iTime*0.2), 1.0, 0.07*sin(iTime*0.3), 0.75+0.2*sin(iTime*0.3)));\n\n    return smin(d2, d, 8.0);\n}\n\nvec3 calcNormal( vec3 p ) \n{\n    // We calculate the normal by finding the gradient of the field at the\n    // point that we are interested in. We can find the gradient by getting\n    // the difference in field at that point and a point slighttly away from it.\n    const float h = 0.0001;\n    return normalize( vec3(\n        \t\t\t       -distanceField(p)+ distanceField(p+vec3(h,0.0,0.0)),\n                           -distanceField(p)+ distanceField(p+vec3(0.0,h,0.0)),\n                           -distanceField(p)+ distanceField(p+vec3(0.0,0.0,h)) \n    \t\t\t\t ));\n}\n\nfloat raymarch( vec3 direction, vec3 start) {\n    // We need to cast out a ray in the given direction, and see which is\n    // the closest object that we hit. We then move forward by that distance,\n    // and continue the same process. We terminate when we hit an object\n    // (distance is very small) or at some predefined distance.\n    float far = 15.0;\n    float d = 0.0;\n    vec3 pos = start;\n    for (int i=0; i<100; i++) {\n    \tfloat sphereDistance = distanceField(pos);\n        pos += sphereDistance*direction;\n\n        d += sphereDistance;\n        if (sphereDistance < 0.01) {\n        \tbreak;\n        }\n        if (d > far) {\n        \tbreak;\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalise and set center to origin.\n    vec2 p = fragCoord/iResolution.xy;\n    p -= 0.5;\n    p.y *= iResolution.y/iResolution.x;\n    \n    vec3 cameraPosition = vec3(0.0, 0.0, -6.0);\n    //vec3 cameraOrientation = vec3(0.0, 0.0, 0.0);\n    vec3 planePosition = vec3(p, -5.0);\n    // planePosition = rotate3D(planePosition, vec3(0.0, 0.0, iTime));\n    \n    vec3 lookingDirection = (planePosition - cameraPosition);\n    \n    // Rotate light around origin in xz plane\n    float angle = iTime;\n    vec2 lightPos2D = mat2(cos(angle),-sin(angle),sin(angle),cos(angle))*vec2(0.0,1.0); \n    vec3 lightPoint = normalize(vec3(1.0*sin(iTime*0.5), 1.0, -1.0));\n    vec3 lightFacing = lightPoint - vec3(0.0);\n    \n    // raymarch to check for colissions.\n    float dist = raymarch(lookingDirection, planePosition);\n    vec3 color = vec3(0.01);\n    if (dist < 15.0) {\n        color = vec3(0.05, 0.105, 0.305);\n    \tvec3 normal = calcNormal(planePosition+ dist*lookingDirection);\n        float light = dot(lightFacing, normal);\n        color += 0.4* smoothstep(0.3, 1.0, light);\n    }\n    \n    // gamma correction\n    color = pow( color, vec3(1.0/2.2) );\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttXRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 175, 217, 217, 662], [664, 664, 723, 723, 773], [775, 775, 816, 816, 868], [870, 870, 911, 911, 987], [990, 990, 1026, 1026, 1705], [1707, 1707, 1735, 1967, 2269], [2271, 2271, 2316, 2605, 2953], [2955, 2955, 3012, 3055, 4192]], "test": "untested"}
{"id": "3ltXzr", "name": "ShoninVRC/Random noise", "author": "ShoninVRC", "description": "noise", "tags": ["noise"], "likes": 2, "viewed": 418, "published": 3, "date": "1580308155", "time_retrieved": "2024-07-30T21:27:35.033205", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n#define _num 200.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int uvx = int(uv.x * _num);\n    int uvy = int(uv.y * _num);\n    uv.x = float(uvx) / _num;\n    uv.y = float(uvy) / _num;\n    float _rnd = rand(uv * iTime);\n    _rnd = rand(vec2(_rnd, iTime));\n    \n    if(fract(iTime * 2.0) > 0.1)\n        _rnd /= fract(iTime * 2.0);\n\n    // Time varying pixel color\n    vec4 col = vec4(_rnd, _rnd, _rnd, _rnd);\n\n    // Output to screen\n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Random noise\",\n\t\"description\": \"first of glsl\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltXzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [114, 114, 171, 221, 661]], "test": "untested"}
{"id": "3ttSzr", "name": "crumpledWave", "author": "nasana", "description": "https://twitter.com/nasana_x", "tags": ["cineshader"], "likes": 116, "viewed": 50183, "published": 3, "date": "1580304104", "time_retrieved": "2024-07-30T21:27:35.946763", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv =  (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n   \n    for(float i = 1.0; i < 8.0; i++){\n    uv.y += i * 0.1 / i * \n      sin(uv.x * i * i + iTime * 0.5) * sin(uv.y * i * i + iTime * 0.5);\n  }\n    \n   vec3 col;\n   col.r  = uv.y - 0.1;\n   col.g = uv.y + 0.3;\n   col.b = uv.y + 0.95;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 416]], "test": "untested"}
{"id": "WtdSzn", "name": "Mondrian pong (308 chars)", "author": "FabriceNeyret2", "description": " golfing [url]https://shadertoy.com/view/Xdy3Wh[/url] ( 548 chars )\nreproducing [url]http://33.media.tumblr.com/tumblr_mafojfoHoJ1rvbw2yo1_400.gif[/url]\n\ncould it be shorter ? :-)", "tags": ["pong", "gif", "mondrian", "golf", "reproduction", "3tweets"], "likes": 4, "viewed": 299, "published": 3, "date": "1580302043", "time_retrieved": "2024-07-30T21:27:36.757595", "image_code": "// golfing https://shadertoy.com/view/Xdy3Wh ( 548 chars )\n// reproducing http://33.media.tumblr.com/tumblr_mafojfoHoJ1rvbw2yo1_400.gif\n\n/*/ doesn't work on windows  (probable Angle bug at ?++)\n#define v vec2//\n#define mainImage(O,u)                                    \\\n    vec2 R = iResolution.xy,                              \\\n         L = .5 - mod( iTime / v(1,2), 2.),               \\\n         l = 1e2*  max( L++, -L ),                        \\\n         p = v(80, l.y*.7),                               \\\n       V[] = v[]( -p,p,l , L=v(15,45),L,v(15,12) );       \\\n    for( int i= -1 ;                                      \\\n         ++i < 4 && min(L.x,L.y) > 1.;                    \\\n         i==3 ? O++ : O                                   \\\n       )                                                  \\\n        l = V[3+i],                                       \\\n        max( L = abs( p = V[i] -1e2*( u+u-R)/R.y ) / l++, \\\n             L.y ).x < 1.                                 \\\n            ? O[i%2*2]++, i==2 ? O.ga++ : R               \\\n            : L = min( abs(p+l), abs(p-l) )              /*/\n\n\n\n\n\n// --- 316 chars\n\n#define B(i,n)                                 \\\n    l= V[3+i],                                 \\\n    L = abs( p = V[i]-U ) / l++,               \\\n    max(L.x,L.y) < 1. ? n++ , R                \\\n       : L = min( abs(p+l), abs(p-l) );        \\\n    if (min(L.x,L.y) > 1.) {                  //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n\t     U = 1e2* ( u+u - R ) / R.y,\n         L = .5 - mod( iTime / vec2(1,2), 2.),\n         l = 1e2*  max( L++, -L ),\n         p = vec2(80, l.y*.7),\n       V[] = vec2[](-p,p,l, L=vec2(15,45),L,vec2(15,12) );\n    B( 0, O.r )\n    B( 1, O.b )\n    B( 2, O.rg )\n    O++; }}}}/*\n\n\n\n\n\n// --- 327 chars\n\n#define B(i,n)                                 \\\n    l= V[3+i];                                 \\\n    L = abs( p = V[i]-U ) / l++;               \\\n    if (max(L.x,L.y) < 1.)  n++;               \\\n    else L = min( abs(p+l), abs(p-l) );        \\\n    if (min(L.x,L.y) > 1.) {                  //\n#define mainImage(O,u)                         \\\n    vec2 R = iResolution.xy, L,                \\\n\t     U = 1e2* (u+u-R)/R.y,                 \\\n         P = mod(iTime/vec2(1,2), 2.),         \\\n         l = 1e2* ( min(P,2.-P) - .5 ),        \\\n         p = vec2(-80,l.y*.7),                 \\\n       V[] = vec2[]( p,-p,l, R=vec2(15,45),R,vec2(15,12) );\\\n    B( 0, O.r )                                \\\n    B( 1, O.b )                                \\\n    B( 2, O.rg )                               \\\n    O++; }}}                                  /*\n\n\n\n\n\n// --- 340 chars\n\n//#define I(n) if (min(L.x,L.y)<1.) { O.n++; return; }\n#define B(i,n)                                 \\\n    l= V[3+i];                                 \\\n    L = abs( p = V[i]-U ) / l++;               \\\n    if (max(L.x,L.y) < 1.)  O.n++;             \\\n    else L = min( abs(p+l), abs(p-l) );        \\\n    if (min(L.x,L.y) < 1.) return;\n        \nvoid mainImage( out vec4 O,  vec2 u ) {\n    vec2 R = iResolution.xy, L,\n\t     U = 1e2* (u+u-R)/R.y,\n         P = mod(iTime/vec2(1,2), 2.),\n         l = 1e2* ( min(P,2.-P) - .5 ),\n         p = vec2(-80,l.y*.7),\n       V[] = vec2[]( p,-p,l, R=vec2(15,45),R,vec2(15,12) );\n    B( 0, r )\n    B( 1, b )\n    B( 2, rg )\n    O++;\n}  /*\n\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3tdXRr", "name": "Electric Red", "author": "tonywu", "description": "for test", "tags": ["test"], "likes": 2, "viewed": 307, "published": 3, "date": "1580301368", "time_retrieved": "2024-07-30T21:27:37.508587", "image_code": "const int AMOUNT = 60;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 20. * (fragCoord-iResolution.xy/2.) / min(iResolution.x, iResolution.y);\n\n    float len;\n    // the sound texture is 512x2\n    //int tx = int(uv.x*512.0);\n    int tx = 3;\n     \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    \n    for(int i=0; i<AMOUNT; i++){\n    \tlen = length(vec2(uv.x, uv.y));\n        uv.x = uv.x - cos(uv.y + sin(len*fft)) + cos(iTime / 10.0);\n        uv.y = uv.y + sin(uv.x + cos(len*fft)) + sin(iTime / 10.0);\n    }\n    vec3 col = vec3(cos(len*2.),0,0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdXRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 724]], "test": "untested"}
{"id": "3ttXRr", "name": "music color water", "author": "tonywu", "description": "color", "tags": ["fft"], "likes": 3, "viewed": 354, "published": 3, "date": "1580300182", "time_retrieved": "2024-07-30T21:27:38.403195", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 6. * fragCoord/iResolution.xy;\n    \n        // the sound texture is 512x2\n    //int tx = int(uv.x*512.0);\n    int tx = 1;\n     \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    for(int n=1; n<8; n++){\n    \n        float i = float(n);\n        uv += vec2(.7 / i * sin(fft * i *uv.y + iTime*5. + 0.3 *i)+0.8, 0.4 / i * sin(uv.x*0.5 +iTime +0.3 * i *fft) +1.6);\n        \n    }\n    \n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 col = vec3(0.5 * sin(uv.x) +0.5, 0.5*sin(uv.y) + 0.5, sin(uv.x + uv.y)+0.5+wave);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttXRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 970]], "test": "untested"}
{"id": "3ltSzn", "name": "Sin and Cos", "author": "tonywu", "description": "just for test", "tags": ["sound"], "likes": 3, "viewed": 289, "published": 3, "date": "1580291616", "time_retrieved": "2024-07-30T21:27:39.285835", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n        // the sound texture is 512x2\n    //int tx = int(uv.x*512.0);\n    int tx = 1;\n     \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    \n    col += sin(uv.x * cos(iTime/30.*fft/20.) * 60.) + sin(uv.y * cos(iTime / 20.) * 18.);\n\n    col += cos(uv.x* sin(iTime/60.) * 60.) + cos(uv.y * sin(iTime / 10.*wave) * 18. * fft);\n    \n    //col *= sin(iTime / 30.);\n    \n    col += mix(col,(cos(iMouse.yxy+vec3(0,2,4))),uv.y);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 951]], "test": "untested"}
{"id": "WttSzn", "name": "Psychedelic Spheres", "author": "kstyler", "description": "Practicing phong shading by making spheres that morph together with other spheres.", "tags": ["phong", "raymarch", "spheres"], "likes": 2, "viewed": 319, "published": 3, "date": "1580291549", "time_retrieved": "2024-07-30T21:27:40.148528", "image_code": "const int MAXD = 400;\nconst float EPSI  =0.0001;\nint matId = 0;\nmat2 rotate(float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat sm( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p,float size){\n    return length(p)-size;\n}\n\nfloat map(vec3 p,bool id){\n    float smo = 2.;\n    float sphere = sdSphere(p,1.);\n    float sphere2 = sdSphere(p+vec3(sin(iTime)*2.,sin(iTime)*2.,sin(iTime)*2.),0.4);\n    float sphere3 = sdSphere(p+vec3(sin(iTime)*2.,sin(iTime)*2.,cos(iTime)*4.),0.4);\n    float sphere4 = sdSphere(p+vec3(sin(iTime)*2.,cos(iTime)*4.,sin(iTime)*2.),0.4);\n    float sphere5 = sdSphere(p+vec3(sin(iTime)*2.,cos(iTime)*4.,cos(iTime)*4.),0.4);\n    float sphere6 = sdSphere(p+vec3(cos(iTime)*4.,sin(iTime)*2.,sin(iTime)*2.),0.4);\n    float sphere7 = sdSphere(p+vec3(cos(iTime)*4.,sin(iTime)*2.,cos(iTime)*4.),0.4);\n    float sphere8 = sdSphere(p+vec3(cos(iTime)*4.,cos(iTime)*4.,sin(iTime)*2.),0.4);\n    float sphere9 = sdSphere(p+vec3(sin(iTime)*4.,sin(iTime)*4.,sin(iTime)*4.),0.4);\n    float sphere10 = sdSphere(p-vec3(sin(iTime)*2.,sin(iTime)*2.,sin(iTime)*2.),0.4);\n    float sphere11 = sdSphere(p-vec3(sin(iTime)*2.,sin(iTime)*2.,cos(iTime)*4.),0.4);\n    float sphere12 = sdSphere(p-vec3(sin(iTime)*2.,cos(iTime)*4.,sin(iTime)*2.),0.4);\n    float sphere13 = sdSphere(p-vec3(sin(iTime)*2.,cos(iTime)*4.,cos(iTime)*4.),0.4);\n    float sphere14 = sdSphere(p-vec3(cos(iTime)*4.,sin(iTime)*2.,sin(iTime)*2.),0.4);\n    float sphere15 = sdSphere(p-vec3(cos(iTime)*4.,sin(iTime)*2.,cos(iTime)*4.),0.4);\n    float sphere16 = sdSphere(p-vec3(cos(iTime)*4.,cos(iTime)*4.,sin(iTime)*2.),0.4);\n    float sphere17 = sdSphere(p-vec3(sin(iTime)*4.,sin(iTime)*4.,sin(iTime)*4.),0.4);\n    \n\n    float plane =1.-(length(p)-550.);\n    float sp = sm(sphere9,sm(sphere8,sm(sphere7,sm(sphere6,sm(sphere5,sm(sphere4,sm(sphere3,sm(sphere2,min(sphere,plane),smo),smo),smo),smo),smo),smo),smo),smo);\n    float sp2 = sm(sphere17,sm(sphere16,sm(sphere15,sm(sphere14,sm(sphere13,sm(sphere12,sm(sphere11,sm(sphere10,min(sphere,plane),smo),smo),smo),smo),smo),smo),smo),smo);\n    float mn = min(sp,sp2);\n    if(id){\n       \n        if(mn == plane){\n            matId = 3;\n        }\n        else{\n            matId = 2;\n        }\n    }\n    return  mn;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(EPSI,0);\n    return normalize(vec3(map(p+e.xyy,false)-map(p-e.xyy,false),\n                            map(p+e.yxy,false)-map(p-e.yxy,false),\n                            map(p+e.yyx,false)-map(p-e.yyx,false)));\n}\nvec3 rayMarch(vec3 ro,vec3 rd, bool id){\n    \n    float tot = 0.;\n    float dst = 0.;\n    vec3 p;\n    for(int i = 0; i<MAXD; i++){\n        p = ro+rd*tot;\n        dst = map(p,id);\n        tot+=dst;\n        if(dst<EPSI || tot > float(MAXD)){\n            break;\n        }\n    }\n    if(dst > EPSI){\n       // matId = 1;\n    }\n    return p;\n}\nvec3 light(vec3 p,vec3 ro){\n    vec3 lightCol = vec3(1);\n    vec3 objCol = vec3(0);\n    vec3 lightPos = vec3(10,10,12);\n    vec3 viewDir = normalize(ro-p);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = normal(p);\n    vec3 reflectDir = reflect(-l,n);\n    float diff = max(dot(l,n),0.);\n    float spec = pow(max(dot(viewDir,reflectDir),0.),25.);\n    float spcStr = 3.;    \n    float ambi = 0.45;\n    \n\n    \n    bool rm = length(rayMarch(p+n*EPSI*2.,l,false))<length(lightPos-p);\n    if(rm){\n        diff *= 0.1;\n    }\n    if(matId == 2){\n        objCol = vec3(1,0.9,0.);\n    }\n    \n    else if(matId == 3){\n    \n        objCol = vec3(0,0,0);\n    }\n    vec3 diffuse = lightCol*diff;\n    vec3 ambient = ambi*lightCol;    \n    vec3 specular = spcStr*spec*lightCol;\n    return (ambient+diffuse+specular)*objCol;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy-0.5 * iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0,0,-20);\n    vec3 rd = normalize(vec3(uv,1.));\n    ro.zy*=rotate(iTime*2.);\n    rd.zy*=rotate(iTime*2.);\n    ro.xz*=rotate(iTime);\n    rd.xz*=rotate(iTime);\n    \n    vec3 p = rayMarch(ro,rd,true);\n    vec3 color = (light(p,ro));\n    if(matId == 1){\n        color = vec3(0);\n    }\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 85, 85, 151], [153, 153, 194, 194, 293], [295, 295, 329, 329, 358], [360, 360, 386, 386, 2363], [2365, 2365, 2385, 2385, 2615], [2616, 2616, 2656, 2656, 2953], [2954, 2954, 2981, 2981, 3766], [3770, 3770, 3824, 3824, 4224]], "test": "untested"}
{"id": "WltXRn", "name": "String Field", "author": "scottdarby", "description": "Quantum String Field", "tags": ["stringtheory"], "likes": 5, "viewed": 405, "published": 3, "date": "1580288972", "time_retrieved": "2024-07-30T21:27:40.969334", "image_code": "// lots of inspiration from IQ and hg_sdf\n\nconst float PI = 3.14159265359;\nconst int MAX_MARCHING_STEPS = 50;\nconst float EPSILON = 0.0001;\n\nvec2 rotate2d(vec2 v, float a) {\n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a)); \n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat opTwist( vec3 p, float fftValue, float time ) {\n    float c = cos((fftValue*1.5) *p.y);\n    float s = sin((fftValue+0.25)*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m * p.xz, p.y);\n    \n    return sdTorus(q, vec2(abs(sin(iTime*0.1))+0.5*(fftValue*0.03), fftValue*0.0001));\n\n}\n\nfloat opRep( vec3 p, vec3 c ) {\n            \n    float idx = mod((floor((p.x)/c.x)), 32.0);\n    float idy = mod((floor((p.y)/c.y)), 32.0);\n    float idz = mod((floor((p.z)/c.z)), 32.0);\n    \n\tfloat id = length(vec3(idx, idy, idz));\n    \n    vec3 q = mod(p, c) - 0.5 * c;\n\n    vec3 r = q;  \n    \n    float rotationAmount = (id * 5.0) + (iTime * 2.0);\n   \n    bool xmod2 = mod(idx, 2.0) == 0.0;\n    \n    // offset even rows\n    if (xmod2) {\n    \tq.y += 1.5;\n        r.y -= 1.5;\n    }\n    \n\tpR(q.xy, rotationAmount);\n    pR(q.xz, rotationAmount * 0.1);\n    \n    float shape1 = opTwist(q, 1.0, iTime);\n    \n    if (xmod2) {\n    \n        pR(r.xy, rotationAmount);\n        pR(r.xz, rotationAmount * 0.1);\n        \n        float shape2 = opTwist(r, 1.0, iTime);\n        \n    \treturn min(shape1, shape2);\n        \n    } else {\n        \n        return shape1;\n        \n    }\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n\treturn opRep(samplePoint, vec3(3.0, 3.0, 3.0));\n}\n\nvec3 castRay(vec3 pos, vec3 dir) {\n\tfor (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n\t\tfloat dist = sceneSDF(pos);\n        if (dist < EPSILON) {\n\t\t\treturn pos;\n        }\n\t\tpos += dist * dir;\n\t}    \n\treturn pos;\n}\n\n\nfloat lightPointDiffuse(vec3 pos, vec3 lightPos) {\n\tfloat lightDist = length(lightPos - pos);\n\tfloat color = 3.0 / (lightDist * lightDist);\n\treturn max(0.0, color*10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec4 mousePos = (iMouse / iResolution.xyxy) * 2.0 - 1.0;\n    \n\tmousePos *= vec2(PI / 2.0, PI / 2.0).xyxy;\n    \n    if (iMouse.zw == vec2(0.0)) {\n        mousePos.xy = vec2(0.5, -0.2); \n    }\n\t\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\t\n\tvec3 cameraPos = vec3(0.0, 0.0, -8.0);\n\t\n\tvec3 cameraDir = vec3(0.0, 0.0, 1.0);\n\tvec3 planeU = vec3(2.0, 0.0, 0.0);\n\tvec3 planeV = vec3(0.0, iResolution.y / iResolution.x * 2.0, 0.0);\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n\t\n\tcameraPos.yz = rotate2d(cameraPos.yz, mousePos.y);\n\trayDir.yz = rotate2d(rayDir.yz, mousePos.y);\n\t\n\tcameraPos.xz = rotate2d(cameraPos.xz, mousePos.x);\n\trayDir.xz = rotate2d(rayDir.xz, mousePos.x);\n    \n    cameraPos.zy += iTime;\n\t\n\tvec3 rayPos = castRay(cameraPos, rayDir);\n\t\n    // base color\n\tvec3 color = vec3(0.0);\n    \n   \n    color += lightPointDiffuse(rayPos, cameraPos) * 9.0;\n    \n    color = pow(color, vec3(0.5));\n    \n    float contrast = 0.5;\n    \n    color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;\n\n    float grey = color.r * 0.21 + color.g * 0.71 + color.b * 0.07;\n    \n\tfragColor = vec4(color, min(grey*0.1, 0.1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltXRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 173, 173, 248], [250, 397, 429, 429, 471], [473, 473, 506, 506, 569], [571, 571, 624, 624, 864], [866, 866, 897, 897, 1733], [1736, 1736, 1770, 1770, 1821], [1823, 1823, 1857, 1857, 2033], [2036, 2036, 2086, 2086, 2207], [2209, 2209, 2266, 2266, 3443]], "test": "untested"}
{"id": "WldSRn", "name": "002-Blue", "author": "haquxx", "description": "Raymarching", "tags": ["cineshader"], "likes": 75, "viewed": 49340, "published": 3, "date": "1580288662", "time_retrieved": "2024-07-30T21:27:41.842000", "image_code": "float sdSphere(vec3 pos, float size)\n{\n    return length(pos) - size;\n}\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n    pos = abs(pos) - vec3(size);\n    return max(max(pos.x, pos.y), pos.z);\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdPlane(vec3 pos)\n{\n    return pos.y;\n}\n\nmat2 rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 repeat(vec3 pos, vec3 span)\n{\n    return abs(mod(pos, span)) - span * 0.5;\n}\n\nfloat getDistance(vec3 pos, vec2 uv)\n{\n    vec3 originalPos = pos;\n\n    for(int i = 0; i < 3; i++)\n    {\n        pos = abs(pos) - 4.5;\n        pos.xz *= rotate(1.0);\n        pos.yz *= rotate(1.0);\n    }\n\n    pos = repeat(pos, vec3(4.0));\n\n    float d0 = abs(originalPos.x) - 0.1;\n    float d1 = sdBox(pos, vec3(0.8));\n\n    pos.xy *= rotate(mix(1.0, 2.0, abs(sin(iTime))));\n    float size = mix(1.1, 1.3, (abs(uv.y) * abs(uv.x)));\n    float d2 = sdSphere(pos, size);\n    float dd2 = sdOctahedron(pos, 1.8);\n    float ddd2 = mix(d2, dd2, abs(sin(iTime)));\n  \n    return max(max(d1, -ddd2), -d0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // camera\n    vec3 cameraOrigin = vec3(0.0, 0.0, -10.0 + iTime * 4.0);\n    vec3 cameraTarget = vec3(cos(iTime) + sin(iTime / 2.0) * 10.0, exp(sin(iTime)) * 2.0, 3.0 + iTime * 4.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    vec3 rayDirection = normalize(cameraRight * p.x + cameraUp * p.y + cameraDir);\n    \n    float depth = 0.0;\n    float ac = 0.0;\n    vec3 rayPos = vec3(0.0);\n    float d = 0.0;\n\n    for(int i = 0; i < 80; i++)\n    {\n        rayPos = cameraOrigin + rayDirection * depth;\n        d = getDistance(rayPos, p);\n\n        if(abs(d) < 0.0001)\n        {\n            break;\n        }\n\n        ac += exp(-d * mix(5.0, 10.0, abs(sin(iTime))));        \n        depth += d;\n    }\n    \n    vec3 col = vec3(0.0, 0.3, 0.7);\n    ac *= 1.2 * (iResolution.x/iResolution.y - abs(p.x)) ;\n    vec3 finalCol = col * ac * 0.06;\n    fragColor = vec4(finalCol, 1.0);\n    fragColor.w = 1.0 - depth * 0.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 71], [73, 73, 107, 107, 184], [186, 186, 223, 223, 521], [523, 523, 548, 548, 568], [570, 570, 592, 592, 668], [670, 670, 704, 704, 751], [753, 753, 791, 791, 1348], [1350, 1350, 1407, 1407, 2586]], "test": "untested"}
{"id": "3tdSRn", "name": "001-DrawCircle", "author": "haquxx", "description": "Draw circle", "tags": ["cineshader"], "likes": 67, "viewed": 30123, "published": 3, "date": "1580288217", "time_retrieved": "2024-07-30T21:27:42.825372", "image_code": "vec3 drawCircle(vec2 pos, float radius, float width, float power, vec4 color)\n{\n    vec2 mousePos = iMouse.xy - vec2(0.5);\n    float dist1 = length(pos);\n    dist1 = fract((dist1 * 5.0) - fract(iTime));\n    float dist2 = dist1 - radius;\n    float intensity = pow(radius / abs(dist2), width); \n    vec3 col = color.rgb * intensity * power * max((0.8- abs(dist2)), 0.0);\n    return col;\n}\n\nvec3 hsv2rgb(float h, float s, float v)\n{\n    vec4 t = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // // -1.0 ~ 1.0\n    vec2 pos = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float h = mix(0.5, 0.65, length(pos));\n    vec4 color = vec4(hsv2rgb(h, 1.0, 1.0), 1.0);\n    float radius = 0.5;\n    float width = 0.8;\n    float power = 0.1;\n    vec3 finalColor = drawCircle(pos, radius, width, power, color);\n\n    pos = abs(pos);\n    // vec3 finalColor = vec3(pos.x, 0.0, pos.y);\n\n    fragColor = vec4(finalColor, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 79, 79, 386], [388, 388, 429, 429, 604], [606, 606, 663, 684, 1123]], "test": "untested"}
{"id": "3l3Szr", "name": "Lattice B -6b", "author": "soundmasteraj", "description": "original code by wyatt Title: Lattice Boltzmann", "tags": ["fluid"], "likes": 9, "viewed": 594, "published": 3, "date": "1580284878", "time_retrieved": "2024-07-30T21:27:43.964326", "image_code": "// Fork of \"Lattice B -6\" by soundmasteraj. https://shadertoy.com/view/Wt3Szr\n// 2020-01-28 22:56:54\n\n// Fork of \"Lattice B -5\" by soundmasteraj. https://shadertoy.com/view/WlcXRr\n// 2020-01-28 22:54:15\n\n// Fork of \"Lattice B -4\" by soundmasteraj. https://shadertoy.com/view/3l3XRr\n// 2020-01-28 22:46:51\n\n// Fork of \"Lattice B -3\" by soundmasteraj. https://shadertoy.com/view/WlcSRr\n// 2020-01-28 22:43:17\n\n// Fork of \"Lattice B -2\" by soundmasteraj. https://shadertoy.com/view/WlcXzn\n// 2020-01-28 22:31:42\n\n// Fork of \"Lattice B Tests\" by soundmasteraj. https://shadertoy.com/view/wlKGDd\n// 2020-01-28 21:56:18\n\n// LENS FLAIR EFFECT\n#define R iResolution.xy\n#define T(U) texture(iChannel0,(U)/R)\n#define D(U) texture(iChannel1,(U)/R)\nvec4 F (vec2 U,vec2 r) {\n\tvec4 t = T(U+r);\n    return exp(-.01*dot(r,r))*(exp(2.*t)-1.);\n}\nvoid mainImage( out vec4 Q, vec2 U )\n{\n   \n   Q = vec4(0);\n    for (float i = 0.; i < 8.; i+=1.1) {\n    \tQ += F(U,+vec2(-i,i));\n    \tQ += F(U,+vec2(i,i*.5));\n    \tQ += F(U,-vec2(-i,i));\n    \tQ += F(U,-vec2(i,i*.5));\n    } \n\n    Q = T(U)*0.15+ 1e-5*Q;\n    Q -= texture(iChannel2,D(U).xy/R)*.47;\n    //Q -= texture(iChannel2,(U-D(U).xy*.5)/iResolution.y)*.47;\n    Q = atan(Q);\n\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Lighting on Buffer B\n#define R iResolution.xy\n#define T(U) texture(iChannel0,(U)/R)\n\nvoid mainImage( out vec4 Q, vec2 U )\n{\n   Q =  1.2-2.2*T(U);\n    Q.xyz = Q.xyz+.5*normalize(Q.xyz);\n   float\n       n = length(T(U+vec2(0,1))),\n       e = length(T(U+vec2(1,0))),\n       s = length(T(U-vec2(0,1))),\n       w = length(T(U-vec2(1,0)));\n    vec3 no = normalize(vec3(e-w,n-s,1));\n    float d = dot(reflect(no,vec3(0,0,1)),normalize(vec3(1)));\n    Q *= 8.*exp(-3.*d*d);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// LOOK UP PICTURE IN LOCATION FROM BUFFER D\n#define R iResolution.xy\n#define T(U) texture(iChannel0,(U)/R)\n#define D(U) texture(iChannel1,(U)/R)\nvoid mainImage( out vec4 Q, vec2 U )\n{\n    Q = texture(iChannel2,D(U).xy/R);\n}", "buffer_b_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// TRANSLATE LOCATION FIELD WITH v(A(coord)), INIT WITH FragCoord\n#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define d(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\nvec2 v (vec4 b) {\n\treturn vec2(b.x-b.y,b.z-b.w);\n}\nvec4 D(vec2 U) {\n    U-=.5*v(A(U));\n    U-=.5*v(A(U));\n\treturn d(U);\n}\nvoid mainImage( out vec4 Q, in vec2  U)\n{\n    Q = D(U);\n    \n    float ptany = +atan(U.y);\n    float ntany = -ptany;\n    float pnamod = .25;\n    float ptanx = atan(U.x);\n    float ntanx = -ptanx;\n    float neg1 = .25;\n    float pmod =  .5;\n    float nmod = -.25;\n    \n    \n    vec4 \n        q = A(U),\n        \n        n = A(U+vec2(   ntany * pnamod * 0.          , ntany * nmod)),\n        \n        e = A(U+vec2(   ntanx * nmod               , ntanx * pnamod* 0. )),\n        \n        s = A(U-vec2(   ntany * pnamod * 0.          , ntany * nmod)),\n        \n        w = A(U-vec2(   ntanx * nmod               , ntanx * pnamod* 0. )),\n    \n        \n\n        N = A(U+vec2(   ntany * pnamod * 0.          , ntany * nmod)),\n        \n        E = A(U+vec2(   ntanx * nmod               , ntanx * pnamod* 0. )),\n        \n        S = A(U-vec2(   ntany * pnamod * 0.          , ntany * nmod)),\n        \n        W = A(U-vec2(   ntanx * nmod               , ntanx * pnamod* 0. ));\n    \n    Q += 0.25*((n.w-q.z)*(N-Q) + (e.y-q.x)*(E-Q) + (s.z-q.w)*(S-Q) + (w.x-q.y)*(W-Q));\n    \n    if (iFrame < 1||(iMouse.z>0.&&length(U-iMouse.xy)<R.y/5.)) Q = vec4(U,0,0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// FLUID EVOLUTION\n#define R iResolution.xy\n#define T(U) texture(iChannel0,(U)/R)\n#define D(U) texture(iChannel1,(U)/R)\n#define B(U) texture(iChannel2,(U)/R)\n// Velocity\nvec2 v (vec4 b) {\n\treturn vec2(b.x-b.y,b.z-b.w);\n}\n// Pressure\nfloat p (vec4 b) {\n\treturn 0.25001*(b.x+b.y+b.z+b.w);\n}\n// TRANSLATE COORD BY Velocity THEN LOOKUP STATE\nvec4 A(vec2 U) {\n    U-=.5*v(T(U));\n    U-=.5*v(T(U));\n\treturn T(U);\n}\nvoid mainImage( out vec4 Q, in vec2  U)\n{\n    // THIS PIXEL\n    Q = A(U);\n    // NEIGHBORHOOD\n    \n    float ptany = +atan(U.y);\n    float ntany = -ptany;\n    float pnamod = .25;\n    float ptanx = atan(U.x);\n    float ntanx = -ptanx;\n    float neg1 = .25;\n    float pmod = .5;\n    float nmod = .25;\n  \n    vec4 \n        \n        n = A(U+vec2(   ntany * pnamod * 0.          , ntany * nmod)),\n        \n        e = A(U+vec2(   ntanx * nmod               , ntanx * pnamod* 0. )),\n        \n        s = A(U-vec2(   ntany * pnamod * 0.          , ntany * nmod)),\n        \n        w = A(U-vec2(   ntanx * nmod               , ntanx * pnamod* 0. ));\n    \n    // GRADIENT of PRESSURE\n    float px = 0.25*(p(e)-p(w));\n    float py = 0.25*(p(n)-p(s)); \n    \n    \t\t// boundary Energy exchange in :   \n    Q += 0.25*(n.w + e.y + s.z + w.x)\n        \t// boundary Energy exchange out :\n        \t-p(Q)\n        \t// dV/dt = dP/dx,  dEnergy In dTime = dEnergy in dSpace\n        \t-vec4(px,-px,py,-py);\n    \n    // get value from picture buffer\n    float z = .8-length(B(U).xyz);\n    \n    // some kind of viscolsity thing \n    Q = mix(mix(Q,0.25*(n+e+s+w),.01),vec4(p(Q)),.01*(1.-z));\n    // gravity polarizes energy! pretty cool imo\n    Q.zw -=  0.001*z*vec2(1,-1);\n     // Q.zw -=  0.00051*z*vec2(1,-1);\n    // Init with no velocity and some pressure\n    if (iFrame < 1||(iMouse.z>0.&&length(U-iMouse.xy)<R.y/5.)) Q = vec4(.2);\n    // At boundarys turn all kinetic energy into potential energy\n    if(U.x<3.||R.x-U.x<3.||U.y<3.||R.y-U.y<3.)Q = vec4(p(Q));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3Szr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[737, 737, 761, 761, 827], [828, 828, 866, 866, 1205]], "test": "untested"}
{"id": "ttcSRr", "name": "Unko", "author": "ChoiChoi", "description": "Unko", "tags": ["unko"], "likes": 1, "viewed": 253, "published": 3, "date": "1580272391", "time_retrieved": "2024-07-30T21:27:44.906806", "image_code": "\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    r/=5.0;\n  float q1 = length(vec2(length(p.xz)-r,p.y+0.2)) - r;\n  float q2 = length(vec2(length(p.xz)-r,p.y+0.5)) - r-0.1;\n  float q3 = length(vec2(length(p.xz)-r,p.y+0.8)) - r-0.2;\n  \n\n  float q = length(vec2(p.x,p.z));\n // float q4 = p.y>2 ? dot(2,float2(q,p.y-1.2))<0.1 :100000000;\n\n  float q4 =0.0;\n    if(p.y>-0.1){\n        q4=dot(vec2(2.0,2.0),vec2(q,p.y))-0.1;\n    } else {\n        q4=10000000.0;\n    }\n\n  //return length(q1)<_Threshold || length(q2)<_Threshold-0.1|| length(q3)<_Threshold-0.2 || (dot(2,float2(q,p.y-1.2))<0.1 && p.y>0.8);\n\n  return min(q1, min(q2,min(q3,q4)));\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"うんこ\",\n\t\"description\": \"きれいなうんこです\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 53, 152], [154, 154, 189, 189, 780], [783, 783, 802, 802, 1138], [1140, 1140, 1170, 1170, 1452], [1454, 1454, 1511, 1511, 2229]], "test": "untested"}
{"id": "tl3SRr", "name": "o r a c l e", "author": "MrHenryBemis", "description": "wheel of causality", "tags": ["wheel"], "likes": 4, "viewed": 327, "published": 3, "date": "1580272098", "time_retrieved": "2024-07-30T21:27:45.656801", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 b = texture(iChannel0, uv);\n    fragColor = vec4(b.rgb, 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define PI 3.63559265359\n#define E 2.6352818284\n#define GR 6.35803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n#define time (sin(((sin(float(__LINE__))*GR/PI+GR/E)*iTime)))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n#define jitter ((tan(iTime)+iTime*10.0)/10.0)\n//#define iTime ((tan(iTime)+iTime*10.0)/10.0)\n#define iTime iTime*.5\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  c = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  d = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, c.yyy) );\n  vec3 x0 =   v - i + dot(i, c.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + c.xxx;\n  vec3 x2 = x0 - i2 + c.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - d.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * d.wyz - d.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv0 = uv;\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float count = 16.0-cos(iTime/GR)*12.0;\n    \n\tfloat sum = 0.;\n    float border = 1.;\n    \n    float bordered = smoothstep(0.4, 0.6, saw(time*E));\n    \n    for(float i = 0.0; i < 100.0; i+=1.0)\n    {\n        if(i > count)\n            break;\n        \n        float theta = float(i)/float(count)*PI*2.0+iTime;\n        vec2 p1 = vec2(cos(theta), sin(theta))*.75;\n        \n        float radialCount = 8.0-cos(iTime/PI)*4.0;\n        \n        for(float j = 0.0; j < 100.0; j+=1.0)\n        {\n        \tfloat theta2 = float(j)/float(radialCount)*PI*2.0-time*2.0;\n            vec2 p2 = p1+vec2(cos(theta2), sin(theta2));\n\n            if(j > radialCount)\n                break;\n            \n            float d = \n                    (p2.y-p1.y)*uv.x-\n                    (p2.x-p1.x)*uv.y+\n                    p2.x*p1.y-p2.y*p1.x/\n                    length(p2-p1);\n            float maxd = .01;\n            \n            float vd = abs(d);\n            \n            if(vd < maxd)\n            {\n                float value = ((length(p1-uv)));\n                sum += value*(border)*(1.-bordered)+bordered*value;\n                border *= vd/maxd*(1.-vd/maxd);\n            }\n        }\n    }\n    float b = clamp((1.-border),0., 1.);\n    fragColor = vec4((cos(iTime*PI+sum*GR+vec3(0., 4.*PI/3.,2.*PI/3.))*.5+.5), 1.0)\n        *b+(1.-b)*texture(iChannel0, uv0)-1./64.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 a = texture(iChannel0, uv);\n    fragColor = a;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3SRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 172]], "test": "untested"}
{"id": "wt3SRn", "name": "Fading Boardwalk", "author": "timeisbeautifulhere", "description": "An early concept for something", "tags": ["lines", "fade", "scrolling"], "likes": 1, "viewed": 307, "published": 3, "date": "1580257449", "time_retrieved": "2024-07-30T21:27:46.411782", "image_code": "\nconst float LINE_WIDTH = 0.05;\nconst float LINE_SPACING = 0.1;\nconst float LINE_VELOCITY = 0.2;\n\n/**\nCheck if coordinate is in the series of moving\nlines. Expects the coordinate to be normalized [0,1]\n*/\nbool isInScrollingLines(vec2 coord){\n    float halfwidth = LINE_WIDTH/2.0;\n    float offset = mod(iTime * LINE_VELOCITY, LINE_SPACING);\n    \n    for(float pos = 0.0 - offset; pos <= 1.0 + LINE_WIDTH; pos=pos+LINE_SPACING){\n        if(coord.x > (pos-halfwidth) && coord.x < (pos+halfwidth)){\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    if(isInScrollingLines(uv))\n        col = vec3(0.0);\n    else{\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        \n        float bgOpacity = (sin(iTime) + 1.0) / 2.0;\n        col = col * bgOpacity;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3SRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 205, 241, 241, 561], [563, 563, 620, 670, 1061]], "test": "untested"}
{"id": "Wl3Xzr", "name": "ikeryou circles", "author": "ikeryou", "description": "many circles", "tags": ["circle"], "likes": 1, "viewed": 367, "published": 3, "date": "1580255134", "time_retrieved": "2024-07-30T21:27:47.158785", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * d * 35.0 - iTime * 13.0;\n \n    \n    // Calculate the ripple thickness\n    d = (sin(t * 0.1) * cos(t * 2.1) * 0.5 + 0.5) * (1.0 - d);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\tcol.rgb = vec3(pow(col.r, 20.0) + 0.2);\n    // Set the output color to rgb channels and the thickness to alpha channel\n    // AO is automatically calculated\n    fragColor = vec4(col, d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3Xzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 724]], "test": "untested"}
{"id": "Wl3SRr", "name": "Halftone Noise", "author": "liamegan", "description": "Points in space", "tags": ["halftone", "noisegrid"], "likes": 9, "viewed": 534, "published": 3, "date": "1580249495", "time_retrieved": "2024-07-30T21:27:48.003526", "image_code": "\n  vec2 getScreenSpace() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    return uv;\n  }\n\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = getScreenSpace();\n    \n    float w = 30./iResolution.y;\n    \n    uv *= 30.;\n    vec2 grid = floor(uv);\n    vec2 subuv = fract(uv);\n    \n    vec3 colour = vec3(0);\n    float d = 0.;\n    \n    for(int x = -1; x < 2; x++) {\n      \n      for(int y = -1; y < 2; y++) {\n        vec2 os = vec2(x,y);\n        vec2 _grid = grid + os;\n        vec2 _subuv = subuv - os;\n        \n        float r = snoise(_grid*.1 + iTime*.5)*.2+.3;\n          d = r;\n        colour += vec3(smoothstep( r+w, r-w, length(_subuv-.5) ));\n      }\n      \n    }\n    \n\n    fragColor = vec4(colour, mix(0., d, colour.x));\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Dot Grid\",\n\t\"description\": \"Points in space\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3SRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 26, 26, 142], [144, 144, 166, 166, 205], [207, 207, 228, 228, 1048], [1050, 1050, 1107, 1107, 1711]], "test": "untested"}
{"id": "XtsyRs", "name": "The Death of Phantom Wood", "author": "TheGrego", "description": "A phantom tree glows and screams when sliced open.", "tags": ["2d", "wood"], "likes": 2, "viewed": 418, "published": 3, "date": "1580248168", "time_retrieved": "2024-07-30T21:27:48.875196", "image_code": "#define BANDING 10.0\n#define rot(a)  mat2( cos(a), sin(a),  -sin(a), cos(a) )\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 tc = uv;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv *= rot(iTime * 0.1 + length(uv * ( (uv.x - 1.0) * 2.0)));\n    \n    \n    float n = texture(iChannel0, vec2( 0.01, uv.y * 0.4)).r;\n    float b = BANDING;// * length(uv * 100.0);\n    float val = round(fract(n) * b) / b;\n    vec3 col = vec3(val);\n    col.r *= 2.0 - uv.y;\n    col.g *= 0.8 - uv.y;\n    col.b *= 1.2 + uv.x;\n    \n    //vec2 pos = vec2( smoothstep( 0.0, 1.0, fract(iTime * 0.5) ), 0.5);\n    \n    // with noise\n    //float p = texture(iChannel0, (tc * uv) * 0.05).r;\n    //vec2 pos = vec2( sin(iTime * 0.5 + p) * 2.0, cos(iTime - p) * 10.0);\n    \n    float p = texture(iChannel0, (tc * uv) * 0.01).r;\n    vec2 pos = vec2( sin(iTime * 0.5) * 2.0 + cos(iTime*0.5 + length(uv)) * 2.0, \n                    cos(iTime*0.4) * 2.0 + p);\n    //vec3 circ = vec3(length((uv - pos) * 2.0));\n    vec3 circ = vec3(max(-0.75, 1.0 - min (length(uv - pos), 2.5)));\n    circ *= dot(uv, vec2(0.0, 1.0));\n    col += circ;\n   \t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 137, 137, 1180]], "test": "untested"}
{"id": "3lK3Wd", "name": "BufATexLoad from static data", "author": "BrunoLevy", "description": "Loading a texture in buffer A from big static array transformed into function. \n(Testing a way to load a big array)\nSome inspiration from: https://www.shadertoy.com/view/tlX3W7\n", "tags": ["texture"], "likes": 15, "viewed": 1172, "published": 3, "date": "1580245778", "time_retrieved": "2024-07-30T21:27:51.783420", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) { \n    ivec2 uv = ivec2(fragCoord);\n    vec4 col = vec4(texelFetch(iChannel0, uv, 0 ));\n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#pragma optimize(off)\n\n\n// #define USE_ARRAY \n// #define HIRES\n\n#ifdef HIRES\nconst int image_width = 128;\nconst int image_height = 128;\nconst int pixel_data_size = 4096;\n\n#ifdef USE_ARRAY\nconst ivec4 pixel_data_array[4096] = ivec4[](\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdfbff,0x00fff9ff,0x00fffff9,0x00fffff2),  ivec4(0x00fffdff,0x00fdfdfd,0x00f1f9fd,0x00dfdbff),\n  ivec4(0x00392cce,0x001c10ea,0x001b0dfd,0x001b11ff),  ivec4(0x00110efe,0x001216fa,0x001619f5,0x001916f9),  ivec4(0x001a13fd,0x001913fb,0x001711f8,0x001611f5),  ivec4(0x001711f1,0x00140feb,0x00120de5,0x000f0be1),\n  ivec4(0x001009e4,0x001107ea,0x003b1fb0,0x00d05215),  ivec4(0x00ca5112,0x00d15b05,0x00d94f1a,0x00d84f1b),  ivec4(0x00e74e16,0x00d05417,0x00aa591c,0x00c05320),  ivec4(0x00ea4c1e,0x00e04f18,0x00ca5719,0x00ab4811),\n  ivec4(0x00772d05,0x00913d32,0x0084375e,0x00642c94),  ivec4(0x004322c9,0x002b1fe8,0x00191bf4,0x00151af8),  ivec4(0x001b19f8,0x002015f9,0x001d13fa,0x00190ffa),  ivec4(0x00150dfb,0x00120dfd,0x00100dfc,0x00110af9),\n  ivec4(0x001109f7,0x000f0fea,0x000f14da,0x000f10d8),  ivec4(0x00110ed6,0x00130cd3,0x001609cd,0x001708c7),  ivec4(0x001907c1,0x001f09b5,0x00411397,0x006f1f6a),  ivec4(0x00873636,0x009c4614,0x00ae4608,0x00a24a12),\n  ivec4(0x0092401a,0x00a83d21,0x009e3f17,0x00993f16),  ivec4(0x00943e15,0x00913d15,0x00943e18,0x00923814),  ivec4(0x00943110,0x0095300e,0x00803a13,0x0055222d),  ivec4(0x000d0363,0x000a0066,0x0004015c,0x0000006b),\n  ivec4(0x00030163,0x00190066,0x000d006e,0x00060072),  ivec4(0x0007007a,0x00060081,0x00050087,0x0004008a),  ivec4(0x0004008e,0x0005018f,0x00040492,0x00050395),  ivec4(0x000b039e,0x00000087,0x00928ed2,0x00f0f3ff),\n  ivec4(0x00f5f9f6,0x00fefcfc,0x00fffcff,0x00fffffe),  ivec4(0x00fffffe,0x00fffffe,0x00fffffe,0x00ffffff),  ivec4(0x00ffffff,0x00fffeff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdfffe,0x00fefefe,0x00fefffd,0x00fffffb),  ivec4(0x00fffdff,0x00fcf6ff,0x00f5f0fa,0x00fcfcfc),\n  ivec4(0x00cacbfe,0x000000c8,0x001f13ef,0x001407fc),  ivec4(0x00150fff,0x001115f9,0x001517f5,0x001914fc),  ivec4(0x001a13fe,0x001914fa,0x001812f8,0x001711f6),  ivec4(0x001811f4,0x001611f0,0x00130de9,0x00100be3),\n  ivec4(0x001209e2,0x001107e4,0x00271cb9,0x00cb5215),  ivec4(0x00d04e1a,0x00d6560d,0x00db4a23,0x00c94f20),  ivec4(0x00d85119,0x00dc4f1d,0x00c2541d,0x00c85617),  ivec4(0x00ca5912,0x00bd5a11,0x00ce511b,0x00b83e27),\n  ivec4(0x00431408,0x0043289d,0x003a25d1,0x00271dee),  ivec4(0x001013fe,0x000a13ff,0x000b13ff,0x001613fd),  ivec4(0x002013f7,0x001c14f9,0x001714fb,0x001412fd),  ivec4(0x001211fe,0x000d0ffc,0x000f0ef9,0x00100ef7),\n  ivec4(0x00120ef5,0x00130fef,0x001311e9,0x00110fe7),  ivec4(0x00110de6,0x00100ce3,0x000d0bdd,0x000b0bd7),  ivec4(0x00080ad0,0x00060bcc,0x00080ac7,0x002f09b7),  ivec4(0x00321891,0x004b2b57,0x009b3a2a,0x00b64514),\n  ivec4(0x00a34012,0x00ac3d1e,0x00a83d16,0x00a33c16),  ivec4(0x009c3a13,0x00943813,0x008c3614,0x007d2f0f),  ivec4(0x006e290b,0x0067250a,0x00632616,0x00471732),  ivec4(0x000a0562,0x0003055c,0x00010557,0x00000071),\n  ivec4(0x00090069,0x00060361,0x0003016c,0x00070073),  ivec4(0x0007007b,0x00070084,0x00060089,0x0005008d),  ivec4(0x0004008f,0x0006028f,0x00000092,0x0006099f),  ivec4(0x00000087,0x006f6cb0,0x00f6f3fe,0x00f7f7fb),\n  ivec4(0x00fffff8,0x00fdfdf8,0x00f9f8f8,0x00fffeff),  ivec4(0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff),  ivec4(0x00fffeff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fefffc,0x00fefffb,0x00fefdff,0x00fefdff),  ivec4(0x00fefefd,0x00fefaff,0x00fdf3ff,0x00fffff6),\n  ivec4(0x00f2f6ff,0x00c1befd,0x000000c5,0x001e14f6),  ivec4(0x00100efc,0x00090dfd,0x001315fd,0x001816f9),  ivec4(0x001a17f5,0x001913fd,0x001814f7,0x001715f0),  ivec4(0x001814ee,0x001812f1,0x00140cf1,0x001107ee),\n  ivec4(0x001505ec,0x001d05e0,0x00271ab7,0x00c34a28),  ivec4(0x00d04925,0x00df5212,0x00d74f1e,0x00c35519),  ivec4(0x00c95319,0x00e04f1a,0x00df5116,0x00db5314),  ivec4(0x00d4590b,0x00c85711,0x00d94c1f,0x00c5412e),\n  ivec4(0x00190327,0x001e19d8,0x001815fe,0x001212ff),  ivec4(0x001010fe,0x000f12ff,0x001213fd,0x001612fe),  ivec4(0x001c0fff,0x001912fa,0x001713f6,0x001412f5),  ivec4(0x00120ff6,0x001210f7,0x001210f6,0x00120ff4),\n  ivec4(0x00130ef2,0x00110bf3,0x000b09f4,0x000b08f3),  ivec4(0x000b07f0,0x000c07ee,0x000e09e9,0x000c0ae2),  ivec4(0x000b0bdc,0x00060dd7,0x00010fd0,0x000e08cf),  ivec4(0x000408bb,0x0022117e,0x008c3143,0x00b4401b),\n  ivec4(0x00a7410e,0x00a54310,0x008d3f14,0x00853911),  ivec4(0x007c3209,0x00742c06,0x006e2a06,0x00642505),  ivec4(0x005b2205,0x00582106,0x00571f0f,0x0034123d),  ivec4(0x000a065d,0x000a045b,0x0005015e,0x0000006b),\n  ivec4(0x0008006b,0x00000466,0x00010171,0x00050079),  ivec4(0x0008007e,0x00090084,0x00080186,0x00040087),  ivec4(0x0003028d,0x00070795,0x00030297,0x0000008a),  ivec4(0x00515299,0x00f1f5fd,0x00fefeff,0x00fefdfd),\n  ivec4(0x00fefcfb,0x00fdfffb,0x00fefffc,0x00fffeff),  ivec4(0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff),  ivec4(0x00fffeff,0x00ffffff,0x00fffffe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00fffeff,0x00ffffff),\n  ivec4(0x00fffefb,0x00f8f6ff,0x00bab9f8,0x000000cf),  ivec4(0x00110cfd,0x001311ff,0x000a07fe,0x001313f5),  ivec4(0x001815f7,0x00170fff,0x001613f8,0x001716ef),  ivec4(0x001715ed,0x001813f3,0x00150df4,0x001208f3),\n  ivec4(0x001207ef,0x001106e7,0x001d1ab5,0x00af433f),  ivec4(0x00cb4928,0x00dc530d,0x00ca5a0f,0x00ce5710),  ivec4(0x00d94d1e,0x00d75018,0x00d55314,0x00c6521c),  ivec4(0x00d65510,0x00d35118,0x00d1521f,0x00b9481c),\n  ivec4(0x00160031,0x00211be3,0x001412f9,0x001613f9),  ivec4(0x001511f9,0x001512fd,0x00140fff,0x00110dff),  ivec4(0x00110aff,0x00130ffd,0x001310f9,0x001310fa),  ivec4(0x00110ff9,0x000f0cf7,0x000e0bf6,0x000d0af6),\n  ivec4(0x000d0af6,0x000b0cf1,0x00080dec,0x000a0cee),  ivec4(0x000a08eb,0x000b07e7,0x000f08e4,0x00160ce2),  ivec4(0x00160cda,0x00110bd4,0x00080cc3,0x000c07a5),  ivec4(0x0002038c,0x00160357,0x00783436,0x008d391c),\n  ivec4(0x00853414,0x008e3407,0x00672b09,0x00622808),  ivec4(0x005e2506,0x00592204,0x005a2208,0x00592209),  ivec4(0x0055220b,0x00542008,0x005a2306,0x00210d4c),  ivec4(0x0005075a,0x000f005e,0x0005006b,0x00000364),\n  ivec4(0x0005006d,0x00050071,0x00020174,0x0004007a),  ivec4(0x00060084,0x00070087,0x000b0588,0x000d0b88),  ivec4(0x00020289,0x0002058f,0x0000008b,0x00433e92),  ivec4(0x00eaeffb,0x00f8fffd,0x00fefef9,0x00fffdff),\n  ivec4(0x00fffbff,0x00fdffff,0x00fbfffb,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffaff,0x00fdfaff,0x00e7f2fc,0x00b2baf2),  ivec4(0x000000d8,0x001b0dff,0x00120ffa,0x001311fd),  ivec4(0x00140dff,0x00120ffe,0x00140eff,0x00140efb),  ivec4(0x001610fa,0x001511f7,0x001512ec,0x001313e1),\n  ivec4(0x001312df,0x001108e9,0x001e19ba,0x00a64149),  ivec4(0x00cb4a27,0x00da520f,0x00ca5810,0x00d25612),  ivec4(0x00d74e1e,0x00d75118,0x00d45314,0x00c4521b),  ivec4(0x00d65510,0x00d15016,0x00d0521f,0x00ba491d),\n  ivec4(0x00190033,0x00211cdc,0x001512f5,0x001611f9),  ivec4(0x00150ffc,0x00160eff,0x00150dff,0x00140cfe),  ivec4(0x00140cfe,0x000f09ff,0x000d0aff,0x000d09ff),  ivec4(0x000c08ff,0x000e09ff,0x000f0bfe,0x000d0afa),\n  ivec4(0x000d09f7,0x000c07f2,0x000f05f0,0x001208ef),  ivec4(0x00160aeb,0x00180de2,0x001b0fd9,0x00160cc9),  ivec4(0x000d04b7,0x000601a8,0x0000018a,0x00030073),  ivec4(0x00000067,0x00100240,0x005d261f,0x0068290d),\n  ivec4(0x005e240b,0x00662200,0x005b2102,0x005a2304),  ivec4(0x005b2507,0x005c2609,0x00572208,0x00572209),  ivec4(0x0056220b,0x00542008,0x00582208,0x00200c4f),  ivec4(0x0004065c,0x000c0061,0x0005006c,0x00000265),\n  ivec4(0x0005006f,0x00050073,0x0003066f,0x00040475),  ivec4(0x00030083,0x0003008d,0x0004008d,0x00030187),  ivec4(0x00080689,0x0009038e,0x003e3f90,0x00ecf2fa),  ivec4(0x00f1f9fe,0x00f9fff1,0x00fffff7,0x00fffdff),\n  ivec4(0x00fffbff,0x00fbfeff,0x00fbfffc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00fdf9fc,0x00f3f6f8,0x00e9f5fd),  ivec4(0x00acaffc,0x000000cf,0x002113fe,0x000d09fa),  ivec4(0x000c0efb,0x001013f8,0x000f0ffb,0x00100cff),  ivec4(0x00130cff,0x00140efb,0x001411f0,0x001413e5),\n  ivec4(0x001512e4,0x001209eb,0x002218c0,0x00983d59),  ivec4(0x00ca4a23,0x00d65310,0x00cc5712,0x00d25613),  ivec4(0x00d54f1e,0x00d65118,0x00d45314,0x00c4521b),  ivec4(0x00d55510,0x00d04f15,0x00ce511f,0x00b94b1e),\n  ivec4(0x001d0137,0x00211ae1,0x00130dfb,0x00140bfe),  ivec4(0x00140bff,0x00150aff,0x00150aff,0x00140efa),  ivec4(0x00130ff5,0x000e0afe,0x000b08ff,0x000b08ff),  ivec4(0x000d09fc,0x000e0af6,0x00110df0,0x00130eeb),\n  ivec4(0x001311e7,0x001811e2,0x001a10d9,0x00160bcf),  ivec4(0x001007c0,0x000e05b1,0x0008019d,0x00020189),  ivec4(0x0001007c,0x00000074,0x00060064,0x00080155),  ivec4(0x00000152,0x000b0534,0x00461b0f,0x004d1f05),\n  ivec4(0x00431d0d,0x004f2005,0x00582205,0x00572305),  ivec4(0x00572206,0x00582207,0x00572208,0x00562309),  ivec4(0x0055220a,0x00532008,0x0056200c,0x001c0b52),  ivec4(0x0003045f,0x000b0064,0x00040070,0x00000268),\n  ivec4(0x00060071,0x00040175,0x00040278,0x00010379),  ivec4(0x0000057d,0x00000189,0x00020193,0x00060096),  ivec4(0x00070085,0x00443c92,0x00e5e5f8,0x00f3fbfd),  ivec4(0x00fcfff4,0x00eff3e0,0x00fffff6,0x00fffdff),\n  ivec4(0x00fffbff,0x00fbfeff,0x00fbfffc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffcfe,0x00fffcf6,0x00fefefa,0x00fefdfe),  ivec4(0x00ecf6fe,0x00b4b9f9,0x000000d2,0x001b11fb),  ivec4(0x001011f0,0x001211f6,0x00100efc,0x000f0cff),  ivec4(0x00100ffe,0x00110ff9,0x00120ef7,0x00130cf6),\n  ivec4(0x001609f7,0x00130aec,0x002516c7,0x0086376a),  ivec4(0x00cb4d20,0x00d15310,0x00cd5515,0x00d55414),  ivec4(0x00d0501d,0x00d65118,0x00d25415,0x00c3531b),  ivec4(0x00d3550f,0x00ce4f15,0x00cd511f,0x00ba4d1f),\n  ivec4(0x001e0338,0x001c1bdd,0x00110ff9,0x00110dff),  ivec4(0x001209ff,0x001207ff,0x001308ff,0x00130bff),  ivec4(0x00100bf9,0x001611f2,0x001611ee,0x001713e9),  ivec4(0x001713e0,0x001813d5,0x001612c7,0x00100cb9),\n  ivec4(0x000a07ad,0x0007049d,0x00040290,0x00030189),  ivec4(0x0002017e,0x00010073,0x00000069,0x00000260),  ivec4(0x00010459,0x00000459,0x0002005a,0x00090550),  ivec4(0x00000452,0x00090534,0x00401b10,0x00481d07),\n  ivec4(0x003c1e10,0x004b2006,0x00512005,0x00532007),  ivec4(0x00552209,0x00562309,0x00552208,0x00562309),  ivec4(0x00532309,0x00522107,0x0051200e,0x00180956),  ivec4(0x00000364,0x00090066,0x00030072,0x0000026b),\n  ivec4(0x00060073,0x00040077,0x00040083,0x00020082),  ivec4(0x0000037e,0x00000387,0x0001018e,0x0000008c),  ivec4(0x00413599,0x00eee9f7,0x00f9faff,0x00fefffa),  ivec4(0x00fafcef,0x00fdfef5,0x00fef9f8,0x00fffcff),\n  ivec4(0x00fffeff,0x00fdfffd,0x00fbfff9,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffbff,0x00fffdfa,0x00fffefd,0x00fffefc),  ivec4(0x00fefffe,0x00e4edfc,0x00bfc8f9,0x000000c7),  ivec4(0x00170bee,0x00180afe,0x001408ff,0x001510ff),  ivec4(0x000b0cf6,0x000d13ee,0x001011ee,0x00120af7),\n  ivec4(0x001307fd,0x00120cee,0x002814ce,0x00722f7b),  ivec4(0x00cd501e,0x00cc5311,0x00cd5216,0x00d65215),  ivec4(0x00cc501a,0x00d35118,0x00d35515,0x00c2521b),  ivec4(0x00d1540e,0x00ce5217,0x00cb521f,0x00bb4f21),\n  ivec4(0x001c0339,0x002020e3,0x000a0df3,0x000d0cf7),  ivec4(0x00130dfe,0x000e07f7,0x000f0cf3,0x00100def),  ivec4(0x001311ea,0x001310c6,0x000d09ae,0x0005039f),  ivec4(0x00040392,0x00040387,0x0004037d,0x00020174),\n  ivec4(0x0001016e,0x0000016a,0x00000066,0x00000063),  ivec4(0x00010160,0x0001015b,0x0003045f,0x00060860),  ivec4(0x0004045c,0x0001015a,0x00000063,0x00020358),  ivec4(0x00000156,0x0006043b,0x003c1410,0x004b1d08),\n  ivec4(0x003f1c0d,0x004c1e03,0x004e1e07,0x00502009),  ivec4(0x0053220a,0x0053220a,0x00532208,0x00542208),  ivec4(0x00532208,0x00532208,0x004e1d12,0x0015095b),  ivec4(0x00000369,0x000a006d,0x00010077,0x0000026e),\n  ivec4(0x00080077,0x00050079,0x0003007f,0x00030287),  ivec4(0x00050393,0x0003008c,0x0000006a,0x00585a9f),  ivec4(0x00eceff7,0x00f5f4fc,0x00fffeff,0x00fffefe),  ivec4(0x00fefefd,0x00fffefe,0x00fffbfe,0x00fffdff),\n  ivec4(0x00fffefe,0x00fdfff8,0x00fdfff9,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffefb,0x00fff8fe,0x00fffbff,0x00fffffa),  ivec4(0x00fffffd,0x00f5fafa,0x00e9f8ff,0x00cfd4f6),  ivec4(0x000000d4,0x001a00f7,0x001000f6,0x001d11ff),  ivec4(0x000101f1,0x000d14ec,0x000e16e5,0x001011eb),\n  ivec4(0x00100df1,0x00120dee,0x002a12d5,0x00622a8c),  ivec4(0x00cc501b,0x00c65212,0x00ce5018,0x00d65016),  ivec4(0x00c85019,0x00d25017,0x00d05313,0x00c0521a),  ivec4(0x00cf530c,0x00ce5116,0x00ca511e,0x00bb5022),\n  ivec4(0x00190239,0x001f13e5,0x00190dfd,0x001d13f6),  ivec4(0x001310dd,0x000c0ec5,0x000205aa,0x00020293),  ivec4(0x0003028b,0x0000017c,0x0000006d,0x00000060),  ivec4(0x00000056,0x00000051,0x00000050,0x0000004c),\n  ivec4(0x00000046,0x0000004b,0x00000056,0x00000058),  ivec4(0x0000005a,0x0000005a,0x00010062,0x00030265),  ivec4(0x00050169,0x0005006e,0x00000065,0x0000005b),  ivec4(0x0000005a,0x0005013e,0x003c1110,0x004a1b06),\n  ivec4(0x003f1909,0x004c1d00,0x004a1d08,0x004d200a),  ivec4(0x004f210b,0x0050210a,0x00512109,0x00512207),  ivec4(0x00522107,0x00522207,0x004b1d16,0x00120860),  ivec4(0x0000026e,0x00070071,0x0001007a,0x00000371),\n  ivec4(0x0009007a,0x0006007c,0x000c1283,0x0000007b),  ivec4(0x00100199,0x00000079,0x008885bf,0x00ecf1f5),  ivec4(0x00fafef3,0x00fbf9f9,0x00fffcff,0x00fffbff),  ivec4(0x00fffbff,0x00fffbff,0x00fffdff,0x00fffefe),\n  ivec4(0x00fefffc,0x00fdfffa,0x00fdfffc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fdfffd,0x00fdfeff,0x00fffaff,0x00fffcfe),  ivec4(0x00fffffb,0x00f5f8f0,0x00f5fafe,0x00f2f2ff),  ivec4(0x00d9dbf9,0x004843e5,0x000000d6,0x001002f3),  ivec4(0x001b12fd,0x000d0ff8,0x000c13ed,0x000f12eb),\n  ivec4(0x000f0fee,0x00120dee,0x002c11d9,0x00542699),  ivec4(0x00c94e16,0x00c15112,0x00ce4d1b,0x00d74e15),  ivec4(0x00c45118,0x00cf4e15,0x00ce5212,0x00bd5018),  ivec4(0x00ce520b,0x00c84e12,0x00c64f1b,0x00b84e20),\n  ivec4(0x00130035,0x002717c8,0x001204c6,0x000904ac),  ivec4(0x0003038d,0x00010276,0x00000060,0x00000049),  ivec4(0x00000048,0x00040a65,0x001f237a,0x00373b91),  ivec4(0x0045489f,0x005053a8,0x005359ad,0x00565bae),\n  ivec4(0x005458aa,0x004f53a7,0x0041459b,0x00282c81),  ivec4(0x000b0d64,0x00000053,0x00000055,0x00000055),  ivec4(0x00000060,0x0003016a,0x0000005f,0x00060154),  ivec4(0x00000055,0x0007023b,0x003a110f,0x00471a07),\n  ivec4(0x003a1809,0x00441d00,0x00471c08,0x004a1f0a),  ivec4(0x004c200b,0x004d210a,0x004e2008,0x00502106),  ivec4(0x00512006,0x00512105,0x004a1d1b,0x000e0763),  ivec4(0x00000371,0x00070072,0x0001007d,0x00000375),\n  ivec4(0x000b007d,0x00060180,0x00020681,0x0002027e),  ivec4(0x00000058,0x00c7bfe7,0x00eee7f8,0x00ffffff),  ivec4(0x00fafcef,0x00fefdf7,0x00fcfefc,0x00fdfeff),  ivec4(0x00fdfdff,0x00fcfdff,0x00fdfffe,0x00fdfffa),\n  ivec4(0x00fdfffc,0x00fffefe,0x00fffdff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fcffff,0x00fbfffe,0x00fcfeff,0x00fdfdff),  ivec4(0x00fefefe,0x00fcfdfb,0x00fdfbfd,0x00fdfdfa),  ivec4(0x00eefbf0,0x00d2eafb,0x008c91f6,0x000000d2),  ivec4(0x000f00fb,0x001009ff,0x000b09fd,0x000b09f9),\n  ivec4(0x000d0df9,0x000f0dee,0x002612df,0x004d239e),  ivec4(0x00c6500c,0x00c34f14,0x00cd4e1c,0x00cf4f18),  ivec4(0x00c34f1c,0x00cc4d15,0x00cb5015,0x00bb4f1b),  ivec4(0x00c8510e,0x00c44b0e,0x00c14d17,0x00b04c22),\n  ivec4(0x001a012c,0x00110b73,0x0002006b,0x0000005a),  ivec4(0x00000042,0x00000044,0x00222173,0x00554ea9),  ivec4(0x006157bb,0x005757b3,0x00565db7,0x00565cb8),  ivec4(0x00575eba,0x005d63c2,0x005e66c3,0x005e65c3),\n  ivec4(0x005b63c1,0x005a63ba,0x005861b0,0x005560a9),  ivec4(0x00505ca0,0x004b5798,0x00495498,0x002e3981),  ivec4(0x0000075c,0x00000048,0x00000050,0x000a024f),  ivec4(0x00010050,0x000a0336,0x00341110,0x003f1907),\n  ivec4(0x00341807,0x003e1c02,0x00451b09,0x00481e0b),  ivec4(0x00491f0b,0x004c2009,0x004e2008,0x004f2007),  ivec4(0x004f2106,0x004e2006,0x00461e1b,0x00110764),  ivec4(0x00000177,0x00010078,0x0000007f,0x0000027a),\n  ivec4(0x000a017f,0x0007057c,0x00000078,0x0000007a),  ivec4(0x00d7ddea,0x00f2f1fa,0x00fffdff,0x00fff5ff),  ivec4(0x00fefbfc,0x00fffff7,0x00f9fff2,0x00fbfffc),  ivec4(0x00fbfffc,0x00fbfffc,0x00fbfff9,0x00fdfff8),\n  ivec4(0x00fdfffd,0x00fffdff,0x00fffbff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00feffff,0x00feffff,0x00feffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00fffeff,0x00fffffe),  ivec4(0x00faffef,0x00f7ffec,0x00d7dff7,0x00cdcaf5),  ivec4(0x002e0be4,0x000000dc,0x000902f8,0x000f11ff),\n  ivec4(0x000002f0,0x000a0bf7,0x001008e6,0x00502ba4),  ivec4(0x00c65c02,0x00cf471e,0x00c54f15,0x00b05018),  ivec4(0x00c64424,0x00cc4c16,0x00c04a1d,0x00b2471f),  ivec4(0x00b24613,0x00ba4a0e,0x00aa440f,0x008b3d23),\n  ivec4(0x00310c1e,0x00070335,0x0000001e,0x00000046),  ivec4(0x00454b9f,0x00474ea9,0x005860c1,0x006167cb),  ivec4(0x00656cce,0x00656dd1,0x00646cd2,0x00626cce),  ivec4(0x00626dcc,0x00646dcb,0x00636dc7,0x00606cc4),\n  ivec4(0x005e6bc0,0x005e6bbe,0x005e69bb,0x005c68b8),  ivec4(0x005966b3,0x005764b1,0x00505eaa,0x004c5aa4),  ivec4(0x004b59a0,0x00414d92,0x00292e77,0x0000004a),  ivec4(0x00000045,0x000f0434,0x001e0911,0x00361a09),\n  ivec4(0x003f1d07,0x00411602,0x003f1909,0x00431b0b),  ivec4(0x00481e0a,0x004b1f08,0x004b1f07,0x004b1f07),  ivec4(0x004a1f09,0x00491f0d,0x003d201c,0x00210b65),  ivec4(0x00060095,0x0000007e,0x0001017a,0x00130084),\n  ivec4(0x0000007c,0x00000046,0x00aaabca,0x00e6e2eb),  ivec4(0x00f9f7ff,0x00fefdfe,0x00fefcfe,0x00fffcff),  ivec4(0x00fffefe,0x00fffffa,0x00fefffa,0x00fefffe),  ivec4(0x00fefffe,0x00fefffe,0x00fefffe,0x00fffffd),\n  ivec4(0x00ffffff,0x00ffffff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffcfc,0x00fbf1f9,0x00faf9fc,0x00ebf2fd),  ivec4(0x00d2dff8,0x00acb6f4,0x000000ce,0x000000d2),\n  ivec4(0x000e00f3,0x001507ff,0x000b00e9,0x005022aa),  ivec4(0x00ba4f05,0x00cc4021,0x00c14f0b,0x00a6560a),  ivec4(0x00c54917,0x00c1470e,0x00b4471b,0x00a5421f),  ivec4(0x009e3d14,0x009d3d08,0x00853104,0x00632d20),\n  ivec4(0x001c0000,0x00040042,0x00595f9e,0x005962ac),  ivec4(0x005f69c3,0x006b77d9,0x006a78dd,0x006b7add),  ivec4(0x006f7ede,0x006f7de1,0x006e7de2,0x006e7edf),  ivec4(0x006c7dda,0x006d7cd5,0x006e7cd1,0x006b7acc),\n  ivec4(0x006877c5,0x006473c1,0x006470c0,0x00606dbd),  ivec4(0x005d6ab9,0x005c68b7,0x005a67b5,0x005866b2),  ivec4(0x005261ac,0x004b5aa3,0x004a569a,0x0043498e),  ivec4(0x00333272,0x0000001b,0x000d0309,0x002f1d0e),\n  ivec4(0x00311401,0x003f1a07,0x003b1705,0x003f1a06),  ivec4(0x00461d07,0x00491e06,0x004b1d05,0x004b1d06),  ivec4(0x00491d09,0x00471d0c,0x00381a21,0x002b0e6a),  ivec4(0x000a008f,0x00000074,0x0000004f,0x00000059),\n  ivec4(0x006657b9,0x00ccd6e5,0x00e7eaf9,0x00ffffff),  ivec4(0x00fefbff,0x00fefdff,0x00fefcfe,0x00fffffe),  ivec4(0x00fffffd,0x00fffffb,0x00fffffd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fef8ff,0x00fef5ff,0x00fffcff,0x00f4f9f1),  ivec4(0x00f8fff9,0x00ecf6ff,0x00cbcbf0,0x00c6bfee),\n  ivec4(0x002c00d5,0x000000d5,0x000000cd,0x004b1696),  ivec4(0x00b04514,0x00c03d25,0x00bb4a0f,0x00a35303),  ivec4(0x00ba480c,0x00b3460f,0x00a04014,0x00893615),  ivec4(0x007d2e0c,0x006e2502,0x005b1c00,0x00290000),\n  ivec4(0x00555277,0x0059619e,0x007b86cf,0x00707cce),  ivec4(0x007181db,0x007586e8,0x007386eb,0x00788cef),  ivec4(0x00768beb,0x007489ec,0x00758ced,0x00768deb),  ivec4(0x007389e3,0x007389dc,0x007486d6,0x007082cc),\n  ivec4(0x006c7ec4,0x006978c0,0x006775bf,0x006371bb),  ivec4(0x00616fba,0x005f6cb9,0x005e6cb9,0x005b68b6),  ivec4(0x005663b1,0x005968b0,0x005667a5,0x005564a4),  ivec4(0x0048508b,0x00565c7f,0x00202229,0x00050000),\n  ivec4(0x00221202,0x002f1706,0x00341602,0x003a1904),  ivec4(0x00411c03,0x00461d03,0x00491b03,0x00491b04),  ivec4(0x00481c06,0x00481b0b,0x00351627,0x00270161),  ivec4(0x00000051,0x00000041,0x00878db4,0x00d8cfe1),\n  ivec4(0x00e5daf4,0x00edf6fb,0x00f8fbfe,0x00f6f4f9),  ivec4(0x00fcfafe,0x00fffeff,0x00fffeff,0x00fffffe),  ivec4(0x00fffffd,0x00fffffc,0x00fffffe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fefcfa,0x00fffef9,0x00fdfcf6,0x00fefef9),  ivec4(0x00fafaf9,0x00feffff,0x00fafbff,0x00f9f8ff),\n  ivec4(0x00d1d1f0,0x00c6c3ee,0x009186e5,0x0034006a),  ivec4(0x00a94d1e,0x00ac3b28,0x00ad401b,0x00954710),  ivec4(0x00a43b18,0x0092380b,0x007d300b,0x0065270e),  ivec4(0x00551600,0x00360000,0x0055393d,0x00767594),\n  ivec4(0x006b78ad,0x007182c8,0x007b8dda,0x00798ce1),  ivec4(0x00768de7,0x00798ff0,0x007a93f6,0x007d95f7),  ivec4(0x007d96f6,0x007b97f6,0x007b9af7,0x007d9bf4),  ivec4(0x007b97eb,0x007891e1,0x007389d4,0x006a80c4),\n  ivec4(0x006a7cbd,0x00687bbc,0x006577bb,0x006273b8),  ivec4(0x005f70b6,0x005d6eb6,0x005c6cb6,0x005c6bb8),  ivec4(0x005d6cba,0x00596bb5,0x00596eac,0x00586ca9),  ivec4(0x0054649e,0x005d6994,0x00535c74,0x004c4f5c),\n  ivec4(0x00070000,0x00090000,0x00291202,0x00321708),  ivec4(0x003a1906,0x003f1a04,0x00431a04,0x00441a05),  ivec4(0x00441a07,0x00461b0d,0x00240118,0x00431c71),  ivec4(0x00c1bbdc,0x00ccd1dd,0x00e6ebf4,0x00fffaff),\n  ivec4(0x00fffbff,0x00fafcf5,0x00fcfefb,0x00fbfafd),  ivec4(0x00fbf9fc,0x00fffeff,0x00ffffff,0x00fffffe),  ivec4(0x00fffffe,0x00fffffd,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdfffd,0x00fcfffc,0x00fcfefa,0x00fefffd),  ivec4(0x00fcfdfb,0x00fffffc,0x00fffffe,0x00ffffff),\n  ivec4(0x00fdffff,0x00f3fafd,0x00e6e5fb,0x00cbbbc6),  ivec4(0x006b0000,0x00710000,0x00840000,0x0074340f),  ivec4(0x00802e1e,0x0065270d,0x00501200,0x00340000),  ivec4(0x00694d54,0x00756879,0x00827fa0,0x007e8abd),\n  ivec4(0x00708bcd,0x00788fdd,0x007c92e3,0x007f98ef),  ivec4(0x007c99f3,0x007e9df9,0x007f9dfc,0x00819cfd),  ivec4(0x00839efd,0x0082a2fe,0x0082a5fd,0x0086a7fb),  ivec4(0x00809fef,0x007791df,0x006c87cd,0x00627bbc),\n  ivec4(0x006276b7,0x006075b5,0x005d72b4,0x005d71b3),  ivec4(0x005b70b3,0x005b6fb4,0x005a6db4,0x005b6db7),  ivec4(0x005c6db8,0x005a6db8,0x00576cb4,0x00576cad),  ivec4(0x00576ba8,0x0057689f,0x005c6995,0x005f6689),\n  ivec4(0x00535771,0x00444556,0x001d0800,0x00060000),  ivec4(0x00260e00,0x0032180c,0x003c1d12,0x002a0000),  ivec4(0x00000000,0x00000000,0x00000000,0x00dedbe3),  ivec4(0x00f8f4ff,0x00f9ffff,0x00fffffb,0x00fffefd),\n  ivec4(0x00fffcff,0x00fffff9,0x00fffffd,0x00fffeff),  ivec4(0x00fefdfe,0x00ffffff,0x00fffffe,0x00fffffe),  ivec4(0x00fffffe,0x00fffffe,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fcffff,0x00f9ffff,0x00faffff,0x00fbfffe),  ivec4(0x00fcfffe,0x00fcfffd,0x00fefeff,0x00fffdff),\n  ivec4(0x00ffffff,0x00f7fff4,0x00fefff6,0x00fdf9fa),  ivec4(0x00d7cfb7,0x00d2caae,0x00d3a592,0x00380000),  ivec4(0x00410000,0x00360000,0x0064505b,0x00786c7f),  ivec4(0x00857d9a,0x008686b0,0x00838ec4,0x007890d4),\n  ivec4(0x007b99e3,0x00809bec,0x00829df1,0x0085a3f8),  ivec4(0x0084a5fc,0x0082a4fc,0x0083a5fe,0x0087a6ff),  ivec4(0x008aa8ff,0x0087a8fe,0x0088a8fd,0x0087a5f8),  ivec4(0x007895e4,0x006c87d3,0x00637cc4,0x005a71b5),\n  ivec4(0x005a70b3,0x005a6fb1,0x00586eae,0x00586eaf),  ivec4(0x00596fb1,0x00596eb1,0x00586eb2,0x00596eb3),  ivec4(0x005a6fb4,0x005b6eb8,0x00586cb8,0x00566eb0),  ivec4(0x00566eab,0x00576cab,0x005a69a9,0x005c66a1),\n  ivec4(0x005a6490,0x005b6484,0x00545972,0x0052576c),  ivec4(0x002a2531,0x00060000,0x00000000,0x005c4644),  ivec4(0x00ccc6c3,0x00cbc7c4,0x00d7d6d2,0x00fdfcf9),  ivec4(0x00fffefe,0x00fcfdf6,0x00fffff9,0x00fffffe),\n  ivec4(0x00fffdff,0x00fffefe,0x00fffffe,0x00ffffff),  ivec4(0x00ffffff,0x00fffffe,0x00fffffe,0x00fffffe),  ivec4(0x00fffffe,0x00fffffe,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fefffe,0x00fcfffd,0x00fcfeff,0x00fdfcff),  ivec4(0x00fdfbff,0x00fcfcff,0x00fdfdff,0x00fefefd),\n  ivec4(0x00fefffc,0x00fcfdf9,0x00fefdf3,0x00f9feff),  ivec4(0x00fffff7,0x00feffeb,0x00fff4ef,0x00c4c3bb),  ivec4(0x00757082,0x0067678a,0x00777497,0x008b8ab1),  ivec4(0x00878dbf,0x007d8ece,0x007b93db,0x007d97e3),\n  ivec4(0x0088a1ed,0x0087a2f5,0x0087a5f8,0x008aa9fd),  ivec4(0x0087acff,0x0088abfe,0x0088adff,0x008bacff),  ivec4(0x008caafe,0x008ba7fa,0x00839ff0,0x007792e2),  ivec4(0x006882d0,0x005f78c5,0x005970bc,0x00556cb6),\n  ivec4(0x00576eb8,0x00596db5,0x00576eb0,0x00576eb0),  ivec4(0x00576eb0,0x00576eb0,0x00576fb0,0x00576faf),  ivec4(0x005870b0,0x00596eb3,0x005b6eb5,0x005972af),  ivec4(0x005773ab,0x00576fae,0x00586cb3,0x005867ae),\n  ivec4(0x00596aa1,0x005b6d98,0x005b6c98,0x00566289),  ivec4(0x004d5776,0x004e5469,0x009193a1,0x00e4e0e0),  ivec4(0x00fdfafb,0x00fffdfc,0x00ffffff,0x00fbfbf9),  ivec4(0x00fffdf9,0x00fffdfa,0x00fffdfe,0x00fdfeff),\n  ivec4(0x00fdfeff,0x00ffffff,0x00fffffd,0x00fffffd),  ivec4(0x00fffffd,0x00fffffe,0x00fffffe,0x00fffffe),  ivec4(0x00fffffe,0x00fffffe,0x00fffffe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffefe,0x00fffefe,0x00fffeff,0x00fffdff),  ivec4(0x00fffdfe,0x00fffdfd,0x00fffffd,0x00fefffb),\n  ivec4(0x00fefffc,0x00fffeff,0x00fffdf5,0x00eff7ff),  ivec4(0x00fefdff,0x00ecf9fc,0x00d1cadf,0x00b3b7c2),  ivec4(0x008181b3,0x007c88c0,0x007681ba,0x00848fc8),  ivec4(0x008191d4,0x007f98e4,0x00809cee,0x00869ef0),\n  ivec4(0x008ea2ef,0x008ca6fb,0x008ca9fd,0x008bacff),  ivec4(0x0089aeff,0x008cb1ff,0x008db1ff,0x008aacfc),  ivec4(0x0084a2f5,0x00829cec,0x00768edd,0x006981d1),  ivec4(0x00637ac8,0x006175c4,0x005e74c4,0x005f76c5),\n  ivec4(0x005e74c4,0x005a70bc,0x005b72b7,0x005870b4),  ivec4(0x00576fb2,0x00576fb0,0x00556ead,0x00566fad),  ivec4(0x005770ae,0x005970ae,0x005c70af,0x005a74a8),  ivec4(0x005776a5,0x005672ab,0x00566db4,0x005a6cb4),\n  ivec4(0x005c71aa,0x005a729e,0x00506ca9,0x00486098),  ivec4(0x00596b98,0x005f6c8e,0x008c92a7,0x00c1c2c8),  ivec4(0x00d8dce2,0x00fdffff,0x00f9fbff,0x00fdfcfe),  ivec4(0x00fdf6f8,0x00fffcff,0x00fffbff,0x00f9fdff),\n  ivec4(0x00f9ffff,0x00fcfffd,0x00fefffc,0x00fffffc),  ivec4(0x00fffffc,0x00fffffd,0x00fffffe,0x00fffffe),  ivec4(0x00fffffe,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffeff,0x00fffeff,0x00ffffff,0x00feffff),  ivec4(0x00fdfffe,0x00fdfffe,0x00fbfdfb,0x00fefefb),\n  ivec4(0x00fffdf9,0x00fffffb,0x00fcf9f9,0x00f8ffff),  ivec4(0x00ced2e8,0x00a6b6d9,0x007673b0,0x005f6daa),  ivec4(0x00727dc2,0x007b8cd0,0x007d8ed2,0x008697dc),  ivec4(0x008399e3,0x0086a0ed,0x0085a2f4,0x0089a6f8),\n  ivec4(0x008aa7f6,0x008da9fe,0x008daaff,0x008cadff),  ivec4(0x008bafff,0x0089adfd,0x0088aefb,0x0083a8f5),  ivec4(0x007ca0ee,0x007a9de5,0x00789ae0,0x007596dd),  ivec4(0x007696e0,0x007894e0,0x00718dda,0x006f89d8),\n  ivec4(0x006b83d3,0x00627bc9,0x005f79c3,0x005d76bd),  ivec4(0x005b72b5,0x005a6eb0,0x005a6eae,0x00596eae),  ivec4(0x00586faf,0x005970ae,0x005a71ab,0x005972a9),  ivec4(0x005873a7,0x005973a9,0x005b72af,0x005e72af),\n  ivec4(0x005c71a9,0x005c73a5,0x005670ab,0x00566ea5),  ivec4(0x00596fa1,0x00586d98,0x004c6288,0x00425b80),  ivec4(0x008593a9,0x00b8c6d4,0x00e2eaf4,0x00fcffff),  ivec4(0x00fbf8fc,0x00fbf8fa,0x00fffdfd,0x00fcfffd),\n  ivec4(0x00f9fffd,0x00f8fffe,0x00fdfffe,0x00fffffe),  ivec4(0x00fffffe,0x00fffffe,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00fffffe,0x00ffffff,0x00fdfffe),  ivec4(0x00fcfffd,0x00fafefc,0x00fcfdfd,0x00fefffe),\n  ivec4(0x00fffdfb,0x00fffdfb,0x00f0f0fd,0x00c7ccdc),  ivec4(0x00808cbd,0x005c6bb5,0x00687cc3,0x007788cd),  ivec4(0x008091d4,0x008395de,0x00869ae4,0x00899fea),  ivec4(0x0088a2ef,0x0088a5f3,0x0088a7f6,0x0088aafb),\n  ivec4(0x0089adfe,0x008baeff,0x008cafff,0x008cafff),  ivec4(0x008cb1ff,0x0089affb,0x0087aff8,0x0086aff6),  ivec4(0x0087b0f6,0x008bb6f4,0x0090bbf6,0x0091baf6),  ivec4(0x0092b8f9,0x008fb3f8,0x0083a4ec,0x007a99e2),\n  ivec4(0x007490db,0x006a87d3,0x006580cd,0x00627bc5),  ivec4(0x005f77ba,0x005c70b3,0x005d70b1,0x005a6eb0),  ivec4(0x00576db1,0x00576daf,0x005771ab,0x005970ab),  ivec4(0x005970ab,0x005a71aa,0x005c74ac,0x005d73aa),\n  ivec4(0x005c73aa,0x005d72aa,0x005e72a8,0x005f74a9),  ivec4(0x005c73a6,0x005a71a2,0x0059729e,0x00546e98),  ivec4(0x0043618d,0x004c6b96,0x0098a5b8,0x00d1d9e4),  ivec4(0x00ffffff,0x00f7f7fa,0x00fffffd,0x00fffffc),\n  ivec4(0x00fdfffb,0x00fafffe,0x00fdffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00fffffe,0x00fffffd,0x00fffffc),  ivec4(0x00fefffb,0x00fdfefb,0x00fefefe,0x00fcfdff),\n  ivec4(0x00fefeff,0x00e5e7f8,0x00b4b9d8,0x006a76b2),  ivec4(0x006a7dc2,0x007084d0,0x007b91de,0x008296df),  ivec4(0x00899de5,0x00869fec,0x0088a2f0,0x0089a5f5),  ivec4(0x0087a6f7,0x0087a8f9,0x0087aafc,0x0089adff),\n  ivec4(0x008ab0ff,0x008bb6fd,0x008cb7fd,0x008cb8fd),  ivec4(0x008eb9fd,0x0090bbfc,0x0093bcfc,0x0097c1fd),  ivec4(0x009cc6ff,0x00a1cdff,0x00a3ceff,0x00a5ceff),  ivec4(0x00a0c8ff,0x0097bcfb,0x0089abee,0x007c9de1),\n  ivec4(0x007493d9,0x006d8ad3,0x006783cf,0x00617bc4),  ivec4(0x005e76ba,0x005b71b3,0x005c70b2,0x00596fb2),  ivec4(0x00566db2,0x00546db0,0x00556fac,0x00566faa),  ivec4(0x00566faa,0x00566faa,0x005872ac,0x005973ac),\n  ivec4(0x005973ac,0x005b73ac,0x006074ad,0x006175ad),  ivec4(0x005f74ab,0x005e73a8,0x005e75a6,0x005b72a2),  ivec4(0x005a72a1,0x00566e9a,0x00556990,0x007c8ba8),  ivec4(0x00cbd4dc,0x00fbffff,0x00fcfeff,0x00fffffd),\n  ivec4(0x00fffffb,0x00fefff9,0x00fffffd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00fefffe,0x00fffffa,0x00fffff9),  ivec4(0x00fffff9,0x00fffffd,0x00f8fbfe,0x00f9fcff),\n  ivec4(0x00e7ecfc,0x00a1abde,0x006374bc,0x007084d1),  ivec4(0x00748bde,0x007a94e9,0x00819bee,0x0087a0ef),  ivec4(0x0089a2ef,0x0086a6f8,0x0087a7f9,0x0086a8fc),  ivec4(0x0084a7fb,0x0085a9fc,0x0085abff,0x0088b0ff),\n  ivec4(0x008ab2ff,0x008dbbfe,0x008ebdfc,0x0092c0fe),  ivec4(0x0096c2fd,0x009cc7ff,0x00a4cdff,0x00aad1ff),  ivec4(0x00aad1ff,0x00a7cefe,0x00a0c6f9,0x009bc0f3),  ivec4(0x0090b3ec,0x0080a2dd,0x007090ce,0x006482c2),\n  ivec4(0x005f7dbe,0x005b76ba,0x00556fb7,0x00536bb0),  ivec4(0x00576daf,0x00596dac,0x005c70af,0x005a70b1),  ivec4(0x005870b3,0x005770b2,0x00556fab,0x00556fab),  ivec4(0x00556fab,0x00556fab,0x005671ae,0x005772ae),\n  ivec4(0x005672af,0x005772b0,0x005f73af,0x006075b0),  ivec4(0x006074af,0x005f74ac,0x005d74aa,0x006178ad),  ivec4(0x005e76aa,0x005b73a5,0x005f78a7,0x0058709b),  ivec4(0x0065799d,0x00cad6df,0x00fcffff,0x00fcffff),\n  ivec4(0x00fffffb,0x00fffff6,0x00fffffb,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00feffff,0x00fdfffd,0x00fffff9,0x00fffff8),  ivec4(0x00fffff9,0x00fcfcfe,0x00f2f7ff,0x00e6eefd),\n  ivec4(0x00a6b3dd,0x00637ad5,0x007087e2,0x007792ee),  ivec4(0x007a97f3,0x007f9ef8,0x0082a2f9,0x0088a8fb),  ivec4(0x0088a7f9,0x0085aaff,0x0086acfe,0x0081a8fc),  ivec4(0x0086abfd,0x0087acff,0x0086aefe,0x0084adfb),\n  ivec4(0x008cb3fe,0x0094bfff,0x0096c1ff,0x009ac3ff),  ivec4(0x00a1c9ff,0x009bbff6,0x0095b6e9,0x0095b5e5),  ivec4(0x008cacdf,0x0085a2d4,0x007997ca,0x00718dc3),  ivec4(0x00637eb6,0x00526ca7,0x004a64a2,0x00445d9d),\n  ivec4(0x00455c9d,0x00465c9b,0x00495d98,0x004c5f98),  ivec4(0x0051629a,0x00516198,0x0050629a,0x004e619b),  ivec4(0x004c639e,0x005167a4,0x005871aa,0x00566faa),  ivec4(0x005670ab,0x005570ac,0x00546fac,0x005470ad),\n  ivec4(0x005571b1,0x005572b1,0x005c71b0,0x005d73b1),  ivec4(0x005e74b1,0x005d74af,0x005e75af,0x005f76af),  ivec4(0x005c75ac,0x005e76af,0x005977ae,0x005b78ac),  ivec4(0x005a75a3,0x00627aa3,0x00cdd8e1,0x00fbffff),\n  ivec4(0x00fffffd,0x00fffef6,0x00fffffc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00feffff,0x00fdfffd,0x00fffffa,0x00fffff9),  ivec4(0x00fffffc,0x00f2f4fc,0x00e8f1ff,0x00a6b6e0),\n  ivec4(0x00667fc9,0x006f8ced,0x007997f9,0x007d9dfc),  ivec4(0x0081a4fe,0x0084a7ff,0x0085a9fe,0x0087aafe),  ivec4(0x0089acff,0x0085acff,0x0086adff,0x0086adfd),  ivec4(0x0087acfb,0x0089affb,0x008eb4fd,0x008aaef7),\n  ivec4(0x008eb2f8,0x0098befe,0x009bc0fd,0x0089ace7),  ivec4(0x0089a9e2,0x008aa4db,0x00657bb0,0x004c6092),  ivec4(0x00334675,0x002d3e6c,0x002f406b,0x00364473),  ivec4(0x003e4c7e,0x00455389,0x004e5e94,0x00495992),\n  ivec4(0x004d5c97,0x00425287,0x00414f7a,0x003c4a71),  ivec4(0x003a4368,0x00323c61,0x00313e65,0x003a4873),  ivec4(0x00475885,0x00475b8c,0x00496094,0x004b6299),  ivec4(0x00556da5,0x005770ab,0x00536da8,0x00526eaa),\n  ivec4(0x00536faf,0x005571ae,0x005971ae,0x005a72b0),  ivec4(0x005b73b0,0x005c75b1,0x005c74b0,0x005c74af),  ivec4(0x005d76b0,0x005e76b1,0x005a78b3,0x005a79b3),  ivec4(0x005c7ab1,0x005c79a9,0x006079a3,0x00d6e0ea),\n  ivec4(0x00fcffff,0x00fdfbf7,0x00fffffd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdffff,0x00fdfffe,0x00fffffc,0x00fffffb),  ivec4(0x00fffdff,0x00f0f5fe,0x00bccaee,0x006481d0),\n  ivec4(0x007191ec,0x007a9afa,0x0083a3ff,0x0085a8ff),  ivec4(0x0089aeff,0x0087adfe,0x0087aeff,0x0087adff),  ivec4(0x0089aeff,0x0087aefe,0x0088aefe,0x0091b5fe),  ivec4(0x008eb2fa,0x0088abf1,0x0086a6e9,0x0082a1e0),\n  ivec4(0x007492d1,0x007492cf,0x007b97d1,0x00738dc7),  ivec4(0x007186b8,0x006677a2,0x00475477,0x001e2342),  ivec4(0x00000000,0x00000000,0x00000000,0x0000000f),  ivec4(0x001d2244,0x00373f61,0x00454d74,0x00485179),\n  ivec4(0x003f4770,0x0022294c,0x00061329,0x00000000),  ivec4(0x00000000,0x00000000,0x00070d25,0x002c334d),  ivec4(0x00424d6b,0x0048577b,0x00455787,0x003c4f81),  ivec4(0x0041568a,0x004c6399,0x00536ba3,0x00556ea9),\n  ivec4(0x00526da9,0x005470ab,0x005872ac,0x005973ad),  ivec4(0x005b74af,0x005c75b0,0x005b74af,0x005c74b0),  ivec4(0x005c75b2,0x005d76b2,0x005e7ab4,0x005c7bb5),  ivec4(0x005b7ab6,0x005a7db5,0x005f7cad,0x007c8fb3),\n  ivec4(0x00e6f0fa,0x00fafbfc,0x00fffffe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00feffff,0x00ffffff,0x00fffffe,0x00fffffe),  ivec4(0x00fefbff,0x00dce3f6,0x00738bd2,0x007194f3),\n  ivec4(0x007299fe,0x0086a5fe,0x008cadff,0x008db1ff),  ivec4(0x008eb4fe,0x008bb2fc,0x008bb2fe,0x0088b1ff),  ivec4(0x0088b0ff,0x008cb2fe,0x0092b5ff,0x008caef3),  ivec4(0x0083a4e4,0x007492d0,0x005f7ab5,0x005670a7),\n  ivec4(0x00375088,0x00002765,0x00304880,0x007186b5),  ivec4(0x007686aa,0x00000012,0x00000000,0x00000000),  ivec4(0x0002050c,0x0004040e,0x0002030d,0x00010207),  ivec4(0x00000000,0x00000000,0x00191b2a,0x0032374b),\n  ivec4(0x00000000,0x00000000,0x00000000,0x0001030b),  ivec4(0x0004050c,0x00050409,0x00000107,0x00000000),  ivec4(0x00000000,0x0030384d,0x004d5a86,0x004e5c8a),  ivec4(0x00334473,0x002e4073,0x004e6399,0x00566da4),\n  ivec4(0x00536ba3,0x00566fa9,0x005773aa,0x005672aa),  ivec4(0x005974ad,0x005a76ae,0x005a75ae,0x005a75ae),  ivec4(0x005b76b1,0x005b76b0,0x00637bb0,0x00607bb4),  ivec4(0x005c7bb8,0x00597dbb,0x006081ba,0x00647ea9),\n  ivec4(0x00a9b7d1,0x00f4faff,0x00fdfeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff),  ivec4(0x00ffffff,0x00ffffff,0x00fffffe,0x00fefffd),  ivec4(0x00fcfffd,0x00f8fdfa,0x00fffefc,0x00fffdff),  ivec4(0x00f4f6ff,0x009caae5,0x007a98e8,0x00749cfe),\n  ivec4(0x0078a2ff,0x0089adff,0x0090b4ff,0x0094b6fe),  ivec4(0x0097b9fd,0x0097bcfd,0x0091b7fe,0x008db8ff),  ivec4(0x008bb5fe,0x0099b9fc,0x008facec,0x006d89c3),  ivec4(0x003c538a,0x002d4273,0x00354874,0x003c4f78),\n  ivec4(0x003e4f78,0x00354771,0x004a5a83,0x003a4868),  ivec4(0x00000000,0x0000000a,0x0000030e,0x0006090d),  ivec4(0x00010204,0x00060607,0x00010200,0x00000000),  ivec4(0x00000000,0x00000000,0x00000000,0x00000000),\n  ivec4(0x00000000,0x00000000,0x00000000,0x00010000),  ivec4(0x00090708,0x000b080a,0x00010103,0x00010308),  ivec4(0x0000010a,0x00000000,0x00000029,0x004c577d),  ivec4(0x00505c82,0x00313e67,0x0042537e,0x00445782),\n  ivec4(0x00435681,0x00495d89,0x004e6391,0x00596d9f),  ivec4(0x005d72a7,0x005a71aa,0x005d75b1,0x005b75b2),  ivec4(0x005a75b1,0x005b77b2,0x00617aaf,0x005f7ab3),  ivec4(0x005c7bb8,0x005b7cbc,0x006080bc,0x006983b6),\n  ivec4(0x0060769e,0x00c7d5ee,0x00fbfeff,0x00fffffd),  ivec4(0x00fffefc,0x00ffffff,0x00fefeff,0x00fdfeff),  ivec4(0x00fffeff,0x00fffffe,0x00fffffe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffdff,0x00fffdff,0x00fffdff,0x00fffdff),  ivec4(0x00fffeff,0x00feffff,0x00fefffd,0x00fcfffb),  ivec4(0x00f7fffa,0x00effaf2,0x00fdfdf8,0x00faf8ff),  ivec4(0x00ccd6f6,0x00819ded,0x00749df9,0x0083acff),\n  ivec4(0x0087b0fc,0x0089b6ff,0x0090baff,0x0099bdff),  ivec4(0x009dbdff,0x00a3c5fd,0x0099bffd,0x0093bffc),  ivec4(0x0096c1fe,0x009db6e9,0x0063729b,0x002f3551),  ivec4(0x00181829,0x00000000,0x00000000,0x00090910),\n  ivec4(0x0033394a,0x003e4967,0x003e4762,0x00000000),  ivec4(0x00030812,0x00060b0f,0x0004070e,0x00050611),  ivec4(0x00000000,0x00000000,0x00000000,0x000b141d),  ivec4(0x00252c3b,0x002e3648,0x00333c51,0x00384157),\n  ivec4(0x0030394f,0x00272f43,0x001d202f,0x00000007),  ivec4(0x00000000,0x00000000,0x00000001,0x0003030c),  ivec4(0x0002030a,0x00010008,0x00000000,0x00121628),  ivec4(0x00484d62,0x003b4258,0x00262c3b,0x00000000),\n  ivec4(0x00000000,0x00000000,0x002c2f45,0x004e5375),  ivec4(0x0057618c,0x00616fa6,0x005e70af,0x005c74b5),  ivec4(0x005773b2,0x005a79b6,0x005a7ab3,0x005a7ab3),  ivec4(0x005d7ab7,0x00607bb9,0x00617ab6,0x00647cb5),\n  ivec4(0x006f89bb,0x006684b8,0x00f2f7fe,0x00fdfcf9),  ivec4(0x00fffdf8,0x00fffdfd,0x00fdfcff,0x00f9fcff),  ivec4(0x00fefdff,0x00fffffc,0x00fffffc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fefffe,0x00fdfffd,0x00fdfffe,0x00fdfeff),  ivec4(0x00fefeff,0x00fcfeff,0x00fdfdff,0x00fcfdff),  ivec4(0x00fafefb,0x00fcfff8,0x00fafcfa,0x00ecf2fe),  ivec4(0x008ea0de,0x007b9df2,0x007ba6ff,0x0086affe),\n  ivec4(0x0091b7fd,0x0091bdfe,0x0094c1ff,0x0097c4ff),  ivec4(0x0099c5ff,0x009cc6fd,0x009ec6fd,0x009ac3f9),  ivec4(0x009ec3f6,0x00697a9d,0x00000000,0x00000000),  ivec4(0x00000003,0x0003030e,0x0002020d,0x00000008),\n  ivec4(0x00000000,0x00000003,0x00000002,0x0001010d),  ivec4(0x00070c15,0x00070e17,0x00000000,0x00000000),  ivec4(0x00141932,0x0037415f,0x00424e73,0x00505e85),  ivec4(0x0056668f,0x005f6f9b,0x006375a4,0x006779aa),\n  ivec4(0x006072a5,0x005a6c9d,0x0052628f,0x004c5b82),  ivec4(0x00404a68,0x00313a4f,0x00000012,0x00000000),  ivec4(0x00030000,0x00020108,0x00020410,0x00000000),  ivec4(0x00000011,0x00000000,0x00000000,0x0000010b),\n  ivec4(0x0000050c,0x00000002,0x00000000,0x00000000),  ivec4(0x0015203a,0x00546289,0x005c70a1,0x005872a9),  ivec4(0x005977af,0x005577af,0x00597ab0,0x00597ab2),  ivec4(0x005d7bb6,0x005f7bb8,0x00627bb7,0x00637cb6),\n  ivec4(0x006b86bb,0x00657fb1,0x00c4d2e7,0x00f3f7fa),  ivec4(0x00fefefe,0x00fefbfa,0x00fefeff,0x00fafdff),  ivec4(0x00fcfdff,0x00fffffe,0x00fffffe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fbfffc,0x00f9fffb,0x00fafffc,0x00fbfffd),  ivec4(0x00fcffff,0x00fdfdff,0x00fefcff,0x00fefbff),  ivec4(0x00fffdfc,0x00fffff6,0x00f8fbff,0x00d5e3f7),  ivec4(0x00829fe3,0x007da6fd,0x007eadff,0x008ab4fc),\n  ivec4(0x009bc0fd,0x009ac2fd,0x0099c7ff,0x0095cbff),  ivec4(0x0094cdff,0x009dd2fc,0x009dcaf9,0x00aacdfa),  ivec4(0x00738cb3,0x00000000,0x0001061e,0x00010211),  ivec4(0x00060610,0x0001030b,0x0000020c,0x0000010f),\n  ivec4(0x00000212,0x0000020c,0x00030712,0x00020513),  ivec4(0x0000030f,0x00000004,0x00222a3f,0x003e496a),  ivec4(0x0051608b,0x006b7eb8,0x00778dcd,0x00778ccc),  ivec4(0x00657cbd,0x00637abe,0x006178be,0x005d76be),\n  ivec4(0x00637bc4,0x006780cb,0x006b87cc,0x007a94d3),  ivec4(0x00778bc3,0x006779a6,0x00505d7d,0x003a4357),  ivec4(0x00090e1d,0x00000000,0x00010107,0x00010209),  ivec4(0x00010108,0x00040410,0x0000000c,0x00010009),\n  ivec4(0x00000008,0x00000107,0x00020601,0x00030a0f),  ivec4(0x00000000,0x00000e21,0x00596e91,0x0058729e),  ivec4(0x005877ac,0x005376ac,0x005979af,0x005b79b2),  ivec4(0x005d79b5,0x005f7bb7,0x00627cb8,0x006681ba),\n  ivec4(0x006781b7,0x006884b7,0x006e88b1,0x00e9f9ff),  ivec4(0x00fbfcfe,0x00fffffb,0x00fffffd,0x00fdffff),  ivec4(0x00fbfeff,0x00feffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fcfffe,0x00fbfffe,0x00fcfffc,0x00fcfffa),  ivec4(0x00fffffb,0x00fffffc,0x00fffefd,0x00fffdfd),  ivec4(0x00fffefc,0x00fdfdfa,0x00f1f9ff,0x009ab2e9),  ivec4(0x0081a7f5,0x007cabff,0x0085b3ff,0x0094bffe),\n  ivec4(0x00a0c6fb,0x00a2cafa,0x009ed0fe,0x0097d4ff),  ivec4(0x0094d5ff,0x0093cef5,0x00a6d3f9,0x00a6c2e5),  ivec4(0x00000000,0x0002081b,0x00020208,0x00070911),  ivec4(0x0007080e,0x0004060c,0x0001050e,0x00000311),\n  ivec4(0x00000210,0x0002050d,0x0000010b,0x00000009),  ivec4(0x00080e25,0x003d4661,0x005a6b96,0x007a8dc3),  ivec4(0x00768cc7,0x005f77bd,0x005c78c0,0x005c76bf),  ivec4(0x005a75be,0x005b75c0,0x005d76c2,0x005c76c4),\n  ivec4(0x005c75c4,0x005874c3,0x005876c5,0x005e7bc6),  ivec4(0x00627dc1,0x006882be,0x00859bcd,0x007489b6),  ivec4(0x0044587f,0x002e3b53,0x00000000,0x0002020a),  ivec4(0x00000005,0x00020106,0x00030009,0x0003010b),\n  ivec4(0x0001010d,0x0000010a,0x00050b03,0x00000400),  ivec4(0x0000060c,0x00000000,0x0025334d,0x005f749f),  ivec4(0x005974aa,0x005271ad,0x005977ae,0x005b79af),  ivec4(0x005d79b2,0x005e7ab6,0x00637fbb,0x00627eb7),\n  ivec4(0x00627eb5,0x006785b9,0x00607ca7,0x00d2e5f4),  ivec4(0x00f9fdff,0x00fffef8,0x00fffff7,0x00fffefa),  ivec4(0x00fffffd,0x00fffffc,0x00fffffd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffeff,0x00fffcff,0x00fefdfc,0x00fefdf7),  ivec4(0x00fefef4,0x00fffff5,0x00fffff8,0x00fffff9),  ivec4(0x00fffdfb,0x00faf7fd,0x00dfeeff,0x0082a5e6),  ivec4(0x0073a1f2,0x0082b4ff,0x008fbdff,0x0099c6fe),\n  ivec4(0x00a3cefc,0x00a7d3f8,0x00a1d4fb,0x009cd9ff),  ivec4(0x0099d9fe,0x009fd6f7,0x00b7dffd,0x00617287),  ivec4(0x00010418,0x0002050d,0x00070a11,0x00080b11),  ivec4(0x00070a10,0x00060711,0x00030611,0x00010715),\n  ivec4(0x00000615,0x00030816,0x00000001,0x001f273d),  ivec4(0x004b577a,0x007f91c2,0x007187c1,0x006880c1),  ivec4(0x00607bc0,0x00617dbe,0x00617dbd,0x005f7bbb),  ivec4(0x005e7aba,0x005f79bb,0x005f79bb,0x005f77bc),\n  ivec4(0x005e76bb,0x005f76bd,0x006076be,0x005f77be),  ivec4(0x005e77be,0x005c79bd,0x005e7dbf,0x005e80c1),  ivec4(0x006e90cf,0x006884b9,0x00424b60,0x0000000b),  ivec4(0x0000000a,0x00020208,0x00050107,0x0004000a),\n  ivec4(0x0001000b,0x0000000c,0x00010405,0x00010406),  ivec4(0x00000209,0x00000010,0x00000000,0x00596992),  ivec4(0x005f74ac,0x00566faf,0x005774a9,0x005c77ae),  ivec4(0x005c77b0,0x005f7bb8,0x005e7ab6,0x00607db6),\n  ivec4(0x00617fb6,0x006281b7,0x00607dab,0x0097a9cb),  ivec4(0x00f8faff,0x00fffefb,0x00fffffa,0x00fdfaf5),  ivec4(0x00fdfdfa,0x00fffffa,0x00fffffc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffbff,0x00fff9ff,0x00fffcff,0x00fefffd),  ivec4(0x00fcfef8,0x00fcfffb,0x00f9fbfd,0x00edf1f7),  ivec4(0x00e6e7f2,0x00e7ebf7,0x00c6ddfa,0x0078a2ec),  ivec4(0x0080afff,0x008bbbff,0x0099c5ff,0x009fcdfd),\n  ivec4(0x00a3d4fe,0x00aadafa,0x00a2d6f8,0x00a4ddfe),  ivec4(0x00a5ddfe,0x00acd9f8,0x00bedcf4,0x00263241),  ivec4(0x00010514,0x00060912,0x00070b14,0x00070a15),  ivec4(0x00070a16,0x00050715,0x00050918,0x00030718),\n  ivec4(0x0003081b,0x0000011e,0x00202944,0x005b6b96),  ivec4(0x008296cd,0x006c83c4,0x006883c7,0x006582c8),  ivec4(0x006582c7,0x006785c3,0x006786c1,0x006784c0),  ivec4(0x006582be,0x006681bd,0x006780bd,0x00677fbc),\n  ivec4(0x00667ebb,0x00677dba,0x00667bba,0x00637ab9),  ivec4(0x005f79bb,0x005b78bd,0x005777bf,0x005577c1),  ivec4(0x00597ec9,0x006688ca,0x008c9ec9,0x00404b68),  ivec4(0x00000015,0x0003040f,0x00010107,0x00030008),\n  ivec4(0x0001000b,0x0001000d,0x0000000d,0x0000020b),  ivec4(0x0001010b,0x0000000e,0x00000007,0x00434c71),  ivec4(0x0059699a,0x005d6eaa,0x005a73a7,0x005e79ab),  ivec4(0x005c77af,0x006079b5,0x005f7bb8,0x005f7bb7),\n  ivec4(0x00607eb7,0x006180b7,0x006682b3,0x006d80a8),  ivec4(0x00e5ebf4,0x00eae8f1,0x00ecedf2,0x00f2f5fe),  ivec4(0x00f2f7fa,0x00fdffff,0x00fefefd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffafe,0x00fffeff,0x00fcfafc,0x00f9feff),  ivec4(0x00ebf6fd,0x00e0eff9,0x00cfdff5,0x0098abdb),  ivec4(0x007683b8,0x007b8ac1,0x007d9fe6,0x0083b0fe),  ivec4(0x0087b5ff,0x0098c1fd,0x00a3cdfb,0x00a3d4fe),\n  ivec4(0x00a5d9ff,0x00a5dbf8,0x00ace1fe,0x00abdafe),  ivec4(0x00a5cff2,0x009bbbd5,0x0063778d,0x00000000),  ivec4(0x00050712,0x00020814,0x00040817,0x00040b1b),  ivec4(0x00070c1f,0x00080d20,0x000c0f23,0x000b0b1f),\n  ivec4(0x000e0d22,0x001b2346,0x006579af,0x007c92d0),  ivec4(0x007490d7,0x006c88d5,0x006b88d5,0x006d8bd3),  ivec4(0x006f8fd0,0x006c8ece,0x006b8cce,0x006b8acc),  ivec4(0x006a89cb,0x006b87c9,0x006a86c8,0x006a84c5),\n  ivec4(0x006982c2,0x006781c0,0x006581bd,0x00637fbb),  ivec4(0x00607cbb,0x005f7bbb,0x00607bbd,0x00627dc0),  ivec4(0x005a75b9,0x00617dc2,0x005773b6,0x00899fd3),  ivec4(0x003d4863,0x00000003,0x0000010a,0x00010107),\n  ivec4(0x0001000a,0x0000000c,0x00000011,0x0000000d),  ivec4(0x00020208,0x00020207,0x0002020b,0x0031384b),  ivec4(0x00546083,0x00576796,0x00576ea0,0x005974a7),  ivec4(0x005c75ac,0x005d77b3,0x005e7ab7,0x005e7cb7),\n  ivec4(0x005f7db6,0x005f80b8,0x00617db7,0x00657baf),  ivec4(0x005d71a1,0x005e7198,0x006579a2,0x00adbee1),  ivec4(0x00d2e0ef,0x00e2ecf7,0x00fdffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffefb,0x00feffff,0x00f7ffff,0x00eaf8fe),  ivec4(0x00bacfec,0x0090a9d8,0x007c98da,0x0084a1ee),  ivec4(0x008da3eb,0x007c92ce,0x007fa3ee,0x007faffe),  ivec4(0x008bb8fd,0x009ec7f9,0x00a8d2f8,0x00a3d6ff),\n  ivec4(0x00a2dcff,0x00ade5ff,0x009fd1f0,0x00add7f6),  ivec4(0x007a99bc,0x00000012,0x00000000,0x00070d1c),  ivec4(0x00060712,0x0002091b,0x00030a1d,0x00091023),  ivec4(0x000f162a,0x00151b30,0x001a1c34,0x00161832),\n  ivec4(0x001c1d3a,0x005c71a9,0x0087a2e5,0x007996df),  ivec4(0x006988d9,0x006f91e3,0x007192e0,0x007494dc),  ivec4(0x007798d7,0x007496de,0x007195df,0x007092dd),  ivec4(0x007091dc,0x00708fd9,0x00708dd7,0x006e8ad4),\n  ivec4(0x006d87d0,0x006888cd,0x006287c6,0x006183c3),  ivec4(0x006080be,0x00627dbb,0x00637bb7,0x00697eb8),  ivec4(0x006679b2,0x00677dbd,0x004d6fbd,0x006682c2),  ivec4(0x00889cca,0x00303c54,0x00000007,0x00000308),\n  ivec4(0x00010009,0x0001000a,0x00000010,0x0000010b),  ivec4(0x00010406,0x00040403,0x000a0e0f,0x00000000),  ivec4(0x00000221,0x003c4b6b,0x0049608b,0x00576ea0),  ivec4(0x005872a7,0x005a75b0,0x005c79b6,0x005c7ab7),\n  ivec4(0x005d7db8,0x005f7fb7,0x005f7cbc,0x006782c0),  ivec4(0x004d669f,0x004d68a1,0x004b6aa4,0x00466aa2),  ivec4(0x00385b8c,0x007c8eaf,0x00eaf1f5,0x00feffff),  ivec4(0x00fcfefe,0x00fefefe,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00feffff,0x00fefffe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffffe,0x00fffffe,0x00fdffff,0x00fdffff),  ivec4(0x00fdffff,0x00fdffff,0x00fdffff,0x00fdffff),\n  ivec4(0x00fdfcef,0x00fdfffc,0x00ebf6fe,0x00b3cbf4),  ivec4(0x008ab1ee,0x008dbaf7,0x0091bef8,0x0098c0f8),  ivec4(0x0099bffa,0x0091baf9,0x008bb6f7,0x008bb8f9),  ivec4(0x0094c3fe,0x009cccff,0x00a4d4fe,0x00a5d9ff),\n  ivec4(0x00a4dbff,0x009ed5f6,0x00a2c8e2,0x00677990),  ivec4(0x00000000,0x0000040a,0x00000710,0x00030816),  ivec4(0x00070919,0x00010a1c,0x00010d20,0x000c142a),  ivec4(0x00181f33,0x00242739,0x001f243e,0x00132146),\n  ivec4(0x00455987,0x007d9be5,0x007797e5,0x007a9be5),  ivec4(0x007a9de5,0x007ba0e4,0x007ba0e5,0x007ea2e5),  ivec4(0x007ea2e5,0x007ca1e5,0x007ba0e4,0x007a9fe4),  ivec4(0x00789de4,0x00779ce3,0x007799e1,0x007394de),\n  ivec4(0x007090db,0x006e8fd7,0x00688bce,0x006588ca),  ivec4(0x006486c7,0x005f80c1,0x006181c0,0x00607cbd),  ivec4(0x005f7cbb,0x00607cb9,0x005c7eb6,0x005e7cbf),  ivec4(0x00637fc4,0x007993c6,0x00060d1f,0x00010b10),\n  ivec4(0x00020206,0x00070107,0x00020008,0x00010108),  ivec4(0x00010206,0x00010107,0x00000107,0x0000020b),  ivec4(0x0000000a,0x00000000,0x00020014,0x005a698c),  ivec4(0x00596f9e,0x005774ae,0x005576b7,0x005977b8),\n  ivec4(0x005f7bb8,0x00677db5,0x006480bd,0x006380be),  ivec4(0x005976b3,0x00506ca8,0x004f6ca7,0x004f6ca6),  ivec4(0x00526ca5,0x00536ca1,0x00416092,0x00e6f5f8),  ivec4(0x00eaf5f9,0x00f9f9f6,0x00fffdfe,0x00fffbff),\n  ivec4(0x00fffbff,0x00fbfffd,0x00fafff9,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffffe,0x00fffffe,0x00fdffff,0x00fdffff),  ivec4(0x00fdffff,0x00fdffff,0x00fffffe,0x00fffffe),\n  ivec4(0x00fefffb,0x00f2fafa,0x00c9dbf4,0x0092b2e6),  ivec4(0x009ac6ff,0x0097ccff,0x009ed0ff,0x00a4d1ff),  ivec4(0x00a3cfff,0x0098c5ff,0x008ebbf8,0x0094c1fd),  ivec4(0x009ac9ff,0x009ccdff,0x00a2d5ff,0x00a6dbff),\n  ivec4(0x00a6dcfd,0x00a4d5f1,0x0082a2b9,0x00000000),  ivec4(0x00010714,0x00020a13,0x00010c14,0x00040a19),  ivec4(0x00070a1c,0x00060e1f,0x00071226,0x00121c33),  ivec4(0x001c2338,0x002a2b3f,0x001e2541,0x000c1644),\n  ivec4(0x008ba9e9,0x007f9feb,0x007e9fee,0x0080a3ec),  ivec4(0x0082a7eb,0x0084aaeb,0x0084aaea,0x0085abeb),  ivec4(0x0086aced,0x0085abec,0x0084aaeb,0x0083a9ea),  ivec4(0x0081a7ea,0x0080a5e9,0x007ea2e7,0x007a9ee4),\n  ivec4(0x007699e2,0x007497df,0x007093d7,0x006d90d4),  ivec4(0x006a8cd0,0x006688ca,0x006284c7,0x006181c4),  ivec4(0x005e7ec1,0x00607fbc,0x005f7fb4,0x005c7cbe),  ivec4(0x005f7dc7,0x006785bf,0x003c506d,0x00000207),\n  ivec4(0x00060509,0x00090108,0x00020107,0x00010107),  ivec4(0x00010107,0x00000109,0x0000010b,0x0000020c),  ivec4(0x0001030e,0x0000010c,0x00000112,0x00000b27),  ivec4(0x006677a0,0x00607cb1,0x005576b4,0x005977b8),\n  ivec4(0x005e7ab7,0x00687cb5,0x00647fbb,0x00627fbc),  ivec4(0x005774b1,0x00506ca8,0x00516ea7,0x00516da6),  ivec4(0x00536da5,0x00556fa7,0x005c73a5,0x0063799d),  ivec4(0x00ecfafb,0x00fbffff,0x00fdf8f8,0x00fffbff),\n  ivec4(0x00fffbff,0x00fdfffd,0x00fafffa,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdffff,0x00fdffff,0x00fffffe,0x00fffffe),  ivec4(0x00fffffe,0x00fffffc,0x00fffffc,0x00fffffc),\n  ivec4(0x00f3faff,0x00dcecfd,0x009eb8db,0x00acd4ff),  ivec4(0x00a6dbff,0x00a3deff,0x00a6dcff,0x00aad9ff),  ivec4(0x00a8d3ff,0x00a1cdff,0x0090bcf7,0x0097c3fe),  ivec4(0x009bcaff,0x00a0d0ff,0x00a5d7ff,0x00a8dcff),\n  ivec4(0x00aaddfd,0x00c4ecfb,0x00000000,0x0002091b),  ivec4(0x000f101e,0x00040c16,0x00030c1a,0x00050c1f),  ivec4(0x00080b21,0x000e1526,0x00121b2e,0x00172137),  ivec4(0x001d213a,0x001e2039,0x00131839,0x004a5c8b),\n  ivec4(0x0083a1e6,0x0085a8f2,0x0086a9f1,0x0089aef2),  ivec4(0x008bb2ef,0x008db5ef,0x008eb6f0,0x008eb6f0),  ivec4(0x008fb6f3,0x008eb5f2,0x008db4f1,0x008cb3f1),  ivec4(0x008ab0ef,0x0088aeee,0x0085abed,0x0082a7ea),\n  ivec4(0x007ea3e6,0x007ca1e6,0x00779be1,0x007396dc),  ivec4(0x007092d8,0x006a8cd2,0x006889ce,0x006483c9),  ivec4(0x00607fc5,0x00617fc1,0x005e7fb8,0x005b7bbd),  ivec4(0x005d7bc2,0x006481bc,0x007b95b7,0x00030408),\n  ivec4(0x0003050c,0x00050004,0x00020107,0x00010107),  ivec4(0x00000109,0x00000109,0x0001030d,0x0002040f),  ivec4(0x0000040f,0x0000030e,0x0003030c,0x0000000d),  ivec4(0x00293654,0x00526a98,0x005875ad,0x005975b5),\n  ivec4(0x005e7ab7,0x00657db9,0x00627dba,0x00617ebb),  ivec4(0x005874b0,0x00506ca8,0x00526ea7,0x00536da5),  ivec4(0x00536ca4,0x00546da5,0x00556da5,0x005c729f),  ivec4(0x008c9eb4,0x00f5fdfe,0x00ffffff,0x00fffeff),\n  ivec4(0x00fffdff,0x00ffffff,0x00fdfffc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdffff,0x00fdffff,0x00fffffe,0x00fffffc),  ivec4(0x00fffffb,0x00fffffb,0x00fffffc,0x00fffffe),\n  ivec4(0x00ecf9fe,0x00aac5ea,0x00b2d7fa,0x00aadcfd),  ivec4(0x00b2edff,0x00afefff,0x00aee7fe,0x00addcff),  ivec4(0x00a8d3ff,0x00a3d0ff,0x0092bff8,0x009cc9ff),  ivec4(0x009ac9fc,0x00a2d3ff,0x00a7daff,0x00a9ddff),\n  ivec4(0x00afdffa,0x00648196,0x00000d20,0x00111123),  ivec4(0x00090917,0x00070d1b,0x00071022,0x000b1329),  ivec4(0x0010142d,0x00161c2b,0x00171f33,0x00161e36),  ivec4(0x00121730,0x000e122b,0x00000025,0x007c93cd),\n  ivec4(0x0084a6ef,0x008db1f6,0x008fb5f5,0x0092b9f6),  ivec4(0x0095bef4,0x0095bff3,0x0095bff3,0x0096c0f4),  ivec4(0x0097c0f6,0x0096bff5,0x0095bef4,0x0093bbf4),  ivec4(0x0092baf3,0x0091b9f3,0x008fb6f2,0x008bb2ef),\n  ivec4(0x0087aeeb,0x0085abeb,0x0080a5e9,0x007a9fe3),  ivec4(0x00769ae0,0x007294da,0x006d8fd7,0x006888d2),  ivec4(0x006484ce,0x006483c8,0x006281be,0x005c7cbe),  ivec4(0x005a7bc0,0x006180bc,0x00809ac4,0x00242e42),\n  ivec4(0x00000009,0x00030207,0x00000109,0x00000109),  ivec4(0x00000109,0x0000000a,0x0002040f,0x00010510),  ivec4(0x00020513,0x00000410,0x000c0b0f,0x00060914),  ivec4(0x00000118,0x006b7da4,0x005d75aa,0x005975b1),\n  ivec4(0x005c79b6,0x00617dba,0x00607cb8,0x00607cb8),  ivec4(0x005773af,0x00526da7,0x00516ca5,0x00516aa2),  ivec4(0x00516aa0,0x00526aa0,0x00526aa8,0x005269a2),  ivec4(0x0061779b,0x00c4d2dd,0x00f8ffff,0x00fffffc),\n  ivec4(0x00fffffe,0x00fffeff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdffff,0x00fdffff,0x00fffffe,0x00fffffb),  ivec4(0x00fffffb,0x00fffffc,0x00fcffff,0x00f6fbfe),\n  ivec4(0x00b9d0ea,0x00a7ccf7,0x00b1dfff,0x00b5ecff),  ivec4(0x00b4f4fe,0x00b5f7fc,0x00aeeaf9,0x00a4d6f8),  ivec4(0x00aad7ff,0x00a2ceff,0x0092bef5,0x00a3cffd),  ivec4(0x009dcbfe,0x00a6d5ff,0x00a7d9fe,0x00aaddfd),\n  ivec4(0x00bae9ff,0x00273543,0x00020a1b,0x000a091a),  ivec4(0x000d0b1b,0x00070e1f,0x00081327,0x00101930),  ivec4(0x00191c35,0x00202232,0x00161d2f,0x00111931),  ivec4(0x000e132c,0x00060b25,0x00010234,0x00a0baf3),\n  ivec4(0x008bb1fb,0x0095befc,0x0098c1fa,0x009bc6fa),  ivec4(0x009cc8f8,0x009cc9f5,0x009cc9f5,0x009cc8f7),  ivec4(0x009cc8f7,0x009cc7f8,0x009bc6f7,0x0099c4f7),  ivec4(0x0098c2f7,0x0096c0f5,0x0093bdf3,0x0091baf1),\n  ivec4(0x008fb8ef,0x008bb3f0,0x0087aff0,0x0082aaeb),  ivec4(0x007da2e6,0x00789de1,0x007395dc,0x006e8fd8),  ivec4(0x006a8ad3,0x006784cd,0x006583c4,0x005d7dbf),  ivec4(0x005a7ebe,0x005b7db9,0x006580b1,0x00425173),\n  ivec4(0x0000000a,0x0003060b,0x00000005,0x0000010b),  ivec4(0x0000010b,0x0000020d,0x00040813,0x00020614),  ivec4(0x00000512,0x00000410,0x00090506,0x000c0a11),  ivec4(0x0000000a,0x004d5f81,0x005e75a5,0x005b76ae),\n  ivec4(0x005d7ab7,0x006480c0,0x005c78b4,0x005d7ab3),  ivec4(0x005773ac,0x005870aa,0x00536ca4,0x0050689f),  ivec4(0x004d669c,0x004e669c,0x0046609d,0x00536eac),  ivec4(0x005b73a0,0x00637693,0x00edfcfe,0x00f8ffff),\n  ivec4(0x00fcfcf8,0x00fffeff,0x00fffdff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdffff,0x00fdffff,0x00fffffc,0x00fffffb),  ivec4(0x00fdfefa,0x00faffff,0x00f4fcff,0x00e4f1ff),\n  ivec4(0x00abcdec,0x00a9d8fe,0x00b3e6ff,0x00b6f0ff),  ivec4(0x00baf8fe,0x00b7f7f7,0x00b6f2fc,0x00ace3fe),  ivec4(0x00a2d1fb,0x009fcaff,0x0099c5fb,0x0098c4f9),  ivec4(0x00a5d3ff,0x00a6d6ff,0x00a8dafe,0x00abdffd),\n  ivec4(0x00bbeaff,0x0017202a,0x00000617,0x000a081b),  ivec4(0x000e0e22,0x000a1325,0x000b192c,0x00121c30),  ivec4(0x00171b31,0x00121222,0x0013162a,0x00090e27),  ivec4(0x00070d24,0x00040c25,0x00192641,0x00adcbff),\n  ivec4(0x008ebcff,0x009ac6ff,0x00a0cbfc,0x00a3cffc),  ivec4(0x00a4d1fb,0x00a2d1f6,0x00a2d1f6,0x00a2d0f7),  ivec4(0x00a2cff9,0x00a2cffa,0x00a1cef9,0x009fccf8),  ivec4(0x009ecaf8,0x009bc7f6,0x009ac5f6,0x0098c3f4),\n  ivec4(0x0095c0f1,0x0092bcf4,0x008cb7f5,0x0089b1f0),  ivec4(0x0082aaea,0x0080a5e7,0x00799ee2,0x007597dd),  ivec4(0x007192db,0x006b8bd4,0x006a86cc,0x005f82c2),  ivec4(0x005b82c0,0x005b7fbb,0x00617db6,0x00576794),\n  ivec4(0x00000012,0x00000109,0x00000108,0x00000008),  ivec4(0x00050712,0x00010510,0x00050916,0x00010814),  ivec4(0x00000514,0x00000412,0x00080609,0x00070710),  ivec4(0x0000000d,0x00415172,0x005c73a1,0x005a76ac),\n  ivec4(0x00617fba,0x006382c1,0x005d7ab6,0x005e7ab3),  ivec4(0x00546fa7,0x00546da5,0x004d659c,0x004b6399),  ivec4(0x004a6196,0x004b6195,0x0047629a,0x004866a2),  ivec4(0x00546da5,0x00526894,0x009fb0c6,0x00f2ffff),\n  ivec4(0x00f6fbfa,0x00fffdff,0x00fffdff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdffff,0x00fffffe,0x00fffffc,0x00fffffc),  ivec4(0x00fcffff,0x00f4fcff,0x00edfdff,0x00bfd5ed),\n  ivec4(0x00abd6f3,0x00ade2ff,0x00b5eaff,0x00b9efff),  ivec4(0x00bdf7ff,0x00c0feff,0x00b4f0fb,0x00ace4fe),  ivec4(0x009ccef7,0x00aed9ff,0x0093bef1,0x00a3ceff),  ivec4(0x00a2cffd,0x00a9d7ff,0x00aadbfc,0x00aee0fc),\n  ivec4(0x00beebff,0x000f1a25,0x00050f21,0x000a0b20),  ivec4(0x000a0e22,0x000e172b,0x000f1d2f,0x00101b2d),  ivec4(0x00101427,0x00121022,0x00020217,0x0001061e),  ivec4(0x00090f25,0x00091429,0x002e3d54,0x00a0c5f3),\n  ivec4(0x0099cbff,0x00a0ceff,0x00a6d3ff,0x00a9d7fe),  ivec4(0x00aad9fc,0x00a7d7f8,0x00a7d7f8,0x00a7d7f8),  ivec4(0x00a7d7f9,0x00a6d6fa,0x00a5d4fa,0x00a4d3f9),  ivec4(0x00a2d0f9,0x00a0cef7,0x009fccf7,0x009dcaf6),\n  ivec4(0x009bc7f4,0x0096c3f5,0x0091bff5,0x008ebaf4),  ivec4(0x008ab3ef,0x0086aeed,0x0082a8e9,0x007ba0e4),  ivec4(0x00789ae0,0x007292db,0x006c8ad4,0x006185c5),  ivec4(0x005b83bd,0x00597ebc,0x00637fbf,0x006171a5),\n  ivec4(0x00000002,0x00020a12,0x0002050e,0x0001030d),  ivec4(0x0000010c,0x000a0d1a,0x00030a16,0x00020918),  ivec4(0x00000615,0x00000614,0x0004060d,0x0000030e),  ivec4(0x00000317,0x00334464,0x0059709d,0x005b77ad),\n  ivec4(0x006886c1,0x006283c1,0x005b78b4,0x00607bb3),  ivec4(0x005b75ad,0x005b73aa,0x00465e94,0x00445b90),  ivec4(0x0043598d,0x00445a8e,0x00435e8f,0x00446095),  ivec4(0x004e66a5,0x005b6fad,0x005e729c,0x00d4e7f3),\n  ivec4(0x00f3fefe,0x00feffff,0x00fffdfe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdffff,0x00fffffe,0x00fffffc,0x00fffffe),  ivec4(0x00fbffff,0x00eefcff,0x00d9eeff,0x00aac8ea),\n  ivec4(0x00b0e1f9,0x00b1e9fe,0x00b8edff,0x00bef0ff),  ivec4(0x00bff6ff,0x00c1fdff,0x00b7f2fe,0x00b5eeff),  ivec4(0x0092c4eb,0x00213b65,0x006d97c7,0x009ac5f6),  ivec4(0x00aad6ff,0x00aad8ff,0x00acdcfc,0x00aee1fb),\n  ivec4(0x00bfebff,0x00111925,0x00010b1f,0x00090d25),  ivec4(0x000d1327,0x000d1a2d,0x00091929,0x00081423),  ivec4(0x00090e1d,0x000b071a,0x000b0a1f,0x0000000a),  ivec4(0x00000000,0x00000000,0x00233d55,0x00a3ccf2),\n  ivec4(0x0092ccff,0x00a5d5ff,0x00abd8ff,0x00addeff),  ivec4(0x00aedfff,0x00addffc,0x00addffc,0x00addffc),  ivec4(0x00addffd,0x00acdcfe,0x00abdbfd,0x00a9d8fc),  ivec4(0x00a8d8fc,0x00a7d6fc,0x00a5d4fa,0x00a3d1fa),\n  ivec4(0x00a1cff8,0x009dccf8,0x0098c7fa,0x0095c3f8),  ivec4(0x0090bdf4,0x008fb8f4,0x0089b1f0,0x0084aaea),  ivec4(0x0080a3e5,0x007a9ae3,0x007490dd,0x00678bcc),  ivec4(0x005f87c1,0x005c81bf,0x006782c4,0x0054659c),\n  ivec4(0x00000000,0x00000000,0x00000000,0x0001030a),  ivec4(0x000b0f1a,0x00050a17,0x00060c19,0x00020919),  ivec4(0x00010819,0x00000717,0x00000411,0x00000311),  ivec4(0x0000041a,0x002f4263,0x005a719e,0x005c78ae),\n  ivec4(0x006f8dc7,0x006081c0,0x005f7ab4,0x006a83bb),  ivec4(0x00122457,0x001e346a,0x00435b91,0x003f568a),  ivec4(0x003e5588,0x00405689,0x00435e88,0x0042608e),  ivec4(0x00475fa1,0x005164ab,0x005669a2,0x0097abc1),\n  ivec4(0x00f2ffff,0x00f7fffc,0x00fbfbfb,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffdff,0x00fffeff,0x00fffffb,0x00fffffc),  ivec4(0x00fdfcff,0x00f0fbff,0x00b6d3ee,0x00aadbfa),\n  ivec4(0x00b1e8fe,0x00b4ecff,0x00b7efff,0x00bbf6ff),  ivec4(0x00bdf9ff,0x00bef7fd,0x00bbf1fd,0x00c1f3ff),  ivec4(0x0026517a,0x00002259,0x004e70a3,0x009bc8fe),  ivec4(0x00a3d6fe,0x00a3ddf6,0x00a8e2f4,0x00ade3fa),\n  ivec4(0x00bbe9ff,0x00192029,0x00000416,0x00120f24),  ivec4(0x00111024,0x000b1327,0x00011124,0x00011526),  ivec4(0x00000000,0x00000000,0x0000002f,0x00a0c1d0),  ivec4(0x00c4e4ec,0x00c3e7f8,0x00bbe8fd,0x009dcef3),\n  ivec4(0x00a2d2fe,0x00acdbfb,0x00b1e2fe,0x00b6e3ff),  ivec4(0x00bbe5ff,0x00bbe6fe,0x00b8e8fe,0x00b4e8fe),  ivec4(0x00b0e9fd,0x00b1e6fc,0x00b1e3fc,0x00afe0fc),  ivec4(0x00acddfc,0x00abdcfc,0x00aadbfe,0x00a7d8fe),\n  ivec4(0x00a5d6fd,0x00a3d3fc,0x00a0cefb,0x009bcafa),  ivec4(0x0097c5f7,0x0094c0f6,0x008cb8f2,0x0087b2f0),  ivec4(0x0081abeb,0x007ca3e5,0x007a9ae0,0x006e92d1),  ivec4(0x00658ac8,0x005e83c2,0x00688acb,0x005a78b4),\n  ivec4(0x007d9dce,0x009cbfe6,0x0097b1dc,0x004d658c),  ivec4(0x00000000,0x00000000,0x00000817,0x00080f1b),  ivec4(0x0003050e,0x00100e16,0x00040314,0x00000315),  ivec4(0x00000215,0x002f4462,0x00556f9d,0x00637fbb),\n  ivec4(0x00728fd1,0x00617fc1,0x00607bb4,0x006c87bb),  ivec4(0x0000043b,0x00010e3e,0x00354877,0x00405484),  ivec4(0x00415787,0x003b5283,0x00405a8b,0x00425d90),  ivec4(0x004b619c,0x004e62a3,0x00546ba6,0x00566c97),\n  ivec4(0x00ebf6ff,0x00f6f6fd,0x00fff9f6,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffcff,0x00fffeff,0x00fffffa,0x00fffffc),  ivec4(0x00f9f9ff,0x00ebf4ff,0x00abcdea,0x00a4dffb),\n  ivec4(0x00afe8ff,0x00b4ebff,0x00b4eefd,0x00b6f4fe),  ivec4(0x00b6f4fd,0x00b4eefc,0x00bbedff,0x00a5d1eb),  ivec4(0x00000536,0x00002366,0x0027458a,0x009dc8ff),  ivec4(0x009dd1ff,0x00a0ddf8,0x00a7e3f5,0x00aae1fc),\n  ivec4(0x00b8e5ff,0x00212e36,0x00040f1c,0x00120e1f),  ivec4(0x00141023,0x00040d20,0x00000012,0x00000000),  ivec4(0x007891a4,0x00b7daeb,0x00c2effb,0x00bff1fd),  ivec4(0x00bef1fd,0x00bdf0ff,0x00b3ecff,0x0099d0f5),\n  ivec4(0x00a2d1fe,0x00aaddfc,0x00b2e4fe,0x00b8e8fe),  ivec4(0x00beebfd,0x00c1ecfc,0x00bfeefd,0x00baeffe),  ivec4(0x00b5f0fd,0x00b8eefe,0x00b9ebfe,0x00b6e8fd),  ivec4(0x00b3e5fd,0x00b2e3fe,0x00aee0fe,0x00acddfe),\n  ivec4(0x00a9dafd,0x00a8d7fd,0x00a5d3fc,0x00a1cefa),  ivec4(0x009ccaf9,0x0099c6fa,0x0092c0f7,0x008db9f4),  ivec4(0x0087b3f1,0x0080abea,0x007da0e2,0x007095d7),  ivec4(0x00678acf,0x006083c7,0x005579b7,0x0088ade8),\n  ivec4(0x009cc5fb,0x0099c7f9,0x009ac2fb,0x008eb5ea),  ivec4(0x009bbeec,0x0087a3c8,0x001b334d,0x00000000),  ivec4(0x00040715,0x000b0f1b,0x00090717,0x0000000f),  ivec4(0x00000214,0x00425979,0x004c669c,0x00758fd4),\n  ivec4(0x006d89d0,0x006280c1,0x005c77b1,0x004c639b),  ivec4(0x00001246,0x00001041,0x001e2f5e,0x00445788),  ivec4(0x003e5287,0x003d5188,0x003c538d,0x00415a92),  ivec4(0x004b6298,0x004d649c,0x004d66a2,0x005c6fa7),\n  ivec4(0x00a5afcd,0x00fbf7fe,0x00fffffe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffcff,0x00fffeff,0x00fffffb,0x00fffffd),  ivec4(0x00f8fbff,0x00d6e5fc,0x00aed1f1,0x00a9e3ff),\n  ivec4(0x00b0e7ff,0x00b2e7ff,0x00b0eafe,0x00b2eeff),  ivec4(0x00b3efff,0x00b2e9fd,0x00b1e2ff,0x008eb5d6),  ivec4(0x00001a54,0x0002216f,0x0002257c,0x0091b8ff),  ivec4(0x0099c8ff,0x00a3d8ff,0x00a8e0fc,0x00aadfff),\n  ivec4(0x00b4e1ff,0x003c5760,0x00051420,0x000b0c1c),  ivec4(0x00111827,0x00000000,0x00415c6b,0x00bde3f0),  ivec4(0x00c1e7f4,0x00baecfd,0x00c6f8fd,0x00c1f3fc),  ivec4(0x00bff3f9,0x00b3e8f2,0x00b6eafe,0x009ccff5),\n  ivec4(0x0099cdf9,0x00a5dbff,0x00afe4ff,0x00b5eaff),  ivec4(0x00bdf1fd,0x00c0f5fb,0x00c3f7fc,0x00c4f8ff),  ivec4(0x00c0f6ff,0x00c1f4ff,0x00c2f2ff,0x00c0f0ff),  ivec4(0x00bbecfe,0x00b8eaff,0x00b6e6ff,0x00b2e4ff),\n  ivec4(0x00afdffd,0x00aedcfe,0x00abd9fe,0x00a6d4fd),  ivec4(0x00a1cffc,0x009ecbfc,0x0096c5f9,0x0092bff9),  ivec4(0x008cbaf5,0x0086b1f0,0x0084a5eb,0x007397e1),  ivec4(0x00668dd7,0x006286cb,0x005476ad,0x00adcdf6),\n  ivec4(0x00afd2fb,0x00aad4fc,0x00aad7fe,0x009fcafb),  ivec4(0x0096c0f5,0x0092b6ed,0x0097b6ea,0x007f98c3),  ivec4(0x00000000,0x00000223,0x00070b1c,0x00020615),  ivec4(0x0000000e,0x005a709b,0x006983c3,0x007d98e1),\n  ivec4(0x006784cb,0x006283c0,0x005b77b0,0x0024356a),  ivec4(0x00051851,0x00021249,0x00020d47,0x0043548d),  ivec4(0x003a4b89,0x003c508f,0x00364e8a,0x003f5890),  ivec4(0x004a6197,0x004e629c,0x004e65a0,0x00546aa0),\n  ivec4(0x00717ca3,0x00ffffff,0x00fffcfe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fefdff,0x00fffeff,0x00fffffc,0x00fffeff),  ivec4(0x00f5fcff,0x00bdd4f0,0x00b2d9fc,0x00b0e6ff),\n  ivec4(0x00aee3ff,0x00aee1ff,0x00ace1fe,0x00ace3fe),  ivec4(0x00ade5fe,0x00b2e6ff,0x00b5e2ff,0x006387b1),  ivec4(0x00002060,0x00082377,0x000a297f,0x006687d2),  ivec4(0x0099c3ff,0x00a1d3ff,0x00a8ddff,0x00abe0ff),\n  ivec4(0x00b4e3ff,0x0083a8b1,0x0000010c,0x000a1a27),  ivec4(0x00000000,0x0088a4b2,0x00c4f0f8,0x00b5e6f2),  ivec4(0x00c0f2fe,0x00b6f3ff,0x00c8f7fc,0x00c5eef2),  ivec4(0x00c2efee,0x00ccf6f9,0x00d5f6ff,0x00c2e4fc),\n  ivec4(0x00a1cff6,0x00a2d7ff,0x00a8e0ff,0x00b0ebff),  ivec4(0x00b9f5fd,0x00c0fbfb,0x00c5fefb,0x00c9ffff),  ivec4(0x00cbfdff,0x00c9faff,0x00c8f8ff,0x00c6f5ff),  ivec4(0x00c2f3fe,0x00c1f1ff,0x00bdefff,0x00bae9ff),\n  ivec4(0x00b4e6fd,0x00b1e2fe,0x00addeff,0x00a9dafd),  ivec4(0x00a4d5fc,0x00a1d1fd,0x0099c8fb,0x0095c3f9),  ivec4(0x0090bff7,0x008ab5f4,0x0088a8f2,0x007399e8),  ivec4(0x00668ddc,0x006687c7,0x006f88b4,0x00bad0eb),\n  ivec4(0x00bfdaf1,0x00b9dbf4,0x00b4dff9,0x00b0daff),  ivec4(0x00a0c9fa,0x009dc2fd,0x008fb3fa,0x008eb1f1),  ivec4(0x0086a7dc,0x00254069,0x00000518,0x0000081b),  ivec4(0x00131c35,0x008296cd,0x00839be6,0x00758fe1),\n  ivec4(0x006887cc,0x005d80b5,0x005771a7,0x000a184a),  ivec4(0x000d2055,0x000d1b52,0x0000043e,0x003c4b85),  ivec4(0x003e4e8d,0x003a4d8e,0x00334b89,0x003b558d),  ivec4(0x004a6197,0x004d629a,0x004d649e,0x004c639b),\n  ivec4(0x0062709b,0x00dcdff2,0x00fcfafe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fcfdff,0x00fffdfe,0x00fffefe,0x00fafbfe),  ivec4(0x00ebf8ff,0x00abcbea,0x00b1dfff,0x00b4e7ff),\n  ivec4(0x00acdbff,0x00abdaff,0x00a5d7fe,0x00a3d8fd),  ivec4(0x00a7dbfe,0x00a6d5fd,0x00acd6ff,0x00375a91),  ivec4(0x00052767,0x00051f6d,0x0016327d,0x00355091),  ivec4(0x00a7ceff,0x009ecbfd,0x00a7dbfe,0x00a2d8f4),\n  ivec4(0x00b4ebfe,0x00c3eff9,0x0000000b,0x00000000),  ivec4(0x00a0bbc9,0x00bee9f5,0x00bcf0fb,0x00bcf6fe),  ivec4(0x00bff9ff,0x00bbf5ff,0x00d0eefc,0x00e5f8fa),  ivec4(0x00e5fefd,0x00ecfffd,0x00fafbfd,0x00f7f9ff),\n  ivec4(0x00c3d7e9,0x00a8d5ff,0x00a9dfff,0x00afeaff),  ivec4(0x00b7f6fe,0x00befdfc,0x00c4fffc,0x00c9ffff),  ivec4(0x00cffdff,0x00ccfcff,0x00ccfdff,0x00ccfbff),  ivec4(0x00c8f9ff,0x00c5f6ff,0x00c2f2ff,0x00beeeff),\n  ivec4(0x00b9eafd,0x00b4e6fe,0x00afe1ff,0x00abddfd),  ivec4(0x00a6d7fd,0x00a3d2fe,0x009bcafe,0x0098c7fd),  ivec4(0x0093c2fb,0x008db8f7,0x0086a7f3,0x007a9ff0),  ivec4(0x00678ad5,0x00748bbe,0x00cbd0e0,0x00cdd1d4),\n  ivec4(0x00cedbe0,0x00bbd4de,0x00b3d2d8,0x00b9daec),  ivec4(0x00b7d9ff,0x00a4c8ff,0x009abeff,0x0090b5fa),  ivec4(0x008fb3f2,0x008cafe4,0x00303d50,0x0006132d),  ivec4(0x00304066,0x008aa0e1,0x008298ec,0x00748ee2),\n  ivec4(0x006482c4,0x005e82af,0x004f6a94,0x00000530),  ivec4(0x000c1e48,0x00162651,0x00000a3a,0x003c4e7f),  ivec4(0x003f538b,0x003b4f8b,0x00314a86,0x0039538b),  ivec4(0x004a6196,0x004f639b,0x004b639e,0x004d659f),\n  ivec4(0x00596d99,0x009fa7bf,0x00f9fbff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdfeff,0x00fffdfe,0x00fffdff,0x00fafbff),  ivec4(0x00d1e7fb,0x00a1ccee,0x00abdeff,0x00b2e2ff),\n  ivec4(0x00a7d3ff,0x00a5d1ff,0x009dcdfd,0x009acbfb),  ivec4(0x009cccfd,0x009ec9fd,0x00a3c8ff,0x00194080),  ivec4(0x00072769,0x000a2569,0x00072462,0x0007103c),  ivec4(0x00436090,0x00a7cfff,0x00a7d6fe,0x00b8effe),\n  ivec4(0x00ade9f7,0x00b1e3f1,0x0020404c,0x007897a7),  ivec4(0x00bde4f2,0x00baedf9,0x00b5f1fc,0x00baf8ff),  ivec4(0x00befaff,0x00bef1fc,0x00eaf3ff,0x00fdfcff),  ivec4(0x00f5fffd,0x00fcfbf3,0x00fffff6,0x00e9cabe),\n  ivec4(0x00949085,0x00b7d7f3,0x00aad7fa,0x00afe3fd),  ivec4(0x00b3effe,0x00b7f7fe,0x00bef9fe,0x00c6fcff),  ivec4(0x00ccfcff,0x00cbfbff,0x00cbfdff,0x00cbfcff),  ivec4(0x00c9f9ff,0x00c5f6ff,0x00c0f2ff,0x00beefff),\n  ivec4(0x00b9ecff,0x00b5e7ff,0x00b0e2ff,0x00acddfe),  ivec4(0x00a7d8fe,0x00a4d3ff,0x009ccaff,0x0098c4ff),  ivec4(0x0092bffd,0x008bb5f7,0x0083a5f3,0x007497e6),  ivec4(0x007690cf,0x008f90aa,0x006e625f,0x00eedabe),\n  ivec4(0x00d8d5c7,0x00c5d5d7,0x00c6d5cc,0x00baced3),  ivec4(0x00b9d3ee,0x00afd0ff,0x009fc2fe,0x008eb2f4),  ivec4(0x008aaeee,0x008eb0ec,0x009db2dd,0x00000000),  ivec4(0x00809bcf,0x0088a5ea,0x00809bee,0x00728dde),\n  ivec4(0x00617ebd,0x005775a1,0x00233c5d,0x0000001c),  ivec4(0x00010928,0x00061738,0x00000f35,0x003f517b),  ivec4(0x003e5586,0x003b548b,0x00314c85,0x0038538b),  ivec4(0x004b6095,0x0050649c,0x004c639e,0x00445e98),\n  ivec4(0x00506797,0x007785a4,0x00f6fdff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdffff,0x00fffdfe,0x00fffdff,0x00fbfcff),  ivec4(0x00b8d4eb,0x009dd0f6,0x00a5ddff,0x00aedaff),\n  ivec4(0x00a5cefe,0x009fc9ff,0x0095c2fc,0x008fbdf7),  ivec4(0x008fbcf8,0x0091b9fa,0x0093b7fb,0x00022e77),  ivec4(0x00082468,0x00072262,0x00000f46,0x00021a4e),  ivec4(0x00001656,0x005270a5,0x00a9d4ff,0x009fd5f4),\n  ivec4(0x00a6e3f6,0x00b6effd,0x00a4d2e8,0x00bde4f7),  ivec4(0x00c1edfd,0x00b6ecfc,0x00b2effc,0x00b8f4ff),  ivec4(0x00bbf0fd,0x00c5eff4,0x00fbfaff,0x00fffaff),  ivec4(0x00fafffd,0x00fffeee,0x00fbeed3,0x00ae6a42),\n  ivec4(0x00a9813f,0x00afbec5,0x00c0e0fa,0x00b3ddf8),  ivec4(0x00aadffc,0x00b0ecff,0x00b5f0ff,0x00c0f6ff),  ivec4(0x00c5f7ff,0x00c6faff,0x00c8faff,0x00c6f9ff),  ivec4(0x00c4f7ff,0x00c0f3ff,0x00bef0ff,0x00baedff),\n  ivec4(0x00b8ebff,0x00b4e6ff,0x00afe1ff,0x00abddfe),  ivec4(0x00a6d7ff,0x00a3d2ff,0x009dcbff,0x0098c4ff),  ivec4(0x0091bdfd,0x0088b2f7,0x0085acf7,0x006d90d7),  ivec4(0x008f9eca,0x006e5e60,0x00976732,0x00a47c4f),\n  ivec4(0x00efddc1,0x00cbd5d3,0x00d2d6cc,0x00bfc8c9),  ivec4(0x00b7cbdd,0x00b7d6f8,0x009ec4f6,0x008cb0ee),  ivec4(0x0082a5e6,0x0081a1e3,0x0088a2df,0x007b96d0),  ivec4(0x0081a2df,0x007798de,0x006b89d6,0x006882cd),\n  ivec4(0x006077b3,0x001f345b,0x00010f2b,0x0002132c),  ivec4(0x00000b27,0x00000826,0x00000e33,0x00394b75),  ivec4(0x003c5485,0x003b548c,0x00314c88,0x0038538b),  ivec4(0x004b6096,0x0051659a,0x004d649f,0x0046629f),\n  ivec4(0x00486195,0x0063749d,0x00f3feff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdffff,0x00fffeff,0x00fffdff,0x00f7f8ff),  ivec4(0x00accde9,0x0098d3f9,0x009dd8ff,0x00abd7ff),\n  ivec4(0x00a4cafe,0x009dc5ff,0x008eb8f6,0x0082adee),  ivec4(0x0082acf1,0x007fa4ed,0x0083a5ef,0x00002774),  ivec4(0x0009246c,0x00071f61,0x00021951,0x000a235c),  ivec4(0x00041b60,0x00001665,0x008fb4f5,0x00a1d4fe),\n  ivec4(0x009edcf7,0x009ad7ef,0x00b5e6fe,0x00c1ecff),  ivec4(0x00bdecff,0x00b3ecff,0x00b1ecfe,0x00bbf1ff),  ivec4(0x00b8e6f6,0x00cbf7f4,0x00fffcff,0x00fff8ff),  ivec4(0x00f3fffb,0x00fffff0,0x00d4946c,0x00f18f42),\n  ivec4(0x00bc851a,0x00535953,0x009aafc0,0x00b2d4f4),  ivec4(0x00b3e2ff,0x00aadfff,0x00ace4ff,0x00b6ecff),  ivec4(0x00bcf2fb,0x00bcf2fb,0x00bdf2fc,0x00bdf1fd),  ivec4(0x00bbeffe,0x00b8ebfe,0x00b6e9ff,0x00b3e7ff),\n  ivec4(0x00b2e4ff,0x00b0e2fe,0x00addefc,0x00a9d9fb),  ivec4(0x00a4d3fc,0x00a1cfff,0x009ac7ff,0x0095befe),  ivec4(0x008cb6fa,0x007faaf4,0x006391de,0x0080a2e3),  ivec4(0x00464d68,0x00875d3c,0x00ae671c,0x00b06f20),\n  ivec4(0x00e2caa9,0x00ced3d4,0x00d3d0d1,0x00c4cbd2),  ivec4(0x00b2c8d9,0x00b3d8f4,0x009bc6f1,0x0088b2ec),  ivec4(0x007da1e7,0x007796e5,0x007290e1,0x006486d0),  ivec4(0x006e96d8,0x006088c9,0x006082c7,0x005973b8),\n  ivec4(0x00394c86,0x00000b38,0x00041634,0x00041633),  ivec4(0x00021131,0x0000092d,0x00000c36,0x00324172),  ivec4(0x003b4e89,0x00374d8d,0x002f4b89,0x0037538b),  ivec4(0x004b6096,0x0051659a,0x004b629d,0x004864a4),\n  ivec4(0x00456097,0x00566b97,0x00dbe7fc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fbfeff,0x00fefdfd,0x00fffdfe,0x00f3f6ff),  ivec4(0x00a9cdeb,0x0094cefa,0x0099d2fe,0x00a9d5fe),\n  ivec4(0x00a3cbfd,0x0097c2fe,0x0085aff3,0x0077a0ea),  ivec4(0x00779feb,0x007398e4,0x007394e0,0x00002375),  ivec4(0x0008236d,0x00031c5c,0x00041e5a,0x00021d5c),  ivec4(0x0007206d,0x000d267d,0x005373bc,0x0092bff6),\n  ivec4(0x009ed4f9,0x00a6e1fc,0x00a2d6f6,0x00b3e2fd),  ivec4(0x00b5e7fd,0x00b6ecff,0x00b4ecff,0x00bbeeff),  ivec4(0x00b2dff1,0x00ddfef6,0x00fffaff,0x00fffbff),  ivec4(0x00f1fffa,0x00f9f2dc,0x00c98228,0x00ea9f36),\n  ivec4(0x00bf8c33,0x00000000,0x00364349,0x00a7abc3),  ivec4(0x00bad3fc,0x009bd5f9,0x009ad9ff,0x00a6e0ff),  ivec4(0x00b0e5fe,0x00b6e7fd,0x00b6e8fe,0x00b6e8ff),  ivec4(0x00b4e6ff,0x00b1e3ff,0x00afe1ff,0x00acdfff),\n  ivec4(0x00aaddff,0x00a8ddfd,0x00a9d7fe,0x00a8d1fe),  ivec4(0x009dcfff,0x0095c6ff,0x0092bdff,0x0087b7fe),  ivec4(0x0080acfb,0x0080a0eb,0x00859dd6,0x00394d77),  ivec4(0x000b0008,0x00452714,0x00bd7933,0x00cb7f27),\n  ivec4(0x00b98e5c,0x00d4d4d8,0x00d0ced2,0x00c5cad1),  ivec4(0x00b2c5d1,0x00b6d8ef,0x009dc8f1,0x0086b3ed),  ivec4(0x007ba2e9,0x007495e4,0x006e8ee1,0x006184d2),  ivec4(0x00597fc3,0x005b82c2,0x00597abb,0x005a74b5),\n  ivec4(0x0011245c,0x00031446,0x00091d48,0x0001143c),  ivec4(0x00001137,0x00000f34,0x00000b37,0x00314074),  ivec4(0x00364886,0x0035488e,0x002f478a,0x0038538d),  ivec4(0x004a6196,0x00516799,0x004d649b,0x004c65a2),\n  ivec4(0x0049659c,0x00546d9a,0x00c0cfea,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00f9fcff,0x00fcfdfb,0x00fefffc,0x00f0fcff),  ivec4(0x00a4c7ec,0x0092c6fc,0x0097ccff,0x00a4d0fa),\n  ivec4(0x009fcafb,0x0092bffe,0x0083aefa,0x006f98ec),  ivec4(0x005f85d7,0x00557ac6,0x006f90dc,0x00153483),  ivec4(0x0005206a,0x00011d58,0x0001205d,0x00002165),  ivec4(0x00011f70,0x0008287e,0x002b4b96,0x0097c2fd),\n  ivec4(0x009fcffa,0x00a5d8ff,0x00a7dafd,0x00b0e3ff),  ivec4(0x00b1e9fd,0x00b7edff,0x00baeeff,0x00baebff),  ivec4(0x00afddf2,0x00f0fff8,0x00fffbff,0x00f9ffff),  ivec4(0x00f6fff9,0x00f0d9b5,0x00ebaf36,0x00d5b434),\n  ivec4(0x0068451b,0x0031140a,0x00450000,0x006b4651),  ivec4(0x00746c8e,0x00a8cfe1,0x00a5d8fd,0x0098cffe),  ivec4(0x00a9d4fe,0x00aad5fd,0x00abd7ff,0x00add8ff),  ivec4(0x00a8d5fe,0x00a5d2fe,0x00a5d3ff,0x00a3d2ff),\n  ivec4(0x00a1d1fe,0x009cd3fb,0x009fcbfd,0x00a1c2fe),  ivec4(0x008fc5fd,0x0089baff,0x008db3fd,0x0080b0f0),  ivec4(0x008cadfc,0x008b8dca,0x00514c68,0x00190000),  ivec4(0x00300400,0x00190000,0x00916934,0x00db922b),\n  ivec4(0x00af6c09,0x00dbd1d2,0x00cecfd0,0x00c6caca),  ivec4(0x00bec7cb,0x00bdd3e9,0x00a5c9f4,0x0088b2f0),  ivec4(0x007da4e8,0x007698dd,0x006c8ed9,0x006688ce),  ivec4(0x00607fc4,0x005f7cbd,0x005774b1,0x005872af),\n  ivec4(0x0001104a,0x00011954,0x00061c53,0x00001647),  ivec4(0x0000123b,0x00001135,0x00000b32,0x003d527e),  ivec4(0x00374a85,0x00384b90,0x0033498f,0x003d5693),  ivec4(0x004a6397,0x004f6898,0x004e6599,0x004a6099),\n  ivec4(0x00475f96,0x00546e9f,0x00aabdd8,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00f7fbfd,0x00fdfdfa,0x00fffffb,0x00edf9ff),  ivec4(0x00a4c4ec,0x0091c1fd,0x0093c4ff,0x00a1cafb),\n  ivec4(0x009cc8fb,0x0093bfff,0x0088b1ff,0x00759af5),  ivec4(0x00658ae1,0x00567cc9,0x0091b3f4,0x0020418b),  ivec4(0x00021f63,0x00011f59,0x0000225f,0x00012369),  ivec4(0x00002072,0x00062880,0x0021408a,0x009ac4ff),\n  ivec4(0x009ccbf7,0x00a3d4ff,0x00a9dcff,0x00afe4ff),  ivec4(0x00b1e9fd,0x00b6ecfe,0x00bcefff,0x00b8eafe),  ivec4(0x00b1dff7,0x00f3fffe,0x00fffef9,0x00fbfefd),  ivec4(0x00fdfffc,0x00d7ab75,0x00fdc745,0x00d6bf4a),\n  ivec4(0x00000000,0x00431207,0x007c131f,0x00830000),  ivec4(0x00650020,0x0053656b,0x008492ad,0x00b2cde5),  ivec4(0x00a7cfe5,0x009fc9f1,0x009ec8f8,0x00a0c8fb),  ivec4(0x00a0c9fd,0x009dc7ff,0x009bc4ff,0x0098c2ff),\n  ivec4(0x0094bffd,0x008cc3f8,0x008fbffc,0x0097b8ff),  ivec4(0x0089bdf6,0x008fb5f4,0x0094a8d6,0x007d97b3),  ivec4(0x0045547d,0x0056405f,0x007d0000,0x006d0715),  ivec4(0x00420300,0x00200e00,0x00463a13,0x00dba132),\n  ivec4(0x00be790c,0x00dfcbc2,0x00cecfd0,0x00c6c9c9),  ivec4(0x00c1c8cd,0x00bbcee4,0x00a8caf6,0x0089b2f0),  ivec4(0x007da4e9,0x007597dd,0x006c8ed5,0x006587cd),  ivec4(0x006281c4,0x005c79ba,0x005571ae,0x005871ad),\n  ivec4(0x00010c45,0x000c235c,0x00081e53,0x00041a4a),  ivec4(0x0000143d,0x00001337,0x00000b31,0x00485e89),  ivec4(0x00455a91,0x003e5295,0x003d5298,0x00455c9c),  ivec4(0x004a649b,0x004d6799,0x004d659a,0x00485d99),\n  ivec4(0x00485e98,0x00566fa3,0x00a0b2ce,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00f8fcfc,0x00fefdf9,0x00fffffb,0x00f0faff),  ivec4(0x00a9c6f0,0x0090bcfd,0x008cbafe,0x009abffc),\n  ivec4(0x009bc5fd,0x0092bdff,0x008bb1ff,0x0084a7fe),  ivec4(0x007c9ff6,0x0079a0e9,0x00a7cbfe,0x00173d7e),  ivec4(0x0000205d,0x00011e5c,0x00012261,0x0001256c),  ivec4(0x00012276,0x00062981,0x00284a95,0x0096c1fc),\n  ivec4(0x009dccf8,0x00a2d3ff,0x00a7dbff,0x00afe3ff),  ivec4(0x00b0e8fc,0x00b5ebfc,0x00bdf0ff,0x00b6e8fd),  ivec4(0x00b4e2fc,0x00eeffff,0x00fffff2,0x00fefffa),  ivec4(0x00fffffb,0x00c58e31,0x00ffc942,0x00c7b150),\n  ivec4(0x001a1508,0x004a110a,0x008c151e,0x00ab171b),  ivec4(0x008e0219,0x00460000,0x00432f3d,0x00878a83),  ivec4(0x00a0c4bb,0x00a9d6f2,0x00a0caf7,0x0097c0f3),  ivec4(0x0091bbf1,0x008db8f2,0x008cb6f5,0x008bb4f7),\n  ivec4(0x008bb4fa,0x0081b8f7,0x007fb4f7,0x0088abf6),  ivec4(0x007cabe3,0x0086a1cf,0x00a7a9ac,0x003d464a),  ivec4(0x00120000,0x00540000,0x00b20011,0x008d0715),  ivec4(0x004e0606,0x00140c00,0x00020800,0x00d8a831),\n  ivec4(0x00d38e1d,0x00ddc2ab,0x00d2d1d1,0x00c7caca),  ivec4(0x00c4cbd0,0x00bacce3,0x00aacbf8,0x008ab3f2),  ivec4(0x007ca3e9,0x007495db,0x006a8cd3,0x006485ca),  ivec4(0x006080c1,0x005a78b8,0x005672af,0x005a72ac),\n  ivec4(0x00010f46,0x000b2055,0x00061c4d,0x00021844),  ivec4(0x0000133a,0x00001437,0x00000b31,0x00485c88),  ivec4(0x0050659b,0x00485d9c,0x00465ba1,0x00475fa1),  ivec4(0x0049639d,0x004a649a,0x0049619a,0x00465b99),\n  ivec4(0x00495e9a,0x00596fa2,0x00a4b3cf,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00f9fdfe,0x00fdfdf7,0x00fffffa,0x00f4fbff),  ivec4(0x00acc4f0,0x008eb7fb,0x0085aef9,0x0090b4f9),\n  ivec4(0x0095bdfa,0x008eb7fc,0x008db2ff,0x0087abff),  ivec4(0x007ea4f7,0x0090b7fa,0x00b0d8ff,0x00234a7e),  ivec4(0x00002158,0x00011e5f,0x00012365,0x0002256f),  ivec4(0x00002479,0x00052a82,0x003d61ad,0x0092bff8),\n  ivec4(0x00a1d0fc,0x00a1d2fe,0x00a7dbff,0x00aee3fe),  ivec4(0x00b0e8fc,0x00b5ebfc,0x00bcefff,0x00b4e6fb),  ivec4(0x00b6e4fd,0x00ebfdff,0x00ffffee,0x00fffff8),  ivec4(0x00fffff9,0x00c48b00,0x00ffd246,0x00aa9442),\n  ivec4(0x0015160a,0x00401413,0x00721015,0x008f1916),  ivec4(0x00820815,0x00480907,0x001e0000,0x0075662d),  ivec4(0x00a4bea2,0x00bceaf9,0x00bcecfe,0x00bef0fb),  ivec4(0x00b9e9fa,0x00b5e6fa,0x00b1e0fb,0x00abd9fc),\n  ivec4(0x00a4d2fe,0x0096cdfd,0x008cbffd,0x008cb1f9),  ivec4(0x0077a3de,0x00849ab9,0x00b5b292,0x00000000),  ivec4(0x00280e0a,0x005c0c00,0x009f0009,0x0078020c),  ivec4(0x00400206,0x00080704,0x00000000,0x00e3b13d),\n  ivec4(0x00df9425,0x00d6b698,0x00d6d4d5,0x00c9cbce),  ivec4(0x00c6cdd3,0x00bacce4,0x00aacafa,0x008ab3f3),  ivec4(0x007ca2ea,0x007495dc,0x006b8dd0,0x006385c7),  ivec4(0x005e7fc1,0x005877b8,0x005673b0,0x005c75ad),\n  ivec4(0x00010f42,0x00021544,0x00031544,0x0000123d),  ivec4(0x00001036,0x00001336,0x00000d32,0x00455983),  ivec4(0x00536b9d,0x004b649f,0x00465ea1,0x00475ea2),  ivec4(0x0048619d,0x0047629a,0x00465f9c,0x00465b9c),\n  ivec4(0x004d609d,0x005e72a2,0x00b2bfd9,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00f9ffff,0x00fcfef7,0x00fffff9,0x00f5f8ff),  ivec4(0x00b1c6ef,0x0092b8fb,0x007fa7f3,0x0089abf4),\n  ivec4(0x008bb1f2,0x008bb3f9,0x0084aaf7,0x00759cea),  ivec4(0x0084adf1,0x00a3cdff,0x00bae3ff,0x0029507e),  ivec4(0x0004255a,0x00031f63,0x00032469,0x0001246f),  ivec4(0x00002479,0x00052a83,0x006a92df,0x0094c3fb),\n  ivec4(0x009ccdf7,0x00a2d3ff,0x00a8ddff,0x00aee3ff),  ivec4(0x00b2eafe,0x00b7edfe,0x00bbeeff,0x00b5e7fb),  ivec4(0x00b5e3fc,0x00ebfcff,0x00ffffef,0x00fffff9),  ivec4(0x00fffff6,0x00c68c00,0x00ffd144,0x00a08e3a),\n  ivec4(0x00131b0f,0x002c1d22,0x004f211e,0x00491005),  ivec4(0x00531211,0x00220d07,0x000f130c,0x0074671d),  ivec4(0x00aaba98,0x00beedf1,0x00c1f9fb,0x00c8ffff),  ivec4(0x00c6ffff,0x00c4feff,0x00bef6ff,0x00b7edff),\n  ivec4(0x00ade2fe,0x00a1d8ff,0x0098c4fe,0x008fb4f8),  ivec4(0x0077a2e3,0x00829ab3,0x00c0c48d,0x00000000),  ivec4(0x001c080a,0x00420e07,0x005f0705,0x00450307),  ivec4(0x002c0910,0x00010007,0x00000000,0x00ecad42),\n  ivec4(0x00e6982e,0x00d4b69a,0x00d8d6d8,0x00cdcfd2),  ivec4(0x00c4cad3,0x00bacce6,0x00a9c9f9,0x008ab2f3),  ivec4(0x007da3eb,0x007495de,0x006b8dce,0x006385c7),  ivec4(0x005d7fc1,0x005979ba,0x005774b1,0x005c76ac),\n  ivec4(0x00001242,0x0003113c,0x00010f37,0x00000f36),  ivec4(0x00001134,0x00001235,0x00000e33,0x0041567e),  ivec4(0x004e6797,0x004d689f,0x004860a0,0x00475da0),  ivec4(0x0045609c,0x0044619b,0x00435e9d,0x00475c9d),\n  ivec4(0x005365a0,0x0060719f,0x00cedaf2,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00f8ffff,0x00fdfef9,0x00fffff8,0x00f9fcff),  ivec4(0x00b6cbee,0x0097bdfc,0x0081aaf4,0x007ea1e8),\n  ivec4(0x007ba0e4,0x00739adf,0x006890d6,0x0078a4e1),  ivec4(0x009ecefb,0x00acdcfd,0x00c7f3ff,0x00133a6e),  ivec4(0x0003225b,0x00021f66,0x0002236b,0x00002370),  ivec4(0x0001267b,0x00002580,0x0091bbfc,0x009ac9ff),\n  ivec4(0x0099ccf5,0x00a1d2fe,0x00a9dcff,0x00ade2fe),  ivec4(0x00b2ebff,0x00b9eeff,0x00b9ecff,0x00b7e9fd),  ivec4(0x00b2e0f9,0x00ecfeff,0x00fffff6,0x00fffffa),  ivec4(0x00fffff4,0x00c68e28,0x00ffd247,0x00b6a748),\n  ivec4(0x001f2514,0x001e1f24,0x002c1f15,0x00000000),  ivec4(0x001d0c00,0x0000120a,0x0000160c,0x00938627),  ivec4(0x00b0bb97,0x00b9e9ec,0x00bcf6f6,0x00c3fefc),  ivec4(0x00c3fffb,0x00c0fefc,0x00baf7fa,0x00b3eefb),\n  ivec4(0x00aae4f9,0x00a1d6fa,0x009dc2fa,0x008eb2f5),  ivec4(0x0076a0e8,0x00809bb1,0x00c4ce84,0x00000000),  ivec4(0x00120814,0x001d0807,0x00000000,0x00000000),  ivec4(0x00170607,0x000a090e,0x00000000,0x00f0a944),\n  ivec4(0x00e49631,0x00dcc3ae,0x00d9d8dc,0x00d0d2d7),  ivec4(0x00c5cad4,0x00bbcce7,0x00a7c7f8,0x0089b0f4),  ivec4(0x007da2ec,0x007594df,0x006c8dcd,0x006285c6),  ivec4(0x005b7ec0,0x005779b9,0x005473b0,0x00566fa3),\n  ivec4(0x00263763,0x00040e35,0x00000c2f,0x00000e32),  ivec4(0x00001133,0x00011235,0x00000e33,0x003a5077),  ivec4(0x00465f8e,0x00496699,0x004c66a2,0x004962a1),  ivec4(0x0043609a,0x00416299,0x00405e9b,0x004b63a1),\n  ivec4(0x00586ca0,0x00607198,0x00e9f6fe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00f8ffff,0x00fefffb,0x00fffff7,0x00fdffff),  ivec4(0x00c3d8f7,0x0099bffa,0x008cb7fb,0x0080a6e8),\n  ivec4(0x007397dd,0x00688ed6,0x0082ace7,0x009bcef6),  ivec4(0x00aee4fb,0x00b9eefd,0x00ccf9ff,0x00001356),  ivec4(0x00032060,0x00011f69,0x0000216a,0x00002473),  ivec4(0x00052980,0x00092b83,0x0099c3ff,0x0098c9fe),\n  ivec4(0x009cd0f9,0x00a0d1fd,0x00a7daff,0x00ade1fd),  ivec4(0x00b2e9fd,0x00b9efff,0x00b7eafe,0x00b8eaff),  ivec4(0x00aedcf3,0x00edffff,0x00fffdfe,0x00fdfffb),  ivec4(0x00fefff3,0x00cd9854,0x00ffd24b,0x00cec44e),\n  ivec4(0x0018160c,0x001d1b1c,0x00221600,0x006f6d4d),  ivec4(0x005c1d00,0x0014150d,0x00000b04,0x00c4ac3d),  ivec4(0x00b4bf97,0x00b5e5f2,0x00baf0fc,0x00c0f7fd),  ivec4(0x00bff9fd,0x00bcf8fc,0x00b5f0fa,0x00afe8fc),\n  ivec4(0x00a7def9,0x009fd2f9,0x009cc1f7,0x008db1f5),  ivec4(0x00749fec,0x00849eae,0x00d0db79,0x00252c00),  ivec4(0x00140814,0x000c0000,0x006e583f,0x0044260c),  ivec4(0x00070000,0x00090a06,0x000f0b00,0x00efab41),\n  ivec4(0x00d48920,0x00e5d0ba,0x00dbdade,0x00d3d6da),  ivec4(0x00c8cdd7,0x00bccde8,0x00a5c5f7,0x0088aff3),  ivec4(0x007ca1ec,0x007595df,0x006c8ccc,0x006384c4),  ivec4(0x00587cbd,0x005376b6,0x005472af,0x00576ea1),\n  ivec4(0x004f5e86,0x00010628,0x00000b2c,0x00000d2f),  ivec4(0x00001031,0x00031235,0x00000e33,0x0030446a),  ivec4(0x00415b88,0x00446293,0x004c679f,0x004d67a3),  ivec4(0x0047689d,0x0043669b,0x0042639d,0x004f68a4),\n  ivec4(0x005b71a0,0x007082a1,0x00f2ffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00f7feff,0x00fffffc,0x00fffff6,0x00fcfcfe),  ivec4(0x00e0f1fe,0x009bbef2,0x0097c2ff,0x0094bcf9),\n  ivec4(0x008db3f3,0x0092bbf4,0x00a2d1fe,0x00ace2fc),  ivec4(0x00baf6fb,0x00c8feff,0x00baeaf9,0x00000041),  ivec4(0x00031e64,0x00022068,0x0000216a,0x00002474),  ivec4(0x00062a82,0x001c3b8f,0x008db9ff,0x0096c8fe),\n  ivec4(0x009dd0fa,0x00a0d1fd,0x00a8d9ff,0x00ade1fd),  ivec4(0x00b2e8fe,0x00b9efff,0x00b6e9fe,0x00b9ebff),  ivec4(0x00aad8f1,0x00efffff,0x00fffbff,0x00f9fffd),  ivec4(0x00fafff3,0x00e0be8b,0x00ffcc4c,0x00ebda59),\n  ivec4(0x00000000,0x00251912,0x009a8669,0x00e1e0bf),  ivec4(0x00dfceb4,0x00321c12,0x00000000,0x00e9c94f),  ivec4(0x00b2c198,0x00b3e2fa,0x00baeaff,0x00beefff),  ivec4(0x00bbf0ff,0x00b8effe,0x00b2e8fe,0x00ade1fe),\n  ivec4(0x00a5d8fe,0x009ccefd,0x0097c0f7,0x008bb0f6),  ivec4(0x00769eed,0x00879fab,0x00d3dc70,0x008b8830),  ivec4(0x00140206,0x006c5649,0x00e0dbc3,0x00dbd8bf),  ivec4(0x002e2715,0x00040900,0x004e4911,0x00efb038),\n  ivec4(0x00be7c01,0x00f3e1d0,0x00dddbe1,0x00d7d8dd),  ivec4(0x00c8cfda,0x00b7cde8,0x00a2c4f6,0x0087aef4),  ivec4(0x007da0ed,0x007495df,0x006d8dcb,0x006384c1),  ivec4(0x00597cbb,0x005174b4,0x005775b2,0x005c75a9),\n  ivec4(0x00617299,0x00000120,0x00000b29,0x00000c2c),  ivec4(0x00021030,0x00041235,0x00011238,0x0021355b),  ivec4(0x0039527e,0x0043608d,0x00476397,0x004e68a1),  ivec4(0x004e70a4,0x004b6fa5,0x004c6ca6,0x004d68a0),\n  ivec4(0x006074a2,0x008d9cb5,0x00f3fdff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00f8fefe,0x00fdfffd,0x00fffffb,0x00fefdfe),  ivec4(0x00f6fdff,0x00b9cff1,0x009cc4f1,0x009ccdff),\n  ivec4(0x009dcffe,0x00a4d7fc,0x00afe6ff,0x00b6f3fc),  ivec4(0x00c5fffe,0x00bdf6f6,0x009ecee5,0x0000003c),  ivec4(0x00041e69,0x00042164,0x0003216b,0x00042577),  ivec4(0x00072b81,0x002d4e9e,0x008bb6ff,0x0099c8ff),\n  ivec4(0x009ccdfd,0x00a2d1fc,0x00aad9ff,0x00addffc),  ivec4(0x00b2e7fd,0x00b8edff,0x00b7ebff,0x00b7eaff),  ivec4(0x00a8d5f2,0x00edf7ff,0x00fdfdff,0x00f4fffe),  ivec4(0x00f7fff7,0x00f0e2b4,0x00efb63e,0x00fddc5e),\n  ivec4(0x00625f20,0x002a230f,0x00af9676,0x00ffffe4),  ivec4(0x00ebedce,0x00251608,0x0091711a,0x00ead14f),  ivec4(0x00abc1a4,0x00b3e3fc,0x00b3e6fd,0x00b7ecff),  ivec4(0x00b6ebff,0x00b4eaff,0x00afe3ff,0x00aaddff),\n  ivec4(0x00a4d5ff,0x0096cdfa,0x008ec1f4,0x0090aef6),  ivec4(0x00809eeb,0x00809db0,0x00c1cc76,0x00d7cc5b),  ivec4(0x00100000,0x007d6753,0x00fffff2,0x00f4f1d1),  ivec4(0x00272813,0x00000000,0x00c1983d,0x00f5b127),\n  ivec4(0x00aa7500,0x00ede7ea,0x00e5d9ea,0x00d7d6e0),  ivec4(0x00bdd0da,0x00afd1ec,0x0097c0f7,0x0085acf8),  ivec4(0x007c9fed,0x007494dd,0x006f8bcc,0x006680be),  ivec4(0x005f79b5,0x005774b1,0x005472b2,0x005772af),\n  ivec4(0x006277a7,0x00010629,0x00000c28,0x00000d2a),  ivec4(0x00021030,0x00031136,0x00011039,0x0013264f),  ivec4(0x0030466f,0x003d557e,0x00496093,0x00486099),  ivec4(0x004f6ea5,0x004e6fa9,0x005471ae,0x005a70ab),\n  ivec4(0x005a6b97,0x00cbd6e8,0x00f8feff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fafffe,0x00fbffff,0x00fffffe,0x00fffeff),  ivec4(0x00faf9ff,0x00dfeefa,0x00a5c5e6,0x009dcef7),\n  ivec4(0x00a7d6fe,0x00b3e4fb,0x00baf4fd,0x00bff9ff),  ivec4(0x00baebff,0x00b6e2fc,0x007ca3d4,0x0000084b),  ivec4(0x00052267,0x00052164,0x0004226d,0x00042679),  ivec4(0x00072b82,0x003a5fae,0x008cb7ff,0x0097c5ff),\n  ivec4(0x0099c8fd,0x00a1cefc,0x00a8d7ff,0x00abddfb),  ivec4(0x00b0e5fc,0x00b6ebff,0x00b6ecff,0x00b5e9ff),  ivec4(0x00a7d6f2,0x00e3effc,0x00faffff,0x00f4fbfe),  ivec4(0x00f7fcfd,0x00fbf8da,0x00d2991a,0x00fcd455),\n  ivec4(0x00cec755,0x00000000,0x006d543f,0x00b9b798),  ivec4(0x007f8c77,0x00411600,0x00e9bb47,0x00e7c850),  ivec4(0x00b3cdc4,0x00ade0fc,0x00aee4fd,0x00b3eaff),  ivec4(0x00b2e8ff,0x00b0e6ff,0x00acdfff,0x00a8daff),\n  ivec4(0x00a3d3fd,0x0094cafc,0x008cc0f7,0x0090b2ee),  ivec4(0x0082a1ea,0x007c9ac5,0x009fab6e,0x00f3e962),  ivec4(0x009f8c24,0x00352127,0x00b5b1a3,0x00948d75),  ivec4(0x00000000,0x00825c24,0x00efab3f,0x00e79c27),\n  ivec4(0x00d5b080,0x00e3e6f1,0x00e8d8eb,0x00d3d4df),  ivec4(0x00b8cfdd,0x00acd1f2,0x0093bbf8,0x0085a9f8),  ivec4(0x00799be6,0x007191d3,0x006a85c7,0x006379b6),  ivec4(0x005f74ad,0x005a74af,0x005371b2,0x00536fb1),\n  ivec4(0x006177ac,0x00020b31,0x00000c29,0x00000e2b),  ivec4(0x00011030,0x00021136,0x00000d36,0x00061743),  ivec4(0x00253565,0x00344679,0x0046588f,0x004c6199),  ivec4(0x00465f95,0x005470a4,0x005971a9,0x005668a0),\n  ivec4(0x00929dbd,0x00f2f9ff,0x00f9fdfc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00faffff,0x00fbffff,0x00fffffe,0x00fffeff),  ivec4(0x00fcfbff,0x00f2fbff,0x00cce3f5,0x00a5cbe9),\n  ivec4(0x00adcbfb,0x00c0e5fc,0x00bdf2eb,0x00c1eeff),  ivec4(0x00a0b9ff,0x008196dd,0x004356a7,0x00042062),  ivec4(0x00021e5b,0x00022067,0x0003226f,0x00012579),  ivec4(0x00042981,0x004970c0,0x0089b3fe,0x0092c1ff),\n  ivec4(0x0097c5fd,0x009dccfc,0x00a4d5ff,0x00a8dcfb),  ivec4(0x00ace3fc,0x00b2eafe,0x00b1e9fe,0x00b3ebff),  ivec4(0x00a8dbf4,0x00cfe3f4,0x00f9feff,0x00faf7ff),  ivec4(0x00f9f7ff,0x00fffcf7,0x00d8c187,0x00eac84c),\n  ivec4(0x00f0e153,0x00beaf5c,0x0079601b,0x00481a00),  ivec4(0x00786a29,0x00ceb651,0x00ffd455,0x00cf9d42),  ivec4(0x00b7d5df,0x00a7defe,0x00ade3fe,0x00b0e6ff),  ivec4(0x00afe5fe,0x00ade1fe,0x00a9dcfd,0x00a7d8ff),\n  ivec4(0x00a1d0fd,0x0099c4ff,0x0093bcfb,0x008cbae5),  ivec4(0x007ba5ec,0x007895dc,0x00899479,0x00ece558),  ivec4(0x00eedb41,0x00ae8f31,0x00280000,0x002e0000),  ivec4(0x00a37135,0x00e39c2e,0x00fca835,0x00b46700),\n  ivec4(0x00fde0d8,0x00e4e4ea,0x00e8dee7,0x00d3d7e1),  ivec4(0x00bccee5,0x00a8c5f2,0x008eaff2,0x007e9ce9),  ivec4(0x00708fd3,0x006785be,0x005e7ab9,0x005a71ae),  ivec4(0x005a70aa,0x005872ae,0x005472b3,0x005470b1),\n  ivec4(0x005f75a9,0x00060e32,0x00000a2d,0x00000c2f),  ivec4(0x0001112f,0x00021332,0x00021236,0x00000c3e),  ivec4(0x00121d5c,0x00252f79,0x0039448a,0x00324881),  ivec4(0x00405785,0x003f5a85,0x00445d8a,0x00828eb2),\n  ivec4(0x00dde3f1,0x00fbfdff,0x00fbfdfc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00faffff,0x00fcffff,0x00fffffe,0x00fffeff),  ivec4(0x00fffdfd,0x00fafdff,0x00eefcff,0x00d1e8f2),\n  ivec4(0x00c7d8fb,0x00c7e3f4,0x00cbf3ed,0x00aac5f8),  ivec4(0x00666cd8,0x000000b2,0x0000007e,0x0007256b),  ivec4(0x00001d59,0x0000216a,0x00012270,0x00012578),  ivec4(0x0003287f,0x00557dce,0x0088b0fd,0x0093beff),\n  ivec4(0x0098c5ff,0x009bcbfd,0x00a2d4ff,0x00a6dbfd),  ivec4(0x00aae1fd,0x00afe8fe,0x00aee7fe,0x00b2ebff),  ivec4(0x00aadef7,0x00b7d4ee,0x00f2fbff,0x00fffbff),  ivec4(0x00fbf8ff,0x00fdf7ff,0x00f7f4dc,0x00c4a42d),\n  ivec4(0x00f5d54b,0x00fef071,0x00d2c336,0x00cdbf45),  ivec4(0x00e2c75d,0x00ffe65c,0x00f4c23e,0x00c89f81),  ivec4(0x00a7c9ea,0x00a7deff,0x00ade0ff,0x00afe3ff),  ivec4(0x00ade1fe,0x00abddfe,0x00a7d8fe,0x00a5d4ff),\n  ivec4(0x00a1cefe,0x009dc2ff,0x0097bbf9,0x0088bce5),  ivec4(0x0076a7ef,0x007190ea,0x008993a3,0x00c2b842),  ivec4(0x00ffe64a,0x00fbd342,0x00c4ad2a,0x00b89329),  ivec4(0x00f5b240,0x00ffae1f,0x00e59412,0x00cca59a),\n  ivec4(0x00f9e9fb,0x00ece6eb,0x00e3e1e3,0x00ced4e1),  ivec4(0x00b1c1e2,0x008fa6dd,0x007c97df,0x006c88cf),  ivec4(0x00637fbc,0x005c78aa,0x00536fac,0x00556ca9),  ivec4(0x00596fa9,0x00556fab,0x005371b2,0x00536fb0),\n  ivec4(0x005b71a5,0x00091032,0x00000830,0x00000b30),  ivec4(0x0001112d,0x0002152f,0x00021235,0x00010c45),  ivec4(0x0004085c,0x00090a71,0x00202275,0x009ea4ce),  ivec4(0x0098a3cc,0x009ba7bd,0x00b9c2cc,0x00d8deec),\n  ivec4(0x00f4f5fc,0x00fefdff,0x00fffffc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdfeff,0x00feffff,0x00ffffff,0x00fffffe),  ivec4(0x00fffdfd,0x00feffff,0x00f8ffff,0x00f6ffff),\n  ivec4(0x00e9f8fe,0x00dff3f8,0x00dbf1ff,0x00626cc8),  ivec4(0x000000a3,0x000600b5,0x00000a89,0x00031c68),  ivec4(0x00022062,0x0000206a,0x0000206f,0x00012476),  ivec4(0x0002277c,0x00597fd0,0x0089affb,0x0095bdff),\n  ivec4(0x009bc4ff,0x009cc9fc,0x00a2d0ff,0x00a7d9ff),  ivec4(0x00acdfff,0x00ade2ff,0x00aee3ff,0x00b0e5fe),  ivec4(0x00acdefb,0x00a8c8f2,0x00ddeefd,0x00fcfffc),  ivec4(0x00fdfdf8,0x00f6fafc,0x00fefffd,0x00dbcfae),\n  ivec4(0x00f6c664,0x00e5d645,0x00fae648,0x00ffec5d),  ivec4(0x00ffda51,0x00dabc00,0x00e3c67c,0x00d1c4d1),  ivec4(0x00a1cef5,0x00a4dbfc,0x00aaddff,0x00acdfff),  ivec4(0x00abdeff,0x00a9daff,0x00a5d4fe,0x00a3d0ff),\n  ivec4(0x009ecbfe,0x009ec2fb,0x0098bbf5,0x0085b7ee),  ivec4(0x0074a5f2,0x007192ed,0x008792c7,0x00b1a293),  ivec4(0x00e3b93a,0x00fac92e,0x00ffd434,0x00eebf2f),  ivec4(0x00f2af14,0x00e08d00,0x00d8a577,0x00f3e9ea),\n  ivec4(0x00dfe2f3,0x00e5dce0,0x00cad0d0,0x00b6bfd2),  ivec4(0x008f9dc8,0x006b7fbe,0x00637cc3,0x005a75b6),  ivec4(0x005771a8,0x00566f9e,0x004f68a7,0x005269a7),  ivec4(0x00586ea8,0x00536da9,0x00506eaf,0x00526eaf),\n  ivec4(0x005b71a5,0x000b1336,0x00000930,0x00000c2f),  ivec4(0x0001112c,0x0002142f,0x00001037,0x00010b4a),  ivec4(0x00070769,0x00010079,0x0000006e,0x00b9bef0),  ivec4(0x00dce2ff,0x00e2ecfb,0x00fbffff,0x00ffffff),\n  ivec4(0x00f6f5fa,0x00fffefe,0x00fffefc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffeff,0x00fffeff,0x00fffeff,0x00fffffe),  ivec4(0x00ffffff,0x00ffffff,0x00fdffff,0x00fdffff),\n  ivec4(0x00f6fff9,0x00ebf8fe,0x00b8bceb,0x0000009d),  ivec4(0x000900b6,0x000201aa,0x00000a88,0x0002166c),  ivec4(0x00051f67,0x00021f68,0x00011f6b,0x00022472),  ivec4(0x00002576,0x006184d1,0x008db0f8,0x0098bbfe),\n  ivec4(0x009cbefd,0x009ec7fb,0x009fc8fb,0x00a5d1fe),  ivec4(0x00acd8ff,0x00acd9ff,0x00afdcff,0x00afddff),  ivec4(0x00addaff,0x00aac9ff,0x00b8d2f2,0x00f3ffff),  ivec4(0x00fcffee,0x00f6fcf8,0x00f5faff,0x00fffffb),\n  ivec4(0x00f4d9be,0x00e4d6ac,0x00f3cc6e,0x00f1bf50),  ivec4(0x00f8c96c,0x00d6cc9a,0x00d4e0cc,0x00afcbf1),  ivec4(0x009fd4f7,0x00a2d8fb,0x00a7d9ff,0x00a9dafe),  ivec4(0x00a8dafe,0x00a7d8ff,0x00a3d2fe,0x00a1ceff),\n  ivec4(0x009cc7fe,0x009ec3f6,0x0098bdf4,0x0085b3fa),  ivec4(0x007da6f7,0x007b9aed,0x007f8fdc,0x00aaa6c9),  ivec4(0x00e2ccbc,0x00ecb867,0x00f6b55d,0x00e8ad49),  ivec4(0x00e8ae6b,0x00daa799,0x00e7cecb,0x00cfdde4),\n  ivec4(0x00beccd1,0x00c1bcbe,0x00a9b5be,0x008f9bb9),  ivec4(0x006272a8,0x00566aad,0x004f68ab,0x004c69a5),  ivec4(0x0050699f,0x0052699e,0x004e67a7,0x005168a6),  ivec4(0x00556ba5,0x00526ca9,0x004d6bac,0x00526eaf),\n  ivec4(0x005b71a5,0x000d183b,0x00000a2d,0x00000d2b),  ivec4(0x0000112c,0x00011230,0x00000d3b,0x0000064f),  ivec4(0x00090672,0x00060084,0x000b047e,0x005e5e9e),  ivec4(0x00e7eaff,0x00f2f8ff,0x00fcffff,0x00fffffc),\n  ivec4(0x00ffffff,0x00fffffe,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff),  ivec4(0x00ffffff,0x00fffffe,0x00fffffe,0x00fffffe),\n  ivec4(0x00f9fff9,0x00e7e9ff,0x005950b4,0x001202b2),  ivec4(0x000801b1,0x000304a9,0x00000591,0x0002106f),  ivec4(0x00081f65,0x00041f68,0x0003206a,0x0003226d),  ivec4(0x0000226d,0x006585cd,0x008aa9ee,0x0091aff0),\n  ivec4(0x008faceb,0x008cb1e5,0x0088ade1,0x008ab0e2),  ivec4(0x0090b4e6,0x0092b7e8,0x0095baea,0x0095bcea),  ivec4(0x0095b8ea,0x0095b0e9,0x0082a6da,0x00c7e0eb),  ivec4(0x00f7fcf4,0x00f9f6f4,0x00edf5ff,0x00f3f2ff),\n  ivec4(0x00fffffb,0x00fff6f9,0x00f0cfc6,0x00eccab1),  ivec4(0x00f4ddc8,0x00eceef0,0x00aed2ee,0x009dd2f8),  ivec4(0x0093c6f2,0x00a5d6ff,0x00a6d7ff,0x00a7d9ff),  ivec4(0x00a7d8ff,0x00a7d7ff,0x00a3d2ff,0x00a1cdff),\n  ivec4(0x009cc7ff,0x009dc2fb,0x0096bef9,0x0084b2fb),  ivec4(0x0085a7f3,0x00859ce9,0x00738ede,0x006783c8),  ivec4(0x00d6d3e6,0x00e4c6c5,0x00e1b2af,0x00deb19a),  ivec4(0x00e4bca9,0x00e7cad8,0x00bcb9d5,0x00a5b2bd),\n  ivec4(0x00a5afb1,0x00a6aab2,0x0091a3b8,0x006779a3),  ivec4(0x004c5f9c,0x004a63a4,0x004865a0,0x0048679b),  ivec4(0x004d669d,0x005064a5,0x004b64a6,0x004f66a3),  ivec4(0x005268a2,0x004f69a6,0x004c6aab,0x004f6bac),\n  ivec4(0x00596fa3,0x000c183c,0x00000c27,0x00000e27),  ivec4(0x0000112b,0x00001033,0x0000083d,0x0004085a),  ivec4(0x00090375,0x00070084,0x00070083,0x00000067),  ivec4(0x00b7b6e2,0x00f7faff,0x00fffffd,0x00fffff9),\n  ivec4(0x00fffffd,0x00fdffff,0x00fdfeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffeff,0x00fffdff,0x00fffeff,0x00fffeff),  ivec4(0x00fefeff,0x00fffeff,0x00ffffff,0x00fffffe),\n  ivec4(0x00f9feff,0x00c4bfea,0x000000aa,0x000c00b5),  ivec4(0x000502ab,0x000302ae,0x000200a3,0x00000a74),  ivec4(0x00051c5a,0x00051f64,0x00052066,0x00052167),  ivec4(0x00021d63,0x004b68ac,0x006d87c9,0x006b83c2),\n  ivec4(0x006b83be,0x005c7cb1,0x005676ab,0x005273aa),  ivec4(0x005372ab,0x005271ac,0x005775b1,0x005776b2),  ivec4(0x005875b1,0x00526fb1,0x004c77bf,0x006081b8),  ivec4(0x00c9cbd8,0x00dbd3db,0x00cfd6ec,0x00cddcef),\n  ivec4(0x00dfe1da,0x00e9e2e1,0x00e3dbe7,0x00dee1e5),  ivec4(0x00d1e0e8,0x00a6bce9,0x0083abe2,0x0089bde9),  ivec4(0x0090bbf8,0x0093bef2,0x0095c4ef,0x0098c7f1),  ivec4(0x009ac9f4,0x0099c6f4,0x0095c1f4,0x0093bdf5),\n  ivec4(0x008fb7f5,0x008baef2,0x0080a9ec,0x0072a1e0),  ivec4(0x007895d9,0x007b89d4,0x006185cc,0x004d88c5),  ivec4(0x003f6daa,0x00b1afda,0x00b3b5cc,0x00c8bbc3),  ivec4(0x00b2a8ae,0x009da6b4,0x0098a1b3,0x00a7a2b1),\n  ivec4(0x00a6a1b6,0x00939eb8,0x007185a7,0x0051669a),  ivec4(0x004d63a4,0x004965a5,0x0047689d,0x00486899),  ivec4(0x0048639d,0x004c5ea8,0x004861a4,0x004c64a0),  ivec4(0x004f659f,0x004c67a3,0x004766a8,0x004a67a7),\n  ivec4(0x00566ca1,0x000b173b,0x00000d24,0x00001024),  ivec4(0x0000102b,0x00000d36,0x00000644,0x000b0c65),  ivec4(0x00070374,0x00090084,0x0007008b,0x00130d85),  ivec4(0x00474885,0x00ecefff,0x00fcfdfd,0x00fffff8),\n  ivec4(0x00fffffd,0x00fafeff,0x00faffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffffc,0x00fffbff,0x00fdfdff,0x00fdfffd),  ivec4(0x00fefeff,0x00fffdff,0x00fffffc,0x00fefffc),\n  ivec4(0x00f0f5ff,0x00514fac,0x001b08b2,0x000802b0),  ivec4(0x000201ac,0x000200b4,0x000901b2,0x0002048d),  ivec4(0x00010d60,0x00041950,0x00061b53,0x00061b54),  ivec4(0x00041450,0x0028397a,0x003f5195,0x00374d8e),\n  ivec4(0x003f5893,0x0038568f,0x003a5692,0x00395794),  ivec4(0x003c5993,0x00435c93,0x00475e99,0x00405c9e),  ivec4(0x00405da3,0x004a66a7,0x003e60ac,0x004865ab),  ivec4(0x005a6294,0x008f8dae,0x008791b5,0x008fa4bf),\n  ivec4(0x008c9fa5,0x009ea1a4,0x0094a4b6,0x007399b5),  ivec4(0x006792c0,0x005e7bc1,0x006b8dc5,0x00547fa1),  ivec4(0x007494e2,0x006385c8,0x00688ec2,0x006c91c7),  ivec4(0x006f94c9,0x007197cc,0x006f93cc,0x006c90cc),\n  ivec4(0x00698aca,0x006180c8,0x005578c0,0x005179b7),  ivec4(0x005b75b7,0x006071b6,0x005275b0,0x003d74a4),  ivec4(0x005074b4,0x00475fa9,0x00638db1,0x008593b0),  ivec4(0x00919aad,0x008e9ea9,0x0096a0ae,0x009a94ae),\n  ivec4(0x009794bb,0x006f80ad,0x004d6693,0x004d639f),  ivec4(0x004d64a9,0x004963a7,0x004868a1,0x00416196),  ivec4(0x004c68a3,0x00465ba2,0x0049609f,0x004a629e),  ivec4(0x004a629f,0x004864a3,0x004463a3,0x004965a1),\n  ivec4(0x00526798,0x000a163a,0x00000d24,0x00000e24),  ivec4(0x00000c30,0x00000841,0x00020556,0x000b0a70),  ivec4(0x00060179,0x000a0186,0x00070189,0x00060283),  ivec4(0x0000006e,0x00bcbde9,0x00f7fafe,0x00fffff2),\n  ivec4(0x00fffffd,0x00fcfdff,0x00fafffd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffff9,0x00fff9ff,0x00fafcff,0x00fafff9),  ivec4(0x00fffcff,0x00fffaff,0x00fefef5,0x00fafef9),\n  ivec4(0x00cbd2fc,0x0000009d,0x000709a6,0x000707b1),  ivec4(0x000501bc,0x000500ba,0x000a03b6,0x000802ab),  ivec4(0x00050584,0x00020544,0x00020936,0x0001062c),  ivec4(0x0001022a,0x0024295e,0x00404c89,0x003e538e),\n  ivec4(0x003c568f,0x003c5492,0x00385594,0x00385794),  ivec4(0x003f598f,0x00495d8d,0x004b5f91,0x00415c9b),  ivec4(0x003d5da8,0x004963a6,0x004b65a8,0x004d67a9),  ivec4(0x004a66a7,0x004564a1,0x00586fa5,0x006679a8),\n  ivec4(0x00707fa9,0x00737baa,0x006578b4,0x004d6eb7),  ivec4(0x004f74bd,0x005875af,0x00566a9b,0x00152461),  ivec4(0x004967ac,0x00455fa5,0x00475fa4,0x004860a6),  ivec4(0x004962a7,0x004a63a8,0x004a63a8,0x004761a6),\n  ivec4(0x00455fa3,0x00445ea1,0x00445ea1,0x00445ca6),  ivec4(0x00455fa5,0x004864a1,0x005b73a8,0x00212a59),  ivec4(0x0053609d,0x006170b5,0x004c67ad,0x005569a7),  ivec4(0x007680b1,0x00787da7,0x007980a8,0x006a78a8),\n  ivec4(0x005169a3,0x0048629f,0x004c689c,0x004a63a4),  ivec4(0x00485ea9,0x00475ea8,0x004863a2,0x00405b94),  ivec4(0x004c689f,0x00415b96,0x004c5f98,0x00485f99),  ivec4(0x00435d9e,0x00405da0,0x00425f9e,0x00496299),\n  ivec4(0x004b5d8c,0x00081439,0x00010b27,0x00010a29),  ivec4(0x00000436,0x00010550,0x0006086b,0x00040279),  ivec4(0x00060083,0x00080087,0x00080385,0x00030280),  ivec4(0x00070388,0x00625fac,0x00f8fdfe,0x00ffffeb),\n  ivec4(0x00fffefc,0x00fffbff,0x00fbfff8,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffffa,0x00fffaff,0x00fafdff,0x00fafff9),  ivec4(0x00fdfaff,0x00fff8fe,0x00fffff7,0x00fafdfe),\n  ivec4(0x008c8cdf,0x000301a5,0x000c07b6,0x000905bd),  ivec4(0x000a03c6,0x000600c0,0x000800ba,0x000b02b4),  ivec4(0x000f089f,0x000a0874,0x0001004e,0x0000012e),  ivec4(0x00020c2a,0x00162445,0x003d4e7c,0x00374b82),\n  ivec4(0x00394f89,0x003a4f8c,0x0036518e,0x0037538e),  ivec4(0x0040578a,0x003d4d77,0x004d5d8a,0x00485f96),  ivec4(0x00425e9f,0x004760a3,0x004863a6,0x004a66a9),  ivec4(0x004966a9,0x004d6aab,0x004e69a5,0x00516aa2),\n  ivec4(0x00576ea0,0x005a6fac,0x00506cb0,0x005677bb),  ivec4(0x005471ad,0x006276a2,0x00000000,0x0048547f),  ivec4(0x004c5f99,0x00455d9e,0x00435c9f,0x00425b9f),  ivec4(0x00415b9e,0x00415a9e,0x00415a9d,0x00415a9e),\n  ivec4(0x00415a9d,0x00405a9b,0x003e5a9a,0x003d579d),  ivec4(0x003e589e,0x00425a9b,0x00496098,0x00000010),  ivec4(0x00303c65,0x00556392,0x004e69a7,0x00546fab),  ivec4(0x004a619c,0x004f66a0,0x004e65a2,0x004a64a4),\n  ivec4(0x004764a9,0x004765a9,0x004865a1,0x004861a6),  ivec4(0x00475da8,0x00495fa3,0x00455e95,0x00516a96),  ivec4(0x00415783,0x00425585,0x00485c93,0x00455a94),  ivec4(0x00405997,0x003c5998,0x003e5a96,0x00425991),\n  ivec4(0x00445686,0x00060e36,0x00000529,0x00010532),  ivec4(0x00020340,0x00030658,0x0006066f,0x0005027b),  ivec4(0x00050081,0x00070086,0x00050084,0x00070386),  ivec4(0x0008048b,0x0000007d,0x00f0f3ff,0x00fefff2),\n  ivec4(0x00fffefd,0x00fffbff,0x00fcfffa,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffffc,0x00fffaff,0x00fbfeff,0x00fbfffa),  ivec4(0x00fdf8ff,0x00fefafb,0x00fdfff6,0x00f8f9fe),\n  ivec4(0x005450ae,0x000d03b9,0x000601bc,0x000d05ca),  ivec4(0x000200c4,0x000400c2,0x000600bd,0x000b00b7),  ivec4(0x000c01a8,0x00070087,0x0008056c,0x00010645),  ivec4(0x0001052e,0x00091836,0x003b4d7a,0x002f4479),\n  ivec4(0x00344881,0x00394984,0x00364b88,0x00374f88),  ivec4(0x00425585,0x00000026,0x00455174,0x004c5b87),  ivec4(0x00495d92,0x00445c9a,0x00465fa1,0x004662a6),  ivec4(0x004563a8,0x004664aa,0x004a68aa,0x004f6aab),\n  ivec4(0x00506aa8,0x004766ac,0x005272b5,0x00536ea6),  ivec4(0x004b5c86,0x00000000,0x0000000c,0x00565f87),  ivec4(0x0048588d,0x00425797,0x0040569b,0x0040579b),  ivec4(0x0042599c,0x0042599d,0x0041599c,0x0041589c),\n  ivec4(0x0041589b,0x003f5998,0x003e5a95,0x003b5797),  ivec4(0x003c559b,0x0042569a,0x00495a95,0x0025305a),  ivec4(0x00000000,0x002f3c51,0x00496192,0x004d689e),  ivec4(0x004a68a4,0x004365aa,0x004263ad,0x004262ae),\n  ivec4(0x004261ad,0x00415fa9,0x004463a3,0x00455fa3),  ivec4(0x00465ba2,0x004a5d99,0x0050638e,0x004c5f7e),  ivec4(0x00374661,0x00131b36,0x00485c8e,0x00435891),  ivec4(0x003f5790,0x003c5492,0x003a5490,0x003a4e86),\n  ivec4(0x003c4c81,0x00050733,0x00010236,0x00040542),  ivec4(0x00050550,0x00030260,0x00040374,0x0004017d),  ivec4(0x00050082,0x00060086,0x00050187,0x00050187),  ivec4(0x000b088e,0x00000079,0x00c0c1ec,0x00fdfffb),\n  ivec4(0x00fffefe,0x00fffcff,0x00fdfffd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffffe,0x00fffcff,0x00fbfffe,0x00fcfffc),  ivec4(0x00fffbff,0x00fdfaf6,0x00f8fff5,0x00f1f1ff),\n  ivec4(0x001f13ab,0x000e03c1,0x000600c0,0x000701c5),  ivec4(0x000500c6,0x000500c1,0x000802bc,0x000902b5),  ivec4(0x0005009f,0x0001007e,0x000d0977,0x0007095e),  ivec4(0x00060b54,0x00050847,0x00333e7d,0x002d3e79),\n  ivec4(0x002f4378,0x00394480,0x00364784,0x00374c85),  ivec4(0x00415380,0x00000017,0x00000016,0x00434b6a),  ivec4(0x0045547c,0x004b5c92,0x00495d97,0x00445d9b),  ivec4(0x00435d9f,0x004563a5,0x004461a4,0x004763a4),\n  ivec4(0x004c67a8,0x004b66a2,0x004c6396,0x0039466a),  ivec4(0x00000000,0x00000111,0x00050823,0x00525f8f),  ivec4(0x00425997,0x0040589b,0x0041599b,0x0040589a),  ivec4(0x0041599a,0x00425a9b,0x00435a9c,0x0041599b),\n  ivec4(0x0040589a,0x003f5896,0x003e5991,0x003a5693),  ivec4(0x003a5396,0x003e5199,0x004f5c9c,0x004b547d),  ivec4(0x0000040f,0x00000000,0x00000927,0x004b5f83),  ivec4(0x00445e92,0x004868a8,0x004364ab,0x004563aa),\n  ivec4(0x004961a7,0x004960a1,0x0043609c,0x00485e9e),  ivec4(0x004d5d9a,0x004d5b8c,0x004a5876,0x00354052),  ivec4(0x00000000,0x00272e46,0x00435687,0x003e538c),  ivec4(0x003c508a,0x00384d8a,0x003b4f8c,0x00384783),\n  ivec4(0x00343f77,0x00030537,0x00040645,0x0007054f),  ivec4(0x00020158,0x00010067,0x00040278,0x0003007f),  ivec4(0x00040084,0x00060085,0x000b028e,0x0005028a),  ivec4(0x00030187,0x00020183,0x008b89b4,0x00fcffff),\n  ivec4(0x00fffefe,0x00fffbff,0x00fdffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffeff,0x00fffdff,0x00fcfffb,0x00fdfffe),  ivec4(0x00fff9ff,0x00fffff6,0x00f8fff9,0x00e9e6ff),\n  ivec4(0x000000a3,0x000900c0,0x000900c1,0x000701c3),  ivec4(0x000702c2,0x000501bb,0x000601b7,0x000501b0),  ivec4(0x00020094,0x00040275,0x000a0877,0x00070471),  ivec4(0x0003006c,0x0004046b,0x00161870,0x00303c7f),\n  ivec4(0x002e3e75,0x00343e7c,0x00314280,0x00334580),  ivec4(0x003e4f7b,0x00070c26,0x0000000e,0x00000000),  ivec4(0x002b334b,0x0048537b,0x00465681,0x003d5082),  ivec4(0x0040578b,0x00435c94,0x00405891,0x00435992),\n  ivec4(0x00475b91,0x00405077,0x000f142f,0x00000000),  ivec4(0x0006020b,0x00000011,0x0029365e,0x003b5492),  ivec4(0x002a4c96,0x003b569c,0x00405698,0x00405698),  ivec4(0x00405698,0x00405698,0x00405698,0x00405698),\n  ivec4(0x00405698,0x00405596,0x003e578f,0x003b578f),  ivec4(0x003a5693,0x003c5299,0x00445297,0x0059608f),  ivec4(0x00000000,0x00000500,0x00010002,0x00000000),  ivec4(0x002f3d5c,0x004a608d,0x00435b90,0x00495e94),\n  ivec4(0x00515f93,0x00515f8f,0x00455c8d,0x0047598b),  ivec4(0x004c5886,0x00424b6d,0x00101829,0x00000000),  ivec4(0x0000000f,0x00333a57,0x003c4d81,0x003b4e87),  ivec4(0x00354884,0x00354584,0x00344383,0x00333b7c),\n  ivec4(0x00060d50,0x00000143,0x00000047,0x00040054),  ivec4(0x00030060,0x0002006d,0x0004027d,0x00030083),  ivec4(0x00040086,0x00060087,0x0007008d,0x0006008c),  ivec4(0x0003028a,0x000a038d,0x006b6aa6,0x00f9fcff),\n  ivec4(0x00fffefb,0x00fefcff,0x00fdffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffdff,0x00fffeff,0x00fcfff8,0x00fefeff),  ivec4(0x00fff6ff,0x00fffff5,0x00f7fffc,0x00c0bcff),\n  ivec4(0x000000ae,0x000a00c5,0x000802c3,0x000602c1),  ivec4(0x000504be,0x000403ba,0x000603b8,0x000500b6),  ivec4(0x0006029b,0x00010173,0x00040478,0x0004007a),  ivec4(0x00000079,0x00020076,0x00000066,0x000c1261),\n  ivec4(0x00293271,0x002f3679,0x002b3b7c,0x002b3e7b),  ivec4(0x00354673,0x00181d36,0x00020411,0x0000010b),  ivec4(0x00000000,0x00000000,0x00222a44,0x003b4664),  ivec4(0x003d4b6f,0x003b4c73,0x0039476d,0x002c3a5d),\n  ivec4(0x00000025,0x00000000,0x00030208,0x000c0406),  ivec4(0x00070207,0x00000010,0x00425789,0x00365599),  ivec4(0x002d4f9a,0x00395399,0x003e5394,0x003e5394),  ivec4(0x003e5394,0x003e5394,0x003e5394,0x003e5394),\n  ivec4(0x003e5394,0x00415396,0x00425493,0x003d588d),  ivec4(0x003a588d,0x003a5496,0x003d4c98,0x004a548e),  ivec4(0x001c223c,0x00000004,0x00040105,0x0001010d),  ivec4(0x00000000,0x00000000,0x00212945,0x0035405e),\n  ivec4(0x00464f6e,0x00485070,0x00404e6f,0x002f3857),  ivec4(0x000b0f2a,0x00000000,0x00000000,0x00000511),  ivec4(0x00000005,0x00404a71,0x00364680,0x00334482),  ivec4(0x00334281,0x00333f82,0x00222b6c,0x0000004a),\n  ivec4(0x00000047,0x0001014d,0x00030050,0x00020055),  ivec4(0x00000061,0x00030072,0x0004017f,0x00020084),  ivec4(0x00030086,0x00050087,0x00070090,0x0006018b),  ivec4(0x00020387,0x00070191,0x0049479c,0x00f8faff),\n  ivec4(0x00fefff8,0x00fefefe,0x00fefdff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffdff,0x00ffffff,0x00fbfff7,0x00fffeff),  ivec4(0x00fff7ff,0x00fffff3,0x00f5fffc,0x00a49ffa),\n  ivec4(0x000300bb,0x000a00c9,0x000800c7,0x000602c4),  ivec4(0x000402c1,0x000502bf,0x000501be,0x000600be),  ivec4(0x000e03b1,0x0004008b,0x00010080,0x0005027e),  ivec4(0x00020179,0x00040177,0x0001016c,0x0001005c),\n  ivec4(0x00010357,0x001e256a,0x0027387c,0x00243979),  ivec4(0x002b3d6d,0x002c344f,0x00000003,0x00000007),  ivec4(0x0002030b,0x0001010c,0x00000000,0x00000000),  ivec4(0x00000000,0x00000000,0x00000000,0x00000000),\n  ivec4(0x00010113,0x0003091f,0x00000008,0x00080103),  ivec4(0x00020007,0x00040b26,0x00354e83,0x003a5697),  ivec4(0x00445b9d,0x003c5091,0x003e5192,0x003e5192),  ivec4(0x003e5192,0x003e5192,0x003e5192,0x003e5192),\n  ivec4(0x003d5192,0x00414e95,0x00425094,0x003d5688),  ivec4(0x00365986,0x00375493,0x00314392,0x00434b93),  ivec4(0x00494f7a,0x00000009,0x00010007,0x0004020e),  ivec4(0x00040310,0x00060718,0x00000002,0x00000000),\n  ivec4(0x00000000,0x00000000,0x00000000,0x00000000),  ivec4(0x0000000b,0x00010208,0x00000105,0x0000010b),  ivec4(0x00040724,0x00455082,0x00324180,0x00334082),  ivec4(0x00323c80,0x00151b60,0x00000048,0x0000004f),\n  ivec4(0x00030254,0x00030155,0x00040055,0x00020057),  ivec4(0x00040165,0x00070476,0x00040180,0x00000085),  ivec4(0x00020087,0x00040088,0x00070091,0x0006018a),  ivec4(0x00020484,0x00050092,0x00292391,0x00fbfdff),\n  ivec4(0x00fcfff2,0x00fffffb,0x00fcfcfc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffcff,0x00fffffe,0x00fbfff7,0x00fffeff),  ivec4(0x00fff8ff,0x00fffff1,0x00f4fffa,0x008e8be4),\n  ivec4(0x000a00c1,0x000b00ce,0x000900cc,0x000600c9),  ivec4(0x000300c6,0x000600c6,0x000500c4,0x000600c5),  ivec4(0x001204c8,0x000f00af,0x0000008b,0x00020179),  ivec4(0x00020572,0x00060672,0x00060370,0x00040469),\n  ivec4(0x00030360,0x00000152,0x000a1763,0x00243779),  ivec4(0x0026386b,0x003c4465,0x00030312,0x00010208),  ivec4(0x0003050a,0x00050609,0x00010107,0x0001010c),  ivec4(0x00000111,0x00040718,0x0000000e,0x0005050c),\n  ivec4(0x0004020a,0x00040311,0x0003030e,0x0005030a),  ivec4(0x0000000f,0x0025345a,0x00364e86,0x00354a88),  ivec4(0x003e4c84,0x003e508b,0x003a508d,0x003a508d),  ivec4(0x003a508d,0x003a508d,0x003a508d,0x003a508d),\n  ivec4(0x003a508d,0x003e4d92,0x003f4c91,0x003b5285),  ivec4(0x00335584,0x0032508d,0x00354b97,0x0038478f),  ivec4(0x00434e82,0x00040a1d,0x0001010e,0x0002020c),  ivec4(0x00010007,0x00060209,0x00080712,0x00030616),\n  ivec4(0x00000117,0x00000015,0x0000020e,0x00040410),  ivec4(0x0005020b,0x00010003,0x00030507,0x0000000e),  ivec4(0x001f274d,0x00333e79,0x00303c80,0x00242e74),  ivec4(0x00030b56,0x0000004b,0x00000250,0x00030153),\n  ivec4(0x00010054,0x00000054,0x00030059,0x0002005d),  ivec4(0x0007056f,0x0009077c,0x00040180,0x00020085),  ivec4(0x00010088,0x0003008a,0x00070090,0x00060189),  ivec4(0x00010585,0x00050094,0x00000085,0x00f9fdff),\n  ivec4(0x00f9fef3,0x00fffffa,0x00fafbfa,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffbff,0x00fdfffb,0x00fdffff,0x00fffdff),  ivec4(0x00fffeff,0x00feffef,0x00eefff3,0x007f82d7),\n  ivec4(0x000d00c7,0x000900cd,0x000800cc,0x000800cc),  ivec4(0x000800cc,0x000700cb,0x000700cc,0x000700cb),  ivec4(0x000900ce,0x000e02cb,0x000201a2,0x0000007d),  ivec4(0x0007067b,0x00050079,0x00030079,0x00010074),\n  ivec4(0x0001056f,0x00000268,0x00000057,0x00000251),  ivec4(0x00222c6a,0x0032386f,0x00191a41,0x0000000c),  ivec4(0x00030208,0x0000020f,0x00000112,0x00000018),  ivec4(0x0001001a,0x0005011d,0x00030315,0x0003060b),\n  ivec4(0x00050905,0x000d0802,0x00070403,0x0000010d),  ivec4(0x00030b2d,0x00425285,0x003b4d89,0x003b4d8b),  ivec4(0x003e4e8b,0x003a4d8a,0x00384d8a,0x00384d8a),  ivec4(0x00384d8a,0x00384d8a,0x00384d8a,0x00384d8a),\n  ivec4(0x00384d8a,0x00384d8b,0x003a4e8c,0x00394e8b),  ivec4(0x00394e8a,0x00384e88,0x003c538c,0x0031487f),  ivec4(0x003c5389,0x0025355d,0x0002020b,0x00000002),  ivec4(0x00020403,0x00040704,0x00020609,0x00010312),\n  ivec4(0x0000001c,0x00000024,0x0000001f,0x00000015),  ivec4(0x0003060e,0x00000405,0x00020509,0x00030419),  ivec4(0x0032396a,0x00313779,0x001c1b68,0x0000004c),  ivec4(0x00020055,0x00030058,0x00000057,0x00000054),\n  ivec4(0x00010352,0x00000350,0x00000067,0x00000075),  ivec4(0x0005037e,0x0005037f,0x00050182,0x00050084),  ivec4(0x00050087,0x00050087,0x00070088,0x00050286),  ivec4(0x0001028e,0x00020095,0x00000076,0x00f8feff),\n  ivec4(0x00f2f5f9,0x00fefefe,0x00fefffa,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffbff,0x00fdfffb,0x00fdffff,0x00fffdff),  ivec4(0x00fffdff,0x00fffff5,0x00f0fff8,0x008a8be4),\n  ivec4(0x000600c4,0x000a00cf,0x000900cc,0x000900cd),  ivec4(0x000900cd,0x000900cc,0x000900cc,0x000900cc),  ivec4(0x000700cb,0x000d08cd,0x000e08c0,0x0002009c),  ivec4(0x00010084,0x00040379,0x00040574,0x00030276),\n  ivec4(0x00000075,0x00020076,0x0000026e,0x0000005e),  ivec4(0x00000056,0x00141461,0x0024225b,0x0001001c),  ivec4(0x0002030e,0x00000013,0x00000018,0x0001001c),  ivec4(0x00050020,0x00060020,0x0004001d,0x00040018),\n  ivec4(0x00020012,0x00070205,0x00020005,0x00000015),  ivec4(0x00222d56,0x00394882,0x00354987,0x0036488a),  ivec4(0x00374a89,0x00394a8c,0x0039498c,0x0039498c),  ivec4(0x0039498c,0x003a4b8d,0x003a4c8e,0x003a4c8e),\n  ivec4(0x003a4c8e,0x003a4b8d,0x003a4a8d,0x003a4a8d),  ivec4(0x003a4b8b,0x00394b8b,0x003a4c8b,0x00394c89),  ivec4(0x00354884,0x00425183,0x000b0e20,0x00000310),  ivec4(0x00000105,0x00020205,0x00000207,0x0001010e),\n  ivec4(0x00020019,0x0002001f,0x00010019,0x00030317),  ivec4(0x00060712,0x0001050e,0x00010413,0x0015193f),  ivec4(0x00262c62,0x0000004e,0x00000048,0x00030254),  ivec4(0x00020154,0x00030156,0x00030157,0x00000158),\n  ivec4(0x00000059,0x0000025b,0x00010072,0x0002007c),  ivec4(0x0005037f,0x0004017f,0x00050083,0x00050085),  ivec4(0x00050087,0x00050087,0x00070088,0x00050386),  ivec4(0x0000028e,0x00030094,0x00010175,0x00f7fcff),\n  ivec4(0x00fbfdff,0x00fefefe,0x00fdfff9,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffcff,0x00fefffb,0x00fdfeff,0x00fffeff),  ivec4(0x00fffcff,0x00fffffc,0x00f2fffd,0x009c99f4),\n  ivec4(0x000100c2,0x000801d0,0x000700cf,0x000800cf),  ivec4(0x000700cf,0x000700ce,0x000700ce,0x000700ce),  ivec4(0x000602cb,0x000103c7,0x000e04d4,0x001102cb),  ivec4(0x0002019f,0x0000007d,0x00010570,0x0005047a),\n  ivec4(0x0002007e,0x00050082,0x0004007c,0x00010074),  ivec4(0x00040071,0x00000063,0x00060456,0x00030639),  ivec4(0x00000015,0x0000000e,0x0000000e,0x0001010e),  ivec4(0x0002030e,0x00030310,0x00040012,0x00010015),\n  ivec4(0x00000014,0x0002010d,0x0000000b,0x00121a37),  ivec4(0x003d4d7c,0x00354883,0x00334787,0x00344888),  ivec4(0x00364987,0x00364788,0x0036468a,0x0036468a),  ivec4(0x0036468a,0x0037488c,0x0038498d,0x0038498d),\n  ivec4(0x0038498d,0x0038488d,0x0037468c,0x0037478b),  ivec4(0x0037488b,0x0037488b,0x00334687,0x00384a8a),  ivec4(0x00344685,0x0037467f,0x00374064,0x0003061a),  ivec4(0x0000000d,0x0004050e,0x00000005,0x00020108),\n  ivec4(0x00040010,0x00060014,0x00040310,0x00050313),  ivec4(0x00010012,0x00000018,0x00010022,0x000a0b46),  ivec4(0x00000041,0x00030858,0x00000156,0x00000152),  ivec4(0x00010253,0x00000151,0x00000256,0x0000005c),\n  ivec4(0x00000066,0x0002006f,0x0005037d,0x00050282),  ivec4(0x00050281,0x00050083,0x00060186,0x00060087),  ivec4(0x0006008a,0x0006008b,0x00070089,0x00050286),  ivec4(0x0001028d,0x00060091,0x0018187c,0x00f7fbff),\n  ivec4(0x00fdfeff,0x00fefdff,0x00fdfff9,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffeff,0x00fffffb,0x00fbfdff,0x00fffeff),  ivec4(0x00fffdff,0x00fffdff,0x00f4ffff,0x00b0acfd),\n  ivec4(0x000200bf,0x000900d3,0x000800d1,0x000800d1),  ivec4(0x000900d2,0x000900d2,0x000900d2,0x000900d2),  ivec4(0x000703d2,0x000001d0,0x000400d5,0x001305db),  ivec4(0x001207c6,0x0004009c,0x00000084,0x00050481),\n  ivec4(0x0003007c,0x00060081,0x0004007d,0x0005007d),  ivec4(0x0004007d,0x0007007a,0x0004006a,0x00070b57),  ivec4(0x0001073c,0x00010013,0x0000000c,0x00000501),  ivec4(0x00000800,0x00000900,0x00000600,0x00000103),\n  ivec4(0x00000005,0x00010314,0x00070f2a,0x0038476d),  ivec4(0x00324477,0x0031457f,0x002f4580,0x00304681),  ivec4(0x0031497f,0x00344682,0x00354685,0x00354685),  ivec4(0x00354685,0x00364686,0x00364686,0x00364686),\n  ivec4(0x00364686,0x00364686,0x00364687,0x00364687),  ivec4(0x00364686,0x00364784,0x00364886,0x00314280),  ivec4(0x00374886,0x00344580,0x003e4b7a,0x00233056),  ivec4(0x0004061b,0x0000000b,0x00000006,0x00010006),\n  ivec4(0x00040007,0x00060009,0x0003000a,0x00010011),  ivec4(0x0000001a,0x0001002e,0x000b064a,0x0003004d),  ivec4(0x0006075d,0x00000159,0x0001025c,0x00000159),  ivec4(0x00010355,0x00010458,0x0000015c,0x00000067),\n  ivec4(0x00020077,0x00090186,0x00070287,0x00040285),  ivec4(0x00040186,0x00050288,0x00050188,0x0005008b),  ivec4(0x0005008b,0x0005008c,0x0006008b,0x00040287),  ivec4(0x0002028c,0x0008018e,0x003b3a86,0x00fbffff),\n  ivec4(0x00ffffff,0x00fdfcff,0x00fafff9,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffffd,0x00fffffc,0x00fbfbff,0x00fefffe),  ivec4(0x00fef9fb,0x00fef6ff,0x00f8ffff,0x00dcd9ff),\n  ivec4(0x000000b6,0x000600d3,0x000500d1,0x000500d1),  ivec4(0x000600d3,0x000700d3,0x000700d3,0x000700d3),  ivec4(0x000500d8,0x000200dd,0x000602d8,0x000804d3),  ivec4(0x001006d4,0x001308cd,0x000400aa,0x0002008f),\n  ivec4(0x00020480,0x00020379,0x00020378,0x0003017a),  ivec4(0x00030080,0x00050083,0x0005007d,0x0005046f),  ivec4(0x00050b62,0x000b0848,0x0000002d,0x00000018),  ivec4(0x0000010a,0x00000305,0x00000505,0x00000307),\n  ivec4(0x00020211,0x00101836,0x0036466e,0x00304070),  ivec4(0x002d3f76,0x002e427b,0x002d437b,0x002e437b),  ivec4(0x002f4578,0x0032477d,0x0032457e,0x0031447d),  ivec4(0x0030437c,0x0031447d,0x0032457e,0x0032457d),\n  ivec4(0x0032457d,0x0032457e,0x00334580,0x00334581),  ivec4(0x00324580,0x00334580,0x0030437e,0x0032447f),  ivec4(0x0031447f,0x0032447f,0x0032447d,0x00364576),  ivec4(0x00283259,0x000b0e26,0x00000011,0x0000000d),\n  ivec4(0x0000000b,0x0002010d,0x00000013,0x0000001d),  ivec4(0x00010035,0x000b0550,0x00060158,0x00020060),  ivec4(0x00020062,0x00000164,0x00020364,0x00000160),  ivec4(0x0000005e,0x00000160,0x00000066,0x00030278),\n  ivec4(0x000b048a,0x00080090,0x0006018d,0x0004028b),  ivec4(0x0004028b,0x0004018c,0x0004018c,0x0004018d),  ivec4(0x0003008c,0x0002008c,0x0007018e,0x00040486),  ivec4(0x00010189,0x000f078f,0x0067679c,0x00f7faff),\n  ivec4(0x00f8f8f6,0x00fcfdfe,0x00fcfffd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffffb,0x00fffffe,0x00fbfbff,0x00fdfff9),  ivec4(0x00fffefc,0x00fffaff,0x00f9fdfc,0x00f1f1ff),\n  ivec4(0x000303b5,0x000800d8,0x000a02d9,0x000a01d8),  ivec4(0x000901d7,0x000800d6,0x000800d6,0x000800d6),  ivec4(0x000700dd,0x000400e1,0x000504d7,0x000706d3),  ivec4(0x000a04da,0x001205e5,0x00190ade,0x000502b1),\n  ivec4(0x00000093,0x00000485,0x0000057f,0x0000017b),  ivec4(0x00040281,0x00040085,0x00030085,0x0002007e),  ivec4(0x00010277,0x000c0275,0x000c036c,0x0004015a),  ivec4(0x00010143,0x00010133,0x00010233,0x00000136),\n  ivec4(0x001e2158,0x0026326c,0x002c3978,0x002a387b),  ivec4(0x002e3c82,0x002a377d,0x002b397c,0x002b3c7b),  ivec4(0x002e3e79,0x002e3f79,0x002f3f7a,0x0030407c),  ivec4(0x0031417c,0x0031417c,0x0031417c,0x0031417c),\n  ivec4(0x0031417b,0x0031417d,0x00334180,0x00334281),  ivec4(0x00344281,0x00334181,0x00303e7f,0x00303d80),  ivec4(0x00303d81,0x002f3d83,0x002e3d83,0x002f3c7d),  ivec4(0x00323c74,0x002f3464,0x000a0c3a,0x00000128),\n  ivec4(0x0001022a,0x00010128,0x00030139,0x00080448),  ivec4(0x000a0756,0x0007045f,0x00020164,0x00010067),  ivec4(0x00000068,0x00000066,0x00000069,0x00000069),  ivec4(0x0000006d,0x00010276,0x00080783,0x0007048c),\n  ivec4(0x00070290,0x00070093,0x00040090,0x0004008f),  ivec4(0x0004008f,0x0004008f,0x0004008f,0x0004008f),  ivec4(0x0004008f,0x0003008e,0x0005008f,0x0006038a),  ivec4(0x00000083,0x000b0388,0x008583ac,0x00fdfefe),\n  ivec4(0x00fcfcf7,0x00fcfdfe,0x00fbfffd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffff9,0x00fffeff,0x00fbf9ff,0x00fdfff7),  ivec4(0x00fffff8,0x00fffafe,0x00f8fef5,0x00f9fdff),\n  ivec4(0x003c3ac3,0x000700d9,0x000801d8,0x000801d8),  ivec4(0x000801d8,0x000801d8,0x000801d8,0x000801d8),  ivec4(0x000800da,0x000b02dd,0x000803da,0x000704dd),  ivec4(0x000802e3,0x000500e3,0x000c00e2,0x001b10e5),\n  ivec4(0x000b02c8,0x000100a4,0x00000090,0x0002038c),  ivec4(0x00000081,0x00060088,0x00050089,0x00020086),  ivec4(0x00010084,0x00050089,0x00070085,0x0006017f),  ivec4(0x00040176,0x000a0876,0x00090771,0x0008056f),\n  ivec4(0x00000066,0x00000264,0x00000464,0x00000465),  ivec4(0x000d1171,0x001f227c,0x0022277b,0x00282e7f),  ivec4(0x002f3481,0x002d3881,0x002c387f,0x002c387f),  ivec4(0x002c3880,0x002e3981,0x002e3a82,0x002e3a82),\n  ivec4(0x002e3a82,0x002f3a85,0x00303a86,0x002f3986),  ivec4(0x002e3786,0x002e3788,0x002f3789,0x00272f81),  ivec4(0x001e257a,0x001a1f77,0x00080f6e,0x00040664),  ivec4(0x00000058,0x00000054,0x00050457,0x00040558),\n  ivec4(0x00010558,0x0004095c,0x00090463,0x00070364),  ivec4(0x00010166,0x00000067,0x0000026d,0x0000006d),  ivec4(0x0001006c,0x0002006b,0x00000070,0x00000076),  ivec4(0x00030184,0x00080391,0x000a0497,0x00070195),\n  ivec4(0x00020090,0x0002008f,0x00030091,0x00030092),  ivec4(0x00030092,0x00030092,0x00030091,0x00030091),  ivec4(0x00020090,0x00010090,0x0003008f,0x0005028a),  ivec4(0x00020085,0x00000085,0x00a8a5d7,0x00fbfdfd),\n  ivec4(0x00fffffa,0x00fcfdff,0x00fbfffe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffff9,0x00fffeff,0x00fbf9ff,0x00fbfff5),  ivec4(0x00fffff7,0x00fffafe,0x00fefff7,0x00f5fdfc),\n  ivec4(0x006d6dce,0x000b03de,0x000600d7,0x000700d8),  ivec4(0x000a02db,0x000a02db,0x000a02db,0x000a02db),  ivec4(0x000b06d7,0x000c07d4,0x000c02e2,0x000800ea),  ivec4(0x000502e6,0x000907e2,0x000d08e7,0x000b00ea),\n  ivec4(0x001906f7,0x00140cdd,0x000502b9,0x00000098),  ivec4(0x0005038d,0x0008028a,0x00070089,0x00040088),  ivec4(0x00020285,0x0000027f,0x0000027e,0x00010282),  ivec4(0x00040584,0x000c0b8a,0x00060382,0x0002007e),\n  ivec4(0x0000007b,0x00010077,0x00020279,0x00040378),  ivec4(0x00030072,0x00010069,0x00030068,0x00050267),  ivec4(0x00080667,0x000b0e69,0x000b1269,0x000e156c),  ivec4(0x0011186e,0x00131970,0x0012196f,0x0012196f),\n  ivec4(0x0012196f,0x000f156e,0x00060c68,0x00040965),  ivec4(0x00010564,0x00000363,0x00000162,0x00000064),  ivec4(0x00000065,0x00000066,0x0000006e,0x0002006e),  ivec4(0x00080371,0x0005006f,0x00040072,0x00000073),\n  ivec4(0x00000177,0x00000075,0x00020074,0x00010074),  ivec4(0x00000173,0x00000270,0x0000006d,0x0000006e),  ivec4(0x00010071,0x00040071,0x00010179,0x00070588),  ivec4(0x000c0798,0x000a019f,0x0004009e,0x0005009b),\n  ivec4(0x00030295,0x0004058f,0x00040192,0x00040095),  ivec4(0x00040095,0x00040095,0x00040193,0x00030092),  ivec4(0x00030092,0x00020090,0x0002008f,0x00010088),  ivec4(0x00080789,0x0000007a,0x00e2ddff,0x00fcfdfe),\n  ivec4(0x00fffef9,0x00fefdff,0x00f7fefb,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffffe,0x00ffffff,0x00fdfeff,0x00fdfffd),  ivec4(0x00fffffc,0x00fffeff,0x00fffffd,0x00feffff),\n  ivec4(0x009694e6,0x000000ce,0x001004df,0x000b10d0),  ivec4(0x000500d4,0x000d00e2,0x000d00e2,0x000a01e3),  ivec4(0x000b06dd,0x000e05e1,0x000d05e6,0x000d04e9),  ivec4(0x000c05e8,0x000c06e7,0x000e05e8,0x000e03ed),\n  ivec4(0x000e03ed,0x000d09e8,0x001712eb,0x00150fd9),  ivec4(0x000201b9,0x000000a1,0x00010096,0x0001028a),  ivec4(0x0000017f,0x00070682,0x00090583,0x00060584),  ivec4(0x00050286,0x00050189,0x00040089,0x0000008a),\n  ivec4(0x0000008a,0x00030183,0x00030283,0x00050281),  ivec4(0x00060281,0x0005007c,0x0005007b,0x0007007b),  ivec4(0x0007007a,0x00040278,0x00030377,0x00030376),  ivec4(0x00030475,0x00030475,0x00030475,0x00030473),\n  ivec4(0x00030473,0x00020474,0x00010374,0x00010372),  ivec4(0x00010472,0x00010471,0x00020570,0x00020670),  ivec4(0x00020670,0x00020670,0x00030474,0x00030375),  ivec4(0x00030276,0x0003007b,0x0003007f,0x00010082),\n  ivec4(0x00000083,0x00010081,0x0008026e,0x0007026f),  ivec4(0x00040073,0x00000076,0x00000078,0x0000007f),  ivec4(0x00010089,0x00040292,0x000a08a0,0x000703a0),  ivec4(0x0003009e,0x0003009c,0x0007009f,0x0007009d),\n  ivec4(0x0008009a,0x00070196,0x00050099,0x00030099),  ivec4(0x00040097,0x00030094,0x00050093,0x00060291),  ivec4(0x0005028e,0x0006018c,0x0002068c,0x00070586),  ivec4(0x00060085,0x0000007a,0x00fffaff,0x00fffcff),\n  ivec4(0x00fffbff,0x00fcfefe,0x00fbfff8,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00dbdcfe,0x000000d1,0x000500d8,0x000106cd),  ivec4(0x000c0ade,0x000d00e1,0x000f01e5,0x000c01e7),  ivec4(0x000a06df,0x000b05e6,0x000c06e7,0x000c06e7),  ivec4(0x000d06e9,0x000d06eb,0x000d06eb,0x000d05ec),\n  ivec4(0x000d05ec,0x000a03ed,0x000a04eb,0x00170cee),  ivec4(0x001f15ec,0x001a11d7,0x000603b5,0x00000098),  ivec4(0x0000008e,0x00040093,0x00050092,0x00060191),  ivec4(0x0004018e,0x0001008b,0x00020189,0x00010189),\n  ivec4(0x00020389,0x0005008f,0x0005008f,0x0005008f),  ivec4(0x0007008e,0x0007008e,0x0008008d,0x0008008c),  ivec4(0x000a008b,0x0006008a,0x0005008a,0x00050089),  ivec4(0x00050089,0x00050087,0x00050086,0x00050086),\n  ivec4(0x00050086,0x00050086,0x00040086,0x00040086),  ivec4(0x00040085,0x00040085,0x00040084,0x00040082),  ivec4(0x00040082,0x00040082,0x00040081,0x0004007f),  ivec4(0x0004007e,0x0004017c,0x0005037b,0x0006037a),\n  ivec4(0x00060477,0x00070477,0x000a027d,0x0005007c),  ivec4(0x00030080,0x00020085,0x00060090,0x00070298),  ivec4(0x000b06a3,0x000d08a7,0x000600a5,0x0000009f),  ivec4(0x0000009d,0x000600a2,0x0007009f,0x0007009d),\n  ivec4(0x0008009b,0x0008009a,0x0005009a,0x0003009a),  ivec4(0x00040099,0x00040095,0x00050093,0x00060291),  ivec4(0x0006028d,0x0006018b,0x00020287,0x0003058f),  ivec4(0x00110688,0x00736ea7,0x00fcfbff,0x00fffeff),\n  ivec4(0x00fffbff,0x00fbfefe,0x00fbfff8,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00f0f9ff,0x002b27c0,0x001502ea,0x000501da),  ivec4(0x000806d9,0x000e03de,0x001000e9,0x000c04e8),  ivec4(0x000b09e2,0x000d06e9,0x000d06e9,0x000e07ea),  ivec4(0x000e07ec,0x001009ee,0x001008ef,0x001008ef),\n  ivec4(0x001006f2,0x000b03f2,0x000a00ef,0x000f02f2),  ivec4(0x001609f4,0x001307ea,0x001c15e8,0x001c16dd),  ivec4(0x00130fce,0x000100b2,0x000000a9,0x000000a2),  ivec4(0x0001009f,0x00010096,0x0001038f,0x0002058a),\n  ivec4(0x00020788,0x00060094,0x00060098,0x00060096),  ivec4(0x00080093,0x00060090,0x0008008f,0x0008008d),  ivec4(0x0009008c,0x00090091,0x00070094,0x00070092),  ivec4(0x00070092,0x00070091,0x00070190,0x00070190),\n  ivec4(0x00070190,0x00070190,0x00060090,0x00060090),  ivec4(0x00060090,0x00060090,0x00050090,0x0005008f),  ivec4(0x0005008f,0x0007008f,0x0009008b,0x00090089),  ivec4(0x00090086,0x00090183,0x0008027e,0x0007027b),\n  ivec4(0x00060376,0x00050178,0x00010093,0x00030097),  ivec4(0x0007019e,0x000f07a7,0x001109ad,0x001008ae),  ivec4(0x000b02ac,0x000500a7,0x000000a0,0x000300a3),  ivec4(0x000600a5,0x000801a5,0x000600a1,0x000800a0),\n  ivec4(0x0007009d,0x0008009b,0x0006009c,0x0004009b),  ivec4(0x00050099,0x00040096,0x00050093,0x00060291),  ivec4(0x0006028d,0x0006018c,0x0002008d,0x0003018f),  ivec4(0x00010079,0x00a5a2cf,0x00fcfcff,0x00fffffc),\n  ivec4(0x00fffeff,0x00fdfeff,0x00fbfffc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00f0feff,0x007b7dcf,0x000f00de,0x000600e4),  ivec4(0x000605d6,0x000d06db,0x000f01ec,0x000f06eb),  ivec4(0x000c0ce3,0x000c07ec,0x000d08ed,0x000d08ed),  ivec4(0x000e08ef,0x00100af3,0x00100af3,0x001009f4),\n  ivec4(0x001009f4,0x00170bfc,0x00170afc,0x000c01f7),  ivec4(0x000800f3,0x000e03f7,0x000d04f3,0x000e08ef),  ivec4(0x00110aec,0x001d19ee,0x001915e5,0x000d09d1),  ivec4(0x000100bb,0x000000ac,0x000000a2,0x00000099),\n  ivec4(0x00000093,0x00000095,0x00010094,0x00010091),  ivec4(0x0003018f,0x0005028d,0x0005048a,0x00070489),  ivec4(0x00070587,0x0006048b,0x0006048c,0x0006048c),  ivec4(0x0006058b,0x0006058b,0x0006058a,0x0006058a),\n  ivec4(0x00060589,0x00060589,0x0005048a,0x0005038b),  ivec4(0x0005038b,0x0005028d,0x0006038f,0x00060291),  ivec4(0x00060192,0x00060291,0x00040289,0x0004018c),  ivec4(0x0004008e,0x00040091,0x00030093,0x00060099),\n  ivec4(0x000b00a2,0x000c01a7,0x000b06b8,0x001009bb),  ivec4(0x001108bb,0x001007b8,0x000901b0,0x000801ad),  ivec4(0x000600aa,0x000400a8,0x000600a8,0x000601aa),  ivec4(0x000801a8,0x000701a6,0x000700a4,0x000600a1),\n  ivec4(0x000800a0,0x0007009d,0x0005009f,0x0004009c),  ivec4(0x0006009b,0x00050097,0x00060094,0x00060291),  ivec4(0x0006018f,0x0006018c,0x00050093,0x0006018e),  ivec4(0x0000006d,0x00e0defd,0x00fffffd,0x00fffff7),\n  ivec4(0x00fffffd,0x00fdfeff,0x00fbffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00f6fff9,0x00c1c3fc,0x000000be,0x000f02e6),  ivec4(0x000b07db,0x000c07db,0x000f01ee,0x000c06ea),  ivec4(0x000a0be4,0x000d07ee,0x000f09f0,0x00100af2),  ivec4(0x00110bf4,0x001009f4,0x00110af5,0x001109f6),\n  ivec4(0x00120bf6,0x00120cf4,0x00140df9,0x001106f7),  ivec4(0x000800f5,0x000700f5,0x000300f3,0x000400f3),  ivec4(0x000801f3,0x000c09ee,0x000c09ec,0x00110ceb),  ivec4(0x001b14ee,0x001e17ea,0x001c13df,0x00190dd5),\n  ivec4(0x001309cb,0x000703b1,0x000502a9,0x000000a3),  ivec4(0x0000009b,0x00000092,0x00000091,0x00000090),  ivec4(0x00010090,0x00020092,0x00030193,0x00030193),  ivec4(0x00040392,0x00030291,0x00030390,0x00030390),\n  ivec4(0x0004058f,0x00030390,0x00020190,0x0001008f),  ivec4(0x00010091,0x00010091,0x00000093,0x00000093),  ivec4(0x00000094,0x00000096,0x0000009b,0x000101a2),  ivec4(0x000604ad,0x000903b7,0x000c04c1,0x001106cb),\n  ivec4(0x001407d2,0x001307d2,0x000d08c4,0x000703bc),  ivec4(0x000301b6,0x000101b1,0x000100ac,0x000500ab),  ivec4(0x000900ab,0x000a01ac,0x000601ac,0x000701ac),  ivec4(0x000600ab,0x000700a7,0x000701a6,0x000801a5),\n  ivec4(0x000701a2,0x000600a1,0x000601a0,0x000601a0),  ivec4(0x0007019c,0x0006019a,0x00070197,0x00060193),  ivec4(0x00060190,0x0005008c,0x00050092,0x000c028c),  ivec4(0x003f3d8e,0x00f5f7ff,0x00fffffc,0x00fffff7),\n  ivec4(0x00fffffa,0x00fdffff,0x00fbfeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fdfff8,0x00f1f4ff,0x001100c2,0x001004e2),  ivec4(0x000603d9,0x000a05df,0x000d02ee,0x000a07e9),  ivec4(0x000909e8,0x000c08f1,0x000d09f2,0x000f0af5),  ivec4(0x000f0af5,0x000f09f6,0x00100af9,0x00100af9),\n  ivec4(0x00110cf7,0x00130ff1,0x00150ff6,0x00120df7),  ivec4(0x000e09f5,0x000a05f5,0x000600f2,0x000300f1),  ivec4(0x000200f0,0x000501ee,0x000501ed,0x000701ed),  ivec4(0x000c03ee,0x001308f2,0x001608f4,0x001b0bf5),\n  ivec4(0x001d0cf9,0x002014f1,0x001f15ec,0x002014e9),  ivec4(0x001f14e4,0x001b10dc,0x00170ed4,0x001207cc),  ivec4(0x000c03c6,0x000800be,0x000700bb,0x000500b9),  ivec4(0x000300b5,0x000300b6,0x000300b3,0x000300b4),\n  ivec4(0x000300b3,0x000300b4,0x000500b6,0x000701b7),  ivec4(0x000902ba,0x000a03bd,0x000d05c1,0x001008c5),  ivec4(0x00160cc9,0x00160ccf,0x00140cdc,0x00120cda),  ivec4(0x00110bd8,0x00100ad7,0x000e09d5,0x000a06d0),\n  ivec4(0x000502cb,0x000201c4,0x000201bb,0x000000b5),  ivec4(0x000000b1,0x000000ae,0x000400af,0x000701ac),  ivec4(0x000901ac,0x000902ab,0x000601ae,0x000500af),  ivec4(0x000400ad,0x000500aa,0x000700a7,0x000701a6),\n  ivec4(0x000700a4,0x000600a3,0x000600a1,0x000601a0),  ivec4(0x0007009d,0x0006019a,0x00070197,0x00060093),  ivec4(0x00060190,0x0005008d,0x0005008f,0x000e0382),  ivec4(0x009899b6,0x00f4f9ff,0x00f9f8f6,0x00fffff9),\n  ivec4(0x00fffff8,0x00fdffff,0x00fbfdff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffcfe,0x00f4faff,0x00797ac7,0x001205d5),  ivec4(0x000802de,0x000902e5,0x000c03eb,0x000a07e9),  ivec4(0x000907ec,0x000c07f2,0x000e09f4,0x000f09f6),  ivec4(0x00100af7,0x00110bf9,0x00110bfa,0x00120bfc),\n  ivec4(0x00120cfa,0x00120df6,0x001410f8,0x001511fa),  ivec4(0x001410f9,0x00130ef9,0x00100bf7,0x000d07f3),  ivec4(0x000905f0,0x000500ee,0x000802f0,0x000801f0),  ivec4(0x000700f0,0x000700ef,0x000b00f3,0x000f01f6),\n  ivec4(0x001203fa,0x000f03f6,0x000f03f6,0x001206f7),  ivec4(0x001408f8,0x001a0cfb,0x001c0ffb,0x001f10fa),  ivec4(0x002011fa,0x002315fa,0x002416f8,0x002316f7),  ivec4(0x002316f7,0x002315f4,0x002216f3,0x002115f2),\n  ivec4(0x002015f1,0x001f14ee,0x001c11eb,0x001b10ea),  ivec4(0x001b0fea,0x001b10ea,0x00180de8,0x00160be5),  ivec4(0x001308e1,0x001004e1,0x000d02e1,0x000a01dc),  ivec4(0x000601d4,0x000501ce,0x000401c6,0x000201bf),\n  ivec4(0x000001b8,0x000002b5,0x000000b2,0x000200b3),  ivec4(0x000400b3,0x000501b2,0x000a03b4,0x000b03b2),  ivec4(0x000901b1,0x000800b0,0x000400b0,0x000500af),  ivec4(0x000400ae,0x000500aa,0x000500a9,0x000700a7),\n  ivec4(0x000600a5,0x000500a4,0x000600a1,0x000600a1),  ivec4(0x0007009d,0x0006009b,0x00070098,0x00060094),  ivec4(0x00060091,0x0005008e,0x0007008b,0x00000060),  ivec4(0x00e2e8f9,0x00f7fcfd,0x00fefdfe,0x00fffefd),\n  ivec4(0x00fffff8,0x00fffffc,0x00fbfeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fff8ff,0x00fafbfb,0x00bcc6f9,0x000000cc),  ivec4(0x000700e1,0x000900eb,0x000c03eb,0x000907e9),  ivec4(0x000805f1,0x000c09f3,0x000d09f5,0x000f0bf8),  ivec4(0x00100bfa,0x00110cfb,0x00120cfd,0x00120cfd),\n  ivec4(0x00130dfe,0x00120cfe,0x00120dfc,0x00130efc),  ivec4(0x00160ffa,0x001610f9,0x001a12fa,0x001912f7),  ivec4(0x00180ef7,0x001408f8,0x000f04f5,0x000b02ef),  ivec4(0x000801ee,0x000902ed,0x000600ed,0x000400eb),\n  ivec4(0x000200e8,0x000401ed,0x000502ef,0x000605f0),  ivec4(0x000a06f1,0x000b05ef,0x000b05ef,0x000f05ef),  ivec4(0x001006ef,0x001005ec,0x001004ec,0x001005ec),  ivec4(0x001005eb,0x001106eb,0x001106ea,0x000f05e8),\n  ivec4(0x000e05e6,0x000e06e6,0x000d06e4,0x000c05e1),  ivec4(0x000b04e0,0x000904dd,0x000702db,0x000601d9),  ivec4(0x000301d7,0x000502d3,0x000e03c5,0x000c01c2),  ivec4(0x000b01c0,0x000a00bd,0x000800b8,0x000600b4),\n  ivec4(0x000500b3,0x000500b3,0x000b03b5,0x000c04b6),  ivec4(0x000b03b9,0x000a01b7,0x000a00b7,0x000a00b7),  ivec4(0x000900b8,0x000800b7,0x000400b1,0x000300b0),  ivec4(0x000400ae,0x000300ac,0x000500aa,0x000700a7),\n  ivec4(0x000600a6,0x000500a4,0x000600a3,0x000600a1),  ivec4(0x0007009f,0x0006009b,0x00070098,0x00060096),  ivec4(0x00060093,0x0005008e,0x0010068d,0x00404391),  ivec4(0x00f3fdff,0x00fcfffc,0x00fffbff,0x00fffbff),\n  ivec4(0x00fffff9,0x00fffffa,0x00fbfeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fcf7ff,0x00fcfef8,0x00eef1fd,0x003425cc),  ivec4(0x000f02dd,0x000302e9,0x000505ef,0x000a06ee),  ivec4(0x000f07f0,0x000d07f4,0x000f09f6,0x00100af8),  ivec4(0x00110bfa,0x00120bfc,0x00120cfd,0x00130dff),\n  ivec4(0x00110dff,0x00120cff,0x00130dff,0x00140eff),  ivec4(0x00140ffc,0x001610fb,0x001711fc,0x001812fb),  ivec4(0x001711fb,0x001516fb,0x001611fe,0x001b0dfc),  ivec4(0x001b0dfb,0x000d06f4,0x000706e7,0x000503e3),\n  ivec4(0x000600ee,0x000001eb,0x000004e8,0x000000ea),  ivec4(0x000000f4,0x000401e2,0x000304e0,0x000100e4),  ivec4(0x000202ea,0x000202e7,0x000300e6,0x000101e4),  ivec4(0x000000e0,0x000000e0,0x000000dc,0x000000dd),\n  ivec4(0x000000db,0x000001d0,0x000004ce,0x000200d9),  ivec4(0x000600d9,0x000403d3,0x000201d2,0x000601d4),  ivec4(0x000200c1,0x001008c1,0x000000c0,0x001205c3),  ivec4(0x000500b8,0x000604c1,0x000200c6,0x000200c9),\n  ivec4(0x000903c4,0x000c02be,0x000a02c2,0x000902c2),  ivec4(0x000a01c1,0x000900bf,0x000800bc,0x000700ba),  ivec4(0x000700b9,0x000800b9,0x000600b3,0x000500b1),  ivec4(0x000500af,0x000500ad,0x000500a9,0x000700a7),\n  ivec4(0x000601a4,0x000600a3,0x000400a4,0x0004029e),  ivec4(0x00040299,0x0003009d,0x0005019c,0x0002028b),  ivec4(0x00010185,0x000a009b,0x00030179,0x00aba5d3),  ivec4(0x00fafaff,0x00fbfdfe,0x00fdfafc,0x00fffeff),\n  ivec4(0x00fffffd,0x00fffffe,0x00fefeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fdfeff,0x00fcfff8,0x00f8f7fe,0x009e95e6),  ivec4(0x000300c8,0x000101e5,0x000306f3,0x000802ed),  ivec4(0x001006ee,0x000f07f4,0x001008f5,0x00120af7),  ivec4(0x00110bfa,0x00120bfc,0x00120cfd,0x00130dff),\n  ivec4(0x00110dff,0x00130dff,0x00130dff,0x00140eff),  ivec4(0x00140eff,0x001510fe,0x001511fd,0x001511fd),  ivec4(0x001311fc,0x000f19fa,0x001613ff,0x001e11ff),  ivec4(0x001e10ff,0x001b16fe,0x001418f5,0x001412f3),\n  ivec4(0x001405fd,0x000707f6,0x000000bc,0x004453df),  ivec4(0x003929e3,0x000000cc,0x000000b5,0x000000c5),  ivec4(0x000000db,0x000000e5,0x000000e2,0x000000e2),  ivec4(0x000000e2,0x000000e3,0x000000de,0x000000dd),\n  ivec4(0x000000dd,0x000000d4,0x000000d0,0x000000d8),  ivec4(0x000000d1,0x000000c4,0x000000b6,0x000000b7),  ivec4(0x000000a6,0x0000009e,0x002e22c7,0x000000ac),  ivec4(0x000f08ab,0x000504bf,0x000604da,0x000400dd),\n  ivec4(0x000801cf,0x000d02c1,0x000600c9,0x000600c9),  ivec4(0x000700c5,0x000600c3,0x000600bf,0x000700bd),  ivec4(0x000600ba,0x000600b8,0x000600b4,0x000600b1),  ivec4(0x000500af,0x000600ad,0x000500a9,0x000701a6),\n  ivec4(0x000601a4,0x000600a1,0x000400a4,0x0004029d),  ivec4(0x00010397,0x0002009d,0x00000098,0x0005078e),  ivec4(0x000c0b8b,0x00050095,0x00000067,0x00f6f0fa),  ivec4(0x00fbf5ff,0x00faf8ff,0x00fdfcfd,0x00fffffd),\n  ivec4(0x00fffffe,0x00fffeff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fefff8,0x00fafaf7,0x00fefcff,0x00e2e3fc),  ivec4(0x000000b1,0x000e0ae7,0x000001ea,0x000908ed),  ivec4(0x001109f3,0x000e06f3,0x000f07f4,0x001109f7),  ivec4(0x00100af9,0x00120bfc,0x00120cfd,0x00130dff),\n  ivec4(0x00110dff,0x00130dff,0x00140eff,0x00150fff),  ivec4(0x00150fff,0x001510ff,0x001511fd,0x001511fd),  ivec4(0x001411fd,0x000f17fc,0x001612ff,0x001d10ff),  ivec4(0x001a12ff,0x001413fb,0x001419fd,0x001918fe),\n  ivec4(0x002112ff,0x001200e9,0x008074e9,0x00c7cbfa),  ivec4(0x00a8a9e6,0x009f9deb,0x009c9ef2,0x009898f2),  ivec4(0x009e93f4,0x007a77ef,0x006f6ee8,0x006160dd),  ivec4(0x005352d4,0x004141cb,0x003332c2,0x00302fc0),\n  ivec4(0x003435c3,0x004240ce,0x00564be0,0x00614fe4),  ivec4(0x006c60db,0x007073ce,0x008087dc,0x008488e2),  ivec4(0x007d83cb,0x008991c0,0x009aa5d4,0x008a8eca),  ivec4(0x00000083,0x002215bb,0x000c01d8,0x000900e3),\n  ivec4(0x000a00d2,0x001105c5,0x000700cc,0x000600cb),  ivec4(0x000800c8,0x000700c4,0x000700c0,0x000700be),  ivec4(0x000700bb,0x000600b9,0x000600b4,0x000600b1),  ivec4(0x000500af,0x000600ad,0x000500a9,0x000701a6),\n  ivec4(0x000601a4,0x000600a1,0x000500a3,0x0004009e),  ivec4(0x00030199,0x00020199,0x0005029d,0x00030291),  ivec4(0x000a048d,0x00080084,0x009d97c1,0x00fcf6ff),  ivec4(0x00fdf9ff,0x00fbfbfd,0x00fffffd,0x00fffffd),\n  ivec4(0x00fffffe,0x00fffeff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffff8,0x00fefafb,0x00f8f7f7,0x00f1fbfd),  ivec4(0x009399e3,0x000000d0,0x000800ed,0x000b09f1),  ivec4(0x000d07f1,0x000e05f3,0x000f07f4,0x001008f6),  ivec4(0x000f09f8,0x00120bfc,0x00120cfd,0x00130dff),\n  ivec4(0x00110dff,0x00140eff,0x00150fff,0x00150fff),  ivec4(0x001610ff,0x001510ff,0x001511fd,0x001511fd),  ivec4(0x001411fe,0x001112ff,0x001612fd,0x001a10ff),  ivec4(0x001612fd,0x000f15f8,0x000e14ff,0x001411ff),\n  ivec4(0x001b0ff5,0x006c5cd7,0x00d4c2ff,0x00d4ccf2),  ivec4(0x00cacde3,0x00c6c9f9,0x00aeaff8,0x00bebdf5),  ivec4(0x00c4bfe6,0x00bdbceb,0x00b9bcee,0x00bbbeef),  ivec4(0x00bdbff1,0x00babcef,0x00b5b6ea,0x00b5b5eb),\n  ivec4(0x00b6b6ed,0x00b0b4e9,0x00afb0e9,0x00b1abe4),  ivec4(0x00adacce,0x00a2afc0,0x00a2afd3,0x008289ca),  ivec4(0x009da1db,0x00a0a9c0,0x00abbbb6,0x00aeb5c1),  ivec4(0x008c88b9,0x00050085,0x001a05ce,0x001300e6),\n  ivec4(0x000d00d8,0x001003ca,0x000801cd,0x000701cc),  ivec4(0x000801c9,0x000801c6,0x000800c1,0x000800be),  ivec4(0x000700bc,0x000700ba,0x000600b3,0x000600b1),  ivec4(0x000500af,0x000600ad,0x000500a9,0x000701a6),\n  ivec4(0x000601a4,0x000600a1,0x0006009f,0x000500a1),  ivec4(0x0003019c,0x00020294,0x00000195,0x0005009b),  ivec4(0x000f0290,0x00000061,0x00eaebf8,0x00faf7fd),  ivec4(0x00fdfdfe,0x00fefefd,0x00fefffb,0x00fffffc),\n  ivec4(0x00fffffe,0x00fffeff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffdfe,0x00fffafe,0x00fcfcfa,0x00f4fef9),  ivec4(0x00e3ebfd,0x000000c6,0x001504ed,0x000504ef),  ivec4(0x000b0bef,0x000d05f2,0x000f07f4,0x001008f6),  ivec4(0x000f09f8,0x00110afb,0x00120cfd,0x00140eff),\n  ivec4(0x00110dff,0x00140eff,0x00150fff,0x001610ff),  ivec4(0x001610ff,0x001611ff,0x001612fe,0x001612fe),  ivec4(0x001612ff,0x00130fff,0x001713fd,0x001810ff),  ivec4(0x001213fd,0x000e19f7,0x000a0dff,0x001911ff),\n  ivec4(0x001a18dc,0x00c4c6f1,0x00d8dbde,0x00c6ccd4),  ivec4(0x00c8cefa,0x008685e3,0x005e59d0,0x009e97f0),  ivec4(0x00cbc8e8,0x00d0d0e5,0x00cfd0eb,0x00d1d1ee),  ivec4(0x00d2d1f1,0x00d1d0f2,0x00cfcef1,0x00cfccf2),\n  ivec4(0x00cecaf3,0x00c8c9e8,0x00c5c7e0,0x00c9c6db),  ivec4(0x00c2c2c9,0x00b2bbc7,0x00a4a8e6,0x003e40a1),  ivec4(0x005e5abc,0x008884da,0x00a9afcc,0x00a9aeb9),  ivec4(0x00b7b6d4,0x004e4798,0x001201ac,0x001203db),\n  ivec4(0x000a00dc,0x000700d1,0x000902d0,0x000801cd),  ivec4(0x000901ca,0x000801c7,0x000901c3,0x000901c1),  ivec4(0x000802be,0x000700bc,0x000701b4,0x000601b1),  ivec4(0x000601af,0x000600ad,0x000400a8,0x000600a5),\n  ivec4(0x000500a3,0x000500a0,0x0006009c,0x000400a1),  ivec4(0x0003009c,0x00020491,0x000d089c,0x000a009c),  ivec4(0x00000078,0x00a4a8c9,0x00f5fdff,0x00fdfdfd),  ivec4(0x00fefefb,0x00fdfefa,0x00fffffa,0x00fffffd),\n  ivec4(0x00fffffe,0x00fffeff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fff9ff,0x00fffbff,0x00fffffb,0x00fafffd),  ivec4(0x00f4f8ff,0x00b0a9ee,0x000000d2,0x000600ec),  ivec4(0x000809ec,0x000d05f2,0x000e06f3,0x001008f6),  ivec4(0x000f09f8,0x00100afb,0x00120cfd,0x00130dff),\n  ivec4(0x00110dff,0x00140eff,0x00150fff,0x001610ff),  ivec4(0x001610ff,0x001611ff,0x001713ff,0x001814ff),  ivec4(0x001813ff,0x00150eff,0x001714fa,0x00160fff),  ivec4(0x001113fe,0x000c19f3,0x000f0fff,0x001a09fb),\n  ivec4(0x006061e6,0x00dbdafe,0x00c9d3e5,0x00b8c6f5),  ivec4(0x006f74d0,0x002822e7,0x000000e0,0x005248d4),  ivec4(0x00c0c7ed,0x00cfd4e5,0x00d1d2ea,0x00d3d2ec),  ivec4(0x00d4d3ee,0x00d3d2ef,0x00d1d0ef,0x00d1ceef),\n  ivec4(0x00cfccef,0x00cacaea,0x00c9c9e6,0x00cdc9e0),  ivec4(0x00c6c6d3,0x00b6bbde,0x009b9bf9,0x000000ad),  ivec4(0x000600bf,0x004238be,0x007771d4,0x00acabe6),  ivec4(0x00b4b7d0,0x008c8fc5,0x00010085,0x00100cca),\n  ivec4(0x000705de,0x000101d8,0x000901d2,0x000902cf),  ivec4(0x000900cc,0x000801c8,0x000a02c5,0x000a01c3),  ivec4(0x000901c0,0x000700bd,0x000801b5,0x000701b2),  ivec4(0x000601b0,0x000600ad,0x000400a8,0x000600a5),\n  ivec4(0x000500a3,0x000500a0,0x0006009b,0x0005009e),  ivec4(0x0002009c,0x00020490,0x0005038b,0x00160998),  ivec4(0x003a2b9c,0x00eceffa,0x00fbfef9,0x00fffffd),  ivec4(0x00fffffc,0x00fefffb,0x00fffffc,0x00fffffd),\n  ivec4(0x00ffffff,0x00fffeff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fff9ff,0x00fefdff,0x00fdfffc,0x00feffff),  ivec4(0x00fcfcff,0x00ede5fe,0x006d62d0,0x00140ede),  ivec4(0x000a0aef,0x000c04f1,0x000e06f3,0x000f07f5),  ivec4(0x000e08f7,0x001009fa,0x00110bfd,0x00120cff),\n  ivec4(0x00100cff,0x00140eff,0x00150fff,0x001610ff),  ivec4(0x001610ff,0x001611ff,0x001713ff,0x001814ff),  ivec4(0x001813ff,0x00160fff,0x001815f8,0x001610ff),  ivec4(0x001212ff,0x000d19ef,0x001810ff,0x001600ee),\n  ivec4(0x00afb4fb,0x00d5ceff,0x00c4c1fa,0x00666cd6),  ivec4(0x000000dc,0x000006e1,0x000608df,0x000000c3),  ivec4(0x00ccd6fb,0x00d0d8e9,0x00d5d8ee,0x00d7d9ef),  ivec4(0x00d7daf0,0x00d6d9ef,0x00d6d8ef,0x00d4d6ee),\n  ivec4(0x00d3d5ec,0x00ced0f1,0x00cdcbf5,0x00d1ccea),  ivec4(0x00cbcadf,0x00bbc1f0,0x00797bee,0x00130dc9),  ivec4(0x000302c6,0x000000be,0x002c1dc1,0x007775c9),  ivec4(0x00afb7ce,0x00acb5d6,0x001e2379,0x000f0fbc),\n  ivec4(0x000608d9,0x000204da,0x000a02d3,0x000a02d1),  ivec4(0x000a01cd,0x000902c9,0x000a01c6,0x000a00c3),  ivec4(0x000901bf,0x000700bd,0x000801b5,0x000701b2),  ivec4(0x000601b0,0x000600ad,0x000400a8,0x000600a5),\n  ivec4(0x000500a3,0x000500a0,0x0007009c,0x0006009a),  ivec4(0x00030199,0x00020193,0x0008068a,0x0000005f),  ivec4(0x00c4c1e6,0x00f9faff,0x00fefff7,0x00fffffe),  ivec4(0x00fffffe,0x00fffffe,0x00fffffe,0x00fffefe),\n  ivec4(0x00fffeff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fefdff,0x00faffff,0x00fafffe,0x00fefffa),  ivec4(0x00fffff9,0x00fdfafd,0x00c7c9f3,0x000000c4),  ivec4(0x000504ef,0x000c04f1,0x000e05f4,0x000f06f4),  ivec4(0x000e08f6,0x000f08fa,0x00110bfd,0x00120cff),\n  ivec4(0x00100bfe,0x00140eff,0x00150fff,0x001610ff),  ivec4(0x001610ff,0x001611ff,0x001713ff,0x001814ff),  ivec4(0x001813ff,0x001811ff,0x001918f7,0x001710ff),  ivec4(0x001311ff,0x00101cef,0x001c0cff,0x003315ec),\n  ivec4(0x00dae3fc,0x00e1dff3,0x00d8d9fe,0x000000c7),  ivec4(0x000f08f9,0x00000ddb,0x000006e1,0x001905e9),  ivec4(0x00bfbdfe,0x00d9ddf6,0x00dedff3,0x00dfe0f4),  ivec4(0x00dde1f1,0x00dce0f0,0x00dcdfef,0x00dadded),\n  ivec4(0x00d9dde9,0x00d6daf1,0x00d4d2f7,0x00d7d1ee),  ivec4(0x00d2d0e8,0x00c2c6fd,0x003739c1,0x000f0bd8),  ivec4(0x000307d9,0x000710cd,0x000300b9,0x006266c1),  ivec4(0x00aab4c2,0x00bcc3d9,0x004e4ba1,0x00150db5),\n  ivec4(0x000d08d3,0x000806d5,0x000b03d4,0x000a03d1),  ivec4(0x000b01ce,0x000a02cb,0x000a00c7,0x000a00c3),  ivec4(0x000900c0,0x000700bd,0x000800b8,0x000701b2),  ivec4(0x000601b0,0x000600ad,0x000400a8,0x000600a5),\n  ivec4(0x000500a3,0x000500a0,0x0008009c,0x00080196),  ivec4(0x00030295,0x00000098,0x00000086,0x007376a7),  ivec4(0x00f0f5ff,0x00fdfdfc,0x00fffdfa,0x00fffeff),  ivec4(0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff),\n  ivec4(0x00fffeff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fefffe,0x00fafeff,0x00faffff,0x00fefff7),  ivec4(0x00fffff7,0x00fffdf9,0x00f1f5ff,0x00989ade),  ivec4(0x000000d7,0x000801f2,0x000806ec,0x000a07f2),  ivec4(0x000a04f7,0x001107f7,0x00130afa,0x00110aff),\n  ivec4(0x000e0cfe,0x00130dff,0x00150fff,0x00150fff),  ivec4(0x001610ff,0x001611ff,0x001713ff,0x001814ff),  ivec4(0x001813ff,0x001912ff,0x001919f6,0x001812ff),  ivec4(0x001412ff,0x00151af5,0x001f0eff,0x00523fe5),\n  ivec4(0x00e9f4fa,0x00e5e8e8,0x00e2ebe9,0x009594eb),  ivec4(0x000401e8,0x00000be8,0x00010bef,0x001c07fa),  ivec4(0x00796ee3,0x00e8e2fe,0x00e1e3f1,0x00e2e9f3),  ivec4(0x00e6e2f9,0x00e9e1f6,0x00e7e9ed,0x00e2eaeb),\n  ivec4(0x00e5e4f0,0x00dbd6ef,0x00dfdef5,0x00e1dded),  ivec4(0x00d5d6ea,0x00c2c6fd,0x000000ad,0x000707da),  ivec4(0x00070bdc,0x000e0dcf,0x000000a5,0x00a0a9e3),  ivec4(0x00a7aeba,0x00c0c2d6,0x007671c3,0x001609b0),\n  ivec4(0x00130cd3,0x000b07d5,0x000c03d5,0x000a02d3),  ivec4(0x000b01cf,0x000a01cc,0x000a00c7,0x000900c3),  ivec4(0x000900c0,0x000700bd,0x000603b3,0x000702b0),  ivec4(0x000800b1,0x000800ae,0x000600a9,0x000800a5),\n  ivec4(0x000700a3,0x000600a1,0x0005009c,0x0007009b),  ivec4(0x00010195,0x000f0799,0x00000079,0x00cfd9f1),  ivec4(0x00f7fefa,0x00fffdfb,0x00fffbfe,0x00fffeff),  ivec4(0x00fffeff,0x00fffeff,0x00fffeff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffefe,0x00fefeff,0x00fdffff,0x00fffffb),  ivec4(0x00fffffd,0x00fffcfc,0x00faf7ff,0x00ede6fb),  ivec4(0x005a4cca,0x001100ec,0x000c0fec,0x000307ed),  ivec4(0x000c08fd,0x001406f6,0x001709f6,0x00110afe),\n  ivec4(0x000b0bff,0x00120cff,0x00140eff,0x00150fff),  ivec4(0x001610ff,0x001611ff,0x001713ff,0x001814ff),  ivec4(0x001813ff,0x001a10ff,0x001a18f8,0x001816fc),  ivec4(0x001513ff,0x001717fd,0x002013fc,0x005f56db),\n  ivec4(0x00eaf5fc,0x00e6ecf4,0x00e9f0e6,0x00dcdbfe),  ivec4(0x000900d5,0x000408ee,0x000009e8,0x000f11f8),  ivec4(0x001202cb,0x00ebdeff,0x00e9f3f2,0x00ddf1e9),  ivec4(0x00eee7fa,0x00f8e4fc,0x00eaedf9,0x00d0e0ef),\n  ivec4(0x00ece7f9,0x00f4e9fa,0x00e3e2f2,0x00e2e2e9),  ivec4(0x00d9ddf5,0x009ea1f7,0x000507ca,0x000209d4),  ivec4(0x000b0bd0,0x001203c7,0x006364ca,0x00b5bfda),  ivec4(0x00b2aec2,0x00c2bfd6,0x008787c9,0x000b02aa),\n  ivec4(0x00130dd9,0x000805da,0x000b04d7,0x000902d5),  ivec4(0x000902d0,0x000901cb,0x000900c6,0x000a00c2),  ivec4(0x000a00bf,0x000900ba,0x000406ac,0x000503ae),  ivec4(0x000900b0,0x000b00b0,0x000c00a9,0x000c00a4),\n  ivec4(0x000900a0,0x000600a1,0x000302a2,0x000703a4),  ivec4(0x000a019d,0x00000068,0x00acadd3,0x00f4fefb),  ivec4(0x00fafff0,0x00fdf8fe,0x00fffaff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffeff,0x00fffeff,0x00ffffff,0x00fffffd),  ivec4(0x00fffffe,0x00fefdff,0x00fcf7ff,0x00fffaff),  ivec4(0x00c9c3ee,0x000000cb,0x00120dec,0x000708f6),  ivec4(0x000605f0,0x001105f5,0x00160af1,0x00120cf6),\n  ivec4(0x000d09ff,0x00110bfe,0x00130dff,0x00140eff),  ivec4(0x001610ff,0x001611ff,0x001713ff,0x001814ff),  ivec4(0x001814ff,0x001a11ff,0x001c19f7,0x001a17fb),  ivec4(0x001713ff,0x001817ff,0x002316fa,0x00655fd9),\n  ivec4(0x00ecf7fc,0x00f0f4ff,0x00f8fbf5,0x00edebfe),  ivec4(0x008278ef,0x000a05ed,0x000310f0,0x000614e8),  ivec4(0x000000d4,0x00d7d0fe,0x00e8f1f9,0x00e5f5f2),  ivec4(0x00f4f1f7,0x00fbedff,0x00abade9,0x007b88cf),\n  ivec4(0x00dbd9ff,0x00f1edfb,0x00e7eaed,0x00e8ebec),  ivec4(0x00dcddfe,0x004f50d8,0x00070bd7,0x00000ad6),  ivec4(0x000d0ad2,0x000400c0,0x00b7b7f9,0x00bdc2ce),  ivec4(0x00c0b6cc,0x00c4c1d1,0x008a8ec7,0x000c01b4),\n  ivec4(0x00120bdd,0x000606da,0x000b04d8,0x000a04d5),  ivec4(0x000a02d0,0x000901cc,0x000900c6,0x000b00c1),  ivec4(0x000a00be,0x000a00b9,0x000403af,0x000401af),  ivec4(0x000800ae,0x000a00ab,0x000c00a3,0x000b019e),\n  ivec4(0x0008029a,0x0003029a,0x000503a3,0x000803a2),  ivec4(0x0000008c,0x007d7cb5,0x00e9edff,0x00f8fef5),  ivec4(0x00fefff4,0x00fef7ff,0x00fffbff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffeff,0x00fffeff,0x00ffffff,0x00fffffc),  ivec4(0x00fffffc,0x00fefffd,0x00fefcff,0x00fffbff),  ivec4(0x00f7f8ff,0x00abaee0,0x000000cb,0x000b04f9),  ivec4(0x000302ee,0x000907f0,0x000f09ef,0x00110af4),\n  ivec4(0x000f07fe,0x00110bfe,0x00120cff,0x00140eff),  ivec4(0x00140eff,0x001611ff,0x001713ff,0x001814ff),  ivec4(0x001814ff,0x001a15ff,0x001c1bf7,0x001c17fe),  ivec4(0x001a13ff,0x001c18ff,0x00281afa,0x00645cd5),\n  ivec4(0x00eff9fd,0x00f4f4fd,0x00fffef9,0x00f4f2fd),  ivec4(0x00d5dcff,0x000000de,0x000f15ff,0x000414df),  ivec4(0x00120def,0x009797ee,0x00e8f1fe,0x00f0f3ff),  ivec4(0x00faf2fc,0x00c9c3f9,0x002f2bda,0x000000da),\n  ivec4(0x008889e3,0x00e2e4fe,0x00edf4f3,0x00e7edef),  ivec4(0x00dad7ff,0x000000b8,0x000103d1,0x000007de),  ivec4(0x000a05d3,0x005c54e3,0x00c8c9ef,0x00cccbd7),  ivec4(0x00ccc1d3,0x00c9cbcb,0x008288c3,0x001403c6),\n  ivec4(0x000f09df,0x00060bd6,0x000c06d7,0x000a04d4),  ivec4(0x000a03d0,0x000b03cc,0x000900c5,0x000b00c1),  ivec4(0x000a00bd,0x000a00ba,0x000400b4,0x000600b2),  ivec4(0x000700ab,0x000700a4,0x0007019d,0x0007039a),\n  ivec4(0x00040398,0x00000495,0x0005009b,0x0009048e),  ivec4(0x00444397,0x00d7dbf8,0x00f3faff,0x00f9fefc),  ivec4(0x00fdfcfa,0x00fffdff,0x00fdfbfc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffeff,0x00fffeff,0x00ffffff,0x00fffffc),  ivec4(0x00fefefa,0x00fffffc,0x00fefffd,0x00fefdff),  ivec4(0x00fdfffb,0x00f2f7fe,0x008582db,0x000000e1),  ivec4(0x000100f2,0x000407ee,0x000905f3,0x001306fd),\n  ivec4(0x001107f6,0x00110bfe,0x00120cff,0x00130dfe),  ivec4(0x00140eff,0x001611ff,0x001713ff,0x001814ff),  ivec4(0x001814ff,0x001a18fe,0x001c1bf7,0x001f15ff),  ivec4(0x001c13ff,0x001d16ff,0x00281cf9,0x00574fcf),\n  ivec4(0x00ecf5ff,0x00f7f7fd,0x00fcf8f8,0x00fdf9ff),  ivec4(0x00ebfaf5,0x006f72ea,0x001009f5,0x000e16ef),  ivec4(0x00110ffe,0x002f32c9,0x00e5f6ff,0x00f1f5fd),  ivec4(0x00dfd0ff,0x005e59d9,0x000000e5,0x00030efb),\n  ivec4(0x000000d8,0x00a9a7e7,0x00ebefff,0x00dde8f7),  ivec4(0x00c2c2f9,0x000b05c3,0x000808e3,0x000307e1),  ivec4(0x000000ba,0x00b2b7ff,0x00cccfda,0x00d1cbd6),  ivec4(0x00cfc2d3,0x00cfd6cf,0x007278bc,0x001703d6),\n  ivec4(0x000d08e1,0x00070dd3,0x000d08d8,0x000b04d4),  ivec4(0x000a04d0,0x000b03ca,0x000900c4,0x000b00bf),  ivec4(0x000901bc,0x000a00ba,0x000600b6,0x000700b0),  ivec4(0x000701a7,0x000501a1,0x000602a0,0x000603a2),\n  ivec4(0x0000019a,0x0003049d,0x000d0395,0x00000076),  ivec4(0x00bdc1e0,0x00f4feff,0x00f8fffe,0x00fdfdff),  ivec4(0x00fdfafd,0x00fefdfd,0x00fdfcfb,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffeff,0x00fffeff,0x00ffffff,0x00fffffd),  ivec4(0x00fefefa,0x00fffffc,0x00fefffc,0x00fefffd),  ivec4(0x00fffffa,0x00fdfffc,0x00dedcff,0x004940d9),  ivec4(0x001001ec,0x000903f8,0x000802f9,0x001002fa),\n  ivec4(0x001508f6,0x00100afd,0x00120cff,0x00140eff),  ivec4(0x00150fff,0x001611ff,0x001713ff,0x001814ff),  ivec4(0x001916ff,0x001818fc,0x001c1bf7,0x002014ff),  ivec4(0x001d14ff,0x001d18fe,0x00261cfa,0x00392fd1),\n  ivec4(0x00e6eeff,0x00fafcff,0x00fdf8fb,0x00fff9ff),  ivec4(0x00edf9ee,0x00c9d8ff,0x000000db,0x000f0df8),  ivec4(0x00070bf9,0x000000c9,0x00cfe7fc,0x00e0ecfd),  ivec4(0x008576df,0x000000dc,0x000014e2,0x000212f7),\n  ivec4(0x001114f3,0x001300cb,0x00b4b3ee,0x00e3f0ff),  ivec4(0x007f82dc,0x001810da,0x000e0df5,0x000405db),  ivec4(0x005f67cf,0x00d7e6f2,0x00dee3da,0x00d5cdd8),  ivec4(0x00d1c6da,0x00d3dde0,0x00565aae,0x001705e1),\n  ivec4(0x000e0be2,0x000a0ed5,0x000d08d8,0x000b06d4),  ivec4(0x000a04cf,0x000b03c9,0x000a02c4,0x000b00be),  ivec4(0x000901ba,0x000a00b8,0x000900b5,0x000601ab),  ivec4(0x000603a3,0x000502a1,0x000400a6,0x000200a8),\n  ivec4(0x000b03a9,0x0006039c,0x00000070,0x00a39dcb),  ivec4(0x00f3fbff,0x00f6fffa,0x00fcfffb,0x00fffcff),  ivec4(0x00fffbff,0x00fefdfc,0x00fffffd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffeff,0x00fffeff,0x00ffffff,0x00ffffff),  ivec4(0x00fffffe,0x00fffffd,0x00fffffd,0x00fffffd),  ivec4(0x00fffefe,0x00fcfafe,0x00faf9ff,0x00c5c3f4),  ivec4(0x000000d7,0x000c00f6,0x000a05f7,0x000d06f1),\n  ivec4(0x001405fa,0x000f09fc,0x00110bfe,0x00130dfe),  ivec4(0x00150fff,0x00140fff,0x001612fd,0x001814ff),  ivec4(0x001915ff,0x001817fd,0x001b1af7,0x002015ff),  ivec4(0x001c16ff,0x001b1bfc,0x00221bfe,0x001c06e2),\n  ivec4(0x00bfc7ff,0x00f2f6fe,0x00fdf9ff,0x00fff9ff),  ivec4(0x00fcfffa,0x00effff8,0x007672e7,0x000e01ef),  ivec4(0x00020bf2,0x000408ee,0x0099a8fc,0x0099a5e7),  ivec4(0x000000d7,0x000e0ff8,0x000001e7,0x000000ef),\n  ivec4(0x000b10f3,0x000307e6,0x003735d1,0x00b8c3ff),  ivec4(0x000005bc,0x00120de2,0x000807ec,0x000000c0),  ivec4(0x00bdc7fa,0x00d9e8d7,0x00e0e7dc,0x00d8d0df),  ivec4(0x00d8d0ec,0x00ced6f2,0x002a2ba1,0x001709e8),\n  ivec4(0x000e0ede,0x000c0bdb,0x000e08d7,0x000b06d4),  ivec4(0x000a04ce,0x000a03c9,0x000a02c3,0x000b01be),  ivec4(0x000901ba,0x000900b7,0x000a00b1,0x000703a7),  ivec4(0x0005059f,0x000302a2,0x000300aa,0x000700ad),\n  ivec4(0x001205a8,0x00000085,0x008884bd,0x00f1edff),  ivec4(0x00f8feff,0x00fbfff4,0x00fffffa,0x00fffcff),  ivec4(0x00fffbff,0x00fffffe,0x00fffffd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffeff,0x00fffeff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fefcff,0x00fbf7ff,0x00fdfaf8,0x00fffffe),  ivec4(0x00a6a5de,0x000000d8,0x000d08ef,0x000c07ee),\n  ivec4(0x000a00f4,0x000d07fa,0x000f09fc,0x00120cfc),  ivec4(0x00130dfe,0x00140ffe,0x001612fd,0x001713ff),  ivec4(0x001814ff,0x001915ff,0x001c1af8,0x001f16ff),  ivec4(0x001b18ff,0x00171df8,0x001815ff,0x00251bf8),\n  ivec4(0x006a6fe7,0x00f1f6fe,0x00fbf8ff,0x00fefbff),  ivec4(0x00ffffff,0x00f7fff4,0x00ced4ff,0x000100d4),  ivec4(0x00000aef,0x000406fd,0x002f2af8,0x000000de),  ivec4(0x001312fa,0x00010af2,0x001000e9,0x006d61f3),\n  ivec4(0x000000d9,0x000b13f5,0x000000db,0x002e35ed),  ivec4(0x000000c7,0x000808e6,0x000000dc,0x005964cd),  ivec4(0x00e7edfc,0x00eae9db,0x00dae1e3,0x00d5d1e4),  ivec4(0x00dfdbfa,0x00a8ade5,0x000d03ad,0x00160beb),\n  ivec4(0x000c0ed5,0x000d05e2,0x000e08d9,0x000b06d3),  ivec4(0x000a04ce,0x000a04c9,0x000801c1,0x000b01bd),  ivec4(0x000701b9,0x000900b5,0x000800af,0x000602a6),  ivec4(0x0005059e,0x000400a1,0x000400a7,0x000b00a4),\n  ivec4(0x00000084,0x00595aa8,0x00e5e4ff,0x00f8f8fe),  ivec4(0x00fcfefe,0x00fefff9,0x00fffefb,0x00fffdff),  ivec4(0x00fffdff,0x00ffffff,0x00fffffe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00fffeff,0x00fffeff),  ivec4(0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff),  ivec4(0x00fcfcff,0x00fbfafe,0x00fffdf5,0x00fdfbf5),  ivec4(0x00f5f8ff,0x008b94e0,0x000000db,0x001005f0),\n  ivec4(0x000b03ed,0x000b05f6,0x000f08fb,0x00100afc),  ivec4(0x00110bfc,0x00140efe,0x001511fd,0x001713fe),  ivec4(0x001712ff,0x001a15ff,0x001d19fa,0x001f17ff),  ivec4(0x001b1afe,0x001821f8,0x001113fd,0x002019ff),\n  ivec4(0x002c30d8,0x00e4e7ff,0x00fbfbff,0x00fdfdfb),  ivec4(0x00fffeff,0x00fffbff,0x00f1ffff,0x006a73db),  ivec4(0x00040bf3,0x000311f3,0x000000f0,0x000606ff),  ivec4(0x00000af5,0x000000db,0x00a3aaec,0x00cacafe),\n  ivec4(0x006770da,0x000000df,0x000a10ef,0x000000de),  ivec4(0x000609e2,0x000d11ee,0x000000c4,0x00b5c5fa),  ivec4(0x00e5e5ee,0x00f3e5ec,0x00d6dae5,0x00d9daeb),  ivec4(0x00e1e1ff,0x005b60ac,0x00180ccb,0x001209e7),\n  ivec4(0x000c0ecf,0x001004e7,0x000e09d8,0x000b07d3),  ivec4(0x000a05cf,0x000a03ca,0x000801c1,0x000a00bc),  ivec4(0x000800b7,0x000700b3,0x000600af,0x000501a6),  ivec4(0x0004049e,0x000300a0,0x000600a2,0x00000090),\n  ivec4(0x003e398e,0x00c4c9e8,0x00fcfffc,0x00fcfdfa),  ivec4(0x00fffdfc,0x00fdfafa,0x00fefdfd,0x00fffeff),  ivec4(0x00ffffff,0x00fffeff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffffe,0x00ffffff,0x00fffeff,0x00fffeff),  ivec4(0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff),  ivec4(0x00fdfdfe,0x00fbfdfc,0x00fffffb,0x00fffdf6),  ivec4(0x00f8fdfe,0x00e5efff,0x009492dc,0x000000d6),\n  ivec4(0x001a08ee,0x000d07f1,0x000d04f7,0x001008fd),  ivec4(0x00130bfd,0x00140bff,0x001511fb,0x001614fb),  ivec4(0x001711ff,0x001915ff,0x001b18fc,0x001e18ff),  ivec4(0x001c1afd,0x001c20fe,0x00191afb,0x001816fa),\n  ivec4(0x002323f7,0x009b99f2,0x00eef5ff,0x00fafff2),  ivec4(0x00fcf3fa,0x00fff2ff,0x00f8fffb,0x00becbff),  ivec4(0x00130deb,0x000218ec,0x000a19f7,0x000308f7),  ivec4(0x000000e2,0x009192dc,0x00ecfbfd,0x00eefaf1),\n  ivec4(0x00d3d6fd,0x006b60d9,0x000000e5,0x000204f0),  ivec4(0x000410f5,0x000712e9,0x00606ac9,0x00e9f7fc),  ivec4(0x00e2e2e8,0x00e6dbea,0x00eae7ea,0x00e2e7f1),  ivec4(0x00b1b2eb,0x000700b3,0x00180be9,0x000d09e1),\n  ivec4(0x00100fcf,0x001408e2,0x000d0bd3,0x000b06d3),  ivec4(0x000a02d1,0x000b01cc,0x000a00c2,0x000c00bc),  ivec4(0x000a00b5,0x000800b3,0x000c04b1,0x000803a9),  ivec4(0x0002039d,0x000706a3,0x0000009c,0x00261a9b),\n  ivec4(0x00adacd8,0x00fcfffe,0x00fcfff8,0x00fffffb),  ivec4(0x00fffcfc,0x00fbf7f9,0x00fffeff,0x00fffffe),  ivec4(0x00ffffff,0x00fffeff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fefffe,0x00fefffe,0x00fffdff,0x00ffffff),  ivec4(0x00fdfffa,0x00f7fdff,0x00eff0ff,0x008983c6),\n  ivec4(0x000000dc,0x001309f4,0x000803e8,0x00110af8),  ivec4(0x001108fe,0x00120bfe,0x00140ffc,0x001612fc),  ivec4(0x001613fc,0x001915fd,0x001a16fe,0x001b19ff),  ivec4(0x001d1afe,0x001e1cfe,0x001f1dfc,0x001f1efb),\n  ivec4(0x001e1dfa,0x000000e7,0x00b6c0ee,0x00effbf7),  ivec4(0x00faeaf5,0x00fff5ff,0x00fffff3,0x00e9f7ff),  ivec4(0x007d7ae3,0x00080ff3,0x000d17f6,0x000000d2),  ivec4(0x008d8fe4,0x00f0f3ff,0x00f0fbf3,0x00f5f8f0),\n  ivec4(0x00fffcff,0x00c9c6f7,0x00616dd8,0x000000e7),  ivec4(0x000916f3,0x000715d3,0x00c6c6f7,0x00f1f0f3),  ivec4(0x00e9e6ed,0x00e1e4e6,0x00f4eff3,0x00d3d6fd),  ivec4(0x003532b8,0x001c0de6,0x000d05f0,0x000d0bdf),\n  ivec4(0x00130ed8,0x00160adc,0x000b0bd1,0x000a06d2),  ivec4(0x000900d2,0x000900cb,0x000b01c0,0x000b02b6),  ivec4(0x000901b1,0x000900af,0x000e08aa,0x000804af),  ivec4(0x000100a7,0x000100a6,0x00010a8e,0x00a2aad0),\n  ivec4(0x00f2f5ff,0x00fffefb,0x00fffffd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00feffff,0x00fcfdff,0x00fefcff,0x00fffefe),  ivec4(0x00fefff6,0x00f6fff6,0x00edf4fe,0x00eeecff),\n  ivec4(0x007b79d0,0x000000e4,0x00110ae3,0x000c09ef),  ivec4(0x000606f8,0x00090cfb,0x000e0cff,0x00150dff),  ivec4(0x001814f9,0x001813fc,0x001914ff,0x001b17fe),  ivec4(0x001c18ff,0x001e1cfe,0x001e1dfd,0x001e1dfc),\n  ivec4(0x001e1efb,0x002d1aff,0x00352fce,0x00bdc8f2),  ivec4(0x00f9feff,0x00fcfdff,0x00fcfef5,0x00f3fcfe),  ivec4(0x00dbdcff,0x002008dc,0x000000d5,0x008389d1),  ivec4(0x00ebf7fe,0x00f7fff5,0x00fffff9,0x00fef7ff),\n  ivec4(0x00fdf7ff,0x00ecf8fb,0x00bcd2ef,0x00595ad7),  ivec4(0x000000d4,0x00746fd8,0x00f6eefa,0x00f8f0f2),  ivec4(0x00f5efef,0x00ebebef,0x00cacdf9,0x00877bee),  ivec4(0x001100cc,0x000e0dd4,0x000d10dd,0x000c0ae4),\n  ivec4(0x001006e5,0x001308dd,0x000d06d8,0x000a03d3),  ivec4(0x000800cc,0x000802c3,0x000703ba,0x000604b1),  ivec4(0x000603ad,0x000601aa,0x0001019e,0x000100aa),  ivec4(0x000000af,0x001d00a1,0x00a1a3c1,0x00f5fffc),\n  ivec4(0x00fbfff7,0x00fdf9ff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdfeff,0x00fbfcff,0x00fdfbff,0x00fffdff),  ivec4(0x00fffff7,0x00f8ffea,0x00fafff9,0x00f4fbfc),\n  ivec4(0x00dce1ff,0x00797dd6,0x000000e1,0x000b00f1),  ivec4(0x00060bf2,0x00020af8,0x00080afe,0x00140dff),  ivec4(0x00190eff,0x001712fe,0x001813ff,0x001a15ff),  ivec4(0x001b17ff,0x001e1cff,0x001e1cfe,0x001e1dfd),\n  ivec4(0x001e1dfd,0x002218ff,0x001900ee,0x003731db),  ivec4(0x00c7d6ef,0x00f0feff,0x00f7fcff,0x00f4f4ff),  ivec4(0x00fffffa,0x009694d3,0x00797ece,0x00e5f2ff),  ivec4(0x00edfef6,0x00fafef9,0x00fefefd,0x00fafafa),\n  ivec4(0x00f5f5fc,0x00f7fffe,0x00e2f4f5,0x00c6c7f7),  ivec4(0x007168c5,0x00d6cbff,0x00f0eaef,0x00f6f7e9),  ivec4(0x00f4f6f5,0x00e2dfff,0x009093ed,0x000000ce),  ivec4(0x001909f3,0x000e13dc,0x000a15d6,0x000c08eb),\n  ivec4(0x000e01ec,0x001108da,0x000f03db,0x000c02d2),  ivec4(0x000703c7,0x000603be,0x000402b9,0x000502b4),  ivec4(0x000401b1,0x000300ac,0x000502a8,0x0000009b),  ivec4(0x002f25a2,0x00a49dd0,0x00ffffff,0x00fcffec),\n  ivec4(0x00fefff4,0x00fcfbfe,0x00fffdff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdffff,0x00fbfeff,0x00fdfdff,0x00fffdff),  ivec4(0x00fefffc,0x00fffff5,0x00fefff3,0x00f8fcf7),\n  ivec4(0x00f0f8ff,0x00d9e5ff,0x007e81d6,0x000000eb),  ivec4(0x000602f1,0x00070df3,0x000608f5,0x00140cff),  ivec4(0x001a0efd,0x001710fe,0x001912ff,0x001914ff),  ivec4(0x001b16ff,0x001d1aff,0x001d1aff,0x001e1bfe),\n  ivec4(0x001e1cfe,0x002424ff,0x002019ff,0x002717ff),  ivec4(0x000000d0,0x00c4d1f2,0x00dce8ff,0x00f9fdff),  ivec4(0x00f9f5f5,0x00f3f6ff,0x00e9f2ff,0x00ebf3fb),  ivec4(0x00faffff,0x00fdfffd,0x00fcfef8,0x00f4fbf1),\n  ivec4(0x00f7fff8,0x00fcfdff,0x00fbfbf8,0x00fcfffe),  ivec4(0x00dfd9fe,0x00fff9fa,0x00fefaff,0x00e1e5ee),  ivec4(0x00cdd9f2,0x008486f8,0x000000c3,0x00160af1),  ivec4(0x00160dfb,0x000d12e6,0x000b11e2,0x000c07ee),\n  ivec4(0x000d03e9,0x001008d8,0x001103d9,0x000e04cd),  ivec4(0x000705c2,0x000504bd,0x000300be,0x000500bd),  ivec4(0x000100b5,0x000f06b6,0x000000a5,0x003b3a9c),  ivec4(0x00a3a5cc,0x00ffffff,0x00fffffc,0x00fffefc),\n  ivec4(0x00fffdff,0x00fdffff,0x00fefefe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00feffff,0x00fbfffd,0x00fdfeff,0x00fffdff),  ivec4(0x00fffdff,0x00fffeff,0x00fffefd,0x00fffffd),\n  ivec4(0x00fdfffe,0x00e0ecf5,0x00effaff,0x00787bd4),  ivec4(0x000000e9,0x000e08f3,0x000501e6,0x001711fc),  ivec4(0x001a11f9,0x00140dff,0x00160fff,0x001812ff),  ivec4(0x001a15ff,0x001a15ff,0x001a17ff,0x001d19ff),\n  ivec4(0x001e1bff,0x001e1aff,0x001e20fc,0x001e21f6),  ivec4(0x002316ff,0x000000d4,0x009494fb,0x00d1d4f4),  ivec4(0x00e3dfff,0x00fcfefa,0x00fffef7,0x00fff8fe),  ivec4(0x00fffff9,0x00fffff7,0x00fffdfe,0x00fff9ff),\n  ivec4(0x00fffdfe,0x00fffcfd,0x00fefcfd,0x00fffffb),  ivec4(0x00fcfefd,0x00e7f4ee,0x00d2ddf6,0x00c8cefc),  ivec4(0x000000c6,0x000000ee,0x00150bf8,0x00100df0),  ivec4(0x000d0de9,0x000c0aee,0x000d08f1,0x000f08eb),\n  ivec4(0x000e08dd,0x000f09d7,0x001205d4,0x000d04c7),  ivec4(0x000605bc,0x000403be,0x000903c4,0x000100b8),  ivec4(0x000f06b3,0x000000b1,0x004441a3,0x00aaaadc),  ivec4(0x00fcffff,0x00fcfcec,0x00fffff5,0x00fffaff),\n  ivec4(0x00fff9ff,0x00fdfdff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fefffd,0x00fefffc,0x00fdfffe,0x00fffeff),  ivec4(0x00fffcff,0x00fffbff,0x00fffcff,0x00fffdff),\n  ivec4(0x00fffeff,0x00fafdff,0x00f4fff3,0x00eef8ff),  ivec4(0x00807cda,0x002800eb,0x000000e0,0x001513ec),  ivec4(0x000b02fb,0x00130bff,0x00140cff,0x00170fff),  ivec4(0x001812ff,0x001812ff,0x001914ff,0x001b17ff),\n  ivec4(0x001b18ff,0x001d1afd,0x001e20fb,0x001d23f2),  ivec4(0x001f19ff,0x002412ff,0x000000f2,0x000c00d2),  ivec4(0x007c80f4,0x00e2d3f7,0x00ebddf9,0x00eae0f7),  ivec4(0x00f7f6f8,0x00fcfcfb,0x00fdfefd,0x00fefff9),\n  ivec4(0x00fdfff8,0x00f7fafe,0x00e2e5ff,0x00dcdffb),  ivec4(0x00d7e0fa,0x00b9c4fd,0x002d2add,0x000000ec),  ivec4(0x000901ee,0x001b1af9,0x00100afc,0x001011eb),  ivec4(0x00110ee8,0x001007f5,0x001005f0,0x00100bde),\n  ivec4(0x000d0ad5,0x000e05d8,0x001003d0,0x000c04c2),  ivec4(0x000705b9,0x000402bc,0x001008c2,0x000602a1),  ivec4(0x000000a6,0x005755a1,0x00b7b4df,0x00fafaff),  ivec4(0x00fbfdfd,0x00f4f3e7,0x00fffff9,0x00fffdff),\n  ivec4(0x00fffcff,0x00fdfcff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00fffffe,0x00fffffc,0x00fdfffe),  ivec4(0x00fcfeff,0x00fcfcff,0x00fdfcff,0x00fffeff),\n  ivec4(0x00fffffe,0x00fffdff,0x00fefef7,0x00fcfff4),  ivec4(0x00f4f7ff,0x008b82ea,0x003e31d8,0x000000da),  ivec4(0x000e0bf5,0x001109fe,0x00110afe,0x00150dff),  ivec4(0x001610ff,0x001610fd,0x001712fd,0x001914fe),\n  ivec4(0x001a17fd,0x001b1df5,0x001b18ff,0x001c13ff),  ivec4(0x001d16ff,0x001816fa,0x002824fe,0x00201ffc),  ivec4(0x000000e8,0x000000dc,0x00311cdf,0x007879f2),  ivec4(0x00b4b7fe,0x00cdd1fc,0x00d5ddfd,0x00d7e6fd),\n  ivec4(0x00d2e2fe,0x00bed3fe,0x008c9efe,0x00453de9),  ivec4(0x000000e7,0x000000ef,0x000d0afd,0x000f13f4),  ivec4(0x00140cf8,0x001e1af4,0x000f10ec,0x00100cec),  ivec4(0x001308f1,0x001505f2,0x001309e2,0x00120fd2),\n  ivec4(0x000c09d2,0x000c01dc,0x000e00d0,0x000901c2),  ivec4(0x000505b7,0x000603b7,0x000000b1,0x000000a2),  ivec4(0x00656592,0x00cecefb,0x00ffffff,0x00fffefe),  ivec4(0x00f8f5f7,0x00fffdff,0x00fffdff,0x00fffcff),\n  ivec4(0x00fdffff,0x00fbfffa,0x00fffffd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00fffeff,0x00fffffd,0x00fdfffc),  ivec4(0x00fbffff,0x00fbfeff,0x00fdfeff,0x00fdffff),\n  ivec4(0x00fffffc,0x00fdfcfd,0x00fffbff,0x00fffffc),  ivec4(0x00f6fdf2,0x00f1f7ff,0x00aea5ff,0x005453db),  ivec4(0x000000d8,0x000600f8,0x00120afe,0x00110afd),  ivec4(0x00120cff,0x00130dff,0x00140ffe,0x001713fd),\n  ivec4(0x001916fc,0x001813fe,0x001815fb,0x001a17fd),  ivec4(0x001a16ff,0x001d1dff,0x001015f8,0x001218ff),  ivec4(0x000d10ff,0x000f18ff,0x000009fe,0x000000fc),  ivec4(0x000000f5,0x000000ec,0x000000f0,0x000000f7),\n  ivec4(0x000000fa,0x000000f7,0x000000f8,0x000000f9),  ivec4(0x001010f9,0x001010ff,0x000c16f5,0x000d14e8),  ivec4(0x001909ff,0x001b0bf8,0x000e13df,0x000e0aeb),  ivec4(0x001105f3,0x001404ec,0x00150cdb,0x00120dce),\n  ivec4(0x000d07d1,0x000c00db,0x000a00cd,0x000802c4),  ivec4(0x000803b7,0x000000ab,0x003225b2,0x006663ac),  ivec4(0x00ebebff,0x00f3fbfd,0x00fffefd,0x00fffdfa),  ivec4(0x00fffffe,0x00f9f8fb,0x00fdfbff,0x00fdfbff),\n  ivec4(0x00fdfffe,0x00fdfff2,0x00fffffb,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fdfffe,0x00fbfffb,0x00fdfdff,0x00fffcff),  ivec4(0x00ffffff,0x00f8fbf7,0x00f8ffff,0x00d6d6ff),  ivec4(0x006561c4,0x002c28e5,0x000000f3,0x000d03f8),  ivec4(0x000603fd,0x000c0aff,0x000d0cfe,0x001514ff),\n  ivec4(0x001614f7,0x001511ff,0x001512ff,0x001613ff),  ivec4(0x001716ff,0x001415fe,0x001615ff,0x001515fe),  ivec4(0x001616fe,0x001313ff,0x001512ff,0x001513fe),  ivec4(0x001615fc,0x001815fb,0x001916f8,0x001a15f7),\n  ivec4(0x001a14f6,0x001514f8,0x001012fc,0x001010fc),  ivec4(0x00110ffa,0x001310fa,0x00130cfa,0x00140bf8),  ivec4(0x00140af6,0x001209f3,0x000e0aeb,0x000f0be6),  ivec4(0x000f0be0,0x000f08e2,0x001408e6,0x000c00db),\n  ivec4(0x000501c9,0x000b04c7,0x000101c0,0x000000c3),  ivec4(0x000000ae,0x004a4ca3,0x009c93e6,0x00f7f2ff),  ivec4(0x00f2f5f9,0x00fafeec,0x00fffffb,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fdfffe,0x00fafffe,0x00fdfcff,0x00fffcff),  ivec4(0x00fffffd,0x00fefef3,0x00f6fdfb,0x00eff5ff),  ivec4(0x00e9ebff,0x009399ed,0x004749c2,0x002204f4),  ivec4(0x000200f3,0x00120afb,0x001111f6,0x001110fb),\n  ivec4(0x00140eff,0x00150ffe,0x001511fd,0x001612fe),  ivec4(0x001713ff,0x001611ff,0x001611ff,0x00160fff),  ivec4(0x00160fff,0x00130fff,0x00110fff,0x00130eff),  ivec4(0x00150dff,0x00160cff,0x00160bff,0x00170aff),\n  ivec4(0x001609ff,0x00140aff,0x00130dff,0x00130cfe),  ivec4(0x00130cfd,0x00130cf8,0x00130df6,0x00140bf3),  ivec4(0x00140bef,0x001308f2,0x001404f6,0x001207e9),  ivec4(0x00100ade,0x000f07e2,0x000700e1,0x000700dc),\n  ivec4(0x000806cd,0x000000b2,0x000000be,0x003330a9),  ivec4(0x005255a3,0x00d0d7fd,0x00f4fcfe,0x00f1f6f7),  ivec4(0x00fbfdff,0x00f9f6ff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fdfffe,0x00fafffe,0x00fdfcff,0x00fffbff),  ivec4(0x00fffffc,0x00fefef0,0x00f4fce7,0x00f7fefb),  ivec4(0x00f4fdfe,0x00ecfdfe,0x00d7dbfd,0x006760e1),  ivec4(0x003f39dd,0x000000e7,0x000e00f4,0x001207fe),\n  ivec4(0x001007ff,0x001010f7,0x001113f5,0x001112f7),  ivec4(0x001311fb,0x001611fd,0x001610ff,0x00160ffe),  ivec4(0x00160ffe,0x00130ffe,0x00100fff,0x00120eff),  ivec4(0x00120dff,0x00140cff,0x00140bff,0x00140bfe),\n  ivec4(0x001309fe,0x00140bfe,0x00150cfa,0x00140df8),  ivec4(0x00130ef5,0x00140ff3,0x00130eef,0x00100fea),  ivec4(0x00100ee8,0x00100de6,0x00100ae5,0x000e06e6),  ivec4(0x000c03e1,0x000c05d9,0x000907d2,0x000300c9),\n  ivec4(0x000000d1,0x001818cb,0x004848a1,0x00a8a6e4),  ivec4(0x00edf4ff,0x00f5fffc,0x00f5fee9,0x00fffff3),  ivec4(0x00f9f9fa,0x00fef8ff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fdfffe,0x00fbfff9,0x00fdffff,0x00fffcff),  ivec4(0x00fffdff,0x00fffff7,0x00fffff4,0x00fbfdf2),  ivec4(0x00fdfdf8,0x00fbfef0,0x00f7fffb,0x00f4fbff),  ivec4(0x00c4c6f6,0x004247c9,0x00312dd6,0x001a00fb),\n  ivec4(0x000800f9,0x000f08ff,0x000e0aff,0x000e0bff),  ivec4(0x000e0cff,0x00110efe,0x001310fb,0x001313f9),  ivec4(0x001313f6,0x001112f7,0x001210fa,0x00120ffb),  ivec4(0x00120ffb,0x00130ffb,0x00120ffa,0x001210f6),\n  ivec4(0x001110f2,0x00110ef7,0x00100afe,0x001009fd),  ivec4(0x001009fa,0x000f09fb,0x000d08f8,0x000b06f6),  ivec4(0x000b07f3,0x000a08f1,0x000708e6,0x000609dc),  ivec4(0x000706d3,0x000600d3,0x000000cb,0x00271bca),\n  ivec4(0x003e4099,0x008085e0,0x00e7e9ff,0x00f5f7ff),  ivec4(0x00f7f9ff,0x00fcfdfb,0x00fefff5,0x00fdfef4),  ivec4(0x00fffff8,0x00fffefc,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fefffc,0x00fbfff7,0x00fdfffc,0x00fffdff),  ivec4(0x00fffcff,0x00fffdff,0x00fffefe,0x00fffffe),  ivec4(0x00fffeff,0x00fffaff,0x00fffffd,0x00fdfff4),  ivec4(0x00f6fff9,0x00ecfbff,0x00b2b8f1,0x00363bc8),\n  ivec4(0x00312ed9,0x00190cf6,0x000600f7,0x000800fb),  ivec4(0x000c01fd,0x000f05fe,0x000f07ff,0x000f08ff),  ivec4(0x000e08ff,0x00140dff,0x00140aff,0x001409ff),  ivec4(0x00150bff,0x00130afd,0x00110df7,0x00100ff1),\n  ivec4(0x000f11eb,0x000e11ec,0x000c10ef,0x000d0eef),  ivec4(0x000c0eee,0x000c0ded,0x000506e7,0x000504e6),  ivec4(0x000505e6,0x000404e5,0x000000db,0x000000dd),  ivec4(0x000500d6,0x002d27cd,0x003535aa,0x007e74d4),\n  ivec4(0x00e2e7fa,0x00f9fffa,0x00fafffa,0x00fefffd),  ivec4(0x00ffffff,0x00fffcff,0x00fffdff,0x00fffefe),  ivec4(0x00fffffa,0x00fffff8,0x00fffffe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffffe,0x00fdfffa,0x00fdfffb,0x00fffffe),  ivec4(0x00fffeff,0x00fffcff,0x00fffbff,0x00fffbff),  ivec4(0x00fffcff,0x00fffefe,0x00fff9ff,0x00fff6ff),  ivec4(0x00fdfbff,0x00f7fffe,0x00f0fffb,0x00e5f3ff),\n  ivec4(0x00c5ccf2,0x00675cf3,0x002e31d4,0x002c25e2),  ivec4(0x00291df0,0x00210ff6,0x001202f7,0x000700f2),  ivec4(0x001005f8,0x001505fb,0x001706fe,0x001603fe),  ivec4(0x001504fe,0x001504ff,0x001205fc,0x001108f7),\n  ivec4(0x000e09f1,0x000e0aef,0x000f0bf0,0x000c09ec),  ivec4(0x000c05e6,0x001007e3,0x000e07de,0x000902d4),  ivec4(0x000b04d4,0x00140dcc,0x00221fc3,0x002829af),  ivec4(0x003033ad,0x00aeafdf,0x00e0e0ff,0x00f7f5ff),\n  ivec4(0x00fefaff,0x00fcf6fd,0x00feffff,0x00fffffd),  ivec4(0x00fffffd,0x00fffffd,0x00fffffe,0x00fffeff),  ivec4(0x00fffdff,0x00fffdff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffeff,0x00fffeff,0x00fffffd,0x00fdfffa),  ivec4(0x00fdfffc,0x00fcfeff,0x00fcfdff,0x00fdfeff),  ivec4(0x00fefffe,0x00fdffef,0x00fffdff,0x00fff2ff),  ivec4(0x00fff2ff,0x00fdf8ff,0x00fcfff4,0x00f6fff0),\n  ivec4(0x00f5fff8,0x00f0fff6,0x00eaf6ff,0x00c5cae8),  ivec4(0x009391de,0x005146d7,0x002022cf,0x001c1fd9),  ivec4(0x001f1be7,0x001f17dd,0x001a15d8,0x001811e0),  ivec4(0x00190dea,0x001407ed,0x001105ef,0x001006ee),\n  ivec4(0x001108ed,0x001507f1,0x001706f1,0x00190aea),  ivec4(0x002012e0,0x002117ce,0x001c1bc3,0x002021af),  ivec4(0x002325be,0x006e5fe6,0x00aca0e5,0x00d5d6fb),  ivec4(0x00f2fffe,0x00f4fefb,0x00f7faff,0x00fcf5ff),\n  ivec4(0x00faf0ff,0x00f8f1fa,0x00fcfdff,0x00fdffff),  ivec4(0x00fffffe,0x00fffffc,0x00fffffd,0x00fffeff),  ivec4(0x00fffdff,0x00fdfbff,0x00fffeff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fffeff,0x00fffaff,0x00ffffff,0x00fdfff8),  ivec4(0x00fbfff6,0x00fafff9,0x00fafffd,0x00fafffb),  ivec4(0x00fbfffa,0x00f7fffd,0x00fbfff7,0x00fffff3),  ivec4(0x00fffff5,0x00fffffb,0x00fffbfe,0x00fffaff),\n  ivec4(0x00fff9ff,0x00fffff5,0x00fcfff4,0x00fdfdff),  ivec4(0x00f6f7ff,0x00f2f6ff,0x00e3ecff,0x00ceddff),  ivec4(0x00b3c7e8,0x0097a5e2,0x00767fe3,0x005c61e4),  ivec4(0x004141e6,0x002725e0,0x00231ee7,0x00231eeb),\n  ivec4(0x00221eee,0x002f2be2,0x005752e3,0x007571e4),  ivec4(0x00918fe1,0x00b1b2e1,0x00c2c7f0,0x00e3e8ff),  ivec4(0x00f2f9ff,0x00f8fbfe,0x00fffafd,0x00fff9ff),  ivec4(0x00fffaff,0x00fefaff,0x00fefcff,0x00fafbf4),\n  ivec4(0x00f9ffec,0x00fbffeb,0x00f9fffd,0x00faffff),  ivec4(0x00fefdff,0x00fffcff,0x00fffbff,0x00fffdff),  ivec4(0x00ffffff,0x00fdfffc,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n);\nivec4 pixel_data(in int i) {\n   return pixel_data_array[i];\n}\n\n#else\nivec4 pixel_data(in int i) {\n#  ifdef R\n#    undef R\n#  endif\n#  define R(i,a,b,c,d) case i: r=ivec4(a,b,c,d); break;\n  ivec4 r;\n  switch(i) {\n    R(0x0000,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0001,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0002,0x00fdfbff,0x00fff9ff,0x00fffff9,0x00fffff2)    R(0x0003,0x00fffdff,0x00fdfdfd,0x00f1f9fd,0x00dfdbff)    R(0x0004,0x00392cce,0x001c10ea,0x001b0dfd,0x001b11ff)    R(0x0005,0x00110efe,0x001216fa,0x001619f5,0x001916f9)    R(0x0006,0x001a13fd,0x001913fb,0x001711f8,0x001611f5)    R(0x0007,0x001711f1,0x00140feb,0x00120de5,0x000f0be1)\n    R(0x0008,0x001009e4,0x001107ea,0x003b1fb0,0x00d05215)    R(0x0009,0x00ca5112,0x00d15b05,0x00d94f1a,0x00d84f1b)    R(0x000a,0x00e74e16,0x00d05417,0x00aa591c,0x00c05320)    R(0x000b,0x00ea4c1e,0x00e04f18,0x00ca5719,0x00ab4811)    R(0x000c,0x00772d05,0x00913d32,0x0084375e,0x00642c94)    R(0x000d,0x004322c9,0x002b1fe8,0x00191bf4,0x00151af8)    R(0x000e,0x001b19f8,0x002015f9,0x001d13fa,0x00190ffa)    R(0x000f,0x00150dfb,0x00120dfd,0x00100dfc,0x00110af9)\n    R(0x0010,0x001109f7,0x000f0fea,0x000f14da,0x000f10d8)    R(0x0011,0x00110ed6,0x00130cd3,0x001609cd,0x001708c7)    R(0x0012,0x001907c1,0x001f09b5,0x00411397,0x006f1f6a)    R(0x0013,0x00873636,0x009c4614,0x00ae4608,0x00a24a12)    R(0x0014,0x0092401a,0x00a83d21,0x009e3f17,0x00993f16)    R(0x0015,0x00943e15,0x00913d15,0x00943e18,0x00923814)    R(0x0016,0x00943110,0x0095300e,0x00803a13,0x0055222d)    R(0x0017,0x000d0363,0x000a0066,0x0004015c,0x0000006b)\n    R(0x0018,0x00030163,0x00190066,0x000d006e,0x00060072)    R(0x0019,0x0007007a,0x00060081,0x00050087,0x0004008a)    R(0x001a,0x0004008e,0x0005018f,0x00040492,0x00050395)    R(0x001b,0x000b039e,0x00000087,0x00928ed2,0x00f0f3ff)    R(0x001c,0x00f5f9f6,0x00fefcfc,0x00fffcff,0x00fffffe)    R(0x001d,0x00fffffe,0x00fffffe,0x00fffffe,0x00ffffff)    R(0x001e,0x00ffffff,0x00fffeff,0x00fffeff,0x00ffffff)    R(0x001f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0020,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0021,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0022,0x00fdfffe,0x00fefefe,0x00fefffd,0x00fffffb)    R(0x0023,0x00fffdff,0x00fcf6ff,0x00f5f0fa,0x00fcfcfc)    R(0x0024,0x00cacbfe,0x000000c8,0x001f13ef,0x001407fc)    R(0x0025,0x00150fff,0x001115f9,0x001517f5,0x001914fc)    R(0x0026,0x001a13fe,0x001914fa,0x001812f8,0x001711f6)    R(0x0027,0x001811f4,0x001611f0,0x00130de9,0x00100be3)\n    R(0x0028,0x001209e2,0x001107e4,0x00271cb9,0x00cb5215)    R(0x0029,0x00d04e1a,0x00d6560d,0x00db4a23,0x00c94f20)    R(0x002a,0x00d85119,0x00dc4f1d,0x00c2541d,0x00c85617)    R(0x002b,0x00ca5912,0x00bd5a11,0x00ce511b,0x00b83e27)    R(0x002c,0x00431408,0x0043289d,0x003a25d1,0x00271dee)    R(0x002d,0x001013fe,0x000a13ff,0x000b13ff,0x001613fd)    R(0x002e,0x002013f7,0x001c14f9,0x001714fb,0x001412fd)    R(0x002f,0x001211fe,0x000d0ffc,0x000f0ef9,0x00100ef7)\n    R(0x0030,0x00120ef5,0x00130fef,0x001311e9,0x00110fe7)    R(0x0031,0x00110de6,0x00100ce3,0x000d0bdd,0x000b0bd7)    R(0x0032,0x00080ad0,0x00060bcc,0x00080ac7,0x002f09b7)    R(0x0033,0x00321891,0x004b2b57,0x009b3a2a,0x00b64514)    R(0x0034,0x00a34012,0x00ac3d1e,0x00a83d16,0x00a33c16)    R(0x0035,0x009c3a13,0x00943813,0x008c3614,0x007d2f0f)    R(0x0036,0x006e290b,0x0067250a,0x00632616,0x00471732)    R(0x0037,0x000a0562,0x0003055c,0x00010557,0x00000071)\n    R(0x0038,0x00090069,0x00060361,0x0003016c,0x00070073)    R(0x0039,0x0007007b,0x00070084,0x00060089,0x0005008d)    R(0x003a,0x0004008f,0x0006028f,0x00000092,0x0006099f)    R(0x003b,0x00000087,0x006f6cb0,0x00f6f3fe,0x00f7f7fb)    R(0x003c,0x00fffff8,0x00fdfdf8,0x00f9f8f8,0x00fffeff)    R(0x003d,0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff)    R(0x003e,0x00fffeff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x003f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0040,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0041,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0042,0x00fefffc,0x00fefffb,0x00fefdff,0x00fefdff)    R(0x0043,0x00fefefd,0x00fefaff,0x00fdf3ff,0x00fffff6)    R(0x0044,0x00f2f6ff,0x00c1befd,0x000000c5,0x001e14f6)    R(0x0045,0x00100efc,0x00090dfd,0x001315fd,0x001816f9)    R(0x0046,0x001a17f5,0x001913fd,0x001814f7,0x001715f0)    R(0x0047,0x001814ee,0x001812f1,0x00140cf1,0x001107ee)\n    R(0x0048,0x001505ec,0x001d05e0,0x00271ab7,0x00c34a28)    R(0x0049,0x00d04925,0x00df5212,0x00d74f1e,0x00c35519)    R(0x004a,0x00c95319,0x00e04f1a,0x00df5116,0x00db5314)    R(0x004b,0x00d4590b,0x00c85711,0x00d94c1f,0x00c5412e)    R(0x004c,0x00190327,0x001e19d8,0x001815fe,0x001212ff)    R(0x004d,0x001010fe,0x000f12ff,0x001213fd,0x001612fe)    R(0x004e,0x001c0fff,0x001912fa,0x001713f6,0x001412f5)    R(0x004f,0x00120ff6,0x001210f7,0x001210f6,0x00120ff4)\n    R(0x0050,0x00130ef2,0x00110bf3,0x000b09f4,0x000b08f3)    R(0x0051,0x000b07f0,0x000c07ee,0x000e09e9,0x000c0ae2)    R(0x0052,0x000b0bdc,0x00060dd7,0x00010fd0,0x000e08cf)    R(0x0053,0x000408bb,0x0022117e,0x008c3143,0x00b4401b)    R(0x0054,0x00a7410e,0x00a54310,0x008d3f14,0x00853911)    R(0x0055,0x007c3209,0x00742c06,0x006e2a06,0x00642505)    R(0x0056,0x005b2205,0x00582106,0x00571f0f,0x0034123d)    R(0x0057,0x000a065d,0x000a045b,0x0005015e,0x0000006b)\n    R(0x0058,0x0008006b,0x00000466,0x00010171,0x00050079)    R(0x0059,0x0008007e,0x00090084,0x00080186,0x00040087)    R(0x005a,0x0003028d,0x00070795,0x00030297,0x0000008a)    R(0x005b,0x00515299,0x00f1f5fd,0x00fefeff,0x00fefdfd)    R(0x005c,0x00fefcfb,0x00fdfffb,0x00fefffc,0x00fffeff)    R(0x005d,0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff)    R(0x005e,0x00fffeff,0x00ffffff,0x00fffffe,0x00ffffff)    R(0x005f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0060,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0061,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0062,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0063,0x00ffffff,0x00ffffff,0x00fffeff,0x00ffffff)    R(0x0064,0x00fffefb,0x00f8f6ff,0x00bab9f8,0x000000cf)    R(0x0065,0x00110cfd,0x001311ff,0x000a07fe,0x001313f5)    R(0x0066,0x001815f7,0x00170fff,0x001613f8,0x001716ef)    R(0x0067,0x001715ed,0x001813f3,0x00150df4,0x001208f3)\n    R(0x0068,0x001207ef,0x001106e7,0x001d1ab5,0x00af433f)    R(0x0069,0x00cb4928,0x00dc530d,0x00ca5a0f,0x00ce5710)    R(0x006a,0x00d94d1e,0x00d75018,0x00d55314,0x00c6521c)    R(0x006b,0x00d65510,0x00d35118,0x00d1521f,0x00b9481c)    R(0x006c,0x00160031,0x00211be3,0x001412f9,0x001613f9)    R(0x006d,0x001511f9,0x001512fd,0x00140fff,0x00110dff)    R(0x006e,0x00110aff,0x00130ffd,0x001310f9,0x001310fa)    R(0x006f,0x00110ff9,0x000f0cf7,0x000e0bf6,0x000d0af6)\n    R(0x0070,0x000d0af6,0x000b0cf1,0x00080dec,0x000a0cee)    R(0x0071,0x000a08eb,0x000b07e7,0x000f08e4,0x00160ce2)    R(0x0072,0x00160cda,0x00110bd4,0x00080cc3,0x000c07a5)    R(0x0073,0x0002038c,0x00160357,0x00783436,0x008d391c)    R(0x0074,0x00853414,0x008e3407,0x00672b09,0x00622808)    R(0x0075,0x005e2506,0x00592204,0x005a2208,0x00592209)    R(0x0076,0x0055220b,0x00542008,0x005a2306,0x00210d4c)    R(0x0077,0x0005075a,0x000f005e,0x0005006b,0x00000364)\n    R(0x0078,0x0005006d,0x00050071,0x00020174,0x0004007a)    R(0x0079,0x00060084,0x00070087,0x000b0588,0x000d0b88)    R(0x007a,0x00020289,0x0002058f,0x0000008b,0x00433e92)    R(0x007b,0x00eaeffb,0x00f8fffd,0x00fefef9,0x00fffdff)    R(0x007c,0x00fffbff,0x00fdffff,0x00fbfffb,0x00ffffff)    R(0x007d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x007e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x007f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0080,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0081,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0082,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0083,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0084,0x00fffaff,0x00fdfaff,0x00e7f2fc,0x00b2baf2)    R(0x0085,0x000000d8,0x001b0dff,0x00120ffa,0x001311fd)    R(0x0086,0x00140dff,0x00120ffe,0x00140eff,0x00140efb)    R(0x0087,0x001610fa,0x001511f7,0x001512ec,0x001313e1)\n    R(0x0088,0x001312df,0x001108e9,0x001e19ba,0x00a64149)    R(0x0089,0x00cb4a27,0x00da520f,0x00ca5810,0x00d25612)    R(0x008a,0x00d74e1e,0x00d75118,0x00d45314,0x00c4521b)    R(0x008b,0x00d65510,0x00d15016,0x00d0521f,0x00ba491d)    R(0x008c,0x00190033,0x00211cdc,0x001512f5,0x001611f9)    R(0x008d,0x00150ffc,0x00160eff,0x00150dff,0x00140cfe)    R(0x008e,0x00140cfe,0x000f09ff,0x000d0aff,0x000d09ff)    R(0x008f,0x000c08ff,0x000e09ff,0x000f0bfe,0x000d0afa)\n    R(0x0090,0x000d09f7,0x000c07f2,0x000f05f0,0x001208ef)    R(0x0091,0x00160aeb,0x00180de2,0x001b0fd9,0x00160cc9)    R(0x0092,0x000d04b7,0x000601a8,0x0000018a,0x00030073)    R(0x0093,0x00000067,0x00100240,0x005d261f,0x0068290d)    R(0x0094,0x005e240b,0x00662200,0x005b2102,0x005a2304)    R(0x0095,0x005b2507,0x005c2609,0x00572208,0x00572209)    R(0x0096,0x0056220b,0x00542008,0x00582208,0x00200c4f)    R(0x0097,0x0004065c,0x000c0061,0x0005006c,0x00000265)\n    R(0x0098,0x0005006f,0x00050073,0x0003066f,0x00040475)    R(0x0099,0x00030083,0x0003008d,0x0004008d,0x00030187)    R(0x009a,0x00080689,0x0009038e,0x003e3f90,0x00ecf2fa)    R(0x009b,0x00f1f9fe,0x00f9fff1,0x00fffff7,0x00fffdff)    R(0x009c,0x00fffbff,0x00fbfeff,0x00fbfffc,0x00ffffff)    R(0x009d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x009e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x009f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x00a0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00a1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00a2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00a3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00a4,0x00ffffff,0x00fdf9fc,0x00f3f6f8,0x00e9f5fd)    R(0x00a5,0x00acaffc,0x000000cf,0x002113fe,0x000d09fa)    R(0x00a6,0x000c0efb,0x001013f8,0x000f0ffb,0x00100cff)    R(0x00a7,0x00130cff,0x00140efb,0x001411f0,0x001413e5)\n    R(0x00a8,0x001512e4,0x001209eb,0x002218c0,0x00983d59)    R(0x00a9,0x00ca4a23,0x00d65310,0x00cc5712,0x00d25613)    R(0x00aa,0x00d54f1e,0x00d65118,0x00d45314,0x00c4521b)    R(0x00ab,0x00d55510,0x00d04f15,0x00ce511f,0x00b94b1e)    R(0x00ac,0x001d0137,0x00211ae1,0x00130dfb,0x00140bfe)    R(0x00ad,0x00140bff,0x00150aff,0x00150aff,0x00140efa)    R(0x00ae,0x00130ff5,0x000e0afe,0x000b08ff,0x000b08ff)    R(0x00af,0x000d09fc,0x000e0af6,0x00110df0,0x00130eeb)\n    R(0x00b0,0x001311e7,0x001811e2,0x001a10d9,0x00160bcf)    R(0x00b1,0x001007c0,0x000e05b1,0x0008019d,0x00020189)    R(0x00b2,0x0001007c,0x00000074,0x00060064,0x00080155)    R(0x00b3,0x00000152,0x000b0534,0x00461b0f,0x004d1f05)    R(0x00b4,0x00431d0d,0x004f2005,0x00582205,0x00572305)    R(0x00b5,0x00572206,0x00582207,0x00572208,0x00562309)    R(0x00b6,0x0055220a,0x00532008,0x0056200c,0x001c0b52)    R(0x00b7,0x0003045f,0x000b0064,0x00040070,0x00000268)\n    R(0x00b8,0x00060071,0x00040175,0x00040278,0x00010379)    R(0x00b9,0x0000057d,0x00000189,0x00020193,0x00060096)    R(0x00ba,0x00070085,0x00443c92,0x00e5e5f8,0x00f3fbfd)    R(0x00bb,0x00fcfff4,0x00eff3e0,0x00fffff6,0x00fffdff)    R(0x00bc,0x00fffbff,0x00fbfeff,0x00fbfffc,0x00ffffff)    R(0x00bd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00be,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00bf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x00c0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00c1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00c2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00c3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00c4,0x00fffcfe,0x00fffcf6,0x00fefefa,0x00fefdfe)    R(0x00c5,0x00ecf6fe,0x00b4b9f9,0x000000d2,0x001b11fb)    R(0x00c6,0x001011f0,0x001211f6,0x00100efc,0x000f0cff)    R(0x00c7,0x00100ffe,0x00110ff9,0x00120ef7,0x00130cf6)\n    R(0x00c8,0x001609f7,0x00130aec,0x002516c7,0x0086376a)    R(0x00c9,0x00cb4d20,0x00d15310,0x00cd5515,0x00d55414)    R(0x00ca,0x00d0501d,0x00d65118,0x00d25415,0x00c3531b)    R(0x00cb,0x00d3550f,0x00ce4f15,0x00cd511f,0x00ba4d1f)    R(0x00cc,0x001e0338,0x001c1bdd,0x00110ff9,0x00110dff)    R(0x00cd,0x001209ff,0x001207ff,0x001308ff,0x00130bff)    R(0x00ce,0x00100bf9,0x001611f2,0x001611ee,0x001713e9)    R(0x00cf,0x001713e0,0x001813d5,0x001612c7,0x00100cb9)\n    R(0x00d0,0x000a07ad,0x0007049d,0x00040290,0x00030189)    R(0x00d1,0x0002017e,0x00010073,0x00000069,0x00000260)    R(0x00d2,0x00010459,0x00000459,0x0002005a,0x00090550)    R(0x00d3,0x00000452,0x00090534,0x00401b10,0x00481d07)    R(0x00d4,0x003c1e10,0x004b2006,0x00512005,0x00532007)    R(0x00d5,0x00552209,0x00562309,0x00552208,0x00562309)    R(0x00d6,0x00532309,0x00522107,0x0051200e,0x00180956)    R(0x00d7,0x00000364,0x00090066,0x00030072,0x0000026b)\n    R(0x00d8,0x00060073,0x00040077,0x00040083,0x00020082)    R(0x00d9,0x0000037e,0x00000387,0x0001018e,0x0000008c)    R(0x00da,0x00413599,0x00eee9f7,0x00f9faff,0x00fefffa)    R(0x00db,0x00fafcef,0x00fdfef5,0x00fef9f8,0x00fffcff)    R(0x00dc,0x00fffeff,0x00fdfffd,0x00fbfff9,0x00ffffff)    R(0x00dd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00de,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00df,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x00e0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00e1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00e2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00e3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00e4,0x00fffbff,0x00fffdfa,0x00fffefd,0x00fffefc)    R(0x00e5,0x00fefffe,0x00e4edfc,0x00bfc8f9,0x000000c7)    R(0x00e6,0x00170bee,0x00180afe,0x001408ff,0x001510ff)    R(0x00e7,0x000b0cf6,0x000d13ee,0x001011ee,0x00120af7)\n    R(0x00e8,0x001307fd,0x00120cee,0x002814ce,0x00722f7b)    R(0x00e9,0x00cd501e,0x00cc5311,0x00cd5216,0x00d65215)    R(0x00ea,0x00cc501a,0x00d35118,0x00d35515,0x00c2521b)    R(0x00eb,0x00d1540e,0x00ce5217,0x00cb521f,0x00bb4f21)    R(0x00ec,0x001c0339,0x002020e3,0x000a0df3,0x000d0cf7)    R(0x00ed,0x00130dfe,0x000e07f7,0x000f0cf3,0x00100def)    R(0x00ee,0x001311ea,0x001310c6,0x000d09ae,0x0005039f)    R(0x00ef,0x00040392,0x00040387,0x0004037d,0x00020174)\n    R(0x00f0,0x0001016e,0x0000016a,0x00000066,0x00000063)    R(0x00f1,0x00010160,0x0001015b,0x0003045f,0x00060860)    R(0x00f2,0x0004045c,0x0001015a,0x00000063,0x00020358)    R(0x00f3,0x00000156,0x0006043b,0x003c1410,0x004b1d08)    R(0x00f4,0x003f1c0d,0x004c1e03,0x004e1e07,0x00502009)    R(0x00f5,0x0053220a,0x0053220a,0x00532208,0x00542208)    R(0x00f6,0x00532208,0x00532208,0x004e1d12,0x0015095b)    R(0x00f7,0x00000369,0x000a006d,0x00010077,0x0000026e)\n    R(0x00f8,0x00080077,0x00050079,0x0003007f,0x00030287)    R(0x00f9,0x00050393,0x0003008c,0x0000006a,0x00585a9f)    R(0x00fa,0x00eceff7,0x00f5f4fc,0x00fffeff,0x00fffefe)    R(0x00fb,0x00fefefd,0x00fffefe,0x00fffbfe,0x00fffdff)    R(0x00fc,0x00fffefe,0x00fdfff8,0x00fdfff9,0x00ffffff)    R(0x00fd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00fe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00ff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0100,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0101,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0102,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0103,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0104,0x00fffefb,0x00fff8fe,0x00fffbff,0x00fffffa)    R(0x0105,0x00fffffd,0x00f5fafa,0x00e9f8ff,0x00cfd4f6)    R(0x0106,0x000000d4,0x001a00f7,0x001000f6,0x001d11ff)    R(0x0107,0x000101f1,0x000d14ec,0x000e16e5,0x001011eb)\n    R(0x0108,0x00100df1,0x00120dee,0x002a12d5,0x00622a8c)    R(0x0109,0x00cc501b,0x00c65212,0x00ce5018,0x00d65016)    R(0x010a,0x00c85019,0x00d25017,0x00d05313,0x00c0521a)    R(0x010b,0x00cf530c,0x00ce5116,0x00ca511e,0x00bb5022)    R(0x010c,0x00190239,0x001f13e5,0x00190dfd,0x001d13f6)    R(0x010d,0x001310dd,0x000c0ec5,0x000205aa,0x00020293)    R(0x010e,0x0003028b,0x0000017c,0x0000006d,0x00000060)    R(0x010f,0x00000056,0x00000051,0x00000050,0x0000004c)\n    R(0x0110,0x00000046,0x0000004b,0x00000056,0x00000058)    R(0x0111,0x0000005a,0x0000005a,0x00010062,0x00030265)    R(0x0112,0x00050169,0x0005006e,0x00000065,0x0000005b)    R(0x0113,0x0000005a,0x0005013e,0x003c1110,0x004a1b06)    R(0x0114,0x003f1909,0x004c1d00,0x004a1d08,0x004d200a)    R(0x0115,0x004f210b,0x0050210a,0x00512109,0x00512207)    R(0x0116,0x00522107,0x00522207,0x004b1d16,0x00120860)    R(0x0117,0x0000026e,0x00070071,0x0001007a,0x00000371)\n    R(0x0118,0x0009007a,0x0006007c,0x000c1283,0x0000007b)    R(0x0119,0x00100199,0x00000079,0x008885bf,0x00ecf1f5)    R(0x011a,0x00fafef3,0x00fbf9f9,0x00fffcff,0x00fffbff)    R(0x011b,0x00fffbff,0x00fffbff,0x00fffdff,0x00fffefe)    R(0x011c,0x00fefffc,0x00fdfffa,0x00fdfffc,0x00ffffff)    R(0x011d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x011e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x011f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0120,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0121,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0122,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0123,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0124,0x00fdfffd,0x00fdfeff,0x00fffaff,0x00fffcfe)    R(0x0125,0x00fffffb,0x00f5f8f0,0x00f5fafe,0x00f2f2ff)    R(0x0126,0x00d9dbf9,0x004843e5,0x000000d6,0x001002f3)    R(0x0127,0x001b12fd,0x000d0ff8,0x000c13ed,0x000f12eb)\n    R(0x0128,0x000f0fee,0x00120dee,0x002c11d9,0x00542699)    R(0x0129,0x00c94e16,0x00c15112,0x00ce4d1b,0x00d74e15)    R(0x012a,0x00c45118,0x00cf4e15,0x00ce5212,0x00bd5018)    R(0x012b,0x00ce520b,0x00c84e12,0x00c64f1b,0x00b84e20)    R(0x012c,0x00130035,0x002717c8,0x001204c6,0x000904ac)    R(0x012d,0x0003038d,0x00010276,0x00000060,0x00000049)    R(0x012e,0x00000048,0x00040a65,0x001f237a,0x00373b91)    R(0x012f,0x0045489f,0x005053a8,0x005359ad,0x00565bae)\n    R(0x0130,0x005458aa,0x004f53a7,0x0041459b,0x00282c81)    R(0x0131,0x000b0d64,0x00000053,0x00000055,0x00000055)    R(0x0132,0x00000060,0x0003016a,0x0000005f,0x00060154)    R(0x0133,0x00000055,0x0007023b,0x003a110f,0x00471a07)    R(0x0134,0x003a1809,0x00441d00,0x00471c08,0x004a1f0a)    R(0x0135,0x004c200b,0x004d210a,0x004e2008,0x00502106)    R(0x0136,0x00512006,0x00512105,0x004a1d1b,0x000e0763)    R(0x0137,0x00000371,0x00070072,0x0001007d,0x00000375)\n    R(0x0138,0x000b007d,0x00060180,0x00020681,0x0002027e)    R(0x0139,0x00000058,0x00c7bfe7,0x00eee7f8,0x00ffffff)    R(0x013a,0x00fafcef,0x00fefdf7,0x00fcfefc,0x00fdfeff)    R(0x013b,0x00fdfdff,0x00fcfdff,0x00fdfffe,0x00fdfffa)    R(0x013c,0x00fdfffc,0x00fffefe,0x00fffdff,0x00ffffff)    R(0x013d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x013e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x013f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0140,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0141,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0142,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0143,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0144,0x00fcffff,0x00fbfffe,0x00fcfeff,0x00fdfdff)    R(0x0145,0x00fefefe,0x00fcfdfb,0x00fdfbfd,0x00fdfdfa)    R(0x0146,0x00eefbf0,0x00d2eafb,0x008c91f6,0x000000d2)    R(0x0147,0x000f00fb,0x001009ff,0x000b09fd,0x000b09f9)\n    R(0x0148,0x000d0df9,0x000f0dee,0x002612df,0x004d239e)    R(0x0149,0x00c6500c,0x00c34f14,0x00cd4e1c,0x00cf4f18)    R(0x014a,0x00c34f1c,0x00cc4d15,0x00cb5015,0x00bb4f1b)    R(0x014b,0x00c8510e,0x00c44b0e,0x00c14d17,0x00b04c22)    R(0x014c,0x001a012c,0x00110b73,0x0002006b,0x0000005a)    R(0x014d,0x00000042,0x00000044,0x00222173,0x00554ea9)    R(0x014e,0x006157bb,0x005757b3,0x00565db7,0x00565cb8)    R(0x014f,0x00575eba,0x005d63c2,0x005e66c3,0x005e65c3)\n    R(0x0150,0x005b63c1,0x005a63ba,0x005861b0,0x005560a9)    R(0x0151,0x00505ca0,0x004b5798,0x00495498,0x002e3981)    R(0x0152,0x0000075c,0x00000048,0x00000050,0x000a024f)    R(0x0153,0x00010050,0x000a0336,0x00341110,0x003f1907)    R(0x0154,0x00341807,0x003e1c02,0x00451b09,0x00481e0b)    R(0x0155,0x00491f0b,0x004c2009,0x004e2008,0x004f2007)    R(0x0156,0x004f2106,0x004e2006,0x00461e1b,0x00110764)    R(0x0157,0x00000177,0x00010078,0x0000007f,0x0000027a)\n    R(0x0158,0x000a017f,0x0007057c,0x00000078,0x0000007a)    R(0x0159,0x00d7ddea,0x00f2f1fa,0x00fffdff,0x00fff5ff)    R(0x015a,0x00fefbfc,0x00fffff7,0x00f9fff2,0x00fbfffc)    R(0x015b,0x00fbfffc,0x00fbfffc,0x00fbfff9,0x00fdfff8)    R(0x015c,0x00fdfffd,0x00fffdff,0x00fffbff,0x00ffffff)    R(0x015d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x015e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x015f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0160,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0161,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0162,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0163,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0164,0x00feffff,0x00feffff,0x00feffff,0x00ffffff)    R(0x0165,0x00ffffff,0x00ffffff,0x00fffeff,0x00fffffe)    R(0x0166,0x00faffef,0x00f7ffec,0x00d7dff7,0x00cdcaf5)    R(0x0167,0x002e0be4,0x000000dc,0x000902f8,0x000f11ff)\n    R(0x0168,0x000002f0,0x000a0bf7,0x001008e6,0x00502ba4)    R(0x0169,0x00c65c02,0x00cf471e,0x00c54f15,0x00b05018)    R(0x016a,0x00c64424,0x00cc4c16,0x00c04a1d,0x00b2471f)    R(0x016b,0x00b24613,0x00ba4a0e,0x00aa440f,0x008b3d23)    R(0x016c,0x00310c1e,0x00070335,0x0000001e,0x00000046)    R(0x016d,0x00454b9f,0x00474ea9,0x005860c1,0x006167cb)    R(0x016e,0x00656cce,0x00656dd1,0x00646cd2,0x00626cce)    R(0x016f,0x00626dcc,0x00646dcb,0x00636dc7,0x00606cc4)\n    R(0x0170,0x005e6bc0,0x005e6bbe,0x005e69bb,0x005c68b8)    R(0x0171,0x005966b3,0x005764b1,0x00505eaa,0x004c5aa4)    R(0x0172,0x004b59a0,0x00414d92,0x00292e77,0x0000004a)    R(0x0173,0x00000045,0x000f0434,0x001e0911,0x00361a09)    R(0x0174,0x003f1d07,0x00411602,0x003f1909,0x00431b0b)    R(0x0175,0x00481e0a,0x004b1f08,0x004b1f07,0x004b1f07)    R(0x0176,0x004a1f09,0x00491f0d,0x003d201c,0x00210b65)    R(0x0177,0x00060095,0x0000007e,0x0001017a,0x00130084)\n    R(0x0178,0x0000007c,0x00000046,0x00aaabca,0x00e6e2eb)    R(0x0179,0x00f9f7ff,0x00fefdfe,0x00fefcfe,0x00fffcff)    R(0x017a,0x00fffefe,0x00fffffa,0x00fefffa,0x00fefffe)    R(0x017b,0x00fefffe,0x00fefffe,0x00fefffe,0x00fffffd)    R(0x017c,0x00ffffff,0x00ffffff,0x00fffeff,0x00ffffff)    R(0x017d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x017e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x017f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0180,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0181,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0182,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0183,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0184,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0185,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0186,0x00fffcfc,0x00fbf1f9,0x00faf9fc,0x00ebf2fd)    R(0x0187,0x00d2dff8,0x00acb6f4,0x000000ce,0x000000d2)\n    R(0x0188,0x000e00f3,0x001507ff,0x000b00e9,0x005022aa)    R(0x0189,0x00ba4f05,0x00cc4021,0x00c14f0b,0x00a6560a)    R(0x018a,0x00c54917,0x00c1470e,0x00b4471b,0x00a5421f)    R(0x018b,0x009e3d14,0x009d3d08,0x00853104,0x00632d20)    R(0x018c,0x001c0000,0x00040042,0x00595f9e,0x005962ac)    R(0x018d,0x005f69c3,0x006b77d9,0x006a78dd,0x006b7add)    R(0x018e,0x006f7ede,0x006f7de1,0x006e7de2,0x006e7edf)    R(0x018f,0x006c7dda,0x006d7cd5,0x006e7cd1,0x006b7acc)\n    R(0x0190,0x006877c5,0x006473c1,0x006470c0,0x00606dbd)    R(0x0191,0x005d6ab9,0x005c68b7,0x005a67b5,0x005866b2)    R(0x0192,0x005261ac,0x004b5aa3,0x004a569a,0x0043498e)    R(0x0193,0x00333272,0x0000001b,0x000d0309,0x002f1d0e)    R(0x0194,0x00311401,0x003f1a07,0x003b1705,0x003f1a06)    R(0x0195,0x00461d07,0x00491e06,0x004b1d05,0x004b1d06)    R(0x0196,0x00491d09,0x00471d0c,0x00381a21,0x002b0e6a)    R(0x0197,0x000a008f,0x00000074,0x0000004f,0x00000059)\n    R(0x0198,0x006657b9,0x00ccd6e5,0x00e7eaf9,0x00ffffff)    R(0x0199,0x00fefbff,0x00fefdff,0x00fefcfe,0x00fffffe)    R(0x019a,0x00fffffd,0x00fffffb,0x00fffffd,0x00ffffff)    R(0x019b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x019c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x019d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x019e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x019f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x01a0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01a1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01a2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01a3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01a4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01a5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01a6,0x00fef8ff,0x00fef5ff,0x00fffcff,0x00f4f9f1)    R(0x01a7,0x00f8fff9,0x00ecf6ff,0x00cbcbf0,0x00c6bfee)\n    R(0x01a8,0x002c00d5,0x000000d5,0x000000cd,0x004b1696)    R(0x01a9,0x00b04514,0x00c03d25,0x00bb4a0f,0x00a35303)    R(0x01aa,0x00ba480c,0x00b3460f,0x00a04014,0x00893615)    R(0x01ab,0x007d2e0c,0x006e2502,0x005b1c00,0x00290000)    R(0x01ac,0x00555277,0x0059619e,0x007b86cf,0x00707cce)    R(0x01ad,0x007181db,0x007586e8,0x007386eb,0x00788cef)    R(0x01ae,0x00768beb,0x007489ec,0x00758ced,0x00768deb)    R(0x01af,0x007389e3,0x007389dc,0x007486d6,0x007082cc)\n    R(0x01b0,0x006c7ec4,0x006978c0,0x006775bf,0x006371bb)    R(0x01b1,0x00616fba,0x005f6cb9,0x005e6cb9,0x005b68b6)    R(0x01b2,0x005663b1,0x005968b0,0x005667a5,0x005564a4)    R(0x01b3,0x0048508b,0x00565c7f,0x00202229,0x00050000)    R(0x01b4,0x00221202,0x002f1706,0x00341602,0x003a1904)    R(0x01b5,0x00411c03,0x00461d03,0x00491b03,0x00491b04)    R(0x01b6,0x00481c06,0x00481b0b,0x00351627,0x00270161)    R(0x01b7,0x00000051,0x00000041,0x00878db4,0x00d8cfe1)\n    R(0x01b8,0x00e5daf4,0x00edf6fb,0x00f8fbfe,0x00f6f4f9)    R(0x01b9,0x00fcfafe,0x00fffeff,0x00fffeff,0x00fffffe)    R(0x01ba,0x00fffffd,0x00fffffc,0x00fffffe,0x00ffffff)    R(0x01bb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01bc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01bd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01be,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01bf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x01c0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01c1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01c2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01c3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01c4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01c5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01c6,0x00fefcfa,0x00fffef9,0x00fdfcf6,0x00fefef9)    R(0x01c7,0x00fafaf9,0x00feffff,0x00fafbff,0x00f9f8ff)\n    R(0x01c8,0x00d1d1f0,0x00c6c3ee,0x009186e5,0x0034006a)    R(0x01c9,0x00a94d1e,0x00ac3b28,0x00ad401b,0x00954710)    R(0x01ca,0x00a43b18,0x0092380b,0x007d300b,0x0065270e)    R(0x01cb,0x00551600,0x00360000,0x0055393d,0x00767594)    R(0x01cc,0x006b78ad,0x007182c8,0x007b8dda,0x00798ce1)    R(0x01cd,0x00768de7,0x00798ff0,0x007a93f6,0x007d95f7)    R(0x01ce,0x007d96f6,0x007b97f6,0x007b9af7,0x007d9bf4)    R(0x01cf,0x007b97eb,0x007891e1,0x007389d4,0x006a80c4)\n    R(0x01d0,0x006a7cbd,0x00687bbc,0x006577bb,0x006273b8)    R(0x01d1,0x005f70b6,0x005d6eb6,0x005c6cb6,0x005c6bb8)    R(0x01d2,0x005d6cba,0x00596bb5,0x00596eac,0x00586ca9)    R(0x01d3,0x0054649e,0x005d6994,0x00535c74,0x004c4f5c)    R(0x01d4,0x00070000,0x00090000,0x00291202,0x00321708)    R(0x01d5,0x003a1906,0x003f1a04,0x00431a04,0x00441a05)    R(0x01d6,0x00441a07,0x00461b0d,0x00240118,0x00431c71)    R(0x01d7,0x00c1bbdc,0x00ccd1dd,0x00e6ebf4,0x00fffaff)\n    R(0x01d8,0x00fffbff,0x00fafcf5,0x00fcfefb,0x00fbfafd)    R(0x01d9,0x00fbf9fc,0x00fffeff,0x00ffffff,0x00fffffe)    R(0x01da,0x00fffffe,0x00fffffd,0x00ffffff,0x00ffffff)    R(0x01db,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01dc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01dd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01de,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01df,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x01e0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01e1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01e2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01e3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01e4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01e5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01e6,0x00fdfffd,0x00fcfffc,0x00fcfefa,0x00fefffd)    R(0x01e7,0x00fcfdfb,0x00fffffc,0x00fffffe,0x00ffffff)\n    R(0x01e8,0x00fdffff,0x00f3fafd,0x00e6e5fb,0x00cbbbc6)    R(0x01e9,0x006b0000,0x00710000,0x00840000,0x0074340f)    R(0x01ea,0x00802e1e,0x0065270d,0x00501200,0x00340000)    R(0x01eb,0x00694d54,0x00756879,0x00827fa0,0x007e8abd)    R(0x01ec,0x00708bcd,0x00788fdd,0x007c92e3,0x007f98ef)    R(0x01ed,0x007c99f3,0x007e9df9,0x007f9dfc,0x00819cfd)    R(0x01ee,0x00839efd,0x0082a2fe,0x0082a5fd,0x0086a7fb)    R(0x01ef,0x00809fef,0x007791df,0x006c87cd,0x00627bbc)\n    R(0x01f0,0x006276b7,0x006075b5,0x005d72b4,0x005d71b3)    R(0x01f1,0x005b70b3,0x005b6fb4,0x005a6db4,0x005b6db7)    R(0x01f2,0x005c6db8,0x005a6db8,0x00576cb4,0x00576cad)    R(0x01f3,0x00576ba8,0x0057689f,0x005c6995,0x005f6689)    R(0x01f4,0x00535771,0x00444556,0x001d0800,0x00060000)    R(0x01f5,0x00260e00,0x0032180c,0x003c1d12,0x002a0000)    R(0x01f6,0x00000000,0x00000000,0x00000000,0x00dedbe3)    R(0x01f7,0x00f8f4ff,0x00f9ffff,0x00fffffb,0x00fffefd)\n    R(0x01f8,0x00fffcff,0x00fffff9,0x00fffffd,0x00fffeff)    R(0x01f9,0x00fefdfe,0x00ffffff,0x00fffffe,0x00fffffe)    R(0x01fa,0x00fffffe,0x00fffffe,0x00ffffff,0x00ffffff)    R(0x01fb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01fc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01fd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01fe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01ff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0200,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0201,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0202,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0203,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0204,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0205,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0206,0x00fcffff,0x00f9ffff,0x00faffff,0x00fbfffe)    R(0x0207,0x00fcfffe,0x00fcfffd,0x00fefeff,0x00fffdff)\n    R(0x0208,0x00ffffff,0x00f7fff4,0x00fefff6,0x00fdf9fa)    R(0x0209,0x00d7cfb7,0x00d2caae,0x00d3a592,0x00380000)    R(0x020a,0x00410000,0x00360000,0x0064505b,0x00786c7f)    R(0x020b,0x00857d9a,0x008686b0,0x00838ec4,0x007890d4)    R(0x020c,0x007b99e3,0x00809bec,0x00829df1,0x0085a3f8)    R(0x020d,0x0084a5fc,0x0082a4fc,0x0083a5fe,0x0087a6ff)    R(0x020e,0x008aa8ff,0x0087a8fe,0x0088a8fd,0x0087a5f8)    R(0x020f,0x007895e4,0x006c87d3,0x00637cc4,0x005a71b5)\n    R(0x0210,0x005a70b3,0x005a6fb1,0x00586eae,0x00586eaf)    R(0x0211,0x00596fb1,0x00596eb1,0x00586eb2,0x00596eb3)    R(0x0212,0x005a6fb4,0x005b6eb8,0x00586cb8,0x00566eb0)    R(0x0213,0x00566eab,0x00576cab,0x005a69a9,0x005c66a1)    R(0x0214,0x005a6490,0x005b6484,0x00545972,0x0052576c)    R(0x0215,0x002a2531,0x00060000,0x00000000,0x005c4644)    R(0x0216,0x00ccc6c3,0x00cbc7c4,0x00d7d6d2,0x00fdfcf9)    R(0x0217,0x00fffefe,0x00fcfdf6,0x00fffff9,0x00fffffe)\n    R(0x0218,0x00fffdff,0x00fffefe,0x00fffffe,0x00ffffff)    R(0x0219,0x00ffffff,0x00fffffe,0x00fffffe,0x00fffffe)    R(0x021a,0x00fffffe,0x00fffffe,0x00ffffff,0x00ffffff)    R(0x021b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x021c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x021d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x021e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x021f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0220,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0221,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0222,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0223,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0224,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0225,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0226,0x00fefffe,0x00fcfffd,0x00fcfeff,0x00fdfcff)    R(0x0227,0x00fdfbff,0x00fcfcff,0x00fdfdff,0x00fefefd)\n    R(0x0228,0x00fefffc,0x00fcfdf9,0x00fefdf3,0x00f9feff)    R(0x0229,0x00fffff7,0x00feffeb,0x00fff4ef,0x00c4c3bb)    R(0x022a,0x00757082,0x0067678a,0x00777497,0x008b8ab1)    R(0x022b,0x00878dbf,0x007d8ece,0x007b93db,0x007d97e3)    R(0x022c,0x0088a1ed,0x0087a2f5,0x0087a5f8,0x008aa9fd)    R(0x022d,0x0087acff,0x0088abfe,0x0088adff,0x008bacff)    R(0x022e,0x008caafe,0x008ba7fa,0x00839ff0,0x007792e2)    R(0x022f,0x006882d0,0x005f78c5,0x005970bc,0x00556cb6)\n    R(0x0230,0x00576eb8,0x00596db5,0x00576eb0,0x00576eb0)    R(0x0231,0x00576eb0,0x00576eb0,0x00576fb0,0x00576faf)    R(0x0232,0x005870b0,0x00596eb3,0x005b6eb5,0x005972af)    R(0x0233,0x005773ab,0x00576fae,0x00586cb3,0x005867ae)    R(0x0234,0x00596aa1,0x005b6d98,0x005b6c98,0x00566289)    R(0x0235,0x004d5776,0x004e5469,0x009193a1,0x00e4e0e0)    R(0x0236,0x00fdfafb,0x00fffdfc,0x00ffffff,0x00fbfbf9)    R(0x0237,0x00fffdf9,0x00fffdfa,0x00fffdfe,0x00fdfeff)\n    R(0x0238,0x00fdfeff,0x00ffffff,0x00fffffd,0x00fffffd)    R(0x0239,0x00fffffd,0x00fffffe,0x00fffffe,0x00fffffe)    R(0x023a,0x00fffffe,0x00fffffe,0x00fffffe,0x00ffffff)    R(0x023b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x023c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x023d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x023e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x023f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0240,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0241,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0242,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0243,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0244,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0245,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0246,0x00fffefe,0x00fffefe,0x00fffeff,0x00fffdff)    R(0x0247,0x00fffdfe,0x00fffdfd,0x00fffffd,0x00fefffb)\n    R(0x0248,0x00fefffc,0x00fffeff,0x00fffdf5,0x00eff7ff)    R(0x0249,0x00fefdff,0x00ecf9fc,0x00d1cadf,0x00b3b7c2)    R(0x024a,0x008181b3,0x007c88c0,0x007681ba,0x00848fc8)    R(0x024b,0x008191d4,0x007f98e4,0x00809cee,0x00869ef0)    R(0x024c,0x008ea2ef,0x008ca6fb,0x008ca9fd,0x008bacff)    R(0x024d,0x0089aeff,0x008cb1ff,0x008db1ff,0x008aacfc)    R(0x024e,0x0084a2f5,0x00829cec,0x00768edd,0x006981d1)    R(0x024f,0x00637ac8,0x006175c4,0x005e74c4,0x005f76c5)\n    R(0x0250,0x005e74c4,0x005a70bc,0x005b72b7,0x005870b4)    R(0x0251,0x00576fb2,0x00576fb0,0x00556ead,0x00566fad)    R(0x0252,0x005770ae,0x005970ae,0x005c70af,0x005a74a8)    R(0x0253,0x005776a5,0x005672ab,0x00566db4,0x005a6cb4)    R(0x0254,0x005c71aa,0x005a729e,0x00506ca9,0x00486098)    R(0x0255,0x00596b98,0x005f6c8e,0x008c92a7,0x00c1c2c8)    R(0x0256,0x00d8dce2,0x00fdffff,0x00f9fbff,0x00fdfcfe)    R(0x0257,0x00fdf6f8,0x00fffcff,0x00fffbff,0x00f9fdff)\n    R(0x0258,0x00f9ffff,0x00fcfffd,0x00fefffc,0x00fffffc)    R(0x0259,0x00fffffc,0x00fffffd,0x00fffffe,0x00fffffe)    R(0x025a,0x00fffffe,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x025b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x025c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x025d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x025e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x025f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0260,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0261,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0262,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0263,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0264,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0265,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0266,0x00fffeff,0x00fffeff,0x00ffffff,0x00feffff)    R(0x0267,0x00fdfffe,0x00fdfffe,0x00fbfdfb,0x00fefefb)\n    R(0x0268,0x00fffdf9,0x00fffffb,0x00fcf9f9,0x00f8ffff)    R(0x0269,0x00ced2e8,0x00a6b6d9,0x007673b0,0x005f6daa)    R(0x026a,0x00727dc2,0x007b8cd0,0x007d8ed2,0x008697dc)    R(0x026b,0x008399e3,0x0086a0ed,0x0085a2f4,0x0089a6f8)    R(0x026c,0x008aa7f6,0x008da9fe,0x008daaff,0x008cadff)    R(0x026d,0x008bafff,0x0089adfd,0x0088aefb,0x0083a8f5)    R(0x026e,0x007ca0ee,0x007a9de5,0x00789ae0,0x007596dd)    R(0x026f,0x007696e0,0x007894e0,0x00718dda,0x006f89d8)\n    R(0x0270,0x006b83d3,0x00627bc9,0x005f79c3,0x005d76bd)    R(0x0271,0x005b72b5,0x005a6eb0,0x005a6eae,0x00596eae)    R(0x0272,0x00586faf,0x005970ae,0x005a71ab,0x005972a9)    R(0x0273,0x005873a7,0x005973a9,0x005b72af,0x005e72af)    R(0x0274,0x005c71a9,0x005c73a5,0x005670ab,0x00566ea5)    R(0x0275,0x00596fa1,0x00586d98,0x004c6288,0x00425b80)    R(0x0276,0x008593a9,0x00b8c6d4,0x00e2eaf4,0x00fcffff)    R(0x0277,0x00fbf8fc,0x00fbf8fa,0x00fffdfd,0x00fcfffd)\n    R(0x0278,0x00f9fffd,0x00f8fffe,0x00fdfffe,0x00fffffe)    R(0x0279,0x00fffffe,0x00fffffe,0x00ffffff,0x00ffffff)    R(0x027a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x027b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x027c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x027d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x027e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x027f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0280,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0281,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0282,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0283,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0284,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0285,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0286,0x00ffffff,0x00fffffe,0x00ffffff,0x00fdfffe)    R(0x0287,0x00fcfffd,0x00fafefc,0x00fcfdfd,0x00fefffe)\n    R(0x0288,0x00fffdfb,0x00fffdfb,0x00f0f0fd,0x00c7ccdc)    R(0x0289,0x00808cbd,0x005c6bb5,0x00687cc3,0x007788cd)    R(0x028a,0x008091d4,0x008395de,0x00869ae4,0x00899fea)    R(0x028b,0x0088a2ef,0x0088a5f3,0x0088a7f6,0x0088aafb)    R(0x028c,0x0089adfe,0x008baeff,0x008cafff,0x008cafff)    R(0x028d,0x008cb1ff,0x0089affb,0x0087aff8,0x0086aff6)    R(0x028e,0x0087b0f6,0x008bb6f4,0x0090bbf6,0x0091baf6)    R(0x028f,0x0092b8f9,0x008fb3f8,0x0083a4ec,0x007a99e2)\n    R(0x0290,0x007490db,0x006a87d3,0x006580cd,0x00627bc5)    R(0x0291,0x005f77ba,0x005c70b3,0x005d70b1,0x005a6eb0)    R(0x0292,0x00576db1,0x00576daf,0x005771ab,0x005970ab)    R(0x0293,0x005970ab,0x005a71aa,0x005c74ac,0x005d73aa)    R(0x0294,0x005c73aa,0x005d72aa,0x005e72a8,0x005f74a9)    R(0x0295,0x005c73a6,0x005a71a2,0x0059729e,0x00546e98)    R(0x0296,0x0043618d,0x004c6b96,0x0098a5b8,0x00d1d9e4)    R(0x0297,0x00ffffff,0x00f7f7fa,0x00fffffd,0x00fffffc)\n    R(0x0298,0x00fdfffb,0x00fafffe,0x00fdffff,0x00ffffff)    R(0x0299,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x029a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x029b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x029c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x029d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x029e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x029f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x02a0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02a1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02a2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02a3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02a4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02a5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02a6,0x00ffffff,0x00fffffe,0x00fffffd,0x00fffffc)    R(0x02a7,0x00fefffb,0x00fdfefb,0x00fefefe,0x00fcfdff)\n    R(0x02a8,0x00fefeff,0x00e5e7f8,0x00b4b9d8,0x006a76b2)    R(0x02a9,0x006a7dc2,0x007084d0,0x007b91de,0x008296df)    R(0x02aa,0x00899de5,0x00869fec,0x0088a2f0,0x0089a5f5)    R(0x02ab,0x0087a6f7,0x0087a8f9,0x0087aafc,0x0089adff)    R(0x02ac,0x008ab0ff,0x008bb6fd,0x008cb7fd,0x008cb8fd)    R(0x02ad,0x008eb9fd,0x0090bbfc,0x0093bcfc,0x0097c1fd)    R(0x02ae,0x009cc6ff,0x00a1cdff,0x00a3ceff,0x00a5ceff)    R(0x02af,0x00a0c8ff,0x0097bcfb,0x0089abee,0x007c9de1)\n    R(0x02b0,0x007493d9,0x006d8ad3,0x006783cf,0x00617bc4)    R(0x02b1,0x005e76ba,0x005b71b3,0x005c70b2,0x00596fb2)    R(0x02b2,0x00566db2,0x00546db0,0x00556fac,0x00566faa)    R(0x02b3,0x00566faa,0x00566faa,0x005872ac,0x005973ac)    R(0x02b4,0x005973ac,0x005b73ac,0x006074ad,0x006175ad)    R(0x02b5,0x005f74ab,0x005e73a8,0x005e75a6,0x005b72a2)    R(0x02b6,0x005a72a1,0x00566e9a,0x00556990,0x007c8ba8)    R(0x02b7,0x00cbd4dc,0x00fbffff,0x00fcfeff,0x00fffffd)\n    R(0x02b8,0x00fffffb,0x00fefff9,0x00fffffd,0x00ffffff)    R(0x02b9,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02ba,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02bb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02bc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02bd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02be,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02bf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x02c0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02c1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02c2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02c3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02c4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02c5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02c6,0x00ffffff,0x00fefffe,0x00fffffa,0x00fffff9)    R(0x02c7,0x00fffff9,0x00fffffd,0x00f8fbfe,0x00f9fcff)\n    R(0x02c8,0x00e7ecfc,0x00a1abde,0x006374bc,0x007084d1)    R(0x02c9,0x00748bde,0x007a94e9,0x00819bee,0x0087a0ef)    R(0x02ca,0x0089a2ef,0x0086a6f8,0x0087a7f9,0x0086a8fc)    R(0x02cb,0x0084a7fb,0x0085a9fc,0x0085abff,0x0088b0ff)    R(0x02cc,0x008ab2ff,0x008dbbfe,0x008ebdfc,0x0092c0fe)    R(0x02cd,0x0096c2fd,0x009cc7ff,0x00a4cdff,0x00aad1ff)    R(0x02ce,0x00aad1ff,0x00a7cefe,0x00a0c6f9,0x009bc0f3)    R(0x02cf,0x0090b3ec,0x0080a2dd,0x007090ce,0x006482c2)\n    R(0x02d0,0x005f7dbe,0x005b76ba,0x00556fb7,0x00536bb0)    R(0x02d1,0x00576daf,0x00596dac,0x005c70af,0x005a70b1)    R(0x02d2,0x005870b3,0x005770b2,0x00556fab,0x00556fab)    R(0x02d3,0x00556fab,0x00556fab,0x005671ae,0x005772ae)    R(0x02d4,0x005672af,0x005772b0,0x005f73af,0x006075b0)    R(0x02d5,0x006074af,0x005f74ac,0x005d74aa,0x006178ad)    R(0x02d6,0x005e76aa,0x005b73a5,0x005f78a7,0x0058709b)    R(0x02d7,0x0065799d,0x00cad6df,0x00fcffff,0x00fcffff)\n    R(0x02d8,0x00fffffb,0x00fffff6,0x00fffffb,0x00ffffff)    R(0x02d9,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02da,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02db,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02dc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02dd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02de,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02df,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x02e0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02e1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02e2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02e3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02e4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02e5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02e6,0x00feffff,0x00fdfffd,0x00fffff9,0x00fffff8)    R(0x02e7,0x00fffff9,0x00fcfcfe,0x00f2f7ff,0x00e6eefd)\n    R(0x02e8,0x00a6b3dd,0x00637ad5,0x007087e2,0x007792ee)    R(0x02e9,0x007a97f3,0x007f9ef8,0x0082a2f9,0x0088a8fb)    R(0x02ea,0x0088a7f9,0x0085aaff,0x0086acfe,0x0081a8fc)    R(0x02eb,0x0086abfd,0x0087acff,0x0086aefe,0x0084adfb)    R(0x02ec,0x008cb3fe,0x0094bfff,0x0096c1ff,0x009ac3ff)    R(0x02ed,0x00a1c9ff,0x009bbff6,0x0095b6e9,0x0095b5e5)    R(0x02ee,0x008cacdf,0x0085a2d4,0x007997ca,0x00718dc3)    R(0x02ef,0x00637eb6,0x00526ca7,0x004a64a2,0x00445d9d)\n    R(0x02f0,0x00455c9d,0x00465c9b,0x00495d98,0x004c5f98)    R(0x02f1,0x0051629a,0x00516198,0x0050629a,0x004e619b)    R(0x02f2,0x004c639e,0x005167a4,0x005871aa,0x00566faa)    R(0x02f3,0x005670ab,0x005570ac,0x00546fac,0x005470ad)    R(0x02f4,0x005571b1,0x005572b1,0x005c71b0,0x005d73b1)    R(0x02f5,0x005e74b1,0x005d74af,0x005e75af,0x005f76af)    R(0x02f6,0x005c75ac,0x005e76af,0x005977ae,0x005b78ac)    R(0x02f7,0x005a75a3,0x00627aa3,0x00cdd8e1,0x00fbffff)\n    R(0x02f8,0x00fffffd,0x00fffef6,0x00fffffc,0x00ffffff)    R(0x02f9,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02fa,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02fb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02fc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02fd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02fe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02ff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0300,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0301,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0302,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0303,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0304,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0305,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0306,0x00feffff,0x00fdfffd,0x00fffffa,0x00fffff9)    R(0x0307,0x00fffffc,0x00f2f4fc,0x00e8f1ff,0x00a6b6e0)\n    R(0x0308,0x00667fc9,0x006f8ced,0x007997f9,0x007d9dfc)    R(0x0309,0x0081a4fe,0x0084a7ff,0x0085a9fe,0x0087aafe)    R(0x030a,0x0089acff,0x0085acff,0x0086adff,0x0086adfd)    R(0x030b,0x0087acfb,0x0089affb,0x008eb4fd,0x008aaef7)    R(0x030c,0x008eb2f8,0x0098befe,0x009bc0fd,0x0089ace7)    R(0x030d,0x0089a9e2,0x008aa4db,0x00657bb0,0x004c6092)    R(0x030e,0x00334675,0x002d3e6c,0x002f406b,0x00364473)    R(0x030f,0x003e4c7e,0x00455389,0x004e5e94,0x00495992)\n    R(0x0310,0x004d5c97,0x00425287,0x00414f7a,0x003c4a71)    R(0x0311,0x003a4368,0x00323c61,0x00313e65,0x003a4873)    R(0x0312,0x00475885,0x00475b8c,0x00496094,0x004b6299)    R(0x0313,0x00556da5,0x005770ab,0x00536da8,0x00526eaa)    R(0x0314,0x00536faf,0x005571ae,0x005971ae,0x005a72b0)    R(0x0315,0x005b73b0,0x005c75b1,0x005c74b0,0x005c74af)    R(0x0316,0x005d76b0,0x005e76b1,0x005a78b3,0x005a79b3)    R(0x0317,0x005c7ab1,0x005c79a9,0x006079a3,0x00d6e0ea)\n    R(0x0318,0x00fcffff,0x00fdfbf7,0x00fffffd,0x00ffffff)    R(0x0319,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x031a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x031b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x031c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x031d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x031e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x031f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0320,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0321,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0322,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0323,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0324,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0325,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0326,0x00fdffff,0x00fdfffe,0x00fffffc,0x00fffffb)    R(0x0327,0x00fffdff,0x00f0f5fe,0x00bccaee,0x006481d0)\n    R(0x0328,0x007191ec,0x007a9afa,0x0083a3ff,0x0085a8ff)    R(0x0329,0x0089aeff,0x0087adfe,0x0087aeff,0x0087adff)    R(0x032a,0x0089aeff,0x0087aefe,0x0088aefe,0x0091b5fe)    R(0x032b,0x008eb2fa,0x0088abf1,0x0086a6e9,0x0082a1e0)    R(0x032c,0x007492d1,0x007492cf,0x007b97d1,0x00738dc7)    R(0x032d,0x007186b8,0x006677a2,0x00475477,0x001e2342)    R(0x032e,0x00000000,0x00000000,0x00000000,0x0000000f)    R(0x032f,0x001d2244,0x00373f61,0x00454d74,0x00485179)\n    R(0x0330,0x003f4770,0x0022294c,0x00061329,0x00000000)    R(0x0331,0x00000000,0x00000000,0x00070d25,0x002c334d)    R(0x0332,0x00424d6b,0x0048577b,0x00455787,0x003c4f81)    R(0x0333,0x0041568a,0x004c6399,0x00536ba3,0x00556ea9)    R(0x0334,0x00526da9,0x005470ab,0x005872ac,0x005973ad)    R(0x0335,0x005b74af,0x005c75b0,0x005b74af,0x005c74b0)    R(0x0336,0x005c75b2,0x005d76b2,0x005e7ab4,0x005c7bb5)    R(0x0337,0x005b7ab6,0x005a7db5,0x005f7cad,0x007c8fb3)\n    R(0x0338,0x00e6f0fa,0x00fafbfc,0x00fffffe,0x00ffffff)    R(0x0339,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x033a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x033b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x033c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x033d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x033e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x033f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0340,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0341,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0342,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0343,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0344,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0345,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0346,0x00feffff,0x00ffffff,0x00fffffe,0x00fffffe)    R(0x0347,0x00fefbff,0x00dce3f6,0x00738bd2,0x007194f3)\n    R(0x0348,0x007299fe,0x0086a5fe,0x008cadff,0x008db1ff)    R(0x0349,0x008eb4fe,0x008bb2fc,0x008bb2fe,0x0088b1ff)    R(0x034a,0x0088b0ff,0x008cb2fe,0x0092b5ff,0x008caef3)    R(0x034b,0x0083a4e4,0x007492d0,0x005f7ab5,0x005670a7)    R(0x034c,0x00375088,0x00002765,0x00304880,0x007186b5)    R(0x034d,0x007686aa,0x00000012,0x00000000,0x00000000)    R(0x034e,0x0002050c,0x0004040e,0x0002030d,0x00010207)    R(0x034f,0x00000000,0x00000000,0x00191b2a,0x0032374b)\n    R(0x0350,0x00000000,0x00000000,0x00000000,0x0001030b)    R(0x0351,0x0004050c,0x00050409,0x00000107,0x00000000)    R(0x0352,0x00000000,0x0030384d,0x004d5a86,0x004e5c8a)    R(0x0353,0x00334473,0x002e4073,0x004e6399,0x00566da4)    R(0x0354,0x00536ba3,0x00566fa9,0x005773aa,0x005672aa)    R(0x0355,0x005974ad,0x005a76ae,0x005a75ae,0x005a75ae)    R(0x0356,0x005b76b1,0x005b76b0,0x00637bb0,0x00607bb4)    R(0x0357,0x005c7bb8,0x00597dbb,0x006081ba,0x00647ea9)\n    R(0x0358,0x00a9b7d1,0x00f4faff,0x00fdfeff,0x00ffffff)    R(0x0359,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x035a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x035b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x035c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x035d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x035e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x035f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0360,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0361,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0362,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0363,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0364,0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff)    R(0x0365,0x00ffffff,0x00ffffff,0x00fffffe,0x00fefffd)    R(0x0366,0x00fcfffd,0x00f8fdfa,0x00fffefc,0x00fffdff)    R(0x0367,0x00f4f6ff,0x009caae5,0x007a98e8,0x00749cfe)\n    R(0x0368,0x0078a2ff,0x0089adff,0x0090b4ff,0x0094b6fe)    R(0x0369,0x0097b9fd,0x0097bcfd,0x0091b7fe,0x008db8ff)    R(0x036a,0x008bb5fe,0x0099b9fc,0x008facec,0x006d89c3)    R(0x036b,0x003c538a,0x002d4273,0x00354874,0x003c4f78)    R(0x036c,0x003e4f78,0x00354771,0x004a5a83,0x003a4868)    R(0x036d,0x00000000,0x0000000a,0x0000030e,0x0006090d)    R(0x036e,0x00010204,0x00060607,0x00010200,0x00000000)    R(0x036f,0x00000000,0x00000000,0x00000000,0x00000000)\n    R(0x0370,0x00000000,0x00000000,0x00000000,0x00010000)    R(0x0371,0x00090708,0x000b080a,0x00010103,0x00010308)    R(0x0372,0x0000010a,0x00000000,0x00000029,0x004c577d)    R(0x0373,0x00505c82,0x00313e67,0x0042537e,0x00445782)    R(0x0374,0x00435681,0x00495d89,0x004e6391,0x00596d9f)    R(0x0375,0x005d72a7,0x005a71aa,0x005d75b1,0x005b75b2)    R(0x0376,0x005a75b1,0x005b77b2,0x00617aaf,0x005f7ab3)    R(0x0377,0x005c7bb8,0x005b7cbc,0x006080bc,0x006983b6)\n    R(0x0378,0x0060769e,0x00c7d5ee,0x00fbfeff,0x00fffffd)    R(0x0379,0x00fffefc,0x00ffffff,0x00fefeff,0x00fdfeff)    R(0x037a,0x00fffeff,0x00fffffe,0x00fffffe,0x00ffffff)    R(0x037b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x037c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x037d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x037e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x037f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0380,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0381,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0382,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0383,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0384,0x00fffdff,0x00fffdff,0x00fffdff,0x00fffdff)    R(0x0385,0x00fffeff,0x00feffff,0x00fefffd,0x00fcfffb)    R(0x0386,0x00f7fffa,0x00effaf2,0x00fdfdf8,0x00faf8ff)    R(0x0387,0x00ccd6f6,0x00819ded,0x00749df9,0x0083acff)\n    R(0x0388,0x0087b0fc,0x0089b6ff,0x0090baff,0x0099bdff)    R(0x0389,0x009dbdff,0x00a3c5fd,0x0099bffd,0x0093bffc)    R(0x038a,0x0096c1fe,0x009db6e9,0x0063729b,0x002f3551)    R(0x038b,0x00181829,0x00000000,0x00000000,0x00090910)    R(0x038c,0x0033394a,0x003e4967,0x003e4762,0x00000000)    R(0x038d,0x00030812,0x00060b0f,0x0004070e,0x00050611)    R(0x038e,0x00000000,0x00000000,0x00000000,0x000b141d)    R(0x038f,0x00252c3b,0x002e3648,0x00333c51,0x00384157)\n    R(0x0390,0x0030394f,0x00272f43,0x001d202f,0x00000007)    R(0x0391,0x00000000,0x00000000,0x00000001,0x0003030c)    R(0x0392,0x0002030a,0x00010008,0x00000000,0x00121628)    R(0x0393,0x00484d62,0x003b4258,0x00262c3b,0x00000000)    R(0x0394,0x00000000,0x00000000,0x002c2f45,0x004e5375)    R(0x0395,0x0057618c,0x00616fa6,0x005e70af,0x005c74b5)    R(0x0396,0x005773b2,0x005a79b6,0x005a7ab3,0x005a7ab3)    R(0x0397,0x005d7ab7,0x00607bb9,0x00617ab6,0x00647cb5)\n    R(0x0398,0x006f89bb,0x006684b8,0x00f2f7fe,0x00fdfcf9)    R(0x0399,0x00fffdf8,0x00fffdfd,0x00fdfcff,0x00f9fcff)    R(0x039a,0x00fefdff,0x00fffffc,0x00fffffc,0x00ffffff)    R(0x039b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x039c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x039d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x039e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x039f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x03a0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03a1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03a2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03a3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03a4,0x00fefffe,0x00fdfffd,0x00fdfffe,0x00fdfeff)    R(0x03a5,0x00fefeff,0x00fcfeff,0x00fdfdff,0x00fcfdff)    R(0x03a6,0x00fafefb,0x00fcfff8,0x00fafcfa,0x00ecf2fe)    R(0x03a7,0x008ea0de,0x007b9df2,0x007ba6ff,0x0086affe)\n    R(0x03a8,0x0091b7fd,0x0091bdfe,0x0094c1ff,0x0097c4ff)    R(0x03a9,0x0099c5ff,0x009cc6fd,0x009ec6fd,0x009ac3f9)    R(0x03aa,0x009ec3f6,0x00697a9d,0x00000000,0x00000000)    R(0x03ab,0x00000003,0x0003030e,0x0002020d,0x00000008)    R(0x03ac,0x00000000,0x00000003,0x00000002,0x0001010d)    R(0x03ad,0x00070c15,0x00070e17,0x00000000,0x00000000)    R(0x03ae,0x00141932,0x0037415f,0x00424e73,0x00505e85)    R(0x03af,0x0056668f,0x005f6f9b,0x006375a4,0x006779aa)\n    R(0x03b0,0x006072a5,0x005a6c9d,0x0052628f,0x004c5b82)    R(0x03b1,0x00404a68,0x00313a4f,0x00000012,0x00000000)    R(0x03b2,0x00030000,0x00020108,0x00020410,0x00000000)    R(0x03b3,0x00000011,0x00000000,0x00000000,0x0000010b)    R(0x03b4,0x0000050c,0x00000002,0x00000000,0x00000000)    R(0x03b5,0x0015203a,0x00546289,0x005c70a1,0x005872a9)    R(0x03b6,0x005977af,0x005577af,0x00597ab0,0x00597ab2)    R(0x03b7,0x005d7bb6,0x005f7bb8,0x00627bb7,0x00637cb6)\n    R(0x03b8,0x006b86bb,0x00657fb1,0x00c4d2e7,0x00f3f7fa)    R(0x03b9,0x00fefefe,0x00fefbfa,0x00fefeff,0x00fafdff)    R(0x03ba,0x00fcfdff,0x00fffffe,0x00fffffe,0x00ffffff)    R(0x03bb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03bc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03bd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03be,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03bf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x03c0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03c1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03c2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03c3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03c4,0x00fbfffc,0x00f9fffb,0x00fafffc,0x00fbfffd)    R(0x03c5,0x00fcffff,0x00fdfdff,0x00fefcff,0x00fefbff)    R(0x03c6,0x00fffdfc,0x00fffff6,0x00f8fbff,0x00d5e3f7)    R(0x03c7,0x00829fe3,0x007da6fd,0x007eadff,0x008ab4fc)\n    R(0x03c8,0x009bc0fd,0x009ac2fd,0x0099c7ff,0x0095cbff)    R(0x03c9,0x0094cdff,0x009dd2fc,0x009dcaf9,0x00aacdfa)    R(0x03ca,0x00738cb3,0x00000000,0x0001061e,0x00010211)    R(0x03cb,0x00060610,0x0001030b,0x0000020c,0x0000010f)    R(0x03cc,0x00000212,0x0000020c,0x00030712,0x00020513)    R(0x03cd,0x0000030f,0x00000004,0x00222a3f,0x003e496a)    R(0x03ce,0x0051608b,0x006b7eb8,0x00778dcd,0x00778ccc)    R(0x03cf,0x00657cbd,0x00637abe,0x006178be,0x005d76be)\n    R(0x03d0,0x00637bc4,0x006780cb,0x006b87cc,0x007a94d3)    R(0x03d1,0x00778bc3,0x006779a6,0x00505d7d,0x003a4357)    R(0x03d2,0x00090e1d,0x00000000,0x00010107,0x00010209)    R(0x03d3,0x00010108,0x00040410,0x0000000c,0x00010009)    R(0x03d4,0x00000008,0x00000107,0x00020601,0x00030a0f)    R(0x03d5,0x00000000,0x00000e21,0x00596e91,0x0058729e)    R(0x03d6,0x005877ac,0x005376ac,0x005979af,0x005b79b2)    R(0x03d7,0x005d79b5,0x005f7bb7,0x00627cb8,0x006681ba)\n    R(0x03d8,0x006781b7,0x006884b7,0x006e88b1,0x00e9f9ff)    R(0x03d9,0x00fbfcfe,0x00fffffb,0x00fffffd,0x00fdffff)    R(0x03da,0x00fbfeff,0x00feffff,0x00ffffff,0x00ffffff)    R(0x03db,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03dc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03dd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03de,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03df,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x03e0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03e1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03e2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03e3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03e4,0x00fcfffe,0x00fbfffe,0x00fcfffc,0x00fcfffa)    R(0x03e5,0x00fffffb,0x00fffffc,0x00fffefd,0x00fffdfd)    R(0x03e6,0x00fffefc,0x00fdfdfa,0x00f1f9ff,0x009ab2e9)    R(0x03e7,0x0081a7f5,0x007cabff,0x0085b3ff,0x0094bffe)\n    R(0x03e8,0x00a0c6fb,0x00a2cafa,0x009ed0fe,0x0097d4ff)    R(0x03e9,0x0094d5ff,0x0093cef5,0x00a6d3f9,0x00a6c2e5)    R(0x03ea,0x00000000,0x0002081b,0x00020208,0x00070911)    R(0x03eb,0x0007080e,0x0004060c,0x0001050e,0x00000311)    R(0x03ec,0x00000210,0x0002050d,0x0000010b,0x00000009)    R(0x03ed,0x00080e25,0x003d4661,0x005a6b96,0x007a8dc3)    R(0x03ee,0x00768cc7,0x005f77bd,0x005c78c0,0x005c76bf)    R(0x03ef,0x005a75be,0x005b75c0,0x005d76c2,0x005c76c4)\n    R(0x03f0,0x005c75c4,0x005874c3,0x005876c5,0x005e7bc6)    R(0x03f1,0x00627dc1,0x006882be,0x00859bcd,0x007489b6)    R(0x03f2,0x0044587f,0x002e3b53,0x00000000,0x0002020a)    R(0x03f3,0x00000005,0x00020106,0x00030009,0x0003010b)    R(0x03f4,0x0001010d,0x0000010a,0x00050b03,0x00000400)    R(0x03f5,0x0000060c,0x00000000,0x0025334d,0x005f749f)    R(0x03f6,0x005974aa,0x005271ad,0x005977ae,0x005b79af)    R(0x03f7,0x005d79b2,0x005e7ab6,0x00637fbb,0x00627eb7)\n    R(0x03f8,0x00627eb5,0x006785b9,0x00607ca7,0x00d2e5f4)    R(0x03f9,0x00f9fdff,0x00fffef8,0x00fffff7,0x00fffefa)    R(0x03fa,0x00fffffd,0x00fffffc,0x00fffffd,0x00ffffff)    R(0x03fb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03fc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03fd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03fe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03ff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0400,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0401,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0402,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0403,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0404,0x00fffeff,0x00fffcff,0x00fefdfc,0x00fefdf7)    R(0x0405,0x00fefef4,0x00fffff5,0x00fffff8,0x00fffff9)    R(0x0406,0x00fffdfb,0x00faf7fd,0x00dfeeff,0x0082a5e6)    R(0x0407,0x0073a1f2,0x0082b4ff,0x008fbdff,0x0099c6fe)\n    R(0x0408,0x00a3cefc,0x00a7d3f8,0x00a1d4fb,0x009cd9ff)    R(0x0409,0x0099d9fe,0x009fd6f7,0x00b7dffd,0x00617287)    R(0x040a,0x00010418,0x0002050d,0x00070a11,0x00080b11)    R(0x040b,0x00070a10,0x00060711,0x00030611,0x00010715)    R(0x040c,0x00000615,0x00030816,0x00000001,0x001f273d)    R(0x040d,0x004b577a,0x007f91c2,0x007187c1,0x006880c1)    R(0x040e,0x00607bc0,0x00617dbe,0x00617dbd,0x005f7bbb)    R(0x040f,0x005e7aba,0x005f79bb,0x005f79bb,0x005f77bc)\n    R(0x0410,0x005e76bb,0x005f76bd,0x006076be,0x005f77be)    R(0x0411,0x005e77be,0x005c79bd,0x005e7dbf,0x005e80c1)    R(0x0412,0x006e90cf,0x006884b9,0x00424b60,0x0000000b)    R(0x0413,0x0000000a,0x00020208,0x00050107,0x0004000a)    R(0x0414,0x0001000b,0x0000000c,0x00010405,0x00010406)    R(0x0415,0x00000209,0x00000010,0x00000000,0x00596992)    R(0x0416,0x005f74ac,0x00566faf,0x005774a9,0x005c77ae)    R(0x0417,0x005c77b0,0x005f7bb8,0x005e7ab6,0x00607db6)\n    R(0x0418,0x00617fb6,0x006281b7,0x00607dab,0x0097a9cb)    R(0x0419,0x00f8faff,0x00fffefb,0x00fffffa,0x00fdfaf5)    R(0x041a,0x00fdfdfa,0x00fffffa,0x00fffffc,0x00ffffff)    R(0x041b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x041c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x041d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x041e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x041f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0420,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0421,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0422,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0423,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0424,0x00fffbff,0x00fff9ff,0x00fffcff,0x00fefffd)    R(0x0425,0x00fcfef8,0x00fcfffb,0x00f9fbfd,0x00edf1f7)    R(0x0426,0x00e6e7f2,0x00e7ebf7,0x00c6ddfa,0x0078a2ec)    R(0x0427,0x0080afff,0x008bbbff,0x0099c5ff,0x009fcdfd)\n    R(0x0428,0x00a3d4fe,0x00aadafa,0x00a2d6f8,0x00a4ddfe)    R(0x0429,0x00a5ddfe,0x00acd9f8,0x00bedcf4,0x00263241)    R(0x042a,0x00010514,0x00060912,0x00070b14,0x00070a15)    R(0x042b,0x00070a16,0x00050715,0x00050918,0x00030718)    R(0x042c,0x0003081b,0x0000011e,0x00202944,0x005b6b96)    R(0x042d,0x008296cd,0x006c83c4,0x006883c7,0x006582c8)    R(0x042e,0x006582c7,0x006785c3,0x006786c1,0x006784c0)    R(0x042f,0x006582be,0x006681bd,0x006780bd,0x00677fbc)\n    R(0x0430,0x00667ebb,0x00677dba,0x00667bba,0x00637ab9)    R(0x0431,0x005f79bb,0x005b78bd,0x005777bf,0x005577c1)    R(0x0432,0x00597ec9,0x006688ca,0x008c9ec9,0x00404b68)    R(0x0433,0x00000015,0x0003040f,0x00010107,0x00030008)    R(0x0434,0x0001000b,0x0001000d,0x0000000d,0x0000020b)    R(0x0435,0x0001010b,0x0000000e,0x00000007,0x00434c71)    R(0x0436,0x0059699a,0x005d6eaa,0x005a73a7,0x005e79ab)    R(0x0437,0x005c77af,0x006079b5,0x005f7bb8,0x005f7bb7)\n    R(0x0438,0x00607eb7,0x006180b7,0x006682b3,0x006d80a8)    R(0x0439,0x00e5ebf4,0x00eae8f1,0x00ecedf2,0x00f2f5fe)    R(0x043a,0x00f2f7fa,0x00fdffff,0x00fefefd,0x00ffffff)    R(0x043b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x043c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x043d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x043e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x043f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0440,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0441,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0442,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0443,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0444,0x00fffafe,0x00fffeff,0x00fcfafc,0x00f9feff)    R(0x0445,0x00ebf6fd,0x00e0eff9,0x00cfdff5,0x0098abdb)    R(0x0446,0x007683b8,0x007b8ac1,0x007d9fe6,0x0083b0fe)    R(0x0447,0x0087b5ff,0x0098c1fd,0x00a3cdfb,0x00a3d4fe)\n    R(0x0448,0x00a5d9ff,0x00a5dbf8,0x00ace1fe,0x00abdafe)    R(0x0449,0x00a5cff2,0x009bbbd5,0x0063778d,0x00000000)    R(0x044a,0x00050712,0x00020814,0x00040817,0x00040b1b)    R(0x044b,0x00070c1f,0x00080d20,0x000c0f23,0x000b0b1f)    R(0x044c,0x000e0d22,0x001b2346,0x006579af,0x007c92d0)    R(0x044d,0x007490d7,0x006c88d5,0x006b88d5,0x006d8bd3)    R(0x044e,0x006f8fd0,0x006c8ece,0x006b8cce,0x006b8acc)    R(0x044f,0x006a89cb,0x006b87c9,0x006a86c8,0x006a84c5)\n    R(0x0450,0x006982c2,0x006781c0,0x006581bd,0x00637fbb)    R(0x0451,0x00607cbb,0x005f7bbb,0x00607bbd,0x00627dc0)    R(0x0452,0x005a75b9,0x00617dc2,0x005773b6,0x00899fd3)    R(0x0453,0x003d4863,0x00000003,0x0000010a,0x00010107)    R(0x0454,0x0001000a,0x0000000c,0x00000011,0x0000000d)    R(0x0455,0x00020208,0x00020207,0x0002020b,0x0031384b)    R(0x0456,0x00546083,0x00576796,0x00576ea0,0x005974a7)    R(0x0457,0x005c75ac,0x005d77b3,0x005e7ab7,0x005e7cb7)\n    R(0x0458,0x005f7db6,0x005f80b8,0x00617db7,0x00657baf)    R(0x0459,0x005d71a1,0x005e7198,0x006579a2,0x00adbee1)    R(0x045a,0x00d2e0ef,0x00e2ecf7,0x00fdffff,0x00ffffff)    R(0x045b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x045c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x045d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x045e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x045f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0460,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0461,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0462,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0463,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0464,0x00fffefb,0x00feffff,0x00f7ffff,0x00eaf8fe)    R(0x0465,0x00bacfec,0x0090a9d8,0x007c98da,0x0084a1ee)    R(0x0466,0x008da3eb,0x007c92ce,0x007fa3ee,0x007faffe)    R(0x0467,0x008bb8fd,0x009ec7f9,0x00a8d2f8,0x00a3d6ff)\n    R(0x0468,0x00a2dcff,0x00ade5ff,0x009fd1f0,0x00add7f6)    R(0x0469,0x007a99bc,0x00000012,0x00000000,0x00070d1c)    R(0x046a,0x00060712,0x0002091b,0x00030a1d,0x00091023)    R(0x046b,0x000f162a,0x00151b30,0x001a1c34,0x00161832)    R(0x046c,0x001c1d3a,0x005c71a9,0x0087a2e5,0x007996df)    R(0x046d,0x006988d9,0x006f91e3,0x007192e0,0x007494dc)    R(0x046e,0x007798d7,0x007496de,0x007195df,0x007092dd)    R(0x046f,0x007091dc,0x00708fd9,0x00708dd7,0x006e8ad4)\n    R(0x0470,0x006d87d0,0x006888cd,0x006287c6,0x006183c3)    R(0x0471,0x006080be,0x00627dbb,0x00637bb7,0x00697eb8)    R(0x0472,0x006679b2,0x00677dbd,0x004d6fbd,0x006682c2)    R(0x0473,0x00889cca,0x00303c54,0x00000007,0x00000308)    R(0x0474,0x00010009,0x0001000a,0x00000010,0x0000010b)    R(0x0475,0x00010406,0x00040403,0x000a0e0f,0x00000000)    R(0x0476,0x00000221,0x003c4b6b,0x0049608b,0x00576ea0)    R(0x0477,0x005872a7,0x005a75b0,0x005c79b6,0x005c7ab7)\n    R(0x0478,0x005d7db8,0x005f7fb7,0x005f7cbc,0x006782c0)    R(0x0479,0x004d669f,0x004d68a1,0x004b6aa4,0x00466aa2)    R(0x047a,0x00385b8c,0x007c8eaf,0x00eaf1f5,0x00feffff)    R(0x047b,0x00fcfefe,0x00fefefe,0x00ffffff,0x00ffffff)    R(0x047c,0x00ffffff,0x00feffff,0x00fefffe,0x00ffffff)    R(0x047d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x047e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x047f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0480,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0481,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0482,0x00fffffe,0x00fffffe,0x00fdffff,0x00fdffff)    R(0x0483,0x00fdffff,0x00fdffff,0x00fdffff,0x00fdffff)    R(0x0484,0x00fdfcef,0x00fdfffc,0x00ebf6fe,0x00b3cbf4)    R(0x0485,0x008ab1ee,0x008dbaf7,0x0091bef8,0x0098c0f8)    R(0x0486,0x0099bffa,0x0091baf9,0x008bb6f7,0x008bb8f9)    R(0x0487,0x0094c3fe,0x009cccff,0x00a4d4fe,0x00a5d9ff)\n    R(0x0488,0x00a4dbff,0x009ed5f6,0x00a2c8e2,0x00677990)    R(0x0489,0x00000000,0x0000040a,0x00000710,0x00030816)    R(0x048a,0x00070919,0x00010a1c,0x00010d20,0x000c142a)    R(0x048b,0x00181f33,0x00242739,0x001f243e,0x00132146)    R(0x048c,0x00455987,0x007d9be5,0x007797e5,0x007a9be5)    R(0x048d,0x007a9de5,0x007ba0e4,0x007ba0e5,0x007ea2e5)    R(0x048e,0x007ea2e5,0x007ca1e5,0x007ba0e4,0x007a9fe4)    R(0x048f,0x00789de4,0x00779ce3,0x007799e1,0x007394de)\n    R(0x0490,0x007090db,0x006e8fd7,0x00688bce,0x006588ca)    R(0x0491,0x006486c7,0x005f80c1,0x006181c0,0x00607cbd)    R(0x0492,0x005f7cbb,0x00607cb9,0x005c7eb6,0x005e7cbf)    R(0x0493,0x00637fc4,0x007993c6,0x00060d1f,0x00010b10)    R(0x0494,0x00020206,0x00070107,0x00020008,0x00010108)    R(0x0495,0x00010206,0x00010107,0x00000107,0x0000020b)    R(0x0496,0x0000000a,0x00000000,0x00020014,0x005a698c)    R(0x0497,0x00596f9e,0x005774ae,0x005576b7,0x005977b8)\n    R(0x0498,0x005f7bb8,0x00677db5,0x006480bd,0x006380be)    R(0x0499,0x005976b3,0x00506ca8,0x004f6ca7,0x004f6ca6)    R(0x049a,0x00526ca5,0x00536ca1,0x00416092,0x00e6f5f8)    R(0x049b,0x00eaf5f9,0x00f9f9f6,0x00fffdfe,0x00fffbff)    R(0x049c,0x00fffbff,0x00fbfffd,0x00fafff9,0x00ffffff)    R(0x049d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x049e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x049f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x04a0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x04a1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x04a2,0x00fffffe,0x00fffffe,0x00fdffff,0x00fdffff)    R(0x04a3,0x00fdffff,0x00fdffff,0x00fffffe,0x00fffffe)    R(0x04a4,0x00fefffb,0x00f2fafa,0x00c9dbf4,0x0092b2e6)    R(0x04a5,0x009ac6ff,0x0097ccff,0x009ed0ff,0x00a4d1ff)    R(0x04a6,0x00a3cfff,0x0098c5ff,0x008ebbf8,0x0094c1fd)    R(0x04a7,0x009ac9ff,0x009ccdff,0x00a2d5ff,0x00a6dbff)\n    R(0x04a8,0x00a6dcfd,0x00a4d5f1,0x0082a2b9,0x00000000)    R(0x04a9,0x00010714,0x00020a13,0x00010c14,0x00040a19)    R(0x04aa,0x00070a1c,0x00060e1f,0x00071226,0x00121c33)    R(0x04ab,0x001c2338,0x002a2b3f,0x001e2541,0x000c1644)    R(0x04ac,0x008ba9e9,0x007f9feb,0x007e9fee,0x0080a3ec)    R(0x04ad,0x0082a7eb,0x0084aaeb,0x0084aaea,0x0085abeb)    R(0x04ae,0x0086aced,0x0085abec,0x0084aaeb,0x0083a9ea)    R(0x04af,0x0081a7ea,0x0080a5e9,0x007ea2e7,0x007a9ee4)\n    R(0x04b0,0x007699e2,0x007497df,0x007093d7,0x006d90d4)    R(0x04b1,0x006a8cd0,0x006688ca,0x006284c7,0x006181c4)    R(0x04b2,0x005e7ec1,0x00607fbc,0x005f7fb4,0x005c7cbe)    R(0x04b3,0x005f7dc7,0x006785bf,0x003c506d,0x00000207)    R(0x04b4,0x00060509,0x00090108,0x00020107,0x00010107)    R(0x04b5,0x00010107,0x00000109,0x0000010b,0x0000020c)    R(0x04b6,0x0001030e,0x0000010c,0x00000112,0x00000b27)    R(0x04b7,0x006677a0,0x00607cb1,0x005576b4,0x005977b8)\n    R(0x04b8,0x005e7ab7,0x00687cb5,0x00647fbb,0x00627fbc)    R(0x04b9,0x005774b1,0x00506ca8,0x00516ea7,0x00516da6)    R(0x04ba,0x00536da5,0x00556fa7,0x005c73a5,0x0063799d)    R(0x04bb,0x00ecfafb,0x00fbffff,0x00fdf8f8,0x00fffbff)    R(0x04bc,0x00fffbff,0x00fdfffd,0x00fafffa,0x00ffffff)    R(0x04bd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x04be,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x04bf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x04c0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x04c1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x04c2,0x00fdffff,0x00fdffff,0x00fffffe,0x00fffffe)    R(0x04c3,0x00fffffe,0x00fffffc,0x00fffffc,0x00fffffc)    R(0x04c4,0x00f3faff,0x00dcecfd,0x009eb8db,0x00acd4ff)    R(0x04c5,0x00a6dbff,0x00a3deff,0x00a6dcff,0x00aad9ff)    R(0x04c6,0x00a8d3ff,0x00a1cdff,0x0090bcf7,0x0097c3fe)    R(0x04c7,0x009bcaff,0x00a0d0ff,0x00a5d7ff,0x00a8dcff)\n    R(0x04c8,0x00aaddfd,0x00c4ecfb,0x00000000,0x0002091b)    R(0x04c9,0x000f101e,0x00040c16,0x00030c1a,0x00050c1f)    R(0x04ca,0x00080b21,0x000e1526,0x00121b2e,0x00172137)    R(0x04cb,0x001d213a,0x001e2039,0x00131839,0x004a5c8b)    R(0x04cc,0x0083a1e6,0x0085a8f2,0x0086a9f1,0x0089aef2)    R(0x04cd,0x008bb2ef,0x008db5ef,0x008eb6f0,0x008eb6f0)    R(0x04ce,0x008fb6f3,0x008eb5f2,0x008db4f1,0x008cb3f1)    R(0x04cf,0x008ab0ef,0x0088aeee,0x0085abed,0x0082a7ea)\n    R(0x04d0,0x007ea3e6,0x007ca1e6,0x00779be1,0x007396dc)    R(0x04d1,0x007092d8,0x006a8cd2,0x006889ce,0x006483c9)    R(0x04d2,0x00607fc5,0x00617fc1,0x005e7fb8,0x005b7bbd)    R(0x04d3,0x005d7bc2,0x006481bc,0x007b95b7,0x00030408)    R(0x04d4,0x0003050c,0x00050004,0x00020107,0x00010107)    R(0x04d5,0x00000109,0x00000109,0x0001030d,0x0002040f)    R(0x04d6,0x0000040f,0x0000030e,0x0003030c,0x0000000d)    R(0x04d7,0x00293654,0x00526a98,0x005875ad,0x005975b5)\n    R(0x04d8,0x005e7ab7,0x00657db9,0x00627dba,0x00617ebb)    R(0x04d9,0x005874b0,0x00506ca8,0x00526ea7,0x00536da5)    R(0x04da,0x00536ca4,0x00546da5,0x00556da5,0x005c729f)    R(0x04db,0x008c9eb4,0x00f5fdfe,0x00ffffff,0x00fffeff)    R(0x04dc,0x00fffdff,0x00ffffff,0x00fdfffc,0x00ffffff)    R(0x04dd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x04de,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x04df,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x04e0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x04e1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x04e2,0x00fdffff,0x00fdffff,0x00fffffe,0x00fffffc)    R(0x04e3,0x00fffffb,0x00fffffb,0x00fffffc,0x00fffffe)    R(0x04e4,0x00ecf9fe,0x00aac5ea,0x00b2d7fa,0x00aadcfd)    R(0x04e5,0x00b2edff,0x00afefff,0x00aee7fe,0x00addcff)    R(0x04e6,0x00a8d3ff,0x00a3d0ff,0x0092bff8,0x009cc9ff)    R(0x04e7,0x009ac9fc,0x00a2d3ff,0x00a7daff,0x00a9ddff)\n    R(0x04e8,0x00afdffa,0x00648196,0x00000d20,0x00111123)    R(0x04e9,0x00090917,0x00070d1b,0x00071022,0x000b1329)    R(0x04ea,0x0010142d,0x00161c2b,0x00171f33,0x00161e36)    R(0x04eb,0x00121730,0x000e122b,0x00000025,0x007c93cd)    R(0x04ec,0x0084a6ef,0x008db1f6,0x008fb5f5,0x0092b9f6)    R(0x04ed,0x0095bef4,0x0095bff3,0x0095bff3,0x0096c0f4)    R(0x04ee,0x0097c0f6,0x0096bff5,0x0095bef4,0x0093bbf4)    R(0x04ef,0x0092baf3,0x0091b9f3,0x008fb6f2,0x008bb2ef)\n    R(0x04f0,0x0087aeeb,0x0085abeb,0x0080a5e9,0x007a9fe3)    R(0x04f1,0x00769ae0,0x007294da,0x006d8fd7,0x006888d2)    R(0x04f2,0x006484ce,0x006483c8,0x006281be,0x005c7cbe)    R(0x04f3,0x005a7bc0,0x006180bc,0x00809ac4,0x00242e42)    R(0x04f4,0x00000009,0x00030207,0x00000109,0x00000109)    R(0x04f5,0x00000109,0x0000000a,0x0002040f,0x00010510)    R(0x04f6,0x00020513,0x00000410,0x000c0b0f,0x00060914)    R(0x04f7,0x00000118,0x006b7da4,0x005d75aa,0x005975b1)\n    R(0x04f8,0x005c79b6,0x00617dba,0x00607cb8,0x00607cb8)    R(0x04f9,0x005773af,0x00526da7,0x00516ca5,0x00516aa2)    R(0x04fa,0x00516aa0,0x00526aa0,0x00526aa8,0x005269a2)    R(0x04fb,0x0061779b,0x00c4d2dd,0x00f8ffff,0x00fffffc)    R(0x04fc,0x00fffffe,0x00fffeff,0x00fffeff,0x00ffffff)    R(0x04fd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x04fe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x04ff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0500,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0501,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0502,0x00fdffff,0x00fdffff,0x00fffffe,0x00fffffb)    R(0x0503,0x00fffffb,0x00fffffc,0x00fcffff,0x00f6fbfe)    R(0x0504,0x00b9d0ea,0x00a7ccf7,0x00b1dfff,0x00b5ecff)    R(0x0505,0x00b4f4fe,0x00b5f7fc,0x00aeeaf9,0x00a4d6f8)    R(0x0506,0x00aad7ff,0x00a2ceff,0x0092bef5,0x00a3cffd)    R(0x0507,0x009dcbfe,0x00a6d5ff,0x00a7d9fe,0x00aaddfd)\n    R(0x0508,0x00bae9ff,0x00273543,0x00020a1b,0x000a091a)    R(0x0509,0x000d0b1b,0x00070e1f,0x00081327,0x00101930)    R(0x050a,0x00191c35,0x00202232,0x00161d2f,0x00111931)    R(0x050b,0x000e132c,0x00060b25,0x00010234,0x00a0baf3)    R(0x050c,0x008bb1fb,0x0095befc,0x0098c1fa,0x009bc6fa)    R(0x050d,0x009cc8f8,0x009cc9f5,0x009cc9f5,0x009cc8f7)    R(0x050e,0x009cc8f7,0x009cc7f8,0x009bc6f7,0x0099c4f7)    R(0x050f,0x0098c2f7,0x0096c0f5,0x0093bdf3,0x0091baf1)\n    R(0x0510,0x008fb8ef,0x008bb3f0,0x0087aff0,0x0082aaeb)    R(0x0511,0x007da2e6,0x00789de1,0x007395dc,0x006e8fd8)    R(0x0512,0x006a8ad3,0x006784cd,0x006583c4,0x005d7dbf)    R(0x0513,0x005a7ebe,0x005b7db9,0x006580b1,0x00425173)    R(0x0514,0x0000000a,0x0003060b,0x00000005,0x0000010b)    R(0x0515,0x0000010b,0x0000020d,0x00040813,0x00020614)    R(0x0516,0x00000512,0x00000410,0x00090506,0x000c0a11)    R(0x0517,0x0000000a,0x004d5f81,0x005e75a5,0x005b76ae)\n    R(0x0518,0x005d7ab7,0x006480c0,0x005c78b4,0x005d7ab3)    R(0x0519,0x005773ac,0x005870aa,0x00536ca4,0x0050689f)    R(0x051a,0x004d669c,0x004e669c,0x0046609d,0x00536eac)    R(0x051b,0x005b73a0,0x00637693,0x00edfcfe,0x00f8ffff)    R(0x051c,0x00fcfcf8,0x00fffeff,0x00fffdff,0x00ffffff)    R(0x051d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x051e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x051f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0520,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0521,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0522,0x00fdffff,0x00fdffff,0x00fffffc,0x00fffffb)    R(0x0523,0x00fdfefa,0x00faffff,0x00f4fcff,0x00e4f1ff)    R(0x0524,0x00abcdec,0x00a9d8fe,0x00b3e6ff,0x00b6f0ff)    R(0x0525,0x00baf8fe,0x00b7f7f7,0x00b6f2fc,0x00ace3fe)    R(0x0526,0x00a2d1fb,0x009fcaff,0x0099c5fb,0x0098c4f9)    R(0x0527,0x00a5d3ff,0x00a6d6ff,0x00a8dafe,0x00abdffd)\n    R(0x0528,0x00bbeaff,0x0017202a,0x00000617,0x000a081b)    R(0x0529,0x000e0e22,0x000a1325,0x000b192c,0x00121c30)    R(0x052a,0x00171b31,0x00121222,0x0013162a,0x00090e27)    R(0x052b,0x00070d24,0x00040c25,0x00192641,0x00adcbff)    R(0x052c,0x008ebcff,0x009ac6ff,0x00a0cbfc,0x00a3cffc)    R(0x052d,0x00a4d1fb,0x00a2d1f6,0x00a2d1f6,0x00a2d0f7)    R(0x052e,0x00a2cff9,0x00a2cffa,0x00a1cef9,0x009fccf8)    R(0x052f,0x009ecaf8,0x009bc7f6,0x009ac5f6,0x0098c3f4)\n    R(0x0530,0x0095c0f1,0x0092bcf4,0x008cb7f5,0x0089b1f0)    R(0x0531,0x0082aaea,0x0080a5e7,0x00799ee2,0x007597dd)    R(0x0532,0x007192db,0x006b8bd4,0x006a86cc,0x005f82c2)    R(0x0533,0x005b82c0,0x005b7fbb,0x00617db6,0x00576794)    R(0x0534,0x00000012,0x00000109,0x00000108,0x00000008)    R(0x0535,0x00050712,0x00010510,0x00050916,0x00010814)    R(0x0536,0x00000514,0x00000412,0x00080609,0x00070710)    R(0x0537,0x0000000d,0x00415172,0x005c73a1,0x005a76ac)\n    R(0x0538,0x00617fba,0x006382c1,0x005d7ab6,0x005e7ab3)    R(0x0539,0x00546fa7,0x00546da5,0x004d659c,0x004b6399)    R(0x053a,0x004a6196,0x004b6195,0x0047629a,0x004866a2)    R(0x053b,0x00546da5,0x00526894,0x009fb0c6,0x00f2ffff)    R(0x053c,0x00f6fbfa,0x00fffdff,0x00fffdff,0x00ffffff)    R(0x053d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x053e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x053f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0540,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0541,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0542,0x00fdffff,0x00fffffe,0x00fffffc,0x00fffffc)    R(0x0543,0x00fcffff,0x00f4fcff,0x00edfdff,0x00bfd5ed)    R(0x0544,0x00abd6f3,0x00ade2ff,0x00b5eaff,0x00b9efff)    R(0x0545,0x00bdf7ff,0x00c0feff,0x00b4f0fb,0x00ace4fe)    R(0x0546,0x009ccef7,0x00aed9ff,0x0093bef1,0x00a3ceff)    R(0x0547,0x00a2cffd,0x00a9d7ff,0x00aadbfc,0x00aee0fc)\n    R(0x0548,0x00beebff,0x000f1a25,0x00050f21,0x000a0b20)    R(0x0549,0x000a0e22,0x000e172b,0x000f1d2f,0x00101b2d)    R(0x054a,0x00101427,0x00121022,0x00020217,0x0001061e)    R(0x054b,0x00090f25,0x00091429,0x002e3d54,0x00a0c5f3)    R(0x054c,0x0099cbff,0x00a0ceff,0x00a6d3ff,0x00a9d7fe)    R(0x054d,0x00aad9fc,0x00a7d7f8,0x00a7d7f8,0x00a7d7f8)    R(0x054e,0x00a7d7f9,0x00a6d6fa,0x00a5d4fa,0x00a4d3f9)    R(0x054f,0x00a2d0f9,0x00a0cef7,0x009fccf7,0x009dcaf6)\n    R(0x0550,0x009bc7f4,0x0096c3f5,0x0091bff5,0x008ebaf4)    R(0x0551,0x008ab3ef,0x0086aeed,0x0082a8e9,0x007ba0e4)    R(0x0552,0x00789ae0,0x007292db,0x006c8ad4,0x006185c5)    R(0x0553,0x005b83bd,0x00597ebc,0x00637fbf,0x006171a5)    R(0x0554,0x00000002,0x00020a12,0x0002050e,0x0001030d)    R(0x0555,0x0000010c,0x000a0d1a,0x00030a16,0x00020918)    R(0x0556,0x00000615,0x00000614,0x0004060d,0x0000030e)    R(0x0557,0x00000317,0x00334464,0x0059709d,0x005b77ad)\n    R(0x0558,0x006886c1,0x006283c1,0x005b78b4,0x00607bb3)    R(0x0559,0x005b75ad,0x005b73aa,0x00465e94,0x00445b90)    R(0x055a,0x0043598d,0x00445a8e,0x00435e8f,0x00446095)    R(0x055b,0x004e66a5,0x005b6fad,0x005e729c,0x00d4e7f3)    R(0x055c,0x00f3fefe,0x00feffff,0x00fffdfe,0x00ffffff)    R(0x055d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x055e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x055f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0560,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0561,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0562,0x00fdffff,0x00fffffe,0x00fffffc,0x00fffffe)    R(0x0563,0x00fbffff,0x00eefcff,0x00d9eeff,0x00aac8ea)    R(0x0564,0x00b0e1f9,0x00b1e9fe,0x00b8edff,0x00bef0ff)    R(0x0565,0x00bff6ff,0x00c1fdff,0x00b7f2fe,0x00b5eeff)    R(0x0566,0x0092c4eb,0x00213b65,0x006d97c7,0x009ac5f6)    R(0x0567,0x00aad6ff,0x00aad8ff,0x00acdcfc,0x00aee1fb)\n    R(0x0568,0x00bfebff,0x00111925,0x00010b1f,0x00090d25)    R(0x0569,0x000d1327,0x000d1a2d,0x00091929,0x00081423)    R(0x056a,0x00090e1d,0x000b071a,0x000b0a1f,0x0000000a)    R(0x056b,0x00000000,0x00000000,0x00233d55,0x00a3ccf2)    R(0x056c,0x0092ccff,0x00a5d5ff,0x00abd8ff,0x00addeff)    R(0x056d,0x00aedfff,0x00addffc,0x00addffc,0x00addffc)    R(0x056e,0x00addffd,0x00acdcfe,0x00abdbfd,0x00a9d8fc)    R(0x056f,0x00a8d8fc,0x00a7d6fc,0x00a5d4fa,0x00a3d1fa)\n    R(0x0570,0x00a1cff8,0x009dccf8,0x0098c7fa,0x0095c3f8)    R(0x0571,0x0090bdf4,0x008fb8f4,0x0089b1f0,0x0084aaea)    R(0x0572,0x0080a3e5,0x007a9ae3,0x007490dd,0x00678bcc)    R(0x0573,0x005f87c1,0x005c81bf,0x006782c4,0x0054659c)    R(0x0574,0x00000000,0x00000000,0x00000000,0x0001030a)    R(0x0575,0x000b0f1a,0x00050a17,0x00060c19,0x00020919)    R(0x0576,0x00010819,0x00000717,0x00000411,0x00000311)    R(0x0577,0x0000041a,0x002f4263,0x005a719e,0x005c78ae)\n    R(0x0578,0x006f8dc7,0x006081c0,0x005f7ab4,0x006a83bb)    R(0x0579,0x00122457,0x001e346a,0x00435b91,0x003f568a)    R(0x057a,0x003e5588,0x00405689,0x00435e88,0x0042608e)    R(0x057b,0x00475fa1,0x005164ab,0x005669a2,0x0097abc1)    R(0x057c,0x00f2ffff,0x00f7fffc,0x00fbfbfb,0x00ffffff)    R(0x057d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x057e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x057f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0580,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0581,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0582,0x00fffdff,0x00fffeff,0x00fffffb,0x00fffffc)    R(0x0583,0x00fdfcff,0x00f0fbff,0x00b6d3ee,0x00aadbfa)    R(0x0584,0x00b1e8fe,0x00b4ecff,0x00b7efff,0x00bbf6ff)    R(0x0585,0x00bdf9ff,0x00bef7fd,0x00bbf1fd,0x00c1f3ff)    R(0x0586,0x0026517a,0x00002259,0x004e70a3,0x009bc8fe)    R(0x0587,0x00a3d6fe,0x00a3ddf6,0x00a8e2f4,0x00ade3fa)\n    R(0x0588,0x00bbe9ff,0x00192029,0x00000416,0x00120f24)    R(0x0589,0x00111024,0x000b1327,0x00011124,0x00011526)    R(0x058a,0x00000000,0x00000000,0x0000002f,0x00a0c1d0)    R(0x058b,0x00c4e4ec,0x00c3e7f8,0x00bbe8fd,0x009dcef3)    R(0x058c,0x00a2d2fe,0x00acdbfb,0x00b1e2fe,0x00b6e3ff)    R(0x058d,0x00bbe5ff,0x00bbe6fe,0x00b8e8fe,0x00b4e8fe)    R(0x058e,0x00b0e9fd,0x00b1e6fc,0x00b1e3fc,0x00afe0fc)    R(0x058f,0x00acddfc,0x00abdcfc,0x00aadbfe,0x00a7d8fe)\n    R(0x0590,0x00a5d6fd,0x00a3d3fc,0x00a0cefb,0x009bcafa)    R(0x0591,0x0097c5f7,0x0094c0f6,0x008cb8f2,0x0087b2f0)    R(0x0592,0x0081abeb,0x007ca3e5,0x007a9ae0,0x006e92d1)    R(0x0593,0x00658ac8,0x005e83c2,0x00688acb,0x005a78b4)    R(0x0594,0x007d9dce,0x009cbfe6,0x0097b1dc,0x004d658c)    R(0x0595,0x00000000,0x00000000,0x00000817,0x00080f1b)    R(0x0596,0x0003050e,0x00100e16,0x00040314,0x00000315)    R(0x0597,0x00000215,0x002f4462,0x00556f9d,0x00637fbb)\n    R(0x0598,0x00728fd1,0x00617fc1,0x00607bb4,0x006c87bb)    R(0x0599,0x0000043b,0x00010e3e,0x00354877,0x00405484)    R(0x059a,0x00415787,0x003b5283,0x00405a8b,0x00425d90)    R(0x059b,0x004b619c,0x004e62a3,0x00546ba6,0x00566c97)    R(0x059c,0x00ebf6ff,0x00f6f6fd,0x00fff9f6,0x00ffffff)    R(0x059d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x059e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x059f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x05a0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x05a1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x05a2,0x00fffcff,0x00fffeff,0x00fffffa,0x00fffffc)    R(0x05a3,0x00f9f9ff,0x00ebf4ff,0x00abcdea,0x00a4dffb)    R(0x05a4,0x00afe8ff,0x00b4ebff,0x00b4eefd,0x00b6f4fe)    R(0x05a5,0x00b6f4fd,0x00b4eefc,0x00bbedff,0x00a5d1eb)    R(0x05a6,0x00000536,0x00002366,0x0027458a,0x009dc8ff)    R(0x05a7,0x009dd1ff,0x00a0ddf8,0x00a7e3f5,0x00aae1fc)\n    R(0x05a8,0x00b8e5ff,0x00212e36,0x00040f1c,0x00120e1f)    R(0x05a9,0x00141023,0x00040d20,0x00000012,0x00000000)    R(0x05aa,0x007891a4,0x00b7daeb,0x00c2effb,0x00bff1fd)    R(0x05ab,0x00bef1fd,0x00bdf0ff,0x00b3ecff,0x0099d0f5)    R(0x05ac,0x00a2d1fe,0x00aaddfc,0x00b2e4fe,0x00b8e8fe)    R(0x05ad,0x00beebfd,0x00c1ecfc,0x00bfeefd,0x00baeffe)    R(0x05ae,0x00b5f0fd,0x00b8eefe,0x00b9ebfe,0x00b6e8fd)    R(0x05af,0x00b3e5fd,0x00b2e3fe,0x00aee0fe,0x00acddfe)\n    R(0x05b0,0x00a9dafd,0x00a8d7fd,0x00a5d3fc,0x00a1cefa)    R(0x05b1,0x009ccaf9,0x0099c6fa,0x0092c0f7,0x008db9f4)    R(0x05b2,0x0087b3f1,0x0080abea,0x007da0e2,0x007095d7)    R(0x05b3,0x00678acf,0x006083c7,0x005579b7,0x0088ade8)    R(0x05b4,0x009cc5fb,0x0099c7f9,0x009ac2fb,0x008eb5ea)    R(0x05b5,0x009bbeec,0x0087a3c8,0x001b334d,0x00000000)    R(0x05b6,0x00040715,0x000b0f1b,0x00090717,0x0000000f)    R(0x05b7,0x00000214,0x00425979,0x004c669c,0x00758fd4)\n    R(0x05b8,0x006d89d0,0x006280c1,0x005c77b1,0x004c639b)    R(0x05b9,0x00001246,0x00001041,0x001e2f5e,0x00445788)    R(0x05ba,0x003e5287,0x003d5188,0x003c538d,0x00415a92)    R(0x05bb,0x004b6298,0x004d649c,0x004d66a2,0x005c6fa7)    R(0x05bc,0x00a5afcd,0x00fbf7fe,0x00fffffe,0x00ffffff)    R(0x05bd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x05be,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x05bf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x05c0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x05c1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x05c2,0x00fffcff,0x00fffeff,0x00fffffb,0x00fffffd)    R(0x05c3,0x00f8fbff,0x00d6e5fc,0x00aed1f1,0x00a9e3ff)    R(0x05c4,0x00b0e7ff,0x00b2e7ff,0x00b0eafe,0x00b2eeff)    R(0x05c5,0x00b3efff,0x00b2e9fd,0x00b1e2ff,0x008eb5d6)    R(0x05c6,0x00001a54,0x0002216f,0x0002257c,0x0091b8ff)    R(0x05c7,0x0099c8ff,0x00a3d8ff,0x00a8e0fc,0x00aadfff)\n    R(0x05c8,0x00b4e1ff,0x003c5760,0x00051420,0x000b0c1c)    R(0x05c9,0x00111827,0x00000000,0x00415c6b,0x00bde3f0)    R(0x05ca,0x00c1e7f4,0x00baecfd,0x00c6f8fd,0x00c1f3fc)    R(0x05cb,0x00bff3f9,0x00b3e8f2,0x00b6eafe,0x009ccff5)    R(0x05cc,0x0099cdf9,0x00a5dbff,0x00afe4ff,0x00b5eaff)    R(0x05cd,0x00bdf1fd,0x00c0f5fb,0x00c3f7fc,0x00c4f8ff)    R(0x05ce,0x00c0f6ff,0x00c1f4ff,0x00c2f2ff,0x00c0f0ff)    R(0x05cf,0x00bbecfe,0x00b8eaff,0x00b6e6ff,0x00b2e4ff)\n    R(0x05d0,0x00afdffd,0x00aedcfe,0x00abd9fe,0x00a6d4fd)    R(0x05d1,0x00a1cffc,0x009ecbfc,0x0096c5f9,0x0092bff9)    R(0x05d2,0x008cbaf5,0x0086b1f0,0x0084a5eb,0x007397e1)    R(0x05d3,0x00668dd7,0x006286cb,0x005476ad,0x00adcdf6)    R(0x05d4,0x00afd2fb,0x00aad4fc,0x00aad7fe,0x009fcafb)    R(0x05d5,0x0096c0f5,0x0092b6ed,0x0097b6ea,0x007f98c3)    R(0x05d6,0x00000000,0x00000223,0x00070b1c,0x00020615)    R(0x05d7,0x0000000e,0x005a709b,0x006983c3,0x007d98e1)\n    R(0x05d8,0x006784cb,0x006283c0,0x005b77b0,0x0024356a)    R(0x05d9,0x00051851,0x00021249,0x00020d47,0x0043548d)    R(0x05da,0x003a4b89,0x003c508f,0x00364e8a,0x003f5890)    R(0x05db,0x004a6197,0x004e629c,0x004e65a0,0x00546aa0)    R(0x05dc,0x00717ca3,0x00ffffff,0x00fffcfe,0x00ffffff)    R(0x05dd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x05de,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x05df,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x05e0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x05e1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x05e2,0x00fefdff,0x00fffeff,0x00fffffc,0x00fffeff)    R(0x05e3,0x00f5fcff,0x00bdd4f0,0x00b2d9fc,0x00b0e6ff)    R(0x05e4,0x00aee3ff,0x00aee1ff,0x00ace1fe,0x00ace3fe)    R(0x05e5,0x00ade5fe,0x00b2e6ff,0x00b5e2ff,0x006387b1)    R(0x05e6,0x00002060,0x00082377,0x000a297f,0x006687d2)    R(0x05e7,0x0099c3ff,0x00a1d3ff,0x00a8ddff,0x00abe0ff)\n    R(0x05e8,0x00b4e3ff,0x0083a8b1,0x0000010c,0x000a1a27)    R(0x05e9,0x00000000,0x0088a4b2,0x00c4f0f8,0x00b5e6f2)    R(0x05ea,0x00c0f2fe,0x00b6f3ff,0x00c8f7fc,0x00c5eef2)    R(0x05eb,0x00c2efee,0x00ccf6f9,0x00d5f6ff,0x00c2e4fc)    R(0x05ec,0x00a1cff6,0x00a2d7ff,0x00a8e0ff,0x00b0ebff)    R(0x05ed,0x00b9f5fd,0x00c0fbfb,0x00c5fefb,0x00c9ffff)    R(0x05ee,0x00cbfdff,0x00c9faff,0x00c8f8ff,0x00c6f5ff)    R(0x05ef,0x00c2f3fe,0x00c1f1ff,0x00bdefff,0x00bae9ff)\n    R(0x05f0,0x00b4e6fd,0x00b1e2fe,0x00addeff,0x00a9dafd)    R(0x05f1,0x00a4d5fc,0x00a1d1fd,0x0099c8fb,0x0095c3f9)    R(0x05f2,0x0090bff7,0x008ab5f4,0x0088a8f2,0x007399e8)    R(0x05f3,0x00668ddc,0x006687c7,0x006f88b4,0x00bad0eb)    R(0x05f4,0x00bfdaf1,0x00b9dbf4,0x00b4dff9,0x00b0daff)    R(0x05f5,0x00a0c9fa,0x009dc2fd,0x008fb3fa,0x008eb1f1)    R(0x05f6,0x0086a7dc,0x00254069,0x00000518,0x0000081b)    R(0x05f7,0x00131c35,0x008296cd,0x00839be6,0x00758fe1)\n    R(0x05f8,0x006887cc,0x005d80b5,0x005771a7,0x000a184a)    R(0x05f9,0x000d2055,0x000d1b52,0x0000043e,0x003c4b85)    R(0x05fa,0x003e4e8d,0x003a4d8e,0x00334b89,0x003b558d)    R(0x05fb,0x004a6197,0x004d629a,0x004d649e,0x004c639b)    R(0x05fc,0x0062709b,0x00dcdff2,0x00fcfafe,0x00ffffff)    R(0x05fd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x05fe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x05ff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0600,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0601,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0602,0x00fcfdff,0x00fffdfe,0x00fffefe,0x00fafbfe)    R(0x0603,0x00ebf8ff,0x00abcbea,0x00b1dfff,0x00b4e7ff)    R(0x0604,0x00acdbff,0x00abdaff,0x00a5d7fe,0x00a3d8fd)    R(0x0605,0x00a7dbfe,0x00a6d5fd,0x00acd6ff,0x00375a91)    R(0x0606,0x00052767,0x00051f6d,0x0016327d,0x00355091)    R(0x0607,0x00a7ceff,0x009ecbfd,0x00a7dbfe,0x00a2d8f4)\n    R(0x0608,0x00b4ebfe,0x00c3eff9,0x0000000b,0x00000000)    R(0x0609,0x00a0bbc9,0x00bee9f5,0x00bcf0fb,0x00bcf6fe)    R(0x060a,0x00bff9ff,0x00bbf5ff,0x00d0eefc,0x00e5f8fa)    R(0x060b,0x00e5fefd,0x00ecfffd,0x00fafbfd,0x00f7f9ff)    R(0x060c,0x00c3d7e9,0x00a8d5ff,0x00a9dfff,0x00afeaff)    R(0x060d,0x00b7f6fe,0x00befdfc,0x00c4fffc,0x00c9ffff)    R(0x060e,0x00cffdff,0x00ccfcff,0x00ccfdff,0x00ccfbff)    R(0x060f,0x00c8f9ff,0x00c5f6ff,0x00c2f2ff,0x00beeeff)\n    R(0x0610,0x00b9eafd,0x00b4e6fe,0x00afe1ff,0x00abddfd)    R(0x0611,0x00a6d7fd,0x00a3d2fe,0x009bcafe,0x0098c7fd)    R(0x0612,0x0093c2fb,0x008db8f7,0x0086a7f3,0x007a9ff0)    R(0x0613,0x00678ad5,0x00748bbe,0x00cbd0e0,0x00cdd1d4)    R(0x0614,0x00cedbe0,0x00bbd4de,0x00b3d2d8,0x00b9daec)    R(0x0615,0x00b7d9ff,0x00a4c8ff,0x009abeff,0x0090b5fa)    R(0x0616,0x008fb3f2,0x008cafe4,0x00303d50,0x0006132d)    R(0x0617,0x00304066,0x008aa0e1,0x008298ec,0x00748ee2)\n    R(0x0618,0x006482c4,0x005e82af,0x004f6a94,0x00000530)    R(0x0619,0x000c1e48,0x00162651,0x00000a3a,0x003c4e7f)    R(0x061a,0x003f538b,0x003b4f8b,0x00314a86,0x0039538b)    R(0x061b,0x004a6196,0x004f639b,0x004b639e,0x004d659f)    R(0x061c,0x00596d99,0x009fa7bf,0x00f9fbff,0x00ffffff)    R(0x061d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x061e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x061f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0620,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0621,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0622,0x00fdfeff,0x00fffdfe,0x00fffdff,0x00fafbff)    R(0x0623,0x00d1e7fb,0x00a1ccee,0x00abdeff,0x00b2e2ff)    R(0x0624,0x00a7d3ff,0x00a5d1ff,0x009dcdfd,0x009acbfb)    R(0x0625,0x009cccfd,0x009ec9fd,0x00a3c8ff,0x00194080)    R(0x0626,0x00072769,0x000a2569,0x00072462,0x0007103c)    R(0x0627,0x00436090,0x00a7cfff,0x00a7d6fe,0x00b8effe)\n    R(0x0628,0x00ade9f7,0x00b1e3f1,0x0020404c,0x007897a7)    R(0x0629,0x00bde4f2,0x00baedf9,0x00b5f1fc,0x00baf8ff)    R(0x062a,0x00befaff,0x00bef1fc,0x00eaf3ff,0x00fdfcff)    R(0x062b,0x00f5fffd,0x00fcfbf3,0x00fffff6,0x00e9cabe)    R(0x062c,0x00949085,0x00b7d7f3,0x00aad7fa,0x00afe3fd)    R(0x062d,0x00b3effe,0x00b7f7fe,0x00bef9fe,0x00c6fcff)    R(0x062e,0x00ccfcff,0x00cbfbff,0x00cbfdff,0x00cbfcff)    R(0x062f,0x00c9f9ff,0x00c5f6ff,0x00c0f2ff,0x00beefff)\n    R(0x0630,0x00b9ecff,0x00b5e7ff,0x00b0e2ff,0x00acddfe)    R(0x0631,0x00a7d8fe,0x00a4d3ff,0x009ccaff,0x0098c4ff)    R(0x0632,0x0092bffd,0x008bb5f7,0x0083a5f3,0x007497e6)    R(0x0633,0x007690cf,0x008f90aa,0x006e625f,0x00eedabe)    R(0x0634,0x00d8d5c7,0x00c5d5d7,0x00c6d5cc,0x00baced3)    R(0x0635,0x00b9d3ee,0x00afd0ff,0x009fc2fe,0x008eb2f4)    R(0x0636,0x008aaeee,0x008eb0ec,0x009db2dd,0x00000000)    R(0x0637,0x00809bcf,0x0088a5ea,0x00809bee,0x00728dde)\n    R(0x0638,0x00617ebd,0x005775a1,0x00233c5d,0x0000001c)    R(0x0639,0x00010928,0x00061738,0x00000f35,0x003f517b)    R(0x063a,0x003e5586,0x003b548b,0x00314c85,0x0038538b)    R(0x063b,0x004b6095,0x0050649c,0x004c639e,0x00445e98)    R(0x063c,0x00506797,0x007785a4,0x00f6fdff,0x00ffffff)    R(0x063d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x063e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x063f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0640,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0641,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0642,0x00fdffff,0x00fffdfe,0x00fffdff,0x00fbfcff)    R(0x0643,0x00b8d4eb,0x009dd0f6,0x00a5ddff,0x00aedaff)    R(0x0644,0x00a5cefe,0x009fc9ff,0x0095c2fc,0x008fbdf7)    R(0x0645,0x008fbcf8,0x0091b9fa,0x0093b7fb,0x00022e77)    R(0x0646,0x00082468,0x00072262,0x00000f46,0x00021a4e)    R(0x0647,0x00001656,0x005270a5,0x00a9d4ff,0x009fd5f4)\n    R(0x0648,0x00a6e3f6,0x00b6effd,0x00a4d2e8,0x00bde4f7)    R(0x0649,0x00c1edfd,0x00b6ecfc,0x00b2effc,0x00b8f4ff)    R(0x064a,0x00bbf0fd,0x00c5eff4,0x00fbfaff,0x00fffaff)    R(0x064b,0x00fafffd,0x00fffeee,0x00fbeed3,0x00ae6a42)    R(0x064c,0x00a9813f,0x00afbec5,0x00c0e0fa,0x00b3ddf8)    R(0x064d,0x00aadffc,0x00b0ecff,0x00b5f0ff,0x00c0f6ff)    R(0x064e,0x00c5f7ff,0x00c6faff,0x00c8faff,0x00c6f9ff)    R(0x064f,0x00c4f7ff,0x00c0f3ff,0x00bef0ff,0x00baedff)\n    R(0x0650,0x00b8ebff,0x00b4e6ff,0x00afe1ff,0x00abddfe)    R(0x0651,0x00a6d7ff,0x00a3d2ff,0x009dcbff,0x0098c4ff)    R(0x0652,0x0091bdfd,0x0088b2f7,0x0085acf7,0x006d90d7)    R(0x0653,0x008f9eca,0x006e5e60,0x00976732,0x00a47c4f)    R(0x0654,0x00efddc1,0x00cbd5d3,0x00d2d6cc,0x00bfc8c9)    R(0x0655,0x00b7cbdd,0x00b7d6f8,0x009ec4f6,0x008cb0ee)    R(0x0656,0x0082a5e6,0x0081a1e3,0x0088a2df,0x007b96d0)    R(0x0657,0x0081a2df,0x007798de,0x006b89d6,0x006882cd)\n    R(0x0658,0x006077b3,0x001f345b,0x00010f2b,0x0002132c)    R(0x0659,0x00000b27,0x00000826,0x00000e33,0x00394b75)    R(0x065a,0x003c5485,0x003b548c,0x00314c88,0x0038538b)    R(0x065b,0x004b6096,0x0051659a,0x004d649f,0x0046629f)    R(0x065c,0x00486195,0x0063749d,0x00f3feff,0x00ffffff)    R(0x065d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x065e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x065f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0660,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0661,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0662,0x00fdffff,0x00fffeff,0x00fffdff,0x00f7f8ff)    R(0x0663,0x00accde9,0x0098d3f9,0x009dd8ff,0x00abd7ff)    R(0x0664,0x00a4cafe,0x009dc5ff,0x008eb8f6,0x0082adee)    R(0x0665,0x0082acf1,0x007fa4ed,0x0083a5ef,0x00002774)    R(0x0666,0x0009246c,0x00071f61,0x00021951,0x000a235c)    R(0x0667,0x00041b60,0x00001665,0x008fb4f5,0x00a1d4fe)\n    R(0x0668,0x009edcf7,0x009ad7ef,0x00b5e6fe,0x00c1ecff)    R(0x0669,0x00bdecff,0x00b3ecff,0x00b1ecfe,0x00bbf1ff)    R(0x066a,0x00b8e6f6,0x00cbf7f4,0x00fffcff,0x00fff8ff)    R(0x066b,0x00f3fffb,0x00fffff0,0x00d4946c,0x00f18f42)    R(0x066c,0x00bc851a,0x00535953,0x009aafc0,0x00b2d4f4)    R(0x066d,0x00b3e2ff,0x00aadfff,0x00ace4ff,0x00b6ecff)    R(0x066e,0x00bcf2fb,0x00bcf2fb,0x00bdf2fc,0x00bdf1fd)    R(0x066f,0x00bbeffe,0x00b8ebfe,0x00b6e9ff,0x00b3e7ff)\n    R(0x0670,0x00b2e4ff,0x00b0e2fe,0x00addefc,0x00a9d9fb)    R(0x0671,0x00a4d3fc,0x00a1cfff,0x009ac7ff,0x0095befe)    R(0x0672,0x008cb6fa,0x007faaf4,0x006391de,0x0080a2e3)    R(0x0673,0x00464d68,0x00875d3c,0x00ae671c,0x00b06f20)    R(0x0674,0x00e2caa9,0x00ced3d4,0x00d3d0d1,0x00c4cbd2)    R(0x0675,0x00b2c8d9,0x00b3d8f4,0x009bc6f1,0x0088b2ec)    R(0x0676,0x007da1e7,0x007796e5,0x007290e1,0x006486d0)    R(0x0677,0x006e96d8,0x006088c9,0x006082c7,0x005973b8)\n    R(0x0678,0x00394c86,0x00000b38,0x00041634,0x00041633)    R(0x0679,0x00021131,0x0000092d,0x00000c36,0x00324172)    R(0x067a,0x003b4e89,0x00374d8d,0x002f4b89,0x0037538b)    R(0x067b,0x004b6096,0x0051659a,0x004b629d,0x004864a4)    R(0x067c,0x00456097,0x00566b97,0x00dbe7fc,0x00ffffff)    R(0x067d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x067e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x067f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0680,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0681,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0682,0x00fbfeff,0x00fefdfd,0x00fffdfe,0x00f3f6ff)    R(0x0683,0x00a9cdeb,0x0094cefa,0x0099d2fe,0x00a9d5fe)    R(0x0684,0x00a3cbfd,0x0097c2fe,0x0085aff3,0x0077a0ea)    R(0x0685,0x00779feb,0x007398e4,0x007394e0,0x00002375)    R(0x0686,0x0008236d,0x00031c5c,0x00041e5a,0x00021d5c)    R(0x0687,0x0007206d,0x000d267d,0x005373bc,0x0092bff6)\n    R(0x0688,0x009ed4f9,0x00a6e1fc,0x00a2d6f6,0x00b3e2fd)    R(0x0689,0x00b5e7fd,0x00b6ecff,0x00b4ecff,0x00bbeeff)    R(0x068a,0x00b2dff1,0x00ddfef6,0x00fffaff,0x00fffbff)    R(0x068b,0x00f1fffa,0x00f9f2dc,0x00c98228,0x00ea9f36)    R(0x068c,0x00bf8c33,0x00000000,0x00364349,0x00a7abc3)    R(0x068d,0x00bad3fc,0x009bd5f9,0x009ad9ff,0x00a6e0ff)    R(0x068e,0x00b0e5fe,0x00b6e7fd,0x00b6e8fe,0x00b6e8ff)    R(0x068f,0x00b4e6ff,0x00b1e3ff,0x00afe1ff,0x00acdfff)\n    R(0x0690,0x00aaddff,0x00a8ddfd,0x00a9d7fe,0x00a8d1fe)    R(0x0691,0x009dcfff,0x0095c6ff,0x0092bdff,0x0087b7fe)    R(0x0692,0x0080acfb,0x0080a0eb,0x00859dd6,0x00394d77)    R(0x0693,0x000b0008,0x00452714,0x00bd7933,0x00cb7f27)    R(0x0694,0x00b98e5c,0x00d4d4d8,0x00d0ced2,0x00c5cad1)    R(0x0695,0x00b2c5d1,0x00b6d8ef,0x009dc8f1,0x0086b3ed)    R(0x0696,0x007ba2e9,0x007495e4,0x006e8ee1,0x006184d2)    R(0x0697,0x00597fc3,0x005b82c2,0x00597abb,0x005a74b5)\n    R(0x0698,0x0011245c,0x00031446,0x00091d48,0x0001143c)    R(0x0699,0x00001137,0x00000f34,0x00000b37,0x00314074)    R(0x069a,0x00364886,0x0035488e,0x002f478a,0x0038538d)    R(0x069b,0x004a6196,0x00516799,0x004d649b,0x004c65a2)    R(0x069c,0x0049659c,0x00546d9a,0x00c0cfea,0x00ffffff)    R(0x069d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x069e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x069f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x06a0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x06a1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x06a2,0x00f9fcff,0x00fcfdfb,0x00fefffc,0x00f0fcff)    R(0x06a3,0x00a4c7ec,0x0092c6fc,0x0097ccff,0x00a4d0fa)    R(0x06a4,0x009fcafb,0x0092bffe,0x0083aefa,0x006f98ec)    R(0x06a5,0x005f85d7,0x00557ac6,0x006f90dc,0x00153483)    R(0x06a6,0x0005206a,0x00011d58,0x0001205d,0x00002165)    R(0x06a7,0x00011f70,0x0008287e,0x002b4b96,0x0097c2fd)\n    R(0x06a8,0x009fcffa,0x00a5d8ff,0x00a7dafd,0x00b0e3ff)    R(0x06a9,0x00b1e9fd,0x00b7edff,0x00baeeff,0x00baebff)    R(0x06aa,0x00afddf2,0x00f0fff8,0x00fffbff,0x00f9ffff)    R(0x06ab,0x00f6fff9,0x00f0d9b5,0x00ebaf36,0x00d5b434)    R(0x06ac,0x0068451b,0x0031140a,0x00450000,0x006b4651)    R(0x06ad,0x00746c8e,0x00a8cfe1,0x00a5d8fd,0x0098cffe)    R(0x06ae,0x00a9d4fe,0x00aad5fd,0x00abd7ff,0x00add8ff)    R(0x06af,0x00a8d5fe,0x00a5d2fe,0x00a5d3ff,0x00a3d2ff)\n    R(0x06b0,0x00a1d1fe,0x009cd3fb,0x009fcbfd,0x00a1c2fe)    R(0x06b1,0x008fc5fd,0x0089baff,0x008db3fd,0x0080b0f0)    R(0x06b2,0x008cadfc,0x008b8dca,0x00514c68,0x00190000)    R(0x06b3,0x00300400,0x00190000,0x00916934,0x00db922b)    R(0x06b4,0x00af6c09,0x00dbd1d2,0x00cecfd0,0x00c6caca)    R(0x06b5,0x00bec7cb,0x00bdd3e9,0x00a5c9f4,0x0088b2f0)    R(0x06b6,0x007da4e8,0x007698dd,0x006c8ed9,0x006688ce)    R(0x06b7,0x00607fc4,0x005f7cbd,0x005774b1,0x005872af)\n    R(0x06b8,0x0001104a,0x00011954,0x00061c53,0x00001647)    R(0x06b9,0x0000123b,0x00001135,0x00000b32,0x003d527e)    R(0x06ba,0x00374a85,0x00384b90,0x0033498f,0x003d5693)    R(0x06bb,0x004a6397,0x004f6898,0x004e6599,0x004a6099)    R(0x06bc,0x00475f96,0x00546e9f,0x00aabdd8,0x00ffffff)    R(0x06bd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x06be,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x06bf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x06c0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x06c1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x06c2,0x00f7fbfd,0x00fdfdfa,0x00fffffb,0x00edf9ff)    R(0x06c3,0x00a4c4ec,0x0091c1fd,0x0093c4ff,0x00a1cafb)    R(0x06c4,0x009cc8fb,0x0093bfff,0x0088b1ff,0x00759af5)    R(0x06c5,0x00658ae1,0x00567cc9,0x0091b3f4,0x0020418b)    R(0x06c6,0x00021f63,0x00011f59,0x0000225f,0x00012369)    R(0x06c7,0x00002072,0x00062880,0x0021408a,0x009ac4ff)\n    R(0x06c8,0x009ccbf7,0x00a3d4ff,0x00a9dcff,0x00afe4ff)    R(0x06c9,0x00b1e9fd,0x00b6ecfe,0x00bcefff,0x00b8eafe)    R(0x06ca,0x00b1dff7,0x00f3fffe,0x00fffef9,0x00fbfefd)    R(0x06cb,0x00fdfffc,0x00d7ab75,0x00fdc745,0x00d6bf4a)    R(0x06cc,0x00000000,0x00431207,0x007c131f,0x00830000)    R(0x06cd,0x00650020,0x0053656b,0x008492ad,0x00b2cde5)    R(0x06ce,0x00a7cfe5,0x009fc9f1,0x009ec8f8,0x00a0c8fb)    R(0x06cf,0x00a0c9fd,0x009dc7ff,0x009bc4ff,0x0098c2ff)\n    R(0x06d0,0x0094bffd,0x008cc3f8,0x008fbffc,0x0097b8ff)    R(0x06d1,0x0089bdf6,0x008fb5f4,0x0094a8d6,0x007d97b3)    R(0x06d2,0x0045547d,0x0056405f,0x007d0000,0x006d0715)    R(0x06d3,0x00420300,0x00200e00,0x00463a13,0x00dba132)    R(0x06d4,0x00be790c,0x00dfcbc2,0x00cecfd0,0x00c6c9c9)    R(0x06d5,0x00c1c8cd,0x00bbcee4,0x00a8caf6,0x0089b2f0)    R(0x06d6,0x007da4e9,0x007597dd,0x006c8ed5,0x006587cd)    R(0x06d7,0x006281c4,0x005c79ba,0x005571ae,0x005871ad)\n    R(0x06d8,0x00010c45,0x000c235c,0x00081e53,0x00041a4a)    R(0x06d9,0x0000143d,0x00001337,0x00000b31,0x00485e89)    R(0x06da,0x00455a91,0x003e5295,0x003d5298,0x00455c9c)    R(0x06db,0x004a649b,0x004d6799,0x004d659a,0x00485d99)    R(0x06dc,0x00485e98,0x00566fa3,0x00a0b2ce,0x00ffffff)    R(0x06dd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x06de,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x06df,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x06e0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x06e1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x06e2,0x00f8fcfc,0x00fefdf9,0x00fffffb,0x00f0faff)    R(0x06e3,0x00a9c6f0,0x0090bcfd,0x008cbafe,0x009abffc)    R(0x06e4,0x009bc5fd,0x0092bdff,0x008bb1ff,0x0084a7fe)    R(0x06e5,0x007c9ff6,0x0079a0e9,0x00a7cbfe,0x00173d7e)    R(0x06e6,0x0000205d,0x00011e5c,0x00012261,0x0001256c)    R(0x06e7,0x00012276,0x00062981,0x00284a95,0x0096c1fc)\n    R(0x06e8,0x009dccf8,0x00a2d3ff,0x00a7dbff,0x00afe3ff)    R(0x06e9,0x00b0e8fc,0x00b5ebfc,0x00bdf0ff,0x00b6e8fd)    R(0x06ea,0x00b4e2fc,0x00eeffff,0x00fffff2,0x00fefffa)    R(0x06eb,0x00fffffb,0x00c58e31,0x00ffc942,0x00c7b150)    R(0x06ec,0x001a1508,0x004a110a,0x008c151e,0x00ab171b)    R(0x06ed,0x008e0219,0x00460000,0x00432f3d,0x00878a83)    R(0x06ee,0x00a0c4bb,0x00a9d6f2,0x00a0caf7,0x0097c0f3)    R(0x06ef,0x0091bbf1,0x008db8f2,0x008cb6f5,0x008bb4f7)\n    R(0x06f0,0x008bb4fa,0x0081b8f7,0x007fb4f7,0x0088abf6)    R(0x06f1,0x007cabe3,0x0086a1cf,0x00a7a9ac,0x003d464a)    R(0x06f2,0x00120000,0x00540000,0x00b20011,0x008d0715)    R(0x06f3,0x004e0606,0x00140c00,0x00020800,0x00d8a831)    R(0x06f4,0x00d38e1d,0x00ddc2ab,0x00d2d1d1,0x00c7caca)    R(0x06f5,0x00c4cbd0,0x00bacce3,0x00aacbf8,0x008ab3f2)    R(0x06f6,0x007ca3e9,0x007495db,0x006a8cd3,0x006485ca)    R(0x06f7,0x006080c1,0x005a78b8,0x005672af,0x005a72ac)\n    R(0x06f8,0x00010f46,0x000b2055,0x00061c4d,0x00021844)    R(0x06f9,0x0000133a,0x00001437,0x00000b31,0x00485c88)    R(0x06fa,0x0050659b,0x00485d9c,0x00465ba1,0x00475fa1)    R(0x06fb,0x0049639d,0x004a649a,0x0049619a,0x00465b99)    R(0x06fc,0x00495e9a,0x00596fa2,0x00a4b3cf,0x00ffffff)    R(0x06fd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x06fe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x06ff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0700,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0701,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0702,0x00f9fdfe,0x00fdfdf7,0x00fffffa,0x00f4fbff)    R(0x0703,0x00acc4f0,0x008eb7fb,0x0085aef9,0x0090b4f9)    R(0x0704,0x0095bdfa,0x008eb7fc,0x008db2ff,0x0087abff)    R(0x0705,0x007ea4f7,0x0090b7fa,0x00b0d8ff,0x00234a7e)    R(0x0706,0x00002158,0x00011e5f,0x00012365,0x0002256f)    R(0x0707,0x00002479,0x00052a82,0x003d61ad,0x0092bff8)\n    R(0x0708,0x00a1d0fc,0x00a1d2fe,0x00a7dbff,0x00aee3fe)    R(0x0709,0x00b0e8fc,0x00b5ebfc,0x00bcefff,0x00b4e6fb)    R(0x070a,0x00b6e4fd,0x00ebfdff,0x00ffffee,0x00fffff8)    R(0x070b,0x00fffff9,0x00c48b00,0x00ffd246,0x00aa9442)    R(0x070c,0x0015160a,0x00401413,0x00721015,0x008f1916)    R(0x070d,0x00820815,0x00480907,0x001e0000,0x0075662d)    R(0x070e,0x00a4bea2,0x00bceaf9,0x00bcecfe,0x00bef0fb)    R(0x070f,0x00b9e9fa,0x00b5e6fa,0x00b1e0fb,0x00abd9fc)\n    R(0x0710,0x00a4d2fe,0x0096cdfd,0x008cbffd,0x008cb1f9)    R(0x0711,0x0077a3de,0x00849ab9,0x00b5b292,0x00000000)    R(0x0712,0x00280e0a,0x005c0c00,0x009f0009,0x0078020c)    R(0x0713,0x00400206,0x00080704,0x00000000,0x00e3b13d)    R(0x0714,0x00df9425,0x00d6b698,0x00d6d4d5,0x00c9cbce)    R(0x0715,0x00c6cdd3,0x00bacce4,0x00aacafa,0x008ab3f3)    R(0x0716,0x007ca2ea,0x007495dc,0x006b8dd0,0x006385c7)    R(0x0717,0x005e7fc1,0x005877b8,0x005673b0,0x005c75ad)\n    R(0x0718,0x00010f42,0x00021544,0x00031544,0x0000123d)    R(0x0719,0x00001036,0x00001336,0x00000d32,0x00455983)    R(0x071a,0x00536b9d,0x004b649f,0x00465ea1,0x00475ea2)    R(0x071b,0x0048619d,0x0047629a,0x00465f9c,0x00465b9c)    R(0x071c,0x004d609d,0x005e72a2,0x00b2bfd9,0x00ffffff)    R(0x071d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x071e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x071f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0720,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0721,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0722,0x00f9ffff,0x00fcfef7,0x00fffff9,0x00f5f8ff)    R(0x0723,0x00b1c6ef,0x0092b8fb,0x007fa7f3,0x0089abf4)    R(0x0724,0x008bb1f2,0x008bb3f9,0x0084aaf7,0x00759cea)    R(0x0725,0x0084adf1,0x00a3cdff,0x00bae3ff,0x0029507e)    R(0x0726,0x0004255a,0x00031f63,0x00032469,0x0001246f)    R(0x0727,0x00002479,0x00052a83,0x006a92df,0x0094c3fb)\n    R(0x0728,0x009ccdf7,0x00a2d3ff,0x00a8ddff,0x00aee3ff)    R(0x0729,0x00b2eafe,0x00b7edfe,0x00bbeeff,0x00b5e7fb)    R(0x072a,0x00b5e3fc,0x00ebfcff,0x00ffffef,0x00fffff9)    R(0x072b,0x00fffff6,0x00c68c00,0x00ffd144,0x00a08e3a)    R(0x072c,0x00131b0f,0x002c1d22,0x004f211e,0x00491005)    R(0x072d,0x00531211,0x00220d07,0x000f130c,0x0074671d)    R(0x072e,0x00aaba98,0x00beedf1,0x00c1f9fb,0x00c8ffff)    R(0x072f,0x00c6ffff,0x00c4feff,0x00bef6ff,0x00b7edff)\n    R(0x0730,0x00ade2fe,0x00a1d8ff,0x0098c4fe,0x008fb4f8)    R(0x0731,0x0077a2e3,0x00829ab3,0x00c0c48d,0x00000000)    R(0x0732,0x001c080a,0x00420e07,0x005f0705,0x00450307)    R(0x0733,0x002c0910,0x00010007,0x00000000,0x00ecad42)    R(0x0734,0x00e6982e,0x00d4b69a,0x00d8d6d8,0x00cdcfd2)    R(0x0735,0x00c4cad3,0x00bacce6,0x00a9c9f9,0x008ab2f3)    R(0x0736,0x007da3eb,0x007495de,0x006b8dce,0x006385c7)    R(0x0737,0x005d7fc1,0x005979ba,0x005774b1,0x005c76ac)\n    R(0x0738,0x00001242,0x0003113c,0x00010f37,0x00000f36)    R(0x0739,0x00001134,0x00001235,0x00000e33,0x0041567e)    R(0x073a,0x004e6797,0x004d689f,0x004860a0,0x00475da0)    R(0x073b,0x0045609c,0x0044619b,0x00435e9d,0x00475c9d)    R(0x073c,0x005365a0,0x0060719f,0x00cedaf2,0x00ffffff)    R(0x073d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x073e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x073f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0740,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0741,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0742,0x00f8ffff,0x00fdfef9,0x00fffff8,0x00f9fcff)    R(0x0743,0x00b6cbee,0x0097bdfc,0x0081aaf4,0x007ea1e8)    R(0x0744,0x007ba0e4,0x00739adf,0x006890d6,0x0078a4e1)    R(0x0745,0x009ecefb,0x00acdcfd,0x00c7f3ff,0x00133a6e)    R(0x0746,0x0003225b,0x00021f66,0x0002236b,0x00002370)    R(0x0747,0x0001267b,0x00002580,0x0091bbfc,0x009ac9ff)\n    R(0x0748,0x0099ccf5,0x00a1d2fe,0x00a9dcff,0x00ade2fe)    R(0x0749,0x00b2ebff,0x00b9eeff,0x00b9ecff,0x00b7e9fd)    R(0x074a,0x00b2e0f9,0x00ecfeff,0x00fffff6,0x00fffffa)    R(0x074b,0x00fffff4,0x00c68e28,0x00ffd247,0x00b6a748)    R(0x074c,0x001f2514,0x001e1f24,0x002c1f15,0x00000000)    R(0x074d,0x001d0c00,0x0000120a,0x0000160c,0x00938627)    R(0x074e,0x00b0bb97,0x00b9e9ec,0x00bcf6f6,0x00c3fefc)    R(0x074f,0x00c3fffb,0x00c0fefc,0x00baf7fa,0x00b3eefb)\n    R(0x0750,0x00aae4f9,0x00a1d6fa,0x009dc2fa,0x008eb2f5)    R(0x0751,0x0076a0e8,0x00809bb1,0x00c4ce84,0x00000000)    R(0x0752,0x00120814,0x001d0807,0x00000000,0x00000000)    R(0x0753,0x00170607,0x000a090e,0x00000000,0x00f0a944)    R(0x0754,0x00e49631,0x00dcc3ae,0x00d9d8dc,0x00d0d2d7)    R(0x0755,0x00c5cad4,0x00bbcce7,0x00a7c7f8,0x0089b0f4)    R(0x0756,0x007da2ec,0x007594df,0x006c8dcd,0x006285c6)    R(0x0757,0x005b7ec0,0x005779b9,0x005473b0,0x00566fa3)\n    R(0x0758,0x00263763,0x00040e35,0x00000c2f,0x00000e32)    R(0x0759,0x00001133,0x00011235,0x00000e33,0x003a5077)    R(0x075a,0x00465f8e,0x00496699,0x004c66a2,0x004962a1)    R(0x075b,0x0043609a,0x00416299,0x00405e9b,0x004b63a1)    R(0x075c,0x00586ca0,0x00607198,0x00e9f6fe,0x00ffffff)    R(0x075d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x075e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x075f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0760,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0761,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0762,0x00f8ffff,0x00fefffb,0x00fffff7,0x00fdffff)    R(0x0763,0x00c3d8f7,0x0099bffa,0x008cb7fb,0x0080a6e8)    R(0x0764,0x007397dd,0x00688ed6,0x0082ace7,0x009bcef6)    R(0x0765,0x00aee4fb,0x00b9eefd,0x00ccf9ff,0x00001356)    R(0x0766,0x00032060,0x00011f69,0x0000216a,0x00002473)    R(0x0767,0x00052980,0x00092b83,0x0099c3ff,0x0098c9fe)\n    R(0x0768,0x009cd0f9,0x00a0d1fd,0x00a7daff,0x00ade1fd)    R(0x0769,0x00b2e9fd,0x00b9efff,0x00b7eafe,0x00b8eaff)    R(0x076a,0x00aedcf3,0x00edffff,0x00fffdfe,0x00fdfffb)    R(0x076b,0x00fefff3,0x00cd9854,0x00ffd24b,0x00cec44e)    R(0x076c,0x0018160c,0x001d1b1c,0x00221600,0x006f6d4d)    R(0x076d,0x005c1d00,0x0014150d,0x00000b04,0x00c4ac3d)    R(0x076e,0x00b4bf97,0x00b5e5f2,0x00baf0fc,0x00c0f7fd)    R(0x076f,0x00bff9fd,0x00bcf8fc,0x00b5f0fa,0x00afe8fc)\n    R(0x0770,0x00a7def9,0x009fd2f9,0x009cc1f7,0x008db1f5)    R(0x0771,0x00749fec,0x00849eae,0x00d0db79,0x00252c00)    R(0x0772,0x00140814,0x000c0000,0x006e583f,0x0044260c)    R(0x0773,0x00070000,0x00090a06,0x000f0b00,0x00efab41)    R(0x0774,0x00d48920,0x00e5d0ba,0x00dbdade,0x00d3d6da)    R(0x0775,0x00c8cdd7,0x00bccde8,0x00a5c5f7,0x0088aff3)    R(0x0776,0x007ca1ec,0x007595df,0x006c8ccc,0x006384c4)    R(0x0777,0x00587cbd,0x005376b6,0x005472af,0x00576ea1)\n    R(0x0778,0x004f5e86,0x00010628,0x00000b2c,0x00000d2f)    R(0x0779,0x00001031,0x00031235,0x00000e33,0x0030446a)    R(0x077a,0x00415b88,0x00446293,0x004c679f,0x004d67a3)    R(0x077b,0x0047689d,0x0043669b,0x0042639d,0x004f68a4)    R(0x077c,0x005b71a0,0x007082a1,0x00f2ffff,0x00ffffff)    R(0x077d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x077e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x077f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0780,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0781,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0782,0x00f7feff,0x00fffffc,0x00fffff6,0x00fcfcfe)    R(0x0783,0x00e0f1fe,0x009bbef2,0x0097c2ff,0x0094bcf9)    R(0x0784,0x008db3f3,0x0092bbf4,0x00a2d1fe,0x00ace2fc)    R(0x0785,0x00baf6fb,0x00c8feff,0x00baeaf9,0x00000041)    R(0x0786,0x00031e64,0x00022068,0x0000216a,0x00002474)    R(0x0787,0x00062a82,0x001c3b8f,0x008db9ff,0x0096c8fe)\n    R(0x0788,0x009dd0fa,0x00a0d1fd,0x00a8d9ff,0x00ade1fd)    R(0x0789,0x00b2e8fe,0x00b9efff,0x00b6e9fe,0x00b9ebff)    R(0x078a,0x00aad8f1,0x00efffff,0x00fffbff,0x00f9fffd)    R(0x078b,0x00fafff3,0x00e0be8b,0x00ffcc4c,0x00ebda59)    R(0x078c,0x00000000,0x00251912,0x009a8669,0x00e1e0bf)    R(0x078d,0x00dfceb4,0x00321c12,0x00000000,0x00e9c94f)    R(0x078e,0x00b2c198,0x00b3e2fa,0x00baeaff,0x00beefff)    R(0x078f,0x00bbf0ff,0x00b8effe,0x00b2e8fe,0x00ade1fe)\n    R(0x0790,0x00a5d8fe,0x009ccefd,0x0097c0f7,0x008bb0f6)    R(0x0791,0x00769eed,0x00879fab,0x00d3dc70,0x008b8830)    R(0x0792,0x00140206,0x006c5649,0x00e0dbc3,0x00dbd8bf)    R(0x0793,0x002e2715,0x00040900,0x004e4911,0x00efb038)    R(0x0794,0x00be7c01,0x00f3e1d0,0x00dddbe1,0x00d7d8dd)    R(0x0795,0x00c8cfda,0x00b7cde8,0x00a2c4f6,0x0087aef4)    R(0x0796,0x007da0ed,0x007495df,0x006d8dcb,0x006384c1)    R(0x0797,0x00597cbb,0x005174b4,0x005775b2,0x005c75a9)\n    R(0x0798,0x00617299,0x00000120,0x00000b29,0x00000c2c)    R(0x0799,0x00021030,0x00041235,0x00011238,0x0021355b)    R(0x079a,0x0039527e,0x0043608d,0x00476397,0x004e68a1)    R(0x079b,0x004e70a4,0x004b6fa5,0x004c6ca6,0x004d68a0)    R(0x079c,0x006074a2,0x008d9cb5,0x00f3fdff,0x00ffffff)    R(0x079d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x079e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x079f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x07a0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x07a1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x07a2,0x00f8fefe,0x00fdfffd,0x00fffffb,0x00fefdfe)    R(0x07a3,0x00f6fdff,0x00b9cff1,0x009cc4f1,0x009ccdff)    R(0x07a4,0x009dcffe,0x00a4d7fc,0x00afe6ff,0x00b6f3fc)    R(0x07a5,0x00c5fffe,0x00bdf6f6,0x009ecee5,0x0000003c)    R(0x07a6,0x00041e69,0x00042164,0x0003216b,0x00042577)    R(0x07a7,0x00072b81,0x002d4e9e,0x008bb6ff,0x0099c8ff)\n    R(0x07a8,0x009ccdfd,0x00a2d1fc,0x00aad9ff,0x00addffc)    R(0x07a9,0x00b2e7fd,0x00b8edff,0x00b7ebff,0x00b7eaff)    R(0x07aa,0x00a8d5f2,0x00edf7ff,0x00fdfdff,0x00f4fffe)    R(0x07ab,0x00f7fff7,0x00f0e2b4,0x00efb63e,0x00fddc5e)    R(0x07ac,0x00625f20,0x002a230f,0x00af9676,0x00ffffe4)    R(0x07ad,0x00ebedce,0x00251608,0x0091711a,0x00ead14f)    R(0x07ae,0x00abc1a4,0x00b3e3fc,0x00b3e6fd,0x00b7ecff)    R(0x07af,0x00b6ebff,0x00b4eaff,0x00afe3ff,0x00aaddff)\n    R(0x07b0,0x00a4d5ff,0x0096cdfa,0x008ec1f4,0x0090aef6)    R(0x07b1,0x00809eeb,0x00809db0,0x00c1cc76,0x00d7cc5b)    R(0x07b2,0x00100000,0x007d6753,0x00fffff2,0x00f4f1d1)    R(0x07b3,0x00272813,0x00000000,0x00c1983d,0x00f5b127)    R(0x07b4,0x00aa7500,0x00ede7ea,0x00e5d9ea,0x00d7d6e0)    R(0x07b5,0x00bdd0da,0x00afd1ec,0x0097c0f7,0x0085acf8)    R(0x07b6,0x007c9fed,0x007494dd,0x006f8bcc,0x006680be)    R(0x07b7,0x005f79b5,0x005774b1,0x005472b2,0x005772af)\n    R(0x07b8,0x006277a7,0x00010629,0x00000c28,0x00000d2a)    R(0x07b9,0x00021030,0x00031136,0x00011039,0x0013264f)    R(0x07ba,0x0030466f,0x003d557e,0x00496093,0x00486099)    R(0x07bb,0x004f6ea5,0x004e6fa9,0x005471ae,0x005a70ab)    R(0x07bc,0x005a6b97,0x00cbd6e8,0x00f8feff,0x00ffffff)    R(0x07bd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x07be,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x07bf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x07c0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x07c1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x07c2,0x00fafffe,0x00fbffff,0x00fffffe,0x00fffeff)    R(0x07c3,0x00faf9ff,0x00dfeefa,0x00a5c5e6,0x009dcef7)    R(0x07c4,0x00a7d6fe,0x00b3e4fb,0x00baf4fd,0x00bff9ff)    R(0x07c5,0x00baebff,0x00b6e2fc,0x007ca3d4,0x0000084b)    R(0x07c6,0x00052267,0x00052164,0x0004226d,0x00042679)    R(0x07c7,0x00072b82,0x003a5fae,0x008cb7ff,0x0097c5ff)\n    R(0x07c8,0x0099c8fd,0x00a1cefc,0x00a8d7ff,0x00abddfb)    R(0x07c9,0x00b0e5fc,0x00b6ebff,0x00b6ecff,0x00b5e9ff)    R(0x07ca,0x00a7d6f2,0x00e3effc,0x00faffff,0x00f4fbfe)    R(0x07cb,0x00f7fcfd,0x00fbf8da,0x00d2991a,0x00fcd455)    R(0x07cc,0x00cec755,0x00000000,0x006d543f,0x00b9b798)    R(0x07cd,0x007f8c77,0x00411600,0x00e9bb47,0x00e7c850)    R(0x07ce,0x00b3cdc4,0x00ade0fc,0x00aee4fd,0x00b3eaff)    R(0x07cf,0x00b2e8ff,0x00b0e6ff,0x00acdfff,0x00a8daff)\n    R(0x07d0,0x00a3d3fd,0x0094cafc,0x008cc0f7,0x0090b2ee)    R(0x07d1,0x0082a1ea,0x007c9ac5,0x009fab6e,0x00f3e962)    R(0x07d2,0x009f8c24,0x00352127,0x00b5b1a3,0x00948d75)    R(0x07d3,0x00000000,0x00825c24,0x00efab3f,0x00e79c27)    R(0x07d4,0x00d5b080,0x00e3e6f1,0x00e8d8eb,0x00d3d4df)    R(0x07d5,0x00b8cfdd,0x00acd1f2,0x0093bbf8,0x0085a9f8)    R(0x07d6,0x00799be6,0x007191d3,0x006a85c7,0x006379b6)    R(0x07d7,0x005f74ad,0x005a74af,0x005371b2,0x00536fb1)\n    R(0x07d8,0x006177ac,0x00020b31,0x00000c29,0x00000e2b)    R(0x07d9,0x00011030,0x00021136,0x00000d36,0x00061743)    R(0x07da,0x00253565,0x00344679,0x0046588f,0x004c6199)    R(0x07db,0x00465f95,0x005470a4,0x005971a9,0x005668a0)    R(0x07dc,0x00929dbd,0x00f2f9ff,0x00f9fdfc,0x00ffffff)    R(0x07dd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x07de,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x07df,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x07e0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x07e1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x07e2,0x00faffff,0x00fbffff,0x00fffffe,0x00fffeff)    R(0x07e3,0x00fcfbff,0x00f2fbff,0x00cce3f5,0x00a5cbe9)    R(0x07e4,0x00adcbfb,0x00c0e5fc,0x00bdf2eb,0x00c1eeff)    R(0x07e5,0x00a0b9ff,0x008196dd,0x004356a7,0x00042062)    R(0x07e6,0x00021e5b,0x00022067,0x0003226f,0x00012579)    R(0x07e7,0x00042981,0x004970c0,0x0089b3fe,0x0092c1ff)\n    R(0x07e8,0x0097c5fd,0x009dccfc,0x00a4d5ff,0x00a8dcfb)    R(0x07e9,0x00ace3fc,0x00b2eafe,0x00b1e9fe,0x00b3ebff)    R(0x07ea,0x00a8dbf4,0x00cfe3f4,0x00f9feff,0x00faf7ff)    R(0x07eb,0x00f9f7ff,0x00fffcf7,0x00d8c187,0x00eac84c)    R(0x07ec,0x00f0e153,0x00beaf5c,0x0079601b,0x00481a00)    R(0x07ed,0x00786a29,0x00ceb651,0x00ffd455,0x00cf9d42)    R(0x07ee,0x00b7d5df,0x00a7defe,0x00ade3fe,0x00b0e6ff)    R(0x07ef,0x00afe5fe,0x00ade1fe,0x00a9dcfd,0x00a7d8ff)\n    R(0x07f0,0x00a1d0fd,0x0099c4ff,0x0093bcfb,0x008cbae5)    R(0x07f1,0x007ba5ec,0x007895dc,0x00899479,0x00ece558)    R(0x07f2,0x00eedb41,0x00ae8f31,0x00280000,0x002e0000)    R(0x07f3,0x00a37135,0x00e39c2e,0x00fca835,0x00b46700)    R(0x07f4,0x00fde0d8,0x00e4e4ea,0x00e8dee7,0x00d3d7e1)    R(0x07f5,0x00bccee5,0x00a8c5f2,0x008eaff2,0x007e9ce9)    R(0x07f6,0x00708fd3,0x006785be,0x005e7ab9,0x005a71ae)    R(0x07f7,0x005a70aa,0x005872ae,0x005472b3,0x005470b1)\n    R(0x07f8,0x005f75a9,0x00060e32,0x00000a2d,0x00000c2f)    R(0x07f9,0x0001112f,0x00021332,0x00021236,0x00000c3e)    R(0x07fa,0x00121d5c,0x00252f79,0x0039448a,0x00324881)    R(0x07fb,0x00405785,0x003f5a85,0x00445d8a,0x00828eb2)    R(0x07fc,0x00dde3f1,0x00fbfdff,0x00fbfdfc,0x00ffffff)    R(0x07fd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x07fe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x07ff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0800,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0801,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0802,0x00faffff,0x00fcffff,0x00fffffe,0x00fffeff)    R(0x0803,0x00fffdfd,0x00fafdff,0x00eefcff,0x00d1e8f2)    R(0x0804,0x00c7d8fb,0x00c7e3f4,0x00cbf3ed,0x00aac5f8)    R(0x0805,0x00666cd8,0x000000b2,0x0000007e,0x0007256b)    R(0x0806,0x00001d59,0x0000216a,0x00012270,0x00012578)    R(0x0807,0x0003287f,0x00557dce,0x0088b0fd,0x0093beff)\n    R(0x0808,0x0098c5ff,0x009bcbfd,0x00a2d4ff,0x00a6dbfd)    R(0x0809,0x00aae1fd,0x00afe8fe,0x00aee7fe,0x00b2ebff)    R(0x080a,0x00aadef7,0x00b7d4ee,0x00f2fbff,0x00fffbff)    R(0x080b,0x00fbf8ff,0x00fdf7ff,0x00f7f4dc,0x00c4a42d)    R(0x080c,0x00f5d54b,0x00fef071,0x00d2c336,0x00cdbf45)    R(0x080d,0x00e2c75d,0x00ffe65c,0x00f4c23e,0x00c89f81)    R(0x080e,0x00a7c9ea,0x00a7deff,0x00ade0ff,0x00afe3ff)    R(0x080f,0x00ade1fe,0x00abddfe,0x00a7d8fe,0x00a5d4ff)\n    R(0x0810,0x00a1cefe,0x009dc2ff,0x0097bbf9,0x0088bce5)    R(0x0811,0x0076a7ef,0x007190ea,0x008993a3,0x00c2b842)    R(0x0812,0x00ffe64a,0x00fbd342,0x00c4ad2a,0x00b89329)    R(0x0813,0x00f5b240,0x00ffae1f,0x00e59412,0x00cca59a)    R(0x0814,0x00f9e9fb,0x00ece6eb,0x00e3e1e3,0x00ced4e1)    R(0x0815,0x00b1c1e2,0x008fa6dd,0x007c97df,0x006c88cf)    R(0x0816,0x00637fbc,0x005c78aa,0x00536fac,0x00556ca9)    R(0x0817,0x00596fa9,0x00556fab,0x005371b2,0x00536fb0)\n    R(0x0818,0x005b71a5,0x00091032,0x00000830,0x00000b30)    R(0x0819,0x0001112d,0x0002152f,0x00021235,0x00010c45)    R(0x081a,0x0004085c,0x00090a71,0x00202275,0x009ea4ce)    R(0x081b,0x0098a3cc,0x009ba7bd,0x00b9c2cc,0x00d8deec)    R(0x081c,0x00f4f5fc,0x00fefdff,0x00fffffc,0x00ffffff)    R(0x081d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x081e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x081f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0820,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0821,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0822,0x00fdfeff,0x00feffff,0x00ffffff,0x00fffffe)    R(0x0823,0x00fffdfd,0x00feffff,0x00f8ffff,0x00f6ffff)    R(0x0824,0x00e9f8fe,0x00dff3f8,0x00dbf1ff,0x00626cc8)    R(0x0825,0x000000a3,0x000600b5,0x00000a89,0x00031c68)    R(0x0826,0x00022062,0x0000206a,0x0000206f,0x00012476)    R(0x0827,0x0002277c,0x00597fd0,0x0089affb,0x0095bdff)\n    R(0x0828,0x009bc4ff,0x009cc9fc,0x00a2d0ff,0x00a7d9ff)    R(0x0829,0x00acdfff,0x00ade2ff,0x00aee3ff,0x00b0e5fe)    R(0x082a,0x00acdefb,0x00a8c8f2,0x00ddeefd,0x00fcfffc)    R(0x082b,0x00fdfdf8,0x00f6fafc,0x00fefffd,0x00dbcfae)    R(0x082c,0x00f6c664,0x00e5d645,0x00fae648,0x00ffec5d)    R(0x082d,0x00ffda51,0x00dabc00,0x00e3c67c,0x00d1c4d1)    R(0x082e,0x00a1cef5,0x00a4dbfc,0x00aaddff,0x00acdfff)    R(0x082f,0x00abdeff,0x00a9daff,0x00a5d4fe,0x00a3d0ff)\n    R(0x0830,0x009ecbfe,0x009ec2fb,0x0098bbf5,0x0085b7ee)    R(0x0831,0x0074a5f2,0x007192ed,0x008792c7,0x00b1a293)    R(0x0832,0x00e3b93a,0x00fac92e,0x00ffd434,0x00eebf2f)    R(0x0833,0x00f2af14,0x00e08d00,0x00d8a577,0x00f3e9ea)    R(0x0834,0x00dfe2f3,0x00e5dce0,0x00cad0d0,0x00b6bfd2)    R(0x0835,0x008f9dc8,0x006b7fbe,0x00637cc3,0x005a75b6)    R(0x0836,0x005771a8,0x00566f9e,0x004f68a7,0x005269a7)    R(0x0837,0x00586ea8,0x00536da9,0x00506eaf,0x00526eaf)\n    R(0x0838,0x005b71a5,0x000b1336,0x00000930,0x00000c2f)    R(0x0839,0x0001112c,0x0002142f,0x00001037,0x00010b4a)    R(0x083a,0x00070769,0x00010079,0x0000006e,0x00b9bef0)    R(0x083b,0x00dce2ff,0x00e2ecfb,0x00fbffff,0x00ffffff)    R(0x083c,0x00f6f5fa,0x00fffefe,0x00fffefc,0x00ffffff)    R(0x083d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x083e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x083f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0840,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0841,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0842,0x00fffeff,0x00fffeff,0x00fffeff,0x00fffffe)    R(0x0843,0x00ffffff,0x00ffffff,0x00fdffff,0x00fdffff)    R(0x0844,0x00f6fff9,0x00ebf8fe,0x00b8bceb,0x0000009d)    R(0x0845,0x000900b6,0x000201aa,0x00000a88,0x0002166c)    R(0x0846,0x00051f67,0x00021f68,0x00011f6b,0x00022472)    R(0x0847,0x00002576,0x006184d1,0x008db0f8,0x0098bbfe)\n    R(0x0848,0x009cbefd,0x009ec7fb,0x009fc8fb,0x00a5d1fe)    R(0x0849,0x00acd8ff,0x00acd9ff,0x00afdcff,0x00afddff)    R(0x084a,0x00addaff,0x00aac9ff,0x00b8d2f2,0x00f3ffff)    R(0x084b,0x00fcffee,0x00f6fcf8,0x00f5faff,0x00fffffb)    R(0x084c,0x00f4d9be,0x00e4d6ac,0x00f3cc6e,0x00f1bf50)    R(0x084d,0x00f8c96c,0x00d6cc9a,0x00d4e0cc,0x00afcbf1)    R(0x084e,0x009fd4f7,0x00a2d8fb,0x00a7d9ff,0x00a9dafe)    R(0x084f,0x00a8dafe,0x00a7d8ff,0x00a3d2fe,0x00a1ceff)\n    R(0x0850,0x009cc7fe,0x009ec3f6,0x0098bdf4,0x0085b3fa)    R(0x0851,0x007da6f7,0x007b9aed,0x007f8fdc,0x00aaa6c9)    R(0x0852,0x00e2ccbc,0x00ecb867,0x00f6b55d,0x00e8ad49)    R(0x0853,0x00e8ae6b,0x00daa799,0x00e7cecb,0x00cfdde4)    R(0x0854,0x00beccd1,0x00c1bcbe,0x00a9b5be,0x008f9bb9)    R(0x0855,0x006272a8,0x00566aad,0x004f68ab,0x004c69a5)    R(0x0856,0x0050699f,0x0052699e,0x004e67a7,0x005168a6)    R(0x0857,0x00556ba5,0x00526ca9,0x004d6bac,0x00526eaf)\n    R(0x0858,0x005b71a5,0x000d183b,0x00000a2d,0x00000d2b)    R(0x0859,0x0000112c,0x00011230,0x00000d3b,0x0000064f)    R(0x085a,0x00090672,0x00060084,0x000b047e,0x005e5e9e)    R(0x085b,0x00e7eaff,0x00f2f8ff,0x00fcffff,0x00fffffc)    R(0x085c,0x00ffffff,0x00fffffe,0x00ffffff,0x00ffffff)    R(0x085d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x085e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x085f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0860,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0861,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0862,0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff)    R(0x0863,0x00ffffff,0x00fffffe,0x00fffffe,0x00fffffe)    R(0x0864,0x00f9fff9,0x00e7e9ff,0x005950b4,0x001202b2)    R(0x0865,0x000801b1,0x000304a9,0x00000591,0x0002106f)    R(0x0866,0x00081f65,0x00041f68,0x0003206a,0x0003226d)    R(0x0867,0x0000226d,0x006585cd,0x008aa9ee,0x0091aff0)\n    R(0x0868,0x008faceb,0x008cb1e5,0x0088ade1,0x008ab0e2)    R(0x0869,0x0090b4e6,0x0092b7e8,0x0095baea,0x0095bcea)    R(0x086a,0x0095b8ea,0x0095b0e9,0x0082a6da,0x00c7e0eb)    R(0x086b,0x00f7fcf4,0x00f9f6f4,0x00edf5ff,0x00f3f2ff)    R(0x086c,0x00fffffb,0x00fff6f9,0x00f0cfc6,0x00eccab1)    R(0x086d,0x00f4ddc8,0x00eceef0,0x00aed2ee,0x009dd2f8)    R(0x086e,0x0093c6f2,0x00a5d6ff,0x00a6d7ff,0x00a7d9ff)    R(0x086f,0x00a7d8ff,0x00a7d7ff,0x00a3d2ff,0x00a1cdff)\n    R(0x0870,0x009cc7ff,0x009dc2fb,0x0096bef9,0x0084b2fb)    R(0x0871,0x0085a7f3,0x00859ce9,0x00738ede,0x006783c8)    R(0x0872,0x00d6d3e6,0x00e4c6c5,0x00e1b2af,0x00deb19a)    R(0x0873,0x00e4bca9,0x00e7cad8,0x00bcb9d5,0x00a5b2bd)    R(0x0874,0x00a5afb1,0x00a6aab2,0x0091a3b8,0x006779a3)    R(0x0875,0x004c5f9c,0x004a63a4,0x004865a0,0x0048679b)    R(0x0876,0x004d669d,0x005064a5,0x004b64a6,0x004f66a3)    R(0x0877,0x005268a2,0x004f69a6,0x004c6aab,0x004f6bac)\n    R(0x0878,0x00596fa3,0x000c183c,0x00000c27,0x00000e27)    R(0x0879,0x0000112b,0x00001033,0x0000083d,0x0004085a)    R(0x087a,0x00090375,0x00070084,0x00070083,0x00000067)    R(0x087b,0x00b7b6e2,0x00f7faff,0x00fffffd,0x00fffff9)    R(0x087c,0x00fffffd,0x00fdffff,0x00fdfeff,0x00ffffff)    R(0x087d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x087e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x087f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0880,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0881,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0882,0x00fffeff,0x00fffdff,0x00fffeff,0x00fffeff)    R(0x0883,0x00fefeff,0x00fffeff,0x00ffffff,0x00fffffe)    R(0x0884,0x00f9feff,0x00c4bfea,0x000000aa,0x000c00b5)    R(0x0885,0x000502ab,0x000302ae,0x000200a3,0x00000a74)    R(0x0886,0x00051c5a,0x00051f64,0x00052066,0x00052167)    R(0x0887,0x00021d63,0x004b68ac,0x006d87c9,0x006b83c2)\n    R(0x0888,0x006b83be,0x005c7cb1,0x005676ab,0x005273aa)    R(0x0889,0x005372ab,0x005271ac,0x005775b1,0x005776b2)    R(0x088a,0x005875b1,0x00526fb1,0x004c77bf,0x006081b8)    R(0x088b,0x00c9cbd8,0x00dbd3db,0x00cfd6ec,0x00cddcef)    R(0x088c,0x00dfe1da,0x00e9e2e1,0x00e3dbe7,0x00dee1e5)    R(0x088d,0x00d1e0e8,0x00a6bce9,0x0083abe2,0x0089bde9)    R(0x088e,0x0090bbf8,0x0093bef2,0x0095c4ef,0x0098c7f1)    R(0x088f,0x009ac9f4,0x0099c6f4,0x0095c1f4,0x0093bdf5)\n    R(0x0890,0x008fb7f5,0x008baef2,0x0080a9ec,0x0072a1e0)    R(0x0891,0x007895d9,0x007b89d4,0x006185cc,0x004d88c5)    R(0x0892,0x003f6daa,0x00b1afda,0x00b3b5cc,0x00c8bbc3)    R(0x0893,0x00b2a8ae,0x009da6b4,0x0098a1b3,0x00a7a2b1)    R(0x0894,0x00a6a1b6,0x00939eb8,0x007185a7,0x0051669a)    R(0x0895,0x004d63a4,0x004965a5,0x0047689d,0x00486899)    R(0x0896,0x0048639d,0x004c5ea8,0x004861a4,0x004c64a0)    R(0x0897,0x004f659f,0x004c67a3,0x004766a8,0x004a67a7)\n    R(0x0898,0x00566ca1,0x000b173b,0x00000d24,0x00001024)    R(0x0899,0x0000102b,0x00000d36,0x00000644,0x000b0c65)    R(0x089a,0x00070374,0x00090084,0x0007008b,0x00130d85)    R(0x089b,0x00474885,0x00ecefff,0x00fcfdfd,0x00fffff8)    R(0x089c,0x00fffffd,0x00fafeff,0x00faffff,0x00ffffff)    R(0x089d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x089e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x089f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x08a0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x08a1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x08a2,0x00fffffc,0x00fffbff,0x00fdfdff,0x00fdfffd)    R(0x08a3,0x00fefeff,0x00fffdff,0x00fffffc,0x00fefffc)    R(0x08a4,0x00f0f5ff,0x00514fac,0x001b08b2,0x000802b0)    R(0x08a5,0x000201ac,0x000200b4,0x000901b2,0x0002048d)    R(0x08a6,0x00010d60,0x00041950,0x00061b53,0x00061b54)    R(0x08a7,0x00041450,0x0028397a,0x003f5195,0x00374d8e)\n    R(0x08a8,0x003f5893,0x0038568f,0x003a5692,0x00395794)    R(0x08a9,0x003c5993,0x00435c93,0x00475e99,0x00405c9e)    R(0x08aa,0x00405da3,0x004a66a7,0x003e60ac,0x004865ab)    R(0x08ab,0x005a6294,0x008f8dae,0x008791b5,0x008fa4bf)    R(0x08ac,0x008c9fa5,0x009ea1a4,0x0094a4b6,0x007399b5)    R(0x08ad,0x006792c0,0x005e7bc1,0x006b8dc5,0x00547fa1)    R(0x08ae,0x007494e2,0x006385c8,0x00688ec2,0x006c91c7)    R(0x08af,0x006f94c9,0x007197cc,0x006f93cc,0x006c90cc)\n    R(0x08b0,0x00698aca,0x006180c8,0x005578c0,0x005179b7)    R(0x08b1,0x005b75b7,0x006071b6,0x005275b0,0x003d74a4)    R(0x08b2,0x005074b4,0x00475fa9,0x00638db1,0x008593b0)    R(0x08b3,0x00919aad,0x008e9ea9,0x0096a0ae,0x009a94ae)    R(0x08b4,0x009794bb,0x006f80ad,0x004d6693,0x004d639f)    R(0x08b5,0x004d64a9,0x004963a7,0x004868a1,0x00416196)    R(0x08b6,0x004c68a3,0x00465ba2,0x0049609f,0x004a629e)    R(0x08b7,0x004a629f,0x004864a3,0x004463a3,0x004965a1)\n    R(0x08b8,0x00526798,0x000a163a,0x00000d24,0x00000e24)    R(0x08b9,0x00000c30,0x00000841,0x00020556,0x000b0a70)    R(0x08ba,0x00060179,0x000a0186,0x00070189,0x00060283)    R(0x08bb,0x0000006e,0x00bcbde9,0x00f7fafe,0x00fffff2)    R(0x08bc,0x00fffffd,0x00fcfdff,0x00fafffd,0x00ffffff)    R(0x08bd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x08be,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x08bf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x08c0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x08c1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x08c2,0x00fffff9,0x00fff9ff,0x00fafcff,0x00fafff9)    R(0x08c3,0x00fffcff,0x00fffaff,0x00fefef5,0x00fafef9)    R(0x08c4,0x00cbd2fc,0x0000009d,0x000709a6,0x000707b1)    R(0x08c5,0x000501bc,0x000500ba,0x000a03b6,0x000802ab)    R(0x08c6,0x00050584,0x00020544,0x00020936,0x0001062c)    R(0x08c7,0x0001022a,0x0024295e,0x00404c89,0x003e538e)\n    R(0x08c8,0x003c568f,0x003c5492,0x00385594,0x00385794)    R(0x08c9,0x003f598f,0x00495d8d,0x004b5f91,0x00415c9b)    R(0x08ca,0x003d5da8,0x004963a6,0x004b65a8,0x004d67a9)    R(0x08cb,0x004a66a7,0x004564a1,0x00586fa5,0x006679a8)    R(0x08cc,0x00707fa9,0x00737baa,0x006578b4,0x004d6eb7)    R(0x08cd,0x004f74bd,0x005875af,0x00566a9b,0x00152461)    R(0x08ce,0x004967ac,0x00455fa5,0x00475fa4,0x004860a6)    R(0x08cf,0x004962a7,0x004a63a8,0x004a63a8,0x004761a6)\n    R(0x08d0,0x00455fa3,0x00445ea1,0x00445ea1,0x00445ca6)    R(0x08d1,0x00455fa5,0x004864a1,0x005b73a8,0x00212a59)    R(0x08d2,0x0053609d,0x006170b5,0x004c67ad,0x005569a7)    R(0x08d3,0x007680b1,0x00787da7,0x007980a8,0x006a78a8)    R(0x08d4,0x005169a3,0x0048629f,0x004c689c,0x004a63a4)    R(0x08d5,0x00485ea9,0x00475ea8,0x004863a2,0x00405b94)    R(0x08d6,0x004c689f,0x00415b96,0x004c5f98,0x00485f99)    R(0x08d7,0x00435d9e,0x00405da0,0x00425f9e,0x00496299)\n    R(0x08d8,0x004b5d8c,0x00081439,0x00010b27,0x00010a29)    R(0x08d9,0x00000436,0x00010550,0x0006086b,0x00040279)    R(0x08da,0x00060083,0x00080087,0x00080385,0x00030280)    R(0x08db,0x00070388,0x00625fac,0x00f8fdfe,0x00ffffeb)    R(0x08dc,0x00fffefc,0x00fffbff,0x00fbfff8,0x00ffffff)    R(0x08dd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x08de,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x08df,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x08e0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x08e1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x08e2,0x00fffffa,0x00fffaff,0x00fafdff,0x00fafff9)    R(0x08e3,0x00fdfaff,0x00fff8fe,0x00fffff7,0x00fafdfe)    R(0x08e4,0x008c8cdf,0x000301a5,0x000c07b6,0x000905bd)    R(0x08e5,0x000a03c6,0x000600c0,0x000800ba,0x000b02b4)    R(0x08e6,0x000f089f,0x000a0874,0x0001004e,0x0000012e)    R(0x08e7,0x00020c2a,0x00162445,0x003d4e7c,0x00374b82)\n    R(0x08e8,0x00394f89,0x003a4f8c,0x0036518e,0x0037538e)    R(0x08e9,0x0040578a,0x003d4d77,0x004d5d8a,0x00485f96)    R(0x08ea,0x00425e9f,0x004760a3,0x004863a6,0x004a66a9)    R(0x08eb,0x004966a9,0x004d6aab,0x004e69a5,0x00516aa2)    R(0x08ec,0x00576ea0,0x005a6fac,0x00506cb0,0x005677bb)    R(0x08ed,0x005471ad,0x006276a2,0x00000000,0x0048547f)    R(0x08ee,0x004c5f99,0x00455d9e,0x00435c9f,0x00425b9f)    R(0x08ef,0x00415b9e,0x00415a9e,0x00415a9d,0x00415a9e)\n    R(0x08f0,0x00415a9d,0x00405a9b,0x003e5a9a,0x003d579d)    R(0x08f1,0x003e589e,0x00425a9b,0x00496098,0x00000010)    R(0x08f2,0x00303c65,0x00556392,0x004e69a7,0x00546fab)    R(0x08f3,0x004a619c,0x004f66a0,0x004e65a2,0x004a64a4)    R(0x08f4,0x004764a9,0x004765a9,0x004865a1,0x004861a6)    R(0x08f5,0x00475da8,0x00495fa3,0x00455e95,0x00516a96)    R(0x08f6,0x00415783,0x00425585,0x00485c93,0x00455a94)    R(0x08f7,0x00405997,0x003c5998,0x003e5a96,0x00425991)\n    R(0x08f8,0x00445686,0x00060e36,0x00000529,0x00010532)    R(0x08f9,0x00020340,0x00030658,0x0006066f,0x0005027b)    R(0x08fa,0x00050081,0x00070086,0x00050084,0x00070386)    R(0x08fb,0x0008048b,0x0000007d,0x00f0f3ff,0x00fefff2)    R(0x08fc,0x00fffefd,0x00fffbff,0x00fcfffa,0x00ffffff)    R(0x08fd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x08fe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x08ff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0900,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0901,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0902,0x00fffffc,0x00fffaff,0x00fbfeff,0x00fbfffa)    R(0x0903,0x00fdf8ff,0x00fefafb,0x00fdfff6,0x00f8f9fe)    R(0x0904,0x005450ae,0x000d03b9,0x000601bc,0x000d05ca)    R(0x0905,0x000200c4,0x000400c2,0x000600bd,0x000b00b7)    R(0x0906,0x000c01a8,0x00070087,0x0008056c,0x00010645)    R(0x0907,0x0001052e,0x00091836,0x003b4d7a,0x002f4479)\n    R(0x0908,0x00344881,0x00394984,0x00364b88,0x00374f88)    R(0x0909,0x00425585,0x00000026,0x00455174,0x004c5b87)    R(0x090a,0x00495d92,0x00445c9a,0x00465fa1,0x004662a6)    R(0x090b,0x004563a8,0x004664aa,0x004a68aa,0x004f6aab)    R(0x090c,0x00506aa8,0x004766ac,0x005272b5,0x00536ea6)    R(0x090d,0x004b5c86,0x00000000,0x0000000c,0x00565f87)    R(0x090e,0x0048588d,0x00425797,0x0040569b,0x0040579b)    R(0x090f,0x0042599c,0x0042599d,0x0041599c,0x0041589c)\n    R(0x0910,0x0041589b,0x003f5998,0x003e5a95,0x003b5797)    R(0x0911,0x003c559b,0x0042569a,0x00495a95,0x0025305a)    R(0x0912,0x00000000,0x002f3c51,0x00496192,0x004d689e)    R(0x0913,0x004a68a4,0x004365aa,0x004263ad,0x004262ae)    R(0x0914,0x004261ad,0x00415fa9,0x004463a3,0x00455fa3)    R(0x0915,0x00465ba2,0x004a5d99,0x0050638e,0x004c5f7e)    R(0x0916,0x00374661,0x00131b36,0x00485c8e,0x00435891)    R(0x0917,0x003f5790,0x003c5492,0x003a5490,0x003a4e86)\n    R(0x0918,0x003c4c81,0x00050733,0x00010236,0x00040542)    R(0x0919,0x00050550,0x00030260,0x00040374,0x0004017d)    R(0x091a,0x00050082,0x00060086,0x00050187,0x00050187)    R(0x091b,0x000b088e,0x00000079,0x00c0c1ec,0x00fdfffb)    R(0x091c,0x00fffefe,0x00fffcff,0x00fdfffd,0x00ffffff)    R(0x091d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x091e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x091f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0920,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0921,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0922,0x00fffffe,0x00fffcff,0x00fbfffe,0x00fcfffc)    R(0x0923,0x00fffbff,0x00fdfaf6,0x00f8fff5,0x00f1f1ff)    R(0x0924,0x001f13ab,0x000e03c1,0x000600c0,0x000701c5)    R(0x0925,0x000500c6,0x000500c1,0x000802bc,0x000902b5)    R(0x0926,0x0005009f,0x0001007e,0x000d0977,0x0007095e)    R(0x0927,0x00060b54,0x00050847,0x00333e7d,0x002d3e79)\n    R(0x0928,0x002f4378,0x00394480,0x00364784,0x00374c85)    R(0x0929,0x00415380,0x00000017,0x00000016,0x00434b6a)    R(0x092a,0x0045547c,0x004b5c92,0x00495d97,0x00445d9b)    R(0x092b,0x00435d9f,0x004563a5,0x004461a4,0x004763a4)    R(0x092c,0x004c67a8,0x004b66a2,0x004c6396,0x0039466a)    R(0x092d,0x00000000,0x00000111,0x00050823,0x00525f8f)    R(0x092e,0x00425997,0x0040589b,0x0041599b,0x0040589a)    R(0x092f,0x0041599a,0x00425a9b,0x00435a9c,0x0041599b)\n    R(0x0930,0x0040589a,0x003f5896,0x003e5991,0x003a5693)    R(0x0931,0x003a5396,0x003e5199,0x004f5c9c,0x004b547d)    R(0x0932,0x0000040f,0x00000000,0x00000927,0x004b5f83)    R(0x0933,0x00445e92,0x004868a8,0x004364ab,0x004563aa)    R(0x0934,0x004961a7,0x004960a1,0x0043609c,0x00485e9e)    R(0x0935,0x004d5d9a,0x004d5b8c,0x004a5876,0x00354052)    R(0x0936,0x00000000,0x00272e46,0x00435687,0x003e538c)    R(0x0937,0x003c508a,0x00384d8a,0x003b4f8c,0x00384783)\n    R(0x0938,0x00343f77,0x00030537,0x00040645,0x0007054f)    R(0x0939,0x00020158,0x00010067,0x00040278,0x0003007f)    R(0x093a,0x00040084,0x00060085,0x000b028e,0x0005028a)    R(0x093b,0x00030187,0x00020183,0x008b89b4,0x00fcffff)    R(0x093c,0x00fffefe,0x00fffbff,0x00fdffff,0x00ffffff)    R(0x093d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x093e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x093f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0940,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0941,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0942,0x00fffeff,0x00fffdff,0x00fcfffb,0x00fdfffe)    R(0x0943,0x00fff9ff,0x00fffff6,0x00f8fff9,0x00e9e6ff)    R(0x0944,0x000000a3,0x000900c0,0x000900c1,0x000701c3)    R(0x0945,0x000702c2,0x000501bb,0x000601b7,0x000501b0)    R(0x0946,0x00020094,0x00040275,0x000a0877,0x00070471)    R(0x0947,0x0003006c,0x0004046b,0x00161870,0x00303c7f)\n    R(0x0948,0x002e3e75,0x00343e7c,0x00314280,0x00334580)    R(0x0949,0x003e4f7b,0x00070c26,0x0000000e,0x00000000)    R(0x094a,0x002b334b,0x0048537b,0x00465681,0x003d5082)    R(0x094b,0x0040578b,0x00435c94,0x00405891,0x00435992)    R(0x094c,0x00475b91,0x00405077,0x000f142f,0x00000000)    R(0x094d,0x0006020b,0x00000011,0x0029365e,0x003b5492)    R(0x094e,0x002a4c96,0x003b569c,0x00405698,0x00405698)    R(0x094f,0x00405698,0x00405698,0x00405698,0x00405698)\n    R(0x0950,0x00405698,0x00405596,0x003e578f,0x003b578f)    R(0x0951,0x003a5693,0x003c5299,0x00445297,0x0059608f)    R(0x0952,0x00000000,0x00000500,0x00010002,0x00000000)    R(0x0953,0x002f3d5c,0x004a608d,0x00435b90,0x00495e94)    R(0x0954,0x00515f93,0x00515f8f,0x00455c8d,0x0047598b)    R(0x0955,0x004c5886,0x00424b6d,0x00101829,0x00000000)    R(0x0956,0x0000000f,0x00333a57,0x003c4d81,0x003b4e87)    R(0x0957,0x00354884,0x00354584,0x00344383,0x00333b7c)\n    R(0x0958,0x00060d50,0x00000143,0x00000047,0x00040054)    R(0x0959,0x00030060,0x0002006d,0x0004027d,0x00030083)    R(0x095a,0x00040086,0x00060087,0x0007008d,0x0006008c)    R(0x095b,0x0003028a,0x000a038d,0x006b6aa6,0x00f9fcff)    R(0x095c,0x00fffefb,0x00fefcff,0x00fdffff,0x00ffffff)    R(0x095d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x095e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x095f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0960,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0961,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0962,0x00fffdff,0x00fffeff,0x00fcfff8,0x00fefeff)    R(0x0963,0x00fff6ff,0x00fffff5,0x00f7fffc,0x00c0bcff)    R(0x0964,0x000000ae,0x000a00c5,0x000802c3,0x000602c1)    R(0x0965,0x000504be,0x000403ba,0x000603b8,0x000500b6)    R(0x0966,0x0006029b,0x00010173,0x00040478,0x0004007a)    R(0x0967,0x00000079,0x00020076,0x00000066,0x000c1261)\n    R(0x0968,0x00293271,0x002f3679,0x002b3b7c,0x002b3e7b)    R(0x0969,0x00354673,0x00181d36,0x00020411,0x0000010b)    R(0x096a,0x00000000,0x00000000,0x00222a44,0x003b4664)    R(0x096b,0x003d4b6f,0x003b4c73,0x0039476d,0x002c3a5d)    R(0x096c,0x00000025,0x00000000,0x00030208,0x000c0406)    R(0x096d,0x00070207,0x00000010,0x00425789,0x00365599)    R(0x096e,0x002d4f9a,0x00395399,0x003e5394,0x003e5394)    R(0x096f,0x003e5394,0x003e5394,0x003e5394,0x003e5394)\n    R(0x0970,0x003e5394,0x00415396,0x00425493,0x003d588d)    R(0x0971,0x003a588d,0x003a5496,0x003d4c98,0x004a548e)    R(0x0972,0x001c223c,0x00000004,0x00040105,0x0001010d)    R(0x0973,0x00000000,0x00000000,0x00212945,0x0035405e)    R(0x0974,0x00464f6e,0x00485070,0x00404e6f,0x002f3857)    R(0x0975,0x000b0f2a,0x00000000,0x00000000,0x00000511)    R(0x0976,0x00000005,0x00404a71,0x00364680,0x00334482)    R(0x0977,0x00334281,0x00333f82,0x00222b6c,0x0000004a)\n    R(0x0978,0x00000047,0x0001014d,0x00030050,0x00020055)    R(0x0979,0x00000061,0x00030072,0x0004017f,0x00020084)    R(0x097a,0x00030086,0x00050087,0x00070090,0x0006018b)    R(0x097b,0x00020387,0x00070191,0x0049479c,0x00f8faff)    R(0x097c,0x00fefff8,0x00fefefe,0x00fefdff,0x00ffffff)    R(0x097d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x097e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x097f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0980,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0981,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0982,0x00fffdff,0x00ffffff,0x00fbfff7,0x00fffeff)    R(0x0983,0x00fff7ff,0x00fffff3,0x00f5fffc,0x00a49ffa)    R(0x0984,0x000300bb,0x000a00c9,0x000800c7,0x000602c4)    R(0x0985,0x000402c1,0x000502bf,0x000501be,0x000600be)    R(0x0986,0x000e03b1,0x0004008b,0x00010080,0x0005027e)    R(0x0987,0x00020179,0x00040177,0x0001016c,0x0001005c)\n    R(0x0988,0x00010357,0x001e256a,0x0027387c,0x00243979)    R(0x0989,0x002b3d6d,0x002c344f,0x00000003,0x00000007)    R(0x098a,0x0002030b,0x0001010c,0x00000000,0x00000000)    R(0x098b,0x00000000,0x00000000,0x00000000,0x00000000)    R(0x098c,0x00010113,0x0003091f,0x00000008,0x00080103)    R(0x098d,0x00020007,0x00040b26,0x00354e83,0x003a5697)    R(0x098e,0x00445b9d,0x003c5091,0x003e5192,0x003e5192)    R(0x098f,0x003e5192,0x003e5192,0x003e5192,0x003e5192)\n    R(0x0990,0x003d5192,0x00414e95,0x00425094,0x003d5688)    R(0x0991,0x00365986,0x00375493,0x00314392,0x00434b93)    R(0x0992,0x00494f7a,0x00000009,0x00010007,0x0004020e)    R(0x0993,0x00040310,0x00060718,0x00000002,0x00000000)    R(0x0994,0x00000000,0x00000000,0x00000000,0x00000000)    R(0x0995,0x0000000b,0x00010208,0x00000105,0x0000010b)    R(0x0996,0x00040724,0x00455082,0x00324180,0x00334082)    R(0x0997,0x00323c80,0x00151b60,0x00000048,0x0000004f)\n    R(0x0998,0x00030254,0x00030155,0x00040055,0x00020057)    R(0x0999,0x00040165,0x00070476,0x00040180,0x00000085)    R(0x099a,0x00020087,0x00040088,0x00070091,0x0006018a)    R(0x099b,0x00020484,0x00050092,0x00292391,0x00fbfdff)    R(0x099c,0x00fcfff2,0x00fffffb,0x00fcfcfc,0x00ffffff)    R(0x099d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x099e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x099f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x09a0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x09a1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x09a2,0x00fffcff,0x00fffffe,0x00fbfff7,0x00fffeff)    R(0x09a3,0x00fff8ff,0x00fffff1,0x00f4fffa,0x008e8be4)    R(0x09a4,0x000a00c1,0x000b00ce,0x000900cc,0x000600c9)    R(0x09a5,0x000300c6,0x000600c6,0x000500c4,0x000600c5)    R(0x09a6,0x001204c8,0x000f00af,0x0000008b,0x00020179)    R(0x09a7,0x00020572,0x00060672,0x00060370,0x00040469)\n    R(0x09a8,0x00030360,0x00000152,0x000a1763,0x00243779)    R(0x09a9,0x0026386b,0x003c4465,0x00030312,0x00010208)    R(0x09aa,0x0003050a,0x00050609,0x00010107,0x0001010c)    R(0x09ab,0x00000111,0x00040718,0x0000000e,0x0005050c)    R(0x09ac,0x0004020a,0x00040311,0x0003030e,0x0005030a)    R(0x09ad,0x0000000f,0x0025345a,0x00364e86,0x00354a88)    R(0x09ae,0x003e4c84,0x003e508b,0x003a508d,0x003a508d)    R(0x09af,0x003a508d,0x003a508d,0x003a508d,0x003a508d)\n    R(0x09b0,0x003a508d,0x003e4d92,0x003f4c91,0x003b5285)    R(0x09b1,0x00335584,0x0032508d,0x00354b97,0x0038478f)    R(0x09b2,0x00434e82,0x00040a1d,0x0001010e,0x0002020c)    R(0x09b3,0x00010007,0x00060209,0x00080712,0x00030616)    R(0x09b4,0x00000117,0x00000015,0x0000020e,0x00040410)    R(0x09b5,0x0005020b,0x00010003,0x00030507,0x0000000e)    R(0x09b6,0x001f274d,0x00333e79,0x00303c80,0x00242e74)    R(0x09b7,0x00030b56,0x0000004b,0x00000250,0x00030153)\n    R(0x09b8,0x00010054,0x00000054,0x00030059,0x0002005d)    R(0x09b9,0x0007056f,0x0009077c,0x00040180,0x00020085)    R(0x09ba,0x00010088,0x0003008a,0x00070090,0x00060189)    R(0x09bb,0x00010585,0x00050094,0x00000085,0x00f9fdff)    R(0x09bc,0x00f9fef3,0x00fffffa,0x00fafbfa,0x00ffffff)    R(0x09bd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x09be,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x09bf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x09c0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x09c1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x09c2,0x00fffbff,0x00fdfffb,0x00fdffff,0x00fffdff)    R(0x09c3,0x00fffeff,0x00feffef,0x00eefff3,0x007f82d7)    R(0x09c4,0x000d00c7,0x000900cd,0x000800cc,0x000800cc)    R(0x09c5,0x000800cc,0x000700cb,0x000700cc,0x000700cb)    R(0x09c6,0x000900ce,0x000e02cb,0x000201a2,0x0000007d)    R(0x09c7,0x0007067b,0x00050079,0x00030079,0x00010074)\n    R(0x09c8,0x0001056f,0x00000268,0x00000057,0x00000251)    R(0x09c9,0x00222c6a,0x0032386f,0x00191a41,0x0000000c)    R(0x09ca,0x00030208,0x0000020f,0x00000112,0x00000018)    R(0x09cb,0x0001001a,0x0005011d,0x00030315,0x0003060b)    R(0x09cc,0x00050905,0x000d0802,0x00070403,0x0000010d)    R(0x09cd,0x00030b2d,0x00425285,0x003b4d89,0x003b4d8b)    R(0x09ce,0x003e4e8b,0x003a4d8a,0x00384d8a,0x00384d8a)    R(0x09cf,0x00384d8a,0x00384d8a,0x00384d8a,0x00384d8a)\n    R(0x09d0,0x00384d8a,0x00384d8b,0x003a4e8c,0x00394e8b)    R(0x09d1,0x00394e8a,0x00384e88,0x003c538c,0x0031487f)    R(0x09d2,0x003c5389,0x0025355d,0x0002020b,0x00000002)    R(0x09d3,0x00020403,0x00040704,0x00020609,0x00010312)    R(0x09d4,0x0000001c,0x00000024,0x0000001f,0x00000015)    R(0x09d5,0x0003060e,0x00000405,0x00020509,0x00030419)    R(0x09d6,0x0032396a,0x00313779,0x001c1b68,0x0000004c)    R(0x09d7,0x00020055,0x00030058,0x00000057,0x00000054)\n    R(0x09d8,0x00010352,0x00000350,0x00000067,0x00000075)    R(0x09d9,0x0005037e,0x0005037f,0x00050182,0x00050084)    R(0x09da,0x00050087,0x00050087,0x00070088,0x00050286)    R(0x09db,0x0001028e,0x00020095,0x00000076,0x00f8feff)    R(0x09dc,0x00f2f5f9,0x00fefefe,0x00fefffa,0x00ffffff)    R(0x09dd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x09de,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x09df,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x09e0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x09e1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x09e2,0x00fffbff,0x00fdfffb,0x00fdffff,0x00fffdff)    R(0x09e3,0x00fffdff,0x00fffff5,0x00f0fff8,0x008a8be4)    R(0x09e4,0x000600c4,0x000a00cf,0x000900cc,0x000900cd)    R(0x09e5,0x000900cd,0x000900cc,0x000900cc,0x000900cc)    R(0x09e6,0x000700cb,0x000d08cd,0x000e08c0,0x0002009c)    R(0x09e7,0x00010084,0x00040379,0x00040574,0x00030276)\n    R(0x09e8,0x00000075,0x00020076,0x0000026e,0x0000005e)    R(0x09e9,0x00000056,0x00141461,0x0024225b,0x0001001c)    R(0x09ea,0x0002030e,0x00000013,0x00000018,0x0001001c)    R(0x09eb,0x00050020,0x00060020,0x0004001d,0x00040018)    R(0x09ec,0x00020012,0x00070205,0x00020005,0x00000015)    R(0x09ed,0x00222d56,0x00394882,0x00354987,0x0036488a)    R(0x09ee,0x00374a89,0x00394a8c,0x0039498c,0x0039498c)    R(0x09ef,0x0039498c,0x003a4b8d,0x003a4c8e,0x003a4c8e)\n    R(0x09f0,0x003a4c8e,0x003a4b8d,0x003a4a8d,0x003a4a8d)    R(0x09f1,0x003a4b8b,0x00394b8b,0x003a4c8b,0x00394c89)    R(0x09f2,0x00354884,0x00425183,0x000b0e20,0x00000310)    R(0x09f3,0x00000105,0x00020205,0x00000207,0x0001010e)    R(0x09f4,0x00020019,0x0002001f,0x00010019,0x00030317)    R(0x09f5,0x00060712,0x0001050e,0x00010413,0x0015193f)    R(0x09f6,0x00262c62,0x0000004e,0x00000048,0x00030254)    R(0x09f7,0x00020154,0x00030156,0x00030157,0x00000158)\n    R(0x09f8,0x00000059,0x0000025b,0x00010072,0x0002007c)    R(0x09f9,0x0005037f,0x0004017f,0x00050083,0x00050085)    R(0x09fa,0x00050087,0x00050087,0x00070088,0x00050386)    R(0x09fb,0x0000028e,0x00030094,0x00010175,0x00f7fcff)    R(0x09fc,0x00fbfdff,0x00fefefe,0x00fdfff9,0x00ffffff)    R(0x09fd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x09fe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x09ff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0a00,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a01,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a02,0x00fffcff,0x00fefffb,0x00fdfeff,0x00fffeff)    R(0x0a03,0x00fffcff,0x00fffffc,0x00f2fffd,0x009c99f4)    R(0x0a04,0x000100c2,0x000801d0,0x000700cf,0x000800cf)    R(0x0a05,0x000700cf,0x000700ce,0x000700ce,0x000700ce)    R(0x0a06,0x000602cb,0x000103c7,0x000e04d4,0x001102cb)    R(0x0a07,0x0002019f,0x0000007d,0x00010570,0x0005047a)\n    R(0x0a08,0x0002007e,0x00050082,0x0004007c,0x00010074)    R(0x0a09,0x00040071,0x00000063,0x00060456,0x00030639)    R(0x0a0a,0x00000015,0x0000000e,0x0000000e,0x0001010e)    R(0x0a0b,0x0002030e,0x00030310,0x00040012,0x00010015)    R(0x0a0c,0x00000014,0x0002010d,0x0000000b,0x00121a37)    R(0x0a0d,0x003d4d7c,0x00354883,0x00334787,0x00344888)    R(0x0a0e,0x00364987,0x00364788,0x0036468a,0x0036468a)    R(0x0a0f,0x0036468a,0x0037488c,0x0038498d,0x0038498d)\n    R(0x0a10,0x0038498d,0x0038488d,0x0037468c,0x0037478b)    R(0x0a11,0x0037488b,0x0037488b,0x00334687,0x00384a8a)    R(0x0a12,0x00344685,0x0037467f,0x00374064,0x0003061a)    R(0x0a13,0x0000000d,0x0004050e,0x00000005,0x00020108)    R(0x0a14,0x00040010,0x00060014,0x00040310,0x00050313)    R(0x0a15,0x00010012,0x00000018,0x00010022,0x000a0b46)    R(0x0a16,0x00000041,0x00030858,0x00000156,0x00000152)    R(0x0a17,0x00010253,0x00000151,0x00000256,0x0000005c)\n    R(0x0a18,0x00000066,0x0002006f,0x0005037d,0x00050282)    R(0x0a19,0x00050281,0x00050083,0x00060186,0x00060087)    R(0x0a1a,0x0006008a,0x0006008b,0x00070089,0x00050286)    R(0x0a1b,0x0001028d,0x00060091,0x0018187c,0x00f7fbff)    R(0x0a1c,0x00fdfeff,0x00fefdff,0x00fdfff9,0x00ffffff)    R(0x0a1d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a1e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a1f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0a20,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a21,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a22,0x00fffeff,0x00fffffb,0x00fbfdff,0x00fffeff)    R(0x0a23,0x00fffdff,0x00fffdff,0x00f4ffff,0x00b0acfd)    R(0x0a24,0x000200bf,0x000900d3,0x000800d1,0x000800d1)    R(0x0a25,0x000900d2,0x000900d2,0x000900d2,0x000900d2)    R(0x0a26,0x000703d2,0x000001d0,0x000400d5,0x001305db)    R(0x0a27,0x001207c6,0x0004009c,0x00000084,0x00050481)\n    R(0x0a28,0x0003007c,0x00060081,0x0004007d,0x0005007d)    R(0x0a29,0x0004007d,0x0007007a,0x0004006a,0x00070b57)    R(0x0a2a,0x0001073c,0x00010013,0x0000000c,0x00000501)    R(0x0a2b,0x00000800,0x00000900,0x00000600,0x00000103)    R(0x0a2c,0x00000005,0x00010314,0x00070f2a,0x0038476d)    R(0x0a2d,0x00324477,0x0031457f,0x002f4580,0x00304681)    R(0x0a2e,0x0031497f,0x00344682,0x00354685,0x00354685)    R(0x0a2f,0x00354685,0x00364686,0x00364686,0x00364686)\n    R(0x0a30,0x00364686,0x00364686,0x00364687,0x00364687)    R(0x0a31,0x00364686,0x00364784,0x00364886,0x00314280)    R(0x0a32,0x00374886,0x00344580,0x003e4b7a,0x00233056)    R(0x0a33,0x0004061b,0x0000000b,0x00000006,0x00010006)    R(0x0a34,0x00040007,0x00060009,0x0003000a,0x00010011)    R(0x0a35,0x0000001a,0x0001002e,0x000b064a,0x0003004d)    R(0x0a36,0x0006075d,0x00000159,0x0001025c,0x00000159)    R(0x0a37,0x00010355,0x00010458,0x0000015c,0x00000067)\n    R(0x0a38,0x00020077,0x00090186,0x00070287,0x00040285)    R(0x0a39,0x00040186,0x00050288,0x00050188,0x0005008b)    R(0x0a3a,0x0005008b,0x0005008c,0x0006008b,0x00040287)    R(0x0a3b,0x0002028c,0x0008018e,0x003b3a86,0x00fbffff)    R(0x0a3c,0x00ffffff,0x00fdfcff,0x00fafff9,0x00ffffff)    R(0x0a3d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a3e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a3f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0a40,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a41,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a42,0x00fffffd,0x00fffffc,0x00fbfbff,0x00fefffe)    R(0x0a43,0x00fef9fb,0x00fef6ff,0x00f8ffff,0x00dcd9ff)    R(0x0a44,0x000000b6,0x000600d3,0x000500d1,0x000500d1)    R(0x0a45,0x000600d3,0x000700d3,0x000700d3,0x000700d3)    R(0x0a46,0x000500d8,0x000200dd,0x000602d8,0x000804d3)    R(0x0a47,0x001006d4,0x001308cd,0x000400aa,0x0002008f)\n    R(0x0a48,0x00020480,0x00020379,0x00020378,0x0003017a)    R(0x0a49,0x00030080,0x00050083,0x0005007d,0x0005046f)    R(0x0a4a,0x00050b62,0x000b0848,0x0000002d,0x00000018)    R(0x0a4b,0x0000010a,0x00000305,0x00000505,0x00000307)    R(0x0a4c,0x00020211,0x00101836,0x0036466e,0x00304070)    R(0x0a4d,0x002d3f76,0x002e427b,0x002d437b,0x002e437b)    R(0x0a4e,0x002f4578,0x0032477d,0x0032457e,0x0031447d)    R(0x0a4f,0x0030437c,0x0031447d,0x0032457e,0x0032457d)\n    R(0x0a50,0x0032457d,0x0032457e,0x00334580,0x00334581)    R(0x0a51,0x00324580,0x00334580,0x0030437e,0x0032447f)    R(0x0a52,0x0031447f,0x0032447f,0x0032447d,0x00364576)    R(0x0a53,0x00283259,0x000b0e26,0x00000011,0x0000000d)    R(0x0a54,0x0000000b,0x0002010d,0x00000013,0x0000001d)    R(0x0a55,0x00010035,0x000b0550,0x00060158,0x00020060)    R(0x0a56,0x00020062,0x00000164,0x00020364,0x00000160)    R(0x0a57,0x0000005e,0x00000160,0x00000066,0x00030278)\n    R(0x0a58,0x000b048a,0x00080090,0x0006018d,0x0004028b)    R(0x0a59,0x0004028b,0x0004018c,0x0004018c,0x0004018d)    R(0x0a5a,0x0003008c,0x0002008c,0x0007018e,0x00040486)    R(0x0a5b,0x00010189,0x000f078f,0x0067679c,0x00f7faff)    R(0x0a5c,0x00f8f8f6,0x00fcfdfe,0x00fcfffd,0x00ffffff)    R(0x0a5d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a5e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a5f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0a60,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a61,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a62,0x00fffffb,0x00fffffe,0x00fbfbff,0x00fdfff9)    R(0x0a63,0x00fffefc,0x00fffaff,0x00f9fdfc,0x00f1f1ff)    R(0x0a64,0x000303b5,0x000800d8,0x000a02d9,0x000a01d8)    R(0x0a65,0x000901d7,0x000800d6,0x000800d6,0x000800d6)    R(0x0a66,0x000700dd,0x000400e1,0x000504d7,0x000706d3)    R(0x0a67,0x000a04da,0x001205e5,0x00190ade,0x000502b1)\n    R(0x0a68,0x00000093,0x00000485,0x0000057f,0x0000017b)    R(0x0a69,0x00040281,0x00040085,0x00030085,0x0002007e)    R(0x0a6a,0x00010277,0x000c0275,0x000c036c,0x0004015a)    R(0x0a6b,0x00010143,0x00010133,0x00010233,0x00000136)    R(0x0a6c,0x001e2158,0x0026326c,0x002c3978,0x002a387b)    R(0x0a6d,0x002e3c82,0x002a377d,0x002b397c,0x002b3c7b)    R(0x0a6e,0x002e3e79,0x002e3f79,0x002f3f7a,0x0030407c)    R(0x0a6f,0x0031417c,0x0031417c,0x0031417c,0x0031417c)\n    R(0x0a70,0x0031417b,0x0031417d,0x00334180,0x00334281)    R(0x0a71,0x00344281,0x00334181,0x00303e7f,0x00303d80)    R(0x0a72,0x00303d81,0x002f3d83,0x002e3d83,0x002f3c7d)    R(0x0a73,0x00323c74,0x002f3464,0x000a0c3a,0x00000128)    R(0x0a74,0x0001022a,0x00010128,0x00030139,0x00080448)    R(0x0a75,0x000a0756,0x0007045f,0x00020164,0x00010067)    R(0x0a76,0x00000068,0x00000066,0x00000069,0x00000069)    R(0x0a77,0x0000006d,0x00010276,0x00080783,0x0007048c)\n    R(0x0a78,0x00070290,0x00070093,0x00040090,0x0004008f)    R(0x0a79,0x0004008f,0x0004008f,0x0004008f,0x0004008f)    R(0x0a7a,0x0004008f,0x0003008e,0x0005008f,0x0006038a)    R(0x0a7b,0x00000083,0x000b0388,0x008583ac,0x00fdfefe)    R(0x0a7c,0x00fcfcf7,0x00fcfdfe,0x00fbfffd,0x00ffffff)    R(0x0a7d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a7e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a7f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0a80,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a81,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a82,0x00fffff9,0x00fffeff,0x00fbf9ff,0x00fdfff7)    R(0x0a83,0x00fffff8,0x00fffafe,0x00f8fef5,0x00f9fdff)    R(0x0a84,0x003c3ac3,0x000700d9,0x000801d8,0x000801d8)    R(0x0a85,0x000801d8,0x000801d8,0x000801d8,0x000801d8)    R(0x0a86,0x000800da,0x000b02dd,0x000803da,0x000704dd)    R(0x0a87,0x000802e3,0x000500e3,0x000c00e2,0x001b10e5)\n    R(0x0a88,0x000b02c8,0x000100a4,0x00000090,0x0002038c)    R(0x0a89,0x00000081,0x00060088,0x00050089,0x00020086)    R(0x0a8a,0x00010084,0x00050089,0x00070085,0x0006017f)    R(0x0a8b,0x00040176,0x000a0876,0x00090771,0x0008056f)    R(0x0a8c,0x00000066,0x00000264,0x00000464,0x00000465)    R(0x0a8d,0x000d1171,0x001f227c,0x0022277b,0x00282e7f)    R(0x0a8e,0x002f3481,0x002d3881,0x002c387f,0x002c387f)    R(0x0a8f,0x002c3880,0x002e3981,0x002e3a82,0x002e3a82)\n    R(0x0a90,0x002e3a82,0x002f3a85,0x00303a86,0x002f3986)    R(0x0a91,0x002e3786,0x002e3788,0x002f3789,0x00272f81)    R(0x0a92,0x001e257a,0x001a1f77,0x00080f6e,0x00040664)    R(0x0a93,0x00000058,0x00000054,0x00050457,0x00040558)    R(0x0a94,0x00010558,0x0004095c,0x00090463,0x00070364)    R(0x0a95,0x00010166,0x00000067,0x0000026d,0x0000006d)    R(0x0a96,0x0001006c,0x0002006b,0x00000070,0x00000076)    R(0x0a97,0x00030184,0x00080391,0x000a0497,0x00070195)\n    R(0x0a98,0x00020090,0x0002008f,0x00030091,0x00030092)    R(0x0a99,0x00030092,0x00030092,0x00030091,0x00030091)    R(0x0a9a,0x00020090,0x00010090,0x0003008f,0x0005028a)    R(0x0a9b,0x00020085,0x00000085,0x00a8a5d7,0x00fbfdfd)    R(0x0a9c,0x00fffffa,0x00fcfdff,0x00fbfffe,0x00ffffff)    R(0x0a9d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a9e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0a9f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0aa0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0aa1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0aa2,0x00fffff9,0x00fffeff,0x00fbf9ff,0x00fbfff5)    R(0x0aa3,0x00fffff7,0x00fffafe,0x00fefff7,0x00f5fdfc)    R(0x0aa4,0x006d6dce,0x000b03de,0x000600d7,0x000700d8)    R(0x0aa5,0x000a02db,0x000a02db,0x000a02db,0x000a02db)    R(0x0aa6,0x000b06d7,0x000c07d4,0x000c02e2,0x000800ea)    R(0x0aa7,0x000502e6,0x000907e2,0x000d08e7,0x000b00ea)\n    R(0x0aa8,0x001906f7,0x00140cdd,0x000502b9,0x00000098)    R(0x0aa9,0x0005038d,0x0008028a,0x00070089,0x00040088)    R(0x0aaa,0x00020285,0x0000027f,0x0000027e,0x00010282)    R(0x0aab,0x00040584,0x000c0b8a,0x00060382,0x0002007e)    R(0x0aac,0x0000007b,0x00010077,0x00020279,0x00040378)    R(0x0aad,0x00030072,0x00010069,0x00030068,0x00050267)    R(0x0aae,0x00080667,0x000b0e69,0x000b1269,0x000e156c)    R(0x0aaf,0x0011186e,0x00131970,0x0012196f,0x0012196f)\n    R(0x0ab0,0x0012196f,0x000f156e,0x00060c68,0x00040965)    R(0x0ab1,0x00010564,0x00000363,0x00000162,0x00000064)    R(0x0ab2,0x00000065,0x00000066,0x0000006e,0x0002006e)    R(0x0ab3,0x00080371,0x0005006f,0x00040072,0x00000073)    R(0x0ab4,0x00000177,0x00000075,0x00020074,0x00010074)    R(0x0ab5,0x00000173,0x00000270,0x0000006d,0x0000006e)    R(0x0ab6,0x00010071,0x00040071,0x00010179,0x00070588)    R(0x0ab7,0x000c0798,0x000a019f,0x0004009e,0x0005009b)\n    R(0x0ab8,0x00030295,0x0004058f,0x00040192,0x00040095)    R(0x0ab9,0x00040095,0x00040095,0x00040193,0x00030092)    R(0x0aba,0x00030092,0x00020090,0x0002008f,0x00010088)    R(0x0abb,0x00080789,0x0000007a,0x00e2ddff,0x00fcfdfe)    R(0x0abc,0x00fffef9,0x00fefdff,0x00f7fefb,0x00ffffff)    R(0x0abd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0abe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0abf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0ac0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ac1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ac2,0x00fffffe,0x00ffffff,0x00fdfeff,0x00fdfffd)    R(0x0ac3,0x00fffffc,0x00fffeff,0x00fffffd,0x00feffff)    R(0x0ac4,0x009694e6,0x000000ce,0x001004df,0x000b10d0)    R(0x0ac5,0x000500d4,0x000d00e2,0x000d00e2,0x000a01e3)    R(0x0ac6,0x000b06dd,0x000e05e1,0x000d05e6,0x000d04e9)    R(0x0ac7,0x000c05e8,0x000c06e7,0x000e05e8,0x000e03ed)\n    R(0x0ac8,0x000e03ed,0x000d09e8,0x001712eb,0x00150fd9)    R(0x0ac9,0x000201b9,0x000000a1,0x00010096,0x0001028a)    R(0x0aca,0x0000017f,0x00070682,0x00090583,0x00060584)    R(0x0acb,0x00050286,0x00050189,0x00040089,0x0000008a)    R(0x0acc,0x0000008a,0x00030183,0x00030283,0x00050281)    R(0x0acd,0x00060281,0x0005007c,0x0005007b,0x0007007b)    R(0x0ace,0x0007007a,0x00040278,0x00030377,0x00030376)    R(0x0acf,0x00030475,0x00030475,0x00030475,0x00030473)\n    R(0x0ad0,0x00030473,0x00020474,0x00010374,0x00010372)    R(0x0ad1,0x00010472,0x00010471,0x00020570,0x00020670)    R(0x0ad2,0x00020670,0x00020670,0x00030474,0x00030375)    R(0x0ad3,0x00030276,0x0003007b,0x0003007f,0x00010082)    R(0x0ad4,0x00000083,0x00010081,0x0008026e,0x0007026f)    R(0x0ad5,0x00040073,0x00000076,0x00000078,0x0000007f)    R(0x0ad6,0x00010089,0x00040292,0x000a08a0,0x000703a0)    R(0x0ad7,0x0003009e,0x0003009c,0x0007009f,0x0007009d)\n    R(0x0ad8,0x0008009a,0x00070196,0x00050099,0x00030099)    R(0x0ad9,0x00040097,0x00030094,0x00050093,0x00060291)    R(0x0ada,0x0005028e,0x0006018c,0x0002068c,0x00070586)    R(0x0adb,0x00060085,0x0000007a,0x00fffaff,0x00fffcff)    R(0x0adc,0x00fffbff,0x00fcfefe,0x00fbfff8,0x00ffffff)    R(0x0add,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ade,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0adf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0ae0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ae1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ae2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ae3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ae4,0x00dbdcfe,0x000000d1,0x000500d8,0x000106cd)    R(0x0ae5,0x000c0ade,0x000d00e1,0x000f01e5,0x000c01e7)    R(0x0ae6,0x000a06df,0x000b05e6,0x000c06e7,0x000c06e7)    R(0x0ae7,0x000d06e9,0x000d06eb,0x000d06eb,0x000d05ec)\n    R(0x0ae8,0x000d05ec,0x000a03ed,0x000a04eb,0x00170cee)    R(0x0ae9,0x001f15ec,0x001a11d7,0x000603b5,0x00000098)    R(0x0aea,0x0000008e,0x00040093,0x00050092,0x00060191)    R(0x0aeb,0x0004018e,0x0001008b,0x00020189,0x00010189)    R(0x0aec,0x00020389,0x0005008f,0x0005008f,0x0005008f)    R(0x0aed,0x0007008e,0x0007008e,0x0008008d,0x0008008c)    R(0x0aee,0x000a008b,0x0006008a,0x0005008a,0x00050089)    R(0x0aef,0x00050089,0x00050087,0x00050086,0x00050086)\n    R(0x0af0,0x00050086,0x00050086,0x00040086,0x00040086)    R(0x0af1,0x00040085,0x00040085,0x00040084,0x00040082)    R(0x0af2,0x00040082,0x00040082,0x00040081,0x0004007f)    R(0x0af3,0x0004007e,0x0004017c,0x0005037b,0x0006037a)    R(0x0af4,0x00060477,0x00070477,0x000a027d,0x0005007c)    R(0x0af5,0x00030080,0x00020085,0x00060090,0x00070298)    R(0x0af6,0x000b06a3,0x000d08a7,0x000600a5,0x0000009f)    R(0x0af7,0x0000009d,0x000600a2,0x0007009f,0x0007009d)\n    R(0x0af8,0x0008009b,0x0008009a,0x0005009a,0x0003009a)    R(0x0af9,0x00040099,0x00040095,0x00050093,0x00060291)    R(0x0afa,0x0006028d,0x0006018b,0x00020287,0x0003058f)    R(0x0afb,0x00110688,0x00736ea7,0x00fcfbff,0x00fffeff)    R(0x0afc,0x00fffbff,0x00fbfefe,0x00fbfff8,0x00ffffff)    R(0x0afd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0afe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0aff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0b00,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b01,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b02,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b03,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b04,0x00f0f9ff,0x002b27c0,0x001502ea,0x000501da)    R(0x0b05,0x000806d9,0x000e03de,0x001000e9,0x000c04e8)    R(0x0b06,0x000b09e2,0x000d06e9,0x000d06e9,0x000e07ea)    R(0x0b07,0x000e07ec,0x001009ee,0x001008ef,0x001008ef)\n    R(0x0b08,0x001006f2,0x000b03f2,0x000a00ef,0x000f02f2)    R(0x0b09,0x001609f4,0x001307ea,0x001c15e8,0x001c16dd)    R(0x0b0a,0x00130fce,0x000100b2,0x000000a9,0x000000a2)    R(0x0b0b,0x0001009f,0x00010096,0x0001038f,0x0002058a)    R(0x0b0c,0x00020788,0x00060094,0x00060098,0x00060096)    R(0x0b0d,0x00080093,0x00060090,0x0008008f,0x0008008d)    R(0x0b0e,0x0009008c,0x00090091,0x00070094,0x00070092)    R(0x0b0f,0x00070092,0x00070091,0x00070190,0x00070190)\n    R(0x0b10,0x00070190,0x00070190,0x00060090,0x00060090)    R(0x0b11,0x00060090,0x00060090,0x00050090,0x0005008f)    R(0x0b12,0x0005008f,0x0007008f,0x0009008b,0x00090089)    R(0x0b13,0x00090086,0x00090183,0x0008027e,0x0007027b)    R(0x0b14,0x00060376,0x00050178,0x00010093,0x00030097)    R(0x0b15,0x0007019e,0x000f07a7,0x001109ad,0x001008ae)    R(0x0b16,0x000b02ac,0x000500a7,0x000000a0,0x000300a3)    R(0x0b17,0x000600a5,0x000801a5,0x000600a1,0x000800a0)\n    R(0x0b18,0x0007009d,0x0008009b,0x0006009c,0x0004009b)    R(0x0b19,0x00050099,0x00040096,0x00050093,0x00060291)    R(0x0b1a,0x0006028d,0x0006018c,0x0002008d,0x0003018f)    R(0x0b1b,0x00010079,0x00a5a2cf,0x00fcfcff,0x00fffffc)    R(0x0b1c,0x00fffeff,0x00fdfeff,0x00fbfffc,0x00ffffff)    R(0x0b1d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b1e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b1f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0b20,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b21,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b22,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b23,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b24,0x00f0feff,0x007b7dcf,0x000f00de,0x000600e4)    R(0x0b25,0x000605d6,0x000d06db,0x000f01ec,0x000f06eb)    R(0x0b26,0x000c0ce3,0x000c07ec,0x000d08ed,0x000d08ed)    R(0x0b27,0x000e08ef,0x00100af3,0x00100af3,0x001009f4)\n    R(0x0b28,0x001009f4,0x00170bfc,0x00170afc,0x000c01f7)    R(0x0b29,0x000800f3,0x000e03f7,0x000d04f3,0x000e08ef)    R(0x0b2a,0x00110aec,0x001d19ee,0x001915e5,0x000d09d1)    R(0x0b2b,0x000100bb,0x000000ac,0x000000a2,0x00000099)    R(0x0b2c,0x00000093,0x00000095,0x00010094,0x00010091)    R(0x0b2d,0x0003018f,0x0005028d,0x0005048a,0x00070489)    R(0x0b2e,0x00070587,0x0006048b,0x0006048c,0x0006048c)    R(0x0b2f,0x0006058b,0x0006058b,0x0006058a,0x0006058a)\n    R(0x0b30,0x00060589,0x00060589,0x0005048a,0x0005038b)    R(0x0b31,0x0005038b,0x0005028d,0x0006038f,0x00060291)    R(0x0b32,0x00060192,0x00060291,0x00040289,0x0004018c)    R(0x0b33,0x0004008e,0x00040091,0x00030093,0x00060099)    R(0x0b34,0x000b00a2,0x000c01a7,0x000b06b8,0x001009bb)    R(0x0b35,0x001108bb,0x001007b8,0x000901b0,0x000801ad)    R(0x0b36,0x000600aa,0x000400a8,0x000600a8,0x000601aa)    R(0x0b37,0x000801a8,0x000701a6,0x000700a4,0x000600a1)\n    R(0x0b38,0x000800a0,0x0007009d,0x0005009f,0x0004009c)    R(0x0b39,0x0006009b,0x00050097,0x00060094,0x00060291)    R(0x0b3a,0x0006018f,0x0006018c,0x00050093,0x0006018e)    R(0x0b3b,0x0000006d,0x00e0defd,0x00fffffd,0x00fffff7)    R(0x0b3c,0x00fffffd,0x00fdfeff,0x00fbffff,0x00ffffff)    R(0x0b3d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b3e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b3f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0b40,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b41,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b42,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b43,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b44,0x00f6fff9,0x00c1c3fc,0x000000be,0x000f02e6)    R(0x0b45,0x000b07db,0x000c07db,0x000f01ee,0x000c06ea)    R(0x0b46,0x000a0be4,0x000d07ee,0x000f09f0,0x00100af2)    R(0x0b47,0x00110bf4,0x001009f4,0x00110af5,0x001109f6)\n    R(0x0b48,0x00120bf6,0x00120cf4,0x00140df9,0x001106f7)    R(0x0b49,0x000800f5,0x000700f5,0x000300f3,0x000400f3)    R(0x0b4a,0x000801f3,0x000c09ee,0x000c09ec,0x00110ceb)    R(0x0b4b,0x001b14ee,0x001e17ea,0x001c13df,0x00190dd5)    R(0x0b4c,0x001309cb,0x000703b1,0x000502a9,0x000000a3)    R(0x0b4d,0x0000009b,0x00000092,0x00000091,0x00000090)    R(0x0b4e,0x00010090,0x00020092,0x00030193,0x00030193)    R(0x0b4f,0x00040392,0x00030291,0x00030390,0x00030390)\n    R(0x0b50,0x0004058f,0x00030390,0x00020190,0x0001008f)    R(0x0b51,0x00010091,0x00010091,0x00000093,0x00000093)    R(0x0b52,0x00000094,0x00000096,0x0000009b,0x000101a2)    R(0x0b53,0x000604ad,0x000903b7,0x000c04c1,0x001106cb)    R(0x0b54,0x001407d2,0x001307d2,0x000d08c4,0x000703bc)    R(0x0b55,0x000301b6,0x000101b1,0x000100ac,0x000500ab)    R(0x0b56,0x000900ab,0x000a01ac,0x000601ac,0x000701ac)    R(0x0b57,0x000600ab,0x000700a7,0x000701a6,0x000801a5)\n    R(0x0b58,0x000701a2,0x000600a1,0x000601a0,0x000601a0)    R(0x0b59,0x0007019c,0x0006019a,0x00070197,0x00060193)    R(0x0b5a,0x00060190,0x0005008c,0x00050092,0x000c028c)    R(0x0b5b,0x003f3d8e,0x00f5f7ff,0x00fffffc,0x00fffff7)    R(0x0b5c,0x00fffffa,0x00fdffff,0x00fbfeff,0x00ffffff)    R(0x0b5d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b5e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b5f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0b60,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b61,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b62,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b63,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b64,0x00fdfff8,0x00f1f4ff,0x001100c2,0x001004e2)    R(0x0b65,0x000603d9,0x000a05df,0x000d02ee,0x000a07e9)    R(0x0b66,0x000909e8,0x000c08f1,0x000d09f2,0x000f0af5)    R(0x0b67,0x000f0af5,0x000f09f6,0x00100af9,0x00100af9)\n    R(0x0b68,0x00110cf7,0x00130ff1,0x00150ff6,0x00120df7)    R(0x0b69,0x000e09f5,0x000a05f5,0x000600f2,0x000300f1)    R(0x0b6a,0x000200f0,0x000501ee,0x000501ed,0x000701ed)    R(0x0b6b,0x000c03ee,0x001308f2,0x001608f4,0x001b0bf5)    R(0x0b6c,0x001d0cf9,0x002014f1,0x001f15ec,0x002014e9)    R(0x0b6d,0x001f14e4,0x001b10dc,0x00170ed4,0x001207cc)    R(0x0b6e,0x000c03c6,0x000800be,0x000700bb,0x000500b9)    R(0x0b6f,0x000300b5,0x000300b6,0x000300b3,0x000300b4)\n    R(0x0b70,0x000300b3,0x000300b4,0x000500b6,0x000701b7)    R(0x0b71,0x000902ba,0x000a03bd,0x000d05c1,0x001008c5)    R(0x0b72,0x00160cc9,0x00160ccf,0x00140cdc,0x00120cda)    R(0x0b73,0x00110bd8,0x00100ad7,0x000e09d5,0x000a06d0)    R(0x0b74,0x000502cb,0x000201c4,0x000201bb,0x000000b5)    R(0x0b75,0x000000b1,0x000000ae,0x000400af,0x000701ac)    R(0x0b76,0x000901ac,0x000902ab,0x000601ae,0x000500af)    R(0x0b77,0x000400ad,0x000500aa,0x000700a7,0x000701a6)\n    R(0x0b78,0x000700a4,0x000600a3,0x000600a1,0x000601a0)    R(0x0b79,0x0007009d,0x0006019a,0x00070197,0x00060093)    R(0x0b7a,0x00060190,0x0005008d,0x0005008f,0x000e0382)    R(0x0b7b,0x009899b6,0x00f4f9ff,0x00f9f8f6,0x00fffff9)    R(0x0b7c,0x00fffff8,0x00fdffff,0x00fbfdff,0x00ffffff)    R(0x0b7d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b7e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b7f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0b80,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b81,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b82,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b83,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b84,0x00fffcfe,0x00f4faff,0x00797ac7,0x001205d5)    R(0x0b85,0x000802de,0x000902e5,0x000c03eb,0x000a07e9)    R(0x0b86,0x000907ec,0x000c07f2,0x000e09f4,0x000f09f6)    R(0x0b87,0x00100af7,0x00110bf9,0x00110bfa,0x00120bfc)\n    R(0x0b88,0x00120cfa,0x00120df6,0x001410f8,0x001511fa)    R(0x0b89,0x001410f9,0x00130ef9,0x00100bf7,0x000d07f3)    R(0x0b8a,0x000905f0,0x000500ee,0x000802f0,0x000801f0)    R(0x0b8b,0x000700f0,0x000700ef,0x000b00f3,0x000f01f6)    R(0x0b8c,0x001203fa,0x000f03f6,0x000f03f6,0x001206f7)    R(0x0b8d,0x001408f8,0x001a0cfb,0x001c0ffb,0x001f10fa)    R(0x0b8e,0x002011fa,0x002315fa,0x002416f8,0x002316f7)    R(0x0b8f,0x002316f7,0x002315f4,0x002216f3,0x002115f2)\n    R(0x0b90,0x002015f1,0x001f14ee,0x001c11eb,0x001b10ea)    R(0x0b91,0x001b0fea,0x001b10ea,0x00180de8,0x00160be5)    R(0x0b92,0x001308e1,0x001004e1,0x000d02e1,0x000a01dc)    R(0x0b93,0x000601d4,0x000501ce,0x000401c6,0x000201bf)    R(0x0b94,0x000001b8,0x000002b5,0x000000b2,0x000200b3)    R(0x0b95,0x000400b3,0x000501b2,0x000a03b4,0x000b03b2)    R(0x0b96,0x000901b1,0x000800b0,0x000400b0,0x000500af)    R(0x0b97,0x000400ae,0x000500aa,0x000500a9,0x000700a7)\n    R(0x0b98,0x000600a5,0x000500a4,0x000600a1,0x000600a1)    R(0x0b99,0x0007009d,0x0006009b,0x00070098,0x00060094)    R(0x0b9a,0x00060091,0x0005008e,0x0007008b,0x00000060)    R(0x0b9b,0x00e2e8f9,0x00f7fcfd,0x00fefdfe,0x00fffefd)    R(0x0b9c,0x00fffff8,0x00fffffc,0x00fbfeff,0x00ffffff)    R(0x0b9d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b9e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0b9f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0ba0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ba1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ba2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ba3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ba4,0x00fff8ff,0x00fafbfb,0x00bcc6f9,0x000000cc)    R(0x0ba5,0x000700e1,0x000900eb,0x000c03eb,0x000907e9)    R(0x0ba6,0x000805f1,0x000c09f3,0x000d09f5,0x000f0bf8)    R(0x0ba7,0x00100bfa,0x00110cfb,0x00120cfd,0x00120cfd)\n    R(0x0ba8,0x00130dfe,0x00120cfe,0x00120dfc,0x00130efc)    R(0x0ba9,0x00160ffa,0x001610f9,0x001a12fa,0x001912f7)    R(0x0baa,0x00180ef7,0x001408f8,0x000f04f5,0x000b02ef)    R(0x0bab,0x000801ee,0x000902ed,0x000600ed,0x000400eb)    R(0x0bac,0x000200e8,0x000401ed,0x000502ef,0x000605f0)    R(0x0bad,0x000a06f1,0x000b05ef,0x000b05ef,0x000f05ef)    R(0x0bae,0x001006ef,0x001005ec,0x001004ec,0x001005ec)    R(0x0baf,0x001005eb,0x001106eb,0x001106ea,0x000f05e8)\n    R(0x0bb0,0x000e05e6,0x000e06e6,0x000d06e4,0x000c05e1)    R(0x0bb1,0x000b04e0,0x000904dd,0x000702db,0x000601d9)    R(0x0bb2,0x000301d7,0x000502d3,0x000e03c5,0x000c01c2)    R(0x0bb3,0x000b01c0,0x000a00bd,0x000800b8,0x000600b4)    R(0x0bb4,0x000500b3,0x000500b3,0x000b03b5,0x000c04b6)    R(0x0bb5,0x000b03b9,0x000a01b7,0x000a00b7,0x000a00b7)    R(0x0bb6,0x000900b8,0x000800b7,0x000400b1,0x000300b0)    R(0x0bb7,0x000400ae,0x000300ac,0x000500aa,0x000700a7)\n    R(0x0bb8,0x000600a6,0x000500a4,0x000600a3,0x000600a1)    R(0x0bb9,0x0007009f,0x0006009b,0x00070098,0x00060096)    R(0x0bba,0x00060093,0x0005008e,0x0010068d,0x00404391)    R(0x0bbb,0x00f3fdff,0x00fcfffc,0x00fffbff,0x00fffbff)    R(0x0bbc,0x00fffff9,0x00fffffa,0x00fbfeff,0x00ffffff)    R(0x0bbd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0bbe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0bbf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0bc0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0bc1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0bc2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0bc3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0bc4,0x00fcf7ff,0x00fcfef8,0x00eef1fd,0x003425cc)    R(0x0bc5,0x000f02dd,0x000302e9,0x000505ef,0x000a06ee)    R(0x0bc6,0x000f07f0,0x000d07f4,0x000f09f6,0x00100af8)    R(0x0bc7,0x00110bfa,0x00120bfc,0x00120cfd,0x00130dff)\n    R(0x0bc8,0x00110dff,0x00120cff,0x00130dff,0x00140eff)    R(0x0bc9,0x00140ffc,0x001610fb,0x001711fc,0x001812fb)    R(0x0bca,0x001711fb,0x001516fb,0x001611fe,0x001b0dfc)    R(0x0bcb,0x001b0dfb,0x000d06f4,0x000706e7,0x000503e3)    R(0x0bcc,0x000600ee,0x000001eb,0x000004e8,0x000000ea)    R(0x0bcd,0x000000f4,0x000401e2,0x000304e0,0x000100e4)    R(0x0bce,0x000202ea,0x000202e7,0x000300e6,0x000101e4)    R(0x0bcf,0x000000e0,0x000000e0,0x000000dc,0x000000dd)\n    R(0x0bd0,0x000000db,0x000001d0,0x000004ce,0x000200d9)    R(0x0bd1,0x000600d9,0x000403d3,0x000201d2,0x000601d4)    R(0x0bd2,0x000200c1,0x001008c1,0x000000c0,0x001205c3)    R(0x0bd3,0x000500b8,0x000604c1,0x000200c6,0x000200c9)    R(0x0bd4,0x000903c4,0x000c02be,0x000a02c2,0x000902c2)    R(0x0bd5,0x000a01c1,0x000900bf,0x000800bc,0x000700ba)    R(0x0bd6,0x000700b9,0x000800b9,0x000600b3,0x000500b1)    R(0x0bd7,0x000500af,0x000500ad,0x000500a9,0x000700a7)\n    R(0x0bd8,0x000601a4,0x000600a3,0x000400a4,0x0004029e)    R(0x0bd9,0x00040299,0x0003009d,0x0005019c,0x0002028b)    R(0x0bda,0x00010185,0x000a009b,0x00030179,0x00aba5d3)    R(0x0bdb,0x00fafaff,0x00fbfdfe,0x00fdfafc,0x00fffeff)    R(0x0bdc,0x00fffffd,0x00fffffe,0x00fefeff,0x00ffffff)    R(0x0bdd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0bde,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0bdf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0be0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0be1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0be2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0be3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0be4,0x00fdfeff,0x00fcfff8,0x00f8f7fe,0x009e95e6)    R(0x0be5,0x000300c8,0x000101e5,0x000306f3,0x000802ed)    R(0x0be6,0x001006ee,0x000f07f4,0x001008f5,0x00120af7)    R(0x0be7,0x00110bfa,0x00120bfc,0x00120cfd,0x00130dff)\n    R(0x0be8,0x00110dff,0x00130dff,0x00130dff,0x00140eff)    R(0x0be9,0x00140eff,0x001510fe,0x001511fd,0x001511fd)    R(0x0bea,0x001311fc,0x000f19fa,0x001613ff,0x001e11ff)    R(0x0beb,0x001e10ff,0x001b16fe,0x001418f5,0x001412f3)    R(0x0bec,0x001405fd,0x000707f6,0x000000bc,0x004453df)    R(0x0bed,0x003929e3,0x000000cc,0x000000b5,0x000000c5)    R(0x0bee,0x000000db,0x000000e5,0x000000e2,0x000000e2)    R(0x0bef,0x000000e2,0x000000e3,0x000000de,0x000000dd)\n    R(0x0bf0,0x000000dd,0x000000d4,0x000000d0,0x000000d8)    R(0x0bf1,0x000000d1,0x000000c4,0x000000b6,0x000000b7)    R(0x0bf2,0x000000a6,0x0000009e,0x002e22c7,0x000000ac)    R(0x0bf3,0x000f08ab,0x000504bf,0x000604da,0x000400dd)    R(0x0bf4,0x000801cf,0x000d02c1,0x000600c9,0x000600c9)    R(0x0bf5,0x000700c5,0x000600c3,0x000600bf,0x000700bd)    R(0x0bf6,0x000600ba,0x000600b8,0x000600b4,0x000600b1)    R(0x0bf7,0x000500af,0x000600ad,0x000500a9,0x000701a6)\n    R(0x0bf8,0x000601a4,0x000600a1,0x000400a4,0x0004029d)    R(0x0bf9,0x00010397,0x0002009d,0x00000098,0x0005078e)    R(0x0bfa,0x000c0b8b,0x00050095,0x00000067,0x00f6f0fa)    R(0x0bfb,0x00fbf5ff,0x00faf8ff,0x00fdfcfd,0x00fffffd)    R(0x0bfc,0x00fffffe,0x00fffeff,0x00fffeff,0x00ffffff)    R(0x0bfd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0bfe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0bff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0c00,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c01,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c02,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c03,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c04,0x00fefff8,0x00fafaf7,0x00fefcff,0x00e2e3fc)    R(0x0c05,0x000000b1,0x000e0ae7,0x000001ea,0x000908ed)    R(0x0c06,0x001109f3,0x000e06f3,0x000f07f4,0x001109f7)    R(0x0c07,0x00100af9,0x00120bfc,0x00120cfd,0x00130dff)\n    R(0x0c08,0x00110dff,0x00130dff,0x00140eff,0x00150fff)    R(0x0c09,0x00150fff,0x001510ff,0x001511fd,0x001511fd)    R(0x0c0a,0x001411fd,0x000f17fc,0x001612ff,0x001d10ff)    R(0x0c0b,0x001a12ff,0x001413fb,0x001419fd,0x001918fe)    R(0x0c0c,0x002112ff,0x001200e9,0x008074e9,0x00c7cbfa)    R(0x0c0d,0x00a8a9e6,0x009f9deb,0x009c9ef2,0x009898f2)    R(0x0c0e,0x009e93f4,0x007a77ef,0x006f6ee8,0x006160dd)    R(0x0c0f,0x005352d4,0x004141cb,0x003332c2,0x00302fc0)\n    R(0x0c10,0x003435c3,0x004240ce,0x00564be0,0x00614fe4)    R(0x0c11,0x006c60db,0x007073ce,0x008087dc,0x008488e2)    R(0x0c12,0x007d83cb,0x008991c0,0x009aa5d4,0x008a8eca)    R(0x0c13,0x00000083,0x002215bb,0x000c01d8,0x000900e3)    R(0x0c14,0x000a00d2,0x001105c5,0x000700cc,0x000600cb)    R(0x0c15,0x000800c8,0x000700c4,0x000700c0,0x000700be)    R(0x0c16,0x000700bb,0x000600b9,0x000600b4,0x000600b1)    R(0x0c17,0x000500af,0x000600ad,0x000500a9,0x000701a6)\n    R(0x0c18,0x000601a4,0x000600a1,0x000500a3,0x0004009e)    R(0x0c19,0x00030199,0x00020199,0x0005029d,0x00030291)    R(0x0c1a,0x000a048d,0x00080084,0x009d97c1,0x00fcf6ff)    R(0x0c1b,0x00fdf9ff,0x00fbfbfd,0x00fffffd,0x00fffffd)    R(0x0c1c,0x00fffffe,0x00fffeff,0x00fffeff,0x00ffffff)    R(0x0c1d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c1e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c1f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0c20,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c21,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c22,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c23,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c24,0x00fffff8,0x00fefafb,0x00f8f7f7,0x00f1fbfd)    R(0x0c25,0x009399e3,0x000000d0,0x000800ed,0x000b09f1)    R(0x0c26,0x000d07f1,0x000e05f3,0x000f07f4,0x001008f6)    R(0x0c27,0x000f09f8,0x00120bfc,0x00120cfd,0x00130dff)\n    R(0x0c28,0x00110dff,0x00140eff,0x00150fff,0x00150fff)    R(0x0c29,0x001610ff,0x001510ff,0x001511fd,0x001511fd)    R(0x0c2a,0x001411fe,0x001112ff,0x001612fd,0x001a10ff)    R(0x0c2b,0x001612fd,0x000f15f8,0x000e14ff,0x001411ff)    R(0x0c2c,0x001b0ff5,0x006c5cd7,0x00d4c2ff,0x00d4ccf2)    R(0x0c2d,0x00cacde3,0x00c6c9f9,0x00aeaff8,0x00bebdf5)    R(0x0c2e,0x00c4bfe6,0x00bdbceb,0x00b9bcee,0x00bbbeef)    R(0x0c2f,0x00bdbff1,0x00babcef,0x00b5b6ea,0x00b5b5eb)\n    R(0x0c30,0x00b6b6ed,0x00b0b4e9,0x00afb0e9,0x00b1abe4)    R(0x0c31,0x00adacce,0x00a2afc0,0x00a2afd3,0x008289ca)    R(0x0c32,0x009da1db,0x00a0a9c0,0x00abbbb6,0x00aeb5c1)    R(0x0c33,0x008c88b9,0x00050085,0x001a05ce,0x001300e6)    R(0x0c34,0x000d00d8,0x001003ca,0x000801cd,0x000701cc)    R(0x0c35,0x000801c9,0x000801c6,0x000800c1,0x000800be)    R(0x0c36,0x000700bc,0x000700ba,0x000600b3,0x000600b1)    R(0x0c37,0x000500af,0x000600ad,0x000500a9,0x000701a6)\n    R(0x0c38,0x000601a4,0x000600a1,0x0006009f,0x000500a1)    R(0x0c39,0x0003019c,0x00020294,0x00000195,0x0005009b)    R(0x0c3a,0x000f0290,0x00000061,0x00eaebf8,0x00faf7fd)    R(0x0c3b,0x00fdfdfe,0x00fefefd,0x00fefffb,0x00fffffc)    R(0x0c3c,0x00fffffe,0x00fffeff,0x00fffeff,0x00ffffff)    R(0x0c3d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c3e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c3f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0c40,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c41,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c42,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c43,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c44,0x00fffdfe,0x00fffafe,0x00fcfcfa,0x00f4fef9)    R(0x0c45,0x00e3ebfd,0x000000c6,0x001504ed,0x000504ef)    R(0x0c46,0x000b0bef,0x000d05f2,0x000f07f4,0x001008f6)    R(0x0c47,0x000f09f8,0x00110afb,0x00120cfd,0x00140eff)\n    R(0x0c48,0x00110dff,0x00140eff,0x00150fff,0x001610ff)    R(0x0c49,0x001610ff,0x001611ff,0x001612fe,0x001612fe)    R(0x0c4a,0x001612ff,0x00130fff,0x001713fd,0x001810ff)    R(0x0c4b,0x001213fd,0x000e19f7,0x000a0dff,0x001911ff)    R(0x0c4c,0x001a18dc,0x00c4c6f1,0x00d8dbde,0x00c6ccd4)    R(0x0c4d,0x00c8cefa,0x008685e3,0x005e59d0,0x009e97f0)    R(0x0c4e,0x00cbc8e8,0x00d0d0e5,0x00cfd0eb,0x00d1d1ee)    R(0x0c4f,0x00d2d1f1,0x00d1d0f2,0x00cfcef1,0x00cfccf2)\n    R(0x0c50,0x00cecaf3,0x00c8c9e8,0x00c5c7e0,0x00c9c6db)    R(0x0c51,0x00c2c2c9,0x00b2bbc7,0x00a4a8e6,0x003e40a1)    R(0x0c52,0x005e5abc,0x008884da,0x00a9afcc,0x00a9aeb9)    R(0x0c53,0x00b7b6d4,0x004e4798,0x001201ac,0x001203db)    R(0x0c54,0x000a00dc,0x000700d1,0x000902d0,0x000801cd)    R(0x0c55,0x000901ca,0x000801c7,0x000901c3,0x000901c1)    R(0x0c56,0x000802be,0x000700bc,0x000701b4,0x000601b1)    R(0x0c57,0x000601af,0x000600ad,0x000400a8,0x000600a5)\n    R(0x0c58,0x000500a3,0x000500a0,0x0006009c,0x000400a1)    R(0x0c59,0x0003009c,0x00020491,0x000d089c,0x000a009c)    R(0x0c5a,0x00000078,0x00a4a8c9,0x00f5fdff,0x00fdfdfd)    R(0x0c5b,0x00fefefb,0x00fdfefa,0x00fffffa,0x00fffffd)    R(0x0c5c,0x00fffffe,0x00fffeff,0x00fffeff,0x00ffffff)    R(0x0c5d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c5e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c5f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0c60,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c61,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c62,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c63,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c64,0x00fff9ff,0x00fffbff,0x00fffffb,0x00fafffd)    R(0x0c65,0x00f4f8ff,0x00b0a9ee,0x000000d2,0x000600ec)    R(0x0c66,0x000809ec,0x000d05f2,0x000e06f3,0x001008f6)    R(0x0c67,0x000f09f8,0x00100afb,0x00120cfd,0x00130dff)\n    R(0x0c68,0x00110dff,0x00140eff,0x00150fff,0x001610ff)    R(0x0c69,0x001610ff,0x001611ff,0x001713ff,0x001814ff)    R(0x0c6a,0x001813ff,0x00150eff,0x001714fa,0x00160fff)    R(0x0c6b,0x001113fe,0x000c19f3,0x000f0fff,0x001a09fb)    R(0x0c6c,0x006061e6,0x00dbdafe,0x00c9d3e5,0x00b8c6f5)    R(0x0c6d,0x006f74d0,0x002822e7,0x000000e0,0x005248d4)    R(0x0c6e,0x00c0c7ed,0x00cfd4e5,0x00d1d2ea,0x00d3d2ec)    R(0x0c6f,0x00d4d3ee,0x00d3d2ef,0x00d1d0ef,0x00d1ceef)\n    R(0x0c70,0x00cfccef,0x00cacaea,0x00c9c9e6,0x00cdc9e0)    R(0x0c71,0x00c6c6d3,0x00b6bbde,0x009b9bf9,0x000000ad)    R(0x0c72,0x000600bf,0x004238be,0x007771d4,0x00acabe6)    R(0x0c73,0x00b4b7d0,0x008c8fc5,0x00010085,0x00100cca)    R(0x0c74,0x000705de,0x000101d8,0x000901d2,0x000902cf)    R(0x0c75,0x000900cc,0x000801c8,0x000a02c5,0x000a01c3)    R(0x0c76,0x000901c0,0x000700bd,0x000801b5,0x000701b2)    R(0x0c77,0x000601b0,0x000600ad,0x000400a8,0x000600a5)\n    R(0x0c78,0x000500a3,0x000500a0,0x0006009b,0x0005009e)    R(0x0c79,0x0002009c,0x00020490,0x0005038b,0x00160998)    R(0x0c7a,0x003a2b9c,0x00eceffa,0x00fbfef9,0x00fffffd)    R(0x0c7b,0x00fffffc,0x00fefffb,0x00fffffc,0x00fffffd)    R(0x0c7c,0x00ffffff,0x00fffeff,0x00fffeff,0x00ffffff)    R(0x0c7d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c7e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c7f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0c80,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c81,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c82,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c83,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c84,0x00fff9ff,0x00fefdff,0x00fdfffc,0x00feffff)    R(0x0c85,0x00fcfcff,0x00ede5fe,0x006d62d0,0x00140ede)    R(0x0c86,0x000a0aef,0x000c04f1,0x000e06f3,0x000f07f5)    R(0x0c87,0x000e08f7,0x001009fa,0x00110bfd,0x00120cff)\n    R(0x0c88,0x00100cff,0x00140eff,0x00150fff,0x001610ff)    R(0x0c89,0x001610ff,0x001611ff,0x001713ff,0x001814ff)    R(0x0c8a,0x001813ff,0x00160fff,0x001815f8,0x001610ff)    R(0x0c8b,0x001212ff,0x000d19ef,0x001810ff,0x001600ee)    R(0x0c8c,0x00afb4fb,0x00d5ceff,0x00c4c1fa,0x00666cd6)    R(0x0c8d,0x000000dc,0x000006e1,0x000608df,0x000000c3)    R(0x0c8e,0x00ccd6fb,0x00d0d8e9,0x00d5d8ee,0x00d7d9ef)    R(0x0c8f,0x00d7daf0,0x00d6d9ef,0x00d6d8ef,0x00d4d6ee)\n    R(0x0c90,0x00d3d5ec,0x00ced0f1,0x00cdcbf5,0x00d1ccea)    R(0x0c91,0x00cbcadf,0x00bbc1f0,0x00797bee,0x00130dc9)    R(0x0c92,0x000302c6,0x000000be,0x002c1dc1,0x007775c9)    R(0x0c93,0x00afb7ce,0x00acb5d6,0x001e2379,0x000f0fbc)    R(0x0c94,0x000608d9,0x000204da,0x000a02d3,0x000a02d1)    R(0x0c95,0x000a01cd,0x000902c9,0x000a01c6,0x000a00c3)    R(0x0c96,0x000901bf,0x000700bd,0x000801b5,0x000701b2)    R(0x0c97,0x000601b0,0x000600ad,0x000400a8,0x000600a5)\n    R(0x0c98,0x000500a3,0x000500a0,0x0007009c,0x0006009a)    R(0x0c99,0x00030199,0x00020193,0x0008068a,0x0000005f)    R(0x0c9a,0x00c4c1e6,0x00f9faff,0x00fefff7,0x00fffffe)    R(0x0c9b,0x00fffffe,0x00fffffe,0x00fffffe,0x00fffefe)    R(0x0c9c,0x00fffeff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c9d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c9e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0c9f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0ca0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ca1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ca2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ca3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ca4,0x00fefdff,0x00faffff,0x00fafffe,0x00fefffa)    R(0x0ca5,0x00fffff9,0x00fdfafd,0x00c7c9f3,0x000000c4)    R(0x0ca6,0x000504ef,0x000c04f1,0x000e05f4,0x000f06f4)    R(0x0ca7,0x000e08f6,0x000f08fa,0x00110bfd,0x00120cff)\n    R(0x0ca8,0x00100bfe,0x00140eff,0x00150fff,0x001610ff)    R(0x0ca9,0x001610ff,0x001611ff,0x001713ff,0x001814ff)    R(0x0caa,0x001813ff,0x001811ff,0x001918f7,0x001710ff)    R(0x0cab,0x001311ff,0x00101cef,0x001c0cff,0x003315ec)    R(0x0cac,0x00dae3fc,0x00e1dff3,0x00d8d9fe,0x000000c7)    R(0x0cad,0x000f08f9,0x00000ddb,0x000006e1,0x001905e9)    R(0x0cae,0x00bfbdfe,0x00d9ddf6,0x00dedff3,0x00dfe0f4)    R(0x0caf,0x00dde1f1,0x00dce0f0,0x00dcdfef,0x00dadded)\n    R(0x0cb0,0x00d9dde9,0x00d6daf1,0x00d4d2f7,0x00d7d1ee)    R(0x0cb1,0x00d2d0e8,0x00c2c6fd,0x003739c1,0x000f0bd8)    R(0x0cb2,0x000307d9,0x000710cd,0x000300b9,0x006266c1)    R(0x0cb3,0x00aab4c2,0x00bcc3d9,0x004e4ba1,0x00150db5)    R(0x0cb4,0x000d08d3,0x000806d5,0x000b03d4,0x000a03d1)    R(0x0cb5,0x000b01ce,0x000a02cb,0x000a00c7,0x000a00c3)    R(0x0cb6,0x000900c0,0x000700bd,0x000800b8,0x000701b2)    R(0x0cb7,0x000601b0,0x000600ad,0x000400a8,0x000600a5)\n    R(0x0cb8,0x000500a3,0x000500a0,0x0008009c,0x00080196)    R(0x0cb9,0x00030295,0x00000098,0x00000086,0x007376a7)    R(0x0cba,0x00f0f5ff,0x00fdfdfc,0x00fffdfa,0x00fffeff)    R(0x0cbb,0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff)    R(0x0cbc,0x00fffeff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cbd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cbe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cbf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0cc0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cc1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cc2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cc3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cc4,0x00fefffe,0x00fafeff,0x00faffff,0x00fefff7)    R(0x0cc5,0x00fffff7,0x00fffdf9,0x00f1f5ff,0x00989ade)    R(0x0cc6,0x000000d7,0x000801f2,0x000806ec,0x000a07f2)    R(0x0cc7,0x000a04f7,0x001107f7,0x00130afa,0x00110aff)\n    R(0x0cc8,0x000e0cfe,0x00130dff,0x00150fff,0x00150fff)    R(0x0cc9,0x001610ff,0x001611ff,0x001713ff,0x001814ff)    R(0x0cca,0x001813ff,0x001912ff,0x001919f6,0x001812ff)    R(0x0ccb,0x001412ff,0x00151af5,0x001f0eff,0x00523fe5)    R(0x0ccc,0x00e9f4fa,0x00e5e8e8,0x00e2ebe9,0x009594eb)    R(0x0ccd,0x000401e8,0x00000be8,0x00010bef,0x001c07fa)    R(0x0cce,0x00796ee3,0x00e8e2fe,0x00e1e3f1,0x00e2e9f3)    R(0x0ccf,0x00e6e2f9,0x00e9e1f6,0x00e7e9ed,0x00e2eaeb)\n    R(0x0cd0,0x00e5e4f0,0x00dbd6ef,0x00dfdef5,0x00e1dded)    R(0x0cd1,0x00d5d6ea,0x00c2c6fd,0x000000ad,0x000707da)    R(0x0cd2,0x00070bdc,0x000e0dcf,0x000000a5,0x00a0a9e3)    R(0x0cd3,0x00a7aeba,0x00c0c2d6,0x007671c3,0x001609b0)    R(0x0cd4,0x00130cd3,0x000b07d5,0x000c03d5,0x000a02d3)    R(0x0cd5,0x000b01cf,0x000a01cc,0x000a00c7,0x000900c3)    R(0x0cd6,0x000900c0,0x000700bd,0x000603b3,0x000702b0)    R(0x0cd7,0x000800b1,0x000800ae,0x000600a9,0x000800a5)\n    R(0x0cd8,0x000700a3,0x000600a1,0x0005009c,0x0007009b)    R(0x0cd9,0x00010195,0x000f0799,0x00000079,0x00cfd9f1)    R(0x0cda,0x00f7fefa,0x00fffdfb,0x00fffbfe,0x00fffeff)    R(0x0cdb,0x00fffeff,0x00fffeff,0x00fffeff,0x00ffffff)    R(0x0cdc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cdd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cde,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cdf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0ce0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ce1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ce2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ce3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ce4,0x00fffefe,0x00fefeff,0x00fdffff,0x00fffffb)    R(0x0ce5,0x00fffffd,0x00fffcfc,0x00faf7ff,0x00ede6fb)    R(0x0ce6,0x005a4cca,0x001100ec,0x000c0fec,0x000307ed)    R(0x0ce7,0x000c08fd,0x001406f6,0x001709f6,0x00110afe)\n    R(0x0ce8,0x000b0bff,0x00120cff,0x00140eff,0x00150fff)    R(0x0ce9,0x001610ff,0x001611ff,0x001713ff,0x001814ff)    R(0x0cea,0x001813ff,0x001a10ff,0x001a18f8,0x001816fc)    R(0x0ceb,0x001513ff,0x001717fd,0x002013fc,0x005f56db)    R(0x0cec,0x00eaf5fc,0x00e6ecf4,0x00e9f0e6,0x00dcdbfe)    R(0x0ced,0x000900d5,0x000408ee,0x000009e8,0x000f11f8)    R(0x0cee,0x001202cb,0x00ebdeff,0x00e9f3f2,0x00ddf1e9)    R(0x0cef,0x00eee7fa,0x00f8e4fc,0x00eaedf9,0x00d0e0ef)\n    R(0x0cf0,0x00ece7f9,0x00f4e9fa,0x00e3e2f2,0x00e2e2e9)    R(0x0cf1,0x00d9ddf5,0x009ea1f7,0x000507ca,0x000209d4)    R(0x0cf2,0x000b0bd0,0x001203c7,0x006364ca,0x00b5bfda)    R(0x0cf3,0x00b2aec2,0x00c2bfd6,0x008787c9,0x000b02aa)    R(0x0cf4,0x00130dd9,0x000805da,0x000b04d7,0x000902d5)    R(0x0cf5,0x000902d0,0x000901cb,0x000900c6,0x000a00c2)    R(0x0cf6,0x000a00bf,0x000900ba,0x000406ac,0x000503ae)    R(0x0cf7,0x000900b0,0x000b00b0,0x000c00a9,0x000c00a4)\n    R(0x0cf8,0x000900a0,0x000600a1,0x000302a2,0x000703a4)    R(0x0cf9,0x000a019d,0x00000068,0x00acadd3,0x00f4fefb)    R(0x0cfa,0x00fafff0,0x00fdf8fe,0x00fffaff,0x00ffffff)    R(0x0cfb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cfc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cfd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cfe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0cff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0d00,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d01,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d02,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d03,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d04,0x00fffeff,0x00fffeff,0x00ffffff,0x00fffffd)    R(0x0d05,0x00fffffe,0x00fefdff,0x00fcf7ff,0x00fffaff)    R(0x0d06,0x00c9c3ee,0x000000cb,0x00120dec,0x000708f6)    R(0x0d07,0x000605f0,0x001105f5,0x00160af1,0x00120cf6)\n    R(0x0d08,0x000d09ff,0x00110bfe,0x00130dff,0x00140eff)    R(0x0d09,0x001610ff,0x001611ff,0x001713ff,0x001814ff)    R(0x0d0a,0x001814ff,0x001a11ff,0x001c19f7,0x001a17fb)    R(0x0d0b,0x001713ff,0x001817ff,0x002316fa,0x00655fd9)    R(0x0d0c,0x00ecf7fc,0x00f0f4ff,0x00f8fbf5,0x00edebfe)    R(0x0d0d,0x008278ef,0x000a05ed,0x000310f0,0x000614e8)    R(0x0d0e,0x000000d4,0x00d7d0fe,0x00e8f1f9,0x00e5f5f2)    R(0x0d0f,0x00f4f1f7,0x00fbedff,0x00abade9,0x007b88cf)\n    R(0x0d10,0x00dbd9ff,0x00f1edfb,0x00e7eaed,0x00e8ebec)    R(0x0d11,0x00dcddfe,0x004f50d8,0x00070bd7,0x00000ad6)    R(0x0d12,0x000d0ad2,0x000400c0,0x00b7b7f9,0x00bdc2ce)    R(0x0d13,0x00c0b6cc,0x00c4c1d1,0x008a8ec7,0x000c01b4)    R(0x0d14,0x00120bdd,0x000606da,0x000b04d8,0x000a04d5)    R(0x0d15,0x000a02d0,0x000901cc,0x000900c6,0x000b00c1)    R(0x0d16,0x000a00be,0x000a00b9,0x000403af,0x000401af)    R(0x0d17,0x000800ae,0x000a00ab,0x000c00a3,0x000b019e)\n    R(0x0d18,0x0008029a,0x0003029a,0x000503a3,0x000803a2)    R(0x0d19,0x0000008c,0x007d7cb5,0x00e9edff,0x00f8fef5)    R(0x0d1a,0x00fefff4,0x00fef7ff,0x00fffbff,0x00ffffff)    R(0x0d1b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d1c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d1d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d1e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d1f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0d20,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d21,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d22,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d23,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d24,0x00fffeff,0x00fffeff,0x00ffffff,0x00fffffc)    R(0x0d25,0x00fffffc,0x00fefffd,0x00fefcff,0x00fffbff)    R(0x0d26,0x00f7f8ff,0x00abaee0,0x000000cb,0x000b04f9)    R(0x0d27,0x000302ee,0x000907f0,0x000f09ef,0x00110af4)\n    R(0x0d28,0x000f07fe,0x00110bfe,0x00120cff,0x00140eff)    R(0x0d29,0x00140eff,0x001611ff,0x001713ff,0x001814ff)    R(0x0d2a,0x001814ff,0x001a15ff,0x001c1bf7,0x001c17fe)    R(0x0d2b,0x001a13ff,0x001c18ff,0x00281afa,0x00645cd5)    R(0x0d2c,0x00eff9fd,0x00f4f4fd,0x00fffef9,0x00f4f2fd)    R(0x0d2d,0x00d5dcff,0x000000de,0x000f15ff,0x000414df)    R(0x0d2e,0x00120def,0x009797ee,0x00e8f1fe,0x00f0f3ff)    R(0x0d2f,0x00faf2fc,0x00c9c3f9,0x002f2bda,0x000000da)\n    R(0x0d30,0x008889e3,0x00e2e4fe,0x00edf4f3,0x00e7edef)    R(0x0d31,0x00dad7ff,0x000000b8,0x000103d1,0x000007de)    R(0x0d32,0x000a05d3,0x005c54e3,0x00c8c9ef,0x00cccbd7)    R(0x0d33,0x00ccc1d3,0x00c9cbcb,0x008288c3,0x001403c6)    R(0x0d34,0x000f09df,0x00060bd6,0x000c06d7,0x000a04d4)    R(0x0d35,0x000a03d0,0x000b03cc,0x000900c5,0x000b00c1)    R(0x0d36,0x000a00bd,0x000a00ba,0x000400b4,0x000600b2)    R(0x0d37,0x000700ab,0x000700a4,0x0007019d,0x0007039a)\n    R(0x0d38,0x00040398,0x00000495,0x0005009b,0x0009048e)    R(0x0d39,0x00444397,0x00d7dbf8,0x00f3faff,0x00f9fefc)    R(0x0d3a,0x00fdfcfa,0x00fffdff,0x00fdfbfc,0x00ffffff)    R(0x0d3b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d3c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d3d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d3e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d3f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0d40,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d41,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d42,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d43,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d44,0x00fffeff,0x00fffeff,0x00ffffff,0x00fffffc)    R(0x0d45,0x00fefefa,0x00fffffc,0x00fefffd,0x00fefdff)    R(0x0d46,0x00fdfffb,0x00f2f7fe,0x008582db,0x000000e1)    R(0x0d47,0x000100f2,0x000407ee,0x000905f3,0x001306fd)\n    R(0x0d48,0x001107f6,0x00110bfe,0x00120cff,0x00130dfe)    R(0x0d49,0x00140eff,0x001611ff,0x001713ff,0x001814ff)    R(0x0d4a,0x001814ff,0x001a18fe,0x001c1bf7,0x001f15ff)    R(0x0d4b,0x001c13ff,0x001d16ff,0x00281cf9,0x00574fcf)    R(0x0d4c,0x00ecf5ff,0x00f7f7fd,0x00fcf8f8,0x00fdf9ff)    R(0x0d4d,0x00ebfaf5,0x006f72ea,0x001009f5,0x000e16ef)    R(0x0d4e,0x00110ffe,0x002f32c9,0x00e5f6ff,0x00f1f5fd)    R(0x0d4f,0x00dfd0ff,0x005e59d9,0x000000e5,0x00030efb)\n    R(0x0d50,0x000000d8,0x00a9a7e7,0x00ebefff,0x00dde8f7)    R(0x0d51,0x00c2c2f9,0x000b05c3,0x000808e3,0x000307e1)    R(0x0d52,0x000000ba,0x00b2b7ff,0x00cccfda,0x00d1cbd6)    R(0x0d53,0x00cfc2d3,0x00cfd6cf,0x007278bc,0x001703d6)    R(0x0d54,0x000d08e1,0x00070dd3,0x000d08d8,0x000b04d4)    R(0x0d55,0x000a04d0,0x000b03ca,0x000900c4,0x000b00bf)    R(0x0d56,0x000901bc,0x000a00ba,0x000600b6,0x000700b0)    R(0x0d57,0x000701a7,0x000501a1,0x000602a0,0x000603a2)\n    R(0x0d58,0x0000019a,0x0003049d,0x000d0395,0x00000076)    R(0x0d59,0x00bdc1e0,0x00f4feff,0x00f8fffe,0x00fdfdff)    R(0x0d5a,0x00fdfafd,0x00fefdfd,0x00fdfcfb,0x00ffffff)    R(0x0d5b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d5c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d5d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d5e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d5f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0d60,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d61,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d62,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d63,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d64,0x00fffeff,0x00fffeff,0x00ffffff,0x00fffffd)    R(0x0d65,0x00fefefa,0x00fffffc,0x00fefffc,0x00fefffd)    R(0x0d66,0x00fffffa,0x00fdfffc,0x00dedcff,0x004940d9)    R(0x0d67,0x001001ec,0x000903f8,0x000802f9,0x001002fa)\n    R(0x0d68,0x001508f6,0x00100afd,0x00120cff,0x00140eff)    R(0x0d69,0x00150fff,0x001611ff,0x001713ff,0x001814ff)    R(0x0d6a,0x001916ff,0x001818fc,0x001c1bf7,0x002014ff)    R(0x0d6b,0x001d14ff,0x001d18fe,0x00261cfa,0x00392fd1)    R(0x0d6c,0x00e6eeff,0x00fafcff,0x00fdf8fb,0x00fff9ff)    R(0x0d6d,0x00edf9ee,0x00c9d8ff,0x000000db,0x000f0df8)    R(0x0d6e,0x00070bf9,0x000000c9,0x00cfe7fc,0x00e0ecfd)    R(0x0d6f,0x008576df,0x000000dc,0x000014e2,0x000212f7)\n    R(0x0d70,0x001114f3,0x001300cb,0x00b4b3ee,0x00e3f0ff)    R(0x0d71,0x007f82dc,0x001810da,0x000e0df5,0x000405db)    R(0x0d72,0x005f67cf,0x00d7e6f2,0x00dee3da,0x00d5cdd8)    R(0x0d73,0x00d1c6da,0x00d3dde0,0x00565aae,0x001705e1)    R(0x0d74,0x000e0be2,0x000a0ed5,0x000d08d8,0x000b06d4)    R(0x0d75,0x000a04cf,0x000b03c9,0x000a02c4,0x000b00be)    R(0x0d76,0x000901ba,0x000a00b8,0x000900b5,0x000601ab)    R(0x0d77,0x000603a3,0x000502a1,0x000400a6,0x000200a8)\n    R(0x0d78,0x000b03a9,0x0006039c,0x00000070,0x00a39dcb)    R(0x0d79,0x00f3fbff,0x00f6fffa,0x00fcfffb,0x00fffcff)    R(0x0d7a,0x00fffbff,0x00fefdfc,0x00fffffd,0x00ffffff)    R(0x0d7b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d7c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d7d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d7e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d7f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0d80,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d81,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d82,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d83,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d84,0x00fffeff,0x00fffeff,0x00ffffff,0x00ffffff)    R(0x0d85,0x00fffffe,0x00fffffd,0x00fffffd,0x00fffffd)    R(0x0d86,0x00fffefe,0x00fcfafe,0x00faf9ff,0x00c5c3f4)    R(0x0d87,0x000000d7,0x000c00f6,0x000a05f7,0x000d06f1)\n    R(0x0d88,0x001405fa,0x000f09fc,0x00110bfe,0x00130dfe)    R(0x0d89,0x00150fff,0x00140fff,0x001612fd,0x001814ff)    R(0x0d8a,0x001915ff,0x001817fd,0x001b1af7,0x002015ff)    R(0x0d8b,0x001c16ff,0x001b1bfc,0x00221bfe,0x001c06e2)    R(0x0d8c,0x00bfc7ff,0x00f2f6fe,0x00fdf9ff,0x00fff9ff)    R(0x0d8d,0x00fcfffa,0x00effff8,0x007672e7,0x000e01ef)    R(0x0d8e,0x00020bf2,0x000408ee,0x0099a8fc,0x0099a5e7)    R(0x0d8f,0x000000d7,0x000e0ff8,0x000001e7,0x000000ef)\n    R(0x0d90,0x000b10f3,0x000307e6,0x003735d1,0x00b8c3ff)    R(0x0d91,0x000005bc,0x00120de2,0x000807ec,0x000000c0)    R(0x0d92,0x00bdc7fa,0x00d9e8d7,0x00e0e7dc,0x00d8d0df)    R(0x0d93,0x00d8d0ec,0x00ced6f2,0x002a2ba1,0x001709e8)    R(0x0d94,0x000e0ede,0x000c0bdb,0x000e08d7,0x000b06d4)    R(0x0d95,0x000a04ce,0x000a03c9,0x000a02c3,0x000b01be)    R(0x0d96,0x000901ba,0x000900b7,0x000a00b1,0x000703a7)    R(0x0d97,0x0005059f,0x000302a2,0x000300aa,0x000700ad)\n    R(0x0d98,0x001205a8,0x00000085,0x008884bd,0x00f1edff)    R(0x0d99,0x00f8feff,0x00fbfff4,0x00fffffa,0x00fffcff)    R(0x0d9a,0x00fffbff,0x00fffffe,0x00fffffd,0x00ffffff)    R(0x0d9b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d9c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d9d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d9e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0d9f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0da0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0da1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0da2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0da3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0da4,0x00fffeff,0x00fffeff,0x00ffffff,0x00ffffff)    R(0x0da5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0da6,0x00fefcff,0x00fbf7ff,0x00fdfaf8,0x00fffffe)    R(0x0da7,0x00a6a5de,0x000000d8,0x000d08ef,0x000c07ee)\n    R(0x0da8,0x000a00f4,0x000d07fa,0x000f09fc,0x00120cfc)    R(0x0da9,0x00130dfe,0x00140ffe,0x001612fd,0x001713ff)    R(0x0daa,0x001814ff,0x001915ff,0x001c1af8,0x001f16ff)    R(0x0dab,0x001b18ff,0x00171df8,0x001815ff,0x00251bf8)    R(0x0dac,0x006a6fe7,0x00f1f6fe,0x00fbf8ff,0x00fefbff)    R(0x0dad,0x00ffffff,0x00f7fff4,0x00ced4ff,0x000100d4)    R(0x0dae,0x00000aef,0x000406fd,0x002f2af8,0x000000de)    R(0x0daf,0x001312fa,0x00010af2,0x001000e9,0x006d61f3)\n    R(0x0db0,0x000000d9,0x000b13f5,0x000000db,0x002e35ed)    R(0x0db1,0x000000c7,0x000808e6,0x000000dc,0x005964cd)    R(0x0db2,0x00e7edfc,0x00eae9db,0x00dae1e3,0x00d5d1e4)    R(0x0db3,0x00dfdbfa,0x00a8ade5,0x000d03ad,0x00160beb)    R(0x0db4,0x000c0ed5,0x000d05e2,0x000e08d9,0x000b06d3)    R(0x0db5,0x000a04ce,0x000a04c9,0x000801c1,0x000b01bd)    R(0x0db6,0x000701b9,0x000900b5,0x000800af,0x000602a6)    R(0x0db7,0x0005059e,0x000400a1,0x000400a7,0x000b00a4)\n    R(0x0db8,0x00000084,0x00595aa8,0x00e5e4ff,0x00f8f8fe)    R(0x0db9,0x00fcfefe,0x00fefff9,0x00fffefb,0x00fffdff)    R(0x0dba,0x00fffdff,0x00ffffff,0x00fffffe,0x00ffffff)    R(0x0dbb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dbc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dbd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dbe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dbf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0dc0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dc1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dc2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dc3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dc4,0x00ffffff,0x00ffffff,0x00fffeff,0x00fffeff)    R(0x0dc5,0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff)    R(0x0dc6,0x00fcfcff,0x00fbfafe,0x00fffdf5,0x00fdfbf5)    R(0x0dc7,0x00f5f8ff,0x008b94e0,0x000000db,0x001005f0)\n    R(0x0dc8,0x000b03ed,0x000b05f6,0x000f08fb,0x00100afc)    R(0x0dc9,0x00110bfc,0x00140efe,0x001511fd,0x001713fe)    R(0x0dca,0x001712ff,0x001a15ff,0x001d19fa,0x001f17ff)    R(0x0dcb,0x001b1afe,0x001821f8,0x001113fd,0x002019ff)    R(0x0dcc,0x002c30d8,0x00e4e7ff,0x00fbfbff,0x00fdfdfb)    R(0x0dcd,0x00fffeff,0x00fffbff,0x00f1ffff,0x006a73db)    R(0x0dce,0x00040bf3,0x000311f3,0x000000f0,0x000606ff)    R(0x0dcf,0x00000af5,0x000000db,0x00a3aaec,0x00cacafe)\n    R(0x0dd0,0x006770da,0x000000df,0x000a10ef,0x000000de)    R(0x0dd1,0x000609e2,0x000d11ee,0x000000c4,0x00b5c5fa)    R(0x0dd2,0x00e5e5ee,0x00f3e5ec,0x00d6dae5,0x00d9daeb)    R(0x0dd3,0x00e1e1ff,0x005b60ac,0x00180ccb,0x001209e7)    R(0x0dd4,0x000c0ecf,0x001004e7,0x000e09d8,0x000b07d3)    R(0x0dd5,0x000a05cf,0x000a03ca,0x000801c1,0x000a00bc)    R(0x0dd6,0x000800b7,0x000700b3,0x000600af,0x000501a6)    R(0x0dd7,0x0004049e,0x000300a0,0x000600a2,0x00000090)\n    R(0x0dd8,0x003e398e,0x00c4c9e8,0x00fcfffc,0x00fcfdfa)    R(0x0dd9,0x00fffdfc,0x00fdfafa,0x00fefdfd,0x00fffeff)    R(0x0dda,0x00ffffff,0x00fffeff,0x00fffeff,0x00ffffff)    R(0x0ddb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ddc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ddd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dde,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ddf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0de0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0de1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0de2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0de3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0de4,0x00fffffe,0x00ffffff,0x00fffeff,0x00fffeff)    R(0x0de5,0x00fffeff,0x00fffeff,0x00fffeff,0x00fffeff)    R(0x0de6,0x00fdfdfe,0x00fbfdfc,0x00fffffb,0x00fffdf6)    R(0x0de7,0x00f8fdfe,0x00e5efff,0x009492dc,0x000000d6)\n    R(0x0de8,0x001a08ee,0x000d07f1,0x000d04f7,0x001008fd)    R(0x0de9,0x00130bfd,0x00140bff,0x001511fb,0x001614fb)    R(0x0dea,0x001711ff,0x001915ff,0x001b18fc,0x001e18ff)    R(0x0deb,0x001c1afd,0x001c20fe,0x00191afb,0x001816fa)    R(0x0dec,0x002323f7,0x009b99f2,0x00eef5ff,0x00fafff2)    R(0x0ded,0x00fcf3fa,0x00fff2ff,0x00f8fffb,0x00becbff)    R(0x0dee,0x00130deb,0x000218ec,0x000a19f7,0x000308f7)    R(0x0def,0x000000e2,0x009192dc,0x00ecfbfd,0x00eefaf1)\n    R(0x0df0,0x00d3d6fd,0x006b60d9,0x000000e5,0x000204f0)    R(0x0df1,0x000410f5,0x000712e9,0x00606ac9,0x00e9f7fc)    R(0x0df2,0x00e2e2e8,0x00e6dbea,0x00eae7ea,0x00e2e7f1)    R(0x0df3,0x00b1b2eb,0x000700b3,0x00180be9,0x000d09e1)    R(0x0df4,0x00100fcf,0x001408e2,0x000d0bd3,0x000b06d3)    R(0x0df5,0x000a02d1,0x000b01cc,0x000a00c2,0x000c00bc)    R(0x0df6,0x000a00b5,0x000800b3,0x000c04b1,0x000803a9)    R(0x0df7,0x0002039d,0x000706a3,0x0000009c,0x00261a9b)\n    R(0x0df8,0x00adacd8,0x00fcfffe,0x00fcfff8,0x00fffffb)    R(0x0df9,0x00fffcfc,0x00fbf7f9,0x00fffeff,0x00fffffe)    R(0x0dfa,0x00ffffff,0x00fffeff,0x00fffeff,0x00ffffff)    R(0x0dfb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dfc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dfd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dfe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0dff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0e00,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e01,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e02,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e03,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e04,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e05,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e06,0x00fefffe,0x00fefffe,0x00fffdff,0x00ffffff)    R(0x0e07,0x00fdfffa,0x00f7fdff,0x00eff0ff,0x008983c6)\n    R(0x0e08,0x000000dc,0x001309f4,0x000803e8,0x00110af8)    R(0x0e09,0x001108fe,0x00120bfe,0x00140ffc,0x001612fc)    R(0x0e0a,0x001613fc,0x001915fd,0x001a16fe,0x001b19ff)    R(0x0e0b,0x001d1afe,0x001e1cfe,0x001f1dfc,0x001f1efb)    R(0x0e0c,0x001e1dfa,0x000000e7,0x00b6c0ee,0x00effbf7)    R(0x0e0d,0x00faeaf5,0x00fff5ff,0x00fffff3,0x00e9f7ff)    R(0x0e0e,0x007d7ae3,0x00080ff3,0x000d17f6,0x000000d2)    R(0x0e0f,0x008d8fe4,0x00f0f3ff,0x00f0fbf3,0x00f5f8f0)\n    R(0x0e10,0x00fffcff,0x00c9c6f7,0x00616dd8,0x000000e7)    R(0x0e11,0x000916f3,0x000715d3,0x00c6c6f7,0x00f1f0f3)    R(0x0e12,0x00e9e6ed,0x00e1e4e6,0x00f4eff3,0x00d3d6fd)    R(0x0e13,0x003532b8,0x001c0de6,0x000d05f0,0x000d0bdf)    R(0x0e14,0x00130ed8,0x00160adc,0x000b0bd1,0x000a06d2)    R(0x0e15,0x000900d2,0x000900cb,0x000b01c0,0x000b02b6)    R(0x0e16,0x000901b1,0x000900af,0x000e08aa,0x000804af)    R(0x0e17,0x000100a7,0x000100a6,0x00010a8e,0x00a2aad0)\n    R(0x0e18,0x00f2f5ff,0x00fffefb,0x00fffffd,0x00ffffff)    R(0x0e19,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e1a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e1b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e1c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e1d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e1e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e1f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0e20,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e21,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e22,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e23,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e24,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e25,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e26,0x00feffff,0x00fcfdff,0x00fefcff,0x00fffefe)    R(0x0e27,0x00fefff6,0x00f6fff6,0x00edf4fe,0x00eeecff)\n    R(0x0e28,0x007b79d0,0x000000e4,0x00110ae3,0x000c09ef)    R(0x0e29,0x000606f8,0x00090cfb,0x000e0cff,0x00150dff)    R(0x0e2a,0x001814f9,0x001813fc,0x001914ff,0x001b17fe)    R(0x0e2b,0x001c18ff,0x001e1cfe,0x001e1dfd,0x001e1dfc)    R(0x0e2c,0x001e1efb,0x002d1aff,0x00352fce,0x00bdc8f2)    R(0x0e2d,0x00f9feff,0x00fcfdff,0x00fcfef5,0x00f3fcfe)    R(0x0e2e,0x00dbdcff,0x002008dc,0x000000d5,0x008389d1)    R(0x0e2f,0x00ebf7fe,0x00f7fff5,0x00fffff9,0x00fef7ff)\n    R(0x0e30,0x00fdf7ff,0x00ecf8fb,0x00bcd2ef,0x00595ad7)    R(0x0e31,0x000000d4,0x00746fd8,0x00f6eefa,0x00f8f0f2)    R(0x0e32,0x00f5efef,0x00ebebef,0x00cacdf9,0x00877bee)    R(0x0e33,0x001100cc,0x000e0dd4,0x000d10dd,0x000c0ae4)    R(0x0e34,0x001006e5,0x001308dd,0x000d06d8,0x000a03d3)    R(0x0e35,0x000800cc,0x000802c3,0x000703ba,0x000604b1)    R(0x0e36,0x000603ad,0x000601aa,0x0001019e,0x000100aa)    R(0x0e37,0x000000af,0x001d00a1,0x00a1a3c1,0x00f5fffc)\n    R(0x0e38,0x00fbfff7,0x00fdf9ff,0x00fffeff,0x00ffffff)    R(0x0e39,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e3a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e3b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e3c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e3d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e3e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e3f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0e40,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e41,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e42,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e43,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e44,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e45,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e46,0x00fdfeff,0x00fbfcff,0x00fdfbff,0x00fffdff)    R(0x0e47,0x00fffff7,0x00f8ffea,0x00fafff9,0x00f4fbfc)\n    R(0x0e48,0x00dce1ff,0x00797dd6,0x000000e1,0x000b00f1)    R(0x0e49,0x00060bf2,0x00020af8,0x00080afe,0x00140dff)    R(0x0e4a,0x00190eff,0x001712fe,0x001813ff,0x001a15ff)    R(0x0e4b,0x001b17ff,0x001e1cff,0x001e1cfe,0x001e1dfd)    R(0x0e4c,0x001e1dfd,0x002218ff,0x001900ee,0x003731db)    R(0x0e4d,0x00c7d6ef,0x00f0feff,0x00f7fcff,0x00f4f4ff)    R(0x0e4e,0x00fffffa,0x009694d3,0x00797ece,0x00e5f2ff)    R(0x0e4f,0x00edfef6,0x00fafef9,0x00fefefd,0x00fafafa)\n    R(0x0e50,0x00f5f5fc,0x00f7fffe,0x00e2f4f5,0x00c6c7f7)    R(0x0e51,0x007168c5,0x00d6cbff,0x00f0eaef,0x00f6f7e9)    R(0x0e52,0x00f4f6f5,0x00e2dfff,0x009093ed,0x000000ce)    R(0x0e53,0x001909f3,0x000e13dc,0x000a15d6,0x000c08eb)    R(0x0e54,0x000e01ec,0x001108da,0x000f03db,0x000c02d2)    R(0x0e55,0x000703c7,0x000603be,0x000402b9,0x000502b4)    R(0x0e56,0x000401b1,0x000300ac,0x000502a8,0x0000009b)    R(0x0e57,0x002f25a2,0x00a49dd0,0x00ffffff,0x00fcffec)\n    R(0x0e58,0x00fefff4,0x00fcfbfe,0x00fffdff,0x00ffffff)    R(0x0e59,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e5a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e5b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e5c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e5d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e5e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e5f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0e60,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e61,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e62,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e63,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e64,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e65,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e66,0x00fdffff,0x00fbfeff,0x00fdfdff,0x00fffdff)    R(0x0e67,0x00fefffc,0x00fffff5,0x00fefff3,0x00f8fcf7)\n    R(0x0e68,0x00f0f8ff,0x00d9e5ff,0x007e81d6,0x000000eb)    R(0x0e69,0x000602f1,0x00070df3,0x000608f5,0x00140cff)    R(0x0e6a,0x001a0efd,0x001710fe,0x001912ff,0x001914ff)    R(0x0e6b,0x001b16ff,0x001d1aff,0x001d1aff,0x001e1bfe)    R(0x0e6c,0x001e1cfe,0x002424ff,0x002019ff,0x002717ff)    R(0x0e6d,0x000000d0,0x00c4d1f2,0x00dce8ff,0x00f9fdff)    R(0x0e6e,0x00f9f5f5,0x00f3f6ff,0x00e9f2ff,0x00ebf3fb)    R(0x0e6f,0x00faffff,0x00fdfffd,0x00fcfef8,0x00f4fbf1)\n    R(0x0e70,0x00f7fff8,0x00fcfdff,0x00fbfbf8,0x00fcfffe)    R(0x0e71,0x00dfd9fe,0x00fff9fa,0x00fefaff,0x00e1e5ee)    R(0x0e72,0x00cdd9f2,0x008486f8,0x000000c3,0x00160af1)    R(0x0e73,0x00160dfb,0x000d12e6,0x000b11e2,0x000c07ee)    R(0x0e74,0x000d03e9,0x001008d8,0x001103d9,0x000e04cd)    R(0x0e75,0x000705c2,0x000504bd,0x000300be,0x000500bd)    R(0x0e76,0x000100b5,0x000f06b6,0x000000a5,0x003b3a9c)    R(0x0e77,0x00a3a5cc,0x00ffffff,0x00fffffc,0x00fffefc)\n    R(0x0e78,0x00fffdff,0x00fdffff,0x00fefefe,0x00ffffff)    R(0x0e79,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e7a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e7b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e7c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e7d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e7e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e7f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0e80,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e81,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e82,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e83,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e84,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e85,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e86,0x00feffff,0x00fbfffd,0x00fdfeff,0x00fffdff)    R(0x0e87,0x00fffdff,0x00fffeff,0x00fffefd,0x00fffffd)\n    R(0x0e88,0x00fdfffe,0x00e0ecf5,0x00effaff,0x00787bd4)    R(0x0e89,0x000000e9,0x000e08f3,0x000501e6,0x001711fc)    R(0x0e8a,0x001a11f9,0x00140dff,0x00160fff,0x001812ff)    R(0x0e8b,0x001a15ff,0x001a15ff,0x001a17ff,0x001d19ff)    R(0x0e8c,0x001e1bff,0x001e1aff,0x001e20fc,0x001e21f6)    R(0x0e8d,0x002316ff,0x000000d4,0x009494fb,0x00d1d4f4)    R(0x0e8e,0x00e3dfff,0x00fcfefa,0x00fffef7,0x00fff8fe)    R(0x0e8f,0x00fffff9,0x00fffff7,0x00fffdfe,0x00fff9ff)\n    R(0x0e90,0x00fffdfe,0x00fffcfd,0x00fefcfd,0x00fffffb)    R(0x0e91,0x00fcfefd,0x00e7f4ee,0x00d2ddf6,0x00c8cefc)    R(0x0e92,0x000000c6,0x000000ee,0x00150bf8,0x00100df0)    R(0x0e93,0x000d0de9,0x000c0aee,0x000d08f1,0x000f08eb)    R(0x0e94,0x000e08dd,0x000f09d7,0x001205d4,0x000d04c7)    R(0x0e95,0x000605bc,0x000403be,0x000903c4,0x000100b8)    R(0x0e96,0x000f06b3,0x000000b1,0x004441a3,0x00aaaadc)    R(0x0e97,0x00fcffff,0x00fcfcec,0x00fffff5,0x00fffaff)\n    R(0x0e98,0x00fff9ff,0x00fdfdff,0x00ffffff,0x00ffffff)    R(0x0e99,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e9a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e9b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e9c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e9d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e9e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0e9f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0ea0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ea1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ea2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ea3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ea4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ea5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ea6,0x00fefffd,0x00fefffc,0x00fdfffe,0x00fffeff)    R(0x0ea7,0x00fffcff,0x00fffbff,0x00fffcff,0x00fffdff)\n    R(0x0ea8,0x00fffeff,0x00fafdff,0x00f4fff3,0x00eef8ff)    R(0x0ea9,0x00807cda,0x002800eb,0x000000e0,0x001513ec)    R(0x0eaa,0x000b02fb,0x00130bff,0x00140cff,0x00170fff)    R(0x0eab,0x001812ff,0x001812ff,0x001914ff,0x001b17ff)    R(0x0eac,0x001b18ff,0x001d1afd,0x001e20fb,0x001d23f2)    R(0x0ead,0x001f19ff,0x002412ff,0x000000f2,0x000c00d2)    R(0x0eae,0x007c80f4,0x00e2d3f7,0x00ebddf9,0x00eae0f7)    R(0x0eaf,0x00f7f6f8,0x00fcfcfb,0x00fdfefd,0x00fefff9)\n    R(0x0eb0,0x00fdfff8,0x00f7fafe,0x00e2e5ff,0x00dcdffb)    R(0x0eb1,0x00d7e0fa,0x00b9c4fd,0x002d2add,0x000000ec)    R(0x0eb2,0x000901ee,0x001b1af9,0x00100afc,0x001011eb)    R(0x0eb3,0x00110ee8,0x001007f5,0x001005f0,0x00100bde)    R(0x0eb4,0x000d0ad5,0x000e05d8,0x001003d0,0x000c04c2)    R(0x0eb5,0x000705b9,0x000402bc,0x001008c2,0x000602a1)    R(0x0eb6,0x000000a6,0x005755a1,0x00b7b4df,0x00fafaff)    R(0x0eb7,0x00fbfdfd,0x00f4f3e7,0x00fffff9,0x00fffdff)\n    R(0x0eb8,0x00fffcff,0x00fdfcff,0x00fffeff,0x00ffffff)    R(0x0eb9,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0eba,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ebb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ebc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ebd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ebe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ebf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0ec0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ec1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ec2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ec3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ec4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ec5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ec6,0x00ffffff,0x00fffffe,0x00fffffc,0x00fdfffe)    R(0x0ec7,0x00fcfeff,0x00fcfcff,0x00fdfcff,0x00fffeff)\n    R(0x0ec8,0x00fffffe,0x00fffdff,0x00fefef7,0x00fcfff4)    R(0x0ec9,0x00f4f7ff,0x008b82ea,0x003e31d8,0x000000da)    R(0x0eca,0x000e0bf5,0x001109fe,0x00110afe,0x00150dff)    R(0x0ecb,0x001610ff,0x001610fd,0x001712fd,0x001914fe)    R(0x0ecc,0x001a17fd,0x001b1df5,0x001b18ff,0x001c13ff)    R(0x0ecd,0x001d16ff,0x001816fa,0x002824fe,0x00201ffc)    R(0x0ece,0x000000e8,0x000000dc,0x00311cdf,0x007879f2)    R(0x0ecf,0x00b4b7fe,0x00cdd1fc,0x00d5ddfd,0x00d7e6fd)\n    R(0x0ed0,0x00d2e2fe,0x00bed3fe,0x008c9efe,0x00453de9)    R(0x0ed1,0x000000e7,0x000000ef,0x000d0afd,0x000f13f4)    R(0x0ed2,0x00140cf8,0x001e1af4,0x000f10ec,0x00100cec)    R(0x0ed3,0x001308f1,0x001505f2,0x001309e2,0x00120fd2)    R(0x0ed4,0x000c09d2,0x000c01dc,0x000e00d0,0x000901c2)    R(0x0ed5,0x000505b7,0x000603b7,0x000000b1,0x000000a2)    R(0x0ed6,0x00656592,0x00cecefb,0x00ffffff,0x00fffefe)    R(0x0ed7,0x00f8f5f7,0x00fffdff,0x00fffdff,0x00fffcff)\n    R(0x0ed8,0x00fdffff,0x00fbfffa,0x00fffffd,0x00ffffff)    R(0x0ed9,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0eda,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0edb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0edc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0edd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ede,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0edf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0ee0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ee1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ee2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ee3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ee4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ee5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ee6,0x00ffffff,0x00fffeff,0x00fffffd,0x00fdfffc)    R(0x0ee7,0x00fbffff,0x00fbfeff,0x00fdfeff,0x00fdffff)\n    R(0x0ee8,0x00fffffc,0x00fdfcfd,0x00fffbff,0x00fffffc)    R(0x0ee9,0x00f6fdf2,0x00f1f7ff,0x00aea5ff,0x005453db)    R(0x0eea,0x000000d8,0x000600f8,0x00120afe,0x00110afd)    R(0x0eeb,0x00120cff,0x00130dff,0x00140ffe,0x001713fd)    R(0x0eec,0x001916fc,0x001813fe,0x001815fb,0x001a17fd)    R(0x0eed,0x001a16ff,0x001d1dff,0x001015f8,0x001218ff)    R(0x0eee,0x000d10ff,0x000f18ff,0x000009fe,0x000000fc)    R(0x0eef,0x000000f5,0x000000ec,0x000000f0,0x000000f7)\n    R(0x0ef0,0x000000fa,0x000000f7,0x000000f8,0x000000f9)    R(0x0ef1,0x001010f9,0x001010ff,0x000c16f5,0x000d14e8)    R(0x0ef2,0x001909ff,0x001b0bf8,0x000e13df,0x000e0aeb)    R(0x0ef3,0x001105f3,0x001404ec,0x00150cdb,0x00120dce)    R(0x0ef4,0x000d07d1,0x000c00db,0x000a00cd,0x000802c4)    R(0x0ef5,0x000803b7,0x000000ab,0x003225b2,0x006663ac)    R(0x0ef6,0x00ebebff,0x00f3fbfd,0x00fffefd,0x00fffdfa)    R(0x0ef7,0x00fffffe,0x00f9f8fb,0x00fdfbff,0x00fdfbff)\n    R(0x0ef8,0x00fdfffe,0x00fdfff2,0x00fffffb,0x00ffffff)    R(0x0ef9,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0efa,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0efb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0efc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0efd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0efe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0eff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f00,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f01,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f02,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f03,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f04,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f05,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f06,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f07,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f08,0x00fdfffe,0x00fbfffb,0x00fdfdff,0x00fffcff)    R(0x0f09,0x00ffffff,0x00f8fbf7,0x00f8ffff,0x00d6d6ff)    R(0x0f0a,0x006561c4,0x002c28e5,0x000000f3,0x000d03f8)    R(0x0f0b,0x000603fd,0x000c0aff,0x000d0cfe,0x001514ff)    R(0x0f0c,0x001614f7,0x001511ff,0x001512ff,0x001613ff)    R(0x0f0d,0x001716ff,0x001415fe,0x001615ff,0x001515fe)    R(0x0f0e,0x001616fe,0x001313ff,0x001512ff,0x001513fe)    R(0x0f0f,0x001615fc,0x001815fb,0x001916f8,0x001a15f7)\n    R(0x0f10,0x001a14f6,0x001514f8,0x001012fc,0x001010fc)    R(0x0f11,0x00110ffa,0x001310fa,0x00130cfa,0x00140bf8)    R(0x0f12,0x00140af6,0x001209f3,0x000e0aeb,0x000f0be6)    R(0x0f13,0x000f0be0,0x000f08e2,0x001408e6,0x000c00db)    R(0x0f14,0x000501c9,0x000b04c7,0x000101c0,0x000000c3)    R(0x0f15,0x000000ae,0x004a4ca3,0x009c93e6,0x00f7f2ff)    R(0x0f16,0x00f2f5f9,0x00fafeec,0x00fffffb,0x00ffffff)    R(0x0f17,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f18,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f19,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f1a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f1b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f1c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f1d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f1e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f1f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f20,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f21,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f22,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f23,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f24,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f25,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f26,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f27,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f28,0x00fdfffe,0x00fafffe,0x00fdfcff,0x00fffcff)    R(0x0f29,0x00fffffd,0x00fefef3,0x00f6fdfb,0x00eff5ff)    R(0x0f2a,0x00e9ebff,0x009399ed,0x004749c2,0x002204f4)    R(0x0f2b,0x000200f3,0x00120afb,0x001111f6,0x001110fb)    R(0x0f2c,0x00140eff,0x00150ffe,0x001511fd,0x001612fe)    R(0x0f2d,0x001713ff,0x001611ff,0x001611ff,0x00160fff)    R(0x0f2e,0x00160fff,0x00130fff,0x00110fff,0x00130eff)    R(0x0f2f,0x00150dff,0x00160cff,0x00160bff,0x00170aff)\n    R(0x0f30,0x001609ff,0x00140aff,0x00130dff,0x00130cfe)    R(0x0f31,0x00130cfd,0x00130cf8,0x00130df6,0x00140bf3)    R(0x0f32,0x00140bef,0x001308f2,0x001404f6,0x001207e9)    R(0x0f33,0x00100ade,0x000f07e2,0x000700e1,0x000700dc)    R(0x0f34,0x000806cd,0x000000b2,0x000000be,0x003330a9)    R(0x0f35,0x005255a3,0x00d0d7fd,0x00f4fcfe,0x00f1f6f7)    R(0x0f36,0x00fbfdff,0x00f9f6ff,0x00ffffff,0x00ffffff)    R(0x0f37,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f38,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f39,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f3a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f3b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f3c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f3d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f3e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f3f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f40,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f41,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f42,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f43,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f44,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f45,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f46,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f47,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f48,0x00fdfffe,0x00fafffe,0x00fdfcff,0x00fffbff)    R(0x0f49,0x00fffffc,0x00fefef0,0x00f4fce7,0x00f7fefb)    R(0x0f4a,0x00f4fdfe,0x00ecfdfe,0x00d7dbfd,0x006760e1)    R(0x0f4b,0x003f39dd,0x000000e7,0x000e00f4,0x001207fe)    R(0x0f4c,0x001007ff,0x001010f7,0x001113f5,0x001112f7)    R(0x0f4d,0x001311fb,0x001611fd,0x001610ff,0x00160ffe)    R(0x0f4e,0x00160ffe,0x00130ffe,0x00100fff,0x00120eff)    R(0x0f4f,0x00120dff,0x00140cff,0x00140bff,0x00140bfe)\n    R(0x0f50,0x001309fe,0x00140bfe,0x00150cfa,0x00140df8)    R(0x0f51,0x00130ef5,0x00140ff3,0x00130eef,0x00100fea)    R(0x0f52,0x00100ee8,0x00100de6,0x00100ae5,0x000e06e6)    R(0x0f53,0x000c03e1,0x000c05d9,0x000907d2,0x000300c9)    R(0x0f54,0x000000d1,0x001818cb,0x004848a1,0x00a8a6e4)    R(0x0f55,0x00edf4ff,0x00f5fffc,0x00f5fee9,0x00fffff3)    R(0x0f56,0x00f9f9fa,0x00fef8ff,0x00fffeff,0x00ffffff)    R(0x0f57,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f58,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f59,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f5a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f5b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f5c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f5d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f5e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f5f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f60,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f61,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f62,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f63,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f64,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f65,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f66,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f67,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f68,0x00fdfffe,0x00fbfff9,0x00fdffff,0x00fffcff)    R(0x0f69,0x00fffdff,0x00fffff7,0x00fffff4,0x00fbfdf2)    R(0x0f6a,0x00fdfdf8,0x00fbfef0,0x00f7fffb,0x00f4fbff)    R(0x0f6b,0x00c4c6f6,0x004247c9,0x00312dd6,0x001a00fb)    R(0x0f6c,0x000800f9,0x000f08ff,0x000e0aff,0x000e0bff)    R(0x0f6d,0x000e0cff,0x00110efe,0x001310fb,0x001313f9)    R(0x0f6e,0x001313f6,0x001112f7,0x001210fa,0x00120ffb)    R(0x0f6f,0x00120ffb,0x00130ffb,0x00120ffa,0x001210f6)\n    R(0x0f70,0x001110f2,0x00110ef7,0x00100afe,0x001009fd)    R(0x0f71,0x001009fa,0x000f09fb,0x000d08f8,0x000b06f6)    R(0x0f72,0x000b07f3,0x000a08f1,0x000708e6,0x000609dc)    R(0x0f73,0x000706d3,0x000600d3,0x000000cb,0x00271bca)    R(0x0f74,0x003e4099,0x008085e0,0x00e7e9ff,0x00f5f7ff)    R(0x0f75,0x00f7f9ff,0x00fcfdfb,0x00fefff5,0x00fdfef4)    R(0x0f76,0x00fffff8,0x00fffefc,0x00ffffff,0x00ffffff)    R(0x0f77,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f78,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f79,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f7a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f7b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f7c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f7d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f7e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f7f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f80,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f81,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f82,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f83,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f84,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f85,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f86,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f87,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f88,0x00fefffc,0x00fbfff7,0x00fdfffc,0x00fffdff)    R(0x0f89,0x00fffcff,0x00fffdff,0x00fffefe,0x00fffffe)    R(0x0f8a,0x00fffeff,0x00fffaff,0x00fffffd,0x00fdfff4)    R(0x0f8b,0x00f6fff9,0x00ecfbff,0x00b2b8f1,0x00363bc8)    R(0x0f8c,0x00312ed9,0x00190cf6,0x000600f7,0x000800fb)    R(0x0f8d,0x000c01fd,0x000f05fe,0x000f07ff,0x000f08ff)    R(0x0f8e,0x000e08ff,0x00140dff,0x00140aff,0x001409ff)    R(0x0f8f,0x00150bff,0x00130afd,0x00110df7,0x00100ff1)\n    R(0x0f90,0x000f11eb,0x000e11ec,0x000c10ef,0x000d0eef)    R(0x0f91,0x000c0eee,0x000c0ded,0x000506e7,0x000504e6)    R(0x0f92,0x000505e6,0x000404e5,0x000000db,0x000000dd)    R(0x0f93,0x000500d6,0x002d27cd,0x003535aa,0x007e74d4)    R(0x0f94,0x00e2e7fa,0x00f9fffa,0x00fafffa,0x00fefffd)    R(0x0f95,0x00ffffff,0x00fffcff,0x00fffdff,0x00fffefe)    R(0x0f96,0x00fffffa,0x00fffff8,0x00fffffe,0x00ffffff)    R(0x0f97,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0f98,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f99,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f9a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f9b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f9c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f9d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f9e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0f9f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0fa0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fa1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fa2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fa3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fa4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fa5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fa6,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fa7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0fa8,0x00fffffe,0x00fdfffa,0x00fdfffb,0x00fffffe)    R(0x0fa9,0x00fffeff,0x00fffcff,0x00fffbff,0x00fffbff)    R(0x0faa,0x00fffcff,0x00fffefe,0x00fff9ff,0x00fff6ff)    R(0x0fab,0x00fdfbff,0x00f7fffe,0x00f0fffb,0x00e5f3ff)    R(0x0fac,0x00c5ccf2,0x00675cf3,0x002e31d4,0x002c25e2)    R(0x0fad,0x00291df0,0x00210ff6,0x001202f7,0x000700f2)    R(0x0fae,0x001005f8,0x001505fb,0x001706fe,0x001603fe)    R(0x0faf,0x001504fe,0x001504ff,0x001205fc,0x001108f7)\n    R(0x0fb0,0x000e09f1,0x000e0aef,0x000f0bf0,0x000c09ec)    R(0x0fb1,0x000c05e6,0x001007e3,0x000e07de,0x000902d4)    R(0x0fb2,0x000b04d4,0x00140dcc,0x00221fc3,0x002829af)    R(0x0fb3,0x003033ad,0x00aeafdf,0x00e0e0ff,0x00f7f5ff)    R(0x0fb4,0x00fefaff,0x00fcf6fd,0x00feffff,0x00fffffd)    R(0x0fb5,0x00fffffd,0x00fffffd,0x00fffffe,0x00fffeff)    R(0x0fb6,0x00fffdff,0x00fffdff,0x00ffffff,0x00ffffff)    R(0x0fb7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0fb8,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fb9,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fba,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fbb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fbc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fbd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fbe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fbf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0fc0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fc1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fc2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fc3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fc4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fc5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fc6,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fc7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0fc8,0x00fffeff,0x00fffeff,0x00fffffd,0x00fdfffa)    R(0x0fc9,0x00fdfffc,0x00fcfeff,0x00fcfdff,0x00fdfeff)    R(0x0fca,0x00fefffe,0x00fdffef,0x00fffdff,0x00fff2ff)    R(0x0fcb,0x00fff2ff,0x00fdf8ff,0x00fcfff4,0x00f6fff0)    R(0x0fcc,0x00f5fff8,0x00f0fff6,0x00eaf6ff,0x00c5cae8)    R(0x0fcd,0x009391de,0x005146d7,0x002022cf,0x001c1fd9)    R(0x0fce,0x001f1be7,0x001f17dd,0x001a15d8,0x001811e0)    R(0x0fcf,0x00190dea,0x001407ed,0x001105ef,0x001006ee)\n    R(0x0fd0,0x001108ed,0x001507f1,0x001706f1,0x00190aea)    R(0x0fd1,0x002012e0,0x002117ce,0x001c1bc3,0x002021af)    R(0x0fd2,0x002325be,0x006e5fe6,0x00aca0e5,0x00d5d6fb)    R(0x0fd3,0x00f2fffe,0x00f4fefb,0x00f7faff,0x00fcf5ff)    R(0x0fd4,0x00faf0ff,0x00f8f1fa,0x00fcfdff,0x00fdffff)    R(0x0fd5,0x00fffffe,0x00fffffc,0x00fffffd,0x00fffeff)    R(0x0fd6,0x00fffdff,0x00fdfbff,0x00fffeff,0x00ffffff)    R(0x0fd7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0fd8,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fd9,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fda,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fdb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fdc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fdd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fde,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fdf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0fe0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fe1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fe2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fe3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fe4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fe5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fe6,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fe7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0fe8,0x00fffeff,0x00fffaff,0x00ffffff,0x00fdfff8)    R(0x0fe9,0x00fbfff6,0x00fafff9,0x00fafffd,0x00fafffb)    R(0x0fea,0x00fbfffa,0x00f7fffd,0x00fbfff7,0x00fffff3)    R(0x0feb,0x00fffff5,0x00fffffb,0x00fffbfe,0x00fffaff)    R(0x0fec,0x00fff9ff,0x00fffff5,0x00fcfff4,0x00fdfdff)    R(0x0fed,0x00f6f7ff,0x00f2f6ff,0x00e3ecff,0x00ceddff)    R(0x0fee,0x00b3c7e8,0x0097a5e2,0x00767fe3,0x005c61e4)    R(0x0fef,0x004141e6,0x002725e0,0x00231ee7,0x00231eeb)\n    R(0x0ff0,0x00221eee,0x002f2be2,0x005752e3,0x007571e4)    R(0x0ff1,0x00918fe1,0x00b1b2e1,0x00c2c7f0,0x00e3e8ff)    R(0x0ff2,0x00f2f9ff,0x00f8fbfe,0x00fffafd,0x00fff9ff)    R(0x0ff3,0x00fffaff,0x00fefaff,0x00fefcff,0x00fafbf4)    R(0x0ff4,0x00f9ffec,0x00fbffeb,0x00f9fffd,0x00faffff)    R(0x0ff5,0x00fefdff,0x00fffcff,0x00fffbff,0x00fffdff)    R(0x0ff6,0x00ffffff,0x00fdfffc,0x00ffffff,0x00ffffff)    R(0x0ff7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0ff8,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ff9,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ffa,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ffb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ffc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ffd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0ffe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0fff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n  }\n  return r;\n}\n#endif\n\n#else\n\nconst int image_width = 45;\nconst int image_height = 89;\nconst int pixel_data_size = 1001;\n\n\n#ifdef USE_ARRAY\nconst ivec4 pixel_data_array[1001] = ivec4[](\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fcfcfc,0x00f4f4f4,0x00f3f4f3,0x00e4e5e5),\n  ivec4(0x00e5e7e8,0x00e8ecee,0x00e3e7ed,0x00e1e5ec),  ivec4(0x00e5e8ed,0x00e9edf1,0x00edf0f2,0x00f4f5f7),  ivec4(0x00f7f8f8,0x00eaebeb,0x00fcfdfd,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00f3f5f6,0x00bcc0c5),  ivec4(0x00818fa4,0x005376a3,0x00396aa5,0x00386dab),\n  ivec4(0x003c73ae,0x003b73aa,0x00386da3,0x00476e9c),  ivec4(0x00667b9c,0x008c95a2,0x00cdd1d6,0x00fdfdfd),  ivec4(0x00fefefe,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00feffff),  ivec4(0x00feffff,0x00ffffff,0x00d7d6d7,0x005f616f),  ivec4(0x00003d71,0x00366097,0x00396198,0x00315789),  ivec4(0x002f5182,0x002f4f7e,0x002e4e7f,0x002f4d7f),\n  ivec4(0x002f4f81,0x002b517d,0x00224b79,0x00000035),  ivec4(0x00888b92,0x00fefefe,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00fcfcfc,0x00e0e1e4,0x00b5bbc1,0x005b6270),  ivec4(0x00002147,0x001e304b,0x000b0d2f,0x0000001f),  ivec4(0x00030023,0x00050022,0x0004001b,0x00010016),  ivec4(0x0003001a,0x0003001a,0x000a0c29,0x00172341),\n  ivec4(0x00132a48,0x00002542,0x00fcfcfd,0x00feffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00fefeff,0x00fefefe),  ivec4(0x00fdfdfe,0x00fdfdfd,0x00fdfdfd,0x00fdfdfd),\n  ivec4(0x00fdfdfd,0x00fefefe,0x00fefefe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00fffffe),  ivec4(0x00ffffff,0x00dad9dc,0x006c7489,0x00001c4d),\n  ivec4(0x00041127,0x000c0820,0x000c1034,0x000d1844),  ivec4(0x000e1d4a,0x00101f4a,0x00111e4b,0x00101c47),  ivec4(0x000d1940,0x000d173f,0x000d1639,0x000d1331),  ivec4(0x000e1328,0x000f1530,0x00000634,0x00dcdee1),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00f8fafb,0x00dee5eb),  ivec4(0x00c3ccd9,0x00a1adc1,0x008a98b2,0x008694ab),  ivec4(0x008e98aa,0x00a3abb8,0x00bfc5ce,0x00dadde1),\n  ivec4(0x00eef0f1,0x00fcfdfd,0x00fefefe,0x00fdfdfe),  ivec4(0x00fdfefe,0x00fefefe,0x00ffffff,0x00ffffff),  ivec4(0x00feffff,0x00ffffff,0x00cccecd,0x00545558),  ivec4(0x00000000,0x00090a29,0x000e1640,0x00111e4f),\n  ivec4(0x0016285b,0x00192e62,0x001a3166,0x001b3066),  ivec4(0x00182d63,0x00182c5e,0x00152755,0x0014224f),  ivec4(0x00121c42,0x000d1631,0x000c1227,0x00000928),  ivec4(0x008e8f97,0x00fbfcfb,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00fcfcfb,0x00aebbcb),  ivec4(0x00376cad,0x00215ca0,0x0027528b,0x001d4377),  ivec4(0x00053365,0x00002c5f,0x00003566,0x00003a6b),  ivec4(0x00184473,0x00596d89,0x00a5b0bb,0x00d0d7de),\n  ivec4(0x00bdc2ca,0x00c2c9d0,0x00cdd3d7,0x00e5e9ec),  ivec4(0x00f8f9fa,0x00fefefe,0x00fffffe,0x00a3a3a2),  ivec4(0x00000000,0x000b1133,0x00101f4a,0x0015285e),  ivec4(0x0017306f,0x001e3a7b,0x00254587,0x002b4c8e),\n  ivec4(0x002b498c,0x00264483,0x00223e79,0x001b366c),  ivec4(0x00192f62,0x00162954,0x00132147,0x000f1a36),  ivec4(0x00040c28,0x00666872,0x00f5f6f7,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00fffeff,0x00f8f8f9),\n  ivec4(0x00626c89,0x00000848,0x0005053c,0x000d194c),  ivec4(0x000f1c4f,0x00121e50,0x00111d4a,0x0009133c),  ivec4(0x00080a31,0x0006042b,0x00000d33,0x0000003d),  ivec4(0x00000047,0x00003369,0x00003b72,0x00003268),\n  ivec4(0x00000049,0x00012750,0x00b9bec2,0x00f0f2f3),  ivec4(0x00999a9b,0x00000000,0x00122051,0x00172d65),  ivec4(0x001c387a,0x0021438c,0x00284c99,0x003259a5),  ivec4(0x003b64ad,0x003961aa,0x0032579f,0x002b4f92),\n  ivec4(0x00244682,0x001e3c74,0x001a3265,0x00152955),  ivec4(0x00142346,0x000f1a35,0x003e4354,0x00f0f1f1),  ivec4(0x00ffffff,0x00ffffff,0x00feffff,0x00fefefd),  ivec4(0x00d6d7db,0x00000025,0x00182f63,0x00213d76),\n  ivec4(0x00284481,0x00294785,0x00284581,0x00233f79),  ivec4(0x001c3369,0x00162a5b,0x00132451,0x00111f47),  ivec4(0x00101a3e,0x000d1435,0x00080829,0x00090727),  ivec4(0x00101633,0x001b2944,0x00000036,0x007f8792),\n  ivec4(0x00dbdee3,0x009e9ea4,0x0000002c,0x00172a62),  ivec4(0x001c3879,0x0023468f,0x002a4fa1,0x002f57ae),  ivec4(0x003c66b4,0x004773b3,0x004773b5,0x003f6ab8),  ivec4(0x00365eab,0x002d539a,0x00274887,0x00203d75),\n  ivec4(0x001b3363,0x00162a51,0x00112343,0x004c525f),  ivec4(0x00f1f2f3,0x00ffffff,0x00ffffff,0x00fdffff),  ivec4(0x00fafafb,0x005c6179,0x00002770,0x002c4e92),  ivec4(0x003d64aa,0x004871b6,0x00456fb6,0x003f67b0),\n  ivec4(0x00365ca4,0x002c4d90,0x0024427f,0x001f3b73),  ivec4(0x001d366a,0x001a3162,0x00192d5d,0x00182b58),  ivec4(0x00162754,0x0012224d,0x00122248,0x00001645),  ivec4(0x00787f8f,0x00e3e4e9,0x00adacb5,0x00000044),\n  ivec4(0x00193370,0x0020428a,0x00294fa0,0x002f5bb2),  ivec4(0x003265c2,0x004075c1,0x005187bf,0x005288c7),  ivec4(0x00477dd1,0x003e6ec6,0x00345daf,0x002d5199),  ivec4(0x00244482,0x001d3a6e,0x00172e5a,0x000b244c),\n  ivec4(0x00777a83,0x00f9f9f9,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00f8f9fa,0x002b4073,0x00254c96),  ivec4(0x003b65b3,0x005481cc,0x005c91d1,0x00578dd0),  ivec4(0x005180ce,0x004472c2,0x003762ac,0x0032569b),\n  ivec4(0x002e5090,0x002b4b8a,0x00284984,0x0027467e),  ivec4(0x00254076,0x001f3c6f,0x00183364,0x00122756),  ivec4(0x000d214c,0x00000032,0x00c8c8cc,0x00c3c1c6),  ivec4(0x00343963,0x000a3076,0x00244895,0x002e55ad),\n  ivec4(0x003462c3,0x00366fd3,0x004681d4,0x00558fd4),  ivec4(0x005590d7,0x004b87dd,0x004276d4,0x003966bb),  ivec4(0x003057a5,0x00284c8e,0x001f3f76,0x00193160),  ivec4(0x0000174c,0x00999ca2,0x00fcfdfd,0x00ffffff),\n  ivec4(0x00ffffff,0x00fffeff,0x00f6f9fa,0x0038518d),  ivec4(0x002856a6,0x003c6ec5,0x00568edd,0x005e9ade),  ivec4(0x005b97e1,0x00528de3,0x00477dd5,0x003c6dbd),  ivec4(0x003863ad,0x00365ca2,0x003b5999,0x003b538f),\n  ivec4(0x00364c82,0x002f426d,0x0026315b,0x001f2a54),  ivec4(0x001b2851,0x000a1b4b,0x00000033,0x00c6c5c6),  ivec4(0x00b6aba8,0x00200000,0x001d2f65,0x00244691),  ivec4(0x002e57b0,0x003465cb,0x003774de,0x003e7fe2),\n  ivec4(0x004886df,0x004889e0,0x004583e3,0x004076d8),  ivec4(0x003769bf,0x002f5aa8,0x002a5093,0x00214279),  ivec4(0x00143160,0x00000038,0x00d5d7d9,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00fffffe,0x00fbfbfc),\n  ivec4(0x007e8ab0,0x00004aa5,0x00386dc7,0x004987e6),  ivec4(0x005294e8,0x005090ea,0x004c87e6,0x003d76d1),  ivec4(0x003666bb,0x00405ca2,0x00515489,0x00664960),  ivec4(0x00764332,0x00793c00,0x00733400,0x00673000),\n  ivec4(0x00532602,0x00421d05,0x00200000,0x00616363),  ivec4(0x00cfcdcd,0x00b09e9d,0x005b0000,0x00532c30),  ivec4(0x00303b74,0x002650a4,0x003565cb,0x003870de),  ivec4(0x003978e2,0x003b7ae2,0x003f7de4,0x003f7ae3),\n  ivec4(0x003972d6,0x003668bf,0x002f5aaa,0x00295094),  ivec4(0x001d3d76,0x00001954,0x0082858f,0x00ffffff),  ivec4(0x00fefeff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fefefd,0x00dde3ee,0x00023f98,0x002e62ba),\n  ivec4(0x003979da,0x004186eb,0x004182e8,0x003a76d4),  ivec4(0x003b67bc,0x005a5b90,0x00884e47,0x009c5102),  ivec4(0x00a25000,0x00a15114,0x00964d1b,0x008d471d),  ivec4(0x0087451f,0x00793d1f,0x0067341f,0x005d270a),\n  ivec4(0x004d2712,0x00ced2ce,0x00cfc3bc,0x007f4120),  ivec4(0x00773908,0x00643425,0x00393d75,0x002b56b1),  ivec4(0x003367d0,0x003673dd,0x003774de,0x003973de),  ivec4(0x003873d9,0x00356fcf,0x003464ba,0x002f5aa5),\n  ivec4(0x0024488a,0x000f336a,0x004a526a,0x00eff1f3),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00fdfeff,0x00fcfdfc,0x00b0bcd2),  ivec4(0x004c68af,0x003c66b9,0x00396ac4,0x003662be),\n  ivec4(0x005060ac,0x007f586a,0x00a45500,0x00aa5a12),  ivec4(0x00a0531c,0x009a4c18,0x00914617,0x008e4419),  ivec4(0x008e4619,0x008d451d,0x007a3c20,0x005a2d1f),  ivec4(0x0055291a,0x00240000,0x00c6c4c5,0x00d0c2be),\n  ivec4(0x00935026,0x009b4907,0x00994b16,0x00844100),  ivec4(0x005b4264,0x003f529e,0x00365eb7,0x003161bd),  ivec4(0x002e63c0,0x003066c3,0x003063bb,0x002d59a2),  ivec4(0x00244986,0x00203768,0x00000037,0x009e9695),\n  ivec4(0x00fafbfc,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00fffeff),  ivec4(0x00fcfefe,0x00d2d9e3,0x009ea8c4,0x00929dbc),  ivec4(0x007d6c85,0x00974b11,0x00ac5900,0x00a8551d),\n  ivec4(0x00a25119,0x00a25117,0x00a45115,0x00a24e10),  ivec4(0x009d4b0e,0x009a4a10,0x00964817,0x00813f1e),  ivec4(0x00663421,0x005d2504,0x005b4032,0x00d7d6d6),  ivec4(0x00cdbdb8,0x00943d00,0x00a14d11,0x00a25217),\n  ivec4(0x00a65617,0x009f4e00,0x00874629,0x006b445d),  ivec4(0x00514473,0x003d4382,0x00394885,0x00354176),  ivec4(0x002e3359,0x0034283e,0x00381c1d,0x00553c32),  ivec4(0x00dbd9d6,0x00fefdfe,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00feffff,0x00feffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ebe0d9,0x00a76848,0x00a14c04),  ivec4(0x00a9571f,0x00a9581f,0x00a6551a,0x00a45117),\n  ivec4(0x00a24e13,0x009a4913,0x00934718,0x008c441e),  ivec4(0x00793c20,0x00693621,0x005b1600,0x007c6b63),  ivec4(0x00e0dfdf,0x00c3b1ae,0x008f2600,0x00a65416),  ivec4(0x00a85719,0x00a35218,0x00a3531a,0x00a65616),\n  ivec4(0x00a65200,0x009d4d00,0x00934900,0x008c4200),  ivec4(0x00824000,0x006e3711,0x005a2b13,0x00000000),  ivec4(0x00cec8c5,0x00ffffff,0x00feffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00fefffe),  ivec4(0x00ffffff,0x00ffffff,0x00fbfcfb,0x00d4c5be),  ivec4(0x009a3700,0x00a8581e,0x00a7561c,0x00a35216),  ivec4(0x00a15013,0x009f4d10,0x009a4b11,0x00944817),\n  ivec4(0x008b431e,0x00773b21,0x006a3621,0x00590e00),  ivec4(0x0081726e,0x00dedcdb,0x00bda8a5,0x008d1800),  ivec4(0x00a45216,0x00a7561f,0x00ab5922,0x00a6571e),  ivec4(0x00a65114,0x009e4d13,0x00974a18,0x008f461b),\n  ivec4(0x0083421a,0x006c371b,0x004e2517,0x002b0000),  ivec4(0x0058453f,0x00f6f7f7,0x00ffffff,0x00fefffe),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00f0eae9,0x008f3d00,0x00a54e09,0x00a55319),  ivec4(0x00a55417,0x00a45316,0x00a15011,0x009f4d0d),  ivec4(0x00994a13,0x008b441e,0x00763b22,0x006b3722),\n  ivec4(0x00580500,0x008e807d,0x00d1cbca,0x00ac908e),  ivec4(0x00912d00,0x00a65419,0x00a7571e,0x00a9581f),  ivec4(0x00a5561d,0x00a55117,0x009c4a14,0x008a441c),  ivec4(0x00743b22,0x005d301e,0x004e261a,0x00421d10),\n  ivec4(0x000c0000,0x00b8b2b1,0x00fcfcfc,0x00fefefe),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00feffff,0x00f4f2f0,0x00a98270,0x009d3b00),  ivec4(0x00a7561b,0x00a7561b,0x00a55417,0x00a35113),  ivec4(0x00a24d0d,0x009b4a10,0x008a451d,0x00753b21),  ivec4(0x006a3721,0x00570000,0x00978985,0x00c9c2c1),\n  ivec4(0x00a2827d,0x00943500,0x00a65518,0x00a8581c),  ivec4(0x00a8591e,0x00a6561a,0x00a44f12,0x00964717),  ivec4(0x0083421f,0x006e3921,0x00592d1c,0x004d2518),  ivec4(0x003d1809,0x00330100,0x00dcdbdb,0x00fdfdfd),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00f9f7f6,0x00c6afa5),\n  ivec4(0x00952000,0x00a95a1c,0x00a8581d,0x00a55518),  ivec4(0x00a35214,0x00a14e0f,0x009a4b10,0x0089451d),  ivec4(0x00743c21,0x006a3621,0x00570000,0x009a8f8c),  ivec4(0x00bcb3b1,0x00986e63,0x00983e00,0x00a75318),\n  ivec4(0x00a65519,0x00a65619,0x00a45417,0x00a14e11),  ivec4(0x00944718,0x007f4121,0x00663521,0x0054281b),  ivec4(0x004a2416,0x002f0000,0x006f6663,0x00f5f4f4),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00fdfdfc),  ivec4(0x00dfd3cd,0x00910000,0x00a9591c,0x00a7581d),\n  ivec4(0x00a55517,0x00a35214,0x00a24f0f,0x009b4a10),  ivec4(0x008a451d,0x00743c21,0x006a3721,0x00570000),  ivec4(0x00a29692,0x00aea09c,0x00904f32,0x009e4a00),  ivec4(0x00a55317,0x00a65518,0x00a65517,0x00a55213),\n  ivec4(0x009d4b12,0x008f451c,0x00783d21,0x005f301f),  ivec4(0x00512619,0x00452012,0x00000000,0x00b3afad),  ivec4(0x00fbfbfb,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00feffff),  ivec4(0x00ffffff,0x00eee7e5,0x009c4900,0x00a85412),  ivec4(0x00a6581d,0x00a65618,0x00a35315,0x00a14f11),\n  ivec4(0x009d4b11,0x008e451c,0x00763c21,0x006c3722),  ivec4(0x005b0000,0x00a59591,0x00a7928d,0x008a3c00),  ivec4(0x00a04e09,0x00a35315,0x00a45417,0x00a55316),  ivec4(0x00a35011,0x009b4913,0x008a441f,0x00723b21),\n  ivec4(0x005b2d1d,0x004c2415,0x003f160a,0x00000000),  ivec4(0x00e5e4e1,0x00fffefe,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00f2eeed,0x00ab765f),  ivec4(0x00a34d00,0x00a8571f,0x00a7561b,0x00a55316),  ivec4(0x00a35012,0x009f4b11,0x008f451b,0x00783d21),\n  ivec4(0x006d3821,0x00642000,0x0097817b,0x009b7c73),  ivec4(0x00903c00,0x00a35013,0x00a45315,0x00a45315),  ivec4(0x00a45216,0x00a14f10,0x00994913,0x00844220),  ivec4(0x006d3822,0x00582b1c,0x00482315,0x002a0000),\n  ivec4(0x00736361,0x00f8f8f8,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00f5f2f1),  ivec4(0x00bb9488,0x00a04400,0x00a8571f,0x00a8571b),  ivec4(0x00a65417,0x00a45214,0x009f4d11,0x0091461a),  ivec4(0x007a3e21,0x006e3821,0x006b2f0c,0x0082655a),\n  ivec4(0x008f6251,0x00994400,0x00a55315,0x00a55416),  ivec4(0x00a45416,0x00a45217,0x00a14f0f,0x00944817),  ivec4(0x007e4021,0x00673520,0x00552a1a,0x00452013),  ivec4(0x00000000,0x00beb7b7,0x00fafbfb,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00f7f5f4,0x00c2a8a0,0x009e3c00,0x00a8571d),  ivec4(0x00a8571b,0x00a65517,0x00a45214,0x00a04e10),  ivec4(0x00924819,0x007c3e21,0x006f3920,0x00713921),  ivec4(0x005f3425,0x00813f1e,0x00a24f13,0x00a45315),\n  ivec4(0x00a55417,0x00a45416,0x00a45216,0x00a04e10),  ivec4(0x008e451c,0x00763d21,0x0061321e,0x00502619),  ivec4(0x00411c0f,0x000e0000,0x00dad8d8,0x00fefdfd),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00faf9f8,0x00cebeb8,0x009a3a00),\n  ivec4(0x00a7561b,0x00a8571c,0x00a55417,0x00a45114),  ivec4(0x00a04e10,0x00934817,0x007d3f20,0x006f3921),  ivec4(0x006e3821,0x005f311f,0x00843f18,0x00a34f14),  ivec4(0x00a45315,0x00a55317,0x00a45315,0x00a35013),\n  ivec4(0x009b4b12,0x0088441f,0x00703a21,0x005b2e1d),  ivec4(0x004d2418,0x003b0c00,0x0055433e,0x00e6e8e8),  ivec4(0x00feffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00fdfcfc,0x00dccfca),  ivec4(0x00973b00,0x00a85617,0x00a8571c,0x00a55518),\n  ivec4(0x00a35215,0x00a14e12,0x00944817,0x007f401f),  ivec4(0x006b3720,0x00693620,0x00673420,0x00874219),  ivec4(0x00a24f11,0x00a45113,0x00a35215,0x00a45114),  ivec4(0x00a24e10,0x00964816,0x0082431f,0x006c3822),\n  ivec4(0x00582c1c,0x004c2316,0x00320000,0x007f7674),  ivec4(0x00f4f4f4,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00fffffe),  ivec4(0x00e6dcd7,0x00964000,0x00a85514,0x00a8571d),  ivec4(0x00a55518,0x00a35215,0x00a04d12,0x00944918),\n  ivec4(0x007f4120,0x006a3720,0x00653420,0x00663420),  ivec4(0x00894318,0x00a14e0e,0x00a34f10,0x00a35012),  ivec4(0x00a24f0f,0x009f4c0e,0x00934619,0x007e4020),  ivec4(0x00683720,0x00542a1a,0x00492316,0x00180000),\n  ivec4(0x00a7a2a1,0x00f9f8f8,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00e9e1dd,0x00994700,0x00a7530f),  ivec4(0x00a8571e,0x00a55519,0x00a35215,0x00a04e12),  ivec4(0x00964816,0x0081411f,0x006c3721,0x00623220),\n  ivec4(0x00663520,0x008a441a,0x009f4c0e,0x00a14d0c),  ivec4(0x00a24e0f,0x00a04d0d,0x009c4a10,0x008f451a),  ivec4(0x007b3f20,0x0064341f,0x00512818,0x00462113),  ivec4(0x00000000,0x00d4d0d0,0x00fdfdfd,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ede6e3,0x009d5931),  ivec4(0x00a54f00,0x00a8571e,0x00a6561a,0x00a55415),  ivec4(0x00a45114,0x00994915,0x0082401d,0x0069361f),  ivec4(0x005b2e1c,0x0063331e,0x0083421f,0x00984a16),\n  ivec4(0x009d4b0e,0x00a04b0c,0x009e4b0d,0x00984913),  ivec4(0x008c451b,0x00783e21,0x0061321f,0x004f2618),  ivec4(0x00401606,0x00000000,0x00eceaea,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00efebe9),\n  ivec4(0x00a0684f,0x00a34a00,0x00a8571e,0x00a7561c),  ivec4(0x009d4f17,0x008f4613,0x007f3d14,0x006a331b),  ivec4(0x00572b1b,0x00522819,0x005d2f1d,0x00753c21),  ivec4(0x008b451d,0x00964916,0x009c4a11,0x009c4b11),\n  ivec4(0x00954917,0x0088451e,0x00753c22,0x005e2f1e),  ivec4(0x004e2517,0x002a0000,0x0072625f,0x00f4f3f3),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00efecea,0x00a0705b,0x00a24700,0x00a5561d),\n  ivec4(0x00914b1b,0x006b3414,0x004b2110,0x00451f14),  ivec4(0x004b2217,0x00522719,0x005a2c1d,0x005e2f1e),  ivec4(0x00663520,0x007a3e20,0x008b451c,0x00954816),  ivec4(0x00974914,0x0090471a,0x00834320,0x00713a21),\n  ivec4(0x005b2e1c,0x004d2417,0x00000000,0x00ada8a7),  ivec4(0x00f9f9f9,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00efeceb,0x009c705f,0x00973f00),  ivec4(0x00814117,0x004c2211,0x002d1110,0x00441f14),\n  ivec4(0x00512519,0x00572a1b,0x005b2e1d,0x00643320),  ivec4(0x006a3621,0x00693620,0x00703a21,0x007d4021),  ivec4(0x008c451c,0x00934719,0x008c461d,0x007e4022),  ivec4(0x006c3721,0x00572d1b,0x00401505,0x00000000),\n  ivec4(0x00afaead,0x00d3d4d3,0x00dadad9,0x00d8d8d8),  ivec4(0x00eaebeb,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00efeceb,0x00957165),  ivec4(0x006a1a00,0x00401b10,0x00391710,0x004a2214),  ivec4(0x00532719,0x00592c1d,0x005d2f1d,0x0062321f),\n  ivec4(0x006c3821,0x00733c21,0x00753d21,0x00773e22),  ivec4(0x00804120,0x008b441d,0x008e451d,0x0086441f),  ivec4(0x00793e22,0x0066351f,0x004f200a,0x00402825),  ivec4(0x005b5755,0x0081807d,0x006f6c69,0x006d6b68),\n  ivec4(0x0061615f,0x00929191,0x00dadada,0x00ffffff),  ivec4(0x00feffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00eeecec),  ivec4(0x00816a64,0x00340000,0x00492214,0x00512719),  ivec4(0x00582c1c,0x005f301d,0x00663420,0x006c3721),  ivec4(0x00703a21,0x00753d21,0x007c4021,0x00824221),\n  ivec4(0x0086431f,0x008a441e,0x008d451c,0x008a441e),  ivec4(0x00804121,0x00733d22,0x005e2d17,0x00432114),  ivec4(0x0067615d,0x00898785,0x008e8d8a,0x008c8b87),  ivec4(0x00868582,0x0091908e,0x0081807f,0x007d7b79),\n  ivec4(0x00dfdedd,0x00fdfdfd,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00e8e6e6,0x005d4845,0x00410300,0x00592c1c),  ivec4(0x0061311f,0x00653421,0x00693721,0x00713b20),  ivec4(0x007b4021,0x007d4121,0x007f4121,0x00844221),  ivec4(0x0089451e,0x008d461b,0x008e461d,0x008a441e),\n  ivec4(0x0083421f,0x00793f21,0x006c371f,0x00562c18),  ivec4(0x00665d58,0x00807f7b,0x008d8c87,0x008e8e8a),  ivec4(0x00afafad,0x00c1c1bf,0x00c5c5c3,0x00c7c8c7),  ivec4(0x00bcbcbb,0x00a8a7a5,0x00fbfbfb,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fcfcfc,0x00d1cfce,0x003e0000,0x005e2d19),\n  ivec4(0x006b3621,0x00713922,0x00733c22,0x00793f21),  ivec4(0x0080411f,0x0089441d,0x008c461c,0x008b451d),  ivec4(0x008e451c,0x008d461b,0x008a461c,0x0087441f),  ivec4(0x00804121,0x00783f22,0x006f3a21,0x00602200),\n  ivec4(0x00736258,0x009c9a95,0x00a4a39f,0x009b9c97),  ivec4(0x00bebebc,0x00d4d5d3,0x00cacbc9,0x00b5b4b2),  ivec4(0x00cacccb,0x00e9eaea,0x00b0b0ae,0x00f9fbfb),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00f6f5f5,0x00b0aaa8,0x004e0000),  ivec4(0x006e3922,0x00783e22,0x007e4021,0x0086441e),\n  ivec4(0x008f4719,0x00924818,0x00974915,0x00994913),  ivec4(0x00994913,0x00994a12,0x00934816,0x0089441e),  ivec4(0x007f4221,0x00763e22,0x006e3922,0x00673521),  ivec4(0x00560100,0x00867a72,0x00babbb7,0x00c0c2bf),\n  ivec4(0x00c3c4c2,0x00e2e3e2,0x00e3e3e2,0x00cbcdca),  ivec4(0x00a2a19f,0x00b1b3b2,0x00cccdcd,0x00a5a4a2),  ivec4(0x00e8e8e8,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00f2f0f0,0x00978682),  ivec4(0x00671d00,0x007e4022,0x00834220,0x0088431e),  ivec4(0x00964915,0x009f4c0e,0x00a04d10,0x00a14e10),\n  ivec4(0x00a04d0e,0x00a14d0a,0x00a14c0a,0x009d4b0f),  ivec4(0x008f4719,0x0082431f,0x00793e22,0x00713a21),  ivec4(0x006d371e,0x00652c05,0x00797269,0x00aeafac),  ivec4(0x00c2c3c1,0x00dddedc,0x00eeedee,0x00e7e7e7),\n  ivec4(0x00d4d4d2,0x00b4b2b1,0x00797a78,0x00949896),  ivec4(0x00aeafae,0x00dfdedd,0x00fffefe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00f0efee),  ivec4(0x0080665c,0x007c3600,0x008f471c,0x00944818),  ivec4(0x00984a17,0x00a04e12,0x00a55011,0x00a45012),  ivec4(0x00a45013,0x00a35013,0x00a34e10,0x00a34d0d),\n  ivec4(0x00a14c0d,0x009b4a12,0x008e4619,0x007d3f1f),  ivec4(0x0070381f,0x00693117,0x006d412f,0x00817d77),  ivec4(0x00a2a29f,0x00cdcecc,0x00edeeec,0x00f2f1f2),  ivec4(0x00e8e7e8,0x00d6d5d5,0x00bcbab9,0x006f6e6c),\n  ivec4(0x00808584,0x00dcdddd,0x00f9f9f9,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00f6f6f7),\n  ivec4(0x00e1dfde,0x00825e4f,0x00813b00,0x00944818),  ivec4(0x009c4c10,0x00a15011,0x00a55315,0x00a75619),  ivec4(0x00a65519,0x00a45217,0x00a35116,0x00a35014),  ivec4(0x00a24e11,0x00a14c0e,0x009e4b0f,0x00894319),\n  ivec4(0x00723920,0x00673420,0x005f2914,0x0068473b),  ivec4(0x00898482,0x00b1b1b0,0x00dfdfde,0x00f6f6f5),  ivec4(0x00f3f2f4,0x00e7e7e7,0x00d3d4d2,0x00b8b6b5),  ivec4(0x006c6968,0x00b3b4b4,0x00f7f8f7,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00e4e4e4,0x00bcbcbd),  ivec4(0x00a2a2a2,0x00928e8e,0x00784a3c,0x00854012),\n  ivec4(0x00954818,0x00994d14,0x00a05115,0x00a45418),  ivec4(0x00a8571c,0x00a8571c,0x00a7561b,0x00a65519),  ivec4(0x00a55317,0x00a45215,0x00a45011,0x00984a15),  ivec4(0x00813f1f,0x00793c22,0x00773c21,0x00713315),\n  ivec4(0x0074513f,0x00918a89,0x00bebebd,0x00ededed),  ivec4(0x00fcfcfc,0x00f3f3f4,0x00e5e5e6,0x00d0d1cf),  ivec4(0x00b2afae,0x00726f6d,0x00f6f5f5,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00d0d1cf,0x007a797c),  ivec4(0x00000000,0x00000000,0x00000019,0x005d2825),  ivec4(0x008e471b,0x009e4e13,0x009f5117,0x00a35419),\n  ivec4(0x00a6551a,0x00a5541a,0x00a5541a,0x00a8561c),  ivec4(0x00a9571d,0x00a7551b,0x00a45418,0x00a45315),  ivec4(0x00974a18,0x008c451b,0x008a451c,0x0081421f),  ivec4(0x00763715,0x00774e39,0x00979190,0x00cdcdcc),\n  ivec4(0x00f6f6f6,0x00fdfdfd,0x00f4f4f5,0x00e2e3e4),  ivec4(0x00cbcdca,0x00a9a7a5,0x006b6966,0x00e9e8e8),  ivec4(0x00fffefe,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00d1d1d2,0x00525252),  ivec4(0x00000000,0x000b0247,0x000c0153,0x001c094f),  ivec4(0x00572c35,0x008f4617,0x00a45111,0x00a45418),  ivec4(0x00a6561c,0x00a8571d,0x00a8571d,0x00a8571d),\n  ivec4(0x00a8571d,0x00a7561c,0x00a5551b,0x00a45418),  ivec4(0x00a55215,0x009e4e16,0x00994b13,0x00924816),  ivec4(0x0083421f,0x00743a20,0x00672900,0x009c948d),  ivec4(0x00d7d9d8,0x00fafafb,0x00faf9f9,0x00eff1f1),\n  ivec4(0x00dbdede,0x00c4c6c4,0x00989794,0x00393831),  ivec4(0x00aaa9a8,0x00fcfcfc,0x00feffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00e1e0e0,0x00505052),\n  ivec4(0x00000000,0x0006003f,0x000c014c,0x000c004e),  ivec4(0x000c034a,0x00462142,0x008a441a,0x00a45112),  ivec4(0x00a65619,0x00a8571e,0x00a8591f,0x00aa5920),  ivec4(0x00ab5a21,0x00aa5920,0x00a7581e,0x00a8581e),\n  ivec4(0x00a8571d,0x00a55318,0x00a35116,0x00a34f13),  ivec4(0x00974818,0x0083411e,0x00793f22,0x006f2100),  ivec4(0x00867366,0x00c8cac9,0x00eceded,0x00e8e8e7),  ivec4(0x00dddedd,0x00cbcccc,0x00adadac,0x0080807b),\n  ivec4(0x0045433d,0x006b6a6a,0x00fcfcfc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00fbfcfc,0x00c9c9c9,0x008f908f),  ivec4(0x00434646,0x00494650,0x00211f41,0x00000044),\n  ivec4(0x0009004b,0x0003004b,0x003f1c48,0x0087421c),  ivec4(0x00a15015,0x00a7561a,0x00a8571e,0x00a85920),  ivec4(0x00aa5a21,0x00a9581f,0x00a5551d,0x00a5561d),  ivec4(0x00a95920,0x00a95820,0x00a6561c,0x00a65417),\n  ivec4(0x00a24f13,0x00974915,0x0090490a,0x007f3f08),  ivec4(0x005c1a00,0x00786c6b,0x00babab7,0x00cbcdcb),  ivec4(0x00c8cac8,0x00c1c1c0,0x00b6b4b4,0x009fa09d),  ivec4(0x00898681,0x0054504b,0x00312e43,0x00dbdadd),\n  ivec4(0x00fefefe,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00d5d6d6,0x00717474),  ivec4(0x00676d6b,0x00797b79,0x00757776,0x006a6d6e),  ivec4(0x004a4a58,0x000b0042,0x00000050,0x003a134c),\n  ivec4(0x00833500,0x009f5016,0x00a7551a,0x00a7581e),  ivec4(0x00a85920,0x00a95920,0x00a2531c,0x009d4f17),  ivec4(0x009e4f18,0x009c4f1c,0x00a2551e,0x00a8571c),  ivec4(0x00a55316,0x00a45216,0x009c4f00,0x00824241),\n  ivec4(0x00582c6a,0x00000068,0x006a6a8a,0x00cecfcf),  ivec4(0x00e0e0db,0x00dadbd7,0x00d6d5d2,0x00d1cec8),  ivec4(0x00b5b5a6,0x0082807e,0x003f3c71,0x00000050),  ivec4(0x0083828c,0x00fbfcfb,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00f0efef,0x00848584),  ivec4(0x00515353,0x005c5f5d,0x00595a59,0x005b5f5d),  ivec4(0x00636664,0x00696b6b,0x00494a54,0x0000004b),  ivec4(0x002a4c6b,0x0076857a,0x009d3600,0x00a6551a),\n  ivec4(0x00a9571d,0x00a85920,0x00a45620,0x00a04c00),  ivec4(0x009e3900,0x00942e00,0x009b4100,0x009a4c14),  ivec4(0x009f511a,0x00a7551c,0x00a55500,0x00814257),  ivec4(0x0041259b,0x000d18a7,0x0000058e,0x002c2d81),\n  ivec4(0x009899ae,0x00cfd0d7,0x00e1e5e9,0x00e3e6e8),  ivec4(0x00cbcbd3,0x009190be,0x004c4bbb,0x001e1ea7),  ivec4(0x00120f78,0x00000033,0x00dcdddf,0x00ffffff),  ivec4(0x00feffff,0x00fdfdfc,0x00cfcfcf,0x008b8a89),\n  ivec4(0x0019180f,0x000f0500,0x002e2c28,0x004c4d4b),  ivec4(0x00424544,0x00373533,0x00545551,0x00666967),  ivec4(0x00220f46,0x00005d7d,0x005cb5bf,0x00906231),  ivec4(0x009e4500,0x00a25417,0x00a8571c,0x00a55000),\n  ivec4(0x0095694c,0x00719e99,0x0059a9ad,0x0075847f),  ivec4(0x00854b29,0x00914508,0x00a75600,0x008b4950),  ivec4(0x004226b2,0x00181ccf,0x00241fbb,0x00201da0),  ivec4(0x000e0c92,0x00000075,0x0064667b,0x008d91da),\n  ivec4(0x008b90e8,0x006c70e2,0x003437e3,0x001f1be6),  ivec4(0x00241fc8,0x001d1a98,0x00000058,0x007f7f90),  ivec4(0x00fefffe,0x00fffffe,0x00ededeb,0x0081807e),  ivec4(0x005c5657,0x00635e5d,0x0066625f,0x005e5b58),\n  ivec4(0x00525551,0x00626564,0x00464441,0x00373531),  ivec4(0x005f605c,0x005d5c6b,0x00485b96,0x000c84b8),  ivec4(0x00779992,0x00994900,0x00a44f10,0x00a75214),  ivec4(0x00a44900,0x007c9991,0x001be0e6,0x0011e6f1),\n  ivec4(0x0027d0d9,0x00678f8b,0x00864106,0x008f4725),  ivec4(0x006136a8,0x00181bdc,0x00251ed8,0x00251fcc),  ivec4(0x00251fc5,0x00211fab,0x0008026b,0x00000000),  ivec4(0x003a36b2,0x000000ea,0x000000f0,0x00262bf0),\n  ivec4(0x00282aeb,0x002620de,0x00221fb9,0x0017138b),  ivec4(0x00000039,0x00ebeaec,0x00fffffe,0x00dedfdd),  ivec4(0x00bbbeba,0x00d7d6d6,0x00d8d8d6,0x00c6c8c6),  ivec4(0x009f9b9a,0x004b4c47,0x00626664,0x00454946),\n  ivec4(0x002f2f2c,0x0042413e,0x0087888a,0x00cdcde0),  ivec4(0x006471c1,0x003d5ca0,0x00904d2c,0x009e4e0f),  ivec4(0x00a15317,0x00a54500,0x00819c8d,0x0033e7eb),  ivec4(0x0027edf7,0x0019edf7,0x0066b7b8,0x00864f13),\n  ivec4(0x00672f73,0x003622d0,0x00211de0,0x00261edd),  ivec4(0x00261fdf,0x002821d5,0x001e1a9d,0x000e0950),  ivec4(0x00000027,0x00353457,0x002e2dce,0x002b31f0),  ivec4(0x002f32ee,0x002b2fee,0x002726ea,0x002520d7),\n  ivec4(0x00221eb1,0x0000005d,0x00c7c5cc,0x00fffffe),  ivec4(0x00c9c9c8,0x00babab7,0x00cccccb,0x00cdcdcb),  ivec4(0x00bbbcba,0x00949190,0x0044423c,0x004f504f),  ivec4(0x00484c49,0x00262826,0x004a4948,0x00bfbfbe),\n  ivec4(0x00ffffff,0x00d9d9f0,0x008782c5,0x00420061),  ivec4(0x007d4200,0x00723f69,0x0076379a,0x00786496),  ivec4(0x0059a9b1,0x0040d0d0,0x004ad0d1,0x00859b90),  ivec4(0x009e5500,0x0065338b,0x000c19d1,0x00261ee1),\n  ivec4(0x00261ee6,0x00251ee4,0x00261fce,0x00201ba7),  ivec4(0x001c178c,0x00151277,0x0001004f,0x0018148a),  ivec4(0x002727da,0x002d2fee,0x002b32ef,0x00292dee),  ivec4(0x002622e7,0x00251fd0,0x0000008d,0x00b2b1b8),\n  ivec4(0x00ffffff,0x00bdbbba,0x00c4c2c0,0x00cdcbca),  ivec4(0x00c8c7c5,0x00bdbbba,0x00999996,0x006e6a66),  ivec4(0x004e4d4c,0x00595a58,0x00373837,0x00646363),  ivec4(0x00edebeb,0x00ffffff,0x00ffffff,0x00e3e5f4),\n  ivec4(0x008c90cb,0x001e0088,0x00582163,0x00482aa0),  ivec4(0x003b1ed1,0x004046d3,0x005d77b7,0x008f8071),  ivec4(0x00a76a35,0x00ad5b00,0x00834668,0x003625bb),  ivec4(0x00201ed7,0x00261ee1,0x00251de5,0x00251ddb),\n  ivec4(0x00251dd6,0x00251ecd,0x00221cc2,0x00211bb6),  ivec4(0x001d18a0,0x00221eba,0x002523db,0x00262bea),  ivec4(0x002730ed,0x002726ec,0x002924e2,0x000000a0),  ivec4(0x00c8c7ce,0x00ffffff,0x00cfcecf,0x00e4e4e4),\n  ivec4(0x00f1f2f1,0x00f5f6f5,0x00ebebea,0x00c2c0be),  ivec4(0x008a8882,0x004c4d4b,0x00616462,0x00484b48),  ivec4(0x00646361,0x00e8e6e6,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00e8eaf9,0x00a7a7e0,0x006d5db1),\n  ivec4(0x004c007d,0x002800a3,0x001904de,0x003e0ad9),  ivec4(0x00752e8d,0x00a45226,0x00b05e11,0x009c530d),  ivec4(0x00593196,0x00101bc1,0x002620da,0x002622e9),  ivec4(0x002726eb,0x002626ec,0x002522e8,0x002724e8),\n  ivec4(0x002726e7,0x002627e2,0x002625d9,0x002722e1),  ivec4(0x002727ec,0x002b31f2,0x002c2df3,0x000000e1),  ivec4(0x004d54af,0x00f0f0f3,0x00fefffe,0x00cdcecd),  ivec4(0x00c0c1c0,0x00c2c2c1,0x00bebdbd,0x00afaead),\n  ivec4(0x00908d8c,0x00686460,0x00454645,0x005e6261),  ivec4(0x004a4e4c,0x005e5d5a,0x00d4d4d3,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00f4f5fd),  ivec4(0x00dcdef3,0x00d6d3e4,0x00bfb4c1,0x006a5795),\n  ivec4(0x00000096,0x00353b85,0x00694755,0x009a5529),  ivec4(0x00b05d00,0x00844556,0x002c20ac,0x00181edc),  ivec4(0x002a2beb,0x002a30ef,0x00292fee,0x002829ed),  ivec4(0x002728ef,0x002829f0,0x002a2cf5,0x002a2bf1),\n  ivec4(0x002521ed,0x00110de1,0x000000d8,0x000000ce),  ivec4(0x007879d5,0x00d7d8e8,0x00ffffff,0x00ffffff),  ivec4(0x00d0d1d0,0x00cacac9,0x00cacac9,0x00bebdbd),  ivec4(0x00b5b5b4,0x00abacaa,0x00999796,0x00716e6e),\n  ivec4(0x005a5c5b,0x004f5352,0x00636461,0x00d4d4d3),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00e4e5e7,0x009e9da4),  ivec4(0x00545973,0x00435c82,0x00476081,0x003d5578),\n  ivec4(0x0058516b,0x008c574a,0x009e5700,0x006b3b89),  ivec4(0x002821de,0x00292cf3,0x002b32f1,0x002a30ef),  ivec4(0x00282bef,0x002421e9,0x000200df,0x000000d1),  ivec4(0x000000c3,0x000000c2,0x004c4dbe,0x008686c9),\n  ivec4(0x00c7c7e5,0x00e7e8f2,0x00fffffd,0x00fefefe),  ivec4(0x00ffffff,0x00ebebeb,0x00dfdfde,0x00eeefef),  ivec4(0x00f6f8f8,0x00f5f6f7,0x00dfdfdd,0x00a6a3a3),  ivec4(0x00666362,0x00565755,0x00535654,0x00747471),\n  ivec4(0x00e8e8e7,0x00ffffff,0x00ffffff,0x00feffff),  ivec4(0x00ffffff,0x00f6f7f7,0x00bec1c7,0x00798093),  ivec4(0x004a5f8a,0x005c7bae,0x00708cbd,0x006f8bb4),  ivec4(0x007390ba,0x006183af,0x00536184,0x0069515b),\n  ivec4(0x005a415d,0x002e24a3,0x002523d5,0x002627e5),  ivec4(0x002725e1,0x00211ece,0x000000bc,0x004c4dbf),  ivec4(0x008383c2,0x00a9abcf,0x00c5c6dc,0x00dcdcea),  ivec4(0x00ebebf2,0x00ffffff,0x00ffffff,0x00fefffd),\n  ivec4(0x00ffffff,0x00ffffff,0x00fcfcfc,0x00d0d1d0),  ivec4(0x00bdbdbc,0x00b2b4b2,0x00adaead,0x008c8c8a),  ivec4(0x00706d69,0x00646461,0x004e4f4b,0x0062625e),  ivec4(0x00848482,0x00fdfdfd,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00f9fafa,0x00bdc1c9,0x0046597e),  ivec4(0x00415f93,0x005c75a7,0x00566b95,0x00405178),  ivec4(0x003f507e,0x00425583,0x005b6fa0,0x005e78a9),  ivec4(0x004b6692,0x00435377,0x00343c65,0x00252c73),\n  ivec4(0x00262b8b,0x00120f82,0x0001016d,0x00bbbdd1),  ivec4(0x00e2e3ee,0x00ececf3,0x00f5f5f8,0x00fbfcfc),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00d7d8d7,0x00cfd0ce,0x00c6c6c6,0x00babab9),  ivec4(0x00afb0af,0x00a5a5a2,0x0083827d,0x0074736f),  ivec4(0x00757470,0x00949492,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00fefefe,0x00d2d6d9,0x004d628a),\n  ivec4(0x004f6fa5,0x006686bd,0x005a73a4,0x00444c5e),  ivec4(0x00414243,0x003d3c47,0x00312c4a,0x00312f58),  ivec4(0x0051628c,0x005973a2,0x00526b99,0x00495b83),  ivec4(0x0038455d,0x002b3645,0x00262f3d,0x000c0f14),\n  ivec4(0x007d7e7c,0x009b9c9a,0x00f0f0ef,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00f6f6f6,0x00eaeaea,0x00ececec),\n  ivec4(0x00f1f1f1,0x00e5e5e5,0x00b3b3b2,0x009c9997),  ivec4(0x008f8d8b,0x006e6c6a,0x009e9e9c,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00eeeff1,0x00919db3),  ivec4(0x004569a3,0x00617aae,0x006582b9,0x004d628b),\n  ivec4(0x00252930,0x00444c62,0x004b5268,0x00494f59),  ivec4(0x004f5760,0x00586172,0x006175a1,0x005f79ac),  ivec4(0x00576e9d,0x004c618b,0x003f4f70,0x00303c57),  ivec4(0x00232c41,0x00000000,0x00000000,0x00c3c3c4),\n  ivec4(0x00fbfbfb,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00fbfafb),  ivec4(0x00f9f9f9,0x00f8f8f8,0x00f6f6f6,0x00e4e4e4),\n  ivec4(0x00a2a09f,0x00726f6f,0x00504e4c,0x009e9c9b),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00e3e6ef),  ivec4(0x007088b7,0x004f6890,0x0027324c,0x002f3c59),  ivec4(0x00202a3d,0x00000005,0x00192032,0x00202535),\n  ivec4(0x001f2222,0x00363f4b,0x005a749e,0x006b88c1),  ivec4(0x006682ba,0x005e79ae,0x005872a3,0x004f6590),  ivec4(0x003c4e72,0x00303f59,0x001d2437,0x00000000),  ivec4(0x00c4c4c5,0x00fbfbfb,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00fdfdfd,0x00fefefe),  ivec4(0x00f9f9f9,0x00a6a3a0,0x0074726e,0x00565450),\n  ivec4(0x00929190,0x00ffffff,0x00ffffff,0x00fbfcfc),  ivec4(0x00cad0dc,0x003f5682,0x001d2530,0x00000000),  ivec4(0x00101b2d,0x001b2a44,0x00192747,0x00132043),  ivec4(0x00182141,0x00090c1c,0x00000000,0x00304362),\n  ivec4(0x003c4f72,0x003f5172,0x005875a5,0x00617db3),  ivec4(0x005a72a3,0x004d628d,0x00394c6c,0x00293452),  ivec4(0x00232334,0x00e8e9ea,0x00ffffff,0x00ffffff),  ivec4(0x00feffff,0x00fffffe,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00f9f9f9,0x00b5b4b1,0x00b7b5b3),  ivec4(0x0092918e,0x0080807e,0x00f8f9f8,0x00ffffff),\n  ivec4(0x00e8ebef,0x0067758d,0x00000004,0x00273144),  ivec4(0x004d638b,0x005772a3,0x00536a9c,0x004a608e),  ivec4(0x003c5179,0x002d3e63,0x00253452,0x00131a2a),  ivec4(0x00000000,0x00000000,0x00000000,0x00607aa8),\n  ivec4(0x006f90cf,0x006280b8,0x005772a4,0x00475e88),  ivec4(0x00364463,0x002b3048,0x008e93a1,0x00abaeb7),  ivec4(0x00e4e4e7,0x00ffffff,0x00fffffe,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00fcfcfc,0x00dddedd),  ivec4(0x00e7e6e6,0x00d3d3d2,0x00969693,0x00dcdcdb),  ivec4(0x00ffffff,0x00c8cedf,0x00001d63,0x00221c0a),\n  ivec4(0x0059709b,0x0080a5dc,0x0088aee3,0x0083a5dd),  ivec4(0x007595cf,0x00637fb5,0x004d6491,0x00394b70),  ivec4(0x0027354f,0x000b0d16,0x00070507,0x00040000),  ivec4(0x003c4a66,0x005972a0,0x006784bc,0x00627db6),\n  ivec4(0x00566d9e,0x003f5275,0x00324261,0x00415784),  ivec4(0x005b75a8,0x00717da3,0x00cdd0d6,0x00fefefe),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00f8f8f8,0x00f0f0f1,0x00e9e9e7,0x00a8a9a8),  ivec4(0x00e2e3e1,0x00f6f8fc,0x009fa9c7,0x0000195f),  ivec4(0x00516385,0x0088ace6,0x009bc5f7,0x00a1cef6),\n  ivec4(0x00a0cbf6,0x0096bef1,0x0086aae3,0x006d8cbf),  ivec4(0x004d638d,0x002e3c5d,0x00000017,0x00000000),  ivec4(0x00060000,0x0015141b,0x001d242f,0x005a72a3),  ivec4(0x006682bc,0x005d76aa,0x00445b84,0x00384a6e),\n  ivec4(0x003b5179,0x006a8cc6,0x007aa1e2,0x007487b1),  ivec4(0x00e8e9eb,0x00fefefe,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00fefeff,0x00f8f8f8,0x00eeeeee),  ivec4(0x00e5e5e5,0x00fdfdfc,0x00f8f9fc,0x00b2bad0),  ivec4(0x0000126e,0x005e78ad,0x0090baf5,0x00a9d7fa),  ivec4(0x00bae4f7,0x00bae3f7,0x00add8f8,0x009dc7f6),\n  ivec4(0x0087aae0,0x005b74a4,0x003b5583,0x00779bc5),  ivec4(0x007ea4cb,0x00516b88,0x0011151e,0x00000000),  ivec4(0x00536c9b,0x006685c0,0x005d78ac,0x0042557b),  ivec4(0x00252d45,0x00283b60,0x007191cf,0x008db3f6),\n  ivec4(0x00668dd4,0x00bec5d3,0x00fbfbfc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00fefefe),\n  ivec4(0x00fcfcfc,0x00fdfdfd,0x00ffffff,0x00ffffff),  ivec4(0x00e3e7ec,0x0075829c,0x005678b6,0x008db6f3),  ivec4(0x00aad8f6,0x00c5effc,0x00c7ebf6,0x00b7e3f8),  ivec4(0x00a5d1fa,0x008cb0e8,0x004968a5,0x0097a8bb),\n  ivec4(0x00c0bdc1,0x00a49199,0x008b94bb,0x00667aa0),  ivec4(0x001a1c13,0x00647bb0,0x006c8bc7,0x005b76a9),  ivec4(0x0031426d,0x000b102e,0x0021335e,0x006381bc),  ivec4(0x007ea4ec,0x007194e0,0x008592b4,0x00fafafb),\n  ivec4(0x00fefefe,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00f1f2f2,0x009ba0af,0x005a7ebf),  ivec4(0x00acc0ea,0x00c3cbc7,0x00a3c3ce,0x00acd5ef),  ivec4(0x00a8d0f7,0x0094bdf0,0x00759cd3,0x0087a2c9),  ivec4(0x00cccdcc,0x00bea180,0x00764600,0x00846b6b),\n  ivec4(0x0092a7d3,0x006f8cbb,0x00718fc9,0x006783c0),  ivec4(0x0044547b,0x001b2446,0x00161d3d,0x00273661),  ivec4(0x00486196,0x006688cc,0x00718bd7,0x00687da9),  ivec4(0x00f9f9fb,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00e4e2e1,0x00414f70),\n  ivec4(0x006f92d1,0x00bac8e9,0x00cdbea1,0x006a582e),  ivec4(0x007593b3,0x00a8d0f6,0x00b0def4,0x009ccceb),  ivec4(0x00b9d7f5,0x00d9d0bf,0x00977532,0x00140000),  ivec4(0x00695030,0x00879bca,0x00799cdd,0x006d8bc9),\n  ivec4(0x00546ea3,0x00233051,0x00000009,0x002c3959),  ivec4(0x00263869,0x00425785,0x005f80bb,0x005c79c3),  ivec4(0x006c7ca4,0x00f9f9fa,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00f3f3f3,0x008a8888),  ivec4(0x00001b4d,0x006687c4,0x00b5c6ed,0x00ded3c3),\n  ivec4(0x00b18c3e,0x00a9b0b2,0x00b4e2f8,0x00bfedf8),  ivec4(0x00aadcf7,0x00c6e3ff,0x00daceb9,0x00987c3d),  ivec4(0x00474946,0x007a6958,0x008798ca,0x007394d6),  ivec4(0x006582ba,0x00506999,0x001f2e56,0x00000014),\n  ivec4(0x00394151,0x00748fc6,0x003e5584,0x00354e80),  ivec4(0x0035539d,0x00aab4c8,0x00fbfcfc,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ececed,0x007c7a8b),  ivec4(0x0010084b,0x002c3965,0x005473ab,0x00879ece),  ivec4(0x00c1cbd5,0x00c1cad3,0x00a9c8e6,0x00b3e4f9),\n  ivec4(0x00b8e6f8,0x00a4d4fa,0x00c1dbfc,0x00e0dbd5),  ivec4(0x00b89c68,0x008d6300,0x00a38f82,0x0090a3da),  ivec4(0x006e91d4,0x00617db3,0x00516998,0x0028365d),  ivec4(0x00060d29,0x00000000,0x00637c9e,0x007d9cd4),\n  ivec4(0x005b80c3,0x00889cc1,0x00e7eaee,0x00fdfdfd),  ivec4(0x00fefefe,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00f4f4f4,0x0095949d),  ivec4(0x0000003d,0x00050057,0x0019164a,0x003c4d70),  ivec4(0x006482b8,0x00748fc2,0x007c92b2,0x0091b5d3),  ivec4(0x00afdbfe,0x00acdafc,0x008fbbe0,0x0086a2c7),\n  ivec4(0x00d7e0ea,0x00efe9dc,0x00e1d4bf,0x00b6bfdd),  ivec4(0x0082a3e7,0x006987c5,0x00546c9d,0x00405981),  ivec4(0x00202f4f,0x00080b23,0x00000019,0x00222946),  ivec4(0x00001f5d,0x00bfc4d2,0x00f2f4f7,0x00fefefe),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00eeeeef),\n  ivec4(0x005d5d6c,0x0000003c,0x000f0557,0x000b0043),  ivec4(0x00101127,0x00233146,0x0017253c,0x0045587b),  ivec4(0x007da1d8,0x008cb7f1,0x0096c2f9,0x007999c3),  ivec4(0x00455673,0x007589ae,0x009eadc8,0x0099a9c8),\n  ivec4(0x007592ca,0x005d7cb8,0x004f689a,0x00445c89),  ivec4(0x003e527a,0x001e2846,0x0009022a,0x000e0539),  ivec4(0x000d0046,0x00000032,0x0096969e,0x00f9f9f9),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00f7f7f9,0x00adabb9,0x00000000,0x000f0452),\n  ivec4(0x000f024d,0x000a0037,0x00000000,0x00384258),  ivec4(0x006b87c0,0x00759ee6,0x00749ee1,0x0076a0e4),  ivec4(0x006d8eca,0x003f4d6e,0x00192235,0x00495c80),  ivec4(0x00526a97,0x0049608c,0x004a6390,0x00496393),\n  ivec4(0x003f5079,0x00242c4d,0x000d0934,0x000e0448),  ivec4(0x000f0554,0x000f0558,0x0000001f,0x0098999e),  ivec4(0x00f8f9f9,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00fffffe,0x00e6e6ec,0x003d3f7c),  ivec4(0x0000002e,0x000b0041,0x000c024e,0x000b004a),\n  ivec4(0x00121344,0x002d3761,0x004a5b8d,0x00607ab4),  ivec4(0x00698ac8,0x006a8ecd,0x00526a9a,0x001b191f),  ivec4(0x00030b17,0x000f192a,0x00191d2b,0x00374161),  ivec4(0x00293154,0x000e1237,0x000a063e,0x000e0452),\n  ivec4(0x000f0861,0x000e065e,0x000d0355,0x00000000),  ivec4(0x00c5c6c7,0x00fcfcfc,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00eaebf1),  ivec4(0x004749a0,0x0004008e,0x001a1264,0x00030000),  ivec4(0x000a0032,0x000d0045,0x000a0046,0x00111049),\n  ivec4(0x0019214e,0x00202954,0x002c3761,0x002c3458),  ivec4(0x00171433,0x00020008,0x00020000,0x00030005),  ivec4(0x000d0a2a,0x000d0649,0x000b065e,0x00110e6c),  ivec4(0x00100d6c,0x000e0a69,0x000f0661,0x00000051),\n  ivec4(0x001b1c42,0x00e6e5e6,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ebebf2,0x005053ab,0x000c00ad,0x002623bb),  ivec4(0x002a25b2,0x001c1680,0x0000004f,0x000b0441),  ivec4(0x0011063c,0x000e0139,0x000b0039,0x000e0236),\n  ivec4(0x00100637,0x000c0535,0x000b053b,0x000e074d),  ivec4(0x00150f68,0x00181176,0x0016127b,0x0016137d),  ivec4(0x0015117b,0x00141075,0x00110d6d,0x00000060),  ivec4(0x00000023,0x00cecdd2,0x00fbfcfc,0x00fefefe),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00efeff5,0x007b7cbc,0x000000b1),  ivec4(0x002621c0,0x002418ce,0x003e3cd0,0x005351c4),  ivec4(0x000000b9,0x000000b0,0x000000b3,0x001e17aa),  ivec4(0x002925a6,0x002823a8,0x00221da2,0x001f1b9b),\n  ivec4(0x001e1a95,0x001d1993,0x001b188f,0x0019168a),  ivec4(0x00181585,0x0016137e,0x00131177,0x0007056a),  ivec4(0x00000058,0x00c7c8d0,0x00fafafb,0x00fffefe),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00f5f5f9,0x00a2a4ce),\n  ivec4(0x000000ac,0x002319c8,0x002c2dd7,0x008486d1),  ivec4(0x00cccde6,0x00dad8e3,0x00bdbbdc,0x008386cd),  ivec4(0x004d4fc2,0x001f14bd,0x001008b4,0x002521b2),  ivec4(0x00231db0,0x00231caf,0x00221eaa,0x00201ba0),\n  ivec4(0x001c1894,0x0019178b,0x00191588,0x0017167b),  ivec4(0x00000050,0x00bab8c3,0x00f8f8f8,0x00ffffff),  ivec4(0x00fffffe,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00fcfdfd),  ivec4(0x00cdcee3,0x000000ac,0x000000c7,0x00676ada),\n  ivec4(0x009395d7,0x008b89e3,0x00eeeff8,0x00fdfef7),  ivec4(0x00f7f7f6,0x00dfe0f1,0x00bab8db,0x007872cf),  ivec4(0x000000d4,0x002721cd,0x002620c0,0x00251fb6),  ivec4(0x00231daa,0x00201b9d,0x001c1994,0x001a1b88),\n  ivec4(0x0000005f,0x008e8fa8,0x00f1f1f4,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00eaebf2,0x006467bb,0x000000c5),  ivec4(0x007f80d9,0x00bcbce3,0x009394e8,0x00dadcf3),\n  ivec4(0x00efeef5,0x00f0f2f5,0x00a6a7ec,0x007b78e9),  ivec4(0x00928fde,0x004a45db,0x001c13d2,0x002620c3),  ivec4(0x002520b9,0x00221eae,0x001f1ca1,0x001f1b93),  ivec4(0x00000077,0x00626489,0x00e7e7eb,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00feffff,0x00d2d3ec),  ivec4(0x000000be,0x006d6eda,0x00bbbbe3,0x00a0a0ea),  ivec4(0x007072e7,0x008b86ea,0x00beb9f0,0x008381ea),\n  ivec4(0x00bebfee,0x00bfc2e6,0x003b3adb,0x001c12d3),  ivec4(0x00251fc3,0x00241fba,0x00231fae,0x00211d9f),  ivec4(0x00000085,0x0000006c,0x00d1d0da,0x00fdfdfe),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00fffffe),  ivec4(0x00f4f4f6,0x00a3a4de,0x000000d3,0x009c9de1),  ivec4(0x00b2b2ec,0x007777e7,0x00a3a5eb,0x004137e6),  ivec4(0x00acabee,0x00eceef1,0x00a5a6e5,0x000000d9),\n  ivec4(0x00251fd2,0x002520c7,0x002420bf,0x002420b5),  ivec4(0x00000098,0x00000070,0x00c9cbd4,0x00fbfcfc),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00feffff,0x00ffffff,0x00e4e5f1,0x006668d5),  ivec4(0x002426de,0x00a4a8e1,0x00edeff0,0x00e9e9f2),  ivec4(0x00b9baee,0x00d3d4ef,0x00babae3,0x001d18d9),  ivec4(0x001c11e0,0x002520d0,0x002521c8,0x002520c0),\n  ivec4(0x000000ab,0x002b2c8b,0x00cfcfd9,0x00fcfcfd),  ivec4(0x00fffefe,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00fffffe),\n  ivec4(0x00e2e5f4,0x007478de,0x000000dd,0x006565e3),  ivec4(0x009595e6,0x009699e4,0x006d6fe0,0x001e15e2),  ivec4(0x001f18e6,0x002620db,0x002822cc,0x000802bb),  ivec4(0x0000009e,0x008b8eb6,0x00e1e2e9,0x00fdfdfd),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fefffe,0x00fefffd,0x00eff2f9,0x00a4a9e3),\n  ivec4(0x000000d6,0x000c09ea,0x002323ea,0x002320e7),  ivec4(0x002118e0,0x001c13d8,0x001102c7,0x000000a7),  ivec4(0x00666aaa,0x00d5d7e4,0x00fbfbfd,0x00fcfeff),  ivec4(0x00feffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fdfefe,0x00e7eaf7,0x00b8bae8,0x009698df),\n  ivec4(0x008588d7,0x008d8dd3,0x00a0a1d3,0x00babad9),  ivec4(0x00dfe0ed,0x00fafbfc,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00fffefe,0x00fefefb,0x00fdfffb,0x00fefffd),  ivec4(0x00fdfcfc,0x00fafbfc,0x00fcfcfc,0x00fefefe),\n  ivec4(0x00fffffe,0x00fffffd,0x00fefefe,0x00fefefe),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff),\n  ivec4(0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff));\n\nivec4 pixel_data(in int i) {\n   return pixel_data_array[i];\n}\n\n#else\nivec4 pixel_data(in int i) {\n#  ifdef R\n#    undef R\n#  endif\n#  define R(i,a,b,c,d) case i: r=ivec4(a,b,c,d); break;\n  ivec4 r;\n  switch(i) {\n    R(0x0000,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0001,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0002,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0003,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0004,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0005,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0006,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0007,0x00fcfcfc,0x00f4f4f4,0x00f3f4f3,0x00e4e5e5)\n    R(0x0008,0x00e5e7e8,0x00e8ecee,0x00e3e7ed,0x00e1e5ec)    R(0x0009,0x00e5e8ed,0x00e9edf1,0x00edf0f2,0x00f4f5f7)    R(0x000a,0x00f7f8f8,0x00eaebeb,0x00fcfdfd,0x00ffffff)    R(0x000b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x000c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x000d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x000e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x000f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0010,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0011,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0012,0x00ffffff,0x00ffffff,0x00f3f5f6,0x00bcc0c5)    R(0x0013,0x00818fa4,0x005376a3,0x00396aa5,0x00386dab)    R(0x0014,0x003c73ae,0x003b73aa,0x00386da3,0x00476e9c)    R(0x0015,0x00667b9c,0x008c95a2,0x00cdd1d6,0x00fdfdfd)    R(0x0016,0x00fefefe,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0017,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0018,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0019,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x001a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x001b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x001c,0x00ffffff,0x00ffffff,0x00ffffff,0x00feffff)    R(0x001d,0x00feffff,0x00ffffff,0x00d7d6d7,0x005f616f)    R(0x001e,0x00003d71,0x00366097,0x00396198,0x00315789)    R(0x001f,0x002f5182,0x002f4f7e,0x002e4e7f,0x002f4d7f)\n    R(0x0020,0x002f4f81,0x002b517d,0x00224b79,0x00000035)    R(0x0021,0x00888b92,0x00fefefe,0x00ffffff,0x00ffffff)    R(0x0022,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0023,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0024,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0025,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0026,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0027,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0028,0x00fcfcfc,0x00e0e1e4,0x00b5bbc1,0x005b6270)    R(0x0029,0x00002147,0x001e304b,0x000b0d2f,0x0000001f)    R(0x002a,0x00030023,0x00050022,0x0004001b,0x00010016)    R(0x002b,0x0003001a,0x0003001a,0x000a0c29,0x00172341)    R(0x002c,0x00132a48,0x00002542,0x00fcfcfd,0x00feffff)    R(0x002d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x002e,0x00ffffff,0x00ffffff,0x00fefeff,0x00fefefe)    R(0x002f,0x00fdfdfe,0x00fdfdfd,0x00fdfdfd,0x00fdfdfd)\n    R(0x0030,0x00fdfdfd,0x00fefefe,0x00fefefe,0x00ffffff)    R(0x0031,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0032,0x00ffffff,0x00ffffff,0x00ffffff,0x00fffffe)    R(0x0033,0x00ffffff,0x00dad9dc,0x006c7489,0x00001c4d)    R(0x0034,0x00041127,0x000c0820,0x000c1034,0x000d1844)    R(0x0035,0x000e1d4a,0x00101f4a,0x00111e4b,0x00101c47)    R(0x0036,0x000d1940,0x000d173f,0x000d1639,0x000d1331)    R(0x0037,0x000e1328,0x000f1530,0x00000634,0x00dcdee1)\n    R(0x0038,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0039,0x00ffffff,0x00ffffff,0x00f8fafb,0x00dee5eb)    R(0x003a,0x00c3ccd9,0x00a1adc1,0x008a98b2,0x008694ab)    R(0x003b,0x008e98aa,0x00a3abb8,0x00bfc5ce,0x00dadde1)    R(0x003c,0x00eef0f1,0x00fcfdfd,0x00fefefe,0x00fdfdfe)    R(0x003d,0x00fdfefe,0x00fefefe,0x00ffffff,0x00ffffff)    R(0x003e,0x00feffff,0x00ffffff,0x00cccecd,0x00545558)    R(0x003f,0x00000000,0x00090a29,0x000e1640,0x00111e4f)\n    R(0x0040,0x0016285b,0x00192e62,0x001a3166,0x001b3066)    R(0x0041,0x00182d63,0x00182c5e,0x00152755,0x0014224f)    R(0x0042,0x00121c42,0x000d1631,0x000c1227,0x00000928)    R(0x0043,0x008e8f97,0x00fbfcfb,0x00ffffff,0x00ffffff)    R(0x0044,0x00ffffff,0x00ffffff,0x00fcfcfb,0x00aebbcb)    R(0x0045,0x00376cad,0x00215ca0,0x0027528b,0x001d4377)    R(0x0046,0x00053365,0x00002c5f,0x00003566,0x00003a6b)    R(0x0047,0x00184473,0x00596d89,0x00a5b0bb,0x00d0d7de)\n    R(0x0048,0x00bdc2ca,0x00c2c9d0,0x00cdd3d7,0x00e5e9ec)    R(0x0049,0x00f8f9fa,0x00fefefe,0x00fffffe,0x00a3a3a2)    R(0x004a,0x00000000,0x000b1133,0x00101f4a,0x0015285e)    R(0x004b,0x0017306f,0x001e3a7b,0x00254587,0x002b4c8e)    R(0x004c,0x002b498c,0x00264483,0x00223e79,0x001b366c)    R(0x004d,0x00192f62,0x00162954,0x00132147,0x000f1a36)    R(0x004e,0x00040c28,0x00666872,0x00f5f6f7,0x00ffffff)    R(0x004f,0x00ffffff,0x00ffffff,0x00fffeff,0x00f8f8f9)\n    R(0x0050,0x00626c89,0x00000848,0x0005053c,0x000d194c)    R(0x0051,0x000f1c4f,0x00121e50,0x00111d4a,0x0009133c)    R(0x0052,0x00080a31,0x0006042b,0x00000d33,0x0000003d)    R(0x0053,0x00000047,0x00003369,0x00003b72,0x00003268)    R(0x0054,0x00000049,0x00012750,0x00b9bec2,0x00f0f2f3)    R(0x0055,0x00999a9b,0x00000000,0x00122051,0x00172d65)    R(0x0056,0x001c387a,0x0021438c,0x00284c99,0x003259a5)    R(0x0057,0x003b64ad,0x003961aa,0x0032579f,0x002b4f92)\n    R(0x0058,0x00244682,0x001e3c74,0x001a3265,0x00152955)    R(0x0059,0x00142346,0x000f1a35,0x003e4354,0x00f0f1f1)    R(0x005a,0x00ffffff,0x00ffffff,0x00feffff,0x00fefefd)    R(0x005b,0x00d6d7db,0x00000025,0x00182f63,0x00213d76)    R(0x005c,0x00284481,0x00294785,0x00284581,0x00233f79)    R(0x005d,0x001c3369,0x00162a5b,0x00132451,0x00111f47)    R(0x005e,0x00101a3e,0x000d1435,0x00080829,0x00090727)    R(0x005f,0x00101633,0x001b2944,0x00000036,0x007f8792)\n    R(0x0060,0x00dbdee3,0x009e9ea4,0x0000002c,0x00172a62)    R(0x0061,0x001c3879,0x0023468f,0x002a4fa1,0x002f57ae)    R(0x0062,0x003c66b4,0x004773b3,0x004773b5,0x003f6ab8)    R(0x0063,0x00365eab,0x002d539a,0x00274887,0x00203d75)    R(0x0064,0x001b3363,0x00162a51,0x00112343,0x004c525f)    R(0x0065,0x00f1f2f3,0x00ffffff,0x00ffffff,0x00fdffff)    R(0x0066,0x00fafafb,0x005c6179,0x00002770,0x002c4e92)    R(0x0067,0x003d64aa,0x004871b6,0x00456fb6,0x003f67b0)\n    R(0x0068,0x00365ca4,0x002c4d90,0x0024427f,0x001f3b73)    R(0x0069,0x001d366a,0x001a3162,0x00192d5d,0x00182b58)    R(0x006a,0x00162754,0x0012224d,0x00122248,0x00001645)    R(0x006b,0x00787f8f,0x00e3e4e9,0x00adacb5,0x00000044)    R(0x006c,0x00193370,0x0020428a,0x00294fa0,0x002f5bb2)    R(0x006d,0x003265c2,0x004075c1,0x005187bf,0x005288c7)    R(0x006e,0x00477dd1,0x003e6ec6,0x00345daf,0x002d5199)    R(0x006f,0x00244482,0x001d3a6e,0x00172e5a,0x000b244c)\n    R(0x0070,0x00777a83,0x00f9f9f9,0x00ffffff,0x00ffffff)    R(0x0071,0x00ffffff,0x00f8f9fa,0x002b4073,0x00254c96)    R(0x0072,0x003b65b3,0x005481cc,0x005c91d1,0x00578dd0)    R(0x0073,0x005180ce,0x004472c2,0x003762ac,0x0032569b)    R(0x0074,0x002e5090,0x002b4b8a,0x00284984,0x0027467e)    R(0x0075,0x00254076,0x001f3c6f,0x00183364,0x00122756)    R(0x0076,0x000d214c,0x00000032,0x00c8c8cc,0x00c3c1c6)    R(0x0077,0x00343963,0x000a3076,0x00244895,0x002e55ad)\n    R(0x0078,0x003462c3,0x00366fd3,0x004681d4,0x00558fd4)    R(0x0079,0x005590d7,0x004b87dd,0x004276d4,0x003966bb)    R(0x007a,0x003057a5,0x00284c8e,0x001f3f76,0x00193160)    R(0x007b,0x0000174c,0x00999ca2,0x00fcfdfd,0x00ffffff)    R(0x007c,0x00ffffff,0x00fffeff,0x00f6f9fa,0x0038518d)    R(0x007d,0x002856a6,0x003c6ec5,0x00568edd,0x005e9ade)    R(0x007e,0x005b97e1,0x00528de3,0x00477dd5,0x003c6dbd)    R(0x007f,0x003863ad,0x00365ca2,0x003b5999,0x003b538f)\n    R(0x0080,0x00364c82,0x002f426d,0x0026315b,0x001f2a54)    R(0x0081,0x001b2851,0x000a1b4b,0x00000033,0x00c6c5c6)    R(0x0082,0x00b6aba8,0x00200000,0x001d2f65,0x00244691)    R(0x0083,0x002e57b0,0x003465cb,0x003774de,0x003e7fe2)    R(0x0084,0x004886df,0x004889e0,0x004583e3,0x004076d8)    R(0x0085,0x003769bf,0x002f5aa8,0x002a5093,0x00214279)    R(0x0086,0x00143160,0x00000038,0x00d5d7d9,0x00ffffff)    R(0x0087,0x00ffffff,0x00ffffff,0x00fffffe,0x00fbfbfc)\n    R(0x0088,0x007e8ab0,0x00004aa5,0x00386dc7,0x004987e6)    R(0x0089,0x005294e8,0x005090ea,0x004c87e6,0x003d76d1)    R(0x008a,0x003666bb,0x00405ca2,0x00515489,0x00664960)    R(0x008b,0x00764332,0x00793c00,0x00733400,0x00673000)    R(0x008c,0x00532602,0x00421d05,0x00200000,0x00616363)    R(0x008d,0x00cfcdcd,0x00b09e9d,0x005b0000,0x00532c30)    R(0x008e,0x00303b74,0x002650a4,0x003565cb,0x003870de)    R(0x008f,0x003978e2,0x003b7ae2,0x003f7de4,0x003f7ae3)\n    R(0x0090,0x003972d6,0x003668bf,0x002f5aaa,0x00295094)    R(0x0091,0x001d3d76,0x00001954,0x0082858f,0x00ffffff)    R(0x0092,0x00fefeff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0093,0x00fefefd,0x00dde3ee,0x00023f98,0x002e62ba)    R(0x0094,0x003979da,0x004186eb,0x004182e8,0x003a76d4)    R(0x0095,0x003b67bc,0x005a5b90,0x00884e47,0x009c5102)    R(0x0096,0x00a25000,0x00a15114,0x00964d1b,0x008d471d)    R(0x0097,0x0087451f,0x00793d1f,0x0067341f,0x005d270a)\n    R(0x0098,0x004d2712,0x00ced2ce,0x00cfc3bc,0x007f4120)    R(0x0099,0x00773908,0x00643425,0x00393d75,0x002b56b1)    R(0x009a,0x003367d0,0x003673dd,0x003774de,0x003973de)    R(0x009b,0x003873d9,0x00356fcf,0x003464ba,0x002f5aa5)    R(0x009c,0x0024488a,0x000f336a,0x004a526a,0x00eff1f3)    R(0x009d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x009e,0x00ffffff,0x00fdfeff,0x00fcfdfc,0x00b0bcd2)    R(0x009f,0x004c68af,0x003c66b9,0x00396ac4,0x003662be)\n    R(0x00a0,0x005060ac,0x007f586a,0x00a45500,0x00aa5a12)    R(0x00a1,0x00a0531c,0x009a4c18,0x00914617,0x008e4419)    R(0x00a2,0x008e4619,0x008d451d,0x007a3c20,0x005a2d1f)    R(0x00a3,0x0055291a,0x00240000,0x00c6c4c5,0x00d0c2be)    R(0x00a4,0x00935026,0x009b4907,0x00994b16,0x00844100)    R(0x00a5,0x005b4264,0x003f529e,0x00365eb7,0x003161bd)    R(0x00a6,0x002e63c0,0x003066c3,0x003063bb,0x002d59a2)    R(0x00a7,0x00244986,0x00203768,0x00000037,0x009e9695)\n    R(0x00a8,0x00fafbfc,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00a9,0x00ffffff,0x00ffffff,0x00ffffff,0x00fffeff)    R(0x00aa,0x00fcfefe,0x00d2d9e3,0x009ea8c4,0x00929dbc)    R(0x00ab,0x007d6c85,0x00974b11,0x00ac5900,0x00a8551d)    R(0x00ac,0x00a25119,0x00a25117,0x00a45115,0x00a24e10)    R(0x00ad,0x009d4b0e,0x009a4a10,0x00964817,0x00813f1e)    R(0x00ae,0x00663421,0x005d2504,0x005b4032,0x00d7d6d6)    R(0x00af,0x00cdbdb8,0x00943d00,0x00a14d11,0x00a25217)\n    R(0x00b0,0x00a65617,0x009f4e00,0x00874629,0x006b445d)    R(0x00b1,0x00514473,0x003d4382,0x00394885,0x00354176)    R(0x00b2,0x002e3359,0x0034283e,0x00381c1d,0x00553c32)    R(0x00b3,0x00dbd9d6,0x00fefdfe,0x00ffffff,0x00ffffff)    R(0x00b4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00b5,0x00feffff,0x00feffff,0x00ffffff,0x00ffffff)    R(0x00b6,0x00ffffff,0x00ebe0d9,0x00a76848,0x00a14c04)    R(0x00b7,0x00a9571f,0x00a9581f,0x00a6551a,0x00a45117)\n    R(0x00b8,0x00a24e13,0x009a4913,0x00934718,0x008c441e)    R(0x00b9,0x00793c20,0x00693621,0x005b1600,0x007c6b63)    R(0x00ba,0x00e0dfdf,0x00c3b1ae,0x008f2600,0x00a65416)    R(0x00bb,0x00a85719,0x00a35218,0x00a3531a,0x00a65616)    R(0x00bc,0x00a65200,0x009d4d00,0x00934900,0x008c4200)    R(0x00bd,0x00824000,0x006e3711,0x005a2b13,0x00000000)    R(0x00be,0x00cec8c5,0x00ffffff,0x00feffff,0x00ffffff)    R(0x00bf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x00c0,0x00ffffff,0x00ffffff,0x00ffffff,0x00fefffe)    R(0x00c1,0x00ffffff,0x00ffffff,0x00fbfcfb,0x00d4c5be)    R(0x00c2,0x009a3700,0x00a8581e,0x00a7561c,0x00a35216)    R(0x00c3,0x00a15013,0x009f4d10,0x009a4b11,0x00944817)    R(0x00c4,0x008b431e,0x00773b21,0x006a3621,0x00590e00)    R(0x00c5,0x0081726e,0x00dedcdb,0x00bda8a5,0x008d1800)    R(0x00c6,0x00a45216,0x00a7561f,0x00ab5922,0x00a6571e)    R(0x00c7,0x00a65114,0x009e4d13,0x00974a18,0x008f461b)\n    R(0x00c8,0x0083421a,0x006c371b,0x004e2517,0x002b0000)    R(0x00c9,0x0058453f,0x00f6f7f7,0x00ffffff,0x00fefffe)    R(0x00ca,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00cb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00cc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00cd,0x00f0eae9,0x008f3d00,0x00a54e09,0x00a55319)    R(0x00ce,0x00a55417,0x00a45316,0x00a15011,0x009f4d0d)    R(0x00cf,0x00994a13,0x008b441e,0x00763b22,0x006b3722)\n    R(0x00d0,0x00580500,0x008e807d,0x00d1cbca,0x00ac908e)    R(0x00d1,0x00912d00,0x00a65419,0x00a7571e,0x00a9581f)    R(0x00d2,0x00a5561d,0x00a55117,0x009c4a14,0x008a441c)    R(0x00d3,0x00743b22,0x005d301e,0x004e261a,0x00421d10)    R(0x00d4,0x000c0000,0x00b8b2b1,0x00fcfcfc,0x00fefefe)    R(0x00d5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00d6,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00d7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x00d8,0x00feffff,0x00f4f2f0,0x00a98270,0x009d3b00)    R(0x00d9,0x00a7561b,0x00a7561b,0x00a55417,0x00a35113)    R(0x00da,0x00a24d0d,0x009b4a10,0x008a451d,0x00753b21)    R(0x00db,0x006a3721,0x00570000,0x00978985,0x00c9c2c1)    R(0x00dc,0x00a2827d,0x00943500,0x00a65518,0x00a8581c)    R(0x00dd,0x00a8591e,0x00a6561a,0x00a44f12,0x00964717)    R(0x00de,0x0083421f,0x006e3921,0x00592d1c,0x004d2518)    R(0x00df,0x003d1809,0x00330100,0x00dcdbdb,0x00fdfdfd)\n    R(0x00e0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00e1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00e2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00e3,0x00ffffff,0x00ffffff,0x00f9f7f6,0x00c6afa5)    R(0x00e4,0x00952000,0x00a95a1c,0x00a8581d,0x00a55518)    R(0x00e5,0x00a35214,0x00a14e0f,0x009a4b10,0x0089451d)    R(0x00e6,0x00743c21,0x006a3621,0x00570000,0x009a8f8c)    R(0x00e7,0x00bcb3b1,0x00986e63,0x00983e00,0x00a75318)\n    R(0x00e8,0x00a65519,0x00a65619,0x00a45417,0x00a14e11)    R(0x00e9,0x00944718,0x007f4121,0x00663521,0x0054281b)    R(0x00ea,0x004a2416,0x002f0000,0x006f6663,0x00f5f4f4)    R(0x00eb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00ec,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00ed,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00ee,0x00ffffff,0x00ffffff,0x00ffffff,0x00fdfdfc)    R(0x00ef,0x00dfd3cd,0x00910000,0x00a9591c,0x00a7581d)\n    R(0x00f0,0x00a55517,0x00a35214,0x00a24f0f,0x009b4a10)    R(0x00f1,0x008a451d,0x00743c21,0x006a3721,0x00570000)    R(0x00f2,0x00a29692,0x00aea09c,0x00904f32,0x009e4a00)    R(0x00f3,0x00a55317,0x00a65518,0x00a65517,0x00a55213)    R(0x00f4,0x009d4b12,0x008f451c,0x00783d21,0x005f301f)    R(0x00f5,0x00512619,0x00452012,0x00000000,0x00b3afad)    R(0x00f6,0x00fbfbfb,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00f7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x00f8,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x00f9,0x00ffffff,0x00ffffff,0x00ffffff,0x00feffff)    R(0x00fa,0x00ffffff,0x00eee7e5,0x009c4900,0x00a85412)    R(0x00fb,0x00a6581d,0x00a65618,0x00a35315,0x00a14f11)    R(0x00fc,0x009d4b11,0x008e451c,0x00763c21,0x006c3722)    R(0x00fd,0x005b0000,0x00a59591,0x00a7928d,0x008a3c00)    R(0x00fe,0x00a04e09,0x00a35315,0x00a45417,0x00a55316)    R(0x00ff,0x00a35011,0x009b4913,0x008a441f,0x00723b21)\n    R(0x0100,0x005b2d1d,0x004c2415,0x003f160a,0x00000000)    R(0x0101,0x00e5e4e1,0x00fffefe,0x00ffffff,0x00ffffff)    R(0x0102,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0103,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0104,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0105,0x00ffffff,0x00ffffff,0x00f2eeed,0x00ab765f)    R(0x0106,0x00a34d00,0x00a8571f,0x00a7561b,0x00a55316)    R(0x0107,0x00a35012,0x009f4b11,0x008f451b,0x00783d21)\n    R(0x0108,0x006d3821,0x00642000,0x0097817b,0x009b7c73)    R(0x0109,0x00903c00,0x00a35013,0x00a45315,0x00a45315)    R(0x010a,0x00a45216,0x00a14f10,0x00994913,0x00844220)    R(0x010b,0x006d3822,0x00582b1c,0x00482315,0x002a0000)    R(0x010c,0x00736361,0x00f8f8f8,0x00ffffff,0x00ffffff)    R(0x010d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x010e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x010f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0110,0x00ffffff,0x00ffffff,0x00ffffff,0x00f5f2f1)    R(0x0111,0x00bb9488,0x00a04400,0x00a8571f,0x00a8571b)    R(0x0112,0x00a65417,0x00a45214,0x009f4d11,0x0091461a)    R(0x0113,0x007a3e21,0x006e3821,0x006b2f0c,0x0082655a)    R(0x0114,0x008f6251,0x00994400,0x00a55315,0x00a55416)    R(0x0115,0x00a45416,0x00a45217,0x00a14f0f,0x00944817)    R(0x0116,0x007e4021,0x00673520,0x00552a1a,0x00452013)    R(0x0117,0x00000000,0x00beb7b7,0x00fafbfb,0x00ffffff)\n    R(0x0118,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0119,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x011a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x011b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x011c,0x00f7f5f4,0x00c2a8a0,0x009e3c00,0x00a8571d)    R(0x011d,0x00a8571b,0x00a65517,0x00a45214,0x00a04e10)    R(0x011e,0x00924819,0x007c3e21,0x006f3920,0x00713921)    R(0x011f,0x005f3425,0x00813f1e,0x00a24f13,0x00a45315)\n    R(0x0120,0x00a55417,0x00a45416,0x00a45216,0x00a04e10)    R(0x0121,0x008e451c,0x00763d21,0x0061321e,0x00502619)    R(0x0122,0x00411c0f,0x000e0000,0x00dad8d8,0x00fefdfd)    R(0x0123,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0124,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0125,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0126,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0127,0x00ffffff,0x00faf9f8,0x00cebeb8,0x009a3a00)\n    R(0x0128,0x00a7561b,0x00a8571c,0x00a55417,0x00a45114)    R(0x0129,0x00a04e10,0x00934817,0x007d3f20,0x006f3921)    R(0x012a,0x006e3821,0x005f311f,0x00843f18,0x00a34f14)    R(0x012b,0x00a45315,0x00a55317,0x00a45315,0x00a35013)    R(0x012c,0x009b4b12,0x0088441f,0x00703a21,0x005b2e1d)    R(0x012d,0x004d2418,0x003b0c00,0x0055433e,0x00e6e8e8)    R(0x012e,0x00feffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x012f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0130,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0131,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0132,0x00ffffff,0x00ffffff,0x00fdfcfc,0x00dccfca)    R(0x0133,0x00973b00,0x00a85617,0x00a8571c,0x00a55518)    R(0x0134,0x00a35215,0x00a14e12,0x00944817,0x007f401f)    R(0x0135,0x006b3720,0x00693620,0x00673420,0x00874219)    R(0x0136,0x00a24f11,0x00a45113,0x00a35215,0x00a45114)    R(0x0137,0x00a24e10,0x00964816,0x0082431f,0x006c3822)\n    R(0x0138,0x00582c1c,0x004c2316,0x00320000,0x007f7674)    R(0x0139,0x00f4f4f4,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x013a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x013b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x013c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x013d,0x00ffffff,0x00ffffff,0x00ffffff,0x00fffffe)    R(0x013e,0x00e6dcd7,0x00964000,0x00a85514,0x00a8571d)    R(0x013f,0x00a55518,0x00a35215,0x00a04d12,0x00944918)\n    R(0x0140,0x007f4120,0x006a3720,0x00653420,0x00663420)    R(0x0141,0x00894318,0x00a14e0e,0x00a34f10,0x00a35012)    R(0x0142,0x00a24f0f,0x009f4c0e,0x00934619,0x007e4020)    R(0x0143,0x00683720,0x00542a1a,0x00492316,0x00180000)    R(0x0144,0x00a7a2a1,0x00f9f8f8,0x00ffffff,0x00ffffff)    R(0x0145,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0146,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0147,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0148,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0149,0x00ffffff,0x00e9e1dd,0x00994700,0x00a7530f)    R(0x014a,0x00a8571e,0x00a55519,0x00a35215,0x00a04e12)    R(0x014b,0x00964816,0x0081411f,0x006c3721,0x00623220)    R(0x014c,0x00663520,0x008a441a,0x009f4c0e,0x00a14d0c)    R(0x014d,0x00a24e0f,0x00a04d0d,0x009c4a10,0x008f451a)    R(0x014e,0x007b3f20,0x0064341f,0x00512818,0x00462113)    R(0x014f,0x00000000,0x00d4d0d0,0x00fdfdfd,0x00ffffff)\n    R(0x0150,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0151,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0152,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0153,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0154,0x00ffffff,0x00ffffff,0x00ede6e3,0x009d5931)    R(0x0155,0x00a54f00,0x00a8571e,0x00a6561a,0x00a55415)    R(0x0156,0x00a45114,0x00994915,0x0082401d,0x0069361f)    R(0x0157,0x005b2e1c,0x0063331e,0x0083421f,0x00984a16)\n    R(0x0158,0x009d4b0e,0x00a04b0c,0x009e4b0d,0x00984913)    R(0x0159,0x008c451b,0x00783e21,0x0061321f,0x004f2618)    R(0x015a,0x00401606,0x00000000,0x00eceaea,0x00ffffff)    R(0x015b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x015c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x015d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x015e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x015f,0x00ffffff,0x00ffffff,0x00ffffff,0x00efebe9)\n    R(0x0160,0x00a0684f,0x00a34a00,0x00a8571e,0x00a7561c)    R(0x0161,0x009d4f17,0x008f4613,0x007f3d14,0x006a331b)    R(0x0162,0x00572b1b,0x00522819,0x005d2f1d,0x00753c21)    R(0x0163,0x008b451d,0x00964916,0x009c4a11,0x009c4b11)    R(0x0164,0x00954917,0x0088451e,0x00753c22,0x005e2f1e)    R(0x0165,0x004e2517,0x002a0000,0x0072625f,0x00f4f3f3)    R(0x0166,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0167,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0168,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0169,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x016a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x016b,0x00efecea,0x00a0705b,0x00a24700,0x00a5561d)    R(0x016c,0x00914b1b,0x006b3414,0x004b2110,0x00451f14)    R(0x016d,0x004b2217,0x00522719,0x005a2c1d,0x005e2f1e)    R(0x016e,0x00663520,0x007a3e20,0x008b451c,0x00954816)    R(0x016f,0x00974914,0x0090471a,0x00834320,0x00713a21)\n    R(0x0170,0x005b2e1c,0x004d2417,0x00000000,0x00ada8a7)    R(0x0171,0x00f9f9f9,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0172,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0173,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0174,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0175,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0176,0x00ffffff,0x00efeceb,0x009c705f,0x00973f00)    R(0x0177,0x00814117,0x004c2211,0x002d1110,0x00441f14)\n    R(0x0178,0x00512519,0x00572a1b,0x005b2e1d,0x00643320)    R(0x0179,0x006a3621,0x00693620,0x00703a21,0x007d4021)    R(0x017a,0x008c451c,0x00934719,0x008c461d,0x007e4022)    R(0x017b,0x006c3721,0x00572d1b,0x00401505,0x00000000)    R(0x017c,0x00afaead,0x00d3d4d3,0x00dadad9,0x00d8d8d8)    R(0x017d,0x00eaebeb,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x017e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x017f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0180,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0181,0x00ffffff,0x00ffffff,0x00efeceb,0x00957165)    R(0x0182,0x006a1a00,0x00401b10,0x00391710,0x004a2214)    R(0x0183,0x00532719,0x00592c1d,0x005d2f1d,0x0062321f)    R(0x0184,0x006c3821,0x00733c21,0x00753d21,0x00773e22)    R(0x0185,0x00804120,0x008b441d,0x008e451d,0x0086441f)    R(0x0186,0x00793e22,0x0066351f,0x004f200a,0x00402825)    R(0x0187,0x005b5755,0x0081807d,0x006f6c69,0x006d6b68)\n    R(0x0188,0x0061615f,0x00929191,0x00dadada,0x00ffffff)    R(0x0189,0x00feffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x018a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x018b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x018c,0x00ffffff,0x00ffffff,0x00ffffff,0x00eeecec)    R(0x018d,0x00816a64,0x00340000,0x00492214,0x00512719)    R(0x018e,0x00582c1c,0x005f301d,0x00663420,0x006c3721)    R(0x018f,0x00703a21,0x00753d21,0x007c4021,0x00824221)\n    R(0x0190,0x0086431f,0x008a441e,0x008d451c,0x008a441e)    R(0x0191,0x00804121,0x00733d22,0x005e2d17,0x00432114)    R(0x0192,0x0067615d,0x00898785,0x008e8d8a,0x008c8b87)    R(0x0193,0x00868582,0x0091908e,0x0081807f,0x007d7b79)    R(0x0194,0x00dfdedd,0x00fdfdfd,0x00ffffff,0x00ffffff)    R(0x0195,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0196,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0197,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0198,0x00e8e6e6,0x005d4845,0x00410300,0x00592c1c)    R(0x0199,0x0061311f,0x00653421,0x00693721,0x00713b20)    R(0x019a,0x007b4021,0x007d4121,0x007f4121,0x00844221)    R(0x019b,0x0089451e,0x008d461b,0x008e461d,0x008a441e)    R(0x019c,0x0083421f,0x00793f21,0x006c371f,0x00562c18)    R(0x019d,0x00665d58,0x00807f7b,0x008d8c87,0x008e8e8a)    R(0x019e,0x00afafad,0x00c1c1bf,0x00c5c5c3,0x00c7c8c7)    R(0x019f,0x00bcbcbb,0x00a8a7a5,0x00fbfbfb,0x00ffffff)\n    R(0x01a0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01a1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01a2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01a3,0x00fcfcfc,0x00d1cfce,0x003e0000,0x005e2d19)    R(0x01a4,0x006b3621,0x00713922,0x00733c22,0x00793f21)    R(0x01a5,0x0080411f,0x0089441d,0x008c461c,0x008b451d)    R(0x01a6,0x008e451c,0x008d461b,0x008a461c,0x0087441f)    R(0x01a7,0x00804121,0x00783f22,0x006f3a21,0x00602200)\n    R(0x01a8,0x00736258,0x009c9a95,0x00a4a39f,0x009b9c97)    R(0x01a9,0x00bebebc,0x00d4d5d3,0x00cacbc9,0x00b5b4b2)    R(0x01aa,0x00cacccb,0x00e9eaea,0x00b0b0ae,0x00f9fbfb)    R(0x01ab,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01ac,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01ad,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01ae,0x00ffffff,0x00f6f5f5,0x00b0aaa8,0x004e0000)    R(0x01af,0x006e3922,0x00783e22,0x007e4021,0x0086441e)\n    R(0x01b0,0x008f4719,0x00924818,0x00974915,0x00994913)    R(0x01b1,0x00994913,0x00994a12,0x00934816,0x0089441e)    R(0x01b2,0x007f4221,0x00763e22,0x006e3922,0x00673521)    R(0x01b3,0x00560100,0x00867a72,0x00babbb7,0x00c0c2bf)    R(0x01b4,0x00c3c4c2,0x00e2e3e2,0x00e3e3e2,0x00cbcdca)    R(0x01b5,0x00a2a19f,0x00b1b3b2,0x00cccdcd,0x00a5a4a2)    R(0x01b6,0x00e8e8e8,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01b7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x01b8,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01b9,0x00ffffff,0x00ffffff,0x00f2f0f0,0x00978682)    R(0x01ba,0x00671d00,0x007e4022,0x00834220,0x0088431e)    R(0x01bb,0x00964915,0x009f4c0e,0x00a04d10,0x00a14e10)    R(0x01bc,0x00a04d0e,0x00a14d0a,0x00a14c0a,0x009d4b0f)    R(0x01bd,0x008f4719,0x0082431f,0x00793e22,0x00713a21)    R(0x01be,0x006d371e,0x00652c05,0x00797269,0x00aeafac)    R(0x01bf,0x00c2c3c1,0x00dddedc,0x00eeedee,0x00e7e7e7)\n    R(0x01c0,0x00d4d4d2,0x00b4b2b1,0x00797a78,0x00949896)    R(0x01c1,0x00aeafae,0x00dfdedd,0x00fffefe,0x00ffffff)    R(0x01c2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01c3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01c4,0x00ffffff,0x00ffffff,0x00ffffff,0x00f0efee)    R(0x01c5,0x0080665c,0x007c3600,0x008f471c,0x00944818)    R(0x01c6,0x00984a17,0x00a04e12,0x00a55011,0x00a45012)    R(0x01c7,0x00a45013,0x00a35013,0x00a34e10,0x00a34d0d)\n    R(0x01c8,0x00a14c0d,0x009b4a12,0x008e4619,0x007d3f1f)    R(0x01c9,0x0070381f,0x00693117,0x006d412f,0x00817d77)    R(0x01ca,0x00a2a29f,0x00cdcecc,0x00edeeec,0x00f2f1f2)    R(0x01cb,0x00e8e7e8,0x00d6d5d5,0x00bcbab9,0x006f6e6c)    R(0x01cc,0x00808584,0x00dcdddd,0x00f9f9f9,0x00ffffff)    R(0x01cd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01ce,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01cf,0x00ffffff,0x00ffffff,0x00ffffff,0x00f6f6f7)\n    R(0x01d0,0x00e1dfde,0x00825e4f,0x00813b00,0x00944818)    R(0x01d1,0x009c4c10,0x00a15011,0x00a55315,0x00a75619)    R(0x01d2,0x00a65519,0x00a45217,0x00a35116,0x00a35014)    R(0x01d3,0x00a24e11,0x00a14c0e,0x009e4b0f,0x00894319)    R(0x01d4,0x00723920,0x00673420,0x005f2914,0x0068473b)    R(0x01d5,0x00898482,0x00b1b1b0,0x00dfdfde,0x00f6f6f5)    R(0x01d6,0x00f3f2f4,0x00e7e7e7,0x00d3d4d2,0x00b8b6b5)    R(0x01d7,0x006c6968,0x00b3b4b4,0x00f7f8f7,0x00ffffff)\n    R(0x01d8,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01d9,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01da,0x00ffffff,0x00ffffff,0x00e4e4e4,0x00bcbcbd)    R(0x01db,0x00a2a2a2,0x00928e8e,0x00784a3c,0x00854012)    R(0x01dc,0x00954818,0x00994d14,0x00a05115,0x00a45418)    R(0x01dd,0x00a8571c,0x00a8571c,0x00a7561b,0x00a65519)    R(0x01de,0x00a55317,0x00a45215,0x00a45011,0x00984a15)    R(0x01df,0x00813f1f,0x00793c22,0x00773c21,0x00713315)\n    R(0x01e0,0x0074513f,0x00918a89,0x00bebebd,0x00ededed)    R(0x01e1,0x00fcfcfc,0x00f3f3f4,0x00e5e5e6,0x00d0d1cf)    R(0x01e2,0x00b2afae,0x00726f6d,0x00f6f5f5,0x00ffffff)    R(0x01e3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01e4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01e5,0x00ffffff,0x00ffffff,0x00d0d1cf,0x007a797c)    R(0x01e6,0x00000000,0x00000000,0x00000019,0x005d2825)    R(0x01e7,0x008e471b,0x009e4e13,0x009f5117,0x00a35419)\n    R(0x01e8,0x00a6551a,0x00a5541a,0x00a5541a,0x00a8561c)    R(0x01e9,0x00a9571d,0x00a7551b,0x00a45418,0x00a45315)    R(0x01ea,0x00974a18,0x008c451b,0x008a451c,0x0081421f)    R(0x01eb,0x00763715,0x00774e39,0x00979190,0x00cdcdcc)    R(0x01ec,0x00f6f6f6,0x00fdfdfd,0x00f4f4f5,0x00e2e3e4)    R(0x01ed,0x00cbcdca,0x00a9a7a5,0x006b6966,0x00e9e8e8)    R(0x01ee,0x00fffefe,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01ef,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x01f0,0x00ffffff,0x00ffffff,0x00d1d1d2,0x00525252)    R(0x01f1,0x00000000,0x000b0247,0x000c0153,0x001c094f)    R(0x01f2,0x00572c35,0x008f4617,0x00a45111,0x00a45418)    R(0x01f3,0x00a6561c,0x00a8571d,0x00a8571d,0x00a8571d)    R(0x01f4,0x00a8571d,0x00a7561c,0x00a5551b,0x00a45418)    R(0x01f5,0x00a55215,0x009e4e16,0x00994b13,0x00924816)    R(0x01f6,0x0083421f,0x00743a20,0x00672900,0x009c948d)    R(0x01f7,0x00d7d9d8,0x00fafafb,0x00faf9f9,0x00eff1f1)\n    R(0x01f8,0x00dbdede,0x00c4c6c4,0x00989794,0x00393831)    R(0x01f9,0x00aaa9a8,0x00fcfcfc,0x00feffff,0x00ffffff)    R(0x01fa,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x01fb,0x00ffffff,0x00ffffff,0x00e1e0e0,0x00505052)    R(0x01fc,0x00000000,0x0006003f,0x000c014c,0x000c004e)    R(0x01fd,0x000c034a,0x00462142,0x008a441a,0x00a45112)    R(0x01fe,0x00a65619,0x00a8571e,0x00a8591f,0x00aa5920)    R(0x01ff,0x00ab5a21,0x00aa5920,0x00a7581e,0x00a8581e)\n    R(0x0200,0x00a8571d,0x00a55318,0x00a35116,0x00a34f13)    R(0x0201,0x00974818,0x0083411e,0x00793f22,0x006f2100)    R(0x0202,0x00867366,0x00c8cac9,0x00eceded,0x00e8e8e7)    R(0x0203,0x00dddedd,0x00cbcccc,0x00adadac,0x0080807b)    R(0x0204,0x0045433d,0x006b6a6a,0x00fcfcfc,0x00ffffff)    R(0x0205,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0206,0x00ffffff,0x00fbfcfc,0x00c9c9c9,0x008f908f)    R(0x0207,0x00434646,0x00494650,0x00211f41,0x00000044)\n    R(0x0208,0x0009004b,0x0003004b,0x003f1c48,0x0087421c)    R(0x0209,0x00a15015,0x00a7561a,0x00a8571e,0x00a85920)    R(0x020a,0x00aa5a21,0x00a9581f,0x00a5551d,0x00a5561d)    R(0x020b,0x00a95920,0x00a95820,0x00a6561c,0x00a65417)    R(0x020c,0x00a24f13,0x00974915,0x0090490a,0x007f3f08)    R(0x020d,0x005c1a00,0x00786c6b,0x00babab7,0x00cbcdcb)    R(0x020e,0x00c8cac8,0x00c1c1c0,0x00b6b4b4,0x009fa09d)    R(0x020f,0x00898681,0x0054504b,0x00312e43,0x00dbdadd)\n    R(0x0210,0x00fefefe,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0211,0x00ffffff,0x00ffffff,0x00d5d6d6,0x00717474)    R(0x0212,0x00676d6b,0x00797b79,0x00757776,0x006a6d6e)    R(0x0213,0x004a4a58,0x000b0042,0x00000050,0x003a134c)    R(0x0214,0x00833500,0x009f5016,0x00a7551a,0x00a7581e)    R(0x0215,0x00a85920,0x00a95920,0x00a2531c,0x009d4f17)    R(0x0216,0x009e4f18,0x009c4f1c,0x00a2551e,0x00a8571c)    R(0x0217,0x00a55316,0x00a45216,0x009c4f00,0x00824241)\n    R(0x0218,0x00582c6a,0x00000068,0x006a6a8a,0x00cecfcf)    R(0x0219,0x00e0e0db,0x00dadbd7,0x00d6d5d2,0x00d1cec8)    R(0x021a,0x00b5b5a6,0x0082807e,0x003f3c71,0x00000050)    R(0x021b,0x0083828c,0x00fbfcfb,0x00ffffff,0x00ffffff)    R(0x021c,0x00ffffff,0x00ffffff,0x00f0efef,0x00848584)    R(0x021d,0x00515353,0x005c5f5d,0x00595a59,0x005b5f5d)    R(0x021e,0x00636664,0x00696b6b,0x00494a54,0x0000004b)    R(0x021f,0x002a4c6b,0x0076857a,0x009d3600,0x00a6551a)\n    R(0x0220,0x00a9571d,0x00a85920,0x00a45620,0x00a04c00)    R(0x0221,0x009e3900,0x00942e00,0x009b4100,0x009a4c14)    R(0x0222,0x009f511a,0x00a7551c,0x00a55500,0x00814257)    R(0x0223,0x0041259b,0x000d18a7,0x0000058e,0x002c2d81)    R(0x0224,0x009899ae,0x00cfd0d7,0x00e1e5e9,0x00e3e6e8)    R(0x0225,0x00cbcbd3,0x009190be,0x004c4bbb,0x001e1ea7)    R(0x0226,0x00120f78,0x00000033,0x00dcdddf,0x00ffffff)    R(0x0227,0x00feffff,0x00fdfdfc,0x00cfcfcf,0x008b8a89)\n    R(0x0228,0x0019180f,0x000f0500,0x002e2c28,0x004c4d4b)    R(0x0229,0x00424544,0x00373533,0x00545551,0x00666967)    R(0x022a,0x00220f46,0x00005d7d,0x005cb5bf,0x00906231)    R(0x022b,0x009e4500,0x00a25417,0x00a8571c,0x00a55000)    R(0x022c,0x0095694c,0x00719e99,0x0059a9ad,0x0075847f)    R(0x022d,0x00854b29,0x00914508,0x00a75600,0x008b4950)    R(0x022e,0x004226b2,0x00181ccf,0x00241fbb,0x00201da0)    R(0x022f,0x000e0c92,0x00000075,0x0064667b,0x008d91da)\n    R(0x0230,0x008b90e8,0x006c70e2,0x003437e3,0x001f1be6)    R(0x0231,0x00241fc8,0x001d1a98,0x00000058,0x007f7f90)    R(0x0232,0x00fefffe,0x00fffffe,0x00ededeb,0x0081807e)    R(0x0233,0x005c5657,0x00635e5d,0x0066625f,0x005e5b58)    R(0x0234,0x00525551,0x00626564,0x00464441,0x00373531)    R(0x0235,0x005f605c,0x005d5c6b,0x00485b96,0x000c84b8)    R(0x0236,0x00779992,0x00994900,0x00a44f10,0x00a75214)    R(0x0237,0x00a44900,0x007c9991,0x001be0e6,0x0011e6f1)\n    R(0x0238,0x0027d0d9,0x00678f8b,0x00864106,0x008f4725)    R(0x0239,0x006136a8,0x00181bdc,0x00251ed8,0x00251fcc)    R(0x023a,0x00251fc5,0x00211fab,0x0008026b,0x00000000)    R(0x023b,0x003a36b2,0x000000ea,0x000000f0,0x00262bf0)    R(0x023c,0x00282aeb,0x002620de,0x00221fb9,0x0017138b)    R(0x023d,0x00000039,0x00ebeaec,0x00fffffe,0x00dedfdd)    R(0x023e,0x00bbbeba,0x00d7d6d6,0x00d8d8d6,0x00c6c8c6)    R(0x023f,0x009f9b9a,0x004b4c47,0x00626664,0x00454946)\n    R(0x0240,0x002f2f2c,0x0042413e,0x0087888a,0x00cdcde0)    R(0x0241,0x006471c1,0x003d5ca0,0x00904d2c,0x009e4e0f)    R(0x0242,0x00a15317,0x00a54500,0x00819c8d,0x0033e7eb)    R(0x0243,0x0027edf7,0x0019edf7,0x0066b7b8,0x00864f13)    R(0x0244,0x00672f73,0x003622d0,0x00211de0,0x00261edd)    R(0x0245,0x00261fdf,0x002821d5,0x001e1a9d,0x000e0950)    R(0x0246,0x00000027,0x00353457,0x002e2dce,0x002b31f0)    R(0x0247,0x002f32ee,0x002b2fee,0x002726ea,0x002520d7)\n    R(0x0248,0x00221eb1,0x0000005d,0x00c7c5cc,0x00fffffe)    R(0x0249,0x00c9c9c8,0x00babab7,0x00cccccb,0x00cdcdcb)    R(0x024a,0x00bbbcba,0x00949190,0x0044423c,0x004f504f)    R(0x024b,0x00484c49,0x00262826,0x004a4948,0x00bfbfbe)    R(0x024c,0x00ffffff,0x00d9d9f0,0x008782c5,0x00420061)    R(0x024d,0x007d4200,0x00723f69,0x0076379a,0x00786496)    R(0x024e,0x0059a9b1,0x0040d0d0,0x004ad0d1,0x00859b90)    R(0x024f,0x009e5500,0x0065338b,0x000c19d1,0x00261ee1)\n    R(0x0250,0x00261ee6,0x00251ee4,0x00261fce,0x00201ba7)    R(0x0251,0x001c178c,0x00151277,0x0001004f,0x0018148a)    R(0x0252,0x002727da,0x002d2fee,0x002b32ef,0x00292dee)    R(0x0253,0x002622e7,0x00251fd0,0x0000008d,0x00b2b1b8)    R(0x0254,0x00ffffff,0x00bdbbba,0x00c4c2c0,0x00cdcbca)    R(0x0255,0x00c8c7c5,0x00bdbbba,0x00999996,0x006e6a66)    R(0x0256,0x004e4d4c,0x00595a58,0x00373837,0x00646363)    R(0x0257,0x00edebeb,0x00ffffff,0x00ffffff,0x00e3e5f4)\n    R(0x0258,0x008c90cb,0x001e0088,0x00582163,0x00482aa0)    R(0x0259,0x003b1ed1,0x004046d3,0x005d77b7,0x008f8071)    R(0x025a,0x00a76a35,0x00ad5b00,0x00834668,0x003625bb)    R(0x025b,0x00201ed7,0x00261ee1,0x00251de5,0x00251ddb)    R(0x025c,0x00251dd6,0x00251ecd,0x00221cc2,0x00211bb6)    R(0x025d,0x001d18a0,0x00221eba,0x002523db,0x00262bea)    R(0x025e,0x002730ed,0x002726ec,0x002924e2,0x000000a0)    R(0x025f,0x00c8c7ce,0x00ffffff,0x00cfcecf,0x00e4e4e4)\n    R(0x0260,0x00f1f2f1,0x00f5f6f5,0x00ebebea,0x00c2c0be)    R(0x0261,0x008a8882,0x004c4d4b,0x00616462,0x00484b48)    R(0x0262,0x00646361,0x00e8e6e6,0x00ffffff,0x00ffffff)    R(0x0263,0x00ffffff,0x00e8eaf9,0x00a7a7e0,0x006d5db1)    R(0x0264,0x004c007d,0x002800a3,0x001904de,0x003e0ad9)    R(0x0265,0x00752e8d,0x00a45226,0x00b05e11,0x009c530d)    R(0x0266,0x00593196,0x00101bc1,0x002620da,0x002622e9)    R(0x0267,0x002726eb,0x002626ec,0x002522e8,0x002724e8)\n    R(0x0268,0x002726e7,0x002627e2,0x002625d9,0x002722e1)    R(0x0269,0x002727ec,0x002b31f2,0x002c2df3,0x000000e1)    R(0x026a,0x004d54af,0x00f0f0f3,0x00fefffe,0x00cdcecd)    R(0x026b,0x00c0c1c0,0x00c2c2c1,0x00bebdbd,0x00afaead)    R(0x026c,0x00908d8c,0x00686460,0x00454645,0x005e6261)    R(0x026d,0x004a4e4c,0x005e5d5a,0x00d4d4d3,0x00ffffff)    R(0x026e,0x00ffffff,0x00ffffff,0x00ffffff,0x00f4f5fd)    R(0x026f,0x00dcdef3,0x00d6d3e4,0x00bfb4c1,0x006a5795)\n    R(0x0270,0x00000096,0x00353b85,0x00694755,0x009a5529)    R(0x0271,0x00b05d00,0x00844556,0x002c20ac,0x00181edc)    R(0x0272,0x002a2beb,0x002a30ef,0x00292fee,0x002829ed)    R(0x0273,0x002728ef,0x002829f0,0x002a2cf5,0x002a2bf1)    R(0x0274,0x002521ed,0x00110de1,0x000000d8,0x000000ce)    R(0x0275,0x007879d5,0x00d7d8e8,0x00ffffff,0x00ffffff)    R(0x0276,0x00d0d1d0,0x00cacac9,0x00cacac9,0x00bebdbd)    R(0x0277,0x00b5b5b4,0x00abacaa,0x00999796,0x00716e6e)\n    R(0x0278,0x005a5c5b,0x004f5352,0x00636461,0x00d4d4d3)    R(0x0279,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x027a,0x00ffffff,0x00ffffff,0x00e4e5e7,0x009e9da4)    R(0x027b,0x00545973,0x00435c82,0x00476081,0x003d5578)    R(0x027c,0x0058516b,0x008c574a,0x009e5700,0x006b3b89)    R(0x027d,0x002821de,0x00292cf3,0x002b32f1,0x002a30ef)    R(0x027e,0x00282bef,0x002421e9,0x000200df,0x000000d1)    R(0x027f,0x000000c3,0x000000c2,0x004c4dbe,0x008686c9)\n    R(0x0280,0x00c7c7e5,0x00e7e8f2,0x00fffffd,0x00fefefe)    R(0x0281,0x00ffffff,0x00ebebeb,0x00dfdfde,0x00eeefef)    R(0x0282,0x00f6f8f8,0x00f5f6f7,0x00dfdfdd,0x00a6a3a3)    R(0x0283,0x00666362,0x00565755,0x00535654,0x00747471)    R(0x0284,0x00e8e8e7,0x00ffffff,0x00ffffff,0x00feffff)    R(0x0285,0x00ffffff,0x00f6f7f7,0x00bec1c7,0x00798093)    R(0x0286,0x004a5f8a,0x005c7bae,0x00708cbd,0x006f8bb4)    R(0x0287,0x007390ba,0x006183af,0x00536184,0x0069515b)\n    R(0x0288,0x005a415d,0x002e24a3,0x002523d5,0x002627e5)    R(0x0289,0x002725e1,0x00211ece,0x000000bc,0x004c4dbf)    R(0x028a,0x008383c2,0x00a9abcf,0x00c5c6dc,0x00dcdcea)    R(0x028b,0x00ebebf2,0x00ffffff,0x00ffffff,0x00fefffd)    R(0x028c,0x00ffffff,0x00ffffff,0x00fcfcfc,0x00d0d1d0)    R(0x028d,0x00bdbdbc,0x00b2b4b2,0x00adaead,0x008c8c8a)    R(0x028e,0x00706d69,0x00646461,0x004e4f4b,0x0062625e)    R(0x028f,0x00848482,0x00fdfdfd,0x00ffffff,0x00ffffff)\n    R(0x0290,0x00ffffff,0x00f9fafa,0x00bdc1c9,0x0046597e)    R(0x0291,0x00415f93,0x005c75a7,0x00566b95,0x00405178)    R(0x0292,0x003f507e,0x00425583,0x005b6fa0,0x005e78a9)    R(0x0293,0x004b6692,0x00435377,0x00343c65,0x00252c73)    R(0x0294,0x00262b8b,0x00120f82,0x0001016d,0x00bbbdd1)    R(0x0295,0x00e2e3ee,0x00ececf3,0x00f5f5f8,0x00fbfcfc)    R(0x0296,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0297,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0298,0x00d7d8d7,0x00cfd0ce,0x00c6c6c6,0x00babab9)    R(0x0299,0x00afb0af,0x00a5a5a2,0x0083827d,0x0074736f)    R(0x029a,0x00757470,0x00949492,0x00ffffff,0x00ffffff)    R(0x029b,0x00ffffff,0x00fefefe,0x00d2d6d9,0x004d628a)    R(0x029c,0x004f6fa5,0x006686bd,0x005a73a4,0x00444c5e)    R(0x029d,0x00414243,0x003d3c47,0x00312c4a,0x00312f58)    R(0x029e,0x0051628c,0x005973a2,0x00526b99,0x00495b83)    R(0x029f,0x0038455d,0x002b3645,0x00262f3d,0x000c0f14)\n    R(0x02a0,0x007d7e7c,0x009b9c9a,0x00f0f0ef,0x00ffffff)    R(0x02a1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02a2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02a3,0x00ffffff,0x00f6f6f6,0x00eaeaea,0x00ececec)    R(0x02a4,0x00f1f1f1,0x00e5e5e5,0x00b3b3b2,0x009c9997)    R(0x02a5,0x008f8d8b,0x006e6c6a,0x009e9e9c,0x00ffffff)    R(0x02a6,0x00ffffff,0x00ffffff,0x00eeeff1,0x00919db3)    R(0x02a7,0x004569a3,0x00617aae,0x006582b9,0x004d628b)\n    R(0x02a8,0x00252930,0x00444c62,0x004b5268,0x00494f59)    R(0x02a9,0x004f5760,0x00586172,0x006175a1,0x005f79ac)    R(0x02aa,0x00576e9d,0x004c618b,0x003f4f70,0x00303c57)    R(0x02ab,0x00232c41,0x00000000,0x00000000,0x00c3c3c4)    R(0x02ac,0x00fbfbfb,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02ad,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02ae,0x00ffffff,0x00ffffff,0x00ffffff,0x00fbfafb)    R(0x02af,0x00f9f9f9,0x00f8f8f8,0x00f6f6f6,0x00e4e4e4)\n    R(0x02b0,0x00a2a09f,0x00726f6f,0x00504e4c,0x009e9c9b)    R(0x02b1,0x00ffffff,0x00ffffff,0x00ffffff,0x00e3e6ef)    R(0x02b2,0x007088b7,0x004f6890,0x0027324c,0x002f3c59)    R(0x02b3,0x00202a3d,0x00000005,0x00192032,0x00202535)    R(0x02b4,0x001f2222,0x00363f4b,0x005a749e,0x006b88c1)    R(0x02b5,0x006682ba,0x005e79ae,0x005872a3,0x004f6590)    R(0x02b6,0x003c4e72,0x00303f59,0x001d2437,0x00000000)    R(0x02b7,0x00c4c4c5,0x00fbfbfb,0x00ffffff,0x00ffffff)\n    R(0x02b8,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02b9,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02ba,0x00ffffff,0x00ffffff,0x00fdfdfd,0x00fefefe)    R(0x02bb,0x00f9f9f9,0x00a6a3a0,0x0074726e,0x00565450)    R(0x02bc,0x00929190,0x00ffffff,0x00ffffff,0x00fbfcfc)    R(0x02bd,0x00cad0dc,0x003f5682,0x001d2530,0x00000000)    R(0x02be,0x00101b2d,0x001b2a44,0x00192747,0x00132043)    R(0x02bf,0x00182141,0x00090c1c,0x00000000,0x00304362)\n    R(0x02c0,0x003c4f72,0x003f5172,0x005875a5,0x00617db3)    R(0x02c1,0x005a72a3,0x004d628d,0x00394c6c,0x00293452)    R(0x02c2,0x00232334,0x00e8e9ea,0x00ffffff,0x00ffffff)    R(0x02c3,0x00feffff,0x00fffffe,0x00ffffff,0x00ffffff)    R(0x02c4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02c5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02c6,0x00ffffff,0x00f9f9f9,0x00b5b4b1,0x00b7b5b3)    R(0x02c7,0x0092918e,0x0080807e,0x00f8f9f8,0x00ffffff)\n    R(0x02c8,0x00e8ebef,0x0067758d,0x00000004,0x00273144)    R(0x02c9,0x004d638b,0x005772a3,0x00536a9c,0x004a608e)    R(0x02ca,0x003c5179,0x002d3e63,0x00253452,0x00131a2a)    R(0x02cb,0x00000000,0x00000000,0x00000000,0x00607aa8)    R(0x02cc,0x006f90cf,0x006280b8,0x005772a4,0x00475e88)    R(0x02cd,0x00364463,0x002b3048,0x008e93a1,0x00abaeb7)    R(0x02ce,0x00e4e4e7,0x00ffffff,0x00fffffe,0x00ffffff)    R(0x02cf,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x02d0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02d1,0x00ffffff,0x00ffffff,0x00fcfcfc,0x00dddedd)    R(0x02d2,0x00e7e6e6,0x00d3d3d2,0x00969693,0x00dcdcdb)    R(0x02d3,0x00ffffff,0x00c8cedf,0x00001d63,0x00221c0a)    R(0x02d4,0x0059709b,0x0080a5dc,0x0088aee3,0x0083a5dd)    R(0x02d5,0x007595cf,0x00637fb5,0x004d6491,0x00394b70)    R(0x02d6,0x0027354f,0x000b0d16,0x00070507,0x00040000)    R(0x02d7,0x003c4a66,0x005972a0,0x006784bc,0x00627db6)\n    R(0x02d8,0x00566d9e,0x003f5275,0x00324261,0x00415784)    R(0x02d9,0x005b75a8,0x00717da3,0x00cdd0d6,0x00fefefe)    R(0x02da,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02db,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02dc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02dd,0x00f8f8f8,0x00f0f0f1,0x00e9e9e7,0x00a8a9a8)    R(0x02de,0x00e2e3e1,0x00f6f8fc,0x009fa9c7,0x0000195f)    R(0x02df,0x00516385,0x0088ace6,0x009bc5f7,0x00a1cef6)\n    R(0x02e0,0x00a0cbf6,0x0096bef1,0x0086aae3,0x006d8cbf)    R(0x02e1,0x004d638d,0x002e3c5d,0x00000017,0x00000000)    R(0x02e2,0x00060000,0x0015141b,0x001d242f,0x005a72a3)    R(0x02e3,0x006682bc,0x005d76aa,0x00445b84,0x00384a6e)    R(0x02e4,0x003b5179,0x006a8cc6,0x007aa1e2,0x007487b1)    R(0x02e5,0x00e8e9eb,0x00fefefe,0x00ffffff,0x00ffffff)    R(0x02e6,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02e7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x02e8,0x00ffffff,0x00fefeff,0x00f8f8f8,0x00eeeeee)    R(0x02e9,0x00e5e5e5,0x00fdfdfc,0x00f8f9fc,0x00b2bad0)    R(0x02ea,0x0000126e,0x005e78ad,0x0090baf5,0x00a9d7fa)    R(0x02eb,0x00bae4f7,0x00bae3f7,0x00add8f8,0x009dc7f6)    R(0x02ec,0x0087aae0,0x005b74a4,0x003b5583,0x00779bc5)    R(0x02ed,0x007ea4cb,0x00516b88,0x0011151e,0x00000000)    R(0x02ee,0x00536c9b,0x006685c0,0x005d78ac,0x0042557b)    R(0x02ef,0x00252d45,0x00283b60,0x007191cf,0x008db3f6)\n    R(0x02f0,0x00668dd4,0x00bec5d3,0x00fbfbfc,0x00ffffff)    R(0x02f1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02f2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02f3,0x00ffffff,0x00ffffff,0x00ffffff,0x00fefefe)    R(0x02f4,0x00fcfcfc,0x00fdfdfd,0x00ffffff,0x00ffffff)    R(0x02f5,0x00e3e7ec,0x0075829c,0x005678b6,0x008db6f3)    R(0x02f6,0x00aad8f6,0x00c5effc,0x00c7ebf6,0x00b7e3f8)    R(0x02f7,0x00a5d1fa,0x008cb0e8,0x004968a5,0x0097a8bb)\n    R(0x02f8,0x00c0bdc1,0x00a49199,0x008b94bb,0x00667aa0)    R(0x02f9,0x001a1c13,0x00647bb0,0x006c8bc7,0x005b76a9)    R(0x02fa,0x0031426d,0x000b102e,0x0021335e,0x006381bc)    R(0x02fb,0x007ea4ec,0x007194e0,0x008592b4,0x00fafafb)    R(0x02fc,0x00fefefe,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02fd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02fe,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x02ff,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0300,0x00ffffff,0x00f1f2f2,0x009ba0af,0x005a7ebf)    R(0x0301,0x00acc0ea,0x00c3cbc7,0x00a3c3ce,0x00acd5ef)    R(0x0302,0x00a8d0f7,0x0094bdf0,0x00759cd3,0x0087a2c9)    R(0x0303,0x00cccdcc,0x00bea180,0x00764600,0x00846b6b)    R(0x0304,0x0092a7d3,0x006f8cbb,0x00718fc9,0x006783c0)    R(0x0305,0x0044547b,0x001b2446,0x00161d3d,0x00273661)    R(0x0306,0x00486196,0x006688cc,0x00718bd7,0x00687da9)    R(0x0307,0x00f9f9fb,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0308,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0309,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x030a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x030b,0x00ffffff,0x00ffffff,0x00e4e2e1,0x00414f70)    R(0x030c,0x006f92d1,0x00bac8e9,0x00cdbea1,0x006a582e)    R(0x030d,0x007593b3,0x00a8d0f6,0x00b0def4,0x009ccceb)    R(0x030e,0x00b9d7f5,0x00d9d0bf,0x00977532,0x00140000)    R(0x030f,0x00695030,0x00879bca,0x00799cdd,0x006d8bc9)\n    R(0x0310,0x00546ea3,0x00233051,0x00000009,0x002c3959)    R(0x0311,0x00263869,0x00425785,0x005f80bb,0x005c79c3)    R(0x0312,0x006c7ca4,0x00f9f9fa,0x00ffffff,0x00ffffff)    R(0x0313,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0314,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0315,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0316,0x00ffffff,0x00ffffff,0x00f3f3f3,0x008a8888)    R(0x0317,0x00001b4d,0x006687c4,0x00b5c6ed,0x00ded3c3)\n    R(0x0318,0x00b18c3e,0x00a9b0b2,0x00b4e2f8,0x00bfedf8)    R(0x0319,0x00aadcf7,0x00c6e3ff,0x00daceb9,0x00987c3d)    R(0x031a,0x00474946,0x007a6958,0x008798ca,0x007394d6)    R(0x031b,0x006582ba,0x00506999,0x001f2e56,0x00000014)    R(0x031c,0x00394151,0x00748fc6,0x003e5584,0x00354e80)    R(0x031d,0x0035539d,0x00aab4c8,0x00fbfcfc,0x00ffffff)    R(0x031e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x031f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0320,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0321,0x00ffffff,0x00ffffff,0x00ececed,0x007c7a8b)    R(0x0322,0x0010084b,0x002c3965,0x005473ab,0x00879ece)    R(0x0323,0x00c1cbd5,0x00c1cad3,0x00a9c8e6,0x00b3e4f9)    R(0x0324,0x00b8e6f8,0x00a4d4fa,0x00c1dbfc,0x00e0dbd5)    R(0x0325,0x00b89c68,0x008d6300,0x00a38f82,0x0090a3da)    R(0x0326,0x006e91d4,0x00617db3,0x00516998,0x0028365d)    R(0x0327,0x00060d29,0x00000000,0x00637c9e,0x007d9cd4)\n    R(0x0328,0x005b80c3,0x00889cc1,0x00e7eaee,0x00fdfdfd)    R(0x0329,0x00fefefe,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x032a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x032b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x032c,0x00ffffff,0x00ffffff,0x00f4f4f4,0x0095949d)    R(0x032d,0x0000003d,0x00050057,0x0019164a,0x003c4d70)    R(0x032e,0x006482b8,0x00748fc2,0x007c92b2,0x0091b5d3)    R(0x032f,0x00afdbfe,0x00acdafc,0x008fbbe0,0x0086a2c7)\n    R(0x0330,0x00d7e0ea,0x00efe9dc,0x00e1d4bf,0x00b6bfdd)    R(0x0331,0x0082a3e7,0x006987c5,0x00546c9d,0x00405981)    R(0x0332,0x00202f4f,0x00080b23,0x00000019,0x00222946)    R(0x0333,0x00001f5d,0x00bfc4d2,0x00f2f4f7,0x00fefefe)    R(0x0334,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0335,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0336,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0337,0x00ffffff,0x00ffffff,0x00ffffff,0x00eeeeef)\n    R(0x0338,0x005d5d6c,0x0000003c,0x000f0557,0x000b0043)    R(0x0339,0x00101127,0x00233146,0x0017253c,0x0045587b)    R(0x033a,0x007da1d8,0x008cb7f1,0x0096c2f9,0x007999c3)    R(0x033b,0x00455673,0x007589ae,0x009eadc8,0x0099a9c8)    R(0x033c,0x007592ca,0x005d7cb8,0x004f689a,0x00445c89)    R(0x033d,0x003e527a,0x001e2846,0x0009022a,0x000e0539)    R(0x033e,0x000d0046,0x00000032,0x0096969e,0x00f9f9f9)    R(0x033f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0340,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0341,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0342,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0343,0x00f7f7f9,0x00adabb9,0x00000000,0x000f0452)    R(0x0344,0x000f024d,0x000a0037,0x00000000,0x00384258)    R(0x0345,0x006b87c0,0x00759ee6,0x00749ee1,0x0076a0e4)    R(0x0346,0x006d8eca,0x003f4d6e,0x00192235,0x00495c80)    R(0x0347,0x00526a97,0x0049608c,0x004a6390,0x00496393)\n    R(0x0348,0x003f5079,0x00242c4d,0x000d0934,0x000e0448)    R(0x0349,0x000f0554,0x000f0558,0x0000001f,0x0098999e)    R(0x034a,0x00f8f9f9,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x034b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x034c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x034d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x034e,0x00ffffff,0x00fffffe,0x00e6e6ec,0x003d3f7c)    R(0x034f,0x0000002e,0x000b0041,0x000c024e,0x000b004a)\n    R(0x0350,0x00121344,0x002d3761,0x004a5b8d,0x00607ab4)    R(0x0351,0x00698ac8,0x006a8ecd,0x00526a9a,0x001b191f)    R(0x0352,0x00030b17,0x000f192a,0x00191d2b,0x00374161)    R(0x0353,0x00293154,0x000e1237,0x000a063e,0x000e0452)    R(0x0354,0x000f0861,0x000e065e,0x000d0355,0x00000000)    R(0x0355,0x00c5c6c7,0x00fcfcfc,0x00ffffff,0x00ffffff)    R(0x0356,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0357,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0358,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0359,0x00ffffff,0x00ffffff,0x00ffffff,0x00eaebf1)    R(0x035a,0x004749a0,0x0004008e,0x001a1264,0x00030000)    R(0x035b,0x000a0032,0x000d0045,0x000a0046,0x00111049)    R(0x035c,0x0019214e,0x00202954,0x002c3761,0x002c3458)    R(0x035d,0x00171433,0x00020008,0x00020000,0x00030005)    R(0x035e,0x000d0a2a,0x000d0649,0x000b065e,0x00110e6c)    R(0x035f,0x00100d6c,0x000e0a69,0x000f0661,0x00000051)\n    R(0x0360,0x001b1c42,0x00e6e5e6,0x00ffffff,0x00ffffff)    R(0x0361,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0362,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0363,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0364,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0365,0x00ebebf2,0x005053ab,0x000c00ad,0x002623bb)    R(0x0366,0x002a25b2,0x001c1680,0x0000004f,0x000b0441)    R(0x0367,0x0011063c,0x000e0139,0x000b0039,0x000e0236)\n    R(0x0368,0x00100637,0x000c0535,0x000b053b,0x000e074d)    R(0x0369,0x00150f68,0x00181176,0x0016127b,0x0016137d)    R(0x036a,0x0015117b,0x00141075,0x00110d6d,0x00000060)    R(0x036b,0x00000023,0x00cecdd2,0x00fbfcfc,0x00fefefe)    R(0x036c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x036d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x036e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x036f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0370,0x00ffffff,0x00efeff5,0x007b7cbc,0x000000b1)    R(0x0371,0x002621c0,0x002418ce,0x003e3cd0,0x005351c4)    R(0x0372,0x000000b9,0x000000b0,0x000000b3,0x001e17aa)    R(0x0373,0x002925a6,0x002823a8,0x00221da2,0x001f1b9b)    R(0x0374,0x001e1a95,0x001d1993,0x001b188f,0x0019168a)    R(0x0375,0x00181585,0x0016137e,0x00131177,0x0007056a)    R(0x0376,0x00000058,0x00c7c8d0,0x00fafafb,0x00fffefe)    R(0x0377,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0378,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0379,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x037a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x037b,0x00ffffff,0x00ffffff,0x00f5f5f9,0x00a2a4ce)    R(0x037c,0x000000ac,0x002319c8,0x002c2dd7,0x008486d1)    R(0x037d,0x00cccde6,0x00dad8e3,0x00bdbbdc,0x008386cd)    R(0x037e,0x004d4fc2,0x001f14bd,0x001008b4,0x002521b2)    R(0x037f,0x00231db0,0x00231caf,0x00221eaa,0x00201ba0)\n    R(0x0380,0x001c1894,0x0019178b,0x00191588,0x0017167b)    R(0x0381,0x00000050,0x00bab8c3,0x00f8f8f8,0x00ffffff)    R(0x0382,0x00fffffe,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0383,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0384,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0385,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0386,0x00ffffff,0x00ffffff,0x00ffffff,0x00fcfdfd)    R(0x0387,0x00cdcee3,0x000000ac,0x000000c7,0x00676ada)\n    R(0x0388,0x009395d7,0x008b89e3,0x00eeeff8,0x00fdfef7)    R(0x0389,0x00f7f7f6,0x00dfe0f1,0x00bab8db,0x007872cf)    R(0x038a,0x000000d4,0x002721cd,0x002620c0,0x00251fb6)    R(0x038b,0x00231daa,0x00201b9d,0x001c1994,0x001a1b88)    R(0x038c,0x0000005f,0x008e8fa8,0x00f1f1f4,0x00ffffff)    R(0x038d,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x038e,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x038f,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x0390,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0391,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0392,0x00ffffff,0x00eaebf2,0x006467bb,0x000000c5)    R(0x0393,0x007f80d9,0x00bcbce3,0x009394e8,0x00dadcf3)    R(0x0394,0x00efeef5,0x00f0f2f5,0x00a6a7ec,0x007b78e9)    R(0x0395,0x00928fde,0x004a45db,0x001c13d2,0x002620c3)    R(0x0396,0x002520b9,0x00221eae,0x001f1ca1,0x001f1b93)    R(0x0397,0x00000077,0x00626489,0x00e7e7eb,0x00ffffff)\n    R(0x0398,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x0399,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x039a,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x039b,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x039c,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x039d,0x00ffffff,0x00ffffff,0x00feffff,0x00d2d3ec)    R(0x039e,0x000000be,0x006d6eda,0x00bbbbe3,0x00a0a0ea)    R(0x039f,0x007072e7,0x008b86ea,0x00beb9f0,0x008381ea)\n    R(0x03a0,0x00bebfee,0x00bfc2e6,0x003b3adb,0x001c12d3)    R(0x03a1,0x00251fc3,0x00241fba,0x00231fae,0x00211d9f)    R(0x03a2,0x00000085,0x0000006c,0x00d1d0da,0x00fdfdfe)    R(0x03a3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03a4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03a5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03a6,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03a7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x03a8,0x00ffffff,0x00ffffff,0x00ffffff,0x00fffffe)    R(0x03a9,0x00f4f4f6,0x00a3a4de,0x000000d3,0x009c9de1)    R(0x03aa,0x00b2b2ec,0x007777e7,0x00a3a5eb,0x004137e6)    R(0x03ab,0x00acabee,0x00eceef1,0x00a5a6e5,0x000000d9)    R(0x03ac,0x00251fd2,0x002520c7,0x002420bf,0x002420b5)    R(0x03ad,0x00000098,0x00000070,0x00c9cbd4,0x00fbfcfc)    R(0x03ae,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03af,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x03b0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03b1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03b2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03b3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03b4,0x00feffff,0x00ffffff,0x00e4e5f1,0x006668d5)    R(0x03b5,0x002426de,0x00a4a8e1,0x00edeff0,0x00e9e9f2)    R(0x03b6,0x00b9baee,0x00d3d4ef,0x00babae3,0x001d18d9)    R(0x03b7,0x001c11e0,0x002520d0,0x002521c8,0x002520c0)\n    R(0x03b8,0x000000ab,0x002b2c8b,0x00cfcfd9,0x00fcfcfd)    R(0x03b9,0x00fffefe,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03ba,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03bb,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03bc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03bd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03be,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03bf,0x00ffffff,0x00ffffff,0x00ffffff,0x00fffffe)\n    R(0x03c0,0x00e2e5f4,0x007478de,0x000000dd,0x006565e3)    R(0x03c1,0x009595e6,0x009699e4,0x006d6fe0,0x001e15e2)    R(0x03c2,0x001f18e6,0x002620db,0x002822cc,0x000802bb)    R(0x03c3,0x0000009e,0x008b8eb6,0x00e1e2e9,0x00fdfdfd)    R(0x03c4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03c5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03c6,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03c7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x03c8,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03c9,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03ca,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03cb,0x00fefffe,0x00fefffd,0x00eff2f9,0x00a4a9e3)    R(0x03cc,0x000000d6,0x000c09ea,0x002323ea,0x002320e7)    R(0x03cd,0x002118e0,0x001c13d8,0x001102c7,0x000000a7)    R(0x03ce,0x00666aaa,0x00d5d7e4,0x00fbfbfd,0x00fcfeff)    R(0x03cf,0x00feffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x03d0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03d1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03d2,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03d3,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03d4,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03d5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03d6,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03d7,0x00fdfefe,0x00e7eaf7,0x00b8bae8,0x009698df)\n    R(0x03d8,0x008588d7,0x008d8dd3,0x00a0a1d3,0x00babad9)    R(0x03d9,0x00dfe0ed,0x00fafbfc,0x00ffffff,0x00ffffff)    R(0x03da,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03db,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03dc,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03dd,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03de,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03df,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x03e0,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03e1,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03e2,0x00fffefe,0x00fefefb,0x00fdfffb,0x00fefffd)    R(0x03e3,0x00fdfcfc,0x00fafbfc,0x00fcfcfc,0x00fefefe)    R(0x03e4,0x00fffffe,0x00fffffd,0x00fefefe,0x00fefefe)    R(0x03e5,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03e6,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)    R(0x03e7,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)\n    R(0x03e8,0x00ffffff,0x00ffffff,0x00ffffff,0x00ffffff)  }\n  return r;\n}\n#endif \n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if(iFrame == 0) {       \n       ivec2 uv = ivec2(fragCoord);\n       uv = uv / 2;\n       if(uv.x < image_width && uv.y < image_height) {\n          int index = uv.y * image_width + uv.x;\n          int comp = index % 4;\n          index = index / 4;\n          ivec4 P = pixel_data(index);\n          int rgb = P[comp];\n          ivec3 col = (ivec3(rgb)>>ivec3(0,8,16))&255;\n          fragColor.xyz = vec3(col)/255.0;            \n      } else {\n         fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      }\n    } else {\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lK3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 164]], "test": "untested"}
{"id": "Wt3XRn", "name": "2d metaballs", "author": "cschied", "description": "some simple 2d metaball thing", "tags": ["metaballs"], "likes": 1, "viewed": 284, "published": 3, "date": "1580241062", "time_retrieved": "2024-07-30T21:27:52.743852", "image_code": "float dist(vec2 p, vec2 x)\n{\n    vec2 a = x - p;\n    return 1.0 / dot(a, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 points[3] = vec2[3](\n        0.5 * vec2(sin(iTime), cos(iTime)),\n        vec2(0.75 + sin(iTime * 0.00012313), 0.5),\n        0.65 * vec2(sin(iTime * 0.129837987), cos(iTime)) + vec2(0.75)\n    );\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float sum = 0.0;\n    for(int i = 0; i < points.length(); i++) {\n    \tsum += dist(points[i], uv);\n    }\n\n    sum = sum / (sum + 1.0);\n\n    fragColor = texture(iChannel0, vec2(sum, fract(iTime * 0.05)));\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3XRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 78], [80, 80, 137, 137, 632]], "test": "untested"}
{"id": "wlV3Wt", "name": "Day 40", "author": "jeyko", "description": "Code may not be the cleanliest", "tags": ["mdtmjvm"], "likes": 9, "viewed": 1052, "published": 3, "date": "1580239423", "time_retrieved": "2024-07-30T21:27:53.607543", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,3.)*0.1;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.4)*3.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.91;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*1.; \n    \n    fragColor *= 1.3;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.8);\n    \n    fragColor = max(fragColor, 0.);\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.8,1. + sin(iTime)*0.2,1. - sin(iTime)*0.2));\n\n    //fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.7));\n    fragColor *= 1. - dot(uvn,uvn)*1.8;\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// It was going ok, but now I kind of hate it.\n\n\n// --------- check out CUTEMODE, looks better --------- //\n#define CUTEMODE \n\n#define mx (iTime*3. + 1.*iMouse.x/iResolution.y)\n#define my (1.*iMouse.y/iResolution.y)\n\n#define dmin(a,b) a.x < b.x ? a : b\n#define pmod(p, x) mod(p, x) - x*0.5\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\nvec3 glow = vec3(0);\n\n#define modDist 5.\nvec3 u;\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e4);\n\tp.xz = pmod(p.xz, modDist);\n    \n    float pR = 4.;\n    p.y = abs(p.y);\n    p.y -= pR*1.1;\n    vec3 q = abs(p) - pR;\n    u = q;\n    float dPyra = max(q.x, q.z);\n    dPyra = max(dPyra, dot(q.xy + 0.5*pR,normalize(vec2(1))));\n    dPyra = max(dPyra, dot(q.zy + 0.5*pR,normalize(vec2(1))));\n    //d.x = min(d.x, length(p) - 0.5);\n    d.x = min(d.x, dPyra);\n    //d.x = min(d.x, length(p) - 0.5);\n    d.x *= 0.22;\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0.);\n    float d = map(p).x;\n\tfloat a = map(p - t.xyy).x;\n\tfloat b = map(p - t.yxy).x;\n\tfloat c = map(p - t.yyx).x;\n    return normalize(d - vec3(a,b,c));\n}\nvoid getNormalAndEdge(vec3 p,inout vec3 n,inout float edge){\n    vec2 t = vec2(0.05,0.);\n    n = getNormal(p);\n    vec3 a = getNormal(p + t.xyy);\n    vec3 b = getNormal(p + t.yxy);\n    vec3 c = getNormal(p + t.yyx);\n    vec3 d = getNormal(p - t.xyy);\n    vec3 e = getNormal(p - t.yxy);\n    vec3 f = getNormal(p - t.yyx);\n    edge = length(a - b - c );\n    edge = length(a - b - c - d - e - f);\n}\n\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\nvec2 march(vec3 ro, vec3 rd,inout float t,inout bool hit){\n\thit = false;\n    t = 0.;\n    vec2 d;\n    vec3 p = ro + rd*1.;\n    for(int i = 0; i < 250; i++){\n    \td = map(p);\n        //glow += exp(-d.x*15.)*pal(0.6 + sin(iTime),vec3(1.3,1.1,1.),vec3(4.7,2.2,3.), d.x*9., 10.);\n        //glow += exp(-d.x*10.)*pal(0.5,vec3(1.3 ,1.1 ,1.),vec3(1.7+ sin(iTime*2.)*1.,2.2,3.), d.x*5., 10.);\n        \n        //glow += exp(-d.x*10.)*pal(0.5,vec3(1.3,1.1,1.),vec3(4.7,2.2,3.), d.x*9., 10.);\n        glow += exp(-d.x*10.)*pal(0.5,vec3(1.3 ,1.1 ,1.),vec3(1.7+ sin(iTime*2.)*1.,2.2,3.), d.x*5., 10.);\n        //glow += exp(-d.x*0.)*pal(0.5,vec3(0.5 ,0.5 ,0.5),vec3(1.7+ sin(iTime*1.)*1.,9.2,3.), d.x*5., 10.)*0.1;\n        if(d.x < 0.001){\n        \thit = true;\n        \tbreak;\n        }\n        t += d.x;\n    \tp = ro + rd*t;\n    }\n\treturn d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir));\n\tvec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    //ro.z += mx;\n    ro.x -= mx;\n    ro.y += 0.2;\n    vec3 lookAt = ro + vec3(0,0,0);\n    lookAt.x += sin(-2.);\n    vec3 rd = getRd(ro, lookAt, uv);\n    rd.yz *= rot(sin(iTime*0.5)*0.1);\n    rd.xy *= 1. - dot(uv,uv)*0.2;\n\n    float t = 0.;\n    bool hit = false;\n    vec2 d = march(ro, rd, t, hit);\n    vec3 n;\n    float edge; \n    vec3 p =ro + rd*t;\n    vec3 j = p;\n    getNormalAndEdge( j*2. - vec3(0,2.5,0), n, edge);\n    if(hit){\n        float l = 1.;\n        //n = 1.;\n        //vec3 i = p;\n        col += abs(sin(iTime*0.6))*smoothstep(l*2.5,l,pow(edge*0.29,6.))*2.*fract(clamp(sin(iTime + p.z - cos(p.x) - p.y),0.,1.));\n        //#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define pi acos(-1.)\n        float mR = 6.;\n        float w = 0.2;\n        u.y = abs(u.y);\n        u = abs(u);\n        u.xy *= rot(0.25*pi);\n        u.zy *= rot(0.225*pi);\n        u = abs(u);\n        u.x -= 20.;\n        float id = floor(u.y*mR);\n        vec2 idZX = floor(p.xz/modDist);\n        #ifdef CUTEMODE\n        float m = abs(mod(u.y*mR,1.)-2.5);\n        #else \n        float m = abs(mod(u.y*mR,1.)-.9);\n        \n        #endif\n        col += smoothstep(w,w*.5 + sin(id)*1.4,m)*pal(0.5,vec3(1.9,0.7,0.1),vec3(0.7,0.2,0.8), 2. + idZX.x - idZX.y*2., id + idZX.x + iTime*0.9);\n        //col += n;\n    } else {\n    \t\n    }\n    \n    \n    col += glow*0.04;\n    col = max(col, vec3(0.00));\n    \n    //col = pow(col, vec3(1.5,1. + sin(iTime)*0.2,1. - sin(iTime)*0.2));\n    col *= 0.7;\n    //col.b*= 1.2;\n    \n    col = mix(col, vec3(0.0,0,0.0),clamp(pow(abs(t)*0.11 - 4.9, 1.), 0., 1.));\n    col = clamp(col, 0.00,1.);\n    col = mix(col,1. - col,0.01);\n    //col = smoothstep(0.,1.,col);\n    //col = mix(col, vec3(0,0,0),clamp(pow(abs(p.y)*0.5 - 0.4, 1.), 0., 1.));\n    //col = mix(col, vec3(0.04,0,0.04),clamp(pow(abs(p.y)*0.5 - 0.9, 1.), 0., 1.));\n    //col = smoothstep(-0.05,1.,col);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlV3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 1229]], "test": "untested"}
{"id": "3lcSRn", "name": "moving bars", "author": "bandaloo", "description": "shader i made for class", "tags": ["cineshader"], "likes": 5, "viewed": 13940, "published": 3, "date": "1580237856", "time_retrieved": "2024-07-30T21:27:54.521100", "image_code": "const float pi = 3.14159265;\n\nvec3 blurry_rectangle(vec2 p, float xEdgeWidth, float yEdgeWidth, float xBlurriness, float yBlurriness, float xOffset, float yOffset) {\n  // the blurry rectangle mask\n  p -= vec2(xOffset, yOffset);\n  float smoothFrequency = 1.0;\n  vec2 innerEdge = vec2(xEdgeWidth, yEdgeWidth) - vec2(xBlurriness, yBlurriness);\n  vec2 outerEdge = vec2(xEdgeWidth, yEdgeWidth) + vec2(xBlurriness, yBlurriness);\n  vec2 bl = smoothstep(innerEdge, outerEdge, p); // bottom-left\n  vec2 tr = smoothstep(innerEdge, outerEdge, 1.0 - p); // top-right\n  return vec3(bl.x * bl.y * tr.x * tr.y);\n}\n\nvec3 waves(vec2 p, float xWiggleRate, float yWiggleRate, float xFrequency, float yFrequency, float xWiggle, float yWiggle) {\n  xFrequency += sin(iTime * xWiggleRate);\n  yFrequency += sin(iTime * yWiggleRate);\n  return vec3(cos(xFrequency * (p.x + xWiggle * sin(p.y))) * cos(yFrequency * (p.y + yWiggle * cos(p.y))));\n}\n\nfloat glow(vec2 p) {\n  vec2 pn = p * 2.0 - 1.0;\n  \n  float glowScalar = 2.0;\n  float glowAdder = 0.0;\n  \n  float fadeFrequency = 1.0;\n  float glowColor = glowAdder + (1.0 - length(pn)) * glowScalar - (0.5 * sin(fadeFrequency * iTime) + 0.5);\n  return clamp(glowColor, 0.0, 1.0);\n}\n\nfloat sinSpeeding(float position, float offset) {\n  float speed = 100.0 * smoothstep(3.0, 100.0, position);\n  return sin(0.01 * position * speed + offset);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // position on screen\n  vec2 p = fragCoord.xy / iResolution.xy;\n  \n  // rectangle masks\n  vec3 mask1 = blurry_rectangle(p, 0.4, 0.125, 0.02, 0.02, 0.3 * sinSpeeding(iTime, 0.0), 0.0);\n  vec3 mask2 = blurry_rectangle(p, 0.4, 0.125, 0.02, 0.02, 0.3 * sinSpeeding(iTime, 2.0 * pi / 3.0), 0.0);\n  vec3 mask3 = blurry_rectangle(p, 0.4, 0.125, 0.02, 0.02, 0.3 * sinSpeeding(iTime, 4.0 * pi / 3.0), 0.0);\n  \n  // inside the blurry rectangle\n  vec3 color1 = waves(p, 0.2, 0.2, 10.0, 10.0, 5.0, 5.0);\n  vec3 color2 = waves(p, 0.1, 0.1, 2.0, 1.0, 100.0, 5.0);\n  vec3 color3 = waves(p, 0.1, 0.1, 2.0, 5.0, 1.0, 5.0);\n  \n  float glowVal = glow(p);\n  fragColor = vec4(mask1 * color1 + mask2 * color2 + mask3 * color3, 1.0) * vec4(0.8 * glowVal, 0.2 * glowVal, 1.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 165, 196, 598], [600, 600, 724, 724, 918], [920, 920, 940, 940, 1200], [1202, 1202, 1251, 1251, 1359], [1361, 1361, 1418, 1442, 2180]], "test": "untested"}
{"id": "ttV3Dd", "name": "Marbling", "author": "fabiojcortes", "description": "generative marbling", "tags": ["water", "generative", "marbling"], "likes": 2, "viewed": 423, "published": 3, "date": "1580233059", "time_retrieved": "2024-07-30T21:27:55.265111", "image_code": "float random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\n//noise algorithme from Morgan McGuire\n//https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec2 st){\n  vec2 ist = floor(st);\n  vec2 fst = fract(st);\n\n  //get 4 corners of the pixel\n  float bl = random(ist);\n  float br = random(ist + vec2(1.0, 0.0));\n  float tl = random(ist + vec2(0.0, 1.0));\n  float tr = random(ist + vec2(1.0, 1.0));\n\n  //smooth interpolation using cubic function\n  vec2 si = fst * fst * (3.0 - 2.0 * fst);\n\n  //mix the four corner to get a noise value\n  return mix(bl, br, si.x) +\n         (tl - bl) * si.y * (1.0 - si.x) +\n         (tr - br) * si.x * si.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = 18.0 * fragCoord / iResolution.xy;\n\n  float angle = sin(0.1*iTime);\n  float c = cos(angle);\n  float s = sin(angle);\n  p *= mat2(c, -s, s, c);\n\n  for(int n = 1; n < 30; n++){\n    float i = float(n);\n    p += vec2(0.8/ i * sin(i * p.y + iTime + 0.3 * i) + 0.8, 0.4 /i * sin(i*p.x + iTime + 2.3 * i) + 1.6);\n  }\n\n  p -= vec2(0.5 / cos(p.x + iTime + 0.3) + 0.8, 0.4 / cos(p.y + iTime + 0.3) + 1.6);\n  // vec3 col = vec3(0.1 * sin(p.x) + 0.2, 0.5 * sin(p.y) + 0.2, sin(p.x));\n  vec3 col = vec3(noise(p), cos(p.y), sin(p.x+0.3) );\n\n  // col *= 0.9;\n\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttV3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 96], [98, 177, 198, 198, 677], [679, 679, 736, 736, 1323]], "test": "untested"}
{"id": "tlVGDd", "name": "The Nautilus, Part 1", "author": "dr2", "description": "From Jules Verne's \"20K Leagues Under The Sea\"; part 1 of a series.", "tags": ["submarine", "sciencefiction", "verne"], "likes": 13, "viewed": 338, "published": 3, "date": "1580231119", "time_retrieved": "2024-07-30T21:27:56.293362", "image_code": "// \"The Nautilus, Part 1\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// From Jules Verne's \"20K Leagues Under The Sea\"; part 1 of a series.\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, sbPos;\nfloat tCur, dstFar, sbRot, sbLen, prpRot, msAz, msEl;\nint idObj;\nbool bmOn;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idGrnd = 14;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat GrndHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec2 q;\n  float ht, wAmp;\n  q = 0.2 * p;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    ht += wAmp * Noisefv2 (q);\n    q *= qRot;\n    wAmp *= 0.5;\n  }\n  return ht - 8.;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.x + 1.5 * Fbm2 (0.5 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.x + 1.9 * Fbm2 (0.3 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e = vec2 (0.002, 0.);\n  float h;\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  if (rd.y == 0.) rd.y = 0.0001;\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (2. * p.x + 0.77 * t + sin (0.73 * p.y - t)) + sin (0.81 * p.y - 0.89 * t +\n     sin (0.33 * p.x + 0.34 * t)) + 0.5 * (sin (1.43 * p.x - t) + sin (0.63 * p.y + t));\n  h *= 0.04 * smoothstep (0.5, 1., rd.y);\n  return h;\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.8), vec3 (0.25, 0.4, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + gd * 0.07);\n}\n\nfloat NautDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  d = PrCylDf (p, 2.3, sbLen + 2.);\n  dMin = d;\n  if (d < 0.1) dMin = NautDf (p);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.02, h);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec2 LBeamDf (vec3 p)\n{\n  vec3 q;\n  float d, bz;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, 2.35);\n  q.yz = Rot2D (q.yz, -0.04 * pi);\n  q.xz = Rot2D (q.xz, 0.01 * pi);\n  bz = q.z / 20.;\n  d = length (q.xy) - 0.08 * (1. + 3. * bz);\n  d = 0.9 * max (d, - min (20. * (1. - bz), q.z));\n  return vec2 (d, bz);\n}\n\nvec2 LBeamRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 d2;\n  float dHit;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d2 = LBeamDf (ro + dHit * rd);\n    dHit += d2.x;\n    if (d2.x < 0.001 || dHit > dstFar) break;\n  }\n  return vec2 (dHit, d2.y);\n}\n\nvec3 LBeamNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = LBeamDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx))).x;\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 NautColN (vec3 p, inout vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  vn.xz = Rot2D (vn.xz, sbRot);\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (0.5, 0.4, 0.3, -1.);\n  }\n  if (col4.a >= 0.) {\n    vn = VaryNf (32. * p, vn, 0.5);\n  }\n  vn.xz = Rot2D (vn.xz, - sbRot);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, vno, vnb, rob[1], rdb[1], bgCol, ltVec;\n  vec2 lbDist, ws;\n  float dstObj, dstGrnd, sh;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = (rd.y < 0.) ? GrndRay (ro, rd) : dstFar;\n  if (dstGrnd < min (dstObj, dstFar)) {\n    dstObj = dstGrnd;\n    idObj = idGrnd;\n  }\n  sh = 1.;\n  if (bmOn) {\n    rob[0] = ro;\n    rdb[0] = rd;\n  }\n  if (dstObj < dstFar) {\n    if (idObj == idGrnd) {\n      ro += dstObj * rd;\n      col4 = mix (vec4 (0.4, 0.3, 0.3, 0.), vec4 (0.3, 0.3, 0.2, 0.),\n         0.3 + 0.4 * smoothstep (0.4, 0.6, Fbm2 (2. * ro.xz))) * (1. +\n         0.2 * smoothstep (0.3, 0.7, Fbm2 (0.5 * ro.xz)));\n      vn = GrndNf (ro);\n      vno = vec3 (0., 1., 0.);\n      if (vn.y > 0.85) {\n        vn4 = RippleNorm (0.25 * ro.xz, vn, 8. * (1. - smoothstep (-0.4, -0.2, dot (rd, vn))));\n        vn = vn4.xyz;\n        col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w);\n      }\n      vn = VaryNf (4. * ro, vn, 4. - 3.5 * smoothstep (0.2, 0.5, dstObj / dstFar));\n      ws = ro.xz - sbPos.xz;\n      ws = Rot2D (ws, sbRot);\n      sh = 0.6 + 0.4 * smoothstep (-0.2, 0.8, length (ws -\n         vec2 (0., clamp (ws.y, - sbLen, sbLen))) -\n         1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, ws.y / sbLen)) *\n         (1. - 0.85 * smoothstep (0.6, 1.1, - ws.y / sbLen)));\n      col = col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, sunDir), 0.));\n      col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (- dstObj / dstFar));\n      col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      vno = vn;\n      col4 = NautColN (ro, vn);\n      sh = ObjSShadow (ro, vec3 (0., 1., 0.));\n      if (col4.a >= 0.) {\n        col = col4.rgb * (0.5 + 0.5 * sh * max (vn.y, 0.) + 0.2 * UnwCol (rd));\n        col *= vec3 (0.7, 0.9, 1.);\n      } else {\n        col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n      }\n    }\n    col += 0.2 * step (0.95, sh) * TurbLt (0.02 * ro, abs (vno), 0.2 * tCur) *\n       (1. - smoothstep (0.5, 0.8, dstObj / dstFar)) * smoothstep (-0.2, -0.1, vno.y);\n  } else {\n    col = UnwCol (rd) + WatShd (rd);\n  }\n  if (bmOn) {\n    lbDist = LBeamRay (rob[0], rdb[0]);\n    vnb = LBeamNf (rob[0] + lbDist.x * rdb[0]);\n    if (lbDist.x < min (dstObj, dstFar))\n       col = mix (col, vec3 (1., 1., 1.), 0.5 * (1. - lbDist.y) * (0.7 - 0.3 * dot (vnb, rd)));\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid ExMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 col, ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  uv = fCoord;\n  bmOn = true;\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  az = 0.;\n  el = 0.;\n  sbPos = vec3 (0., 0.09, 3. * tCur);\n  sbRot = 0.;\n  az += (msAz > -999.) ? msAz : 0.;\n  el += (msEl > -999.) ? msEl : 0.;\n  ro.xz = sbPos.xz + 24. * sin (0.01 * 2. * pi * tCur + vec2 (0., 0.5 * pi));\n  ro.y = -2.;\n  vd = sbPos - ro;\n  vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n  dstFar = 100.;\n  zmFac = 2.;\n  sunDir = normalize (vec3 (1., 3., -1.));\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  uv *= vec2 (9./16., 1./0.85);\n  col *= 1. - 0.8 * smoothstep (0.9, 1., length (uv));\n  fCol = col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n    msAz = 2. * pi * mPtr.x;\n    msEl = 0.5 * pi * mPtr.y;\n  }\n  if (abs (uv.y) < 0.85) ExMain (col, uv);\n  else col = vec3 (0.05);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 i, f, t1, t2;\n  i = floor (p);\n  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  t1 = Hashv4f (dot (i.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (i.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n               mix (mix (t2.x, t2.y, f.z), mix (t2.z, t2.w, f.z), f.w));\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVGDd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1229, 1229, 1252, 1252, 1494], [1496, 1496, 1530, 1530, 2009], [2011, 2011, 2033, 2033, 2172], [2174, 2174, 2199, 2199, 2578], [2580, 2580, 2624, 2624, 2818], [2820, 2820, 2844, 2844, 3175], [3177, 3177, 3217, 3217, 3677], [3679, 3679, 3702, 3702, 4122], [4124, 4124, 4147, 4147, 7028], [7030, 7030, 7052, 7052, 7212], [7214, 7214, 7247, 7247, 7430], [7432, 7432, 7453, 7453, 7708], [7710, 7710, 7747, 7747, 7988], [7990, 7990, 8013, 8013, 8349], [8351, 8351, 8385, 8385, 8607], [8609, 8609, 8632, 8632, 8891], [8893, 8893, 8932, 8932, 11570], [11572, 11572, 11607, 11607, 14022], [14024, 14024, 14069, 14069, 14822], [14824, 14824, 14880, 14880, 15353], [15355, 15355, 15388, 15388, 15477], [15479, 15479, 15525, 15525, 15572], [15574, 15574, 15607, 15607, 15634], [15636, 15636, 15678, 15678, 15729], [15731, 15731, 15790, 15790, 15921], [15923, 15923, 15976, 15976, 16037], [16039, 16039, 16061, 16061, 16099], [16101, 16101, 16137, 16137, 16343], [16345, 16345, 16390, 16390, 16493], [16495, 16495, 16552, 16552, 16635], [16637, 16637, 16667, 16667, 16780], [16814, 16814, 16838, 16838, 16891], [16893, 16893, 16917, 16917, 17047], [17049, 17049, 17073, 17073, 17136], [17138, 17138, 17162, 17162, 17382], [17384, 17384, 17409, 17409, 17595], [17597, 17597, 17622, 17622, 17847], [17849, 17849, 17874, 17874, 18195], [18197, 18197, 18222, 18222, 18368], [18370, 18370, 18392, 18392, 18546], [18548, 18548, 18569, 18569, 18724], [18726, 18726, 18747, 18747, 18902], [18904, 18904, 18933, 18933, 19145], [19147, 19147, 19186, 19186, 19371]], "test": "untested"}
{"id": "wtVGDd", "name": "camera controls, rotation", "author": "samhattangady", "description": "So day2, implemented a camera, and rotation of the camera. Output is super wonky, and it's not entirely clear as to exactly what is happeneing... Eh. Life.", "tags": ["camera", "rotation"], "likes": 0, "viewed": 369, "published": 3, "date": "1580229560", "time_retrieved": "2024-07-30T21:27:57.039368", "image_code": "/*\nday002: rotating camera\n28 Jan 2020\n\nSo day2, implemented a camera, and rotation of the camera.\nOutput is super wonky, and it's not entirely clear as to\nexactly what is happeneing... Eh. Life.\n\n*/\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\n\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\n\nfloat sdfPlane( vec3 position, vec4 n )\n{\n  // TODO (28 Jan 2020 sam): Figure out how this works.\n  // Currently, I'm just fiddling values till I get the result I want.\n  return dot(position,n.xyz) + n.w;\n}\n\nfloat distanceField(vec3 position) {\n\t// sphere 1\n    float d = sdfSphere(position, vec3(0.0, 0.0, 0.0), 0.55);\n    //return d;\n    vec2 moon = mat2(cos(iTime),-sin(iTime),sin(iTime),cos(iTime)) * vec2(1.0,0.0);\n    float d1 = sdfSphere(position, vec3(moon.x, 0.1, moon.y), 0.25);\n    float d2 = sdfPlane(position, vec4(0.0, 0.5, 0.0, 1.0));\n\n    return min(d2, min(d, d1));\n}\n\nvec3 calcNormal( vec3 p ) \n{\n    // We calculate the normal by finding the gradient of the field at the\n    // point that we are interested in. We can find the gradient by getting\n    // the difference in field at that point and a point slighttly away from it.\n    const float h = 0.0001;\n    return normalize( vec3(\n        \t\t\t       -distanceField(p)+ distanceField(p+vec3(h,0.0,0.0)),\n                           -distanceField(p)+ distanceField(p+vec3(0.0,h,0.0)),\n                           -distanceField(p)+ distanceField(p+vec3(0.0,0.0,h)) \n    \t\t\t\t ));\n}\n\nfloat raymarch( vec3 direction, vec3 start) {\n    // We need to cast out a ray in the given direction, and see which is\n    // the closest object that we hit. We then move forward by that distance,\n    // and continue the same process. We terminate when we hit an object\n    // (distance is very small) or at some predefined distance.\n    float far = 15.0;\n    float d = 0.0;\n    vec3 pos = start;\n    for (int i=0; i<100; i++) {\n    \tfloat sphereDistance = distanceField(pos);\n        pos += sphereDistance*direction;\n\n        d += sphereDistance;\n        if (sphereDistance < 0.01) {\n        \tbreak;\n        }\n        if (d > far) {\n        \tbreak;\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalise and set center to origin.\n    vec2 p = fragCoord/iResolution.xy;\n    p -= 0.5;\n    p.y *= iResolution.y/iResolution.x;\n    \n    vec3 cameraPosition = vec3(0.0, 0.0, -6.0);\n    //vec3 cameraOrientation = vec3(0.0, 0.0, 0.0);\n    vec3 planePosition = vec3(p, -5.0);\n    planePosition = rotate3D(planePosition, vec3(0.0, 0.0, iTime));\n    \n    vec3 lookingDirection = (planePosition - cameraPosition);\n    \n    // Rotate light around origin in xz plane\n    float angle = iTime;\n    vec2 lightPos2D = mat2(cos(angle),-sin(angle),sin(angle),cos(angle))*vec2(0.0,1.0); \n    vec3 lightPoint = normalize(vec3(1.0, 1.0, -1.0));\n    vec3 lightFacing = lightPoint - vec3(0.0);\n    \n    // raymarch to check for colissions.\n    float dist = raymarch(lookingDirection, planePosition);\n    vec3 color = vec3(0.1);\n    if (dist < 15.0) {\n        color = vec3(0.2, 0.2, 0.4);\n    \tvec3 normal = calcNormal(planePosition+ dist*lookingDirection);\n        color += 0.3*dot(lightFacing, normal);\n    }\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVGDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 200, 242, 242, 687], [689, 689, 748, 748, 798], [800, 800, 841, 968, 1006], [1008, 1008, 1044, 1057, 1384], [1386, 1386, 1414, 1646, 1948], [1950, 1950, 1995, 2284, 2632], [2634, 2634, 2691, 2734, 3725]], "test": "untested"}
{"id": "tlV3Wd", "name": "curvature blindness cubes", "author": "ahihi", "description": "👀", "tags": ["2d"], "likes": 1, "viewed": 270, "published": 3, "date": "1580225624", "time_retrieved": "2024-07-30T21:27:57.783378", "image_code": "#define TAU 6.283185307179586\n\nvec3 dark = vec3(0.27);\nvec3 mid = vec3(0.41);\nvec3 light = vec3(0.62);\n\nvec4 sine(vec2 k, float w, float t, vec2 p) {\n    float y = k.y * sin(k.x*p.x);\n    vec3 c = fract(k.x*(p.x+t)/TAU) < 0.5 ? light : dark;\n    return y - 0.5*w <= p.y && p.y <= y + 0.5*w ? vec4(c, 1.0) : vec4(0.0);\n}\n\nfloat map(float x, float l0, float r0, float l1, float r1) {\n\treturn (x - l0) / (r0 - l0) * (r1 - l1) + l1;\n}\n\nfloat imod(float x, float l, float r) {\n\treturn map(fract(map(x, l, r, 0.0, 1.0)), 0.0, 1.0, l, r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord/iResolution.xy*2.0 - 1.0)*vec2(1.0, iResolution.y/iResolution.x);\n   \tp = fragCoord * 0.005;\n    \n    float kt = 0.01*iTime;\n    vec2 sine_k = vec2(32.0, 0.013);\n    float dy = 0.1;\n    float w = 0.01;\n    float r = sine_k.y+w;\n    float l = -r;\n    float df = map(p.y + dy, l, r, 0.0, 1.0/3.0);\n    float d = floor(df);\n    float dir = mod(d, 2.0) < 1.0 ? 1.0 : -1.0;\n    float o = d * TAU * (dir >= 0.0 ? 0.5 : 0.0) / sine_k.x;\n    vec2 kp = vec2(kt * dir, dy);\n    vec2 p1 = p + kp;\n    p1.x += o;\n    p1.y = imod(p1.y, l, r); \n\n    vec3 bg = mid;\n    vec3 color = bg;\n    vec4 sine_color = sine(sine_k, w, -kt * dir + (dir >= 0.0 ? 0.5*TAU/sine_k.x : 0.0), p1);\n    color = mix(color, sine_color.rgb, sine_color.a);     \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlV3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 149, 149, 319], [321, 321, 381, 381, 430], [432, 432, 471, 471, 533], [535, 535, 592, 592, 1381]], "test": "untested"}
{"id": "Wt33Wf", "name": "Cyber Fuji 2020", "author": "kaiware007", "description": "A Happy New Yeahhhhhhhhhhhhhhhhhh!!!!!!!!!!!!!", "tags": ["sun", "80s", "retro", "fuji", "cineshader"], "likes": 480, "viewed": 457877, "published": 3, "date": "1580223238", "time_retrieved": "2024-07-30T21:27:58.530381", "image_code": "\nfloat sun(vec2 uv, float battery)\n{\n \tfloat val = smoothstep(0.3, 0.29, length(uv));\n \tfloat bloom = smoothstep(0.7, 0.0, length(uv));\n    float cut = 3.0 * sin((uv.y + iTime * 0.2 * (battery + 0.02)) * 100.0) \n\t\t\t\t+ clamp(uv.y * 14.0 + 1.0, -6.0, 6.0);\n    cut = clamp(cut, 0.0, 1.0);\n    return clamp(val * cut, 0.0, 1.0) + bloom * 0.6;\n}\n\nfloat grid(vec2 uv, float battery)\n{\n    vec2 size = vec2(uv.y, uv.y * uv.y * 0.2) * 0.01;\n    uv += vec2(0.0, iTime * 4.0 * (battery + 0.05));\n    uv = abs(fract(uv) - 0.5);\n \tvec2 lines = smoothstep(size, vec2(0.0), uv);\n \tlines += smoothstep(size * 5.0, vec2(0.0), uv) * 0.4 * battery;\n    return clamp(lines.x + lines.y, 0.0, 3.0);\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k){\n\tfloat h = clamp(0.5 + 0.5 * (d2 - d1) /k,0.0,1.0);\n    return mix(d2, d1 , h) - k * h * ( 1.0 - h);\n}\n\nfloat sdCloud(in vec2 p, in vec2 a1, in vec2 b1, in vec2 a2, in vec2 b2, float w)\n{\n\t//float lineVal1 = smoothstep(w - 0.0001, w, sdLine(p, a1, b1));\n    float lineVal1 = sdLine(p, a1, b1);\n    float lineVal2 = sdLine(p, a2, b2);\n    vec2 ww = vec2(w*1.5, 0.0);\n    vec2 left = max(a1 + ww, a2 + ww);\n    vec2 right = min(b1 - ww, b2 - ww);\n    vec2 boxCenter = (left + right) * 0.5;\n    //float boxW = right.x - left.x;\n    float boxH = abs(a2.y - a1.y) * 0.5;\n    //float boxVal = sdBox(p - boxCenter, vec2(boxW, boxH)) + w;\n    float boxVal = sdBox(p - boxCenter, vec2(0.04, boxH)) + w;\n    \n    float uniVal1 = opSmoothUnion(lineVal1, boxVal, 0.05);\n    float uniVal2 = opSmoothUnion(lineVal2, boxVal, 0.05);\n    \n    return min(uniVal1, uniVal2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n    float battery = 1.0;\n    //if (iMouse.x > 1.0 && iMouse.y > 1.0) battery = iMouse.y / iResolution.y;\n    //else battery = 0.8;\n    \n    //if (abs(uv.x) < (9.0 / 16.0))\n    {\n        // Grid\n        float fog = smoothstep(0.1, -0.02, abs(uv.y + 0.2));\n        vec3 col = vec3(0.0, 0.1, 0.2);\n        if (uv.y < -0.2)\n        {\n            uv.y = 3.0 / (abs(uv.y + 0.2) + 0.05);\n            uv.x *= uv.y * 1.0;\n            float gridVal = grid(uv, battery);\n            col = mix(col, vec3(1.0, 0.5, 1.0), gridVal);\n        }\n        else\n        {\n            float fujiD = min(uv.y * 4.5 - 0.5, 1.0);\n            uv.y -= battery * 1.1 - 0.51;\n            \n            vec2 sunUV = uv;\n            vec2 fujiUV = uv;\n            \n            // Sun\n            sunUV += vec2(0.75, 0.2);\n            //uv.y -= 1.1 - 0.51;\n            col = vec3(1.0, 0.2, 1.0);\n            float sunVal = sun(sunUV, battery);\n            \n            col = mix(col, vec3(1.0, 0.4, 0.1), sunUV.y * 2.0 + 0.2);\n            col = mix(vec3(0.0, 0.0, 0.0), col, sunVal);\n            \n            // fuji\n            float fujiVal = sdTrapezoid( uv  + vec2(-0.75+sunUV.y * 0.0, 0.5), 1.75 + pow(uv.y * uv.y, 2.1), 0.2, 0.5);\n            float waveVal = uv.y + sin(uv.x * 20.0 + iTime * 2.0) * 0.05 + 0.2;\n            float wave_width = smoothstep(0.0,0.01,(waveVal));\n            \n            // fuji color\n            col = mix( col, mix(vec3(0.0, 0.0, 0.25), vec3(1.0, 0.0, 0.5), fujiD), step(fujiVal, 0.0));\n            // fuji top snow\n            col = mix( col, vec3(1.0, 0.5, 1.0), wave_width * step(fujiVal, 0.0));\n            // fuji outline\n            col = mix( col, vec3(1.0, 0.5, 1.0), 1.0-smoothstep(0.0,0.01,abs(fujiVal)) );\n            //col = mix( col, vec3(1.0, 1.0, 1.0), 1.0-smoothstep(0.03,0.04,abs(fujiVal)) );\n            //col = vec3(1.0, 1.0, 1.0) *(1.0-smoothstep(0.03,0.04,abs(fujiVal)));\n            \n            // horizon color\n            col += mix( col, mix(vec3(1.0, 0.12, 0.8), vec3(0.0, 0.0, 0.2), clamp(uv.y * 3.5 + 3.0, 0.0, 1.0)), step(0.0, fujiVal) );\n            \n            // cloud\n            vec2 cloudUV = uv;\n            cloudUV.x = mod(cloudUV.x + iTime * 0.1, 4.0) - 2.0;\n            float cloudTime = iTime * 0.5;\n            float cloudY = -0.5;\n            float cloudVal1 = sdCloud(cloudUV, \n                                     vec2(0.1 + sin(cloudTime + 140.5)*0.1,cloudY), \n                                     vec2(1.05 + cos(cloudTime * 0.9 - 36.56) * 0.1, cloudY), \n                                     vec2(0.2 + cos(cloudTime * 0.867 + 387.165) * 0.1,0.25+cloudY), \n                                     vec2(0.5 + cos(cloudTime * 0.9675 - 15.162) * 0.09, 0.25+cloudY), 0.075);\n            cloudY = -0.6;\n            float cloudVal2 = sdCloud(cloudUV, \n                                     vec2(-0.9 + cos(cloudTime * 1.02 + 541.75) * 0.1,cloudY), \n                                     vec2(-0.5 + sin(cloudTime * 0.9 - 316.56) * 0.1, cloudY), \n                                     vec2(-1.5 + cos(cloudTime * 0.867 + 37.165) * 0.1,0.25+cloudY), \n                                     vec2(-0.6 + sin(cloudTime * 0.9675 + 665.162) * 0.09, 0.25+cloudY), 0.075);\n            \n            float cloudVal = min(cloudVal1, cloudVal2);\n            \n            //col = mix(col, vec3(1.0,1.0,0.0), smoothstep(0.0751, 0.075, cloudVal));\n            col = mix(col, vec3(0.0, 0.0, 0.2), 1.0 - smoothstep(0.075 - 0.0001, 0.075, cloudVal));\n            col += vec3(1.0, 1.0, 1.0)*(1.0 - smoothstep(0.0,0.01,abs(cloudVal - 0.075)));\n        }\n\n        col += fog * fog * fog;\n        col = mix(vec3(col.r, col.r, col.r) * 0.5, col, battery * 0.7);\n\n        fragColor = vec4(col,1.0);\n    }\n    //else fragColor = vec4(0.0);\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt33Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 36, 341], [343, 343, 379, 379, 680], [682, 682, 706, 706, 725], [727, 727, 792, 792, 1102], [1104, 1104, 1153, 1153, 1272], [1274, 1274, 1311, 1311, 1395], [1397, 1397, 1446, 1446, 1549], [1551, 1551, 1634, 1700, 2304], [2306, 2306, 2363, 2363, 6188]], "test": "untested"}
{"id": "ttV3Dt", "name": "Tokamak", "author": "lucasassone", "description": "Inside the Tokamak, use mouse (with button pressed) to look around", "tags": ["raymarching", "mouse"], "likes": 4, "viewed": 492, "published": 3, "date": "1580222789", "time_retrieved": "2024-07-30T21:27:59.367143", "image_code": "\nvec3 rotate(vec3 p, float angle, vec3 axis){\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\ta.x * a.x * r + c,\n\t\ta.y * a.x * r + a.z * s,\n\t\ta.z * a.x * r - a.y * s,\n\t\ta.x * a.y * r - a.z * s,\n\t\ta.y * a.y * r + c,\n\t\ta.z * a.y * r + a.x * s,\n\t\ta.x * a.z * r + a.y * s,\n\t\ta.y * a.z * r - a.x * s,\n\t\ta.z * a.z * r + c\n\t);\n\treturn m * p;\n}\n\nconst float THRESHOLD = 0.0001;\nconst float maiorRadius = 5.0;\nconst float minorRadius = 3.0;\n\n// --------------------------------------------------------------------------\n\n// distance estimators\nfloat torusDist(vec3 p) {\n\tfloat f1 = min(abs(0.3 * sin(10.0 * atan(p.z, p.x))), 0.1);\n\tvec2 uv = vec2(-atan(p.z, p.x), atan(p.y, length(p.xz) - maiorRadius)) / 2.0 / 3.141592 + 0.5;\n\tfloat f2 = max(sin(200. * uv.x) * sin(200. * uv.y) - 0.95, 0.0);\n\tfloat dis1 = minorRadius - (f1 + f2) - length(vec2(length(p.xz) - maiorRadius, p.y));\n\treturn dis1;\n}\n\nfloat tubesDist(vec3 p) {\n\tfloat d1 = length(vec2(length(p.xz) - (maiorRadius + minorRadius - 0.5), p.y - 1.3)) - 0.2;\n\tfloat d2 = length(vec2(length(p.xz) - (maiorRadius + minorRadius - 0.5), p.y + 1.3)) - 0.2;\n\tfloat d3 = length(vec2(length(p.xz) - (maiorRadius - minorRadius + 0.6), p.y + 1.5)) - 0.2;\n\tfloat d4 = length(vec2(length(p.xz) - (maiorRadius - minorRadius + 1.0), p.y + 2.0)) - 0.2;\n\treturn min(min(d1, d2), min(d3, d4));\n}\n\nfloat floorDist(vec3 p) {\n\treturn p.y + 2.7;\n}\n\nfloat ceilDist(vec3 p) {\n\tfloat f = max(sin(10. * atan(p.z, p.x)) - 0.6, 0.0);\n\tfloat d1 = length(vec2(length(p.xz) - maiorRadius + 1.0, p.y - minorRadius - 2.0)) - 2.5 - f;\n\tfloat d2 = length(vec2(length(p.xz) - maiorRadius - 1.0, p.y - minorRadius - 2.0)) - 2.5 - f;\n\treturn min(d1, d2);\n}\n\nfloat protonsDist(vec3 p) {\n\tvec3 p1 = rotate(p, 10.0 * iTime, vec3(0., 1., 0.));\n\tfloat d1 = length(vec2(length(p1.xz) - maiorRadius, p1.y + 0.0)) - 0.1 * (sin(0.5 * atan(p1.z, p1.x)) + 1.0);\n\treturn d1;\n}\n\nfloat sceneDist(vec3 p) {\n\tfloat v = min(min(torusDist(p), tubesDist(p)), min(floorDist(p), ceilDist(p)));\n\treturn min(v, protonsDist(p));\n}\n\n// --------------------------------------------------------------------------\n\nvec3 torusColor(vec3 p) {\n\treturn vec3(0.9, 0.9, 1.0);\n}\n\nvec3 floorColor(vec3 p) {\n\treturn vec3(max(sin(50.0 * p.x) - 0.5, 0.0) + max(sin(50.0 * p.z) - 0.5, 0.0));\n}\n\nvec3 ceilColor(vec3 p) {\n\treturn vec3(0.9, 0.9, 1.0);\n}\n\nvec3 tubesColor(vec3 p) {\n\treturn vec3(0.8, 0.9, 1.0);\n}\n    \n// --------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ( gl_FragCoord.xy * 2. - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\tvec2 mo = iMouse.xy / iResolution.xy - 0.5;\n\n\tvec3 cameraPos = vec3(0., -0.5, -7.);\n\tfloat screenZ = 2.0;\n\tvec3 rayDirection = normalize(vec3(p, screenZ));\n\n\trayDirection = rotate(rayDirection, -0.05, vec3(0., 0., 1.));\n\n\trayDirection = rotate(rayDirection, 2. * mo.x, vec3(0., 1., 0.));\n\trayDirection = rotate(rayDirection, 2. * mo.y, vec3(1., 0., 0.));\n\n\tcameraPos = rotate(cameraPos, iTime, vec3(0., 1., 0.));\n\trayDirection = rotate(rayDirection, iTime, vec3(0., 1., 0.));\n\n\tfloat depth = 0.0;\n\tvec3 col = vec3(1.0);\n\tvec3 rayPos;\n\n\t// ray marching\n\tint i = 0;\n\tfor (i = 0; i < 99; i++) {\n\t\trayPos = cameraPos + rayDirection * depth;\n\t\tfloat dist = sceneDist(rayPos);\n\t\tif (dist < THRESHOLD) {\n\t\t\tif      (torusDist(rayPos) < THRESHOLD) col = torusColor(rayPos);\n\t\t\telse if (floorDist(rayPos) < THRESHOLD) col = floorColor(rayPos);\n\t\t\telse if (ceilDist(rayPos)  < THRESHOLD) col = ceilColor(rayPos);\n\t\t\telse if (tubesDist(rayPos) < THRESHOLD) col = tubesColor(rayPos);\n\t\t\tif (protonsDist(rayPos) < THRESHOLD) col = vec3(100.0);\n\t\t\tbreak;\n\t\t}\n\t\tdepth += dist;\n\t}\n\n\tcol = col * (1.6 / (1.0 + 0.1 * depth)); // scurisce con la profondita'\n\tcol = 0.1 * col * max(0.3 * float(i), 1.0); // effetto aura (schiarisce all'aumentare di i)\n    col = mix(col, vec3(0.6, 0.5, 1.0), max(1.0 - minorRadius - rayPos.y, 0.0));\n\n\t// luce rossa lampeggiante\n\tfloat f = sin(6. * iTime) * 0.3 + 0.3;\n\tcol = col * vec3(1., 1. - f, 1. - f);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttV3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 45, 45, 399], [575, 598, 623, 623, 949], [951, 951, 976, 976, 1389], [1391, 1391, 1416, 1416, 1437], [1439, 1439, 1463, 1463, 1730], [1732, 1732, 1759, 1759, 1938], [1940, 1940, 1965, 1965, 2080], [2161, 2161, 2186, 2186, 2217], [2219, 2219, 2244, 2244, 2327], [2329, 2329, 2353, 2353, 2384], [2386, 2386, 2411, 2411, 2442], [2527, 2527, 2584, 2584, 4157]], "test": "untested"}
{"id": "tlVGDt", "name": "Octagrams", "author": "whisky_shusuky", "description": "Inspired by arabesque.\nhttps://cineshader.com/editor", "tags": ["raymarching", "cineshader"], "likes": 455, "viewed": 353201, "published": 3, "date": "1580222118", "time_retrieved": "2024-07-30T21:28:00.377442", "image_code": "precision highp float;\n\n\nfloat gTime = 0.;\nconst float REPEAT = 5.0;\n\n// 回転行列\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box(vec3 pos, float scale) {\n\tpos *= scale;\n\tfloat base = sdBox(pos, vec3(.4,.4,.1)) /1.5;\n\tpos.xy *= 5.;\n\tpos.y -= 3.5;\n\tpos.xy *= rot(.75);\n\tfloat result = -base;\n\treturn result;\n}\n\nfloat box_set(vec3 pos, float iTime) {\n\tvec3 pos_origin = pos;\n\tpos = pos_origin;\n\tpos .y += sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box1 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n\tpos = pos_origin;\n\tpos .y -=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box2 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n\tpos = pos_origin;\n\tpos .x +=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box3 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n\tpos = pos_origin;\n\tpos .x -=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box4 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n\tpos = pos_origin;\n\tpos.xy *=   rot(.8);\n\tfloat box5 = box(pos,.5) * 6.;\t\n\tpos = pos_origin;\n\tfloat box6 = box(pos,.5) * 6.;\t\n\tfloat result = max(max(max(max(max(box1,box2),box3),box4),box5),box6);\n\treturn result;\n}\n\nfloat map(vec3 pos, float iTime) {\n\tvec3 pos_origin = pos;\n\tfloat box_set1 = box_set(pos, iTime);\n\n\treturn box_set1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 ro = vec3(0., -0.2 ,iTime * 4.);\n\tvec3 ray = normalize(vec3(p, 1.5));\n\tray.xy = ray.xy * rot(sin(iTime * .03) * 5.);\n\tray.yz = ray.yz * rot(sin(iTime * .05) * .2);\n\tfloat t = 0.1;\n\tvec3 col = vec3(0.);\n\tfloat ac = 0.0;\n\n\n\tfor (int i = 0; i < 99; i++){\n\t\tvec3 pos = ro + ray * t;\n\t\tpos = mod(pos-2., 4.) -2.;\n\t\tgTime = iTime -float(i) * 0.01;\n\t\t\n\t\tfloat d = map(pos, iTime);\n\n\t\td = max(abs(d), 0.01);\n\t\tac += exp(-d*23.);\n\n\t\tt += d* 0.55;\n\t}\n\n\tcol = vec3(ac * 0.02);\n\n\tcol +=vec3(0.,0.2 * abs(sin(iTime)),0.5 + sin(iTime) * 0.2);\n\n\n\tfragColor = vec4(col ,1.0 - t * (0.02 + 0.02 * sin (iTime)));\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Octgrams\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 86, 105, 105, 162], [164, 164, 195, 195, 280], [282, 282, 316, 316, 470], [472, 472, 510, 510, 1281], [1283, 1283, 1317, 1317, 1401], [1404, 1404, 1461, 1461, 2147]], "test": "untested"}
{"id": "wlKGDt", "name": "JuliaLand", "author": "lucasassone", "description": "A Julia fractal landscape with raymarching", "tags": ["raymarching", "fractal", "julia", "landscape"], "likes": 3, "viewed": 343, "published": 3, "date": "1580220762", "time_retrieved": "2024-07-30T21:28:01.281027", "image_code": "\nint julia(vec2 c, vec2 z) {\n\tz.y = mod(z.y + 0.9, 1.8) - 0.9;\n\tint counter = 0;\n\twhile(counter < 600) {\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n\t\tif (length(z) > 2.) break;\n\t\tcounter++;\n\t}\n\treturn counter;\n}\n\nvec3 skycol(int counter) {\n\tfloat val = 2.0 * log(float(counter + 3)) - 3.891 - 1.570;\n\tfloat red = sin(0.5 * val) * 0.20 + 0.80;\n\tfloat gre = sin(0.5 * val) * 0.20 + 0.80;\n\tfloat blu = sin(0.5 * val) * 0.10 + 0.90;\n\treturn vec3(red, gre, blu);\n}\n\nvec3 gndcol(int counter) {\n\tfloat val = 2.0 * log(float(counter + 3)) - 3.891 - 1.570;\n\tfloat red = sin(1.3 * val) * 0.250 + 0.350;\n\tfloat gre = sin(1.1 * val) * 0.282 + 0.518;\n\tfloat blu = sin(1.0 * val) * 0.694 + 0.306;\n\treturn vec3(red, gre, blu) * (0.8 + 0.3 * sin(0.1 * float(counter)));\n}\n\n\nconst vec3 camera = vec3(0.0, 0.3, 0.6);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y) + vec2(0.0, 0.5);\n\n\tfloat den = camera.z / (camera.z - uv.y);\n\tvec2 r = 0.02 * vec2(uv.x * den, camera.y * abs(den));\n\n\tint counter;\n\tvec3 color;\n\tfloat t2 = 0.080 * iTime;\n\tfloat t3 = 0.004 * iTime;\n\n\tif(den > 0.0) {\n\t\tcounter = julia(vec2(-0.8, 0.156), r + vec2(0.0, t2));\n\t\tcolor = gndcol(counter);\n\t\tif (counter < 100) {\n\t\t\tint counter0 = julia(vec2(-0.8, 0.156), vec2(-r.x, r.y + 0.9 + t3));\n\t\t\tcolor = mix(0.7 * skycol(counter0), color, float(counter) / 100.0);\n\t\t}\n\t} else {\n\t\tcounter = julia(vec2(-0.8, 0.156), r + vec2(0.0, 0.9 + t3));\n\t\tcolor = skycol(counter);\n\t}\n    \n    // postprocessing\n    // fog\n    float fog = 0.9 * fract(r.y / (r.y + 0.04));\n    color = mix(color, vec3(1.00, 0.90, 0.70), fog);\n    // vignette\n    color *= cos(uv.x) * cos(2.0 * (uv.y - 0.5)) + 0.2;\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 224], [226, 226, 252, 252, 472], [474, 474, 500, 500, 768], [813, 813, 870, 870, 1809]], "test": "untested"}
{"id": "ttKGDt", "name": "Phantom Star for CineShader", "author": "kasari39", "description": "https://cineshader.com/view/ttKGDt", "tags": ["raymarching", "ifs", "phantommode"], "likes": 465, "viewed": 278220, "published": 3, "date": "1580219576", "time_retrieved": "2024-07-30T21:28:02.340195", "image_code": "precision highp float;\n\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=0; i<5; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 16.)-8.;\n    p1.xy = pmod(p1.xy, 5.0);\n    return ifsBox(p1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);\n    // vec3 cPos = vec3(0.3*sin(iTime*0.8), 0.4*cos(iTime*0.3), -6.0 * iTime);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp  = vec3(sin(iTime), 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    // Phantom Mode https://www.shadertoy.com/view/MtScWW by aiekick\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist*3.0);\n        if (mod(length(pos)+24.0*iTime, 30.0) < 3.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a;\n        t += dist * 0.5;\n    }\n\n    vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2*0.002, acc * 0.012+ acc2*0.005);\n    fragColor = vec4(col, 1.0 - t * 0.03);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 107], [165, 165, 193, 193, 299], [301, 301, 330, 330, 421], [423, 423, 445, 445, 635], [637, 637, 667, 667, 839], [841, 841, 898, 898, 1897]], "test": "untested"}
{"id": "3tG3Rm", "name": "Dimensional clock", "author": "nodo", "description": "https://cineshader.com/view/3tG3Rm", "tags": ["volume", "raymarch"], "likes": 5, "viewed": 16969, "published": 3, "date": "1580216545", "time_retrieved": "2024-07-30T21:28:03.309603", "image_code": "precision highp float;\n\n#define Time floor(iTime)*30.0\n\nconst float pi = acos(-1.);\nconst float pi2 = pi*2.;\nfloat pmodid;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 4378.553);\n}\n\n///\n/// Noise function\n///\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n\n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\n\nfloat rand(vec2 co){\n    float a = 52.9498;\n    float b = 48.213;\n    float c = 438.5453;\n    float dt= dot(co.xy ,vec2(a,b));\n    float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n///\n/// Fractal Brownian motion.\n///\n/// Refer to:\n/// EN: https://thebookofshaders.com/13/\n/// JP: https://thebookofshaders.com/13/?lan=jp\n///\nfloat fbm(vec3 p)\n{\n    float f;\n    f  = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\nvec3 hsv(float h, float s, float v) {\n\tvec3 a = fract(h+vec3(0.,2.,1.)/3.)*6.-3.;\n\ta = clamp(abs(a)-1.,0.,1.)-1.;\n\ta = a*s +1.;\n\treturn a*v;\n}\n\nmat2 rot(float t){\n    float s = sin(t),c = cos(t);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    float n = pi2 / r;\n    pmodid = floor(a / n);\n    a = pmodid * n;\n    return p * rot(-a);\n}\n\nvec2 opI(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? d2 : d1;\n}\n\nvec2 map(vec3 p){\n        \n    vec3 bp = p;    \n    vec3 pp = p;\n \n    float period = 5.0;\n    float v = floor(iTime/period)*period+smoothstep(0.2, 0.8,mod(iTime,period));\n    p.xz *= rot(pi*v);\n    \n    float period2 = 8.0;\n    v = floor(iTime/period2)*period2+smoothstep(0.2, 0.8,mod(iTime,period2));\n    p.yz *= rot(pi*v*2.0);\n    \n    \n    float f = fbm(bp * 0.2+iTime+0.001);\n    \n\n    bp.xy = pmod(bp.xy,40.0);\n  \n\n    bp.y -= 30.0;\n    vec2 bd = vec2(0.1 - length(bp) * 0.1+f*0.6,1.0);\n\n\n    for(int i = 0; i < 2;i++){\n        bp.y -= 6.0;\n\n        bp.xy *= rot(pi/20.0*float(i));\n    \tbd = opI(bd,vec2(0.1 - length(bp) * 0.1+f*0.6,1.0));\n    }\n    \n    \n    vec3 lp = p;\n    lp.xy *= rot(-Time/60.0);  \n    float f2 = fbm(lp * 0.1+iTime);\n    \n    \n    lp.y -= 10.;\n    vec2 longhand = vec2(0.1 - length(lp*vec3(1.5,0.3,1.0)) * 0.1 +f2,3.0);\n    \n    \n    vec3 sp = p;  \n    sp.xy *= rot(-Time/720.0);   \n    sp.y -= 6.;\n    vec2 shorthand = vec2(0.1 - length(sp*vec3(1.5,0.5,1.0)) * 0.1 +f2,3.0);\n    \n    \n    \n    p.xy = pmod(p.xy,12.0);\n    p.y -= 23.0;\n    vec2 dial = vec2(0.1 - length(p) * 0.1 + f*0.5,2.0);\n    \n    pmod(pp.xy,40.0);\n    \n    //return opI(opI(shorthand,longhand),bd);\n    return opI(opI(dial,opI(shorthand,longhand)),bd);\n}\n\n\n//https://www.shadertoy.com/view/WslGWl\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 ro = vec3(0.0,0.0,-45.0);\n    float screenZ = 1.0;\n    vec3 rd = normalize(vec3(uv,screenZ));\n\n    \n    // For raymarching const values.\n    const int sampleCount = 34;\n    const int sampleLightCount = 2;\n    const float eps = 0.01;\n    \n    // Raymarching step settings.\n    float zMax = 65.0;\n    float zstep = zMax / float(sampleCount);\n    \n    float zMaxl = 20.0;\n    float zstepl = zMaxl / float(sampleLightCount);\n    \n    // Easy access to the ray origin\n    vec3 p = ro;\n    \n    // Transmittance\n    float T = 1.0;\n    \n    // Substantially transparency parameter.\n    float absorption = 60.0;\n    \n    // Light Direction\n    vec3 sun_direction = normalize(vec3(1.0, 0.0, 0.0));\n    \n    vec4 col = vec4(0.0);\n    \n    vec2 mat;\n    \n    \n    for (int i = 0; i < sampleCount; i++)\n    {\n\n        \n        mat = map(p);\n        float density = mat.x;\n        \n        if (density > 0.0)\n        {\n\n            float tmp = density / float(sampleCount);\n            \n            T *= 1.0 - (tmp * absorption);\n            \n            if (T <= 0.01)\n            {\n                break;\n            }\n            \n            float Tl = 1.0;\n\n            vec3 lp = p;\n            \n            for (int j = 0; j < sampleLightCount; j++)\n            {\n                float densityLight = map(lp).x;\n                \n                if (densityLight > 0.0)\n                {\n                    float tmpl = densityLight / float(sampleCount);\n                    Tl *= 1.0 - (tmpl * absorption);\n                }\n                \n                if (Tl <= 0.01)\n                {\n                    break;\n                }\n                \n                lp += sun_direction * zstepl;\n            }\n            \n            float opaity = 50.0;\n            float k = opaity * tmp * T;            \n            \n            vec4 cloudColor = vec4(vec3(0.01,0.11,0.5),1.0);\n            \n            if(mat.y == 1.0){\n                cloudColor.rgb = hsv(pmodid/40.0,1.,1.5);           \n            }else if(mat.y == 3.0){\n                cloudColor.rgb = vec3(.0,.8,.9); \n                         \n            }else{\n                pmod(p.xy,12.0);\n                cloudColor.rgb = hsv(pmodid/12.0,1.0,1.8);                   \n            }\n            \n            vec4 col1 = cloudColor * k;\n                       \n            float opacityl = 30.0;\n            float kl = opacityl * tmp * T * Tl;\n            vec4 lightColor = vec4(.0, 0., .1, 1.0);\n            vec4 col2 = lightColor * kl;\n            \n            col += col1 + col2*3.0;\n        }\n        \n        p += rd * zstep;\n    }\n    \n    col.a *= 0.5;\n    \n    if(col.a == 0.0){\n        col.rgb = vec3(0.0);\n    }\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tG3Rm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 252, 252, 291], [293, 320, 344, 344, 780], [783, 783, 803, 803, 970], [972, 1116, 1135, 1135, 1284], [1286, 1286, 1323, 1323, 1428], [1430, 1430, 1448, 1448, 1510], [1512, 1512, 1540, 1540, 1675], [1677, 1677, 1705, 1705, 1741], [1743, 1743, 1760, 1760, 2999], [3043, 3043, 3100, 3100, 5932]], "test": "untested"}
{"id": "ttK3Wt", "name": "Sponge Tunnel", "author": "hatuxes", "description": "Simple Menger.", "tags": ["cineshadermengerspongeraymarching"], "likes": 15, "viewed": 27581, "published": 3, "date": "1580216516", "time_retrieved": "2024-07-30T21:28:04.306936", "image_code": "const float pi=acos(-1.0);\nconst float pi2=pi*2.0;\n\nmat2 rot(float a){\n    float c=cos(a), s=sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 pmod(vec2 p, float r){\n    float a=atan(p.x, p.y)+pi/r;\n    float n=pi2*(-sin(0.42*iTime)*sin(0.42*iTime)+0.35)/r;\n    a=floor(a/n)*n-pi;\n    return p*rot(-a);\n}\n\nfloat crossf(vec3 p, float r){\n    p=abs(p);\n    float dxy=max(p.x, p.y);\n    float dyz=max(p.y, p.z);\n    float dxz=max(p.z, p.x);\n    return min(dxy, min(dyz, dxz))-r;\n}\n\nfloat boxf(vec3 p, vec3 b){\n    p=abs(p)-b;\n    return length(max(p, 0.0))+min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\n\nfloat mengersponge(vec3 p, float scale, float width){\n    float d=boxf(p, vec3(1.0));\n    float s=1.0;\n    for(int i=0; i<5; i++){\n        vec3 a=mod(p*s, 2.0)-1.0;\n        s*=scale;\n        vec3 r=1.0-scale*abs(a);\n        float c=crossf(r, width)/s;\n        d=max(d,c);\n    }\n    return d;\n}\n\nfloat map(vec3 p){\n    p=mod(p, 4.0)-2.0;\n    return mengersponge(p, 3.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 ro=vec3(0.0, 0.0, 8.0*iTime);\n    vec3 rd=normalize(vec3(uv, 0.8*sin(0.58*iTime)));\n    vec3 col=vec3(0);\n    float dp=0.0, dpp=0.0;\n    for(int i=0; i<99; i++){\n        vec3 pos=ro+rd*dp;\n        pos.xy*=rot(0.1*iTime);\n        pos.xy=pmod(pos.xy, 8.0);\n        float d=map(pos);\n        if(d<0.00001){\n            col=vec3(1.0-float(i)*0.02);\n            break;\n        }\n        dp+=d*0.8;\n        dpp=d*75.516;\n    }\n    fragColor=vec4(col, dpp);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttK3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 70, 70, 132], [134, 134, 161, 161, 300], [302, 302, 332, 332, 473], [475, 475, 502, 502, 586], [589, 589, 642, 642, 882], [884, 884, 902, 902, 965], [967, 967, 1024, 1024, 1567]], "test": "untested"}
{"id": "WtK3Dt", "name": "Fireworks send", "author": "aethelwhat", "description": "Voronoi particle tracking learned from a variety of Wyatt's shaders. I want to track particle lifetime, color, type (for multiple firework types) separately so i tried syncing a second buffer that also sorts on the position xy in buffer a. Next time", "tags": ["fireworks", "voronoiparticles"], "likes": 18, "viewed": 826, "published": 3, "date": "1580188320", "time_retrieved": "2024-07-30T21:28:05.095827", "image_code": "/* see description\n * click and drag I dare u\n * i'll fix full screen and other resolutions next time\n */\n\nvoid mainImage( out vec4 Q, in vec2 U)\n{\n\n    vec4 a = A(U);\n    vec4 b = B(U);\n    vec4 color = vec4(1.0);\n    Q = smoothstep(1.,0.,length(a.xy-U))*(.2+2.*COLOR);\n\n    Q += vec4(1.0)-B(U) * .9;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Buffer A\n//swap and Voronoi particle tracking learned from user Wyatt on Shadertoy.\nvoid swap (inout vec4 a, vec2 U, vec2 r) {\n    vec4 n = A(U+r);\n    if (length(U-n.xy)<length(U-a.xy)){\n        a = n;\n    }\n}\n\nvoid mainImage( out vec4 Q, in vec2 U)\n{\n    // FIND NEAREST PARTICLE\n    vec4 a = A(U);\n    swap(a,U,vec2(1,0));\n    swap(a,U,vec2(0,1));\n    swap(a,U,vec2(-1,0));\n    swap(a,U,vec2(0,-1));\n\n    Q = a;\n    Q.w -= .005;\n    Q.xy += Q.zw;\n    Q.zw *= AIR;\n\n    if(length(Q.zw) < 0.001){ // firework explodes\n      \tQ.zw = normalize(U - Q.xy);//* VELOCITY;\n        Q.xy = Q.xy + Q.zw;\n    }\n\n    // Creating particles per frame\n    float randomX = iResolution.x * rand(float(iFrame)); \n    vec2 pos = vec2(randomX * 6., 1.);\n    if (length(U-pos)<length(U-a.xy)){// && iTime < 1.){\n      Q = vec4(pos, 0., 2. + rand(iTime)*1.5);\n    }\n    \n    // Click to paint in color\n    if ((iMouse.z>0.&&length(iMouse.xy-U)<1.)) {\n        Q = vec4(U, 0., 1.);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Buffer B\n//fade the smoke blown by wind\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec4 a = A(U);\n    //U -= .5*a.xy;\n    Q = B(U);\n    vec4\n        n = B(U+vec2(0,1)),\n        e = B(U+vec2(1,0)),\n        s = B(U-vec2(0,1)),\n        w = B(U-vec2(1,0));\n    Q = mix(Q,0.2*n+.8*w,.02*vec4(2,4,6,5));\n    Q = mix(Q,vec4(1.),0.001);\n    vec4 h = vec4(0.);\n    Q += .1*(h-Q)*smoothstep(1.,0.,length(a.xy-U));\n\n    if (iFrame < 1) Q = vec4(1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Common\n#define R iResolution.xy\n#define A(U) texture(iChannel0, (U)/R)\n#define B(U) texture(iChannel1, (U)/R)\n\n#define AIR .99\n#define VELOCITY 119.8\n#define FADE 1.\n#define TRAIL_FACTOR 1.3\n#define LIFETIME 1.\n#define COLOR vec4(1.,.8,.9,1.)\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 147, 147, 308]], "test": "untested"}
{"id": "WlKGDt", "name": "Four Planets With Moons", "author": "timF", "description": "Weird looking moons spinning around planets. This is only my second real shader and realize this was not done efficiently, but don't know how to do it better!\nI still am learning how to add colors.", "tags": ["raymarching"], "likes": 1, "viewed": 279, "published": 3, "date": "1580183934", "time_retrieved": "2024-07-30T21:28:05.972483", "image_code": "#define MAX_STEPS 30.0\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 100.0\n#define PI 3.14159265359\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat4 rotationMatrix(float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\n\nfloat map(vec3 p){\n \n    vec3 boxPos = p;\n    boxPos.y -= 2.0;\n    \n    float box = sdBox( boxPos, vec3(.5,.2,1.0 ));\n    \n    vec4 pPos = vec4(p,0.0);\n    \n    vec4 planets[4] = vec4[4](pPos,pPos,pPos,pPos);\n    \n    float finalShape = 0.0;\n    \n    float planetShapes[4];\n    \n    float speed = 3.0;\n    \n  \tfloat moonShapes[4];\n    \n    for (int i = 0; i < 4; i++){\n        float iAsFloat = float(i);\n        \n        float randomSpeed = rand(iAsFloat+1.0);\n        \n        \n        float curRotation =  randomSpeed * speed ;\n     \tplanets[i] = rotationMatrix(iTime * curRotation, vec3(0.0,1.0,0.0)) * planets[i];   \n    \tplanets[i].x += 3.0+ iAsFloat*3.0;\n        float newPlanet = sdSphere(planets[i].xyz, .30 * randomSpeed * 2.5);\n\t\n        planetShapes[i] = newPlanet;\n        \n        speed -= .3;\n        \n        vec4 newMoonPos = planets[i];\n        newMoonPos.x += .6* randomSpeed;\n        newMoonPos = rotationMatrix(iTime*20. * randomSpeed, vec3(0.0,1.0,0.0)) * newMoonPos;\n        //newMoonPos += 1.3;\n        //planets[i];\n        \n        \n        \n        newMoonPos = rotationMatrix(iTime*15., vec3(0.0,1.0,0.0))*planets[i]+.7;\n        newMoonPos.y -= 1.0;\n        //newMoonPos = rotationMatrix(iTime, vec3(0.0,1.0,0.0)) * newMoonPos;\n        float newMoon = sdSphere(newMoonPos.xyz, .1);\n        moonShapes[i] = newMoon;\n    }\n    \n    \n\n    float sun = sdSphere(p, 1.50);\n    \n    finalShape = min(planetShapes[0],planetShapes[1]);\n    finalShape = min(sun,finalShape);\n    finalShape = min(planetShapes[2], finalShape);\n    finalShape = min(planetShapes[3], finalShape);\n    \n    // moons\n    finalShape = min(moonShapes[0],finalShape);\n    finalShape = min(moonShapes[1], finalShape);\n    finalShape = min(moonShapes[2],finalShape);\n    finalShape = min(moonShapes[3],finalShape);\n    \n\treturn finalShape;\n}\n\n\nvec3 getNormal(vec3 p){\n\t//sampling around the point\n\tvec2 e = vec2(0.01, 0.0); //eplison - small offset\n\tfloat d = map(p);\n\tvec3 n = d - vec3(\n\t\t\t\t\tmap(p-e.xyy),\n\t\t\t\t\tmap(p-e.yxy),\n\t\t\t\t\tmap(p-e.yyx));\n\treturn normalize(n);\n}\n\nfloat diffuseLighting(vec3 p) {\n    vec3 lightPosition = vec3(3,9,-3);\n    vec3 light = normalize(lightPosition - p); // normalize the vector\n    vec3 normal = getNormal(p);\n\n    float diffuse = clamp( dot(normal, light), 0., 1.); // percentage of similarity\n    return diffuse;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv = uv.st * 2.0 - 1.0 ; // 0 is the center\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 8.0, -3.5); // change this to change the camera\n    \n    float camOffset = sin(iTime*.2)*-.6-1.0;\n    float camOffsetPos = cos(iTime*.3)*-2.0+.7;//sin(iTime * 5.0);\n    mat4 camRotMat = rotationMatrix(camOffset, vec3(1.0,0.0,0.0));\n    rayOrigin.y -= camOffsetPos;\n    \n    vec3 rayDirection = normalize(camRotMat * vec4(uv, 1.,0.0)).xyz;\n        \n        //normalize();\n    float diffuse;\n    float distanceOrigin = 0.0; // initial distance from cam is 0\n\n    vec3 normal;\n    // you must define a max limit for marching...\n    // good upper limit is 128\n    for ( int i = 0; i < 128; i++ ) {\n\n        // start with camera origin + the incremented value, * ray Direction\n        vec3 position = rayOrigin + distanceOrigin * rayDirection;\n        //formula to create a sphere\n        float map = map(position); // just for naming\n        distanceOrigin += map; // check again after hitting the radius of the sphere\n\n        //set the near and far clipping plane\n        if (distanceOrigin < MIN_DISTANCE || distanceOrigin > MAX_DISTANCE) break;\n        diffuse = diffuseLighting(position);\n\n    }\n\n    distanceOrigin /= 2.; // couldn't see the map, so divide by 2\n\n    vec3 shape = vec3(1,1,1) * diffuse;\n    \n\n    vec4 color = vec4(shape,1);\n\n    // Output to screen\n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 136, 136, 160], [162, 162, 193, 193, 280], [282, 282, 327, 327, 955], [957, 957, 977, 977, 1015], [1018, 1018, 1036, 1036, 2849], [2852, 2852, 2875, 2904, 3077], [3079, 3079, 3110, 3110, 3360], [3363, 3363, 3420, 3470, 4932]], "test": "untested"}
{"id": "ttG3Dd", "name": "Blue Flower", "author": "Klems", "description": "Simple layered 2D effect.", "tags": ["2d"], "likes": 17, "viewed": 470, "published": 3, "date": "1580171076", "time_retrieved": "2024-07-30T21:28:06.738435", "image_code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    float zoom = exp(-iTime*0.1);\n\tuv *= mix(20.0, 70.0, zoom); // progressive zoom\n    uv.y += 1.0;\n    \n    const vec3 background = vec3(0.8, 0.85, 0.9);\n    const vec3 light = normalize(vec3(1, 2, 3));\n    const vec3 lightColor = vec3(0.9, 0.8, 0.5);\n    \n    float dd = dot(uv,uv);\n    fragColor = vec4(background, 1);\n    \n    vec2 mou = (iMouse.xy-iResolution.xy*0.5)/iResolution.xy*4.0;\n    if (iMouse.z < 0.5) mou = vec2(0);\n    \n    #define LAYERS 20\n    \n    for (int i = min(0, iFrame) ; i < 2 ; i++) {\n    \tfor (int r = min(0, iFrame) ; r < LAYERS ; r++) {\n    \t\t\n            int rr = i == 0 ? LAYERS - r - 1: r;\n            float radius = float(rr*rr+1)*0.05;\n            \n\t\t\tvec3 pHere = vec3(uv, sqrt(max(0.0, radius*radius-dd)));\n\n            float sig = float(i*2-1);\n            vec3 p = pHere;\n            p.z *= sig;\n            vec3 n = p/radius;\n            n *= sig;\n\n            float dist = max(0.0, 2.0 - p.z);\n\n            float time = iTime*0.05 + float(rr)*0.3;\n            p.zy *= rot(2.2+mou.y);\n            p.xz *= rot(-0.1+mou.x);\n            p.yx *= rot(time);\n            p.xz *= rot(sin(time*8.145)*0.2);\n            p.zy *= rot(sin(time*6.587)*0.2);\n\n            float at = atan(p.x, p.y);\n            float rad = (sin(at*5.0)*0.6 + 0.2)*radius;\n\t\t\t\n            // anti-aliased petal border\n            float df = rad-p.z;\n            float aa = fwidth(df);\n            float sm = smoothstep(aa, -aa, df);\n            // anti-aliased wrap around border\n            float dfs = dd-radius*radius;\n            float aas = fwidth(dfs);\n            sm *= smoothstep(aas, -aas, dfs);\n\n            // fake normal mapping\n            float str = cos(at*5.0)*20.0;\n            str *= smoothstep(0.1, 0.0, abs(str/30.0));\n            float dotl = max(0.0, dot(light, n)+str*0.05);\n            // basic lighting + fog\n            vec3 albedo = vec3(0.2, 0.3, 0.8);\n            float ao = 1.0-min(1.0, exp((p.z/radius-1.0)));\n            vec3 col = albedo*lightColor*dotl*3.0 + albedo*background*0.4*ao;\n            col = mix(background, col, exp(-dist*0.1));\n            // accumulate color\n            fragColor.rgb = mix(fragColor.rgb, col, sm);\n\n        }\n        \n    }\n        \n    // gamma correction, vignette, dithering\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n    vec2 uu = (fragCoord.xy-iResolution.xy*0.5)/iResolution.xy;\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), dot(uu,uu)*0.5);\n    fragColor.rgb += (hash33(vec3(fragCoord, iFrame))-0.5)*0.02;\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttG3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 100, 100, 224], [226, 226, 283, 283, 2853]], "test": "untested"}
{"id": "wlyGDd", "name": "Curvature blindness but more so", "author": "vonrosceau", "description": "https://www.shadertoy.com/view/WtVGDc wasn't distressing enough", "tags": ["illusion"], "likes": 2, "viewed": 298, "published": 3, "date": "1580163352", "time_retrieved": "2024-07-30T21:28:07.589160", "image_code": " void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float wave_uv_y = fragCoord.y / 12.0 + sin(fragCoord.x / 10.0) * 0.5;\n    float wave_cos = cos(fragCoord.x / 10.0);\n    \n    float wave_fract = fract(wave_uv_y);\n    \n    float wave = 1.0 - clamp(abs(wave_fract * 2.0 - 1.0) * 6.0 - 1.0, 0.0, 1.0);\n    wave *= mod(wave_uv_y, 4.0) < 2.0 ? 0.0 : 1.0;\n    \n    float wave_color_offset = (cos(iTime * 0.6) * 2.0) + (floor(wave_uv_y * 0.25) * acos(-1.0) * 0.5);\n    float wave_color = sin(fragCoord.x / 10.0 + wave_color_offset) > 0.0 ? 0.65 : 0.35;\n    \n    vec2 uv = fragCoord/iResolution.xx;\n    float offset = sin(iTime * 0.5) * 0.35;\n    if (iMouse.z > 0.0)\n        offset = 0.5 - iMouse.x / iResolution.x;\n    \n    float diag = uv.x - 0.5 + offset - (uv.y - 0.5*iResolution.y/iResolution.x) * 0.5;\n    float back_color = 0.5;\n    back_color = mix(1.0, back_color, clamp((diag + 0.35) * iResolution.x * 0.75, 0.0, 1.0));\n    back_color = mix(back_color, 0.0, clamp((diag - 0.35) * iResolution.x * 0.75, 0.0, 1.0));\n    \n    float col = mix(back_color, wave_color, wave);\n\n    fragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1128]], "test": "untested"}
{"id": "3ty3Dd", "name": "PimpThatAss2", "author": "Del", "description": "fork of pimp that ass by makc\noriginal here: https://www.shadertoy.com/view/WtV3Wc", "tags": ["sdf", "animated", "distance", "parametric"], "likes": 22, "viewed": 2024, "published": 3, "date": "1580142211", "time_retrieved": "2024-07-30T21:28:08.551587", "image_code": "// fork of pimp that ass - https://www.shadertoy.com/view/WtV3Wc - added jiggle anim + various other tweaks :)\n// basically a combination of:\n// - https://mathematica.stackexchange.com/a/66564 by Nikolai Mikuszeit\n// - https://www.shadertoy.com/view/Ws3SDl by Inigo Quilez\n\n#define AA 2\n\nfloat pi = 3.14159265, tau = 6.2831853;\n\nfloat box (in float x, in float x1, in float x2, in float a, in float b) {\n\treturn tanh(a * (x - x1)) + tanh(-b * (x - x2));\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat ex (in float z, in float z0, in float s) {\n    return exp(-(z - z0) * (z - z0) / s);\n}\n\nfloat r(in float z, in float x) {\n    float s = sin (tau * x), c = cos(tau * x),\n\t\tc2 = cos (pi * x), t4z = tanh(4. * z);\n    return /* body */.4 * (1.0 - .4 * ex(z, .8, .15) +\n\t\ts * s + .6 * ex(z, .8, .25) * c * c + .3 * c) *\n\t\t0.5 * (1. + t4z) + /* legs */ (1. - .2 * ex(z, -1.3, .9)) *\n\t\t0.5 * (1. - t4z) * (.5 * (1. + s * s + .3 * c) *\n\t\t(pow(abs(s), 1.3) + .08 * (1. + t4z) ) ) +\n\t\t/* improve butt */ .13 * box(c2, -.45, .45, 5., 5.) *\n\t\tbox(z, -.5, .2, 4., 2.) - 0.1 * box(c2, -.008, .008, 30., 30.) *\n\t\tbox(z, -.4, .25, 8., 6.) - .05 * pow(abs(sin(pi * x)), 16.) * box(z, -.55, -.35, 8., 18.);\n}\n\n// $1M question: how close are we to ParametricPlot3D[...] surface?\nfloat sd( in vec3 p )\n{\n\t/* shift butt belly */\n\tfloat dx = .1 * exp(-pow((p.z-.8),2.)/.6) - .18 * exp(-pow((p.z -.1),2.)/.4);\n\n    // on the surface, we have:\n    // p.x = r * cos + dx\n\t// p.y = r * sin\n\t\n    float jiggle = p.z*1.75;\n    float jsize = 0.5;\n    if (iMouse.z>0.5)\n    {\n        jiggle+=p.y*.5;\n        jsize+=.175;\n    }\n    \n\tdx *= 1.5+(sin(jiggle+iTime*9.65)*jsize);\n\t\n\tfloat angle = atan(p.y, p.x - dx);\n\tfloat r_expected = r(p.z, angle / tau);\n//\tfloat d1 = (.5 + .5 * smoothstep(.4,1.,p.z)) * (length(vec2(p.y, p.x - dx)) - r_expected);\n\tfloat d1 = (length(vec2(p.y, p.x - dx)) - r_expected)*0.5;\n    \n    p.x -= dx;\n\tfloat d2 = sdSphere(p+vec3(-0.35,0.4,-1.875),0.4);\n\tfloat d3 = sdSphere(p+vec3(-0.35,-0.4,-1.875),0.4);\n    d2 = smin(d2,d3,0.35);\n    return smin(d1,d2,0.07);\n    //return min(d1,min(d2,d3));\n}\n\n\nfloat map( in vec3 pos )\n{\n    return sd (pos.zxy);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = sin(iTime+2.15)*0.7;\t//0.5*iTime - 0.8;\n    if (iMouse.z>0.5)\n        an+=iMouse.x/(iResolution.x*0.25);\n    //an+=3.14;\n    \n\tvec3 ro = vec3( 2.55*sin(an), 0.5, -2.55*cos(an) );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 tot = vec3(0.0);\n    \n    \n    vec2 p1 = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float val = sin(iTime+p1.x+p1.y*20.0)*(0.8+sin(p1.y+iTime*3.0)*0.3);\n    val = clamp(val,0.0,2.0);\n    vec3 bcol = vec3(val,val*0.2,val*0.1);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        \n        vec3 col = bcol;\n        // raymarch\n        if (abs(p.x)<0.8)\n        {\n            // create view ray\n            vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n            \n            const float tmax = 5.0;\n            float t = 0.0;\n            for( int i=0; i<150; i++ )\n            {\n                vec3 pos = ro + t*rd;\n                float h = map(pos);\n                if( h<0.0001 || t>tmax ) break;\n                t += h;\n            }\n            // shading/lighting\t\n            if( t<tmax )\n            {\n                vec3 pos = ro + t*rd;\n                vec3 nor = calcNormal(pos);\n                float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n                float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n                col = vec3(0.3,0.15,0.1)*amb + vec3(0.8,0.5,0.2)*dif;\n                col += pow(dif,16.0);\n            }\n        }\n\n        // gamma        \n        //col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    // gamma        \n    tot = sqrt( tot );\n    \n   tot *= 1.0 - 0.2*dot(p1,p1);\t\t// vignette\n    \n\tfragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ty3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 329, 403, 403, 455], [456, 456, 491, 491, 517], [518, 518, 559, 559, 652], [654, 654, 702, 702, 746], [748, 748, 781, 781, 1350], [1352, 1420, 1443, 1467, 2253], [2256, 2256, 2282, 2282, 2309], [2311, 2357, 2389, 2389, 2627]], "test": "untested"}
{"id": "Wty3Dt", "name": "Day 39", "author": "jeyko", "description": "As always, code is messy.\ninspired by a gif on the web\nand this <3 https://www.youtube.com/watch?v=JURh1XtkR-w&t=94s\nShould probably work on this and polish it but too lazy", "tags": ["mdtmjvm"], "likes": 23, "viewed": 1248, "published": 3, "date": "1580132112", "time_retrieved": "2024-07-30T21:28:09.363416", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 t = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 B = texture(iChannel0, fragCoord/iResolution.xy, 6.);\n    vec4 C = texture(iChannel0, fragCoord/iResolution.xy, 6.);\n    C = pow(C*1.5, vec4(2.));\n    C = clamp(C, 0., 1.);\n    fragColor = t*1. + C*0.4;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// As always, code is messy.\n// inspired by a gif on the web\n// and this <3 https://www.youtube.com/watch?v=JURh1XtkR-w&t=94s\n\n// ------- IF GLITCHY OR GREEN -------- //\n//\n// comment these lines at the end\n//     col = clamp(col, vec3(0.01), vec3(1.));\n//     col = smoothstep(0.,1.,col);\n//\n\n#define dmin(a,b) a.x < b.x ? a : b\n#define pmod(a,x) mod(a, x) - x*0.5\n\n#define mx (3.*iTime+20.*iMouse.x/iResolution.x)\n#define pi acos(-1.)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\n//check out variations!\n//#define VAR1\n//#define VAR2\n#define VARENDLESS\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.x, max(p.z, p.y));\n}\nvec3 u;\nfloat zid;\nfloat repD = 1.;\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e5);\n\tvec3 o = p;\n    zid = floor(p.z/repD);\n    p.z = pmod(p.z, repD);\n    //d = dmin(d, vec2(length(p) - 1., 2.));\n    vec3 q = p;\n    u = p*(2. + floor(mod(p.z, repD*4.)/(repD*4.)));\n    \n    p = abs(p);\n    \n    p.x -= 2.15;\n    p.y -= 2.13;\n    p = abs(p);\n    p.yz *= rot(zid*pi*0.25);\n    p.xy *= rot(0.25*pi);\n    \n    #ifdef VARENDLESS\n    \tp = abs(p);\n    \tp.x -= 0.7 + sin(zid);\n    #endif\n    //p.zx *= rot(0.25*pi*zid);\n   \t#ifdef VAR2\n    \tp.yz *= rot(-0.1);\n    #endif\n    d = dmin(d, vec2(sdBox(p, vec3(1,2,1)), 1.));\n    d.x = max(d.x, -u.z  );\n    #ifdef VAR1\n    d.x = max(d.x, u.z  );\n\t#endif\n    d.x = max(d.x, u.z - 4.9  );\n    d.x *= 0.5;\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0);\n    return normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n    \n}\nvec3 glow = vec3(0);\n\nvec2 march(vec3 ro, vec3 rd, inout float t,inout bool hit, inout vec3 p){\n\tvec2 d;\n    \n\tp = ro + rd;\n    \n    for (int i = 0; i < 270; i++){\n    \td = map(p);\n        glow += exp(-d.x);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        //if (t > 60.){break;}\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n\treturn d;\n}\n\n//#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define pal(a,b,c,d,e) (a + b*cos( (c*d + e)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0.,0.,0. + mx);\n    vec3 lookAt = ro + vec3(0,0,1.);\n    //lookAt.x += sin(iTime)*0.1;\n    vec3 rd = getRd(ro, lookAt, uv);\n//    rd.xy *= 1. - dot(uv,uv)*0.2;\n    vec3 p;\n    float t = 0.; bool hit = false;\n    vec2 d = march(ro, rd, t, hit, p);\n    \n    vec3 n = getNormal(ro + rd.x*t);\n    \n    if(hit){\n    \t//col += n;\n    \t//u.xy *= rot(0.15*pi + iTime);\n        if (d.y == 1.){\n        \tvec3 q = p;\n            \n            float repD=7.;\n            float w = 2.8;\n            //q.z *= 9.;\n            //q.x *= 2.;\n            q *= 2.;\n            //q.y *= 3.;\n    \t\tzid = floor(p.z/repD);\n            \n            q = abs(q);\n            //q.xy -= pow(abs(sin(iTime*0.4 + zid*3.)), 20.)*2. ;\n            q.xy *= rot(zid*pi*0.25);\n            //q.zy *= rot(0.25*pi*zid);\n            float id = floor(max(abs(q.x)*repD, abs(q.y)*repD)*0.95) + 1.;\n            //float sqs = abs((mod(max(abs(q.x), max(abs(q.y),q.z)) , 1.) - 0.5)*repD); \n            float sqs = abs((mod(max(abs(q.x), max(abs(q.y),q.z)) , 1.) - 0.5)*repD); \n            \n            w += sin(id*9.)*3.;\n            //w = min(w, 2.2);\n            //w = max(w, 0.8);\n        \tcol += smoothstep(w,w*0.5, sqs)*pal(0.5,0.5,vec3(2,3,3),id ,iTime*1. + zid*0.6 + 9.*id);\n        \tcol -= abs(sin(id*5. + iTime))*0.4;\n        }\n    }\n    //col += pow(glow*0.03,vec3(3.))*0.28;\n    col -= pow(glow*0.03,vec3(6.))*0.1;\n    //col = pow(col, vec3(1.75));\n    //col = smoothstep();\n    \n    //col = pow(col, vec3(1.9,1.1,1.7));\n    col = pow(col, vec3(1.0,1.9,1.0));\n    //col.b *= 0.8;\n    col = clamp(col, 0.0, 1.);\n    col = smoothstep(0.,1.,col);\n    col.b *= 0.4;\n    col *= 1.2;\n    //col += pow(glow*0.03,vec3(1.))*0.28;\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 331]], "test": "untested"}
{"id": "tlVGDc", "name": "Rhombus 3D - distance", "author": "iq", "description": "A rhombus with thickness. Similar to [url]https://www.shadertoy.com/view/XdXcRB[/url], but extruded and with some rounding controls.", "tags": ["3d", "distancefield", "sdf", "distance", "rhombus", "primitive"], "likes": 9, "viewed": 2216, "published": 3, "date": "1580127774", "time_retrieved": "2024-07-30T21:28:10.204168", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Euclidean distance to rhombus with thickness and rounding.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\nfloat map( in vec3 pos )\n{\n    return sdRhombus(pos, 0.6, 0.2, 0.02, 0.02 ) - 0.01;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVGDc.jpg", "access": "api", "license": "mit", "functions": [[1267, 1267, 1296, 1296, 1324], [1326, 1366, 1430, 1430, 1688], [1691, 1691, 1717, 1717, 1776], [1778, 1824, 1856, 1856, 2095]], "test": "ok"}
{"id": "WtV3D3", "name": "2d ripples", "author": "mba105", "description": "based on Hugo Elias' article here: https://web.archive.org/web/20160116150939/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm\n\nsimilar to: https://www.shadertoy.com/view/WdVXDt , but with reflections at the edges", "tags": ["ripples", "water"], "likes": 6, "viewed": 836, "published": 3, "date": "1580122623", "time_retrieved": "2024-07-30T21:28:11.116729", "image_code": "void mainImage(out vec4 color, in vec2 coord)\n{\n    if (iFrame % 2 == 1)\n        color = vec4(vec3(texture(iChannel0, coord / iResolution.xy).r * 0.5 + 0.5), 1.0);\n    else\n        color = vec4(vec3(texture(iChannel1, coord / iResolution.xy).r * 0.5 + 0.5), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    if (iFrame == 0)\n    {\n        color = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    \n    ivec2 p = ivec2(coord);\n    \n    if (iFrame % 2 == 1)\n    {\n    \tcolor = texelFetch(iChannel0, p, 0);\n        return;\n    }\n    \n    ivec2 res = ivec2(iResolution.xy);\n    vec2 mouse = vec2(iMouse.xy);\n    \n    float h = process(iChannel1, iChannel0, res, mouse, p);\n    \n    color = vec4(h, 0.0, 0.0, 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    if (iFrame == 0)\n    {\n        color = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    \n    ivec2 p = ivec2(coord);\n    \n    if (iFrame % 2 == 0)\n    {\n    \tcolor = texelFetch(iChannel1, p, 0);\n        return;\n    }\n    \n    ivec2 res = ivec2(iResolution.xy);\n    vec2 mouse = vec2(iMouse.xy);\n    \n    float h = process(iChannel0, iChannel1, res, mouse, p);\n    \n    color = vec4(h, 0.0, 0.0, 1.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nfloat read(sampler2D tex, ivec2 res, ivec2 coord, ivec2 offset, vec2 mouse)\n{\n    ivec2 r = res;\n    ivec2 c = coord + offset;\n    \n    // is there a better way to mirror the coordinates? :(\n    if (c.x < 0)\n        c.x = -c.x;\n    else if (c.x > r.x)\n        c.x = r.x - (c.x - r.x);\n        \n    if (c.y < 0)\n        c.y = -c.y;\n    else if (c.y > r.y)\n        c.y = r.y - (c.y - r.y);\n    \n    // is there a way to tell if the mouse is down or not? it seems to get stuck :(\n    float ui = clamp(1.0 - length(vec2(c) - mouse.xy) / 5.0, 0.0, 1.0);\n    float h = texelFetch(tex, c, 0).r;\n    \n    return h + ui;\n}\n\nfloat process(sampler2D bufferIn, sampler2D bufferOut, ivec2 res, vec2 mouse, ivec2 p)\n{\n    float l = read(bufferIn, res, p, ivec2(-1,  0), mouse);\n    float r = read(bufferIn, res, p, ivec2( 1,  0), mouse);\n    float u = read(bufferIn, res, p, ivec2( 0, -1), mouse);\n    float d = read(bufferIn, res, p, ivec2( 0,  1), mouse);\n    \n    float c = read(bufferOut, res, p, ivec2(0), mouse);\n    \n    float damp = 0.98;\n    \n    return ((l + r + u + d) / 2.0 - c) * damp;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtV3D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 265]], "test": "untested"}
{"id": "wtVGW3", "name": "Hello Sphere", "author": "samhattangady", "description": "27 Jan 2020: day001\nLooking to draw a basic sphere using sdf.\nUsing parallel projectsion.", "tags": ["sdf", "sphere"], "likes": 3, "viewed": 290, "published": 3, "date": "1580093618", "time_retrieved": "2024-07-30T21:28:12.109076", "image_code": "/*\nday001: Sphere\n27 Jan 2020\n\nLooking to draw a basic sphere using sdf.\nUsing parallel projections\n*/\n\n\nfloat sdfSphere(vec3 position) {\n    vec3 center = vec3(0.0);\n    float radius = 0.25;\n    return distance(position, center) - radius;\n}\n\nvec3 calcNormal( vec3 p ) \n{\n    // We calculate the normal by finding the gradient of the field at the\n    // point that we are interested in. We can find the gradient by getting\n    // the difference in field at that point and a point slighttly away from it.\n    const float h = 0.0001;\n    return normalize( vec3(\n        \t\t\t       -sdfSphere(p)+ sdfSphere(p+vec3(h,0.0,0.0)),\n                           -sdfSphere(p)+ sdfSphere(p+vec3(0.0,h,0.0)),\n                           -sdfSphere(p)+ sdfSphere(p+vec3(0.0,0.0,h)) \n    \t\t\t\t ));\n}\n\nfloat raymarch( vec3 direction, vec3 start) {\n    // We need to cast out a ray in the given direction, and see which is\n    // the closest object that we hit. We then move forward by that distance,\n    // and continue the same process. We terminate when we hit an object\n    // (distance is very small) or at some predefined distance.\n    float far = 15.0;\n    float d = 0.0;\n    vec3 pos = start;\n    for (int i=0; i<100; i++) {\n    \tfloat sphereDistance = sdfSphere(pos);\n        pos += sphereDistance*direction;\n\n        d += sphereDistance;\n        if (sphereDistance < 0.01) {\n        \tbreak;\n        }\n        if (d > far) {\n        \tbreak;\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalise and set center to origin.\n    vec2 p = fragCoord/iResolution.xy;\n    p -= 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 q = p - vec2(0.0, 0.0);\n    \n    vec3 planePosition = vec3(0.0, 0.0, -5.0);\n    vec3 lookingDirection = vec3(0.0, 0.0, 1.0);\n    \n    // Rotate light around origin in xz plane\n    float angle = iTime;\n    vec2 lightPos2D = mat2(cos(angle),-sin(angle),sin(angle),cos(angle))*vec2(0.0,1.0); \n    vec3 lightPoint = vec3(lightPos2D.x, 0.0, lightPos2D.y);\n    vec3 lightFacing = lightPoint - vec3(0.0);\n    \n    // raymarch to check for colissions.\n    vec3 start = vec3(p, planePosition.z);\n    float dist = raymarch(lookingDirection, start);\n    float color = 0.0;\n    if (dist < 15.0) {\n    \tvec3 normal = calcNormal(start+ dist*lookingDirection);\n        color = -dot(lightFacing, normal);\n    }\n    fragColor = vec4(vec3(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 137, 137, 241], [243, 243, 271, 503, 781], [783, 783, 828, 1117, 1461], [1463, 1463, 1520, 1563, 2401]], "test": "untested"}
{"id": "3lK3Dc", "name": "Triangle sound Wave", "author": "EFHIII", "description": "A triangle sound wave", "tags": ["sound", "wave", "triangle", "audio"], "likes": 6, "viewed": 416, "published": 3, "date": "1580088085", "time_retrieved": "2024-07-30T21:28:12.857076", "image_code": "/*\nSound text copied from\nhttps://www.shadertoy.com/view/MtyXRW\n*/\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nfloat getWave(in float time){\n\tfloat Tau=6.2831853;\n \n    float C=Tau*261.6256;\n    \n    float freq[8];\n    freq[0]=C;\n    freq[1]=C*3.;\n    freq[2]=C*5.;\n    freq[3]=C*7.;\n    freq[4]=C*9.;\n    freq[5]=C*11.;\n    freq[6]=C*13.;\n    freq[7]=C*15.;\n    \n    float mag[8];\n    mag[0]=1.;\n    mag[1]=1./9.;\n    mag[2]=1./25.;\n    mag[3]=1./49.;\n    mag[4]=1./81.;\n    mag[5]=1./(11.*11.);\n    mag[6]=1./(13.*13.);\n    mag[7]=1./(15.*15.);\n    \n    float val=0.;\n    for(int i=0;i<8;i++){\n    \tval+=cos(freq[i]*time)*mag[i];\n    }\n    \n    \n    if(time<.2){\n    \treturn val*sin(time*6.2831853*1.25);\n    }\n    \n    if(time<2.2){\n    \treturn val*0.5/(time+0.3)*(1.-(time-0.2)*0.5);\n    }\n    \n    return 0.;\n}\n\nfloat func(in float x){\n    float Tau = 6.2831853;\n    float t = (x+iTime/6.)*Tau*2.;\n    float val = -getWave(x*0.01+iTime);\n\treturn val/2.1+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iResolution.y<2000.) {\n        float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);\n    \tif(c>=0.){\n            fragColor=vec4(c);return;\n        }\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n   \tfloat mag=50.;\n    float maxV=0.;\n    \n    float val = func(uv.x);\n    if(uv.y>val-0.02&&uv.y<val+0.02){\n\t\tval = (abs(uv.y-val))*mag;\n    \tfragColor = vec4(1.-val,0.,val,1.);\n    }\n    else{\n    \tfragColor=vec4(0.,0.,0.2,1.);\n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound( in int samp, float time )\n{\n\tfloat Tau=6.2831853;\n \n    float C=Tau*261.6256;\n    \n    float freq[8];\n    freq[0]=C;\n    freq[1]=C*3.;\n    freq[2]=C*5.;\n    freq[3]=C*7.;\n    freq[4]=C*9.;\n    freq[5]=C*11.;\n    freq[6]=C*13.;\n    freq[7]=C*15.;\n    \n    float mag[8];\n    mag[0]=1.;\n    mag[1]=1./9.;\n    mag[2]=1./25.;\n    mag[3]=1./49.;\n    mag[4]=1./81.;\n    mag[5]=1./(11.*11.);\n    mag[6]=1./(13.*13.);\n    mag[7]=1./(15.*15.);\n    \n    float val=0.;\n    for(int i=0;i<8;i++){\n    \tval+=cos(freq[i]*time)*mag[i];\n    }\n    \n    if(time<.2){\n    \treturn vec2(val*sin(time*6.2831853*1.25));\n    }\n    \n    if(time<2.2){\n    \treturn vec2(val*0.5/(time+0.3)*(1.-(time-0.2)*0.5));\n    }\n    \n    return vec2(0.);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lK3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 309, 332, 379, 558], [560, 560, 589, 589, 1264], [1266, 1266, 1289, 1289, 1414], [1416, 1416, 1473, 1473, 2064]], "test": "untested"}
{"id": "wscSWf", "name": "shadetober #30 (catch)", "author": "percentcer", "description": "Inktober, but with shaders\n\nWanted to try some subsurface scattering stuff, https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/ has a good guide!", "tags": ["subsurfacescattering", "sss", "inktober", "shadertober", "shadetober", "inktober2019"], "likes": 0, "viewed": 299, "published": 3, "date": "1580087488", "time_retrieved": "2024-07-30T21:28:13.601086", "image_code": "#define MAXD 30.\n#define PI 3.141\n#define TAU 6.283\n\n#define REPETITION_PERIOD 4.\n#define HALF_PERIOD REPETITION_PERIOD * .5\n\n#define DEBUG_LIGHT_SOURCE 0\n\nmat3 roty(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\nmat3 rotx(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a), 0., -sin(a), cos(a));\n}\n\nvec3 spherical(vec3 cart)\n{\n    float rho = length(cart);\n    float theta = atan(cart.y, cart.x); // [-pi, pi]\n    float phi = acos(cart.z / rho);     // [0, pi]\n    return vec3(rho, theta, phi);\n}\n\nfloat expStep(float x, float k, float n) { return exp(-k * pow(x, n)); }\n\nfloat sphere(vec3 p, float rad) { return length(p) - rad; }\n\n\nfloat shape(vec3 p)\n{\n#if 1\n    // da experiment zone\n    //p = p.zxy;\n    mat3 rot = roty((iMouse.x / iResolution.x - .5) * 10.);\n    // mat3 rot = roty(iTime);\n    p *= rot;\n#endif\n#if 1\n    vec3 sp = spherical(p);\n\n    const float latPeaks = 5.;\n    const float latMin = .7;\n    float lateralRadius = mix(latMin, 1.0, cos(sp.y * latPeaks) * .5 + .5);\n\n    const float longPeaks = 6.;\n    const float longSpeed = 8.;\n    const float longDamp = 0.1;\n    float longitudinalWiggle = cos((sp.z * 2.) * longPeaks + iTime * longSpeed) * longDamp;\n\n    return length(p) - (lateralRadius + longitudinalWiggle);\n#else\n    return sphere(p, 1.);\n#endif\n}\n\nvec2 map(vec3 p)\n{\n    // return a distance and a material id\n    vec2 cur = vec2(MAXD, 0.);\n\n    vec2 shp = vec2(shape(p), 1.);\n    if (shp.x < cur.x)\n    {\n        cur = shp;\n    }\n\n#if DEBUG_LIGHT_SOURCE\n    vec2 dbg = vec2(sphere(p - vec3(0., 1., 3.) * roty(iTime), .01), 2.);\n    if (dbg.x < cur.x)\n    {\n        cur = dbg;\n    }\n#endif\n\n    return cur;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 ep = vec2(0.001, 0.0);\n    return normalize(\n        map(p).r - vec3(map(p - ep.xyy).r, map(p - ep.yxy).r, map(p - ep.yyx).r));\n}\n\nvec3 cell(vec3 p) { return floor((p + vec3(HALF_PERIOD)) / REPETITION_PERIOD); }\n\n// https://iquilezles.org/articles/distfunctions\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    vec3 localpos = mod(p + c / 2., c) - c / 2.;\n    vec3 cell = cell(p);\n    vec3 noise = texture(iChannel0, vec2(cell.x, cell.y * cell.z) * .1).rgb;\n    vec3 offs = noise - .5;\n    \n    return localpos*rotx(sin(iTime*noise.x)*noise.y) + offs*2.;\n}\n\nvec4 march(vec3 ro, vec3 rd, int invert)\n{\n    float t = 0.;\n    vec4 ret;\n\n    for (int i = 0; i < 100; i++)\n    {\n        ret.xyz = ro + rd * t;\n        vec2 d = map(opRep(ret.xyz, vec3(REPETITION_PERIOD))) * vec2(invert, 1);\n\n        if (d.x < .1)\n        {\n            ret.w = d.y;\n            break;\n        }\n\n        // only using a portion of the sphere step\n        // because I was getting a lot of errors from the\n        // shape distortion with the full step\n        t += d.x * .2f;\n\n        if (t > MAXD)\n        {\n            break;\n        }\n    }\n    return ret;\n}\n\nvec3 sss(vec3 p, vec3 rd, vec3 lp, vec3 lc)\n{\n    vec3 origP = p;\n    p = opRep(p, vec3(REPETITION_PERIOD));\n    // from https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/\n    vec3 L = normalize(lp - p);\n    const float subsurfaceDistortion = .5;\n\n    // figure out if our point is the light's entry or exit\n    float inShadow = -sign(dot(norm(p), L));\n    vec3 lightEgress = march(p + (inShadow * L * .05), inShadow * L, -1).xyz;\n    vec3 lightIngress = p;\n    if (inShadow > 0.)\n    {\n        lightIngress = lightEgress;\n        lightEgress = p.xyz;\n    }\n\n    // fudging a bit but a length of 2 is about the max width of this shape\n    // todo currently unused\n    // float thickness = length(lightEgress - lightIngress) / 2.;\n    vec3 N = norm(lightEgress);\n\n    vec3 cell = cell(origP);\n    vec3 noiseOffset =\n        texture(iChannel0, vec2(cell.x, cell.y + cell.z) * .1).rgb-.5;\n    vec3 basecolor = vec3(.6, 1., .2) + noiseOffset;\n\n    float lightAlign = max(0., dot(norm(p.xyz), L));\n\n    vec3 I_sss =\n        max(0., dot(rd, normalize(L + N * subsurfaceDistortion))) * basecolor;\n    vec3 I_diff = lightAlign * basecolor;\n\n    vec3 refl = reflect(L, norm(p.xyz));\n    float specAlign = abs(dot(rd, refl)); // abs so we get shinies on both sides\n    float I_spec = pow(specAlign, 50.);\n\n    return I_sss + I_diff + I_spec;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\tvec3 bgcol = vec3(.4,.6, 0.);\n    vec3 col = bgcol;\n\n    vec3 ro = vec3(0., 0., -1.);\n    vec3 rd = normalize(vec3(uv.xy, -2.));\n\n    // start the march a little ahead of the\n    // actual ro to enforce a near plane\n    vec4 p = march(ro + rd * 2., rd, 1);\n\n    vec3 lp = vec3(0., 0., -3.);\n    vec3 lc = vec3(1., 1., .878);\n    lp *= roty(iTime);\n\n    if (p.w == 1.)\n    {\n        col = sss(p.xyz, rd, lp, lc);\n    }\n#if DEBUG_LIGHT_SOURCE\n    if (p.w == 2.)\n    {\n        col = lc;\n    }\n#endif\n    \n    col = mix(col, bgcol, length(p.xyz)/MAXD);\n    col *= 1.-length((uv+vec2(sin(iTime),0.))*.25);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscSWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 176, 176, 248], [249, 249, 269, 269, 341], [343, 343, 370, 370, 540], [542, 542, 584, 584, 614], [616, 616, 649, 649, 675], [678, 678, 699, 699, 1323], [1325, 1325, 1343, 1386, 1685], [1687, 1687, 1706, 1706, 1845], [1847, 1847, 1866, 1866, 1927], [1929, 1978, 2012, 2012, 2262], [2264, 2264, 2306, 2306, 2845], [2847, 2847, 2892, 2892, 4198], [4200, 4200, 4255, 4255, 4957]], "test": "untested"}
{"id": "WlV3Wc", "name": "4-point voronoi", "author": "Wasserwecken", "description": "I've tried to make a  voronoi noise where a pixel/fragment only has to check three neighbours instead of 9.\n\nit kinda works, but its very uniform due to the limited area for the random points", "tags": ["voronoi", "test", "experiment"], "likes": 6, "viewed": 361, "published": 3, "date": "1580080909", "time_retrieved": "2024-07-30T21:28:14.343102", "image_code": "vec2 r( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat v(vec2 n)\n{\n\tfloat d = 2.0;\n\tvec2 nfl = floor(n);\n\tvec2 nfr = fract(n);\n\n\tvec2 p;\n\tvec2 ns = sign(nfr - vec2(0.5));\n\tfor(float x = 0.0; x < 2.0; x++)\n\t{\n\t \tfor(float y = 0.0; y < 2.0; y++)\n\t \t{\n\t \t    vec2 ne = vec2(x,y) * ns;\n\t \t   \n\t \t    p = r(nfl + ne) * 0.7 + 0.15 + ne;\n            //p = r(nfl + ne) + ne; //This will create artefacts\n\t \t    d = min(distance(p, nfr), d);\n\t \t}\n\t }\n\n\t return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv *= 10.0;\n    uv += iTime * 0.3;\n\n    // Output to screen\n    fragColor = vec4(vec3(v(uv)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3Wc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 111], [113, 113, 130, 130, 520], [522, 522, 579, 629, 773]], "test": "untested"}
{"id": "3tV3Wc", "name": "Trumpet Tone", "author": "EFHIII", "description": "I'm playing around with generating sound using pure sine waves", "tags": ["wave", "audio", "tone"], "likes": 4, "viewed": 393, "published": 3, "date": "1580079725", "time_retrieved": "2024-07-30T21:28:15.194825", "image_code": "/*\nSound text copied from\nhttps://www.shadertoy.com/view/MtyXRW\n*/\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nfloat getWave(in float time){\n\tfloat Tau=6.2831853;\n \n    float C=Tau*261.6256;\n    \n    float freq[8];\n    freq[0]=C;\n    freq[1]=C*2.;\n    freq[2]=C*3.;\n    freq[3]=C*4.;\n    freq[4]=C*5.;\n    freq[5]=C*6.;\n    freq[6]=C*7.;\n    freq[7]=C*8.;\n    \n    float mag[8];\n    mag[0]=0.1155;\n    mag[1]=0.3417;\n    mag[2]=0.1789;\n    mag[3]=0.1232;\n    mag[4]=0.0678;\n    mag[5]=0.0473;\n    mag[6]=0.0260;\n    mag[7]=0.0045;\n    \n    float val=0.;\n    for(int i=0;i<8;i++){\n    \tval+=sin(freq[i]*time)*mag[i];\n    }\n    \n    \n    if(time<.2){\n    \treturn val*sin(time*6.2831853*1.25);\n    }\n    \n    if(time<2.2){\n    \treturn val*0.5/(time+0.3)*(1.-(time-0.2)*0.5);\n    }\n    \n    return 0.;\n}\n\nfloat func(in float x){\n    float Tau = 6.2831853;\n    float t = (x+iTime/6.)*Tau*2.;\n    float val = -getWave(x*0.01+iTime);\n\treturn val/2.1+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iResolution.y<2000.) {\n        float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);\n    \tif(c>=0.){\n            fragColor=vec4(c);return;\n        }\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n   \tfloat mag=50.;\n    float maxV=0.;\n    \n    float val = func(uv.x);\n    if(uv.y>val-0.02&&uv.y<val+0.02){\n\t\tval = (abs(uv.y-val))*mag;\n    \tfragColor = vec4(1.-val,0.,val,1.);\n    }\n    else{\n    \tfragColor=vec4(0.,0.,0.2,1.);\n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound( in int samp, float time )\n{\n\tfloat Tau=6.2831853;\n \n    float C=Tau*261.6256;\n    \n    float freq[8];\n    freq[0]=C;\n    freq[1]=C*2.;\n    freq[2]=C*3.;\n    freq[3]=C*4.;\n    freq[4]=C*5.;\n    freq[5]=C*6.;\n    freq[6]=C*7.;\n    freq[7]=C*8.;\n    \n    float mag[8];\n    mag[0]=0.1155;\n    mag[1]=0.3417;\n    mag[2]=0.1789;\n    mag[3]=0.1232;\n    mag[4]=0.0678;\n    mag[5]=0.0473;\n    mag[6]=0.0260;\n    mag[7]=0.0045;\n    \n    float val=0.;\n    for(int i=0;i<8;i++){\n    \tval+=sin(freq[i]*time)*mag[i];\n    }\n    \n    if(time<.2){\n    \treturn vec2(val*sin(time*6.2831853*1.25));\n    }\n    \n    if(time<2.2){\n    \treturn vec2(val*0.5/(time+0.3)*(1.-(time-0.2)*0.5));\n    }\n    \n    return vec2(0.);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tV3Wc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 309, 332, 379, 558], [560, 560, 589, 589, 1248], [1250, 1250, 1273, 1273, 1398], [1400, 1400, 1457, 1457, 2048]], "test": "untested"}
{"id": "3tVGWc", "name": "Clockwork Chaos Map", "author": "zovox", "description": "Clockwork Chaos Map", "tags": ["clockworkchaosmap"], "likes": 5, "viewed": 1128, "published": 3, "date": "1580070519", "time_retrieved": "2024-07-30T21:28:16.183182", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 b = texture(iChannel0, uv);\n    fragColor = vec4(b.rgb, 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n#define time (sin(float(__LINE__)*GR/PI+GR/E)*iTime/PI)\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv0 = uv;\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n\tfloat sum = 0.;\n    float border = 1.;\n    \n    float bordered = smoothstep(0.4, 0.6, saw(time*E));\n    \n    const float min_outer_radials = 8.0;\n    const float max_outer_radials = 32.0;\n    \n    \n    float outer_count = min_outer_radials+(max_outer_radials-min_outer_radials)*saw(time);\n    \n    for(float i = 0.0; i < max_outer_radials; i+=1.0)\n    {\n        if(i > outer_count)\n            break;\n        float theta = float(i)/float(outer_count)*PI*2.0+time;\n        vec2 p1 = vec2(cos(theta), sin(theta))*.75;\n    \n        const float min_inner_radials = 8.0;\n        const float max_inner_radials = 32.0;\n\n    \tfloat inner_count = min_inner_radials+(max_inner_radials-min_inner_radials)*saw(time);\n        \n        for(float j = 0.0; j < max_inner_radials; j+=1.0)\n        {\n            if(j > inner_count)\n                break;\n        \tfloat theta2 = float(j)/float(inner_count)*PI*2.0-time;\n            vec2 p2 = p1+vec2(cos(theta2), sin(theta2));\n\n            float d = \n                    (p2.y-p1.y)*uv.x-\n                    (p2.x-p1.x)*uv.y+\n                    p2.x*p1.y-p2.y*p1.x/\n                    length(p2-p1);\n            float maxd = .01;\n            \n            float vd = abs(d);\n            \n            if(vd < maxd)\n            {\n                float value = ((length(p1-uv)));\n                sum += value*(border);\n                border *= vd/maxd;\n            }\n        }\n    }\n    vec4 last = texture(iChannel0, uv0);\n    float b = clamp((1.-border),0., 1.);\n    fragColor = vec4((cos(iTime*PI+sum*PI*GR+vec3(0., 4.*PI/3.,2.*PI/3.))*.5+.5), 1.0)*b\n        +last*(1.-pow(b, 4.)/GR)-1./60.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 a = texture(iChannel0, uv);\n    vec4 b = texture(iChannel1, uv);\n    fragColor = vec4(a.rgb,1.)+b*(1.-a.a)-1./60.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 172]], "test": "untested"}
{"id": "WtK3D3", "name": "Plates Fractal", "author": "zovox", "description": "Plates,Fractal", "tags": ["fractal", "plates"], "likes": 19, "viewed": 702, "published": 3, "date": "1580065688", "time_retrieved": "2024-07-30T21:28:16.954121", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time (sin(((sin(float(__LINE__))*GR/PI+GR/PI/E)*iTime+100.0)/100.0)*100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.5-GR/PI/E, .5+GR/PI/E, x))\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan((uv).y, (uv).x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define GUASS(x) (smoothstep(0.0, 1.0/GR/PI/E, saw(x*PI/2.0)*(1.0-saw(x*PI/2.0))))\n\n#define GRID_COUNT (50.0)\n\n#define MAX_DIM (max(iResolution.x, iResolution.y))\n\n\nfloat seedling = 0.0;\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return saw(cdiv(cmul(uv, multa) + offa, cmul(uv, multb) + offb)*PI)*2.0-1.0;\n}\n\nvec2 square_map(vec2 uv)\n{\n    return (rotatePoint(vec3(uv+vec2(cos(seedling*PI), cos(seedling*GR)), 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy*(1.0+sin(time+seedling)/PI/E/GR)\n            +vec2(cos(time+seedling)+sin(time+seedling)));\n}\n\nvec2 iterate_square(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = square_map(a);\n    vec2 mb = square_map(b);\n    vec2 mc = square_map(c);\n    vec2 md = square_map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return square_map(uv);\n}\nvec2 mobius_map(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return mobius(uv, multa, offa, multb, offb);\n}\n\nvec2 iterate_mobius(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius_map(a, multa, offa, multb, offb);\n    vec2 mb = mobius_map(b, multa, offa, multb, offb);\n    vec2 mc = mobius_map(c, multa, offa, multb, offb);\n    vec2 md = mobius_map(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return mobius_map(uv, multa, offa, multb, offb);\n}\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nfloat last_height = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sample1 = texture(iChannel1, uv);\n    float height = max(lowAverage(), last_height)-1.0/30.0;\n    float beat = clip(height);\n    float scale = exp(sin(time))*PI;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy;\n    uv += cos(vec2(time, time/GR))/PI/E;\n    vec2 uv0 = uv;\n    float r = length(uv);\n\n    \n    float map = time;\n    float noise = 1.0;\n    float spounge = time*4.0*PI;\n\tconst int max_iterations = 5;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec3 color = vec3(1.0);\n\tvec3 accum = vec3(0.0);\n    float sum = 0.0;\n    float anticolor = 1.0;\n    seedling = 0.0;\n    \n    float black, white;\n    white = 0.0;\n        \n    float border_color = 0.0;\n    float border = 0.0;\n    \n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI)*PI;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI);\n        \n        uv = iterate_square(uv, .5/iResolution.xy, magnification);\n        float weight = smoothstep(0.0, 0.25, magnification);\n        antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        float q = quadrant(uv);\n        seedling += q+float(i);\n\n        map += (q+seedling)*antispeckle;\n        float shift = time;\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.y*PI)))));\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.x*PI)))));\n\n        border *= GUASS(antispeckle);\n        \n\n        float stripes = map*1.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n        float black = smoothstep(0.0, .75, saw(stripes))*clamp(1.0-abs(border), 0.0, 1.0);\n        float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n\n        vec3 final = flux(map*2.0*PI+shift+float(i))*black+white;\n\n\n        color *= (final);\n        accum += final;\n        sum += 1.0;\n        anticolor *= white;\n\n        if(i > 0)\n        {\n            uv = iterate_mobius(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n            antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.y*PI)))));\n\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.x*PI)))));\n\n            border_color += (border+float(i))*GUASS(antispeckle);\n\n        \tborder *= GUASS(antispeckle);\n        }\n    }\n    \n    color = pow(color, vec3(1.0/float(max_iterations)));\n    \n    antispeckle = pow(antispeckle, .5/float(max_iterations));\n    \n    fragColor.rgb = (color+accum/sum)*(1.0-border);\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1109, 1109, 1131, 1131, 1305], [1307, 1307, 1336, 1336, 1406], [1408, 1408, 1437, 1437, 1521], [1523, 1523, 1591, 1591, 1674], [1676, 1676, 1702, 1702, 1909], [1911, 1911, 1977, 1977, 2585], [2586, 2586, 2658, 2658, 2709], [2711, 2711, 2823, 2823, 3561], [3562, 3562, 3585, 3585, 3688], [3690, 3690, 3710, 3710, 4088], [4116, 4116, 4173, 4173, 7261]], "test": "untested"}
{"id": "WlK3W3", "name": "Tree Fractal", "author": "zovox", "description": "Tree Fractal", "tags": ["fractal", "tree"], "likes": 4, "viewed": 393, "published": 3, "date": "1580063872", "time_retrieved": "2024-07-30T21:28:18.000324", "image_code": "//-----------------CONSTANTS MACROS-----------------\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n//--------------------------------------------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\n\nvec2 saw(vec2 x) { return vec2(saw(x.x), saw(x.y)); }\nvec3 saw(vec3 x) { return vec3(saw(x.x), saw(x.y), saw(x.z)); }\nvec4 saw(vec4 x) { return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w)); }\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\nfloat draw(vec2 uv)\n{\n    return (1.-smoothstep(0., .1, abs(uv.x-.5)))*(1.-smoothstep(0.9, 1., abs(uv.y)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy)/iResolution.xy;//*2.-1.;\n    p.x = p.x*2.-1.;\n    p.x *= iResolution.x/iResolution.y;\n\tp.x = p.x *.5+.5;\n    \n    vec3 col = vec3(0.);\n\n    const float max_iterations = 16.;\n    \n    float map = 0.;\n    map += draw(p);\n    for(float f = 0.; f < max_iterations; f+=1.){\n        float iteration = (f/max_iterations+1.);\n        float angle = (time*iteration)/PI-1.*PI/4.;//floor(((angle/PI)*.5+.5)*rots);\n\n        vec2 a = vec2(1., 1.);\n        vec2 b = vec2(0., 1.);\n        vec2 c = vec2(0., 0.);\n        vec2 d = vec2(1., 0.);\n        \n        p = p*2.-1.;\n        \n        vec2 s = vec2(.75);\n        vec2 o = vec2(.5, 0.);\n        mat2 m = rotate(angle);\n        \n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n        \n        a = a*m; b = b*m; c = c*m; d = d*m;\n        a *= s; b *= s; c *= s; d *= s;\n        a += o; b += o; c += o; d += o;\n        //= a*.5+.5; b = b*.5+.5; c = c*.5+.5; d = d*.5+.5;\n\n        \n        /*\n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n\t\t*/\n\n        vec2 a2 = a*vec2(-1., 1.);\n        vec2 b2 = b*vec2(-1., 1.);\n        vec2 c2 = c*vec2(-1., 1.);\n        vec2 d2 = d*vec2(-1., 1.);\n        if(p.x > 0.)\n        \tp = (invBilinear( p, a, b, c, d ));\n        else\n        \tp = (invBilinear( p, a2, b2, c2, d2 ));\n            \n\n        \n        //map += 1.-smoothstep((f)/max_iterations, (f+1.)/max_iterations, (abs(p.x+p.y)));\n        map += draw(p)*iteration;//1.-smoothstep((f)/max_iterations, (f+1.)/max_iterations, (abs(p.y-.5)));\n    }\n\n    fragColor = vec4(flux(map*PI)*clamp(map, 0., 1.), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlK3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 382, 382, 487], [489, 489, 507, 507, 542], [543, 543, 561, 561, 606], [607, 607, 625, 625, 680], [683, 683, 705, 705, 753], [755, 755, 794, 794, 822], [824, 824, 899, 899, 1871], [1873, 1873, 1894, 1894, 1982], [1983, 1983, 2040, 2040, 3620]], "test": "untested"}
{"id": "ttG3Dc", "name": "Spiral Fire Tree", "author": "zovox", "description": "Sometimes looks like a tree on fire, caught in a downward spiral.", "tags": ["fire", "spiral", "tree"], "likes": 3, "viewed": 758, "published": 3, "date": "1580063854", "time_retrieved": "2024-07-30T21:28:19.079438", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define time ((saw(float(__LINE__)/GR)/E+1.0)*iTime/PI)\n#define stair floor\n#define jag fract\n\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2( g, f );\n    float k1 = cross2( e, f ) + cross2( h, g );\n    float k0 = cross2( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    return saw(res*1.0);\n}\n\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \nvec2 tree(vec2 uv)\n{\n    \n    uv = uv*2.0-1.0;\n    \n    mat4 square = mat4(EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, EPS, 0.0, 0.0,\n                       1.0-EPS, 1.0-EPS, 0.0, 0.0,\n                       0.0, 1.0-EPS, 0.0, 0.0);\n    \n    float size =  .5;\n    \n    square = translate(square, vec2(-.5));\n    square = scale(square, vec2(2.0));\n    square = RotateZ(square, PI/6.0+sin(time)*.1);\n    square = scale(square, vec2(3./4.));\n    square = translate(square, vec2(.5, 0.0));\n    \n    \n    vec2 uv1 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    square = scale(square, vec2(-1.0, 1.0));\n    vec2 uv2 = invBilinear(uv, square[0].xy, square[1].xy, square[2].xy, square[3].xy);\n    square = scale(square, vec2(1.0, -1.0));\n    if(uv.x >= 0.0)\n    \treturn uv1;\n    if(uv.x < 0.0)\n    \treturn uv2;\n    else\n    \treturn uv*.5+.5;\n}\n\n\n\nfloat square(vec2 uv, float iteration)\n{\n    uv = uv*2.-1.;\n    return 1.-smoothstep(0.0, 0.5, abs(saw(uv.y+time/PI)-uv.x));\n}\n\n\nvec2 spiral(vec2 uv)\n{\n    float r = log(length(uv)+1.)/2.;\n    float theta = atan(uv.y, uv.x)/PI-r;\n    return vec2(saw(r+time/E),\n                saw(theta+time/GR));\n}\n\nvec3 phase(float map)\n{\n    return vec3(sin(map),\n                sin(4.0*PI/3.0+map),\n                sin(2.0*PI/3.0+map))*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv0 = uv.xy;\n    \n    float map = 0.0;\n    \n    float lambda = 4.0;\n    \n\tconst int max_iterations = 12;\n\n    float scale = 3.0*PI+sin(time/GR/E);\n    uv *= scale;\n    uv -= scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.xy += vec2(cos(time*.234),\n                  sin(time*.345))*scale/2.;\n    uv.xy = spiral(uv.xy*scale);\n    \n    for(int i = 0; i <= max_iterations; i++)\n    {\n    \tfloat iteration = (float(i)/(float(max_iterations) ));\n        uv.xy = tree(uv.xy);\n        map += square(uv.xy, iteration);\n    }\n    \n    fragColor.rgb = phase(map)*\n        \t\t\tclamp(map, 0.0, 1.0);\n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttG3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 225, 225, 253], [255, 255, 275, 275, 380], [381, 381, 399, 399, 438], [440, 440, 458, 458, 507], [508, 678, 753, 753, 1286], [2588, 2588, 2608, 2608, 3463], [3467, 3467, 3507, 3507, 3593], [3596, 3596, 3618, 3618, 3766], [3768, 3768, 3791, 3791, 3900]], "test": "untested"}
{"id": "wtGGDc", "name": "Spherical Tangents", "author": "zovox", "description": "Tangents of a sphere rotating around.", "tags": ["spherical", "tangents"], "likes": 6, "viewed": 385, "published": 3, "date": "1580063830", "time_retrieved": "2024-07-30T21:28:20.090736", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))*GR/2.0/PI+GR/PI)*iTime+100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//#define iTime (iTime*.1)\n\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\t//vec3 eye = vec3(0.0, 0.0, 3.0);\n\tvec3 eye = vec3(cos(iTime), sin(iTime*.5), sin(iTime))*2.0;\n    vec3 look = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 foward = normalize(look-eye);\n    vec3 right = normalize(cross(foward, up));\n    up = normalize(cross(right, foward));\n    vec3 ray = normalize(foward+uv.x*right+uv.y*up);\n    \n    fragColor = vec4(0.0);\n    \n \tconst float outerCount = 10.0;\n \tconst float innerCount = 8.0;\n        \n    float map = 0.0;\n    float sum = 0.0;\n    \n    vec2 xy = vec2(0.);\n    \n    for(float i = 0.0; i < outerCount; i+=1.0)\n    {\n        \n        float theta1 = i/outerCount*4.0*PI+time*PI*i/outerCount;\n        \n        for(float j = 0.0; j < innerCount; j+=1.0)\n        {\n            float theta2 = theta1+j/innerCount*PI*4.0+time*PI*j/innerCount;\n\n       \t \tvec3 p1 = vec3(cos(theta1)*sin(theta2),\n                           sin(theta1)*sin(theta2),\n                           cos(theta2));\n                           \n       \t \tvec3 p2 = vec3(cos(theta1)*sin(theta2+PI/8.0),\n                           sin(theta1)*sin(theta2+PI/8.0),\n                           cos(theta2+PI/8.0));\n            \n            vec3 ray2 = normalize(p2-p1);\n            \n            float a = dot(ray,ray);\n            float b = dot(ray,ray2);\n            float c = dot(ray2,ray2);\n            float d = dot(ray,eye-p1);\n            float e = dot(eye-p1,ray2);\n            \n            float t1 = (b*e-c*d)/(a*c-b*b);\n            float t2 = (a*e-b*d)/(a*c-b*b);\n            \n            float dist = length((eye+ray*t1)-(p1+ray2*t2));\n            \n            float lineWidth = .1;\n            \n            float lineLength = 1.5+.5*sin(time);\n            \n            if(t1 > 0.0 && abs(t2) < lineLength && dist < lineWidth)\n            {\n                float sides = (1.0-smoothstep(0.0, lineWidth, dist));\n                float ends = (1.0-smoothstep(0.0, lineLength, abs(t2)));\n                float line = sides*ends;\n                \n                map += line;\n                sum += 1.0;\n            }\n        }\n    }\n    \n\tfragColor = vec4(flux(PI*pow(map/sum, 1.0+.5*sin(-time/GR))+time), 1.0)*clamp(map, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[505, 505, 562, 562, 2830]], "test": "untested"}
{"id": "3lK3W3", "name": "Recursive Flower", "author": "zovox", "description": "Heart <3 the Recursive Flower!!", "tags": ["flower", "recursive"], "likes": 2, "viewed": 321, "published": 3, "date": "1580063806", "time_retrieved": "2024-07-30T21:28:20.974372", "image_code": "//-----------------CONSTANTS MACROS-----------------\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n//--------------------------------------------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\n\nvec2 saw(vec2 x) { return vec2(saw(x.x), saw(x.y)); }\nvec3 saw(vec3 x) { return vec3(saw(x.x), saw(x.y), saw(x.z)); }\nvec4 saw(vec4 x) { return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w)); }\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy)/iResolution.xy*2.-1.;\n    \n    p.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 col = vec3(0.);\n\n    vec2 c = vec2(0., 1./MAX_DIM);\n    vec2 d = vec2(0., -1./MAX_DIM);\n\n    const float max_iterations = 4.;\n    \n    float map = 0.;\n    \n    for(float f = 0.; f < max_iterations; f+=1.){\n        float iteration = (f/max_iterations+1.);\n        float rots = floor(2.+8.*saw(time))+1./MAX_DIM;\n        float angle = atan(-p.y, -p.x);\n        angle = floor(((angle/PI)*.5+.5)*rots);\n\n        vec2 a = vec2(1., 0.);\n        vec2 b = vec2(1., 0.);\n        \n        b *= rotate(angle/rots*2.*PI);\n        angle += 1.;\n        a *= rotate(angle/rots*2.*PI);\n\n        p = (invBilinear( p, a, b, c, d ));\n\n        map += 1.-smoothstep(0., 1., abs(p.y-.5));\n        p = p*2.-1.;\n    }\n    fragColor = vec4(flux(map*PI), 1.0 )*clamp(map, 0., 1.)+clamp(1.-map, 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lK3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 382, 382, 487], [489, 489, 507, 507, 542], [543, 543, 561, 561, 606], [607, 607, 625, 625, 680], [683, 683, 705, 705, 753], [755, 755, 794, 794, 822], [824, 824, 899, 899, 1871], [1873, 1873, 1930, 1930, 2820]], "test": "untested"}
{"id": "WtV3W3", "name": "Recursive Drawings", "author": "zovox", "description": "Recursive Drawings", "tags": ["recursive", "drawings"], "likes": 8, "viewed": 415, "published": 3, "date": "1580063790", "time_retrieved": "2024-07-30T21:28:21.780218", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define time ((saw(float(__LINE__)/GR)+1.0)*(iTime/E+1234.4321)/E)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\n\nfloat smooth_floor(float x)\n{\n\treturn floor(x)+smoothstep(.75, 1., fract(x));\n}\n\nvec2 tree(vec2 uv)\n{\n    \n    vec2 p = uv*2.-1.;\n    \n\t\n        float angle = smooth_floor((time))*PI/12.;\n\n        vec2 a = vec2(1., 1.);\n        vec2 b = vec2(0., 1.);\n        vec2 c = vec2(0., 0.);\n        vec2 d = vec2(1., 1./MAX_DIM);\n        \n        \n        vec2 s = vec2(.75);\n        vec2 o = vec2(smooth_floor(time/PI)/500., 0.);\n        mat2 m = rotate(angle);\n        \n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n        \n        a = a*m; b = b*m; c = c*m; d = d*m;\n        a *= s; b *= s; c *= s; d *= s;\n        a += o; b += o; c += o; d += o;\n\n        \n        /*\n        //= a*.5+.5; b = b*.5+.5; c = c*.5+.5; d = d*.5+.5;\n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n\t\t*/\n\n        vec2 a2 = a*vec2(-1., 1.);\n        vec2 b2 = b*vec2(-1., 1.);\n        vec2 c2 = c*vec2(-1., 1.);\n        vec2 d2 = d*vec2(-1., 1.);\n        if(p.x > 0.)\n        \tp = (invBilinear( p, a, b, c, d ));\n        else\n        \tp = (invBilinear( p, a2, b2, c2, d2 ));\n    return p;\n}\n\nvec2 flower(vec2 p)\n{\n\tp *= rotate(time);\n\tfloat rots = smooth_floor(3.+6.*saw(time/E))+1./MAX_DIM;\n\tfloat angle = atan(-p.y, -p.x);\n\tfloat radius = length(p);\n\tangle = floor(((angle/PI)*.5+.5)*rots);\n\n\n\tvec2 a = vec2(1., 0.);\n\tvec2 b = vec2(1., 1./MAX_DIM);\n\tvec2 c = vec2(0., 1./MAX_DIM);\n\tvec2 d = vec2(0., -1./MAX_DIM);\n\t\n\tb *= rotate(angle/rots*2.*PI);\n\tangle += 1.;\n\ta *= rotate(angle/rots*2.*PI);\n\t\n\treturn (invBilinear( p, a, b, c, d ));\n}\n\n\nfloat square(vec2 uv, vec2 uv0)\n{\n    uv = (uv*2.-1.)*GR;\n    return abs(saw(uv.y+uv0.x-uv0.y+time)-uv.x);\n}\n\n\nvec2 spiral(vec2 uv)\n{\n    float r = log(length(uv)+1.)/2.;\n    float theta = atan(uv.y, uv.x)/PI-r*sin(time/E/PI/GR)/PI;\n    return vec2(saw(r+time/E/E),\n                saw(theta+time/GR/E))*2.-1.;\n}\n\nvec3 phase(float map)\n{\n    return vec3(sin(map),\n                sin(4.0*PI/3.0+map),\n                sin(2.0*PI/3.0+map))*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uv0 = uv.xy*2.-1.;\n    uv0.x *= max(iResolution.x/iResolution.y, 1.);\n    uv0.y *= max(iResolution.y/iResolution.x, 1.);\n\tuv0 = uv0*.5+.5;\n    float map = 0.0;\n    \n    float lambda = 4.0;\n\tconst int max_iterations = 12;\n\n    float scale = 3.0*PI+(time*PI*GR*E);\n    uv *= scale;\n    uv -= scale/2.0;\n    uv.x *= max(iResolution.x/iResolution.y, 1.);\n    uv.y *= max(iResolution.y/iResolution.x, 1.);\n    uv.xy += vec2(cos(time*.234),\n                  sin(time*.345))*scale/2.;\n\tfloat m = smoothstep(0.45, .55, saw(time/E/PI));\n    uv.xy = spiral(uv.xy*scale)*m+(1.-m)*(uv0);;\n    \n\tfloat nature = smoothstep(.45, .55, saw(time/GR/E))*(1.-m);\n\tuv =  uv*(1.-nature)+flower(uv0*2.-1.)*nature;\n\t\n    for(int i = 0; i <= max_iterations; i++)\n    {\n    \tfloat iteration = (float(i)/(float(max_iterations) ));\n        uv.xy = saw(tree(uv.xy));\n\t\t\tmap += square(uv.xy, uv0);\n\t\tuv0 = uv;\n    }\n    \n    float w = smoothstep(saw(map/float(max_iterations)+time), .0, .2);\n    float b = smoothstep(saw(map/float(max_iterations)+time), .0, .2);\n    fragColor.rgb = (flux(map))*\n        \t\t\t\n        \t\t\tclamp(map, 0.0, 1.0);\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtV3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 323, 323, 351], [353, 353, 373, 373, 478], [479, 479, 497, 497, 536], [538, 538, 556, 556, 605], [606, 606, 681, 681, 1653], [1656, 1656, 1678, 1678, 1726], [1729, 1729, 1758, 1758, 1808], [1810, 1810, 1830, 1830, 2803], [2805, 2805, 2826, 2826, 3252], [3255, 3255, 3288, 3288, 3363], [3366, 3366, 3388, 3388, 3567], [3569, 3569, 3592, 3592, 3701]], "test": "untested"}
{"id": "wtG3Dc", "name": "Polymorphic Polyhedron", "author": "zovox", "description": "A polymorphic polyhedron.", "tags": ["polyhedron", "polymorphic"], "likes": 6, "viewed": 378, "published": 3, "date": "1580063781", "time_retrieved": "2024-07-30T21:28:22.586063", "image_code": "//Do not redistribute.\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))*GR/2.0/PI+GR/PI)*iTime+100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define carpet_floor(x) (floor(x)+smoothstep(.9, 1.,(fract(x))))\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nconst float fov = 50.0;\n\n// epsilon-type values\nconst float S = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n        \n    float d = 1E32;\n\n \tconst float outerCount = 2.0;\n \tconst float innerCount = 2.0;\n        \n    float map = 0.0;\n    float sum = 0.0;\n    \n    float min_scale = 1./GR;\n    float max_scale = 1.;\n    float scale_steps = 1.;\n    float scalar = 1./PI/GR;\n    for(float i = 0.0; i < outerCount; i+=1.0)\n    {\n        \n        float theta1 = i/outerCount*PI;\n        \n        for(float j = 0.0; j < innerCount; j+=1.0)\n        {\n            \n            float theta2 = j/innerCount*PI;\n\n            \n            float omega1 = theta1+time;\n            float omega2 = theta2+time*sign(cos(i*PI));\n            \n            /*\n       \t \tvec3 p1 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n                           \n            omega2 += PI/outerCount*2.;\n       \t \tvec3 p2 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n            \n            omega2 -= PI/outerCount*2.;\n            omega1 += PI/outerCount*2.;\n       \t \tvec3 p3 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n            d = min(d, (sdCapsule(p, p1, p2, .05)));\n            d = min(d, (sdCapsule(p, p1, p3, .05)));\n            */\n            /*\n       \t \tvec3 p1 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n\t\t\t*/\n       \t \tvec3 p3 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n            p = rotatePoint(p, vec3(1.,0.,0.), omega1);\n            p = rotatePoint(p, vec3(0.,0.,1.), omega2);;\n            \n            d = min(d, (sdOctahedron((p)-vec3(0.), .15)));\n        }\n    }\n    return d;\n}\n\n\n// better normal implementation with half the sample points\n// used in the blog post method\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\n\nvec4 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    for(int i = 0; i < 24; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        dist += nearest;\n    }\n    return vec4(computeSurfaceNormal(p+dir*dist), dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 cameraPosition = vec3(sin(iTime), 0.0, cos(iTime));\n\tvec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0, -1.0*cos(iTime));\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n  \n    // generate the ray for this pixel\n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy);\n    \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec4 sum = intersectWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4((flux(sum.w*PI*12.)+sum.xyz)/sum.w, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3Dc.jpg", "access": "api", "license": "proprietary-license", "functions": [[538, 538, 582, 582, 639], [640, 640, 692, 692, 819], [1043, 1043, 1082, 1082, 2981], [2984, 3076, 3110, 3110, 3327], [3331, 3331, 3373, 3373, 3601], [3603, 3603, 3660, 3660, 4466]], "test": "untested"}
{"id": "ttGGDc", "name": "Party Tree", "author": "zovox", "description": "Tree dancing to music.", "tags": ["tree", "party"], "likes": 5, "viewed": 436, "published": 3, "date": "1580063759", "time_retrieved": "2024-07-30T21:28:23.422826", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 sample1 = texture(iChannel0, uv);\n    fragColor = sample1; return;\n    fragColor = vec4(sample1.a); return;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//-----------------CONSTANTS MACROS-----------------\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n//--------------------------------------------------\nfloat height = 0.;\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime*GR+height)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\n\nvec2 saw(vec2 x) { return vec2(saw(x.x), saw(x.y)); }\nvec3 saw(vec3 x) { return vec3(saw(x.x), saw(x.y), saw(x.z)); }\nvec4 saw(vec4 x) { return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w)); }\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\nfloat draw(vec2 uv)\n{\n    return (1.-smoothstep(0., .1, abs(uv.x-.5)))*(1.-smoothstep(0.9, 1., abs(uv.y)+.5));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy)/iResolution.xy;//*2.-1.;\n    vec2 uv0 = p;\n    p.x = (p.x*2.-1.);\n    p.x *= iResolution.x/iResolution.y;\n\tp.x = p.x *.5+.5;\n    \n    height = (texture(iChannel0, vec2(.5,.5)).r+.5);\n    p = (p*2.-1.)*height*.5+.5;\n    vec3 col = vec3(0.);\n\n    const float max_iterations = 16.;\n    \n    float map = 0.;\n    map += draw(p);\n    for(float f = 0.; f < max_iterations; f+=1.){\n        float iteration = (f/max_iterations+1.);\n        float angle = time;//sin(time*iteration)/PI-1.*PI/4.;\n\n        vec2 a = vec2(1., 1.);\n        vec2 b = vec2(0., 1.);\n        vec2 c = vec2(0., 0.);\n        vec2 d = vec2(1., 0.);\n        \n        p = p*2.-1.;\n        \n        vec2 s = vec2(.75+.125*sin(time));\n        vec2 o = vec2(.5+sin(time)*.125+.25 , 0.);\n        mat2 m = rotate(angle);\n        \n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n        \n        a = a*m; b = b*m; c = c*m; d = d*m;\n        a *= s; b *= s; c *= s; d *= s;\n        a += o; b += o; c += o; d += o;\n\n        \n        /*\n        //= a*.5+.5; b = b*.5+.5; c = c*.5+.5; d = d*.5+.5;\n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n\t\t*/\n\n        vec2 a2 = a*vec2(-1., 1.);\n        vec2 b2 = b*vec2(-1., 1.);\n        vec2 c2 = c*vec2(-1., 1.);\n        vec2 d2 = d*vec2(-1., 1.);\n        if(p.x > 0.)\n        \tp = (invBilinear( p, a, b, c, d ));\n        else\n        \tp = (invBilinear( p, a2, b2, c2, d2 ));\n            \n        map += draw(p);\n    }\n\n    float w = clamp(map, 0., 1.);\n    fragColor = vec4(flux(map*PI+time), 1.0 )*w+texture(iChannel1, uv0)*(1.-w);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 20984, "src": "https://soundcloud.com/kadeunit/school-mix-welcome-week-edition", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "//-----------------USEFUL-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n#define time ((saw(float(__LINE__))*.125+.25)*(iTime+12345.12345))\n#define saw(x) (acos(cos(x))/PI)\n\n\n//-----------------RENDER-----------------\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 2.0;//+saw(time*1.1234)*4.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord/iResolution.xy;\n    vec4 sample0 = texture(iChannel0, uv0);\n    \n    vec2 uv = uv0;\n    \n    float scale = 2.0*PI;\n    \n    float variety = time;\n    \n    float len = sqrt(clamp(length(uv0*2.0-1.0), 0.0, 1.0));\n    \n    float recursion1 = clamp(saw(variety*PI)*3.0-1.0, 0.0, 1.0)*len;\n    float recursion2 = clamp(saw(variety*PI)*3.0-1.0, 0.0, 1.0)*len;\n    \n    uv = ((spiral(scale*(spiral(scale*((uv)*2.0-1.0))*2.0-1.0))*2.0-1.0)*recursion1+(1.0-recursion1)*(uv*2.0-1.0))\n        \t*(1.0-recursion2)+recursion2*(saw(uv*PI*(5.0+sin(time)*5.0))*2.0-1.0);\n    \n    vec2 direction = uv*iResolution.xy/60.0;\n    \n    vec4 sample1 = texture(iChannel0, uv0+direction/iResolution.xy*sample0.a);\n    \n    fragColor = (sample1)*sample0.a+sample0*(1.0-sample0.a);\n    fragColor.rgb -= 5.0/255.0*sample0.a;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 217]], "test": "untested"}
{"id": "wlG3Dc", "name": "Meteor Galaxies", "author": "zovox", "description": "One of a few.", "tags": ["galaxies", "meteor"], "likes": 12, "viewed": 1070, "published": 3, "date": "1580063739", "time_retrieved": "2024-07-30T21:28:24.220692", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/GR/PI/E)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n//-----------------TREES---------------------------\nfloat distTree = 0.0;\nfloat angleTree = 0.0;\n\n//-----------------BASE IMAGE--------------------------\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime*PI*2.0;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time*PI*4.0), 1.0);\n    \n    vec4 final = (acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.)))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r);\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 4;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, multa+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offa\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        vec2 denominator = cmul(uv, multb+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offb\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        quotient += (cdiv(numerator, denominator));\n        \n        \n    }\n        \n    float a = atan(quotient.y, quotient.x);\n    \n    angleTree = a/PI;\n    distTree = length(quotient.xy);\n    \n    //quotient = rotatePoint(vec3(quotient, 0.0), vec3(0.0, 0.0, 1.0), a).xy;\n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    \n    \n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvec3 weights[32];\n\nvec4 stars(vec2 uv)\n{\n    float density = 2.0;\n    uv *= density;\n    float s = floor(uv.x)*1234.1234+floor(uv.y)*123.123;\n    vec2 p = floor(uv)+saw(floor(uv)+iTime+s)*.5+.25;\n    \n    float l = length(p-uv);\n    float f = smoothstep(.1*GR, 1.0, exp(-l*8.0));\n    \n    return vec4(clamp(flux(time+f+s)*f+f*f*f, 0.0, 1.0), f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float center = 1.0E32;\n    float angle = atan(uv.y, uv.x)/PI;\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    border *= (1.0-color.a);//*antispeckle;\n    \n    for(int i = 0; i < max_iterations; i++)\n        weights[i] = vec3(vec2(0.0), 1.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI*4.0)*.5+1.0;\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI*4.0)*2.0;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI*4.0)*.5+1.0;\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI*4.0)*2.0;\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n        antispeckle *= stretch;\n\n        float weight = pow(antispeckle, 1.0/float(i+1));\n        \n        weights[i] = vec3(uv*2.0-1.0, weight);\n\n        border *= clamp(1.0-color.a, 0.0, 1.0);//*antispeckle;\n\n        float skip = saw(floor(uv.x+uv.y)*PI*123.0);\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        center = min(min(center, distTree), weight);\n        \n        angle = (angle*angleTree);\n        \n        color += (galaxy((p.xy)*2.0-1.0)+stars(p.xy))*pow(border, 1.0/float(i+1))*weight;//+stars(p.xy)*draw, 0.0, 1.0);\n\n    }\n    float weight = color.a;//*pow(antispeckle, 1.0/float(max_iterations));\n    \n    vec4 s = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    fragColor = clamp(vec4((color)*GR)*weight+(1.0-weight)*s, 0.0, 1.0);\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlG3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 124]], "test": "untested"}
{"id": "tty3Dc", "name": "Melting Galaxies", "author": "zovox", "description": "Galaxies that look like they're melting.", "tags": ["melting", "galaxies"], "likes": 7, "viewed": 471, "published": 3, "date": "1580063721", "time_retrieved": "2024-07-30T21:28:24.988639", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    fragColor = color;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E/PI+1.0/PI/GR/E/PI)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n//-----------------TREES---------------------------\nfloat distTree = 0.0;\nfloat angleTree = 0.0;\n\n//-----------------BASE IMAGE--------------------------\n\nvec4 stars(vec2 uv)\n{\n    float density = 2.0;\n    uv *= density;\n    float s = floor(uv.x)*1234.1234+floor(uv.y)*123.123;\n    vec2 p = floor(uv)+saw(floor(uv)+iTime+s)*.5+.25;\n    \n    float l = length(p-uv);\n    float f = smoothstep(.1*GR, 1.0, exp(-l*8.0));\n    \n    return vec4(clamp(flux(f+s+seedling)*f+f*f*f, 0.0, 1.0), f);\n}\n\nvec4 galaxy(vec2 uv)\n{\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time*(saw(seedling)+1.0)*PI*4.0).xy;;\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = time;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    float plant = (seedling*GR+1.0/GR)*4.0*PI;\n    \n    \n    float arms = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0);\n    \n    vec4 color = vec4(flux(plant*PI+arms+time*PI)*smoothstep(0.0, 1.0/5.0, saw(plant+arms+theta1+theta2)), 1.0)*arms;\n    \n    color += stars(uv)*arms;\n    vec4 final = clamp(color/2.0, 0.0, 1.0);\n         \n    final /= r1;\n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return clamp(final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r)*length(color.rgb), 0.0, 1.0);\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 16;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = uv;\n        vec2 denominator =rotatePoint(vec3(cmul(uv, sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))), 0.0), \n                                      vec3(0.0, 0.0, 1.0), time).xy\n            +vec2(cos(iteration*16.0*PI-(time+seedling)), sin(iteration*16.0*PI-(time+seedling)))*iteration*2.0;\n        vec2 final = (cdiv(numerator, denominator));\n        quotient += final/(float(bends));\n        \n        \n    }\n        \n    float a = atan(quotient.y, quotient.x);\n    \n    angleTree = a/PI;\n    distTree = length(quotient.xy);\n    \n    //quotient = rotatePoint(vec3(quotient, 0.0), vec3(0.0, 0.0, 1.0), a).xy;\n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    \n    \n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv)\n{\n    uv += offset;\n    \n    \n    vec2 final = mobius(uv);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvec3 weights[32];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = GR*5.0+2.0*sin(time*12.0*PI);\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float center = 1.0E32;\n    float angle = atan(uv.y, uv.x)/PI;\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    border *= (1.0-color.a);//*antispeckle;\n    \n    for(int i = 0; i < max_iterations; i++)\n        weights[i] = vec3(vec2(0.0), 1.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv);\n        \n        antispeckle *= clamp(1.0/length(fwidth(uv)), 0.0, 1.0);\n\n        float weight = smoothstep(0.0, 1.0, pow(antispeckle, 1.0/float(i+1)));\n        \n        weights[i] = vec3(uv*2.0-1.0, weight);\n\n        float draw = border*(1.0-color.a);\n\n        float skip = saw(floor(uv.x+uv.y)*PI*123.0);\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        center = min(center, distTree);\n        \n        angle = (angle*angleTree);\n        \n        color += (galaxy((p.xy)*2.0-1.0)+stars(p.xy))*draw*weight;//+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n    float core = (1.0-smoothstep(0.0, 1.0/PI/GR/E, antispeckle));\n    antispeckle = pow(antispeckle, 1.0/float(max_iterations));\n    fragColor = vec4((color))+smoothstep(0.0, 1.0/PI, core*antispeckle)*vec4(flux(seedling), 1.0);\n}\n\n", "buffer_a_inputs": [], "buffer_b_code": "#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float l = length(uv*2.0-1.0);\n    vec4 sample0 = texture(iChannel0, uv);\n    vec4 sample1 = texture(iChannel1, uv+sin(\n        vec2(iTime/1.1,iTime)*3.14+\n        uv*2.0-1.0)/60.0/PI);\n    \n    \n    fragColor = clamp((sample1)*(1.0-sample0.a)+sample0-1.0/60.0, 0.0, 1.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tty3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 167]], "test": "untested"}
{"id": "3lKGD3", "name": "Interesting Flower", "author": "zovox", "description": "Interesting Flower", "tags": ["flower", "interesting"], "likes": 3, "viewed": 270, "published": 3, "date": "1580063705", "time_retrieved": "2024-07-30T21:28:25.830389", "image_code": "//-----------------CONSTANTS MACROS-----------------\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n//--------------------------------------------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), -sin(x), cos(x)); }\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    if( w<0.0 ) return vec2(-1.0);\n    w = sqrt( w );\n\n    // will fail for k0=0, which is only on the ba edge \n    float v = 2.0*k0/(-k1 - w); \n    if( v<0.0 || v>1.0 ) v = 2.0*k0/(-k1 + w);\n\n    float u = (h.x - f.x*v)/(e.x + g.x*v);\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n    return vec2( u, v );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy)/iResolution.xy*2.-1.;\n    \n    p.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 col = vec3(0.);\n\n    vec2 c = vec2(0., 0.);\n    vec2 d = vec2(0., 0.);\n\n    const float max_iterations = 4.;\n    \n    float map = 0.;\n    \n    for(float f = 0.; f < max_iterations; f+=1.){\n        float iteration = (f/max_iterations+1.);\n        float rots = 6.+3.*sin(time);\n        float angle = atan(-p.y, -p.x);\n        angle = floor(((angle/PI)*.5+.5)*rots);\n\n        vec2 a = vec2(1., 0.);\n        vec2 b = vec2(1., 0.);\n        \n        a *= rotate(-angle/rots*2.*PI);\n        angle += 1.;\n        b *= rotate(-angle/rots*2.*PI);\n\n        p = (invBilinear( p, a, b, c, d ))*2.-1.;\n\n        \n        map += 1.-smoothstep((f)/max_iterations, (f+1.)/max_iterations, (abs(p.x+p.y)));\n    }\n\n    fragColor = vec4(flux(map)*clamp(map, 0., 1.), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 382, 382, 487], [488, 488, 506, 506, 545], [547, 547, 565, 565, 614], [616, 616, 634, 634, 693], [696, 696, 718, 718, 766], [768, 768, 807, 807, 835], [837, 837, 912, 912, 1474], [1476, 1476, 1528, 1528, 1648], [1650, 1650, 1674, 1674, 1730], [1732, 1732, 1789, 1789, 2654]], "test": "untested"}
{"id": "3tK3W3", "name": "Heart Tree", "author": "zovox", "description": "Heart <3 the Heart Tree!!", "tags": ["tree", "heart"], "likes": 3, "viewed": 283, "published": 3, "date": "1580063685", "time_retrieved": "2024-07-30T21:28:26.592351", "image_code": "//-----------------CONSTANTS MACROS-----------------\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n//--------------------------------------------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\n\nvec2 saw(vec2 x) { return vec2(saw(x.x), saw(x.y)); }\nvec3 saw(vec3 x) { return vec3(saw(x.x), saw(x.y), saw(x.z)); }\nvec4 saw(vec4 x) { return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w)); }\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\nfloat draw(vec2 uv)\n{\n    return (1.-smoothstep(0., .1, abs(uv.x-.5)))*(1.-smoothstep(0.9, 1., abs(uv.y)+.5));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy)/iResolution.xy;//*2.-1.;\n    p.x = p.x*2.-1.;\n    p.x *= iResolution.x/iResolution.y;\n\tp.x = p.x *.5+.5;\n    \n    vec3 col = vec3(0.);\n\n    const float max_iterations = 16.;\n    \n    float map = 0.;\n    map += draw(p);\n    for(float f = 0.; f < max_iterations; f+=1.){\n        float iteration = (f/max_iterations+1.);\n        float angle = sin(time*iteration)/PI-1.*PI/4.;\n\n        vec2 a = vec2(1., 1.);\n        vec2 b = vec2(0., 1.);\n        vec2 c = vec2(0., 0.);\n        vec2 d = vec2(1., 0.);\n        \n        p = p*2.-1.;\n        \n        vec2 s = vec2(.75);\n        vec2 o = vec2(.5, 0.);\n        mat2 m = rotate(angle);\n        \n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n        \n        a = a*m; b = b*m; c = c*m; d = d*m;\n        a *= s; b *= s; c *= s; d *= s;\n        a += o; b += o; c += o; d += o;\n\n        \n        /*\n        //= a*.5+.5; b = b*.5+.5; c = c*.5+.5; d = d*.5+.5;\n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n\t\t*/\n\n        vec2 a2 = a*vec2(-1., 1.);\n        vec2 b2 = b*vec2(-1., 1.);\n        vec2 c2 = c*vec2(-1., 1.);\n        vec2 d2 = d*vec2(-1., 1.);\n        if(p.x > 0.)\n        \tp = (invBilinear( p, a, b, c, d ));\n        else\n        \tp = (invBilinear( p, a2, b2, c2, d2 ));\n            \n        map += (1.-smoothstep(0., .1, abs(p.x-.5)))*(1.-smoothstep(0.9, 1., abs(p.y)+.5));\n    }\n    fragColor = vec4(flux(map*PI), 1.0 )*clamp(map, 0., 1.)+clamp(1.-map, 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tK3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 382, 382, 487], [489, 489, 507, 507, 542], [543, 543, 561, 561, 606], [607, 607, 625, 625, 680], [683, 683, 705, 705, 753], [755, 755, 794, 794, 822], [824, 824, 899, 899, 1871], [1873, 1873, 1894, 1894, 1985], [1986, 1986, 2043, 2043, 3496]], "test": "untested"}
{"id": "3tVGW3", "name": "Galactic Particles", "author": "zovox", "description": "Galaxies emitting particles to the beat of a Sound Cloud song.", "tags": ["particles", "galactic"], "likes": 3, "viewed": 370, "published": 3, "date": "1580063656", "time_retrieved": "2024-07-30T21:28:27.653514", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/GR/PI/E)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.333, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 sample1 = texture(iChannel0, uv);\n    vec4 sample2 = texture(iChannel1, uv);\n    \n    float w = smoothstep(0.0, 1.0, length(sample2.zw)/sqrt(2.0));\n    \n    fragColor.rgb = (sample1.rgb*w+\n                     \n                      (1.0-w)*GR);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/GR/PI/E)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\nconst int numWeights = 32;\n\nfloat lowAverage()\n{\n    const int iters = numWeights;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel1, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n//-----------------TREES---------------------------\nfloat distTree = 0.0;\nfloat angleTree = 0.0;\n\n//-----------------BASE IMAGE--------------------------\n\nvec4 galaxy(vec2 uv)\n{\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time*(saw(seedling)+1.0)*PI*4.0).xy;;\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = time;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    float plant = (seedling*GR+1.0/GR)*4.0*PI;\n    \n    \n    float arms = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0);\n    \n    vec4 color = vec4(flux(plant*PI+arms+time*PI)*smoothstep(0.0, 1.0/3.0, saw(plant+arms+theta1+theta2)), 1.0)*arms;\n    \n    vec4 final = clamp(color/2.0, 0.0, 1.0);\n         \n    final /= r1;\n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return clamp(final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r)*length(color.rgb), 0.0, 1.0);\n}\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 2;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, multa+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offa\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        vec2 denominator = cmul(uv, multb+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offb\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        quotient += (cdiv(numerator, denominator));\n        \n        \n    }\n        \n    float a = atan(quotient.y, quotient.x);\n    \n    angleTree = a/PI;\n    distTree = length(quotient.xy);\n    \n    //quotient = rotatePoint(vec3(quotient, 0.0), vec3(0.0, 0.0, 1.0), a).xy;\n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    \n    \n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvec3 weights[32];\n\nvec4 stars(vec2 uv)\n{\n    float density = 2.0;\n    uv *= density;\n    float s = floor(uv.x)*1234.1234+floor(uv.y)*123.123;\n    vec2 p = floor(uv)+saw(floor(uv)+iTime+s)*.5+.25;\n    \n    float l = length(p-uv);\n    float f = smoothstep(.1*GR, 1.0, exp(-l*8.0));\n    \n    return vec4(clamp(flux(time+f+s)*f+f*f*f, 0.0, 1.0), f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float height = max(lowAverage(), last_height)-1.0/30.0;\n    float delta = height-last_height;\n    last_height = height;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E*PI+last_height*PI*E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float center = 1.0E32;\n    float angle = atan(uv.y, uv.x)/PI;\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    border *= (1.0-color.a);//*antispeckle;\n    \n    for(int i = 0; i < max_iterations; i++)\n        weights[i] = vec3(vec2(0.0), 1.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI*4.0)*.5+1.0;\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI*4.0)*2.0;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI*4.0)*.5+1.0;\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI*4.0)*2.0;\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n        antispeckle *= stretch;\n\n        float weight = smoothstep(0.0, 1.0, pow(antispeckle, 1.0/float(i+1)));\n        \n        weights[i] = vec3(uv*2.0-1.0, weight);\n\n        float draw = border*(1.0-color.a);\n\n        float skip = saw(floor(uv.x+uv.y)*PI*123.0);\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        center = min(center, distTree);\n        \n        angle = (angle*angleTree);\n        \n        color += (galaxy((p.xy)*2.0-1.0))*draw*weight;//+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n    \n    fragColor = vec4((color.rgba)*(1./GR+last_height))*delta;\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 20986, "src": "https://soundcloud.com/kadeunit/school-mix-welcome-week-edition", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "//-----------------USEFUL-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n#define time ((saw(float(__LINE__))/GR+.5/GR)*(iTime/PI+12345.12345))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n#define R 3.0\n#define RESTITUTION 1.\n\nvec4 FindArrivingParticle( vec2 arriveCoord )\n{\n    vec4 p = vec4(0.0);\n    float sum = 0.0;\n    for( float i = -R; i <= R; i++ )\n    {\n        for( float j = -R; j <= R; j++ )\n        {\n            vec2 partCoord = arriveCoord + vec2( i, j )/ iResolution.xy;\n            \n            vec4 part = texture( iChannel1, partCoord );\n            \n            \n            vec2 nextPos = part.xy + .5*(part.zw*2.0-1.0)/ iResolution.xy * R* R;\n            // arrival means within half a pixel of this bucket\n            vec2 off = (nextPos - arriveCoord)*iResolution.xy;\n            if( abs(off.x)<= sqrt(1./2.) && abs(off.y)<=sqrt(1./2.) )\n            {\n                // yes! greedily take this particle.\n                // a better algorithm might be to inspect all particles that arrive here\n                // and pick the one with the highest velocity.\n                p += part;\n                sum += 1.0;\n            }\n        }\n    }\n    // no particle arriving at this bucket.\n    return p/sum;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv0 = uv;\n    vec4 sample0 = texture(iChannel1, uv0);\n    vec4 sample1 = texture(iChannel0, uv0);\n    vec4 arrival = FindArrivingParticle(uv);\n    \n    if(iFrame == 0)\n    {\n        fragColor = vec4(vec2(0.0), vec2(0.5, 0.5));\n        return;\n    }\n    \n    float thresh = (32.0+16.0)/255.0;\n    \n    float w = clamp(length(sample1.rgb)/sqrt(3.0)*sample1.a, 0.0, 1.0);\n    \n    if(w > thresh || length(sample0.xy-uv) > sqrt(10.0)/length(iResolution.xy))\n    {\n        w = (w - thresh)/(1.0-thresh);\n        fragColor = vec4(uv0, (saw(sample1.xy*PI*2.0+w*2.0*PI)));\n        return;\n    }\n    \n    w = (thresh-w)/(thresh);\n    arrival.xy += .5*(arrival.zw*2.0-1.0)/ iResolution.xy * R * R;\n    //arrival.zw = ((arrival.zw*2.0-1.0)*.975)*.5+.5;\n    fragColor.xyzw = (arrival.xyzw);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[878, 878, 898, 898, 1015], [1016, 1016, 1034, 1034, 1073], [1075, 1075, 1093, 1093, 1142], [1143, 1143, 1161, 1161, 1220], [1222, 1222, 1279, 1279, 1579]], "test": "untested"}
{"id": "tlG3Dc", "name": "Galactic Meteors", "author": "zovox", "description": "One of a few.", "tags": ["meteors", "galactic"], "likes": 10, "viewed": 494, "published": 3, "date": "1580063629", "time_retrieved": "2024-07-30T21:28:28.770528", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/GR/PI/E)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n//-----------------TREES---------------------------\nfloat distTree = 0.0;\nfloat angleTree = 0.0;\n\n//-----------------BASE IMAGE--------------------------\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime*PI*2.0;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time*PI*4.0), 1.0);\n    \n    vec4 final = (acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.)))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r);\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 2;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, multa+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offa\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        vec2 denominator = cmul(uv, multb+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offb\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        quotient += (cdiv(numerator, denominator));\n        \n        \n    }\n        \n    float a = atan(quotient.y, quotient.x);\n    \n    angleTree = a/PI;\n    distTree = length(quotient.xy);\n    \n    //quotient = rotatePoint(vec3(quotient, 0.0), vec3(0.0, 0.0, 1.0), a).xy;\n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    \n    \n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvec3 weights[32];\n\nvec4 stars(vec2 uv)\n{\n    float density = 2.0;\n    uv *= density;\n    float s = floor(uv.x)*1234.1234+floor(uv.y)*123.123;\n    vec2 p = floor(uv)+saw(floor(uv)+iTime+s)*.5+.25;\n    \n    float l = length(p-uv);\n    float f = smoothstep(.1*GR, 1.0, exp(-l*8.0));\n    \n    return vec4(clamp(flux(time+f+s)*f+f*f*f, 0.0, 1.0), f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 8;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float center = 1.0E32;\n    float angle = atan(uv.y, uv.x)/PI;\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    border *= (1.0-color.a);//*antispeckle;\n    \n    for(int i = 0; i < max_iterations; i++)\n        weights[i] = vec3(vec2(0.0), 1.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI*4.0)*.5+1.0;\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI*4.0)*2.0;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI*4.0)*.5+1.0;\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI*4.0)*2.0;\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n        antispeckle *= stretch;\n\n        float weight = smoothstep(0.0, 1.0, pow(antispeckle, 1.0/float(i+1)));\n        \n        weights[i] = vec3(uv*2.0-1.0, weight);\n\n        float draw = border*(1.0-color.a);\n\n        float skip = saw(floor(uv.x+uv.y)*PI*123.0);\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        center = min(center, distTree);\n        \n        angle = (angle*angleTree);\n        \n        color += (galaxy((p.xy)*2.0-1.0)+stars(p.xy))*draw*weight;//+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n    \n    fragColor = vec4((color)*GR);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlG3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[877, 877, 897, 897, 1014], [1015, 1015, 1033, 1033, 1072], [1074, 1074, 1092, 1092, 1141], [1142, 1142, 1160, 1160, 1219], [1584, 1584, 1606, 1606, 2474], [2539, 2539, 2568, 2568, 2638], [2640, 2640, 2669, 2669, 2753], [2755, 2755, 2823, 2871, 4140], [4204, 4204, 4309, 4309, 5054], [5079, 5079, 5100, 5100, 5407], [5409, 5409, 5466, 5466, 7414]], "test": "untested"}
{"id": "tty3Wc", "name": "Fractal Spiral Mapping", "author": "zovox", "description": "2-dimensional spiral mapping of a Julia set fractal.", "tags": ["fractal", "spiral", "mapping"], "likes": 4, "viewed": 297, "published": 3, "date": "1580063614", "time_retrieved": "2024-07-30T21:28:29.651173", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nfloat draw(vec2 p)\n{\n    \n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n        if( m2>1024.0 ) continue;\n\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n\n\td = clamp( 8.0*d/zoo, 0.0, 1.0 );\n\td = pow( d, 0.25 );\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float scale = 2.0*PI;\n    uv *= scale;\n    uv -= scale/2.0;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv += vec2(cos(iTime*.234), sin(iTime*.345))*1.0;\n    uv = spiral(uv*scale);\n    uv = spiral(uv);\n   fragColor = vec4(draw(saw(uv*1.0*PI)*2.0-1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tty3Wc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 70, 70, 102], [103, 103, 121, 121, 153], [155, 155, 177, 177, 351], [353, 353, 373, 396, 970], [972, 972, 1029, 1029, 1333]], "test": "untested"}
{"id": "WtVGD3", "name": "Flower Fractal", "author": "zovox", "description": "Flower Fractal", "tags": ["fractal", "flower"], "likes": 1, "viewed": 262, "published": 3, "date": "1580063594", "time_retrieved": "2024-07-30T21:28:30.392192", "image_code": "//-----------------CONSTANTS MACROS-----------------\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n//--------------------------------------------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\n\nvec2 saw(vec2 x) { return vec2(saw(x.x), saw(x.y)); }\nvec3 saw(vec3 x) { return vec3(saw(x.x), saw(x.y), saw(x.z)); }\nvec4 saw(vec4 x) { return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w)); }\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy)/iResolution.xy*2.-1.;\n    \n    p.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 col = vec3(0.);\n\n\n    const float max_iterations = 4.;\n    \n    float map = 0.;\n    \n    for(float f = 0.; f < max_iterations; f+=1.){\n        float iteration = (f/max_iterations+1.);\n        float rots = floor(3.+12.*saw(time))+1./MAX_DIM;\n        float angle = atan(-p.y, -p.x);\n        float radius = length(p);\n        angle = floor(((angle/PI)*.5+.5)*rots);\n\n        vec2 a = vec2(1., 0.);\n        vec2 b = vec2(1., 0.);\n        vec2 c = vec2(0., 1./MAX_DIM);\n        vec2 d = vec2(0., -1./MAX_DIM);\n        \n        \n\n        \n        b *= rotate(angle/rots*2.*PI);\n        angle += 1.;\n        a *= rotate(angle/rots*2.*PI);\n\n        \n        p = (invBilinear( p, a, b, c, d ));\n\n        map += 1.-smoothstep(0., 1., abs(p.y-.5));\n        p = p*2.-1.;\n    }\n    fragColor = vec4(flux(map*PI), 1.0 )*clamp(map, 0., 1.)+clamp(1.-map, 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 382, 382, 487], [489, 489, 507, 507, 542], [543, 543, 561, 561, 606], [607, 607, 625, 625, 680], [683, 683, 705, 705, 753], [755, 755, 794, 794, 822], [824, 824, 899, 899, 1871], [1873, 1873, 1902, 1902, 1972], [1974, 1974, 2003, 2003, 2087], [2089, 2089, 2146, 2146, 3107]], "test": "untested"}
{"id": "WtK3W3", "name": "Dark Heart Tree", "author": "zovox", "description": "Heart <3 the Dark Heart Tree!!", "tags": ["tree", "heart", "dark"], "likes": 4, "viewed": 271, "published": 3, "date": "1580063582", "time_retrieved": "2024-07-30T21:28:31.149168", "image_code": "//-----------------CONSTANTS MACROS-----------------\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n//--------------------------------------------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\n\nvec2 saw(vec2 x) { return vec2(saw(x.x), saw(x.y)); }\nvec3 saw(vec3 x) { return vec3(saw(x.x), saw(x.y), saw(x.z)); }\nvec4 saw(vec4 x) { return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w)); }\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\nfloat draw(vec2 uv)\n{\n    return (1.-smoothstep(0., .1, abs(uv.x-.5)))*(1.-smoothstep(0.9, 1., abs(uv.y)+.5));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy)/iResolution.xy;//*2.-1.;\n    p.x = p.x*2.-1.;\n    p.x *= iResolution.x/iResolution.y;\n\tp.x = p.x *.5+.5;\n    \n    vec3 col = vec3(0.);\n\n    const float max_iterations = 16.;\n    \n    float map = 0.;\n    map += draw(p);\n    for(float f = 0.; f < max_iterations; f+=1.){\n        float iteration = (f/max_iterations+1.);\n        float angle = sin(time*iteration)/PI-1.*PI/4.;\n\n        vec2 a = vec2(1., 1.);\n        vec2 b = vec2(0., 1.);\n        vec2 c = vec2(0., 0.);\n        vec2 d = vec2(1., 0.);\n        \n        p = p*2.-1.;\n        \n        vec2 s = vec2(.75);\n        vec2 o = vec2(.5, 0.);\n        mat2 m = rotate(angle);\n        \n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n        \n        a = a*m; b = b*m; c = c*m; d = d*m;\n        a *= s; b *= s; c *= s; d *= s;\n        a += o; b += o; c += o; d += o;\n\n        \n        /*\n        //= a*.5+.5; b = b*.5+.5; c = c*.5+.5; d = d*.5+.5;\n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n\t\t*/\n\n        vec2 a2 = a*vec2(-1., 1.);\n        vec2 b2 = b*vec2(-1., 1.);\n        vec2 c2 = c*vec2(-1., 1.);\n        vec2 d2 = d*vec2(-1., 1.);\n        if(p.x > 0.)\n        \tp = (invBilinear( p, a, b, c, d ));\n        else\n        \tp = (invBilinear( p, a2, b2, c2, d2 ));\n            \n        map += draw(p);\n    }\n\n    fragColor = vec4(flux(map*PI)*clamp(map, 0., 1.), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 382, 382, 487], [489, 489, 507, 507, 542], [543, 543, 561, 561, 606], [607, 607, 625, 625, 680], [683, 683, 705, 705, 753], [755, 755, 794, 794, 822], [824, 824, 899, 899, 1871], [1873, 1873, 1894, 1894, 1985], [1986, 1986, 2043, 2043, 3408]], "test": "untested"}
{"id": "WtVGW3", "name": "Dancer", "author": "zovox", "description": "Dancer dancing to Sound Cloud music.", "tags": ["dancer"], "likes": 3, "viewed": 595, "published": 3, "date": "1580063565", "time_retrieved": "2024-07-30T21:28:32.145504", "image_code": "\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*2.0)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime+1000.0+last_height)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nfloat last_height = 0.0;\nvec3 eye = vec3 (0.0);\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdSphere(vec3 rp, vec3 rd, vec3 bp, float r) {\n    //return length(bp - rp) - r;\n    \n    vec3 oc = eye - bp;\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - r*r;\n    float disc = b * b - 4.0 * c;\n\n    if (disc < 0.0)\n        return FAR;\n\n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n\n    float t0 = q;\n    float t1 = c / q;\n\n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    \n    return length(bp - rp) - r;\n}\n\nfloat sdCapsule(vec3 rp, vec3 rd, vec3 a, vec3 b, float r) {\n    vec3 pa = rp - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    vec3 ray = rd;\n    vec3 ray2 = normalize(b-a);\n\n    float a1 = dot(ray,ray);\n    float b1 = dot(ray,ray2);\n    float c = dot(ray2,ray2);\n    float d = dot(ray,eye-a);\n    float e = dot(eye-a,ray2);\n\n    float t1 = (b1*e-c*d)/(a1*c-b1*b1);\n    float t2 = (a1*e-b1*d)/(a1*c-b1*b1);\n\n    float dist = length((eye+ray*t1)-(a+ray2*t2));\n    return dist > r || t2 < r || t2 > length(a-b)+r? FAR : length(pa - ba * h) - r;\n}\n\n\nconst int NUM_ANGLES = 5;\nconst int ELBOWS = 0;\nconst int WRISTS = 1;\nconst int FINGERS = 2;\nconst int KNEES = 3;\nconst int ANKLES = 4;\n// stance structure:\n//{\n//\tvec4(leftLegOmega, leftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftElbowOmega, relativeLeftElbowTheta, relativeRightElbowOmega, relativeRightElbowTheta)),\n//\tvec4(relativeLeftWristOmega, relativeLeftWristTheta, relativeRightWristOmega, relativeRightWristTheta)),\n//\tvec4(relativeLeftFingersOmega, relativeLeftFingersTheta, relativeRightFingersOmega, relativeRightFingersTheta)),\n//\tvec4(leftLegOmega, LeftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftKneeOmega, relativeLeftKneeTheta, relativeRightKneeOmega, relativeRightKneeTheta)),\n//\tvec4(relativeLeftAnkleOmega, relativeLeftAnkleTheta, relativeRightAnkleOmega, relativeRightAnkleTheta)),\n//}\n//\nvec4  saved_stance[NUM_ANGLES];\nvec4  stance[NUM_ANGLES];\n\nfloat saved_shoulderRot = 0.0;\nfloat shoulderRot = 0.0;\n\nfloat saved_hipRot = 0.0;\nfloat hipRot = 0.0;\n\nfloat saved_lean = 0.0;\nfloat lean = 0.0;\n\n//body joints\nvec3 head = vec3(0.0);\n\nvec3 bSpine = vec3(0.0);\nvec3 uSpine = vec3(0.0);\n\nvec3 leftShoulder = vec3(0.0);\nvec3 rightShoulder = vec3(0.0);\n\nvec3 leftElbow = vec3(0.0);\nvec3 rightElbow = vec3(0.0);\n\nvec3 leftWrist = vec3(0.0);\nvec3 rightWrist = vec3(0.0);\n\nvec3 leftFinger = vec3(0.0);\nvec3 rightFinger = vec3(0.0);\n\nvec3 leftHip = vec3(0.0);\nvec3 rightHip = vec3(0.0);\n\nvec3 leftKnee = vec3(0.0);\nvec3 leftAnkle = vec3(0.0);\n\nvec3 rightKnee = vec3(0.0);\nvec3 rightAnkle = vec3(0.0);\n\nconst vec3 downY = vec3(0.0, -1.0, 0.0);\nfloat minY = 0.0;\n\nvoid load_stance() {\n    \n   \tfor(int i = 0; i < NUM_ANGLES;i++)\n    \tstance[i] = saved_stance[i];\n    \n    shoulderRot = (saved_shoulderRot);\n    hipRot = (saved_hipRot);\n    lean = (saved_lean);\n    \n    head = vec3(0.0, GR/E, 0.0);\n    \n    ///////////////////////////////////////////////////////////////\n    //Spine////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    bSpine = head/GR;\n    uSpine = -bSpine;\n    \n    ///////////////////////////////////////////////////////////////\n    //Shoulders////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    leftShoulder = bSpine+vec3(1.0, 0.0, 0.0)/E;\n    rightShoulder = bSpine-vec3(1.0, 0.0, 0.0)/E;\n    \n    ///////////////////////////////////////////////////////////////\n    //Elbows///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 hangingLeftElbow = downY/GR;\n\n    float leftArmOmega = stance[ELBOWS].x;\n    float leftArmTheta = stance[ELBOWS].y;\n    \n    hangingLeftElbow = rotatePoint(rotatePoint(hangingLeftElbow, vec3(1.0, 0.0, 0.0), leftArmOmega), vec3(0.0, 0.0, 1.0), leftArmTheta);\n    \n    leftElbow = leftShoulder+hangingLeftElbow;\n        \n    vec3 hangingRightElbow = downY/GR;\n    \n    float rightArmOmega = stance[ELBOWS].z;\n    float rightArmTheta = stance[ELBOWS].w;\n    \n    hangingRightElbow = rotatePoint(rotatePoint(hangingRightElbow, vec3(1.0, 0.0, 0.0), rightArmOmega), vec3(0.0, 0.0, -1.0), rightArmTheta);\n    \n    rightElbow = rightShoulder+hangingRightElbow;\n    \n    ///////////////////////////////////////////////////////////////\n    //Wrists///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    vec3 straightLeftWrist = downY/E;\n\n    float leftForeArmOmega = leftArmOmega+stance[WRISTS].x;\n    float leftForeArmTheta = leftArmTheta+stance[WRISTS].y;\n    \n    straightLeftWrist = rotatePoint(rotatePoint(straightLeftWrist, vec3(1.0, 0.0, 0.0), leftForeArmOmega), vec3(0.0, 0.0, 1.0), leftForeArmTheta);\n    \n    leftWrist = leftElbow+straightLeftWrist;\n        \n    vec3 straightRightWrist = downY/E;\n    \n    float rightForeArmOmega = rightArmOmega+stance[WRISTS].z;\n    float rightForeArmTheta = rightArmTheta+stance[WRISTS].w;\n    \n    straightRightWrist = rotatePoint(rotatePoint(straightRightWrist, vec3(1.0, 0.0, 0.0), rightForeArmOmega), vec3(0.0, 0.0, -1.0), rightForeArmTheta);\n    \n    rightWrist = rightElbow+straightRightWrist;\n    \n    ///////////////////////////////////////////////////////////////\n    //Fingers//////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    vec3 straightLeftFingers = downY/PI/E;\n\n    float leftFingersOmega = leftForeArmOmega+stance[FINGERS].x;\n    float leftFingersTheta = leftForeArmTheta+stance[FINGERS].y;\n    \n    straightLeftFingers = rotatePoint(rotatePoint(straightLeftFingers, vec3(1.0, 0.0, 0.0), leftFingersOmega), vec3(0.0, 0.0, 1.0), leftFingersTheta);\n    \n    leftFinger = leftWrist+straightLeftFingers;\n        \n    vec3 straightRightFingers = downY/PI/E;\n    \n    float rightFingersOmega = rightForeArmOmega+stance[FINGERS].z;\n    float rightFingersTheta = rightForeArmTheta+stance[FINGERS].w;\n    \n    straightRightFingers = rotatePoint(rotatePoint(straightRightFingers, vec3(1.0, 0.0, 0.0), rightFingersOmega), vec3(0.0, 0.0, -1.0), rightFingersTheta);\n    \n    rightFinger = rightWrist+straightRightFingers;\n    \n    \n    ///////////////////////////////////////////////////////////////\n    //Hips/////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    leftHip = uSpine+vec3(circle(hipRot), 0.0).xzy/E/GR;\n    rightHip = uSpine-vec3(circle(hipRot), 0.0).xzy/E/GR;\n    ///////////////////////////////////////////////////////////////\n    //Knees////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 hangingLeftKnee = downY/GR;\n\n    float leftKneeOmega = stance[KNEES].x;\n    float leftKneeTheta = stance[KNEES].y;\n    \n    hangingLeftKnee = rotatePoint(rotatePoint(hangingLeftKnee, vec3(1.0, 0.0, 0.0), leftKneeOmega), vec3(0.0, 0.0, 1.0), leftKneeTheta);\n    \n    leftKnee = leftHip+hangingLeftKnee;\n        \n    vec3 hangingRightKnee = downY/GR;\n    \n    float rightKneeOmega = stance[KNEES].z;\n    float rightKneeTheta = stance[KNEES].w;\n    \n    hangingRightKnee = rotatePoint(rotatePoint(hangingRightKnee, vec3(1.0, 0.0, 0.0), rightKneeOmega), vec3(0.0, 0.0, -1.0), rightKneeTheta);\n    \n    rightKnee = rightHip+hangingRightKnee;\n    \n    ///////////////////////////////////////////////////////////////\n    //Ankles///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 straightLeftAnkle = downY/GR;\n\n    float leftAnkleOmega = leftKneeOmega+stance[ANKLES].x;\n    float leftAnkleTheta = leftKneeTheta+stance[ANKLES].y;\n    \n    straightLeftAnkle = rotatePoint(rotatePoint(straightLeftAnkle, vec3(1.0, 0.0, 0.0), leftAnkleOmega), vec3(0.0, 0.0, 1.0), leftAnkleTheta);\n    \n    leftAnkle = leftKnee+straightLeftAnkle;\n        \n    vec3 straightRightAnkle = downY/GR;\n    \n    float rightAnkleOmega = rightKneeOmega+stance[ANKLES].z;\n    float rightAnkleTheta = rightKneeTheta+stance[ANKLES].w;\n    \n    straightRightAnkle = rotatePoint(rotatePoint(straightRightAnkle, vec3(1.0, 0.0, 0.0), rightAnkleOmega), vec3(0.0, 0.0, -1.0), rightAnkleTheta);\n    \n    rightAnkle = rightKnee+straightRightAnkle;\n    \n    ///////////////////////////////////////////////////////////////\n    //Lean/////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    bSpine = rotatePoint(bSpine, vec3(1.0, 0.0, 0.0), lean);\n    head = rotatePoint(head, vec3(1.0, 0.0, 0.0), lean);\n    \n    leftShoulder = rotatePoint(leftShoulder, vec3(1.0, 0.0, 0.0), lean);\n    rightShoulder = rotatePoint(rightShoulder, vec3(1.0, 0.0, 0.0), lean);\n    leftElbow = rotatePoint(leftElbow, vec3(1.0, 0.0, 0.0), lean);\n    rightElbow = rotatePoint(rightElbow, vec3(1.0, 0.0, 0.0), lean);\n    leftWrist = rotatePoint(leftWrist, vec3(1.0, 0.0, 0.0), lean);\n    rightWrist = rotatePoint(rightWrist, vec3(1.0, 0.0, 0.0), lean);\n    leftFinger = rotatePoint(leftFinger, vec3(1.0, 0.0, 0.0), lean);\n    rightFinger = rotatePoint(rightFinger, vec3(1.0, 0.0, 0.0), lean);\n    \n    ///////////////////////////////////////////////////////////////\n    //Shoulder Rotation////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n\n    leftShoulder = rotatePoint(leftShoulder, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightShoulder = rotatePoint(rightShoulder, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftElbow = rotatePoint(leftElbow, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightElbow = rotatePoint(rightElbow, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftWrist = rotatePoint(leftWrist, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightWrist = rotatePoint(rightWrist, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftFinger = rotatePoint(leftFinger, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightFinger = rotatePoint(rightFinger, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    \n    ///////////////////////////////////////////////////////////////\n    //Hip Rotation/////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    //MIN calc\n \tfloat lowestY = min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(bSpine.y, uSpine.y),\n                                                                            leftShoulder.y),\n                                                                        rightShoulder.y),\n                                                                    leftElbow.y),\n                                                                rightElbow.y),\n                                                            leftWrist.y),\n                                                        rightWrist.y),\n                                                    leftFinger.y), \n                                                rightFinger.y), \n                                            leftHip.y), \n                                        rightHip.y), \n                                    leftKnee.y), \n                                leftAnkle.y),\n                            rightKnee.y),\n                        rightAnkle.y);\n    minY = min(lowestY, minY);\n}\n\nfloat dfScene(vec3 rp, vec3 rd) {\n    \n    float msd = 99.0;\n    \n    float scale = GR;\n    \n    //hip\n    msd = min(msd, sdSphere(rp, rd, leftHip, 0.06*scale));\n    msd = min(msd, sdSphere(rp, rd, rightHip, 0.06*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftHip, rightHip, 0.02*scale));\n    //left thigh\n    msd = min(msd, sdSphere(rp, rd, leftKnee, 0.05*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftHip, leftKnee, 0.02*scale));\n    //left shin\n    msd = min(msd, sdSphere(rp, rd, leftAnkle, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftKnee, leftAnkle, 0.015*scale));\n    //right thigh\n    msd = min(msd, sdSphere(rp, rd, rightKnee, 0.05*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightHip, rightKnee, 0.02*scale));\n    //right shin\n    msd = min(msd, sdSphere(rp, rd, rightAnkle, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightKnee, rightAnkle, 0.015*scale));\n    //spine\n    msd = min(msd, sdSphere(rp, rd, bSpine, 0.04*scale));\n    msd = min(msd, sdSphere(rp, rd, uSpine, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, bSpine, uSpine, 0.02*scale));\n    //shoulder\n    msd = min(msd, sdSphere(rp, rd, leftShoulder, 0.05*scale));\n    msd = min(msd, sdSphere(rp, rd, rightShoulder, 0.05*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftShoulder, rightShoulder, 0.02*scale));\n    //left upper arm\n    msd = min(msd, sdSphere(rp, rd, leftElbow, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftShoulder, leftElbow, 0.02*scale));\n    //left lower arm\n    msd = min(msd, sdSphere(rp, rd, leftWrist, 0.03*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftElbow, leftWrist, 0.015*scale));\n    //left finger\n    msd = min(msd, sdSphere(rp, rd, leftFinger, 0.015*scale));\n    msd = min(msd, sdCapsule(rp, rd, leftWrist, leftFinger, 0.01*scale));\n    //right upper arm \n    msd = min(msd, sdSphere(rp, rd, rightElbow, 0.04*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightShoulder, rightElbow, 0.02*scale));\n    //right lower arm\n    msd = min(msd, sdSphere(rp, rd, rightWrist, 0.03*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightElbow, rightWrist, 0.015*scale));\n    //right finger\n    msd = min(msd, sdSphere(rp, rd, rightFinger, 0.015*scale));\n    msd = min(msd, sdCapsule(rp, rd, rightWrist, rightFinger, 0.01*scale));\n    //head\n    msd = min(msd, sdSphere(rp, rd, head, 0.15));\n    \n    return msd;\n}\n\nvec3 surfaceNormal(vec3 p, vec3 rd) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy, rd), d2 = dfScene(p - e.xyy, rd);\n\tfloat d3 = dfScene(p + e.yxy, rd), d4 = dfScene(p - e.yxy, rd);\n\tfloat d5 = dfScene(p + e.yyx, rd), d6 = dfScene(p - e.yyx, rd);\n\tfloat d = dfScene(p, rd) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//IQ\nfloat calcAO(vec3 pos, vec3 nor, vec3 rd) {   \n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.05*float(i);\n        vec3 aopos = pos + nor*hr;\n        occ += smoothstep(0.0, 0.7, hr - dfScene(aopos, rd)) * sca;\n        sca *= 0.97;\n    }\n    return clamp(1.0 - 3.0 * occ , 0.0, 1.0);\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \n    for (int i = 0; i < 8; i++) {\n        rp = ro + rd * d;\n        eye = rp;\n        float ns = dfScene(rp, rd);\n        d += ns;\n        if (ns < 1.0/MAX_DIM || d > FAR) break;\n    }\n    \n    if (d < FAR) {\n\n        vec3 sc = vec3(1.0, 0.0, 0.0); //surface colour\n        vec3 n = surfaceNormal(rp, rd);\n        float ao = calcAO(rp, n, rd);\n        \n        float diff = max(dot(n, lp), 0.0); //diffuse\n\t    pc = sc * 0.5 + diff * sc * ao;\n        float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n        pc = pc + spe * vec3(1.0);\n    }\n    \n    return pc;\n}\n\nconst int numWeights = 512;\n\nvec3 weights[numWeights];\n\nfloat lowAverage()\n{\n    const int iters = numWeights;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.25)).r;\n        \n        product *= sound;\n        sum += sound;\n        \n        weights[i].r = sound;\n    }\n    for(int i = 0; i < iters; i++)\n        weights[i].gb = vec2(sum/float(iters), pow(product, 1.0/float(iters)));\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nvoid clear_stance()\n{\n   \tfor(int i = 0; i < NUM_ANGLES;i++)\n        stance[i] = vec4(0.0);\n    shoulderRot = 0.0;\n    hipRot = 0.0;\n    lean = 0.0;\n}\n\nvoid dance1()\n{\n    clear_stance();\n\tfloat twist = time;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    vec2 twistCircle = circle(twist*GR)*GR;\n    \n    stance[ELBOWS].x = twistCircle.x;\n    stance[ELBOWS].y = twistCircle.x/PI;\n    stance[ELBOWS].z = twistCircle.y;\n    stance[ELBOWS].w = twistCircle.y/PI;\n    \n    stance[WRISTS].x = (stance[ELBOWS].x*.5+.5);\n    stance[WRISTS].z = (stance[ELBOWS].z*.5+.5);\n    \n    shoulderRot = sin(PI+twist*PI*3.0)/PI/GR;\n    hipRot = sin(twist*PI*3.0)/PI/GR;\n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance2()\n{\n    clear_stance();\n\tfloat run = time*PI;\n    \n    vec2 runCircleA = circle(run)*.5+.5;\n    vec2 runCircleB = circle(run+PI)*.5+.5;\n    \n    stance[ELBOWS].x = (runCircleA.x*2.0-1.0)*GR;\n    stance[ELBOWS].z = (runCircleB.x*2.0-1.0)*GR;\n    \n    stance[KNEES].x = runCircleA.x*2.0-1.0;\n    stance[KNEES].z = runCircleB.x*2.0-1.0;\n    stance[ANKLES].x = runCircleA.y;\n    stance[ANKLES].z = runCircleB.y;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance3()\n{\n    clear_stance();\n    \n    float wave = time*PI*PI;\n    \n    \n    stance[ELBOWS].y = PI/2.0+sin(wave)/PI;\n    stance[ELBOWS].w = PI/2.0+sin(wave+PI/2.0)/PI;\n    \n    stance[WRISTS].y = sin(wave-PI/2.0)/PI;\n    stance[WRISTS].w = sin(wave+PI)/PI;\n    \n    stance[FINGERS].y = sin(wave-PI)/PI;\n    stance[FINGERS].w = sin(wave+PI*3.0/2.0)/PI;\n    \n    hipRot = sin(time*PI*3.0)/PI/GR;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance4()\n{\n    clear_stance();\n    \n    float wave = time*PI*PI;\n    \n    \n    stance[ELBOWS].y = PI+sin(wave)/PI;\n    stance[ELBOWS].w = PI+sin(wave+PI/2.0)/PI;\n    \n    stance[WRISTS].y = sin(wave-PI/2.0)/PI;\n    stance[WRISTS].w = sin(wave+PI)/PI;\n    \n    stance[FINGERS].y = sin(wave-PI)/PI;\n    stance[FINGERS].w = sin(wave+PI*3.0/2.0)/PI;\n    \n    hipRot = sin(time*PI*3.0)/PI/GR;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid dance5()\n{\n    clear_stance();\n    \n    float wave = time*PI*PI;\n    \n    \n    stance[ELBOWS].y = PI+sin(wave)/PI;\n    stance[ELBOWS].w = PI+sin(wave+PI/2.0)/PI;\n    \n    stance[ELBOWS].x = sin(wave)/PI;\n    stance[ELBOWS].z = sin(wave)/PI;\n    \n    stance[WRISTS].y = sin(wave-PI/2.0)/PI;\n    stance[WRISTS].w = sin(wave+PI)/PI;\n    \n    stance[FINGERS].y = sin(wave-PI)/PI;\n    stance[FINGERS].w = sin(wave+PI*3.0/2.0)/PI;\n    \n    hipRot = sin(time*PI*3.0)/PI/GR;\n    \n    stance[KNEES].xz = vec2(saw(time));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\nvoid save_stance(float factor)\n{\n   \tfor(int i = 0; i < NUM_ANGLES;i++)\n    {\n        saved_stance[i] += (stance[i]-saved_stance[i])*factor;\n    }\n    \n    saved_shoulderRot += (shoulderRot-saved_shoulderRot)*factor;\n    saved_hipRot += (hipRot-saved_hipRot)*factor;\n    saved_lean += (lean-saved_lean)*factor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    float height = max(lowAverage(), last_height)-1.0/60.0;\n    last_height = height;\n    \n    float dance = time/PI/PI;\n    float v1 =  smoothstep(-1.0, 1.0/5.0, saw(dance));\n    float v2 =  smoothstep(1.0/5.0, 2.0/5.0, saw(dance));\n    float v3 =  smoothstep(2.0/5.0, 3.0/5.0, saw(dance));\n    float v4 =  smoothstep(3.0/5.0, 4.0/5.0, saw(dance));\n    float v5 =  smoothstep(4.0/5.0, 1.0, saw(dance));\n    dance1();\n    save_stance(v1);\n    dance2();\n    save_stance(v2);\n    dance3();\n    save_stance(v3);\n    dance4();\n    save_stance(v4);\n    dance5();\n    save_stance(v5);\n    load_stance();\n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0.0, minY+1.25, -3.5);\n    \n    //rotate camera\n    ro.yz *= rot(sin(iTime) * 0.25);\n    rd.yz *= rot(sin(iTime) * 0.25); \n    ro.xz *= rot(iTime * 0.5);\n    rd.xz *= rot(iTime * 0.5);\n    //*/\n    \n    eye = ro;\n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n", "image_inputs": [{"id": 20987, "src": "https://soundcloud.com/coolio/gangstas-paradise", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1060, 1060, 1079, 1079, 1131], [1133, 1133, 1185, 1219, 1793], [1795, 1795, 1855, 1855, 2374], [3988, 3988, 4008, 4008, 12988], [12990, 12990, 13023, 13023, 15337], [15339, 15339, 15376, 15376, 15706], [15708, 15713, 15756, 15756, 16053], [16055, 16068, 16103, 16103, 16885], [16943, 16943, 16963, 16963, 17458], [17460, 17460, 17481, 17481, 17610], [17612, 17612, 17627, 17627, 18216], [18218, 18218, 18233, 18233, 18694], [18696, 18696, 18711, 18711, 19245], [19247, 19247, 19262, 19262, 19788], [19790, 19790, 19805, 19805, 20410], [20412, 20412, 20444, 20444, 20724], [20726, 20726, 20781, 20781, 21873]], "test": "untested"}
{"id": "wlGGDc", "name": "Corridors of Galaxies", "author": "zovox", "description": "Corridors of Galaxies.", "tags": ["galaxies", "corridors"], "likes": 9, "viewed": 967, "published": 3, "date": "1580063525", "time_retrieved": "2024-07-30T21:28:32.986256", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time (sin(((sin(float(__LINE__)*100.0)*GR/PI+GR/PI/E)*iTime+100.0)/100.0)*100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.5-GR/PI/E, .5+GR/PI/E, x))\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan((uv).y, (uv).x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define GUASS(x) (smoothstep(0.0, 1.0/GR/PI/E, saw(x*PI/2.0)*(1.0-saw(x*PI/2.0))))\n\n#define GRID_COUNT (50.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define MAX_DIM (max(iResolution.x, iResolution.y))\n\n\n\n\nfloat seedling = 0.0;\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return saw(cdiv(cmul(uv, multa) + offa, cmul(uv, multb) + offb)*PI)*2.0-1.0;\n}\n\nvec2 square_map(vec2 uv)\n{\n    return (rotatePoint(vec3(uv+vec2(cos(seedling*PI), cos(seedling*GR)), 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy*(1.0+sin(time+seedling)/PI/E/GR)\n            +vec2(cos(time+seedling)+sin(time+seedling)));\n}\n\nvec2 iterate_square(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = square_map(a);\n    vec2 mb = square_map(b);\n    vec2 mc = square_map(c);\n    vec2 md = square_map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return square_map(uv);\n}\nvec2 mobius_map(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return mobius(uv, multa, offa, multb, offb);\n}\n\nvec2 iterate_mobius(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius_map(a, multa, offa, multb, offb);\n    vec2 mb = mobius_map(b, multa, offa, multb, offb);\n    vec2 mc = mobius_map(c, multa, offa, multb, offb);\n    vec2 md = mobius_map(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return mobius_map(uv, multa, offa, multb, offb);\n}\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nfloat last_height = 0.0;\n\nvec4 galaxy(vec2 uv)\n{\n\tuv *= 5.0;\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = time;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux(time+seedling), 1.0);\n    \n    vec4 final = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))*color\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    \n    final *= 2.0;\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sample1 = texture(iChannel1, uv);\n    float scale = exp(sin(time))*E+GR;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy;\n    vec2 uv0 = uv;\n    uv += cos(vec2(time, time/GR));\n    float r = length(uv);\n\n    \n    float map = time;\n    float noise = 1.0;\n    float spounge = time*4.0*PI;\n\tconst int max_iterations = 4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec3 color = vec3(1.0);\n\tvec3 accum = vec3(0.0);\n    float sum = 0.0;\n    float anticolor = 1.0;\n    seedling = 0.0;\n    \n    float black, white;\n    white = 0.0;\n        \n    float border_color = 0.0;\n    float border = 0.0;\n    \n    vec4 hit = vec4(0.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI)*PI;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI);\n        \n        uv = iterate_square(uv, .5/iResolution.xy, magnification);\n        float weight = smoothstep(0.0, 0.25, magnification);\n        antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        float q = quadrant(uv);\n        seedling += q+float(i);\n\n        map += (q+seedling)*antispeckle;\n        float shift = time;\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.y*PI)))));\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.x*PI)))));\n        \n        float stripes = map*1.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n        float black = smoothstep(0.0, .75, saw(stripes))*clamp(1.0-abs(border), 0.0, 1.0);\n        float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n\n        vec3 final = flux(map*2.0*PI+shift+float(i))*black+white;\n\n\n        color *= (final);\n        accum += final;\n        sum += 1.0;\n        anticolor *= white;\n\n        if(i != 0)\n        {\n\t\t\thit += galaxy(saw(uv*PI/2.0)*2.0-1.0)*clamp(1.0-length(hit.rgb), 0.0, 1.0)*(1.0-border);\n            \n            uv = iterate_mobius(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n            antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.y*PI)))));\n\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.x*PI)))));\n\n        }\n    }\n    \n\n    scale = 32.;\n    vec2 gridPosition = floor(uv0 * scale) / scale;\n    vec2 randomOffset = hash(gridPosition) * 2. - 1.;\n    vec2 localGridPositionCenter = fract(uv0 * scale) - .5;\n\n    hit = hit;\n    \n    color = pow(color, vec3(1.0/float(max_iterations)));\n    \n    antispeckle = pow(antispeckle, 1.0/float(max_iterations));\n    \n    fragColor.rgb = (color+accum/sum)*(1.0-border);\n    fragColor.a = 1.0;\n    \n    fragColor = hit;\n}\n", "image_inputs": [{"id": 20985, "src": "https://soundcloud.com/majorleaguewobs/space-odyssey-2001-theme-trap-remix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1215, 1215, 1237, 1237, 1411], [1413, 1413, 1442, 1442, 1512], [1514, 1514, 1543, 1543, 1627], [1629, 1629, 1697, 1697, 1780], [1782, 1782, 1808, 1808, 2015], [2017, 2017, 2083, 2083, 2691], [2692, 2692, 2764, 2764, 2815], [2817, 2817, 2929, 2929, 3667], [3668, 3668, 3691, 3691, 3794], [3796, 3796, 3816, 3816, 4194], [4222, 4222, 4244, 4244, 4986], [4987, 4987, 5044, 5044, 8240]], "test": "untested"}
{"id": "wty3Wc", "name": "Comet Wars Background", "author": "zovox", "description": "Background of an old video game.", "tags": ["background", "comet", "wars"], "likes": 2, "viewed": 344, "published": 3, "date": "1580063516", "time_retrieved": "2024-07-30T21:28:33.760187", "image_code": "\n        \n        \nfloat PI = 3.14159265359;\n#define GR 1.61803398875\n#define EPS .001\n#define INFINITY 1E32     \n\n\n\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\nfloat jag(float x)\n{\n    return mod(x, 1.0);\n}\nvec2 jag(vec2 x)\n{\n    return vec2(jag(x.x), jag(x.y));\n}\n\nfloat stair(float x)\n{\n    return float(int(x));\n}\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2( g, f );\n    float k1 = cross2( e, f ) + cross2( h, g );\n    float k0 = cross2( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    \n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    return saw(res*1.0*PI);\n}\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  // x0 = x0 - 0.0 + 0.0 * C.xxx;\n  // x1 = x0 - i1 + 1.0 * C.xxx;\n  // x2 = x0 - i2 + 2.0 * C.xxx;\n  // x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 flux(float x)\n{\n    return vec3(cos(x*1.0)*.5+.5,\n                cos(x*1.0+4.0*PI/3.0)*.5+.5,\n                cos(x*1.0+2.0*PI/3.0)*.5+.5);\n}\nvec4 cometwars(vec2 uv)\n{\n    uv.y = uv.y*3.0-1.5;\n    uv.x = uv.x*2.0-.5;\n    \n    uv.x *= uv.x > 0.0 ? .65 : 1.0;\n    uv.x = uv.x < 0.0 ? uv.x*1.5 : pow(uv.x, .75)*1.25;\n    \n    float turns = 32.0;//uv.x < 0.0 ? 24.0: 32.0;\n    float theta = atan(uv.y, uv.x);\n    float r = length(uv)+sin(theta*turns)*.05;\n    \n    float spikyness = .75;\n    \n    float tailyness = clamp(uv.x+1.0, 0.0, 2.0)/2.5;\n    float shortenyness = clamp(-uv.x, 0.0, 1.0);\n    float bendsign = (theta > PI || theta < 0.0) ? -1.0: 1.0;\n    \n    theta += (tailyness+iTime*1.1375)*bendsign;\n    \n    r += saw(theta*turns)*spikyness+shortenyness;\n    \n    float edgefade = pow(saw(clamp(r/2.0-1.0, -0.5, .5)/.5*PI), .125);\n    float rockyness = pow(clamp(1.0-length(uv)*GR, 0.0, 1.0), .75);\n    float comet = rockyness+edgefade;//*saw(sin(atan(uv.y, uv.x)*turns/2.0-iTime*bendsign*15.6789)+pow(length(uv), 2.75)*turns*2.0-iTime*PI*15.0);\n    \n    vec4 specs = vec4(flux(2.0*PI*snoise(vec3(r*length(uv)-iTime*PI, theta*2.0, 0.0))), 1.0);\n    if(1.0 > r)\n        return vec4(0.3, 0.5, specs.b, specs.b)*comet+rockyness;//vec4(, 1.0)+clamp(.75-comet, 0.0, 1.0);\n    else \n        return vec4(1.0-saw(clamp(r-.85, 0.0, .5)/.5*PI));\n}\n\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3)));\n    return fract(sin(p)*43458.3453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 persp = uv*2.0-1.0;\n    persp.x *=  iResolution.x/iResolution.y;\n    persp += vec2(cos(iTime*1.123456789)*.35-.35, cos(iTime*1.6789)*.25);\n    \n    vec2 crosshair = vec2(-0.75, 0.0);\n    \n    vec2 duv = persp-crosshair;\n    \n    duv = RotateZ(duv, cos(iTime*.25)*PI);\n    \n    float theta = atan(duv.y, duv.x);\n    float section = mod(theta, PI/2.0)/(PI/2.0);\n    section = section < .15 || section >.85 ? 1.0-(1.0-abs(section-.5)/.5)/.3: 0.0;\n    section = pow(section, .125);\n \tfloat r = length(duv);\n   \t\n    float d = .45;\n    float outerscalar = 1.25;\n    float outerw = .05;\n    \n    float outer = r > d*outerscalar && r < d*outerscalar+outerw ? section*cos(clamp(r-d*outerscalar, 0.0, outerw)/outerw*PI-PI/2.0): 0.0;\n    float grid = r > d ? outer : pow(cos(r/d*PI*9.0)*.5+.5, 2.0);\n    grid += (1.0-clamp(abs(duv.x/outerw*2.0), 0.0, 1.0))*pow(clamp(d*1.75-abs(duv.y), 0.0, 1.0)/d, .125)+\n        \t(1.0-clamp(abs(duv.y/outerw*2.0), 0.0, 1.0))*pow(clamp(d*1.75-abs(duv.x), 0.0, 1.0)/d, .125);\n    grid = pow(grid, 2.0);\n    \n    uv += vec2(cos(iTime*1.234), cos(iTime*1.456))*.05;\n    vec4 c = cometwars(uv);\n    uv -= vec2(iTime*.5, 0.0);\n    float scale = 40.;\n    float radius = 1.5;\n    vec2 gridPosition = floor(uv * scale) / scale;\n    vec2 randomOffset = hash(gridPosition) * 2. - 1.;\n    vec2 localGridPositionCenter = fract(uv * scale) - .5;\n    float stars = mix(0., 1., step(length(localGridPositionCenter + randomOffset * .5), .1));\n    \n    fragColor = vec4(0.3, 0.5, 1.0, 1.0)*c.b*(1.0-grid)+vec4(1.0, 0.0, 0.0, 1.0)*grid;\n    fragColor += clamp(1.0-length(fragColor), 0.0, 1.0)*stars;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wty3Wc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 155, 155, 183], [185, 185, 205, 205, 237], [238, 238, 256, 256, 288], [289, 289, 309, 309, 335], [336, 336, 354, 354, 393], [395, 395, 417, 417, 445], [446, 446, 521, 521, 1198], [2500, 2500, 2521, 2521, 2570], [2572, 2572, 2594, 2594, 2634], [2636, 2636, 2664, 2664, 2716], [2718, 2718, 2739, 2739, 2788], [2790, 2790, 2811, 2811, 2860], [2862, 2862, 2884, 2884, 2921], [2923, 2923, 2947, 2947, 5062], [5064, 5064, 5084, 5084, 5211], [5212, 5212, 5237, 5237, 6413], [6415, 6415, 6436, 6436, 6541], [6543, 6543, 6600, 6600, 8264]], "test": "untested"}
{"id": "tlyGDc", "name": "Code Demon", "author": "zovox", "description": "A code demon.", "tags": ["code", "demon"], "likes": 2, "viewed": 289, "published": 3, "date": "1580063499", "time_retrieved": "2024-07-30T21:28:34.792427", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n#define MATRIX_W (floor(MAX_DIM/75.0))\n#define MATRIX_H (floor(MAX_DIM/75.0))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/GR/PI)*iTime+1000.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define zero(x) (smoothstep(-1.0/GR/PI/E, 1.0/GR/PI/E, x))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch;\nvec2 targetResolution = vec2(512.0);\n\n\n//-----------------AUDIO ALGORITHM-----------------\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\n//-----------------SIMPLEX ALGORITHM-----------------\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626, // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy) );\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy) );\n    vec3 x0 = v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    // x0 = x0 - 0.0 + 0.0 * C.xxx;\n    // x1 = x0 - i1 + 1.0 * C.xxx;\n    // x2 = x0 - i2 + 2.0 * C.xxx;\n    // x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n//-----------------BASE IMAGE--------------------------\n\n#define R(r)  fract( 4e4 * sin(2e3 * r) )  // random uniform [0,1[\nvec4 stars(vec2 uv)\n{\n    vec4 stars = vec4(0.0);\n    for (float i = 0.; i < 32.0; i ++)\n    {\n        float r = R(i)/ 256.0         // pos = pos(0)  +  velocity   *  t   ( modulo, to fit screen )\n        / length( saw( R(i+vec2(.1,.2)) + (R(i+vec2(.3,.5))-.5) * time ) \n                 - saw(uv) );\n        stars += r*vec4(flux(r*PI+i), 1.0);\n    }\n    \n    return stars-1.0/16.0;\n}\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime*PI*2.0;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time/GR), 1.0);\n    \n    vec4 final = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))*color\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    final *= 2.0;\n    final -= .25;\n    \n\tfinal = sqrt(clamp(final, 0.0, 1.0));\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r);\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 numerator = cmul(uv, multa) + offa;\n    vec2 denominator = cmul(uv, multb) + offb;\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = (cdiv(numerator, denominator));\n    \n    for(int i = 0 ; i < 4; i++)\n    {\n        numerator = cmul(uv, multa) + offa+sin(vec2(float(i)-time*GR, -float(i)+time));\n        quotient += (cdiv(numerator, quotient));\n    }\n    \n    \n    \n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    stretch = denom/numer;\n    \n    seedling = (floor(quotient.x)*3.0+floor(quotient.y));\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    return final;\n}\n    \n\nfloat getEyes(vec2 uv)\n{\n    vec2 p = uv;\n\n    p.y += 1.0/PI;\n\n    p.x *= GR;\n\n    vec4 a = vec4(-1.0/GR, 1.0/GR, 0, 0);\n    vec4 b = vec4(1.0/GR, 1.0/GR, 0, 0);\n\n    p.y += cos(uv.x*(7.0+saw(time)))/PI;\n\n    float distA = length(p.xy-a.xy);\n    float distB = length(p.xy-b.xy);\n\n    float fade_lengthA = .20;\n    float fade_lengthB = .20;\n\n    float color = clamp((1.0-distA/fade_lengthA)*distB, 0.0, 1.0)\n        \t\t  +clamp((1.0-distB/fade_lengthB)*distA, 0.0, 1.0);\n    return color;\n}\n\nfloat getTeeth(vec2 uv)\n{\n    vec2 p = uv;\n    p.x *= PI;\n    p.y *= PI*(cos(p.x/PI/PI));\n    p.y += 1.5*cos(p.x)+1.0;\n    p.y *= (sin(time*PI*20.0+seedling))*.25+2.0;\n\n    float r = p.x*p.x+p.y*p.y;\n    \n    float xy = sin(p.x*PI*10.0)+cos(p.y*3.0+PI);\n\n    return clamp(clamp((3.0/(r*r*r)-p.y*p.y), 0.0, 1.0)*xy, 0.0, 1.0);\n}\n\nvec3 demon(vec2 uv)\n{\n    float eyes = getEyes(uv);\n    float teeth = getTeeth(uv);\n    \n    return vec3(clamp(eyes+teeth, 0.0, 1.0));\n}\n\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\t\t\n\tif(vUV.x < 0.0) return 0.0;\n\tif(vUV.y < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\t// In this version, each digit is made up of a 4x5 array of bits\n\t\n\tfloat fDigitBinary = 0.0;\n\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tfDigitBinary = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tfDigitBinary = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tfDigitBinary = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tfDigitBinary = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tfDigitBinary = 2.0 + 0.0 * 16.0 + 0.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tfDigitBinary = 0.0 + 0.0 * 16.0 + 7.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(fDigitBinary / pow(2.0, fIndex)), 2.0);\n}\n\nvec4 fire(vec2 p)\n{\n    p.x *= 1.0/E/GR;\n    p.y *= PI/GR;\n    float tempX = (p.y+.5)*cos(p.x*4.0*PI+time)*2.0;\n    float tempY = (p.y+.5)*sin(p.x*4.0*PI+time)*2.0;\n\n    p.x = tempX;\n    p.y = tempY;\n\n\n    p.x += .5*snoise(vec2(time*.6+256.0, p.y));\n    p.y += .5*snoise(vec2(time*.6+500.0, p.x));\t\n\n    float x_max = 0.56999993;\n    float y_max = 0.74999976;\n\n    float R = x_max;\n    float r = .1;\n\n    float x = snoise(vec2(time*.6+256.0, p.y))*.25+.875;\n    float y = snoise(vec2(time*.6+256.0, p.x))*.25-.625;\n\n    vec4 c = vec4(x, y, 0.0, 0.0);\n\n    vec2 Z = p*vec2(.85,1.0);\n    int iterations_temp;\n    const float max_iterations =6.0;\n    float depth_trap = 4500.0;\n    for(int iterations=0; iterations < int(max_iterations); iterations++) \n    {\n        Z = c.xy + cmul(Z.xy, vec2(tanh(Z.x), tanh(Z.y)));\n\n        if(dot(Z,Z)>depth_trap) {\n            break;\n        }\n        iterations_temp = iterations;\n    }\n\n    float NIC = (Z.x * Z.x) + (Z.y * Z.y);\n    NIC = float(iterations_temp)/max_iterations-log(sqrt(NIC))/float(iterations_temp);\n    float red = clamp(sin(NIC)+.25, 0.0, 1.0);//red*3.0/4.0);\n    float green = clamp(sin(NIC)*sin(NIC), 0.0, red*3.0/5.0);\n\n    /*\nint temp = int(p.x*64.0);\nfor(int i = 0; i < 64 i++)\nif(i == temp)\ngreen = Frequency[int(i)];\n*/\t\n\n    //if(red -green > 0.79) return texture(Frequency, vec2(p.x, p.y)).rgba;\n    return vec4(red, green , 0.0, 0.0);\n\n    /*\n//3-phase flux of 3 different coloring patterns\nreturn vec4(red, green, blue, 0.0) * clamp(sin(time*5.0+0.0), 0.0, 1.0)\n+ vec4(green, red, green, 0.0) * clamp(sin(time*5.0+4.0*PI/3.0), 0.0, 1.0)\n+ vec4(green, green, red, 0.0) * clamp(sin(time*5.0+2.0*PI/3.0), 0.0, 1.0);\n*/\n}\n\nvec3 scienceordie(vec2 uv)\n{\n    \n    float scale = E/GR;\n    uv = uv*scale-scale/2.0;\n    //uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), sin(time*PI)).xy;\n    //uv += cos(vec2(time*PI, time*GR*PI))/GR/PI;\n    uv.y -= .1/GR;\n    float depth = demon(uv).r;\n    float angle =  depth*PI+time;\n    \n    //uv.xy += depth*vec2(cos(angle), sin(angle))/MATRIX_W;\n    \n    vec2 fract_matrix = fract(uv*vec2(MATRIX_W,MATRIX_H));\n    vec2 floor_matrix = floor(uv*vec2(MATRIX_W,MATRIX_H));\n    float number = (mod(time*sin(floor_matrix.x+floor_matrix.y*MATRIX_W), 10.0));\n    float digit = SampleDigit(number, GR*fract_matrix);\n    \n    \n    vec3 body = smoothstep(0.0, 1.0/GR, smoothstep(0.0, 1.0/GR*E/PI, sqrt(clamp(1.0-length(uv*vec2(1.0, 1.0/GR)*GR), 0.0, 1.0)))*demon(uv*1.125));\n    \n    vec3 science = vec3(0.0, digit, 0.0)*(1.0-body)+body;\n\tfloat or = zero(-uv.x);\n    \n    vec4 die = clamp(fire(uv), 0.0, 1.0);\n    \n    vec3 scene = science*or+(1.0-body)*(1.0-or)*die.rgb;;//+(1.0-or)*body*flux(time+body.r*PI*2.0);\n    return scene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor.rgb = scienceordie(uv);\n    fragColor.a = 1.0;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1228, 1228, 1248, 1248, 1626], [1683, 1683, 1704, 1704, 1755], [1757, 1757, 1778, 1778, 1829], [1831, 1831, 1853, 1853, 1892], [1894, 1894, 1916, 1916, 3522], [3524, 3524, 3545, 3545, 3596], [3598, 3598, 3620, 3620, 3659], [3661, 3661, 3689, 3689, 3743], [3745, 3745, 3767, 3767, 6025], [6150, 6150, 6171, 6171, 6534], [6536, 6536, 6558, 6558, 7466], [7531, 7531, 7560, 7560, 7630], [7632, 7632, 7661, 7661, 7745], [7747, 7747, 7815, 7815, 8579], [8643, 8643, 8748, 8748, 9417], [9424, 9424, 9448, 9448, 9912], [9914, 9914, 9939, 9939, 10241], [10243, 10243, 10264, 10264, 10379], [12286, 12286, 12305, 12305, 13970], [13972, 13972, 14000, 14000, 15012], [15014, 15014, 15071, 15071, 15184]], "test": "untested"}
{"id": "ttyGWc", "name": "Clockwork Chaos", "author": "zovox", "description": "Reminds me of chaotic clockwork.", "tags": ["chaos", "clockwork"], "likes": 3, "viewed": 1196, "published": 3, "date": "1580063486", "time_retrieved": "2024-07-30T21:28:35.593285", "image_code": "#define S 83.0\n#define D 68.0\n#define C 67.0\n#define T 84.0\n#define Y 89.0\n#define F 70.0\n\n#define SDCTYF (S+D+C+T+Y+F)\n#define PI 3.14159265359\n\n#define jitter ((tan(iTime)+iTime*10.0)/10.0)\n//#define iTime ((tan(iTime)+iTime*10.0)/10.0)\n#define iTime iTime*.5\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  c = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  d = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, c.yyy) );\n  vec3 x0 =   v - i + dot(i, c.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + c.xxx;\n  vec3 x2 = x0 - i2 + c.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - d.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * d.wyz - d.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float count = 7.0+cos(iTime)*5.0;\n    \n\tfloat sum = 0.;\n    \n    for(float i = 0.0; i < 100.0; i+=1.0)\n    {\n        if(i > count)\n            break;\n        \n        float theta = float(i)/float(count)*PI*2.0+iTime;\n        vec2 p1 = vec2(cos(theta), sin(theta))*.75;\n        \n        float radialCount = 7.0+cos(iTime/PI)*5.0;\n        \n        for(float j = 0.0; j < 100.0; j+=1.0)\n        {\n        \tfloat theta2 = float(j)/float(radialCount)*PI*2.0-iTime*2.0;\n            vec2 p2 = p1+vec2(cos(theta2), sin(theta2));\n\n            if(j > radialCount)\n                break;\n            \n            float d = \n                    (p2.y-p1.y)*uv.x-\n                    (p2.x-p1.x)*uv.y+\n                    p2.x*p1.y-p2.y*p1.x/\n                    length(p2-p1);\n            float maxd = 10./max(iResolution.x,iResolution.y);\n            \n            if(abs(d) < maxd)\n            {\n                sum += (cos(d/maxd*PI/2.0));\n            }\n        }\n    }\n    fragColor = vec4((cos(iTime*PI+length(uv.xy)*PI+sum*PI/2.+vec3(0., 4.*PI/3.,2.*PI/3.))*.5+.5)*clamp(sum,0., PI), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 262, 283, 283, 332], [334, 334, 355, 355, 404], [406, 406, 428, 428, 468], [470, 470, 498, 498, 550], [552, 552, 576, 576, 2720], [2722, 2722, 2779, 2779, 3964]], "test": "untested"}
{"id": "WlV3W3", "name": "3D Tree Forest", "author": "zovox", "description": "3D Tree Forest", "tags": ["3d", "tree", "forest"], "likes": 5, "viewed": 393, "published": 3, "date": "1580063471", "time_retrieved": "2024-07-30T21:28:36.645472", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (20.)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\n#define TAO 6.283\nvec2 Rotate(in vec2 v, float angle) {return v*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));}\nvec2 Kaleido(in vec2 v,float power){return Rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\nfloat HTorus(in vec3 z, float radius1, float radius2){return max(-z.y-0.055,length(vec2(length(z.xy)-radius1,z.z))-radius2-z.x*0.035);}\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\nfloat scale = 3.;\nfloat seed;\nvec3 mcol;\nfloat dfScene(in vec3 z0){\n\tvec4 z=vec4(z0,1.0);\n    float d = 1E32;\n    \n    float height =1.;\n    float width = .05;\n    const int iterations = 4;\n    float loop = float(1.)/float(iterations);\n\tfloat dB=sdCapsule(z0.xyz, vec3(0.,width,0.), vec3(0.,-height*2.,0.),width); \n    \n    if(dB < d)\n    {\n        d = dB;\n    \tmcol = vec3(loop/GR+(1.-loop)/E, loop, 0.);\n    }\n    \n    dB = z0.y+height*2.;\n    \n    if(dB < d)\n    {\n        d = dB;\n        float grass = pow(cos(z0.x*2.*PI/scale)*cos(z0.z*2.*PI/scale)*.5+.5, 4.);\n    \tmcol = vec3(loop/GR+(1.-loop)/E, loop+grass/PI/GR, 0.);\n    }\n    \n    \n\tfor(int i=0;i<5;i++){\n\t\tz.xz=Kaleido(z.xz,float(i+2)*(1.+floor(saw(seed*float(i+1))*4.)));\n\t\tz.yz=Rotate(z.yz,(saw(time*PI+seed)*.5-.5));\n\t\t\n        float dcap = sdCapsule(z.xyz+vec3(0., 0., .5), vec3(0.,0.,.5), vec3(0.,.5,0.),width);\n        dB = dcap/z.w;\n        if(dB < d)\n        {\n\t\t\td=dB;\n            loop = float(i+1)/float(iterations);\n            mcol = vec3(loop/GR+(1.-loop)/GR, loop, 0.);\n        }\n\t\tz.z+=.5;\n        z.y -= .5;\n\t\tz*=vec4(2.0,2.0,2.0,2.0);\n\t}\n\t//dB=(length(z.xyz)-1.0)/z.w;\n\treturn d;\n\treturn d;\n}\n\nvec3 surfaceNormal(vec3 p) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy), d2 = dfScene(p - e.xyy);\n\tfloat d3 = dfScene(p + e.yxy), d4 = dfScene(p - e.yxy);\n\tfloat d5 = dfScene(p + e.yyx), d6 = dfScene(p - e.yyx);\n\tfloat d = dfScene(p) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \tfloat ns;\n    vec3 p;\n    for (int i = 0; i <32; i++) {\n        rp = ro + rd * d;\n        p = rp;\n        seed = floor((rp.x)/scale)*1.2345+floor((rp.z)/scale)*5.4321;\n        p.xz = (fract((rp.xz)/scale)-.5)*scale;\n        ns = dfScene(p);\n        d += ns;\n        if(d > FAR)\n        {\n            break;\n        }\n        \n    }\n    vec3 sky_color = vec3(.35, .35, .85);\n    float fog = smoothstep(.75, .9, d/FAR);\n    \n\n    vec3 n = surfaceNormal(p);\n    vec3 sc = mcol; //surface colour\n\n    float diff = max(dot(n, lp), 0.0); //diffuse\n    pc = sc * 0.5 + diff * sc ;\n    float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n    pc = (pc + spe * vec3(1.0))*(1.-fog)+fog*sky_color;\n    \n    return pc;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0.0, -.5, -PI)*2.;\n    \n    float movement = time;\n    \n    ro += vec3((sin(movement*PI))*scale, 0., (movement+.5)*scale);\n    //rotate camera\n    rd.yz *= rot(.25+sin(movement/GR)*.1); \n    rd.xz *= rot(cos(movement*PI) * 0.5);\n    //*/\n    \n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1011, 1011, 1048, 1048, 1109], [1110, 1110, 1146, 1146, 1209], [1210, 1210, 1264, 1264, 1345], [1347, 1347, 1366, 1366, 1418], [1420, 1420, 1472, 1472, 1599], [1643, 1643, 1669, 1669, 2773], [2775, 2775, 2803, 2803, 3105], [3107, 3120, 3155, 3155, 4079], [4082, 4082, 4137, 4171, 4661]], "test": "untested"}
{"id": "3lV3W3", "name": "3D Tree", "author": "zovox", "description": "3D Tree", "tags": ["3d", "tree"], "likes": 5, "viewed": 357, "published": 3, "date": "1580063451", "time_retrieved": "2024-07-30T21:28:37.431371", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*GR*E*5.)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI/GR/E)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\n#define TAO 6.283\nvec2 Rotate(in vec2 v, float angle) {return v*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));}\nvec2 Kaleido(in vec2 v,float power){return Rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\nfloat HTorus(in vec3 z, float radius1, float radius2){return max(-z.y-0.055,length(vec2(length(z.xy)-radius1,z.z))-radius2-z.x*0.035);}\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nvec3 mcol;\nfloat dB;\nfloat dfScene(in vec3 z0){\n\tvec4 z=vec4(z0,1.0);\n\tfloat d=max(abs(z.y+1.0)-1.0,length(z.xz)-0.13);\n\tfor(int i=0;i<5;i++){\n\t\tz.xz=Kaleido(z.xz,float(i+2)*2.);\n\t\tz.yz=Rotate(z.yz,(saw(time*PI)-1.));\n\t\t\n        float dcap = sdCapsule(z.xyz+vec3(0., 0., 1.), vec3(0.,0.,1.), vec3(0.,2.0,0.),0.1);\n        dB += dcap/z.w/10.;\n\t\td=min(d,dcap/z.w);\n\t\tz.z+=1.0;\n        z.y -= 2.;\n\t\tz*=vec4(2.0,2.0,2.0,2.0);\n\t}\n\t//dB=(length(z.xyz)-1.0)/z.w;\n\treturn d;\n}\n\nvec3 surfaceNormal(vec3 p, vec3 rd) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy), d2 = dfScene(p - e.xyy);\n\tfloat d3 = dfScene(p + e.yxy), d4 = dfScene(p - e.yxy);\n\tfloat d5 = dfScene(p + e.yyx), d6 = dfScene(p - e.yyx);\n\tfloat d = dfScene(p) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//IQ\nfloat calcAO(vec3 pos, vec3 nor, vec3 rd) {   \n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.05*float(i);\n        vec3 aopos = pos + nor*hr;\n        occ += smoothstep(0.0, 0.7, hr - dfScene(aopos)) * sca;\n        sca *= 0.97;\n    }\n    return clamp(1.0 - 3.0 * occ , 0.0, 1.0);\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \n    for (int i = 0; i < 64; i++) {\n        rp = ro + rd * d;\n        float ns = dfScene(rp);\n        d += ns;\n        if (ns < 1.0/MAX_DIM || d > FAR) break;\n    }\n    \n    if (d < FAR) {\n\n        vec3 sc = flux(dB+time); //surface colour\n        vec3 n = surfaceNormal(rp, rd);\n        float ao = calcAO(rp, n, rd);\n        \n        float diff = max(dot(n, lp), 0.0); //diffuse\n\t    pc = sc * 0.5 + diff * sc * ao;\n        float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n        pc = sc;//pc + spe * vec3(1.0);\n    }\n    \n    return pc;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0.0, 1./GR, -PI)*2.;\n    \n    //rotate camera\n    ro.yz *= rot(sin(iTime) * 0.25);\n    rd.yz *= rot(sin(iTime) * 0.25); \n    ro.xz *= rot(iTime * 0.5);\n    rd.xz *= rot(iTime * 0.5);\n    //*/\n    \n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lV3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1023, 1023, 1060, 1060, 1121], [1122, 1122, 1158, 1158, 1221], [1222, 1222, 1276, 1276, 1357], [1359, 1359, 1378, 1378, 1430], [1432, 1432, 1484, 1484, 1611], [1633, 1633, 1659, 1659, 2080], [2082, 2082, 2119, 2119, 2421], [2423, 2428, 2471, 2471, 2764], [2766, 2779, 2814, 2814, 3574], [3577, 3577, 3632, 3666, 4110]], "test": "untested"}
{"id": "tly3D3", "name": "3D Spiral Flower", "author": "zovox", "description": "3-dimensional spiral flower.", "tags": ["spiral", "flower"], "likes": 5, "viewed": 364, "published": 3, "date": "1580063438", "time_retrieved": "2024-07-30T21:28:38.379835", "image_code": "#define PI 3.14159265359\n#define E 2.7182818284\n//#define iTime 2.0*tan(1.0*iTime)\n\nfloat height(vec2 uv)\n{\n    float r = length(uv);\n    \n    if(r > 1.0) return 10.0;\n    \n    float sum = 0.0;\n    \n    \n    \n    for(int i = 0 ; i < 12; i++)\n    {\n        \n        //if(i < 64+int(sin(iTime)*64.0))\n        {\n            \n            //float theta1 = (7.0*atan(uv.y, uv.x)-r*PI*4.0*cos(float(i)+iTime))+ cos(iTime);\n\n            float awesome = pow(clamp(1.0-acos(cos((7.0*atan(uv.y, uv.x)-r*PI*4.0*cos(float(i)+iTime))+ cos(iTime))), 0.0, 1.0), PI);\n\n            sum = (sum+awesome);\n        }\n    \n    }\n    return -sum;\n}\n\nvec2 flower(vec3 p, vec3 d)\n{\n    \n    float zoom = 1.0;\n        \n    vec2 uv = p.xz*zoom/2.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv = vec2(uv.x*cos(iTime)-uv.y*sin(iTime),\n                 uv.x*sin(iTime)+uv.y*cos(iTime));\n    \n    //fragColor = 1.0-vec4(1.0-pow(1.0/E,2.0*PI*clamp(length(uv), 0.0, 1.0)));\n    \n    vec2 uv2 = uv + vec2(.01/iResolution.x,  0.0);\n    vec2 uv3 = uv + vec2(0.0,  .01/iResolution.y);\n    \n    vec3 p1 = vec3(uv, height(uv)).xzy;\n    vec3 p2 = vec3(uv2, height(uv2)).xzy;\n    vec3 p3 = vec3(uv3, height(uv3)).xzy;\n    \n    vec3 n = normalize(cross(p3-p1, p2-p1));\n    \n    return vec2(dot(p-p1, n), p1.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    \n    \n    vec3 origin = vec3(0.0, 1.0, 0.0);\n    vec3 rayOrigin = vec3(0.0, 1.5, .25);\n    vec3 rayPos = rayOrigin.xyz;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 mainDir = normalize(origin-rayPos);\n    vec3 right = normalize(cross(up, mainDir));\n    up = normalize(cross(right, mainDir));\n    vec3 rayDir = normalize(mainDir-up*uv.y+right*uv.x);\n\n    \n    for(float t = 0.0; t < 100.0; t += 2.5)\n    {\n        vec2 dist = flower(rayPos, rayDir);\n        rayPos += .1*rayDir;\n        if( rayPos.y - dist.y < 0.0)\n            break;\n        else if(length(rayPos-rayOrigin) >= 10.0 )\n        {\n            fragColor = vec4(1.0);\n            return;\n        }\n    }\n    \n    \n    vec2 sum = flower(rayPos, rayDir);\n    \n    fragColor.r = 1.0-pow(cos(rayPos.y*1.0+cos(iTime*1.0)), 2.0);\n    fragColor.g = 1.0-pow(cos(rayPos.y*1.0+cos(iTime*2.0)), 2.0);\n    fragColor.b = 1.0-pow(cos(rayPos.y*1.0+cos(iTime*3.0)), 2.0);\n    //fragColor.rgb *= sum.y-;\n    \n//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 107, 107, 624], [626, 626, 655, 655, 1283], [1285, 1285, 1342, 1342, 2403]], "test": "untested"}
{"id": "WtKGD3", "name": "3D Jack", "author": "zovox", "description": "3D Jack", "tags": ["3d", "jack"], "likes": 1, "viewed": 840, "published": 3, "date": "1580063428", "time_retrieved": "2024-07-30T21:28:39.342262", "image_code": "\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*2.0)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime+1000.0+last_height)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR))*.25+.5))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nfloat last_height = 0.0;\nfloat beat = 0.0;\n\nfloat sphere(vec3 rp, vec3 rd, vec3 bp, float r) {\n    \n    vec3 oc = rp - bp;\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - r*r;\n    float disc = b * b - 4.0 * c;\n\n    if (disc < 0.0)\n        return 0.0;\n\n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n\n    float t0 = q;\n    float t1 = c / q;\n\n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    \n    return (t1-t0)/r;\n}\n\n\nfloat line(vec3 rp, vec3 rd, vec3 a, vec3 b, float r) {\n    vec3 pa = rp - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    vec3 ray = rd;\n    vec3 ray2 = normalize(b-a);\n\n    float a1 = dot(ray,ray);\n    float b1 = dot(ray,ray2);\n    float c = dot(ray2,ray2);\n    float d = dot(ray,rp-a);\n    float e = dot(rp-a,ray2);\n\n    float t1 = (b1*e-c*d)/(a1*c-b1*b1);\n    float t2 = (a1*e-b1*d)/(a1*c-b1*b1);\n\n    float dist = length((rp+ray*t1)-(a+ray2*t2));\n    \n    float foward = 1.0-abs(t2/length(a-b)*2.0-1.0);\n    return dist > r || t2 < r || t2 > length(a-b)+r? 0.0 : smoothstep(0.0, 1.0/GR, (1.0-dist/r)*foward);\n}\n\nfloat dancer(vec3 p, vec3 rd) {\n    \nfloat t = mod(time,1.0);\nfloat s = sin(time)/PI/GR;\n\nconst vec3 xu = vec3(1.0,0.0, 0.0);\nconst vec3 xd = vec3(-1.0,0.0, 0.0);\n\nconst vec3 yu = vec3(0.0,GR,0.0);\nconst vec3 yd = vec3(0.0,-GR,0.0);\n\nconst vec3 zu = vec3(0.0,0.0,1.0);\nconst vec3 zd = vec3(0.0,0.0,-1.0);\n\n    float d = 0.0;\n\n    float radius = .1;\n\t// outside\n\td += line(p,rd,xu,xd,radius);\n\td += line(p,rd,yu,yd,radius);\n\td += line(p,rd,zu,zd,radius);\n    \n\td += sphere(p,rd,xu,radius);\n\td += sphere(p,rd,xd,radius);\n\td += sphere(p,rd,zu,radius);\n\td += sphere(p,rd,zd,radius);\n\n    return d;\n}\n\nvec4 draw(vec3 ro, vec3 rd, vec2 uv0) {\n    float depth = dancer(ro, rd);\n    \n    float weight = clamp(depth, 0.0, 1.0);;\n    \n    return vec4(flux(depth+time*PI)*weight, weight);//clamp(+(1.0-weight)*sample, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //coordinate system\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec2 uv = (uv0* 2.0 - 1.0)*vec2(iResolution.x / iResolution.y, 1.0);\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    float t = time;\n    vec3 axis = rormal();//vec3(0.0, 1.0, 0.0);\n    \n    ro = rotatePoint(ro, axis, t);\n    rd = rotatePoint(rd, axis, t);\n    ro *= FAR/PI;\n    \n    fragColor = draw(ro, rd, uv0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1046, 1046, 1096, 1096, 1659], [1662, 1662, 1717, 1717, 2311], [2313, 2313, 2344, 2344, 2908], [2910, 2910, 2949, 2949, 3132], [3135, 3135, 3190, 3219, 3640]], "test": "untested"}
{"id": "3tKGD3", "name": "3D Hypercube", "author": "zovox", "description": "3D Hypercube", "tags": ["3d", "hypercube"], "likes": 6, "viewed": 1330, "published": 3, "date": "1580063417", "time_retrieved": "2024-07-30T21:28:40.390461", "image_code": "\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*2.0)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime+1000.0+last_height)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR))*.25+.5))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nfloat last_height = 0.0;\nfloat beat = 0.0;\n\nfloat sphere(vec3 rp, vec3 rd, vec3 bp, float r) {\n    \n    vec3 oc = rp - bp;\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - r*r;\n    float disc = b * b - 4.0 * c;\n\n    if (disc < 0.0)\n        return 0.0;\n\n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n\n    float t0 = q;\n    float t1 = c / q;\n\n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    \n    return (t1-t0)/r;\n}\n\n\nfloat line(vec3 rp, vec3 rd, vec3 a, vec3 b, float r) {\n    vec3 pa = rp - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    vec3 ray = rd;\n    vec3 ray2 = normalize(b-a);\n\n    float a1 = dot(ray,ray);\n    float b1 = dot(ray,ray2);\n    float c = dot(ray2,ray2);\n    float d = dot(ray,rp-a);\n    float e = dot(rp-a,ray2);\n\n    float t1 = (b1*e-c*d)/(a1*c-b1*b1);\n    float t2 = (a1*e-b1*d)/(a1*c-b1*b1);\n\n    float dist = length((rp+ray*t1)-(a+ray2*t2));\n    return dist > r || t2 < r || t2 > length(a-b)+r? 0.0 : 1.0-dist/r;\n}\n\nconst int NUM_ANGLES = 5;\nconst int ELBOWS = 0;\nconst int WRISTS = 1;\nconst int FINGERS = 2;\nconst int KNEES = 3;\nconst int ANKLES = 4;\n// stance structure:\n//{\n//\tvec4(leftLegOmega, leftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftElbowOmega, relativeLeftElbowTheta, relativeRightElbowOmega, relativeRightElbowTheta)),\n//\tvec4(relativeLeftWristOmega, relativeLeftWristTheta, relativeRightWristOmega, relativeRightWristTheta)),\n//\tvec4(relativeLeftFingersOmega, relativeLeftFingersTheta, relativeRightFingersOmega, relativeRightFingersTheta)),\n//\tvec4(leftLegOmega, LeftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftKneeOmega, relativeLeftKneeTheta, relativeRightKneeOmega, relativeRightKneeTheta)),\n//\tvec4(relativeLeftAnkleOmega, relativeLeftAnkleTheta, relativeRightAnkleOmega, relativeRightAnkleTheta)),\n//}\n//\n// Vertices\nconst vec3 lbf = vec3(-0.5,-0.5,-0.5);\nconst vec3 rbf = vec3( 0.5,-0.5,-0.5);\nconst vec3 lbb = vec3(-0.5,-0.5, 0.5);\nconst vec3 rbb = vec3( 0.5,-0.5, 0.5);\n\nconst vec3 ltf = vec3(-0.5, 0.5,-0.5);\nconst vec3 rtf = vec3( 0.5, 0.5,-0.5);\nconst vec3 ltb = vec3(-0.5, 0.5, 0.5);\nconst vec3 rtb = vec3( 0.5, 0.5, 0.5);\n\n\nfloat dancer(vec3 p, vec3 rd) {\n    \nfloat t = mod(time,1.0);\nfloat s = sin(time)/PI/GR;\n\nvec3 lbfi = vec3(-0.5+s,-0.5+s,-0.5+s);\nvec3 rbfi = vec3( 0.5-s,-0.5+s,-0.5+s);\nvec3 lbbi = vec3(-0.5+s,-0.5+s, 0.5-s);\nvec3 rbbi = vec3( 0.5-s,-0.5+s, 0.5-s);\n\nvec3 ltfi = vec3(-0.5+s, 0.5-s,-0.5+s);\nvec3 rtfi = vec3( 0.5-s, 0.5-s,-0.5+s);\nvec3 ltbi = vec3(-0.5+s, 0.5-s, 0.5-s);\nvec3 rtbi = vec3( 0.5-s, 0.5-s, 0.5-s);\n\nvec3 lbf_lbfi = mix(lbf,lbfi,t);\nvec3 ltf_ltfi = mix(ltf,ltfi,t);\nvec3 lbb_lbbi = mix(lbb,lbbi,t);\nvec3 ltb_ltbi = mix(ltb,ltbi,t);\n\nvec3 rbb_lbb = mix(rbb,lbb,t);\nvec3 rbf_lbf = mix(rbf,lbf,t);\nvec3 rtf_ltf = mix(rtf,ltf,t);\nvec3 rtb_ltb = mix(rtb,ltb,t);\n\nvec3 lbfi_rbfi = mix(lbfi,rbfi,t);\nvec3 lbbi_rbbi = mix(lbbi,rbbi,t);\nvec3 ltfi_rtfi = mix(ltfi,rtfi,t);\nvec3 ltbi_rtbi = mix(ltbi,rtbi,t);\n\nvec3 rbbi_rbb = mix(rbbi,rbb,t);\nvec3 rbfi_rbf = mix(rbfi,rbf,t);\nvec3 rtfi_rtf = mix(rtfi,rtf,t);\nvec3 rtbi_rtb = mix(rtbi,rtb,t);\n    \n    float d = 0.0;\n\n    float radius = .025;\n\t// outside\n\td += line(p,rd,lbf_lbfi,rbf_lbf,radius);\n\td += line(p,rd,lbb_lbbi,rbb_lbb,radius);\n\td += line(p,rd,ltf_ltfi,rtf_ltf,radius);\n\td += line(p,rd,ltb_ltbi,rtb_ltb,radius);\n\n\td += line(p,rd,lbf_lbfi,lbb_lbbi,radius);\n\td += line(p,rd,ltf_ltfi,ltb_ltbi,radius);\n\td += line(p,rd,lbf_lbfi,ltf_ltfi,radius);\n\td += line(p,rd,lbb_lbbi,ltb_ltbi,radius);\n\n\td += line(p,rd,rbf_lbf,rbb_lbb,radius);\n\td += line(p,rd,rtf_ltf,rtb_ltb,radius);\n\td += line(p,rd,rbf_lbf,rtf_ltf,radius);\n\td += line(p,rd,rbb_lbb,rtb_ltb,radius);\n\n    // inside\n\td += line(p,rd,lbfi_rbfi,lbbi_rbbi,radius);\n\td += line(p,rd,ltfi_rtfi,ltbi_rtbi,radius);\n\td += line(p,rd,lbfi_rbfi,ltfi_rtfi,radius);\n\td += line(p,rd,lbbi_rbbi,ltbi_rtbi,radius);\n\n\td += line(p,rd,lbbi_rbbi,rbbi_rbb,radius);\n\td += line(p,rd,lbfi_rbfi,rbfi_rbf,radius);\n\td += line(p,rd,ltfi_rtfi,rtfi_rtf,radius);\n\td += line(p,rd,ltbi_rtbi,rtbi_rtb,radius);\n\n\td += line(p,rd,rbfi_rbf,rtfi_rtf,radius);\n\td += line(p,rd,rbbi_rbb,rtbi_rtb,radius);\n\td += line(p,rd,rbfi_rbf,rbbi_rbb,radius);\n\td += line(p,rd,rtfi_rtf,rtbi_rtb,radius);\n\n    // connections\n\td += line(p,rd,rtbi_rtb,rtb_ltb,radius);\n\td += line(p,rd,rbfi_rbf,rbf_lbf,radius);\n\td += line(p,rd,rbbi_rbb,rbb_lbb,radius);\n\td += line(p,rd,rtfi_rtf,rtf_ltf,radius);\n\t\n\td += line(p,rd,ltfi_rtfi,ltf_ltfi,radius);\n\td += line(p,rd,ltbi_rtbi,ltb_ltbi,radius);\n\td += line(p,rd,lbfi_rbfi,lbf_lbfi,radius);\n\td += line(p,rd,lbbi_rbbi,lbb_lbbi,radius);\n\n    return d;\n}\n\nvec4 draw(vec3 ro, vec3 rd, vec2 uv0) {\n    float depth = dancer(ro, rd);\n    \n    float weight = clamp(depth, 0.0, 1.0);;\n    \n    return vec4(flux(depth+time*PI)*weight, weight);//clamp(+(1.0-weight)*sample, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //coordinate system\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec2 uv = (uv0* 2.0 - 1.0)*vec2(iResolution.x / iResolution.y, 1.0);\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    float t = time;\n    vec3 axis = rormal();//vec3(0.0, 1.0, 0.0);\n    \n    ro = rotatePoint(ro, axis, t);\n    rd = rotatePoint(rd, axis, t);\n    ro *= FAR/PI;\n    \n    fragColor = draw(ro, rd, uv0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1046, 1046, 1096, 1096, 1659], [1662, 1662, 1717, 1717, 2220], [3397, 3397, 3428, 3428, 5835], [5837, 5837, 5876, 5876, 6059], [6062, 6062, 6117, 6146, 6567]], "test": "untested"}
{"id": "wly3Wc", "name": "Arriving late to a Movie.", "author": "angelo12", "description": "Shader Sundays 04! This time trying to focus on learning how to model a basic scene.", "tags": ["raymarching", "sdf", "pathtraced"], "likes": 5, "viewed": 550, "published": 3, "date": "1580053922", "time_retrieved": "2024-07-30T21:28:41.449627", "image_code": "/*\n\tShader Sundays! (4/52) \n\t\"Walking into a Film\"\n\t\n\tSo for this week I tried to focus on learning how to model a scene from a reference image. \n\tI picked this image as my starting point since I thought I would be able to model it pretty easily:\n\thttps://flic.kr/p/JYJJ4E . (Insert suprise pikachu) As a sdf noob this turned out to be more challenging than\n\tI thought it was gonna be. I couldn't quite get the stairs to look right, in fact they still kinda don't.\n\tAt one point it did start to look more like the entrance of a movie theater and I liked that a lot more\n\tso that's what I'm calling it now so that you also imagine it :) \n\n\tNo idea yet of what I'll do next week but it should be fun!\n\t\n\tReferences:\n\thttps://www.shadertoy.com/view/3dyXzD\n*/\n\n\n#define INV_GAMMA 0.4545454\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0.0);\n    if(iFrame > 0)\n    {\n        col = texture(iChannel0, uv).xyz;\n        col /= float(iFrame);\n    }\n\n    col *= 3.5;\n    col = pow(col, vec3(INV_GAMMA));\n    fragColor = vec4(col, 1.0); \n    fragColor = smoothstep(0.,1.0,fragColor);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define M_PI 3.1415926535\n#define M_TAU M_PI*2.0\n\n#define DEBUG 0\n\nfloat rng_ = 0.0;\n\nmat3\nSetCamera(vec3 eye, vec3 target, float roll)\n{\n    vec3 f, temp, r, u;\n    f = normalize(target - eye);\n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(temp, f));\n    u = cross(f, r); \n\n    return mat3(r, u, f);\n}\n\nfloat\nhash(float p)\n{\n    p = fract(p *0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat\nsdBox(vec3 p, vec3 sides)\n{\n    vec3 q = abs(p) - sides;\n    return length(max(q, 0.0)) - min(max(q.z, max(q.x, q.y)), 0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat\nsdRail(vec3 p)\n{\n    vec3 r1A = vec3(0.0, 0.0, -1.0);\n    vec3 r1B = vec3(0.0, 0.0, 0.1);\n    float r1r = 0.02;\n\n    vec3 r2B = vec3(0.0, 1.7, 04.0);\n\n    float r1 = sdCapsule(p - vec3(0.45, 0.2, 0.0), // pos\n                             r1A, // start\n                             r1B, // end\n                             r1r); // radius\n\n    float r2 = sdCapsule(p - vec3(0.45, 0.2, 00.0), // pos\n                             r1B, // start\n                             r2B, // end\n                             r1r); // radius\n    \n    r1 = min(r1, r2);\n\n    vec3 r3B = vec3(r2B.xy, r2B.z + 0.5);\n\n    r2 = sdCapsule(p - vec3(0.45, 0.2, 00.0), // pos\n                             r2B, // start\n                             r3B, // end\n                             r1r); // radius\n    r1 = min(r1, r2);\n\n    vec3 r4B = vec3(r3B.x, r3B.y + r2B.y + 0.20, r3B.z + 4.0);\n\n    r2 = sdCapsule(p - vec3(0.45, 0.2, 00.0), // pos\n                             r3B, // start\n                             r4B, // end\n                             r1r); // radius\n    r1 = min(r1, r2);\n\n    vec3 r5B = vec3(r4B.x, r4B.y , r4B.z + 4.0);\n\n    r2 = sdCapsule(p - vec3(0.45, 0.2, 00.0), // pos\n                             r4B, // start\n                             r5B, // end\n                             r1r); // radius\n    r1 = min(r1, r2);\n\n    return r1;\n}\n\nfloat\nsdGround(vec3 p)\n{\n    float d = p.y;\n\n    float steps = floor(p.z* 5.0);\n\n    if ( p.z > 0.0 && p.z < 10.0)\n    {\n        d -= steps * 0.08 - 0.0 ;\n    }\n\n    //IQ steps https://www.shadertoy.com/view/ttBXRG\n    float i = floor(d);\n    float f = fract(d);\n    float k = 4.0;\n    float a = 0.5*pow(2.0*((f<0.5)?f:1.0-f), k);\n    f = (f<0.5)?a:1.0-a;\n    \n    return i+f;\n}\n\n//union op\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n//mirror op\nvec3\nmop(vec3 p)\n{\n    float off = 0.2;\n    p.x = abs(p.x + off)- off;\n    return p;\n}\n\n#define UOP(dist, id) res = uop(res, vec2(dist, id))\n\n#define BOX_ID 0.0\n\n#define GROUND_ID 1.0\n#define LEFT_ID 2.0\n#define RIGHT_ID 3.0\n#define STAIRS_ID 4.0\n#define RAIL_ID 5.0\n#define ROOM_ID 6.0\n#define CEIL_ID 7.0\n\n#define EPSI 0.004\nvec2\nMap(vec3 p)\n{\n    vec2 res = vec2(1e10, -1.0);\n\n    float o = -1.4; //side offset\n    float h = 300.5; // height of staircase walls\n    UOP(sdGround(p - vec3(0.0, -0.1, 0.0)), GROUND_ID); \n    UOP(sdBox(p - vec3(0.02 + o, 0.0, 0.0), vec3(EPSI, h, 20.0)), LEFT_ID); \n    UOP(sdBox(p - vec3(1.99 + o, 0.0, 0.0), vec3(EPSI, 2., 20.0)), RIGHT_ID); \n    UOP(sdBox(p - vec3(0.0, 09.1, 0.0), vec3(20.0,EPSI, 25.0)), CEIL_ID); \n    UOP(sdBox(p - vec3(0.0, 10.1, 20.1), vec3(20.0,20.0, EPSI)), ROOM_ID); \n    UOP(sdBox(p - vec3(o, 7.9, 17.0), vec3(0.1, 0.1, 0.2)), BOX_ID);\n    UOP(sdRail(mop(p)), RAIL_ID);\n\n\n    return res;\n}\n\n#define MAX_STEPS 2000\n#define MIN_DIST 0.001\n#define MAX_DIST 50.0\nvec2\nRayMarch(vec3 ro, vec3 rd)\n{\n    vec2 res = vec2(-1.0, -1.0);\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++i)\n    {\n        vec2 hit = Map(ro + t*rd);\n\n        if(abs(hit.x) < t*MIN_DIST)\n        {\n            res = vec2(t, hit.y);\n            break;\n        }\n        t += hit.x;\n    }\n\n    return res;\n}\n\nvec3\nCalcNormal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(Map(p + e.xyy).x - Map(p - e.xyy).x,\n                          Map(p + e.yxy).x - Map(p - e.yxy).x,\n                          Map(p + e.yyx).x - Map(p - e.yyx).x));\n}\n\nstruct Material\n{\n    vec3 col; //r,g,b\n    float emi;\n    float rough;\n    vec3 pad;\n};\n\nvec3 roomCol = vec3(0.08, 0.08, 0.7);\n\nMaterial\nGetMaterialFromID(float id, vec3 p, vec3 N)\n{\n    Material mat;\n    //Default\n    mat.col = vec3(1.0);\n    mat.emi = 0.0;\n    mat.rough = 1.0; //1.0 is maximum roughness 0.0 is perfectly reflective\n\n    if(id == BOX_ID)\n    {\n        mat.col = vec3(0.0, 0.8, 0.0);\n        mat.emi = 2.6;\n    }\n    else if(id == RAIL_ID) \n    {\n        float r = length(p.xy);\n        float a = atan(p.y, p.x);\n\n        float dir = dot(N, vec3(0.0, -1.0, 0.0));\n        if(abs(dir - 1.0) < 0.4)\n        {\n            mat.emi = 1.6;\n            mat.col = vec3(1.0, 0.0, 0.0);\n        }\n        else\n        {\n            mat.col = vec3(0.5);\n            mat.rough = 0.2;\n        }\n    }\n    else if (id == ROOM_ID)\n    {\n        mat.col = roomCol;\n        mat.emi = 1.0;\n    }\n    else if(id == LEFT_ID || id == RIGHT_ID)\n    {\n        mat.col = vec3(0.27, 0.27, 0.27);\n        mat.rough = 0.6;\n    }\n    else if(id == CEIL_ID)\n    {\n        mat.rough = 0.5;\n    }\n    return mat;\n}\n\nvec3\nCosineWeightedRay(vec3 n , float seed)\n{\n    float u = hash(seed + 82.753);\n    float v = hash(seed + 18.902);\n\n    float a = M_TAU * v;\n    u = 2.0*u - 1.0;\n\n\n    return normalize(n + vec3(sqrt(1.0 - u*u) * vec2(cos(a), sin(a)),u));\n}\n\nfloat\nCalcShadows(vec3 ro, vec3 rd)\n{\n    float k = 2.0;\n    float res = 1.0;\n    for(float t = 0.012; t < MAX_DIST;)\n    {\n        float h = Map(ro + t*rd).x;\n        \n        if(h < MIN_DIST) return 0.0;\n        res = min(res, h*k/t);\n        t += h;\n    }\n\n    return res;\n}\n\n#define saturate(val) clamp(0.0, 1.0, val)\n\nvec3\nCalcRayDirection(vec3 originalRd, vec3 reflectionDir, vec3 normal, float rough, float seed)\n{\n    vec3 newRd = vec3(0.0);\n    vec3 randDir = CosineWeightedRay(normal, seed);\n    if(rough >= 1.0)\n    {\n        newRd = randDir;\n    }\n    else\n    {\n        newRd = reflectionDir*(saturate(1.0 - rough)) + rough * randDir;\n        newRd = normalize(newRd);\n    }\n\n    return newRd;\n}\n\nvec3 sunCol = vec3(0.8, 0.7, 0.8);\nvec3 skyCol = vec3(0.0, 0.2, 0.8);\nvec3 sunDir = vec3(1.0, 1.3, 0.0);\n\n#define GI_BOUNCES 2\nvec3\nRender(vec3 ro, vec3 rd)\n{\n    //Global illumination tracking vars\n    vec3 tot = vec3(0.0);\n    vec3 rayCol = vec3(1.0);\n\n    //Original data\n    vec3 oro = ro;\n    vec3 ord = rd;\n    float depth = 0.0;\n    float t = 0.0;\n\n    for(int bounce = 0; bounce < GI_BOUNCES; ++bounce)\n    {\n        //Scene traversal\n        vec2 res = RayMarch(ro, rd);\n        t = res.x;\n        float id = res.y;\n\n        //First hit\n        if (id < 0.0)\n        {\n            //you hit the sky\n            if (bounce == 0)\n            {\n                //If you hit it on the first bounce that's your final color\n                tot = skyCol;\n            }\n            break;\n        }\n        if(bounce == 0) depth = t;\n\n        //Geometry\n        vec3 P = ro + t*rd;\n        vec3 N = CalcNormal(P);\n        vec3 R = reflect(rd, N);\n\n        //Material\n        Material mat = GetMaterialFromID(id, P, N);\n        rayCol *=mat.col;\n\n        //Lighting\n        vec3 lAcc =  vec3(0.0);\n        vec3 L = normalize(sunDir);\n        float diff = saturate(dot(N, L));\n\n        vec3 indirect = rayCol * mat.emi;\n\n        //Shadowing\n        float shadowed = CalcShadows(P, L);\n\n        //Shading\n        #if DEBUG\n            tot = N;\n            break;\n        #else\n            //lAcc += shadowed * diff * sunCol;\n            lAcc += indirect;\n            tot += lAcc * rayCol;\n        #endif\n\n        //Next Ray bounce\n        ro = P;\n        float timeSeed =  76.2 + 73.1*float(bounce) + rng_ + 17.7*float(iFrame);\n        //rd = CosineWeightedRay(N, timeSeed);\n        rd = CalcRayDirection(rd, R, N, mat.rough, timeSeed);\n    }\n\n    //Fog\n    tot = mix(tot, vec3(roomCol), 1.0 - exp(-0.0008*depth*depth));\n\n    return tot;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Seeding rng per pixel per frame\n    rng_ = hash(dot(vec2(12.9898, 78.233), fragCoord)+ 1113.1*float(iFrame));\n\n    //Camera setup\n    float nearP = 0.79;\n    float roll = 0.0;\n    vec2 offset = - 0.5 + vec2(hash(rng_ + 10.852), hash(rng_ + 56.266));\n    vec2 uv = ((fragCoord+offset) - 0.5*iResolution.xy)/iResolution.y;\n    vec3 ta = vec3(0.0, 0.6, 00.0);\n    vec3 ro = vec3(0.0, 0.4, -1.0);\n    mat3 cam = SetCamera(ro, ta, roll);\n    vec3 rd = cam * normalize(vec3(uv, nearP));\n\n    //Adding to prev color\n    vec2 screen = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, screen).xyz;\n    if( iFrame == 0) col = vec3(0.0); \n\n    //Render\n    col += Render(ro, rd);\n\n    //Noise debug\n    //col += vec3(rng_);\n\n    fragColor = vec4(col, 1.0);    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wly3Wc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[787, 787, 842, 842, 1148]], "test": "untested"}
{"id": "wtyGWc", "name": "vortex simulation+Voronoi track", "author": "FabriceNeyret2", "description": "red/blue = vortices +/-, intensity = strength    white = passive markers\nfullscreen !\n\nBoosting rendering of vortex simulation  [url]https://shadertoy.com/view/lsy3zR[/url]\nusing  Voronoï particle tracking [url]https://www.shadertoy.com/view/3ty3Dy[/url]", "tags": ["simulation", "particles", "dynamics", "vortex", "seminewton", "lagrangian", "vorticity", "biotsavart", "voronoiparticletracking", "voronoitracking"], "likes": 54, "viewed": 2011, "published": 3, "date": "1580052843", "time_retrieved": "2024-07-30T21:28:42.546694", "image_code": "// optimized version of transitional https://shadertoy.com/view/wtGGWc\n//    Fork of vortex simulation  https://shadertoy.com/view/lsy3zR\n//             inspired from http://evasion.imag.fr/~Fabrice.Neyret/demos/JS/Vort.html\n//    + Voronoï particle tracking https://www.shadertoy.com/view/3ty3Dy\n\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    O = keyFlip(32)\n     // ? T1(U).rrrr/(Nf*Nf)   // space key: draw Id/Voronoi ( closest )\n        ? T1(U)/(Nf*Nf)        // space key: draw Id/Voronoi ( RGBA = 1st-4th closest )\n        : T0(U);               // draw trace\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === semi-Newton (aka Verlet) integration of Biot-Savart velocity field induced by vortex particles\n// inspired from http://evasion.imag.fr/~Fabrice.Neyret/demos/JS/Vort.html\n \nvoid mainImage( out vec4 O, vec2 U )\n{\n    O-=O;\n    vec2 T = floor(U/Nf); // several grids are mapped in the buffer\n    // tile (0,0).xy , zw : pos, velocity of pass 1  (init from pass 2 output)\n    // tile (0,1).z         vorticity\n    // tile (0,2).xy , zw : backup of ref pos, velocity  ( UNUSED )\n\n    /*\n    if (iFrame < 1) {   // ----- initialization\n        O = vec4( R * rand2(U),         // P0\n                  2.*rand2(U+7.13)-1.); // V0 (for gravity) or W (if tile(0,1) )\n\n        if (T==vec2(0,1)) \n            if (int(U.x)+N*(int(U.y)%N) > Nvort)  O.z = 0.;  // W = 0 : passive markers\n        \telse if (BINARY==1) O.z = sign(O.z); // binary mode: all active |W|=1\n        return; \n    }*/\n    \n    if (T==vec2(0,1))\n        O = T1(U);          // for buffer persistency \n    \n    U = mod(U,Nf);          // U = particle id ( N*N particles )\n    \n  //if ( T == vec2(0,2) )   // backup ref positions ( UNUSED )\n  //    { O = refState(U); return; }\n    \n    int pass = 0;\n    float dt = iFrame < 10 ? 1./60. : iTimeDelta; \n    \n    if ( T == vec2(0,0) ) { // pass 1 : 1/2 time step from ref position (to get V)\n        pass = 1; \n        dt *= .5; \n        O = T1(U);\n    }\n    else if (pass==0) return;\n    \n    // if pass 1: compute tmp pos(v) at half time-step\n    // if pass 2: compute new pos using velocities(tmppos) and ref pos\n\n    // ----- evaluate forces (Newton, for gravity) \n    //         or directly velocity (Biot-Savart, for vorticity)\n    vec2 F = vec2(0);\n \n#if CYCLE == 1         // forces through cycling world\n    for (int cx=-1; cx<2; cx++)\n      for (int cy=-1; cy<2; cy++)\n#endif\n    for (int k=0; k < Nvort; k++) {\n            vec2 P = vec2(k%N,k/N), d = T1(P).xy - O.xy;\n            float w = W(P); \n            BINARY == 2 ? w = .5*sign(w) : w;\n#if CYCLE == 1\n            d += iResolution.xy*vec2(cx,cy);\n#elif CYCLE == 2     // cycling world : clipped to most contributive window\n            d = ( fract(.5+d/iResolution.xy) -.5)*iResolution.xy;\n#endif\n            float l = dot(d,d);\n         // if (l>1e-5) F += d /l;                   // Newton, for gravity \n            if (l>1e-5) F += vec2(-d.y,d.x) * w /l;  // Biot-Savart, for vorticity\n            }\n    \n // O.zw += 1e-1*F*dt;    // v += sum(F).dt   for Newton\n    O.zw = STRENGTH*F;    // direct eval of V (stored as F) for Biot-Savart\n    if (pass==2)   // increment from ref pos, not pass 1 pos\n        O.xy = T0(U).xy;\n    O.xy += O.zw*dt;      // x += v.dt\n    O.xy = mod(O.xy, iResolution.xy);\n  \n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// === semi-Newton (aka Verlet)  integration of Biot-Savart velocity field induced by vortex particles\n// inspired from http://evasion.imag.fr/~Fabrice.Neyret/demos/JS/Vort.html\n    \nvoid mainImage( out vec4 O, vec2 U )\n{\n    O-=O;\n    vec2 T = floor(U/Nf); // several grids are mapped in the buffer\n    // tile (0,0).xy , zw : pos, velocity of pass 1  (init from pass 2 output)\n    // tile (0,1).z         vorticity\n    // tile (0,2).xy , zw : backup of ref pos, velocity  ( UNUSED )\n    \n    if (iFrame < 1) {   // ----- initialization\n        O = vec4( R * rand2(U),         // P0\n                  2.*rand2(U+7.13)-1.); // V0 (for gravity) or W (if tile(0,1) )\n\n        if (T==vec2(0,1)) \n            if (int(U.x)+N*(int(U.y)%N) > Nvort)  O.z = 0.;  // W = 0 : passive markers\n        \telse if (BINARY==1) O.z = sign(O.z); // binary mode: all active |W|=1\n        return; \n    }\n    \n    if (T==vec2(0,1))\n        O = T1(U);          // for buffer persistency \n    \n    U = mod(U,Nf);          // U = particle id ( N*N particles )\n    \n  //if ( T == vec2(0,2) )   // backup ref positions ( UNUSED )\n  //    { O = refState(U); return; }\n    \n    int pass = 0;\n    float dt = iFrame < 10 ? 1./60. : iTimeDelta; \n    \n    if ( T == vec2(0,0) ) { // pass 1 : 1/2 time step from ref position (to get V)\n        pass = 2; \n        O = T1(U);\n    }\n    else if (pass==0) return;\n    \n    // if pass 1: compute tmp pos(v) at half time-step\n    // if pass 2: compute new pos using velocities(tmppos) and ref pos\n\n    // ----- evaluate forces (Newton, for gravity) \n    //         or directly velocity (Biot-Savart, for vorticity)\n    vec2 F = vec2(0);\n \n#if CYCLE == 1         // forces through cycling world\n    for (int cx=-1; cx<2; cx++)\n      for (int cy=-1; cy<2; cy++)\n#endif\n    for (int k=0; k<Nvort; k++) {\n            vec2 P = vec2(k%N,k/N), d = T1(P).xy - O.xy;\n            float w = W(P);\n            BINARY == 2 ? w = .5*sign(w) : w;\n#if CYCLE == 1\n            d += iResolution.xy*vec2(cx,cy);\n#elif CYCLE == 2     // cycling world : clipped to most contributive window\n            d = ( fract(.5+d/iResolution.xy) -.5)*iResolution.xy;\n#endif\n            float l = dot(d,d);\n         // if (l>1e-5) F += d /l;                   // Newton, for gravity \n            if (l>1e-5) F += vec2(-d.y,d.x) * w /l;  // Biot-Savart, for vorticity\n            }\n    \n // O.zw += 1e-1*F*dt;    // v += sum(F).dt   for Newton\n    O.zw = STRENGTH*F;    // direct eval of V (stored as F) for Biot-Savart\n    if (pass==2)   // increment from ref pos, not pass 1 pos\n        O.xy = T0(U).xy;\n    O.xy += O.zw*dt;      // x += v.dt\n    O.xy = mod(O.xy, iResolution.xy);\n  \n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// === Voronoï buffer: manage tracking of particles Ids\n\n// --- insert (i,d) and maintain the 4 closest (i_,d_) \nvoid list_insert(inout vec4 i, inout vec4 d, float i_, float d_){\t\n    if(i_ == 0.) return;           // not a particle : exit\n    if(any(equal(vec4(i_),i))) return; // already in top4 : exit\n    if     (d_ < d[0])             // closer to closest: insert here\n        i = vec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             // closer to 2nd closest: insert here\n        i = vec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])             // closer to 3rd closest: insert here\n        i = vec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])             // closer to 4th closest: insert here\n        i = vec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    vec4  i = vec4(0),\n         i0 = T1( I ),             // 4 closests particles here and around\n         ia = T1( I + vec2( 1, 0) ),  // NB: could use an array.\n         ib = T1( I + vec2( 0, 1) ),\n         ic = T1( I + vec2(-1, 0) ),\n         id = T1( I + vec2( 0,-1) );\n\n//#define dist(i) length( A(i).xy - I )\n//#define dist(i) length( mod( A(i).xy-I + R/2., R) - R/2. )  \nvec2 D;\n#define dist(i) ( D = mod( A(i,0).xy-I + R/2., R) - R/2., dot(D,D) )\n\n    vec4  d = vec4(1e9); \n    for(int k = 0; k < 4; k++){    // sorts all these\n        list_insert( i, d, i0[k], dist(i0[k]) );\n        list_insert( i, d, ia[k], dist(ia[k]) );\n        list_insert( i, d, ib[k], dist(ib[k]) );\n        list_insert( i, d, ic[k], dist(ic[k]) );\n        list_insert( i, d, id[k], dist(id[k]) );\n    }\n#if 0 // also checking diagonal (to test possibly axis bias)\n    ia = T1( I + vec2( 1, 1) ),\n    ib = T1( I + vec2(-1, 1) ),\n    ic = T1( I + vec2( 1,-1) ),\n    id = T1( I + vec2(-1,-1) );\n    for(int k = 0; k < 4; k++){    // sorts all these\n        list_insert( i, d, ia[k], dist(ia[k]) );\n        list_insert( i, d, ib[k], dist(ib[k]) );\n        list_insert( i, d, ic[k], dist(ic[k]) );\n        list_insert( i, d, id[k], dist(id[k]) );\n    }\n#endif\n    \n    for(int k = 0; k < 8; k++){    // try to re-insert some random particle (possibly escaped from tracking)\n      //int r = IHash( int(I.x) + int(I.y)*2048 + iFrame*2048*2048 +k*11131); //deterministic\n        int r = IHash( int(I.x) + int(I.y)*2141 + iFrame*2141*2141 +k*11131); //without 2048 bias\n      //int r = IHash( int(I.x) + int(I.y)*2048 + (int(iTime*2048.)+iFrame)*2048 +k*11131);\n        int i_ =  1 + r % ( N*N ); \n        list_insert(i, d, float(i_), dist(i_) );\n    }\n    O = vec4(i);                   // stores 4 closest\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// === display with motion blur\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n/* // --- test: display data tiles\n    float n = 3.*Nf/iResolution.y,\n        r = iResolution.x/iResolution.y;\n    U /= iResolution.xy;\n\tO.xy =  U.x < .5 ? texture(iChannel0,U*n).xy\n                     : texture(iChannel0,(U-vec2(2.*n,0))*n).zw;\n    if (U.y < 1./3.) O /= iResolution.y;\n    else if (U.x>.5 && max((U.x-.5)*r,U.y-1./3.)<1./3.) O = O.x==0. ? vec4(1) : O.x>0. ? vec4(O.x,0,0,1) : vec4(0,0,-O.x,1);\n // O = fract(O);\n    return;\n/**/    \n\n // --- Display partics using Voronoï tracking \n\n#if BLEND != 1    \n  #define blend(d,s,w) d += (s)*(w)\n#else\n  #define blend(d,s,w) d = max(d,(s))\n#endif\n    \n    O = vec4(0);\n    vec4 a = T2(U), P;         // 4 particule id (supposed to be particles closest to I)\n    float w,l;\n    for(int i = 0; i < 4; i++){// draw blobs\n        P = A(a[i],0); if (a[i]==0.) break;\n        l = l2( U - P.xy );   \n        w = A(a[i],ivec2(0,N)).z;            // particle vorticity             \n        if   (w==0.) blend(O, smoothstep(Rm,Rm/4.,l)*.6,.3); // passiwe marker : white\n        else { l = smoothstep(Rv,Rv/4.,l);                   // active vortices : red/blue\n              if (w>0.) blend(O.r, w*l, Wv); \n              else      blend(O.b,-w*l, Wv);\n             }\n    }\n    \n#if BLEND != 2    \n    blend( O, .95*T1(U),1.);     // blend with fading past\n#else\n    O = max(O/.5,.95*T1(U));     // blend with fading past\n#endif\n    \n/* // --- old way: Display partics using usual NxN browsing & blending\n    \n    O = (1.-.05)*texture(iChannel1,U/iResolution.xy); // blur relaxation of past    \n    for (int j=0; j<N; j++)\n        for (int i=0; i<N; i++) \n        {\n            vec2 d = tex(i,j).xy - U.xy;\n            float l = dot(d,d),\n                  w = W(i,j);    // particle vorticity\n         // O += 2.*abs(w)/l;\n            if (l<Rp)              \n              if   (w==0.) O += smoothstep(Rm,Rm/2.,l) * .2; // passiwe marker : white\n              else { l = smoothstep(Rp,Rp/2.,l) * .3;        // active vortices : red/blue\n                     if (w>0.) O.r += w*l; else O.b += -w*l;\n                   }\n     }\n/**/    \n}\n", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R     iResolution.xy\n\n// --- simu params\n\n#define N 100         // N*N partics\n#define Nf float(N)\n#define MARKERS .97   // % of passive markers\n#define BINARY 0      // are vorticities distributed or binaries ( -1 or 1 )\n                      //   2: on the fly\n#define CYCLE 2       // evaluate forces through cycling world 0:no 1:full 2:cheap\n#define STRENGTH ( (R.y>300. ? 2e2 : 1e2 ) / (1.-MARKERS) * (15./Nf) )\n#define Nmark     int( float(N*N) * MARKERS )\n#define Nvort    ( N*N - Nmark )\n\n\n// --- display params\n\n#define BLEND 2 // Blending mode: 0: add   1: max   2: add partics & blend past\n\nfloat Rv = 16., // vortice thickness^2 (pixels)\n      Rm = 2.,  // markers thickness^2 (pixels)\n      Wv = BLEND != 2 ? .3 : .5; // vortice weight\n\n\n\n// ----------------------------------------------\n\n// Buff B (1) store Voronoï tracking acceleration structure;\n//            xyzw: ids of 4 closest partics to buffer location\n// Buff A (0) stores particles: \n//            xy: position zw: velocity\n\n// --- translate particle id to buffer pixel \n#define A(n,T) T0( T+ ivec2( (int(n)-1) % N,     \\\n                             (int(n)-1) / N ) ) // + tile offset\n\n#define W(P)      T1( P + vec2(0,N) ).z\n                                 \n// --- utils\n                           \n#define iR    ivec2(iResolution)\n#define T0(U) texelFetch( iChannel0, ivec2(U)   , 0 )\n#define T1(U) texelFetch( iChannel1, ivec2(U)%iR, 0 )\n#define T2(U) texelFetch( iChannel2, ivec2(U)   , 0 )\n\n#define l2(x) dot(x,x)\n\n#define TAU 6.2831853\n\n#define keyFlip(k) ( texelFetch( iChannel3, ivec2(k,2), 0 ).x > .5 )\n                           \n// --- random numbers\n\n #define rand2(U)   fract( 1e5* sin( mat2(17.1,191.7,-31.1,241.7) * U ))\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[300, 300, 339, 339, 567]], "test": "untested"}
{"id": "wtG3D3", "name": "Hello Shadertoy, *waves*", "author": "samhattangady", "description": "26 Jan 2020 : Day 000\nSo, day 0. I think I want to do a waving hand. \nTo kinda say hi to everyone, welcome to the project.", "tags": ["hello"], "likes": 3, "viewed": 260, "published": 3, "date": "1580044606", "time_retrieved": "2024-07-30T21:28:43.303670", "image_code": "/*\nDay 000 : Hello Shadertoy\n26 Jan 2020\n\nSo, day 0. I think I want to do a waving hand. \nTo kinda say hi to everyone, welcome to the project.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.14159;\n    float handWaveAngle = pi/6.0 * sin(iTime*4.0);\n    mat2 handRotate = mat2(cos(handWaveAngle), -sin(handWaveAngle),\n                           sin(handWaveAngle), cos(handWaveAngle));\n\n    vec2 center = vec2(0.5, 0.4);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = (uv - center);\n    q = handRotate * q;\n    \n    vec3 bgColor = 0.5 + 0.5 * (uv.xyy);\n    float hand = 0.13;\n    float fingers = 0.06 * cos(atan(q.x,q.y)*4.0 + 58.0*q.x);\n    hand += fingers;\n\n    bgColor *= smoothstep(hand, hand+0.005, length(q));  \n    fragColor = vec4(bgColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 204, 204, 791]], "test": "untested"}
{"id": "tly3W3", "name": "operators <<n , >>n ; n = + or -", "author": "FabriceNeyret2", "description": "top to bottom: ( B= 1010101 )\n t\nB<< t    B>> -t    B>>t    B << -t    (if white, same on int and uint)\n   on OpenGL,  1st & last are cyclical, not the others\nSame for -B:  on OpenGL,  1st & last right-insert 0, not the others\nSame for -1<<31 with  left-1", "tags": ["test", "shift", "bitwise", "roll", "compatibility"], "likes": 6, "viewed": 440, "published": 3, "date": "1580037593", "time_retrieved": "2024-07-30T21:28:44.051670", "image_code": "// checking int vs uint\n// checking negative shift\n// spec here: https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.1.30.pdf#page=56\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U *= vec2(32,16)/iResolution.xy;\n    int x = int(32.-U.x), y = int(16.-U.y), t = iFrame/10, B = 1+4+16+64; // try 1\n    O -= O;\n    U = fract(-U);\n    if ( y%4 == 2  && U.y  < .1 ) { O.r++; return; } // red marks\n    if ( min( U.x, U.y) < .1 )    { O.b++; return; } // blue marks\n\n    O = vec4((                                       // bits\n                y == 1 ?   t/6\n        \n              : y == 2 ?   B << t\n              : y == 3 ?   B >> -t\n              : y == 4 ?   B >> t\n              : y == 5 ?   B << -t\n        \n              : y == 6 ?  -B << t\n              : y == 7 ?  -B >> -t\n              : y == 8 ?  -B >> t\n              : y == 9 ?  -B << -t\n        \n              : y ==10 ? (-1<<31) >> t\n              : y ==11 ? (-1<<31) << -t\n              : y ==12 ? (-1<<31) << t\n              : y ==13 ? (-1<<31) >> -t\n              : 0 \n            )  >> x  & 1 );                          // show bit x\n\n    if (y < 6) O.g = float((             // just to check Uint has same behavior\n                y == 1 ?  uint(t/6)\n              : y == 2 ?  uint(B) << t\n              : y == 3 ?  uint(B) >> -t\n              : y == 4 ?  uint(B) >> t\n              : y == 5 ?  uint(B) << -t\n              : 0U \n            )  >> x  & 1U );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 182, 182, 1433]], "test": "untested"}
{"id": "wtG3W3", "name": "Voxel Mandelbulb  With Normals", "author": "Chrisy", "description": "straight up fork of thorn0906 and iq\nhttps://www.shadertoy.com/view/3d2XRd", "tags": ["octree"], "likes": 4, "viewed": 421, "published": 3, "date": "1580029688", "time_retrieved": "2024-07-30T21:28:44.976198", "image_code": "// Sample the envmap in multiple places and pick the highest valued one. Not really physically accurate if not 1\n#define SKY_SAMPLES 1\n// How many directions to sample the lighting & BRDF at\n// Setting it to 0 disables the envmap lighting and switches to a constant light\n#define MAT_SAMPLES 0\n\n// Set this to 1 for a liquid-like animation\n#define ANIMATE 0\n// Try turning that on and this off to see the animation more clearly\n#define CAMERA_MOVEMENT 0\n\n// Enable this to see the exact raymarched model\n#define MARCH 0\n\n// The size of the scene. Don't change unless you change the distance function\nconst float root_size = 3.;\n// The resolution, in octree levels. Feel free to play around with this one\nconst int levels = 10;\n\n// The maximum iterations for voxel traversal. Increase if you see raymarching-like\n//\thole artifacts at edges, decrease if it's too slow\nconst int MAX_ITER = 1024;\n// Note, though, that the fake AO might look weird if you change it much\n\n// These are parameters for the Mandelbulb, change if you want. Higher is usually slower\nconst float Power = 4.;\nconst float Bailout = 1.5;\nconst int Iterations = 7;\n\n#define STACKLESS\n\n// -----------------------------------------------------------------------------------------\n\nconst float  offset =pow(root_size,float(levels));\n\nvec3 snap (vec3 pos)\n{\n    return round(pos*offset)/offset;\n}\n\n// This is from http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n// \tbecause it had code that I could just copy and paste\nfloat dist(vec3 pos) {\n    // This function takes ~all of the rendering time, the trigonometry is super expensive\n    // So if there are any faster approximations, they should definitely be used\n\tvec3 z = snap(pos);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    for (int i = 0; i < Iterations; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n        \n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n        #if ANIMATE\n        theta += iTime*0.5;\n        #endif\n\t\tfloat phi = atan(z.y,z.x);\n        #if ANIMATE\n        phi += iTime*0.5;\n        #endif\n\t\tdr = pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tpos = snap(pos);\n    vec2 e = vec2(1.0,-1.0)*(1.0/offset);\n    return normalize( e.xyy*dist( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*dist( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*dist( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*dist( pos + e.xxx ) );\n   \n}\n\n// -----------------------------------------------------------------------------------------\n\n\n#define PI 3.1415926535\nconst float IPI = 1./PI;\nconst float R2PI = sqrt(2./PI);\n\nstruct Material {\n    vec3 base_color;\n    float roughness;\n};\n\nfloat sqr(float x) { return x*x; }\n#define saturate(x) clamp(x,0.,1.)\n\nvec2 isect(in vec3 pos, in float size, in vec3 ro, in vec3 rd, out vec3 tmid, out vec3 tmax) {\n    vec3 mn = pos - 0.5 * size;\n    vec3 mx = mn + size;\n    vec3 t1 = (mn-ro) / rd;\n    vec3 t2 = (mx-ro) / rd;\n    vec3 tmin = min(t1, t2);\n    tmax = max(t1, t2);\n    tmid = (pos-ro)/rd; // tmax;\n    return vec2(max(tmin.x, max(tmin.y, tmin.z)), min(tmax.x, min(tmax.y, tmax.z)));\n}\n\nstruct ST {\n    vec3 pos;\n\tint scale; // size = root_size * exp2(float(-scale));\n    vec3 idx;\n    float h;\n} stack[levels];\n\nint stack_ptr = 0; // Next open index\nvoid stack_reset() { stack_ptr = 0; }\nvoid stack_push(in ST s) { stack[stack_ptr++] = s; }\nST stack_pop() { return stack[--stack_ptr]; }\nbool stack_empty() { return stack_ptr == 0; }\n\n\n// -----------------------------------------------------------------------------------------\n\n#if MARCH\n\n// Simple ray marcher for visualizing the exact distance function\nbool trace(in vec3 ro, in vec3 rd, out vec2 t, out vec3 pos, out int iter, out float size) {\n\tsize = 0.;\n    \n    t = vec2(0.);\n    pos = ro;\n    iter = MAX_ITER;\n    while (iter --> 0 && t.x < root_size) {\n        float d = dist(pos);\n        if (d < 0.01)\n            return true;\n        t += d;\n        pos += rd*d;\n    }\n    return false;\n}\n\n#else\n\n// The distance to the corner of the voxel; thanks, abje!\n// This removes artifacts (present when d_corner = 0.5);\nconst float d_corner = sqrt(0.75);\n\n// The actual ray tracer, based on https://research.nvidia.com/publication/efficient-sparse-voxel-octrees\nbool trace(in vec3 ro, in vec3 rd, out vec2 t, out vec3 pos, out int iter, out float size) {\n    stack_reset();\n    \n    //-- INITIALIZE --//\n    \n    int scale = 0;\n    size = root_size;\n    vec3 root_pos = vec3(0);\n    pos = root_pos;\n    vec3 tmid;\n    vec3 tmax;\n    bool can_push = true;\n    float d;\n    t = isect(pos, size, ro, rd, tmid, tmax);\n    float h = t.y;\n    \n    // Initial push, sort of\n    // If the minimum is before the middle in this axis, we need to go to the first one (-rd)\n    vec3 idx = mix(-sign(rd), sign(rd), lessThanEqual(tmid, vec3(t.x)));\n    scale = 1;\n    size *= 0.5;\n    pos += 0.5 * size * idx;\n    \n    iter = MAX_ITER;\n    while (iter --> 0) { // `(iter--) > 0`; equivalent to `for(int i=128;i>0;i--)`\n        t = isect(pos, size, ro, rd, tmid, tmax);\n        \n        d = dist(pos);\n        \n        if (d < size*d_corner) { // Voxel exists\n            if (scale >= levels)// || d < -size)\n                return true; // Filled leaf\n            \n            if (can_push) {\n                //-- PUSH --//\n                \n                #ifndef STACKLESS\n                if (t.y < h) // Don't add this if we would leave the parent voxel as well\n                    stack_push(ST(pos, scale, idx, h));\n                #endif\n                h = t.y;\n                scale++;\n                size *= 0.5;\n                idx = mix(-sign(rd), sign(rd), lessThanEqual(tmid, vec3(t.x)));\n                pos += 0.5 * size * idx;\n                continue;\n            }\n        }\n        \n        //-- ADVANCE --//\n        \n        // Advance for every direction where we're hitting the middle (tmax = tmid)\n        vec3 old = idx;\n        idx = mix(idx, sign(rd), equal(tmax, vec3(t.y)));\n        pos += mix(vec3(0.), sign(rd), notEqual(old, idx)) * size;\n        \n        // If idx hasn't changed, we're at the last child in this voxel\n        if (idx == old) {\n            //-- POP --//\n            #ifdef STACKLESS\n            \n            vec3 target = pos;\n            size = root_size;\n            pos = root_pos;\n            scale = 0;\n\n            vec3 tmid, tmax;\n            t = isect(pos, size, ro, rd, tmid, tmax);\n            if (t.y <= h)\n                return false;\n\n            float nh = t.y;\n            for (int j = 0; j < 100; j++) { // J is there just in case\n                scale++;\n                size *= 0.5;\n                idx = sign(target-pos);\n                pos += idx * size * 0.5;\n                t = isect(pos, size, ro, rd, tmid, tmax);\n\n                // We have more nodes to traverse within this one\n                if (t.y > h) {\n                    nh = t.y;\n                } else break;\n            }\n            h = nh;\n            \n            #else\n            if (stack_empty() || scale == 0) return false; // We've investigated every voxel on the ray\n            \n            ST s = stack_pop();\n            pos = s.pos;\n            scale = s.scale;\n            size = root_size * exp2(float(-scale));\n\t\t\tidx = s.idx;\n            h = s.h;\n            #endif\n            \n            can_push = false; // No push-pop inf loops\n        } else can_push = true; // We moved, we're good\n    }\n    \n    return false;\n}\n#endif\n\n// -----------------------------------------------------------------------------------------\n\n\n// We want to shade w/ the mipmap\nvec3 sky(vec3 dir) {\n    return texture(iChannel1, dir).xyz;\n}\n\n// And see the sharp version\nvec3 sky_cam(vec3 dir) {\n    return texture(iChannel0, dir).xyz;\n}\n\n// https://shaderjvo.blogspot.com/2011/08/van-ouwerkerks-rewrite-of-oren-nayar.html\nvec3 oren_nayar(vec3 from, vec3 to, vec3 normal, Material mat) {\n    // Roughness, A and B\n    float roughness = mat.roughness;\n    float roughness2 = roughness * roughness;\n    vec2 oren_nayar_fraction = roughness2 / (roughness2 + vec2(0.33, 0.09));\n    vec2 oren_nayar = vec2(1, 0) + vec2(-0.5, 0.45) * oren_nayar_fraction;\n    // Theta and phi\n    vec2 cos_theta = saturate(vec2(dot(normal, from), dot(normal, to)));\n    vec2 cos_theta2 = cos_theta * cos_theta;\n    float sin_theta = sqrt((1.-cos_theta2.x) * (1.-cos_theta2.y));\n    vec3 light_plane = normalize(from - cos_theta.x * normal);\n    vec3 view_plane = normalize(to - cos_theta.y * normal);\n    float cos_phi = saturate(dot(light_plane, view_plane));\n    // Composition\n    float diffuse_oren_nayar = cos_phi * sin_theta / max(cos_theta.x, cos_theta.y);\n    float diffuse = cos_theta.x * (oren_nayar.x + oren_nayar.y * diffuse_oren_nayar);\n    \n    return mat.base_color * diffuse;\n}\n\n\n// These bits from https://simonstechblog.blogspot.com/2011/12/microfacet-brdf.html\n\nfloat schlick_g1(vec3 v, vec3 n, float k) {\n    float ndotv = dot(n, v);\n    return ndotv / (ndotv * (1. - k) + k);\n}\n\nvec3 brdf(vec3 from, vec3 to, vec3 n, Material mat, float ao) {\n    float ior = 1.5;\n    \n    // Half vector\n    vec3 h = normalize(from + to);\n    \n    // Schlick fresnel\n    float f0 = (1.-ior)/(1.+ior);\n    f0 *= f0;\n    float fresnel = f0 + (1.-f0)*pow(1.-dot(from, h), 5.);\n    \n    // Beckmann microfacet distribution\n    float m2 = sqr(mat.roughness);\n    float nh2 = sqr(saturate(dot(n,h)));\n    float dist = (exp( (nh2 - 1.)\n    \t/ (m2 * nh2)\n    \t))\n        / (PI * m2 * nh2*nh2);\n    \n    // Smith's shadowing function with Schlick G1\n    float k = mat.roughness * R2PI;\n    float geometry = schlick_g1(from, n, k) * schlick_g1(to, n, k);\n    \n    return saturate((fresnel*geometry*dist)/(4.*dot(n, from)*dot(n, to))\n        + ao*(1.-f0)*oren_nayar(from, to, n, mat));\n}\n\n\n// -----------------------------------------------------------------------------------------\n\n\n// By Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 shade(vec3 ro, vec3 rd, vec2 t, int iter, vec3 pos) {\n\n    // This pretends the Mandelbulb is actually a sphere, but it looks okay w/ AO.\n    vec3 n = normalize(pos);\n     n = calcNormal(pos);\n    // And this isn't accurate even for a sphere, but it ensures the edges are visible.\n    n = faceforward(n,-rd,-n);\n    \n\n   \n    \n    Material mat = Material(vec3(1.,.9,.7), 0.9);\n\n    #if MAT_SAMPLES\n    vec3 acc = vec3(0.);\n    int j;\n    for (j = 0; j < MAT_SAMPLES; j++) {\n        vec3 lightDir;\n        vec3 lightCol = vec3(0.);\n        for (int i = 0; i < SKY_SAMPLES; i++) {\n            vec3 d = hash33(0.2*pos+0.5*n+float(i+j*SKY_SAMPLES));\n            d = normalize(d);\n            vec3 c = sky(d);\n            if (length(c) > length(lightCol)) {\n                lightCol = c;\n                lightDir = d;\n            }\n        }\n        acc +=\n            2.*pow(lightCol, vec3(2.2)) * brdf(lightDir, -rd, n, mat, (float(iter)/float(MAX_ITER)));\n    }\n    return acc / float(j);\n\t#else\n    vec3 lightDir = reflect(rd,n);\n    return 2.*brdf(lightDir, -rd, n, mat, (float(iter)/float(MAX_ITER)));\n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    #if CAMERA_MOVEMENT\n    float r = iTime;\n    #else\n    float r = 12.0*iMouse.x/iResolution.x;\n    #endif\n    vec3 ro = vec3(2.0*sin(0.5*r),1.5-iMouse.y/iResolution.y,1.6*cos(0.5*r));\n    vec3 lookAt = vec3(0.0);\n    vec3 cameraDir = normalize(lookAt-ro);\n    vec3 up = vec3(0.0,1.0,0.0);\n    vec3 left = normalize(cross(cameraDir, up)); // Might be right\n    vec3 rd = cameraDir;\n    float FOV = 0.5; // Not actual FOV, just a multiplier\n    rd += FOV * up * uv.y;\n    rd += FOV * left * uv.x;\n    // `rd` is now a point on the film plane, so turn it back to a direction\n    rd = normalize(rd);\n    \n    vec2 t;\n    vec3 pos;\n    float size;\n    int iter;\n    \n    vec3 col = trace(ro, rd, t, pos, iter, size) ? shade(ro, rd, t, iter, pos) : sky_cam(rd);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1299, 1299, 1321, 1321, 1360], [1362, 1558, 1580, 1752, 2423], [2425, 2425, 2457, 2457, 2682], [2925, 2925, 2945, 2945, 2959], [2996, 2996, 3090, 3090, 3376], [3523, 3542, 3562, 3562, 3579], [3580, 3580, 3606, 3606, 3632], [3633, 3633, 3649, 3649, 3678], [3679, 3679, 3699, 3699, 3724], [7815, 7849, 7869, 7869, 7911], [7913, 7942, 7966, 7966, 8008], [8010, 8094, 8158, 8184, 9041], [9129, 9129, 9172, 9172, 9246], [9248, 9248, 9311, 9311, 10029], [10127, 10184, 10206, 10206, 10331], [11456, 11456, 11513, 11513, 12426]], "test": "untested"}
{"id": "ttyGW3", "name": "Phone call", "author": "EFHIII", "description": "We all have cell phones, so come on, lets get real.", "tags": ["sound", "audio", "ring", "phone"], "likes": 3, "viewed": 320, "published": 3, "date": "1580025837", "time_retrieved": "2024-07-30T21:28:45.834902", "image_code": "/*\nSound text copied from\nhttps://www.shadertoy.com/view/MtyXRW\n\nas per request of the author, FabriceNeyret2, thanks\n\n*/\n// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureLod( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), \\\n//                                                                               log2(length(fwidth(U/16.*iResolution.xy))) )\n  #define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound( in int samp, float time )\n{\n    float A=6.2831*440.0;\n    \n    if(int(time*1.5)%5<2){\n    \treturn vec2(sin(A*time)+sin(1.05*A*time));\n    }\n    return vec2(0.);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[797, 797, 820, 867, 1046], [1048, 1048, 1105, 1166, 1392]], "test": "untested"}
{"id": "Wty3Dc", "name": "Hyper/Epitrochoid 2D Section", "author": "hiogawa", "description": "I'm not sure how exactly this is related to \"Torus knot\" since my construction is more like \"Depth modulated hypertrochoid/epitrochoid with thickness\".\nWhat I mean by \"Knotted Hyper/Epitrochoid\" can be seen here https://www.shadertoy.com/view/wlGGW3.", "tags": ["2d", "torus", "epitrochoid", "hypertrochoid"], "likes": 3, "viewed": 320, "published": 3, "date": "1580024458", "time_retrieved": "2024-07-30T21:28:46.649724", "image_code": "//\n// 2D Section of Rotating Knotted Hyper/Epi-Trochoid\n//\n// NOTE:\n// - \"ROT_VELOCITY\" here doesn't necessarily give angular velocity around any axis\n//   since this is a derivative of extrinsic rotation angles xyz in this order.\n//   This might be the reason why \"vec3(M_PI, M_PI, M_PI)\" already does crazy stuff.\n// - Surprisingly \"Hyper\" and \"Epi\" give visually similar results.\n//   But, \"Epi\" requires more points to approximate curve since \"Epi\" curve is longer thant \"Hyper\".\n//   So \"Hyper\" might be the ones should be used.\n// - \"KNOTNESS > 1.0\" and \"KNOTNESS < 1.0\" give quite different results as expected.\n//\n\n#define M_PI 3.14159\n\nfloat AA = 2.0;\nfloat SCALE_TIME = 0.5;\nvec2  UV_CENTER = vec2(0.0, 0.0);\nfloat UV_HEIGHT = 3.0;\n\nfloat CHECKER_SCALE = 1.0;\nvec3  CHECKER_COLOR0 = vec3(0.1);\nvec3  CHECKER_COLOR1 = vec3(0.2);\nvec4  SECTION_COLOR = vec4(0.8, 1.0, 1.0, 0.9);\n\nconst float kEpi = 0.0;\nconst float kHyper = 1.0;\n\n// == Curve parameter ==\n// [ KNOTNESS > 1.0 ]\nconst float EPI_OR_HYPER = kHyper;\nfloat NUM_SYMMETRY = 4.0;\nfloat KNOTNESS = 2.5;\nfloat NUM_SEGMENTS = 128.0 * (EPI_OR_HYPER == kEpi ? 2.0 : 1.0);\nfloat BEBEL_WIDTH = 0.15;\n\n// [ KNOTNESS < 1.0 ]\n// const float EPI_OR_HYPER = kHyper;\n// float NUM_SYMMETRY = 3.0;\n// float KNOTNESS = 0.2;\n// float NUM_SEGMENTS = 128.0 * (EPI_OR_HYPER == kEpi ? 2.0 : 1.0);\n// float BEBEL_WIDTH = 0.15;\n\n// == Rotation ==\n// vec3  ROT_VELOCITY = vec3(M_PI, 0.0,  0.0);\n// vec3  ROT_VELOCITY = vec3(M_PI, 0.0,  M_PI);\n// vec3  ROT_VELOCITY = vec3(M_PI, M_PI, 0.0);\nvec3  ROT_VELOCITY = vec3(M_PI, M_PI, M_PI);\n// vec3  ROT_VELOCITY = vec3(M_PI, M_PI, 0.5 * M_PI);\n// vec3  ROT_VELOCITY = vec3(M_PI, M_PI * 4.0 / 3.0, M_PI * 5.0/ 4.0);\n\n\nfloat distance_Point_LineSegment(vec3 p, vec3 q1, vec3 q2) {\n  // < p - (q + t v), v> = 0  <=>  t = < p - q, v > / < v, v >\n  vec3 v = q2 - q1;\n  float dot_vv = dot(v, v);\n  if (dot(v, v) < 0.0000001) {\n    return distance(p, q1);\n  }\n  float t = dot(p - q1, v) / dot_vv;\n  float s = clamp(t, 0.0, 1.0);\n  return distance(p, q1 + s * v);\n}\n\nvec3 knottedTrochoidPoint(float t, float r1, float r2, float r3, float type) {\n  float n = r1 / r2;\n  vec3 q;\n  if (type == kHyper) {\n    q = vec3(\n      // usual hyper-trochoid formula\n      (r1 - r2) * cos(t) + r3 * cos((1.0 - n) * t),\n      (r1 - r2) * sin(t) + r3 * sin((1.0 - n) * t),\n      // knot by waving z coord along symmetry\n      sin(n * t));\n  }\n  if (type == kEpi) {\n    q = vec3(\n      // usual epi-trochoid formula\n      (r1 + r2) * cos(t) + r3 * cos((1.0 + n) * t - M_PI),\n      (r1 + r2) * sin(t) + r3 * sin((1.0 + n) * t - M_PI),\n      // knot by waving z coord along symmetry\n      sin(n * t));\n  }\n  return q;\n}\n\n//\n// Re-parameterize hyper/epi-trochoid for easier visual control\n//\n//   \"num_symmetry\"\n//     n = r1 / r2 = 1 / r2 \\in N\n//\n//   \"knotness\" (knot (a > 1), intersecton (1 > a > 0), no-intersection (0 > a))\n//     r3 = (1 - a) r2 + a * (r1 - r2)  (for hyper-trochoid)\n//     r3 = (1 - a) r2 + a * (r1 + r2)  (for epi-trochoid)\n//\nfloat signedDistanceToKnottedTrochoid(\n    vec3 p, float type, float knotness, float num_symmetry,\n    float num_segments, float bebel_width) {\n\n  // Take care reparameterization and normalize overall size to about [-1, 1]^2\n  float r1 = 1.0;\n  float r2 = 1.0 / num_symmetry;\n  float r3, size; {\n    if (type == kHyper) {\n      r3 = (1.0 - knotness) * r2 + knotness * (r1 - r2);\n      size = r1 - r2 + r3;\n    }\n    if (type == kEpi) {\n      r3 = (1.0 - knotness) * r2 + knotness * (r1 + r2);\n      size = r1 + r2 + r3;\n    }\n  }\n  r1 /= size; r2 /= size; r3 /= size;\n\n  // Approximate distance by straight lines\n  float min_distance = 1000.0;\n\n  vec3 q1, q2;\n  q1 = knottedTrochoidPoint(0.0, r1, r2, r3, type);\n\n  bool OPTIM_LOOP_WITH_SYMMETRY = true;\n  if (OPTIM_LOOP_WITH_SYMMETRY) {\n    // NOTE: It seems this approach is a bit faster.\n    for (float i = 1.0; i < num_segments / num_symmetry + 1.0; i++) {\n      float t = 2.0 * M_PI * i / num_segments;\n      q2 = knottedTrochoidPoint(t, r1, r2, r3, type);\n      for (float j = 0.0; j < num_symmetry; j++) {\n        float s = 2.0 * M_PI * j / num_symmetry;\n        mat2 rot = mat2(cos(s), sin(s), -sin(s), cos(s));\n        vec3 v1 = vec3(rot * q1.xy, q1.z);\n        vec3 v2 = vec3(rot * q2.xy, q2.z);\n        float sd = distance_Point_LineSegment(p, v1, v2) - bebel_width;\n        min_distance = min(min_distance, sd);\n      }\n      q1 = q2;\n    }\n\n  } else {\n    vec3 q1, q2;\n    q1 = knottedTrochoidPoint(0.0, r1, r2, r3, type);\n    for (float i = 1.0; i < num_segments + 1.0; i++) {\n      float t = 2.0 * M_PI * i / num_segments;\n      q2 = knottedTrochoidPoint(t, r1, r2, r3, type);\n      float sd = distance_Point_LineSegment(p, q1, q2) - bebel_width;\n      min_distance = min(min_distance, sd);\n      q1 = q2;\n    }\n  }\n  return min_distance;\n}\n\n\n//\n// Misc\n//\n\nmat2 rot2(float t) {\n  return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nmat3 rot3(vec3 r) {\n  mat2 x = rot2(r.x);\n  mat2 y = rot2(r.y);\n  mat2 z = rot2(r.z);\n  mat3 X = mat3(\n      1.0,     0.0,     0.0,\n      0.0, x[0][0], x[0][1],\n      0.0, x[1][0], x[1][1]);\n  mat3 Y = mat3(\n    y[1][1],   0.0, y[0][1],\n        0.0,   1.0,     0.0,\n    y[1][0],   0.0, y[0][0]);\n  mat3 Z = mat3(\n    z[0][0], z[0][1],   0.0,\n    z[1][0], z[1][1],   0.0,\n        0.0,     0.0,   1.0);\n  return Z * Y * X;\n}\n\nfloat signedDistanceToChecker(vec2 uv, float scale) {\n  uv *= scale;\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float dist = min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n  dist /= scale;\n  bool is_even_spot = mod(uvi.x + uvi.y, 2.0) == 0.0;\n  return is_even_spot ? -dist : dist;\n}\n\nmat3 invViewTransform(vec2 center, float height) {\n  vec2 Res = iResolution.xy;\n  vec2 size = vec2(height * Res.x / Res.y, height);\n  vec2 a = center - size / 2.0;\n  float Sy = height / Res.y;\n  mat3 xform = mat3(\n       Sy,   0,   0,\n        0,  Sy,   0,\n      a.x, a.y, 1.0);\n  return xform;\n}\n\nfloat smoothBoundaryCoverage(float signed_distance, float boundary_width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / boundary_width + 0.5);\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  mat3 inv_view_xform = invViewTransform(UV_CENTER, UV_HEIGHT);\n  float inv_view_scale = inv_view_xform[0][0];\n  vec2 uv =  vec2(inv_view_xform * vec3(frag_coord, 1.0));\n  float t = SCALE_TIME * iTime;\n\n  vec3 color;\n  {\n    // Checker\n    float sd = signedDistanceToChecker(uv, CHECKER_SCALE);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(CHECKER_COLOR0, CHECKER_COLOR1, coverage);\n  }\n  {\n    // Animate transform and coordinate\n    mat4 obj_xform = mat4(rot3(ROT_VELOCITY * t));\n    vec3 p = vec3(uv, 0.0);\n    vec3 p_in_obj = vec3(inverse(obj_xform) * vec4(p, 1.0));\n\n    // Approximate 2d section distance by 3d distance\n    float sd = signedDistanceToKnottedTrochoid(\n        p_in_obj, EPI_OR_HYPER, KNOTNESS, NUM_SYMMETRY, NUM_SEGMENTS, BEBEL_WIDTH);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(color, SECTION_COLOR.xyz, SECTION_COLOR.w * coverage);\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1704, 1704, 1764, 1827, 2043], [2045, 2045, 2123, 2123, 2678], [2680, 3011, 3154, 3235, 4815], [4833, 4833, 4853, 4853, 4903], [4905, 4905, 4924, 4924, 5327], [5329, 5329, 5382, 5382, 5625], [5627, 5627, 5677, 5677, 5922], [5924, 5924, 5999, 5999, 6078], [6096, 6096, 6150, 6150, 7130]], "test": "untested"}
{"id": "wlGGW3", "name": "Knotted Hyper/Epitrochoid", "author": "hiogawa", "description": "What I call \"Knotted Hyper/Epi-Trochoid\". Tring to show depth by changing size of point, but not really good.\nThis one was the base for https://www.shadertoy.com/view/Wty3Dc.", "tags": ["2d", "epitrochoid", "hypertrochoid"], "likes": 6, "viewed": 333, "published": 3, "date": "1580024434", "time_retrieved": "2024-07-30T21:28:47.553308", "image_code": "//\n// Knotted Hyper/Epi-Trochoid\n//\n\n#define M_PI 3.14159\n\nfloat AA = 2.0;\nfloat SCALE_TIME = 1.5;\nvec2  UV_CENTER = vec2(0.0, 0.0);\nfloat UV_HEIGHT = 2.2;\n\nfloat CHECKER_SCALE = 1.0;\nvec3  CHECKER_COLOR0 = vec3(0.1);\nvec3  CHECKER_COLOR1 = vec3(0.2);\n\nconst float kEpi = 0.0;\nconst float kHyper = 1.0;\n\nconst float EPI_OR_HYPER = kEpi;\nfloat NUM_SYMMETRY = 4.0;\nconst float NUM_POINTS = 128.0 * (EPI_OR_HYPER == kEpi ? 2.0 : 1.0);\nfloat POINT_RADIUS = M_PI / NUM_POINTS * (EPI_OR_HYPER == kEpi ? 2.0 : 0.9);\nvec4  TROCHOID_COLOR = vec4(0.8, 1.0, 1.0, 0.9);\n\n//\n// Re-parameterize hyper/epi-trochoid for easier visual control\n//\n//   \"num_symmetry\"\n//     n = r1 / r2 = 1 / r2 \\in N\n//\n//   \"knotness\" (knot (a > 1), intersecton (1 > a > 0), no-intersection (0 > a))\n//     r3 = (1 - a) r2 + a * (r1 - r2)  (for hyper-trochoid)\n//     r3 = (1 - a) r2 + a * (r1 + r2)  (for epi-trochoid)\n//\n// TODO:\n// - reduce loop by taking symmetry into account\n// - for higher n, there is different kind of qualitative change (e.g. intersection with neighbor).\n//\nfloat signedDistanceToKnottedTrochoidPoints(\n    vec2 p, float trochoid_type, float knotness, float num_symmetry,\n    float num_points, float point_radius, float knot_offset) {\n\n  float r1 = 1.0;\n  float r2 = 1.0 / num_symmetry;\n  float r3, size; {\n    if (trochoid_type == kHyper) {\n      r3 = (1.0 - knotness) * r2 + knotness * (r1 - r2);\n      size = r1 - r2 + r3;\n    }\n    if (trochoid_type == kEpi) {\n      r3 = (1.0 - knotness) * r2 + knotness * (r1 + r2);\n      size = r1 + r2 + r3;\n    }\n  }\n  r1 /= size; r2 /= size; r3 /= size;\n\n  float min_distance = 1000.0;\n  for (float i = 0.0; i < num_points; i++) {\n    float t = 2.0 * M_PI * i / num_points;\n    vec3 q; {\n      if (trochoid_type == kHyper) {\n        q = vec3(\n          // usual hyper-trochoid formula\n          (r1 - r2) * cos(t) + r3 * cos((1.0 - num_symmetry) * t),\n          (r1 - r2) * sin(t) + r3 * sin((1.0 - num_symmetry) * t),\n          // knot by waving z coord along symmetry\n          sin(num_symmetry * (t + knot_offset)));\n      }\n      if (trochoid_type == kEpi) {\n        q = vec3(\n          // usual epi-trochoid formula\n          (r1 + r2) * cos(t) + r3 * cos((1.0 + num_symmetry) * t - M_PI),\n          (r1 + r2) * sin(t) + r3 * sin((1.0 + num_symmetry) * t - M_PI),\n          // knot by waving z coord along symmetry\n          sin(num_symmetry * (t + knot_offset)));\n      }\n    }\n    float radius = point_radius * mix(0.6, 1.0, q.z);\n    float sd = distance(p, q.xy) - radius;\n    if (sd < min_distance) {\n      min_distance = sd;\n    }\n  }\n  return min_distance;\n}\n\n\n//\n// Misc\n//\n\nfloat signedDistanceToChecker(vec2 uv, float scale) {\n  uv *= scale;\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float dist = min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n  dist /= scale;\n  bool is_even_spot = mod(uvi.x + uvi.y, 2.0) == 0.0;\n  return is_even_spot ? -dist : dist;\n}\n\nmat3 invViewTransform(vec2 center, float height) {\n  vec2 Res = iResolution.xy;\n  vec2 size = vec2(height * Res.x / Res.y, height);\n  vec2 a = center - size / 2.0;\n  float Sy = height / Res.y;\n  mat3 xform = mat3(\n       Sy,   0,   0,\n        0,  Sy,   0,\n      a.x, a.y, 1.0);\n  return xform;\n}\n\nfloat smoothBoundaryCoverage(float signed_distance, float boundary_width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / boundary_width + 0.5);\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  mat3 inv_view_xform = invViewTransform(UV_CENTER, UV_HEIGHT);\n  float inv_view_scale = inv_view_xform[0][0];\n  vec2 uv =  vec2(inv_view_xform * vec3(frag_coord, 1.0));\n  float t = SCALE_TIME * iTime;\n\n  vec3 color;\n  {\n    // Checker\n    float sd = signedDistanceToChecker(uv, CHECKER_SCALE);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(CHECKER_COLOR0, CHECKER_COLOR1, coverage);\n  }\n  {\n    // Hyper/Epi-Trochoid\n    float knotness = 3.0 * (0.5 + 0.5 * sin(t));\n    float knot_offset = 0.0; // not used now\n    float sd = signedDistanceToKnottedTrochoidPoints(\n        uv, EPI_OR_HYPER, knotness, NUM_SYMMETRY, NUM_POINTS, POINT_RADIUS, knot_offset);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(color, TROCHOID_COLOR.xyz, TROCHOID_COLOR.w * coverage);\n  }\n  frag_color = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 1051, 1227, 1227, 2605], [2623, 2623, 2676, 2676, 2919], [2921, 2921, 2971, 2971, 3216], [3218, 3218, 3293, 3293, 3372], [3390, 3390, 3444, 3444, 4322]], "test": "untested"}
{"id": "3lG3Dc", "name": "Isosurface Teapot", "author": "klk", "description": "Teapot SDF model (was made as a test task for job application)", "tags": ["sdf", "isosurface", "teapot", "tea"], "likes": 23, "viewed": 808, "published": 3, "date": "1580019416", "time_retrieved": "2024-07-30T21:28:48.476839", "image_code": "// Fork of \"Isosurface Heart\" by klk. https://shadertoy.com/view/XtVSRh\n\n// Many Thanks to IQ for wonderful idea of signed distance field!\n\n#define PI 3.1415926535897932384626433832795\n\n#define float3 vec3\n#define float2 vec2\n#define float4 vec4\n#define float3x3 mat3\n\nconst float MAX_RAY_LENGTH=10000.0;\n\nvoid RayPlane(float3 tp0, float3 dp1, float3 dp2, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n\tfloat3 dp0=rp0-tp0;\n\n\tfloat3 dett =cross(dp1,dp2);\n\tfloat3 detuv=cross(dp0,rd);\n\n\tfloat det=(-1.0)/dot(dett,rd);\n\n\tfloat u=(dot(detuv,dp2))*det;\n\tfloat v=(dot(detuv,dp1))*det;\n\tt=(dot(dett ,dp0))*det;\n\tif(t<0.0)\n\t{\n\t\tt=MAX_RAY_LENGTH;\n\t\treturn;\n\t}\n\t\n\tuv=float3(u,v,0.0);\n\tn=normalize(dett);\n}\n\nfloat Arrows(float2 p, float t)\n{\n\tfloat2 p1=float2(p.x+p.y,p.x-p.y);\n\tfloat2 f1xy=abs(fract(p1/sqrt(8.0))-0.5)-0.25;\n\tf1xy=clamp(f1xy*t+0.5,0.0,1.0);\n\tfloat f1=mix(f1xy.x,1.0-f1xy.x,f1xy.y);\n\n\tfloat2 fxy=float2(p.x-sqrt(0.125),p.y);\n\tfxy=abs(fract((fxy*sqrt(2.0)+0.5)/2.0)-0.5)-0.25;\n\tfxy=clamp(fxy*t/sqrt(2.0)+0.5,0.0,1.0);\n\tfloat f=mix(fxy.x,1.0-f1,fxy.y);\n\n\treturn f;\n}\n\nfloat Checker(float2 p, float t)\n{\n\tfloat2 fxy=float2(p.x,p.y);\n\tfxy=abs(fract((fxy+0.5)/2.0)-0.5)-0.25;\n\tfxy=clamp(fxy*t+0.5,0.0,1.0);\n\tfloat f=mix(fxy.x,1.0-fxy.x,fxy.y);\n\n\treturn f;\n}\n\nfloat PlaneTexture(float2 p, float t)\n{\n\treturn Arrows(p,t);\n}\n\n// Trace non-SDF objects\nvoid Trace(float3 rp0, float3 rd, out float t, out float3 pos, out float3 n)\n{\n\tfloat t1=MAX_RAY_LENGTH;\n\tfloat3 col1;\n\tfloat3 n1;\n\tRayPlane(float3(0.0,-10.0,0.0),float3(-1.0,0.0,0.0),float3(0.0,0,1.0),rp0, rd, t1, col1, n1);\n\tpos=rp0+rd*t1;\n\tt=t1;\n}\n\n// Smooth combine functions from IQ\nfloat smin(float a, float b, float k)\n{\n\tfloat h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n\treturn mix(b, a, h)-k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k)\n{\n\treturn -smin(-a,-b,k);\n}\n\nfloat smin( float a, float b)\n{\n\treturn smin(a,b,0.1);\n}\n\nfloat smax( float a, float b)\n{\n\treturn smax(a,b,0.1);\n}\n\nfloat sq(float x){return x*x;}\n\nfloat Torus(float x, float y, float z, float R, float r)\n{\n\treturn sqrt(sq(sqrt(sq(x)+sq(z))-R)+sq(y))-r;\n}\n\nfloat Torus(vec3 p, float R, float r)\n{\n\treturn sqrt(sq(sqrt(sq(p.x)+sq(p.z))-R)+sq(p.y))-r;\n}\n\n\nfloat Lid(float x, float y, float z)\n{\n\tfloat v=sqrt(sq(x)+sq(y-0.55)+sq(z))-1.4;\n\tv=smin(v,Torus(y-2.,x,z,.2,.08),.1);\n\tv=smax(v,-sqrt(sq(x)+sq(y-0.55)+sq(z))+1.3);\n\tv=smax(v,sqrt(sq(x)+sq(y-2.5)+sq(z))-1.3);\n\n\tv=smax(v,-sqrt(sq(x-.25)+sq(z-.35))+0.05,.05);\n\tv=smin(v,Torus(x,(y-1.45)*.75,z,.72,.065),.2);\n\treturn v;\n}\n\nfloat Nose(float x, float y, float z)\n{\n\tz-=sin((y+0.8)*3.6)*.15;\n\t\n\tfloat v=sqrt(sq(x)+sq(z));\n\t\n\tv=abs(v-.3+sin(y*1.6+.5)*0.18)-.05;\n\tv=smax(v,-y-1.);\n\tv=smax(v,y-0.85,.075);\n\t\n\treturn v;\n}\n\nfloat Teapot(float3 p)\n{\n\tfloat x=p.x;\n\tfloat y=p.y;\n\tfloat z=p.z;\n\n\tfloat v=0.0;\n\tv=sqrt(x*x+z*z)-1.2-sin(y*1.5+2.0)*.4;\n\tv=smax(v,abs(y)-1.,0.3);\n\n\n\t\n\tfloat v1=sqrt(x*x*4.+sq(y+z*.1)*1.6+sq(z+1.2))-1.0;\n\tv1=smax(v1,-sqrt(sq(z+1.2)+sq(y+z*.12+.015)*1.8)+.8,.3);\n\t\n\tv=smin(v,Torus(y*1.2+.2+z*.3,x*.75,z+1.25+y*.2,.8,.1),.25);\n\tv=smin(v,sqrt(sq(x)+sq(y-1.1)+sq(z+1.8))-.05,.32);\n\n\tfloat v3=Nose(x,(y+z)*sqrt(.5)-1.6,(z-y)*sqrt(.5)-1.1);\n\n\tv=smin(v,v3,0.2);\n\t\n\tv=smax(v,smin(sin(y*1.4+2.0)*0.5+.95-sqrt(x*x+z*z),y+.8, .2));\n\tv=smax(v,-sqrt(sq(x)+sq(y+.15)+sq(z-1.5))+.12);\n\n\tv=smin(v,Torus(x,y-0.95,z,0.9,.075));\n\tv=smin(v,Torus(x,y+1.05,z,1.15,.05),0.15);\n\t\n\t\n\tfloat v2=Lid(x,y+.5,z);\n\tv=min(v,v2);\n\n\treturn v;\n}\n\nfloat plate0(float3 p)\n{\n\tfloat v=(length(p.xz)*.8-p.y)/sqrt(1.64);\n\tv=smin(v,(length(p.xz)*.3-p.y+.7)/sqrt(1.09));\n\tv=smax(v,-p.y+.8,.1);\n\treturn v;\n}\n\nfloat Plate(float3 p)\n{\n\tfloat v;\n\tfloat vi=plate0(p);\n\tfloat vo=plate0(p+float3(0,-.1,0));\n\tv=smax(vi,-vo);\n\tv=smax(v,(length(p.xz)*2.+p.y)/sqrt(3.)-3.);\n\tv=smin(v,Torus(p.x,p.y-.7,p.z,0.8,.025),0.2);\n\treturn v;\n}\n\nfloat Value(float3 p)\n{\n\tfloat v;\n\tv=Teapot(p);\n\t//v=Plate(p);\n\treturn v;\n}\n\nstruct Ray\n{\n\tvec3 p;\n\tvec3 d;\n};\n\nbool RayMarch(\n\tconst in Ray r, \n\tconst float startT, const float endT, \n\tconst float stp, \n\tconst int N,\n\tout float t, out float v, out int i)\n{\n\tfloat t0=startT;\n\tt=t0;\n\tv=Value(r.p+r.d*t);\n\n\tif(v<0.)\n\t\treturn true;\n\n\ti=0;\n\tfor(int j=0;j<1;j+=0)\n\t{\n\t\tt+=max(v*.85, stp);\n\t\tfloat v1=Value(r.p+r.d*t);\n\t\tif(v1<0.)\n\t\t{\n\t\t\t// Linear interpolation between two last steps\n\t\t\tt=t0+(t-t0)*v/(v-v1);\n\t\t\tv=Value(r.p+r.d*t);\n\t\t\treturn true;\n\t\t}\n\t\tif(t>endT)\n\t\t\treturn false;\n\t\ti++;\n\t\tif(i>N)\n\t\t\treturn false;\n\t\tv=v1;\n\t\tt0=t;\n\t}\n\treturn false;\n}\n\nfloat3 CalcNormal(float3 p, float n0)\n{\n\tfloat3 n;\n\tfloat d=0.001;\n\tn.x=Value(p+float3(d,0.0,0.0))-n0;\n\tn.y=Value(p+float3(0.0,d,0.0))-n0;\n\tn.z=Value(p+float3(0.0,0.0,d))-n0;\n\n\tn=normalize(n);\n\treturn n;\n}\n\nstruct Sphere\n{\n\tvec3 p;\n\tfloat r;\n};\n\nbool RaySphere(in Ray r, in Sphere s, out float t0, out float t1)\n{\n\tfloat3 l=s.p-r.p;\n\tfloat tc=dot(l,r.d);\n\tif(tc<0.0)\n\t{\n\t\treturn false;\n\t};\n\n\tfloat d2=s.r*s.r+tc*tc-dot(l,l);\n\n\tif(d2<0.0)\n\t{\n\t\treturn false;\n\t};\n\n\tfloat thc=sqrt(d2);\n\tt0=tc-thc;\n\tt1=tc+thc;\n\treturn true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat3 campos=float3(-12.0,3.0,0.0);\n\tfloat3 look_at=float3(0.0,0.5,0.0);\n\tfloat3 up=float3(0,1,0);\n\tfloat3 forward;\n\tfloat3 right;\n\n\tfloat3 light=float3(0,10,10);\n\n\tfloat T=iTime*0.45;\n\t\n\tlight.x=cos(T)*10.0;\n\tlight.z=sin(T)*10.0;\n\tlight.y=5.0;\n\t\n\tfloat mposx=iMouse.x;\n\tfloat mposy=iMouse.y;\n\t//if(iMouse.z<0.0)mposx=-iMouse.z;\n\t//if(iMouse.w<0.0)mposy=-iMouse.w;\n\t\n\tfloat a1=(0.6+(mposy/iResolution.y-0.5)*0.7)*PI;\n\tfloat a2=mposx/iResolution.x*PI*2.0-PI/3.0;\n\n\tif(iMouse.y<10.0)\n\t{\n\t\ta1=PI*0.55;\n\t\ta2=PI+0.3;\n\t}\n\n\tcampos.y=cos(a1)*campos.x;\n\tfloat camx=sin(a1)*campos.x;\n\tcampos.x=cos(a2)*camx;\n\tcampos.z=sin(a2)*camx;\n\t\n\tforward=normalize(look_at-campos);\n\tright=normalize(cross(up,forward));\n\tup=normalize(cross(forward,right));\n\n\tfloat2 scr = fragCoord.xy /iResolution.xy;\n\tscr=2.0*scr-1.0;\n\n\tfloat2 scr2ray=scr;\n\tscr2ray.x*=(iResolution.x/iResolution.y);\n\tfloat2 uv=scr2ray;\n\tfloat3 ray=normalize(forward+(up*uv.y+right*uv.x)*0.2);\n\n\tfloat3 col=float3(0.0,0.5,0.0);\n\tfloat3 n;\n\tfloat t;\n\n\tfloat3 fogcol=mix(float3(0.87,0.8,0.83),float3(0.3,0.6,1.0),clamp(1.0-(1.0-ray.y)*(1.0-ray.y),0.,1.));\n\tfragColor.rgb=fogcol;\n\tfloat3 tpos;\n\tTrace(campos, ray, t, tpos, n);\n\tcol=mix(float3(0.97,0.95,0.83),float3(0.1,0.15,0.4), smoothstep(0.0,1.0,PlaneTexture(tpos.xz*0.2,36000.0/t/t)));\n\tfloat3 tolight=normalize(light);\n\n\t// Debug visualization of SDF values \n\tif(false)\n\t{\n\t\tfloat t1=MAX_RAY_LENGTH;\n\t\tfloat3 col1;\n\t\tfloat3 colp=vec3(0);\n\t\tfloat3 n1;\n\t\tRayPlane(float3(0.,0.,0.),float3(0.0,1.0,0.0),float3(1.0,0,0.0),campos, ray, t1, col1, n1);\n\t\tfloat3 pos=campos+ray*t1;\n\t\tif(t1<t)\n\t\t{\n\t\t\tt=t1;\n\t\t\tfloat v=Value(pos);\n\t\t\tcolp.r=v>0.?fract(v):0.5;\n\t\t\tcolp.b=v<0.?fract(v):0.5;\n\t\t\tcolp.g=.5-abs(clamp(fract(v*10.),0.,1.)-0.5);\n\t\t}\n\t\tcol.rgb+=colp.rgb*0.5;\n\t\tfragColor.rgb=col;\n\t}\n\n\tif(t<MAX_RAY_LENGTH)\n\t{\n\t\tcol=mix(fogcol,col,exp(-t*0.005));\n\t\tfragColor.rgb=col;\n\t}\n\n\t{\n\t\tfloat ts0, ts1;\n\t\tfloat3 start=campos;\n\t\tfloat n0;\n\t\tSphere bound=Sphere(vec3(.0,.3,.2),2.5);\n\n\t\t// Try bounding sphere first\n\t\tbool hit=RaySphere(Ray(start,ray), bound, ts0, ts1);\n\t\t//if(hit)fragColor.rgb*=0.95;\n\t\tint nt=-1;\n\n\t\tfloat tp;\n\n\t\tif(hit)\n\t\t{\n\t\t\thit=RayMarch(Ray(start,ray),ts0,ts1,.025,180,tp,n0,nt);\n\t\t}\n\n\t\tif(hit)\n\t\t{\n\t\t\tif(tp<t)\n\t\t\t{\n\t\t\t\tt=tp;\n\t\t\t\tfloat3 p=start+ray*tp;\n\t\t\t\tfloat3 n=CalcNormal(p,n0);\n\t\t\t\tif(nt<0)\n\t\t\t\t{\n\t\t\t\t\tn=normalize(p-bound.p);\n\t\t\t\t}\n\n\t\t\t\tfloat3 halfn=normalize(tolight-ray);\n\n\t\t\t\tfloat lamb=pow(clamp(dot(n,tolight),0.0,1.0),1.0)*0.9+0.1;\n\t\t\t\tfloat3 refray=reflect(ray,n);\n\n\t\t\t\tfloat spec1=clamp(dot(halfn,n),0.0,1.0);\n\t\t\t\tfloat spec2=clamp(dot(tolight,refray),0.0,1.0);\n\n\t\t\t\tfloat3 reffog=mix(\n\t\t\t\t\tfloat3(0.87,0.8,0.83),\n\t\t\t\t\tfloat3(0.3,0.6,1.0),\n\t\t\t\t\tclamp(1.0-(1.0-refray.y)*(1.0-refray.y),0.,1.));\n\n\t\t\t\tfloat3 n1;\n\n\t\t\t\tcol=lamb*float3(0.78,0.79,0.8);\n\t\t\t\tfloat3 rpos;\n\t\t\t\tfloat3 rcol;\n\t\t\t\tfloat tr;\n\t\t\t\tTrace(p, reflect(ray,n), tr, rpos, n1);\n\t\t\t\tfloat fresn=clamp(1.0-dot(ray,-n),0.0,1.0);\n\t\t\t\tif(tp<MAX_RAY_LENGTH)\n\t\t\t\t{\n\t\t\t\t\trcol=mix(float3(0.87,0.85,0.83),float3(0.1,0.12,0.4),\n\t\t\t\t\t\tsmoothstep(0.0,1.0,PlaneTexture(rpos.xz*0.2,600.0/tr/tr)));\n\t\t\t\t\trcol=mix(reffog,rcol,exp(-tr*0.02));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trcol=reffog;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tcol=mix(col,rcol,pow(fresn,1.2)*0.50);\n\t\t\t\t\tcol+=rcol*(pow(fresn,2.6)*0.2+0.1);\n\t\t\t\t\tcol=mix(col,float3(1,1,1),pow(spec2,40.0)*.4);\n\t\t\t\t\tcol=mix(col,float3(1,1,1),.8*pow(spec2,180.0));\n\t\t\t\t}\n\t\t\t\tfragColor.rgb=col;\n\t\t\t}\n\t\t}\n\n\t\t// Color coded steps count\n\t\tif(false)\n\t\t{\n\t\t\tif(nt>8)\n\t\t\t\tfragColor.g+=.2;\n\t\t\tif(nt>16)\n\t\t\t\tfragColor.r+=.4;\n\t\t\tif(nt>32)\n\t\t\t\tfragColor.g-=.2;\n\t\t\tif(nt>48)\n\t\t\t\tfragColor.rb+=vec2(-.4,.4);\n\t\t}\n\t}\n\tfragColor.a=1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lG3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 306, 422, 422, 716], [718, 718, 751, 751, 1091], [1093, 1093, 1127, 1127, 1279], [1281, 1281, 1320, 1320, 1343], [1345, 1370, 1448, 1448, 1620], [1622, 1658, 1697, 1697, 1776], [1778, 1778, 1818, 1818, 1844], [1846, 1846, 1877, 1877, 1902], [1904, 1904, 1935, 1935, 1960], [1962, 1962, 1980, 1980, 1992], [1994, 1994, 2052, 2052, 2101], [2103, 2103, 2142, 2142, 2197], [2200, 2200, 2238, 2238, 2519], [2521, 2521, 2560, 2560, 2712], [2714, 2714, 2738, 2738, 3425], [3427, 3427, 3451, 3451, 3578], [3580, 3580, 3603, 3603, 3794], [3796, 3796, 3819, 3819, 3871], [4445, 4445, 4484, 4484, 4650], [4691, 4691, 4758, 4758, 4967], [4969, 4969, 5026, 5026, 8629]], "test": "untested"}
{"id": "WtG3D3", "name": "Voronoi Embers", "author": "aethelwhat", "description": "accident while working on voronoi particle tracking", "tags": ["voronoi", "abstract", "tracking", "particle"], "likes": 3, "viewed": 336, "published": 3, "date": "1580016019", "time_retrieved": "2024-07-30T21:28:49.399372", "image_code": "void mainImage( out vec4 Q, in vec2 U)\n{\n    vec4 a = A(U);\n    \n    //Q = vec4(a.xy / R + .1, a.z, 1.);\n    \n    float red = smoothstep(0., 1.1, 1.0 - abs((a.x / R.x) -.5));\n\tQ = vec4(red, a.y / R.y, a.z, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// learned voronoi particle tracking from wyatt's ecosystem\nvoid swap (inout vec4 a, vec2 U, vec2 r) {\n    vec4 n = A(U+r);\n    if (length(U-n.xy)<length(U-a.xy)){\n      a = n;\n    }\n}\n\nvoid mainImage( out vec4 Q, in vec2 U)\n{\n    // FIND NEAREST PARTICLE\n    vec4 a = A(U);\n    swap(a,U,vec2(1,0));\n    swap(a,U,vec2(0,1));\n    swap(a,U,vec2(-1,0));\n    swap(a,U,vec2(0,-1));\n    swap(a,U,vec2(1,1));\n    swap(a,U,vec2(-1,-1));\n    swap(a,U,vec2(-1,1));\n    swap(a,U,vec2(1,-1));\n\n    Q = a;\n    Q.y -= 0.35;\n    \n    float randomX = iResolution.x * rand(iTime) * 3.; \n    // the *3. slows down the rate of adding particles (\"slices\") by sending 2/3 out of range\n    float halfY = iResolution.y/2.;\n    if (length(U-vec2(randomX, halfY))<length(U-a.xy)){\n      Q = vec4(randomX, halfY, 0., 1.);\n    }\n    \n    // Click to paint in color\n    if ((iMouse.z>0.&&length(iMouse.xy-U)<1.)) {\n        Q = vec4(U,pow(randomX,2.),1.);\n    }   \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * voronoi tracking of particles\n * a new particle is added randomly at the midway line, creating\n * a 'cutting' effect\n */\n\n//Common\n#define R iResolution.xy\n#define A(U) texture(iChannel0, (U)/R)\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtG3D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 212]], "test": "untested"}
{"id": "3lG3D3", "name": "[multipass] - Raytraced balls #5", "author": "Cewein", "description": "this version is multi pass and implement refaction\n\nThis is a implementation of the \"Ray Tracing in one weekend\" done in real time.\n\n60 fps with a GTX 1070Ti and 20 rays per pixel!", "tags": ["raytracing", "realtime", "relfection", "mutlipass", "metalic", "raytracinginoneweekend"], "likes": 6, "viewed": 819, "published": 3, "date": "1580002014", "time_retrieved": "2024-07-30T21:28:50.276029", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 color = texture(iChannel0, uv).rgb;\n    \n\tfragColor = vec4(pow(clamp(color, 0., 1.), vec3(1./2.2)), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\n// this is a port of a single pass shader to a multipass shader\n// the shader can be found here: https://www.shadertoy.com/view/3syGWz\n// made by Cewein, 2020\n//\n\n#define FLT_MAX 3.402823466e+38\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\nconst int MAX_BOUNCE = 5;\n\nstruct ray {\n    vec3 A;\n    vec3 B;\n};\n    \nstruct hitRecord {\n    float t;\n    vec3 p;\n    vec3 normal;\n    int mat;\n    vec3 color;\n};\n\nstruct sphere \n{\n    vec3 center;\n    float radius;\n    int mat;\n    vec3 color;\n};\n    \nstruct hitableList {\n    sphere[5] sList;\n    int size;\n};\n\nstruct camera {\n    vec3 llc;\n    vec3 h;\n    vec3 v;\n    vec3 o;\n};\n        \n           \nvec3 origin(ray r) {return r.A; }\nvec3 direction(ray r) {return r.B; }\nvec3 pointAtParameter(ray r, float t) { return r.A + t*r.B; }\n\nbool hitSphere(in ray r, float tmin, float tmax, inout hitRecord rec, sphere s)\n{\n    vec3 oc = origin(r) - s.center;\n    float a = dot(direction(r),direction(r));\n    float b = dot(oc, direction(r));\n    float c = dot(oc,oc)-s.radius*s.radius;\n    float d = b*b - a*c;\n    if (d > 0.) \n    {\n        float temp = (-b - sqrt(b*b-a*c))/a;\n        if(temp < tmax && temp > tmin)\n        {\n            rec.t = temp;\n            rec.p = pointAtParameter(r,rec.t);\n            rec.normal = (rec.p - s.center) / s.radius;\n            rec.mat = s.mat;\n            rec.color = s.color;\n            return true;\n        }\n        temp = (-b + sqrt(b*b-a*c))/a;\n        if(temp < tmax && temp > tmin)\n        {\n            rec.t = temp;\n            rec.p = pointAtParameter(r,rec.t);\n            rec.normal = (rec.p - s.center) / s.radius;\n            rec.mat = s.mat;\n            rec.color = s.color;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit(in ray r, float tmin, float tmax, inout hitRecord rec, hitableList list)\n{\n    hitRecord tempRec;\n    bool hitAny = false;\n    float closestSoFar = tmax;\n    for(int i = 0; i < list.size; i++)\n    {\n        if(hitSphere(r,tmin, closestSoFar,tempRec, list.sList[i]))\n        {\n            hitAny = true;\n            closestSoFar = tempRec.t;\n            rec = tempRec;\n        }\n    }\n    return hitAny;\n}\n\nray getRay(float u, float v, camera cam) { return ray(cam.o,cam.llc + u*cam.h + v*cam.v); }\n\nfloat random (vec2 st) {\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(st.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec3 randInUnitSphere(vec2 st) {\n    float phi = random(st.yx) * 2.0 * 3.14159265;\n    float theta = random(st.xy) * 3.14169265;\n    \n    return vec3(cos(phi) * sin(theta), cos(theta), sin(phi) * sin(theta));\n}\n\nbool checkRefract(vec3 v, vec3 n, float niOverNt)\n{\n    vec3 uv = v;\n    float dt = dot(uv, n);\n    float discriminant = 1.0 - niOverNt * niOverNt * (1.-dt*dt);\n    if (discriminant > 0.)\n    {\n        return true;\n    }\n    return false;\n}\n\nfloat schlick(float cosine, float refIdx)\n{\n    float r0 = (1.-refIdx)/(1.+refIdx);\n    r0 = r0*r0;\n    return r0 + (1.-r0) * pow((1. - cosine),5.);\n}\n              \nvec3 color(ray r, hitableList list, vec2 st)\n{\n    hitRecord rec;\n    vec3 unitDirection;\n    float t;\n    \n    vec3 att = vec3(1.);\n    \n    int bounceSize = MAX_BOUNCE;\n    int bounce = 0;\n    \n    while(hit(r, 0.001, FLT_MAX, rec, list) && bounce < bounceSize)\n    {\n        unitDirection = normalize(direction(r));\n        if(rec.mat == 0)\n        {\n            vec3 target = rec.p + rec.normal + randInUnitSphere(st);\n            r = ray(rec.p, target-rec.p);\n            att *= rec.color;\n        }\n        if(rec.mat == 1)\n        {\n            float globalFuzz = 0.;// change to 0 for full reflection\n            vec3 reflected =reflect(unitDirection, rec.normal);\n            r = ray(rec.p, reflected + globalFuzz*randInUnitSphere(st));\n            att *= rec.color; // if  att *= rec.color * 50; then the shpere become a light source o_O\n        }\n        if(rec.mat == 2)\n        {\n            float refractiveIndex = 1.9;\n            vec3 outwardNormal;\n            vec3 reflected =reflect(unitDirection, rec.normal);\n            float niOverNt;\n            vec3 refracted;\n            \n            float refProb;\n            float cosine;\n            \n            if(dot(unitDirection, rec.normal) > 0.)\n            {\n                outwardNormal = -rec.normal;\n                niOverNt = refractiveIndex;\n                cosine = refractiveIndex * dot(direction(r), rec.normal) / length(direction(r));\n            }\n            else\n            {\n                outwardNormal = rec.normal;\n                niOverNt = 1.0 / refractiveIndex;\n                cosine = -dot(direction(r), rec.normal) / length(direction(r));\n            }\n            if(checkRefract(unitDirection, outwardNormal, niOverNt))\n            {\n                \n                refProb = schlick(cosine, refractiveIndex);\n            }\n            else\n            {\n                refProb = 1.0;\n            }\n            \n            if(random(vec2(iTime) + vec2(iFrame)) > refProb)\n            {   \n            r = ray(rec.p, refract(unitDirection, outwardNormal,niOverNt));\n        \t}\n            else\n            {\n                r = ray(rec.p, reflected);\n            }\n            \n            //vec3 refracted = refract(unitDirection, rec.normal, 1.0 / refractiveIndex);\n        }\n        bounce++;\n    }\n    \n    unitDirection = normalize(direction(r));\n    t =  (unitDirection.y + 1.);\n    return att * (t*vec3(0.6,0.8,1.)*texture( iChannel1, unitDirection ).xyz);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    camera cam;\n    cam.llc = vec3(-2.,-1.,-1.);\n    cam.h = vec3(4.,0.,0.);\n    cam.v = vec3(0.,2.25,0.);\n    cam.o = vec3(0.);\n    \n    hitableList list;\n    list.size = 5;\n    list.sList = sphere[5](\n        sphere(vec3(0.,0.,-1.5),0.5,0,vec3(0.8,0.3,0.3)),\n        sphere(vec3(-1.,.0,-1.5),0.5,1,vec3(0.8,0.8,0.8)),\n        sphere(vec3(1.0,.0,-1.5),0.5,2,vec3(0.8,0.6,0.2)),\n        sphere(vec3(0.,-100.5,-1.),100.,0,vec3(0.8,0.8,0.0)),\n        sphere(vec3(0.,0.5,-10.),5.,1,vec3(0.8,0.6,0.2))\n    );\n    \n    vec2 aa = vec2(random(st + vec2(iFrame))) / iResolution.xy;\n\n    ray r = getRay(st.x + aa.x, st.y + aa.y, cam);\n    \n    //multipass code\n    vec3 col = texture(iChannel0, st).rgb * float(iFrame);;\n \tcol += color(r,list,st + iTime);\n    fragColor = fragColor = vec4(col/float(iFrame + 1), 1.);\n}", "buffer_a_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lG3D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 212]], "test": "untested"}
{"id": "ttK3WV", "name": "deferred — sat.sketch #7", "author": "szczm_", "description": "More of a technical sketch. deferred rendering, shadow mapping, nice bloom, flat look.\n\nMore info in the shader since this description is length restricted ( . _.)", "tags": ["flat", "shadow", "bloom", "mapping", "tonemapping", "grading", "debug", "lowpoly", "aesthetic", "look", "nice", "comment", "aces", "ortographic", "deferred"], "likes": 10, "viewed": 722, "published": 3, "date": "1579982264", "time_retrieved": "2024-07-30T21:28:51.447895", "image_code": "// Uncomment below line for fun debug view~\n\n// #define DEBUG_VIEW\n\n// Debug view, starting from top-left, going clockwise:\n//\n// G-buffer, normal vectors, shininess, roughness, albedo, depth, shadow buffer, projected light\n// space point, sampled shadow, final shadow, final render before post-process,\n// extracted bright features for bloom\n\n\n/******************************************************************************************\n\n deferred — saturday sketch #7\n  — Matthias Scherba (@szczm_)\n\n\n This is more of a technical sketch. It includes:\n - deferred rendering, with different materials (yes I tried thousands of lights,\n   yes, it was satisfying, no, it didn't look good, shush)\n - approximated ACES tonemaping (credits go to Krzysztof Narkowicz)\n - a shadow mapped directional light\n - \"flat\" look (achieved by quantization of the normal)\n - proper bloom\n - nice color \"grading\"\n\n Some might say a few of these are unnecessarily redundant for ShaderToy. Yes, I know. (: :) (:\n\n The code is spread out between tabs for two reasons:\n  - to declutter the common tab, and\n  - to ensure separation between different stages of rendering\n\n As the shadow resolution depends on the buffer resolution, which depends on\n the viewport resolution, be sure to go fullscreen!\n\n\n I tried to comment the code nicely, but if you have any questions, leave a comment\n or hit me up on Twitter:\n\n twitter.com/szczm_\n\n\n FUTURE TO-DO MAYBE WHO KNOWS:\n - investigate occasional shadow clipping at some angles (weird shadow buffer bias?)\n - minor buffer artifacts/fireflies?\n\n******************************************************************************************/\n\n// Image tab: Apply final post processing and tone mapping.\n\n\n#define LIT_BUFFER (iChannel0)\n#define BLOOM_BUFFER (iChannel1)\n#define SHADOW_BUFFER (iChannel2)\n#define G_BUFFER (iChannel3)\n\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894 * exp(-0.5*x*x / (sigma*sigma)) / sigma;\n}\n\n// Credits: Krzysztof Narkowicz\nvec3 acesApprox(vec3 v)\n{\n    v *= 0.6f;\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    time = iTime;\n    \n    vec2 coords = fragCoord / iResolution.xy;\n    \n#if defined(DEBUG_VIEW)\n    coords = coords * 2.0 - 0.5;\n#endif\n    \n    fragColor = texture(LIT_BUFFER, coords);\n    \n    vec3 bloom = vec3(0.0);\n    \n    const float SIGMA = 3.0;\n    const float STRETCH = 2.5;\n    const float LOD = 3.0;\n    \n    const int KERNEL_WIDTH = 10;\n    const int KERNEL_HEIGHT = KERNEL_WIDTH / 2;\n    \n    const float BLOOM_INTENSITY = 0.015;\n    \n    \n    // Calculate bloom\n    for (int x = -KERNEL_WIDTH; x <= KERNEL_WIDTH; x++)\n    {\n        float xx = float(x) / float(KERNEL_WIDTH);\n        xx = normpdf(xx, SIGMA);\n        \n        for (int y = -KERNEL_HEIGHT; y <= KERNEL_HEIGHT; y++)\n        {\n            float yy = float(y) / float(KERNEL_HEIGHT);\n            yy = normpdf(yy, SIGMA);\n            \n            bloom += textureLod(BLOOM_BUFFER, coords + vec2(float(x), float(y)) / iResolution.xy * STRETCH, LOD).rgb * xx * yy;\n        }\n    }\n    \n    // Color correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.5, 1.5, 0.6));\n    \n    // Tonemapping\n    fragColor.rgb = acesApprox(fragColor.rgb);\n    \n    // Apply PS2 era bloom\n    fragColor.rgb += bloom * BLOOM_INTENSITY;\n    \n    // Vi~gnet~te\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 1.0, 0.5) * 0.4, 1.3 * pow(length(coords - 0.5), 3.0));\n\n    \n// Beware, traveler! Below be Ugly Debug Dragons!\n    \n#if defined(DEBUG_VIEW)\n    vec2 debugCoords = mod(coords * 2.0, vec2(1.0));\n\n    vec4 g_buffer = texture(G_BUFFER, debugCoords);\n    vec3 bloom_buffer = texture(BLOOM_BUFFER, debugCoords).rgb;\n    vec3 shadow_buffer = texture(SHADOW_BUFFER, debugCoords).rgb;\n\n    vec3 viewDir = rayDirection(iResolution.xy, debugCoords * iResolution.xy);\n    \n    vec3 eye = getEye();\n    mat4 viewToWorld = viewMatrix(eye, CAMERA_TARGET, UP);\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n        \n    float depth;\n    vec3 normal;\n    Material material;\n    \n    unpackGbuffer(g_buffer, depth, normal, material);\n    \n\n    vec3 position = eye + depth * worldDir;\n    \n\n    float lightDist;\n\tvec3 lightPoint = worldPointToLightPoint(position, lightDist);\n    \n    float shadowDist;\n    unpackShadow(texture(SHADOW_BUFFER, lightPoint.xy), shadowDist);\n    \n    float shadow = shadowDist - lightDist;\n    shadow = step(0.0, shadow);\n\n    if (clamp(lightPoint.x, 0.0, 1.0) != lightPoint.x\n     || clamp(lightPoint.y, 0.0, 1.0) != lightPoint.y\n     || shadowDist >= MAX_DIST_SHADOW - 1.0) // _why_\n        shadow = 1.0;\n    \n    \n    \n    vec3 debugLeft = texture(LIT_BUFFER, debugCoords).rgb;\n    debugLeft = mix(debugLeft, bloom_buffer, step(0.5, coords.y));\n    \n    vec3 debugRight = g_buffer.aaa;\n    debugRight = mix(debugRight, material.albedo, step(0.5, coords.y));\n    \n    vec3 debugBottom = vec3(shadow);\n    debugBottom = mix(debugBottom, vec3(shadowDist) / MAX_DIST_SHADOW, step(0.0, coords.x));\n    debugBottom = mix(debugBottom, lightPoint, step(0.5, coords.x));\n    debugBottom = mix(debugBottom, shadow_buffer, step(1.0, coords.x));\n    \n    vec3 debugTop = g_buffer.rgb;\n    debugTop = mix(debugTop, 0.5 + 0.5 * normal, step(0.0, coords.x));\n    debugTop = mix(debugTop, vec3(material.shininess), step(0.5, coords.x));\n    debugTop = mix(debugTop, vec3(material.roughness / MAX_ROUGHNESS), step(1.0, coords.x));\n    \n    \n    fragColor.rgb = mix(fragColor.rgb, debugLeft, step(0.0, -coords.x));\n    fragColor.rgb = mix(fragColor.rgb, debugRight, step(1.0, coords.x));\n    fragColor.rgb = mix(fragColor.rgb, debugBottom, step(-0.0, -coords.y));\n    fragColor.rgb = mix(fragColor.rgb, debugTop, step(1.0, coords.y));\n\n    return;\n#endif\n}\n\n#undef LIT_BUFFER\n#undef BLOOM_BUFFER\n#undef G_BUFFER\n#undef SHADOW_BUFFER", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A: Render the G buffer.\n\n// This tab has knowledge of materials, no other tab does.\n\n\nMaterial materials[4] = Material[]\n(\n    //            albedo        // shininess // roughness\n    Material(vec3(0.5),                  0.0,         0.0), // plane\n    Material(vec3(0.5, 0.25, 0.5),       0.3,        60.0), // sphere\n    Material(vec3(0.6, 0.4, 0.15),       0.5,        20.0), // torus\n    Material(vec3(0.25, 0.5, 0.6),       0.2,         8.0)  // capsule\n);\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).dist - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    time = iTime;\n    \n\tvec3 viewDir = rayDirection(iResolution.xy, fragCoord);\n    \n    vec3 eye = getEye();\n    mat4 viewToWorld = viewMatrix(eye, CAMERA_TARGET, UP);\n    vec3 worldDir = (viewToWorld * viewDir.xyzz).xyz;\n    \n    Hit hit = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n\n    Material material;\n        \n    if (hit.id > 0)\n    {    \n        vec3 normal = normal(eye + hit.dist * worldDir);\n        Material material = materials[hit.id - 1];\n        \n\t\tpackGbuffer(fragColor, hit.dist, normal, material);\n    }\n\n}", "buffer_a_inputs": [], "common_code": "precision highp float;\n\n\n// Constants\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\n\nconst int MAX_STEPS = 200;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 30.0;\nconst float EPSILON = 1e-4;\n\nconst float MIN_DIST_SHADOW = 0.0;\nconst float MAX_DIST_SHADOW = 5.5;\n\nconst vec3 CAMERA_TARGET = vec3(0.0, -0.8, 0.0);\nconst float CAMERA_FOV = 90.0;\n\nconst vec3 LIGHT_CAMERA_TARGET = vec3(0.0, -0.5, 0.0);\nconst float LIGHT_CAMERA_SIZE = 2.3;\n\nconst float MAX_ROUGHNESS = 60.0;\n\n\n// Need to set time in buffers - iTime is undefined in the Common tab\nfloat time;\n\n\n// Distance functions\n\nfloat torusSDF(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat sphereSDF(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat planeSDF(vec3 p, vec3 n)\n{\n    return length(p) * dot(normalize(p), n);\n}\n\nfloat capsuleSDF(vec3 p, float h, float r)\n{\n\tp.y -= clamp(p.y, 0.0, h);\n\treturn length(p) - r;\n}\n\n\n// Gotta fix those for my drivers\n#define TAU 6.28318530718\nfloat sinf(float arg) { return sin(mod(arg, TAU)); }\nfloat cosf(float arg) { return cos(mod(arg, TAU)); }\n\n\n// Rotations\n\nvec3 rotX(vec3 p, float angle) {\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cosf(angle), -sinf(angle)),\n        vec3(1.0, sinf(angle), cosf(angle))\n    ) * p;\n}\n      \nvec3 rotY(vec3 p, float angle) {\n    return mat3(\n        vec3(cosf(angle), 0.0, sinf(angle)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sinf(angle), 0.0, cosf(angle))\n    ) * p;\n}\n      \nvec3 rotZ(vec3 p, float angle) {\n    return mat3(\n        vec3(cosf(angle), -sinf(angle), 0.0),\n        vec3(sinf(angle), cosf(angle), 0.0),\n        vec3(1.0, 0.0, 1.0)\n    ) * p;\n}\n\n\n// Structs\n\nstruct Material\n{\n    vec3 albedo;\n    float shininess;\n    float roughness;\n};\n\nstruct Hit\n{\n    float dist;\n    int id;\n};\n    \n\n// Tracing stuff\n    \nHit minHit(Hit a, Hit b)\n{\n    if (a.dist < b.dist)\n        return a;\n    \n    return b;\n}\n\nHit sceneSDF(vec3 p)\n{\n    p -= vec3(-0.3, -0.2, 0.2);\n    Hit scene = Hit(planeSDF(p + vec3(1.5), vec3(0.0, 1.0, 0.0)), 1);\n    \n    scene = minHit(scene, Hit(sphereSDF(p - vec3(-0.5, 0.2, 0.0), 0.7), 2));\n    scene = minHit(scene, Hit(torusSDF(p - vec3(0.5, -0.4, 1.1), vec2(0.45, 0.3)), 3));\n    scene = minHit(scene, Hit(capsuleSDF(p - vec3(1.1, -0.2, -0.7), 0.7, 0.5), 4));\n    \n    return scene;\n}\n\nHit shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    Hit finalHit = Hit(start, -1);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        Hit hit = sceneSDF(eye + finalHit.dist * marchingDirection);\n        \n        finalHit.dist += hit.dist;\n        finalHit.id = hit.id;\n        \n        if (hit.dist < EPSILON) {\n\t\t\tbreak;\n        }\n        \n        if (finalHit.dist >= end) {\n            finalHit = Hit(end, -1);\n            break;\n        }\n    }\n    \n    return finalHit;\n}\n\nvec3 getEye()\n{\n    return rotY(vec3(2.0, 2.0, 3.0), -time * 0.1);\n}\n\n\n// Math stuff\n\n// vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\nvec3 rayDirection(vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(CAMERA_FOV) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n// Light stuff\n\nvec3 lightPosition()\n{\n    vec3 dir = vec3(0.0, 2.0, 0.0);\n    \n    dir = rotX(dir, -0.15 * TAU);\n    dir = rotY(dir, time * 0.1 * TAU);\n    \n    return dir;\n}\n\n// This is a directional light - the direction is always the same\nvec3 lightDirection()\n{\n    return -normalize(lightPosition());\n}\n\nvec3 lightColor()\n{\n    return vec3(1.0, 0.9, 0.75) * 3.9;\n}\n\nmat4 lightToWorldMatrix()\n{\n    return viewMatrix(lightPosition(), LIGHT_CAMERA_TARGET, UP);\n}\n\nvec3 worldPointToLightPoint(vec3 worldPoint, out float lightDist)\n{\n    vec3 lightDir = lightDirection();\n    vec3 lightPos = lightPosition();\n    \n    // Plane SDF allows easy distance calculation to ortographic plane.\n    // -lightPos = lightDir * length(lightPos)\n    lightDist = planeSDF(worldPoint, -lightPos);\n\n    mat4 worldToLight = inverse(lightToWorldMatrix());\n    \n    vec3 lightPoint = worldPoint + lightDist * lightDir;\n\tlightPoint = (worldToLight * vec4(lightPoint, 0.0)).xyz;\n    lightPoint = (lightPoint + LIGHT_CAMERA_SIZE) / (2.0 * LIGHT_CAMERA_SIZE);\n    \n    return lightPoint;\n}\n\n\n// Packing/encoding functions\n\nfloat map(in float val, in float startIn, in float endIn, in float startOut, in float endOut)\n{\n    float norm = (val - startIn) / (endIn - startIn);\n    return norm * (endOut - startOut) + startOut;\n}\n\nvec3 quantize(vec3 value, float steps)\n{\n    return floor(value * steps) / steps;\n}\n\nfloat packVec3(vec3 vec, float steps)\n{\n    vec3 quantized = quantize(vec, steps);\n    \n    float x = quantized.x * steps * steps;\n    float y = quantized.y * steps;\n    float z = quantized.z;\n    \n    return (x + y + z) / (steps * steps);\n}\n\nvec3 unpackVec3(float packed, float steps)\n{\n    vec3 vec = vec3(0.0);\n    \n    vec.x = fract(packed);\n    vec.y = fract(packed * steps);\n    vec.z = fract(packed * steps * steps);\n    \n    return vec;\n}\n\nvoid packGbuffer(out vec4 packed, in float depth, in vec3 normal, in Material material)\n{\n    packed = vec4(0.0);\n    \n    // values equal to 1.0 are clipped, so have to lower them a bit\n    packed.r = packVec3(normal * 0.49 + 0.49, 16.0);\n    packed.g = packVec3(material.albedo * 0.999, 256.0);\n    packed.b = packVec3(vec3(material.shininess, material.roughness / MAX_ROUGHNESS, 0.0) * 0.999, 100.0);\n    packed.a = map(depth, MIN_DIST, MAX_DIST, 0.0, 1.0);\n}\n\nvoid unpackGbuffer(in vec4 packed, out float depth, out vec3 normal, out Material material)\n{\n    vec3 matParams = unpackVec3(packed.b, 100.0);\n    \n    depth = map(packed.a, 0.0, 1.0, MIN_DIST, MAX_DIST);\n    normal = 2.0 * unpackVec3(packed.r, 16.0) - 1.0;\n\n    material.shininess = matParams.r;\n    material.roughness = matParams.g * MAX_ROUGHNESS;\n    material.albedo = unpackVec3(packed.g, 256.0);\n}\n\nvoid packShadow(out vec4 packed, in float depth)\n{\n    packed = vec4(map(depth, MIN_DIST_SHADOW, MAX_DIST_SHADOW, 0.0, 1.0));\n}\n\nvoid unpackShadow(in vec4 packed, out float depth)\n{\n    depth = map(packed.r, 0.0, 1.0, MIN_DIST_SHADOW, MAX_DIST_SHADOW);\n}", "buffer_b_code": "// Buffer B: Render the shadow buffer.\n\n// This is an ortographic camera oriented around the center.\n// Parameters chosen for best quality.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    \n    vec2 coord = (-1.0 + 2.0 * fragCoord / iResolution.xy) * LIGHT_CAMERA_SIZE;\n    \n    vec3 eye = lightPosition();\n    vec3 viewDir = vec3(0.0, 0.0, -1.0);\n    \n    mat4 lightToWorld = lightToWorldMatrix();\n    \n    // Ortographic projection\n    eye += (lightToWorld * vec4(coord.x, coord.y, 0.0, 0.0)).xyz;\n    \n    vec3 worldDir = (lightToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    Hit hit = shortestDistanceToSurface(eye, worldDir, MIN_DIST_SHADOW, MAX_DIST_SHADOW);\n\n    packShadow(fragColor, hit.dist);\n}", "buffer_b_inputs": [], "buffer_c_code": "// Buffer C: Render the actual scene.\n\n// This tab knows how to light the scene, no other tab does.\n// No post processing here.\n\n\n#define G_BUFFER (iChannel0)\n#define SHADOW_BUFFER (iChannel1)\n\nvec3 lighting(in vec3 position, in vec3 normal, in vec3 viewDir, in Material material, in float shadow)\n{\n    vec3 lightDir = lightDirection();\n    vec3 lightCol = lightColor();\n    \n    // Specular\n    float ndoth = dot(normal, normalize(-viewDir - lightDir));\n    float specularBlinnPhong = pow(max(ndoth, 0.0), material.roughness);\n    \n    // Diffuse\n    float ndotl = dot(normal, -lightDir);\n    float diffuseLambert = max(0.0, ndotl);\n    \n    // Final terms\n    float ambient = 0.4;\n    float diffuse = diffuseLambert * shadow;\n    float specular = specularBlinnPhong * material.shininess * diffuse;\n    \n    return (ambient * material.albedo + (diffuse * material.albedo + specular))* lightCol;\n}\n\nfloat shadow(in vec3 position)\n{\n    float lightDist;\n\tvec3 lightPoint = worldPointToLightPoint(position, lightDist);\n    \n    float shadowDist;\n    unpackShadow(texture(SHADOW_BUFFER, lightPoint.xy), shadowDist);\n    \n    // Shadow mapping\n    float shadow = shadowDist - lightDist;\n    shadow = step(0.0, shadow);\n\n    if (clamp(lightPoint.x, 0.0, 1.0) != lightPoint.x\n     || clamp(lightPoint.y, 0.0, 1.0) != lightPoint.y\n     || shadowDist >= MAX_DIST_SHADOW - 1.0)\n        shadow = 1.0;\n    \n    return shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    time = iTime;\n\n    vec3 viewDir = rayDirection(iResolution.xy, fragCoord);\n    \n    vec3 eye = getEye();\n    mat4 viewToWorld = viewMatrix(eye, CAMERA_TARGET, UP);\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n        \n    \n    float depth;\n    vec3 normal;\n    Material material;\n    \n    unpackGbuffer(texture(G_BUFFER, fragCoord / iResolution.xy), depth, normal, material);\n    \n\n    vec3 position = eye + depth * worldDir;\n    \n    float shadow = shadow(position);\n    \n    fragColor.rgb = lighting(position, normal, worldDir, material, shadow);\n    fragColor.a = 1.0;\n}\n\n#undef G_BUFFER\n#undef SHADOW_BUFFER", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Buffer D: Extract bright features.\n\n\n#define LIT_BUFFER (iChannel0)\n\nfloat luminance(vec3 col)\n{\n    return dot(col, vec3(0.299, 0.587, 0.114));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    \n    fragColor.rgb = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    float luma = luminance(fragColor.rgb);\n   \n    const float bloom_min_threshold = 2.0;\n    const float bloom_max_threshold = 2.5;\n    \n    fragColor.rgb = mix(vec3(0.0), fragColor.rgb, smoothstep(bloom_min_threshold, bloom_max_threshold, luma));\n}\n\n#undef LIT_BUFFER", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttK3WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1853, 1853, 1896, 1896, 1955], [1957, 1989, 2014, 2014, 2193], [2195, 2195, 2252, 2252, 5889]], "test": "untested"}
{"id": "WlyGW3", "name": "2D section of rotating torus", "author": "hiogawa", "description": "I wasn't sure how to obtain distance on 2d section, but it seems okay to just use usual 3d distance.\nThis only leads to under-estimation, so, for example, when torus is tilted, there is more blur to it.", "tags": ["2d", "torus"], "likes": 4, "viewed": 348, "published": 3, "date": "1579979581", "time_retrieved": "2024-07-30T21:28:52.253740", "image_code": "//\n// 2D Section of Rotating Torus\n//\n\n#define M_PI 3.14159\n\nfloat AA = 2.0;\nfloat SCALE_TIME = 0.6;\nvec2  UV_CENTER = vec2(0.0, 0.0);\nfloat UV_HEIGHT = 3.2;\n\nfloat TORUS_R1 = 1.0;\nfloat TORUS_R2 = 0.35;\nvec3  TORUS_ROT_VELOCITY = vec3(M_PI, 0.0, M_PI * 2.5 / 2.0);\nvec4  TORUS_COLOR = vec4(vec3(0.95, 1.0, 1.0), 0.8);\n\nfloat CHECKER_SCALE = 1.0;\nvec3  CHECKER_COLOR0 = vec3(0.1);\nvec3  CHECKER_COLOR1 = vec3(0.2);\n\n\n// Torus boundary given by\n//   q(u, v) = R_{z, u} (r1 e1 + R_{y, v} (r2 e1))\nfloat signedDistanceToTorus(vec3 p, float r1, float r2) {\n  return length(vec2(length(p.xy) - r1, p.z)) - r2;\n}\n\nfloat signedDistanceToChecker(vec2 uv, float scale) {\n  uv *= scale;\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float dist = min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n  dist /= scale;\n  bool is_even_spot = mod(uvi.x + uvi.y, 2.0) == 0.0;\n  return is_even_spot ? -dist : dist;\n}\n\nmat2 rot2(float t) {\n  return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nmat4 rotationTransform(vec3 r) {\n  mat2 x = rot2(r.x);\n  mat2 y = rot2(r.y);\n  mat2 z = rot2(r.z);\n  mat3 X = mat3(\n      1.0,     0.0,     0.0,\n      0.0, x[0][0], x[0][1],\n      0.0, x[1][0], x[1][1]);\n  mat3 Y = mat3(\n    y[1][1],   0.0, y[0][1],\n        0.0,   1.0,     0.0,\n    y[1][0],   0.0, y[0][0]);\n  mat3 Z = mat3(\n    z[0][0], z[0][1],   0.0,\n    z[1][0], z[1][1],   0.0,\n        0.0,     0.0,   1.0);\n  mat4 R = mat4(Z * Y * X);\n  return R;\n}\n\n// [0, W] x [0, H]  <-->  [c.x - A, c.x + A] x [c.y - B, c.y + B]\n// where AR = W / H\n//       A = AR * height / 2\n//       B = height / 2\nmat3 invViewTransform(vec2 center, float height) {\n  vec2 Res = iResolution.xy;\n  vec2 size = vec2(height * Res.x / Res.y, height);\n  vec2 a = center - size / 2.0;\n  float Sy = height / Res.y;\n  mat3 xform = mat3(\n       Sy,   0,   0,\n        0,  Sy,   0,\n      a.x, a.y, 1.0);\n  return xform;\n}\n\n// Anti aliasing\nfloat smoothBoundaryCoverage(float signed_distance, float boundary_width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / boundary_width + 0.5);\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  mat3 inv_view_xform = invViewTransform(UV_CENTER, UV_HEIGHT);\n  float inv_view_scale = inv_view_xform[0][0];\n  vec2 uv =  vec2(inv_view_xform * vec3(frag_coord, 1.0));\n  float t = SCALE_TIME * iTime;\n\n  vec3 color;\n  {\n    // Checker\n    float sd = signedDistanceToChecker(uv, CHECKER_SCALE);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(CHECKER_COLOR0, CHECKER_COLOR1, coverage);\n  }\n  {\n    // Animating Torus\n    mat4 torus_xform = rotationTransform(TORUS_ROT_VELOCITY * t);\n\n    // Approximate 2D section distance as 3D distance\n    //   this approximation under-estimates distance on 2d section\n    //   when 3d closest point's normal is not orthogonal to 2d section.\n    //   For example, there will be too much AA blur when torus is tilted.\n    vec3 p = vec3(uv, 0.0);\n    vec3 p_in_torus = vec3(inverse(torus_xform) * vec4(p, 1.0));\n    float sd = signedDistanceToTorus(p_in_torus, TORUS_R1, TORUS_R2);\n\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(color, TORUS_COLOR.xyz, TORUS_COLOR.w * coverage);\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 495, 552, 552, 606], [608, 608, 661, 661, 904], [906, 906, 926, 926, 976], [978, 978, 1010, 1010, 1433], [1435, 1574, 1624, 1624, 1869], [1871, 1888, 1963, 1963, 2042], [2060, 2060, 2114, 2114, 3246]], "test": "untested"}
{"id": "3lyGRd", "name": "Republic of India Flag", "author": "piyushslayer", "description": "Couldn't really find any accurate depictions of the Indian flag here, so decided to lazily doodle one myself for this year's Republic day.", "tags": ["flag"], "likes": 33, "viewed": 3934, "published": 3, "date": "1579974383", "time_retrieved": "2024-07-30T21:28:53.061580", "image_code": "/**\n A very lazy and quick doodle of the Indian flag on this year's Indian Republic Day.\n Not the most efficient code, but I think it still looks cool. \n*/\n\n#define PI 3.1415926535\n\n#define ROT(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n\n#define ORANGE vec3(255., 154., 48.) / 255.\n#define GREEN vec3(9., 137, 1.) / 255.\n#define NAVY_BLUE vec3(0., 0., 137.) / 255.\n\n#define RADIUS .7\n#define HALF_RADIUS RADIUS * .5\n\n// Hash by Dave_Hoskins\nfloat hash(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) / float(0xffffffffU);\n}\n\n// iq's 2d sdf for iscosceles triangles (https://www.shadertoy.com/view/MldcD7)\nfloat isoscelesTriangle(in vec2 q, in vec2 p)\n{\n    p.y -= .5;\n    p.x = abs(p.x);\n    \n\tvec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0., 1.);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0., 1.), 1.);\n    \n    float s = -sign(q.y);\n\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n                  vec2(dot(b, b), s * (p.y - q.y)));\n\n\treturn -sqrt(d.x) * sign(d.y);\n}\n\n// Probably not the best way to model the chakra, would have used the abs\n// mirroring technique to efficiently draw it, but since it's a lazy and quick\n// doodle so I said whatever, it doesn't matter either way.\nfloat getChakra(vec2 uv)\n{\n\tfloat outerCircle = smoothstep(.01, -.01, abs(length(uv) - RADIUS - .22) - .06);\n    float innerCircle = smoothstep(.22, .20, length(uv));\n    float spokes = 0., spokeThickness = .03, notches = 0., theta = 2. * PI / 24.;\n    for (int i = 0; i < 24; ++i)\n    {\n        vec2 suv = ROT(float(i) * theta) * uv;\n        // shorter inward pointing triangle\n        suv.y += HALF_RADIUS;\n        spokes += smoothstep(.015, -.015,\n\t\t\t\t\tisoscelesTriangle(vec2(spokeThickness, RADIUS * .334), suv));\n        // longer outward pointing triangle\n        suv.y -= RADIUS + .0025;\n        spokes += smoothstep(.015, -.015,\n\t\t\t\t\tisoscelesTriangle(vec2(spokeThickness, -RADIUS * .666), suv));\n        \n        // boundary notches\n\t\tvec2 nuv = ROT(float(i) * theta + theta * .5) * uv;\n        nuv.y -= RADIUS + .16;\n        notches += smoothstep(.04, .032, length(nuv));\n    }\n    \n    float chakra = notches + innerCircle + outerCircle + spokes;\n    return clamp(chakra, 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 st = fragCoord / iResolution.xy;\n\tfloat w = sin((uv.x + uv.y - iTime * .75 + sin(1.5 * uv.x + 4.5 * uv.y) * PI * .3)\n                  * PI * .6); // fake waviness factor\n    \n    uv *= 1. + (.036 - .036 * w);\n    vec3 col = vec3(0.);\n    \n    // flag colors\n    col += 1.;\n    col = mix(col, ORANGE, smoothstep(.35, .36, uv.y));\n    col = mix(col, GREEN, smoothstep(-.35, -.36, uv.y));\n    col = mix(col, NAVY_BLUE, getChakra(uv * 3.2));\n    col += w * .225;\n    \n    float v = 16. * st.x * (1. - st.x) * st.y * (1. - st.y); // vignette\n\tcol *= 1. - .6 * exp2(-1.75 * v);\n    col = clamp(col - hash(fragCoord) * .004, 0., 1.);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[415, 439, 459, 459, 599], [601, 681, 728, 728, 1064], [1066, 1279, 1305, 1305, 2272], [2275, 2275, 2332, 2332, 3087]], "test": "untested"}
{"id": "ttVGDV", "name": "Wang, Jenkins & Other Hashes", "author": "mla", "description": "Comparison of Wang hash & others for pairs - the Wang hash has some artefacts, but a little extra mixing improves things.\n\n[url]https://burtleburtle.net/bob/hash/integer.html[/url]\n[url]https://www.shadertoy.com/view/wlVGWK[/url]", "tags": ["hash", "wang", "integer", "jenkins", "murmur"], "likes": 18, "viewed": 2832, "published": 3, "date": "1579971245", "time_retrieved": "2024-07-30T21:28:53.961175", "image_code": "int N = 1; // Number of iterations, N = 1000 for benchmark\n#define HASH wellons3\n//#define HASH jenkins\n//#define HASH murmur\n//#define HASH wellons\n//#define HASH wellons3\n\n//Wang\nuint wang(uint a) {\n\ta = (a ^ 61U) ^ (a >> 16U);\n\ta = a * 9U;\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2dU;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\n// Jenkins\nuint jenkins(uint a) {\n    a -= (a<<6);\n    a ^= (a>>17);\n    a -= (a<<9);\n    a ^= (a<<4);\n    a -= (a<<3);\n    a ^= (a<<10);\n    a ^= (a>>15);\n    return a;\n}\n\n// MurmurHash3 finalizer\nuint murmur(uint x) {\n    x ^= x >> 16;\n    x *= 0x85ebca6bU;\n    x ^= x >> 13;\n    x *= 0xc2b2ae35U;\n    x ^= x >> 16;\n    return x;\n}\n\n// Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint wellons(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// Chris Wellons 3-round function\n// bias: 0.020888578919738908 = minimal theoretic limit\nuint wellons3(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nfloat hashtest(uint a) {\n    uint hash = a;\n    for (int i = 0; i < N; i++) {\n    \thash = HASH(hash);\n    }\n    return float(hash) / float(0xFFFFFFFFU); // Uniform in [0,1]\n}\n\nvec4 rand4(uint seed){\n    return vec4(hashtest(seed^0x34F85A93U),\n                hashtest(seed^0x85FB93D5U),\n                hashtest(seed^0x6253DF84U),\n                hashtest(seed^0x25FC3625U));\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 uv = U-0.5*iResolution.xy;\n    uint seed = uint(U.x) + (uint(U.y) << 11);\n    // Extra mixing improves Wang hash\n    if (iMouse.z > 0.0) seed *= 257U;\n    O = rand4(seed);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 181, 200, 200, 316], [318, 329, 351, 351, 489], [491, 516, 537, 537, 651], [653, 712, 734, 734, 848], [850, 940, 963, 963, 1117], [1119, 1119, 1143, 1143, 1293], [1295, 1295, 1317, 1317, 1496], [1498, 1498, 1536, 1536, 1719]], "test": "untested"}
{"id": "ttKGDK", "name": "Noise  isosurface", "author": "hiogawa", "description": "My first attempt to do somthing 3d-ish.", "tags": ["noise"], "likes": 2, "viewed": 331, "published": 3, "date": "1579950851", "time_retrieved": "2024-07-30T21:28:54.885703", "image_code": "//\n// - Thin isosurfaces of 3d noise as emission source\n// - Beer-Lambert model of absorption\n//\n\n#define M_PI 3.14159\n\nfloat SCALE_TIME = 0.15;\n\n// Emission source\nfloat NOISE_SCALE = 2.0;\nfloat NOISE_NUM_OCTAVES = 6.0;\nfloat ISOSURFACE_VALUE_HALF_WIDTH = 0.03;\nfloat NUM_ISOSURFACE_SIDES = 2.0;\n\n\n// Volume\nfloat VOLUME_DEPTH = 0.2;\nfloat VOLUME_NUM_SAMPLES = 6.0;\nfloat EMISSION_SCALE = 0.2;\nvec3 EMISSION_COLOR = vec3(0.0, 1.0, 1.0);\n\n\n//\n// Noise\n//\n\nfloat hash31(vec3 v) {\n  vec3 u = vec3(1234.5, 5432.1, 5678.9);\n  return fract(sin(dot(v, u) * 2357.0) * 56789.0);\n}\n\nfloat hash41(vec4 v) {\n  vec4 u = vec4(1234.5, 5432.1, 5678.9, 3456.7);\n  return fract(sin(dot(v, u) * 2357.0) * 56789.0);\n}\n\nvec2 hash32(vec3 v) {\n  return vec2(hash31(v), hash41(vec4(v, 1.0)));\n}\n\nvec3 hashGradient3(vec3 v) {\n  vec2 p = hash32(v);\n\n  // Usual spherical sampling\n  // Prob([0, theta] \\sub [0, pi]) = (1 - cos(theta)) / 2\n  float theta = acos(1.0 - 2.0 * p[0]);\n  float phi = 2.0 * M_PI * p[1];\n\n  return vec3(\n    sin(theta) * cos(phi),\n    sin(theta) * sin(phi),\n    cos(theta)\n  );\n}\n\nfloat mix2(float f00, float f10, float f01, float f11, vec2 uv) {\n  return mix(mix(f00, f10, uv[0]), mix(f01, f11, uv[0]), uv[1]);\n}\n\nfloat mix3(\n    float f000, float f100, float f010, float f110,\n    float f001, float f101, float f011, float f111,\n    vec3 v) {\n  float fxy0 = mix2(f000, f100, f010, f110, v.xy);\n  float fxy1 = mix2(f001, f101, f011, f111, v.xy);\n  return mix(fxy0, fxy1, v.z);\n}\n\nfloat gradientNoise3(vec3 v) {\n  vec3 vi = floor(v);\n  vec3 vf = v - vi;\n  float f000 = dot(hashGradient3(vi + vec3(0.0, 0.0, 0.0)), vf - vec3(0.0, 0.0, 0.0));\n  float f100 = dot(hashGradient3(vi + vec3(1.0, 0.0, 0.0)), vf - vec3(1.0, 0.0, 0.0));\n  float f010 = dot(hashGradient3(vi + vec3(0.0, 1.0, 0.0)), vf - vec3(0.0, 1.0, 0.0));\n  float f110 = dot(hashGradient3(vi + vec3(1.0, 1.0, 0.0)), vf - vec3(1.0, 1.0, 0.0));\n  float f001 = dot(hashGradient3(vi + vec3(0.0, 0.0, 1.0)), vf - vec3(0.0, 0.0, 1.0));\n  float f101 = dot(hashGradient3(vi + vec3(1.0, 0.0, 1.0)), vf - vec3(1.0, 0.0, 1.0));\n  float f011 = dot(hashGradient3(vi + vec3(0.0, 1.0, 1.0)), vf - vec3(0.0, 1.0, 1.0));\n  float f111 = dot(hashGradient3(vi + vec3(1.0, 1.0, 1.0)), vf - vec3(1.0, 1.0, 1.0));\n  vec3 vf_smooth = smoothstep(vec3(0.0), vec3(1.0), vf);\n  float t = mix3(f000, f100, f010, f110, f001, f101, f011, f111, vf_smooth);\n  // Normalize via upper/lower bound = +- 2 / sqrt(3) ~= 1.15\n  return (t / 1.15 + 1.0) * 0.5;\n}\n\nfloat noise(vec3 v, float n) {\n  float result = 0.0;\n  for (float i = 0.0; i < n; i++) {\n    float p = pow(2.0, i);\n    result += (gradientNoise3(v * p) / p);\n  }\n  result /= (pow(2.0, n) - 1.0) / (pow(2.0, n - 1.0));\n  return result;\n}\n\n//\n// Misc\n//\n\nfloat smoothBump(float fac, float bump, float half_width) {\n  return 1.0 - smoothstep(0.0, half_width, abs(fac - bump));\n}\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  vec2 uv =  frag_coord / iResolution.y;\n  float t = SCALE_TIME * iTime;\n\n  // Compute \"intensity\" by summing each layers\n  float fac_total = 0.0;\n  for (float i = 0.0; i < VOLUME_NUM_SAMPLES; i++) {\n    float z = i / VOLUME_NUM_SAMPLES * VOLUME_DEPTH;\n\n    // Noise\n    float fac_noise = noise(vec3(NOISE_SCALE * uv, z + t), NOISE_NUM_OCTAVES);\n    fac_noise = smoothstep(0.0, 1.0, fac_noise); // tonemap\n\n    // Pickup isosurfaces\n    float fac = 0.0;\n    fac += smoothBump(fac_noise, 0.5, ISOSURFACE_VALUE_HALF_WIDTH);\n    for (float j = 1.0; j <= NUM_ISOSURFACE_SIDES; j++) {\n      fac += smoothBump(fac_noise, 0.5 + 4.0 * j * ISOSURFACE_VALUE_HALF_WIDTH, ISOSURFACE_VALUE_HALF_WIDTH);\n      fac += smoothBump(fac_noise, 0.5 - 4.0 * j * ISOSURFACE_VALUE_HALF_WIDTH, ISOSURFACE_VALUE_HALF_WIDTH);\n    }\n\n    // Attenuate by depth\n    fac_total += exp(- z) * fac;\n  }\n\n\n  frag_color = vec4(fac_total * EMISSION_SCALE * EMISSION_COLOR, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKGDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[456, 456, 478, 478, 572], [574, 574, 596, 596, 698], [700, 700, 721, 721, 771], [773, 773, 801, 801, 1077], [1079, 1079, 1144, 1144, 1211], [1213, 1213, 1342, 1342, 1477], [1479, 1479, 1509, 1509, 2478], [2480, 2480, 2510, 2510, 2716], [2733, 2733, 2792, 2792, 2855], [2872, 2872, 2926, 2926, 3871]], "test": "untested"}
{"id": "wlVGWK", "name": "testing hash(x+2048y)", "author": "FabriceNeyret2", "description": "searching for source of bias in [url]https://www.shadertoy.com/view/3ty3Dy[/url]\nIhash( x + y*2048) do shows patterns !\nOne has to use a prime number, or at least not a power of 2 !  ( mouse click: using 2141 )", "tags": ["test", "hash", "rand"], "likes": 3, "viewed": 540, "published": 3, "date": "1579946452", "time_retrieved": "2024-07-30T21:28:55.633703", "image_code": "int IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\n#define Hash(a) ( float(IHash(a)) / float(0x7FFFFFFF) ) // Uniform in [0,1]\n\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    int k = iMouse.z <= 0. ? 2048 : 2141;    // NB: 2141 is prime\n    O = rand4(int(U.x)+int(U.y)*k);          // just for color\n  //O = vec4( Hash(int(U.x)+int(U.y)*k) );   // direct B&W from Hash() is as good\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 136], [215, 215, 236, 236, 395], [397, 397, 435, 435, 648]], "test": "untested"}
{"id": "tdXSR7", "name": "Multipleye", "author": "polymonster", "description": "Based on my friends concept art for a game.", "tags": ["eye"], "likes": 2, "viewed": 304, "published": 3, "date": "1579945913", "time_retrieved": "2024-07-30T21:28:56.551250", "image_code": "float pi = 3.14159265358979323846264;\n\nvec3 _00 = vec3(252.0, 64.0, 136.0) / 255.0;\nvec3 _01 = vec3(255.0, 237.0, 12.0) / 255.0;\nvec3 _02 = vec3(151.0, 25.0, 121.0) / 255.0;\nvec3 _03 = vec3(80.0, 246.0, 219.0) / 255.0;\nvec3 _10 = vec3(78.0, 249.0, 177.0) / 255.0;\nvec3 _11 = vec3(80.0, 121.0, 250.0) / 255.0;\nvec3 _12 = vec3(180.0, 69.0, 250.0) / 255.0;\nvec3 _13 = vec3(244.0, 66.0, 100.0) / 255.0;\n\n// from gold noise\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\nfloat rand(vec2 coordinate, float seed)\n{\n    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\nfloat test(float i, float j)\n{\n    if(i == j)\n        return 1.0;\n    \n    return 0.0;\n}\n\nvec3 rand_col(vec2 index)\n{   \n    vec3 rc = vec3(0.0);\n    \n    rc += _00 * test(index.y, 0.0) * test(index.x, 0.0);\n    rc += _01 * test(index.y, 0.0) * test(index.x, 1.0);\n    rc += _02 * test(index.y, 0.0) * test(index.x, 2.0);\n    rc += _03 * test(index.y, 0.0) * test(index.x, 3.0);\n    rc += _10 * test(index.y, 1.0) * test(index.x, 0.0);\n    rc += _11 * test(index.y, 1.0) * test(index.x, 1.0);\n    rc += _12 * test(index.y, 1.0) * test(index.x, 2.0);\n    rc += _13 * test(index.y, 1.0) * test(index.x, 3.0);\n    rc += _00 * test(index.y, 2.0) * test(index.x, 0.0);\n    rc += _01 * test(index.y, 2.0) * test(index.x, 1.0);\n    rc += _02 * test(index.y, 2.0) * test(index.x, 2.0);\n    rc += _03 * test(index.y, 2.0) * test(index.x, 3.0);\n    rc += _10 * test(index.y, 3.0) * test(index.x, 0.0);\n    rc += _11 * test(index.y, 3.0) * test(index.x, 1.0);\n    rc += _12 * test(index.y, 3.0) * test(index.x, 2.0);\n    rc += _13 * test(index.y, 3.0) * test(index.x, 3.0);\n    \n    return rc;\n}\n\nvec4 eye(vec2 coord)\n{\n    // useful vars\n    vec2 ii = floor(mod(coord, 4.0));\n    vec2 uv = mod(coord, 1.0);\n    vec2 aspect = iResolution.xy / iResolution.yy;\n    \n    vec2 ndc = uv * 2.0 - 1.0;\n    vec2 ppc = ndc * aspect;\n    vec2 ppn = normalize(ppc);\n    \n    vec2 index = (ii);\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    // eye\n    vec2 ebc = ndc;\n    ebc.y = pow(abs(ebc.y), 1.0/1.5);\n    float r = step(length(ebc), 0.7);\n    vec3 eyelid = vec3(r, r, r);\n    \n    // eye ball\n    float cd = 0.0;\n    \n    float t = iTime * 0.00001;\n    float pt = t - 0.001;\n    float nt = t + 0.001;\n    \n    float prx = floor(rand(index, pt) * 4.0);\n    float pry = floor(rand(index, pt) * 4.0);\n    \n    float rx = floor(rand(index, t) * 4.0);\n    float ry = floor(rand(index, t) * 4.0);\n    \n    if(length(index - vec2(rx, ry)) < 0.2 )\n        cd = 1.0;\n    \n    float open = 1.0/2.2;\n    float closed = 1.0/20.0;\n    float closedness = mix(open, closed, cd);\n    ebc.y = pow(abs(ebc.y), closedness);\n    r = step(length(ebc), 0.7);\n    vec3 eyeball = vec3(r, r, r);\n    \n    // pupil\n    r = step(length(ppc), 0.2);\n    vec3 pupil = vec3(r, r, r);\n    vec3 pupil_col = vec3(length(ppc));\n    \n    // iris\n    r = step(length(ppc), 0.4);\n    vec3 iris = vec3(r, r, r);\n    \n    r = length(ppc);\n    float at = atan(ppn.x, ppn.y) + sin(iTime);\n    float mat = mod(at, pi / 10.0);\n                    \n    //vec3 iris_col = mix(vec3(0.2, 0.5, 0.9), vec3(0.2, 0.9, 0.9), mat);\n    \n    vec3 iris_col = rand_col(index.yx);\n            \n    col = (eyeball * vec3(1.0, 1.0, 1.0)) * (1.0 - iris);\n   \tcol += iris_col * iris * eyeball * (1.0 - pupil);\n    col += pupil_col* pupil * eyeball;\n    col += rand_col(index) * (1.0 - eyeball) * eyelid;\n    \n    return vec4(col, eyelid);\n}\n\nvec3 bg_func(vec2 uv)\n{\n    float x = uv.x + iTime;\n    float y = uv.y;\n    float yv = uv.y * 2.0 - 1.0;\n    float m = 0.0;\n    \n    if(yv < 0.0)\n    \tm = step(mod(x + y, 0.4), 0.2);\n    else\n    \tm = 1.0 - step(mod(x - y, 0.4), 0.2);\n        \n    vec3 bg3 = mix(_02, _03, sin(iTime*10.0));\n    vec3 bg4 = mix(_12, _13, cos(iTime*10.0));\n    \n    vec3 bg2 = mix(mix(_00, _01, sin(iTime * 5.0) * 0.5 + 0.5), bg3, sin(iTime * 5.0));\n    vec3 bg1 = mix(mix(_10, _11, cos(iTime * 5.0) * 0.5 + 0.5), bg4, sin(iTime * 5.0));\n   \n    vec3 bg = mix(bg1, bg2, m);\n    \n    return bg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 _uv = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    vec2 aspect = iResolution.xy / iResolution.yy;\n    \n    uv.x += sin(iTime * 10.0 + uv.y * 10.0) * 0.01;\n    \n    // eyes   \n    vec2 num = vec2(1.0, 1.0) + vec2(floor(mod(iTime / 4.0, 8.0)));\n    vec4 eyes = eye(uv * num + vec2(iTime, 0.0));\n    \n    // bg\n\tvec3 bg = bg_func(uv);\n\n    // led / pixels\n    float led_size = 0.00005;\n    float edge = 0.04;\n    vec2 led_size2 = vec2(led_size, led_size) / aspect;\n    vec2 mm = mod(_uv * aspect, led_size);\n    vec2 mv = smoothstep(0.0, led_size, mm);\n    vec2 led = step(mv, vec2(edge) * aspect);\n    float third = 1.2/3.0;\n    float led_r = step(mv.x, third);\n    float led_g = step(mv.x, third * 2.0) * (1.0 - led_r);\n    float led_b = step(mv.x, third * 3.0) * (1.0 - led_r) * (1.0 - led_g);\n    vec3 led_rgb = vec3(led_r, led_g, led_b) * clamp(1.0 - (led.x + led.y), 0.0, 1.0);\n        \n   \tbg *= led_rgb;\n        \n    vec3 col = bg * (1.0 - eyes.a);\n    col += eyes.a * eyes.rgb;\n    \n    //col = bg;\n    \n    // output\n    fragColor = vec4(col.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[614, 614, 655, 655, 732], [734, 734, 764, 764, 822], [824, 824, 851, 851, 1818], [1820, 1820, 1842, 1861, 3594], [3596, 3596, 3619, 3619, 4172], [4174, 4174, 4231, 4231, 5366]], "test": "untested"}
{"id": "WtVGDV", "name": "Signed circumcircle", "author": "hiogawa", "description": "I can canonically obtain \"sign\" based on \"InCircle test\", but it doesn't give canonical AA-friendly pixel value since it is the volume of a tetrahedra in a quite unrelated 3d space.", "tags": ["2d", "triangle", "circle"], "likes": 3, "viewed": 298, "published": 3, "date": "1579928993", "time_retrieved": "2024-07-30T21:28:57.366071", "image_code": "//\n// Signed circumcircle\n//\n// NOTE:\n//   I can canonically obtain \"sign\" based on \"InCircle test\",\n//   but it doesn't give canonical AA friendly pixel value\n//   since it is the volume of a tetrahedra in a quite unrelated 3d space.\n//   So, \"USE_IN_CIRCLE_TEST = false\" switches to direct computation\n//   of circumcircle and signed area of a triangle.\n//\n\n#define M_PI 3.14159\n\nbool USE_IN_CIRCLE_TEST = true;\nfloat IN_CIRCLE_TEST_VOLUME_SCALE = 1000.0;\n\nfloat SCALE = 1.2;\nfloat SCALE_TIME = .4;\n\nfloat CHECKER_SCALE = 4.0;\nvec3  CHECKER_COLOR0 = vec3(0.20);\nvec3  CHECKER_COLOR1 = vec3(0.60);\n\nfloat POINT_RADIUS = 3.0;\nvec3  POINT_COLOR = vec3(0.0, 1.0, 1.0);\n\nvec3  TRIANGLE_COLOR = vec3(0.0, 1.0, 1.0);\nfloat TRIANGLE_ALPHA = 0.75;\n\nvec3  DISK_COLOR = vec3(1.0);\nfloat DISK_ALPHA = 0.75;\n\nfloat AA = 2.0;\n\n//\n// Utils\n//\n\nvec2 unitVector2(float t) {\n  return vec2(cos(2.0 * M_PI * t), sin(2.0 * M_PI * t));\n}\nfloat mix2(float f00, float f10, float f01, float f11, vec2 uv) {\n  return mix(mix(f00, f10, uv[0]), mix(f01, f11, uv[0]), uv[1]);\n}\n\nvoid intersect_Line_Line(\n    vec2 p1, vec2 v1, vec2 p2, vec2 v2,\n    out float t1, out float t2) {\n  // assume v1, v2: linear indep.\n  // p1 + t1 v1 = p2 + t2 v2\n  // <=>  (p1 - p2) + [v1, -v2] {t1, t2} = 0\n  // <=>  {t1, t2} = inv([v1, -v2]) (-p1 + p2)\n  vec2 t1t2 = inverse(mat2(v1, -v2)) * (-p1 + p2);\n  t1 = t1t2[0];\n  t2 = t1t2[1];\n}\n\nfloat distance_Point_LineSegment(vec2 p, vec2 q1, vec2 q2) {\n  // < p - (q + t v), v> = 0  <=>  t = < p - q, v > / < v, v >\n\n  vec2 v = q2 - q1;\n  float dot_vv = dot(v, v);\n  if (dot(v, v) < 0.0001) {\n    return distance(p, q1);\n  }\n  float t = dot(p - q1, v) / dot_vv;\n  float s = clamp(t, 0.0, 1.0);\n  return distance(p, q1 + s * v);\n}\n\n\n//\n// Noise\n//\n\nfloat hash11(float t) {\n  return fract(sin(1.0 + t * 123456.789) * 123456.789);\n}\n\nfloat hash21(vec2 v) {\n  return hash11(hash11(v[0]) + 2.0 * hash11(v[1]));\n}\n\nvec2 hash12(float v) {\n  return vec2(hash11(v), hash21(vec2(v, 1.0)));\n}\n\nvec2 hashGradient2(vec2 uv) {\n  return unitVector2(hash21(uv));\n}\n\nfloat gradientNoise2(vec2 uv) {\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float f00 = dot(hashGradient2(uvi + vec2(0.0, 0.0)), uvf - vec2(0.0, 0.0));\n  float f10 = dot(hashGradient2(uvi + vec2(1.0, 0.0)), uvf - vec2(1.0, 0.0));\n  float f01 = dot(hashGradient2(uvi + vec2(0.0, 1.0)), uvf - vec2(0.0, 1.0));\n  float f11 = dot(hashGradient2(uvi + vec2(1.0, 1.0)), uvf - vec2(1.0, 1.0));\n  float t = mix2(f00, f10, f01, f11, smoothstep(vec2(0.0), vec2(1.0), uvf));\n  return (t / 0.7 + 1.0) * 0.5;\n}\n\nvec2 someNoise(float hash_seed, float conti_seed) {\n  // Taking hashed direction to break inherent velocity pattern of gradientNoise2\n  vec2 p = hash12(hash_seed);\n  vec2 dir1 = unitVector2(p[0]);\n  vec2 dir2 = unitVector2(p[1]);\n  vec2 v = vec2(\n      gradientNoise2(123.456 * vec2(hash_seed) + 456.789 + conti_seed * dir1),\n      gradientNoise2(456.123 * vec2(hash_seed) + 789.456 + conti_seed * dir2));\n\n  // Tonemap [0, 1] to make movement more \"dynamical\"\n  return smoothstep(0.0, 1.0, v);\n}\n\n\n//\n// Misc\n//\n\nfloat signedDistanceToChecker(vec2 uv, float scale) {\n  uv *= scale;\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float dist = min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n  dist /= scale;\n  bool is_even_spot = mod(uvi.x + uvi.y, 2.0) == 0.0;\n  return is_even_spot ? -dist : dist;\n}\n\nfloat signedDistanceToTriangle(vec2 uv, vec2 p0, vec2 p1, vec2 p2) {\n  vec2 v1 = p1 - p0;\n  vec2 v2 = p2 - p0;\n  float signed_area = cross(vec3(v1, 0.0), vec3(v2, 0.0)).z;\n  if (abs(signed_area) <= 0.0000001) {\n    return 1000.0;\n  }\n\n  // Barycentric coord (uv = p0 + s * v1 + t * v2)\n  mat2 v1v2 = mat2(v1, v2);\n  vec2 st = inverse(transpose(v1v2) * v1v2) * transpose(v1v2) * (uv - p0);\n  bool is_inside = st.x >= 0.0 && st.y >= 0.0 && (st.x + st.y) <= 1.0;\n\n  float dist = 1000.0;\n  dist = min(dist, distance_Point_LineSegment(uv, p0, p1));\n  dist = min(dist, distance_Point_LineSegment(uv, p1, p2));\n  dist = min(dist, distance_Point_LineSegment(uv, p2, p0));\n\n  return is_inside ? -dist : dist;\n}\n\nfloat signedDistanceToCircle(vec2 uv, vec2 center, float radius) {\n  return distance(uv, center) - radius;\n}\n\nfloat inCircleTestVolume(vec2 q, vec2 p0, vec2 p1, vec2 p2) {\n  mat3 circle_test_mat = mat3(\n    (p0 - q).x, (p0 - q).y, dot(p0, p0) - dot(q, q),\n    (p1 - q).x, (p1 - q).y, dot(p1, p1) - dot(q, q),\n    (p2 - q).x, (p2 - q).y, dot(p2, p2) - dot(q, q));\n  float circle_test_det = determinant(circle_test_mat);\n  return circle_test_det;\n}\n\nvec2 circumcircleCenter(vec2 p0, vec2 p1, vec2 p2) {\n  // assume non degenerate triangle\n  vec2 q1 = (p0 + p1) / 2.0;\n  vec2 q2 = (p0 + p2) / 2.0;\n  vec2 u1 = p1 - p0;\n  vec2 u2 = p2 - p0;\n  vec2 v1 = vec2(cross(vec3(0.0, 0.0, 1.0), vec3(u1, 0.0)));\n  vec2 v2 = vec2(cross(vec3(0.0, 0.0, 1.0), vec3(u2, 0.0)));\n  float t1, t2;\n  intersect_Line_Line(q1, v1, q2, v2, t1, t2);\n  return q1 + t1 * v1;\n}\n\n// anti alias\nfloat smoothBoundaryCoverage(float signed_distance, float boundary_width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / boundary_width + 0.5);\n}\n\n// view transform with aspect ratio preserved\nmat3 invViewTransform(vec2 center, float scale_y) {\n  vec2 Res = iResolution.xy;\n  vec2 size = vec2(scale_y * Res.x / Res.y, scale_y);\n  vec2 a = center - size / 2.0;\n  float Sy = scale_y / Res.y;\n  mat3 xform = mat3(\n       Sy,   0,   0,\n        0,  Sy,   0,\n      a.x, a.y, 1.0\n  );\n  return xform;\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  mat3 inv_view_xform = invViewTransform(vec2(0.5, 0.5), SCALE);\n  float inv_view_scale = inv_view_xform[0][0];\n\n  vec2 uv = vec2(inv_view_xform * vec3(frag_coord, 1.0));\n  float t = SCALE_TIME * iTime;\n\n  vec3 color;\n  {\n    // Draw checker\n    float sd = signedDistanceToChecker(uv, CHECKER_SCALE);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(CHECKER_COLOR0, CHECKER_COLOR1, coverage);\n  }\n  {\n    // Prepare random 3 points\n    vec2 ps[3];\n    for (int i = 0; i <= 2; i++) {\n      ps[i] = someNoise(float(i), t);\n    }\n\n    // Draw circumcircle\n    if (USE_IN_CIRCLE_TEST) {\n      float volume = inCircleTestVolume(uv, ps[0], ps[1], ps[2]);\n      volume *= IN_CIRCLE_TEST_VOLUME_SCALE;\n      float coverage = 1.0 - smoothstep(-1.0, 1.0, volume);\n      color = mix(color, DISK_COLOR, DISK_ALPHA * coverage);\n\n    } else {\n      vec2 center = circumcircleCenter(ps[0], ps[1], ps[2]);\n      float radius = distance(center, ps[0]);\n      float sd = signedDistanceToCircle(uv, center, radius);\n\n      float signed_area = cross(vec3(ps[1] - ps[0], 0.0), vec3(ps[2] - ps[0], 0.0)).z;\n      sd *= sign(signed_area);\n\n      float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n      color = mix(color, DISK_COLOR, DISK_ALPHA * coverage);\n    }\n\n    // Draw triangle\n    {\n      float sd = signedDistanceToTriangle(uv, ps[0], ps[1], ps[2]);\n      float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n      color = mix(color, TRIANGLE_COLOR, TRIANGLE_ALPHA * coverage);\n    }\n\n    // Draw point\n    {\n      float min_distance = 1000.0;\n      for (int i = 0; i <= 2; i++) {\n        min_distance = min(min_distance, distance(ps[i], uv));\n      }\n      float coverage = smoothBoundaryCoverage(\n          min_distance / inv_view_scale - POINT_RADIUS, AA);\n      color = mix(color, POINT_COLOR, coverage);\n    }\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[831, 831, 858, 858, 917], [918, 918, 983, 983, 1050], [1052, 1052, 1151, 1306, 1391], [1393, 1393, 1453, 1516, 1730], [1749, 1749, 1772, 1772, 1830], [1832, 1832, 1854, 1854, 1908], [1910, 1910, 1932, 1932, 1982], [1984, 1984, 2013, 2013, 2049], [2051, 2051, 2082, 2082, 2552], [2554, 2554, 2605, 2687, 3050], [3068, 3068, 3121, 3121, 3364], [3366, 3366, 3434, 3434, 4067], [4069, 4069, 4135, 4135, 4177], [4179, 4179, 4240, 4240, 4515], [4517, 4517, 4569, 4605, 4915], [4917, 4931, 5006, 5006, 5085], [5087, 5133, 5184, 5184, 5435], [5453, 5453, 5507, 5507, 7414]], "test": "untested"}
{"id": "3tVGDV", "name": "Delaunay triangulation", "author": "hiogawa", "description": "I thought it's fun to utilize \"In Circle Test\" signed volume to reduce sudden triangulation flip.", "tags": ["2d"], "likes": 15, "viewed": 1438, "published": 3, "date": "1579928484", "time_retrieved": "2024-07-30T21:28:58.200840", "image_code": "//\n// Delaunay triangulation\n//\n\n#define M_PI 3.14159\n\nfloat SCALE = 5.0;\nfloat SCALE_TIME = .3;\n\nfloat POINT_RADIUS = 3.0;\nfloat GRID_LINE_WIDTH = 1.0;\nfloat QUAD_EDGE_WIDTH = 3.0;\nfloat TRI_EDGE_WIDTH  = 2.0;\n\nvec3 CLEAR_COLOR = vec3(0.15);\nvec3 GRID_LINE_COLOR = vec3(0.3);\nvec3 POINT_COLOR = vec3(0.0, 1.0, 1.0);\nvec3 QUAD_EDGE_COLOR = vec3(1.0, 0.0, 1.0);\nvec3 TRI_EDGE_COLOR  = vec3(1.0, 1.0, 0.0) * 0.8;\nfloat TRI_EDGE_DEGENERACY_FACTOR_SCALE = 0.1; // heuristics to reduce sudden triangulation flip\n\nfloat AA = 2.0;\n\n//\n// Utils\n//\n\nvec2 unitVector2(float t) {\n  return vec2(cos(2.0 * M_PI * t), sin(2.0 * M_PI * t));\n}\nfloat mix2(float f00, float f10, float f01, float f11, vec2 uv) {\n  return mix(mix(f00, f10, uv[0]), mix(f01, f11, uv[0]), uv[1]);\n}\n\nfloat distance_Point_LineSegment(vec2 p, vec2 q1, vec2 q2) {\n  // < p - (q + t v), v> = 0  <=>  t = < p - q, v > / < v, v >\n\n  vec2 v = q2 - q1;\n  float dot_vv = dot(v, v);\n  if (dot(v, v) < 0.0001) {\n    return distance(p, q1);\n  }\n  float t = dot(p - q1, v) / dot_vv;\n  float s = clamp(t, 0.0, 1.0);\n  return distance(p, q1 + s * v);\n}\n\n\n//\n// Noise\n//\n\nfloat hash11(float t) {\n  return fract(sin(1.0 + t * 123456.789) * 123456.789);\n}\n\nfloat hash21(vec2 v) {\n  return hash11(hash11(v[0]) + 2.0 * hash11(v[1]));\n}\n\nfloat hash31(vec3 v) {\n  return hash11(hash11(v[0]) + 2.0 * hash11(v[1]) + 3.0 * hash11(v[2]));\n}\n\nvec2 hash22(vec2 v) {\n  return vec2(hash21(v), hash31(vec3(v, 1.0)));\n}\n\nvec2 hashGradient2(vec2 uv) {\n  return unitVector2(hash21(uv));\n}\n\nfloat gradientNoise2(vec2 uv) {\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float f00 = dot(hashGradient2(uvi + vec2(0.0, 0.0)), uvf - vec2(0.0, 0.0));\n  float f10 = dot(hashGradient2(uvi + vec2(1.0, 0.0)), uvf - vec2(1.0, 0.0));\n  float f01 = dot(hashGradient2(uvi + vec2(0.0, 1.0)), uvf - vec2(0.0, 1.0));\n  float f11 = dot(hashGradient2(uvi + vec2(1.0, 1.0)), uvf - vec2(1.0, 1.0));\n  float t = mix2(f00, f10, f01, f11, smoothstep(vec2(0.0), vec2(1.0), uvf));\n  return (t / 0.7 + 1.0) * 0.5;\n}\n\nvec2 someNoise(vec2 hash_seed, float conti_seed) {\n  // Taking hashed direction to break inherent velocity pattern of gradientNoise2\n  vec2 p = hash22(hash_seed);\n  vec2 dir1 = unitVector2(p[0]);\n  vec2 dir2 = unitVector2(p[1]);\n  vec2 v = vec2(\n      gradientNoise2(123.456 * hash_seed + 456.789 + conti_seed * dir1),\n      gradientNoise2(456.123 * hash_seed + 789.456 + conti_seed * dir2));\n\n  // Tonemap [0, 1] to make movement more \"dynamical\"\n  return smoothstep(0.0, 1.0, v);\n}\n\n//\n// Delaunay triangulation\n//\n\nvoid distanceToNoiseSitesTriangulation(\n    vec2 uv, float noise_seed,\n    out float min_distance_vertex,\n    out float min_distance_quad_edge,\n    out float min_distance_tri_edge,\n    out float in_circle_test_det) {\n\n  vec2 lattice_uv = floor(uv);\n  min_distance_vertex = sqrt(2.0);\n  min_distance_quad_edge = 1.0;\n  min_distance_tri_edge = sqrt(2.0);\n\n  // Cache sites coordinate\n  vec2 sites[9];\n  #define _ENCODE_IJ(i, j)       (3 * int(i + 1.0) + int(j + 1.0))\n  #define READ_SITE(i, j)        sites[_ENCODE_IJ(i, j)]\n  #define WRITE_SITE(i, j, site) sites[_ENCODE_IJ(i, j)] = site\n\n  // iterate sites\n  for (float i = -1.0; i <= 1.0; i++) {\n    for (float j = -1.0; j <= 1.0; j++) {\n      vec2 lattice_ij = lattice_uv + vec2(i, j);\n      vec2 site_ij = lattice_ij + someNoise(lattice_ij, noise_seed);\n      min_distance_vertex = min(min_distance_vertex, distance(uv, site_ij));\n      WRITE_SITE(i, j, site_ij);\n    }\n  }\n\n  // iterate quad edges\n  // - these quads are not necessarily convex, but the probablity of such case should be quite low.\n  //   or you could force convexity by weaking the noise factor (e.g. 0.5 * someNoise(...)).\n  for (float k = -1.0; k <= 1.0; k++) {\n    for (float l = -1.0; l <= 0.0; l++) {\n      float d_kl = distance_Point_LineSegment(uv, READ_SITE(k, l), READ_SITE(k + 0.0, l + 1.0));\n      float d_lk = distance_Point_LineSegment(uv, READ_SITE(l, k), READ_SITE(l + 1.0, k + 0.0));\n      min_distance_quad_edge = min(min_distance_quad_edge, min(d_kl, d_lk));\n    }\n  }\n\n  // iterate triangulation diagonal edges\n  for (float k = -1.0; k <= 0.0; k++) {\n    for (float l = -1.0; l <= 0.0; l++) {\n      vec2 v0 = READ_SITE(k + 0.0, l + 0.0);\n      vec2 v1 = READ_SITE(k + 1.0, l + 0.0);\n      vec2 v2 = READ_SITE(k + 0.0, l + 1.0);\n      vec2 v3 = READ_SITE(k + 1.0, l + 1.0);\n\n      // Cf. Guibas 1985, Lemma 8.1 (https://doi.org/10.1145%2F282918.282923)\n      mat3 in_circle_test_mat = mat3(\n          (v1 - v0).x, (v1 - v0).y, dot(v1, v1) - dot(v0, v0),\n          (v2 - v0).x, (v2 - v0).y, dot(v2, v2) - dot(v0, v0),\n          (v3 - v0).x, (v3 - v0).y, dot(v3, v3) - dot(v0, v0));\n      float in_circle_test_det_current = determinant(in_circle_test_mat);\n      float d = in_circle_test_det_current > 0.0\n          ? distance_Point_LineSegment(uv, v1, v2)  // edge: 10 <--> 01\n          : distance_Point_LineSegment(uv, v0, v3); // edge: 00 <--> 11\n      if (d < min_distance_tri_edge) {\n        min_distance_tri_edge = d;\n        in_circle_test_det = in_circle_test_det_current;\n      }\n    }\n  }\n\n  #undef _ENCODE_IJ\n  #undef READ_SITE\n  #undef WRITE_SITE\n}\n\n//\n// Misc\n//\n\n// grid\nfloat distanceToGrid(vec2 uv) {\n  vec2 uvf = fract(uv);\n  return min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n}\n\n// anti alias\nfloat smoothBoundaryCoverage(float b, float d, float w) {\n  return 1.0 - smoothstep(0.0, 1.0, (d - b) / w + 0.5);\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  float inv_view_scale = SCALE / iResolution.y;\n  vec2 uv =  inv_view_scale * frag_coord;\n  float t = SCALE_TIME * iTime;\n\n  vec3 color = CLEAR_COLOR;\n  {\n    float d = distanceToGrid(uv);\n    float coverage = smoothBoundaryCoverage(0.5 * GRID_LINE_WIDTH, d / inv_view_scale, AA);\n    color = mix(color, GRID_LINE_COLOR, coverage);\n  }\n  {\n    float d_vertex, d_quad_edge, d_tri_edge, in_circle_test_det;\n    distanceToNoiseSitesTriangulation(\n        uv, t, d_vertex, d_quad_edge, d_tri_edge, in_circle_test_det);\n\n    float coverage_vertex = smoothBoundaryCoverage(\n        POINT_RADIUS, d_vertex / inv_view_scale, AA);\n    float coverage_quad_edge = smoothBoundaryCoverage(\n        0.5 * QUAD_EDGE_WIDTH, d_quad_edge / inv_view_scale, AA);\n    float coverage_tri_edge = smoothBoundaryCoverage(\n        0.5 * TRI_EDGE_WIDTH, d_tri_edge / inv_view_scale, AA);\n    float degeneracy_factor = smoothstep(\n        0.0, TRI_EDGE_DEGENERACY_FACTOR_SCALE, abs(in_circle_test_det));\n\n    color = mix(color, QUAD_EDGE_COLOR, coverage_quad_edge);\n    color = mix(color, TRI_EDGE_COLOR, coverage_tri_edge * degeneracy_factor);\n    color = mix(color, POINT_COLOR, coverage_vertex);\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[541, 541, 568, 568, 627], [628, 628, 693, 693, 760], [762, 762, 822, 885, 1099], [1118, 1118, 1141, 1141, 1199], [1201, 1201, 1223, 1223, 1277], [1279, 1279, 1301, 1301, 1376], [1378, 1378, 1399, 1399, 1449], [1451, 1451, 1480, 1480, 1516], [1518, 1518, 1549, 1549, 2019], [2021, 2021, 2071, 2153, 2504], [5153, 5161, 5192, 5192, 5282], [5284, 5298, 5355, 5355, 5413], [5431, 5431, 5485, 5485, 6696]], "test": "untested"}
{"id": "WtKGDK", "name": "FrostyBlur", "author": "space928", "description": "I was playing with some blurring distributions, to try and make something super super soft and asymptotic (think like a GGX distribution).\nI think the results are interesting though a bit subtle. It flips between a rough gaussian blur and custom function.", "tags": ["2d", "blur"], "likes": 5, "viewed": 798, "published": 3, "date": "1579901568", "time_retrieved": "2024-07-30T21:28:59.079490", "image_code": "const float r = 20.;\nconst float pi = 3.14159265;\n\nconst float g = 0.76;\nfloat henyey_greenstein_phase_func(float mu)\n{\n\treturn\n\t\t\t\t\t\t(1. - g*g)\n\t/ //---------------------------------------------\n\t\t((4. * pi) * pow(1. + g*g - 2.*g*mu, 1.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    float sum = 0.;\n    //col.r = CalculateGGX(.25,uv.r);\n    \n    for(float x = -r; x < r; x++)\n    {\n        for(float y = -r; y < r; y++)\n        {\n            /*if(sqrt(x*x+y*y)>r)\n                continue;*/\n            vec2 off = vec2(x,y)/r;\n            vec2 offFrost = tan(off*pi/2.)*(2./pi);\n            //offFrost = vec2(henyey_greenstein_phase_func(off.x*3.), henyey_greenstein_phase_func(off.y*3.))*(2./pi);\n            \n            float l = 1.-sqrt(x*x+y*y)/r;\n            float lHermite = -2.*l*l*l+3.*l*l;\n            float lFrost = tan(l);\n            //lFrost = henyey_greenstein_phase_func(l);\n            //lFrost = lHermite;\n            \n            //Pick between frosty and less frosty\n            off = mix(offFrost, off, sin(iTime)*.5+.5>.5?0.:1.);\n            float weight = mix(lFrost,lHermite, sin(iTime)*.5+.5>.5?1.:1.);\n            \n            off *= 30.;\n            sum += weight;\n            col += textureLod(iChannel0, uv + off/iResolution.xy,2.).rgb*weight;\n        }\n    }\n    col /= sum;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 119, 119, 243], [245, 245, 302, 352, 1535]], "test": "untested"}
{"id": "wtG3WV", "name": "The Doubtful Minimal circle", "author": "erevan", "description": "Minimalist sdf circle transition with some grain", "tags": ["sdf", "circle", "grain"], "likes": 8, "viewed": 529, "published": 3, "date": "1579875498", "time_retrieved": "2024-07-30T21:28:59.854418", "image_code": "float sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat triangle(float x)\n{\n\treturn abs(1.0 - mod(abs(x), 2.0)) * 2.0 - 1.0;\n}\n\nfloat randomNoise(float x, float y)\n{\n    return fract(sin(dot(vec2(x, y), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat _Indensity = 0.7; \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = floor(iTime * 16.0) / 16.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p += vec2(triangle(uv.y * rand(time * 0.1) * 1.0) * rand(time * 2.1) * 0.004,\n\t\t\ttriangle(uv.x * rand(time * 0.1) * 1.0) * rand(time * 3.1) * 0.004);\n    \n    float x = (p.x + 4.0 ) * (p.y + 4.0 ) * (iTime);\n\tfloat grain = fract(sin(dot(p.xy, vec2(17.0,180.)))* 2400. + iTime);\n        \n\tfloat d = sdCircle( p, -0.1 );\n    \n    float c = iTime * 0.8;\n    vec3 col = vec3(d) - vec3(0.5);\n\tcol *= 11. * cos(35. * d - d * pow(d, .1)) + 11.* d * cos(abs(c*1.3) + 0.8) * 11.; \n    \n    // Grain\n\tgrain = 1.0 - grain;\n    vec3 color = mix(col, vec3(grain), 0.3);\n    \n    \n    // Depth alpha\n    float alpha = col.x * grain*0.007; // cine shader depth\n\tfragColor = vec4(color,alpha);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Minimalist sdf circle transition\",\n\t\"description\": \"Minimalist sdf circle transition with grain\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 61], [63, 63, 84, 84, 125], [127, 127, 152, 152, 203], [205, 205, 242, 242, 320], [349, 349, 406, 406, 1242]], "test": "untested"}
{"id": "3tVGz3", "name": "[♪]Scale Sequencer 2", "author": "Catzpaw", "description": "newer version of Scale Sequencer\n", "tags": ["music"], "likes": 13, "viewed": 564, "published": 3, "date": "1579873936", "time_retrieved": "2024-07-30T21:29:00.804877", "image_code": "//---Scale Sequencer 2\n// by Catzpaw 2020\n\nfloat circle(vec2 p,vec2 s,float r1,float r2){\n    float d=1./iResolution.y;\n    float v=(s.x+s.y)*.5;\n    float l=length(p);r1+=v*.01;r2+=r1;\n    float r=min(smoothstep(r1,r1+d,l),smoothstep(r2+d,r2,l));\n    s=abs(s);\n    v=p.x<0.?s.x*3.+s.y:s.x+s.y*3.;\n    r=min(r,smoothstep(v+d,v,atan(abs(p.x),-p.y)));\n    return v>0.?r*.6:0.;\n}\nvec4 tx1(int x){\n    return texture(iChannel1,vec2((float(x)+.5)/iResolution.x,.5/iResolution.y))*2.-1.;\n}\nmat2 rot(float a){\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=fragCoord/iResolution.xy;\n    vec3 e=vec3(.07,.07,0);\n    vec4 c=texture(iChannel0,uv+e.xz)*.2;\n    c=max(c,texture(iChannel0,uv-e.xz)*.2);\n    c=max(c,texture(iChannel0,uv+e.zy)*.2);\n    c=max(c,texture(iChannel0,uv-e.zy)*.2);\n    c*=1.-length(uv-.5)*1.5;\n    c=max(c,texture(iChannel0,uv));\n    c.w=1.;\n    \n    uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    float vol=tx1(0).x*.5+.5;\n    vec4 tx=vec4(0);\n    if(length(uv)<.5){\n        tx=tx1(6);c.xy+=circle(uv,tx.xy   *vol,0.15,.09);c.z +=circle(uv,tx.zw   *vol,0.15,.09);\n        tx=tx1(5);c.x +=circle(uv,tx.xy*6.*vol,0.25,.02);c.yz+=circle(uv,tx.zw*6.*vol,0.25,.02);\n        tx=tx1(4);c.xy+=circle(uv,tx.xy*5.*vol,0.28,.02);c.z +=circle(uv,tx.zw*5.*vol,0.28,.02);\n        tx=tx1(3);c.x +=circle(uv,tx.xy*2.*vol,0.31,.04);c.yz+=circle(uv,tx.zw*2.*vol,0.31,.04);\n        tx=tx1(2);c.xy+=circle(uv,tx.xy*2.*vol,0.36,.06);c.z +=circle(uv,tx.zw*2.*vol,0.36,.06);\n        tx=tx1(1);c.x +=circle(uv,tx.xy*2.*vol,0.43,.04);c.yz+=circle(uv,tx.zw*2.*vol,0.43,.04);\n        c+=circle(uv*rot(-iTime*6.283*bpm/120.),vec2(vol*.7),0.12,.02);\n        c+=circle(uv*rot(-iTime*6.283*bpm/120.),vec2(vol*(iTime/180.)),0.48,.01);\n    }\n\tfragColor=c;    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// see \"Common\" tab", "sound_inputs": [], "buffer_a_code": "//---Scale Sequencer 2\n// by Catzpaw 2020\n\n//BufferA:animation\n\nvec3 hsv(float h,float s,float v){\n    return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec4 c=texture(iChannel0,fragCoord/iResolution.xy).gbra*.3;\n\tfloat t=iTime*.2,a=0.,x=0.,y=0.;\n\tvec2 uv=(fragCoord/iResolution.y-.5)*mat2(sin(t),cos(t),-cos(t),sin(t)),p=uv*3.;\n\tfor(int i=0;i<25;i++){\n        x=sin(t*1.107+a*.1)*3.,y=sin(t*.907+a*.4)*3.;\n        p=vec2(cos(p.x+x),sin(p.x+a*3.-y))*exp(p.y+a*3.+4.4)*.05+uv;\n        if(p.y>100.)break;\n        a+=.04;\n    }\n\tc=max(c,a<1.?vec4(hsv(a*.4+t*.05,sin(log(abs(p.x))*.1)*.5+.5,1.5-fract(log(abs(p.y))*.05)-a),0):vec4(0));\n    c.w=a;\n    fragColor=c;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//---Scale Sequencer 2\n// by Catzpaw 2020\n\n//SETUP\nconst float base =432.;\t//A tuning (Hz)\nconst float bpm  =135.;\t//beats per minute\nconst float steps=240.;\t//block length\nconst float start=1.;   //start count (beats)\nconst float fade =10.;  //fade out time (sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\nconst float gateseed=188.;\nconst float noteseed=177.;\nconst int chord3=2; //3rd tone(default:2)\nconst int chord5=4; //5th tone(default:4)\n\n//SCALE\nint key=4; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\nint scale=10;\nconst uint[12] scl=uint[](\n    0xcb975420u, //0:major\n    0xca875320u, //1:natural minor\n    0xcb875320u, //2:harmonic minor\n    0xcb975320u, //3:melodic minor\n    0xa9765320u, //4:blues octatonic\n    0xa9764310u, //5:blues diminished octatonic\n    0xc9974420u, //6:major pentatonic (to heptatonic)\n    0xca775530u, //7:minor pentatonic (to heptatonic)\n    0xcb775540u, //8:ryukyu pentatonic (to heptatonic)\n    0xcb755420u, //9:ryukyu hexatonic (to heptatonic)\n    0xba875410u, //10:maqam hijaz octatonic\n    0xba876320u);//11:gypsy minor octatonic\nint scalenote(int y){\n    return y<0?-999:key+((int(scl[scale])>>(y&7)*4)&15);\n}\n\n//PATTERN\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\nconst uint[32] pat=uint[](\n    0x37000000u,0x37011171u,0x47012172u,0x37011773u,  //00-   melody\n    0x37054394u,0x37054c95u,0x44226166u,0x34617167u,\n    0x34028168u,0x34019119u,0x4401a11au,0x3440417cu,  //  -0B\n    0x31001434u,0x31001491u,0x31001022u,0x31001022u,  //0C-0F backing\n    0x10000000u,0x10000000u,0x10000000u,0x10000000u,  //10-13 chord\n    0x44504789u,0x4461a890u,0x44143327u,0x44957631u,  //14-17 bass\n    0x313aa13au,0x513aa186u,0x323a323au,0x5556a186u,  //18-1B sd+hh\n    0x91e121e1u,0x55e121e5u,0x4db18db1u,0x55919d55u); //1C-1F bd+conga\n\n//SEQUENCE\n// speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n// speed    0:0.5x 1:1x 2:2x 3:4x\n// degree   0:mute 1:I  2:II 3:III 4:IV 5:V 6:VI 7:VII\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2)\nconst uint[16] seq1=uint[]( //snare+hihat\n    0x11000118u,0x11000118u,0x11000118u,0x11188119u,\n    0x11000118u,0x11000118u,0x11000119u,0x1100011bu,\n    0x11000118u,0x11000118u,0x11000118u,0x11188119u,\n    0x11000118u,0x11000118u,0x11000119u,0x1100011bu);\nconst uint[16] seq2=uint[]( //bassdrum+conga\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111ee11fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x111e811fu,\n    0x1100011eu,0x1100011eu,0x1100011eu,0x1100011fu);\nconst uint[16] seq3=uint[]( //bass\n    0x11000114u,0x11000114u,0x11000214u,0x11000616u,\n    0x11000114u,0x11000114u,0x11000214u,0x11000717u,\n    0x11000614u,0x11000414u,0x11000514u,0x11000116u,\n    0x11000614u,0x11000414u,0x11000514u,0x11000717u);\nconst uint[16] seq4=uint[]( //chord\n    0x11000110u,0x11000110u,0x11000210u,0x11000612u,\n    0x11000110u,0x11000110u,0x11000210u,0x11000713u,\n    0x11000610u,0x11000410u,0x11000510u,0x11000112u,\n    0x11000610u,0x11000410u,0x11000510u,0x11000713u);\nconst uint[16] seq5=uint[]( //backing\n    0x1100010cu,0x00000000u,0x1100020cu,0x190d860eu,\n    0x1100010cu,0x00000000u,0x1100020cu,0x110d870fu,\n    0x1100060cu,0x00000000u,0x1100050cu,0x170d810eu,\n    0x1100060cu,0x00000000u,0x1100050cu,0x110d870fu);\nconst uint[16] seq6=uint[]( //melody\n    0x11000101u,0x11000102u,0x11000203u,0x11000604u,\n    0x11000101u,0x11000102u,0x11000203u,0x11000705u,\n    0x11000606u,0x11000407u,0x11000508u,0x11000109u,\n    0x11000606u,0x11000407u,0x1100050Au,0x1100070Bu);\n\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint imod(uint x,uint y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\nfloat osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float[16] nt=float[](2.,4.,8.,16.,32.,48.,64.,80.,101.,127.,190.,254.,381.,508.,1017.,2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*1789772.5/nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\nconst uint[24] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*24.,24.))]>>(i*4))&15u)/15.-.5);}\n\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x),vec2(1./p.y)),-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nfloat freq(float n){return pow(2.,(n-69.)/12.)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 tri4bass(float f,float x){return vec2(osc_tri4(f*(.5+detune)),osc_tri4(f*(.5-detune)));}\nvec2 tri4lead(float f,float x){return vec2(osc_tri4(f*(1.-detune)),osc_tri4(f*(1.+detune)));}\nvec2 c30bass(float f,float x){return vec2(osc_c30(f*(1.+detune),5),osc_c30(f*(1.-detune),5))*env_d(x,.5);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\nvec2 c30lead(float f,float x){return vec2(osc_c30(f*(1.-detune),4),osc_c30(f*(1.+detune),4))*env_d(x,.5);}\n\n//CHIPTUNE PERCUSSION (time)\nfloat nessd(float x){return osc_nesnoise(x,11)*env_d(x,.2);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.2);}\nfloat neslc(float x){return osc_duty(10./(x*.3+.1),.25)*env_d(x,.05);}\nfloat neshc(float x){return osc_duty(12./(x*.3+.1),.25)*env_d(x,.05);}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   dg=0;  //degree now playing\nuint  pt=0u;  //pattern now playing\nint   st=0;  //step now playing\nbool getpattern(float t,uint sq){\n    // speed(4),degree1(4),pattern1(8),division(4),degree2(4),pattern2(8)\n    mp=pow(2.,float(get4(sq,7)-1))*16.;\n    st=int(mod(t*bpm*mp/steps,16.));\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,3);\n    dg=di?get4(sq,6):get4(sq,2);\n    pt=di?pat[get8(sq,4)]:pat[get8(sq,0)];\n    return dg==0?false:true;\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateseed)*50.)<(float(get4(pt,6))*.0625)?-1:\n    imod(int(abs(sin(float(s+s1+s*s2)*noteseed)*float(s2))),get4(pt,7));\n}\nvec4 getnote(float t,float l){\n    // melodic:range(4),rest(4),seed1(12),seed2(12)\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n<0)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<0?0:dg-1;\n    return (dg<1)||(n<0)?vec4(x,-1,-1,-1):vec4(x,scalenote(n),scalenote(n+chord3),scalenote(n+chord5));\n}\nvec4 getgate(float t,float l){\n    // percussive:note(2x16)\n    int n=get2(pt,st);\n    float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return dg<1?vec4(x,-1,-1,-1):vec4(x,n,n,n);\n}\n\n//RENDERER\nvec2 track1(float t,float l,int s){//TRACK 1 NES noise snaredrum,closehh,openhh\n    vec2 o=vec2(0);\n    getpattern(t,seq1[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?nessd(n.x)*.8:0.;\n    o+=(n.y==2.)?neshh(n.x,.08)*.4:0.;\n    o+=(n.y==3.)?neshh(n.x,.2)*.5:0.;\n    return o;\n}\nvec2 track2(float t,float l,int s){//TRACK 2 NES sqr bassdrum,lowconga,highconga\n    vec2 o=vec2(0);\n    getpattern(t,seq2[imod(s,16)]);\n    vec4 n=getgate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*.6:0.;\n    o+=(n.y==2.)?neslc(n.x)*.3:0.;\n    o+=(n.y==3.)?neshc(n.x)*.3:0.;\n    return o;\n}\nvec2 track3(float t,float l,int s){//TRACK 3 NES sqr bass\n    vec2 o=vec2(0);\n    getpattern(t,seq3[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?dutybass(freq(n.y+36.)*n.x,n.x)*.35:vec2(0);\n    return o;\n}\nvec2 track4(float t,float l,int s){//TRACK 4 N163 chord\n    vec2 o=vec2(0);\n    getpattern(t,seq4[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30chord(freq(n.y+60.03)*n.x,n.x)*.3:vec2(0);\n    o+=(n.y>=0.)?c30chord(freq(n.z+60.02)*n.x,n.x)*.3:vec2(0);\n    o+=(n.y>=0.)?c30chord(freq(n.w+60.01)*n.x,n.x)*.3:vec2(0);\n    return o;\n}\nvec2 track5(float t,float l,int s){//TRACK 5 N163 backing\n    vec2 o=vec2(0);\n    getpattern(t,seq5[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30bell(freq(n.y+72.05)*n.x,n.x)*.3:vec2(0);\n    return o;\n}\nvec2 track6(float t,float l,int s){//TRACK 6 N163 & NES tri melody\n    vec2 o=vec2(0);\n    getpattern(t,seq6[imod(s,16)]);\n    vec4 n=getnote(t,l);\n    o+=(n.y>=0.)?c30lead(freq(n.y+36.05)*n.x,n.x)*.6+tri4lead(freq(n.y+60.)*n.x,n.x)*.6:vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o){\n    float c=0.;       //render target\n    int   s=int(t/l); //sequence number now playing\n    vec4  n=vec4(0);  //chord info x:gate yzw:notes\n    o+=track1(t,l,s); //TRACK 1 NES noise snaredrum,closehh,openhh\n    o+=track2(t,l,s); //TRACK 2 NES sqr bassdrum,lowconga,highconga\n    o+=track3(t,l,s); //TRACK 3 NES sqr bass\n    o+=track4(t,l,s); //TRACK 4 N163 chord\n    o+=track5(t,l,s); //TRACK 5 N163 backing\n    o+=track6(t,l,s); //TRACK 6 N163 & NES tri melody\n}\n\n//MASTER SECTION\n#define MASTER_DRIVE    0.5\n#define MASTER_PRESSURE 1.1\nfloat mvol=0.; //for indicator\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o);\n    mvol=vol;\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n", "buffer_b_code": "//---Scale Sequencer 2\n// by Catzpaw 2020\n\n//BufferB:samples for level indicator\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p=fragCoord;\n    int x=int(p.x),y=int(p.y);\n    if((x>6)||(y>0))discard;\n    vec2 o=vec2(0);\n    float t=iTime,l=steps/bpm,vol=1.;\n    if(t>sec-fade){vol=(sec-min(t,sec))/fade;}\n    t-=start*60./bpm;\n    if(t>0.){\n        int s=int(t/l);\n        if(x==0){o=vec2(vol,0);}\n        if(x==1){o=track1(t,l,s)*.5+.5;}\n        if(x==2){o=track2(t,l,s)*.5+.5;}\n        if(x==3){o=track3(t,l,s)*.5+.5;}\n        if(x==4){o=track4(t,l,s)*.5+.5;}\n        if(x==5){o=track5(t,l,s)*.5+.5;}\n        if(x==6){o=track6(t,l,s)*.5+.5;}\n    }    \n    vec2 b=texture(iChannel1,fragCoord/iResolution.xy).xy;\n    fragColor = vec4(o,b);\n}\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 89, 89, 376], [484, 484, 502, 502, 551], [552, 552, 605, 605, 1812]], "test": "untested"}
{"id": "wtK3DG", "name": "Nebula Noise", "author": "BenoitArbelot", "description": "Trying to visualize in 2D the Nebula Noise from : [url]https://www.shadertoy.com/view/MdKXzc[/url]", "tags": ["noise"], "likes": 4, "viewed": 457, "published": 3, "date": "1579857560", "time_retrieved": "2024-07-30T21:29:01.692504", "image_code": "//Taken from Duke's shader : https://www.shadertoy.com/view/MdKXzc\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec3 p )\n{\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 4.;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.; // noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n    float final = 2.;\n    final += fbm(p*90.);\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*3.0;\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.07;\n}\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0), vec3(0.0), density );\n\t\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 coords3D = vec3(uv * 3., .1*iTime);\n    \n    float n = map(coords3D);\n    \n    // Time varying pixel color\n    vec3 col = computeColor(n, 0.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtK3DG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 82, 108, 108, 327], [329, 329, 350, 350, 439], [441, 1101, 1129, 1129, 1677], [1679, 1679, 1706, 1706, 1825], [1827, 1827, 1847, 1847, 1924], [1926, 1955, 2005, 2090, 2163], [2165, 2165, 2222, 2272, 2523]], "test": "untested"}
{"id": "ttyGzW", "name": "Alexander horned sphere zoom", "author": "tmst", "description": "- Infinite zoom into an Alexander horned sphere\n- Use mouse drag to move forward or back along the path", "tags": ["recursive", "outlines", "topology", "alexanderhornedsphere"], "likes": 156, "viewed": 5796, "published": 3, "date": "1579846331", "time_retrieved": "2024-07-30T21:29:02.946153", "image_code": "#define WO_0 (1.0/8.0)\n#define WO_1 (1.0/8.0)\n\n#define FOG_MIN 0.0\n#define FOG_MAX 1.0\n#define FOG_COLOR vec3(0.325, 0.3, 0.375)\n\nfloat isInInterval(float a, float b, float x) {\n    return step(a, x) * (1.0 - step(b, x));\n}\n\nvoid outlineCheck(in vec2 uv, in float weight, in float aBase, inout float n) {\n    vec4 data = textureLod(iChannel0, uv, 0.0);\n    float depth = data.a;\n\n    n += weight * (1.0 - isInInterval(aBase-0.004, aBase+0.004, depth));\n}\n\nfloat outline(in vec2 uv, in float aBase) {\n    vec2 uvPixel = 1.0/iResolution.xy;\n    float n = 0.0;\n\n    outlineCheck(uv + vec2( 1.0, 0.0)*uvPixel, WO_1, aBase, n);\n    outlineCheck(uv + vec2( 0.0, 1.0)*uvPixel, WO_1, aBase, n);\n    outlineCheck(uv + vec2( 0.0,-1.0)*uvPixel, WO_1, aBase, n);\n    outlineCheck(uv + vec2(-1.0, 0.0)*uvPixel, WO_1, aBase, n);\n\n    outlineCheck(uv + vec2( 1.0, 1.0)*uvPixel, WO_0, aBase, n);\n    outlineCheck(uv + vec2( 1.0,-1.0)*uvPixel, WO_0, aBase, n);\n    outlineCheck(uv + vec2(-1.0, 1.0)*uvPixel, WO_0, aBase, n);\n    outlineCheck(uv + vec2(-1.0,-1.0)*uvPixel, WO_0, aBase, n);\n\n    return n;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 data = textureLod(iChannel0, uv, 0.0);\n    float depth = data.a;\n\n    float fogAmount = pow(mix(FOG_MIN, FOG_MAX, depth), 3.0);\n    vec3 finalColor = mix(data.rgb, FOG_COLOR, fogAmount);\n\n    float outlineAmount = outline(uv, depth);\n    vec3 outlineColor = vec3(0.0);\n    finalColor = mix(finalColor, outlineColor, outlineAmount*0.8);\n\n    vec2 radv = uv - vec2(0.5);\n    float dCorner = length(radv);\n    float vignetteFactor = 1.0 - mix(0.0, 0.5, smoothstep(0.2, 0.707, dCorner));\n    finalColor *= vignetteFactor;\n\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define HALF_PI 1.570796326794896\n#define ONE_PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n\n#define ID_3X3      mat3( 1., 0., 0.,   0., 1., 0.,   0., 0., 1.)\n#define ROT_X       mat3( 1., 0., 0.,   0., 0., 1.,   0.,-1., 0.)\n#define ROT_X_INV   mat3( 1., 0., 0.,   0., 0.,-1.,   0., 1., 0.)\n#define ROT_Y       mat3( 0., 0.,-1.,   0., 1., 0.,   1., 0., 0.)\n#define ROT_Y_INV   mat3( 0., 0., 1.,   0., 1., 0.,  -1., 0., 0.)\n#define ROT_Z       mat3( 0., 1., 0.,  -1., 0., 0.,   0., 0., 1.)\n#define ROT_Z_INV   mat3( 0.,-1., 0.,   1., 0., 0.,   0., 0., 1.)\n\n#define E1 vec3(1.0, 0.0, 0.0)\n#define E2 vec3(0.0, 1.0, 0.0)\n#define E3 vec3(0.0, 0.0, 1.0)\n\n#define TAN_HALF_FOVY 0.5773502691896257\n#define CAM_Z_NEAR 0.1\n#define CAM_Z_FAR 50.0\n\n#define MIN_DIST 0.005\n#define MAX_DIST 50.0\n#define GRAD_EPS 0.01\n\n#define MAX_BRANCH_DEPTH 18\n\n#define SPHERE_CENTER vec3(0.0)\n#define SPHERE_RADIUS 2.0\n#define SPHERE_BUFFER 0.1\n\n#define SUBSPHERE_ZOOM 2.75\n#define SUBSPHERE_RADIUS (SPHERE_RADIUS/SUBSPHERE_ZOOM)\n#define SUBSPHERE_CENTER_L vec3(-SUBSPHERE_RADIUS-0.001, 0.0, 0.0)\n#define SUBSPHERE_CENTER_R vec3( SUBSPHERE_RADIUS+0.001, 0.0, 0.0)\n\n#define Q_RADIUS (0.5*(SPHERE_RADIUS-SPHERE_BUFFER-2.0*SUBSPHERE_RADIUS)-0.001)\n\n// If we move to the \"left\" subsphere center infinitely many times, based on the\n// left subsphere transform (cf. makeTL) we end up at the following point:\n#define L_INF_X (SUBSPHERE_CENTER_L.x/(1.0+1.0/(SUBSPHERE_ZOOM*SUBSPHERE_ZOOM)))\n#define L_INF_POS vec3(L_INF_X, L_INF_X/SUBSPHERE_ZOOM, 0.0)\n\n// =============================================\n// Some generic helpers\n// =============================================\n\n// Find t so that mix(a,b,t) = x\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nfloat distsq(vec3 p, vec3 q) {\n    vec3 pq = q - p;\n    return dot(pq, pq);\n}\n\nmat4 getClipToWorld(float aspectWoverH, vec3 nvCamFw, vec3 nvCamFixedUp) {\n    mat4 clipToEye = mat4(\n        aspectWoverH * TAN_HALF_FOVY, 0.0, 0.0, 0.0,\n        0.0, TAN_HALF_FOVY, 0.0, 0.0,\n        0.0, 0.0,  0.0, (CAM_Z_NEAR - CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR),\n        0.0, 0.0, -1.0, (CAM_Z_NEAR + CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR)\n    );\n\n    vec3 nvCamRt = normalize(cross(nvCamFw, nvCamFixedUp));\n    vec3 nvCamUp = cross(nvCamRt, nvCamFw);\n    mat4 eyeToWorld = mat4(\n         nvCamRt, 0.0,\n         nvCamUp, 0.0,\n        -nvCamFw, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return eyeToWorld * clipToEye;\n}\n\nvoid computeLighting(\n    in float diffuseCoefficient,\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 lightColor,\n    in vec3 texColor,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam,\n    out vec3 litColor\n) {\n    float valDiffuse = max(0.0, dot(nvNormal, nvFragToLight));\n    valDiffuse *= diffuseCoefficient;\n\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    litColor = valDiffuse*texColor*lightColor + valSpecular*lightColor;\n}\n\nvoid sphereClip(\n    in vec3 center, in float radius,\n    in vec3 p, in vec3 v,\n    out vec2 tRange, out float didHit\n) {\n    // Solve quadratic in t: |p+tv - center|^2 = radius^2\n    // Or, |A+tB|^2 = 1, with A = (p-center)/radius, B = v/radius\n    // Solution: t = (-A.B +- sqrt(D))/|B|^2, D = (A.B)^2 + |B|^2 * (1-|A|^2).\n\n    vec3 A = (p - center) / radius;\n    vec3 B = v / radius;\n\n    float AA = dot(A,A);\n    float AB = dot(A,B);\n    float BB = dot(B,B);\n\n    float D = AB*AB + BB*(1.0 - AA);\n    float sqD = sqrt(abs(D));\n    didHit = 1.0 - step(D, 0.0);\n\n    float t0 = (-AB + sqD)/BB;\n    float t1 = (-AB - sqD)/BB;\n    tRange = vec2(min(t0,t1), max(t0,t1));\n}\n\n// =============================================\n// Recursive transform helpers\n// =============================================\n\n// Treats the bits of an integer as a stack, with\n// \"0\" meaning \"left branch\" and \"1\" meaning \"right branch\"\n\nvoid pushBranch(inout int branch, inout int branchDepth, int val) {\n    if (branchDepth == 0) {\n        branch = val;\n    } else {\n        branch = 2*branch + val;\n    }\n    branchDepth++;\n}\n\nint popBranch(inout int branch, inout int branchDepth) {\n    int b2 = branch % 2;\n    branch = (branch - b2) / 2;\n    branchDepth--;\n    return b2;\n}\n\nvoid makeTL(out mat3 transM, out mat3 transMInv, out vec3 transO) {\n    transM = SUBSPHERE_ZOOM*ROT_Z_INV;\n    transMInv = (1.0/SUBSPHERE_ZOOM)*ROT_Z;\n    transO = SUBSPHERE_CENTER_L;\n}\n\nvoid makeTR(out mat3 transM, out mat3 transMInv, out vec3 transO) {\n    transM = SUBSPHERE_ZOOM*ROT_X*ROT_Y;\n    transMInv = (1.0/SUBSPHERE_ZOOM)*ROT_Y_INV*ROT_X_INV;\n    transO = SUBSPHERE_CENTER_R;\n}\n\nvoid makeT(\n    in int branch, in int branchDepth,\n    out mat3 transM, out mat3 transMInv, out vec3 transO\n) {\n    transMInv = ID_3X3;\n    transM = ID_3X3;\n    transO = vec3(0.0);\n\n    int b = branch;\n    for (int i=0; i<branchDepth; i++) {\n        int b2 = b % 2;\n\n        mat3 curM;\n        mat3 curMInv;\n        vec3 curO;\n\n        if (b2 == 0) {\n            makeTL(curM, curMInv, curO);\n        } else {\n            makeTR(curM, curMInv, curO);\n        }\n\n        transM = transM * curM;\n        transMInv = curMInv * transMInv;\n        transO = curO + curMInv*transO;\n\n        b = (b - b2) / 2;\n    }\n}\n\n// =============================================\n// \"Object\" helpers\n// =============================================\n\n// circT maps circle in xy plane to desired circle:\n// i.e., mat3(\"zero angle direction\", \"90 degrees direction\", circ plane normal)\n// and circTInv is the transpose\n// uvAng is (theta,phi) where theta is 0 in the \"zero angle direction\"\nvoid cpCirc(\n    in vec3 circCenter, in float circRadius,\n    in mat3 circT, in mat3 circTInv, in vec3 p,\n    out vec3 cp, out vec2 uvAng\n) {\n    vec3 v = circTInv*(p - circCenter);\n\n    vec3 vProj = vec3(v.xy, 0.0);\n    float vProjLen = length(v.xy);\n    vec3 cpT = (circRadius/vProjLen)*vProj;\n\n    uvAng = vec2(\n        atan(v.y, v.x),\n        atan(v.z, vProjLen-circRadius)\n    );\n    cp = circT*cpT + circCenter;\n}\n\nvec3 cpTuple2(vec3 q0, vec3 q1, vec3 p) {\n    vec3 q = q0;\n    return mix(q, q1, step( distsq(p,q1), distsq(p,q) ));\n}\n\nfloat radiusMultiplier(vec2 uvAng, float maxAngle) {\n    float rt = abs(uvAng.s)/maxAngle;\n    return mix(1.0, 1.0/SUBSPHERE_ZOOM, smoothstep(0.4, 0.9, rt));\n}\n\nvec2 uvAng_to_uv(vec2 uvAng, float maxAngle) {\n    return vec2(\n        unmix(-maxAngle, maxAngle, uvAng.s),\n        unmix(-ONE_PI, ONE_PI, uvAng.t)\n    );\n}\n\nvoid sdBaseUV(in vec3 p, out vec3 uv, out float sd) {\n    // ---------------------------------------------------\n    // Basic geometry piece is a circle which hits 3 points:\n    // - (-x0,   0 ): Q_RADIUS from the left-most edge of main sphere\n    // - ( x1, +-y1): Top and bottom of right subsphere\n\n    const float x0 = SPHERE_RADIUS-SPHERE_BUFFER - Q_RADIUS;\n    const float x1 = SUBSPHERE_CENTER_R.x;\n    const float y1 = x0/SUBSPHERE_ZOOM;\n    float linkCenter = (x1-x0)/2.0 + (y1/2.0)*(1.0/(x0+x1)) * y1;\n    float linkRadius = x0 + linkCenter;\n    float maxAngle = atan(y1, -(x1 - linkCenter));\n    // ---------------------------------------------------\n\n    // \"Left\" link (in xz-plane):\n    vec3 cpL;\n    vec2 uvAngL;\n    cpCirc(\n        vec3(linkCenter,0.0,0.0), linkRadius,\n        mat3(-E1,E3,E2), mat3(-E1,E3,E2), p, cpL, uvAngL\n    );\n    float dsqL = distsq(p, cpL);\n\n    // \"Right\" link (in xy-plane):\n    vec3 cpR;\n    vec2 uvAngR;\n    cpCirc(\n        vec3(-linkCenter,0.0,0.0), linkRadius,\n        mat3(E1,E2,E3), mat3(E1,E2,E3), p, cpR, uvAngR\n    );\n    float dsqR = distsq(p, cpR);\n\n    // \"Parent\" link: right-link with inv. left-transform applied (or reverse!)\n    mat3 transLM;\n    mat3 transLMInv;\n    vec3 transLO;\n    makeTL(transLM, transLMInv, transLO);\n\n    vec3 pT = transLMInv*p + transLO;\n    vec3 cpP;\n    vec2 uvAngP;\n    cpCirc(\n        vec3(-linkCenter,0.0,0.0), linkRadius,\n        mat3(E1,E2,E3), mat3(E1,E2,E3), pT, cpP, uvAngP\n    );\n    float cull = step( maxAngle, abs(uvAngP.s) );\n    cpP = mix( cpP, cpTuple2(vec3(-x1,-y1,0.0), vec3(-x1,y1,0.0), pT), cull );\n    cpP = transLM*(cpP - transLO);\n    float dsqP = distsq(p, cpP);\n\n    float hitRadius = Q_RADIUS;\n    if (dsqP < dsqL && dsqP < dsqR) {\n        // NOTE: uv.p is used to correct the smoothBranchDepth elsewhere\n        uv = vec3(uvAng_to_uv(uvAngP, maxAngle), 1.0);\n        hitRadius *= SUBSPHERE_ZOOM;\n        sd = distance(p, cpP) - hitRadius * radiusMultiplier(uvAngP, maxAngle);\n    } else if (dsqL < dsqR) {\n        uv = vec3(uvAng_to_uv(uvAngL, maxAngle), 0.0);\n        sd = distance(p, cpL) - hitRadius * radiusMultiplier(uvAngL, maxAngle);\n    } else {\n        uv = vec3(uvAng_to_uv(uvAngR, maxAngle), 0.0);\n        sd = distance(p, cpR) - hitRadius * radiusMultiplier(uvAngR, maxAngle);\n    }\n}\n\nvoid objNormal(in vec3 p, out vec3 hitNormal) {\n    float fXA, fXB, fYA, fYB, fZA, fZB;\n    vec3 uv;\n\n    sdBaseUV(p - vec3(GRAD_EPS, 0.0, 0.0), uv, fXA);\n    sdBaseUV(p + vec3(GRAD_EPS, 0.0, 0.0), uv, fXB);\n    sdBaseUV(p - vec3(0.0, GRAD_EPS, 0.0), uv, fYA);\n    sdBaseUV(p + vec3(0.0, GRAD_EPS, 0.0), uv, fYB);\n    sdBaseUV(p - vec3(0.0, 0.0, GRAD_EPS), uv, fZA);\n    sdBaseUV(p + vec3(0.0, 0.0, GRAD_EPS), uv, fZB);\n\n    hitNormal = vec3(fXB-fXA, fYB-fYA, fZB-fZA);\n}\n\nvoid hitObject(\n    in vec3 p, in vec3 nv, in vec2 tRange,\n    out float didHit, out float tHit, out vec3 uvHit\n) {\n    didHit = 0.0;\n    vec3 curPos = p + tRange.s*nv;\n    tHit = tRange.s;\n\n    for (int i=0; i<50; i++) {\n        float tAdd;\n        sdBaseUV(curPos, uvHit, tAdd);\n\n        if (abs(tAdd) < MIN_DIST) {\n            didHit = 1.0;\n            break;\n        }\n\n        curPos += tAdd * nv;\n        tHit += tAdd;\n\n        if (tHit > tRange.t) {\n            break;\n        }\n    }\n}\n\n// =============================================\n// Recursive scene\n// =============================================\n\nfloat inInterval(float t, vec2 tRange) {\n    return step(tRange.s, t) * (1.0 - step(tRange.t, t));\n}\n\nvec2 minHitData(float t, vec2 minData, vec2 tRangeAllowed, float typeId) {\n    float doUse = inInterval(t, tRangeAllowed) * step(t, minData.x);\n    return mix( minData, vec2(t, typeId), doUse );\n}\n\nvoid march(\n    in vec3 p, in vec3 nv,\n    out float didHit, out vec3 hitPos,\n    out vec3 nvHitNormal, out vec3 hitUV, out int hitBranchDepth\n) {\n    // Update range for root sphere\n    vec2 tRangeRoot;\n    float didHitSphere;\n    sphereClip(SPHERE_CENTER, SPHERE_RADIUS, p, nv, tRangeRoot, didHitSphere);\n    if (didHitSphere < 0.5) {\n        didHit = 0.0;\n        return;\n    }\n\n    // transform is p \\mapsto M(p - O)\n    mat3 transMInv = ID_3X3;\n    mat3 transM = ID_3X3;\n    vec3 transO = vec3(0.0);\n\n    vec3 pTransRay = p;\n    vec3 nvTransRay = nv;\n    vec2 tRangeCur = tRangeRoot;\n\n    int branchDepth = 0;\n    int branch = -1;\n\n    for (int i=0; i<100; i++) { // TODO\n\n        vec2 hitData = vec2(tRangeCur.t, 0.0);\n\n        // Check object hit within sphere\n        float didHitObject;\n        float tHitObject;\n        vec3 uvHitObject;\n        hitObject(\n            pTransRay, nvTransRay, vec2(max(0.0, tRangeCur.s), tRangeCur.t),\n            didHitObject, tHitObject, uvHitObject\n        );\n        if (didHitObject > 0.5) {\n            hitData = minHitData(tHitObject, hitData, tRangeCur, 0.1);\n        }\n\n        // Check \"left\" subsphere hit\n        vec2 tRangeSubsphereL;\n        float didHitL;\n        sphereClip(\n            SUBSPHERE_CENTER_L, SUBSPHERE_RADIUS, pTransRay, nvTransRay,\n            tRangeSubsphereL, didHitL\n        );\n        if (branchDepth < MAX_BRANCH_DEPTH && didHitL > 0.5) {\n            hitData = minHitData(tRangeSubsphereL.s, hitData, tRangeCur, 0.2);\n        }\n\n        // Check \"right\" subsphere hit\n        vec2 tRangeSubsphereR;\n        float didHitR;\n        sphereClip(\n            SUBSPHERE_CENTER_R, SUBSPHERE_RADIUS, pTransRay, nvTransRay,\n            tRangeSubsphereR, didHitR\n        );\n        if (branchDepth < MAX_BRANCH_DEPTH && didHitR > 0.5) {\n            hitData = minHitData(tRangeSubsphereR.s, hitData, tRangeCur, 0.3);\n        }\n\n        if (hitData.y < 0.05) {\n\n            // Exiting sphere: \"pop\" transform to parent sphere\n\n            if (branchDepth == 0) {\n                break;\n            }\n            popBranch(branch, branchDepth);\n            makeT(branch, branchDepth, transM, transMInv, transO);\n\n            pTransRay = transM * (p - transO);\n            nvTransRay = normalize( transM * nv );\n\n            vec2 tRangeParent;\n            float didHitSphereParent;\n            sphereClip(\n                SPHERE_CENTER, SPHERE_RADIUS, pTransRay, nvTransRay,\n                tRangeParent, didHitSphereParent\n            );\n            tRangeCur = vec2(tRangeCur.t/SUBSPHERE_ZOOM, tRangeParent.t);\n\n        } else if (hitData.y < 0.15) {\n\n            // Hit object--done!\n\n            didHit = 1.0;\n            vec3 hitPosTrans = pTransRay + tHitObject*nvTransRay;\n            hitPos = transMInv*hitPosTrans + transO;\n\n            vec3 hitNormal;\n            objNormal(hitPosTrans, hitNormal);\n            nvHitNormal = normalize(transMInv*hitNormal);\n\n            hitUV = uvHitObject;\n            hitBranchDepth = branchDepth;\n\n            break;\n\n        } else if (hitData.y < 0.25) {\n\n            // Entered \"left\" subsphere; push transform and continue\n\n            pushBranch(branch, branchDepth, 0);\n            makeT(branch, branchDepth, transM, transMInv, transO);\n\n            pTransRay = transM * (p - transO);\n            nvTransRay = normalize( transM * nv );\n            tRangeCur = tRangeSubsphereL * SUBSPHERE_ZOOM;\n\n        } else if (hitData.y < 0.35) {\n\n            // Entered \"right\" subsphere; push transform and continue\n\n            pushBranch(branch, branchDepth, 1);\n            makeT(branch, branchDepth, transM, transMInv, transO);\n\n            pTransRay = transM * (p - transO);\n            nvTransRay = normalize( transM * nv );\n            tRangeCur = tRangeSubsphereR * SUBSPHERE_ZOOM;\n\n        }\n    }\n\n}\n\nvoid camConfig(\n    out float scfa,\n    out vec3 camPos,\n    out vec3 nvCamFw,\n    out vec3 nvCamFixedUp\n) {\n    float itAdj = iTime/3.0;\n    if (iMouse.z > 0.0) {\n        itAdj = 12.0*iMouse.y/iResolution.y;\n    }\n    float ft4 = fract(itAdj/4.0)*4.0;\n\n    // scfa is the scale factor at the current cam pos: how much things are\n    // scaled relative to the \"base object\" in the root/parent sphere\n    scfa = pow(1.0/SUBSPHERE_ZOOM, ft4+2.0);\n\n    float ct = cos(itAdj*HALF_PI);\n    float st = sin(itAdj*HALF_PI);\n\n    vec3 camOffset = normalize(vec3(1.0, 1.5*ct, 1.0));\n    camPos = L_INF_POS + camOffset*scfa;\n    nvCamFw = normalize(-camOffset);\n    nvCamFixedUp = normalize(vec3(cos(0.5*ct), 0.0, sin(0.5*ct)));\n}\n\nvec3 skybox(vec3 nvDir) {\n    float sep = -0.15;\n    float blend = 0.025;\n    return mix(\n        mix(vec3(1.0), vec3(0.8, 0.45, 0.25), unmix(-1.0, sep, nvDir.x)),\n        mix(vec3(1.0), vec3(0.7, 0.6, 1.0), unmix(sep, 1.0, nvDir.x)),\n        smoothstep(sep-blend, sep+blend, nvDir.x)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float scfa;\n    vec3 camPos;\n    vec3 nvCamFw;\n    vec3 nvCamFixedUp;\n    camConfig(scfa, camPos, nvCamFw, nvCamFixedUp);\n\n    float aspectWoverH = iResolution.x/iResolution.y;\n    mat4 clipToWorld = getClipToWorld(aspectWoverH, nvCamFw, nvCamFixedUp);\n\n    vec4 vWorld = clipToWorld * vec4(uv*2.0 - 1.0, 1.0, 1.0);\n    vec3 nvCamDir = normalize(vWorld.xyz / vWorld.w);\n\n    vec4 color = vec4(1.0);\n\n    float didHit;\n    vec3 hitPos;\n    vec3 nvHitNormal;\n    vec3 hitUV;\n    int hitBranchDepth;\n    march(camPos, nvCamDir, didHit, hitPos, nvHitNormal, hitUV, hitBranchDepth);\n    if (didHit > 0.5) {\n\n        vec3 nvCamRt = normalize(cross(nvCamFw, nvCamFixedUp));\n        vec3 nvCamUp = normalize(cross(nvCamRt, nvCamFw));\n        vec3 lightPos = mix(camPos, L_INF_POS, 0.5);\n\n        float smoothBranchDepth = (\n            float(hitBranchDepth) + 2.0*abs(hitUV.s - 0.5) - hitUV.p\n        );\n        float ct = fract(smoothBranchDepth/4.0);\n        float ctt = fract(-0.2*iTime + smoothBranchDepth/4.0);\n        vec3 matColor = 0.5 + 0.5*vec3(\n            cos(TWO_PI * ct),\n            cos(TWO_PI * (ct - 1.0/3.0)),\n            cos(TWO_PI * (ct - 2.0/3.0))\n        );\n        float pulse = 1.0 - step(0.25+0.25*sin(iTime), abs(ctt-0.5));\n        matColor = mix(matColor, vec3(0.0), pulse);\n\n        vec3 nvFragToCam = normalize(camPos - hitPos);\n        vec3 nvFragToLight = normalize(lightPos - hitPos);\n\n        vec3 litColor;\n        computeLighting(\n            0.8, 1.0, 50.0,\n            vec3(1.0), matColor, nvHitNormal,\n            nvFragToLight,\n            nvFragToCam,\n            litColor\n        );\n\n        vec3 nvRefl = normalize(reflect( hitPos-camPos, nvHitNormal ));\n        vec3 skyColor = skybox(nvRefl);\n\n        vec3 finalColor = litColor;\n        finalColor += 0.4*skyColor; //reflective\n        finalColor += 0.25*matColor; //emissive\n        finalColor = clamp(finalColor, 0.0, 1.0);\n\n        float dScale = length(hitPos-camPos)/length(L_INF_POS-camPos);\n        float dVal = clamp( unmix(0.0, 20.0, dScale), 0.0, 1.0 );\n        float dA = 100.0; // higher gives more detail on nearer values\n        float finalDepth = log(dA*dVal+1.0)/log(dA+1.0);\n\n        color = vec4(finalColor, finalDepth);\n\n    }\n\n    fragColor = color;\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyGzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 177, 177, 223], [225, 225, 304, 304, 454], [456, 456, 499, 499, 1088], [1090, 1090, 1145, 1145, 1757]], "test": "untested"}
{"id": "wlGGWG", "name": "Ashanoha", "author": "coposuke", "description": "traning. 麻の葉", "tags": ["pattern", "japanese", "traning", "cineshader"], "likes": 62, "viewed": 28072, "published": 3, "date": "1579844164", "time_retrieved": "2024-07-30T21:29:03.957448", "image_code": "#define PI  \t3.14159265357989\n#define TAU \t(PI * 2.0)\n#define HEX_COS (0.86602540378443 * 0.5)\n#define HEX_TAN (0.57735026918962 * 0.5)\n\n\nstruct Animation\n{\n    float screenAngle;\n    float screenScale;\n    vec2  screenOffset;\n    float lineWidth;\n    float lineColorOffset;\n    float meshColorOffset;\n    float meshColorDist;\n    float lightAngle;\n    float blendLine;\n    float blendSolid;\n    float blendMesh;\n};\n\n\nmat2 rotate(float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec2 pmod(vec2 pos, float num, out float id)\n{\n    float angle = atan(pos.x, pos.y) + PI / num;\n    float split = TAU / num;\n    id = floor(angle / split);\n\tangle = id * split;\n    return rotate(-angle) * pos;\n}\n\nfloat cubicInOut(float time)\n{\n  return (time < 0.5) ? (4.0 * time * time * time) : (1.0 - 4.0 * pow(1.0 - time, 3.0));\n}\n\n// for line\nvoid map(vec2 uv, out vec3 near, out vec3 neighbor)\n{\n    vec2 point;\n    near = vec3(1e+4);\n\n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.25);\n        float dist = distance(uv, point);\n        near = near.z < dist ? near : vec3(point, dist);\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            for(float both=-1.0; both<=1.0; both+=2.0)\n            {\n                point = vec2(x * 0.125, HEX_COS + y * HEX_COS * 0.5);\n                point.x += both * 0.5     * 0.125 * -x;\n                point.y += both * HEX_TAN * 0.125 * -y;\n                float dist = distance(uv, point);\n                near = near.z < dist ? near : vec3(point, dist);\n            }\n        }\n    }\n    \n    neighbor = vec3(1e+4);\n    \n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.25);\n        if(near.xy != point)\n        {\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            for(float both=-1.0; both<=1.0; both+=2.0)\n            {\n                point = vec2(x * 0.125, HEX_COS + y * HEX_COS * 0.5);\n                point.x += both * 0.5     * 0.125 * -x;\n                point.y += both * HEX_TAN * 0.125 * -y;\n                \n                if(near.xy != point)\n                {\n                    vec2 center = (point + near.xy) * 0.5;\n                    float dist = dot(uv - center, normalize(near.xy - point));\n                    neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n                }\n            }\n        }\n    }\n}\n\n// for normal\nvec4 normalmap(vec2 uv)\n{\n    vec2 point = vec2(0);\n    vec3 near = vec3(1e+4);\n    vec3 neighbor = vec3(1e+4);\n    \n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.5);\n        float dist = distance(uv, point);\n        near = near.z < dist ? near : vec3(point, dist);\n    }\n    \n\tfor(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.5);\n        if(near.xy != point)\n        {\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            point = vec2(x * 0.25, HEX_COS - y * (HEX_COS - HEX_TAN * 0.5));\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    return vec4(normalize(vec3(neighbor.xy - near.xy, 1.0)), neighbor.z);\n}\n\nvoid animate(float time, vec2 uv, inout Animation anim)\n{\n    float animLoop = floor(floor(time) / 13.0);\n    float animType = mod(floor(time), 13.0);\n    float animTime = fract(time);\n    float clockwise = mod(animLoop, 2.0) <= 0.0 ? 1.0 : -1.0;\n    \n    anim.screenScale = 2.0;\n    anim.screenAngle = PI * 0.166667;\n    anim.screenOffset= vec2(0, 0);\n    anim.lineWidth   = 0.01;\n    anim.lineColorOffset = 0.0;\n    anim.meshColorOffset = 0.0;\n    anim.meshColorDist = 200.0;\n    anim.lightAngle = 0.0;\n    anim.blendLine = 0.0;\n    anim.blendMesh = 0.0;\n    anim.blendSolid = 0.0;\n    \n    if(animType <= 0.0)\n    {\n        anim.screenScale = cubicInOut(animTime) * 1.0 + 1.0;\n    \tanim.lineWidth   = cubicInOut(1.0 - animTime) * 0.4 + 0.01;\n    \tanim.lineColorOffset = animTime;\n    \tanim.blendLine = 1.0;\n    }\n    else if(animType <= 1.0)\n    {\n        anim.screenScale -= animTime * 0.02;\n    \tanim.lineColorOffset = PI * 2.0 * animTime;\n    \tanim.blendLine = 1.0;\n    }\n    else if(animType <= 2.0)\n    {\n        anim.screenScale -= animTime * 0.02 + 0.02;\n    \tanim.lineColorOffset = PI * 2.0 * animTime;\n        anim.meshColorOffset = PI * 3.0 * animTime;\n    \tanim.blendLine = smoothstep(1.0, 0.0, animTime);\n    \tanim.blendMesh = smoothstep(0.0, 1.0, animTime);\n    }\n    else if(animType <= 3.0)\n    {\n        anim.screenScale -= animTime * 0.02 + 0.04;\n        anim.meshColorOffset = PI * 3.0 * animTime + PI;\n    \tanim.meshColorDist = smoothstep(1.0, 0.2, animTime) * 200.0;\n   \t \tanim.lightAngle  = PI * 2.0 * time;\n    \tanim.blendMesh = smoothstep(0.8, 0.2, animTime);\n    \tanim.blendSolid = smoothstep(0.0, 1.0, animTime);\n    }\n    else if(animType <= 4.0)\n    {\n        anim.screenScale -= animTime * 0.02 + 0.06;\n    \tanim.blendSolid = 1.0;\n    }\n    else if(animType <= 10.0)\n    {\n        animTime += animType - 5.0;\n        anim.screenScale -= clamp(animTime * 0.02 + 0.08, 0.0, 0.1);\n        animTime /= 11.0 - 5.0;\n        anim.screenAngle += smoothstep(0.0, 1.0, animTime) * PI * 0.5 * clockwise;\n        \n        uv = rotate(PI * 2.0 * animTime * clockwise) * uv;\n        float pos = abs(uv.x + 0.0) + animTime;\n        float blend = smoothstep(-0.1, 0.0, sin(pos * PI * 3.0 * sin(animTime * PI)));\n    \tanim.blendSolid = blend;\n        anim.blendLine = 1.0 - blend;\n    \tanim.lineColorOffset = PI * 2.0 * animTime;\n    }\n    else if(animType <= 11.0)\n    {\n        anim.screenScale -= 0.1;\n        anim.screenAngle += PI * 0.5 * clockwise;\n        anim.lightAngle += PI * 2.0 * animTime;\n    \tanim.blendSolid = 1.0;\n    }\n    else if(animType <= 12.0)\n    {\n        anim.screenScale -= 0.1;\n        anim.screenAngle += PI * 0.5 * clockwise;\n        anim.lightAngle += PI * 2.0 * animTime;\n\n        float lineTime = (sin(animTime * PI * 3.0 - PI * 0.5) * 0.5 + 0.5);\n        lineTime = lineTime * lineTime * (animTime - (uv.x * uv.y * 0.2));\n        anim.lineWidth = clamp(lineTime, 0.0, 1.0) * 0.5;\n        anim.blendLine = 1.0;\n    \tanim.blendSolid = 1.0;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n \n    // animation\n    Animation anim;\n    animate(iTime, uv, anim);\n    \n    // view\n    uv *= anim.screenScale;\n    uv += anim.screenOffset;\n    uv = rotate(anim.screenAngle) * uv;\n\n    // tiling\n    vec2 uvLocal = uv;\n    uvLocal.x = mod(uv.x, 1.0) - 0.5;\n    uvLocal.y = mod(uv.y, HEX_COS * 2.0) - HEX_COS;\n    \n    // rot tiling\n    float id;\n    uvLocal = pmod(uvLocal, 6.0, id);\n\n    // scene\n    vec3 near, neighbor;\n    map(uvLocal, near, neighbor);\n    \n    // lighting\n    vec4 normal = normalmap(uvLocal);\n    normal.xy = rotate(id * PI / 3.0) * normal.xy;\n    float dist = normal.w;\n    dist = 1.0 - pow(1.0 - dist, 20.0);\n\n    vec3 lightDir = normalize(vec3(rotate(anim.lightAngle) * vec2(1,0), 0.25));\n    float light = dot(normal.xyz, lightDir) * 0.8 + 0.2;\n    \n    // draw\n    float lineWidth = (1.0 - smoothstep(0.0, anim.lineWidth, neighbor.z));\n    vec3 lineColor = cos(vec3(0,2,4) * PI / 3.0 + anim.lineColorOffset) * 0.25 + 1.0;\n    vec3 meshColor = cos(vec3(0,2,4) * PI / 3.0 + anim.meshColorOffset + anim.meshColorDist * neighbor.z) * 0.35 + 0.65;\n    float solid = (dist * light) * 0.6 + 0.2;\n    solid = 1.0 - pow(1.0 - solid, 3.0);\n    \n    fragColor.rgb = vec3(0);\n    fragColor.rgb = mix(fragColor.rgb, vec3(solid), anim.blendSolid);\n    fragColor.rgb = mix(fragColor.rgb, lineColor, lineWidth * anim.blendLine);\n    fragColor.rgb = mix(fragColor.rgb, meshColor, anim.blendMesh);\n    \n    // degamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n    \n    // displacement\n    fragColor.a = mix(0.0, normal.w * 4.0, anim.blendSolid);\n    \n    // debug\n    //fragColor.gb = vec2(0);\n    //fragColor.r = 1.0 - pow(1.0 - near.z, 5.0);\n    //fragColor.r = neighbor.z * 10.0;\n    //fragColor.r = normal.w * 7.0;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Ashanoha\",\n\t\"description\": \"soundproof cushion\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[418, 418, 444, 444, 518], [520, 520, 566, 566, 731], [733, 733, 763, 763, 854], [856, 868, 921, 921, 2739], [2741, 2755, 2780, 2780, 3895], [3897, 3897, 3954, 3954, 6890], [6893, 6893, 6950, 6950, 8787]], "test": "untested"}
{"id": "wlV3DG", "name": "Game of Colors", "author": "BackwardsCap", "description": "A basic game of life simulation where the colors mix over time\nClick to add more agents of a random color\nPress Space to see behind the curtain\nPress R to restart the simulation\nPress C to clear the simulation, provides a blank slate for drawing", "tags": ["life", "life", "conway", "gameoflife"], "likes": 12, "viewed": 609, "published": 3, "date": "1579810694", "time_retrieved": "2024-07-30T21:29:04.944808", "image_code": "void mainImage( out vec4 c, in vec2 f )\n{\n    vec2 uv = f/iResolution.xy;\n    vec4 t = S1(uv), s = S0(uv);\n    c = texelFetch( iChannel2, ivec2(32,0),0).x>0. ? s : (pow(t,vec4(.15)))*pow(normalize(t)*1.3,vec4(7.0));\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 c, in vec2 f )\n{\n    vec2 uv = f/iResolution.xy;\n    \n    float s = S0(uv).r;\n    \n    //inspired by https://www.shadertoy.com/view/ld3Sz7\n    //reset on frame 0/when the user presses R\n    if(iFrame < 1 || texelFetch( iChannel1, ivec2(82,0),0).x>0.)\n    {\n        c = sign(vec4(rand(uv))-.5);\n    }\n    else if(texelFetch( iChannel1, ivec2(67,0),0).x>0.)\n    {\n        c=vec4(0);\n    }\n    else\n    {\n        if(iMouse.z>0.&&distance(iMouse.xy,f)<15.&&rand(f)>.75 ) c=vec4(1.);\n        else\n        {\n            //sample how many neighbors we have\n            float n =  N(-1, -1) + N(-1, 0) + N(-1, 1) +\n                       N(0,-1)   +            N(0, 1) +\n                       N(1,-1)   + N(1, 0)  + N(1, 1);\n\n            //if we are dead and have 3 neighbors we resurrect\n            if(s<=0.&&n==3.0)s=1.0;\n\n            //kill if we don't have 3 or 2 neighbors\n            if(n!=2.0&&n!=3.0)s*=0.;\n\n            //fade as it ages\n            if(s>0.2)s-=0.01;\n\n            //set the current pixel\n            c = vec4(vec3(s), 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 c, in vec2 f )\n{\n    vec2 uv = f/iResolution.xy;\n    \n    vec4 s = S1(uv);\n    \n    if(iFrame < 1 || texelFetch( iChannel2, ivec2(82,0),0).x>0.)\n    {\n        c = pow(randColor(uv),vec4(10.));\n    }\n    else\n    {        \n        //sample around our pixel to figure out what color we will become\n        vec3[] samp = vec3[](C(-1,0), C(1,0), C(0,1), C(0,-1),\n                             C(-1,1), C(1,1), C(1,-1), C(-1,-1));\n        vec3 a = vec3(0), m = S0(uv).rgb;\n        \n        if(iMouse.z>0.&&distance(iMouse.xy,f)<15.&&rand(f)>.75 ) a=randColor(uv).rgb;\n        \n        float d = 0.;\n        \n        for(int i=0;i<8;i++)\n        {\n            d++;\n            a+= samp[i];\n        }\n\n        a/=d;\n        \n        if(s.r>0.&&length(m)<3.)\n        {\n            a+=m;\n        }\n        \n        c = length(m)<99999. ? vec4(a*(s.rgb+.755), 1.0) : vec4(a,1.0);\n    \n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//change i,j into thhe corresponding movement in our coordinate space\n#define R(i,j) vec2(i,j)*vec2(1.0/iResolution.xy)\n//sample in the direction i,j from our current uv position\n#define T(i,j) S0((uv + R(i,j))).r\n//retrieve color from neighboring pixel\n#define C(i,j) S0((uv + R(i,j))).rgb\n//checks if the neighbor is alive\n#define N(i,j) float( T(i,j) > 0.)\n//sample a texture\n#define S0(i) texture(iChannel0, fract(i))\n#define S1(i) texture(iChannel1, fract(i))\n\nfloat rand (vec2 p)\n{\n    return fract(sin(dot(p.xy,vec2(12389.1283,8941.1283)))*(12893.128933+iDate.w));\n}\n\nvec4 randColor(vec2 p)\n{\n    float c = rand(p);\n    float r = float(.5 < rand(p+vec2(-.5,-.5)));\n    float g = float(.5 < rand(p+vec2(.5,.5)));\n    float b = float(.5 > rand(p+vec2(-1.,1.)));\n    \n    return vec4(c*r, c*g, c*b, 1.0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlV3DG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 217]], "test": "untested"}
{"id": "tlV3Wy", "name": "Emissive Effect", "author": "yasuo", "description": "Emissive Effect with Japanease traditional textile", "tags": ["reflection", "emission"], "likes": 12, "viewed": 511, "published": 3, "date": "1579807574", "time_retrieved": "2024-07-30T21:29:05.827448", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 25.\n#define SURF_DIST .01\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) 1.0-smoothstep(b,antialiasing(1.0),d)\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// Try to add a glow color to the model, depending on the world position.\nvec3 emitColor(vec3 p, vec3 emitPos, vec3 emitColor, float radius, float softness, float brightness) {\n    float c = smoothstep(-softness,softness,-(length(p-emitPos)-radius));\n    emitColor = (emitColor*c)*brightness;\n    return emitColor;\n}\n\nfloat linear(float t) {\n  return t;\n}\n\n// A smart way to control the animation. function is from \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\nfloat animscene(in float t, float w, float s) {\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nvec4 Layer1(vec3 p,  float z, float speed, float dir, mat3 rot) {\n    p.z += iTime*3.0;\n    p.z += z;\n    p.z = mod(p.z,9.0)-4.5;\n    \n    p *= rot*matRotateX(radians(30.0*dir))*matRotateY(radians(40.0*dir));\n    p.y+=1.25;\n    \n    float y = 0.25;\n    \n    // box\n    float b = sdBox(p-vec3(0.0,1.0+y,0.0),vec3(1.5,2.5,0.2));\n    float b2 = sdBox(p-vec3(0.0,1.0+y,0.0),vec3(1.2,2.2,0.3));\n\n    float animTime = mod(iTime,speed*4.0);\n    float ey = 0.0;\n    ey += linear(animscene(animTime, 0.0, speed))*5.0;\n    ey += linear(animscene(animTime, speed*2.0, speed))*-5.0;\n    \n    float ex = 0.0;\n    ex += linear(animscene(animTime, speed, speed))*2.6;\n    ex += linear(animscene(animTime, speed*3.0, speed))*-2.6;\n    \n    vec3 emitPos = vec3((1.3*dir)-(ex*dir),1.25+(2.5-ey),0.0);\n    vec3 ecol = emitColor(p,emitPos, vec3(0.0,0.7,0.8),0.02,0.9,5.0);\n    \n    float d = max(-b2,b);\n    if(dir == 1.0){\n    \tp *= matRotateZ((z == 6.0) ?radians(30.0):radians(-30.0));\n\t\td = (z == 6.0) ?max(-p.y+0.5,max(-b2,b)):max(p.y-1.5,max(-b2,b));\t\n    }\n    \n    vec4 res = vec4(vec3(0.8)+ecol,d);\n    return res;\n}\n\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    float _floor = p.y;\n    \n    vec4 layer1 = Layer1(p,0.0,0.5,1.0,matRotateZ(radians(iTime*50.0)));\n    vec4 layer2 = Layer1(p,3.0,1.0,-1.0,matRotateZ(radians(iTime*-60.0)));\n    vec4 layer3 = Layer1(p,6.0,1.5,1.0,matRotateZ(radians(iTime*70.0)));\n\tvec4 layers = combine(layer1,combine(layer2,layer3));\n\n    return layers;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nfloat GetAmbientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - RayMarch(p + n*d,n).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n\n    float ao = GetAmbientOcclusion(p,n);\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif*ao),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nfloat typoNine(vec2 p) {\n    float c0 = sdUnevenCapsule(p*Rot(radians(90.0)),0.15,0.15,0.14);\n    float c1 = sdUnevenCapsule(p*Rot(radians(90.0)),0.07,0.07,0.14);\n    float cut0 = dBox2d((p+vec2(-0.26,-0.04))*Rot(radians(20.0)),vec2(0.08,0.08));\n    float cut1 = dBox2d(p+vec2(-0.32,0.1),vec2(0.2,0.1));\n    float c2 = length(p+vec2(-0.12,0.11))-0.04;\n    float topC = min(max(-cut1,max(-cut0,max(-c1,c0))),c2);\n    \n    vec2 btmP = vec2(0.1,0.11);\n    c0 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.15,0.15,0.22);\n    c1 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.07,0.07,0.22);\n    c2 = length(p+btmP+vec2(-0.1,-0.11))-0.04;\n    cut0 = dBox2d((p+vec2(-0.05,0.2)),vec2(0.08,0.08));\n    float btmC = max(-cut0,min(max(-p.x-btmP.x+0.1,max(-c1,c0)),c2));\n    \n    return min(topC,btmC);\n}\n\nvec3 jpTraditionalTex(vec2 p, vec3 col, vec3 lcol) {\n    p.y -= iTime*0.1;\n    p*=1.5;\n    p = mod(p,0.4)-0.2;\n\n    \n    float len = 0.2;\n    float len2 = 0.15;\n    float l = sdLine(p,vec2(-len,-len),vec2(len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len,len),vec2(len,-len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(0.0,len),vec2(0.0,-len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len,0.0),vec2(len,0.0));\n\tcol = mix(col,lcol,S(l,0.0));\n    \n\tl = sdLine(p,vec2(-len*0.3,-len2),vec2(len*0.3,len2));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(-len*0.7,-len2*0.4),vec2(len*0.7,len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len*0.3,len2),vec2(len*0.3,-len2));\n\tcol = mix(col, lcol,S(l,0.0));    \n    l = sdLine(p,vec2(-len*0.7,len2*0.4),vec2(len*0.7,-len2*0.4));\n\tcol = mix(col,lcol,S(l,0.0));\n    \n\tl = sdLine(p,vec2(0.0,len),vec2(len*0.3,len2));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(0.0,len),vec2(-len*0.3,len2));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(0.0,-len),vec2(len*0.3,-len2));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(0.0,-len),vec2(-len*0.3,-len2));\n\tcol = mix(col, lcol,S(l,0.0));\n    \n\tl = sdLine(p,vec2(len,0.0),vec2(len*0.7,len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(len,0.0),vec2(len*0.7,-len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(-len,0.0),vec2(-len*0.7,len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(-len,0.0),vec2(-len*0.7,-len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n    \n    l = sdLine(p,vec2(len*0.3,len2),vec2(len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(len*0.7,len2*0.4),vec2(len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len*0.3,-len2),vec2(-len,-len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len*0.7,-len2*0.4),vec2(-len,-len));\n\tcol = mix(col, lcol,S(l,0.0));    \n    \n\tl = sdLine(p,vec2(-len*0.3,len2),vec2(-len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len*0.7,len2*0.4),vec2(-len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(len*0.3,-len2),vec2(len,-len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(len*0.7,-len2*0.4),vec2(len,-len));\n\tcol = mix(col, lcol,S(l,0.0));      \n    \n    return col;\n}\n\nvec3 bg(vec2 p){\n    float d = smoothstep(0.0,0.2,p.y-sin(iTime*0.5)*0.5);\n  \tvec3 col = vec3(d);\n\tcol = mix(vec3(0.0,0.2,0.3), vec3(0.0,0.05,0.1),d);\n    \n\tcol = jpTraditionalTex(p,col,vec3(0.5));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec2 uvref = uv;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(iTime*20.0));\n    ro.yz *= Rot(radians(-20.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 refl = bg(r.xy);\n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz+refl;\n        col *= dif.y;\n    } else {\n        // background\n        col = bg(uv);\n    }\n    \n    uv*=0.45;\n\t\n    float nine = typoNine(uv+vec2(0.05,-0.055));\n    col = mix( col, jpTraditionalTex(uvref,col,vec3(0.0,1.3,0.5))-vec3(0.8), S(nine,0.005) );\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlV3Wy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[624, 624, 654, 654, 704], [706, 706, 768, 768, 1007], [1009, 1009, 1058, 1058, 1177], [1179, 1179, 1220, 1220, 1311], [1313, 1313, 1349, 1349, 1391], [1393, 1393, 1422, 1422, 1506], [1508, 1582, 1684, 1684, 1824], [1826, 1826, 1849, 1849, 1863], [1865, 1977, 2024, 2024, 2065], [2067, 2067, 2132, 2132, 3171], [3173, 3173, 3195, 3195, 3542], [3544, 3544, 3577, 3577, 3830], [3832, 3832, 3856, 3856, 4057], [4059, 4059, 4093, 4093, 4407], [4757, 4757, 4780, 4780, 5181], [5183, 5183, 5225, 5225, 5420], [5422, 5422, 5446, 5446, 6217], [6219, 6219, 6271, 6271, 8524], [8526, 8526, 8542, 8542, 8746], [8748, 8748, 8805, 8805, 9762]], "test": "untested"}
{"id": "3tKGDW", "name": "Piranha Plant", "author": "PixelPhil", "description": "A Piranah Plant inspired by Mario Bros with procedural animations and PBR-ish Lighting.\nDrag around the screen to move the camera.\n\nMusic: Underworld Remix by Zifur ", "tags": ["procedural", "mario", "pbr", "plant", "animations", "piranha"], "likes": 102, "viewed": 7734, "published": 3, "date": "1579802265", "time_retrieved": "2024-07-30T21:29:06.880632", "image_code": "//\n// Piranah Plant by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define MAX_DST 50.0\n#define MIN_DST 0.004\n#define S(a,b,c) smoothstep(a,b,c)\n#define sat(a) clamp(a,0.0,1.0)\n#define ZERO (min(iFrame,0))\n\n//Material regions\n#define LEAF\t\t \t0.0\n#define STEM   \t\t\t1.0\n#define HEAD\t\t\t2.0\n#define LIPS\t\t\t3.0\n#define INSIDE_MOUTH \t4.0\n#define TONGUE\t\t\t5.0\n#define\tTEETH\t\t\t6.0\n#define\tPOT\t\t\t\t7.0\n#define\tSOIL\t\t\t8.0\n#define\tHILL\t\t\t9.0\n#define SKY\t\t\t\t10.0\n\nconst vec3 leafGreen  = vec3(0.21, 0.66, 0.23);\nconst vec3 leafInside = vec3(0.52, 1.00, 0.36);\n\n// All the parametters for an animation pose\nstruct KeyFrame\n{\n    float leafAngle;\n    float mouthAngle;\n    float spine1;\n    float spine2;\n    float spine3;\n    float neck;\n};\n\n// Linear interpolation between two animation frames\nvoid mixKeyFrame(KeyFrame a, KeyFrame b, float ratio, out KeyFrame c)\n{\n    ratio = ratio*ratio*(3.0-2.0*ratio); // Thanks iq :D\n    \n    c.leafAngle\t\t= mix(a.leafAngle , b.leafAngle\t  , ratio);\n    c.mouthAngle\t= mix(a.mouthAngle, b.mouthAngle  , ratio);\n    c.spine1\t\t= mix(a.spine1\t  , b.spine1\t  , ratio);\n    c.spine2\t\t= mix(a.spine2\t  , b.spine2\t  , ratio);\n    c.spine3\t\t= mix(a.spine3\t  , b.spine3\t  , ratio);\n    c.neck\t\t\t= mix(a.neck\t  , b.neck\t\t  , ratio);\n}\n\n// all matrices and offsets that needs to be pre-computed\n// in order to keep the SDF relatively straightforward\nstruct PlantSpace\n{\n   //mat4 viewMat;\n   \n   // Leaf Matrix\n   mat2 matLeaf;\n   \n   // Spine\n   float joint1AngleZ;\n   float joint2AngleZ;\n   float joint3AngleZ;\n   mat4 joint1;\n   mat4 joint2;\n   mat4 head;\n   \n   // Head / Mouth\n   float mouthAngle;\n   mat2 mouthRot;\n   mat2 teethRot;\n   mat2 teethRot2;\n   vec3 tPos1;\n   vec3 tPos2;\n   vec3 tPos3;\n   vec3 tPos4;\n   vec3 tPos5;\n};\n\n// Attributes of a PBR material\nstruct PBRMat\n{\n    vec3 albedo;\n    float metalness;\n    float roughness;\n    float occlusion;\n};\n\n// From world space to leaf space (before symmetry)\nvec3 leafSpace(vec3 pos, PlantSpace ps)\n{\n    vec3 leafPos = pos;\n    \n    leafPos.z = abs(leafPos.z) - 2.8;\n    leafPos.y  += ps.matLeaf[0][1] * 2.8;\n    leafPos.zy = ps.matLeaf * leafPos.zy;\n    \n    return leafPos;\n}\n\n// Distance to the leaf cutout pattern (on xz)\nfloat dstLeaf(vec3 leafPos)\n{\n    float c1 = 1.1 - length(leafPos.zx - vec2(2.8, 1.1));\n    float c2 = 1.25 - length(leafPos.zx - vec2(1.1, 2.5));\n    return max(c1, c2);\n}\n\n// Color of the LEAF region from pos in world space\nvec3 LeafColor(vec3 pos, PlantSpace ps)\n{\n    vec3 leafPos = leafSpace(pos, ps);\n   \n    leafPos.x = abs(leafPos.x); // The fishbone pattern uses x symetry in leaf space\n    \n    float d = leafPos.x - 0.15; // central line\n    float l = abs(0.5 - fract(leafPos.z + leafPos.x * 0.5 + 0.20)) * 2.0 - 0.25; // 'fins'\n    \n    leafPos.z = abs(leafPos.z); // The lighter area uses x and z symettry\n   \n    float dst = dstLeaf(leafPos); \n    \n    float p = smin(d, l, 0.3) + S(-1.2, -0.0, dst) * 0.28;\n    float pattern = S(-0.05, 0.05, p); // Fishbone pattern mask\n    \n    float area = S(-0.5, -0.6, dst); // Lighter area\n    \n    vec3 col = mix(leafGreen, leafInside, min(area, pattern));\n    \n    return col;\n}\n\n// Computes the color of the HEAD region from pos in world space\nvec3 HeadColor(vec3 pos, PlantSpace ps)\n{\n    // Compute a unit vector from inside the head in head space\n    vec3 headPos = normalize((ps.head * vec4(pos, 1.0)).xyz - vec3(0, 3, 0));\n    \n    \n    vec3 dir = vec3(0, -length(headPos.xy), headPos.z); //Longitudinal vector on the \n    \n    // The vector is rotated around the jaw taking into account the mouth opening\n    // To simulate the skin 'stretching'\n    float zAngle = atan(headPos.x, -headPos.y) * (pi / (pi - ps.mouthAngle));\n    dir = (rotationZ(zAngle) * vec4(dir, 0.0)).xyz;\n    \n    dir.xz = abs(dir.xz); // Symetry on x & z for more dots faster\n\n    // Compute the distances with all the dots in the unit sphere\n    // hopefully the compiler optimizes out all these normalize()\n    float d = S(0.95, 0.96, dot(dir, normalize(vec3(1, 0.1, 0))));\n    d += S(0.96, 0.97, dot(dir, normalize(vec3(1, 1, 0.9))));\n    d += S(0.94, 0.95, dot(dir, normalize(vec3(0.7, -0.3, 0.9))));\n    d += S(0.96, 0.97, dot(dir, normalize(vec3(0.6, -0.6, 0.0))));\n    d += S(0.97, 0.98, dot(dir, normalize(vec3(0.0, -1.25, 1.0))));\n    \n    return mix(vec3(0.8, 0.18, 0.25), vec3(1.0),  d);\n}\n\n// Astro turf on the hill\nvoid HillColor(vec3 pos, out PBRMat mat)\n{\n    vec2 noizeUV = pos.xz * 0.65;\n    \n    // Compute a low frequency 2D vector field\n    vec2 noise = vec2(Noise2(noizeUV.xy + vec2(455.0, 123.9)) - 0.5, Noise2(noizeUV.xy + vec2(-6.8, 467.23)) - 0.5);\n    \n    // Compute a high frequency noise stretched by the vector field\n    float grass = sat(Noise2(pos.xz * 7.0 + noise.xy * 15.0) + length(noise) * 2.0);\n    \n    // Mix in some octaves of noise\n    grass -= (Noise2(pos.xz * 5.0) + Noise2(pos.xz * 10.0) + Noise2(pos.xz * 20.0))  * 0.3;\n\n    vec3 strands = mix(vec3(0.3, 1.0, 0.4), vec3(0.1, 0.5, 0.4), grass);\n    \n    //use the strands mask as occlusion for richer shadows\n    mat = PBRMat(strands, 0.2, 0.8 , sat(grass)); \n}\n\n\n// Computes a PBR Material from material ID and world position\nvoid GetColor(float id, vec3 pos, PlantSpace ps, out PBRMat mat, out vec3 normalBend)\n{   \n    normalBend = vec3(0);\n    \n    if (id == LEAF){\n        mat = PBRMat(LeafColor(pos, ps), 0.3, 0.2, 1.0);\n    \treturn;\n    }\n    else if (id == STEM){\n        mat = PBRMat(leafGreen, 0.3, 0.2, 1.0);\n    \treturn;\n    }\n    else if (id == HEAD){\n        mat = PBRMat(HeadColor(pos, ps), 0.5, 0.1, 1.0);\n    \treturn;\n    }\n    else if (id == LIPS){\n        mat = PBRMat(vec3(1.0, 1.0, 1.0), 0.05, 1.0, 1.0);\n    \treturn;\n    }\n    else if (id == INSIDE_MOUTH){\n        mat = PBRMat(vec3(0.7, 0.0, 0.5), 0.3, 0.2, 1.0);\n    \treturn;\n    }\n    else if (id == TONGUE){\n        mat = PBRMat(vec3(1.0, 0.4, 0.4), 0.7, 0.8, 1.0);\n    \treturn;\n    }\n    else if (id == TEETH){\n        mat = PBRMat(vec3(1.0, 1.0, 1.0), 0.4, 0.2, 1.0);\n    \treturn;\n    }\n    else if (id == POT){\n        mat = PBRMat(vec3(0.2, 0.2, 0.6), 1.0, 0.3, 1.0);\n    \treturn;\n    } \n    else if (id == SOIL){\n        vec2 nCoords = pos.xz * 4.0;\n    \tnormalBend = vec3(Noise2(nCoords) - 0.5, 0.0, Noise2(nCoords.yx + vec2(45.5, 45.5)) - 0.5);\n        mat = PBRMat(vec3(0.31, 0.2, 0.08), 0.15, 1.0, 1.0);\n        return;\n    }\n    else if (id == HILL){\n        HillColor(pos, mat);\n    \treturn;\n    }\n\telse if (id == SKY){\n        mat = PBRMat(vec3(0.5, 0.6, 1.0), 0.0, 0.0, 1.0);\n    \treturn;\n    }  \t\n}\n\n// Somehow the switch block didn't work with the iOS compiler\n/*\nvoid GetColor(float id, vec3 pos, PlantSpace ps, out PBRMat mat, out vec3 normalBend)\n{   \n    normalBend = vec3(0);\n    \n    switch(int(id))\n    {\n      case int(LEAF):\n        mat = PBRMat(LeafColor(pos, ps), 0.3, 0.2, 1.0);\n        return;\n      case int(STEM):\n        mat = PBRMat(leafGreen, 0.3, 0.2, 1.0);\n        return;\n      case int(HEAD):\n        mat = PBRMat(HeadColor(pos, ps), 0.6, 0.1, 1.0);\n        return;\n      case int(LIPS):\n        mat = PBRMat(vec3(1.0, 1.0, 1.0), 0.05, 1.0, 1.0);\n        return;\n      case int(INSIDE_MOUTH):\n        mat = PBRMat(vec3(0.7, 0.0, 0.5), 0.3, 0.2, 1.0);\n        return;\n      case int(TONGUE):\n        mat = PBRMat(vec3(1.0, 0.4, 0.4), 0.8, 0.6, 1.0);\n        return;\n      case int(TEETH):\n        mat = PBRMat(vec3(1.0, 1.0, 1.0), 0.4, 0.2, 1.0);\n        return;\n      case int(POT):\n        mat = PBRMat(vec3(0.2, 0.2, 0.6), 1.0, 0.3, 1.0);\n        return; \n      case int(SOIL):\n        vec2 nCoords = pos.xz * 4.0;\n        normalBend = vec3(Noise2(nCoords) - 0.5, 0.0, Noise2(nCoords.yx + vec2(45.5, 45.5)) - 0.5);\n        mat = PBRMat(vec3(0.31, 0.2, 0.08), 0.15, 1.0, 1.0);\n        return;\n      case int(HILL):\n        HillColor(pos, normalBend, mat);\n        return;\n      case int(SKY):\n        mat = PBRMat(vec3(0.5, 0.6, 1.0), 0.0, 0.0, 1.0);\n        return;  \t\n    }\n}\n*/\n\n// Build all the matrices and offsets necessary to compute the SDF\n// leaving all that in would lead to bad perfs and crazy compile times\nvoid buildPlantSpace(KeyFrame frame, out PlantSpace res)\n{\n    // Leaves\n    float leafAngle = frame.leafAngle;//  -(sin(iTime) * 0.2 + 0.1);\n    float leafSin = sin(leafAngle);\n    float leafCos = cos(leafAngle);\n    \n    res.matLeaf = mat2(-leafCos, leafSin, leafSin, leafCos);\n\n    // Spine\n    res.joint1AngleZ = frame.spine1;\n    res.joint2AngleZ = frame.spine2;\n    res.joint3AngleZ = frame.spine3;\n    \n    res.joint1 = joint3DMatrix(3.0, res.joint1AngleZ);\n    res.joint2 = rotationY(frame.neck) * joint3DMatrix(3.0, res.joint2AngleZ) * res.joint1;\n    \n    \n    // Head / Mouth\n    float MouthAngle = frame.mouthAngle;\n    res.mouthAngle = MouthAngle;\n    \n    float scale = 1.0 - MouthAngle * 0.07;\n    res.head = scaleMatrix(vec3(scale, 1, 1)) * joint3DMatrix(3.0, res.joint3AngleZ) * res.joint2;\n\n    float c = cos(MouthAngle);\n    float s = sin(MouthAngle);\n   \t\n    res.mouthRot = mat2(c, s, s, -c);\n\t\n    \n    float c2 = cos(MouthAngle * 0.5);\n    float s2 = sin(MouthAngle * 0.5);\n    \n    res.teethRot = mat2(s2, -c2,\n                     c2, s2);\n    \n    res.teethRot2 = mat2(s2,  c2,\n                        -c2, s2);\n    \n    res.tPos1 = vec3(s * 1.5, -1.1, 0.0);\n    res.tPos2 = vec3(s * 1.2, -0.8, 1.1);\n    res.tPos3 = vec3(s * 0.6, -1.0, 1.5);\n    res.tPos4 = vec3(-s * 1.5, -1.0, 0.56);\n    res.tPos5 = vec3(-s * 1.2, -1.3, 1.3);\n}\n\n// Signed distance foe a leaf (pos in leaf space)\nfloat sdLeaf(vec3 pos)\n{\n    pos.xz = abs(pos.xz); // Leaf geometry uses symetry on x & z\n    \n    // Starts with an ellipsoid slightly offset from symmetry plane.\n    float leaf = sdEllipsoid(pos - vec3(0.5, 0, 0), vec3(1.4, 0.9, 3));\n    \n    if (leaf > 0.8)\n    {\n        //Early exit with bounding volume\n        return leaf - 0.05;\n    }\n    \n    \n    leaf = abs(leaf) - 0.11; // Onioning\n    \n    float patternDist = dstLeaf(pos); // Cutout pattern SDF\n    \n    float offset = 0.0;\n    \n    leaf = smax(leaf, patternDist, 0.2); //Cutout the shape\n    leaf = smax(leaf, -pos.y, 0.2); //remove the lower part\n    \n    return (leaf - offset) * 0.6; // the 0.6 ratio removed ray marching artefacts\n}\n\n// Computes the sdf to the head (y is material id)\nvec2 sdHead(vec3 pos, PlantSpace ps)\n{\n    //Head space is Mouth Up\n    \n    // Head starts with a sphere\n    float head = sdSphere(pos - vec3(0, 3, 0), 2.8);\n    \n    if (head > 1.0)\n    {\n        //Early exit with bounding volume\n        return vec2(head - 0.5, HEAD);\n    }\n    \n    pos.z = abs(pos.z); // Right/Left Symmetry\n    \n    vec2 ac = vec2(1,0);\n    \n    \n    \n    // Compute teeth implantation positions\n    // 5 teeth for the 9 on the plant (The top middle one is on the symmetry plane)\n    vec3 teethPos = vec3(ps.teethRot * (pos.xy - vec2(0, 3)), pos.z);\n  \n    vec3 tPos = teethPos - ps.tPos1;\n    vec3 tPos2 = teethPos - ps.tPos2;\n    vec3 tPos3 = teethPos - ps.tPos3;\n    \n    vec3 teethPos2 = vec3(ps.teethRot2 * (pos.xy - vec2(0, 3)), pos.z);\n    \n    vec3 tPos4 = teethPos2 - ps.tPos4;\n    vec3 tPos5 = teethPos2 - ps.tPos5;\n    \n    // Compute teeths SDFs\n    float teeth =      sdRoundCone(tPos, 0.5, 0.15, 1.5);\n    teeth = min(teeth, sdRoundCone(tPos2, 0.5, 0.15, 1.2));\n    teeth = min(teeth, sdRoundCone(tPos3, 0.5, 0.15, 1.2));\n    teeth = min(teeth, sdRoundCone(tPos4, 0.5, 0.15, 1.2));\n    teeth = min(teeth, sdRoundCone(tPos5, 0.5, 0.15, 1.2));\n    \n\n    \n    // Inside of the mouth is a soft compooud of 3 speres \n    float mouthInside = sdSphere(pos - vec3(0, 3.5, 0), 2.2);\n\tmouthInside = smin(mouthInside, sdSphere(pos - vec3(0.2, 1.5, 0.0), 0.9), 0.3);\n    mouthInside = smax(mouthInside, -sdSphere(pos - vec3(0.8, 1.6, 0.0), 0.4), 0.5);\n    \n    // Tongue is an ellipsoid\n    float tongue = sdEllipsoid(pos - vec3(-1.0, 2.2, 0.0), vec3(0.7, 1.7, 1.2));\n\n    // Adds X symmetry to compute both lips simultaneously\n\tpos.x = abs(pos.x); \n    \n    vec3 lp = pos.zyx;\n    lp.y -= 3.0;\n    lp.yz = lp.yz * ps.mouthRot;\n    \n    float lips = sdCappedTorus(lp, ac, 2.6, 0.8);\n    \n    // Cut open the head like a Pac Man \n    vec2 pc = pos.xy - vec2(0, 3.0);\n    float plane2 = dot(pc, vec2(ps.mouthRot[1][1], ps.mouthRot[0][1]));\n    head = max(plane2, head);\n    \n    // Combine all parts of the head with material ids\n    vec2 res = vec2(head, HEAD);\n    res = combineMax(res, vec2(-mouthInside, INSIDE_MOUTH));\n    res = combineMin(res, vec2(teeth, TEETH));\n    res = combineMin(res, vec2(lips, LIPS));\n    res = combineMin(res, vec2(tongue, TONGUE));\n    \n    return res;\n}\n\n\n// SDF of the scene\nvec2 SDF(vec3 pos, PlantSpace ps)\n{\n    // Hill\n    vec3 hillPos = pos - vec3(0, -20, 0);\n    hillPos.y = max(0.0, hillPos.y);\n    float hillDst = length(hillPos);\n    \n    float hill = (hillDst - 17.0);\n    \n    \n    float cDist = length(pos.xz);// Infinite cylinder to carve a hole in the Pot\n    \n    float pot = sdRoundedCylinder(pos - vec3(0, -0.5, 0), 1.3, 0.25, 0.5);\n    pot = smax(pot, 1.9 - cDist, 0.25);\n    \n    vec2 pipe = combineMax(vec2(cDist - 2.0, POT), vec2(pos.y, SOIL));\n    \n    // Pipe + Soil with materila Ids\n    vec2 potCol = combineMin(vec2(pot, POT), pipe);\n    \n    float leaf = sdLeaf(leafSpace(pos, ps));\n    \n    // The stem is 3 Joint3DSphere chained\n    float stem = smin(sdSphere(pos, 0.8), sdJoint3DSphere(pos,  3.0, ps.joint1AngleZ /*0.4*/, 0.5), 0.8);\n    \n    vec3 newPos = (ps.joint1 * vec4(pos, 1.0)).xyz;\n    stem = min(stem, sdJoint3DSphere(newPos,  3.0, ps.joint2AngleZ /*-0.75*/, 0.5));\n    \n    newPos = (ps.joint2 * vec4(pos, 1.0)).xyz;\n    stem = min(stem, sdJoint3DSphere(newPos,  3.0, ps.joint3AngleZ /*sin(iTime * 0.7) * 0.2 - 0.5*/, 0.5));\n    \n    vec3 headPos = (ps.head * vec4(pos, 1.0)).xyz;\n    \n    // A rounded cylinder is addded as the 'neck'\n    stem = smin(stem, sdRoundedCylinder(headPos, 0.5, 0.4, 0.0), 0.3);\n    \n    // Combine all parts together with materil ids\n    vec2 res = sdHead(headPos, ps);\n    res = combineMin(res, vec2(leaf, LEAF));\n    res = combineMin(res, vec2(stem, STEM));\n\tres = combineMin(res, potCol);\n    res = combineMin(res, vec2(hill, HILL));\n\n\treturn res;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( vec3 pos, PlantSpace ps)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    \n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * SDF(pos+0.0005*e, ps).x;\n    }\n    return normalize(n);\n}\n\n// inspired by\n// https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 pos, vec3 lPos, PlantSpace ps)\n{   \n    vec3 dir = lPos - pos;  // Light direction & disantce\n    \n    float len = length(dir);\n    dir /= len;\t\t\t\t// It's normalized now\n    \n    pos += dir * MIN_DST * 2.0;  // Get out of the surface\n    \n    float dst = SDF(pos, ps).x; // Get the SDF\n    \n    // Start casting the ray\n    float t = 0.0;\n    float obscurance = 1.0;\n    \n    while (t < len)\n    {\n        if (dst < MIN_DST) return 0.0; \n        obscurance = min(obscurance, (20.0 * dst / t)); \n        t += dst;\n        pos += dst * dir;\n        dst = SDF(pos, ps).x;\n    }\n    return obscurance;     \n}\n\nfloat shadow(vec3 p, vec3 n, vec3 lPos, PlantSpace ps)\n{\n    return shadow(p + n * MIN_DST * 40.0, lPos, ps);\n}\n\n// Cast a ray across the SDF return x: Distance, y: Materila Id\nvec2 castRay(vec3 pos, vec3 dir, float maxDst, float minDst, PlantSpace ps)\n{\n    vec2 dst = vec2(minDst * 2.0, 0.0);\n    \n    float t = 0.0;\n    \n    while (dst.x > minDst && t < maxDst)\n    {\n        dst = SDF(pos, ps);\n        t += dst.x;\n        pos += dst.x * dir;\n    }\n    \n    return vec2(t + dst.x, dst.y);\n}\n\n// A 2D blurrable cloud \nfloat cloudSky(vec2 skyUv, float blur)\n{\n    float sum = Noise2(skyUv);\n    float div = 1.0;\n    \n    if (blur < 0.75)\n    {\n        sum += Noise2(skyUv * 8.0) * 0.1 - 0.05;\n        \n        if (blur < 0.50)\n        {\n    \t\tsum += Noise2(skyUv * 4.0) * 0.25 - 0.125;\n            \n            if (blur < 0.25)\n        \t{\n    \t\t\tsum += Noise2(skyUv * 2.0) * 0.5 - 0.25;\n            }\n        }\n    }\n    sum /= 3.0;\n    return sum;\n}\n\n// A blurrable cloud environement map\nvec3 SkyDome(vec3 rayDir, float blur)\n{\n    float blue = sat(rayDir.y * 2.0 + 0.7);\n    vec3    col = mix(vec3(0.8, 0.9, 1.0), vec3(0.5, 0.6, 1.0), blue);\n    \n    vec2 dome = rayDir.xz;\n    float len = length(dome);\n    \n    float a = atan(rayDir.x, rayDir.z);\n    \n    // Compute 2 layers of clouds and blend them with longitude to mask the vertical seam\n    vec2 skyUv = vec2(a * 7.5 - iTime * 0.1, rayDir.y * 10.0);\n    float cloud1 = cloudSky(skyUv, blur);\n    \n    vec2 skyUv2 = vec2((a + pi2) * 7.5 - iTime * 0.1, rayDir.y * 10.0);\n    float cloud2 = cloudSky(skyUv2, blur);\n    \n    float ratio = 1.0 - (a + pi) / pi2;\n    float cloud =  mix(cloud1, cloud2, ratio);\n    \n    // Mask the cloud across a horizontal band\n    float cloudMask = S(0.8, 0.0, abs(rayDir.y + 0.2));\n    cloud *= cloudMask;\n    \n    // When blurred the clouds are merely the mask itself\n    cloud = mix(cloud, cloudMask * (1.0 - blur * 0.6), blur);\n\n    // Add some burn around the sun\n    float sun = max(0.0, dot(rayDir, normalize(vec3(-1.0, 0.4, -1))) - 0.3);\n          \n    col.rgb += cloud;\n    col.rgb += sun * sun * sun;\n    \n    //col.rgb = mix(col.rgb, vec3(0, 1, 0), S(-0.5, -1.0, rayDir.y));\n    \n    return col;\n}\n\n\n// A PBR-ish lighting model\nvec3 PBRLight(vec3 pos, vec3 normal, vec3 view, PBRMat mat, vec3 lightPos, vec3 lightColor, float lightRadius, float fresnel, PlantSpace ps, bool AddEnv)\n{\n    //Basic lambert shading stuff\n    \n    vec3 key_Dir = lightPos - pos;\n    float key_len = length(key_Dir);\n    \n    float atten = sat(1.0 - key_len / lightRadius);\n    atten *= atten;\n    \n    key_Dir /= key_len;\n    \n\n    float key_lambert = max(0.0, dot(normal, key_Dir)) * atten;\n    float key_shadow = shadow(pos, normal, lightPos, ps); \n    \n    float diffuseRatio = key_lambert * key_shadow;\n    \n    vec3 key_diffuse = vec3(diffuseRatio);\n    \n    // The more metalness the more present the Fresnel\n    float f = pow(fresnel + 0.5 * mat.metalness, mix(2.5, 0.5, mat.metalness));\n    \n    // metal specular color is albedo, it is white for dielectrics\n    vec3 specColor = mix(vec3(1.0), mat.albedo, mat.metalness);\n    \n    vec3 col = mat.albedo * key_diffuse * (1.0 - mat.metalness);\n    \n    // Reflection vector\n    vec3 refDir = reflect(view, normal);\n    \n    // Specular highlight (softer with roughness)\n    float key_spec = max(0.0, dot(key_Dir, refDir));\n    key_spec = pow(key_spec, 10.0 - 9.0 * mat.roughness) * atten * key_shadow;\n    \n    float specRatio = mat.metalness * diffuseRatio;\n    \n    col += vec3(key_spec) * specColor * specRatio;\n    col *= lightColor;\n    \n    //Optionnal environment reflection (only for key light)\n    if (AddEnv)\n    {\n       vec3 dome = SkyDome(refDir, mat.roughness);\n       dome *= dome; //linear space conversion;\n       col += f * dome * specRatio;\n    }\n    \n    return col;\n}\n\n// Some 3 octave 1D noise for animation\nfloat Noise13(float x, float seed)\n{\n    float res = Noise1(x, seed);\n    res += Noise1(x * 2.0, seed) * 0.5;\n    res += Noise1(x * 4.0, seed) * 0.25;\n    return res;\n}\n\n// A calm animation where the plant is idle\nvoid CalmAnim(out KeyFrame kf)\n{\n    kf.leafAngle = -0.15 + Noise13(iTime * 0.25, 45.0) * 0.5; //-0.5 to 0.2;\n    kf.mouthAngle = 0.27; //0.27 to 1.4\n    \n    float spineNoise = Noise13(iTime * 0.2, 155.0);\n    \n    kf.spine1 = 0.5 + spineNoise * 0.2;     //rest at 0.5\n    kf.spine2 = -0.7 - spineNoise * 0.15;    //rest at -0.7\n    kf.spine3 = -0.65 - spineNoise * 0.15;\t //rest at -0.65\n    \n    kf.neck = Noise1(iTime * 0.25, 456.0) * 0.8;\t\t //-1.3 to 1.3\n}\n\n// A menacing animation where the plant is mouth opened ready to bite\nvoid AgressiveAnim(out KeyFrame kf)\n{\n    float spineNoise = Noise13(iTime * 0.4, 155.0);\n    \n    kf.leafAngle = -0.15 - spineNoise * 0.5; //-0.5 to 0.2;\n    kf.mouthAngle = 1.3 + Noise13(iTime * 1.0, 45.0) * 0.2; //0.27 to 1.4\n    \n    kf.spine1 = 0.6 + spineNoise * 0.2;     //rest at 0.5\n    kf.spine2 = -0.7 - spineNoise * 0.15;    //rest at -0.7\n    kf.spine3 = -0.7 - spineNoise * 0.15;\t //rest at -0.65\n    \n    kf.neck = Noise1(iTime * 0.6, 456.0) * 2.3;\t\t //-1.3 to 1.3\n}\n\n// An animation where the plant attacks repeatedly\nvoid ChompAnim(out KeyFrame kf)\n{\n    float a = sin(iTime * 20.0) * 0.5 + 0.5;\n    \n    float spineNoise = Noise13(iTime * 0.4, 155.0);\n    \n    kf.leafAngle = -0.25 - a * spineNoise; //-0.5 to 0.2;\n    \n    kf.mouthAngle = mix(0.27, 1.6, a * a);\n    \n    kf.spine1 = 0.4 + spineNoise * 0.2;     //rest at 0.5\n    kf.spine2 = -0.8 - spineNoise * 0.15 - a * 0.1;    //rest at -0.7\n    kf.spine3 = -0.5 - spineNoise * 0.15 + a * 0.1;\t //rest at -0.65\n    \n    kf.neck = Noise1(iTime * 1.0, 456.0) * 2.3;\t\t //-1.3 to 1.3\n}\n\n\nvec4 render(vec3 camPos, vec3 rayDir)\n{\n       \n    PlantSpace plantSpace;\n    \n    KeyFrame kf1;\n    KeyFrame kf2;\n    KeyFrame kf;\n    \n    // Varies the plant agressivity with time\n    float aggro = mix(-0.5, 2.0, Noise1(iTime * 0.3, 236.8) + 0.5);\n    \n    // compute two animation poses and a blending factor\n    if (aggro < 1.0)\n    {\n        CalmAnim(kf1);\n    \tAgressiveAnim(kf2);\n    }\n    else\n    {\n        AgressiveAnim(kf1);\n    \tChompAnim(kf2);\n        aggro -= 1.0;\n    }\n    \n\tmixKeyFrame(kf1, kf2, sat(aggro * 2.0), kf); \n    \n    // Build matrices\n    buildPlantSpace(kf, plantSpace);\n    \n    vec3 col;\n    \n    vec2 d = castRay(camPos, rayDir, MAX_DST, MIN_DST, plantSpace);\n    \n    \n    if (d.x > MAX_DST)\n    {\n        // sky dome\n        col = SkyDome(rayDir, 0.0);\n    }\n    else   \n    {\n        vec3 pos = camPos + rayDir * d.x;\n \n        vec3 n;\n        \n        vec3 normalOffset = vec3(0);\n        \n        \n        PBRMat mat;\n        \n        GetColor(d.y, pos, plantSpace, mat, normalOffset);\n        \n        mat.albedo *= mat.albedo; // Convert albedo to linear space\n        \n        n = normalize(calcNormal(pos, plantSpace) + normalOffset);\n        \n        // Some bogus ambient term\n        vec3 ambient = mix(vec3(0.5, 1, 0.5), vec3(0.5, 0.5, 1), n.y * 0.5 + 0.5);\n        ambient += vec3(0.5, 0.2, 0.2) * (1.0- abs(n.y * n.y));\n        \n        // Fake AO\n        float dst = 1.0 - sat(SDF(pos + n * 0.2, plantSpace).x * 1.0);\n        ambient *= (1.0 - dst * dst) * 0.8 + 0.2;\n        ambient *= mat.occlusion * 0.5;\n  \n        col =  mat.albedo * ambient;\n        \n        // Fresnel\n        float fresnel = pow(1.0 - sat(dot(n, -rayDir)), 1.0);\n\n\t\tvec3 key_LightPos = vec3(-10.0, 10.0, -13.0);\n        col += PBRLight(pos, n, rayDir, mat, key_LightPos, vec3(0.9), 1000.0, fresnel, plantSpace, true);\n        \n                \n        vec3 fill_LightPos = vec3(-8.0, 10.0, 10.0);\n        col += PBRLight(pos, n, rayDir, mat, fill_LightPos, vec3(0.8), 50.0, fresnel, plantSpace, false);\n\n    \tcol = pow(col,vec3(0.4545));\n    }\n\n    return vec4(col, d);\n}\n\n// Classic stuff\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(fragCoord - .5 * iResolution.xy) / iResolution.y; \n\n    vec3 camPos = vec3(0.0, 2.8, -40.0);\n    vec3 camDir = vec3(0.0, 0.0,  1.0);\n    \n    vec3 rayDir = camDir + vec3(uv * 0.45, 0.0);\n    \n    \n   \tvec3 res = vec3(0.0);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    if(mouse.x<.001) mouse = vec2(0.5, 0.5);\n    \n    vec2 viewAngle = vec2((-mouse.x - 0.6) * pi2, (mouse.y - 0.65) * halfPi);\n    \n    mat4 viewMat = rotationY(viewAngle.x) * rotationX(viewAngle.y);\n    \n    camPos = (viewMat * vec4(camPos, 1.0)).xyz;\n    rayDir = (viewMat * vec4(rayDir, 0.0)).xyz;\n    \n\n    res = render(camPos, rayDir).rgb;\n\n    // Output to screen\n    fragColor = vec4(res.rgb,1.0);\n}", "image_inputs": [{"id": 20980, "src": "https://soundcloud.com/zifur/underworld-remix-super-mario", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define pi 3.14159265359\n#define pi2 (pi * 2.0)\n#define halfPi (pi * 0.5)\n\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(pos - center) - radius;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n    \n  float edge = dot(p.xy,sc);\n  float k = (sc.y*p.x>sc.x*p.y) ? edge : length(p.xy);\n  float ratio = max(0.5, 1.0 - edge * edge * 0.055);\n  return (sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb * ratio) * ratio;\n}\n\nfloat dot2( vec2 v ) { return dot(v,v); }\n\n\nvec2 combineMin(vec2 a, vec2 b)\n{\n    return (a.x < b.x)? a : b;\n}\n\nvec2 combineMax(vec2 a, vec2 b)\n{\n    return (a.x > b.x)? a : b;\n}\n\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\n// Some hash function 2->1\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n    p = mod(p, vec2(1456.2346));\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// A 2d Noise\nfloat Noise2(vec2 uv)\n{\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    vec2 diff = fract(uv);\n    \n    diff = diff * diff * (vec2(3) - vec2(2) * diff);\n    //diff = smoothstep(vec2(0), vec2(1), diff);\n    \n    return mix(mix(c00, c10, diff.x), mix(c01, c11, diff.x), diff.y);\n}\n\n// 1d Noise, y is seed\nfloat Noise1(float x, float seed)\n{\n    vec2 uv = vec2(x, seed);\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    float diff = fract(uv.x);\n    \n    diff = diff * diff * (3.0 - 2.0 * diff);\n    \n    return mix(c00, c10, diff) - 0.5;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGDW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[835, 888, 959, 959, 1357], [1991, 2043, 2084, 2084, 2262], [2264, 2311, 2340, 2340, 2483], [2485, 2537, 2578, 2578, 3245], [3247, 3312, 3353, 3417, 4446], [4448, 4474, 4516, 4516, 5201], [5204, 5267, 5354, 5354, 6628], [8036, 8174, 8232, 8246, 9531], [9533, 9583, 9607, 9607, 10284], [10286, 10337, 10375, 10442, 12646], [12649, 12669, 12704, 12716, 14216], [14219, 14265, 14308, 14406, 14621], [14623, 14683, 14733, 14733, 15305], [15307, 15307, 15363, 15363, 15418], [15420, 15484, 15561, 15561, 15801], [15803, 15828, 15868, 15868, 16259], [16261, 16299, 16338, 16338, 17506], [17509, 17537, 17692, 17726, 19133], [19135, 19175, 19211, 19211, 19343], [19345, 19389, 19421, 19421, 19850], [19852, 19922, 19959, 19959, 20403], [20405, 20456, 20489, 20489, 20975], [20978, 20978, 21017, 21017, 23075], [23077, 23094, 23151, 23151, 23844]], "test": "untested"}
{"id": "3tV3Dy", "name": "Animating Smile", "author": "tonywu", "description": "For learning", "tags": ["animation"], "likes": 1, "viewed": 363, "published": 3, "date": "1579771210", "time_retrieved": "2024-07-30T21:29:07.693459", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap01(float a, float b, float t){\n\treturn sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n\treturn sat((t-a)/(b-a)) * (d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect){\n    return (uv - rect.xy)/(rect.zw - rect.xy);\n}\n\nvec4 Brow(vec2 uv){\n\n    float y = uv.y;\n    uv.y += uv.x*.8-.3;\n    uv.x -= .1;\n    uv -= .5;\n    \n    vec4 col = vec4(0.);\n    float blur = .1;\n    \n    float d1 = length(uv);\n    float s1 = S(.45, .45-blur, d1);\n    float d2 = length(uv-vec2(.1, -.2)*.7);\n    float s2 = S(.5, .5-blur, d2);\n    \n    float browMask = sat(s1-s2);\n    \n    float colMask = remap01(.7, .8, y)*.75;\n    colMask *= S(.6, .9, browMask);\n    vec4 browCol = mix(vec4(.4, .2, .2, 1.), vec4(1., .75, .5, 1.), colMask); \n    \n    uv.y += .15;\n    blur += .1;\n    d1 = length(uv);\n    s1 = S(.45, .45-blur, d1);\n    d2 = length(uv-vec2(.1, -.2)*.7);\n    s2 = S(.5, .5-blur, d2);\n    float shadowMask = sat(s1-s2);\n    \n    col = mix(col, vec4(0., 0., 0., 1.), S(.0, 1., shadowMask));\n    \n    col = mix(col, browCol, S(.2, .4, browMask));\n    \n    \n    return col;\n    \n}\n\nvec4 Eye(vec2 uv, float side, vec2 m){\n    uv -= 0.5;\n    uv.x *= side;\n    \n    float d = length(uv);\n\t\n    vec4 irisCol = vec4(.3, .5, 1., 1.);\n    \n    vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d)*0.5);\n    \n    col.rgb *= 1. - S(.45, .5, d)*0.5*sat(-uv.y-uv.x*side);\n    \n    d = length(uv - m*.4);\n    col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d));\n    \n    irisCol.rgb *= 1. + S(.3, .05, d);\n    col.rgb = mix(col.rgb, irisCol.rgb, S(.28, .25, d));\n    \n    col.rgb = mix(col.rgb, vec3(0.), S(.16, .14, d));\n    \n    d = length(uv-m*.45);\n    \n    float highlight = S(.1, .09, length(uv - vec2(-.15, .15)));\n    highlight += S(.07, .05, length(uv + vec2(-.08, .08)));\n    \n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    col.a = S(.5, .48, d);\n    \n     \n    return col;\n}\n\nvec4 Mouth(vec2 uv){\n\tuv -= .5;\n    vec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 3.5;\n    uv.y -= uv.x * uv.x*2.; \n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    float td = length(uv-vec2(0., .6));\n    \n    vec3 toothCol = vec3(1.) * S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));\n     \n    td = length(uv+vec2(0., .5));\n    col.rgb =mix(col.rgb, vec3(1., .5, .5), S(.5, .2, td));\n    return col;\n}\n\nvec4 Head(vec2 uv){\n\tvec4 col = vec4(.9, .65, .1, 1.);\n    float d = length(uv);\n    col.a = S(0.5, 0.49, d);\n    float edgeShade = remap01(.35, .5, d);\n    edgeShade *= edgeShade;\n    \n    col.rgb *= 1. - edgeShade*.5;\n    col.rgb = mix(col.rgb, vec3(.6, .3, .1), S(0.47, 0.48, d));\n    \n    float highlight = S(0.41, 0.405, d);\n    highlight *= remap(0.41, -.1, 0.75, 0., uv.y);\n    highlight *= S(.18, .19, length(uv-vec2(.21,.08)));\n    col.rgb = mix(col.rgb, vec3(1.0), highlight);\n    \n    \n    \n    d = length(uv - vec2(.25, -.2));\n    float cheek = S(0.2, 0.01, d)*0.4;\n    cheek *= S(0.17, 0.16, d);\n    col.rgb = mix(col.rgb, vec3(1., .1, .1), cheek);\n    \n    return col;\n}\n\nvec4 Smiley(vec2 uv, vec2 m){\n\tvec4 col = vec4(0.0);\n    float side = sign(uv.x);\n    uv.x = abs(uv.x);\n    vec4 head = Head(uv);\n    vec4 eye = Eye(within(uv, vec4(0.03, -.1, .37, .25)), side, m);\n    vec4 mouth = Mouth(within(uv, vec4(-.3, -.4, .3, -.1)));\n    vec4 brow = Brow(within(uv, vec4(.03,.2,0.4,0.45)));\n    \n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    col = mix(col, brow, brow.a);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= .5;\n    \n    if(m.x<-.49 && m.y<-.49) {\t\t\t// make it that he looks around when the mouse hasn't been used\n    \tfloat s = sin(t*.5);\n        float c = cos(t*.38);\n        \n        m = vec2(s, c)*.4;\n    }\n    \n    if(length(m) > .707) m *= 0.;\t\t// fix bug when coming back from fullscreen\n    \n    float d = dot(uv, uv);\n    uv -= m*sat(.23-d);\n    \n    m.x = sin(iTime)*.15;\n    m.y = cos(iTime)*.2;\n\n    // Output to screen\n    fragColor = Smiley(uv,m);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tV3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 113, 113, 141], [143, 143, 200, 200, 240], [242, 242, 274, 274, 323], [325, 325, 344, 344, 1170], [1172, 1172, 1210, 1210, 1964], [1966, 1966, 1986, 1986, 2408], [2410, 2410, 2429, 2429, 3094], [3096, 3096, 3125, 3125, 3575], [3578, 3578, 3635, 3635, 4310]], "test": "untested"}
{"id": "3lVGDy", "name": "Tartan floater", "author": "joynes", "description": "Simple implementation of a tartan structure, inspired by bookofshaders", "tags": ["tartan"], "likes": 4, "viewed": 457, "published": 3, "date": "1579768867", "time_retrieved": "2024-07-30T21:29:08.611006", "image_code": "#define M_PI 3.1416\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{     \n  vec2 t = fragCoord/iResolution.y;\n  float r = M_PI/4. * sin(iTime*.5);\n  t = mat2(cos(r), sin(r), -sin(r), cos(r))*(t - .5);\n  t *= 2. + .8*sin(iTime);\n  t.y += iTime;\n  t = fract(t);\n  float lines = 9.;\n\n  vec2 ic = (floor(t*lines*10.));\n  float pat = step(mod(ic.x-ic.y, 3.), 1.);\n  float bc = .8;\n\n  vec2 cut = step(abs((t-.5)*lines*2.), vec2(5.));\n  float hb = mod(ceil(t.y*lines), 2.);\n  float hw = 1. - hb;\n\n  float alpha = 0.95;\n  float col = mix(bc, 1. - (hb*pat), alpha*hb*cut.y*pat);\n  col = mix(col, hw*pat, alpha*hw*cut.y*pat);\n\n  pat = 1. - pat;\n  float vb = mod(ceil(t.x*lines), 2.);\n  col = mix(col, 1. - (vb*pat), alpha*vb*cut.x*pat);\n  float vw = 1. - vb;\n  col = mix(col, vw*pat, alpha*vw*cut.x*pat); \n\n  vec2 red = step(lines*2.-1., floor(abs(t-.5)*lines*4.));\n  vec3 vcol = vec3(col);\n  vcol = mix(vcol, vec3(red.x*pat, 0., 0.), alpha*red.x*pat);\n  vcol = mix(vcol, vec3(red.y*(1.-pat), 0, 0.), alpha*red.y*(1.-pat));\n\n  fragColor = vec4(vcol, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 1057]], "test": "untested"}
{"id": "WtVGDy", "name": "Make noise", "author": "tonywu", "description": "make some useful noise", "tags": ["noise"], "likes": 1, "viewed": 309, "published": 3, "date": "1579767542", "time_retrieved": "2024-07-30T21:29:09.521571", "image_code": "float N21(vec2 p){\n\treturn fract(sin(p.x*100. + p.y*643.)*5647.);\n}\n\nfloat SmoothNoise(vec2 uv){\n    \n \tvec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3. - 2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl,br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) {\n\tfloat c = SmoothNoise(uv*4.);\n    c += SmoothNoise(uv*8.) * .5;\n    c += SmoothNoise(uv*16.) * .25;\n    c += SmoothNoise(uv*32.) * .125;\n    c += SmoothNoise(uv*64.) * .0625;\n    \n    return c /=2.;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t//float c = N21(uv);\n    \n    uv += iTime*.1;\n    float c = SmoothNoise2(uv);\n    \n    \n    vec3 col =vec3(c);\n    \n    //col.rg = lv;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 67], [69, 69, 96, 96, 419], [421, 421, 450, 450, 657], [659, 659, 716, 716, 955]], "test": "untested"}
{"id": "3lVGDG", "name": "Super Smile", "author": "tonywu", "description": "for test", "tags": ["test"], "likes": 1, "viewed": 338, "published": 3, "date": "1579751255", "time_retrieved": "2024-07-30T21:29:10.413187", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap01(float a, float b, float t){\n\treturn sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n\treturn sat((t-a)/(b-a)) * (d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect){\n    return (uv - rect.xy)/(rect.zw - rect.xy);\n}\n\nvec4 Eye(vec2 uv){\n    uv -= 0.5;\n    \n    float d = length(uv);\n\t\n    vec4 irisCol = vec4(.3, .5, 1., 1.);\n    \n    vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d)*0.5);\n    \n    col.rgb *= 1. - S(.45, .5, d)*0.5*sat(-uv.y-uv.x);\n    \n    col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d));\n    \n    irisCol.rgb *= 1. + S(.3, .05, d);\n    col.rgb = mix(col.rgb, irisCol.rgb, S(.28, .25, d));\n    \n    col.rgb = mix(col.rgb, vec3(0.), S(.16, .14, d));\n    \n    float highlight = S(.1, .09, length(uv - vec2(-.15, .15)));\n    highlight += S(.07, .05, length(uv + vec2(-.08, .08)));\n    \n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    col.a = S(.5, .48, d);\n    \n     \n    return col;\n}\n\nvec4 Mouth(vec2 uv){\n\tuv -= .5;\n    vec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5+ abs(2.*cos(0.5*3.14*iTime));\n    uv.y -= uv.x * uv.x*2.; \n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    float td = length(uv-vec2(0., .6));\n    \n    vec3 toothCol = vec3(1.) * S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));\n     \n    td = length(uv+vec2(0., .5));\n    col.rgb =mix(col.rgb, vec3(1., .5, .5), S(.5, .2, td));\n    return col;\n}\n\nvec4 Head(vec2 uv){\n\tvec4 col = vec4(.9, .65, .1, 1.);\n    float d = length(uv);\n    col.a = S(0.5, 0.49, d);\n    float edgeShade = remap01(.35, .5, d);\n    edgeShade *= edgeShade;\n    \n    col.rgb *= 1. - edgeShade*.5;\n    col.rgb = mix(col.rgb, vec3(.6, .3, .1), S(0.47, 0.48, d));\n    \n    float highlight = S(0.41, 0.405, d);\n    highlight *=remap(0.41, -.1, 0.75, 0., uv.y);\n    col.rgb = mix(col.rgb, vec3(1.0), highlight);\n    \n    \n    \n    d = length(uv - vec2(.25, -.2));\n    float cheek = S(0.2, 0.01, d)*0.4;\n    cheek *= S(0.17, 0.16, d);\n    col.rgb = mix(col.rgb, vec3(1., .1, .1), cheek);\n    \n    return col;\n}\n\nvec4 Smiley(vec2 uv){\n\tvec4 col = vec4(0.0);\n    uv.x = abs(uv.x);\n    vec4 head = Head(uv);\n    vec4 eye = Eye(within(uv, vec4(0.03, -.1, .37, .25)));\n    vec4 mouth = Mouth(within(uv, vec4(-.3, -.4, .3, -.1)));\n    \n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = Smiley(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVGDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 113, 113, 141], [143, 143, 200, 200, 240], [242, 242, 274, 274, 323], [325, 325, 343, 343, 1016], [1018, 1018, 1038, 1038, 1489], [1491, 1491, 1510, 1510, 2118], [2120, 2120, 2141, 2141, 2457], [2460, 2460, 2517, 2567, 2807]], "test": "untested"}
{"id": "wly3Dy", "name": "Cosmic Cycles", "author": "BigWIngs", "description": "See comments. Watch full screen with sound!", "tags": ["star", "space", "stars", "starfield", "universe", "bigbang"], "likes": 101, "viewed": 4205, "published": 3, "date": "1579749264", "time_retrieved": "2024-07-30T21:29:11.179139", "image_code": "// \"Cosmic Cycles\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// Music:\n// https://soundcloud.com/weareallastronauts/ether\n//\n// Starfields used to be super cool back in the day. It was one of the first\n// effects I ever made sometime at the end of the 1980's. \n// This started out as a normal star field (comment out BURST to see)\n// After trying it with a circle inversion I decided to make it into some\n// sort of big bang scenario.\n\n#define BURST\n#define NUM_LAYERS 5.\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Star(vec2 uv, float a, float sparkle) {\n    vec2 av1 = abs(uv);\n \tvec2 av2 = abs(uv*Rot(a));\n    vec2 av = min(av1, av2);\n    \n    vec3 col = vec3(0);\n    float d = length(uv);\n    float star = av1.x*av1.y;\n    star = max(av1.x*av1.y, av2.x*av2.y);\n    star = max(0., 1.-star*1e3);\n    \n    float m = min(5., 1e-2/d);\n    \n    return m+pow(star, 4.)*sparkle;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,145.54));\n    p += dot(p, p+45.23);\n    return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv, float t, float sparkle) {\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n\tvec3 col = vec3(0);\n    \n    #ifndef BURST\n    t = 0.;\n    #endif\n    \n    for(int y=-1; y<=1; y++) {\n        for(int x=-1; x<=1; x++) {\n            vec2 offs = vec2(x, y);\n            float n = Hash21(id-offs);\n\t\t\tvec3 N = fract(n*vec3(10,100,1000));\n            vec2 p = (N.xy-.5)*.7;\n            \n            float brightness = Star(gv-p+offs, n*6.2831+t, sparkle);\n            vec3 star = brightness*vec3(.6+p.x, .4, .6+p.y)*N.z*N.z;\n            \n            \n            \n            star *= 1.+sin((t+n)*20.)*smoothstep(sin(t)*.5+.5, 1., fract(10.*n));\n            \n            float d = length(gv+offs);\n            \n            col += star*smoothstep(1.5, .8, d);\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = iMouse.xy/iResolution.xy;\n    \n    M *= 10.;\n    \n\tfloat t = -iTime*.3;\n\t\n    float twirl = sin(t*.1);\n    twirl *= twirl*twirl*sin(dot(uv,uv));\n    uv *= Rot(-t*.2);\n    \n    uv *= 2.+sin(t*.05);\n    \n    vec3 col = vec3(0);\n    float speed = -.2;\n    #ifdef BURST\n    speed = .1;\n    float bla = sin(t+sin(t+sin(t)*.5))*.5+.5;\n    float d = dot(uv,uv);\n    \n    float a = atan(uv.x, uv.y);\n    uv /= d;\n    float burst = sin(iTime*.05);\n    uv *= burst+.2;\n    #endif\n    \n    float stp = 1./NUM_LAYERS;\n        \n    for(float i=0.; i<1.; i+=stp) {\n    \tfloat lt = fract(t*speed+i);\n        float scale = mix(10., .25, lt);\n        float fade = smoothstep(0., .4, lt)*smoothstep(1., .95, lt); \n        vec2 sv = uv*scale+i*134.53-M;\n        //sv.x += t;\n        col += StarLayer(sv, t, fade)*fade;\n    }\n    \n    #ifdef BURST\n    //t = iTime*.5;\n    float burstFade = smoothstep(0., .02, abs(burst));\n    float size = .9*sin(t)+1.;\n    size = max(size, sqrt(size));\n    float fade = size/d;\n    col *= mix(1., fade, burstFade);\n    col += fade*.2*vec3(1., .5, .1)*bla*burstFade;\n    \n    t*=1.5;\n    \n    a -= M.x*.1;\n    float rays = sin(a*5.+t*3.)-cos(a*7.-t);\n    rays *= sin(a+t+sin(a*4.)*10.)*.5+.5;\n    col += rays*bla*.1*burstFade;\n    col += 1.-burstFade;\n    #else\n    col *= 4.;\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 20977, "src": "https://soundcloud.com/weareallastronauts/ether", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wly3Dy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[678, 678, 697, 697, 756], [758, 758, 803, 803, 1124], [1126, 1126, 1148, 1148, 1241], [1243, 1243, 1292, 1292, 2052], [2054, 2054, 2111, 2111, 3523]], "test": "untested"}
{"id": "ttG3Dy", "name": "shortest sound (31 ch)", "author": "ttg", "description": "Shortest audible sound.", "tags": ["short", "onetweet", "golf"], "likes": 3, "viewed": 352, "published": 3, "date": "1579733297", "time_retrieved": "2024-07-30T21:29:12.141566", "image_code": "//MtyXRW\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define mainSound sin(t*t)*vec2\n\n\n\n\n/* Shadertoy's current mSoundPassFooter for reference, last checked on 2019-10-27\n\nout vec4 outColor;\nvoid main()\n        {\n            float t = iBlockOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;\n            vec2 y = mainSound( in int samp, t );\n            vec2 v  = floor((0.5+0.5*y)*65536.0);\n            vec2 vl =   mod(v,256.0)/255.0;\n            vec2 vh = floor(v/256.0)/255.0;\n            outColor = vec4(vl.x,vh.x,vl.y,vh.y);\n        }\n*/\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttG3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 273, 320, 499], [501, 501, 558, 619, 845]], "test": "untested"}
{"id": "wtyGWy", "name": "boring n-body simulation thing", "author": "DJDoomz", "description": "Mess around with number of objects and gravity and stuff in Common", "tags": ["2d", "gravity"], "likes": 7, "viewed": 489, "published": 3, "date": "1579726437", "time_retrieved": "2024-07-30T21:29:13.039166", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //center view around average of system\n    vec2 cen = vec2(0,0);\n    for(float i = 0.0; i < NUM; i++)\n    {\n    \n    \tvec4 o = texelFetch(iChannel0, ivec2(i,0), 0);\n        cen += o.xy;\n    \n    }\n    cen /= NUM;\n    vec2 uv = 2.*(fragCoord-.5*iResolution.xy)/iResolution.y + cen;\n    \n    vec3 col = vec3(0);//0.06 + 0.06*cos(iTime+uv.xyx*3.+vec3(0,2,4));\n    \n    for(float i = 0.0; i < NUM; i++)\n    {\n    \n    \tvec4 o = texelFetch(iChannel0, ivec2(i,0), 0);\n        \n        vec3 c = .5+.5*sin(vec3(1,2,3)*i);\n        \n        float d = .005/length(uv-o.xy);\n        \n        d = smoothstep(0.2,.4, d);\n        \n        col += c*d;\n    \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NUM 8.0\n#define GRAV .0008\n#define DMUL 2.0", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 100, 766]], "test": "untested"}
{"id": "tlGGWG", "name": "Closest distance to a line", "author": "mystery", "description": "I just tried to draw a line segment\nUse the mouse to change the position of the starting point", "tags": ["line"], "likes": 1, "viewed": 393, "published": 3, "date": "1579707945", "time_retrieved": "2024-07-30T21:29:13.885902", "image_code": "\nvec2 ClosestPointOnLine(vec2 a, vec2 b, vec2 p)\n{\n    vec2 v = b - a;\n    return a + v * clamp(dot(v, (p - a) / dot(v,v)), 0.0, 1.0);\n}\n\nvec2 NormalizeSpace(vec2 s)\n{\n    return (s.xy - 0.5 * iResolution.xy) / iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat smoothness = 2.0/iResolution.y;\n    float thickness = 1.0;\n    \n    vec2 uv = NormalizeSpace(fragCoord) * 4.0;\n    vec2 muv = NormalizeSpace(iMouse.xy) * 4.0;\n    \n    vec2 start = vec2(muv);\n    vec2 end = vec2(2.0, 0.0);\n    float col = length(uv-ClosestPointOnLine(start, end, uv));\n    col = smoothstep(thickness, thickness + smoothness, col);\n\n    // Output to screen\n    fragColor = vec4(col,col, col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 50, 50, 136], [138, 138, 167, 167, 227], [229, 229, 286, 286, 708]], "test": "untested"}
{"id": "3ty3Dy", "name": "Crowdy waves 2", "author": "FabriceNeyret2", "description": "refactored & commented version of rory618's \"Crowdy waves\" [url]https://shadertoy.com/view/ttyGWw[/url] (Voronoi particle tracking )\nSPACE: show Ids/voronoi   C mouse,+D,S,P\nAnother partic Voronoï tracker: [url]https://www.shadertoy.com/view/WtK3ztl[/url]", "tags": ["2d", "particles", "splat", "swarm", "boids", "voronoitracking", "voronoiparticlestracking", "write2xy", "writetoxy"], "likes": 165, "viewed": 5191, "published": 3, "date": "1579704247", "time_retrieved": "2024-07-30T21:29:14.797465", "image_code": "// Commented refactored fork of \"Crowdy waves\" by rory618. https://shadertoy.com/view/ttyGWw\n// All-in-one-buffer variant of the Voronoi particle tracking method: https://www.shadertoy.com/view/wlcXRS\n\n// more refs: https://www.shadertoy.com/results?query=voronoi%20particle%20tracking&sort=newest\n//            rory618's: https://www.shadertoy.com/user/rory618 [which one seminal ?]\n//            wyatt's: https://www.shadertoy.com/results?query=wyatt [which one seminal ?] https://www.shadertoy.com/view/MlVfDR\n//            https://www.shadertoy.com/view/4sK3WK\n// Another refactored/commented (very different) one: https://www.shadertoy.com/view/WtK3zt\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    O = keyFlip(32)\n        ? T1(I)/(R.x*R.y)*N    // space key: draw Id/Voronoi\n        : T2(I);               // draw trace\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === Physics: manage particles pos+V: advect & react\n// see also: Boids physics https://www.shadertoy.com/results?query=boids\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    O = T0(I);              // previous state\n    \n    O.xy = mod(O.xy,R);     // cyclical world\n  //vec4 r = rand4( int(I.x) + int(I.y)*2048 + iFrame*2048*2048);   // deterministic\n  //vec4 r = rand4( int(I.x) + int(I.y)*2048 + (int(iTime*2048.)+iFrame)*2048);\n    vec4 r = rand4( int(I.x) + int(I.y)*2141 + (int(iTime*2141.)+iFrame)*2141); // without 2048 bias\n    \n    if(iFrame<3)            // init: random location, random V , |V|= 1/4\n        O.xy = r.xy*R,\n        O.zw = .25*cos(TAU*(vec2(0,.25)+r.z));\n\n    \n#if 1                       // --- emulate pressure & viscosity (is also boids/schoolfish coeherence)\n    vec4 a = T1(O.xy);      // get the 4 ids in Voronoï buffer at particle location\n    vec2 ns = vec2(0),      //         (should be the closest)\n         df = vec2(0), D;\n    for(int i = 0; i < 4; i++){ \n        vec4 n = A(a[i]);\n        ns += n.zw/4.;      // average velocity\n        D = O.xy - n.xy;\n        D = mod( D + R/2., R ) - R/2.;\n                            // repulsed by nearby particles  \n        if( l2(D) > l2(.005) && l2(D) < l2(10.) )\n        \tdf += normalize(D)/(length(D)+.03);\n    }\n    O.zw += df/25.;         // pressure: apply repulsion force\n    O.zw = mix(O.zw,ns,.1); // visc: V = average Vpartic + relax(oldV+centering)\n#endif\n    \n    if(l2(O.zw) > l2(.001)) // |V| = 1/4 + relax(oldV)\n    \tO.zw = mix(O.zw, normalize(O.zw)/4.,.05);\n    \n    O.zw += randn(r.xy)/1e2; // --- add a bit of random force [init/resized=superimposed]\n\n    if(iMouse.z > 0.){         // --- mouse action on particles\n        vec2 D = O.xy-iMouse.xy, F = D;           // default: repulse\n        if keyDown(64+4 ) F = -D;                 // \"D\": drain\n        if keyDown(64+19) F = vec2( -D.y, D.x);   // \"S\": swirl\n        if keyDown(64+16) F = iMouse.xy-iMouse.zw;// \"P\": push\n        O.zw += normalize(F+1e-5)/(length(D)+.03);\n    }\n    O.xy += O.zw;  // pos += V  (indeed V contains dx/dt )\n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// === Voronoï buffer: manage tracking of particles Ids\n\n// --- insert (i,d) and maintain the 4 closest (i_,d_) \nvoid list_insert(inout vec4 i, inout vec4 d, float i_, float d_){\t\n    if(i_ == 0.) return;           // not a particle : exit\n    if(any(equal(vec4(i_),i))) return; // already in top4 : exit\n    if     (d_ < d[0])             // closer to closest: insert here\n        i = vec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             // closer to 2nd closest: insert here\n        i = vec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])             // closer to 3rd closest: insert here\n        i = vec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])             // closer to 4th closest: insert here\n        i = vec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    vec4  i = vec4(0),\n         i0 = T1( I ),             // 4 closests particles here and around\n         ia = T1( I + vec2( 1, 0) ),  // NB: could use an array.\n         ib = T1( I + vec2( 0, 1) ),\n         ic = T1( I + vec2(-1, 0) ),\n         id = T1( I + vec2( 0,-1) );\n\n//#define dist(i) length( A(i).xy - I )\n//#define dist(i) length( mod( A(i).xy-I + R/2., R) - R/2. )  \nvec2 D;\n#define dist(i) ( D = mod( A(i).xy-I + R/2., R) - R/2., dot(D,D) )\n\n    vec4  d = vec4(1e9); \n    for(int k = 0; k < 4; k++){    // sorts all these\n        list_insert( i, d, i0[k], dist(i0[k]) );\n        list_insert( i, d, ia[k], dist(ia[k]) );\n        list_insert( i, d, ib[k], dist(ib[k]) );\n        list_insert( i, d, ic[k], dist(ic[k]) );\n        list_insert( i, d, id[k], dist(id[k]) );\n    }\n#if 0 // also checking diagonal (to test possibly axis bias)\n    ia = T1( I + vec2( 1, 1) ),\n    ib = T1( I + vec2(-1, 1) ),\n    ic = T1( I + vec2( 1,-1) ),\n    id = T1( I + vec2(-1,-1) );\n    for(int k = 0; k < 4; k++){    // sorts all these\n        list_insert( i, d, ia[k], dist(ia[k]) );\n        list_insert( i, d, ib[k], dist(ib[k]) );\n        list_insert( i, d, ic[k], dist(ic[k]) );\n        list_insert( i, d, id[k], dist(id[k]) );\n    }\n#endif\n    \n    for(int k = 0; k < 1; k++){    // try to re-insert some random particle (possibly escaped from tracking)\n      //int r = IHash( int(I.x) + int(I.y)*2048 + iFrame*2048*2048 +k*11131); //deterministic\n        int r = IHash( int(I.x) + int(I.y)*2141 + iFrame*2141*2141 +k*11131); //without 2048 bias\n      //int r = IHash( int(I.x) + int(I.y)*2048 + (int(iTime*2048.)+iFrame)*2048 +k*11131);\n        int i_ =  1 + r % ( int(R.x*R.y)/int(N) ); // [ why /10? ]\n        list_insert(i, d, float(i_), dist(i_) );\n    }\n    O = vec4(i);                   // stores 4 closest\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N 10. // use only 1/N % of the max Rx*Ry particles (for readability)\n\n// Buff B (1) store Voronoï tracking acceleration structure;\n//            xyzw: ids of 4 closest partics to buffer location\n// Buff A (0) stores particles: \n//            xy: position zw: velocity\n\n// --- translate particle id (in [1,Rx*Ry] ) to buffer pixel \n#define A(n) T0( vec2( (int(n)-1) % iR.x,      \\\n                       (int(n)-1) / iR.x ) +.5 )  // +.5 useless\n\n// --- utils\n                           \n#define R     iResolution.xy\n#define iR    ivec2(iResolution)\n#define T0(U) texelFetch( iChannel0, ivec2(U)   , 0 )\n#define T1(U) texelFetch( iChannel1, ivec2(U)%iR, 0 )\n#define T2(U) texelFetch( iChannel2, ivec2(U)   , 0 )\n\n#define l2(x) dot(x,x)\n\n#define TAU 6.2831853\n                           \n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n                           \n// --- keyboard\n#define key(k,mode) ( texelFetch( iChannel3, ivec2(k,mode), 0 ).x > .5 )\n#define keyDown(k) key(k,0)\n#define  keyHit(k) key(k,1)\n#define keyFlip(k) key(k,2)\n\n\n// --- random numbers\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\n#define Hash(a) ( float(IHash(a)) / float(0x7FFFFFFF) ) // Uniform in [0,1]\n\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\n\n// --- normal law random generator\nvec2 randn(vec2 r){ // r: randuniform\n    r.x = sqrt( -2.* log(1e-9+abs(r.x)));\n    r.y *= TAU;\n    return r.x * vec2(cos(r.y),sin(r.y));\n}\n", "buffer_c_code": "// === draw + blend with fading past\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    O = vec4(0);\n    vec4 a = T1(I), P;         // 4 particule id (supposed to be particles closest to I)\n    \n    for(int i = 0; i < 4; i++) // draw Gaussian blobs\n        P = A(a[i]),\n        O += .4* exp( -.5* l2( I - P.xy ) ) \n               * ( keyFlip(64+3) ? hue( length(P.zw) ) : vec4(1));\n\n    O = mix(O, T2(I), .9);     // blend with fading past\n  //O = mix(O, texture(iChannel2,-.01+1.02*I/R), .9); // false-3D variant\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ty3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[658, 658, 696, 696, 824]], "test": "untested"}
{"id": "wlVGRV", "name": "Better marching (updated)", "author": "NLIBS", "description": "-Dynamic relaxed sphere tracing (seems to always be faster)\n-Early sky detection (would only work for this fractal)\nIt's all at line 102\nCircle colours : outline=overstep, red=slow raymarching, green=fast raymarching, blue/purple=early sky detection", "tags": ["raymarching", "fast"], "likes": 17, "viewed": 787, "published": 3, "date": "1579679425", "time_retrieved": "2024-07-30T21:29:15.549455", "image_code": "/*\nExplanation:\n\n\tEarly sky detecion:\n\n\tIf the point in question returns a large enough distance and \n\tits direction from the origin (0,0,0) is similar to the ray \n\tdirection, it is safe to assume the ray will never hit the \n\tobject again, saving alot of time marching into the distance.\n\n\n\tRelaxed sphere tracing:\n\n\tThis is an old technique. You start your marching with an \n\tomega value. This value multiplies the distance at each step\n\tso that marching is faster. The Only problem is that you \n\tmight march right past something (overstep), but its easy to\n\tdetect if this happened. Just see if the previous distance \n\tplus the Current distance is smaller that what you just \n\tstepped by, and if so go back a bit to make sure you are \n\tcorrect. With this old technique the omega value is set \n\tto 1 after an overstep is detected. But we can do better!\n\n\n\tDynamic relaxed sphere tracing (I just made this up):\n\n\tInstead of just reverting to normal raymarching after an\n\toverstep, simply solve for the highest value of omega that\n\tWouldn't have caused any problems and set it to that! \n\tIts also easy to extend on this by bringing the omega closer\n\tto this optimum amount each step, meaning the marching speed\n\tis always as fast as possible! \n\tWe can also use the distance that was calculated at the \n\toverstep point so that no information is thrown away. (line 140)\n\t\n\n\tThanks, I hope this can help someone out!\n*/\n\n//Ps you can comment line 146 to see normal raymarching instead.\n\n\n\n//fractal params\nconst float w0 = 0.;\nconst float scaleM = 2.;\nconst float iters = 8.;\nconst vec4 offsetM = vec4(0,0,0,0.1);\nconst vec4 ScaleC = vec4(1.,1.,1.,0.5);\nconst vec4 scaleC_c = vec4(\n \tScaleC.x*(scaleM-1.)    /scaleM, // the divide is for more _c\n    ScaleC.y*(scaleM-1.)    /scaleM,\n    ScaleC.z*(scaleM-1.)/scaleM*0.5,\n    ScaleC.w*(scaleM-1.)    /scaleM\n);\nconst float scaleC_c2 = scaleC_c.z*.5;\n\n#define angle 0.12\nconst mat2 rot2D = mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n\n//Mixpinski\nfloat de(vec3 p){\n\tvec4 z = vec4(p,w0);\n\n    float i = 0.;\n\tfloat r = 0.;   \n    for (; i<iters; i++){\n        if(z.x+z.y<0.0) z.xy = -z.yx;\n\t\tif(z.x+z.z<0.0) z.xz = -z.zx;\n        if(z.y+z.z<0.0) z.yz = -z.zy;\n        if(z.x+z.w<0.0) z.xw = -z.wx;\n\t\tif(z.y+z.w<0.0) z.yw = -z.wy;\n\t\tif(z.z+z.w<0.0) z.zw = -z.wz;\n\n\t\tz += offsetM;\n        z = scaleM*vec4(z.xyw-scaleC_c.xyw,scaleC_c2-(z.z-scaleC_c2)*sign(z.z)).xywz;\n        z.xy *= rot2D;\n\t}\n\n    return length(z)*exp2(-i)-1./exp2(iters); //.0017\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Boring variables\n    float stime = (iTime+5.5)*0.31415;\n    float zslice = -.158;//cos(stime);\n    vec3 spos = vec3((fragCoord-iResolution.xy*.5f)/iResolution.x * 5.,zslice);\n    vec3 rd = vec3(cos(sin(stime)*.5+.6),sin(sin(stime)*.5+.6),0);\n    vec2 mouseUV = (iMouse.xy-iResolution.xy*.5f)/iResolution.x * 5.;\n    vec3 ro = vec3(mouseUV,zslice);\n    float T = 0.;\n    \n    //Colour \n    float h = de(spos);\n    vec3 col = vec3((6.-h)*0.04);\n    if (h<=0.) col = vec3(1); //.002\n    \n    \n    //The interesting part\n    float omega = 1.;\n    float pom = 1.;\n    float ph = 1e5;\n    vec2 gap = vec2(0.,0.);\n    for (int i = 0; i<10; ++i) {\n        //Position and distance estimation\n        vec3 p = ro+T*rd;\n        h = de(p);\n        \n        //Drawing circles\n        vec2 shade = mix(vec2(0.1,0.9),vec2(0.9,0.1),smoothstep(1.,2.,omega));\n        float edge = clamp((h-length(spos-p))*100.+1.,0.,1.);\n        col.xy = mix(col.xy, col.xy*shade+1.-shade, edge);\n\t\t//for (int i2 = 0; i2<i+1; i2++) {\n        //   \tcol += step(length(spos-p-vec3((float(i2)-float(i)/2.)*0.03,0,0)),.01)*2.*sign(float(i%2)-.5);\n        //}\n        \n        //Overstep recovery\n        float om = (ph+h)/ph;\n        if (om<pom && pom > 1.) { //ph+h<ph*pom\n            col -= smoothstep(0.008,.0,abs(h-length(spos-p)))*6.; //Draw a black outline\n            \n            gap = vec2(h,T);\n            T+=(1.-pom)*ph;\n            pom = 1.;\n            \n        } else {\n            if (h>.2 && dot(p,rd)>0.3) { //Sky bailout\n            \tif (length(spos-p)<h) col.b = col.b*0.1+0.9; \n            \tbreak;\n            }\n            \n            //Variable updates\n        \tT += h * omega;\n            ph = h;\n            pom = omega;\n            \n            //Back to the place where the gap opened (foward)\n        \tif (T>=gap.y-gap.x && gap.y+gap.x > T) {T = gap.y+gap.x*omega; ph = gap.x;};\n        }\n        \n          \n        //Dynamic Omega \n        //omega = clamp((omega+om)*.5,1.,3.);\n        omega = clamp(omega+(om-omega)*.6,1.,3.);\n    }\n\t\n\t\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1986, 1998, 2015, 2015, 2496], [2499, 2499, 2556, 2584, 4637]], "test": "untested"}
{"id": "wtKGzd", "name": "Hologram Toy", "author": "benburrill", "description": "Raymarch simulation of one of those hologram toys with two parabolic mirrors.\nA ball bounces on a bright circle, but there may be more than meets the eye...\n---\nClick and drag to look inside and see the real ball\nClick again to reset view", "tags": ["raymarch", "mirror", "hologram", "paraboloid", "parabolic"], "likes": 2, "viewed": 576, "published": 3, "date": "1579660224", "time_retrieved": "2024-07-30T21:29:16.296457", "image_code": "/** Hologram Toy -- Ben Burrill\nRaymarch simulation of one of those hologram toys with two parabolic mirrors.\nA ball bounces on a bright circle, but there may be more than meets the eye...\n---\nClick and drag to look inside and see the real ball\nClick again to reset view\n\nI originally wrote this for glslViewer, which has a built-in stateful\ncamera.  On Shadertoy, the best I can do is fake a camera using the\niMouse uniform.  For this shader it's mostly fine, but it would be nice\nto port some of the other shaders I made to Shadertoy and some of those\nrely on the ability to zoom the camera in addition to moving it, and I\ncan't think of any way to finagle Shadertoy's uniforms into getting that\nto work.  If anyone knows of a better way to fake a camera on Shadertoy,\nI'd love to hear about it.\n*/\n\n// A thing in the scene\nstruct Thing {\n    float dist;\n    vec3 color;\n    float refl;  // How reflective the thing is\n};\n\nvoid addThing(inout Thing closest, Thing thing) {\n    if (thing.dist < closest.dist) closest = thing;\n}\n\nfloat paraboloid(vec3 p, float A, float B) {\n    /** Distance function for paraboloid y = A (x^2 + z^2) + B\n    This is an approximation.  I don't know how to get the true closest\n    distance to a paraboloid.  Using the vertical distance above the\n    paraboloid is super easy and works OK, but has some artifacts, so I\n    tried to get closer to true closest distance by making a triangle\n    with the vertical and radial distance.  This seems to converge a lot\n    better on the surface, but it's still not a true distance function.\n    */\n\n    // Shift y so paraboloid starts at origin\n    float y = p.y - B;\n    float r_sq = p.x * p.x + p.z * p.z;\n\n    // Vertical and radial distances\n    float ver = y - A * r_sq;\n    float rad = sqrt(max(y / A, 0.)) - sqrt(r_sq);\n\n    // Pretend it's a cone and find triangular altitude to surface.\n    // It still overshoots, but should be better than either ver or rad.\n    // Sign of vertical distance is ignored.  As a result, the sign of\n    // alt is positive when radially inside, not positive when y is\n    // above the paraboloid like ver is.  So making A negative doesn't\n    // turn the paraboloid inside out like it would if with ver's sign.\n    float alt = abs(ver) * rad / sqrt(ver * ver + rad * rad);\n\n    // When below the paraboloid, use vertical distance to bottom if it\n    // is farther than the altitude.\n    // Otherwise, there would be a line under the paraboloid where the\n    // distance is 0 because the radius of the paraboloid is non-real,\n    // so it is clamped to be 0.\n    return min(sign(A) * y, alt);\n}\n\nThing scene(vec3 p) {\n    float ry = 15.;\n    float y = -ry * .90;\n\n    float sr = 3.;\n    vec3 so = vec3(0., y-ry+sr + ry*(sin(iTime)+1.)/8., 0.);\n    Thing result = Thing(\n        distance(p, so) - sr,\n        // Striped ball coloring\n        (mod(floor(atan(p.z - so.z, p.x - so.x) * 5.), 2.) == 0.)?\n            vec3(1., 0.5, 0.) : vec3(0., 0.5, 0.),\n        0.\n    );\n\n    float foc = 2. * ry - sr;\n    float a = 1. / 4. / foc;\n    addThing(result, Thing(\n        max(p.y, min(paraboloid(p, a, y-ry), paraboloid(p, -a, y+ry))),\n        // Checkerboard pattern coloring\n        (mod(floor(p.x * 0.1) + floor(p.z * 0.1), 2.) == 0.)?\n            vec3(0., 0.2, 0.5) : vec3(0., 0., 0.5),\n        0.8\n    ));\n\n    return result;\n}\n\n// Derivative epsilon.  Seems like a good idea to separate this from the\n// raymarch's epsilon, even though currently they are the same...\n#define DEPS 0.001\nvec3 normal(vec3 p) {\n    /** Normal vector\n    This is pretty inefficient since it needlessly computes colors.\n    I don't really like it, but it works...\n    */\n\n    // The direction of the normal is given by the gradient of the\n    // distance function (direction where distance increases fastest).\n    return normalize(vec3(\n        scene(vec3(p.x + DEPS, p.yz)).dist - scene(vec3(p.x - DEPS, p.yz)).dist,\n        scene(vec3(p.x, p.y + DEPS, p.z)).dist - scene(vec3(p.x, p.y - DEPS, p.z)).dist,\n        scene(vec3(p.xy, p.z + DEPS)).dist - scene(vec3(p.xy, p.z - DEPS)).dist\n    ));\n}\n\n#define EPS 0.001\n#define STEPS 100\nvec3 raymarch(vec3 p, vec3 dir) {\n    float contrib = 1.;\n    vec3 color = vec3(0., 0., 0.);\n\n    for (int i = 0; i < STEPS; i++) {\n        Thing thing = scene(p);\n\n        if (abs(thing.dist) < EPS) {\n            vec3 n = normal(p);\n            vec3 light_dir = normalize(vec3(0., 1., 0.));\n\n            // Ambient lighting\n            color += contrib * (1. - thing.refl) * thing.color;\n\n            contrib *= thing.refl;\n\n            p -= 2. * EPS * dir; // back up a bit\n\n            // Reflection\n            dir -= 2. * dot(n, dir) * n;\n        }\n\n        p += thing.dist * dir;\n    }\n\n    return color;\n}\n\n#define PI 3.14159\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 sc = (fragCoord.xy/iResolution.x -\n               vec2(0.5, 0.5 * iResolution.y / iResolution.x));\n\n    vec2 drag = (iMouse.xy - abs(iMouse.zw)) / iResolution.y;\n    vec2 drag_ang = vec2(1., 0.7) + 0.5 * PI * drag;\n    drag_ang.y = drag_ang.y > 0.? drag_ang.y : 0.;\n    vec3 cam_pos = 50. * vec3(\n        cos(drag_ang.x) * cos(drag_ang.y),\n        sin(drag_ang.y),\n        sin(drag_ang.x) * cos(drag_ang.y)\n    );\n\n    // Allow camera to go upside down.  Is there a better way to do this?\n    vec3 up = drag_ang.y > 0.5 * PI? vec3(0., -1., 0.) : vec3(0., 1., 0.);\n    vec3 forward = normalize(vec3(0., 0., 0.) - cam_pos);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    mat3 cam = mat3(right, up, forward);\n\n    fragColor = vec4(raymarch(\n        cam_pos, normalize(cam * vec3(sc, 1.0))\n    ), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKGzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[925, 925, 974, 974, 1028], [1030, 1030, 1074, 1619, 2608], [2610, 2610, 2631, 2631, 3339], [3499, 3499, 3520, 3800, 4087], [4125, 4125, 4158, 4158, 4737], [4758, 4758, 4813, 4813, 5670]], "test": "untested"}
{"id": "3tG3zV", "name": "Joseph Albers 4", "author": "danamuise", "description": " By Dana Muise. This is a color experiment based on a popular painting by Joseph Albers, The Interaction of Color: \"we do not see colors as they really are. In our perception they alter one another.\" \nSpecial thanks to Patricio Vivo's The Book of Shaders.", "tags": ["illusion", "colortheory", "albers"], "likes": 1, "viewed": 2545, "published": 3, "date": "1579656766", "time_retrieved": "2024-07-30T21:29:17.185081", "image_code": "uniform float u_time;\n\nfloat rect(in vec2 st, in vec2 size){\n\tsize = 0.25-size*0.25;\n    vec2 uv = step(size,st*(1.0-st));\n\treturn uv.x*uv.y;\n}\n\nvec3 DrawBox(int i, vec2 uv, vec4 dim, vec3 col, float blend){\n\tvec3 colorBox = vec3(0.0);\n\n    if(uv.x>dim[0] && uv.x<dim[1] && uv.y>dim[2] && uv.y<dim[3] ) {\n        colorBox = col;\n    }\n    \n    vec3 blendBar = vec3(177.0/255., 162./255., 97./255.);\n\n     if(uv.x>dim[0] && uv.x<dim[1] && uv.y>-0.2 && uv.y<0.2 ){\n     \tcolorBox = mix(colorBox, blendBar, blend);\n\t}\n    \n    if(uv.x>dim[0]+0.1 && uv.x<dim[1]+0.1 && uv.y>-0.2 && uv.y<0.2 ){\n\n       colorBox = mix(colorBox, blendBar, .7);;\n    }\n    \n    if(uv.x>-9.0 && uv.x<dim[0]-1.0 && uv.y>-0.2 && uv.y<0.2 ){\n\n       colorBox = mix(colorBox, blendBar, .7);;\n    }\n    return colorBox; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; // move center\n    \n    vec3 rectColor = vec3(1., abs(sin(iTime))/4.0, 0.0);\n\n    float rectHeight = 0.6;\n    float vOffset = 0.1;\n    float hOffset = 0.1;\n    int numRects = 8;\n\tvec4 dimArray [8];\n    float tempOffset = -0.55 + (sin(iTime)*.1);\n\n    //init rect dimentions array\n    for(int i=1; i<numRects-1; i++){\n\t    //vec4(L, R, T, B)\n    \tdimArray[i] = vec4 (tempOffset, tempOffset+hOffset, -0.35, 0.35);\n    \ttempOffset += hOffset*2.0;\n    }\n    \n    vec3 color = vec3(87.0/255.0, 106.0/255.0, 87.0/255.0);\n    float blend = 0.1/0.6;\n    float index = 0.0;\n    for(int i=0; i<numRects; i++){\n    \tcolor += DrawBox(i, uv, dimArray[i], rectColor, blend*index);\n    \tindex +=1.0;   \n    }    \n    vec3 col = mix(color, vec3(0.5, 0.0, 0.5), abs(sin(iTime))/4.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tG3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 60, 60, 143], [145, 145, 207, 207, 792], [794, 794, 851, 851, 1704]], "test": "untested"}
{"id": "WlK3Rd", "name": "Day 33 - Metalicity", "author": "jeyko", "description": "Coding every day, so the code may be dirty. Read at your own risk.", "tags": ["mdtmjvm"], "likes": 45, "viewed": 1177, "published": 3, "date": "1579644944", "time_retrieved": "2024-07-30T21:29:18.135540", "image_code": "// Fork of \"Day 29 - Dwarf Train\" by jeyko. https://shadertoy.com/view/3tG3RK\n// 2020-01-21 19:48:13\n// Buffer A is draw buffer\n// Buffer B is TAA from https://www.shadertoy.com/view/4dSBDt\n// Image buffer removes buriness from TAA by sharpening from https://www.shadertoy.com/view/MtdXW4\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\t//C += T(c0,U/iResolution.xy);\n    C = sharpen(c0,U/iResolution.xy,iResolution.xy);\n    C *= 1.3;\n    C = mix(C,smoothstep(0.,1.,C), 0.8);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define c0 iChannel0 \n#define c1 iChannel1 \n#define c2 iChannel2 \n#define c3 iChannel3 \n\n#define T(c, uv) texture(c, uv)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define PI pi\n\n\nstruct Mat {\n    vec3 albedo;\n\tfloat metalness; \n\tfloat roughness;\n};\nMat mats[5] = Mat[](\n\tMat(vec3(1)*0.9,0.5,0.23),\n\tMat(vec3(1)*0.1,0.0,0.2),\n\tMat(vec3(1,1,1.)*0.0,0.2,0.5),\n\tMat(vec3(1,1,1.)*0.2,0.2,0.1),\n\tMat(vec3(1,1,1.)*0.2,0.0,0.)\n);  \n\n\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n\n\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n// ----------------------------------------------------------------------------\n\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\n\nvec4 sharpen(sampler2D channel,vec2 uv,vec2 res){\n    vec2 step = 1.0 / res;\n    float kernel [9];vec2 offset [9];\n\n\n    offset[0] = vec2(-step.x, -step.y);\n    offset[1] = vec2(0.0, -step.y);\n    offset[2] = vec2(step.x, -step.y);\n    \n    offset[3] = vec2(-step.x, 0.0);\n    offset[4] = vec2(0.0, 0.0);\n    offset[5] = vec2(step.x, 0.0);\n    \n    offset[6] = vec2(-step.x, step.y);\n    offset[7] = vec2(0.0, step.y);\n    offset[8] = vec2(step.x, step.y);\n    \n    kernel[0] = 0.0; kernel[1] = -0.25; kernel[2] = 0.0;\n    kernel[3] = -0.25; kernel[4] = 1.0; kernel[5] = -0.25;\n    kernel[6] = 0.0; kernel[7] = -0.25; kernel[8] = 0.0;\n    \n    vec4 sum = texture(channel, uv);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 color = texture(channel, uv + offset[i]);\n        sum += color * kernel[i]*2.;\n    }\n    return sum;\n}\n\nvec4 blur(sampler2D channel,vec2 uv,vec2 res){\n    vec2 step = 1.0 / res;\n    float kernel [9];vec2 offset [9];\n\n\n    offset[0] = vec2(-step.x, -step.y);\n    offset[1] = vec2(0.0, -step.y);\n    offset[2] = vec2(step.x, -step.y);\n    \n    offset[3] = vec2(-step.x, 0.0);\n    offset[4] = vec2(0.0, 0.0);\n    offset[5] = vec2(step.x, 0.0);\n    \n    offset[6] = vec2(-step.x, step.y);\n    offset[7] = vec2(0.0, step.y);\n    offset[8] = vec2(step.x, step.y);\n    \n    kernel[0] = 1.0; kernel[1] = 1.; kernel[2] = 1.0;\n    kernel[3] = 1.; kernel[4] = 1.0; kernel[5] = 1.;\n    kernel[6] = 1.0; kernel[7] = 1.; kernel[8] = 1.0;\n    \n    vec4 sum = vec4(0);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 color = texture(channel, uv + offset[i]);\n        sum += color * kernel[i];\n    }\n    sum /= 9.;\n\t\n    return sum;\n}\n\n", "buffer_a_code": "\n\n#define maxIters 120\n#define mx (30.*iMouse.x/iResolution.x)\n#define dmin(a, b) a.x < b.x ? a : b\n#define dmax(a, b) a.x > b.x ? a : b \n#define pmod(p, x) mod(p, x) - x*0.5\n\nfloat r11c(float x){return texture(iChannel0, vec2(x, x*12.5)).x;}\n\nvec2 offsetTunnel(float z){\n    vec2 t = vec2(\n        sin(z*0.1)*2.,\n        cos(z*0.1)*2.\n    );\n    t.y -= 0.;\n\treturn t;\n}\n\n#define szTunnel 1.\n\n#define modDist 10.\n\nvec3 centerPipes = vec3(0);\nvec3 centerTunnel = vec3(0);\n\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n\n    p.xy -= offsetTunnel(p.z);\n    \n    // --- TUNN --- //\n    \n\t\n    centerTunnel = p;\n    d = dmin(d, vec2(-(length(p.xy) - szTunnel), 0.));\n        \n\n\tvec3 q = p;\n    q.z = pmod(q.z, 1.);\n    \n    p.z = pmod(p.z, modDist);\n    \n    // seperations\n    d = dmin(d, vec2(max(-(length(p.xy) - szTunnel*0.9), (abs(q.z) - 0.01)) ,0.));\n    \n    // bolts\n    vec3 i = q;\n    pModPolar(i.xy, 20.);\n    i.x -= 0.96;\n    i.z *= 2.;\n    d = dmin(d, vec2(length(i)-0.04,0.));\n    \n    // seperations2\n    q = abs(q);\n    q.xy *= rot(0.125*pi);\n    q = abs(q);\n    q.xy *= rot(0.125*pi);\n    d = dmin(d, vec2(max(-(length(p.xy) - szTunnel*0.9), (abs(q.x) - 0.01)) ,0.));\n    \n    // --- LAMPS --- //\n    \n    d =dmin(d, vec2(sdCapsule( abs(p) - vec3(0.+ 0.07,szTunnel*0.8,0) , vec3(0,0,0.6), vec3(0.0), 0.04 ), 4.)); \n\n    \n    // --- PIPES --- //\n    i = p;\n    i.x = abs(i.x);\n    i.x -= 0.89;\n    d = dmin(d, vec2(length(i.xy)-0.04,3.));\n    \n    i.xy += 0.45;\n\n    i.x -= 0.02;\n    i.y += 0.12;\n    \n    i.xy *= rot(p.z*0.5);\n    i= abs(i);\n    i.xy -= 0.03;\n    //i.xy *= rot(0.9);i.y -= 0.05; i.y = abs(i.y); i.y -= 0.05;\n    // cables\n    d = dmin(d, vec2(length(i.xy)-0.02,2.));\n    \n    // --- FLOOR --- //\n    float offsFloor = szTunnel*0.67;\n    p.y += offsFloor;\n    p.x = abs(p.x);\n    d = dmin(d, vec2(\n        max(\n            max(max(p.y, (p.x- 0.4) ),\n                -(p.y + 0.1)\n               ),\n            abs(q.z) - 0.42\n            )\n        , 1.));\n    \n    d.x *= 0.9;\n\treturn d;\n}\nvec3 pLamp;\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return -normalize(\n    \t vec3(\n        \tmap(p - t.xyy).x - map(p + t.xyy).x,\n        \tmap(p - t.yxy).x - map(p + t.yxy).x,\n        \tmap(p - t.yyx).x - map(p + t.yyx).x\n        )\n    );\n}\n\n#define fov 0.8\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n\treturn dir + right*uv.x*fov + up*uv.y*fov;\n}\n\nvec3 colLight = vec3(1.)*2.2;\nvec3 glowLight = vec3(0);\nvec3 att = vec3(1.);\nint iters = 0;\nfloat dither;\n//vec3 p\nvec2 march(inout vec3 ro,inout vec3 p,inout vec3 rd, inout float t, inout bool didHit, inout float bounce){\n    p = ro + rd*0.5;vec2 d;\n    didHit = false;\n    for(; iters < maxIters; iters++){\n    \td = map(p);\n        d.x *= dither;\n        if (d.y == 4.)\n            glowLight += exp(-d.x*8.);\n        \n        if(((iters % 7) == 0) && d.x < 0.001){\n            didHit = true;\n            int id = int(d.y); \n            break;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,0,-0.);\n    ro.z += iTime*2. + mx;\n    ro.xy += offsetTunnel(ro.z);\n    \n    vec3 lookAt = ro + vec3(0,0,9);\n    lookAt.xy += offsetTunnel(lookAt.z);\n    \n    dither = mix(0.8,1.,texture(iChannel0,20.*uv*256. + iTime*2.).x);\n    vec3 rd = getRd(ro, lookAt, uv);\n    rd.xy *= 1. - dot(uv,uv)*0.2;\n    rd = normalize(rd);\n\t\n    vec3 p = ro; float t = 0.;vec2 d; vec3 l = vec3(0); bool didHit = false; float bounce = 0.;\n    for (int i = 0; i < 2; i++){\n    \td = march(ro, p, rd, t, didHit, bounce);\n    \n        if(didHit == true){\n            pLamp = vec3(0,szTunnel*0.4,floor(p.z/modDist)*modDist + modDist*0.5 );\n            pLamp.xy += offsetTunnel(pLamp.z);\n\n            vec3 n = getNormal(p);\n            l = normalize(pLamp - p);\n            vec3 h = normalize(l - rd);\n            int id = int(d.y);\n            //id = 0;\n            float metalness = mats[id].metalness;\n            float roughness = mats[id].roughness;\n            roughness = max(roughness, 0.);\n            vec3 albedo = mats[id].albedo;\n            vec3 N = getNormal(p);\n            vec3 V = normalize(ro - p);\n            //vec3 V = -rd;\n\n            if (id == 0) \n            {\n                float t =tex3D(iChannel0,p*0.6, n).b*0.2;\n                roughness -= t;\n            \tmetalness -= t;\n            }\n            if (id == 2) {\n                float t =tex3D(iChannel0,p*0.6, n).b*0.2;\n                roughness -= t;\n            \tmetalness -= t;    \n            }\n\n            vec3 F0 = vec3(0.14); \n            F0 = mix(F0, albedo, metalness);\n\n\n            // calculate per-light radiance\n            float distL    = length(pLamp - p);\n            float attenuation = 0.9 / (distL * distL);\n            vec3 radiance     = colLight * attenuation;        \n\n            // cook-torrance brdf\n            float NDF = DistributionGGX(n, h, roughness);   \n            float G   = GeometrySmith(n, V, l, roughness);      \n            vec3 F    = fresnelSchlick(clamp(dot(n, V), 0.0, 1.0), F0);     \n\n            vec3 kS = F;\n            vec3 kD = vec3(1.0) - kS;\n            kD *= 1.0 - metalness;\t  \n\n            vec3 numerator    = NDF * G * F;\n            float denominator = 4.0 * max(dot(n, V), 0.0) * max(dot(n, l), 0.0);\n            vec3 specular     = numerator / max(denominator, 0.001);  \n\n            // add to outgoing radiance Lo\n            float NdotL = max(dot(n, l), 0.0); \n            col += (kD * albedo / PI + specular) * radiance * NdotL * attenuation*att; \n\t\t\t\n           // col += glow;\n\n            if (id < 2 && bounce != 2.){\n                if(id == 0){\n                \tatt *= max(0.03 - roughness*0.1, 0.);\n                } else {\n                \tatt *= max(0.37 - roughness, 0.);\n                \n                }\n                bounce++;\n                ro = p;\n                rd = reflect(rd, n);\n                t = 0.;\n            } else {\n                break;\n            }\n    }\n        \n    }\n    if(d.y == 4.) col = vec3(1);\n\n    col *= vec3(1.0,1.014,1.02);\n    col += glowLight*0.02;\n    \n    col = pow(col, vec3(0.45));\n    \n    col = clamp(col, 0.07 ,1.);\n    //col = smoothstep(0.,0.6,col);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "ivec2 offsets[8] = ivec2[8]( ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0));\n\nvec3 RGBToYCoCg( vec3 RGB )\n{\n\tfloat Y = dot(RGB, vec3(  1, 2,  1 )) * 0.25;\n\tfloat Co= dot(RGB, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat Cg= dot(RGB, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(Y, Co, Cg);\n}\n\nvec3 YCoCgToRGB( vec3 YCoCg )\n{\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat Cg= YCoCg.z - ( 0.5 * 256.0 / 255.0 );\n\tfloat R= Y + Co-Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co-Cg;\n\treturn vec3(R,G,B);\n}\n\n//#define NO_AA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;    \n    vec3 new = RGBToYCoCg(textureLod(iChannel0, q, 0.0).xyz);\n    vec3 history = RGBToYCoCg(textureLod(iChannel1, q, 0.0).xyz);\n    \n    vec3 colorAvg = new;\n    vec3 colorVar = new*new;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord.xy)+offsets[i], 0).xyz);\n        colorAvg += fetch;\n        colorVar += fetch*fetch;\n    }\n    colorAvg /= 9.0;\n    colorVar /= 9.0;\n    float gColorBoxSigma = 0.75;\n\tvec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg*colorAvg));\n\tvec3 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec3 colorMax = colorAvg + gColorBoxSigma * sigma;\n    \n    history = clamp(history, colorMin, colorMax);\n  \n\tfragColor = vec4(YCoCgToRGB(mix(new, history, 0.95)), 1.0);\n#ifdef NO_AA\n    fragColor = vec4(YCoCgToRGB(new), 1.0);\n#endif\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlK3Rd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 332, 364, 474]], "test": "untested"}
{"id": "3tV3zt", "name": "Communicators", "author": "wyatt", "description": "Click to add points and watch the graph communicate. Sometimes your roommates don't know how to communicate... ", "tags": ["graph"], "likes": 44, "viewed": 817, "published": 3, "date": "1579643450", "time_retrieved": "2024-07-30T21:29:18.899497", "image_code": "void mainImage( out vec4 Q, in vec2 U )\n{\n    Q = B(U).z*C(U+2.).zzzz;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n//Texture lookups :\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define Main void mainImage( out vec4 Q, in vec2 U )\n#define N 7.\n#define For for (float i = -(N); i<=(N); i++)\n#define S 2.\n#define Gaussian(i) 0.3989422804/S*exp(-.5*(i)*(i)/S/S)\n#define W 25.\n\n// Distance to line\nvec2 ln (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn vec2(length(p-a-(b-a)*i),i);\n}", "buffer_a_code": "void X (inout vec4 Q, vec2 U, vec2 r) {\n    vec4 n = A(U+r);\n    if (ln(U,n.xy,n.zw).x<ln(U,Q.xy,Q.zw).x) Q = n;\n    else if (ln(U,Q.xy,n.zw).x<ln(U,Q.xy,Q.zw).x) Q.zw = n.zw;\n}\nvoid Xr (inout vec4 Q, vec2 U, float r) {\n\t X(Q,U,vec2(r,0));\n     X(Q,U,vec2(0,r));\n     X(Q,U,vec2(0,-r));\n     X(Q,U,vec2(-r,0));\n}\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    Q = vec4(0);\n\tXr(Q,U,1.); \n\tXr(Q,U,2.); \n\tXr(Q,U,3.); \n    \n    Q.xy += B(Q.xy).xy;\n    Q.zw += B(Q.zw).xy;\n    \n    if (length(U-Q.zw)<length(U-Q.xy)) {\n    \tvec2 u = Q.xy;\n        Q.xy = Q.zw;\n        Q.zw = u;\n    }\n    \n    if (Q.x< 1.) Q.xy = Q.zw;\n    if (Q.z< 1.) Q.zw = Q.xy;\n    \n    if (iMouse.z>0.) {\n        vec4 n = iMouse.xyxy;\n        if (ln(U,n.xy,n.zw).x<ln(U,Q.xy,Q.zw).x) Q = n;\n    \tif (ln(U,Q.xy,n.xy).x<ln(U,Q.xy,Q.zw).x) Q.zw = n.xy;\n    }\n   \n    if (iFrame < 1) {\n        if (length(U-0.5*R)<55.)\n    \tQ = floor(U/10.+0.5).xyxy*10.;\n    }\n    if (length(Q.xy-Q.zw) > W) Q.zw = Q.xy;\n    \n    if (iFrame%40==0) if (length(U-0.5*R+7.*sin(float(iFrame)))<length(U-Q.xy)) Q.xy = 0.5*R; \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 Q, in vec2 U )\n{\n    vec4 a = A(U), b = B(U);\n\tvec2 u = a.xy-a.zw;\n    float r = length(u);\n    vec2 l = ln(U,a.xy,a.zw);\n\tif (r>1.) Q.xy =  250.*u/r/r*smoothstep(3.,1.,l.x)*exp(-5.*l.y);\n\telse Q.xy = vec2(0);\n    \n    Q.zw = vec2(1);\n    Q *= smoothstep(1.,2.,length(U-a.xy));\n    Q *= smoothstep(0.,1.,ln(U,a.xy,a.zw).x);\n\tQ.zw = mix(Q.zw,b.zw,0.7);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n{\n    Q = vec4(0);\n    For Q += Gaussian(i) * A(U+vec2(0,i));\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n{\n    Q = vec4(0);\n    For Q += Gaussian(i) * A(U+vec2(i,0));\n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tV3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 72]], "test": "untested"}
{"id": "3lK3zd", "name": "Rainbow Mandelbrot", "author": "Cobbleopolis", "description": "just messing around with colors and the mandelbrot", "tags": ["fractal"], "likes": 0, "viewed": 299, "published": 3, "date": "1579643211", "time_retrieved": "2024-07-30T21:29:19.654479", "image_code": "#define ITER 100.0\n#define STEP_TIME 0.1\n#define SCALE 0.45\nconst vec2 center = vec2(0.5, 0.0);\n\nconst vec3 color1 = vec3(1.0, 0.0, 0.0);\nconst vec3 color2 = vec3(0.0, 0.0, 1.0);\n\nvoid mainImage( out vec4 fragColor,  vec2 uv ) {\n\tuv /= iResolution.xy;\n\tvec2 c = vec2(4, 3) * (uv - .5) / (SCALE * 3.0) - center, z = c;\n\n    fragColor -= fragColor;\n    \n    float v = 0.0;\n\n    for(float i=0.; i < (ITER / 100.0); i+=.01) \n        if( length(z = mat2(z, -z.y, z.x) * z + c) > 2.) { \n            v += 1.0 - i;\n            break;\n        }\n    \n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n    fragColor = mix(vec4(1.0 - col, 1.0), vec4(col, 1.0), v);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lK3zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 228, 228, 673]], "test": "untested"}
{"id": "WtV3zt", "name": "Spreading fire", "author": "Roninkoi", "description": "Some sort of weird fire effect using three colors. LMB starts fire.", "tags": ["fire", "diffusion"], "likes": 1, "viewed": 474, "published": 3, "date": "1579635762", "time_retrieved": "2024-07-30T21:29:20.464314", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n    fragColor.b += 0.1;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord)/iResolution.xy;\n    \n    vec2 n = (fragCoord + vec2(0.0, 1.0))/iResolution.xy;\n    vec2 s = (fragCoord + vec2(0.0, -1.0))/iResolution.xy;\n    vec2 w = (fragCoord + vec2(-1.0, 0.0))/iResolution.xy;\n    vec2 e = (fragCoord + vec2(1.0, 0.0))/iResolution.xy;\n    \n    vec4 nc = texture(iChannel0, n);\n    vec4 sc = texture(iChannel0, s);\n    vec4 wc = texture(iChannel0, w);\n    vec4 ec = texture(iChannel0, e);\n    \n    if (iMouse.z > 0.0) {\n\t    if (round(fragCoord) == round(iMouse.xy)) {\n\t        fragColor = vec4(1.0, 0.01, 0.000001, 1.0)*100000.0;\n\t        return;\n    \t}\n    }\n    \n    float t = 0.4 * iTime;\n    \n    float nr = texture(iChannel1, n + 0.3*abs(vec2(cos(t*1.1), sin(t*1.59)))).r;\n    float sr = texture(iChannel1, s + 0.3*abs(vec2(cos(t*1.3), sin(t)*1.47))).r;\n    float wr = texture(iChannel1, w + 0.3*abs(vec2(cos(t)*1.23, sin(t*1.43)))).r;\n    float er = texture(iChannel1, e + 0.3*abs(vec2(cos(t)*1.37, sin(t*1.41)))).r;\n    \n    nr *= pow(nr, 1.2);\n    sr *= pow(sr, 1.2);\n    wr *= pow(wr, 1.2);\n    er *= pow(er, 1.2);\n    \n    fragColor.rgb = (0.25 * (nc*nr + sc*sr + wc*wr + ec*er)*4.0).rgb;\n    \n    fragColor.r = clamp(fragColor.r, 0.0, 10000000.0);\n    fragColor.g = clamp(fragColor.g, 0.0, 10000.0);\n    fragColor.b = clamp(fragColor.b, 0.0, 100.0);\n    \n    fragColor.a = 1.0;\n}\n", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtV3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 242]], "test": "untested"}
{"id": "WlVGRd", "name": "spooky2", "author": "Del", "description": "spooky", "tags": ["spooky"], "likes": 7, "viewed": 357, "published": 3, "date": "1579635326", "time_retrieved": "2024-07-30T21:29:21.243231", "image_code": "// spooky2 21/01/2019\n\nfloat map(vec3 p)\n{\n\tp.xy += sin(p.x*0.1+iTime*0.8+p.z*1.2)*0.3;\n\tp.x += sin(iTime+p.y*.15)*0.2;\n\tvec3 tp = mod(p, 2.0) - 1.0;\n\tfloat t = length(tp.xz) - 0.26;\n\tp.y = abs(p.y*(sin(iTime*0.4+p.z*0.25)*0.25+1.55));\n\tt = min(t, 2.0 - dot(p, vec3(sin(p.z+iTime*0.2)*0.2, 1, 0)));\t// tilt\n\treturn t;\n}\n\nfloat trace(vec3 p, vec3 d)\n{\n\tfloat t = 0.0;\n\tfor(int i = 0 ; i < 22; i++)\n \t t += map(p + d * t);\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat tt = step(mod(iTime+4.0,10.0),3.0);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tvec3 pos = vec3(0, 0, iTime*(0.8+tt*4.0));\n\tfloat t = trace(pos, dir);\n\tvec3 col = vec3(t*0.1,t*0.07,t*0.07);\n\tcol -= abs(sin(iTime+t*2.0)*0.05);\n\tif (tt>0.0)\n\t\tcol = 0.7-col;\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    float v = 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n\tfragColor = vec4(col*v, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 42, 42, 319], [321, 321, 350, 350, 433], [435, 435, 492, 492, 951]], "test": "untested"}
{"id": "WtK3zt", "name": "chaotic particle swarm 2", "author": "FabriceNeyret2", "description": "refactoring + comments of [url]https://shadertoy.com/view/ttK3Rc[/url]\n( also twice faster )  SPACE \n\nPrinciple of \"Voronoi particle tracking\":  try so store P(x,y) closer and closer to location (x,y)\nA,B is doubled as C,D in order to make faster fluid.\n", "tags": ["2d", "noise", "particles", "voronoiparticletracking"], "likes": 62, "viewed": 2576, "published": 3, "date": "1579630329", "time_retrieved": "2024-07-30T21:29:22.044090", "image_code": "// Commented refactored fork of unnick's shader https://shadertoy.com/view/ttK3Rc\n// more refs: https://www.shadertoy.com/results?query=voronoi%20particle%20tracking&sort=newest\n//            rory618's: https://www.shadertoy.com/user/rory618 [which one seminal ?]\n//            wyatt's: https://www.shadertoy.com/results?query=wyatt [which one seminal ?] https://www.shadertoy.com/view/MlVfDR\n//            https://www.shadertoy.com/view/4sK3WK\n// another refactored/commented (very different) one: https://www.shadertoy.com/view/3ty3Dy\n\n//[unnick said:]\n//its still a mystery to me how to make particles interact with each other though\n//ive seen some people use the gauss-seidel method to solve a poisson equation\n//but idk how that works\n\n//i use a divergence-free vector field together with the midpoint method to move particles\n\n#define keyFlip(k) ( texelFetch( iChannel3, ivec2(k,2), 0 ).x > .5 )\n\nvoid mainImage(out vec4 O,  vec2 _pos) \n{\n    vec4 state = T(_pos); // we assume particle pos(x,y) is very close of storage(x,y)\n    \n    O = keyFlip(32)\n        ? vec4( fract(state.xy/30.), state.z, 0) // displays particle-voronoi pos & id\n        :   exp(-.2*l2( state.xy - _pos ) )      // draw gaussian spot\n          * sqrt( sin((state.z + vec4(0,1,2,0)/3.) * tau) * .5 + .5); // hue\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 col, in vec2 _pos) \n{\n    // col = content closest to pos within neighborhood (2-length cross around pos)\n    swapN(_pos,col);\n    \n    // init\n    if(iFrame == 0) col = vec4(1e4);\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define res   iResolution.xy\n#define ires  ivec2(res)\n#define tau   6.283185\n#define l2(v) dot(v,v)\n#define T(U)  texelFetch(iChannel0, ivec2(U), 0)\n\n//velocity field\n#define       speed .2\n#define    posscale 2e-3\n#define   timescale .1\n//particle creation\n#define npartchance .01\n#define     mindist 7.\n//voronoi tracking\n#define checkradius 2\n\n\n// --- swapN: col = content closest to pos within neighborhood (2-length cross around pos) if closer than pos\n\n// pos.xy = particle location  pos.z = Id\n// strategy is to try so store P(x,y) closer and closer to buff location (x,y)\n// Indeed, this creates small voronoi regions with (pos, id). (uncomment last line in Image to see).\n\n// NB: iChannel0 forbidden in Common :-( -> Pass as parameter or use macro\n#define swap(state, p, offs) \\\nif(!any(bvec4(greaterThanEqual(p+offs, ires), lessThan(p+offs, ivec2(0)))))\\\n{ vec4 n = T(p+offs);        \\\n  if ( l2(n.xy - vec2(p)-1.) < l2(state.xy - vec2(p)-1.) ) state = n;      \\\n}\n\n// NB: iChannel0 forbidden in Common :-( -> Pass as parameter or use macro\n#define swapN(_pos,col)                     \\\n    ivec2 pos = ivec2(_pos);                \\\n    col = T(pos);                           \\\n    for(int i = 1; i <= checkradius; i++) { \\\n        swap(col, pos, ivec2( i, 0));       \\\n        swap(col, pos, ivec2( 0, i));       \\\n        swap(col, pos, ivec2(-i, 0));       \\\n        swap(col, pos, ivec2( 0,-i));       \\\n    }\n\n\n// --- rand, noise and fluids \n\nuint hash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash3i1f(uvec3 p) {\n    return float(hash(hash(hash(p.x) ^ p.y) ^ p.z) >> 8) / 16777216.;\n}\n\n//computes the x and y derivatives of a noise field \nvec2 noise(vec3 p) {\n    uvec3 i = uvec3(ivec3(floor(p)));\n     vec3 f =             fract(p)  ,\n          u = f*f*f*(f*(f*6.-15.)+10.),\n         du = 30.*f*f*(f*(f-2.)+1.);\n\n#define g(x,y,z) sin( tau* ( hash3i1f(i+uvec3(x,y,z)) + vec2(0,.25) ) ) // SC(rand angle)\n    vec2 ga = g(0,0,0),\n         gb = g(1,0,0),\n         gc = g(0,1,0),\n         gd = g(1,1,0),\n         ge = g(0,0,1),\n         gf = g(1,0,1),\n         gg = g(0,1,1),\n         gh = g(1,1,1);\n \n#define v(g,i,j)  dot(g, f.xy - vec2(i,j))\n    float va = v(ga,0,0),\n          vb = v(gb,1,0),\n          vc = v(gc,0,1),\n          vd = v(gd,1,1),\n          ve = v(ge,0,0),\n          vf = v(gf,1,0),\n          vg = v(gg,0,1),\n          vh = v(gh,1,1);\n    \n    return mix(mix(mix(ga, gb, u.x), mix(gc, gd, u.x), u.y),\n               mix(mix(ge, gf, u.x), mix(gg, gh, u.x), u.y), u.z)\n         + du.xy * mix(u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va,\n                       u.yx*(ve-vf-vg+vh) + vec2(vf,vg) - ve, u.z);\n}\n\nvec2 fluidnoise(vec3 p) {\n    vec2 total = vec2(0);\n    float amp = 1.;\n    for(int i = 0; i < 5; i++) {\n        total += noise(p) * amp;\n        p = p*2. + 4.3; amp *= 1.5;\n    }\n    return total.yx * vec2(-1,1); // divergence-free field\n}\n\n// advection with midpoint method\n// NB: iTime forbidden in Common :-( -> Pass as parameter or use macro\n#define fluidStep(P) { \\\n    vec2 tmp = P + fluidnoise(vec3( P  * posscale , iTime * timescale)) * .5 * speed; \\\n              P += fluidnoise(vec3(tmp * posscale, (iTime+iTimeDelta*.5) * timescale)) * speed;\\\n}\n", "buffer_b_code": "void mainImage(out vec4 col, in vec2 _pos) \n{\n    // col = content closest to pos within neighborhood (2-length cross around pos)\n    swapN(_pos,col);\n\n    // move fluid\n    fluidStep(col.xy);\n   \n    // create particle from time to time when too far to pos (i.e. region empty of partic)\n    if ( fract(hash3i1f(uvec3(pos,iFrame))) < npartchance\n         && mindist < length(col.xy - _pos - 1.) \n       ) \n       col = vec4(_pos, hash3i1f(uvec3(pos,iFrame+1000)), 0);\n    \n    \n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 col, in vec2 _pos) \n{\n    // col = content closest to pos within neighborhood (2-length cross around pos)\n    swapN(_pos,col);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 col, in vec2 _pos) \n{\n    // col = content closest to pos within neighborhood (2-length cross around pos)\n    swapN(_pos,col);\n\n    // move fluid ( 2 steps per frame ).\n    fluidStep(col.xy);\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[904, 904, 945, 945, 1294]], "test": "untested"}
{"id": "WtK3Rt", "name": "HaaH WaaW", "author": "luluco250", "description": "Only professional shaders in this website.", "tags": ["2d", "filter", "meme"], "likes": 2, "viewed": 357, "published": 3, "date": "1579622482", "time_retrieved": "2024-07-30T21:29:22.853925", "image_code": "void mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    vec2 mouse = iMouse.xy * ps;\n    mouse.x = (iMouse.z > 0.0)\n        ? mouse.x\n        : abs(fract(iTime * 0.075) - 0.5) * 2.0;\n        //: sin(iTime * 0.3) * 0.5 + 0.5;\n    \n    if (mouse.x < 0.5)\n    \tuv.x = (uv.x < mouse.x)\n        \t? mouse.x - (uv.x - mouse.x)\n        \t: uv.x;\n    else\n        uv.x = (uv.x > mouse.x)\n        \t? mouse.x - uv.x + mouse.x\n        \t: uv.x;\n    \n    color = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3Rt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 539]], "test": "untested"}
{"id": "ttK3Rc", "name": "chaotic particle swarm", "author": "unnick", "description": "voronoi particle tracking is awesome!", "tags": ["2d", "noise", "particles", "flownoise", "midpoint"], "likes": 25, "viewed": 1402, "published": 3, "date": "1579620447", "time_retrieved": "2024-07-30T21:29:23.668746", "image_code": "//its still a mystery to me how to make particles interact with each other though\n//ive seen some people use the gauss-seidel method to solve a poisson equation\n//but idk how that works\n\n//i use a divergence-free vector field together with the midpoint method to move particles\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    vec4 state = texelFetch(iChannel0, ivec2(_pos), 0);\n    float len = length(state.xy - _pos);\n    col = exp(-len*len*.2) * sqrt(sin((state.z + vec4(0,1,2,0)/3.) * tau) * .5 + .5);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void swap(inout vec4 state, ivec2 p, ivec2 offs) {\n    if(any(bvec4(greaterThanEqual(p+offs, ires), lessThan(p+offs, ivec2(0))))) return;\n    vec4 n = texelFetch(iChannel0, p+offs, 0);\n    vec2 tmp = vec2(p+1);\n    if(length(n.xy-tmp) < length(state.xy-tmp)) state = n;\n}\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    col = texelFetch(iChannel0, pos, 0);\n    //check if any neighbooring particles are closer to the current pixel\n    //than the particle currently stored\n    for(int i = 1; i <= checkradius; i++) {\n        swap(col, pos, ivec2( i, 0));\n        swap(col, pos, ivec2( 0, i));\n        swap(col, pos, ivec2(-i, 0));\n        swap(col, pos, ivec2( 0,-i));\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    //initial conditions\n    if(iFrame == 0) col = vec4(1e4);\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define res iResolution.xy\n#define ires ivec2(iResolution.xy)\n#define tau 6.283185\n\n//velocity field\n#define speed .2\n#define posscale 2e-3\n#define timescale .1\n//particle creation\n#define npartchance .01\n#define mindist 7.\n//voronoi tracking\n#define checkradius 2\n\nuint hash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash3i1f(uvec3 p) {\n    return float(hash(hash(hash(p.x) ^ p.y) ^ p.z) >> 8) / 16777216.;\n}\n\n//computes the x and y derivatives of a noise field \nvec2 noise(vec3 p) {\n    uvec3 i = uvec3(ivec3(floor(p)));\n     vec3 f =             fract(p)  ;\n    vec3  u = f*f*f*(f*(f*6.-15.)+10.);\n    vec3 du = 30.*f*f*(f*(f-2.)+1.);\n    \n    vec2 ga = sin((hash3i1f(i+uvec3(0,0,0))+vec2(0,.25))*tau);\n    vec2 gb = sin((hash3i1f(i+uvec3(1,0,0))+vec2(0,.25))*tau);\n    vec2 gc = sin((hash3i1f(i+uvec3(0,1,0))+vec2(0,.25))*tau);\n    vec2 gd = sin((hash3i1f(i+uvec3(1,1,0))+vec2(0,.25))*tau);\n    vec2 ge = sin((hash3i1f(i+uvec3(0,0,1))+vec2(0,.25))*tau);\n    vec2 gf = sin((hash3i1f(i+uvec3(1,0,1))+vec2(0,.25))*tau);\n    vec2 gg = sin((hash3i1f(i+uvec3(0,1,1))+vec2(0,.25))*tau);\n    vec2 gh = sin((hash3i1f(i+uvec3(1,1,1))+vec2(0,.25))*tau);\n    \n    float va = dot(ga, f.xy - vec2(0,0));\n    float vb = dot(gb, f.xy - vec2(1,0));\n    float vc = dot(gc, f.xy - vec2(0,1));\n    float vd = dot(gd, f.xy - vec2(1,1));\n    float ve = dot(ge, f.xy - vec2(0,0));\n    float vf = dot(gf, f.xy - vec2(1,0));\n    float vg = dot(gg, f.xy - vec2(0,1));\n    float vh = dot(gh, f.xy - vec2(1,1));\n    \n    return mix(mix(mix(ga, gb, u.x), mix(gc, gd, u.x), u.y),\n               mix(mix(ge, gf, u.x), mix(gg, gh, u.x), u.y), u.z)\n         + du.xy * mix(u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va,\n                       u.yx*(ve-vf-vg+vh) + vec2(vf,vg) - ve, u.z);\n}\n\nvec2 fluidnoise(vec3 p) {\n    vec2 total = vec2(0);\n    float amp = 1.;\n    for(int i = 0; i < 5; i++) {\n        total += noise(p) * amp;\n        p *= 2.; p += 4.3; amp *= 1.5;\n    }\n    return total.yx * vec2(-1,1);\n}\n", "buffer_b_code": "void swap(inout vec4 state, ivec2 p, ivec2 offs) {\n    if(any(bvec4(greaterThanEqual(p+offs, ires), lessThan(p+offs, ivec2(0))))) return;\n    vec4 n = texelFetch(iChannel0, p+offs, 0);\n    vec2 tmp = vec2(p+1);\n    if(length(n.xy-tmp) < length(state.xy-tmp)) state = n;\n}\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    col = texelFetch(iChannel0, pos, 0);\n    //check if any neighbooring particles are closer to the current pixel\n    //than the particle currently stored\n    for(int i = 1; i <= checkradius; i++) {\n        swap(col, pos, ivec2( i, 0));\n        swap(col, pos, ivec2( 0, i));\n        swap(col, pos, ivec2(-i, 0));\n        swap(col, pos, ivec2( 0,-i));\n    }\n    //move particles according to the fluidnoise vector field with the midpoint method\n    vec2 tmp = col.xy + fluidnoise(vec3(col.xy * posscale, iTime * timescale)) * .5 * speed;\n    col.xy += fluidnoise(vec3(tmp * posscale, (iTime+iTimeDelta*.5) * timescale)) * speed;\n    //create a new particle with a small chance if\n    //the distance to the nearest particle is too big\n    bool cansplit = hash3i1f(uvec3(pos,iFrame)) < npartchance;\n    vec4 newpart = vec4(_pos, hash3i1f(uvec3(pos,iFrame+1000)), 0);\n    if(length(col.xy - _pos - 1.) >= mindist && cansplit) col = newpart;\n    \n    \n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void swap(inout vec4 state, ivec2 p, ivec2 offs) {\n    if(any(bvec4(greaterThanEqual(p+offs, ires), lessThan(p+offs, ivec2(0))))) return;\n    vec4 n = texelFetch(iChannel0, p+offs, 0);\n    vec2 tmp = vec2(p+1);\n    if(length(n.xy-tmp) < length(state.xy-tmp)) state = n;\n}\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    col = texelFetch(iChannel0, pos, 0);\n    //check if any neighbooring particles are closer to the current pixel\n    //than the particle currently stored\n    for(int i = 1; i <= checkradius; i++) {\n        swap(col, pos, ivec2( i, 0));\n        swap(col, pos, ivec2( 0, i));\n        swap(col, pos, ivec2(-i, 0));\n        swap(col, pos, ivec2( 0,-i));\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void swap(inout vec4 state, ivec2 p, ivec2 offs) {\n    if(any(bvec4(greaterThanEqual(p+offs, ires), lessThan(p+offs, ivec2(0))))) return;\n    vec4 n = texelFetch(iChannel0, p+offs, 0);\n    vec2 tmp = vec2(p+1);\n    if(length(n.xy-tmp) < length(state.xy-tmp)) state = n;\n}\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    ivec2 pos = ivec2(_pos);\n    col = texelFetch(iChannel0, pos, 0);\n    //check if any neighbooring particles are closer to the current pixel\n    //than the particle currently stored\n    for(int i = 1; i <= checkradius; i++) {\n        swap(col, pos, ivec2( i, 0));\n        swap(col, pos, ivec2( 0, i));\n        swap(col, pos, ivec2(-i, 0));\n        swap(col, pos, ivec2( 0,-i));\n    }\n    //move particles according to the fluidnoise vector field with the midpoint method\n    vec2 tmp = col.xy + fluidnoise(vec3(col.xy * posscale, iTime * timescale)) * .5 * speed;\n    col.xy += fluidnoise(vec3(tmp * posscale, (iTime+iTimeDelta*.5) * timescale)) * speed;\n    \n    \n    \n    \n    \n    \n    \n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttK3Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 323, 323, 508]], "test": "untested"}
{"id": "WlKGRt", "name": "glsl bug #189", "author": "FabriceNeyret2", "description": "the top should be yellow and the bottom like a B&W keyboard.\nBug: on OpenGL(linux, at least) nvidia, top appears black ( compiler bug causing a side effect in \"if\" ?)", "tags": ["glsl", "bug"], "likes": 0, "viewed": 385, "published": 3, "date": "1579619108", "time_retrieved": "2024-07-30T21:29:24.482570", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = vec4(0);         // just in case\n    \n    if (U.y<100.) { O = vec4(mod(U.x,10.)); return;}\n\n\n    O.rg = vec2(1);\n  //O.rg ++;             // does work\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKGRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 199]], "test": "untested"}
{"id": "3lKGRt", "name": "IEEE float precision: x/x != 1", "author": "FabriceNeyret2", "description": "a  reminder that x/x is not always exactly 1 on computer (ex: 33/33), especially with IEEE float, especially on GPU.\n( because is 33*(1/33), and 1/33 cannot be represented exactly in IEEE floats. )\nticks every 0%10.", "tags": ["glsl", "precision", "bug", "floats"], "likes": 4, "viewed": 346, "published": 3, "date": "1579618680", "time_retrieved": "2024-07-30T21:29:25.244533", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n#if 0\n    U += .00001*iTime; // micro-variations \n#else\n    U = floor(U);      // U integer\n#endif\n    \n    if (min(U.x,U.y)<10.) { O = mod(max(U.x,U.y),10.)==0. ? vec4(0,0,1,1):vec4(1); return;}\n \n    U /= U + min(0.,iTime); // hack because windows optimizer is smart ;-)\n    O.rg = vec2(U.x==1., U.y==1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKGRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 353]], "test": "untested"}
{"id": "wlG3Rd", "name": "2D noise contour", "author": "hiogawa", "description": "I just heard that you can make contour lines simply by feeding it to any periodic function.\nAlso, I was curious how it looks if we rotate gradient used for noise interpolation.", "tags": ["2d", "noise"], "likes": 7, "viewed": 647, "published": 3, "date": "1579611982", "time_retrieved": "2024-07-30T21:29:26.166069", "image_code": "float M_PI = 3.1415;\n\nfloat SCALE = 3.0;\nfloat NUM_OCTAVES = 2.0;\nfloat SCALE_TIME = 0.1;\n\nfloat SCALE_CONTOUR = 32.0;\nvec2 CLIP_RANGE = vec2(0.8, 1.0);\nvec3 COLOR1 = vec3(1.0, 0.0, 1.0);\nvec3 COLOR2 = vec3(0.0, 1.0, 1.0);\n\n// R -> [0, 1)\nfloat hash11(float t) {\n  return fract(sin(t * 56789.0) * 56789.0);\n}\n\n// R^2 -> [0, 1)\nfloat hash21(vec2 uv) {\n  return hash11(hash11(uv[0]) + 2.0 * hash11(uv[1]));\n}\n\nvec2 hashGradient2(vec2 uv) {\n  float t = hash21(uv);\n  return vec2(cos(2.0 * M_PI * t), sin(2.0 * M_PI * t));\n}\n\nfloat mix2(float f00, float f10, float f01, float f11, vec2 uv) {\n  return mix(mix(f00, f10, uv[0]), mix(f01, f11, uv[0]), uv[1]);\n}\n\nvec2 rotate2(vec2 uv, float r) {\n  mat2 R = mat2(\n    cos(r), sin(r),\n   -sin(r), cos(r)\n  );\n  return R * uv;\n}\n\n// R^2 -> [0, 1)\n// support additional argument to rotate gradient\nfloat gradientNoise(vec2 uv, float r) {\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  vec2 g00 = rotate2(hashGradient2(uvi + vec2(0.0, 0.0)), r);\n  vec2 g10 = rotate2(hashGradient2(uvi + vec2(1.0, 0.0)), r);\n  vec2 g01 = rotate2(hashGradient2(uvi + vec2(0.0, 1.0)), r);\n  vec2 g11 = rotate2(hashGradient2(uvi + vec2(1.0, 1.0)), r);\n  float f00 = dot(g00, uvf - vec2(0.0, 0.0));\n  float f10 = dot(g10, uvf - vec2(1.0, 0.0));\n  float f01 = dot(g01, uvf - vec2(0.0, 1.0));\n  float f11 = dot(g11, uvf - vec2(1.0, 1.0));\n  float t = mix2(f00, f10, f01, f11, smoothstep(vec2(0.0), vec2(1.0), uvf));\n\n  // Normalize via upper/lower bound = +- 1 / sqrt(2) ~ 0.7\n  return (t / 0.7 + 1.0) * 0.5;\n}\n\nfloat noise(vec2 uv, float r) {\n  float result = 0.0;\n  for (float i = 0.0; i < NUM_OCTAVES; i++) {\n    float p = pow(2.0, i);\n    result += (gradientNoise(uv * p, r) / p);\n  }\n  result /= (pow(2.0, NUM_OCTAVES) - 1.0) / (pow(2.0, NUM_OCTAVES - 1.0));\n  return result;\n}\n\nfloat wave(float t) {\n  return 0.5 * (1.0 - cos(SCALE_CONTOUR * M_PI * t));\n}\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  vec2 uv =  SCALE * frag_coord / iResolution.y;\n\n  float noise_fac = noise(uv, SCALE_TIME * 2.0 * M_PI * iTime);\n  float contour_fac = wave(noise_fac);\n  float clip = smoothstep(CLIP_RANGE[0], CLIP_RANGE[1], contour_fac);\n  vec3 color = mix(COLOR1, COLOR2, noise_fac);\n\n  frag_color = vec4(color * clip, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlG3Rd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 239, 262, 262, 308], [310, 327, 350, 350, 406], [408, 408, 437, 437, 520], [522, 522, 587, 587, 654], [656, 656, 688, 688, 768], [770, 837, 876, 876, 1527], [1529, 1529, 1560, 1560, 1799], [1801, 1801, 1822, 1822, 1878], [1880, 1880, 1934, 1934, 2247]], "test": "untested"}
{"id": "tlG3Rd", "name": "Xor Stack (254 chars)", "author": "FabriceNeyret2", "description": "code golfing of [url]https://shadertoy.com/view/3llXz2[/url] (528 chars)\n\nNote that blur is done by x 10 oversampling. Maybe it could be done shortly analytically.", "tags": ["loop", "2tweets", "golf"], "likes": 12, "viewed": 359, "published": 3, "date": "1579611838", "time_retrieved": "2024-07-30T21:29:27.009813", "image_code": "// golfing \"Xor Stack\" by yx: https://shadertoy.com/view/3llXz2 (528 chars)\n\nvoid mainImage(out vec4 O, vec2 u) {\n    for ( float t = fract(iTime/4.);\n          O.a++ < 12.; t += .1/60.) {\n        vec2 R = iResolution.xy, s = vec2(-3,3),\n             U = 15.* (u+u-R)/R.y / exp2(t);\n        vec4 p = .33 +smoothstep(.2,0.,t-.1*vec4(1,3,5,7) );\n        p = max( abs(U.x-p*s.xyyx), abs(U.y-p*s.yyxx) ) -2.;\n        p.x*p.y*p.z*p.w < 0. ? O += .1 : O;\n    };\n}/*\n\n\n\n\n\n// -- 259 chars\n\n#define mainImage(O,u)                                      \\\n    float t = fract(iTime/4.);                              \\\n    for (int i = 0; i++ < 10; t += .1/60.) {                \\\n        vec2 R = iResolution.xy, s = vec2(-3,3),            \\\n             U = 15.* (u+u-R)/R.y / exp2(t);                \\\n        vec4 p = .33 +smoothstep(.2,0.,t-.1*vec4(1,3,5,7) );\\\n        p = max( abs(U.x-p*s.xyyx), abs(U.y-p*s.yyxx) ) -2.;\\\n        p.x*p.y*p.z*p.w < 0. ? O += .1 : O;                 \\\n    }                                                      /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlG3Rd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 113, 113, 457]], "test": "untested"}
{"id": "Wly3zt", "name": "Meandering", "author": "Plento", "description": "Bored ", "tags": ["3d", "blur", "bump"], "likes": 10, "viewed": 449, "published": 3, "date": "1579576664", "time_retrieved": "2024-07-30T21:29:28.287397", "image_code": "// Plento\n\nvec2 R;\n\n\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\nconst int SAMPLES = 25;\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 m = iMouse.xy / R.xy-.5; \n    m.x *= R.x/R.y;\n    \n    vec2 uv2 = u/R;\n    \n    vec3 col = texture(iChannel0, uv2).xyz;\n    \n    float w = .1; \n    vec2 tuv = vec2(uv2.x, uv2.y)-.5;\n    vec2 dTuv = -tuv*.5/float(SAMPLES);\n    \n    uv2 += dTuv*(hash(uv.xy + fract(iTime))*2.0 )*2.;\n    \n    vec3 blur = vec3(0);\n    \n    \n    for(int i = 0;i < SAMPLES; i++){\n        uv2 -= dTuv;\n        vec3 samp = texture(iChannel0, uv2).xyz * w;\n       \n        blur += samp;\n        \n        w *= 0.96;\n    }\n    \n    col = mix(col, blur, smoothstep(0., 0.7, length(uv)));\n    \n    \n    f = vec4(col, 1.0);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Plento\nvec2 R;\n\n#define ss(a, b, t) smoothstep(a, b, t)\n#define movement(a) sin(a*1.3 + iTime)*.6  \nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\nvec3 tex(vec2 p){return texture(iChannel0, p).xyz;   }\nvec2 m(){\n    vec2 m = iMouse.xy / iResolution.xy-.5; \n    m.x *= iResolution.x/iResolution.y;\n\treturn m;\n}\nfloat map(vec3 rp){\n    rp.y += movement(rp.z);\n    rp.xz *= rot(rp.y*.3);\n    return .8-length(rp.xy);\n}\n\nvec3 normal( in vec3 pos ){vec2 e = vec2(0.002, -0.002);return normalize(e.xyy * map(pos + e.xyy) + e.yyx * map(pos + e.yyx) + e.yxy * map(pos + e.yxy) + e.xxx * map(pos + e.xxx));}\nfloat march(vec3 rd, vec3 ro){float t = 0., d = 0.;for(int i = 0; i < 60; i++){d = map(ro + rd*t);if(abs(d) < .002 || t > 64.){break;}t += d * .7;}return t;}\n\nfloat height(vec2 p){return tex(p).r;}\n\nvec3 TextureBump(vec2 uv, float strength){\n    float h = 0.002;\n    \n    vec3 p = tex(uv); \n    float dx = height(uv) - height(uv + vec2(h, .0));\n    float dy = height(uv) - height(uv + vec2(0., h));\n    \n    return normalize( vec3(0., 0., -1.) + vec3(dx, dy, 0.)*strength);\n}\n\nvec3 color(vec3 p, vec3 rd, vec3 n, vec2 u, float t){\n    vec3 ld = normalize(-p);\n   \t\n    p.y += movement(p.z);\n    p.z += iTime * 1.4;\n    p.x = abs(p.x);\n    \n    vec3 bn = TextureBump(p.xz*.3, 120.0);\n    vec3 col = mix(vec3(1., 0., 1.)*.25, vec3(.6), tex(p.xz*.3).r);\n    \n    n = normalize(n + bn);\n    \n    float spec = pow(max(dot(normalize(reflect(ld, n)), rd), 0.), 12.);\n    float dif = max(dot(n, ld), .02);\n    \n    col *= 2.8*dif*vec3(1);\n    col += vec3(.8, .4, .2) * spec * 1.25;\n    \n    col = mix(vec3(0.), col, exp(-t*t*t*.062));\n    \n\treturn 1.-exp(-col * .7);   \n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 m = iMouse.xy / R.xy-.5; \n    m.x *= R.x/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 0.6));\n    rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * -0.2));\n    vec3 ro = vec3(0., 0., 0.);\n    \n    rd.xy*=rot(iTime*.2);\n    \n    float t = march(rd, ro);\n    \n    vec3 n = normal(ro + rd*t);\n    vec3 col = color(ro + rd*t, rd, n, u, t);\n    \n    col *= ss(1.05, 0., length(uv));\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}\n\n\n", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wly3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 42, 42, 97], [124, 124, 164, 164, 839]], "test": "untested"}
{"id": "3tG3zt", "name": "Pure Vorofluid", "author": "michael0884", "description": "No pressure solve! More voronoi particle tracking!\n[url]JAVASCRIPT: H=location.host;E=(H?window:opener).Effect;P=E.prototype;if(!E.P)E.P=P.Paint;P.Paint=function(...A){for(i=0;i<8;i++)E.P.apply(this,A);};if(!H)close();[/url]", "tags": ["particles", "what"], "likes": 13, "viewed": 490, "published": 3, "date": "1579571531", "time_retrieved": "2024-07-30T21:29:29.038389", "image_code": "// Fork of \"Wavy beams\" by michael0884. https://shadertoy.com/view/3tK3Dm\n// 2020-01-21 00:52:31\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tvec4 particle = texel(ch0, pos);\n    float distr = gauss(pos - particle.xy, prad);\n    vec4 flow = 0.5*texel(ch1, pos);\n    fragColor = vec4(cos(particle.zwz*vec3(5.2,2.6,1.0)), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//voronoi particle tracking \n\nfloat border(vec2 a)\n{\n    return min(minn(a), minn(size - a));\n}\n\nvec3 minv(vec3 a, vec3 b)\n{\n    return (a.z>b.z)?b:a;\n}\n\nvec3 borderF(vec2 a)\n{\n    return minv(minv(minv(vec3(1.,0.,a.x),vec3(0.,1.,a.y)),vec3(-1.,0.,size.x - a.x)),vec3(0.,-1.,size.y - a.y));\n}\n\nbool inside(vec2 a)\n{\n    if(border(a) > 1.) return true;\n    return false;\n}\n\n//loop the vector\nvec2 loop_d(vec2 pos)\n{\n\treturn mod(pos + size*0.5, size) - size*0.5;\n}\n\n//loop the space\nvec2 loop(vec2 pos)\n{\n\treturn mod(pos, size);\n}\n\n\nvoid Check(inout vec4 U, vec2 pos, vec2 dx)\n{\n    vec4 Unb = texel(ch0, loop(pos+dx));\n    //check if the stored neighbouring particle is closer to this position \n    if(length(loop_d(Unb.xy - pos)) < length(loop_d(U.xy - pos)))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec2 pos, float r)\n{\n    Check(U, pos, vec2(-r,0));\n    Check(U, pos, vec2(r,0));\n    Check(U, pos, vec2(0,-r));\n    Check(U, pos, vec2(0,r));\n}\n\n#define rad 2\nvec2 computeforce(vec4 pr)\n{\n    vec2 F = vec2(0);\n    for(int i = -rad; i <= rad; i++)\n        for(int j = -rad; j <= rad; j++)\n        {\n            if(i != 0 && j != 0)\n            {\n                //neighbor particle\n                vec2 cell = pr.xy+vec2(i,j);\n                vec4 nb = texel(ch0, cell);\n                if(maxx(abs(nb.xy - cell))<0.5) //if neighbor is inside its cell then count force (to exclude repeated evals)\n                {\n                    vec2 dv = nb.zw - pr.zw; //velocity difference\n                    vec2 dr = nb.xy - pr.xy; //position vector\n                    vec2 tanv = dot(dv,dr)*dr/(dot(dr,dr) + 1e-3); //tangental velocity\n                    F += 1.*tanv*exp(-0.1*dot(dr,dr)) + 1.3*dr*exp(-2.*dot(dr,dr));\n                }\n            }\n        }\n    vec3 borderval = borderF(pr.xy);\n    F += 0.2*borderval.xy*exp(-borderval.z);\n    return F;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 muv = iMouse.xy/size;\n   \n    //this pixel value\n    U = texel(ch0, pos);\n    \n    //check neighbours \n    CheckRadius(U, pos, 1.);\n    CheckRadius(U, pos, 2.);\n    CheckRadius(U, pos, 3.);\n    CheckRadius(U, pos, 4.);\n    CheckRadius(U, pos, 5.);\n   \n    U.xy = loop(U.xy);\n    \n    // particle cloning \n    if(length(U.xy - pos) > 3.)\n    \tU = vec4(pos, 0.95*U.zw);\n\n\t//update the particle    \n    U.zw = U.zw + dt*computeforce(U);\n    U.xy += dt*U.zw;\n    \n    U.xy = loop(U.xy);\n    \n    \n    if(iFrame < 1 || (iMouse.z > 0. && length(iMouse.xy - pos) < 30.) || (maxx(abs(size.xy*0.5 - pos)) < 50.))\n    {\n        U.xy = vec2(pdens*round(pos.x/pdens),pdens*round(pos.y/pdens));\n        U.zw = 10.*(hash22(U.xy) - 0.5);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//simulation variables\n#define dt 0.3\n#define prad 1.\n\n\n#define pdens 2.\n//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n//functions\nfloat gauss(vec2 x, float r)\n{\n    return exp(-pow(length(x)/r,2.));\n}\n   \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\n//Gradient\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n\n\nfloat angle_between(vec2 a,vec2 b)\n{\n    return atan(a.x*b.y-a.y*b.x,dot(a,b));\n}\n\nfloat minn(vec2 a)\n{\n    return min(a.x, a.y);\n}\n\nfloat maxx(vec2 a)\n{\n    return max(a.x, a.y);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tG3zt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 149, 149, 335]], "test": "untested"}
{"id": "WlGGzt", "name": "Symmetric Nearest-Neighbour blur", "author": "fenwick67", "description": "Proof of concept implementing the Symmetric Nearest Neighbour smoothing algorithm as detailed in https://observablehq.com/@jobleonard/symmetric-nearest-neighbour-all-the-things. This is only box blur.\n\nChange r on line 73 to change the blur radius.", "tags": ["postprocessing", "blur", "smoothing", "cartoonify"], "likes": 5, "viewed": 662, "published": 3, "date": "1579566164", "time_retrieved": "2024-07-30T21:29:29.903077", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define CHANNEL iChannel0\n#define colorDist colorDistFast\n\nfloat colorDistFast(vec4 c1, vec4 c2){\n\tfloat dr = c1.r - c2.r;\n    float dg = c1.g - c2.g;\n    float db = c1.b - c2.b;\n    return dr * dr + dg * dg + db * db;\n}\n\nfloat colorDistAccurate(vec4 c1, vec4 c2){\n\tvec4 c = c1 - c2;\n    float y = c.r * 0.2124681075446384 + c.g * 0.4169973963260294 + c.b * 0.08137907133969426;\n  \tfloat i = c.r * 0.3258860837850668 - c.g * 0.14992193838645426 - c.b * 0.17596414539861255;\n  \tfloat q = c.r * 0.0935501584120867 - c.g * 0.23119531908149002 + c.b * 0.13764516066940333;\n  \treturn y*y + i*i + q*q;\n}\n\n\n// pick one of the 4 diagonal pixels!\n// d.x must not be zero\nvec4 pick4(vec2 center, vec2 d){\n    \n    float closest_dist = 10000000000000.0f;\n    vec4 pick;\n    vec4 sampCenter = texture(CHANNEL, center/ iResolution.xy);\n    \n\tvec4 samp;\n    float dist;\n    \n\tsamp = texture(CHANNEL, (center+d) / iResolution.xy);\n    dist = colorDist(sampCenter, samp);\n    if (closest_dist > dist){\n        pick = samp;\n        closest_dist = dist;\n    }\n    samp = texture(CHANNEL, (center-d) / iResolution.xy);\n    dist = colorDist(sampCenter, samp);\n    if (closest_dist > dist){\n        pick = samp;\n        closest_dist = dist;\n    }\n    \n    samp = texture(CHANNEL, (center+vec2(d.y*-1.0f, d.x)) / iResolution.xy);\n    dist = colorDist(sampCenter, samp);\n    if (closest_dist > dist){\n        pick = samp;\n        closest_dist = dist;\n    }\n    samp = texture(CHANNEL, (center-vec2(d.y*-1.0f, d.x)) / iResolution.xy);\n    dist = colorDist(sampCenter, samp);\n    if (closest_dist > dist){\n        pick = samp;\n        closest_dist = dist;\n    }\n    \n    return pick;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tif (fragCoord.x < iMouse.x){// show unmodified\n\t\tfragColor = texture(CHANNEL, fragCoord.xy / iResolution.xy);\n    } else if (abs(fragCoord.x - iMouse.x) < 1.5f){// render line\n    \tfragColor = vec4(1.0f, 1.0f, 1.0f, 2.0f) - texture(CHANNEL, fragCoord.xy / iResolution.xy);\n    }else {// blur\n        \n\t\tint r = 5;\n        vec3 color;\n\t\t\n\t\tfor (int i=1; i <= r; i++)\n\t\t{\n\t\t\tfor (int j=0; j <= r; j++)\n\t\t\t{\n\t\t\t\tcolor += pick4(fragCoord.xy, vec2(i, j)).rgb;\n\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tfragColor = vec4(color/float(r*(r+1)), 1.0);\n\t}\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 143, 143, 266], [268, 268, 310, 310, 643], [646, 708, 740, 740, 1706], [1708, 1708, 1765, 1765, 2292]], "test": "untested"}
{"id": "3tGGzt", "name": "Differential Geometry ", "author": "wyatt", "description": "using some math I learned from my continuum mechanics shader", "tags": ["blackmagic"], "likes": 4, "viewed": 452, "published": 3, "date": "1579561792", "time_retrieved": "2024-07-30T21:29:30.761781", "image_code": "Main {\n\tQ = A(U);\n    Neighborhood;\n   \tQ = length(Q.xy)*3.3-2.+ 2.*vec4(abs(Q.w),length(Q.zw),abs(Q.z),1);\n\tQ = abs(sin(Q));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Main void mainImage (out vec4 Q, vec2 U)\n#define R iResolution.xy\n#define A(U) texture(iChannel0,X((U),iMouse.z>0.?iMouse.xy:0.5*R)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n\n#define curl 0.25*(e.y-w.y+s.x-n.x)\n#define conv 0.25*(w.x-e.x+s.y-n.y)\n#define grad 0.25*vec2(w.z-e.z,s.z-n.z)\n#define darg 0.25*vec2(s.w-n.w,e.w-w.w)\n\n#define a 0.002\n#define c vec4(.3,0.01,0.01,1)\n\nvec2 X (vec2 U, vec2 r) {\n\tU -= r;\n    U *= (1.-a)*mat2(cos(a),-sin(a),sin(a),cos(a));\n    U += r;\n    return U;\n    \n}", "buffer_a_code": "Main {\n    Q = A(U);\n    Neighborhood;\n    Q = mix(Q,m,c.w);\n    vec2 x = darg+grad;\n    Q.xy += x;\n    if (length(x) > 0.) Q.xy = mix(Q.xy,normalize(x),c.x);\n    Q.z = mix(Q.z,conv,c.y);\n    Q.w = mix(Q.w,curl,c.z);\n    \n    if (iFrame < 1) Q = sin(0.1*U.xyxy);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = A(U);\n    Neighborhood;\n    Q = mix(Q,m,c.w);\n    vec2 x = darg+grad;\n    Q.xy += x;\n    if (length(x) > 0.) Q.xy = mix(Q.xy,normalize(x),c.x);\n    Q.z = mix(Q.z,-conv,c.y);\n    Q.w = mix(Q.w,-curl,c.z);\n    \n    if (iFrame < 1) Q = sin(0.1*U.xyxy);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = A(U);\n    Neighborhood;\n    Q = mix(Q,m,c.w);\n    vec2 x = darg+grad;\n    Q.xy += x;\n    if (length(x) > 0.) Q.xy = mix(Q.xy,normalize(x),c.x);\n    Q.z = mix(Q.z,-conv,c.y);\n    Q.w = mix(Q.w,-curl,c.z);\n    \n    if (iFrame < 1) Q = sin(0.1*U.xyxy);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = A(U);\n    Neighborhood;\n    Q = mix(Q,m,c.w);\n    vec2 x = darg+grad;\n    Q.xy += x;\n    if (length(x) > 0.) Q.xy = mix(Q.xy,normalize(x),c.x);\n    Q.z = mix(Q.z,-conv,c.y);\n    Q.w = mix(Q.w,-curl,c.z);\n    \n    if (iFrame < 1) Q = sin(0.1*U.xyxy);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGGzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wlKGR3", "name": "Day 32 - Fruit Salad", "author": "jeyko", "description": "Why this compiles in 3 seconds ._. is beyond me.\nI dunno, so, yeah! The drop is some FM stuff.\nTried to refactor my sound engine. \nAll of the sound/instrument logic is in // ----- INSTRUMENTS ----- // in common.", "tags": ["mdtmjvm"], "likes": 12, "viewed": 423, "published": 3, "date": "1579544462", "time_retrieved": "2024-07-30T21:29:31.801003", "image_code": "// so\n\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}    \n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.8+0.5*sin(iTime),1.0);\n\n}   ", "image_inputs": [], "sound_code": "\n// i_____ = instrument\n// g_____ = generator\n// e_____ = effect\n// c_____ = channel\n\n// toolchain goes i > g > e > c\n\n\nfloat tGlobal;              \n\nconst float base = 12.;           \nvec2[] scaleA = vec2[8](\n\tvec2(base,0),\n\tvec2(base + 2.,0),      \n\tvec2(base + 3.,0),\n\tvec2(base + 5.,0),                  \n\tvec2(base + 7.,0),\n\tvec2(base + 7.,0),   \n\tvec2(base + 10.,0),\n\tvec2(base + 12.,0)\n);\n\n\n           \nfloat arpA(float t,vec2[8] scale, float period, float rep, float seed){\n\tfloat n = 0. ;\n    float r = r11( mod( floor(t/period), rep) + seed);\n    r *= 7.  ;\n    r = floor(r)   ;\n    n = note(scaleA[int(r)].x, scaleA[int(r)].y);\n    return n;\n}\n\n// ------------ GENERATORS ------------ //\n  \nvec2 gKick(float t){\n    vec2 s = vec2(0);\n\tt = mod(t, hbeat);\n    vec2 introK = iKick(t);\n    s += iKick(t);\n\treturn s;\n}\n\n\nvec2 gCymbal(float t){\n\tvec2 s = vec2(0);\n    \n    t -= hbeat*0.5;\n    t = mod(t, beat);\n    float env = exp(-t*1.);\n    s += iCymbal(t, 0. )*env;\n        \n    //t = step(t, hbeat);\n    \n    \n    return s;\n}\nvec2 gCymbalB(float time){\n    //if (time < measure*2.) return vec2(0);\n    \n    time = mod(time, qbeat);\n    if (mod(time, hmsr) < 0.25){\n//    \ttime = mod(time, qbeat*8.) - hbeat/2.;\n    } else {\n//    \ttime = mod(time, qbeat*4.) - hbeat/2.;\n    }\n\t\n\tfloat s;\n    \n    int t = int(time*iSampleRate/7.);\n    t = int(time*iSampleRate);\n        \n    \tt = t % ((t >>3) % t*2);\n        s =float(t & 0xff - 128)/ 128.;\n        s *= pow(exp(-mod(time,qbeat*20.)), 30.);\n        s = (s + (s*noise(time * mod(time, 0.1)*1.))*3.*exp(-time));\n    \ts *= exp(-time*20.);\n        s *= 3.;\n    \n    s = clamp(s, -1., 1.);\n\treturn vec2(s);\n}\n\n\nvec2 gHats(float t){\n\tvec2 s;\n    float currentMeasure = floor(t/(measure));\n    Q(measure*4.){\n        Q(measure*2.){\n            s += iHatsC(mod(t , bar) + 0.001);\n            QL(measure*1.){\n                s += iHatsC(mod(t + hbar*0.99, bar) + 0.001)*0.6;\n            }\n        } else {\n            s += iHatsC(mod(t, hbar)*2. + 0.001)*2.;\n            QL(measure*3.){\n            \ts += iHatsC(mod(t + hbar*0.5, hbar)*2. + 0.001)*2.;\n            }\n        }\n        \n    }else {\n        s += iHatsA(mod(t, qbeat))*0.4;\n        s += iHatsB(mod(t + 0.08, qbeat))*0.4;\n        \n    }\n    return s;\n}\n\n\nvec2 gBass(float t){\n\tvec2 s = vec2(0);\n    float ramp = smoothstep(1., 0., fract(t/hbeat));\n    float freq = note(0., 0.);\n    Q(measure*4.){\n        QL(measure*3. + beat*10.){\n\t\t\tt = t - (measure*3. + beat*10.);\n            float envA = exp(-t*2.);\n            float envB = smoothstep(0.,1.,t);\n        \ts += sin(20.*TT*t + 2.*noise(t)*(1. - exp(-t*2.)))*envB;\n        }\n    }\n    \n    QL(measure*4.){\n        t = mod(t, measure*2.) + measure*4.;\n        Q(measure*5.){\n            float id = mod(t/hmsr,2.);\n            float rA = rT(floor(t/hmsr));\n            t = mod(t, hmsr);\n            Q(beat){\n                if(id == 1.){\n                    s += sin((freq + ramp*100.)*TT);\n                    s = sat(s,1.1 );\n                } else {\n                    s += sin((freq*2. )*TT + sin(4.*freq*TT)*0.4 + sin((40.*freq + ramp)*4.*TT)*0.4*(0.8 - ramp));\n                }\n                //s = s*(1.-satAmt) +  (s / (abs(s)))*satAmt;\n            } E Q(beat*4.){\n                //s += sin( (freq*2. )*TT+ sin(freq*4.*TT)*0.1 + sin(freq*10.*TT)*(0.4 + sin(t*25.)*0.4) );\t\n                s += sin( (freq*2. )*TT+ sin(freq*4.*TT)*0.3 + sin(freq*10.*TT)*(0.4 + sin(t*25.)*0.4) );\t\n                s = sat(s,1.3 );\n            } E Q(beat*6.){\n                float env = smoothstep(0.,1.,(t - beat*4.)*7.);\n                float freq = note(0. + 3.,0.); // don't do this lol\n                float n = noise(t);\n                s += sin( (freq*2. )*TT\n                         + sin(freq*4.*TT)*0.1\n                         + sin(freq*20.*TT)*(0.4 + sin(t*11.)*0.4)\n                        )*env;\t\n            } E Q(beat*8.){ \n                float env = smoothstep(0.,1.,(t - beat*6.)*7.);\n                float freq = note(0. - 5.,0.); // don't do this lol\n                float n = noise(t);\n                float ramp = smoothstep(1., 0., fract(t/beat));\n                float m = +(1. - ramp/2.)*1.;\n                s += sin( (freq*2. + sin(ramp*pi)*0. )*TT\n                         + sin((freq)*4.*TT)*0.1\n                         + sin((freq )*30.*TT  + (1. - ramp)*200.)*(0.4 + n*0.0  + sin(t*11.)*0.4)\n\n                        )*env;\t\n\n            }\n        }\n        QL(measure*5.){\n            float id = mod(t/hmsr,2.);\n            float rA = rT(floor(t/hmsr));\n            t = mod(t, hmsr);\n            Q(beat){\n                if(id == 1.){\n                    s += sin((freq + ramp*100.)*TT);\n                    s = sat(s,1.1 );\n                } else {\n                    s += sin((freq*2. )*TT + sin(26.*freq*TT)*0.3 + sin((40.*freq + ramp)*1.*TT)*0.5*(0.8 - ramp));\n                }\n                //s = s*(1.-satAmt) +  (s / (abs(s)))*satAmt;\n            } E Q(beat*4.){\n                float m = (t < beat*4. - beat) ? sin(t*85.) : sin(t*25.);\n                //s += sin( (freq*2. )*TT+ sin(freq*4.*TT)*0.1 + sin(freq*10.*TT)*(0.4 + sin(t*25.)*0.4) );\t\n                s += sin( (freq*2. )*TT+ sin(freq*4.*TT)*0.3*m + sin(freq*10.*TT)*(0.4 + m*0.4) );\t\n                s = sat(s,1.3 );\n            } E Q(beat*6.){\n                float env = smoothstep(0.,1.,(t - beat*4.)*7.);\n                float freq = note(0. + 3.,0.); // don't do this lol\n                float n = noise(t);\n                s += sin( (freq*2. )*TT\n                         + sin(freq*2.*TT)*0.1\n                         + sin(freq*20.*TT)*(0.4 + sin(t*4.)*0.4)\n                        )*env;\t\n                s = sat(s, 1.5);\n            } E Q(beat*8.){ \n                float env = smoothstep(0.,1.,(t - beat*6.)*7.);\n                float freq = note(0. - 5.,0.); // don't do this lol\n                float n = noise(t);\n                float ramp = smoothstep(1., 0., fract(t/beat));\n                float m = +(1. - ramp/2.)*1.;\n                s += sin( (freq*2.   )*TT\n                         + sin((freq)*10.*TT)*0.2\n                         + sin((freq )*41.*TT  )*(0.76 - n*0.0 ))*env;\t\n\n            }        \n        }\n\n    \n    }\n\n    \n    \n    return s;\n}\n\nvec2 gPads(float t){\n    vec2 s = vec2(0);\n    \n    #define padInstr iSuperSaw\n    \n    Q(measure*2.){\n    }else Q(measure*4.){\n            float repLen = bar;\n            t= mod(t,repLen*4.);\n            float lT = mod(t, repLen);\n\t\t\tfloat env = exp(-mod(t, repLen)*0.4);  \n            float[4]chord;\n            Q(repLen){addChord((f(26.), f(12. + 10.), f(12. + 7.) , f(12. + 3.)), 4.,chord)}\n            else Q(repLen*2.) {addChord((f(24. - 3.), f(12. + 10. - 3.), f(12. + 7. - 3.) , f(24. + 3. - 3.)), 4.,chord)}\n            else Q(repLen*3.) {addChord((f(26. + 5.), f(12. + 10. + 5.), f(12. + 7. + 5.) , f(12. + 3. + 5.)), 4.,chord)}\n            else Q(repLen*4.) {addChord((f(24. - 5.), f(12. + 10. - 5.), f(12. + 7. - 5.) , f(24. + 3. - 5.)), 4.,chord)}\n            //Q(beat, {addChord((f(26.), f(12. + 10.), f(12. + 7.) , f(12. + 3.)), 4.,padInstr, env,lT,s)})\n            playChord(chord, 4,padInstr, env, t,s);   \n    }\n    s *= 0.9;\n    \n\treturn s;\n}\n\n\nvec2 gLead(float t){\n    vec2 s = vec2(0);\n    float tB = t;\n    float rep = beat;\n    float freq = arpA(t, scaleA,rep, 14., 19.);\n    t = mod(t,rep);\n    //float env = exp(-t*8.);\n    freq *= 4.;\n    //s += iPlucky(t, freq) ;\n    eChorus(t, iPlucky,freq, 10.,20., s, 1.);\n\n    //s = eLofi(s, 4.);\n    s *= 0.9;\n\treturn s;\n} \n\n\nvec2 gIntroDrone(float t, float i){\n\tvec2 s = vec2(0);\n\n    QL(measure*2.) return vec2(0);\n    \n    float freqA = note(12., 0.);\n    float freqB = note(3., 1.);\n    float freqC = note(12. + 7., 1.);\n    float scale = 0.1;\n    float iters = 6.;\n    for (float i = 0.; i < iters; i++) {\n    \n        s.x += sin(tau*t*freqA    )*scale * 0.5;\n        s.x += sin(tau*t*freqB    )*scale * 0.5;\n        s.x += sin(tau*t*freqC  + smoothstep(0.,1.,sin(t) * noise(vec2(t))*0.5)  )*scale * 0.4;\n    \tfreqA *= 2.002 +noise(i)*0.3 + sin(t + i)*0.002;\n    \tfreqC *= 2.002 +noise(i)*0.3 + sin(t + i)*0.002;\n    \tfreqB *= 1.501;\n        scale *= 0.2 + smoothstep(0.,1., t*0.2)*0.3 + cos(t * 0.2)*0.1;\n    }\n    s.y = s.x;\n    \n    return s;\n}\n\n\nvec2 gSnare(float t){\n\tvec2 s = vec2(0);\n    vec2 s1 = iSnareGhidra(mod(t + beat, beat));\n    Q(measure*4.){\n    } else QL (measure*4.){\n    \ts += s1;\n    }\n    \n    return s;\n}\n// ------------ CHANNELS ------------ //\n\nvec2 cSpringReverb(float t){\n\tvec2 s = vec2(0);\n    float iters = 10.;\n    float st = 7./iSampleRate;\n    for(float i = 0.; i < iters; i++){\n        float offs = r11(i)*0.02; // electronic\n    \ts += gPads(t - st*i - offs)*(1. - i/iters);\n    \ts += gHats(t - st*i - offs*0.2)*(1. - i/iters)*2.;\n    }\n\n    s /= iters;\n    s *= 2.;\n    //s = sat(s, 2.);\n    //s = clamp(s, -1., 1.);\n    //s /= 2.;\n    return s;\n}\n\nvec2 cEchoInput(float t){\n\treturn gLead(t);\n}\nvec2 cEcho(float t) {\n\tvec2 s = vec2(0);\n    float fb = 0.65, tm = qbeat*1.5, cf = 0.9, ct = tm;\n    // tap 1 \n    s += cEchoInput(t) * cf; cf *= fb; \n    // tap 2\n    s += cEchoInput(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 3\n    s += cEchoInput(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 4\n    s += cEchoInput(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 5\n    //s += cEchoInput(t - ct) * cf; cf *= fb; ct += tm;\n    \n    return s;\n}\n\n// ------------ MAIN ------------ //\n\nvec2 mainSound( in int samp, float t )\n{\n    #ifdef tOffset\n    t += tOffset;\n    #endif\n    vec2 s = vec2(0);\n    tGlobal = t;\n    \n    // drums\n    vec2 kick = gKick(t);\n    vec2 bass = gBass(t);\n    vec2 snare = gSnare(t);\n    vec2 iirKick; eIIR(t, gKick, 6., 10., iirKick); \n    vec2 cym1bal = gCymbal(t);\n    vec2 cymbalB = gCymbalB(t);\n    vec2 kickR = gKickR(t + measure);\n    vec2 hats = gHats(t);\n    \n    \n    // synths\n    vec2 pads = gPads(t);\n    vec2 introDrone = gIntroDrone(t,0.)/3.;\n    vec2 lead = gLead(t);   \n    vec2 reverb = cSpringReverb(t);\n    vec2 echo = cEcho(t);\n   \t        \n    \n    // mixer\n\t//pads *= sideChain(t);\t\n    //reverb *= sideChain(t);\t\n    s += kickR*0.7;\n    s += bass*0.24;\n    s += pads*0.4;   \n    s += introDrone*2.;\n\n    s += reverb*0.5;\n    //s += hats*3.;\n    s += echo*0.2;\n    s += snare*0.18;\n\n    s *= 0.7;\n    //s = clamp(s, -1., 1.);\n    s = sat(s, 1.7);\n    return s;\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define tOffset 0. + measure*4. + beat*9.\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT tau*t\n  \n#define tempo 174.\n#define hbeat ((60./tempo)/1.)\n#define qnote (hbeat/2.)\n#define beat  (hbeat*2.)\n#define qbeat  (beat/4.)\n#define measure  (beat*4.*4.)\n#define hmsr  (measure*0.5)\n#define bar (0.5*hmsr)\n#define hbar (0.5*bar)\n\n#define P(x) t/measure < x\n#define PL(x) t/measure > x\n   \n#define E else\n#define sStep (1./iSampleRate)\n\n#define f(x) float(x)\n#define sat(x, amt) clamp(x*amt, -1., 1.)\n#define Q(period)  \\\n\tif (t < period)\n#define QL(period)  \\\n\tif (t > period)\n\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\nfloat r11(float i){\n\treturn fract(sin(i*742.62412)*1535.52156);\n}\n\n#define rT(i) texture(iChannel0, vec2(i)).x\nfloat noise( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\n\nfloat noise(float t){\n    float n = 0.;\n    n = fract(r11(t)*r11(t*2.41));\n    vec2 p = vec2(fract(r11(t*14.11)),fract(r11(t*124.1)*r11(t*3.15)));\n    vec2 q = vec2(fract(r11(t*14.124)*r11(t*41.15)), n*0.15);\n    n = fract(dot(p,q));\n\treturn n;\n}   \nfloat notVeryRandom(float st){\n    return fract(sin(st*451.5524));\n}\n\n// ------------ EFFECTS ------------ //\n\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i)/(m)+0.5)*(m))\n\n#define eIIR(t, instr, stSz, iters, varName) \\\n\t{\t\t\t\t\t\t\t\t\t\t \\\n    \tvarName = vec2(0);\t\t\t\t     \\\n        float st = stSz/iSampleRate;\t\t     \\\n        for(float i = 0.; i < iters; i++){\t \\\n            varName += instr(t - st*i);      \\\n        }\t\t\t\t\t\t\t\t     \\\n        varName /= iters;        \t\t\t \\\n    }\n\n#define eChorus(t, instr,freq, iters,stepSz, varName, outAmp) \\\n\t{\t\t\t\t\t\t\t\t\t\t \t\t  \\\n    \tvarName = vec2(0);\t\t\t\t     \t\t  \\\n        float st = stepSz/iSampleRate;\t\t \t\t  \\\n        float n = noise(t); \t\t\t\t          \\\n        for(float i = 0.; i < iters; i++){\t   \t\t  \\\n            varName += instr(t - st*i*sign(mod(i, 3.) - 1.), freq)*outAmp;      \\\n        }\t\t\t\t\t\t\t\t     \t\t  \\\n        varName /= iters;        \t\t\t          \\\n    }\n\n// ------------ DRUMS ------------ //\n\nvec2 iKick(float t){\n    vec2 s = vec2(0);\n    float envA = exp(-t*20.);\n    float envB = exp(-t*50.);\n    s += sin(tau*t*(40. + sin(t*90.)*1. +envB*1000.))*envA;\n    return s;\n}\nvec2 iKickB(float t){\n    vec2 s = vec2(0);\n    float envA = exp(-t*20.);\n    float envB = exp(-t*50.);\n    s += sin(tau*t*(10. + sin(t*90.)*1. +envB*400.))*envA;\n    s = sat(s, 2.);\n    return s;\n}\nvec2 iKickA(float t){\n    vec2 s = vec2(0);\n    float env = exp(-t*10.);\n    s.x += sin( (140. * env+ 10. ) *tau*t) * env ;\n    s.y = s.x;\n\treturn s;\n}\nvec2 iSnareA(float t){\n\tvec2 s = vec2(0);\n\n    float envA = exp(-t*30.);\n    float envB = exp(-t*37.);\n    float envC = exp(-t*90.);\n    //float envC = exp(smoothstep(1.,0.,(t - 1.)) );\n    s += sin( t*tau*(200. + envA * 190.) + noise(t)*(1. - envC))*envB;\n    \n    \n    s = sat(s, 1.3);\n    return s;\n}\nvec2 iSnareGhidra(float t){\n    vec2 s = vec2(0);\n    float hit = mod(t + beat/2.,beat);\n\n    s += sin(tau*note(12.+ 1.6*exp(-hit*26.) ,2.))*exp(-hit*18.)*0.2;    \t\n    s += sin(tau*note(12.+ 1.6*exp(-hit*26.) ,1.))*exp(-hit*13.)*0.8;    \t\n\n    float satAmt = 0.4;\n    s = s*(1.-satAmt) +  (s / (0.99 -abs(s)))*satAmt;\n    //s *= 0.7;\n    s = (s + noise(t + noise(t))*s*8.)/2.; \n\treturn s*1.;\n}\n\nvec2 iHatsA (float t) {\n\tvec2 s = vec2(0);;\n    float env = exp(-t*24.);\n    float r = r11(t);\n    s.x = sin(470.*t*tau + sin(2040.*t*tau + r*4500.)*4. + r*7.*env ) * env;\n    s.y = s.x;\n    return s;\n}\nvec2 iHatsB (float t) {\n\tvec2 s = vec2(0);\n    float env = exp(-t*50.);\n    float r = r11(t);\n    s.x = sin(570.*t*tau + sin(2040.*t*tau + r*1500.)*4. + r*4. ) * env;\n    s.y = s.x;\n    s *= 0.5;\n    return s;\n}\nvec2 iHatsC(float time){\n\tfloat s;\n    \n    //time = mod(time, beat*2.);\n    //time = mod(time, beat);\n    int t = int(time*iSampleRate/7.);\n    t = int(time*iSampleRate*2.);\n    t = t % ((t >>3) % t*4);\n    s =float(t & 0xff - 128)/ 128.;\n    s *= pow(exp(-time), 1.);\n    s = (s + (s*noise(time * mod(time, 0.001)*300.))*2.*exp(-time));\n    s *= 3.;\n    return vec2(float(s));\n}\n\nvec2 iCymbal(float t, float freq){\n\tvec2 s = vec2(0);\n    \n    float n = noise(t)*clamp(exp( (t- 1.)*1.), 0., 1.);\n    //s += n;\n    float fund = 1000.;\n    //s += sin(fund*t*tau + sin(t*tau*fund*12.)*5.* exp(-t*5.) + n*600.) * exp(-t*10.);\n    s += sin(fund*t*tau + sin(t*tau*fund*49.001)*5.* exp(-t*5.) ) * exp(-t*16.);\n    \n    \n    s = abs(s);\n    \n    s = clamp(s, -1., 1.);\n    \n\treturn s;\n}\nvec2 hats (float t) {\n\tvec2 s = vec2(0);\n\n    t = mod(t, hbeat);\n    float env = exp(-t*20.);\n    float r = r11(t);\n    s.x = sin(470.*t*tau + sin(2040.*t*tau + r*4500.)*4. + r*7.*env ) * env;\n    s.y = s.x;\n    return s;\n}\n\nvec2 hatsTwo (float t) {\n\tvec2 s = vec2(0);\n\n    t = mod(t, hbeat/2.);\n    float env = exp(-t*50.);\n    \n    float r = r11(t);\n    s.x = sin(570.*t*tau + sin(2040.*t*tau + r*1500.)*4. + r*4. ) * env;\n    s.y = s.x;\n    \n    return s;\n\n}\n\n\n// ------------ SYNTHS ------------ //\n\n\nvec2 iSineWide(float t, float freq){\n\tvec2 s = vec2(0);\n    t += noise(t)*0.00004;\n    s.x = sin(freq*tau*t);\n    s.y = sin(freq*tau*t + 5.);\n    return s;\n}\nvec2 iPiano(float t, float freq){\n\tvec2 s = vec2(0);\n    t += noise(t)*0.00004;\n    float envA = exp(-t*3.);\n    s.x = sin(freq*tau*t + sin(freq*tau*t*1.)*envA*1.);\n    s.y = sin(freq*tau*t + sin(freq*tau*t*1.)*envA*1.+ 5.);\n    return s;\n}\nvec2 iOrganLead(float t, float freq){\n    vec2 s = vec2(0);\n    float env = exp(-t*9.);\n    freq *= 4.;\n    float iterations = 3.;\n    float scale = 1.;\n    for (float i = 0.; i < iterations; i++) {\n        float r = r11(i)*10.;\n    \ts.x += sin((freq + r)*tau*t )*env*scale;\n    \ts.x += sin(freq*tau*(t + 0.05) )*env*scale;\n    \ts.x += sin(0.5*freq*tau*(t + 0.06) )*env*scale;\n        scale *= 0.8;\n        s.x * 0.33;\n        freq *= 2.01;\n    }\n    s.x /= iterations;\n    s.y = s.x;\n    return s;\n}\nvec2 iPlucky(float t, float freq){\n\tvec2 s = vec2(0);\n    freq *= 4.;\n\tfloat r = r11(t)*0.01;\n    float envA = exp(-t*6.);\n    float envB = exp(-t*20.);\n\ts.x += sin((freq + r)*tau*t + sin((8.*freq + r)*tau*t)*envB*0.5 )*envA;\n    s.y = s.x;\n    return s;\n}\n\nvec2 iSawAChorused(float t, float freq){\n\tvec2 s = vec2(0);\n    eChorus(t, iPiano,freq*2.,10., 1., s, 1.);\n    //s *= exp(-t);\n    //s.x /= 6.;\n    return s;\n}\nvec2 iSawA(float t, float freq){\n\tvec2 s = vec2(0);\n    s.x = fract(freq*tau*t + sin(t)*9. + r11(t)*0.1*exp(-t*200.))*0.2;\n    s.y = s.x;\n    return s;\n}\nvec2 iSuperSaw(float t,float freq){\n\tvec2 s = vec2(0);\n    //float n = noise(t);\n    t += r11(t)*0.00009;\n    float detuneAmt = 1.;\n    //t += noise(t)*0.0004;\n    s += iSawA(t, freq);\n    s += iSawA(t, freq*(1. - 0.02*detuneAmt));\n    s += iSawA(t, freq*(1. + 0.015*detuneAmt));\n    s /= 3.;\n    return s;\n}\nvec2 iAmbG(float t, float freq){\n\tvec2 s = vec2(0);\n    freq *= 3.;\n    t = mod(t, hmsr);\n    float iters = 3. + clamp( exp(-t/2.)*5., 0., 30.);\n    for (float i = 1.;i < iters; i++){\n    \ts += sin(t*tau*freq*i)/i;\n    }\n    \n    float n = noise(t);\n    vec2 sOrig = s;\n    float tMod = sin(t*8.)*(1. + exp(t/2.- 1.)*0.3);\n    float tMod2 = cos(t*2.)*0.5;\n    s = sOrig*sin(freq*4.*t*tau + n*0.4  + tMod          );\n    s += sOrig*sin(freq*2.*t*tau + n*0.4 + tMod2        );\n    s += sOrig*(fract(freq*8.*t*tau + n*0.4 -tMod + tMod2  ));\n\n    s /= 8.;\n    \n    return s;\n}\n\n\n// ------------ GENERATORS ------------ //\n\nvec2 gKickR(float t) {\n    vec2 s = vec2(0);\n    \n    vec2 k = iKick(t);\n    \n    Q(measure*4.){\n        return vec2(0);\n    } else QL (measure*4.){\n        s += k;\n    }\n    float period = hbeat;\n    t = mod(t + beat*4.,beat*8.);\n\tfloat r = noise(floor(t/period) + 1.);\n\tfloat rB = noise(floor(t/period) + 2.);\n    \n    if (rB < 0.1){\n    \tr = floor(r* 3.99);\n    \tfloat offs = (period/4.)*r;\n        float mT = mod(t, period) - offs;\n        if (mT > 0.){\n            eIIR(mT, iKickB, 6., 10., s);\n        }\n    }\n    s = sat(s, 1.2);\n    //s.y = s.x;\n\treturn s;\n}\n\n// ------------ OTHER STUFF ------------ //\n\n\n#define addChord(array,arraysize,arrayname) \t\t\t\t\\\n\t{arrayname = float[]array;\t\t\t\t\t\t\t\t\\\n    }\n#define playChord(array, arraysize, synth,env,t,sound)  \t\\\n        for (int i = 0; i < int(arraysize); i++){\t\t\t\\\n            sound += vec2( synth(t, note(chord[i],0.)) )*env;\\\n        }\t\t\t\t\t\t\t\t\t\t\t\t\t\n\nfloat sideChain(float t){\n    float s;\n\n    t = mod(t, hbeat);\n    //s = exp(pow( (t*1.- 1.)*0.5, 2.));\n    s = pow(sqrt(t ), 0.8);\n    \n    return s;\n}\n\nvec2 eLofi(vec2 s, float amt){\n    float st = (1./(pow(2.,amt)));\n    s = st * floor( s/st + 0.5 );\n    return s;\n}\n\n// ------------ VAULT ------------ //\n\n/*\nvec2 echoChannel(float t) {\n\tvec2 s = vec2(0);\n\n    float fb = 0.85, tm = qbeat*1.5, cf = 0.9, ct = tm;\n    // tap 1 \n    s += lead(t) * cf; cf *= fb; \n    \n    s += lead(t) * cf; cf *= fb; \n    // tap 2\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 3\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 4\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 5\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    \n    return s;\n}*/\n\n/*\n#define eReverb(t, instr, iters, stSz, varName)\n{\n    vec2 ls = vec2(0);\n    float st = stSz/iSampleRate;\n    st = 0.008;\n    for(float i = 0.; i < iters; i++){\n        float offs = noise(i)*0.8;\n    \tls += instr(t - st*i - offs)*1.*(1. - i/iters);\n    }\n\n    ls /= iters;\n    ls = clamp(s, -1., 1.);\n    varName += ls;\n}*/\n\n\n\n\n/*\nvec2 cHipass(float t){\n    float f = 900.4;\n    float r = 0.9; // 0.1 to sqrt(2)\n\n    float c = tan(pi * f / iSampleRate);\n\n    float a1 = 1.0 / ( 1.0 + r * c + c * c);\n    float a2 = -2.*a1;\n    float a3 = a1;\n    float b1 = 2.0 * ( c*c - 1.0) * a1;\n    float b2 = ( 1.0 - r * c + c * c) * a1;\n    \n    //vec2 s = a1 * gKick(t) + a2 * gKick(t - sStep) + a3 * gKick(t - sStep*2.) - b1*out(n-1) - b2*out(n-2);\n    vec2 sC = a1 * gKick(t) + a2 * gKick(t - sStep) + a3 * gKick(t - sStep*2.);\n    vec2 sB = a1 * gKick(t - sStep*1.) + a2 * gKick(t - sStep*2.) + a3 * gKick(t - sStep*3.);\n    vec2 sBB = a1 * gKick(t - sStep*2.) + a2 * gKick(t - sStep*3.) + a3 * gKick(t - sStep*4.);\n    vec2 s = sC - b1*sB - b2*sBB;\n    //vec2 s = a1 * gKick(t - sStep*2.) + a2 * gKick(t - sStep*3.) + a3 * gKick(t - sStep*4.);\t    \n  //out(n) = \n\treturn s;\n}*/\n\n\n/*\nvec2 cReverb(float t){\n\tvec2 s = vec2(0);\n    float iters = 100.;\n    float st = 1./iSampleRate;\n    st = 0.008;\n    for(float i = 0.; i < iters; i++){\n        float offs = noise(i)*0.8;\n    \ts += gSawA(t - st*i - offs)*3.*(1. - i/iters);\n        //s += gCymbal(t - st*i + offs*0.4)*0.1*(1. - i/iters) ;\n        \n        //s += gCymbalB(t - st*i + offs*0.06)*0.3*(1. - i/iters) ;\n    }\n\n    s /= iters;\n    s = clamp(s, -1., 1.);\n    //s /= 2.;\n    return s;\n}*/\n// The awesome IRR bass is from https://www.shadertoy.com/view/XljSD3\nfloat Hash( float n )\n{\n\treturn fract( (1.0 + cos(n)) * 415.92653);\n}\n\n//we can use jitter for analog driftness\nfloat genSaw(float time, float freq, bool useJitter)\n{\n    float jitter1 = 0.0;\n    float jitter2 = 0.0;\n/*\n    if(useJitter)\n    {\n      jitter1 = texture(iChannel0, vec2(time,0.2)*0.01).x;\n      jitter2 = texture(iChannel0, vec2(time-0.01,0.2)*0.01).x;\n    }*/\n    \n    float val = fract(time*(freq + (jitter1+jitter2)*0.2));\n    return val;\n}\n\nfloat genNiceSaw(float time, float freq, bool useJitter)\n{\n    return (genSaw(time,freq,useJitter) - 0.5) * 2.0;\n}\n#define maxTaps 20\n/* Reso lowpass saw... truncated IIR #yoloswag */\nfloat resoLpSaw(float time, float freq, float fa)\n{\n    \n    fa= sqrt(fa);\n\tfloat reso = 0.2;   \n    float c = pow(0.5, (128.0-fa*128.0)   / 16.0);\n  \tfloat r = pow(0.5, (reso*128.0+24.0) / 16.0);\n    \n    float v0,v1;\n    v0 = 0.0;\n    v1 = 0.0;\n    \n    for(int i = 0; i < maxTaps; i++)\n    {\n          float history = float(maxTaps-i)*(1.0/44100.0);\n\n          float t = time - history;\n          float inp = genNiceSaw(t,freq,false);\n          v0 =  (1.0-r*c)*v0  -  (c)*v1  + (c)*inp;\n  \t\t  v1 =  (1.0-r*c)*v1  +  (c)*v0;\n    }\n    \n    return v1;\n}\n/*\nvec2 gBass(float t){\n    vec2 s = vec2(0);\n    float tB = t;\n    float freq = arpA(t, scaleA,qnote, 4., 9.);\n    t = mod(t,qnote);\n    float env = exp(-t*2.);\n    float scale = 0.7;\n    s += resoLpSaw(t, freq, 0.2) * env * scale ;\n\treturn s;\n} */\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[7, 7, 31, 55, 457], [467, 467, 524, 585, 786]], "test": "untested"}
{"id": "wlVGRc", "name": "Scrolling path tracing", "author": "kig", "description": "Rendering one pixel row at a time. Scene lit by a point light behind the wall.", "tags": ["pathtracing", "hack", "bidirectional", "scrolling"], "likes": 7, "viewed": 469, "published": 3, "date": "1579532864", "time_retrieved": "2024-07-30T21:29:32.885104", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define THRESHOLD 0.003\n#define MAX_DISTANCE 8.0\n\n#define RAY_STEPS 120\n\nstruct ray\n{\n\tvec3 p; // ray origin\n\tvec3 d; // ray direction\n\n\t// how much light the ray allows to pass at this point\n\tvec3 transmit; // *= material.transmit\n\t\n\t// how much light has passed through the ray\n\tvec3 light;    // += ray.transmit * material.emit\n\n};\n\nstruct mat\n{\n\tvec3 transmit; // how much of the incoming light the material allows to pass\n\tvec3 emit;     // how much light the material emits\n\tfloat diffuse; // how much to scatter the reflections\n};\n    \nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat cylinder(vec3 p, vec3 c, float r) {\n    return length(p.yz-c.yz) - r;\n}\n\nfloat scene(vec3 p)\n{\n\tfloat cube = length(max(abs(p + vec3(0.75, 1., -2.4)) - vec3(0.25, 0.07, 1.0), 0.0)) - 0.025;\n\tcube = min(cube, length(max(abs(p + vec3(-0.25, 1.6, -2.4)) - vec3(0.25, 0.07, 1.0), 0.0)) - 0.025);\n\tfloat s1 = length(p+vec3(-1.0, -0.5, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(-2.75, 1.35, 0.)) - 0.05;\n\tfloat s3 = length(max(abs(p+vec3(-2.5, -1.3, 0.0)) - vec3(0.05, 2.5, 2.5), 0.0));\n    s3 = max(s3, -(length(max(abs(p - vec3(2.5, 0., 2.)) - vec3(0.25, 3.0, 0.035), 0.0)) - 0.025));\n    s3 = max(s3, -(max(cylinder(p, vec3(2.5, 1.85, -1.8), 0.35), -cylinder(p, vec3(2.5, 1.85, -1.8), 0.28))));\n    //s3 = max(s3, -(length(max(abs(p - vec3(2.5, 1.85, -1.8)) - vec3(0.25, 0.25, 0.035), 0.0)) - 0.025));\n    //s3 = max(s3, -(length(max(abs(p - vec3(2.5, 1.85, -1.8)) - vec3(0.25, 0.035, 0.25), 0.0)) - 0.025));\n\tfloat s4 = length(max(abs(p+vec3(0.0, 0.0, 2.5)) - vec3(8.5, 2.95, 0.05), 0.0));\n\t//s4 = min(s4, length(max(abs(p+vec3(-2.0, 2.0, 0.5)) - vec3(1.75, 0.05, 1.05), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(0.0, 2.5, 0.0)) - vec3(8.5, 0.05, 8.5), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(2.0, -2.5, 0.0)) - vec3(4.5, 0.05, 2.5), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(-0.7, 0.0, -2.5)) - vec3(8.5, 2.5, 0.05), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(3.75, 0.0, 0.0)) - vec3(0.05, 40.5, 40.5), 0.0)));;\n\ts4 = min(s4, length(max(abs(p+vec3(-3.9, 0.0, 0.0)) - vec3(0.05, 40.5, 40.5), 0.0)));\n\treturn min( min( min( min(cube, s1), s2 ), s3 ), s4);\n}\n\nmat material(vec3 p, float rayNumber)\n{\n\t//float cube = length(max(abs(p) - vec3(0.95), 0.0)) - 0.05;\n\tfloat s1 = length(p+vec3(-1.0, -0.5, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(-2.75, 1.35, 0.)) - 0.05;\n\tfloat s5 = length(max(abs(p+vec3(-1.0, 1.5, 1.2)) - vec3(1.0, 0.05, 1.65), 0.0));\n\tmat m;\n\tm.emit = vec3(0.0);\n\tm.transmit = vec3(1.0);\n\tm.diffuse = 0.0;\n/*\tif (cube < s1 && cube < s2 && cube < s5) {\n\t\tm.transmit = vec3(0.9, 0.6, 0.3);\n\t\tm.diffuse = 0.6;\n\t} else */\n    if (s2 < 0.01) {\n\t\tm.emit = vec3(5.0, 3.5, 3.0)*20.0;\n\t\tm.transmit = vec3(0.9, 0.6, 0.3);\n\t\tm.diffuse = 0.85;\n\t} else if (s1 < 0.01 || abs(sin(p.z*p.y)) < 0.5) {\n\t\tm.transmit = vec3(0.8, 0.6, 0.4);\n        if (s1 < 0.01 && abs(p.z-2.0) < 0.1)\n\t        m.emit = vec3(1.1, 0.2, 0.1);\n\t\tm.diffuse = 0.15;\n    } else if ((p.z > 0.0 || p.z < -2.0 && p.y < 0.0) && mod(rayNumber, 8.0) < 1.0) { // && mod(abs(length(p.xy-vec2(2.0, -1.5))-2.5), 1.0) < 0.25) {\n        m.diffuse = 0.05;\n        m.transmit = vec3(0.8, 0.6, 0.4);\n\t} else {\n\t\tm.diffuse = 1.0;\n\t\tm.transmit = 0.5 * vec3(0.9, 0.93, 0.96); //min(vec3(1.0), abs(p));\n\t}\n\treturn m;\n}\n\nvec3 normal(ray r, float d)\n{\n\tfloat e = 0.001;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + r.p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + r.p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + r.p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 shadeBg(vec3 nml, float t)\n{\n    return vec3(0.0);\n    \n    vec3 lightPos_ = vec3(\n        -cos(t)*-8.5, \n        sin(t)*3.0 - 4.0, \n        -(sin(t)*4.0)\n    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\tvec3 bgCol = vec3(0.2, 0.15, 0.1);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tbgCol += 0.1*sun*pow( max(sunPow, 0.0), 2.0);\n\tbgCol += 2.0*bgCol*pow( max(-sunPow, 0.0), 2.0);\n\tbgCol += bgDiff*vec3(0.25, 0.5, 0.5);\n\tbgCol += sun*pow( max(sunPow, 0.0), abs(bgLight.y)*256.0);\n\tbgCol += bgCol*pow( max(sunPow, 0.0), abs(bgLight.y)*128.0);\n\treturn max(vec3(0.0), bgCol);\n}\n\nvec2 xy(float k, float n)\n{\n\treturn vec2(floor(k/n), k-(floor(k/n)*n));\n}\n\nvoid offset(inout vec3 nml, float k, float count, float diffuse) {\n\tvec3  uu  = normalize( cross( nml, vec3(0.01,1.0,1.0) ) );\n\tvec3  vv  = normalize( cross( uu, nml ) );\n\tvec2  aa = hash2( count );\n\tfloat ra = sqrt(aa.y);\n\tfloat rx = ra*cos(6.2831*aa.x); \n\tfloat ry = ra*sin(6.2831*aa.x);\n\tfloat rz = sqrt( sqrt(k)*(1.0-aa.y) );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*nml );\t\n\tnml = normalize(mix(nml, rr, diffuse));\n}\n\n// camera rotation\nmat3 rotationXY( vec2 angle ) {\n\t// pitch\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\t// yaw\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nray setupRay(vec2 uv, float k, float t) {\n\n\tmat3 rot = rotationXY( vec2( t*0.501, t*0.602 ) );\n\tray r;\n\tr.light = vec3(0.0);\n\tr.transmit = vec3(1.0);\n\tr.p = rot * vec3(0.3, -2.0, -3.5);\n\tr.d = rot * normalize(vec3(uv.x, uv.y+0.75, 1.3));\n\n\treturn r;\n}\n\nvec3 traceLight(ray r, vec3 nml, ray light) {\n    vec3 dir = normalize(light.p - r.p);\n    vec3 col = vec3(0.0);\n    for (int i=0; i<30; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * dir;\n\t\tif (length(r.p - light.p) < THRESHOLD*4.0) {\n            col = max(0.0, dot(nml, dir)) * max(0.0, dot(-dir, light.d)) * light.light;\n            break;\n\t\t} else if (dist < THRESHOLD || dist > MAX_DISTANCE) {\n            break;\n    \t}\n    }\n\treturn col;\n}\n\nvec4 trace(vec2 fragCoord, vec2 uv, vec2 uvD, inout float rayNumber, float convergeCount)\n{\t\n\tvec3 accum = vec3(0.0);\n    \n    float k = 0.0;\n\n    vec2 rc = fragCoord + (5.0+mod(iTime, 1.73728))*vec2(rayNumber*37.0, rayNumber*63.0);\n    vec4 rand = texelFetch(iChannel0, ivec2(mod(rc, vec2(256.0))), 0);\n\n    float time = 64.0 + 11.5; //floor(float(iFrame)/300.0);\n    float shutterSpeed = 0.01;\n    \n    float t = time + shutterSpeed*rand.x;\n\t\n    int bounces = 0;\n    ray lights[3];\n\n    ray r;\n    r.d = normalize(rand.xyz);\n    rand = rand.yzwx;\n    r.p = vec3(2.75, -1.35, 0.) + r.d * 0.06;\n    r.d = normalize(r.p - vec3(2.75, -1.35, 0.));\n    r.light = vec3(5.0, 3.5, 3.0)*20.0;\n    r.transmit = vec3(1.0);\n    lights[0] = r;\n    \n    for (int i=0; i<100; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n            mat m = material(r.p, rayNumber);\n            if (bounces == 0) {\n                r.transmit *= m.transmit;\n                lights[1] = r;\n                lights[1].light = r.light * r.transmit;\n\t            bounces++;\n                float diffuse = m.diffuse;\n                offset(r.d, rayNumber+k, rand.x+rayNumber+k+10.0*dot(nml, r.d), diffuse*0.5);\n                r.d = reflect(r.d, nml);\n                lights[1].d = nml;\n                r.p += 4.0*THRESHOLD * r.d;\n            } else {\n                r.transmit *= m.transmit;\n                lights[2] = r;\n                lights[2].light = r.light * r.transmit;\n                float diffuse = m.diffuse;\n                offset(r.d, rayNumber+k, rand.x+rayNumber+k+10.0*dot(nml, r.d), diffuse*0.5);\n                r.d = reflect(r.d, nml);\n                lights[2].d = nml;\n                break;\n            }\n\t\t} else if (dist > MAX_DISTANCE) {\n            break;\n    \t}\n    }\n        \n    rand = texelFetch(iChannel0, ivec2(mod(rc+vec2(37.0,63.0), vec2(256.0))), 0);\n\tr = setupRay(uv+(uvD*vec2(rand.x, rand.y)), k+rayNumber, t);\n    bounces = 0;\n    k = 0.0;\n\n    vec3 startP = r.p;\n    float hitD = 1000000.0;\n\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n            if (bounces == 0) hitD = length(r.p - startP);\n            mat m = material(r.p, rayNumber);\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n            float diffuse = m.diffuse;\n            r.light += r.transmit * m.emit;\n            r.transmit *= m.transmit;\n\t\t\toffset(r.d, rayNumber+k, rand.x+rayNumber+k+10.0*dot(nml, r.d), diffuse*0.5);\n            r.d = reflect(r.d, nml);\n\t\t\tr.p += 4.0*THRESHOLD * r.d;\n\t\t\t\n            vec3 collected = vec3(0.0);\n\t\t\tcollected += traceLight(r, nml, lights[0]);\n\t\t\tcollected += traceLight(r, nml, lights[1]);\n\t\t\tcollected += traceLight(r, nml, lights[2]);\n\t\t\taccum += r.light*3.0 + r.transmit * collected;\n\n            k += 3.0;\n\t\t\t\n            //r.light += 0.1;\n            \n            rand = rand.yzwx;\n            bounces++;\n            if (bounces > 3) {\n                break;\n            }\n\t\t} else if (dist > MAX_DISTANCE) {\n            //r.light += r.transmit * 2.0*r.d.yxx;\n            break;\n\t\t}\n\t}\n    accum += r.light;\n    k++;\n\trayNumber += k;\n\treturn vec4(accum, hitD);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = iFrame % int(3.0 * iResolution.y);\n    if (frame == 0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    float scrollY = max(0.0, float(frame) - iResolution.y);\n    vec2 sy = scrollY > 0.0 ? vec2(0.0, -1.0) : vec2(0.0);\n    vec4 color = texelFetch(iChannel1, ivec2(fragCoord + sy), 0);\n    int samples = 20;\n    float rayNumber = 0.0;\n    if (scrollY > 0.0) {\n        if (floor(fragCoord.y) > 0.0) {\n            fragColor = color;\n            return;\n        }\n        color *= 0.0;\n    } else {\n        if (int(iResolution.y - fragCoord.y) != frame) {\n            fragColor = color;\n            return;\n        }\n    }\n\n    vec3 c = texelFetch(iChannel2, ivec2(fragCoord), 0).rgb;\n\n    vec4 lightD = vec4(color.rgb, 0.0);\n\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy + vec2(0.0, -scrollY+300.0)) / iResolution.xy;\n    uv = (2.0*uv - 1.0) * aspect;\n\n    vec2 uvD = ((2.0*((fragCoord.xy + vec2(0.0, -scrollY+300.0))+vec2(1.0, 1.0)) / iResolution.xy - 1.0) * aspect) - uv;\n \n    for (int i = 0; i < samples; i++) {\n        lightD += trace(fragCoord + vec2(0.0, -scrollY+300.0), uv, uvD, rayNumber, 0.0);\n    }\n    lightD.rgb /= rayNumber;\n    lightD.a /= rayNumber;\n    \n    fragColor = lightD;\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 accum = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = (1.0 - exp(-accum * 1.5));\n    fragColor.a = accum.a;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 119]], "test": "untested"}
{"id": "wlVGz3", "name": "My test01", "author": "tonywu", "description": "Just for test", "tags": ["test"], "likes": 1, "viewed": 265, "published": 3, "date": "1579524077", "time_retrieved": "2024-07-30T21:29:33.778715", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur){\n\tfloat d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    float mask = Circle(uv, vec2(0), 0.4, 0.05);\n    mask -= Circle(uv, vec2(0.3*sin(iTime), 0.3*cos(iTime)), 0.25, 0.05);\n    vec3 col = vec3(1);\n    col *= mask;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 132], [134, 134, 191, 241, 651]], "test": "untested"}
{"id": "wtVGz3", "name": "Smiley Faces for test", "author": "tonywu", "description": "Just for test", "tags": ["test"], "likes": 2, "viewed": 330, "published": 3, "date": "1579523433", "time_retrieved": "2024-07-30T21:29:34.538683", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur){\n\tfloat d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    return c;\n}\n\nfloat Band(float t, float start, float end, float blur){\n\tfloat step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    float band = step1 * step2;\n    return band;\n}\n\nfloat Rect(vec2 uv, float left, float right, float top, float bottom, float blur){\n\tfloat band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    float rect = band1 * band2;\n    return rect;\n}\n\nfloat remap01(float a, float b, float t){\n\treturn (t-a) / (b-a);\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n\treturn remap01(a, b, t) * (d-c) + c;\n}\n\nfloat Smiley(vec2 uv, vec2 p, float size){\n    \n    uv -= p;\n    uv /= size;\n    \n    float mask = Circle(uv, vec2(0), 0.4, 0.05);\n    vec3 col = vec3(1,1,0);\n    \n    \n    mask -= Circle(uv, vec2(-0.15,0.1), 0.08, 0.015);\n    mask -= Circle(uv, vec2(0.15,0.1), 0.08, 0.015);\n    //mask -= Circle(uv, vec2(0,-0.2), 0.1, 0.015);\n    \n    float mouth = Circle(uv, vec2(0), 0.3, 0.015) * abs(sin(iTime));\n    mouth -= Circle(uv, vec2(0,0.05), 0.3, 0.015) * abs(sin(iTime));\n    \n    mask-= mouth;\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float t  = iTime;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n   \tfloat mask = Smiley(uv, vec2(sin(iTime)*0.3,cos(iTime)*0.3), 0.5);\n\tmask += Smiley(uv, vec2(cos(iTime)*0.1,sin(iTime)*0.5), 0.5);\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float m = -(x-0.5)*(x+0.5);\n    //m = m*m*4.0;\n    m = m*sin(t+x*8.0)*0.5;\n    y = y-m;\n    \n    float blur = remap(-0.5, 0.5, 0.01, 0.25, x);\n    blur = pow(blur*4.0,3.0);\n    \n    mask += Rect(vec2(x,y), -0.5, 0.5, 0.1, -0.1, blur);\n    \n    vec3 col = vec3(1,1,0)*mask;\n    //col = vec3(mouth);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 132], [134, 134, 190, 190, 348], [350, 350, 432, 432, 578], [580, 580, 621, 621, 646], [648, 648, 705, 705, 745], [747, 747, 789, 789, 1259], [1261, 1261, 1318, 1368, 2120]], "test": "untested"}
{"id": "WtK3Rc", "name": "Sphere Chaser", "author": "kstyler", "description": "Chasing a sphere down a road.", "tags": ["raymarch", "sphere", "chase"], "likes": 4, "viewed": 271, "published": 3, "date": "1579499410", "time_retrieved": "2024-07-30T21:29:35.325579", "image_code": "#define time iTime\n#define MAX_DST 150\n#define EPSI 0.001\nint mat = 0;\nfloat random(vec2 p){\n    return(fract(sin(p.x*431.+p.y*707.)*7443.));\n}\nfloat noise(vec2 uv){\n     vec2 id = floor(uv*10.);\n    vec2 lc = smoothstep(0.,1.,fract(uv*10.));\n    \n    float a = random(id);\n    float b = random(id + vec2(1.,0.));\n    float c = random(id + vec2(0.,1.));\n    float d = random(id + vec2(1.,1.));\n    \n    float ud = mix(a,b,lc.x);\n    float lr = mix(c,d,lc.x);\n    float fin = mix(ud,lr,lc.y);\n    return fin;\n}\n\nfloat octaves(vec2 uv,int octs){\n    float amp = 0.5;\n    float f = 0.;\n    for(int i =1; i<octs+1;i++){\n        f+=noise(uv)*amp;\n        uv*=2.;\n        amp*=0.5;\n    }\n    return f;\n}\nmat2 rotate(float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat sphere(vec3 p){\n    float r = 1.;\n    r*=1.-(sin(p.y*20.+time*22.)*0.001)*20.;\n    r*=1.-(cos(p.x*10.+time*22.)*0.001)*50.;\n\n    return length(p)-r;\n}\n\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p){\n    float sph = sphere(p+vec3(-10.,-6.5,-3.-time*62.));\n    float plane = p.y+8.+octaves((p.xz/30.)+(time/10.)+sin(length(p.xz*2.))*.04,10);\n    float c = 20.;\n    float c2 = 8.;\n    p.x+=sin(p.z*0.2);\n    p.x=mod(p.x+c*.5,c)-c*.5;\n    p.z=mod(p.z+c2*.5,c2)-c2*.5;\n \n    return  min(min(sph,min(sdBox(p,vec3(0.5,4.0,1)),sdBox(p+vec3(0,-4.5,0),vec3(1.5,0.5,4)))),plane);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(10,7,-5);\n    vec3 rd = normalize(vec3(uv,1.));\n    ro.yz*=rotate(.3);\n    rd.yz*=rotate(.3);\n   \n    ro.z+=time*62.;\n    ro.x+=sin(time)*4.;\n    ro.y+=cos(time)*2.;\n  \n    float tot = 0.;\n    float dst = 0.;\n    float shad = 0.;\n    vec3 p = vec3(0.) ;\n    mat = 0;\n    for(int i =0;i<MAX_DST;i++){\n        p = ro+rd*tot;\n        dst = map(p);\n        tot+=dst;    \n        if(dst<EPSI){\n            shad = float(i)/float(MAX_DST);\n            break;\n        }\n    }\n    if(dst>EPSI){\n        mat = 1;\n    }\n  \n  \n    col= vec3(shad);\n    uv.y*=5.;\n    if(mat == 1)col =vec3(octaves(uv/10.,8)/1.6)+vec3(.5);\n    col = mix(col,vec3(0.),1.-exp(-0.4*shad));//fog\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 92, 92, 143], [144, 144, 165, 165, 509], [511, 511, 543, 543, 697], [698, 698, 719, 719, 785], [787, 787, 808, 808, 943], [946, 946, 976, 976, 1063], [1065, 1065, 1083, 1083, 1455], [1458, 1458, 1514, 1514, 2317]], "test": "untested"}
{"id": "ttyGz3", "name": "ShaderDojo 044", "author": "antonOTI", "description": "Tweaking my precedent shader.\nThe idea was to better showcase the 3D nature of the scene.\nHowever This reveal several artefacts.", "tags": ["raymarch", "stars", "minimal"], "likes": 4, "viewed": 556, "published": 3, "date": "1579474704", "time_retrieved": "2024-07-30T21:29:36.204230", "image_code": "float tau=6.28318;\nfloat star(vec3 p,float t,float r,out float i){\n p.xz*=mat2(cos(t*r),-sin(t*r),sin(t*r),cos(t*r));\n float re=tau/5.,a=mod(atan(p.y,p.x)+re*t*.25,re)-re*.5,\n l=length(p.xy);\n vec3 q=vec3(cos(a)*l,sin(a)*l,p.z*p.z*10.),d=vec3(1.,0.,0.);\n i=length(q.xy-d.xy*clamp(dot(q.xy,d.xy),.0,1.))-(.5-q.x*.25);\n return length(q-d*clamp(dot(q,d),.0,1.))-(.5-q.x*.25);\n}\nfloat m(vec3 p,out float i,out float j){\n float t=iTime*2.,a=atan(p.y,p.x);\n return min(star(p*vec3(2.,2.,1.),t*.25,1.,i),\n  star(vec3(mod(p.z+1.5,3.)-1.5,\n   mod(a*12.+tau*.5+(t+tau*.9)*\n    (mod(floor((p.z+1.5)/3.),2.)*3.-1.5),tau)-tau*.5,\n     length(p.xy)-5.),(t+tau)*.25,1.,j));\n}\nvoid mainImage(out vec4 col,in vec2 coord){\n  vec2 uv=(coord-iResolution.xy*.5)/iResolution.y,e=vec2(.01,.0);\n  vec3 ro=vec3(0.,0.,-3.),rd=normalize(vec3(-uv,1.)),cp=ro+rd;\n  float st=0.,dist=0.,cd=0.,i,j,g;\n  for(;st<1.;st+=1./300.){\n   cd=m(cp,i,j);\n   if(abs(cd)<.01||cd>200.)break;\n   dist+=cd*.05;\n   cp=ro+rd*dist;\n  }\n  st=pow(st+(fract(sin(uv.x+ uv.y*7512.)*4573.1)-.5)*.1,5.);\n  col=mix(vec4(1.,.8,.0,0.),vec4(0.),length(uv)-st)+st;\n  if(cd<.01){\n  vec3 n=normalize(vec3(cd-m(cp+e.xyy,g,g),cd-m(cp+e.yyx,g,g),\n  cd-m(cp+e.yyx,g,g)));\n  float li=clamp(dot(n,vec3(.577)),0.,1.);\n  col.rgb=vec3(.95,.4,.12)*.25;\n  col.rgb+=vec3(1.,1.,1.)*li*.75;i=-(i>.1?j:i);\n  col.rgb=mix(col.rgb,vec3(1.,1.,0.)*1.2,(i+pow(i,4.)+step(.125,i))/3.);\n }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 66, 66, 374], [375, 375, 415, 415, 660], [661, 661, 704, 704, 1404]], "test": "untested"}
{"id": "tly3zK", "name": "ShaderDojo 043", "author": "antonOTI", "description": "A shader form a wish card project =)\nOn one side of the wish card is the shader, on the other is the code.", "tags": ["star", "minimal", "cookie"], "likes": 2, "viewed": 350, "published": 3, "date": "1579474662", "time_retrieved": "2024-07-30T21:29:36.996112", "image_code": "float tau=6.28318;\nfloat star(vec3 p,float t,out float i){\n float re=tau/5.,a=mod(atan(p.y,p.x)+re*t*.25,re)-re*.5,\n l=length(p.xy);\n vec3 q=vec3(cos(a)*l,sin(a)*l,p.z*p.z*10.),d=vec3(1.,0.,0.);\n i=length(q.xy-d.xy*clamp(dot(q.xy,d.xy),.0,1.))-(.5-q.x*.25);\n return length(q-d*clamp(dot(q,d),.0,1.))-(.5-q.x*.25);\n}\nfloat m(vec3 p,out float i){\n float t=iTime*2.,a=atan(p.y,p.x);\n return min(star(p*vec3(2.,2.,1.),t*.25,i),\n  star(vec3(mod(p.z+1.5,3.)-1.5,\n   mod(a*12.+tau*.5+t*(mod(floor((p.z+1.5)/3.),2.)*3.-1.5),tau)-tau*.5,\n    length(p.xy)-5.),t,a));\n}\nvoid mainImage(out vec4 col,in vec2 coord){\n  vec2 uv=(coord-iResolution.xy*.5)/iResolution.y,e=vec2(.01,.0);\n  vec3 ro=vec3(0.,0.,-3.),rd=normalize(vec3(-uv,1.)),cp=ro+rd;\n  float st=0.,dist=0.,cd=0.,i,g;\n  for(;st<1.;st+=1./200.){\n   cd=m(cp,i);\n   if(abs(cd)<.01||cd>300.)break;\n   dist+=cd*.05;\n   cp=ro+rd*dist;\n  }\n  col=mix(vec4(1.,.8,.0,0.),vec4(0.),length(uv)-st*st)+st*st;\n  if(cd<.01){\n  vec3 n=normalize(vec3(cd-m(cp+e.xyy,g),cd-m(cp+e.yyx,g),\n  cd-m(cp+e.yyx,g)));\n  float li=clamp(dot(n,vec3(.577)),0.,1.);\n  col.rgb=vec3(.95,.4,.12)*.25;\n  col.rgb+=vec3(1.,1.,1.)*li*.75;i=-i;\n  col.rgb=mix(col.rgb,vec3(1.,1.,0.)*1.2,(i+pow(i,4.)+step(.125,i))/3.);\n }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 58, 58, 315], [316, 316, 344, 344, 558], [559, 559, 602, 602, 1228]], "test": "untested"}
{"id": "wtG3Rc", "name": "tiled camera jam", "author": "jackwitherell", "description": "eee", "tags": ["webcam"], "likes": 4, "viewed": 594, "published": 3, "date": "1579471753", "time_retrieved": "2024-07-30T21:29:37.865787", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uva = uv;\n\t/*uv.y*=(sin(iTime/10.0)+1.0)/2.0;\n    uv.x*=(cos(iTime/10.0)+1.0)/3.0;\n    */\n    \n    float freq = 5.0 + sin(iTime)*3.0;\n   \n    float split =15.0;\n    float dsp = (1.0/split)*2.0;\n    float esp = (1.0/split);\n    if(mod(uv.x,dsp)>esp){\n        uv.x+=esp;\n    }\n    else{\n        uv.x-=esp;\n    }\n    \n    if(mod(uv.y,dsp)>esp){\n        uv.y+=esp;\n    }\n    else{\n        uv.y-=esp;\n    }\n    \n    \n    uv.x+=sin((uv.y*freq)+iTime)/5.0;\n    \n    \n    uv.x=mod(uv.x,1.0);\n    uv.y=mod(uv.y+(iTime/split), 1.0);\n    \n    // Time varying pixel color\n    vec4 col = texture(iChannel0,uv);\n    \n    col.r+=floor(uva.x*split)/split;\n    col.b+=mod(1.0 - uva.y, 1.0);\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 878]], "test": "untested"}
{"id": "tlyGRc", "name": "weird kaleidoscope", "author": "unnick", "description": "once upon a time when i first saw the internals of a kaleidoscope, i wondered what would happen if the mirrors in it were arranged in a pentagon and not a triangle/square, so i coded this little thing up to answer that question.", "tags": ["2d", "kaleidoscope"], "likes": 2, "viewed": 368, "published": 3, "date": "1579471362", "time_retrieved": "2024-07-30T21:29:38.688587", "image_code": "#define res iResolution\n#define TAU 6.283185\n\nvoid mainImage(out vec4 col, in vec2 _pos) {\n    //get [-1,1] position\n    vec2 pos = (_pos*2. - res.xy) / res.y;\n    \n    //the number of sides\n    float numSides = iMouse.z > .5 ? iMouse.x/iResolution.x * 6. + 3. : sin(iTime * .3) + 4.;\n    \n    //ray direction, pos, and z\n    vec2 rd = pos * 4.;\n    vec2 ro = vec2(0);\n    float z = 0.;\n    \n    //attenuation factor (see line 52)\n    float att = 1.;\n    \n    for(int bounce = 0; bounce < 16; bounce++) {\n        //the normal and the distance to the nearest line that intersects with the ray\n        float fd = 100000.;\n        vec2 fnorm;\n        \n        //check all lines (mirrors) in an ngon for intersections\n        for(int line = 0; line < int(ceil(numSides)); line++) {\n            float a = float(line) / numSides;\n            \n            //get the origin, direction, and normal of a line\n            vec2 lo = vec2(sin(a * TAU), cos(a * TAU));\n            vec2 ld = vec2(cos(a * TAU), -sin(a * TAU));\n            vec2 norm = ld.yx * vec2(1,-1);\n            \n            //back-face culling (that also prevents a ray from hitting the same line twice)\n            if(dot(norm, rd) > 0.) continue;\n            \n            //get the distance to the intersection\n            float dist = (inverse(mat2(rd, ld)) * (lo - ro)).x;\n            \n            if(dist > -.0001 && dist < fd) {fd = dist; fnorm = norm;}\n        }\n        \n        //if the ray exits the kaleidoscope before it hits the mirror,\n        //move ray origin as far as it can go before it exits.\n        if(z + fd > 1.) {\n            ro += rd * (1. - z);\n            break;\n        }\n        \n        //increase z by the distance to the mirror\n        z += fd;\n        //move ray origin to the intersection\n        ro += rd * fd;\n        //reflect ray direction\n        rd = reflect(rd,fnorm);\n        //attenuate the reflected light a bit\n        att *= .9;\n    }\n    \n    //texture lookup\n    col = texture(iChannel1, rd) * att;\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyGRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 90, 116, 2006]], "test": "untested"}
{"id": "tly3z3", "name": "Long Way From Home", "author": "yx", "description": "A shadertoy port of my Graphics entry at Synchrony 2020. Placed 1st out of 4 entries.\n\nDownload the original executable version here: [url]https://www.pouet.net/prod.php?which=84621[/url]", "tags": ["raymarching", "sdf", "snow", "pathtraced"], "likes": 76, "viewed": 2217, "published": 3, "date": "1579466991", "time_retrieved": "2024-07-30T21:29:39.684924", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 tex = texture(iChannel0,uv);\n    \n    // divide by sample-count\n\tvec3 color = tex.rgb/tex.a;\n    \n    #if !GRADING\n    fragColor.rgb=color;return;\n    #endif\n    \n\t// vignette to darken the corners\n\tuv-=.5;\n\tcolor *= mix(vec3(.6,.9,1),vec3(1),1.-dot(uv,uv)*.75);\n\n\t// exposure\n\tcolor *= 2.5;\n\n\t// tonemap\n\tcolor /= color+1.;\n\n\t// gamma correction\n\tcolor = pow(color, vec3(.45));\n\n\t// grading\n\t{\n\t\t// make it pop\n\t\tcolor = smoothstep(.3,1.,color);\n\n\t\t// cold tint\n\t\tcolor = pow(color,vec3(1,1.05,1.1).bgr);\n\t}\n\t    \n\tfragColor = vec4(color,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi (acos(-1.))\n\nmat2 rotate(float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return mat2(c,-s,s,c);\n}\n\nvec2 hash2( const float n ) {\n\treturn fract(sin(vec2(n,n+1.))*vec2(43758.5453123));\n}\n\nint m;\n\nfloat footprint(vec2 p)\n{\n    vec2 h = vec2(0.125,0);\n    vec2 q = p - clamp( p, -h, h );\n    return length(q.xy);\n}\n\nfloat ridges(vec2 p)\n{\n    return smoothstep(.5,1.,cos(p.x*10.))*1.5 + sin(p.x*100.)*.5+.5;\n}\n\nfloat scene(vec3 p)\n{\n    float d = 1e9;\n    \n    // bounce-light orb\n    d=min(d,length(p-vec3(0,5,0))-2.5);\n    \n    // light direction debug orb\n    //d=min(d,length(p-vec3(0,.5,0))-.5);\n\n    // poles\n    vec3 r=p;\n    r.x=abs(r.x-1.1)-.2;\n    float dpole = max(length(r.xz+vec2(0,5.))-.01,r.y-5.);\n\n    vec3 q=p;\n    if(p.y <.3){\n    \t// snow roughness\n\t\tp.y += texture(iChannel1,p.xz*.125).r*.0009;\n\t\tp.y += texture(iChannel1,p.xz*2.*.125).r*.0011;\n\t\tp.y += texture(iChannel1,p.xz*4.*.125).r*.0021;\n\t    p.y += texture(iChannel1,p.xz*4.*.0625).r*.0051;\n\t    p.y += texture(iChannel1,p.xz*4.*.03125).r*.01;\n        p.y += sin(p.x*2.)*.05;\n        \n        // gentle curvature\n        p.y -= length(sin(p.xz*.5))*.1;\n\n        \n        // footprint meandering\n        p.z += sin(p.x*.5)*.5;\n        \n        // footprint zigzag\n        p.z += step(.5,mod(p.x,1.))*.3-.15;\n        \n        // footprints\n        float depth = .03;\n        p.x = mod(p.x,.5)-.25;\n        float dfoot = footprint(p.xz);\n        float foot = smoothstep(.1,.13,dfoot);\n        p.y += .1- foot*depth;\n        \n        // raised snow around footprints\n        p.y -= smoothstep(.05,.0,abs(dfoot-.16))*.004;\n        \n        // footprint stripe pattern\n        p.y -= (1.-foot)*.01*ridges(p.xz);\n        \n    }\n    \n    // extra mounds\n    p.y -= smoothstep(2.,0.,length(q.xz+vec2(-1.5,3.5)))*.2;\n    p.y -= smoothstep(2.,0.,length(q.xz+vec2(1,-2)))*.2;\n    \n    // floor\n    float ground = p.y;\n    d=min(d,ground);\n    \n    m=(dpole<d)?1:0;\n    d=min(d,dpole);\n    \n    return d*.9;\n}\n\nvec2 rv2;\n\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,-1),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// various bits of lighting code \"borrowed\" from \n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rv2;\n\tr.x=r.x*2.*pi;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getSample(vec3 dir) {\n\treturn getSampleBiased(dir,0.0);\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\treturn getSampleBiased(dir,1.0);\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  rv2;\n\tr.x=r.x*2.*pi;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 sky(vec3 dir) {\n\treturn vec3(1,2,3)*.2;\n}\n\nbool trace(vec3 cam, vec3 dir, out vec3 h, out vec3 n, out float k) {\n\tfloat t=0.;\n    for(int i=0;i<100;++i)\n    {\n        k = scene(cam+dir*t);\n        t += k;\n        if (abs(k) < .004)\n            break;\n    }\n\n    h = cam+dir*t;\n\t\n    // if we hit something\n    if(abs(k)<.004)\n    {\n        vec2 o = vec2(.001, 0);\n        k=scene(h);\n        n = normalize(vec3(\n            scene(h+o.xyy) - k,\n            scene(h+o.yxy) - k,\n            scene(h+o.yyx) - k \n        ));\n        return true;\n    }\n    return false;\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    float mouseX = (iMouse.x/iResolution.x);\n    float mouseY = (iMouse.y/iResolution.y);\n    \n    mouseX = 0.65;\n    mouseY = 0.18;\n    \n    vec3 sunDirection = normalize(vec3(\n        (mouseX-.5)*2.,\n        mouseY*2.,\n        -1\n    ));\n    const float sunSize = 1e-4;\n    const vec3 sunColor = vec3(1.,.6,.2)*2.;\n    \n    vec3 accum = vec3(1);\n    vec3 direct=vec3(0);\n    for(int ibounce=0;ibounce<10;++ibounce)\n    {\n        vec3 h,n;\n        float k;\n        if (trace(cam,dir,h,n,k))\n        {\n            #if !SHADING\n            return n*.5+.5;\n            #endif\n            vec3 albedo = vec3(1);\n            \n            // pole material\n            if (m==1) {\n                albedo = vec3(0.7);\n            }\n            \n            cam = h+n*.002;\n            dir=getSampleBiased(n,1.);\n            accum*=albedo;\n             \n            vec3 sunSampleDir = getConeSample(sunDirection,sunSize);\n            float sunLight = dot(n, sunSampleDir);\n            vec3 dummy0,dummy1;\n            float dummy2;\n            if (sunLight>0.0 && !trace(h + n*.002,sunSampleDir,dummy0,dummy1,dummy2)) {\n                direct += accum*sunLight*sunColor;\n            }\n            \n            rv2=hash2(rv2.y);\n        }\n        else if (abs(k) > .1) {\n            return direct + sky(dir) * accum;\n        } else {\n            break;\n        }\n    }\n    \n    return vec3(0);\n}\n\nvec2 bokeh(){\n\tvec2 a=rv2;\n    if(a.y>a.x)\n        a=1.-a;\n    a.y*=pi*2./a.x;\n    return a.x*vec2(cos(a.y),sin(a.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // recover previous frame for iterative rendering\n   \tfragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\t\n    \n    // get UVs\n    vec2 uv = fragCoord.xy/iResolution.xy-.5;\n    \n    // seed per-pixel\n    float seed = iTime+(uv.x+iResolution.x*uv.y)*1.51269341231;\n\trv2 = hash2( seed );\n  \n    // jitter for antialiasing\n    uv += (rv2-.5)/iResolution.xy;\n    \n    // correct UVs for aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n\n    // camera params\n    const vec3 camPos = vec3(-4,2,3);\n    const vec3 lookAt = vec3(0,0,0);\n    const float focusDistance=distance(camPos,lookAt);\n    const vec2 apertureRadius=vec2(1,2)*.015;\n   \n    // make a camera\n    vec3 cam = vec3(0);\n    vec3 dir = normalize(vec3(uv,2.));\n    \n    // slight bokeh\n    #if BOKEH\n    vec2 bokehJitter=bokeh();\n    cam.xy+=bokehJitter*apertureRadius;\n    dir.xy-=bokehJitter*apertureRadius*dir.z/focusDistance;\n    #endif\n\n    // rotate/move the camera\n    vec3 lookDir = lookAt-camPos;\n    float pitch = -atan(lookDir.y,length(lookDir.xz));\n    float yaw = -atan(lookDir.x,lookDir.z);\n    cam.yz *= rotate(pitch);\n    dir.yz *= rotate(pitch);\n    cam.xz *= rotate(yaw);\n    dir.xz *= rotate(yaw);\n    cam += camPos;\n    \n    // compute the pixel color\n\tvec4 pixel = vec4(trace(cam,dir),1);\n    \n    if (iMouse.z > 0.) {\n        fragColor = vec4(0);\n    }\n    \n    if (!isnan(pixel.r) && pixel.r >= 0.)\n\t    fragColor += pixel;\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SHADING 1\n#define BOKEH 1\n#define GRADING (SHADING && 1)\n\n/*\n+--------------------------------------+\n|                                      |\n|         \"Long Way From Home\"         |\n|            by yx/Polarity            |\n|                                      |\n|       4kb executable graphics        |\n|      released at Synchrony 2020      |\n|         in the graphics compo        |\n|                                      |\n|      should take no longer than      |\n|        five seconds to render        |\n|                                      |\n|             created with             |\n|    crinkler 2.1a by loonies & tbc    |\n|        shader minifier by llb        |\n|                                      |\n|          greetings to:               |\n|           alkama                     |\n|            blackle                   |\n|             cpdt                     |\n|              evvvvil                 |\n|               fizzer                 |\n|                flopine               |\n|                 noby                 |\n|                  nusan               |\n|                   slerpy             |\n|                    tdhooper          |\n|                                      |\n+--------------------------------------+\n*/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 649]], "test": "untested"}
{"id": "wtG3z3", "name": "Stanford bunny", "author": "BrunoLevy", "description": "A raytraced simplified Stanford Bunny with Axis-Aligned Bounding Box tree to accelerate ray-triangle intersections.\nNote: depending on the browser/driver/GPU combination, you may experience VERY different results, between 0.5 and 60 FPS.\n", "tags": ["mesh"], "likes": 15, "viewed": 1049, "published": 3, "date": "1579466294", "time_retrieved": "2024-07-30T21:29:40.884715", "image_code": "// Uncomment to deactivate AABB\n// #define NAIVE\n\nconst float FARAWAY=1e30;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.Obs+C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Material {\n   vec3 Ka;\n   vec3 Kd;\n   vec3 Ks;\n   float s;\n   vec3 Ke;\n};\n\nstruct Intersection {\n   float t;\n   Material material;\n   vec3 P;\n   vec3 N;\n};\n \nIntersection intersection() {\n   Intersection I;\n   I.t = FARAWAY;\n   return I;\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return (t > 0.0);\n}\n\nvoid sphere(in Ray R, in Sphere S, in Material M, inout Intersection I) {\n   float t;\n   if(intersect_sphere(R, S, t) && t < I.t) {\n      I.t = t;\n      I.material = M;\n      I.P = R.Origin + t*R.Dir;\n      I.N = normalize(I.P - S.Center);\n   }\n}\n\n\nbool intersect_triangle(in Ray R, in vec3 A, in vec3 B, in vec3 C, out float t) {\n   vec3 E1 = B-A;\n   vec3 E2 = C-A;\n   vec3 P = cross(R.Dir,E2);\n   float det = dot(P,E1);\n   if(det < 1e-6) {\n      return false;\n   }\n   float invdet = 1.0 / det;\n   vec3 T = R.Origin - A;\n   float u = invdet * dot(P,T);\n   if(u < 0.0 || u > 1.0) {\n      return false;\n   }\n   vec3 Q = cross(T,E1);\n   float v = invdet * dot(Q,R.Dir);\n   if(v < 0.0 || (u+v) > 1.0) {\n      return false;\n   }\n   t = invdet * dot(Q,E2);\n   return true;\n}\n\nvoid triangle(in Ray R, vec3 A, vec3 B, vec3 C, in Material M, inout Intersection I) {\n   float t;\n   if(intersect_triangle(R, A,B,C, t) && t < I.t) {\n      I.t = t;\n      I.material = M;\n      I.P = R.Origin + t*R.Dir;\n      I.N = normalize(cross(B-A,C-A));\n   }\n}\n\nbool segment_box_intersection(\n  in vec3 q1,\n  in vec3 dirinv,\n  in vec3 boxmin,\n  in vec3 boxmax\n) {  \n   vec3 T1 = dirinv*(boxmin - q1);\n   vec3 T2 = dirinv*(boxmax - q1);\n   vec3 Tmin = min(T1,T2); \n   vec3 Tmax = max(T1,T2);\n   float tmin = max(max(Tmin.x, Tmin.y),Tmin.z);\n   float tmax = min(min(Tmax.x, Tmax.y),Tmax.z);   \n   return (tmax >= 0.0) && (tmin <= tmax) && (tmin <= 1.0);\n}\n\nint stack_top = -1;\nint stack_n[20];\nint stack_b[20];\nint stack_e[20];\n\nbool stack_empty() {\n  return (stack_top < 0);\n}\n\nvoid stack_push(in int n, in int b, in int e) {\n  stack_top++;\n  stack_n[stack_top] = n;\n  stack_b[stack_top] = b;\n  stack_e[stack_top] = e;  \n}\n\nvoid stack_pop(out int n, out int b, out int e) {\n  n = stack_n[stack_top];\n  b = stack_b[stack_top];\n  e = stack_e[stack_top];\n  --stack_top;\n}\n\nvoid mesh_AABB(in Ray R, in Material M, inout Intersection I) {\n#ifdef NAIVE\n    for(int t=0; t<triangles.length(); ++t) {\n        ivec3 T = triangles[t];\n        triangle(R, vertices[T.x], vertices[T.y], vertices[T.z], M, I);\n    }\n#else    \n    vec3 invDir = vec3(1.0/R.Dir.x, 1.0/R.Dir.y, 1.0/R.Dir.z);\n   \n    if(segment_box_intersection(R.Origin, invDir, bbox_min[1], bbox_max[1])) {    \n       stack_push(1, 0, triangles.length());\n    }\n\n    while(!stack_empty()) {\n       int n,b,e;\n       stack_pop(n,b,e);\n       if(e-b <= leaf_size) {\n\t     for(int t=b; t<e; ++t) {\n             ivec3 T = triangles[t];\n             triangle(R, vertices[T.x], vertices[T.y], vertices[T.z], M, I);\n          }\n        } else {\n       \t  int m = b + (e-b)/2;\n\t      if(segment_box_intersection(R.Origin, invDir, bbox_min[2*n], bbox_max[2*n])) {\n\t         stack_push(2*n, b, m);\n\t      }\n\t      if(segment_box_intersection(R.Origin, invDir, bbox_min[2*n+1], bbox_max[2*n+1])) {\n\t         stack_push(2*n+1, m, e);\n\t      }\n       }\n    }\n#endif    \n}\n\n\nvoid sky(out vec4 fragColor, in Ray R) {\n   vec3 V = normalize(R.Dir);\n   float s = 0.5 * (V.z + 1.0);\n   fragColor = mix( \n      vec4(0.0, 0.0, 0.0, 1.0),\n      vec4(1.0, 1.0, 2.0, 1.0),\n      s\n   );\n}\n\n\nvec3 lighting( in Intersection I, in vec3 LightPos) {\n   vec3 L = LightPos - I.P;\n   float diffuse = max(dot(I.N, L)/length(L),0.0);\n   return diffuse * I.material.Kd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   float alpha = float(iFrame)/30.0;\n   float c = cos(alpha);\n   float s = sin(alpha);\n   Camera C = camera(\n       vec3(2.0*c, 2.0*s, 1.5),\n       vec3(0.0, 0.0, 0.0),\n       20.0       \n   );\n   Ray R = launch(C, fragCoord);\n   Intersection I = intersection();\n\n   const Material WHITE = Material(\n      vec3(0.0, 0.0, 0.0),\n      vec3(1.0, 1.0, 1.0),\n      vec3(0.0, 0.0, 0.0),\n      0.0,\n      vec3(0.0, 0.0, 0.0)\n   );\n\n   const Material RED = Material(\n      vec3(0.0, 0.0, 0.0),\n      vec3(1.0, 0.0, 0.0),\n      vec3(0.0, 0.0, 0.0),\n      0.0,\n      vec3(0.0, 0.0, 0.0)\n   );\n\n\n   mesh_AABB(R, WHITE, I);\n   sphere(R, Sphere(vec3(0.0, 0.0, -1001.0), 1000.0), WHITE, I);\n\n   if(I.t == FARAWAY) {\n      sky(fragColor, R);\n   } else {\n      fragColor.xyz = I.material.Ka;\n      fragColor.xyz += lighting(I, vec3(0.5, 0.0, 5.5));\n   }\n}\n", "image_inputs": [], "common_code": " \nconst vec3 vertices[300] = vec3[](\n  vec3(-0.202433,-0.205672,-0.366396),\n  vec3(-0.207577,-0.205712,-0.350817),\n  vec3(-0.203737,-0.170591,-0.371898),\n  vec3(-0.230776,-0.170082,-0.366393),\n  vec3(-0.227282,-0.169885,-0.342848),\n  vec3(-0.226380,-0.055279,-0.361297),\n  vec3(-0.217937,-0.109229,-0.369646),\n  vec3(-0.225426,-0.051436,-0.370237),\n  vec3(-0.218473,-0.107933,-0.360471),\n  vec3(-0.141037,-0.209477,-0.354688),\n  vec3(-0.167315,-0.205319,-0.328910),\n  vec3(-0.140518,-0.206284,-0.365108),\n  vec3(-0.112965,-0.184808,-0.368108),\n  vec3(-0.177509,-0.093258,-0.372813),\n  vec3(-0.113334,-0.039293,-0.366667),\n  vec3(-0.197076,-0.057813,-0.329509),\n  vec3(-0.180699,-0.181601,-0.308385),\n  vec3(-0.191830,-0.105397,-0.328095),\n  vec3(-0.252973,-0.187060,-0.144925),\n  vec3(-0.251863,-0.137955,-0.205569),\n  vec3(-0.313115,-0.135504,-0.044296),\n  vec3(-0.275352,-0.175983,-0.065444),\n  vec3(-0.341389,-0.077246,-0.056198),\n  vec3(-0.333675,-0.043151,-0.133055),\n  vec3(-0.314537,-0.128065,-0.138199),\n  vec3(-0.206810,-0.071663,-0.250462),\n  vec3(-0.286436,-0.061416,-0.202658),\n  vec3(-0.206776,-0.206272,-0.091473),\n  vec3(-0.178109,-0.183221,-0.198570),\n  vec3(-0.151144,-0.207465,-0.134049),\n  vec3(-0.111988,-0.190435,-0.306210),\n  vec3(-0.150838,-0.168607,-0.262821),\n  vec3(-0.190197,-0.153408,-0.306147),\n  vec3(-0.174143,-0.133786,-0.242163),\n  vec3(-0.167084,-0.046106,-0.289390),\n  vec3(-0.167479,-0.055388,-0.266750),\n  vec3(-0.161945,-0.110274,-0.282174),\n  vec3(-0.370043,-0.189141,0.027241),\n  vec3(-0.344696,-0.150184,-0.003764),\n  vec3(-0.323856,-0.225786,0.030259),\n  vec3(-0.309607,-0.180792,-0.013054),\n  vec3(-0.262164,-0.169746,-0.015052),\n  vec3(-0.129219,-0.193976,-0.033044),\n  vec3(-0.270752,-0.200296,-0.002874),\n  vec3(-0.240903,-0.205265,0.026092),\n  vec3(-0.209239,-0.177835,-0.013919),\n  vec3(-0.369210,-0.157762,0.089473),\n  vec3(-0.305305,-0.236737,0.088294),\n  vec3(-0.346007,-0.155074,0.159943),\n  vec3(-0.344853,-0.215722,0.092210),\n  vec3(-0.299152,-0.199315,0.153460),\n  vec3(-0.277057,-0.242160,0.033569),\n  vec3(-0.253051,-0.210438,0.085848),\n  vec3(-0.191488,-0.167727,0.036963),\n  vec3(-0.246058,-0.158618,0.193325),\n  vec3(-0.226798,-0.165857,0.152148),\n  vec3(-0.376365,-0.117514,0.039835),\n  vec3(-0.366110,-0.089145,0.137995),\n  vec3(-0.349580,-0.032500,0.005029),\n  vec3(-0.362769,-0.036895,0.081810),\n  vec3(-0.348329,-0.087419,-0.000788),\n  vec3(-0.132590,-0.142467,0.040042),\n  vec3(-0.164355,-0.133574,0.080348),\n  vec3(-0.141201,-0.067848,0.096907),\n  vec3(-0.160798,-0.032753,0.142915),\n  vec3(-0.355317,-0.074004,0.185760),\n  vec3(-0.305048,-0.115981,0.201511),\n  vec3(-0.230207,-0.077258,0.212164),\n  vec3(-0.200597,-0.109470,0.201888),\n  vec3(-0.212132,-0.020846,0.217114),\n  vec3(-0.182016,-0.098478,0.164754),\n  vec3(-0.180162,-0.036366,0.234995),\n  vec3(-0.177077,-0.056710,0.208853),\n  vec3(-0.149987,-0.044371,0.184545),\n  vec3(-0.123202,-0.027777,0.238124),\n  vec3(-0.245516,-0.004575,-0.351870),\n  vec3(-0.277648,0.023180,-0.187941),\n  vec3(-0.244486,0.003348,-0.368787),\n  vec3(-0.221870,0.039666,-0.361239),\n  vec3(-0.208961,-0.002717,-0.374290),\n  vec3(-0.199202,0.025283,-0.322366),\n  vec3(-0.208348,-0.002569,-0.244120),\n  vec3(-0.207526,-0.009427,-0.313500),\n  vec3(-0.176515,0.005642,-0.275635),\n  vec3(-0.330637,-0.008760,-0.050635),\n  vec3(-0.320685,0.017230,0.019846),\n  vec3(-0.337843,-0.019978,0.163177),\n  vec3(-0.310998,0.027644,0.105255),\n  vec3(-0.161656,-0.007107,0.158012),\n  vec3(-0.133941,-0.019991,0.174932),\n  vec3(-0.309974,0.033086,-0.119483),\n  vec3(-0.202143,0.022511,0.150513),\n  vec3(-0.156926,-0.000879,0.102915),\n  vec3(-0.211166,0.042840,-0.371665),\n  vec3(-0.194009,0.060710,-0.205968),\n  vec3(-0.248948,0.083390,-0.139050),\n  vec3(-0.194194,0.099786,-0.079956),\n  vec3(-0.154793,0.063497,-0.366067),\n  vec3(-0.138034,0.058418,-0.370465),\n  vec3(-0.159421,0.096885,-0.155418),\n  vec3(-0.156748,0.040151,-0.254840),\n  vec3(-0.144328,0.052707,-0.325137),\n  vec3(-0.278257,0.056732,-0.044229),\n  vec3(-0.269120,0.046767,0.044224),\n  vec3(-0.281885,0.046028,0.165000),\n  vec3(-0.254074,0.046510,0.135735),\n  vec3(-0.257763,0.087154,0.162014),\n  vec3(-0.211613,0.042822,0.083474),\n  vec3(-0.232657,0.061255,0.153263),\n  vec3(-0.144811,0.043172,0.061578),\n  vec3(-0.123262,0.092456,-0.017793),\n  vec3(-0.204555,0.069385,0.011223),\n  vec3(-0.303537,-0.017005,0.201870),\n  vec3(-0.232669,0.147577,0.177448),\n  vec3(-0.288343,0.043422,0.207364),\n  vec3(-0.276344,0.115856,0.204894),\n  vec3(-0.252161,-0.000723,0.211005),\n  vec3(-0.272402,0.054526,0.235490),\n  vec3(-0.244057,0.067827,0.239716),\n  vec3(-0.285092,0.129908,0.255725),\n  vec3(-0.266256,0.148840,0.282002),\n  vec3(-0.266856,0.184469,0.236174),\n  vec3(-0.234128,0.162792,0.279896),\n  vec3(-0.249550,0.190023,0.186052),\n  vec3(-0.229054,0.258645,0.234052),\n  vec3(-0.224009,0.242415,0.209249),\n  vec3(-0.283213,0.215495,0.298176),\n  vec3(-0.264194,0.241401,0.297361),\n  vec3(-0.263854,0.238295,0.322851),\n  vec3(-0.229519,0.251540,0.323128),\n  vec3(-0.256848,0.265771,0.331515),\n  vec3(-0.218411,0.005061,0.194578),\n  vec3(-0.223194,0.032796,0.192977),\n  vec3(-0.190718,0.009933,0.186697),\n  vec3(-0.146870,0.017288,0.187569),\n  vec3(-0.157299,-0.001461,0.268597),\n  vec3(-0.114899,-0.009577,0.291003),\n  vec3(-0.188175,0.005267,0.225385),\n  vec3(-0.134777,0.037838,0.238100),\n  vec3(-0.115981,0.036650,0.292707),\n  vec3(-0.217165,0.075901,0.176577),\n  vec3(-0.211770,0.119977,0.230469),\n  vec3(-0.212243,0.187444,0.211569),\n  vec3(-0.204640,0.287430,0.258672),\n  vec3(-0.198125,0.277712,0.259377),\n  vec3(-0.205018,0.223898,0.270210),\n  vec3(-0.197187,0.296434,0.308661),\n  vec3(-0.222005,0.285099,0.336825),\n  vec3(-0.198366,0.286426,0.314195),\n  vec3(-0.218529,0.289809,0.313850),\n  vec3(-0.083974,-0.230929,-0.360395),\n  vec3(-0.026898,-0.247572,-0.363210),\n  vec3(-0.011024,-0.258149,-0.352006),\n  vec3(0.081762,-0.234192,-0.358164),\n  vec3(0.036399,-0.258734,-0.281392),\n  vec3(0.090900,-0.286122,-0.210004),\n  vec3(-0.085553,-0.231823,-0.341639),\n  vec3(-0.009359,-0.250364,-0.313495),\n  vec3(0.096819,-0.245768,-0.321447),\n  vec3(-0.040016,-0.195054,-0.355561),\n  vec3(0.042137,-0.202472,-0.351564),\n  vec3(-0.068152,-0.113210,-0.360715),\n  vec3(-0.049216,-0.031631,-0.355043),\n  vec3(-0.053131,-0.216309,-0.295004),\n  vec3(-0.085267,-0.186364,-0.257740),\n  vec3(-0.031888,-0.218003,-0.258501),\n  vec3(0.097017,-0.042302,-0.348562),\n  vec3(0.020841,-0.105220,-0.344035),\n  vec3(0.170291,-0.233970,-0.296252),\n  vec3(0.123796,-0.187391,-0.351860),\n  vec3(0.178692,-0.204623,-0.343632),\n  vec3(0.252979,-0.175615,-0.306745),\n  vec3(0.280872,-0.188261,-0.260914),\n  vec3(0.245560,-0.208356,-0.224045),\n  vec3(0.336483,-0.164987,-0.264012),\n  vec3(0.306684,-0.174574,-0.209210),\n  vec3(0.360549,-0.152664,-0.206004),\n  vec3(0.107180,-0.124734,-0.349761),\n  vec3(0.213697,-0.124869,-0.348804),\n  vec3(0.177796,-0.053355,-0.352705),\n  vec3(0.249907,-0.036288,-0.334927),\n  vec3(0.305796,-0.116137,-0.315260),\n  vec3(0.283789,-0.008720,-0.281764),\n  vec3(0.332173,-0.055017,-0.292687),\n  vec3(0.313066,-0.019534,-0.230107),\n  vec3(0.368629,-0.110896,-0.251639),\n  vec3(0.361556,-0.049318,-0.234668),\n  vec3(-0.089483,-0.212791,-0.105792),\n  vec3(-0.090835,-0.198544,-0.193488),\n  vec3(-0.051395,-0.252014,-0.110219),\n  vec3(-0.053976,-0.232323,-0.170039),\n  vec3(0.002144,-0.279192,-0.187374),\n  vec3(0.177494,-0.258265,-0.188587),\n  vec3(0.027993,-0.289742,-0.117506),\n  vec3(0.132019,-0.276995,-0.107656),\n  vec3(0.230309,-0.228904,-0.106295),\n  vec3(-0.053463,-0.216950,-0.049067),\n  vec3(-0.006418,-0.251726,-0.065920),\n  vec3(-0.041757,-0.170354,0.035947),\n  vec3(0.027234,-0.221964,-0.010556),\n  vec3(0.058190,-0.183507,0.065972),\n  vec3(0.071821,-0.257910,-0.054214),\n  vec3(0.182044,-0.234498,-0.035104),\n  vec3(0.236501,-0.178612,-0.002920),\n  vec3(0.111642,-0.223941,0.000779),\n  vec3(0.160217,-0.183140,0.055697),\n  vec3(0.284764,-0.168660,-0.163885),\n  vec3(0.282692,-0.151449,-0.071232),\n  vec3(0.303017,-0.036575,-0.170073),\n  vec3(0.300156,-0.055095,-0.080658),\n  vec3(0.335791,-0.056569,-0.183953),\n  vec3(0.374185,-0.098849,-0.191557),\n  vec3(0.307751,-0.104911,-0.147406),\n  vec3(0.325809,-0.139547,-0.172785),\n  vec3(0.335811,-0.098094,-0.165407),\n  vec3(-0.089817,-0.093863,0.072015),\n  vec3(-0.024557,-0.030184,0.078012),\n  vec3(-0.070924,-0.014177,0.225334),\n  vec3(0.002798,-0.116067,0.085420),\n  vec3(0.071179,-0.046613,0.101698),\n  vec3(0.107968,-0.129926,0.099268),\n  vec3(0.155261,-0.059536,0.093978),\n  vec3(0.204780,-0.124030,0.062575),\n  vec3(0.267172,-0.089001,-0.000154),\n  vec3(0.222477,-0.027188,0.045057),\n  vec3(-0.077961,0.050345,-0.357584),\n  vec3(-0.009232,0.087183,-0.354834),\n  vec3(0.025583,0.004998,-0.341143),\n  vec3(0.075497,0.064257,-0.348960),\n  vec3(0.100149,0.091384,-0.357151),\n  vec3(0.183463,0.040729,-0.348484),\n  vec3(0.137262,0.029803,-0.348113),\n  vec3(0.223974,0.029594,-0.302490),\n  vec3(0.149100,0.093263,-0.328782),\n  vec3(-0.071265,0.083136,-0.300536),\n  vec3(-0.040488,0.082665,-0.276970),\n  vec3(-0.094157,0.071168,-0.210286),\n  vec3(-0.083993,0.051977,-0.273789),\n  vec3(0.271213,0.017822,-0.226771),\n  vec3(0.277374,0.026743,-0.125225),\n  vec3(0.207794,0.082963,-0.279163),\n  vec3(0.224253,0.085126,-0.192770),\n  vec3(0.229136,0.069704,-0.089964),\n  vec3(-0.108136,0.101111,-0.364483),\n  vec3(-0.106810,0.099578,-0.347250),\n  vec3(-0.069177,0.123225,-0.366678),\n  vec3(-0.063989,0.141973,-0.358728),\n  vec3(-0.001659,0.131434,-0.332297),\n  vec3(0.006991,0.123465,-0.360401),\n  vec3(-0.039038,0.129242,-0.315024),\n  vec3(0.075797,0.118169,-0.315477),\n  vec3(0.009873,0.137026,-0.271272),\n  vec3(-0.043560,0.097041,-0.230541),\n  vec3(-0.007272,0.164322,-0.186025),\n  vec3(-0.094550,0.105566,-0.107868),\n  vec3(-0.056007,0.121412,-0.153814),\n  vec3(-0.037627,0.137929,-0.104388),\n  vec3(0.063659,0.158907,-0.204757),\n  vec3(0.013873,0.172565,-0.124651),\n  vec3(0.149073,0.123632,-0.240429),\n  vec3(0.158696,0.127051,-0.147959),\n  vec3(0.085639,0.155981,-0.110627),\n  vec3(-0.105173,-0.008488,0.079701),\n  vec3(-0.070218,-0.004965,0.246982),\n  vec3(-0.107526,0.011961,0.192446),\n  vec3(-0.048422,0.007121,0.221306),\n  vec3(-0.051017,0.050597,0.039012),\n  vec3(-0.065345,0.055141,0.246363),\n  vec3(0.004021,0.028630,0.251400),\n  vec3(-0.039557,0.100991,-0.039658),\n  vec3(-0.027062,0.034861,0.234378),\n  vec3(0.046229,0.029479,0.063595),\n  vec3(0.024677,0.059230,0.263436),\n  vec3(0.267418,0.002160,-0.034037),\n  vec3(0.200940,0.040567,0.003942),\n  vec3(0.137712,0.016079,0.070085),\n  vec3(0.009389,0.133565,-0.069183),\n  vec3(0.158309,0.101288,-0.064285),\n  vec3(0.038441,0.087987,-0.009605),\n  vec3(0.120648,0.070379,0.005209),\n  vec3(0.085107,0.118512,-0.055434),\n  vec3(-0.080556,0.006984,0.292246),\n  vec3(-0.016958,0.027302,0.264726),\n  vec3(-0.086584,0.023253,0.323239),\n  vec3(-0.049582,0.028755,0.346212),\n  vec3(-0.035876,0.067222,0.351718),\n  vec3(-0.061225,0.069633,0.298154),\n  vec3(-0.026467,0.048162,0.339521),\n  vec3(-0.023523,0.058862,0.367092),\n  vec3(-0.001827,0.079972,0.372423),\n  vec3(0.020782,0.096535,0.350530),\n  vec3(0.013159,0.101593,0.308996),\n  vec3(0.024278,0.066330,0.291262),\n  vec3(0.021363,0.079625,0.275892),\n  vec3(0.040924,0.092778,0.298507),\n  vec3(0.005105,0.104292,0.349824),\n  vec3(0.012132,0.102342,0.367543),\n  vec3(0.041270,0.108258,0.307409),\n  vec3(0.032913,0.115013,0.345864),\n  vec3(0.033136,0.119257,0.338701)\n);\nconst ivec3 triangles[596] = ivec3[](\n  ivec3(1,3,0),\n  ivec3(3,2,0),\n  ivec3(4,3,1),\n  ivec3(16,4,1),\n  ivec3(8,6,3),\n  ivec3(6,2,3),\n  ivec3(8,3,4),\n  ivec3(17,8,4),\n  ivec3(17,4,32),\n  ivec3(7,6,5),\n  ivec3(5,6,8),\n  ivec3(77,7,5),\n  ivec3(75,5,15),\n  ivec3(13,2,6),\n  ivec3(15,8,17),\n  ivec3(79,13,7),\n  ivec3(7,13,6),\n  ivec3(15,5,8),\n  ivec3(1,0,9),\n  ivec3(10,1,9),\n  ivec3(0,2,11),\n  ivec3(16,1,10),\n  ivec3(9,11,150),\n  ivec3(30,9,156),\n  ivec3(11,12,150),\n  ivec3(9,0,11),\n  ivec3(30,10,9),\n  ivec3(12,2,13),\n  ivec3(14,13,79),\n  ivec3(11,2,12),\n  ivec3(161,12,13),\n  ivec3(14,161,13),\n  ivec3(32,4,16),\n  ivec3(82,15,34),\n  ivec3(16,10,30),\n  ivec3(36,17,32),\n  ivec3(34,15,17),\n  ivec3(18,19,28),\n  ivec3(24,19,18),\n  ivec3(27,18,29),\n  ivec3(25,33,19),\n  ivec3(41,20,21),\n  ivec3(20,24,21),\n  ivec3(21,18,27),\n  ivec3(45,21,27),\n  ivec3(24,18,21),\n  ivec3(23,24,22),\n  ivec3(22,24,20),\n  ivec3(84,23,22),\n  ivec3(84,22,58),\n  ivec3(26,25,19),\n  ivec3(26,19,24),\n  ivec3(81,25,26),\n  ivec3(76,26,23),\n  ivec3(23,26,24),\n  ivec3(42,27,29),\n  ivec3(45,27,42),\n  ivec3(31,32,16),\n  ivec3(29,18,28),\n  ivec3(29,28,188),\n  ivec3(42,29,187),\n  ivec3(31,16,30),\n  ivec3(31,30,164),\n  ivec3(28,31,188),\n  ivec3(35,36,33),\n  ivec3(36,32,31),\n  ivec3(19,33,28),\n  ivec3(28,33,31),\n  ivec3(33,36,31),\n  ivec3(34,17,36),\n  ivec3(34,36,35),\n  ivec3(81,35,25),\n  ivec3(35,33,25),\n  ivec3(83,34,35),\n  ivec3(40,39,37),\n  ivec3(37,39,49),\n  ivec3(38,40,37),\n  ivec3(56,38,37),\n  ivec3(43,39,40),\n  ivec3(51,39,43),\n  ivec3(41,40,20),\n  ivec3(20,40,38),\n  ivec3(41,43,40),\n  ivec3(44,43,41),\n  ivec3(41,21,45),\n  ivec3(53,41,45),\n  ivec3(61,45,42),\n  ivec3(52,51,44),\n  ivec3(51,43,44),\n  ivec3(52,44,53),\n  ivec3(53,44,41),\n  ivec3(53,45,61),\n  ivec3(46,37,49),\n  ivec3(56,37,46),\n  ivec3(47,39,51),\n  ivec3(49,39,47),\n  ivec3(48,46,49),\n  ivec3(57,46,48),\n  ivec3(50,49,47),\n  ivec3(48,49,50),\n  ivec3(66,48,50),\n  ivec3(52,47,51),\n  ivec3(62,52,53),\n  ivec3(50,47,52),\n  ivec3(55,50,52),\n  ivec3(54,50,55),\n  ivec3(55,52,62),\n  ivec3(62,53,61),\n  ivec3(66,50,54),\n  ivec3(68,54,55),\n  ivec3(70,55,62),\n  ivec3(59,56,57),\n  ivec3(60,38,56),\n  ivec3(56,46,57),\n  ivec3(65,57,48),\n  ivec3(58,60,56),\n  ivec3(58,22,60),\n  ivec3(59,58,56),\n  ivec3(59,57,86),\n  ivec3(86,57,65),\n  ivec3(60,20,38),\n  ivec3(22,20,60),\n  ivec3(62,61,215),\n  ivec3(63,215,262),\n  ivec3(62,215,63),\n  ivec3(70,62,63),\n  ivec3(73,70,64),\n  ivec3(70,63,64),\n  ivec3(64,63,92),\n  ivec3(63,262,92),\n  ivec3(66,65,48),\n  ivec3(86,65,112),\n  ivec3(67,66,54),\n  ivec3(112,65,66),\n  ivec3(67,112,66),\n  ivec3(116,112,67),\n  ivec3(67,54,68),\n  ivec3(69,67,71),\n  ivec3(69,116,67),\n  ivec3(68,55,70),\n  ivec3(72,68,70),\n  ivec3(72,70,73),\n  ivec3(67,68,72),\n  ivec3(71,67,72),\n  ivec3(74,72,73),\n  ivec3(71,72,74),\n  ivec3(73,64,89),\n  ivec3(217,73,89),\n  ivec3(74,73,217),\n  ivec3(77,79,7),\n  ivec3(77,5,75),\n  ivec3(78,77,75),\n  ivec3(94,81,76),\n  ivec3(82,75,15),\n  ivec3(80,75,82),\n  ivec3(93,79,77),\n  ivec3(78,93,77),\n  ivec3(78,75,80),\n  ivec3(83,80,82),\n  ivec3(98,79,93),\n  ivec3(98,14,79),\n  ivec3(101,80,83),\n  ivec3(83,35,81),\n  ivec3(100,81,94),\n  ivec3(83,82,34),\n  ivec3(100,83,81),\n  ivec3(100,101,83),\n  ivec3(90,23,84),\n  ivec3(102,84,85),\n  ivec3(90,76,23),\n  ivec3(102,90,84),\n  ivec3(85,58,59),\n  ivec3(87,59,86),\n  ivec3(85,84,58),\n  ivec3(87,85,59),\n  ivec3(87,86,104),\n  ivec3(76,81,26),\n  ivec3(64,92,91),\n  ivec3(88,64,91),\n  ivec3(89,64,88),\n  ivec3(88,91,134),\n  ivec3(103,85,87),\n  ivec3(262,109,92),\n  ivec3(92,107,91),\n  ivec3(134,91,133),\n  ivec3(92,109,107),\n  ivec3(97,93,78),\n  ivec3(101,97,78),\n  ivec3(95,76,90),\n  ivec3(101,78,80),\n  ivec3(95,94,76),\n  ivec3(99,94,95),\n  ivec3(102,95,90),\n  ivec3(96,95,102),\n  ivec3(96,99,95),\n  ivec3(97,98,93),\n  ivec3(101,244,97),\n  ivec3(97,243,98),\n  ivec3(244,243,97),\n  ivec3(236,94,99),\n  ivec3(254,99,96),\n  ivec3(237,101,100),\n  ivec3(236,100,94),\n  ivec3(254,236,99),\n  ivec3(103,102,85),\n  ivec3(105,103,87),\n  ivec3(107,103,105),\n  ivec3(111,102,103),\n  ivec3(105,87,104),\n  ivec3(105,104,106),\n  ivec3(91,105,108),\n  ivec3(105,106,108),\n  ivec3(108,106,113),\n  ivec3(107,111,103),\n  ivec3(91,107,105),\n  ivec3(111,96,102),\n  ivec3(108,113,140),\n  ivec3(91,108,140),\n  ivec3(109,111,107),\n  ivec3(91,140,132),\n  ivec3(110,254,96),\n  ivec3(110,96,111),\n  ivec3(109,110,111),\n  ivec3(104,86,114),\n  ivec3(104,115,106),\n  ivec3(106,115,123),\n  ivec3(106,123,113),\n  ivec3(114,86,112),\n  ivec3(104,114,115),\n  ivec3(131,116,69),\n  ivec3(132,116,131),\n  ivec3(132,118,116),\n  ivec3(117,114,112),\n  ivec3(116,117,112),\n  ivec3(117,119,114),\n  ivec3(118,117,116),\n  ivec3(114,119,115),\n  ivec3(141,122,118),\n  ivec3(120,119,117),\n  ivec3(118,120,117),\n  ivec3(118,122,120),\n  ivec3(119,121,115),\n  ivec3(115,121,123),\n  ivec3(126,121,119),\n  ivec3(120,126,119),\n  ivec3(113,123,125),\n  ivec3(123,124,125),\n  ivec3(126,127,121),\n  ivec3(121,127,124),\n  ivec3(123,121,124),\n  ivec3(122,128,120),\n  ivec3(120,128,126),\n  ivec3(126,130,127),\n  ivec3(128,130,126),\n  ivec3(128,147,130),\n  ivec3(122,129,128),\n  ivec3(129,147,128),\n  ivec3(127,149,124),\n  ivec3(130,149,127),\n  ivec3(147,149,130),\n  ivec3(91,131,133),\n  ivec3(131,69,137),\n  ivec3(91,132,131),\n  ivec3(140,141,132),\n  ivec3(89,88,264),\n  ivec3(133,131,137),\n  ivec3(264,88,134),\n  ivec3(134,133,138),\n  ivec3(133,137,138),\n  ivec3(137,69,135),\n  ivec3(135,69,71),\n  ivec3(135,71,136),\n  ivec3(136,71,74),\n  ivec3(283,135,136),\n  ivec3(132,141,118),\n  ivec3(134,138,267),\n  ivec3(137,135,139),\n  ivec3(138,137,139),\n  ivec3(139,135,283),\n  ivec3(140,113,142),\n  ivec3(140,142,141),\n  ivec3(141,145,122),\n  ivec3(142,145,141),\n  ivec3(113,125,142),\n  ivec3(142,125,144),\n  ivec3(125,124,143),\n  ivec3(125,143,144),\n  ivec3(142,144,145),\n  ivec3(145,129,122),\n  ivec3(124,149,143),\n  ivec3(144,148,145),\n  ivec3(144,143,146),\n  ivec3(143,149,146),\n  ivec3(148,147,129),\n  ivec3(146,149,147),\n  ivec3(145,148,129),\n  ivec3(144,146,148),\n  ivec3(146,147,148),\n  ivec3(152,150,151),\n  ivec3(150,12,151),\n  ivec3(152,151,153),\n  ivec3(151,160,153),\n  ivec3(156,150,152),\n  ivec3(9,150,156),\n  ivec3(157,156,152),\n  ivec3(152,153,158),\n  ivec3(158,153,170),\n  ivec3(157,158,154),\n  ivec3(154,158,155),\n  ivec3(165,154,191),\n  ivec3(191,154,155),\n  ivec3(163,156,157),\n  ivec3(157,152,158),\n  ivec3(165,163,157),\n  ivec3(190,165,191),\n  ivec3(165,157,154),\n  ivec3(151,12,159),\n  ivec3(151,159,160),\n  ivec3(153,160,169),\n  ivec3(160,177,169),\n  ivec3(14,162,161),\n  ivec3(159,12,161),\n  ivec3(162,167,161),\n  ivec3(161,167,159),\n  ivec3(159,167,160),\n  ivec3(30,156,163),\n  ivec3(188,165,190),\n  ivec3(164,30,163),\n  ivec3(188,31,164),\n  ivec3(188,164,165),\n  ivec3(160,167,177),\n  ivec3(164,163,165),\n  ivec3(177,167,166),\n  ivec3(227,167,162),\n  ivec3(166,167,227),\n  ivec3(158,170,168),\n  ivec3(155,158,168),\n  ivec3(153,169,170),\n  ivec3(169,177,178),\n  ivec3(168,170,171),\n  ivec3(171,174,172),\n  ivec3(170,169,178),\n  ivec3(170,178,171),\n  ivec3(171,181,174),\n  ivec3(168,171,173),\n  ivec3(173,171,172),\n  ivec3(155,168,192),\n  ivec3(192,168,173),\n  ivec3(172,174,175),\n  ivec3(174,185,176),\n  ivec3(173,172,175),\n  ivec3(173,175,206),\n  ivec3(175,174,176),\n  ivec3(179,177,166),\n  ivec3(178,177,179),\n  ivec3(178,180,181),\n  ivec3(171,178,181),\n  ivec3(179,166,231),\n  ivec3(178,179,180),\n  ivec3(180,179,230),\n  ivec3(182,183,180),\n  ivec3(180,183,181),\n  ivec3(186,183,182),\n  ivec3(184,186,182),\n  ivec3(181,185,174),\n  ivec3(183,185,181),\n  ivec3(186,185,183),\n  ivec3(210,186,184),\n  ivec3(208,184,238),\n  ivec3(176,185,211),\n  ivec3(211,185,186),\n  ivec3(211,186,210),\n  ivec3(187,190,189),\n  ivec3(187,189,196),\n  ivec3(187,188,190),\n  ivec3(29,188,187),\n  ivec3(191,155,193),\n  ivec3(189,191,193),\n  ivec3(190,191,189),\n  ivec3(189,193,197),\n  ivec3(197,193,201),\n  ivec3(194,155,192),\n  ivec3(192,173,195),\n  ivec3(195,173,206),\n  ivec3(206,175,213),\n  ivec3(193,155,194),\n  ivec3(201,193,194),\n  ivec3(194,192,195),\n  ivec3(194,195,202),\n  ivec3(195,206,207),\n  ivec3(196,189,197),\n  ivec3(42,187,196),\n  ivec3(199,197,201),\n  ivec3(196,197,199),\n  ivec3(42,196,198),\n  ivec3(61,42,198),\n  ivec3(199,204,200),\n  ivec3(198,196,199),\n  ivec3(199,200,198),\n  ivec3(201,194,204),\n  ivec3(202,195,203),\n  ivec3(199,201,204),\n  ivec3(204,194,202),\n  ivec3(204,202,205),\n  ivec3(202,203,205),\n  ivec3(195,207,203),\n  ivec3(200,205,220),\n  ivec3(204,205,200),\n  ivec3(205,203,222),\n  ivec3(206,212,207),\n  ivec3(207,212,209),\n  ivec3(203,223,222),\n  ivec3(203,207,223),\n  ivec3(209,239,273),\n  ivec3(209,208,239),\n  ivec3(223,273,224),\n  ivec3(223,209,273),\n  ivec3(207,209,223),\n  ivec3(175,176,213),\n  ivec3(210,184,208),\n  ivec3(176,211,213),\n  ivec3(214,211,210),\n  ivec3(213,211,214),\n  ivec3(206,213,212),\n  ivec3(212,208,209),\n  ivec3(213,214,212),\n  ivec3(212,214,210),\n  ivec3(212,210,208),\n  ivec3(61,198,215),\n  ivec3(215,216,262),\n  ivec3(198,200,218),\n  ivec3(198,218,215),\n  ivec3(263,74,217),\n  ivec3(136,74,281),\n  ivec3(215,218,216),\n  ivec3(218,219,216),\n  ivec3(217,89,265),\n  ivec3(200,220,218),\n  ivec3(218,220,219),\n  ivec3(216,219,271),\n  ivec3(220,221,219),\n  ivec3(219,221,275),\n  ivec3(205,222,220),\n  ivec3(220,222,221),\n  ivec3(222,223,224),\n  ivec3(222,224,221),\n  ivec3(221,224,275),\n  ivec3(245,225,98),\n  ivec3(98,225,14),\n  ivec3(243,245,98),\n  ivec3(234,244,101),\n  ivec3(225,162,14),\n  ivec3(227,162,225),\n  ivec3(226,225,245),\n  ivec3(226,227,225),\n  ivec3(228,227,226),\n  ivec3(229,231,228),\n  ivec3(229,228,226),\n  ivec3(230,179,231),\n  ivec3(230,231,229),\n  ivec3(231,166,227),\n  ivec3(231,227,228),\n  ivec3(232,180,230),\n  ivec3(240,230,233),\n  ivec3(233,230,229),\n  ivec3(237,234,101),\n  ivec3(237,235,234),\n  ivec3(252,235,237),\n  ivec3(235,249,234),\n  ivec3(236,237,100),\n  ivec3(236,252,237),\n  ivec3(242,241,260),\n  ivec3(255,252,236),\n  ivec3(241,240,259),\n  ivec3(182,180,232),\n  ivec3(238,182,232),\n  ivec3(273,239,242),\n  ivec3(184,182,238),\n  ivec3(208,238,239),\n  ivec3(232,230,240),\n  ivec3(238,232,240),\n  ivec3(238,240,241),\n  ivec3(239,241,242),\n  ivec3(239,238,241),\n  ivec3(246,243,244),\n  ivec3(248,226,245),\n  ivec3(249,244,234),\n  ivec3(251,249,235),\n  ivec3(246,245,243),\n  ivec3(248,245,246),\n  ivec3(249,246,244),\n  ivec3(247,246,249),\n  ivec3(247,248,246),\n  ivec3(229,226,248),\n  ivec3(250,248,247),\n  ivec3(233,229,250),\n  ivec3(250,229,248),\n  ivec3(250,247,251),\n  ivec3(251,247,249),\n  ivec3(240,233,259),\n  ivec3(259,233,250),\n  ivec3(257,250,251),\n  ivec3(254,255,236),\n  ivec3(253,252,255),\n  ivec3(251,235,252),\n  ivec3(253,251,252),\n  ivec3(269,256,254),\n  ivec3(256,255,254),\n  ivec3(256,253,255),\n  ivec3(276,258,256),\n  ivec3(256,258,253),\n  ivec3(259,250,257),\n  ivec3(253,257,251),\n  ivec3(258,257,253),\n  ivec3(276,261,258),\n  ivec3(261,257,258),\n  ivec3(241,259,260),\n  ivec3(242,260,277),\n  ivec3(260,259,257),\n  ivec3(260,257,261),\n  ivec3(277,260,261),\n  ivec3(265,89,264),\n  ivec3(216,266,262),\n  ivec3(281,74,263),\n  ivec3(282,263,217),\n  ivec3(264,134,267),\n  ivec3(262,266,109),\n  ivec3(270,265,264),\n  ivec3(268,217,265),\n  ivec3(282,217,268),\n  ivec3(266,110,109),\n  ivec3(267,138,286),\n  ivec3(269,254,110),\n  ivec3(266,269,110),\n  ivec3(270,264,267),\n  ivec3(272,265,270),\n  ivec3(269,276,256),\n  ivec3(266,278,269),\n  ivec3(293,270,267),\n  ivec3(216,271,266),\n  ivec3(219,275,271),\n  ivec3(271,278,266),\n  ivec3(268,265,272),\n  ivec3(224,273,274),\n  ivec3(275,224,274),\n  ivec3(274,273,242),\n  ivec3(275,274,279),\n  ivec3(271,275,279),\n  ivec3(278,276,269),\n  ivec3(278,280,276),\n  ivec3(274,242,277),\n  ivec3(280,261,276),\n  ivec3(277,261,280),\n  ivec3(272,270,293),\n  ivec3(271,279,278),\n  ivec3(274,277,279),\n  ivec3(279,280,278),\n  ivec3(279,277,280),\n  ivec3(281,263,282),\n  ivec3(138,139,286),\n  ivec3(287,281,282),\n  ivec3(287,282,292),\n  ivec3(284,136,281),\n  ivec3(283,136,284),\n  ivec3(284,281,287),\n  ivec3(288,283,284),\n  ivec3(139,283,285),\n  ivec3(285,283,288),\n  ivec3(289,284,287),\n  ivec3(267,286,291),\n  ivec3(286,139,285),\n  ivec3(286,285,295),\n  ivec3(288,284,289),\n  ivec3(285,288,296),\n  ivec3(293,267,291),\n  ivec3(291,286,295),\n  ivec3(295,285,296),\n  ivec3(292,282,268),\n  ivec3(290,287,292),\n  ivec3(289,287,290),\n  ivec3(296,288,289),\n  ivec3(294,268,272),\n  ivec3(292,268,294),\n  ivec3(297,272,293),\n  ivec3(294,272,297),\n  ivec3(290,292,294),\n  ivec3(297,293,291),\n  ivec3(298,294,297),\n  ivec3(296,289,298),\n  ivec3(298,289,290),\n  ivec3(298,290,294),\n  ivec3(299,297,291),\n  ivec3(298,297,299),\n  ivec3(295,296,299),\n  ivec3(291,295,299),\n  ivec3(299,296,298)\n);\nconst int leaf_size = 16;\nconst vec3 bbox_min[128] = vec3[](\n  vec3(0.000000,0.000000,0.000000),\n  vec3(-0.376365,-0.289742,-0.374290),\n  vec3(-0.376365,-0.242160,-0.374290),\n  vec3(-0.156748,-0.289742,-0.370465),\n  vec3(-0.376365,-0.242160,-0.374290),\n  vec3(-0.362769,-0.061416,-0.374290),\n  vec3(-0.151144,-0.289742,-0.368108),\n  vec3(-0.156748,-0.053355,-0.370465),\n  vec3(-0.349580,-0.231823,-0.374290),\n  vec3(-0.376365,-0.242160,-0.065444),\n  vec3(-0.362769,-0.061416,-0.374290),\n  vec3(-0.337843,-0.036366,0.150513),\n  vec3(-0.150838,-0.286122,-0.368108),\n  vec3(-0.151144,-0.289742,-0.230107),\n  vec3(-0.156748,-0.053355,-0.370465),\n  vec3(-0.146870,-0.046613,-0.110627),\n  vec3(-0.245516,-0.231823,-0.374290),\n  vec3(-0.349580,-0.212791,-0.328095),\n  vec3(-0.376365,-0.242160,-0.065444),\n  vec3(-0.376365,-0.165857,-0.056198),\n  vec3(-0.362769,-0.061416,-0.374290),\n  vec3(-0.320685,0.017230,-0.371665),\n  vec3(-0.337843,-0.020846,0.162014),\n  vec3(-0.244057,-0.036366,0.150513),\n  vec3(-0.150838,-0.286122,-0.368108),\n  vec3(0.081762,-0.286122,-0.358164),\n  vec3(-0.151144,-0.289742,-0.224045),\n  vec3(-0.133941,-0.183507,-0.230107),\n  vec3(-0.156748,-0.053355,-0.370465),\n  vec3(-0.108136,0.069704,-0.366678),\n  vec3(-0.146870,-0.046613,-0.110627),\n  vec3(-0.134777,-0.009577,0.238100),\n  vec3(-0.245516,-0.205712,-0.374290),\n  vec3(-0.227282,-0.231823,-0.374290),\n  vec3(-0.349580,-0.207465,-0.250462),\n  vec3(-0.252973,-0.212791,-0.328095),\n  vec3(-0.376365,-0.242160,-0.065444),\n  vec3(-0.376365,-0.242160,0.027241),\n  vec3(-0.376365,-0.157762,-0.056198),\n  vec3(-0.355317,-0.165857,0.142915),\n  vec3(-0.277648,-0.057813,-0.374290),\n  vec3(-0.362769,-0.061416,-0.244120),\n  vec3(-0.309974,0.023180,-0.371665),\n  vec3(-0.320685,0.017230,-0.107868),\n  vec3(-0.337843,-0.020846,0.162014),\n  vec3(-0.285092,0.115856,0.177448),\n  vec3(-0.244057,-0.036366,0.150513),\n  vec3(-0.234128,0.075901,0.176577),\n  vec3(-0.141037,-0.286122,-0.368108),\n  vec3(-0.150838,-0.247572,-0.368108),\n  vec3(0.081762,-0.286122,-0.358164),\n  vec3(0.097017,-0.175615,-0.352705),\n  vec3(-0.151144,-0.289742,-0.224045),\n  vec3(-0.132590,-0.276995,-0.110219),\n  vec3(0.204780,-0.178612,-0.230107),\n  vec3(-0.133941,-0.183507,-0.000154),\n  vec3(-0.144328,-0.053355,-0.370465),\n  vec3(-0.156748,-0.036575,-0.348484),\n  vec3(-0.108136,0.082665,-0.366678),\n  vec3(-0.094550,0.069704,-0.315477),\n  vec3(-0.146870,-0.030184,-0.107868),\n  vec3(-0.051017,-0.046613,-0.110627),\n  vec3(-0.134777,-0.009577,0.238100),\n  vec3(-0.026467,0.027302,0.251400),\n  vec3(-0.230776,-0.205712,-0.371898),\n  vec3(-0.245516,-0.170591,-0.374290),\n  vec3(-0.207577,-0.231823,-0.371898),\n  vec3(-0.227282,-0.206284,-0.374290),\n  vec3(-0.314537,-0.207465,-0.250462),\n  vec3(-0.349580,-0.137955,-0.250462),\n  vec3(-0.252973,-0.212791,-0.308385),\n  vec3(-0.251863,-0.183221,-0.328095),\n  vec3(-0.376365,-0.242160,-0.044296),\n  vec3(-0.277057,-0.242160,-0.065444),\n  vec3(-0.376365,-0.242160,0.027241),\n  vec3(-0.305305,-0.242160,0.033569),\n  vec3(-0.376365,-0.157762,-0.056198),\n  vec3(-0.348329,-0.150184,-0.056198),\n  vec3(-0.355317,-0.158618,0.159943),\n  vec3(-0.230207,-0.165857,0.142915),\n  vec3(-0.277648,-0.057813,-0.374290),\n  vec3(-0.211166,-0.055388,-0.374290),\n  vec3(-0.362769,-0.043151,-0.187941),\n  vec3(-0.320685,-0.061416,-0.244120),\n  vec3(-0.309974,0.023180,-0.371665),\n  vec3(-0.211166,0.040151,-0.371665),\n  vec3(-0.320685,0.017230,-0.044229),\n  vec3(-0.278257,0.022511,-0.107868),\n  vec3(-0.337843,-0.020846,0.162014),\n  vec3(-0.303537,-0.017005,0.201870),\n  vec3(-0.285092,0.115856,0.177448),\n  vec3(-0.283213,0.148840,0.234052),\n  vec3(-0.223194,-0.020846,0.150513),\n  vec3(-0.244057,-0.036366,0.187569),\n  vec3(-0.234128,0.075901,0.176577),\n  vec3(-0.234128,0.162792,0.234052),\n  vec3(-0.141037,-0.258149,-0.368108),\n  vec3(-0.085553,-0.286122,-0.352006),\n  vec3(-0.113334,-0.247572,-0.368108),\n  vec3(-0.150838,-0.232323,-0.355043),\n  vec3(0.081762,-0.286122,-0.358164),\n  vec3(0.090900,-0.286122,-0.306745),\n  vec3(0.097017,-0.175615,-0.352705),\n  vec3(0.271213,-0.164987,-0.315260),\n  vec3(-0.151144,-0.289742,-0.210004),\n  vec3(0.027993,-0.289742,-0.224045),\n  vec3(-0.132590,-0.257910,-0.110219),\n  vec3(0.027234,-0.276995,-0.107656),\n  vec3(0.204780,-0.178612,-0.170073),\n  vec3(0.284764,-0.174574,-0.230107),\n  vec3(-0.133941,-0.183507,0.035947),\n  vec3(-0.024557,-0.183507,-0.000154),\n  vec3(-0.144328,-0.039293,-0.370465),\n  vec3(-0.009232,-0.053355,-0.357151),\n  vec3(-0.156748,0.040151,-0.325137),\n  vec3(0.183463,-0.036575,-0.348484),\n  vec3(-0.108136,0.082665,-0.366678),\n  vec3(-0.039038,0.082963,-0.360401),\n  vec3(-0.094550,0.071168,-0.276970),\n  vec3(-0.007272,0.069704,-0.315477),\n  vec3(-0.146870,-0.030184,0.039012),\n  vec3(-0.144811,0.007121,-0.107868),\n  vec3(-0.051017,-0.046613,-0.089964),\n  vec3(-0.039557,0.029479,-0.110627),\n  vec3(-0.134777,-0.009577,0.238100),\n  vec3(-0.115981,0.023253,0.246363),\n  vec3(-0.026467,0.027302,0.251400),\n  vec3(-0.001827,0.079625,0.275892)\n);\nconst vec3 bbox_max[128] = vec3[](\n  vec3(0.000000,0.000000,0.000000),\n  vec3(0.374185,0.296434,0.372423),\n  vec3(-0.065345,0.296434,0.336825),\n  vec3(0.374185,0.172565,0.372423),\n  vec3(-0.068152,0.023180,0.238124),\n  vec3(-0.065345,0.296434,0.336825),\n  vec3(0.374185,0.040729,0.292246),\n  vec3(0.313066,0.172565,0.372423),\n  vec3(-0.068152,0.023180,0.005029),\n  vec3(-0.070924,-0.000723,0.238124),\n  vec3(-0.083993,0.147577,0.192977),\n  vec3(-0.065345,0.296434,0.336825),\n  vec3(0.374185,0.040729,-0.163885),\n  vec3(0.374185,0.029479,0.292246),\n  vec3(0.313066,0.172565,-0.034037),\n  vec3(0.267418,0.155981,0.372423),\n  vec3(-0.068152,0.003348,-0.282174),\n  vec3(-0.085267,0.023180,0.005029),\n  vec3(-0.129219,-0.089145,0.201888),\n  vec3(-0.070924,-0.000723,0.238124),\n  vec3(-0.105173,0.060710,0.187569),\n  vec3(-0.083993,0.147577,0.192977),\n  vec3(-0.211770,0.289809,0.336825),\n  vec3(-0.065345,0.296434,0.336825),\n  vec3(0.178692,0.004998,-0.170039),\n  vec3(0.374185,0.040729,-0.163885),\n  vec3(0.325809,-0.124030,0.099268),\n  vec3(0.374185,0.029479,0.292246),\n  vec3(0.313066,0.129242,-0.034037),\n  vec3(0.229136,0.172565,-0.039658),\n  vec3(0.267418,0.155981,0.298154),\n  vec3(0.041270,0.119257,0.372423),\n  vec3(-0.177509,0.003348,-0.306147),\n  vec3(-0.068152,-0.002717,-0.282174),\n  vec3(-0.151144,0.023180,0.005029),\n  vec3(-0.085267,0.005642,-0.013919),\n  vec3(-0.129219,-0.117514,0.092210),\n  vec3(-0.132590,-0.089145,0.201888),\n  vec3(-0.089817,-0.000879,0.185760),\n  vec3(-0.070924,-0.000723,0.238124),\n  vec3(-0.113334,0.060710,-0.187941),\n  vec3(-0.105173,0.056732,0.187569),\n  vec3(-0.083993,0.105566,-0.044229),\n  vec3(-0.094550,0.147577,0.192977),\n  vec3(-0.211770,0.190023,0.282002),\n  vec3(-0.218529,0.289809,0.336825),\n  vec3(-0.065345,0.119977,0.323239),\n  vec3(-0.197187,0.296434,0.336825),\n  vec3(0.178692,-0.184808,-0.170039),\n  vec3(0.123796,0.004998,-0.170039),\n  vec3(0.368629,-0.110896,-0.163885),\n  vec3(0.374185,0.040729,-0.170073),\n  vec3(0.325809,-0.139547,-0.035104),\n  vec3(0.282692,-0.124030,0.099268),\n  vec3(0.374185,0.026743,0.062575),\n  vec3(0.267172,0.029479,0.292246),\n  vec3(0.249907,0.123225,-0.279163),\n  vec3(0.313066,0.129242,-0.034037),\n  vec3(0.207794,0.158907,-0.204757),\n  vec3(0.229136,0.172565,-0.039658),\n  vec3(0.038441,0.137929,0.298154),\n  vec3(0.267418,0.155981,0.275892),\n  vec3(0.024278,0.104292,0.372423),\n  vec3(0.041270,0.119257,0.372423),\n  vec3(-0.180699,-0.105397,-0.306147),\n  vec3(-0.177509,0.003348,-0.328095),\n  vec3(-0.083974,-0.170591,-0.306210),\n  vec3(-0.068152,-0.002717,-0.282174),\n  vec3(-0.151144,-0.071663,-0.013919),\n  vec3(-0.206810,0.023180,0.005029),\n  vec3(-0.085267,-0.153408,-0.013919),\n  vec3(-0.150838,0.005642,-0.198570),\n  vec3(-0.262164,-0.117514,0.092210),\n  vec3(-0.129219,-0.142467,0.085848),\n  vec3(-0.277057,-0.089145,0.201511),\n  vec3(-0.132590,-0.098478,0.201888),\n  vec3(-0.337843,-0.019978,0.185760),\n  vec3(-0.089817,-0.000879,0.184545),\n  vec3(-0.180162,-0.000723,0.234995),\n  vec3(-0.070924,-0.014177,0.238124),\n  vec3(-0.194009,0.060710,-0.187941),\n  vec3(-0.113334,0.060710,-0.205968),\n  vec3(-0.277648,0.056732,0.165000),\n  vec3(-0.105173,0.046767,0.187569),\n  vec3(-0.144328,0.099786,-0.044229),\n  vec3(-0.083993,0.105566,-0.079956),\n  vec3(-0.202143,0.147577,0.177448),\n  vec3(-0.094550,0.147577,0.192977),\n  vec3(-0.212132,0.190023,0.239716),\n  vec3(-0.211770,0.162792,0.282002),\n  vec3(-0.224009,0.258645,0.298176),\n  vec3(-0.218529,0.289809,0.336825),\n  vec3(-0.107526,0.119977,0.238100),\n  vec3(-0.065345,0.119977,0.323239),\n  vec3(-0.198125,0.287430,0.279896),\n  vec3(-0.197187,0.296434,0.336825),\n  vec3(0.178692,-0.184808,-0.313495),\n  vec3(0.096819,-0.216309,-0.170039),\n  vec3(0.123796,-0.031631,-0.344035),\n  vec3(0.107180,0.004998,-0.170039),\n  vec3(0.336483,-0.116137,-0.210004),\n  vec3(0.368629,-0.110896,-0.163885),\n  vec3(0.332173,0.040729,-0.281764),\n  vec3(0.374185,0.017822,-0.170073),\n  vec3(0.090900,-0.198544,-0.049067),\n  vec3(0.325809,-0.139547,-0.035104),\n  vec3(0.111642,-0.142467,0.065972),\n  vec3(0.282692,-0.124030,0.099268),\n  vec3(0.307751,0.026743,0.062575),\n  vec3(0.374185,-0.019534,-0.080658),\n  vec3(0.071179,0.007121,0.292246),\n  vec3(0.267172,0.029479,0.101698),\n  vec3(0.075497,0.123225,-0.300536),\n  vec3(0.249907,0.093263,-0.279163),\n  vec3(0.229136,0.129242,-0.089964),\n  vec3(0.313066,0.085126,-0.034037),\n  vec3(0.009873,0.141973,-0.271272),\n  vec3(0.207794,0.158907,-0.204757),\n  vec3(0.013873,0.172565,-0.039658),\n  vec3(0.229136,0.172565,-0.064285),\n  vec3(0.004021,0.055141,0.292246),\n  vec3(0.038441,0.137929,0.298154),\n  vec3(0.267418,0.087987,0.263436),\n  vec3(0.229136,0.155981,0.275892),\n  vec3(0.024278,0.069633,0.367092),\n  vec3(0.021363,0.104292,0.372423),\n  vec3(0.041270,0.108258,0.372423),\n  vec3(0.041270,0.119257,0.372423)\n);\n ", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 305, 305, 603], [605, 605, 642, 642, 745], [912, 912, 941, 941, 993], [1043, 1043, 1102, 1102, 1373], [1375, 1375, 1448, 1448, 1621], [1624, 1624, 1705, 1705, 2144], [2146, 2146, 2232, 2232, 2411], [2413, 2413, 2514, 2514, 2804], [2878, 2878, 2898, 2898, 2926], [2928, 2928, 2975, 2975, 3072], [3074, 3074, 3123, 3123, 3218], [3220, 3220, 3283, 3283, 4260], [4263, 4263, 4303, 4303, 4466], [4469, 4469, 4522, 4522, 4638], [4640, 4640, 4697, 4697, 5537]], "test": "untested"}
{"id": "tly3R3", "name": "Day 31 - Plojunb haspl", "author": "jeyko", "description": "hex kifs-ing", "tags": ["hex", "mdtmjvm"], "likes": 14, "viewed": 638, "published": 3, "date": "1579461402", "time_retrieved": "2024-07-30T21:29:42.064561", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 20.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,2.7)*0.7;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.4)*9.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.91;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*1.; \n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.9);\n    //fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.7));\n    fragColor *= 1. - dot(uvn,uvn)*1.8;\n}\n\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define dmin(a, b) a.x < b.x  ? a : b\n#define dmax(a, b) a.x > b.x  ? a : b\n#define pi acos(-1.)\n#define iTime (iTime + pi*2.)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define mx (20.*iMouse.x/iResolution.y)\n\n\n\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\nvec4 HexCoords(vec2 uv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n\n\n#define pmod(p, x) mod(p, x) - x*0.5\n#define modDist 3.\n\nfloat id;\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e9);\n\n    id = floor(p.z/modDist);\n    \n    vec3 z = p;\n    /*\n    for (float i = 0.; i < 4.; i++){\n    \tp = abs(p);\n        \n        p.xy *= rot(0.9  + i*0.6 );\n        p.zy *= rot(0.04);\n        p.xz *= rot(0.04+ exp(-length(z.xy)*1.)*0.001);\n    \tp.y -= 0.9;\n        p.x += 0.9;\n        p.xy *= 1. - atan(p.x,p.y)*0.2;\n        //p.z -= 0.1;\n    }*/\n    p.xy *= rot(id*1.2 - iTime*0.5);\n\n    p.z = pmod(p.z, modDist);\n    for (float i = 0.; i < 9.; i++){\n    \tp = abs(p);\n        \n        //p.xy *= rot(0.9  + i*1.5 + id*0. );\n        p.xy *= rot(0.9  + i*1.8 + id*0. );\n        //p.y += 2.4 ;\n        p.zy *= rot(0.025 + sin(id)*0.03);\n        p.xz *= rot(0.02 + exp(-length(z.xy)*1.)*0.57 + sin(id*0.6)*0.01);\n        //p.x -= 0.02;\n    \t//p.y -= 0.9;\n        //p.x += 0.9;\n        //p.xy *= 1. - atan(p.x,p.y)*0.7;\n        //p.z -= 0.1;\n    }\n    \n\tvec4 hc = HexCoords(p.xy);\n    \n    \n    \n    d = dmin(d, vec2((hc.y - 0.12), 0.));\n    d.x = max(d.x, (abs(p.z) - 0.1));\n    \n    \n    d = dmin(d, vec2(\n        max((hc.y - 0.19), (abs(p.z) - 0.06))\n        , 1.));\n    \n    \n    \n    //d.x = max(d.x, );\n    \n    \n    \n    \n    \n    d.x *= 0.8;\n    return d;\n}\n#define fov 2.\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + right*uv.x*fov + up*uv.y*fov);\n}\n\nvec3 glow = vec3(0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,0,-2. + (iTime + mx)*5.);\n    vec3 lookAt = ro + vec3(0,0,1);\n    \n    lookAt.x += sin(iTime)*(0.25 + sin(iTime*0.5)*0.25)*0.3;\n    lookAt.y += cos(iTime)*(0.25 + sin(iTime*0.5)*0.25)*0.3;\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    //rd.xy *= 1. - dot(uv,uv)*0.3;\n    rd.xy *= 1. - dot(uv,uv)*0.2;\n    rd = normalize(rd);\n    float t= 0.; vec3 p = ro;\n    #define iters 260.\n    for (float i = 0.; i < iters; i++){\n    \tvec2 d = map(p);\n        #define tau (2.*pi)\n        #define pal(a,b,g,c,d) ((a) + (b)*cos(tau*((g)*(c) + (d))))\n        float glowSc = exp(-d.x*20.);\n        vec3 glowCol = vec3(0);\n        if (d.y == 0.){\n            //glowCol = vec3(0.1,0.9,0.9);\n            glowCol = vec3(0.4);\n        } else {\n            //glowCol = vec3(0.7,0,1.7);\n            //glowCol = pal(0.9,0.9,0.5 + id*0.1,vec3(0.6,0.4,0.9), id*0.06 + length(uv.xy)*0.9 - length(p.xy)*0.04);\n            glowCol = pal(0.9,0.9,0.8,vec3(0.1,0.4,0.9), id*0.05 + length(uv.xy)*0.1 - length(p.xy)*0.1)*0.5;\n        \n        }\n        glow += glowSc * glowCol;\n        if (d.x < 0.001){\n            \n            break;\n        }\n        \n        if (t > 100.){\n        \tbreak;\n        }\n    \t\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n\tcol += glow*0.04;\n    //col *= 2.;\n    \n    \n    //col = smoothstep(0.,1., col);\n    //col = pow(col, vec3(0.45));\n\n    \n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3R3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 1070]], "test": "untested"}
{"id": "ttG3R3", "name": "Simple Water Distortion", "author": "sirjofri", "description": "This is a simple water distortion experiment with deep water color and distortion only. No fancy shading here (still need to learn that)", "tags": ["distortion", "water", "experiment"], "likes": 3, "viewed": 471, "published": 3, "date": "1579456984", "time_retrieved": "2024-07-30T21:29:42.960166", "image_code": "vec2 dist(vec2 uv)\n{\n    float a = (texture(iChannel1, uv/3.+iTime*.05).r)-.5;\n    return vec2(uv+a*.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x += iTime*.3;\n    uv.y += sin(iTime*.5)*.2;\n    \n    float a = clamp(0., 1., texture(iChannel1, uv/10.).r/8.);\n\n    float d = pow(uv.y, 3.);\n    vec2 nuv = mix(uv*2., dist(uv*2.), d);\n\n    vec3 c = texture(iChannel0, nuv).rgb;\n    vec3 col = mix(vec3(1), vec3(0.1, 0.7, 1.), pow(d, 3.));\n    \n    vec3 final = c*col*(1.-d*.2);\n\n    fragColor = vec4(pow(final, vec3(1.5)),1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttG3R3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 106], [108, 108, 165, 165, 591]], "test": "untested"}
{"id": "Wty3z3", "name": "RadioActivity_VolumeLight", "author": "Honorfil", "description": "raymarching volume light", "tags": ["raymarchvolumelight"], "likes": 6, "viewed": 315, "published": 3, "date": "1579446990", "time_retrieved": "2024-07-30T21:29:43.719137", "image_code": "#define MAX_STEPS 800\n#define MAX_DIST 100.\n#define LIGHT_VOLUME_STEP 0.05\n#define SURF_DIST 0.01\n#define PI 3.1415\n#define LIGHT_DENSITY 0.3\n#define LIGHT_POS vec3(0., 15., 1.3)\n#define LIGHT_DIR vec3(0., -1., 0.)\n\nfloat GetLightDist(vec3 p)\n{\n    vec3 base = LIGHT_POS;\n    base.y = 0.;\n    \n\treturn GetCone(p, base, LIGHT_POS, 2.9, 0.0);\n}\n\nfloat RayMarchLight(vec3 ro, vec3 rd)\n{\n    float d0 = 0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * d0;\n        float ds = abs(GetLightDist(p));\n        d0 += ds;\n\n        if (d0 > MAX_DIST || ds < SURF_DIST)\n        {\n            break;\n        }\n    }\n    \n    return step(d0, MAX_DIST / 2.) * d0;\n}\n\nfloat GetRadioEdge(vec3 p)\n{   \n    vec3 n = -vec3(0,0,1);\n    float leftPlane = dot(p, n * GetRot3dY(2. * PI / 6.));\n    float rightPlane = dot(p, n * GetRot3dY(-2. * PI / 6.));\n    \n    p -= vec3(0,0.0,1);\n    \n    float result = GetBox(p, vec3(1, .1, 1));\n    result = max(result, leftPlane);\n\tresult = max(result, rightPlane);\n                          \n    return result;\n}\n\nfloat GetRadioShape(vec3 p)\n{\n    float base = GetBox(p, vec3(10,1,20), vec3(0, -1, 0), vec3(0, 0, 0));\n    \n    float s1 = GetRadioEdge(p);\n    float s2 = GetRadioEdge(p * GetRot3dY(2. * PI / 3.));\n    float s3 = GetRadioEdge(p * GetRot3dY(-2. * PI / 3.));\n    \n    float outer = GetCylinder(p, vec3(0,-1,0), vec3(0,1,0), 2.);\n    float inner = GetCylinder(p, vec3(0,-1,0), vec3(0,1,0), .4);\n    float center = GetCylinder(p, vec3(0,-.05,0), vec3(0,.05,0), .2);\n    \n    float result = s1;\n    result = min(result, s2);\n    result = min(result, s3);\n    result = max(result, outer);\n    result = max(result, -inner);\n    result = min(result, center);\n    \n    return result;\n}\n\nfloat GetSpheres(vec3 p)\n{\n    vec3 s1Pos = vec3(0, 2.6, 1.3) + vec3(cos(-iTime * 0.3), 0, sin(-iTime * 0.3)) * 1.3;\n    vec3 s2Pos = vec3(0, 1.7, 1.3) + vec3(cos(iTime * 0.26), 0, sin(iTime * 0.26)) * 1.7;\n    \n    float s1 = GetSphere(p, s1Pos, .3);\n    float s2 = GetSphere(p, s2Pos, .3);\n    \n    return min(s1, s2);\n}\n\nfloat GetRoom(vec3 p)\n{\n    vec3 pFloor = p - vec3(0,0,0);\n    vec3 pCeil = p - vec3(0,4,0);\n        \n    float fl = GetBox(pFloor, vec3(5, .1, 5));\n    float ce = GetBox(pCeil, vec3(5, .1, 5));\n    float hole = GetCylinder(p - vec3(0,4,1.3), vec3(0,-1.,0), vec3(0,1.,0), 2.1);\n    \n    float result = ce;\n    result = max(result, -hole);\n    result = min(result, fl);\n    \n    return result;\n}\n\nfloat GetDistScene(vec3 p)\n{\n    vec3 pShape = p - vec3(0,4.05,1.27);\n    pShape *= GetRot3dY(iTime);\n    \n    float shape = GetRadioShape(pShape);   \n    float room = GetRoom(p);\n    \n    return min(room, shape);\n}\n\nfloat RayMarchScene(vec3 ro, vec3 rd)\n{\n    float d0 = 0.;\n        for (int i = 0; i < MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * d0;\n            float ds = abs(GetDistScene(p));\n            d0 += ds;\n            \n            if (abs(d0) > MAX_DIST || ds < SURF_DIST)\n            {\n                break;\n            }\n        }\n    \n    return min(d0, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p)\n{   \n    float d = GetDistScene(p);\n    vec2 e = vec2(0.01, .0);\n    \n    vec3 n = d - vec3(\n    \tGetDistScene(p - e.xyy),\n    \tGetDistScene(p - e.yxy),\n    \tGetDistScene(p - e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, out vec3 n)\n{  \n    vec3 lightPos = LIGHT_POS;\n    vec3 lray = normalize(lightPos - p);\n    n = GetNormal(p);\n    float distToLight = length(lightPos - p);\n\n    float co = radians(10.0);\n    float coDel = radians(14.0);\n    float fall = clamp((dot(lray, -LIGHT_DIR) - cos(coDel)) / (cos(co) - cos(coDel)), 0.0, 1.0);\n    float diff = max(0.0, dot(lray, n));\n    \n    float shadow = 1.;\n    \n    float realDistToLight = RayMarchScene(p + n * .02, lray);\n    if (realDistToLight < distToLight)\n    {\n        shadow = 0.7;\n    }\n    \n    return diff * fall * shadow;\n}\n\nfloat GetLightDistance(vec3 ro, vec3 rd, out vec3 pIn, out vec3 pOut)\n{\n    vec3 roBack = ro + rd * 20.;\n\n    float dc = RayMarchLight(ro, rd);\n    float df = RayMarchLight(roBack, -rd);\n    \n    if (dc < 0.01 && df < 0.01)\n    {\n        return 0.;\n    }\n    \n    pIn = ro + rd * dc;\n    pOut = roBack - rd * df;\n    \n    return length(pIn - pOut);\n}\n\nfloat GetLightDensity(vec3 ro, vec3 rd, vec3 hitPoint)\n{\n    vec3 pIn;\n    vec3 pOut;\n    \n    float traverseDist = GetLightDistance(ro, rd, pIn, pOut);\n    if (traverseDist < 0.01 || length(ro - pIn) > length(ro - hitPoint))\n    {\n        return 0.;\n    }\n    \n    float distToHitPoint = length(pIn - hitPoint);\n    traverseDist = min(traverseDist, distToHitPoint);\n\n    vec3 singleStep = rd * LIGHT_VOLUME_STEP;\n    vec3 lSetVec = vec3(0);\n    float lightDensity = 0.;\n    \n    while (length(lSetVec) < traverseDist)\n    {\n        vec3 vlP = pIn + lSetVec;\n        vec3 lightDir = normalize(LIGHT_POS - vlP);\n        \n        float distToLight = length(vlP - LIGHT_POS);\n        float realDistLoLight = RayMarchScene(vlP, lightDir);\n        realDistLoLight = max(realDistLoLight, distToLight);\n\n        float distMult = smoothstep(1., 0.8, distToLight / LIGHT_POS.y);\n        lightDensity += LIGHT_VOLUME_STEP * LIGHT_DENSITY * distMult * (1. - step(realDistLoLight, distToLight));\n        \n        lSetVec += singleStep;\n    }\n    \n    return lightDensity * 0.4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0, 1.5, -4.9);   \n    vec3 rd = normalize (vec3(uv.x, uv.y, 1));    \n    rd *= GetRot3dX(-.1);\n\n    float d = RayMarchScene(ro, rd);\n    \n    vec3 n;\n    vec3 p = ro + rd * d;\n    float dif = GetLight(p, n);\n    vec3 diffColor = vec3(1, 1, 0) * dif * 0.4;\n    \n    float lightDensity = GetLightDensity(ro, rd, p);\n    vec3 lightVolumeColor = lightDensity * vec3(1, 1, 0);\n\n    fragColor = vec4(diffColor + lightVolumeColor, 1.0);\n}\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "//math help\n\nmat2 GetRot2d(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    \n    return mat2(c, -s, s, c);\n}\n\nmat3 GetRot3dX(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    \n    return mat3(vec3(1, 0, 0), vec3(0, c, -s), vec3(0, s, c));\n}\n\nmat3 GetRot3dY(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    \n    return mat3(vec3(c, 0, s), vec3(0, 1, 0), vec3(-s, 0, c));\n}\n\nmat3 GetRot3dZ(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    \n    return mat3(vec3(c, -s, 0), vec3(s, c, 0), vec3(0, 0, 1));\n}\n\n//Primitives\n\nfloat GetSphere(vec3 p, vec3 spherePos, float r)\n{\n    return length(p - spherePos) - r;\n}\n\nfloat GetCylinder(vec3 p, vec3 top, vec3 bottom, float radius)\n{\n    vec3 ab = bottom - top;\n    vec3 ap = p - top;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = top + t * ab;\n\n    float x = length(p - c) - radius;\n    float y = (abs(t - .5) - .5) * length(ab);\n    float exterior = length(max(vec2(x, y), 0.));\n    float interior = min(max(x, y), 0.);\n    \n    return exterior + interior;\n}\n\nfloat GetBox(vec3 p, vec3 s)\n{\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetBox(vec3 p, vec3 size, vec3 pos, vec3 rot)\n{   \n    p -= pos;    \n    p *= GetRot3dZ(rot.z) * GetRot3dY(rot.y) * GetRot3dX(rot.x);\n    \n    return GetBox(p, size);\n}\n\nfloat GetCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 244, 244, 342], [344, 344, 383, 383, 677], [679, 679, 707, 707, 1057], [1059, 1059, 1088, 1088, 1736], [1738, 1738, 1764, 1764, 2060], [2062, 2062, 2085, 2085, 2456], [2458, 2458, 2486, 2486, 2673], [2675, 2675, 2714, 2714, 3054], [3056, 3056, 3080, 3080, 3294], [3296, 3296, 3332, 3332, 3884], [3886, 3886, 3957, 3957, 4236], [4238, 4238, 4294, 4294, 5305], [5307, 5307, 5364, 5364, 5877]], "test": "untested"}
{"id": "3ly3Rc", "name": "pseudo-Tron screensaver 3", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/WlyGz3[/url]\nvariant of [url]https://shadertoy.com/view/ttyGWD[/url]", "tags": ["tron", "particles", "short", "golf", "3tweets"], "likes": 9, "viewed": 414, "published": 3, "date": "1579445791", "time_retrieved": "2024-07-30T21:29:44.472124", "image_code": "// variant of https://shadertoy.com/view/WlyGz3\n// variant of https://shadertoy.com/view/ttyGWD\n// variant of https://shadertoy.com/view/ttyGWD\nvoid mainImage(out vec4 O, vec2 U) { mi }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// variant of https://shadertoy.com/view/ttyGWD\nvoid mainImage(out vec4 O, vec2 U) { mi }", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// +6: wow: a windows Angle compatibility bug forbids using (cond)?: for iFrame==0 || O.w < 0.\n//                                            cf: https://www.shadertoy.com/view/wtV3DW\n\n#define T(U) texture( iChannel0, U / H.xy )                    //\n#define mi                                                      \\\n    vec4 H = iResolution.xyzz;   int t = iFrame;                \\\n    O = T(U);                                                   \\\n    if (U.y < 1.)  /* move particles */                         \\\n        if ( t < 1 || O.w < 1. )                                \\\n            H = fract( sin( (iTime+U.x) * H ) *4e4 ),           \\\n            O = H, O.z*=6.3, O.w = exp(fract(H.z*4.)*5.)-1. ;   \\\n        else O.xy = fract( O.xy + (U.x==.5 ? cos(O.z+vec2(11,0))\\\n                                           : (T(vec2(0))-O).xy )\\\n                                 *H.y/1e2/H.xy ),               \\\n             O.z +=.1, O.w-- ;                                  \\\n    else           /* draw trajectories */                      \\\n        for( H--, O *= .97; H.z++ < 4e2; )                      \\\n            O = mix( O, .6 + .6 * cos( H.z + vec4(0,23,21,0) ), \\\n                     clamp( H.y/2e2 - length( U - (H*T(H.zw)).xy )*20./T(H.zw).w, 0.,1. ) );", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ly3Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WlG3Rc", "name": "A star at dawn", "author": "angelo12", "description": "2020 shader challenge week 3!", "tags": ["reflections", "pathtracing", "colour"], "likes": 2, "viewed": 347, "published": 3, "date": "1579445098", "time_retrieved": "2024-07-30T21:29:45.238077", "image_code": "/*\n\tShader Sundays! (3/52) \n\t\"A star at Dawn\"\n\t\n\tThis week I continued my path tracing experiments but struggled a lot more than the last one. It turns out that\n\tit's considerably easier to write a path tracer than to write an interesting scene with it. This one probably\n\tdoesn't even really need to be pathtraced since it's so simple. Next week I'm gonna focus on building a pretty\n\tscene instead of learning some new gfx thing. \n\n\tSources of inspiration for this week:\n\thttps://iquilezles.org/articles/palettes\n\thttp://the-witness.net/\n*/\n\n#define INV_GAMMA 0.454545\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    vec3 col;\n    vec2 screen = fragPos / iResolution.xy;\n\n    //Simple montecarlo integration\n    if(iFrame > 0)\n    {\n        col = texture(iChannel0, screen).xyz;\n        col /= float(iFrame);\n    } \n\n    //Post processing\n    col = pow(col, vec3(INV_GAMMA));\n    col *= 2.0;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//GLOBALS\nfloat seed_ = 0.0;\n\nfloat \nhash(float p)\n{ \n    p = fract(p* 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3\nCosineWeightedRay(vec3 normal, float seed)\n{\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( normal + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );   \n}\n\nmat3\nSetCamera(vec3 eye, vec3 tar, float roll)\n{\n    vec3 f, r, u, upTemp;\n    f = normalize(tar - eye);\n    upTemp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(upTemp, f)); \n    u = normalize(cross(f, r));\n\n    return mat3(r, u, f);\n}\n\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat\nsdBox(vec3 p, vec3 s)\n{\n    vec3 q = abs(p) - s;\n    return length(max(q,0.0)) + min(max(max(q.x, q.y), q.z), 0.0);\n}\n\nvec2 \nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\nvec3\nrepetitionOp(vec3 p, vec3 cellSize)\n{\n    return mod(p + +0.5*cellSize, cellSize) - 0.5*cellSize;\n}\n\nfloat\nsdCircle(vec3 p, float r, float t)\n{\n    float d1 = sdBox(p, vec3(r, r, t));\n\n    float d2 = sdSphere(p, r);\n\n    return max(d1, d2);\n}\n\n#define UOP(dist, id) res = uop(res, vec2(dist, id))\n\n#define SPHERE1_ID 0.0\n#define SPHERE2_ID 1.0\n\n#define BOTTOM_ID 2.0\n#define TOP_ID 3.0\n#define LEFT_ID 4.0\n#define RIGHT_ID 5.0\n#define BACK_ID 6.0\n#define FRONT_ID 7.0\n\n#define WITNESS_ID 8.0\n\n#define EPSI 0.005\n\nvec2\nMap(vec3 p)\n{\n    vec2 res = vec2(1e10, -1.0);\n    //Random box\n    //UOP(sdSphere(p - vec3(00.5, 00.2, 00.0),      0.25),           SPHERE1_ID);\n    //UOP(sdSphere(p - vec3(-0.5, 00.2, 00.0),      0.25),           SPHERE2_ID);\n\n    //Enclosure\n    UOP(sdBox(p - vec3(00.0, -0.1, 00.0), vec3(01.0, EPSI, 1.0)), BOTTOM_ID);\n    UOP(sdBox(p - vec3(00.0, 01.0, 00.0), vec3(01.0, EPSI, 1.0)), TOP_ID);\n    UOP(sdBox(p - vec3(01.0, 00.0, 00.0), vec3(EPSI, 01.0, 1.0)), LEFT_ID);\n    UOP(sdBox(p - vec3(-1.0, 00.0, 00.0), vec3(EPSI, 01.0, 1.0)), RIGHT_ID);\n    UOP(sdBox(p - vec3(00.0, 00.0, -1.0), vec3(01.0, 01.0, EPSI)), FRONT_ID);\n    UOP(sdBox(p - vec3(00.0, 00.0, 01.0), vec3(01.0, 01.0, EPSI)), BACK_ID);\n\n    //Witness Symbol\n    float h = 0.4;\n    float d = 0.1;\n    float p1 = 0.05;\n    float size = 1.2;\n    UOP(sdCircle(p - vec3(-0.7 + p1, h, d), 0.14*size, EPSI), WITNESS_ID);\n    UOP(   sdBox(p - vec3(-0.0 + p1, h, d), vec3(0.7, 0.07*size, EPSI )), WITNESS_ID);\n    UOP(sdCircle(p - vec3(00.7 + p1, h, d), 0.07*size, EPSI), WITNESS_ID);\n\n    return res;\n}\n\n#define MAX_STEPS 400\n#define MAX_DIST 200.0\n#define MIN_DIST 0.001\nvec2\nRayMarch(vec3 ro, vec3 rd)\n{\n    vec2 res = vec2(-1.0, -1.0);\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++i)\n    {\n        vec2 hit = Map(ro + t*rd);\n\n        if(abs(hit.x) < t*MIN_DIST)\n        {\n            res = vec2(t, hit.y);\n            break;\n        }\n\n        t += hit.x;\n    }\n\n    return res;\n}\n\nvec3\nCalcNormal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(Map(p + e.xyy).x - Map(p - e.xyy).x, \n                          Map(p + e.yxy).x - Map(p - e.yxy).x,\n                          Map(p + e.yyx).x - Map(p - e.yyx).x));\n}\n\nstruct Material\n{\n    vec4 color; // RGB (unused 4th channel)\n    vec4 properties; // Emissive, Roughness, unused 3rd & 4th channel\n};\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nMaterial\nGetMaterial(vec3 p, vec3 n, float id)\n{\n    Material mat;\n    mat.color = vec4(vec3(1.0), -1.0);\n    mat.properties = vec4(0.0, 1.0, -1.0, -1.0);\n\n    if(id == SPHERE1_ID)\n    {\n        mat.color.xyz = vec3(1.0, 1.0, 1.0);\n        mat.properties.x = 0.0;  //Emissive \n        mat.properties.y = 1.0 * mod(floor(p.x * 40.0), 2.0);  //Roughness (0.0reflective, 1.0diffuse)\n    }\n    else if(id == SPHERE2_ID)\n    {\n        mat.properties.y = 1.0 * mod(floor(p.y * 40.0), 2.0);  //Roughness (0.0reflective, 1.0diffuse)\n        mat.color.xyz = vec3(1.0, 1.0, 1.0);\n        mat.properties.x = 0.0;  //Emissive \n    }\n    else if(id == BOTTOM_ID)\n    {\n        // vec2 tile = floor(p.xz * 4.0);\n        // float isTile = mod(tile.x + tile.y, 2.0);\n        // mat.color.xyz = vec3(1.0, 1.0, 1.0) * isTile;\n        mat.color.xyz = vec3(0.8, 0.9, 1.1);\n        //mat.properties.x = 0.5;  //Emissive \n        mat.properties.y = 0.005 ;  //Roughness (0.0reflective, 1.0diffuse)\n    }\n    else if(id == TOP_ID)\n    {\n        mat.color.xyz = vec3(0.8, 0.9, 1.1);\n        //mat.properties.x = 0.5;  //Emissive \n        mat.properties.y = 0.006;  //Roughness (0.0reflective, 1.0diffuse)\n    }\n    else if(id == LEFT_ID)\n    {\n        mat.color.xyz = vec3(0.8, 0.9, 1.1);\n        //mat.properties.x = 0.5;  //Emissive \n        mat.properties.y = 0.007;  //Roughness (0.0reflective, 1.0diffuse)\n\n    }\n    else if(id == RIGHT_ID)\n    {\n        mat.color.xyz = vec3(0.8, 0.9, 1.1);\n        //mat.color.xyz = vec3(1.0, 0.0, 0.0);\n        //mat.properties.x = 0.5;  //Emissive \n        mat.properties.y = 0.008;  //Roughness (0.0reflective, 1.0diffuse)\n\n    }\n    else if(id == BACK_ID)\n    {\n        mat.properties.y = 0.008;  //Roughness (0.0reflective, 1.0diffuse)\n    }\n    else if(id == FRONT_ID)\n    {\n\t\tmat.properties.y = 0.007;  //Roughness (0.0reflective, 1.0diffuse)\n    }\n    else if(id == WITNESS_ID)\n    {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(1.0, 1.0, 1.0);\n        vec3 d = vec3(0.0, 0.33, 0.67);\n\n        float t = p.x / 2.0;\n        mat.color.xyz = palette(t, a, b, c, d);\n        mat.properties.x = 1.5;  //Emissive \n    }\n\n    return mat;\n}\n\n#define saturate(val) clamp(0.0, 1.0, val)\n\nvec3\nCalcRayDirection(vec3 originalRd, vec3 reflectionDir, vec3 normal, float rough, float seed)\n{\n    vec3 newRd = vec3(0.0);\n    vec3 randDir = CosineWeightedRay(normal, seed);\n    if(rough >= 1.0)\n    {\n        newRd = randDir;\n    }\n    else\n    {\n        newRd = reflectionDir*(saturate(1.0 - rough)) + rough * randDir;\n        newRd = normalize(newRd);\n    }\n\n    return newRd;\n}\n\nconst vec3 skyCol = vec3(0.5, 0.8, 0.9);\n\n#define GI_BOUNCES 10\nvec3\nRender(vec3 ro, vec3 rd)\n{\n    //GI accumulation setup\n    vec3 tot = vec3(0.0);\n\n    float firstBounceDist = 0.0;\n\n    vec3 rayCol = vec3(1.0);\n\n    //Global illumination loop for solid lighting\n    for(int bounce = 0; bounce < GI_BOUNCES; ++bounce)\n    {\n        //Ray traversal results\n        vec2 res = RayMarch(ro, rd);\n        float t = res.x;\n        float id = res.y;\n\n        if(id < 0.0)\n        {\n            if(bounce == 0)\n            {\n                tot = skyCol;\n            }\n            break;\n        }\n\n        if(bounce == 0 ) firstBounceDist = t;\n\n        //Geometry\n        vec3 P = ro + t*rd;\n        vec3 N = CalcNormal(P);\n        vec3 R = reflect(rd, N);\n\n        //Material\n        Material mat = GetMaterial(P, N, id);\n        rayCol *= mat.color.xyz;\n        float emissiveness = mat.properties.x;\n        float roughness = mat.properties.y;\n\n        //Lighting\n        vec3 lightAccumulation = vec3(0.0);\n        vec3 indirectLight = emissiveness * rayCol;\n\n        //Shadowing\n\n        //Shading\n        lightAccumulation += indirectLight;\n\n        //Light accumulation\n        lightAccumulation *= pow(0.65, float(bounce));\n        tot += lightAccumulation * rayCol;\n\n\n        //Next bounce setup\n        float timeSeed =  76.2 + 73.1*float(bounce) + seed_ + 17.7*float(iFrame);\n        ro = P;\n        rd = CalcRayDirection(rd, R, N, roughness, timeSeed);\n    }\n\n    //Hacky Volumetrics\n\n    //Distance fog\n    tot = mix(tot, skyCol, 1.0 - exp(-0.002*firstBounceDist *firstBounceDist));\n\n\n\n    return tot;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    //Generating a different random number per frame per pixel\n    seed_ = hash( dot(vec2(12.9898, 78.233), fragPos ) + float(iFrame)*1113.1);\n\n    //Getting prev frame result for additive blend \n    vec2 screen = fragPos / iResolution.xy;\n    vec3 col = texture(iChannel0, screen).xyz;\n    if (iFrame == 0) col = vec3(0.0);\n\n    //Camera setup\n    float nearp = 0.7;\n    float roll = 0.0;\n    vec2 offset = -0.5 + vec2(hash(seed_ + 58.21), hash(seed_ + 18.61));\n    vec2 uv = ((fragPos + offset) - 0.5*iResolution.xy) / iResolution.y;\n    vec3 ta = vec3(0.0, 0.3, 0.0);\n    vec3 ro = ta + vec3(0.5, 0.0, -0.97);\n    mat3 cam  = SetCamera(ro, ta, roll);\n    vec3 rd = cam * normalize(vec3(uv, nearp));  \n\n    //Rendering the path of one ray\n    col += Render(ro, rd);\n    //Debug rng\n    //col = vec3(seed_);\n\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlG3Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[571, 571, 624, 624, 937]], "test": "untested"}
{"id": "3tyGRc", "name": "abelian sandpile model", "author": "unnick", "description": "click this to make it faster: [url]JAVASCRIPT:H=location.host;E=(H?window:opener).Effect;P=E.prototype;if(!E.P)E.P=P.Paint;P.Paint=function(...A){for(i=0;i<16;i++)E.P.apply(this,A);};if(!H)close();[/url]\nclick the bottom-left corner to clear the screen.", "tags": ["2d", "fractal", "automata"], "likes": 5, "viewed": 412, "published": 3, "date": "1579444238", "time_retrieved": "2024-07-30T21:29:46.014001", "image_code": "vec3 palette[4] = vec3[4](\n    vec3(0,0,1),\n    vec3(.5,.7,1),\n    vec3(1,1,0),\n    vec3(.5,0,0)\n);\n\nvoid mainImage(out vec4 col, in vec2 pos) {\n    int state = int(texture(iChannel0, pos/res).x);\n    col = state >= 4 ? vec4(1) : palette[state].xyzz;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 col, in vec2 pos) {\n    #define fetch(a,b) int(texelFetch(iChannel0, ipos+ivec2(a,b), 0).x)\n    ivec2 ipos = ivec2(pos);\n    int state = fetch(0,0);\n    state -= int(state >= 4) * 4;\n    state += int(fetch( 1,  0) >= 4);\n    state += int(fetch( 0,  1) >= 4);\n    state += int(fetch(-1,  0) >= 4);\n    state += int(fetch( 0, -1) >= 4);\n    if(floor(pos) == round(res/2.)) state = 4;\n    if(iMouse.z > .5 && round(iMouse.xy) == floor(pos)) state = 256;\n    if(iMouse.z > .5 && iMouse.x < 30. && iMouse.y < 30.) state = 0;\n    col = vec4(state);\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define res iResolution.xy\n", "buffer_b_code": "void mainImage(out vec4 col, in vec2 pos) {\n    #define fetch(a,b) int(texelFetch(iChannel0, ipos+ivec2(a,b), 0).x)\n    ivec2 ipos = ivec2(pos);\n    int state = fetch(0,0);\n    state -= int(state >= 4) * 4;\n    state += int(fetch( 1,  0) >= 4);\n    state += int(fetch( 0,  1) >= 4);\n    state += int(fetch(-1,  0) >= 4);\n    state += int(fetch( 0, -1) >= 4);\n    if(floor(pos) == round(res/2.)) state = 4;\n    \n    \n    col = vec4(state);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 col, in vec2 pos) {\n    #define fetch(a,b) int(texelFetch(iChannel0, ipos+ivec2(a,b), 0).x)\n    ivec2 ipos = ivec2(pos);\n    int state = fetch(0,0);\n    state -= int(state >= 4) * 4;\n    state += int(fetch( 1,  0) >= 4);\n    state += int(fetch( 0,  1) >= 4);\n    state += int(fetch(-1,  0) >= 4);\n    state += int(fetch( 0, -1) >= 4);\n    if(floor(pos) == round(res/2.)) state = 4;\n    \n    \n    col = vec4(state);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 col, in vec2 pos) {\n    #define fetch(a,b) int(texelFetch(iChannel0, ipos+ivec2(a,b), 0).x)\n    ivec2 ipos = ivec2(pos);\n    int state = fetch(0,0);\n    state -= int(state >= 4) * 4;\n    state += int(fetch( 1,  0) >= 4);\n    state += int(fetch( 0,  1) >= 4);\n    state += int(fetch(-1,  0) >= 4);\n    state += int(fetch( 0, -1) >= 4);\n    if(floor(pos) == round(res/2.)) state = 4;\n    \n    \n    col = vec4(state);\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyGRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 144, 144, 252]], "test": "untested"}
{"id": "WlyGz3", "name": "pseudo-Tron screensaver 2", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/ttyGWD[/url]", "tags": ["tron", "particles", "short", "golf", "3tweets"], "likes": 8, "viewed": 465, "published": 3, "date": "1579436039", "time_retrieved": "2024-07-30T21:29:46.798903", "image_code": "// variant of https://shadertoy.com/view/ttyGWD\n// variant of https://shadertoy.com/view/ttyGWD\nvoid mainImage(out vec4 O, vec2 U) { mi }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// variant of https://shadertoy.com/view/ttyGWD\nvoid mainImage(out vec4 O, vec2 U) { mi }", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// +6: wow: a windows Angle compatibility bug forbids using (cond)?: for iFrame==0 || O.w < 0.\n//                                            cf: https://www.shadertoy.com/view/wtV3DW\n\n#define T(U) texture( iChannel0, U / H.xy )                    //\n#define mi                                                      \\\n    vec4 H = iResolution.xyzz;   int t = iFrame;                \\\n    O = T(U);                                                   \\\n    if (U.y < 1.)  /* move particles */                         \\\n        if ( t < 1 || O.w < 1. )                                \\\n            H = fract( sin( (iTime+U.x) * H ) *4e4 ),           \\\n            O = H, O.z*=6.3, O.w = exp(fract(H.z*4.)*5.)-1. ;   \\\n        else O.xy = fract( O.xy + cos(O.z+vec2(11,0)) * O.w*H.y/4e3/H.xy ),\\\n             O.z +=.1, O.w-- ;                                  \\\n    else           /* draw trajectories */                      \\\n        for( H--, O *= .97; H.z++ < 2e2; )                      \\\n            O = mix( O, .6 + .6 * cos( H.z + vec4(0,23,21,0) ), \\\n                     clamp( H.y/2e2 - length( U - (H*T(H.zw)).xy )*9./T(H.zw).w, 0.,1. ) );", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtyGz3", "name": "Sound Tribe Sector9", "author": "yasuo", "description": "https://sts9.com/", "tags": ["sts9"], "likes": 6, "viewed": 311, "published": 3, "date": "1579434818", "time_retrieved": "2024-07-30T21:29:47.547900", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) 1.0-smoothstep(b,antialiasing(1.0),d)\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat typoS(vec2 p) {\n    vec2 pref = p;\n\tp*= Rot(radians(90.0));\n    float c0 = sdUnevenCapsule(p,0.15,0.15,0.22);\n    float c1 = sdUnevenCapsule(p,0.07,0.07,0.22);\n    p = pref;\n    float c2 = length(p+vec2(-0.12,0.11))-0.04;\n    float topC = min(max(p.x-0.12,max(-c1,c0)),c2);\n    \n    vec2 btmP = vec2(0.1,0.11);\n    c0 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.15,0.15,0.22);\n    c1 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.07,0.07,0.22);\n    p = pref;\n    c2 = length(p+btmP+vec2(-0.1,-0.11))-0.04;\n    float btmC = min(max(-p.x-btmP.x+0.1,max(-c1,c0)),c2);\n    \n    return min(topC,btmC);\n}\n\nfloat typoT(vec2 p) {\n    vec2 pref = p;\n\tfloat b0 = dBox2d(p+vec2(-0.33,-0.11),vec2(0.18,0.04));\n    float b1 = dBox2d(p+vec2(-0.405,0.11),vec2(0.105,0.15));\n    float b2 = dBox2d(p+vec2(-0.485,0.19),vec2(0.105,0.15));\n    float b3 = dBox2d(p+vec2(-0.338,0.00),vec2(0.045,0.045));\n    float c0 = length(p+vec2(-0.379,0.04))-0.08;\n    float b = min(min(b0,max(-b3,max(-b2,b1))),max(-b2,c0));\n    return b;\n}\n\nfloat typoNine(vec2 p) {\n    float c0 = sdUnevenCapsule(p*Rot(radians(90.0)),0.15,0.15,0.14);\n    float c1 = sdUnevenCapsule(p*Rot(radians(90.0)),0.07,0.07,0.14);\n    float cut0 = dBox2d((p+vec2(-0.26,-0.04))*Rot(radians(20.0)),vec2(0.08,0.08));\n    float cut1 = dBox2d(p+vec2(-0.32,0.1),vec2(0.2,0.1));\n    float c2 = length(p+vec2(-0.12,0.11))-0.04;\n    float topC = min(max(-cut1,max(-cut0,max(-c1,c0))),c2);\n    \n    vec2 btmP = vec2(0.1,0.11);\n    c0 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.15,0.15,0.22);\n    c1 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.07,0.07,0.22);\n    c2 = length(p+btmP+vec2(-0.1,-0.11))-0.04;\n    cut0 = dBox2d((p+vec2(-0.05,0.2)),vec2(0.08,0.08));\n    float btmC = max(-cut0,min(max(-p.x-btmP.x+0.1,max(-c1,c0)),c2));\n    \n    return min(topC,btmC);\n}\n\nvec3 animateBg(vec2 p, vec3 col, float s, float t) {\n    p*=Rot(radians(t*20.0));\n    p.x = abs(p.x);\n    p.x -= 0.34;\n    p.y = abs(p.y);\n    p.y -= 0.2;\n    \n    p*= s;\n    float thickness = 0.03;\n    float t0 = sdTriangle(vec2(0.0,0.1), vec2(-0.1,-0.05),vec2(0.1,-0.05),(p+vec2(0.0,0.0))*Rot(radians(t*50.0)));\n    float t0m = sdTriangle(vec2(0.0,0.1-thickness), vec2(-0.1+thickness,-0.05+thickness*0.5),vec2(0.1-thickness,-0.05+thickness*0.5),(p+vec2(0.0,0.0))*Rot(radians(t*50.0)));\n    float t1 = sdTriangle(vec2(0.0,-0.05), vec2(-0.1,0.1),vec2(0.1,0.1),(p+vec2(0.2,0.0))*Rot(radians(t*40.0)));\n    float t1m = sdTriangle(vec2(0.0,-0.05+thickness), vec2(-0.1+thickness,0.1-thickness*0.5),vec2(0.1-thickness,0.1-thickness*0.5),(p+vec2(0.2,0.0))*Rot(radians(t*40.0)));\n    float t2 = sdTriangle(vec2(0.0,-0.1), vec2(-0.1,0.1),vec2(0.1,0.1),(p+vec2(-0.2,0.0))*Rot(radians(t*35.0)));\n    float t2m = sdTriangle(vec2(0.0,-0.1+thickness), vec2(-0.1+thickness,0.1-thickness*0.5),vec2(0.1-thickness,0.1-thickness*0.5),(p+vec2(-0.2,0.0))*Rot(radians(t*35.0)));\n    float res = min(max(-t0m,t0),min(max(-t1m,t1),max(-t2m,t2)));\n\n    float blur = -0.02;\n    col = mix( col,  0.5 + 0.5*sin(t+p.xyx+vec3(1,2,4)), S(res,blur) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p =  (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    p +=(mod(iTime,3.0)<0.3)?sin(floor(p*30.0)*iTime*15.)*0.03:vec2(0.0);\n    vec2 pref = p;\n    \n    // bg color\n    vec3 col = vec3(0.0);\n    \n\tfloat logoY = -0.03;\n    float s0 = typoS(p+vec2(0.62,logoY));\n    float t = typoT(p+vec2(0.62,logoY));\n    float s1 = typoS(p+vec2(-0.07,logoY));\n    float nine = typoNine(p+vec2(-0.49,logoY));\n\n    col = animateBg(p,col,0.7,iTime*1.2);\n    col = animateBg(p,col,0.65,-iTime*1.7);\n    col = animateBg(p,col,0.4,iTime*2.2);\n    col = animateBg(p,col,0.5,-iTime*2.0);\n    vec3 bgCol = col;\n    \n    float blur = 0.0;\n    \n\tcol = mix( col, vec3(1.0)-bgCol, S(s0,blur) );\n    col = mix( col, vec3(1.0), S(t,blur) );\n    col = mix( col, vec3(1.0)-bgCol, S(s1,blur) );\n    \n    col = mix( col, (0.5 + 0.5*sin(iTime+p.xyx+vec3(1,2,3)))-bgCol, S(nine,blur) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 193, 193, 243], [245, 245, 312, 312, 951], [953, 953, 1015, 1015, 1254], [1256, 1256, 1277, 1277, 1866], [1868, 1868, 1889, 1889, 2275], [2277, 2277, 2301, 2301, 3072], [3074, 3074, 3126, 3126, 4312], [4314, 4314, 4371, 4371, 5292]], "test": "untested"}
{"id": "wlVGRG", "name": "Urban Light", "author": "kstyler", "description": "I wanted to practice modeling with distance functions. This is my attempt to reinterpret the Urban light art piece at the LACMA.", "tags": ["raymarch", "infinite", "lamps", "la"], "likes": 2, "viewed": 224, "published": 3, "date": "1579409355", "time_retrieved": "2024-07-30T21:29:48.302881", "image_code": "//distance functions from https://iquilezles.org/articles/distfunctions\nconst int MAX_DST = 800;\nconst float EPSI = 0.001;\nint mat = 0;//coloring objects\n\nmat2 rotate(float a){\n\treturn mat2(cos(a),-sin(a),\n               \tsin(a), cos(a));\n}\n\nfloat roundCone( vec3 p, float r1, float r2, float h ){\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sphere(vec3 p,float radius){\n    return length(p)-radius;\n}\n\nfloat box(vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat octagon(vec3 p, vec3 b){//Using 4 boxes to cut off the 4 conrers of another box and make an octagon.\n    float b1 =  box(p,b);\n    \n    vec3 b2Rot = p;\n    b2Rot.xz*= rotate(0.8);\n    float b2 =  box(b2Rot+vec3(b.x*2.0,0.,b.z*0.),b+vec3(0,1.,0));\n    \n    vec3 b3Rot = p;\n    b3Rot.xz*= rotate(2.4);\n    float b3 =  box(b3Rot+vec3(b.x*2.0,0.,b.z*0.),b+vec3(0,1.,0));\n    \n        \n    vec3 b4Rot = p;\n    b4Rot.xz*= rotate(4.0);\n    float b4 =  box(b4Rot+vec3(b.x*2.0,0.,b.z*0.),b+vec3(0,1.,0));\n    \n    vec3 b5Rot = p;\n    b5Rot.xz*= rotate(5.5);\n    float b5 =  box(b5Rot+vec3(b.x*2.0,0.,b.z*0.),b+vec3(0,1.,0));\n    \n    float sm = 0.05;\n    return smoothSub(b5,smoothSub(b4,smoothSub(b3,smoothSub(b2,b1,sm),sm),sm),sm);\n}\n\nfloat lampBase(vec3 p){\n    vec3 octPos = vec3 (0.,10.5,0.);\n    vec3 octPos2 = vec3 (0.,-0.8,0.);\n    return smoothUnion(octagon(p+octPos,vec3(2.0,0.4,2.0)),octagon(p+octPos2+octPos,vec3(1.8,0.4,1.8)),0.3);\n}\n\nfloat cyl(vec3 p){\n    float rad = 0.8;\n    rad -= 0.03*p.y;\n    rad -= 0.15*(0.3+0.3*sin(13.*atan(p.x,p.z)));\n    float d = length(p.xz)- rad;\t\n    d = max(d,p.y-10.);\n    d = max(d,-p.y-10.);\n\treturn d;\n}\n\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map(vec3 p, bool setMat){\n    float c = 10.;\n    p.x = mod(p.x+c*0.5,c)-c*0.5;\n    p.z = mod(p.z+c*0.5,c)-c*0.5;\n    vec3 cylPos = vec3 (0.,0.,0.); \n    float bulb = roundCone(p+vec3(0,-11.0,0),1.2,1.4,1.);\n    float tip1 = sphere(p+vec3(0,-13.35,0),0.3);\n    float tip2 = sphere(p+vec3(0,-13.1,0),0.5);\n    \n    float minD =min(tip1,\n               \tmin(tip2,\n               \tmin(bulb,\n               \tsmoothUnion(torus(p+vec3(0,-10.2,0),vec2(0.7,0.4)),\n        \t\tsmoothUnion(octagon(p+vec3(0,6.5,0),vec3(1.05,0.4,1.05)),\n               \tsmoothUnion(torus(p+vec3(0,-8.6,0),vec2(0.53,0.1)),\n                smoothUnion(torus(p+vec3(0,-7.8,0),vec2(0.56,0.1)),\n                smoothUnion(cyl(p+cylPos),lampBase(p),1.0),0.1),0.1),0.1),0.5))));\n    \n    if(setMat){\n    if(minD == bulb ||minD == tip1 ||minD == tip2){//Lamp Light\n            mat = 2;\n    }else{mat =3;}//Lamp Body\n        \n    }\n    return minD;\n    \n}\n\nfloat rayMarch(vec3 ro,vec3 rd, bool setMat){\n    float tot = 0.;\n    float dst = 0.;\n    for(int i = 0; i < MAX_DST; i++){\n        vec3 p = ro + rd*tot;\n        dst = map(p,setMat);\n        tot+=dst;\n        if(dst<EPSI||tot>float(MAX_DST)){\n        \ttot = float(i)/float(MAX_DST);\n            break;\n        }\n     }\n    if(dst>EPSI && setMat){//sky\n    \tmat = 1;\n    }\n\treturn tot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x; \n    vec3 ro = vec3(5,-3,-50. + iTime*10.);\n    vec3 rd = normalize(vec3(uv,1.));\n    float rm = rayMarch(ro,rd,true);\n    vec3 col =vec3(rm);\n    \n    if(mat == 1)col = vec3(1);\n    if(mat == 2)col = vec3(1.,1.,0.85); \n    if(mat == 3)col += vec3(0.7,0.73,0.7);\n                \n    col = mix(col,vec3(1),1.-exp(-3.*rm));//fog\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 176, 176, 240], [242, 242, 297, 297, 561], [563, 563, 597, 597, 628], [630, 630, 657, 657, 744], [746, 746, 796, 796, 896], [898, 898, 946, 946, 1047], [1049, 1049, 1079, 1155, 1781], [1783, 1783, 1806, 1806, 1992], [1994, 1994, 2012, 2012, 2200], [2202, 2202, 2232, 2232, 2297], [2299, 2299, 2330, 2330, 3221], [3223, 3223, 3268, 3268, 3609], [3611, 3611, 3667, 3667, 4088]], "test": "untested"}
{"id": "WlVGRV", "name": "metal nonbeing2", "author": "hmitchell", "description": "aaaaa", "tags": ["aaa"], "likes": 3, "viewed": 289, "published": 3, "date": "1579386961", "time_retrieved": "2024-07-30T21:29:49.165575", "image_code": "#define TWOPI (3.14159 * 2.0)\n\nfloat random (in vec2 st) {\n    return fract (sin(dot(st.xy,\n                          vec2(12.9898, 78.233)))*\n                  43758.543123);\n\t}\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n   //four corner in 2D of the tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + \n        (d - b) * u.x * u.y;\n    \n\t\t}\n\nfloat fbm (in vec2 p) {\n    \n    const int octaves = 1;\n    float freqScale = 2.;\n    float ampScale = 0.666;\n    float frequency = 1.;\n    float amplitude = 1.;\n    float result; //keep track of the sum of the noise outside\n    //of the loop\n    \n    for (int i = 0;i < octaves; i++) {\n        result += noise(p*frequency)*amplitude;\n        frequency *= freqScale;\n        amplitude *= ampScale;\n    }\n    \n    return result;\n    \n}\n    \n    \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x += sin(iTime*0.015 +  uv.y*11.) * cos(iTime*0.08) * 0.05 ;\n    uv.y += cos(iTime*0.02 +  uv.x*11.) * sin(0.04) * 0.05;\n                \n    // Time varying pixel color\n    vec3 col = texture(iChannel1, uv).rgb;\n    \n    float fbmResult = fbm(vec2(length(col)*0.05, iTime * 0.0001))*6.;\n    \n    uv += vec2(sin(.006*fbmResult), cos(6.*fbmResult))*cos(iTime *.03);\n    \n    \n   col.b = col.b - iMouse.x *0.001 ;\n   col.r = col.r - iMouse.x *0.003 ;\n   col.g = col.g + iMouse.x *0.001 ;\n    \n \n  \n        //* (iMouse.x * 0.000001) ;\n    \n\n    \n    col = texture(iChannel1, uv).rgb;\n    \n   //col.b = col.b - 0.2;\n   //col.r = col.r + 0.06;\n   //col.g = col.g + 0.1;\n    \n    \n   // col.r = length(col* 0.75)* 0.8;\n   // col.b = length(col* 0.55)* 0.9;\n   // col.g = length(col*.5);\n    \n   //col.b = col.b - iMouse.x *0.0002 ;\n   //col.r = col.r - iMouse.x *0.0003 ;\n   //col.g = col.g + iMouse.x *0.0002 ;\n   \n   \n    \n    //col.g = length(col.g);\n    \n   col = sin(col + length(col)*1.5 + 100. * 0.001) * -0.49 + 0.6;\n    \n  \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVGRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 58, 58, 178], [179, 179, 205, 205, 588], [590, 590, 613, 613, 1024], [1038, 1038, 1094, 1144, 2285]], "test": "untested"}
{"id": "WtK3zK", "name": "Continuum Mechanics", "author": "wyatt", "description": "divergence and curl is just about all you can say about a vector field - ignore torsion (ie delete w channel) - and this becomes a fluid simulation. This simulates a solid because it stores torsional energy. ", "tags": ["wave", "fluid"], "likes": 26, "viewed": 837, "published": 3, "date": "1579377032", "time_retrieved": "2024-07-30T21:29:50.016301", "image_code": "#define X vec2(5,4)\nfloat time;\nfloat ln (vec2 p, vec2 a, vec2 d,float i) {\n    float r = clamp(dot(p-a,d)/dot(d,d),0.,1.);\n\treturn length(p-a-d*r);\n}\nvoid mainImage( out vec4 Q, vec2 U )\n{\n    vec4 a ;\n    float r = 1e3;\n    float z = 20.;\n    Q = vec4(0);\n    for (int x = -2; x <= 3; x++)\n    for (int y = -2; y <= 3; y++) {\n        vec2 V = floor(U/X+0.5+vec2(x,y))*X;\n        V.x += mod(V.y/X.y,2.)*2.;\n        a = A(V);\n        r = min(1e3, ln(U,V,-z*X*a.xy,0.));\n        V -= z*X*a.xy;\n        a = A(V);\n        r = min(r,ln(U,V,-z*X*a.xy,1.));\n        Q += exp(-2.*r);\n    }\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n\n#define Main void mainImage( out vec4 Q, in vec2 U )\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w); \n", "buffer_a_code": "Main {\n\tQ = A(U);\n    Neighborhood;\n    // Gradient of Pressure\n    Q.xy += 0.25*vec2(w.z-e.z,s.z-n.z);\n    // Curl of Torsion\n    Q.xy += 0.25*vec2(s.w-n.w,e.w-w.w);\n    \n    \n    // Boundary conditions :\n    if (iMouse.z>0.) {\n    \tif (length(iMouse.xy-U)<10.)\n            Q.xy = vec2(0.5,0);\n    }\n    if (iFrame < 1) {\n    \tif (length(0.5*R-U)<10.)\n            Q.xy = vec2(0,0.5);\n    }\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)\n        Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tQ = A(U);\n    Neighborhood;\n    // convergence of velocity\n    Q.z += 0.25*(w.x-e.x+s.y-n.y);\n    // curl of velocity\n    Q.w += 0.25*(e.y-w.y+s.x-n.x);\n    // Make this a fluid simulation :\n    // Q.w *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = A(U-A(U).xy);\n    // Make this a fluid simulation :\n    // Q.w *= 0.;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 75, 75, 150], [151, 151, 189, 189, 584]], "test": "untested"}
{"id": "WlVGzK", "name": "Electric field lines interactive", "author": "frhun", "description": "This shader dynamically calculates, and shows the intensity and field lines of two positive charges, moving apart.\nBy clicking and holding somewhere, a negative charge can be inserted at that point.", "tags": ["2d", "interactive", "field", "physics", "vectorfield", "equipotential"], "likes": 7, "viewed": 598, "published": 3, "date": "1579375693", "time_retrieved": "2024-07-30T21:29:50.963767", "image_code": "vec3 colorGradiantBlackRedWhite( in float val ){ // generate color gradient from black over red and yellow to white\n    vec3 col;\n    col.r = val * 1.5;\n    col.g = (clamp(val, 0.33, 1.) - 0.33) * 1.5;\n    col.b = (clamp(val, 0.66, 1.) - 0.66) * 3.0;\n    return col;\n}\n\nvec2 grad1(in float dist, in vec2 uv){ //calculate field gradient, only for the two positive charges\n    return vec2(\n        ((dist-uv.x)/sqrt(pow(pow(dist - uv.x, 2.0) + pow(uv.y, 2.0), 3.0))) - ((dist+uv.x)/sqrt(pow(pow(dist + uv.x, 2.0) + pow(uv.y, 2.0), 3.0))),\n        (- (uv.y)/sqrt(pow(pow(dist - uv.x, 2.0) + pow(uv.y, 2.0), 3.0))) - ((uv.y)/sqrt(pow(pow(dist + uv.x, 2.0) + pow(uv.y, 2.0), 3.0))));\n}\n\nvec2 grad2(in float dist, in vec2 pos3, in vec2 uv){ //calculate field gradient, including user movable negative charge\n    return vec2(\n    \t((uv.x-pos3.x)/pow(pow(uv.x-pos3.x, 2.0) + pow(uv.y-pos3.y, 2.0), 1.5))\n        -((uv.x-dist)/pow(pow(uv.x-dist, 2.0) + pow(uv.y, 2.0), 1.5))\n        -((uv.x+dist)/pow(pow(uv.x+dist, 2.0) + pow(uv.y, 2.0), 1.5)) ,\n        \n        ((uv.y-pos3.y)/pow(pow(uv.x-pos3.x, 2.0) + pow(uv.y-pos3.y, 2.0), 1.5))\n        -((uv.y)/pow(pow(uv.x-dist, 2.0) + pow(uv.y, 2.0), 1.5))\n        -((uv.y)/pow(pow(uv.x+dist, 2.0) + pow(uv.y, 2.0), 1.5))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y); //make square coordinates with 0,0 in center\n    uv *= 2.0;\n    \n    float dist = sin(iTime/10.0 * 3.14); //current distance of the charges from center\n    \n    vec2 e1coord = vec2(-dist,0);\n    vec2 e2coord = vec2(dist,0);\n    vec2 e3coord = (iMouse.xy * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y); //get coordinates of user movable negative charge\n    e3coord *= 2.0;\n    \n    float e1 = 1.0/length(uv-e1coord);\n    float e2 = 1.0/length(uv-e2coord);\n    float e3 = 1.0/length(uv-e3coord);\n    \n    float e = e1 + e2 - (iMouse.z > 0.0 ? e3 : 0.0);\n    \n    bool eneg = e < 0.0;\n    \n    bool fieldLines = false; //is this point on a field line, originating with a target angle\n    vec2 currPos = uv;\n    if(!(min(length(e1coord - currPos), length(e2coord - currPos)) < 0.1\n            || (iMouse.z > 0.0 ? length(e3coord - currPos) < 0.1 : false))) //only try iteration when far enough from charge\n    for(int i = 200; i > 0; i--){ \t\t\t\t\t\t\t\t\t\t\t//iteration to find if point is on path of field line\n        vec2 grad = (iMouse.z > 0.0 ? grad2(dist, e3coord, currPos) : grad1(dist, currPos));\n        if(\n            min(length(e1coord - currPos), length(e2coord - currPos)) < 0.1\t//check if iteration came close to charge\n            || (iMouse.z > 0.0 ? length(e3coord - currPos) < 0.1 : false)\t//optionally check for interactive charge\n        ){\t\t\t\t\t\t\t\t\t\t\t// ↓ uncomment for \"rotating\" field lines\n        \tfloat gradAngle = mod(atan(grad.y/grad.x) + iTime/2.0, 3.14159 / 4.0);\n            if(gradAngle < max(abs(e), 1.0)/50.0) //expect more precision in target start angle; make field lines roughly same width\n            \tfieldLines = true;\n            break;\n        }\n        \tcurrPos += (grad / (length(grad) * 10.0)) * (min(1.0/length(grad), 1.0));\n    }\n    \n    \n    //combine field intensity, and show individual gradient components (red = -log(x of grad(E)); green = -log(y of grad(E))\n    /*\n\tvec2 grad = (iMouse.z > 0.0 ? grad2(dist, e3coord, uv) : grad1(dist, uv));\n\tvec3 col = mix(\n                \tclamp(colorGradiantBlackRedWhite(e/10.0), 0.0, 1.0),\n                \tclamp(vec3(-log(grad), -(-log(grad)).x), 0.0, 1.0),\n                    0.5\n                );*/\n    \n    //only show the field, repeating on equipotential lines\n    vec3 col = clamp(colorGradiantBlackRedWhite(mod(e, 1.0)), 0.0, 1.0);\n    \n    if(fieldLines){\n        if(eneg) // make field lines black in negative areas\n            col = vec3(0.0, 0.0, 0.0);\n        else\n        \tcol = vec3(1.0, 1.0, 1.0);\n    }\n    \n    //add blue for negative field\n    //if(eneg)\n    //    col.z = 1.0;\n\t\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVGzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 115, 268], [270, 270, 308, 370, 680], [682, 682, 734, 801, 1265], [1267, 1267, 1324, 1324, 4037]], "test": "untested"}
{"id": "wdGGDh", "name": "Judgement of the Sun", "author": "irwatts", "description": "Praise the Sun!", "tags": ["procedural", "2d", "sun", "sinusoidal", "solaire", "praise"], "likes": 12, "viewed": 424, "published": 3, "date": "1579370135", "time_retrieved": "2024-07-30T21:29:51.760636", "image_code": "// Judgement of the Sun\n\n// Many thanks to IQ\n// https://iquilezles.org/articles/smin\n// Polynomial Cubic Smooth Min (k = 0.1);\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a,b)-h*h*h/(6.0*k*k);\n}\n\n// Noise\nfloat randFloat(float n)\n{\n \treturn fract( sin( n*64.19 )*420.82 );\n}\nvec2 randVec2(vec2 n)\n{\n \treturn vec2(randFloat( n.x*12.95+n.y*43.72 ),randFloat( n.x*16.21+n.y*90.23 )); \n}\nfloat worley(vec2 n, float s)\n{\n    float dist = 2.0;\n    for( int x=-1;x<=1;x++ )\n    {\n        for( int y=-1;y<=1;y++ )\n        {\n            vec2 p = floor( n/s )+vec2(x,y);\n            float d = length( randVec2( p )+vec2(x,y)-fract( n/s ) );\n            if ( d < dist )\n            {\n             \tdist = d;   \n            }\n        }\n    }\n    return dist;\n}\n\nfloat wave(float dist, float offset)\n{\n    return (0.01*sin(29.0*dist-0.9*(iTime+offset)))\n        +(0.005*sin(72.0*dist-3.1*(iTime+offset)))\n        +(0.003*sin(96.0*dist-4.2*(iTime+offset)));\n}\n\n// Clouds\nvoid clouds(inout vec3 col, in vec2 uv)\n{\n    float noise = 0.8*worley(uv*64.0+vec2(-20.42*iTime,0.0), 128.0)+0.15*worley(uv*64.0+vec2(923.324-1.2*iTime,10.234), 5.0);\n    float grain = randFloat(uv.x*12.95+uv.y*43.72+0.001*noise);\n    noise -= grain*0.05;\n    vec3 lightDir = normalize(vec3(-0.25, 0.75, 0.1));\n    vec3 norm = normalize(vec3(worley(uv*256.0+vec2(90.1921,403.32), 32.0-8.0*noise)-0.5, 0.4*(worley(uv*(64.0+128.0*noise)+vec2(90.1921,3.14159), 24.0)-0.5), 0.5));\n    float lightDot = dot(lightDir, norm);\n    float disp = 10.0*wave(lightDot+uv.y,0.0);\n    float light = clamp(0.64+lightDot, 0.0, 1.0);\n    \n    col = mix(vec3(0.1,0.42,0.64), col, light);\n}\n\n// Sun Arms\nconst vec3 ARMS_COLOR = vec3(0.4745098, 0.1098039, 0.1647059);\nconst vec3 ARMS_END_COLOR = vec3(0.3803922, 0.1254902, 0.1647059);\nconst vec3 ARMS_SPLOTCH_COLOR = vec3(0.1901961, 0.0627451, 0.0823530);\nconst float ARMS_INNER_RADIUS = 0.18;\nconst float ARMS_OUTLINE = 0.005;\nconst float ARMS_FEATHER = 0.0025;\nconst float ARMS_LENGTH = 0.48;\nconst float ARMS_THICKNESS = 0.042;\n\nvoid arms(inout vec3 col, in vec2 uv, in vec2 id)\n{\n    float dist = 1.0;\n    float innerDist = length(uv)-ARMS_INNER_RADIUS;\n    \n    //float thickness = pow((ARMS_THICKNESS*cos((2.6/ARMS_LENGTH)*dist)),0.9);\n    float thickness = (1.0-pow(clamp(innerDist/(ARMS_LENGTH-ARMS_INNER_RADIUS),0.0,1.0),2.0))\n        *ARMS_THICKNESS;\n    \n    vec3 armColor = mix(ARMS_COLOR, ARMS_END_COLOR, \n                        clamp(innerDist/(ARMS_LENGTH-ARMS_INNER_RADIUS),0.0,1.0));\n    \n    float armDist = 0.0;\n    // Horizontal '-'\n    armDist = length(uv+vec2(clamp(-uv.x,-ARMS_LENGTH,ARMS_LENGTH),\n                             wave(innerDist,12.92*id.x)))-thickness+0.006;\n    dist = min(dist, armDist);\n    // Vertical '|'\n    armDist = length(uv+vec2(wave(innerDist,91.42*id.y),\n                             clamp(-uv.y,-ARMS_LENGTH,ARMS_LENGTH)))-thickness+0.006;\n    dist = min(dist, armDist);\n    // Diagonal '\\'\n    armDist = abs(uv.x+uv.y-wave(innerDist,69.32*(id.x+3.0*id.y)))\n        +0.012*abs(uv.x-uv.y)-thickness*1.4;\n    dist = min(dist, armDist);\n    // Diagonal '/'\n    armDist = abs(uv.x-uv.y+-wave(innerDist,128.13*(id.x+3.0*id.y)))\n        +0.012*abs(uv.x+uv.y)-thickness*1.4;\n    dist = min(dist, armDist);\n    \n    dist = smin(dist, innerDist, 0.05);\n    \n    // Background Sky Blue\n    col = mix(col, vec3(0.1,0.42,0.64), dist*2.0 );\n    \n    float outlineMask = smoothstep(ARMS_OUTLINE+ARMS_FEATHER,ARMS_OUTLINE,dist);\n    col = mix(col, vec3(0.0), outlineMask);\n    float armsMask = smoothstep(ARMS_FEATHER,0.0,dist);\n    float noise = 0.42*worley(uv*512.0, 32.0);\n    col = mix(col, armColor*(1.0+noise), armsMask);\n    \n    // Splotches\n    float splotchMask = pow(abs(1.0-worley(uv*(512.0), 12.0+20.0*wave(innerDist,42.13))), 4.0)*smoothstep(0.1, 0.0, innerDist)*\n        smoothstep(ARMS_FEATHER+0.03,0.0,dist+0.04);\n    col = mix(col, ARMS_SPLOTCH_COLOR, splotchMask);\n}\n\n// Sun Center\nconst vec3 CENTER_COLOR = vec3(0.6823529, 0.7058824, 0.3294118);\nconst float CENTER_RADIUS = 0.14;\nconst float CENTER_OUTLINE = 0.006;\nconst float CENTER_FEATHER = 0.004;\n\nvoid center(inout vec3 col, in vec2 uv)\n{\n    float dist = length(uv)-CENTER_RADIUS;\n    float outlineMask = smoothstep(CENTER_OUTLINE+CENTER_FEATHER,CENTER_OUTLINE,dist);\n    col = mix(col, vec3(0.0), outlineMask);\n    float centerMask = smoothstep(CENTER_FEATHER,0.0,dist);\n    //col = mix(col, CENTER_COLOR, centerMask);\n    //col = mix(col, CENTER_COLOR, 0.3*pow(1.0-dist,3.0));\n    // Shading\n    vec3 lightDir = normalize(vec3(-0.5, -0.042, 0.2));\n    float light = clamp(dot(lightDir, normalize(vec3(uv/CENTER_RADIUS, \n                                                     sqrt(1.0-clamp(dot(uv, uv),0.0,1.0))))), 0.0, 1.0);\n    //light = pow(light, 0.5);\n    float cells1 = 1.0-pow(worley(uv*1024.0, 32.0+100.0*wave(dist,189.37)), 0.2);\n    float cells2 = 1.0-pow(worley(uv*1024.0, 24.0+100.0*wave(dist,42.13)), 0.2);\n    float noise = 0.8*smin(cells1, cells2, 0.5);\n    float shading = 1.6*(1.0-((1.0-light)*(0.2+noise)));\n    //shading = light;\n    vec3 centerColor = mix(CENTER_COLOR, shading*CENTER_COLOR, 0.42);\n    col = mix(col, centerColor, centerMask);\n    \n}\n\n// Sun Face\nconst float BROW_WIDTH = 0.032;\nconst float BROW_THICKNESS = 0.0025;\nconst float BROW_L_X = -0.045;\nconst float BROW_L_Y = -0.074;\nconst float BROW_R_X = 0.06;\nconst float BROW_R_Y = -0.072;\nconst float SOCKET_WIDTH = 0.038;\nconst float SOCKET_THICKNESS = 0.001;\nconst float SOCKET_L_X = -0.053;\nconst float SOCKET_L_Y = -0.052;\nconst float SOCKET_R_X = 0.06;\nconst float SOCKET_R_Y = -0.052;\nconst float NOSE_HEIGHT = 0.035;\nconst float NOSE_THICKNESS = 0.0025;\nconst float NOSE_X = -0.015;\nconst float NOSE_Y = -0.029;\nconst float NOSTRILS_WIDTH = 0.02;\nconst float NOSTRILS_THICKNESS = 0.003;\nconst float NOSTRILS_X = 0.0;\nconst float NOSTRILS_Y = 0.015;\nconst float EYE_RADIUS = 0.005;\nconst float EYE_L_X = -0.052;\nconst float EYE_L_Y = -0.04;\nconst float EYE_R_X = 0.06;\nconst float EYE_R_Y = -0.04;\nconst float MOUTH_WIDTH = 0.042;\nconst float MOUTH_THICKNESS = 0.001;\nconst float MOUTH_Y = 0.05;\nconst float CHIN_WIDTH = 0.015;\nconst float CHIN_HEIGHT = 0.015;\nconst float CHIN_THICKNESS = 0.002;\nconst float CHIN_X = 0.0;\nconst float CHIN_Y = 0.08;\nconst float FACE_FEATHER = 0.0025;\n\nvoid face(inout vec3 col, in vec2 uv)\n{\n    float dist = 1.0;\n    float thickness = 0.0;\n    float disp = 0.0;\n    \n    vec2 eyesOffset = vec2(0.008*(sin(iTime*0.2+0.42)+0.42*sin(iTime*0.31)+0.1*sin(iTime*1.3)),0.0);\n    \n    // Left Eyebrow\n    thickness = BROW_THICKNESS+(0.001*sin(54.0*uv.x+2.1));\n    disp = (0.006*sin(50.0*uv.x+4.9));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          BROW_L_X-BROW_WIDTH,BROW_L_X+BROW_WIDTH),\n                                    BROW_L_Y-disp))-thickness);\n    \n    // Right Eyebrow\n    thickness = BROW_THICKNESS+(0.0015*sin(54.0*uv.x-2.9));\n    disp = (0.006*sin(90.0*uv.x+1.1));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          BROW_R_X-BROW_WIDTH,BROW_R_X+BROW_WIDTH),\n                                    BROW_R_Y-disp))-thickness);\n    // Left Eye Socket\n    thickness = SOCKET_THICKNESS+(0.001*sin(54.0*uv.x-1.8));\n    disp = (0.004*sin(80.0*uv.x+4.2+eyesOffset.x*42.0));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_L_X-SOCKET_WIDTH,\n                                          SOCKET_L_X+SOCKET_WIDTH-0.005),\n                                    SOCKET_L_Y-disp))-thickness);\n    thickness = SOCKET_THICKNESS+(0.002*sin(54.0*uv.x+2.2));\n    disp = (0.013*sin(120.0*uv.x+1.2));\n    dist = smin(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_L_X-SOCKET_WIDTH+0.0008,\n                                          SOCKET_L_X+SOCKET_WIDTH-0.072),\n                                    SOCKET_L_Y+0.004-disp))-thickness,\n               0.01);\n    thickness = SOCKET_THICKNESS+(0.0003*sin(80.0*uv.x-3.1));\n    disp = (0.003*sin(120.0*uv.x+2.2+eyesOffset.x*200.1));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_L_X-SOCKET_WIDTH+0.02,\n                                          SOCKET_L_X+SOCKET_WIDTH-0.015),\n                                    SOCKET_L_Y+0.022-disp))-thickness);\n    \n    // Right Eye Socket\n    thickness = SOCKET_THICKNESS+(0.001*sin(54.0*uv.x-2.9));\n    disp = (0.005*sin(100.0*uv.x+1.1+eyesOffset.x*42.0));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_R_X-SOCKET_WIDTH,\n                                          SOCKET_R_X+SOCKET_WIDTH),\n                                    SOCKET_R_Y-disp))-thickness);\n    thickness = SOCKET_THICKNESS+(0.001*sin(54.0*uv.x-2.9));\n    disp = (0.02*sin(70.0*uv.x-3.2));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_R_X-SOCKET_WIDTH-0.01,\n                                          SOCKET_R_X-0.04),\n                                    SOCKET_R_Y+0.022-disp))-thickness);\n    thickness = SOCKET_THICKNESS+(0.0003*sin(54.0*uv.x-2.9));\n    disp = (0.01*sin(70.0*uv.x-4.5+eyesOffset.x*60.0));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_R_X-SOCKET_WIDTH+0.015,\n                                          SOCKET_R_X+SOCKET_WIDTH-0.008),\n                                    SOCKET_R_Y+0.015-disp))-thickness);\n    \n    // Nose Bridge\n    thickness = NOSE_THICKNESS+(0.0015*sin(54.0*uv.y-2.9));\n    disp = (0.003*sin(120.0*uv.y-3.1));\n    dist = smin(dist, length(uv+vec2(NOSE_X-disp,\n                              clamp(-uv.y,NOSE_Y-NOSE_HEIGHT,NOSE_Y+NOSE_HEIGHT)))-thickness, \n                0.01);\n    // Nose Nostrils\n    thickness = NOSTRILS_THICKNESS+(0.002*sin(54.0*uv.x+1.0));\n    disp = (0.004*sin(160.0*uv.x-2.4));\n    dist = smin(dist, length(uv+vec2(clamp(-uv.x,NOSTRILS_X-NOSTRILS_WIDTH,\n                                          NOSTRILS_X+NOSTRILS_WIDTH),NOSTRILS_Y-disp))-thickness,\n               0.02);\n\n    // Left Eyeball\n    dist = min(dist, length(uv+vec2(EYE_L_X+eyesOffset.x,EYE_L_Y+eyesOffset.y))-EYE_RADIUS);\n    // Right Eyeball\n    dist = min(dist, length(uv+vec2(EYE_R_X+eyesOffset.x,EYE_R_Y+eyesOffset.y))-EYE_RADIUS);\n    \n    // Mouth\n    thickness = MOUTH_THICKNESS+(0.0015*sin(54.0*uv.x-1.7));\n    disp = (0.002*sin(120.0*uv.x-2.4));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,-MOUTH_WIDTH,MOUTH_WIDTH),\n                                    MOUTH_Y-disp))-thickness);\n    \n    // Chin\n    thickness = CHIN_THICKNESS+(0.005*sin(54.0*uv.x+0.4));\n    disp = (0.003*sin(80.0*(CHIN_X+uv.x)-2.8));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,CHIN_X-CHIN_WIDTH,CHIN_X+CHIN_WIDTH),\n                                    CHIN_Y-disp))-thickness);\n    thickness = CHIN_THICKNESS+(0.0005*sin(54.0*uv.y-2.9));\n    disp = (0.006*sin(120.0*(CHIN_Y+uv.y)+3.9));\n    dist = min(dist, length(uv+vec2(CHIN_X-0.022-disp,\n                              clamp(-uv.y,CHIN_Y+0.02-CHIN_HEIGHT,\n                                    CHIN_Y+0.01+CHIN_HEIGHT)))-thickness);\n    \n    col = mix(col, vec3(0.0), smoothstep(FACE_FEATHER,0.0,dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-(0.5*iResolution.xy))/iResolution.y;\n    //cuv *= 1.0+(0.5*sin(iTime*0.5));\t// Scale in out\n    vec3 col = vec3(1.0);\n    vec2 id = floor(uv*2.0);\n    clouds(col, cuv);\n    arms(col, cuv, id);\n    center(col, cuv);\n    face(col, cuv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGGDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 128, 167, 167, 241], [243, 252, 278, 278, 321], [322, 322, 345, 345, 430], [431, 431, 462, 462, 795], [797, 797, 835, 835, 992], [994, 1004, 1045, 1045, 1675], [2066, 2066, 2117, 2117, 3955], [4143, 4143, 4184, 4184, 5218], [6326, 6326, 6365, 6365, 11245], [11247, 11247, 11302, 11302, 11636]], "test": "untested"}
{"id": "tlG3RV", "name": "Day 30 - Xargantian Polyjupe", "author": "jeyko", "description": "Wow, it's 30. Is this the end?", "tags": ["tunnel", "glow", "mdtmjvm"], "likes": 32, "viewed": 1348, "published": 3, "date": "1579356988", "time_retrieved": "2024-07-30T21:29:52.520605", "image_code": "\n#define mx (10.*iMouse.x/iResolution.y)\n#define iTime (iTime - 25. + mx)\nvec3 getRd(vec3 ro,vec3 lookAt,vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n\treturn dir + right*uv.x + up*uv.y;\n}\n#define dmin(a,b) a.x < b.x ? a : b\n#define pmod(p,x) mod(p, x) - x*0.5\n\nvec4 r14c(float i){return texture(iChannel0, vec2(i));}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;    \n    return max(p.x, max(p.y, p.z));\n}\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define tunnRotRate\n\nvec2 id;\nvec2 map(vec3 p){\n\tvec2 d = (vec2(10e7));\n\n    p.xy *= rot(0. + p.z*0.1 + 0.1*iTime);\n    \n    \n    for (float i = 0.; i < 4.; i++){\n    \tp = abs(p);\n    \tp.xy *= rot(0.4*pi );\n        p.x -= 0.2;\n        p.x *= 1. + 0.4*atan(p.x, p.y)/pi;\n        //p.y += 0.1;\n    }    \n\n    p.xy -= 2.0;\n    \n    \n    p.y = abs(p.y);\n    \n    \n    p.y -= 1. + sin(iTime*0.1)*0.2;\n    \n    #define modSz 0.5\n    id = floor(p.xz/modSz);\n    //vec2 \n    \n    p.xy -= 0.8;\n    p.xz = pmod(p.xz, modSz);\n    \n    for (float i = 0.; i < 5.; i++){\n    \tp = abs(p);\n        p.y -= 0.28 - sin(iTime*0.2)*0.08 - 0.1;\n        p.x += 0.04;\n    \tp.xy *= rot(0.6*pi + id.y*6.  + 0.9);\n        if (i == 3.){\n        \tp.xz *= rot(iTime*2. + id.y);\n        }\n    }     \n\n    d = dmin(d, vec2(sdBox(p, vec3(modSz*0.25 + sin(iTime*0.26)*0.1)), 1.)); \n    \n    d.x *= 0.25;\n    return d;\n} \n/*\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001,0);\n    return normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}*/\n    \nvec3 glow = vec3(0);\n\n//#define pal(q,w,e,r,t) (q + w*sin(e*r + t))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0.,0,0);\n    ro.z += iTime*3. + mx;\n    \n    float rate = ro.z*0.1 + 0.1*iTime;\n    \n    ro.xy += vec2(sin(rate), cos(rate))*2.;\n    \n    vec3 lookAt = ro + vec3(0,0,4);\n    float rotRate = iTime*0.3 + sin(iTime*0.3)*0.0;\n    lookAt.xz += vec2(\n    \tsin(rotRate),\n    \tcos(rotRate)\n    );\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 p = ro; float t = 0.;\n    for (int i = 0; i < 250; i++){\n    \tvec2 d = map(p);\n        #define pal(q,w,e,r,t) (q + w*cos( tau*(e*r + t))\n        //glow += exp(-d.x*70.)* pal(vec3(0.5,0.6,0.7)*1., 0.35, id.y*0.2 + iTime*0.4 + 1.*p.z*(sin(iTime)*0.001), vec3(0.4, 0.9,0.2), 0. + p.z*0.02));\n        //glow += exp(-d.x*20.)* pal(vec3(0.5,0.6,0.7)*1., 0.45, id.y*0.2 + iTime*0.4 + 0.*p.z*(sin(iTime)*0.001), vec3(0.4, 0.9,0.2), 0. + p.z*0.02));\n        //zglow += exp(-d.x*20.)* pal(vec3(0.5,0.6,0.7)*0.2, 0.95, id.y*0.05 + iTime*1. + 0.*p.z*(sin(iTime)*0.001), vec3(0.1, 0.9,0.2), 0.5 + p.z*0.02));\n        //glow += exp(-d.x*60.)* pal(0.5, 0.45, id.y*0.2 + iTime*2., vec3(0.1, 0.4,0.8), 0.5)) ;\n        glow += exp(-d.x*60.)* pal(1., 0.95, id.y*0.004 , vec3(0.4, 0.97,0.9), 0.9 + p.z*0.02 + iTime*.1)) ;\n        if(d.x < 0.0005){\n            /*\n            vec3 n = getNormal(p);\n            vec3 l = normalize(vec3(1));\n            vec3 h = normalize(l - rd);\n            float diff = max(dot(n,l),0.);\n            float spec = max(dot(n,h),0.);\n            float fres = pow(1. - max(dot(n,-rd), 0.),5.);\n            */\n            //col += fres*diff*3.;\n            \n        \tbreak;\n        }\n        if (t > 100.){\n        \tbreak;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\t\n    \n    float bass = pow(texture(iChannel1, vec2(0.,0.14)).x, 4.);\n    \n    col += glow*(0.01 + bass*0.);\n    \n    col = mix(col, vec3(0), pow(clamp(t*.02 - 0.1, 0., 1.), 2.));\n    col = smoothstep(0.,1., col);\n    //col = smoothstep(0.,1., col);\n    \n    //col = pow(col , vec3(1.8,1.0,1.));\n    \n    \n    //col.g = pow(col.g, 2. - 0.5*( col.r + col.b*0.1));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 20960, "src": "https://soundcloud.com/twistedmusic/1-brain-in-a-fish-tank?in=twistedmusic/sets/shpongle-1", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlG3RV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 114, 114, 279], [353, 353, 372, 372, 408], [410, 410, 438, 438, 497], [619, 619, 636, 636, 1474]], "test": "untested"}
{"id": "tlG3RK", "name": "Smooth smooth step", "author": "hiogawa", "description": "I was curious how does it look if we make smoothstep simply based on pow(x, p).", "tags": ["2d", "plot"], "likes": 3, "viewed": 381, "published": 3, "date": "1579341120", "time_retrieved": "2024-07-30T21:29:53.278578", "image_code": "// Misc\n#define SCALE_BEND 8.0\n#define SCALE_TIME 0.7\n#define COLOR vec3(0.0, 1.0, 1.0) * 1.0\n\n#define SCALE_UV  (1.0 / 1.2)\n#define OFFSET_UV vec2(((iResolution.x / iResolution.y / SCALE_UV) - 1.0) * 0.5, 0.1)\n\n// AA\n#define LINE_HALF_WIDTH (2.5 / iResolution.y / SCALE_UV)\n#define DISTANCE_RESOLUTION (0.2 / iResolution.y / SCALE_UV)\n#define NUM_ANGLES 8.0\n\n// Background\n#define COLOR_CHECKER1 vec3(1.0) * 0.35\n#define COLOR_CHECKER2 vec3(1.0) * 0.70\n#define SCALE_CHECKER 4.0\n\n\nfloat smoothSmoothStep(float t, float p) {\n  // Odd around (0.5, 0.5) with f(u \\in [0, 0.5]) = (2 t)^p / 2.\n  float u = clamp(t, 0.0, 1.0);\n  float b = float(u >= 0.5);\n  float s = 2.0 * b - 1.0;\n  return b - s * pow((2.0 * (b - s * u)), p) * 0.5;\n}\n\n\nfloat getDistance(vec2 uv, float p) {\n  float result = LINE_HALF_WIDTH;\n  bool init_state = uv.y < smoothSmoothStep(uv.x, p);\n\n  // Search NUM_ANGLES directions\n  for (float t = 0.0; t < NUM_ANGLES; t++) {\n    vec2 dire = vec2(cos(2.0 * 3.1415 * t / NUM_ANGLES), sin(2.0 * 3.1415 * t / NUM_ANGLES));\n\n    // Search up-to DISTANCE_RESOLUTION\n    bool state = init_state;\n    for (float i = 1.0; i < LINE_HALF_WIDTH / DISTANCE_RESOLUTION; i++) {\n      float curr_step = i * DISTANCE_RESOLUTION;\n      vec2 xy = uv + curr_step * dire;\n      bool curr_state = xy.y < smoothSmoothStep(xy.x, p);\n      if (state != curr_state && curr_step < result) {\n        result = curr_step - DISTANCE_RESOLUTION;\n        break;\n      }\n\n      state = curr_state;\n    }\n  }\n\n  return result;\n}\n\n\nvec3 checker(vec2 uv) {\n  float xi = floor(SCALE_CHECKER * uv.x);\n  float yi = floor(SCALE_CHECKER * uv.y);\n  bool even_spot = mod(xi + yi, 2.0) == 0.0;\n  return even_spot ? COLOR_CHECKER1 : COLOR_CHECKER2;\n}\n\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec2 uv = (frag_coord + vec2(0.5, 0.5)) / iResolution.y / SCALE_UV - OFFSET_UV;\n\n  float q = cos(SCALE_TIME * 3.1415 * iTime);\n  float p = pow(SCALE_BEND, q);\n  float d = getDistance(uv, p);\n\n  float fac = smoothstep(LINE_HALF_WIDTH, 0.0, d);\n  frag_color = vec4(mix(checker(uv), COLOR, fac), 1.0);\n}", "image_inputs": [], "common_code": "//\n// History\n//\n\n//\n// AA version 1\n//\n\n/*\n#define LINE_HALF_HEIGHT 4.0\n#define SCALE 6.0\n#define COLOR vec3(0.0, 1.0, 1.0) * 0.95\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec2 uv = (frag_coord + vec2(0.5, 0.5)) / iResolution.y;\n\n  float q = cos(3.1415 * iTime);\n  float p = pow(SCALE, q);\n\n  frag_color = vec4(vec3(0.0), 1.0);\n  if (uv.x <= 1.0) {\n    float fx = smoothSmoothStep(uv.x, p);\n    float d = abs(fx - uv.y);\n\n    float fac = smoothstep((LINE_HALF_HEIGHT / iResolution.y), 0.0, d);\n    frag_color = vec4(fac * COLOR, 1.0);\n  }\n}\n\n*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlG3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[482, 482, 524, 589, 731], [734, 734, 771, 771, 1508], [1511, 1511, 1534, 1534, 1719], [1722, 1722, 1779, 1779, 2082]], "test": "untested"}
{"id": "WtK3D1", "name": "winter~", "author": "WingStone", "description": "winter is coming~", "tags": ["2d", "particle"], "likes": 5, "viewed": 579, "published": 3, "date": "1579338440", "time_retrieved": "2024-07-30T21:29:54.067469", "image_code": "float Pow2(float par)\n{\n    return par*par;\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat wave(float x)\n{\n    return 2.0*Pow2((x+1.0)*0.5)-1.0;\n}\n\nvec3 snow( vec2 uv, float scale, float density)\n{\n    vec3 col = vec3(0,0,0);\n    \n    uv *= scale;\n    uv.y += 0.5*iTime;\n    vec2 id = floor(uv);\n    vec2 xy = fract(uv)*2.0-1.0;\n    for( float i = -3.0; i <= 3.0; i+=1.0 )\n    {\n    \tfor( float j = -3.0; j <= 3.0; j+=1.0 )\n        {\n            vec2 random = hash(id+vec2(i,j));\n\t\t\tvec2 center = random*vec2(0.5*sin(random.x*6.283 + iTime*1.5), 1.0) + vec2(i,j)*2.0 ;\n            \n            float lightness = max(0.0, 0.025/distance(xy, center)*(random.y*1.5+1.5)-0.07);\n            //float lightness = max(0.0, exp2(-24.0*distance(xy, center))*(random.y*1.5+1.5));\n            lightness *= step(random.x, density);\n            \n            col += lightness; \n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    //mountain1\n    vec3 col = vec3(0,0,0);\n    uv.y += 0.5;\n    float hight1 = 0.05*wave( sin((uv.x + iTime*0.02)*3.0));\n    hight1 += 0.08*wave( sin((uv.x + iTime*0.02)*6.0));\n    hight1 += 0.06*wave( sin((uv.x + iTime*0.02)*12.0));\n    col += 1.0-smoothstep(-0.01, 0.01, uv.y - hight1-0.7);\n    \n    //mountain2\n    float hight2 = 0.02*wave( sin((uv.x + iTime*0.04)*2.0));\n    hight2 += 0.06*wave( sin((uv.x + iTime*0.04)*4.0));\n    hight2 += 0.05*wave( sin((uv.x + iTime*0.04)*6.0));\n    col = col*0.8 + 1.0-smoothstep(-0.01, 0.01, uv.y - hight2-0.6);\n    col = clamp(col, 0.0, 1.0);\n    \n    //snow\n    vec3 snowCol = vec3(0,0,0);\n    snowCol += snow(uv, 10.0, 0.0);\n    snowCol += snow(uv, 5.0, 0.7);\n    snowCol += snow(uv, 2.0, 1.0);\n    snowCol = clamp(snowCol, 0.0, 1.0);\n    \n    col = snowCol + col*(1.0 - snowCol);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 45], [47, 47, 108, 108, 246], [248, 248, 269, 269, 309], [311, 311, 360, 360, 1059], [1061, 1061, 1118, 1118, 2020]], "test": "untested"}
{"id": "WlG3zV", "name": "vaultShader1", "author": "hmitchell", "description": "hahahah", "tags": ["aaaa"], "likes": 2, "viewed": 268, "published": 3, "date": "1579309470", "time_retrieved": "2024-07-30T21:29:54.920189", "image_code": "#define TWOPI (3.14159 * 2.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x += sin(iTime*0.5 +  uv.y*10.) * 0.05;\n    uv.y += cos(iTime*0.5 +  uv.x*10.) * 0.05;\n                \n    // Time varying pixel color\n    vec3 col = texture(iChannel1, uv).rgb;\n    \n   // col.b = col.b - iMouse.x *0.001 ;\n   // col.r = col.r - iMouse.x *0.003 ;\n   // col.g = col.g + iMouse.x *0.001 ;\n    \n    col.b = col.b - 395.0 *0.001;\n    col.r = col.r - 295.0 *0.003;\n    col.g = col.g + 400.0 *0.001;\n  \n        //* (iMouse.x * 0.000001) ;\n    col = sin(col + length(col)*10.0 + iMouse.y * 0.001) * 0.6 + 0.6;\n\n    col = col - 0.70;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlG3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 87, 137, 794]], "test": "untested"}
{"id": "WlGGRV", "name": "Starry Landscape", "author": "Klems", "description": "Black and white stuff.", "tags": ["3d", "noise", "raymarch"], "likes": 41, "viewed": 959, "published": 3, "date": "1579304570", "time_retrieved": "2024-07-30T21:29:55.670184", "image_code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://research.nvidia.com/sites/default/files/pubs/2017-02_Hashed-Alpha-Testing/Wyman2017Hashed.pdf\nconst float hashScale = 1.0;\nfloat hashedNoise(vec3 p, vec3 dpdx, vec3 dpdy) {\n    float maxDeriv = max(length(dpdx), length(dpdy));\n    float pixScale = 1.0 / (hashScale*maxDeriv);\n    vec2 pixScales = vec2(exp2(floor(log2(pixScale))), exp2(ceil(log2(pixScale))));\n    float aa = textureGrad(iChannel0, pixScales.x*p.xyz/32.0, pixScales.x*dpdx/32.0, pixScales.x*dpdy/32.0).r;\n    float bb = textureGrad(iChannel0, pixScales.y*p.xyz/32.0, pixScales.y*dpdx/32.0, pixScales.y*dpdy/32.0).r;\n   \tvec2 alpha = vec2(aa, bb);\n    //alpha = vec2(hash33(floor(pixScales.x*p.xyz)).r, hash33(floor(pixScales.y*p.xyz)).r);\n    float lerpFactor = fract( log2(pixScale) );\n    float x = (1.0-lerpFactor)*alpha.x + lerpFactor*alpha.y;\n    float a = min( lerpFactor, 1.0-lerpFactor );\n    vec3 cases = vec3( x*x/(2.0*a*(1.0-a)),(x-0.5*a)/(1.0-a),1.0-((1.0-x)*(1.0-x)/(2.0*a*(1.0-a))) );\n    float alphaRes = (x < (1.0-a)) ? ((x < a) ? cases.x : cases.y) :cases.z;\n    alphaRes = clamp(alphaRes, 1.0e-6, 1.0);\n    return alphaRes;\n}\n\n// https://iquilezles.org/articles/filteringrm\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, \n                out vec3 dpdx, out vec3 dpdy ) {\n    dpdx = t*(rdx*dot(rd,nor)/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)/dot(rdy,nor) - rd);\n}\n\n// noise with smooth derivative\nfloat snoise( in vec3 x, const in float lod ) {\n    float dim = 32.0 / exp2(lod);\n    x = x * dim;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    x = (p+f+0.5) / dim;\n    return textureLod(iChannel0, x, lod).r;\n}\n\n// smoother noise\nfloat noise( in vec2 x ) {\n    x *= 32.0;\n    const vec2 e = vec2(1, 0);\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix( hash12(i+e.yy), hash12(i+e.xy),f.x),\n               mix( hash12(i+e.yx), hash12(i+e.xx),f.x),f.y);\n}\n\n// cascading return to optimize distance function\nfloat height(vec2 p, float y) {\n    p /= 32.0;\n    float hei = noise(p*0.04);\n    hei *= hei*30.0;\n    if (y > hei+3.0) return hei;\n    hei += snoise(vec3(p*0.5, 0), 0.0)*1.0;\n    if (y > hei+2.0) return hei;\n    hei += snoise(vec3(p*1.0, 10), 10.0)*0.2;\n    if (y > hei+1.0) return hei;\n    hei += snoise(vec3(p*2.0, 100), 20.0)*0.1;\n    return hei;\n}\n\nfloat de(vec3 p) {\n    return p.y - height(p.xz, p.y);\n}\n\nvec3 getNormal(vec3 p) {\n\tvec3 e = vec3(0.0, 0.3, 0.0);\n\treturn normalize(vec3(\n\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\tde(p+e.xxy)-de(p-e.xxy)));\t\n}\n\nbool intSphere( in vec4 sp, in vec3 ro, in vec3 rd, out float t ) {\n    vec3  d = ro - sp.xyz;\n    float b = dot(rd,d);\n    float c = dot(d,d) - sp.w*sp.w;\n    float tt = b*b-c;\n    if ( tt > 0.0 ) {\n        t = -b-sqrt(tt);\n        return true;\n    }\n    return false;\n}\n\nfloat star( in vec3 dir ) {\n    dir.yz *= rot(-0.7);\n    float base = step(abs(dir.z), 0.007);\n    dir.xy *= rot(iTime*0.5);\n    float trail = (atan(dir.x, dir.y)+PI)/(2.0*PI);\n    trail = pow(trail+0.05, 20.0);\n    return base*trail;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    uv += uv*dot(uv,uv)*0.5;\n    \n\tvec3 from = vec3(0, 2, -5);\n\tvec3 dir = normalize(vec3(uv, 0.4));\n    \n\tvec2 mouse=(iMouse.xy - iResolution.xy*0.5) / iResolution.y * 2.5;\n    if (iMouse.z < 0.5) mouse = vec2(0);\n\tmat2 rotxz = rot(-mouse.x+sin(iTime*0.1512)*0.75-PI*0.5);\n\tmat2 rotxy = rot(mouse.y+sin(iTime*0.12412)*0.25);\n\tdir.zy *= rotxy;\n\tdir.xz *= rotxz;\n\n    from.x += iTime*10.0;\n    from.y += height(from.xz, 9e9);\n    \n\tfloat totdist = 0.0;\n    for (int steps = min(iFrame, 0) ; steps < 150 ; steps++) {\n\t\tvec3 p = from + totdist * dir;\n        float dist = de(p);\n\t\ttotdist += dist*0.5;\n        if (dist < 0.001 || totdist > 400.0) {\n        \tbreak;   \n        }\n\t}\n    \n    const vec3 light = normalize(vec3(3, 1, 2));\n    float noi = hashedNoise(dir, dFdx(dir), dFdy(dir));\n    float lig = 0.0;\n    vec3 test = vec3(0);\n    if (totdist > 400.0) {\n        \n        // add stars\n        lig = pow(texture(iChannel0, dir*0.7).r, 40.0)*10.0;\n        \n        // add a shooting star\n        lig += star(dir);\n        \n        // add a planet\n        vec3 fromPl = vec3(8, 5, -1);\n        float toSphere = 0.0;\n        bool sphere = intSphere( vec4(0, 0, 0, 1), fromPl, dir, toSphere);\n        if (sphere) {\n            vec3 normal = fromPl + dir*toSphere;\n            lig = max(0.0, dot(normal, light))*30.0;\n        }\n        \n    } else {\n    \n        vec3 p = from + totdist * dir;\n        vec3 n = getNormal(p);\n        vec3 dpdx = vec3(0);\n        vec3 dpdy = vec3(0);\n        calcDpDxy(from, dir, dir+dFdx(dir), dir+dFdy(dir), totdist, n, dpdx, dpdy);\n\n        noi = hashedNoise(p, dpdx, dpdy);\n\t\t\n        // diffuse\n        lig = max(0.0, dot(n, light));\n        lig *= lig*2.0;\n        \n        // some fresnel\n        float fres = pow(max(0.0, 1.0-dot(n, -dir)), 10.0);\n        lig += fres*2.0;\n    }\n    \n    // vignette, gamma correction\n    lig = pow(lig*0.5, 1.0/2.2);\n    vec2 uu = (fragCoord.xy-iResolution.xy*0.5)/iResolution.xy;\n    lig = mix(lig, 0.0, dot(uu,uu)*1.3);\n    \n    fragColor = vec4(step(noi, lig));\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGGRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 100, 100, 224], [226, 226, 248, 248, 364], [500, 500, 549, 549, 1486], [1488, 1535, 1675, 1675, 1777], [2053, 2071, 2097, 2097, 2335], [2337, 2387, 2418, 2418, 2739], [2741, 2741, 2759, 2759, 2797], [2799, 2799, 2823, 2823, 2964], [2966, 2966, 3033, 3033, 3237], [3239, 3239, 3266, 3266, 3475], [3477, 3477, 3534, 3534, 5646]], "test": "untested"}
{"id": "3tG3RK", "name": "Day 29 - Dwarf Train", "author": "jeyko", "description": "Code is messy,  might clean it up later.\n\nWent for a tech-y vibe with this one, ended up kind-of Shane-ish.\n\n\n", "tags": ["mdtmjvm"], "likes": 15, "viewed": 575, "published": 3, "date": "1579298405", "time_retrieved": "2024-07-30T21:29:56.536866", "image_code": "#define mx (200.*iMouse.x/iResolution.x)\n#define dmin(a, b) a.x < b.x ? a : b\n#define dmax(a, b) a.x > b.x ? a : b \n#define pmod(p, x) mod(p, x) - x*0.5\n\nfloat r11c(float x){return texture(iChannel0, vec2(x, x*12.5)).x;}\n\nvec2 offsetTunnel(float z){\n    vec2 t = vec2(\n        sin(z*0.1)*2.,\n        cos(z*0.1)*2.\n    );\n    t.y -= 0.;\n\treturn t;\n}\n\n#define szTunnel 1.\n\n#define szLamp 0.08\n#define lenLamp 0.24\nvec2 sdLamp(vec3 p){\n\tvec2 d = vec2(sdCapsule( p, vec3(0,0,lenLamp), vec3(0.0), szLamp ), 2.); \n    \n    return d;\n} \n\n#define modDist 10.\n\nvec3 centerPipes = vec3(0);\nvec3 centerTunnel = vec3(0);\n\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n\n    p.xy -= offsetTunnel(p.z);\n    \n    // --- TUNN --- //\n    \n    centerTunnel = p;\n    d = dmin(d, vec2(-(length(p.xy) - szTunnel), 0.));\n    \n    \n    \n    vec3 q = p;\n    q.x = abs(q.x);\n    q.y = abs(q.y);\n    //p.y -= szTunnel;\n    \n    q.xy -= vec2(cos(0.5),sin(0.5))*szTunnel;\n    \n    \n    \n    \n    // --- PIPES --- //\n    \n    centerPipes = q;\n    d = dmin(d, vec2((length(q.xy) - 0.1), 1.));\n    \n    q.z = pmod(q.z,1.);\n    d = dmin(d, vec2(max((length(q.xy) - 0.12), -abs(q.z) + 0.3 ), 1.));\n\t\n    \n    // --- LAMP --- //\n    float id = floor(p.z/modDist);\n    p.z = pmod(p.z, modDist);\n    q = p;\n    q.y -= szTunnel*1.;\n    q.z += lenLamp*1.;\n    //q.z -= 1.;\n    //d = dmin(d, sdLamp(q));\n    d = dmin(d, vec2(sdCapsule( q, vec3(0,0,lenLamp), vec3(0.0), szLamp ), 2.));\n    //q.y += 0.9;\n    q.z -= szLamp*3.;\n    \n    float z = q.z;\n    \n    q.z = pmod(q.z, 0.14); \n    \n    q.y -= smoothstep(0., 0.8, pow(length(z*0.29)*4.5, 3.)); // function drawing\n    q.yz *= rot(0.5*pi);\n\n    // lamp thingie\n    d = dmin(d, vec2(0.61*sdTorus(q, vec2(0.10,0.015)), 4.));\n    // --- FLOOR --- //\n    float offsFloor = szTunnel*0.76;\n    p.y += offsFloor;\n    d = dmin(d, vec2(p.y , 0.));\n    \n    // --- TRAIN --- //\n    float offsTrain = szTunnel*0.25;\n    q = p;\n    p.x = abs(p.x);\n    p.x -= offsTrain*1.3;\n    \n    p.y -= 0.1;\n    vec3 i = abs(p);\n    i -= 0.01;\n    float sm = length(max(i.y,0.0)) + min(max(i.x,max(i.y,i.z)),0.1) - 0.1;\n    //d = dmin(d, vec2(sm, 5.));\n    d = dmin(d, vec2(max(abs(p.y) - 0.04, abs(p.x) - 0.04), 5.));\n    \n    q.z = pmod(q.z, 0.5);\n    q.y += 0.05;\n\td = dmin(d, vec2(max(abs(q.y) - 0.1, max(abs(q.z) - 0.1, abs(q.x) - 0.54)) , 4.));\n    \n    \n    d.x *= 0.9;\n\treturn d;\n}\nvec3 pLamp;\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n    technique = 1;\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<212; i++ )\n    {\n        vec2 d = map( ro + rd*t );\n        \n        //d.x -= texture(iChannel3, vec2(float(i))).x*0.002;\n\t\tfloat h = d.x;\n\t\t//h *=  0.7*exp(-h*2.);\n        //h *= 1. - exp(-h*0.01)*0.6;\n        //h *= 0.3 + exp(-length((ro.y + rd.y*t) - abs(pLamp.y))*20.)*0.7; // TODO: fix this so it's faster\n        \n        \n        if (d.y == 2. ) {\n            h += 0.3;\n        }\n        \n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n            float y = h*h/(2.0*ph);\n            float di = sqrt(h*h-y*y);\n            res = min( res, 10.*di/max(0.,t-y) );\n            ph = h;\n        \n\n        }\n        \n        t += h;\n        \n        if( res<0.005 || t>tmax ) break;\n          \n    }\n    //res *= 5.4;\n    return clamp( res, .0, 1.0 );\n}\n\n\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0005, 0.);\n    return normalize(\n    \tmap(p).x - vec3(\n        \tmap(p - t.xyy).x,\n        \tmap(p - t.yxy).x,\n        \tmap(p - t.yyx).x\n        )\n    );\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n\treturn dir + right*uv.x + up*uv.y;\n}\n\nvec3 colLight = vec3(0.6,0.34,0.22)*2.2;\n\nvec3 glow = vec3(0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,0,-0.);\n    ro.z += iTime*5. + mx;\n    ro.xy += offsetTunnel(ro.z);\n    \n    vec3 lookAt = ro + vec3(0,0,9);\n    lookAt.xy += offsetTunnel(lookAt.z);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    vec3 p = ro; float t = 0.;vec2 d; vec3 l = vec3(0); bool didHit = false; float att = 0.;\n    for(int i = 0; i < 270; i++){\n    \td = map(p);\n        if (d.y == 2.  ){\n        \tglow += exp(-d.x*4.);\n        }\n        \n        if(d.x < 0.001){\n            didHit = true;\n            float id = floor(p.z/modDist);\n            pLamp = vec3(0,szTunnel*1.,id*modDist + modDist*0.5 );\n            pLamp.xy += offsetTunnel(pLamp.z);\n            //pLamp.y += 0.001;\n            att = 1.5/(length(p-pLamp),length(p-pLamp));\n            \n           \n\t\t\tvec3 n = getNormal(p);\n            l = normalize(pLamp - p);\n\t\t\tvec3 h = normalize(l - rd);\n            float diff = max(dot(n,l),0.);\n            float fres = pow(1. - max(dot(n,-rd),0.), 5.);\n            float spec = max(dot(n,h),0.);\n        \t//spec = pow(spec,4.);\n            float q = atan(p.y, p.x); // polar coords\n                \n            //q /= tau;\n            q *= 1.;\n            \n            if (d.y == 0. || d.y == 1.){\n                vec3 tex;\n                if (d.y == 0.){\n                \ttex = tex3D(iChannel1, p*0.7,n).xyz;\n                } else {\n                    p.xy *= rot(p.z*0.2);\n                \ttex = tex3D(iChannel2, p*5.,n).xyz;\n                    tex = pow(tex, vec3(0.7));\n                    tex.gb *= 1.2;\n                    tex *= 0.1;\n                }\n                n.z += pow(tex.x*1.6, 4.)*0.2;\n                diff = max(dot(n,l),0.);\n                fres = pow(1. - max(dot(n,-rd),0.), 2.);\n                spec = max(dot(n,h),0.);\n                spec = pow(spec, 2.);\n                col += mix(tex*diff*colLight*fres,tex*fres*spec*colLight,0.8 - length(tex.rg)*0.8) * (att);\n                \n            } else if (d.y == 2. || d.y == 3.){\n            \t//col += fres*diff;\n                //col += diff;\n            \t//col += mix(diff,fres*spec,0.9) * (att);\n                col = colLight*pow(1. , 2.)*att;\n            } else if (d.y == 4.){\n                vec3 tex = tex3D(iChannel1, p*0.7,n).xyz;\n                \n                tex.x *= 1.;\n                tex.y *= 0.54;\n                tex.z *= 0.4;\n                tex.x = tex.y;\n            \t\n            \tcol += mix(tex*diff*colLight,tex*fres*spec*colLight,0.1 + min(tex.r*1., 1.)) * (att);\n            } else if (d.y == 5.){\n                //vec3 tex = texture(ichanne, -n).xyz;\n                vec3 tex = tex3D(iChannel1, p*0.7,n).xyz;\n                \n                tex.x *= 1.;\n                tex.y *= 1.;\n                tex.z *= 1.;\n                tex.x = tex.y;\n                tex.y = tex.x;\n            \t\n                col += mix(tex*diff*colLight,tex*fres*pow(spec, 1.5)*colLight,0.9) *att;\n            \t//col += * (att);\n            \n            }\n            \n            \n        \tbreak;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    float shad = calcSoftshadow(p, l, 0.01, 100., 0 );\n    col *= shad*att;\n\t\n    \n    col *= 4.;\n    //col *= 3.;\n    \n    col += glow*0.004*colLight;\n    //col -= glow*0.5*colLight*(1. - att);\n    \n    col = pow(col, vec3(0.45));\n    col *= 1.5;\n    //col = smoothstep(0.,0.6,col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define c0 iChannel0 \n#define c1 iChannel1 \n#define c2 iChannel2 \n#define c3 iChannel3 \n\n#define T(c, uv) texture(c, uv)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n// thx to iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tG3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 174, 174, 220], [222, 222, 249, 249, 348], [412, 412, 432, 432, 528], [611, 611, 628, 628, 2372], [2386, 2386, 2479, 2479, 3696], [3700, 3700, 3723, 3723, 3894], [3896, 3896, 3938, 3938, 4103], [4168, 4168, 4225, 4225, 7693]], "test": "untested"}
{"id": "WtKGDw", "name": "DataSphere", "author": "shau", "description": "Another techy scene ", "tags": ["3d"], "likes": 12, "viewed": 379, "published": 3, "date": "1579297718", "time_retrieved": "2024-07-30T21:29:57.293842", "image_code": "// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define EPS 0.005\n#define FAR 50.0\n#define ZERO (min(iFrame,0))\n#define T iTime\n#define PI 3.141592\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define S(a, b, v) smoothstep(a, b, v)\n\n//Dave Hoskins - improved hash without sin\n//https://www.shadertoy.com/view/XdGfRR\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nfloat hash12(vec2 p) \n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n//noise IQ - Shane\nfloat n3D(vec3 p) \n{    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//Nimitz\nfloat tri(float x) {return abs(x - floor(x) - 0.5);}\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n//SDF functions - IQ\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) \n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n/*\nvec3 opRepLim(vec3 p, float c, vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n*/\n\n//IQ - Intesectors, sphere and box functions\n//https://iquilezles.org/www/index.htm\nvec2 sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0); //missed\n    h = sqrt(h);\n    float tN = -b - h;\n    float tF = -b + h;\n    return vec2(tN, tF);\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\nvec3 sphNormal(vec3 pos, vec4 sph) \n{\n    return normalize(pos - sph.xyz);\n}\n\nvec2 boxes(vec3 p)\n{\n    p.z += T;\n    vec3 q = p;    \n    q.y = abs(q.y);\n    q.xz = fract(p.xz*0.125)*8.0 - 4.0;\n    return vec2(sdBox(q - vec3(0.0, 8.0, 0.0), vec3(3., 0.3, 3.0)), \n                hash12(floor(p.xz*0.125)));\n}\n\nvec4 map(vec3 p)\n{\n    vec2 b = boxes(p);\n    \n    /*\n    vec3 q = p;\n    q += vec3(-8.0, -0.0, 3.0);\n    float l = sin(p.x*3.0)*3.0 * min(1.0, p.x*0.08) * max(0.0, (1.0 - p.x*0.08));\n    q.xy *= rot(sin(p.x*2.0+T*1.2)*0.16);\n    q.xz *= rot(sin(p.x*2.0+T*2.8)*0.2);\n    q = opRepLim(q, 0.25, vec3(30.0, 0.0, 0.0));\n    q.yz *= rot(floor(p.x*4.0)*0.1+T*0.9);\n    float cs = sdCapsule(q, vec3(0.0, -1.0*l, 0.0), vec3(0.0, 1.0*l, 0.0), 0.02);\n    cs = max(cs, -sdSphere(p, 3.0));\n    //*/\n    \n    //capsule stream\n    //right\n    vec3 q = p;\n    q += vec3(0.0, -2.0, 2.0);\n    float l = sin(p.x*2.0)*3.0 * min(1.0, p.x*0.08) * max(0.0, (1.0 - p.x*0.08));  \n    q.xy *= rot(sin(p.x+T*1.2)*0.1);\n    q.xz *= rot(sin(p.x+T*0.8)*0.1);\n    q.x = fract(p.x*4.0)*0.25 - 0.125;\n    q.yz *= rot(floor(p.x*4.0)*0.1+T*0.9);\n    float cs = sdCapsule(q, vec3(0.0, -1.0*l, 0.0), vec3(0.0, 1.0*l, 0.0), 0.01);\n    cs = p.x>0.0 && p.x<20.6 ? cs : FAR;\n    //noise line\n    //left\n    q = p;\n    q.y += sin(q.x*2.0+T*6.)*0.2 + sin((q.x - 4.2)*3.2+T*13.3)*0.1;\n    q.z += sin((q.x - 1.3)*1.7+T*5.)*0.2 + sin((q.x - 5.9)*3.2+T*7.1)*0.14;\n\tq.yz += tri(q.x*0.31 + T*3.6)*0.2;\n\tq.xz += tri(q.x*0.7 + T*1.6)*0.8;\n    cs = min(cs, sdCapsule(q, vec3(-20.0, -7.0 + sin(T*0.4)*2.0, -4.0 + sin((T-3.1)*0.14)), vec3(0.0, -2.0, 0.0), 0.01));\n    //cutout\n    cs = max(cs, -sdSphere(p, 3.0));\n\n    return vec4(min(cs, b.x), cs, b.x, b.y);\n}\n\n// particles (Andrew Baldwin)\n// stolen from Galvanize by Virgill \nfloat snow(vec3 direction) {\n\tfloat help = 0.0;\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec2 uvx = vec2(direction.x,direction.z)+vec2(1.,iResolution.y/iResolution.x)*gl_FragCoord.xy / iResolution.xy;\n\tfloat acc = 0.0;\n\tfloat DEPTH = direction.y*direction.y-0.3;\n\tfloat WIDTH =0.1;\n\tfloat SPEED = 0.1;\n\tfor (int i=0;i<10;i++) {\n\t\tfloat fi = float(i);\n\t\tvec2 q = uvx*(1.+fi*DEPTH);\n\t\tq += vec2(q.y*(WIDTH*mod(fi*7.238917,1.)-WIDTH*.5),SPEED*iTime/(1.+fi*DEPTH*.03));\n\t\tvec3 n = vec3(floor(q),31.189+fi);\n\t\tvec3 m = floor(n)*.00001 + fract(n);\n\t\tvec3 mp = (31415.9+m)/fract(p*m);\n\t\tvec3 r = fract(mp);\n\t\tvec2 s = abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\tfloat d = .7*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n\t\tfloat edge = .04;\n\t\tacc += smoothstep(edge,-edge,d)*(r.x/1.0);\n\t\thelp = acc;\n\t}\n\treturn help;\n}\n\n/*\nvec3 overlay(vec2 uv)\n{\n    vec2 ruv = uv*rot(sin(T*0.03));\n    ruv.x += (sin(ruv.y*4.0 + T*0.3) * 0.08);\n    vec2 c = fract(ruv*vec2(20.0, 12.0)) - 0.5;\n    float cH = hash12(floor(ruv*vec2(20.0, 12.0)));\n    \n    vec3 col = palette(cH*10000.) * S(0.16+cH*0.1, 0.1+cH*0.1, length(c)); //dots\n    //vignette\n    col *= S(0.0, 0.1, uv.x) * S(1.0, 0.9, uv.x) * \n           S(0.0, 0.1, uv.y) * S(1.0, 0.9, uv.y);\n    return col;\n}\n*/\n\n//background\nvec3 background(vec3 rd, vec3 colA, vec3 colB)\n{\n    //radial lines\n    float a = (atan(rd.x, rd.y)/6.2831853) + 0.5, //0->1\n          l = floor(a * 24.0) / 24.0; //partition cells    \n    vec3 pc = colB * 2.0 *\n              S(0.46, 0.5, fract(a*24.0)) * S(0.54, 0.5, fract(a*24.0));\n    //horizontal lines\n    float dY = pow(abs(rd.y), 0.8), //problem with power - thanks iapafotoo\n          cY = fract(dY*6.0-T*0.4),\n          cYID = floor(dY*6.0-T*0.4),\n          cYH = hash11(cYID) - 0.6,    \n          tt = mod(T*cYH*4.0*sign(rd.y), 3.0) - 1.5,\n          dX = length(tt - rd.x);\n    pc += colB * 1.6 * S(0.02, 0.0, length(cY - 0.5)); //lines\n    //noise\n    pc *= (2.0 +n3D(rd*3.6+T)) * n3D(rd*5.0+T*0.3);\n    //sparks\n    pc += (cYH*sign(-rd.y)>0.0 ? step(tt, rd.x) : step(rd.x, tt)) * //clip\n          colA * 6.0 * S(0.05, 0.0, length(cY - 0.5)) / //line \n          (1.0 + dX*dX*60.); //attenuation \n    //fade\n    pc *= max(abs(rd.y*0.4), 0.);\n    //center glow\n    pc += colB / ((1.0 + abs(rd.x)*abs(rd.x)*8.0) * (1.0 + dY*dY*100.0));\n\n    return pc;\n}\n\nvec4 renderScene(vec3 ro, vec3 rd, vec3 lp, vec3 colA, vec3 colB)\n{\n    float t = 0.0;\n    vec3 pc = background(rd, colA, colB); \n    \n    for (int i=ZERO; i<80; i++)\n    {\n        vec3 p = ro + rd*t;\n        vec4 ns = map(p);\n        //if (abs(ns.x)<EPS && ns.x==ns.y) break;\n        pc += 0.3 * colA / (1.0 + ns.y*ns.y*200.0);\n        float atn = 1.0 / (1.0 + length(p-ro)*length(p*ro)*0.0001);\n        pc += step(ns.z, EPS) * step(ns.w, 0.4) * //clip \n              0.008 * colB / (1.0 + ns.z*ns.z*30.0) * atn;\n        t += max(EPS*2.0, ns.x * 0.6);\n        if (t>FAR) break;\n    }    \n        \n    return vec4(pc, t);\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, in vec2 U)\n{\n    vec3 col = vec3(0),\n         la = vec3(0),\n         colA = rotHue(vec3(1,0,0), T*0.1),\n         colB = rotHue(vec3(1,0,0), (T-3.0)*0.1),\n         ro = vec3(0.0, sin(T*0.1)*2.0, -11.0 - sin(T*0.2)*2.0);\n    \n    ro.xz *= rot(sin((T+5.0)*0.3)*0.3);\n    vec3 rd = camera(U, ro, la, 1.4);\n    vec3 lp = vec3(3.0, 4.0, -2.0);\n    \n\tvec4 scene = renderScene(ro, rd, lp, colA, colB);\n    col = scene.xyz;\n    \n    vec4 sph = vec4(0.0, 0.0, 0.0, 3.0);\n    vec2 si = sphIntersect(ro, rd, sph);\n    float sd = sphDensity(ro,rd, sph, FAR);\n    if (si.x>0.0)\n    {\n        \n        col *= scene.y==2.0 ? 0.0 : 0.4;\n        vec3 pN = ro + rd*si.x;\n        vec3 pF = ro + rd*si.y;\n        \n        vec3 nN = sphNormal(pN, sph);\n        vec3 nF = sphNormal(pF, sph) * -1.0;\n        \n        vec3 ldN = normalize(lp - pN);\n        vec3 ldF = normalize(lp - pF);\n        \n        float specN = pow(max(dot(reflect(-ldN, nN), -rd), 0.0), 16.0);\n        float specF = pow(max(dot(reflect(-ldF, nF), -rd), 0.0), 16.0);\n        float fres = pow(clamp(dot(nN, rd) + 1.0, 0.0, 1.0), 2.0);\n\n        col += colA * pow(sd, 4.0) * max(0.0, (sin(T*4.0)+0.5) * 0.6);\n        \n        col += vec3(1) * specN;  \n        col += vec3(1) * specF*0.2;  \n        \n        //reflection\n        vec3 rro = pN;\n        vec3 rrd = reflect(rd, nN);\n        vec4 rScene = renderScene(rro, rrd, lp, colA, colB);\n        col += rScene.xyz * fres;\n    }\n    \n    col += colA*2.0*snow(normalize(vec3(0.0, 0.0, -1.0)));\n    \n    C = vec4(col, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGDw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[493, 576, 597, 597, 678], [680, 680, 703, 703, 792], [794, 794, 817, 817, 903], [905, 924, 944, 944, 1249], [1251, 1260, 1280, 1280, 1312], [1313, 1342, 1361, 1361, 1407], [1409, 1566, 1596, 1596, 1965], [1967, 2036, 2066, 2066, 2161], [2163, 2163, 2214, 2214, 2341], [2343, 2343, 2376, 2376, 2404], [2495, 2579, 2626, 2626, 2884], [2886, 2886, 2947, 2947, 3463], [3465, 3465, 3502, 3502, 3541], [3543, 3543, 3563, 3563, 3772], [3774, 3774, 3792, 3792, 5182], [5184, 5251, 5279, 5279, 6102], [6539, 6552, 6600, 6619, 7614], [7616, 7616, 7683, 7683, 8239], [8241, 8241, 8291, 8291, 8476], [8478, 8478, 8517, 8517, 10025]], "test": "untested"}
{"id": "WlG3zK", "name": "Hashed Alpha Test", "author": "Klems", "description": "When you need stable world space noise. Paper link in the comments.", "tags": ["noise"], "likes": 15, "viewed": 728, "published": 3, "date": "1579293967", "time_retrieved": "2024-07-30T21:29:58.246296", "image_code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n\n// uncomment to use procedural noise\n//#define PROCEDURAL\n// uncomment to use screen-space derivatives\n//#define SCREENSPACE\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// anti-aliased and mipmapped nearest neighbor sampling\nvec4 myTexture(vec3 uv, vec3 dpdx, vec3 dpdy) {\n    vec3 res = vec3(32);\n    uv = uv*res + 0.5;\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    vec3 aa = (abs(dpdx)+abs(dpdy))*res*0.5;\n    fr = smoothstep( vec3(0.5)-aa, vec3(0.5)+aa, fr);\n    uv = (fl+fr-0.5) / res;\n    return textureGrad(iChannel0, uv, dpdx, dpdy);\n}\n\n// https://research.nvidia.com/sites/default/files/pubs/2017-02_Hashed-Alpha-Testing/Wyman2017Hashed.pdf\nconst float hashScale = 1.0;\nfloat hashedNoise(vec3 p, vec3 dpdx, vec3 dpdy) {\n    float maxDeriv = max(length(dpdx), length(dpdy));\n    float pixScale = 1.0 / (hashScale*maxDeriv);\n    vec2 pixScales = exp2(floor(log2(pixScale))) * vec2(1,2);\n    \n    #ifdef PROCEDURAL\n    vec2 alpha = vec2(hash33(floor(pixScales.x*p.xyz)).r, hash33(floor(pixScales.y*p.xyz)).r);\n    #else\n    float aa = myTexture(pixScales.x*p.xyz/32.0, pixScales.x*dpdx/32.0, pixScales.x*dpdy/32.0).r;\n    float bb = myTexture(pixScales.y*p.xyz/32.0, pixScales.y*dpdx/32.0, pixScales.y*dpdy/32.0).r;\n    vec2 alpha = vec2(aa, bb);\n    #endif\n    \n    float lerpFactor = fract( log2(pixScale) );\n    float x = mix( alpha.x, alpha.y, lerpFactor );\n    float a = min( lerpFactor, 1.0-lerpFactor );\n    vec3 cases = vec3( x*x/(2.0*a*(1.0-a)),(x-0.5*a)/(1.0-a),1.0-((1.0-x)*(1.0-x)/(2.0*a*(1.0-a))) );\n    float alphaRes = (x < (1.0-a)) ? ((x < a) ? cases.x : cases.y) :cases.z;\n    alphaRes = clamp(alphaRes, 0.0, 1.0);\n    return alphaRes;\n}\n\n// https://iquilezles.org/articles/filteringrm\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, \n                out vec3 dpdx, out vec3 dpdy ) {\n    dpdx = t*(rdx*dot(rd,nor)/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)/dot(rdy,nor) - rd);\n}\n\nfloat noise( in vec3 x ) {\n    return textureLod(iChannel0, x/32.0, 0.0).r;\n}\n\nfloat height(vec2 p) {\n   \treturn (\n        noise(vec3(p, 0))*4.0 +\n        noise(vec3(p*4.124, 10))*0.5 +\n        noise(vec3(p*8.124, 100))*0.25)*0.3;\n}\n\nfloat de(vec3 p) {\n    vec2 inPill = mod(p.xz, 3.0)-1.5;\n    float pill = length(inPill)-0.1;\n    return min(pill, p.y - height(p.xz));\n}\n\nvec3 getNormal(vec3 p) {\n\tvec3 e = vec3(0.0, 0.03, 0.0);\n\treturn normalize(vec3(\n\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\tde(p+e.xxy)-de(p-e.xxy)));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\t\n\tvec3 from = vec3(0, 1, -5);\n\tvec3 dir = normalize(vec3(uv*0.4, 1.0));\n    \n\tvec2 mouse=(iMouse.xy - iResolution.xy*0.5) / iResolution.y * 2.5;\n    if (iMouse.z < 0.5) mouse = vec2(0, -0.4);\n\tmat2 rotxz = rot(-mouse.x+iTime*0.2);\n\tmat2 rotxy = rot(mouse.y);\n\tdir.zy  *= rotxy;\n\tdir.xz  *= rotxz;\n    from.zy *= rotxy;\n\tfrom.xz *= rotxz;\n\n\tfloat totdist = 0.0;\n\tfor (int steps = min(iFrame, 0) ; steps < 200 ; steps++) {\n\t\tvec3 p = from + totdist * dir;\n        float dist = de(p);\n\t\ttotdist += dist*0.5;\n        if (totdist < 0.0001 || totdist > 20.0) {\n        \tbreak;   \n        }\n\t}\n    \n    vec3 p = from + totdist * dir;\n    vec3 n = getNormal(p);\n    n += (hash33(vec3(fragCoord, iFrame))-0.5)*0.1;\n    n = normalize(n);\n    vec3 dpdx = vec3(0);\n    vec3 dpdy = vec3(0);\n    #ifndef SCREENSPACE\n    calcDpDxy(from, dir, dir+dFdx(dir), dir+dFdy(dir), totdist, n, dpdx, dpdy);\n    #else\n    dpdx = dFdx(p);\n    dpdy = dFdy(p);\n    #endif\n    \n    \n    \n    fragColor = vec4(hashedNoise(p, dpdx, dpdy));\n    return;\n\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlG3zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 226, 226, 350], [352, 408, 455, 455, 733], [869, 869, 918, 918, 1850], [1852, 1899, 2039, 2039, 2141], [2143, 2143, 2169, 2169, 2220], [2222, 2222, 2244, 2244, 2375], [2377, 2377, 2395, 2395, 2514], [2516, 2516, 2540, 2540, 2682], [2684, 2684, 2741, 2741, 3836]], "test": "untested"}
{"id": "WlGGRK", "name": "Triangle tile animation", "author": "hiogawa", "description": "Somehow I found this kind of transition intriguing.\nProbably very common anywhere but inspired from BBC Radio 1's intro as in this https://www.youtube.com/watch?v=KTaokISuOGQ.", "tags": ["2d", "triangle"], "likes": 9, "viewed": 567, "published": 3, "date": "1579284762", "time_retrieved": "2024-07-30T21:29:59.015241", "image_code": "// TODO:\n// - [x] interpolation curve\n// - [x] different direction\n// - [x] aniti aliasing\n// - [x] different color\n// - [x] fit vertical size\n// - [ ] offset by mouse position\n// - [ ] use random color\n\n#define AA 4.0\n#define NUM_ROWS 4.0\n#define SCALE NUM_ROWS * (sqrt(3.0) / 2.0)\n#define COLOR1 vec3(1.0) * 0.15\n#define COLOR2 vec3(0.0, 1.0, 1.0) * 0.95\n#define COLOR3 vec3(1.0, 0.0, 1.0) * 0.95\n#define COLOR4 vec3(1.0, 1.0, 0.0) * 0.95\n\nfloat someStep(float t) {\n    // Doubles step so it's more \"sticky\".\n    return smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, t));\n}\n\nfloat smoothMod(float s, float m) {\n  return someStep(mod(s, m) / m) * m;\n}\n\nvec2 invSimplexFrame(vec2 xy, float state) {\n  mat3 transf;\n  if (state == 0.0) {\n    transf = mat3(\n              1.0,             0.0, 0.0,\n        1.0 / 2.0, sqrt(3.0) / 2.0, 0.0,\n              0.0,             0.0, 1.0);\n  }\n  if (state == 1.0) {\n    transf = mat3(\n            - 1.0,             0.0, 0.0,\n      - 1.0 / 2.0, sqrt(3.0) / 2.0, 0.0,\n              1.0,             0.0, 1.0);\n  }\n  if (state == 2.0) {\n    transf = mat3(\n      - 1.0 / 2.0, - sqrt(3.0) / 2.0, 0.0,\n        1.0 / 2.0, - sqrt(3.0) / 2.0, 0.0,\n        1.0 / 2.0,   sqrt(3.0) / 2.0, 1.0);\n  }\n  return vec2(inverse(transf) * vec3(xy, 1));\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  float state1;    // {0, 1, 2}\n  bool  state2;    // {0, 1}\n  float state3;    // [0, 2)\n  bool  px_state1; // {0, 1}\n\n  // Offset time so that first frame shows triangles for shadertoy browser.\n  float t = iTime + 3.0;\n  state1 = mod(t, 6.0) < 2.0 ? 0.0 :\n           mod(t, 6.0) < 4.0 ? 1.0 :\n                               2.0;\n  state2 = mod(t, 4.0) < 2.0;\n  state3 = smoothMod(t, 2.0);\n\n  // Multi sampling\n  vec3 color;\n  for (float i = 0.0; i <= 1.0; i += 1.0 / AA) {\n    for (float j = 0.0; j <= 1.0; j += 1.0 / AA) {\n\n      // Rendering code of single uv\n      vec2 uv = SCALE * (frag_coord + vec2(i, j)) / iResolution.y;\n      vec2 st = invSimplexFrame(uv, state1);\n      px_state1 = fract(st.x) + fract(st.y) > state3;\n      vec3 c;\n      if (state1 == 0.0) {\n        c = px_state1 ? (state2 ? COLOR2 : COLOR1) : (state2 ? COLOR1 : COLOR3);\n      }\n      if (state1 == 1.0) {\n        c = px_state1 ? (state2 ? COLOR3 : COLOR1) : (state2 ? COLOR1 : COLOR4);\n      }\n      if (state1 == 2.0) {\n        c = px_state1 ? (state2 ? COLOR4 : COLOR1) : (state2 ? COLOR1 : COLOR2);\n      }\n      color += c;\n    }\n  }\n  color /= pow((AA + 1.0), 2.0);\n\n  frag_color = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "//\n// History\n//\n\n// 1st version\n\n/*\n\n#define AA 4.0\n#define NUM_ROWS 4.0\n#define SCALE NUM_ROWS * (sqrt(3.0) / 2.0)\n#define COLOR1 vec3(1.0) * 0.15\n#define COLOR2 vec3(0.0, 1.0, 1.0) * 0.95\n#define COLOR3 vec3(1.0, 0.0, 1.0) * 0.95\n#define COLOR4 vec3(1.0, 1.0, 0.0) * 0.95\n\nfloat someStep(float t) {\n    // Doubles step so it's more \"sticky\".\n    return smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, t));\n}\n\nfloat smoothMod(float s, float m) {\n  return someStep(mod(s, m) / m) * m;\n}\n\nvec2 invSimplexFrame(vec2 xy, float state) {\n  mat3 transf;\n  if (state == 0.0) {\n    transf = mat3(\n              1.0,             0.0, 0.0,\n        1.0 / 2.0, sqrt(3.0) / 2.0, 0.0,\n              0.0,             0.0, 1.0);\n  }\n  if (state == 1.0) {\n    transf = mat3(\n            - 1.0,             0.0, 0.0,\n      - 1.0 / 2.0, sqrt(3.0) / 2.0, 0.0,\n              1.0,             0.0, 1.0);\n  }\n  if (state == 2.0) {\n    transf = mat3(\n      - 1.0 / 2.0, - sqrt(3.0) / 2.0, 0.0,\n        1.0 / 2.0, - sqrt(3.0) / 2.0, 0.0,\n        1.0 / 2.0,   sqrt(3.0) / 2.0, 1.0);\n  }\n  return vec2(inverse(transf) * vec3(xy, 1));\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  float state1;    // {0, 1, 2}\n  bool  state2;    // {0, 1}\n  float state3;    // [0, 2)\n  bool  px_state1; // {0, 1}\n\n  // Offset time so that first frame shows triangles for shadertoy browser.\n  float t = iTime + 3.0;\n  state1 = mod(t, 6.0) < 2.0 ? 0.0 :\n           mod(t, 6.0) < 4.0 ? 1.0 :\n                               2.0;\n  state2 = mod(t, 4.0) < 2.0;\n  state3 = smoothMod(t, 2.0);\n\n  // Multi sampling\n  vec3 color;\n  for (float i = 0.0; i <= 1.0; i += 1.0 / AA) {\n    for (float j = 0.0; j <= 1.0; j += 1.0 / AA) {\n\n      // Rendering code of single uv\n      vec2 uv = SCALE * (frag_coord + vec2(i, j)) / iResolution.y;\n      vec2 st = invSimplexFrame(uv, state1);\n      px_state1 = fract(st.x) + fract(st.y) > state3;\n      vec3 c;\n      if (state1 == 0.0) {\n        c = px_state1 ? (state2 ? COLOR2 : COLOR1) : (state2 ? COLOR1 : COLOR3);\n      }\n      if (state1 == 1.0) {\n        c = px_state1 ? (state2 ? COLOR3 : COLOR1) : (state2 ? COLOR1 : COLOR4);\n      }\n      if (state1 == 2.0) {\n        c = px_state1 ? (state2 ? COLOR4 : COLOR1) : (state2 ? COLOR1 : COLOR2);\n      }\n      color += c;\n    }\n  }\n  color /= pow((AA + 1.0), 2.0);\n\n  frag_color = vec4(color, 1.0);\n}\n\n*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGGRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[442, 442, 467, 510, 570], [572, 572, 607, 607, 647], [649, 649, 693, 693, 1269], [1271, 1271, 1328, 1328, 2517]], "test": "untested"}
{"id": "WlV3DD", "name": "[♪]Wavetable Synthesizer", "author": "Catzpaw", "description": "★Wavetable Synthesizer\n    wavetable synthesizer similar to Namco C30\n    8 instruments, max 32 samples\n★Wavetable Viewer\n    visualize the wavetable\n★Scale Sequencer\n    generate melody, chord & bassline based on scale\n", "tags": ["music"], "likes": 23, "viewed": 882, "published": 3, "date": "1579280988", "time_retrieved": "2024-07-30T21:30:00.015565", "image_code": "//---Wavetable Viewer\n// by Catzpaw 2020\n\n//STATE (iChannel0)\nvec4 peek(in ivec2 a){return texelFetch(iChannel0,a,0);}\nconst ivec2 txsel=ivec2(2,0);\n\n//FONT (iChannel3)\nvec2 cur=vec2(0);\nfloat siz=24.;\nfloat chr(int c){\n    vec2 p=cur*siz/16.;\n    vec4 t=p.x<.0||p.x>.0625||p.y<0.||p.y>.0625?vec4(0):\n        textureGrad(iChannel3,p+fract(vec2(c,15-c/16)/16.),dFdx(p),dFdy(p));\n    cur.x-=.5/siz;\n    return length(t.yz)==0.?0.:t.x;\n}\nint imod(uint x,uint y){return int(x-y*(x/y));}\nfloat puthex(uint n){int b=imod(n,16u)>9?55:48;return chr(b+imod(n,16u));}\n\n//GRAPHICS\nfloat rect(vec2 p,vec4 r){return (p.x>r.x)&&(p.y>r.y)&&(p.x<r.x+r.z)&&(p.y<r.y+r.w)?1.:0.;}\n\n//MAIN\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.x;\n    vec3 col=vec3(0);\n    float c=0.3-rect(uv,vec4(-2,-.2,4,.4))*.15;\n    int t=int(peek(txsel).x);\n    cur=vec2(.095,-.2)+uv;\n    c+=chr(83);c+=chr(79);c+=chr(85);c+=chr(78);c+=chr(68);\n    c+=chr(32);c+=chr(35);c+=puthex(uint(t));\n    siz=32.;\n    float l=float(wl[t]),x=-.5+.125/24.,y=0.;\n    for(int i=0;i<int(wl[t]);i++){\n        y=float((wt[i]>>(t*4))&15u);\n        float h=(y-7.5)*.025,v=-1.;\n        if(h<0.){v=rect(uv,vec4(x,h,.7/l,-h))*.4;}else{v=rect(uv,vec4(x,0,.7/l,h))*.4;}\n        if(v>0.){col+=mix(vec3(0,1,1),vec3(1,0,1),abs(h)*4.);}\n        cur=vec2(0.495-float(i)*(1./l),.235)+uv;\n        c+=puthex(uint(y))*.1;\n        x+=1./l;\n    }\n    fragColor=vec4(col+c,1);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//---Scale Sequencer\n// by Catzpaw 2020\n\n//SETUP\nconst float base =432.;\t//A tuning (Hz)\nconst float bpm  =135.;\t//beats per minute\nconst float steps=240.;\t//block length\nconst float start=1.;   //start count (beats)\nconst float fade =10.;  //fade out time (sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\n\n//SCALE\nconst int forcescale=-1; //0-10:scale compulsion -1:disable...use pattern data\nconst uint[11] scl=uint[](\n    0xcb975420u, //0:major\n    0xca875320u, //1:natural minor\n    0xcb875320u, //2:harmonic minor\n    0xcb975320u, //3:melodic minor\n    0xc9974320u, //4:major blues\n    0xca965320u, //5:minor blues\n    0x42c97420u, //6:major pentatonic\n    0x53ca7530u, //7:minor pentatonic\n    0xc9974420u, //8:major pentatonic (to heptatonic)\n    0xca775330u, //9:minor pentatonic (to heptatonic)\n    0xeca86420u);//10:whole tone\nint scalenote(int sc,int y){\n    sc=forcescale>=0?forcescale:sc;\n    return y<0?-999:(int(scl[sc])>>(y&7)*4)&15;\n}\n\n//PATTERN\n// melodic:scale(4),tonic(4),mode(4),seed1(8),seed2(12)\n// percussive:note(2x16)\nconst uint[32] pat=uint[](\n    //00-0B melody\n    0x74000000u,0x74011171u,0x74012172u,0x74013173u,\n    0x74014174u,0x74015165u,0x74016166u,0x74017167u,\n    0x74028168u,0x74019119u,0x7401a11au,0x7401b11bu,\n    //0C-0F backing\n    0x74001434u,0x74001491u,0x74001002u,0x74001002u,\n    //10-13 chord\n    0x74004434u,0x74004491u,0x74004002u,0x74004002u,\n    //14-17 bass\n    0x74004434u,0x74004491u,0x74004002u,0x74000003u,\n    //18-1F rhythm\n    0x313aa13au,0x513aa186u,0x00000000u,0x00000000u,  //sd+hh\n    0x91e121e1u,0x55e121e5u,0x00000000u,0x00000000u); //bd+conga\n\n//SEQUENCE\n// speed(2),algorithm(2),division(4),pattern1(8),key1(4),pattern2(8),key2(4)\n//  >>>>algorithm:0mute 1,2,3note(no difference so far)\n//  0123↓speed:0half\n//  4567↓      1normal\n//  89AB↓      2double\n//  CDEF↓      3quad\nconst uint[16] seq1=uint[]( //snare+hihat\n    0x50000180u,0x50000180u,0x50000180u,0x58180190u,\n    0x50000180u,0x50000180u,0x50000180u,0x50000190u,\n    0x50000180u,0x50000180u,0x50000180u,0x58180190u,\n    0x50000180u,0x50000180u,0x50000180u,0x50000190u);\nconst uint[16] seq2=uint[]( //bassdrum+conga\n    0x500001c0u,0x500001c0u,0x500001c0u,0x5e1c01d0u,\n    0x500001c0u,0x500001c0u,0x500001c0u,0x581c01d0u,\n    0x500001c0u,0x500001c0u,0x500001c0u,0x581c01d0u,\n    0x500001c0u,0x500001c0u,0x500001c0u,0x500001d0u);\nconst uint[16] seq3=uint[]( //bass\n    0x50000140u,0x50000140u,0x50000141u,0x50000165u,\n    0x50000140u,0x50000140u,0x50000141u,0x50000176u,\n    0x50000145u,0x50000143u,0x50000144u,0x50000160u,\n    0x50000145u,0x50000143u,0x50000144u,0x50000176u);\nconst uint[16] seq4=uint[]( //chord\n    0x50000100u,0x50000100u,0x50000101u,0x50000125u,\n    0x50000100u,0x50000100u,0x50000101u,0x50000136u,\n    0x50000105u,0x50000103u,0x50000104u,0x50000120u,\n    0x50000105u,0x50000103u,0x50000104u,0x50000136u);\nconst uint[16] seq5=uint[]( //backing\n    0x100000c0u,0x500000c0u,0x100000c1u,0x980d80e5u,\n    0x100000c0u,0x500000c0u,0x100000c1u,0x980d00f6u,\n    0x100000c5u,0x500000c3u,0x100000c4u,0x980d60e0u,\n    0x100000c5u,0x500000c3u,0x100000c4u,0x980d00f6u);\nconst uint[16] seq6=uint[]( //melody\n    0x10000010u,0x10000020u,0x10000031u,0x10000045u,\n    0x10000010u,0x10000020u,0x10000031u,0x10000056u,\n    0x10000065u,0x10000073u,0x10000084u,0x10000090u,\n    0x10000065u,0x10000073u,0x100000A4u,0x100000B6u);\n\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint imod(uint x,uint y){return int(x-y*(x/y));}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\n\n//PATTERN GENERATOR\nfloat hash(float s){s=fract(s*.13);s*=s+33.33;return fract(s+s*s);}\nfloat pgen(float s,float r){\n    int p=0;\n    for(int i=0;i<16;i+=2){p+=int(hash(s)*r)<<i;s+=1.;}\n    return float(p);\n}\n\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x),vec2(1./p.y)),-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nfloat freq(float n){return pow(2.,(n-69.)/12.)*base*6.283;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nfloat dutybass(float f,float x){return osc_duty(f*.5,.5)*env_d(x,.6);}\nfloat tri4bass(float f,float x){return osc_tri4(f*.5);}\nfloat c30chord(float f,float x){return osc_c30(f,6);}\nfloat c30bell(float f,float x){return osc_c30(f,1)*env_d(x,.6);}\nfloat c30lead(float f,float x){return osc_c30(f,4)*env_d(x,.5);}\n\n//CHIPTUNE PERCUSSION (time)\nfloat nessd(float x){return osc_nesnoise(x,11)*env_d(x,.2);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(20./(x*.5+.1),.5)*env_d(x,.2);}\nfloat neslc(float x){return osc_duty(65./(x*.3+.1),.25)*env_d(x,.05);}\nfloat neshc(float x){return osc_duty(75./(x*.3+.1),.25)*env_d(x,.05);}\n\n//NOTE GENERATORS\nint rnd1(float s,float s1,float s2){\n    int r=int(mod(abs(sin(floor(s)*s1*s2)*s2),4.)-1.2);return r<0?-999:r;\n}\nvec2 bassline(float t,float l,uint b,float m,float s,int k){\n    //pattern:scale(4),tonic(4),mode(4),seed1(8),seed2(12)\n    int sc=get4(b,7),to=get4(b,6),mo=get4(b,5);\n    float s1=float(get8(b,3))+16.,s2=float(b&4095u)+16.;\n    float x=mod(t,l/m);\n    int y=scalenote(sc,rnd1(s,s1,s2)*2+mo+k);\n    if((s>=1.)&&(y<0)){y=scalenote(sc,rnd1(s-1.,s1,s2)*2+mo+k);x+=l/m;}\n    return vec2(x,y+to);\n}\nvec4 triad(float t,float l,uint b,float m,float s,int k){\n    //pattern:scale(4),tonic(4),mode(4),seed1(8),seed2(12)\n    int sc=get4(b,7),to=get4(b,6),mo=get4(b,5);\n    float s1=float(get8(b,3))+16.,s2=float(b&4095u)+16.;\n    float x=mod(t,l/m);\n    int y=scalenote(sc,mo+k);\n    int z=scalenote(sc,mo+k+2);\n    int w=scalenote(sc,mo+k+4);\n    y+=rnd1(s,s1,s2)>1?-999:0;\n    return vec4(x,y+to,z+to,w+to);\n}\nint rnd2(float s,float s1,float s2){\n    int r=int(mod(abs(sin(floor(s)*s1*s2)*s2+s1),7.)-1.8);return r<0?-999:r;\n}\nvec2 melody(float t,float l,uint b,float m,float s,int k){\n    //pattern:scale(4),tonic(4),mode(4),seed1(8),seed2(12)\n    int sc=get4(b,7),to=get4(b,6),mo=get4(b,5);\n    float s1=float(get8(b,3))+16.,s2=float(b&4095u)+16.;\n    float x=mod(t,l/m);\n    int y=scalenote(sc,rnd2(s,s1,s2)*2+mo+k);\n    if((s>=1.)&&(y<0)){y=scalenote(sc,rnd2(s-1.,s1,s2)*2+mo+k);x+=l/m;}\n    return vec2(x,y+to);\n}\n\n//PERFORMER SETUP\nbool performerinit(in float t,inout uint b,inout float m,inout float s,inout int a,inout int k){\n    //sequence:speed(2),algorithm(2),division(4),pattern1(8),key1(4),pattern2(8),key2(4)\n    a=get2(b,14);if(a==0)return false;\n    m=pow(2.,float(get2(b,15)-1))*16.;\n    s=mod(t*bpm*m/steps,16.);\n    int d=int(mod(t*bpm*16./steps,16.));\n    k=d<get4(b,6)?get8(b,3):get8(b,0);\n    b=d<get4(b,6)?pat[get8(b,4)]:pat[get8(b,1)];\n    return true;\n}\n\n//PERFORMERS\nvec2 playpercussion(float t,float l,uint b){\n    float m=0.,s=0.;int a=0,k=0;if(!performerinit(t,b,m,s,a,k))return vec2(0);\n    float x=mod(t,l/m);int y=get2(b,int(s));\n    if((s>=1.)&&(y==0)){y=get2(b,int(s)-1);x+=l/m;}\n    return vec2(x,y);\n}\nvec2 playbassline(float t,float l,uint b){\n    float m=0.,s=0.;int a=0,k=0;if(!performerinit(t,b,m,s,a,k))return vec2(0);\n    return bassline(t,l,b,m,s,k);\n}\nvec4 playchord(float t,float l,uint b){\n    float m=0.,s=0.;int a=0,k=0;if(!performerinit(t,b,m,s,a,k))return vec4(0);\n    return triad(t,l,b,m,s,k);\n}\nvec2 playbacking(float t,float l,uint b){\n    float m=0.,s=0.;int a=0,k=0;if(!performerinit(t,b,m,s,a,k))return vec2(0);\n    return bassline(t,l,b,m,s,k);\n}\nvec2 playmelody(float t,float l,uint b){\n    float m=0.,s=0.;int a=0,k=0;if(!performerinit(t,b,m,s,a,k))return vec2(0);\n    return melody(t,l,b,m,s,k);\n}\n\n//RENDERER\nvoid render(float t,float l,inout vec2 o){\n    float c=0.;     //render target\n    vec2 n=vec2(0); //note info x:gate y:note\n    vec4 nc=vec4(0); //chord info x:gate yzw:note\n    float f=0.;     //freq*gate for melodic osc\n    int b=int(t/l); //pattern offset now playing\n\n    //TRACK 1 NES noise snaredrum,closehh,openhh\n    n=playpercussion(t,l,seq1[imod(b,16)]);\n    c+=(n.y==1.)?nessd(n.x)*.8:0.;\n    c+=(n.y==2.)?neshh(n.x,.08)*.4:0.;\n    c+=(n.y==3.)?neshh(n.x,.2)*.5:0.;\n\n    //TRACK 2 NES sqr bassdrum,lowconga,highconga\n    n=playpercussion(t,l,seq2[imod(b,16)]);\n    c+=(n.y==1.)?nesbd(n.x)*.6:0.;\n    c+=(n.y==2.)?neslc(n.x)*.2:0.;\n    c+=(n.y==3.)?neshc(n.x)*.2:0.;\n\n    //TRACK 3 NES tri4 bass\n    n=playbassline(t,l,seq3[imod(b,16)]);\n    c+=(n.y>0.)?tri4bass(freq(n.y+48.)*n.x,n.x)*.8:0.;\n\n    //TRACK 4 N163 chord\n    nc=playchord(t,l,seq4[imod(b,16)]);\n    c+=(nc.y>0.)?c30chord(freq(nc.y+60.03)*nc.x,nc.x)*.2:0.;\n    c+=(nc.y>0.)?c30chord(freq(nc.z+60.02)*nc.x,nc.x)*.2:0.;\n    c+=(nc.y>0.)?c30chord(freq(nc.w+60.01)*nc.x,nc.x)*.2:0.;\n\n    //TRACK 5 N163 backing\n    n=playbacking(t,l,seq5[imod(b,16)]);\n    c+=(n.y>0.)?c30bell(freq(n.y+72.05)*n.x,n.x)*.3:0.;\n\n    //TRACK 6 N163 melody\n    n=playmelody(t,l,seq6[imod(b,16)]);\n    c+=(n.y>0.)?c30lead(freq(n.y+48.05)*n.x,n.x)*.6:0.;\n\n    o+=c; //output\n}\n\n//MASTER SECTION\n#define MASTER_DRIVE    0.5\n#define MASTER_PRESSURE 1.1\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o);\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n", "sound_inputs": [], "common_code": "//---Wavetable Synthesizer\n// by Catzpaw 2020\n\n//WAVETABLE (8 instruments, max 32 samples)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\n\n//square wave with duty ratio(NES)\nfloat osc_duty(float x,float d){return mod(x,6.283)<d*6.283?1.:-1.;}\n\n//4bit triangle wave(NES)\nfloat osc_tri4(float x){return abs(floor(mod(x/6.283,1.)*15.9999)/7.5-1.);}\n\n//noise(NES)\nconst float[16] nt=float[](2.,4.,8.,16.,32.,48.,64.,80.,101.,127.,190.,254.,381.,508.,1017.,2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*1789772.5/nt[i])*179.2)*204.8);}\n\n//wavetable osc(namco C30/N163)\nconst uint[32] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u,\n    0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u);\nconst float[8] wl=float[](24.,24.,24.,24.,24.,24.,24.,24.);\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*wl[i]/6.283,wl[i]))]>>(i*4))&15u)/15.-.5);}\n", "buffer_a_code": "//---Clickable UI\n// by Catzpaw 2020\n\n//STATE (iChannel0)\nvec4 peek(ivec2 a){return texelFetch(iChannel0,a,0);}\nvoid poke(ivec2 a,in vec4 v,inout vec4 f,in ivec2 p){f=(p==a)?v:f;}\nbool chktx(ivec2 tx,ivec2 p){return (tx.x==p.x)&&(tx.y==p.y);}\nconst float txw=3.,txh=1.;\nconst ivec2 txstat=ivec2(0,0);\nconst ivec2 txlmo=ivec2(1,0);\nconst ivec2 txsel=ivec2(2,0);\n\n//BUTTONS\nbool chkrect(vec2 c,vec4 r,float d){return((c.x>r.x)&&(c.x<r.x+r.z)&&(c.y>r.y)&&(c.y<r.y+r.w));}\nconst vec4 b0=vec4(-1.00,-0.50,1.00,1.00);\nconst vec4 b1=vec4( 0.00,-0.50,1.00,1.00);\n\n//MAIN\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\n    //FRAME INIT\n    if(fragCoord.x>=txw||fragCoord.y>=txh)discard;\n    ivec2 fcd=ivec2(fragCoord-.5);\n    fragColor=vec4(0);\n\n    //LOAD STATE\n    vec4 stat=peek(txstat),lmo=peek(txlmo),sel=peek(txsel);\n\n    //FIRST FRAME\n    if(iFrame==0)stat.x=-1.;\n    if(stat.x<-.5){stat.x=1.;sel.x=0.;lmo=iMouse;}\n\n    //UI OPERATION\n    if(stat.x>.5){\n        bool click=(iMouse.z>1e-3)&&(lmo.z<-1e-3);\n        if(click){\n            vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n            vec2 mo=(iMouse.xy-.5*iResolution.xy)/iResolution.y;\n            //button:prev\n            if(chkrect(mo,b0,8.)&&chktx(txsel,fcd)){sel.x=floor(mod(sel.x+7.,8.));}\n            //button:next\n            if(chkrect(mo,b1,8.)&&chktx(txsel,fcd)){sel.x=floor(mod(sel.x+1.,8.));}\n        }\n    }\n\n    //STORE STATE\n    poke(txstat,stat,fragColor,fcd);\n    poke(txlmo,iMouse,fragColor,fcd);\n    poke(txsel,sel,fragColor,fcd);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 62, 84, 84, 118], [202, 202, 219, 219, 434], [435, 435, 459, 459, 482], [483, 483, 504, 504, 557], [559, 570, 596, 596, 661], [663, 670, 723, 723, 1468]], "test": "untested"}
{"id": "wlKGWm", "name": "a bunch of spheres", "author": "loicvdb", "description": "a bunch of spheres", "tags": ["dof", "glass", "caustics", "bloom", "pathtracing", "depthoffield", "aperture"], "likes": 26, "viewed": 894, "published": 3, "date": "1579234779", "time_retrieved": "2024-07-30T21:30:00.867288", "image_code": "vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale)+1.0;\n    vec3 bloom = vec3(0);\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n            bloom += textureLod(iChannel0, (fragCoord+vec2(x, y) * scale)/iResolution.xy, logScale).rgb;\n    \n    return max(bloom/9.0 - vec3(threshold), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    vec3 bloomSum = bloom(.02 * iResolution.y, .5, fragCoord) * .2\n        \t\t  + bloom(.10 * iResolution.y, .1, fragCoord) * .2;\n    \n    fragColor = vec4(ACESFilm(col + bloomSum), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//uncomment this line to give very pixel the same seed on each frame\n//#define CONST_SEED\n\n\n\n#define Pi 3.14159265359\n\n#define MaxSteps 200\n#define MaxBounces 50\n#define MaxDist 10.0\n#define MinDist .001\n#define SPPPerFrame 2\n\n#define LightIndex 1\n#define PlaneIndex 2\n#define SpheresIndex 3\n\n\nvec3 CamPos = vec3(0, .75, -3);\nvec3 CamRot = vec3(.3, 0., 0.);\nfloat CamFocalLength = 1.;\nfloat CamFocalDistance = 3.;\nfloat CamAperture = .05;\nfloat CamLensDistortion = .8; //positive = barrel, negative = pincushion, zero = none\n\nvec3 LightPos = vec3(0., 1., 0.);\nvec3 LightColor = vec3(.7, .5, .3) * 250.;\nfloat LightRadius = .2;\n\nvec3 SpheresColor = vec3(.7, .8, 1.);\nfloat SpheresRadius = .1;\nfloat SpheresIoR = 1.45;\n\nvec3 PlaneColor = vec3(1.);\n\n\nfloat seed;\n\nfloat randomFloat(){\n    return fract(sin(seed++)*43758.54536156);\n}\n\nvec2 roundTo(vec2 v, vec2 p){\n    return p*floor(v/p+.5);\n}\n\nvec2 polar2Cartesian(vec2 pos){\n    return vec2(cos(pos.x)*pos.y, sin(pos.x)*pos.y);\n}\n\nvec2 cartesian2Polar(vec2 pos){\n    return vec2(atan(pos.y, pos.x), length(pos));\n}\n\nfloat vornoi(vec3 pos){\n    \n    vec2 center = polar2Cartesian(roundTo(cartesian2Polar(pos.xz), vec2(Pi*2./50., .5)));\n    return length(vec3(center.x, 0., center.y) - pos);\n}\n\nfloat deSpheres(vec3 pos){\n    return vornoi(pos) - SpheresRadius;\n}\n\nfloat dePlane(vec3 pos){\n    return pos.y+SpheresRadius+2.*MinDist;\n}\n\nfloat deLight(vec3 pos){\n    return length(pos-LightPos)-LightRadius;\n}\n\nfloat distanceEstimation(vec3 pos, out int materialIndex){\n    float deS = deSpheres(pos);\n    float deP = dePlane(pos);\n    float deL = deLight(pos);\n    float de = min(min(deS, deP), deL);\n    if(deS == de)\n        materialIndex = SpheresIndex;\n    else if(deP == de)\n        materialIndex = PlaneIndex;\n    else\n        materialIndex = LightIndex;\n    return de;\n}\n\nfloat distanceEstimation(vec3 pos){\n    int placeHolder;\n    return distanceEstimation(pos, placeHolder);\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\n//could've used a simpler approach since it's only used for the plane (with a normal of [0,1,0])\nvec3 getCosineWeightedSample(vec3 dir) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(randomFloat(), randomFloat());\n\tr.x = r.x * 2.0 * Pi;\n\tr.y = pow(r.y, .5);\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n//not the most efficient technique but I mean it's only used once per bounce\nvec3 normalEstimation(vec3 pos){\n  vec3 xDir = vec3(MinDist, 0, 0);\n  vec3 yDir = vec3(0, MinDist, 0);\n  vec3 zDir = vec3(0, 0, MinDist);\n  return normalize(vec3(distanceEstimation(pos + xDir),\n\t  \t\t\t\t\tdistanceEstimation(pos + yDir),\n  \t\t\t\t\t\tdistanceEstimation(pos + zDir))\n\t\t\t\t - vec3(distanceEstimation(pos)));\n}\n\nfloat fresnel(vec3 dir, vec3 normal, float ior) {\n  float cosi = dot(dir, normal);\n  float etai = 1.0;\n  float etat = ior;\n  if (cosi > 0.0) {\n    float tmp = etai;\n    etai = etat;\n    etat = tmp;\n  }\n  float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n  if (sint >= 1.0) return 1.0;\n  float cost = sqrt(max(0.0, 1.0 - sint * sint));\n  cosi = abs(cosi);\n  float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n  float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n  return (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n}\n\nbool trace(inout vec3 pos, in vec3 dir, in float dSign, out int materialIndex){\n    \n    for(int i = 0; i < MaxSteps; i++){\n        float dist = distanceEstimation(pos, materialIndex);\n        if(dSign*dist > MaxDist) return false;\n        if(dSign*dist < MinDist) return true;\n        pos += dir*dSign*dist;\n    }\n    return false;\n}\n\nvec3 pathTrace(vec3 pos, vec3 dir){\n    \n    vec3 abso = vec3(1.);\n    \n    float dSign = sign(distanceEstimation(pos));\n    int materialIndex;\n    for(int i = 0; i < MaxBounces; i++){\n        if(!trace(pos, dir, dSign, materialIndex)) break;\n        if(materialIndex == LightIndex) return i==0 ? vec3(0.) : LightColor*abso;\n        vec3 normal = normalEstimation(pos);\n        float dist = distanceEstimation(pos);\n        if(materialIndex == PlaneIndex){\n            abso *= PlaneColor;\n            dir = getCosineWeightedSample(normal);\n        }\n        // if you're scared of branching close your eyes for a second\n        if(materialIndex == SpheresIndex){\n            if(randomFloat() > fresnel(dir, normal, SpheresIoR)){\n            \tabso *= SpheresColor;\n                bool d = dot(dir, normal) < 0.;\n                vec3 n = d ? normal : -normal;\n                float etai = d ? 1./SpheresIoR : SpheresIoR;\n               \tdir = refract(dir, n, etai);\n            } else {\n                dir = reflect(dir, normal);\n            }\n        }\n        dSign = dot(dir, normal) < 0. ? -1. : 1.;\n        pos += dSign * 2. * MinDist * normal;\n    }\n    return vec3(0.);\n}\n\n//n-blade aperture\nvec2 sampleAperture(int nbBlades, float rotation){\n    \n    float alpha = 2.0*Pi / float(nbBlades);\n    float side = sin(alpha/2.0);\n    \n    int blade = int(randomFloat() * float(nbBlades));\n    \n    vec2 tri = vec2(randomFloat(), -randomFloat());\n    if(tri.x+tri.y > 0.0) tri = vec2(tri.x-1.0, -1.0-tri.y);\n    tri.x *= side;\n    tri.y *= sqrt(1.0-side*side);\n    \n    float angle = rotation + float(blade)/float(nbBlades) * 2.0 * Pi;\n    \n    return vec2(tri.x * cos(angle) + tri.y * sin(angle),\n                tri.y * cos(angle) - tri.x * sin(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    #ifdef CONST_SEED\n    \tseed = mod(iTime, 184.3158915);\n    #else\n    \tseed = mod(fragCoord.x*.6868628+fragCoord.y*.6595975+iTime, 184.3158915);\n    #endif\n    \n    \n    vec2 uv = (fragCoord+vec2(randomFloat(), randomFloat())-iResolution.xy/2.0) / iResolution.y;\n    \n    \n    vec3 focalPoint = vec3(uv * CamFocalDistance / CamFocalLength, CamFocalDistance);\n    vec3 aperture = CamAperture * vec3(sampleAperture(6, 0.0), 0.0);\n    vec3 rayDir = normalize(focalPoint-aperture);\n    \n    rayDir.xy /= pow(rayDir.z, CamLensDistortion);\n    rayDir = normalize(rayDir);\n    \n    mat3 CamMatrix = rotationMatrix(CamRot);\n\n    rayDir *= CamMatrix;\n    aperture *= CamMatrix;\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(iMouse.w > 0.) fragColor.a = 0.;\n    for(int i = 0; i < SPPPerFrame; i++){\n        fragColor.a++;\n        fragColor.rgb = mix(fragColor.rgb, pathTrace(CamPos+aperture,rayDir), 1./fragColor.a);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 163], [165, 165, 222, 222, 522], [524, 524, 581, 581, 843]], "test": "untested"}
{"id": "wlyGzy", "name": "Waves on flat sea surface", "author": "mrange", "description": "Based on a earlier shader I did that relier but simplified to waves rotation. Detects the intersection of the flat sea surface and computes the wave normal to produce the wave effect. Looks best in FF for me and doesn't work properly in Edge. ", "tags": ["raytracing", "flat"], "likes": 17, "viewed": 647, "published": 3, "date": "1579203898", "time_retrieved": "2024-07-30T21:30:01.974329", "image_code": "#define PI  3.141592654\n#define TAU (2.0*PI)\n\nconst float gravity = 1.0;\nconst float waterTension = 0.01;\n\nconst vec3 skyCol1 = vec3(0.6, 0.35, 0.3);\nconst vec3 skyCol2 = vec3(1.0, 0.3, 0.3);\nconst vec3 sunCol1 = vec3(1.0,0.5,0.4);\nconst vec3 sunCol2 = vec3(1.0,0.8,0.7);\nconst vec3 seaCol1 = vec3(0.1,0.2,0.2);\nconst vec3 seaCol2 = vec3(0.8,0.9,0.6);\n\nvec2 wave(in float t, in float a, in float w, in float p) {\n  float x = t;\n  float y = a*sin(t*w + p);\n  return vec2(x, y);\n}\n\nvec2 dwave(in float t, in float a, in float w, in float p) {\n  float dx = 1.0;\n  float dy = a*w*cos(t*w + p);\n  return vec2(dx, dy);\n}\n\nvec2 gravityWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return wave(t, a ,k, w*iTime);\n}\n\nvec2 capillaryWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return wave(t, a, k, w*iTime);\n}\n\nvec2 gravityWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return dwave(t, a, k, w*iTime);\n}\n\nvec2 capillaryWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return dwave(t, a, k, w*iTime);\n}\n\nvoid mrot(inout vec2 p, in float a) {\n  // c*c + s*s\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec4 sea(in vec2 p, in float ia) {\n  float y = 0.0;\n  vec3 d = vec3(0.0);\n\n  const int maxIter = 8;\n  const int midIter = 4;\n\n  float kk = 1.0/1.3;\n  float aa = 1.0/(kk*kk);\n  float k = 1.0*pow(kk, -float(maxIter) + 1.0);\n  float a = ia*0.25*pow(aa, -float(maxIter) + 1.0);\n\n  float h = 25.0;\n  p *= 0.5;\n  \n  vec2 waveDir = vec2(0.0, 1.0);\n\n  for (int i = midIter; i < maxIter; ++i) {\n    float t = dot(-waveDir, p) + float(i);\n    y += capillaryWave(t, a, k, h).y;\n    vec2 dw = capillaryWaveD(-t, a, k, h);\n    \n    d += vec3(waveDir.x, dw.y, waveDir.y);\n\n    mrot(waveDir, PI/3.0);\n\n    k *= kk;\n    a *= aa;\n  }\n  \n  waveDir = vec2(0.0, 1.0);\n\n  for (int i = 0; i < midIter; ++i) {\n    float t = dot(waveDir, p) + float(i);\n    y += gravityWave(t, a, k, h).y;\n    vec2 dw = gravityWaveD(t, a, k, h);\n    \n    vec2 d2 = vec2(0.0, dw.x);\n    \n    d += vec3(waveDir.x, dw.y, waveDir.y);\n\n    mrot(waveDir, -step(2.0, float(i)));\n\n    k *= kk;\n    a *= aa;\n  }\n\n  vec3 t = normalize(d);\n  vec3 nxz = normalize(vec3(t.z, 0.0, -t.x));\n  vec3 nor = cross(t, nxz);\n\n  return vec4(y, nor);\n}\n\nvec3 sunDirection() {\n  vec3 dir = normalize(vec3(0, 0.06, 1));\n  return dir;\n}\n\nvec3 skyColor(in vec3 rd) {\n  vec3 sunDir = sunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  \n  vec3 final = vec3(0.0);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n\n  final += 0.5*sunCol1*pow(sunDot, 90.0);\n\n  final += 4.0*sunCol2*pow(sunDot, 900.0);\n    \n  return final;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  float dsea = (0.0 - ro.y)/rd.y;\n  \n  vec3 sunDir = sunDirection();\n  \n  vec3 sky = skyColor(rd);\n  \n  if (dsea > 0.0) {\n    vec3 p = ro + dsea*rd;\n    vec4 s = sea(p.xz, 1.0);\n    float h = s.x;    \n    vec3 nor = s.yzw;\n    nor = mix(nor, vec3(0.0, 1.0, 0.0), smoothstep(0.0, 200.0, dsea));\n\n    float fre = clamp(1.0 - dot(-nor,rd), 0.0, 1.0);\n    fre = pow(fre, 3.0);\n    float dif = mix(0.25, 1.0, max(dot(nor,sunDir), 0.0));\n    \n    vec3 refl = skyColor(reflect(rd, nor));\n    vec3 refr = seaCol1 + dif*sunCol1*seaCol2*0.1; \n    \n    col = mix(refr, 0.9*refl, fre);\n    \n    float atten = max(1.0 - dot(dsea,dsea) * 0.001, 0.0);\n    col += seaCol2*(p.y - h) * 2.0 * atten;\n    \n    col = mix(col, sky, 1.0 - exp(-0.01*dsea));\n    \n  } else {\n    col = sky;\n  }\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 ww = normalize(vec3(0.0, -0.1, 1.0));\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 col = render(ro, rd);\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 412, 412, 478], [480, 480, 540, 540, 614], [616, 616, 682, 682, 756], [758, 758, 826, 826, 923], [925, 925, 992, 992, 1067], [1069, 1069, 1138, 1138, 1236], [1238, 1238, 1275, 1290, 1375], [1377, 1377, 1411, 1411, 2464], [2466, 2466, 2487, 2487, 2545], [2547, 2547, 2574, 2574, 2831], [2833, 2833, 2870, 2870, 3683], [3685, 3685, 3740, 3740, 4124]], "test": "untested"}
{"id": "tty3Ry", "name": "transition cool thing yeaaa", "author": "thefox231", "description": "look at it go idk why i made this", "tags": ["2d", "simple", "transition"], "likes": 2, "viewed": 382, "published": 3, "date": "1579197188", "time_retrieved": "2024-07-30T21:30:02.853976", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    if (mod(iTime, 1.6) > 0.2 && mod(iTime, 1.6) < 1.0) col = 0.5 - col;\n    \n    float changevar = mod(uv.x + uv.y, 0.2);\n    if (mod(iTime, 1.6) > 0.4) changevar = mod(uv.x - uv.y, 0.2);                      \n    \n    \n    if (mod(iTime, 0.8) < 0.2 &&\n        abs(changevar) < mod(iTime, 0.2) ||\n        mod(iTime, 0.8) > 0.2 && mod(iTime, 0.8) < 0.4 &&\n        abs(changevar) > mod(iTime, 0.2)) col = vec3(1);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tty3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 610]], "test": "untested"}
{"id": "Wly3Ry", "name": "Day 28 - Alien Cave", "author": "jeyko", "description": "potato", "tags": ["clouds", "organic", "flesh", "mdtmjvm"], "likes": 14, "viewed": 562, "published": 3, "date": "1579194165", "time_retrieved": "2024-07-30T21:30:03.662814", "image_code": "\n// CHECK OUT SECOND VARIANT IN BUFFER B #define\n\n// Cloud technique from lsdlive and Duke!\n// https://www.shadertoy.com/view/wd3GWM\n// https://www.shadertoy.com/view/MljXDw\n\n// I recommend it, it's very fun\n\n// Inspiration from 3d trabaculum from aiekick\n\n// Trabeculum from Frabrice Neyret\n\n// Noise from iq\n\n// pModPolar from hg-sdf\n\n// Triplanar from Shane/nvidia\n\n\n#define mx (20.*iMouse.x/iResolution.x)\n#define my (20.*iMouse.y/iResolution.x)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define iTime (iTime + 5.4)\n#define VARIANT 2\n\n\n// Trabeculum from FabriceNeyret2 \n// https://www.shadertoy.com/view/4dKSDV\nfloat effect(vec2 uv)\n{\n    float l;\n    vec2 c;\n    vec3 O = vec3(0.39 + sin(iTime*0.5)*0.05);\n    for (int k=0; k<9; k++)\n    { \n     \tc = ceil(uv) + vec2(k-k/3*3,k/3)-2.;\n        c += abs( fract( sin( c.x - c.y/.7 + iTime*0.5   ) ) - 0.5) - uv;\n        l = dot(c,c);        \n        l < O.x  \n            ? O.yz = O.xy, O.x = l       \n            : l < O.y  \n                ? O.z = O.y , O.y = l \n                : l < O.z  \n                    ? O.z = l \n                    : l;\n    }\n    return 1.-2./(1./(O.y-O.x)+1./(O.z-O.x)); // Formula (c) Fabrice NEYRET - BSD3:mention author.\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nfloat tex3D( in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tfloat tx = effect( p.yz);\n    float ty = effect( p.zx);\n    float tz = effect( p.xy);\n    return (tx*n.x + ty*n.y + tz*n.z);\n    \n}\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n#define pmod(p, x) mod(p, x) - x*0.5\n\n#define dmin(a, b) a.x < b.x ? a : b\n#define dmax(a, b) a.x > b.x ? a : b\n// iq fbm\nfloat noise(in vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3. - 2. * f);\n\tvec2 uv = (p.xy + vec2(37., 17.) * p.z) + f.xy;\n\tvec2 rg = textureLod(iChannel0, (uv + .5) / 256., 0.).yx;\n\treturn -1. + 2.4 * mix(rg.x, rg.y, f.z);\n}\n\n// Fbm\nfloat fbm(vec3 p) {\n\treturn noise(p * .06125) * .5 + noise(p * .125) * .25 + noise(p * .25) * .125;\n}\n#define modDist 7.\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e10);\n    vec3 q = p;\n\tp.xz = pmod(p.xz, modDist);\n    \n    vec3 N = normalize(p);\n    \n    p.xz += (0.1 + sin(iTime*3. + p.y)*0.1)*N.xz * smoothstep(0.35,1.,exp(-abs(q.y*0.25)))*exp(abs(p.y)); \n    // ^ just some function graphing\n    for(float i = 0.; i < 6.; i++){\n    \tp = abs(p);\n    \tp.y -= 2.4;\n        p.xy *= rot(3.4 - exp(-i*5. )*0.14);\n        #if VARIANT==2\n        if(i < 5.){\n        \tp.z -= 1.2;\n        }\n        #else \n        \tp.z -= 1.1;\n        \n        #endif\n        p.y -= 1.35;\n        p.xz *= rot(0.7);\n    }\n    \n    // ^ IFS\n    N = normalize(p);\n    \n    float dS = length(p) - 1.;\n    \n    float trabA = tex3D(p*5., N); \n    float trabB = tex3D(p*10., N);\n\n    d = dmin(d, vec2(dS, 1.));\n    d = dmax(d, vec2(-(dS - 0.5), 1.));\n    d -= trabA*0.34;\n    \n    d = dmin(d, vec2(dS, 2.));\n    //d = dmin(d, vec2(q.y + 6. - trabA*0.8, 1.));\n    //d.x = length(p) - 1.+ fbm(p*10.)*0.1;\n    //return d;\n    d.x -= fbm(q*9.)*0.1;\n    \n    //d.x -= 0.1 + sin(iTime + p.y)*0.1;\n    d.x *= 0.8;\n    return d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross( dir, right));\n    return dir + uv.x*right + uv.y*up;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001,0);\n    return normalize(\n    \tmap(p).x - vec3(\n        \tmap(p - t.xyy).x,\n        \tmap(p - t.yxy).x,\n        \tmap(p - t.yyx).x\n        )\n    );\n}\n// cool sin - does nothing\nfloat csin(float i, float p){\n    return sin(i);\n    p = 1.;\n\tfloat ni = mod(i/(2.*PI), 1.);\n    ni = pow(ni, p);\n}\n\nvec3 glow = vec3(0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(-0.,-0.,-0.);\n    ro.y += sin(iTime*0.24 + sin(iTime*0.5)*0.8)*1.;\n    //ro.x += modDist * 0.5;\n    float T = iTime*0.4;\n    ro.z += 1.7;\n    ro.z += T;\n    ro.x += csin( 1.*(T/modDist)*(PI) + PI, 1. )*modDist*2.;\n    ro.x += csin( (0.5*T/modDist)*(PI), 1. )*modDist/4.;\n    vec3 lookAt = ro + vec3(0.,0,5);\n    lookAt.xz -= csin((T/modDist)*PI + csin(iTime, 1.)*0.25 + 0.5, 1. )*modDist*0.2;\n     \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    \n    \n\t// local density/distance\n\tfloat ldensity = 0.;\n\n\t// accumulation color & density\n\tvec3 bg = vec3(.16, .12, .22)*0.6;\n\tvec4 sum = vec4(bg, 0.);\n   \n   \t// total color\n   \tvec3 tc = vec3(0.);\n   \n    vec2 d = vec2(10e9);\n    vec3 p = ro; float t = 0.; vec3 N;\n    #define iters 80\n    for (int i = 0; i <= iters; i++){\n        if((d.x<=0.0001*t) || (t > 100.) || (sum.a > 1.) ){\n\t\t   break;\n        }\n        \n    \td = map(p);\n        \n        d.x *= 0.7;\n        glow += exp(-d.x*1.)*vec3(1.);\n        //glow += d.x;\n        \n\t\t// compute local density and weighting factor \n\t\tconst float h = .06;\n\t\tldensity = (h - d.x) * step(d.x, h);\n\t\tvec4 c;\n        \n\t\t#define pal(t,x,y,i,z) (t + x*sin(y*i + z))\n\t\tc.rgb = pal(0.5, 2.5, vec3(0.6,0.1,0.2) , 0.5- d.y,7.5 );\n        //c.rgb =vec3(1.);\n        //col.rgb = clamp(col.rgb, 0., 1.);\n\t\tc.a = ldensity;\n        c.rgb *= c.a;\n\t\tsum += (1. - sum.a) * c;\n\n\t\t// from duke/las\n\t\tsum.a += .026;\n\n      \td.x = max(d.x, 0.02);\n        \n        t += d.x;\n    \tp = ro + rd*t;\n    }\n    \n    \n    \n    N = getNormal(p);\n    vec3 L = normalize(vec3(1));\n    vec3 H = normalize(L - rd);\n    float diff = max(dot(N, L), 0.);\n    float fres = pow(1. - max(dot(N, -rd), 0.), 5.);\n    float spec = pow(max(dot(N, H),0.), 5.); \n    \n    col += sum.xyz*1.;\n    \n    float s = (1. - sum.w);\n    col -= N*s*0.7;\n    col -= glow*0.02*pal(0.6,0.8,vec3(0.7,0.5,0.8),0.8,0.6)*0.09;\n    \n    //col *= 0.9;\n    col = pow(col, mix(vec3(1),vec3(0.45), smoothstep(0., 1., t*0.03)));\n    \n    \n    \n    uv = fragCoord/R;\n    uv -= 0.5;\n    col *= 1. - mix(0.,1., pow(smoothstep(0.,1.,length(uv))*0.3, 0.6));\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R (iResolution.xy)\n#define T(uv) texture(iChannel0, uv/R)\n#define PI acos(-1.)\n#define tau (2.*PI)\n\nfloat r11(float i){return fract(sin(i*8124.124124)*123.2412);}\nvec3 r13(float i){return vec3(r11(i),r11(i + 0.2),r11(i + 0.4));}\nfloat r11c(float i){return fract(sin(i*8124.124124));} // cheaper\n\n#define pmod(p, x) mod(p, x) - x*0.5\n\n#define dmin(a, b) a.x < b.x ? a : b\n#define dmax(a, b) a.x > b.x ? a : b\n#define zoom 10.\n\nfloat sdBox(vec3 p, vec3 s){\n\t p = abs(p) - s;\n\treturn max(p.x, max(p.y, p.z));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wly3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[550, 626, 649, 649, 1217], [1220, 1378, 1414, 1414, 1606], [1607, 1607, 1657, 1657, 2047], [2161, 2171, 2195, 2195, 2415], [2417, 2424, 2443, 2443, 2525], [2545, 2545, 2562, 2562, 3608], [3609, 3609, 3651, 3651, 3820], [3822, 3822, 3845, 3845, 4013], [4014, 4041, 4070, 4070, 4156], [4179, 4179, 4236, 4236, 6458]], "test": "untested"}
{"id": "WlG3zG", "name": "pow(x,2.2) approximation", "author": "iq", "description": "Approximates pow(x,2.2), the usual gamma to linear map, through an EXP2M1 (2ˣ-1) and a linear term. It runs 2.0x faster. In blue, pow(x,2.2). In yellow, (2ˣ-1 - x·ln2)/(1-ln2)", "tags": ["gamma", "pow", "approximatoin"], "likes": 35, "viewed": 3074, "published": 3, "date": "1579160480", "time_retrieved": "2024-07-30T21:30:04.651171", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Approximating pow(x,2.2), the usual gamma-to-linear\n// mapping, through (2ˣ-1 - x·ln2)/(1-ln2), resulting\n// in a 2x speed up (in my GPU)\n//\n// In blue, pow(x,2.2)\n// In yellow, (2ˣ-1 - x·ln2)/(1-ln2)\n//\n// Note that GPUs implement exp2m1(x) = 2ˣ-1 in hardware,\n// so this _should_ translate to EXP2M1, MAD, MUL, while\n// regular pow(x,2.2) does in principle involve a log and\n// an exponential.\n\n// Set to 1 to measure performance, then go to line 63 and 64\n#define DISPLAY_OR_MEASURE 0\n\nfloat exp2m1( in float x ) { return exp2(x)-1.0; }\n\n// Different approximations to pow(x,2.2)\nfloat my_pow_22( float x )\n{\n\t// By iq, f(x) = (2ˣ-1 - x·ln2)/(1-ln2) \n    return (exp2m1(x)-x*0.693147)*3.258891;\n    \n    // Same idea (one extra mul), but better match. By Marc B.Reynolds\n    // return (exp2m1(0.718151*x)-0.503456*x)*7.07342;\n\n    // By BigWIngs (see comments), probably best tradeof perf and accuracy\n    // return x*x*(0.75 + 0.25*x);\n\n    // By iq (see comments)\n    // return x*(1.12*x - 0.12);\n\n    // By Marc B.Reynolds (http://marc-b-reynolds.github.io/math/2019/12/10/GammaRamp.html)\n    // return (0.5*x*x)*(sqrt(x)+1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n#if DISPLAY_OR_MEASURE==0\n    float dx = 1.0/iResolution.y;\n    vec2  p = ( vec2((iResolution.y-iResolution.x)/2.0,0.0)+fragCoord)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    if( p.x>0.0 && p.x<1.0 )\n    {\n        col = vec3( 0.2 + 0.02*mod(floor(p.x*10.0)+floor(p.y*10.0),2.0) );\n        // yellow: pow(x,2.2), usual gamma-to-linear\n        {\n        float y = pow( p.x, 2.2 );\n        float dy = pow(p.x-dx,2.2) - y;\n        float di = abs(p.y-y)/sqrt(dx*dx+dy*dy);\n        col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 1.5, di ) );\n        }\n        // blue: approximation\n        {\n        float y = my_pow_22( p.x );\n        float dy = my_pow_22(p.x-dx) - y;\n        float di = abs(p.y-y)/sqrt(dx*dx+dy*dy);\n        col = mix( col, vec3(0.0,0.4,0.8), 1.0-smoothstep( 0.0, 2.0, di ) );\n        }\n    }\n#else    \n    // measure performance\n    float x = fragCoord.x/iResolution.x + min(iTime,0.1);\n\n    vec3 col = vec3(0.0);\n\n    float f = 0.0;\n    uint num = 100000u+min(uint(iFrame),0u);\n    for( uint i=0u; i<num; i++ )\n    {\n        float g = x+f*0.0000001;\n      //f += pow(g, 2.2);  // gamma curve\n        f += my_pow_22(g); // approximation\n    }\n    col.x = f/float(num);\n#endif\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlG3zG.jpg", "access": "api", "license": "mit", "functions": [[1575, 1575, 1603, 1603, 1625], [1627, 1669, 1697, 1741, 2223], [2226, 2226, 2283, 2283, 3521]], "test": "ok"}
{"id": "3tG3zG", "name": "Particles Text", "author": "talon", "description": "try to use 2D distance field to control movement of particles and display text\nthis simple particles system is based on iapafoto's Interactive Shoal of fish https://www.shadertoy.com/view/ldd3DB\nclick to interact with particles", "tags": ["text", "particles", "multipass"], "likes": 29, "viewed": 1139, "published": 3, "date": "1579154440", "time_retrieved": "2024-07-30T21:30:05.471976", "image_code": "vec4 Particle(float i) { return texelFetch(iChannel0, ivec2(int(i),0),0);}\n\nfloat sdParticle(vec2 uv,vec2 center){\n\treturn smoothstep(0.00,0.01,length(uv-center)-radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float dist = 1e5;\n    for(float i=0.0;i<ParticleNum;i++){\n        vec4 info = texelFetch(iChannel0,ivec2(i,0),0);\n        dist = min(sdParticle(uv,info.xy),dist);\n    }\n    // Output to screen\n    fragColor = vec4(dist);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ParticleNum iResolution.x\n#define dt 0.02\n#define RESIST 0.035\n#define radius 0.006\n#define CHAR_WIDTH 0.75\n\n// here to switch on/off INTERACTIVE MODE\n#define INTERACTIVE\n\nstruct Word{\n    int len;\n    int charsIndex[12];\n};\n\nvec2 hash(float n) { return fract(sin(vec2(n,n*7.))*43458.528); }\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( in vec2 p, float r ){\n    return length(p)-r;\n}\n\nmat2 rotate(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s,c,-c,s);\n}\n\nfloat sdCharacter(vec2 uv,int charNum){\n    float dist = 1e5;\n    switch(charNum){\n        case 1:\n            // 'A'\n            uv.x = abs(uv.x);\n            dist = min(dist ,sdLine(uv,vec2(0.0,0.4),vec2(0.3,-0.4)));\n            dist = min(dist ,sdLine(uv,vec2(0.0,0.0),vec2(0.15, 0.0)));\n            break;\n        case 2:\n            // 'B'\n            uv.y = abs(uv.y);\n            \n            uv.x += 0.1;\n            uv.x *= 0.6;\n            dist = min(dist ,abs(sdSphere(uv-vec2(0.0,0.2),0.2)));\n            dist = max(dist ,-sdSphere(uv-vec2(-3.00,0.0),2.95));\n            dist = min(dist ,sdLine(uv,vec2(-0.05,0.4),vec2(-0.05,-0.4)));\n            break;\n        case 3:\n            // 'C'\n            uv.x *= 1.2;\n            dist = min(dist ,abs(sdSphere(uv,0.38)));\n            dist = max(dist ,-sdSphere(uv*vec2(1.0,2.0)-vec2(1.05,0.0),0.85));\n            break;\n        case 4:\n            // 'D'\n            uv.x += 0.1;\n            dist = min(dist ,abs(sdSphere(uv,0.40)));\n            dist = min(dist ,sdLine(uv,vec2(-0.1,0.4),vec2(-0.1,-0.4)));\n            dist = max(dist ,-sdSphere(uv-vec2(-1.9,0.0),1.80));\n            break;\n        case 5:\n            // 'E'\n            uv.y = abs(uv.y);\n            dist = min(dist ,sdLine(uv,vec2(-0.2,0.35),vec2(0.2,0.35)));\n            dist = min(dist ,sdLine(uv,vec2(-0.2,0.0),vec2(0.2,0.0)));\n            dist = min(dist ,sdLine(uv,vec2(-0.2,0.0),vec2(-0.2,0.35)));\n            break;\n        case 6:\n            // 'F'\n            dist = min(dist ,sdLine(uv,vec2(-0.2,0.35),vec2(0.2,0.35)));\n            dist = min(dist ,sdLine(uv,vec2(-0.2,0.0),vec2(0.15,0.0)));\n            dist = min(dist ,sdLine(uv,vec2(-0.2,-0.35),vec2(-0.2,0.35)));\n            break;\n        case 7:\n            // 'G'\n            uv.x *= 1.2;\n            dist = min(dist ,abs(sdSphere(uv,0.38)));\n            dist = max(dist ,-sdSphere(uv*vec2(1.0,2.0)-vec2(1.05,0.0),0.85));\n            dist = min(dist ,sdLine(uv,vec2(0.05,-0.1),vec2(0.35,-0.1)));\n            dist = min(dist ,sdLine(uv,vec2(0.32,-0.1),vec2(0.32,-0.35)));\n            break;\n        case 8:\n            // 'H'\n            uv.x = abs(uv.x);\n            dist = min(dist ,sdLine(uv,vec2(0.2,0.35),vec2(0.2,-0.35)));\n            dist = min(dist ,sdLine(uv,vec2(0.0,0.00),vec2(0.2, 0.00)));\n            break;\n        case 9:\n            // 'I'\n            uv.y = abs(uv.y);\n            dist = min(dist ,sdLine(uv,vec2(0.12,0.35),vec2(-0.12,0.35)));\n            dist = min(dist ,sdLine(uv,vec2(0.00,0.00),vec2( 0.00,0.35)));\n            break;\n        case 10:\n            // 'J'\n            uv.x *= 2.05;\n            uv.x += 0.02;\n            dist = min(dist ,abs(sdSphere(uv,0.38)));\n            dist = max(dist ,-sdSphere(uv-vec2(0.00,1.0),1.25));\n            dist = min(dist ,sdLine(uv,vec2(0.32,0.35),vec2(0.32,-0.2)));\n            break;\n        case 11:\n            // 'K'\n            uv.x -= 0.02;\n            uv.y = abs(uv.y);\n            dist = min(dist ,sdLine(uv,vec2(-0.2,-0.35),vec2(-0.2,0.35)));\n            dist = min(dist ,sdLine(uv,vec2(-0.2, 0.00),vec2( 0.18,0.35)));\n            break;\n        case 12:\n            // 'L'\n            dist = min(dist ,sdLine(uv,vec2(-0.2,-0.35),vec2(-0.2,0.35)));\n            dist = min(dist ,sdLine(uv,vec2(-0.2,-0.35),vec2( 0.2,-0.35)));\n            break;\n        case 13:\n            // 'M'\n            uv.x = abs(uv.x);\n            dist = min(dist ,sdLine(uv,vec2(0.00,-0.25),vec2(0.25,0.35)));\n            dist = min(dist ,sdLine(uv,vec2(0.25,-0.35),vec2(0.25,0.35)));\n            break;\n        case 14:\n            // 'N'\n            dist = min(dist ,sdLine(uv,vec2(-0.25,0.35),vec2(0.25,-0.35)));\n            dist = min(dist ,sdLine(uv,vec2(0.25,-0.35),vec2(0.25,0.35)));\n            dist = min(dist ,sdLine(uv,vec2(-0.25,-0.35),vec2(-0.25,0.35)));\n            break;\n        case 15:\n            // 'O'\n            uv.x *= 1.2;\n            dist = min(dist ,abs(sdSphere(uv,0.38)));\n            break;\n        case 16:\n            // 'P'\n            uv.x += 0.1;\n            uv.x *= 0.6;\n            dist = min(dist ,abs(sdSphere(uv-vec2(0.0,0.2),0.2)));\n            dist = max(dist ,-sdSphere(uv-vec2(-3.00,0.0),2.95));\n            dist = min(dist ,sdLine(uv,vec2(-0.05,0.4),vec2(-0.05,-0.4)));   \n            break;\n        case 17:\n            // 'Q'\n            uv.x *= 1.2;\n            dist = min(dist ,abs(sdSphere(uv,0.38)));\n            dist = min(dist ,sdLine(uv,vec2(0.35,-0.35),vec2(0.10,-0.15)));\n            break;\n        case 18:\n            // 'R'\n            uv.x += 0.1;\n            uv.x *= 0.6;\n            dist = min(dist ,abs(sdSphere(uv-vec2(0.0,0.2),0.2)));\n            dist = max(dist ,-sdSphere(uv-vec2(-3.00,0.0),2.95));\n            dist = min(dist ,sdLine(uv,vec2(-0.05,0.4),vec2(-0.05,-0.4))); \n            dist = min(dist ,sdLine(uv,vec2(0.02,0.0),vec2(0.20,-0.38)));\n            break;\n        case 19:\n            // 'S'\n            vec2 t = uv;\n            float m1 = 1e5;\n            float m2 = 1e5;\n            uv -= vec2(0.0,0.2);\n            m1 = min(m1 ,abs(sdSphere(uv-vec2(0.02,0.0),0.2)));\n            uv *= rotate(2.0);\n            m1 = max(m1 ,-sdSphere(uv*vec2(1.0,0.4)-vec2(0.2,0.0),0.17));        \n            m2 = min(m2 ,abs(sdSphere(t-vec2(-0.02,0.0)-vec2(0.0,-0.2),0.2)));\n            t  *= rotate(2.0);\n            m2 = max(m2 ,-sdSphere(t*vec2(1.0,0.4)-vec2(-0.2,0.0),0.17));\n            dist = min(m1,m2);\n            break;\n        case 20:\n            // 'T'\n            dist = min(dist ,sdLine(uv,vec2(0.25,0.35),vec2(-0.25,0.35)));\n            dist = min(dist ,sdLine(uv,vec2(0.00,-0.35),vec2( 0.00,0.35)));\n            break;\n        case 21:\n            // 'U'\n            uv.x = abs(uv.x);\n            uv.x += 0.08;\n            dist = min(dist ,abs(sdSphere(uv,0.38)));\n            dist = max(dist ,-sdSphere(uv-vec2(0.00,1.),1.25));\n            dist = min(dist ,sdLine(uv,vec2(0.32,0.35),vec2(0.32,-0.2)));\n            break;\n        case 22:\n            // 'V'\n            uv.x = abs(uv.x);\n            dist = min(dist ,sdLine(uv,vec2(0.00,-0.35),vec2(0.3,0.35)));\n            break;\n        case 23:\n            // 'W'\n            uv.x = abs(uv.x);\n            dist = min(dist ,sdLine(uv,vec2(0.0,0.25),vec2(0.15,-0.30)));\n            dist = min(dist ,sdLine(uv,vec2(0.30,0.30),vec2(0.15,-0.30)));\n            break;\n        case 24:\n            // 'X'\n            uv = abs(uv);\n            dist = min(dist ,sdLine(uv,vec2(0.0,0.0),vec2(0.25,0.35)));\n            break;\n        case 25:\n            // 'Y'\n            uv.x = abs(uv.x);\n            dist = min(dist ,sdLine(uv,vec2(0.0,0.05),vec2(0.25,0.35)));\n            dist = min(dist ,sdLine(uv,vec2(0.0,0.05),vec2(0.00,-0.35)));\n            break;\n        case 26:\n            // 'Z'\n            dist = min(dist ,sdLine(uv,vec2(-0.25,0.30),vec2(0.25,0.30)));\n            dist = min(dist ,sdLine(uv,vec2(-0.25,-0.30),vec2(0.25,0.30)));\n            dist = min(dist ,sdLine(uv,vec2(-0.25,-0.30),vec2(0.25,-0.30)));\n            break;\n            \n    }\n    return dist;\n}", "buffer_a_code": "vec4 Particle(float i) { return texelFetch(iChannel0, ivec2(int(i),0),0);}\n\nfloat map(vec2 uv,Word word){\n    float dist = 1e5;\n    uv *= 3.8;\n    uv.x += CHAR_WIDTH*(float(word.len)-1.0)/2.0;\n    for(int i=0;i<word.len;i++){\n    \tdist = min(dist ,sdCharacter(uv,word.charsIndex[i]));\n        uv.x -= CHAR_WIDTH;\n    }\n    return dist;             \n}\n\nvec2 normal(vec2 uv,Word wd){\n    vec2 p = vec2(1e-4,0.0);\n\treturn normalize(vec2(map(uv,wd)-map(uv-p.xy,wd),\n                          map(uv,wd)-map(uv-p.yx,wd)));\n}\n\nvec2 sdfForce(vec2 p,Word wd){\n\treturn 256.0*normal(p.xy,wd)/(map(p.xy,wd)+100.0);\n}\n\nvoid mainImage( out vec4 Output, in vec2 uv )\n{\n    vec4 res;\n    float id = floor(uv.x);\n    if(iFrame < 5){\n    \t// initialize        \n        float k = iResolution.x/iResolution.y;\n        res = vec4(1.0*hash(id*2.723+8.213)-0.5,0.0,0.0);\n        res.x *= k;\n    }\n    else{\n        float d;\n        vec4 p = Particle(id);\n        vec2 sumF;\n        \n        // define the word to display \n        int charsIndex[12];\n        charsIndex[0] = 19;\n        charsIndex[1] = 8;\n        charsIndex[2] = 1;\n        charsIndex[3] = 4;\n        charsIndex[4] = 5;\n        charsIndex[5] = 18;\n        charsIndex[6] = 20;\n        charsIndex[7] = 15;\n        charsIndex[8] = 25;\n        Word wd = Word(9,charsIndex);\n        \n        /*\n        int talon[12];\n        talon[0] = 20;\n        talon[1] = 1 ;\n        talon[2] = 12;\n        talon[3] = 15;\n        talon[4] = 14;\n        Word td = Word(5,talon);\n\t\t*/\n        \n        // test random force\n        sumF -= (6.0*hash(iTime+id*0.1232+0.3532)-3.0);\n        \n      \t#ifdef INTERACTIVE\n        if(iMouse.z>0.5)\n        {\n            vec2 mousePos = iMouse.xy/iResolution.xy-0.5;\n            mousePos.x *= iResolution.x/iResolution.y;\n            vec2 diff = p.xy-mousePos;\n            float l = length(diff)+0.001;\n            sumF += diff/l/l/l*0.05;\n        }\n        #endif\n        \n        // move according to sdf\n        sumF -= sdfForce(p.xy,wd);\n        \n    \t// Friction    \n        sumF -= p.zw*RESIST/dt;\n        \n        // update position and velocity\n        p.zw += (sumF * dt);\n        p.xy += (p.zw * dt + sumF * dt * dt);\n        res = p;\n    }\n    // x,y : position \n    // z,w : velocity\n    Output = res;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tG3zG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 74], [76, 76, 114, 114, 172], [174, 174, 231, 231, 519]], "test": "untested"}
{"id": "wlK3Dm", "name": "Lightning flow", "author": "michael0884", "description": "More random sims with voronoi particle tracking! \n[url]JAVASCRIPT: H=location.host;E=(H?window:opener).Effect;P=E.prototype;if(!E.P)E.P=P.Paint;P.Paint=function(...A){for(i=0;i<8;i++)E.P.apply(this,A);};if(!H)close();[/url]", "tags": ["particles", "what"], "likes": 37, "viewed": 1253, "published": 3, "date": "1579131482", "time_retrieved": "2024-07-30T21:30:06.261865", "image_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tvec4 particle = texel(ch0, pos);\n    float distr = gauss(pos - particle.xy, prad);\n    vec4 flow = 0.7*texel(ch1, pos);\n    fragColor = vec4(flow.x*flow.x*vec3(0.23,0.15,1.), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//voronoi particle tracking \n\n//loop the vector\nvec2 loop_d(vec2 pos)\n{\n\treturn mod(pos + size*0.5, size) - size*0.5;\n}\n\n//loop the space\nvec2 loop(vec2 pos)\n{\n\treturn mod(pos, size);\n}\n\n\nvoid Check(inout vec4 U, vec2 pos, vec2 dx)\n{\n    vec4 Unb = texel(ch0, loop(pos+dx));\n    //check if the stored neighbouring particle is closer to this position \n    if(length(loop_d(Unb.xy - pos)) < length(loop_d(U.xy - pos)))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec2 pos, float r)\n{\n    Check(U, pos, vec2(-r,0));\n    Check(U, pos, vec2(r,0));\n    Check(U, pos, vec2(0,-r));\n    Check(U, pos, vec2(0,r));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 muv = iMouse.xy/size;\n   \n    //this pixel value\n    U = texel(ch0, pos);\n    \n    //check neighbours \n    CheckRadius(U, pos, 1.);\n    CheckRadius(U, pos, 2.);\n    CheckRadius(U, pos, 3.);\n    CheckRadius(U, pos, 4.);\n    CheckRadius(U, pos, 5.);\n    CheckRadius(U, pos, 6.);\n    CheckRadius(U, pos, 7.);\n    CheckRadius(U, pos, 8.);\n   \n    U.xy = loop(U.xy);\n    \n    //cell cloning \n   // if(length(U.xy - pos) > 7.)\n    //\tU.xy += 1.*(hash22(pos)-0.5);\n\n    //syncronizing the particles with the flow\n    \n    vec2 vel0 = pspeed*vec2(cos(U.z), sin(U.z));\n    vec4 F =  pixel(ch1, U.xy);\n    vec2 vel1 = F.yz;\n    float dangl =3.3*angle_between(vel0,vel1);\n    U.z += dt*(dangl+0.7*fbm(1.5*(U.w), 0.07*float(iFrame)*dt));\n    U.w += dt*0.4;\n \n    vec2 pvel = pspeed*vec2(cos(U.z), sin(U.z));\n    \n    //update the particle\n    U.xy += dt*pvel;\n    \n    U.xy = loop(U.xy);\n    \n    \n    if((iMouse.z > 0. && length(iMouse.xy - pos) < 30.) || (length(size.xy*vec2(0.3,0.5) - pos) < 40. || (length(size.xy*vec2(0.7,0.5) - pos) < 40.)))\n    {\n        U.xy = vec2(pdens*round(pos.x/pdens),pdens*round(pos.y/pdens));\n        U.zw = vec2(2.,2.)*PI*(hash22(U.xy) - 0.5);\n    }\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//simulation variables\n#define dt 0.25\n#define prad 0.5\n#define decay 0.14\n\n//particle speed\nfloat pspeed =20.;\n\n\n#define pdens 2.\n//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p-0.5), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p) - 0.5;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat nbase(float x)\n{\n    return mix(hash11(floor(x)),hash11(ceil(x)), fract(x));\n}\n\nfloat fbm(float x, float t)\n{\n    float a = 1., b = 1., c = 0.;\n    for(int i = 0; i < 3; i++)\n    {\n        c += a*nbase(b*x + t);\n        a *= 2.5;\n        b *= 4.5;\n    }\n    return c;\n}\n\n//functions\nfloat gauss(vec2 x, float r)\n{\n    return exp(-pow(length(x)/r,2.));\n}\nfloat gauss(float x, float r)\n{\n    return exp(-pow(x/r,2.));\n}\n   \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\n//Gradient\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n\n\nfloat angle_between(vec2 a,vec2 b)\n{\n    return atan(a.x*b.y-a.y*b.x,dot(a,b));\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}", "buffer_b_code": "//saving and diffusing the velocity trails \n\nfloat sdtrail(vec2 p)\n{\n    float de = 1e10;\n    for(float x = -2.; x <= 2.; x+=1.)\n        for(float y = -2.; y <= 2.; y+=1.)\n        {\n            vec4 particle = texel(ch0, p+vec2(x,y));\n   \t\t    vec2 pvel = pspeed*vec2(cos(particle.z), sin(particle.z));\n            de = min(de, sdLine(p, particle.xy, particle.xy - dt*pvel));\n        }\n    \n    return de;\n}\n\nfloat trail(vec2 p)\n{\n    return gauss(sdtrail(p), prad);\n}\n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    Q = texel(ch1, p);\n   \n    //diffusion equation\n    Q += 0.1*dt*Laplace(ch1, p);\n    \n    vec4 particle = texel(ch0, p);\n    \n    vec2 pvel = pspeed*vec2(cos(particle.z), sin(particle.z));\n    float distr = exp(-0.02*particle.w) * trail(p);\n    \n  \n    \n    //velocity depositing\n    Q += dt*vec4(1., pvel.x, pvel.y, 1.)*distr;\n        \n    //decay\n    Q += -dt*decay*Q;\n    \n    if(iFrame < 1) Q = vec4(0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//voronoi particle tracking \n\n//loop the vector\nvec2 loop_d(vec2 pos)\n{\n\treturn mod(pos + size*0.5, size) - size*0.5;\n}\n\n//loop the space\nvec2 loop(vec2 pos)\n{\n\treturn mod(pos, size);\n}\n\n\nvoid Check(inout vec4 U, vec2 pos, vec2 dx)\n{\n    vec4 Unb = texel(ch0, loop(pos+dx));\n    //check if the stored neighbouring particle is closer to this position \n    if(length(loop_d(Unb.xy - pos)) < length(loop_d(U.xy - pos)))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec2 pos, float r)\n{\n    Check(U, pos, vec2(-r,0));\n    Check(U, pos, vec2(r,0));\n    Check(U, pos, vec2(0,-r));\n    Check(U, pos, vec2(0,r));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 muv = iMouse.xy/size;\n   \n    //this pixel value\n    U = texel(ch0, pos);\n    \n    //check neighbours \n    CheckRadius(U, pos, 1.);\n    CheckRadius(U, pos, 2.);\n    CheckRadius(U, pos, 3.);\n    CheckRadius(U, pos, 4.);\n    CheckRadius(U, pos, 5.);\n    CheckRadius(U, pos, 6.);\n    CheckRadius(U, pos, 7.);\n    CheckRadius(U, pos, 8.);\n   \n    U.xy = loop(U.xy);\n    \n    //cell cloning \n   // if(length(U.xy - pos) > 7.)\n    //\tU.xy += 1.*(hash22(pos)-0.5);\n\n    //syncronizing the particles with the flow\n    \n    vec2 vel0 = pspeed*vec2(cos(U.z), sin(U.z));\n    vec4 F =  pixel(ch1, U.xy);\n    vec2 vel1 = F.yz;\n    float dangl =3.3*angle_between(vel0,vel1);\n    U.z += dt*(dangl+0.7*fbm(1.5*(U.w), 0.07*float(iFrame)*dt));\n    U.w += dt*0.4;\n \n    vec2 pvel = pspeed*vec2(cos(U.z), sin(U.z));\n    \n    //update the particle\n    U.xy += dt*pvel;\n    \n    U.xy = loop(U.xy);\n    \n    \n    if((iMouse.z > 0. && length(iMouse.xy - pos) < 30.) || (length(size.xy*vec2(0.3,0.5) - pos) < 40. || (length(size.xy*vec2(0.7,0.5) - pos) < 40.)))\n    {\n        U.xy = vec2(pdens*round(pos.x/pdens),pdens*round(pos.y/pdens));\n        U.zw = vec2(2.,2.)*PI*(hash22(U.xy) - 0.5);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//saving and diffusing the velocity trails \n\nfloat sdtrail(vec2 p)\n{\n    float de = 1e10;\n    for(float x = -2.; x <= 2.; x+=1.)\n        for(float y = -2.; y <= 2.; y+=1.)\n        {\n            vec4 particle = texel(ch0, p+vec2(x,y));\n   \t\t    vec2 pvel = pspeed*vec2(cos(particle.z), sin(particle.z));\n            de = min(de, sdLine(p, particle.xy, particle.xy - dt*pvel));\n        }\n    \n    return de;\n}\n\nfloat trail(vec2 p)\n{\n    return gauss(sdtrail(p), prad);\n}\n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    Q = texel(ch1, p);\n   \n    //diffusion equation\n    Q += 0.1*dt*Laplace(ch1, p);\n    \n    vec4 particle = texel(ch0, p);\n    \n    vec2 pvel = pspeed*vec2(cos(particle.z), sin(particle.z));\n    float distr = exp(-0.02*particle.w) * trail(p);\n    \n  \n    \n    //velocity depositing\n    Q += dt*vec4(1., pvel.x, pvel.y, 1.)*distr;\n        \n    //decay\n    Q += -dt*decay*Q;\n    \n    if(iFrame < 1) Q = vec4(0);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlK3Dm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 234]], "test": "untested"}
{"id": "wlVGDm", "name": "[twitch] Four Regular Solids", "author": "yx", "description": "I stream shader creation live, over at [url]https://twitch.tv/lunasorcery[/url]\nCome and watch a show!\n\nOr watch the VOD for this shader here: [url]https://www.twitch.tv/videos/536586403[/url]", "tags": ["raymarch", "sdf", "escher", "polyhedra", "twitch"], "likes": 43, "viewed": 1176, "published": 3, "date": "1579127718", "time_retrieved": "2024-07-30T21:30:07.006873", "image_code": "/*\n    This shader was created live on stream!\n    You can watch the VOD here: https://www.twitch.tv/videos/536586403\n\n    I use the Bonzomatic tool by Gargaj/Conspiracy:\n    https://github.com/Gargaj/Bonzomatic\n\n    I stream at https://twitch.tv/lunasorcery\n    Come and watch a show!\n\n    ~yx\n*/\n\nfloat phi = (1.+sqrt(5.))*.5;\n#define spinSpeed (iTime*.5)\n\nmat2 rotate(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(\n\t\tc,-s,\n\t\ts,c\n\t);\n}\n\nfloat sdIcosahedron(vec3 p, float r)\n{\n\tfloat q = (sqrt(5.)+3.)/2.;\n\n\tvec3 n1 = normalize(vec3(q,1,0));\n\tvec3 n2 = vec3(sqrt(3.)/3.);\n\n\tp = abs(p/r);\n\tfloat a = dot(p, n1.xyz);\n\tfloat b = dot(p, n1.zxy);\n\tfloat c = dot(p, n1.yzx);\n\tfloat d = dot(p, n2.xyz)-n1.x;\n\treturn max(max(max(a,b),c)-n1.x,d)*r;\n}\n\nfloat sdDodecahedron(vec3 p, float r)\n{\n\tp = abs(p);\n\tp += phi*p.zxy;\n\treturn (max(max(p.x,p.y),p.z)-r*phi) / sqrt(phi*phi+1.);\n}\n\n\nfloat sdRhombicTriacontahedron(vec3 p, float r)\n{\n    float l = phi*2.;\n    \n    p = abs(p);\n    float a = max(max(p.x,p.y),p.z);\n    p += (p+p.yzx)*phi+p.zxy;\n    return max(a, max(p.x,max(p.y,p.z))/l)-r;\n}\n\nfloat sdHexahedron(vec3 p, float r)\n{\n    p = abs(p)-r;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat sdOctahedron(vec3 p, float r)\n{\n    return (dot(abs(p),vec3(1))-r)/sqrt(3.);\n}\n\nfloat sdRhombicDodecahedron(vec3 p, float r)\n{\n    p = abs(p);\n    p += p.yzx;\n    return (max(max(p.x,p.y),p.z)-r) * sqrt(.5);\n}\n\n\nint mat,matHack;\nfloat scene1(vec3 p)\n{\n\tp.xz *= rotate(spinSpeed);\n\t\n\tfloat dodec = sdDodecahedron(p,1.);\n\tfloat icos = sdIcosahedron(p.zyx,1.);\n\t\n\tfloat unity = min(dodec,icos);\n\tfloat intersect = max(dodec,icos);\n\t\n\tfloat innerEdges = max(intersect-.004, -unity);\n\tfloat outerEdges = max(unity-.001, -sdRhombicTriacontahedron(p.zyx,1.));\n\t\n\tfloat best = unity;//min(union,min(outerEdges, innerEdges));\n\tif (best == dodec)\n\t\tmatHack = 0;\n\telse if (best == icos)\n\t\tmatHack = 1;\n\telse if (best == outerEdges)\n\t\tmatHack = 2;\n\telse\n\t\tmatHack = 3;\n\treturn best;\n}\n\nfloat scene2(vec3 p)\n{\n\tp.xz *= rotate(spinSpeed);\n\t\n\tfloat hexa = sdHexahedron(p,.5);\n\tfloat octa = sdOctahedron(p,1.);\n\t\n\tfloat unity = min(hexa, octa);\n\tfloat intersect = max(hexa, octa);\n\t\n\tfloat innerEdges = max(intersect-.004, -unity);\n\tfloat outerEdges = max(unity-.001, -sdRhombicDodecahedron(p.zyx,1.));\n\t\n\tfloat best = unity;//min(union,min(outerEdges, innerEdges));\n\tif (best == hexa)\n\t\tmatHack = 4;\n\telse if (best == octa)\n\t\tmatHack = 5;\n\telse if (best == outerEdges)\n\t\tmatHack = 6;\n\telse\n\t\tmatHack = 7;\n\treturn best;\n}\n\nvec3 hatching(vec2 uv, vec2 dir, vec3 n, vec3 darkCol, vec3 lightCol, float density, float fade, float ao)\n{\n\tuv *= density;\n\tfloat light = dot(n,normalize(vec3(1,3,1)))*.5+.5;\n\tlight *= ao;\n\tlight += fade;\n\t//return vec3(light);\n\tlightCol = mix(lightCol,vec3(1),fade);\n\tfloat p = dot(uv, normalize(dir));\n\tfloat d = abs(fract(p)-.5)+(light*.5-.5);\n\tfloat e = dFdy(uv.y);//(density/80.)*.1;\n\treturn darkCol + smoothstep(-e,e,d) * (lightCol-darkCol);\n}\n\nfloat screenHatching(vec2 uv, vec2 dir, float light)\n{\n\tfloat p = dot(uv, normalize(dir));\n\tfloat d = abs(fract(p)-.5)+(light*.5-.5);\n\tfloat e = dFdy(uv.y);//.1;\n\treturn smoothstep(-e,e,d);\n}\n\nvec3 shade(vec2 uv, vec3 n, float ao)\n{\n\tfloat fade = sin(iTime*.5)*.5+.5;\n\t\n\tif (mat == 3) {\n\t\treturn mix(vec3(0),vec3(1),fade);\n\t} else if (mat == 2) {\n\t\treturn vec3(1);\n\t} else if (mat == 1) {\n\t\treturn hatching(uv, vec2(1,.5), n, vec3(0), vec3(1), 80., fade, ao);\n\t} else if (mat == 0) {\n\t\treturn hatching(uv, vec2(.5,-1), n, vec3(0), vec3(1/*,.7,.5*/), 80., fade, ao);\n\t} else if (mat == 7) {\n\t\treturn vec3(1,0,0);\n\t} else if (mat == 6) {\n\t\treturn vec3(1,0,0);\n\t} else if (mat == 5) {\n\t\treturn hatching(uv, vec2(1,-.1), n, vec3(1,0,0), vec3(1), 200., (1.-fade)*.3, ao);\n\t} else if (mat == 4) {\n\t\treturn hatching(uv, vec2(.1,1), n, vec3(1,0,0), vec3(1), 200., (1.-fade)*.3, ao);\n\t}\n}\n\nvec3 trace1(vec3 cam, vec3 dir, vec2 uv)\n{\n\tfloat t=0.;\n\tfloat k=0.;\n\tfor(int i=0;i<100;++i) {\n\t\tk = scene1(cam+dir*t);\n\t\tt += k;\n\t\tif (abs(k)<.001)\n\t\t\tbreak;\n\t}\n\tmat = matHack;\n\t\n\tif (abs(k)<.001)\n\t{\n\t\tvec3 h = cam+dir*t;\n\t\tconst vec2 o = vec2(0.001,0);\n\t\tvec3 n = normalize(vec3(\n\t\t\tscene1(h+o.xyy)-scene1(h-o.xyy),\n\t\t\tscene1(h+o.yxy)-scene1(h-o.yxy),\n\t\t\tscene1(h+o.yyx)-scene1(h-o.yyx)\n\t\t));\n\t\t\n\t\tfloat aoDist = scene1(h+n*.2);\n\t\tfloat ao = pow(aoDist/.2,.8);\n\t\t\n\t\treturn shade(uv, n, ao);\n\t}\n\treturn vec3(1);\n}\n\nvec3 trace2(vec3 cam, vec3 dir, vec2 uv)\n{\n\tfloat t=0.;\n\tfloat k=0.;\n\tfor(int i=0;i<100;++i) {\n\t\tk = scene2(cam+dir*t);\n\t\tt += k;\n\t\tif (abs(k)<.001)\n\t\t\tbreak;\n\t}\n\tmat = matHack;\n\t\n\tif (abs(k)<.001)\n\t{\n\t\tvec3 h = cam+dir*t;\n\t\tconst vec2 o = vec2(0.001,0);\n\t\tvec3 n = normalize(vec3(\n\t\t\tscene2(h+o.xyy)-scene2(h-o.xyy),\n\t\t\tscene2(h+o.yxy)-scene2(h-o.yxy),\n\t\t\tscene2(h+o.yyx)-scene2(h-o.yyx)\n\t\t));\n\t\t\n\t\tfloat aoDist = scene2(h+n*.2);\n\t\tfloat ao = pow(aoDist/.2,.5);\n\t\t\n\t\treturn shade(uv, n, ao);\n\t}\n\treturn vec3(1);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 cam = vec3(0,0,-5);\n\tvec3 dir = normalize(vec3(uv,1.5));\n\t\n\tcam.yz *= rotate(0.2);\n\tdir.yz *= rotate(0.2);\n\t\n\tvec3 color1 = trace1(cam, dir, uv);\n\tvec3 color2 = trace2(cam, dir, uv);\n\t\n\tfragColor.rgb = clamp(color1*color2,0.,1.);\n\tfragColor.rgb *= mix(vec3(0), vec3(1), screenHatching(uv*80., vec2(1,4), 1.3-dot(uv,uv)*.5));\n\tfragColor.rgb = mix(vec3(.2), vec3(1,.9,.8), fragColor.rgb);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 359, 380, 380, 448], [450, 450, 488, 488, 753], [755, 755, 794, 794, 884], [887, 887, 936, 936, 1094], [1096, 1096, 1133, 1133, 1187], [1189, 1189, 1226, 1226, 1273], [1275, 1275, 1321, 1321, 1404], [1424, 1424, 1446, 1446, 1967], [1969, 1969, 1991, 1991, 2500], [2502, 2502, 2610, 2610, 2953], [2955, 2955, 3009, 3009, 3146], [3148, 3148, 3187, 3187, 3834], [3836, 3836, 3878, 3878, 4350], [4352, 4352, 4394, 4394, 4866], [4868, 4868, 4920, 4920, 5400]], "test": "untested"}
{"id": "WtVGDm", "name": "Day 27 - A Sewer", "author": "jeyko", "description": "It's a sewer.\nTakes a while to converge", "tags": ["pathtracer", "mdtmjvm"], "likes": 7, "viewed": 436, "published": 3, "date": "1579126350", "time_retrieved": "2024-07-30T21:30:07.757865", "image_code": "\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U / iResolution.xy;\n    \n    C = T(U);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n\n#define mx (20.*iMouse.x/iResolution.x)\n#define my (20.*iMouse.y/iResolution.x)\n#define pmod(p,x) mod(p, x) - x*0.5\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nMaterial materials[7] = Material[](\n\tMaterial(vec3(1.,0.4,1)*1.1,0.,1., 0.), // wall\n\tMaterial(vec3(0.9,1.,0.9)*1.0,0.1,1., 0.), // Wall\n\tMaterial(vec3(1.07,1.05,1)*1.,0.0,1., 60.), \t\t// Light\n\tMaterial(vec3(0.9,0.8,0.8)*1.0,0.6,0.2, 0.), // Red Rust\n\tMaterial(vec3(1.,1.,1.)*0.4,0.7,0.14, 0.), // Wires\n\tMaterial(vec3(0.9,1.,0.9)*1.0,0.6,0.9, 0.), //\n\tMaterial(vec3(0.4,0.5,0.7)*1.0,1.,0.3, 0.) // \n);  \n\n\nvec3 getRd(vec3 o, vec3 lookAt, vec2 uv) {\n    uv += (hash(uv.x + uv.y + float(iFrame)) - 0.5  )*0.002;\t\t\t// thx slerpy\n    vec3 dir = normalize(lookAt - o);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return dir + right*uv.x*fov + up*uv.y*fov;\n}\n\n// ----------------- SDFs ----------------- //\nfloat sdBox (vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.x, max(p.y, p.z));\n}    \nfloat sdSphere (vec3 p, float s){\n\treturn length(p) - s;\n}\nfloat sdFloorA (vec3 p){\n    return p.y;\n}\nfloat sdWall (vec3 p){\n    return -p.x;\n}\nfloat sdBackWall (vec3 p){\n    return -p.z;\n}\n\n#define pmod(p, x) mod(p, x) - x*0.5\n\n#define outerW 17.\n\n \n\nvec2 sdMain(vec3 p){\n\tvec2 d = vec2(10e10);\n    \n    float repDistY = 8.;\n    float qRepDistY = 30.;\n    float idY = floor(p.y/repDistY);\n    float rA = r11(idY);\n    float rB = r11(idY + 0.2);\n    float rC = r11(idY + 0.6);    \n\n    float repsXZ = 2. + floor(rA*1.99);\n\n    vec3 q = p;\n    q.y = pmod(q.y, qRepDistY);\n        \n    p.xz *= rot(rA*PI*30.);\n    \n    \n    q = abs(q);\n    q.x -= outerW;\n    vec3 v = q;\n    vec3 s = vec3(0.9, 10., 1.6);\n    // WallBox\n    \n    q.x += 0.5;\n    \n    d = dmin(d, sdBox(q, s), 5.);\n    q = abs(q);\n    for(int i = 0; i < 4; i++){\n    \tq = abs(q);\n    \tq.xz *= rot(0.25*PI);\n    }\n    q.xy *= rot(0.1*PI);    \n    q.x += 1.4;\n    // WallBox\n    d = dmax(d, -sdBox(q, s*0.9), 1.);\n    \n    d = dmin(d, sdBox(v, s*0.9), 2.);\n\n    vec3 polarQ = vec3(\n        length(q),\n    \tatan(q.y,q.x),\n        acos(p.z/length(p))\n    );\n     \n    // Outer\n    d = dmin(d, -(length(p.xz) - outerW) - T1(vec2(p.y*.5, 5.*atan(p.z, p.x)/tau)).x*7.95, 1.)  ;\n   \n    // Center\n    d = dmin(d,   max(abs(p.x)-1.,abs(p.z) -1.), 3.);\n    //d.x = min(d.x, length(p.xz) - 1.);\n    \n    vec3 n = p;\n    float pId = floor(3.*atan(p.x,p.z)/tau);\n    pModPolar(p.xz, repsXZ);\n    pModPolar(n.xz, repsXZ);\n    p.y = pmod(p.y, repDistY);\n    \n    p.xz *= rot(0.5*PI);\n    \n    // Lines\n    p.y -= repDistY*0.5;\n    p.y += (1. + 3.*sin(pId*5214.))*sin((length(p.xz)/outerW)*PI);\n    d = dmin(d, length(p.yx) - 0.1, 4.) ;\n    \n    // Pipes\n    q.y -= 9.6;\n    q.x += 19.5;\n    \n    q.xz *= rot(0.2);\n    //q.y -= 2.*sin((length(q.xz)/outerW)*PI);\n    d = dmin(d, length(q.yx) - 0.5, 6.) ;\n    \n    d.x *= 0.74;\n    \n    return d;\n}\n\nvec3 glow = vec3(0);\n\n// ----------------- MAP ----------------- //\n#define HEIGHT\nObject map(vec3 p) {\n    Object o = NewObject;\n    \n    vec2 dMain = sdMain(p);\n    \n\tObject mainScene = Object(\n    \tdMain.x,\n        true,\n        materials[int(dMain.y)]\n    );\n    \n    o = omin(o, mainScene);\n    //o = omin(o, length(p) - 4., materials[2]);\n\t\n    glow += exp(-o.d*1.);    \n    o.didHit = true;\n    return o;\n}\n\nObject trace(vec3 ro, vec3 rd) {\n    vec3 p = ro + rd*0.2;\n    float t = 0.;\n    for (int i = 0; i < MARCH_ITERATIONS; i++) {\n    \tObject obj = map(p);\n        \n        if (obj.d < 0.001) {\n            obj.d = t;\n        \treturn obj;\n            break;\n        }\n        \n        if (t > 300.) {\n            obj.didHit = false;\n            return obj;\n        \tbreak;\n        }\n    \n        t += obj.d;\n        p = ro + rd*t;\n    }\n\n\n}\n\nvec3 getNormal(vec3 p) {\n\tvec2 t = vec2(0.001,0.);    \n    return normalize(vec3(\n    \tmap(p + t.xyy).d - map(p - t.xyy).d,\n    \tmap(p + t.yxy).d - map(p - t.yxy).d,\n    \tmap(p + t.yyx).d - map(p - t.yyx).d\n    ));\n}\n\n// ----------------- MAIN ----------------- //\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    vec2 uv = (U - 0.5*iResolution.xy)/iResolution.y;\n    uv -= normalize(uv)*pow(length(uv)*0.34,3.);\n    vec2 uvs = (U/R);\n\n    vec4 col = T(U);\n\t\n    vec3 accum = vec3(0);\n    vec3 attenuation = vec3(1.);\n    \n    vec3 ro = vec3(3.,-0.09,0.);\n    float r = 2.2;\n    ro.xz -= vec2(sin(r), cos(r)) * zoom;\n\n    vec3 lookAt = vec3(1.0,24,0);\n    vec3 rd = getRd(ro, lookAt, uv);\n    rd.xy *= rot(0.2);\n    vec3 dir = rd;\n    float seed = hash(float(iFrame) + uv.x*243.124 + uv.y*212.512);\n    \n    float dFirst = 0.;\n    bool hitBg = false;\n    int i = 0;\n    for (; i < BOUNCES; i++){\n    \tObject obj = trace(ro, rd);\n        if (obj.didHit) {       \n            if (i == 0){\n                dFirst = obj.d;\n            }\n            vec3 p = ro + rd * obj.d;  \t\t\t\t\n    \t\tvec3 N = getNormal(p);\n            accum += obj.material.albedo*obj.material.emissiveness*attenuation;\n\t\t\t//accum += ;\n            attenuation *= obj.material.albedo;\n            attenuation *= 1./PI; // thx slerpy\n            //accum += obj.material.albedo * attenuation;\n            //seed += 14.5;\n            seed = hash22(float(iFrame) + vec2(uv) + float(i)*1. ).x;\n            ro = p;\n                        \n            rd = mix(cosineDirection(seed, N),N,obj.material.metalness);\n            \n        } else {\n            hitBg = true;\n            break;\n        }\n        \n    }\n    float light = 1.5*step(.7,dot(rd,normalize(vec3(0.01,-1,0.01))));\n    //accum *= light;\n    //col.xyz += accum;\n\n    //col.xyz -= glow*0.001;\n    if (iFrame == 0) {\n        col.w = 0.;\n        col.xyz = vec3(0.);\n    }\n\n    col.w += 1.;\n    //col.xyz = vec3(dFirst);\n    col.xyz += accum;    \n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RAND 2\n\n#define fov 0.7\n#define BOUNCES 4\n#define MARCH_ITERATIONS 160\n#define zoom 9.\n\n\n#define bdist 0.00\n#define PI 3.14159265359\n\n#define R (iResolution.xy)\n#define T(UV) texture(iChannel0, UV/R)\n#define T1(UV) texture(iChannel1, UV/R)\n#define tau (2.*PI)\n\n\nfloat r11(float i){return fract(sin(i*8124.124124)*123.2412);}\nvec3 r13(float i){return vec3(r11(i),r11(i + 0.2),r11(i + 0.4));}\nfloat r11c(float i){return fract(sin(i*8124.124124));} // cheaper\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n#define BLUR_AMT (1.)\n//#define FOCUS_DISTANCE (0.1 + (0.5 + sin(iTime)*0.5))\n#define FOCUS_DIV 3.\n//#define FOCUS_DIdSTANCE (0.1 + (FOCUS_DIV + sin(iTime)*FOCUS_DIV))\n#define FOCUS_DISTANCE (2.5)\n#define SRGBLIN\n\n#define dmin(a, b, mat) a.x < b ? a : vec2(b, mat)\n#define dmax(a, b, mat) a.x > b ? a : vec2(b, mat)\n\n#if RAND == 1\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125 + u.z*12525.215215215)*124115.125235);\n}\n#elif RAND == 2\n// by Dave Hoskins\nfloat r31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n#endif\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n// hg_sdf\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\nstruct Material {\n    vec3 albedo;\n\tfloat metalness; \n\tfloat roughness; \n\tfloat emissiveness;\n};\n\nstruct Light {\n\tvec3 colour;\n    vec3 pos;\n\tfloat intensity;\n};\nLight lights[1] = Light[](\n    Light(vec3(1.2,1.2,1), vec3(-0.,10.,0.), 0.)\n);    \n\nstruct Object {\n\tfloat d;\n    bool didHit;\n\tMaterial material;\n};\nObject omin(Object a, float bdistance, Material bmaterial) {\n    if (a.d < bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\nObject omin(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, float bdistance, Material bmaterial) {\n    if (a.d > bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\n\n\n#define NewObject Object(1e8,false,materials[0])\n\n\n\n\n// by fizzer: http://www.amietia.com/lambertnotangent.html\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}", "buffer_b_code": "#define C fragColor\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    vec2 uv = U/R;\n    uv.y -= 0.5;\n\n    vec4 tex = T(U);\n    fragColor = tex;\n    fragColor.xyz /= fragColor.w;\n    \n    fragColor *= 1.;\n    fragColor = 1.*fragColor/(1.0+max(fragColor.x,max(fragColor.y,fragColor.z)));\n    //vec3 fogColor =  mix(vec3(0.6,.26,0.119)*0.05, vec3(0.5,.16,0.319)*0.09, uv.y)*0.2;\n    //fragColor.xyz = mix(fragColor.xyz,fogColor, pow(smoothstep(0.,1.,fragColor.w*0.19 - 0.9), 1.04));\n    //fragColor.xyz = clamp(fragColor.xyz, 0.03,1.);\n    \n    C = smoothstep(0.05,0.8,C);\n    C.xyz*= vec3(0.96,0.9,0.95);\n    //C = smoothstep(0.01,1.,C);\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545));\n    \n    C *= 1. - mix(0.,1., pow(smoothstep(0.,1.,length(uv))*0.8, 3.6));\n    C *= 2.6;\n    //fragColor.xyz = smoothstep(0.,1.,fragColor.xyz); // thx to yx for smoothstep col\n    \n    //fragColor.xyz = smoothstep(0.,1.,pow(fragColor.xyz, vec3(0.8)));\n}   ", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Texture generation\n\nfloat sdBox(vec2 p, vec2 s){\n\t p = abs(p) - s;\n\treturn max(p.x, p.y);\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    // thx alkama for giving idea for similar texture\n\tvec2 p = (U - 0.5*R)/R.y;\n    if (iFrame < 4){\n        for (float i = 0.; i < 10.; i++){\n            vec3 r = r13(i);\n            vec2 z = p - (r.xy*2. - 1.)*1.; \n            vec2 s = r.yz + 0.2; \n        \tC += smoothstep(0.11,0.1, sdBox(z, s));\n        }\n        C /= 10.;\n    } else {\n    \tC = T(U);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVGDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 44, 44, 99]], "test": "untested"}
{"id": "Wt3Gz4", "name": "My second raymarched scene", "author": "maksy", "description": "My second raymarched scene. Thanks to iq and BigWIngs / The Art of Code for great tutorials.", "tags": ["raymarching"], "likes": 2, "viewed": 400, "published": 3, "date": "1579125093", "time_retrieved": "2024-07-30T21:30:08.503870", "image_code": "#define PI 3.141592\n#define MAX_STEPS 150\n#define MAX_DIST 100.0\n#define SURF_DIST .01\n\n#define GROUND 0\n#define SKY 1\n#define SPHERE 2\n#define SHELL 3\n#define BOX 4\n\n#define SKY_COLOR vec3(0.1, 0.1, 0.15)\n\nstruct Obj {\n\tint type;\n    float d;\n    vec3 hitPos;\n};\n    \nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat rand2(float x){\n    return fract(sin(x)*43758.5453123);\n}\n\nmat2 rotation(float angle) {\n\tfloat s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    return length(max(abs(p)-s, 0.0));\n}\n\nfloat sdSphere(vec3 p, vec4 s) {\n    return length(p-s.xyz)-s.w;\n}\n\n// Value noise\n// from the book of shader\nfloat noise(in vec2 uv) {\n   \n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth\n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n/*\n * Fractal Brownian Motion adds different iterations of noise (octaves) \n * by incrementing the frequencies in regular steps and decrease the amplitude \n * of the noise. It makes the noise more granular and add more fine details.\n*/\nfloat fbm(in vec2 uv, int octaves) {\n    \n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise(uv);\n        uv *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nObj getDist(vec3 p) {\t\n    \n    // distance to the ground\n    float height = fbm(vec2(p.x, p.z), 7); \n    float planeDist = p.y - height;\n    \n    // distance to the surface of sphere\n    vec4 s = vec4(4, 1., 4, 0.8);\n    float sphereDist =  sdSphere(p, s);\n    \n     // distance to the surface of shell\n    vec3 plane = vec3(2, 2, 1.5);\n    plane.xz *= rotation(2.45);\n    \n    float slice = dot(p, normalize(plane));   \n    vec4 s2 = vec4(0.8, 0.93, -2.6, 0.6);\n    \n    float shellDist = sdSphere(p, s2);\n    shellDist = max(abs(shellDist)-.03, slice);\n    \n    // distance to the surface of the twisted box\n    vec3 bp = p-vec3(-3,1,1);\n    bp.xz *= rotation(bp.y*2.6);\n    \n    float boxDist = sdBox(bp, vec3(0.2, 3.0, 0.2)) * 0.4;\n    \n    Obj obj = Obj(GROUND, planeDist, p);\n    \n    if (sphereDist < obj.d) {\n    \tobj = Obj(SPHERE, sphereDist, p);\n    }\n  \n    if (shellDist < obj.d) {\n    \tobj = Obj(SHELL, shellDist, p);\n    }\n     \n    if (boxDist < obj.d) {\n    \tobj = Obj(BOX, boxDist, p);\n    }\n    \n    return obj;\n}\n\nObj rayMarch(vec3 ro, vec3 rd) {\n\t\n    float t = 0.0;\n    \n    Obj hitObj = Obj(SKY, t, ro + rd);\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \t\n        vec3 p = ro + rd*t;\n        hitObj = getDist(p);      \n        t += hitObj.d;\n        \n        // the ray has marched far enough but hit nothing. \n        // Render the pixel as a part of the sky.\n        if (t > MAX_DIST) {\n        \thitObj = Obj(SKY, t, p);\n            break;\n        }\n\n        // the ray has marched close enough to an object\n        if (abs(hitObj.d) < SURF_DIST) {\n            hitObj = Obj(hitObj.type, t, p);\n        \tbreak;\n        }\n        \n        hitObj.d = t;\n    }\n    \n    return hitObj;\n}\n\nvec3 getNormal(vec3 p) \n{\n\tfloat d = getDist(p).d;\n    \n    // use offset samples to compute normal\n    vec2 e = vec2(0.01, 0);    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).d,\n        getDist(p-e.yxy).d,\n        getDist(p-e.yyx).d);\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 lightPos) {\n    \n    // compute the light vector and its normal   \n    lightPos.xz += vec2(sin(iTime*0.5), cos(iTime*0.5))*1.4;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    \n    // calculate diffuse lightning\n    // dot product gives values between -1 to 1 hence the range\n    // is clamped to 0 to 1\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    // Add shadow\n    // raymarch to the direction of light. If the ray hits something that's\n    // closer than the light there's an object between and shadow can be added\n    float d = rayMarch(p+n*SURF_DIST*2.0, l).d;\n    \n    if(d < length(lightPos-p)) {\n        dif *= 0.1;\n    }\n    \n    return dif;\n}\n\n// From the book Texturing & Modeling: A Procedural Approach\nvec3 star(vec2 pos, float npoints, float rmin, float rmax)\n{\n    // calculates how wide the angle between two points of the star is\n    float starAngle = 2.0*PI/npoints;\n\t\n    // polar coordinates of the given point\n    float angle = atan(pos.x, pos.y) + PI;\n\tfloat radius = length(pos);\n    \n    // transforms the coordinates into new feature space in which\n    // the range between two points is set to 0 to 1. If the point lies \n    // in the upper half of the \"V\" shape the point is reflected to the\n    // lower half through the center line. This is done to avoid checking \n    // both edges and is possible due to symmetry.\n    angle = mod(angle, starAngle) / starAngle;\n    if (angle >= 0.5) {\n\t\tangle = 1.0 - angle;\n    }\n    \n    // the tip of a point of the star\n    vec3 p0 = vec3(rmax, 0, 0);\n    // the point lying in the middle of the two points at radius rmin\n    // from the center\n\tvec3 p1 = rmin * vec3(cos(starAngle/2.0) - 0.45, sin(starAngle/2.0) - 0.45, 0.0);\n    \n    // vector from the tip of the star point to the point at rmin radius\n    // from the centre \n    vec3 d0 = p1 - p0; \n    // vector from the the tip to the current position\n    vec3 d1 = radius * vec3(cos(angle), sin(angle), 0) - p0;\n    \n    // cross product will point along the positive z-axis or along the negative\n    // z-axis. The direction is determined by whether the first vector is \n    // to the left or to the right of the second vector. Hence, the direction\n    // of the cross product tells which side of the edge d0 and if it's inside\n    // the star or not.\n    vec3 direction = cross(d0, d1);\n    \n\tfloat in_out = smoothstep(0.0, 0.03, direction.z);\n\tvec3 bgColor = vec3(0.0);    \n    \n    vec3 col = mix(bgColor, vec3(1.0), in_out / length(pos));\n    \n    return col;\n}\n\n// Analytically box-filtered checkerboard by iq\nfloat checkersTextureGradBox(in vec2 p, in vec2 ddx, in vec2 ddy) {\n\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\nvec2 texCoords(in vec3 pos, in vec4 sc0) {\n    vec3 q = normalize(pos - sc0.xyz);\n    vec2 matuv = vec2(atan(q.x,q.z), acos(q.y )) * sc0.w;\n\n    return 2.0*matuv;\n}\n\nvec3 fog(vec3 color, float d, vec3 camDir, vec3 sunDir, float extintion, float inscattering) {\n\n    float sunAmount = max(dot(camDir, sunDir), 0.0);\n    vec3 fogColor = mix(vec3(0., 0., 0.), vec3(1.0, 0.9, 0.7), pow(sunAmount, 8.0));\n    return (color * exp(-d * extintion)) + (fogColor * (1.0 - exp(-d * inscattering)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // normalize coordinates ranging from -0.5 to 0.5 and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n   \n    vec3 col = SKY_COLOR;\n    \n    // camera\n    vec3 ro = vec3(.5, 2, -8);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    Obj hitObj = rayMarch(ro, rd);\n\n    vec3 LIGHT_DIR = vec3(-1, 4, -6);\n    \n    if (hitObj.type == SKY) {\n        \n        // add one pixel wide star\n        float twinkle = dot(length(sin(uv + iTime*0.05)), \n                            length(cos(uv*vec2(22.67)-iTime*0.05)));\n        twinkle = sin(twinkle*10.0)*0.5+0.5;\n        col += vec3(pow(rand(uv), 780.0)) * twinkle;\n        \n        // add the stars with points    \n        vec3 starColor = vec3(1.0000,0.5161, 0.0000);\n\t\tvec3 bgColor = vec3(0.0);\n    \n    \tfloat rmin = 15.36 / iResolution.x*1.4;\n    \tfloat rmax = 0.12;\n    \n\t\tcol += star(uv-vec2(0.4, 0.3), 4.0, rmin, rmax);\n        col += star(uv-vec2(0.7, 0.4), 4.0, rmin, rmax);\n        col += star(uv-vec2(0.6, 0.2), 4.0, rmin, rmax);\n        col += star(uv+vec2(0.2, -0.25), 4.0, rmin, rmax);\n        col += star(uv+vec2(0.15, -0.4), 4.0, rmin, rmax);\n        col += star(uv+vec2(0.66, -0.11), 4.0, rmin, rmax);\n        col += star(uv+vec2(0.06, -0.11), 4.0, rmin, rmax);\n        col += star(uv+vec2(0.7, -0.35), 4.0, rmin, rmax);\n        \n        // add moon\n      \t\n        // first, change the background to solid color\n        float moon = step(0.01, length(uv-vec2(0.20,0.25))-0.09);\n        col *= moon;\n        col += (1.0-moon) * SKY_COLOR;\n        \n        \n        // add two circles almost on top of each other\n        moon = smoothstep(0.001, -0.009, length(uv-vec2(0.20,0.25))-0.09);\n        col += vec3(moon);      \n        \n        moon = smoothstep(-0.01, 0.06, length(uv-vec2(0.26, 0.26))-0.095);\n        col *= moon;\n        col += (1.0-moon) * SKY_COLOR;\n            \n      \n        // add mountains\n        uv *= 10.0;\n    \tfloat i = floor(uv.x);\n  \t    float f = fract(uv.x);\n    \n    \tfloat s = rand2(uv.x);\n    \n    \tfloat pct = smoothstep(-0.01, 0.01, s-uv.y);\n    \n    \tpct = mix(rand2(i), rand2(i +1.0), smoothstep(0., 1.0, f))*1.;\n   \n        float mountain = smoothstep(-0.01, 0.01, pct-uv.y);\n    \tcol *= (1.0-mountain);\n        \n        vec3 colb = vec3(0.02);\n        vec3 colt = vec3(0.07);\n        \n        vec3 mountain_col = mix(colb, colt, uv.y);\n        col += mountain*mountain_col;\n        \n    } else if (hitObj.type == SPHERE || \n               hitObj.type == BOX ||\n               hitObj.type == SHELL) {\n    \n    \tvec4 sc0 = vec4(5.5, 1.5, 10.5, 11.5);\n        \n        if (hitObj.type == SHELL) {\n        \tsc0 = vec4(.5, 1.5, 1.5, 11.5);\n        }\n           \n        // add checkerboard texture\n      \tvec2 uvw = texCoords(hitObj.hitPos, sc0) - uv;\n\n      \tvec2 ddx_uv = dFdx( uvw );\n      \tvec2 ddy_uv = dFdy( uvw );\n        \n      \tcol = vec3(checkersTextureGradBox(uvw, ddx_uv, ddy_uv));\n\n        // make it red\n        col = col + vec3(0.5, 0.0, 0.0);\n        \n        float dif = getLight(hitObj.hitPos, LIGHT_DIR);\n        col *= dif;\n        \n    } else if (hitObj.type == GROUND) {\n        float dif = getLight(hitObj.hitPos, LIGHT_DIR) * hitObj.hitPos.y;       \n        \n        // add fog to make the farther terrain darker\n        col = dif * vec3(0.4, 0.4, 0.4);\n        float fogExtintion = 0.07;\n        float fogInscattering = 4.5;\n        \n       col = fog(col, hitObj.d, rd, LIGHT_DIR, fogExtintion, fogInscattering); \n        col += 0.02;\n\n    } else {\n    \n  \t\tfloat dif = getLight(hitObj.hitPos, LIGHT_DIR);\n  \t\tcol = vec3(dif);\n    }\n\n \tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3Gz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 290, 290, 372], [374, 374, 395, 395, 437], [439, 439, 467, 467, 548], [550, 550, 579, 579, 620], [622, 622, 654, 654, 688], [690, 732, 757, 757, 1143], [1145, 1381, 1417, 1444, 1698], [1700, 1700, 1721, 1757, 2732], [2734, 2734, 2766, 2766, 3408], [3410, 3410, 3435, 3435, 3681], [3683, 3683, 3722, 3777, 4390], [4392, 4453, 4513, 4584, 6230], [6232, 6280, 6347, 6369, 6589], [6591, 6591, 6633, 6633, 6755], [6757, 6757, 6851, 6851, 7080], [7082, 7082, 7139, 7219, 10761]], "test": "untested"}
{"id": "ttKGWw", "name": "Butterfly particles", "author": "michael0884", "description": "More random sims!\n[url]JAVASCRIPT: H=location.host;E=(H?window:opener).Effect;P=E.prototype;if(!E.P)E.P=P.Paint;P.Paint=function(...A){for(i=0;i<8;i++)E.P.apply(this,A);};if(!H)close();[/url]", "tags": ["particles", "what"], "likes": 19, "viewed": 712, "published": 3, "date": "1579105179", "time_retrieved": "2024-07-30T21:30:09.251870", "image_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tvec4 particle = texel(ch0, pos);\n    float distr = gauss(pos - particle.xy, prad);\n    vec4 flow = 0.5*texel(ch1, pos);\n    fragColor = vec4(sin(flow.xxx*vec3(1.5,1.2,1.)), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//voronoi particle tracking \n\n//loop the vector\nvec2 loop_d(vec2 pos)\n{\n\treturn mod(pos + size*0.5, size) - size*0.5;\n}\n\n//loop the space\nvec2 loop(vec2 pos)\n{\n\treturn mod(pos, size);\n}\n\n\nvoid Check(inout vec4 U, vec2 pos, vec2 dx)\n{\n    vec4 Unb = texel(ch0, loop(pos+dx));\n    //check if the stored neighbouring particle is closer to this position \n    if(length(loop_d(Unb.xy - pos)) < length(loop_d(U.xy - pos)))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec2 pos, float r)\n{\n    Check(U, pos, vec2(-r,0));\n    Check(U, pos, vec2(r,0));\n    Check(U, pos, vec2(0,-r));\n    Check(U, pos, vec2(0,r));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 muv = iMouse.xy/size;\n   \n    //this pixel value\n    U = texel(ch0, pos);\n    \n    //check neighbours \n    CheckRadius(U, pos, 1.);\n    CheckRadius(U, pos, 2.);\n    CheckRadius(U, pos, 3.);\n    CheckRadius(U, pos, 4.);\n    CheckRadius(U, pos, 5.);\n   \n    U.xy = loop(U.xy);\n    \n    //cell cloning \n   // if(length(U.xy - pos) > 7.)\n    //\tU.xy += 1.*(hash22(pos)-0.5);\n\n    //syncronizing the particles with the flow\n    \n    vec2 vel0 = pspeed*vec2(cos(U.z), sin(U.z)) + 0.1*(hash22(U.xy+iTime)-0.5);\n    vec4 F =  pixel(ch1, U.xy);\n    vec2 vel1 = F.yz;\n    float dangl = 0.8*angle_between(vel0,vel1);\n    U.z += dt*(dangl+0.1*(hash12(U.xy+iTime)-0.5)+1.*sin(U.w));\n    U.w += dt*0.4;\n   \n    vec2 pvel = pspeed*vec2(cos(U.z), sin(U.z)) + 1.*(hash22(U.xy+iTime)-0.5);;\n    \n    //update the particle\n    U.xy += dt*pvel;\n    \n    U.xy = loop(U.xy);\n    \n    \n    if(iFrame < 1 || (iMouse.z > 0. && length(iMouse.xy - pos) < 30.) || (length(size.xy*0.5 - pos) < 5.))\n    {\n        U.xy = vec2(pdens*round(pos.x/pdens),pdens*round(pos.y/pdens));\n        U.zw = 2.*PI*(hash22(U.xy) - 0.5);\n    }\n    \n    if(iFrame < 1)\n    {\n        U = vec4(0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//simulation variables\n#define dt 0.25\n#define prad 1.4\n#define decay 0.02\n\n//particle speed\nfloat pspeed = 10.;\n\n\n#define pdens 2.\n//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p-0.5), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n//functions\nfloat gauss(vec2 x, float r)\n{\n    return exp(-pow(length(x)/r,2.));\n}\n   \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\n//Gradient\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n\n\nfloat angle_between(vec2 a,vec2 b)\n{\n    return atan(a.x*b.y-a.y*b.x,dot(a,b));\n}", "buffer_b_code": "//saving and diffusing the velocity trails \n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    Q = texel(ch1, p);\n   \n    //diffusion equation\n    Q += 0.05*dt*Laplace(ch1, p);\n    \n    vec4 particle = texel(ch0, p);\n    float distr = gauss(p - particle.xy, prad);\n    \n    vec2 pvel = pspeed*vec2(cos(particle.z), sin(particle.z));\n    \n    //pheromone depositing\n    Q += dt*vec4(1., pvel.x, pvel.y, 1.)*distr;\n        \n    //pheromone decay\n    Q += -dt*decay*Q;\n    \n    if(iFrame < 1) Q = vec4(0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 232]], "test": "untested"}
{"id": "3tK3Dm", "name": "Wavy beams", "author": "michael0884", "description": "More random sims!\n[url]JAVASCRIPT: H=location.host;E=(H?window:opener).Effect;P=E.prototype;if(!E.P)E.P=P.Paint;P.Paint=function(...A){for(i=0;i<8;i++)E.P.apply(this,A);};if(!H)close();[/url]", "tags": ["particles", "what"], "likes": 16, "viewed": 490, "published": 3, "date": "1579104034", "time_retrieved": "2024-07-30T21:30:10.115561", "image_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tvec4 particle = texel(ch0, pos);\n    float distr = gauss(pos - particle.xy, prad);\n    vec4 flow = 0.5*texel(ch1, pos);\n    fragColor = vec4(sin(flow.xxx*vec3(1.5,1.2,1.)), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//voronoi particle tracking \n\n//loop the vector\nvec2 loop_d(vec2 pos)\n{\n\treturn mod(pos + size*0.5, size) - size*0.5;\n}\n\n//loop the space\nvec2 loop(vec2 pos)\n{\n\treturn mod(pos, size);\n}\n\n\nvoid Check(inout vec4 U, vec2 pos, vec2 dx)\n{\n    vec4 Unb = texel(ch0, loop(pos+dx));\n    //check if the stored neighbouring particle is closer to this position \n    if(length(loop_d(Unb.xy - pos)) < length(loop_d(U.xy - pos)))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec2 pos, float r)\n{\n    Check(U, pos, vec2(-r,0));\n    Check(U, pos, vec2(r,0));\n    Check(U, pos, vec2(0,-r));\n    Check(U, pos, vec2(0,r));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 muv = iMouse.xy/size;\n   \n    //this pixel value\n    U = texel(ch0, pos);\n    \n    //check neighbours \n    CheckRadius(U, pos, 1.);\n    CheckRadius(U, pos, 2.);\n    CheckRadius(U, pos, 3.);\n    CheckRadius(U, pos, 4.);\n    CheckRadius(U, pos, 5.);\n   \n    U.xy = loop(U.xy);\n    \n    //cell cloning \n   // if(length(U.xy - pos) > 7.)\n    //\tU.xy += 1.*(hash22(pos)-0.5);\n\n    //syncronizing the particles with the flow\n    \n    vec2 vel0 = pspeed*vec2(cos(U.z), sin(U.z)) + 0.1*(hash22(U.xy+iTime)-0.5);\n    vec4 F =  pixel(ch1, U.xy);\n    vec2 vel1 = F.yz;\n    float dangl = angle_between(vel0,vel1);\n    U.z += dt*(dangl+0.1*(hash12(U.xy+iTime)-0.5)+0.3*sin(U.w));\n    U.w += dt*0.4;\n   \n    vec2 pvel = pspeed*vec2(cos(U.z), sin(U.z)) + 1.*(hash22(U.xy+iTime)-0.5);;\n    \n    //update the particle\n    U.xy += dt*pvel;\n    \n    U.xy = loop(U.xy);\n    \n    \n    if(iFrame < 1 || (iMouse.z > 0. && length(iMouse.xy - pos) < 30.) || (length(size.xy*0.5 - pos) < 20.))\n    {\n        U.xy = vec2(pdens*round(pos.x/pdens),pdens*round(pos.y/pdens));\n        U.zw = 2.*PI*(hash22(U.xy) - 0.5);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//simulation variables\n#define dt 0.25\n#define prad 1.4\n#define decay 0.04\n\n//particle speed\nfloat pspeed = 6.;\n\n\n#define pdens 2.\n//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p-0.5), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n//functions\nfloat gauss(vec2 x, float r)\n{\n    return exp(-pow(length(x)/r,2.));\n}\n   \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\n//Gradient\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n\n\nfloat angle_between(vec2 a,vec2 b)\n{\n    return atan(a.x*b.y-a.y*b.x,dot(a,b));\n}", "buffer_b_code": "//saving and diffusing the velocity trails \n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    Q = texel(ch1, p);\n   \n    //diffusion equation\n    Q += 0.05*dt*Laplace(ch1, p);\n    \n    vec4 particle = texel(ch0, p);\n    float distr = gauss(p - particle.xy, prad);\n    \n    vec2 pvel = pspeed*vec2(cos(particle.z), sin(particle.z));\n    \n    //pheromone depositing\n    Q += dt*vec4(1., pvel.x, pvel.y, 1.)*distr;\n        \n    //pheromone decay\n    Q += -dt*decay*Q;\n    \n    if(iFrame < 1) Q = vec4(0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tK3Dm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 232]], "test": "untested"}
{"id": "3scXWB", "name": "weird terrain;k", "author": "vjblind", "description": "t", "tags": ["planet"], "likes": 3, "viewed": 501, "published": 3, "date": "1579096860", "time_retrieved": "2024-07-30T21:30:11.139823", "image_code": "#define ANTIALIAS 2\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  240.0\n#define MAX_RAY_MARCHES 550\n\n// Hi    just to say A big thank for iq for the help !!\n\n\n\n\n\n#define speed iTime*0.\n#define time iTime*.50\n#define timeline iTime\n\n#define LIGHT_COLOR\t\t\tvec3(.0, 0.9, 2.6)*1.6\n\n//wip//SCENESsystem/////////////////////////////////////////////////////////////////////\n//const ivec3 SCENES[] = ivec3[](}\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat stepUp(float t, float len, float smo)\n{\n  float tt = mod(t += smo, len);\n  float stp = floor(t / len) - 1.0;\n  return smoothstep(0.0, smo, tt) + stp;\n}\n\n\n/////transform/////////////////////////////////////////////////////////////////////\nfloat smin(in float a ,float b, float k){\nfloat h= max(k-abs(a-b),0.0);\nreturn min(a,b)-h*h/(k*4.);\n}\nfloat smin1(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k * (1.0-k ) * h;\n}\n\n\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInt( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat opdistsub( float d1, float d2 ) { return max(-d1,d2); }\n\n\n\nmat2 rot(float a)\n{\n float cs = cos(a);\n    float si = sin(a);\n    \n    return mat2(cs, si, -si, cs);\n}\n///////////////////////////////////////////////////////////////////////////////////\n\n\n//////tool/////////////////////////////////////////////////////////////////////////\nvec3 fracta(vec3 p,float t){\n float s=3.;\n    for(float i=0.0;i<4.;i++){\n    float t2=t*i;\n    p.xy*=rot(t2);\n    p.yz*=rot(t2*1.2);\n        p=abs(p);\n     p-=s;\n   p*=.870;\n    }\n\n\nreturn p;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\n//////noise/////////////////////////////////////////////////////////////////////////\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\n\n\n//---------------------------------------------------------------\n// value noise, and its analytical derivatives\n//---------------------------------------------------------------\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n\n\n\n/////fbm///////////////////////////////////////////////////////////////////////////\n\n\nvec4 fbmd( in vec3 x )\n{\n      float scale  = 1.5+3.*sin(iTime/100.);\n\n    float a = 0.0;\n    float b = 0.5;\n\tfloat f = 1.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<3; i++ )\n    {\n        vec4 n = noised(f*x*scale)*noised(f*x*scale).x;\n        a += b*n.x;           // accumulate values\t\t\n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= 0.5;             // amplitude decrease\n        f *= 2.8;             // frequency increase\n    }\n\n\treturn vec4( a, d );\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////////\n\n\n\n//////Primitive/////////////////////////////////////////////////////////////////\n//////Primitive/////////////////////////////////////////////////////////////////\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n///////////////////////////////////////////////////////////////////////////////////\n//////Primitive normal/////////////////////////////////////////////////////////////////\n\n\nvec4 sdsphere1( vec3 p, vec3 b ) // distance and normal\n{\n    return vec4( (length(p)-b),1.);\n}\n\n\nvec4 sdBox2( vec3 p, vec3 b ) // distance and normal\n{\n    vec3 d = abs(p) - b;\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\n    return vec4( x, vec3(1.) );\n}\n/////light/////////////////////////////////////////////////////////////////   \n\nconst vec3 lightPos1 = 20.0*vec3(-0.3,-1.15, 1.0);\nconst vec3 lightPos2 = 20.0*vec3(-0.33,  -0.2, -1.0);\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n/////Sceneglow///////////////////////////////////////////////////////////\n \nfloat  GScene( vec3 p){      return sdSphere( p, 3. );}\n\n \n//////////////////////////////////////////////////////////////////\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n///Scene//////////////////////////////////////////////////////////////////////////\n\nvec2 Scene( vec3 p){\n  \nfloat d =sdBox(p+vec3(0.0,0.0,-speed+25.) ,vec3(1.,1.0,1.0)*10.);;\n  vec3 p1= fracta(p+vec3(0.0,0.0,-speed+25.),time*0.3);  \n  vec3 p2= fracta(p+vec3(0.0,0.0,-speed+25.),time*0.4);  \n \nfloat d1=sdBox(p1 ,vec3(1.,1.0,1.0)*2.);\nfloat d2=sdBox(p2+vec3(1.,1.0,1.0) ,vec3(1.,1.0,1.0)*2.);      \n    \n//vec3 mirror= vec3(abs(q.x),q.yz);\n   \nfloat res=10.0;\n\nres=smin(res,d1,2. );\nres=smin(res,d2 ,9.);\n    \nfloat m1=d1;\n// res=min(res,d);     \n     float mat = 0.0 ;\n     if(res==m1)mat=1.0;\n   return vec2(res,mat);\n}\nvec2 Scene1( vec3 p){\n  \nfloat d =sdBox(p+vec3(0.0,0.0,-speed+25.) ,vec3(1.,1.0,1.0)*10.);;\n  vec3 p1= fracta(p+vec3(0.0,0.0,-speed+25.),time*0.3);  \n  vec3 p2= fracta(p+vec3(0.0,0.0,-speed+25.),time*0.4);  \n \nfloat d1=sdSphere(p1 ,3.);\nfloat d2=sdSphere(p2+vec3(1.,1.0,1.0) ,2.);      \n    \n//vec3 mirror= vec3(abs(q.x),q.yz);\n   \nfloat res=10.0;\n\nres=smin(res,d1,2. );\nres=smin(res,d2 ,9.);\n    \nfloat m1=res=opSub(d1,d2 );\n  \nfloat m2=GScene( p);\n   \nres= min(res, GScene(  p)); \n    \n    \n    \n// res=min(res,d);     \n   float mat = 0.0 ;\n   if(res==m1)mat=1.0;\n   if(res==m2)mat=2.7;\n   return vec2(res,mat);\n}\n\n\n\nvec2 Scenex( vec3 p){\n   // vec3 p2= fracta(p+vec3(0.0,0.0,-speed*0.0+25.),time*0.00004);\n   // p.xy*=rot(time);\nfloat d =sdSphere(p +vec3(0.0,0.0,-50.),10.);\n     \n    // clip to box\n    vec4 d2 = sdsphere1( p , vec3(5.5) ); \n    \n vec4 d1 = fbmd(p );\n    d1.x -= 0.4213571542;\n\t d1.x *= .47;\n    \n    vec4 d3 = fbmd(p )*d1.x;\n    d3.x -= 0.5213571542;\n\t d3.x *= .47;\n //   d1.yzw = normalize(d1.yzw);\n\n    // clip to box\n //   vec4 d2 = sdBox( p, vec3(1.5) );\n   \n   // ugly hacky slow distance field with bad gradients\n   // d = p.y;\n    float c = max(10.0, pow(distance(p.xz, vec2(0,16)), 1.0));\n    float cc = pow(smoothstep(20.0, 105.0, c), 1.0);\n    p.xz *= cc;\n    vec4 n = noised(vec3(p.xz*10.7, 50.5));\n    float nn = n.x * (length((n.yzw)));\n   // n = noised(vec3(p.xz*0.173, 10.*1.639));\n  // nn += 0.25*n.x * (length((n.yzw)));\n    nn = smoothstep(-0.5, .015, nn);\n    d3.x = d3.x*123.0*nn*(cc);\n    \n    \nfloat res = opdistsub(-d,   mix(d3.x, 0.15,  0.9915));\n   res+=d1.x  ;\n   // if(d1.x<0.5)res=d1.x;\n    \n    \n   // ugly hacky slow distance field with bad gradients\n  \n    \n    \n    \n    \n    // res=min(res,d);     \n     float mat =2.7 ;\n\n   return vec2(res,mat);\n}\n \nvec2 path(in float z){ float s = sin(z/36.)*cos(z/18.); return vec2(s*16., 0.); }\n\n\n//////////////////////////////////////////////////////////////////\n////map/////////////////////////////////////////////////////////////////////\n\nvec2 map1(in vec3 p)\n{\n    \n  float t = mod(stepUp(timeline, 15.0, 1.0),15.0);\n    \n\t vec2 d = mix(Scene(p), Scene1(p), clamp(t, 0.0, 1.0));\n          d = mix(d, Scene(p), clamp(t - 3.0, 0.0, 1.0));\n              d = Scenex(p);\n //vec2    d =  Scene2(p);\n\n  //  d = mix(d, s1, clamp(t - 3.0, 0.0, 1.0));\n    \n// min(max(0.0, d), 1.0);   \n    \n\nreturn d;\n\n\n}\n\n\n\n\n\n\n//mat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n float mag2(vec2 p){return dot(p,p);}\n float prm1 = 0.1;\nvec2 bsMo = vec2(00.6);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(in vec3 p)\n{\n    vec3 p2 = p;\n     p2.xy -= disp(p.z).xy;\n     p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n   float cl =mag2(p2.xy);\n    float d =  .1;\n   p *= .61;\n    float z = 1.;\n    float trk = 10.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 1\n        ; i++)\n    {\n\t p += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 9.57;\n        trk *= 1.4;\n         //p = p*m3;\n    }\n   // d  =  abs( d + prm1*3.)+ prm1*.3 - 20.5 + bsMo.y;//carve the tunel\n  \n      d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n  // return  3.-vec2(length((d*1.3)+p2)-65. , cl);\n    \n    \n   // return  3.-vec2(length(p2)-65. , cl);\n\n    return 1.-vec2(d + cl*.2 + 0.25, cl);\n     \n  // return vec2(   d + cl*.0 + 0.25, 10.1);\n}\n\n\nvec4 Shade( vec3 pos, vec3 ray, vec3 n,float m )\n{\n    vec4 col = vec4(1,0,0,0);\nif (m==1.)col = vec4(1,0,0,0);\nif (m==2.) col = vec4(0,1,0,0);   \n    // col.rgb = fract(pos);\n\n    vec3 diffuse = vec3(.1)*(n.y*.5+.5);\n\tvec2 uv = vec2( atan( n.x, n.z ), acos(n.y) );\n    \t  uv =  (pos.xz + pos.xy*30.)/11.0;\n  \n    vec3 col1 = (texture( iChannel0, uv*0.0915 ).xyz);\n    vec3 l = normalize( vec3( 2,3,4 ) );\n   diffuse = col1*col1* max(dot(n,l),0.);\n\n     col.rgb = diffuse*vec3(.0, 0.9, 2.6)* .6;\n    \n    // reflectivity\n    col.a =  clamp(  pow( 1.+dot(ray,n), 5. ),0.01,1.0);\n    col.a = mix( .01, 1., col.a );\n    \n    return col;\n}\n\nvec3 GetNormal( vec3 pos, float sampleSpacing )\n{\n    vec2 d = vec2(-1,1)*sampleSpacing;\n    \n    return normalize(\n        map( pos + d.xxx ).x*d.xxx +\n        map( pos + d.yyx ).x*d.yyx +\n        map( pos + d.yxy ).x*d.yxy +\n        map( pos + d.xyy ).x*d.xyy\n        );\n}\n\n\nvec2 GlowMarch(vec3 p, vec3 o)\n{\n\tfloat d\t\t= 1000.0;\n\tfloat z\t\t= 0.0;\n\tfloat acc\t= 0.0;\n\t\n\tfor(int i=0; i<100; i++)\n\t{\n\t     \td= map(p + o*z).x;\n  \n\t\tacc\t+= max(3. - d,- 0.);\n            z\t+= max(0.1, d)*d/100.;\n\t}\n\t\n\treturn vec2(acc/1560., z);\n}\n\nvec2 Trace( vec3 start, vec3 dir, float minT, float maxT, float pixelScale )\n{\n    float epsilon = pixelScale*1.;\n    \n    float t = minT;\n    float m ;\n    float dist;\n    for ( int i=0; i < 500; i++ ) // this can be really big as long as epsilon is high enough\n    {\n        dist = map( start + t*dir ).x;\n         m =map( start + t*dir ).y;;\n        if ( abs(dist) < epsilon*t || t > maxT ) return vec2(t,m);\n        t += dist;\n    }\n    \n    if ( dist >0.1 && t < maxT )\n    {\n        t += dist;\n        float dist2 = map( start + t*dir ).x;\n        \n        // try to guess where the surface might be, by extrapolating as if SDF is planar here\n        t += max(0.,dist2*dist/(dist-dist2)); //(dist-dist2)/dist = change in df / distance stepped, so divide DF by this to find distance we should step\n        \n        return vec2 (t,m);\n    }\n    \n    return vec2(maxT,m); // todo: maybe return best-guess t when we run out of iterations?\n}\n\n\nvec2  camera( float p, int x )\n{\n    if( x== 1){return path(p);}\n    if( x== 2){return path(p);}\n}\n\n \n\nvec3 cameraani(int s){\n    float an2= 10.*iMouse.y/iResolution.y ;//iTime;\n    float an= 10.*iMouse.x/iResolution.x ;//iTime;\n    \n    \n  \nswitch (s)\n{\n    case 1:\n     return vec3(sin(an )*10.0 ,-sin(an2 )*10.0, 50.+5.*sin(time/10.) +cos(an )*10.0); \n  \n    \n    break;\n\n    case 2:\n       return vec3(0.0,0.0,50.0); \n    break;\n        \n    default:  return vec3(0.0,0.0,0.0); \n        // code to be executed if n doesn't match any constant\n}\n\n\n\n}\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    const float targetT = 1.;\n     \n    vec3 camPos = vec3(0.0);\n    vec2 uv =(2.0* fragCoord-iResolution.xy )/iResolution.y;\n\n \tfloat fft  = texture( iChannel0, vec2(uv.x,0.25) ).x; \n    \n    // second texture row is the sound wave\n\tfloat wave = texture( iChannel0, vec2(uv.x,0.75) ).x;\n\t\n    //  time = mod(time * 0.6, 500.0) + 16.4;\n    \n   float an2= 10.*iMouse.y/iResolution.y ;//iTime;\n    float an= 10.*iMouse.x/iResolution.x ;//iTime;\n    \n    \n vec3 ro  =cameraani(1);//=vec3(sin(an )*10.0+ speed+-10. ,-sin(an2 )*10.0, speed+50.*sin(time/1.) +cos(an )*10.0); \n  vec3 ta =vec3(00.0,0.0,0.);\n     \n    //ta.xy +=camera( ta.z , 1 );\n\t//ro.xy += camera( ro.z , 2 );\n    vec3 ww=normalize(ta-ro);\n    vec3 uu=normalize(cross(ww,vec3(0.0,1.0,0.0)));\n    vec3 vv=normalize(cross(uu,ww));\n     \n   \n  vec3 rd =normalize(uv.x*uu+uv.y*vv+.5*ww);                  \n rd = normalize(vec3(uv,-2.));\n       \n      \n      \n     vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.y,1.);\n    float pixelScale = (1.1 )/ray.z / iResolution.y;\n    pixelScale = ( .1*pixelScale);\n    \n       ray =rd;\n\n       camPos=ro ;\n    \n    float far = 1e10;\n    float t = Trace( camPos, ray, 0., far, pixelScale ).x;\nfloat tr;\n    fragColour.rgb = vec3(.0);\n    if ( t < far )\n    {\n        vec3 pos = camPos + ray*t;\n        \n\t    vec3 n = GetNormal( pos,   pixelScale*t  );\n\n        fragColour.rgba = Shade( pos, ray, n ,2.);\n        \n        // reflection\n        vec3 rayr = reflect(ray,n);\n         tr = Trace( pos+n*0.01, rayr, .01, 128., pixelScale ).x;\n\t\tfloat tr2 = Trace( pos, rayr, .01, 128., pixelScale ).y;\nfragColour.rgba *=vec4(.0, 0.9, 2.6,0.0)* .6+ 1.5*exp(-max(t-1.0,0.0)*0.03)*clamp(length(pos-vec3(0.0,0.0,50.))/10.0,0.0,1.0);\n        vec3 ref = vec3(.90, 0.9, 1.6);\n        if ( tr < 128. )\n        {\n            vec3 posr = pos + rayr*t;\n       ref = Shade( posr, rayr, GetNormal( posr, .001 ),2. ).rgb+vec3(.0, 0.9, 1.6)* .46;\n        }\n        \n   fragColour.rgb += mix( fragColour.rgb, ref, fragColour.a );\n    }\n\n    \n\n     \n    \tvec2 gres\t= GlowMarch(ro, rd);\n\tfloat glowi\t= 1.0;\n\tif(tr < .001)\n\t{\n\t \n\t\tglowi = smoothstep(-10.0, 10.5, max(tr, 5.0));\n        //\tfragColour.rgb\t+=(fbmd(   vec3 (tr)).x/100.)-0.293*gres.x *0.50 * LIGHT_COLOR;\n\t}\n\t\t\t\n //fragColour.rgb\t+=(fbmd(   vec3 (tr)).x/400.)-0.2481*gres.x* LIGHT_COLOR;\n\n    \n // fragColour.rgb = mix( fragColour.rgb, ref, fragColour.a );\n\n    \n    fragColour.xyz = acesFilm(fragColour.xyz * 1.85);\n     fragColour.xyz = pow(fragColour.xyz, vec3(1.850/2.2));\n\n    fragColour.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scXWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[496, 496, 541, 541, 653], [656, 740, 781, 781, 841], [842, 842, 882, 882, 966], [970, 970, 1007, 1007, 1028], [1030, 1030, 1065, 1065, 1087], [1089, 1089, 1124, 1124, 1145], [1148, 1148, 1187, 1187, 1209], [1213, 1213, 1232, 1232, 1316], [1403, 1487, 1515, 1515, 1680], [1767, 1852, 1875, 1875, 1914], [1918, 1918, 1944, 1944, 2349], [2534, 2534, 2560, 2560, 3395], [3485, 3485, 3509, 3509, 3969], [4060, 4271, 4330, 4330, 4419], [4420, 4420, 4451, 4451, 4542], [4543, 4543, 4578, 4578, 4604], [4605, 4605, 4638, 4638, 4703], [4705, 4705, 4741, 4741, 4775], [4776, 4776, 4828, 4828, 4935], [5110, 5110, 5167, 5167, 5205], [5208, 5208, 5262, 5262, 5447], [5817, 5817, 5840, 5840, 5872], [5876, 5980, 6031, 6031, 6299], [6385, 6385, 6405, 6405, 6921], [6922, 6922, 6943, 6943, 7537], [7541, 7541, 7562, 7653, 8725], [8728, 8728, 8750, 8750, 8809], [8957, 8957, 8979, 8979, 9314], [9321, 9398, 9417, 9417, 9434], [9479, 9479, 9498, 9498, 9549], [9551, 9551, 9572, 9572, 10350], [10353, 10353, 10403, 10403, 10988], [10990, 10990, 11039, 11039, 11264], [11267, 11267, 11299, 11299, 11513], [11515, 11515, 11593, 11593, 12457], [12460, 12460, 12492, 12492, 12558], [12563, 12563, 12585, 12585, 13012], [13013, 13013, 13042, 13042, 13246], [13249, 13249, 13307, 13307, 15860]], "test": "untested"}
{"id": "WtVGDw", "name": "Twisted tunnel (checkerboard v3)", "author": "tombla", "description": "Twisting tunnel.", "tags": ["procedural", "tunnel", "visualization", "fast", "checkerboard", "glmixer"], "likes": 7, "viewed": 490, "published": 3, "date": "1579086048", "time_retrieved": "2024-07-30T21:30:11.958633", "image_code": "#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define COLOR1 vec3(0.9, 0.9, 0.8)\n#define COLOR2 vec3(0.05, 0.05, 0.05)\n#define LIGHTCOLOR  vec3(1., 1., 1.)\n\n#define ARMS 10.\n#define DENSITY 3.\n#define ANGLE_SPEED 3.\n#define ANGLE_TEMPO 2.\n#define SPEED 2.\n#define PULSE_SPEED 4.\n#define SMOOTH 0.04\n\nfloat smoothstepCheckerboard(in vec2 uv) {\n    // Shift, as fract gives 0..1 and we will smooth\n    // around 0.25 and 0.75.\n    uv = fract(uv + 0.25);\n    float sm2 = SMOOTH * 0.5;\n    // p01 oscillates between 0 and 1.\n    vec2 p01 =\n        smoothstep(0.25 - sm2, 0.25 + sm2, uv) -\n        smoothstep(0.75 - sm2, 0.75 + sm2, uv);\n    // pn11 oscillates between -1 and 1.\n    vec2 pn11 = (p01 - 0.5) * 2.;\n    // This results in smoothed 0..1 transitions.\n    // We take advantage of the fact that multiplication\n    // of -1/1 behaves like XOR. Then we rescale\n    // -1..1 result of the multiplication to 0..1.\n    return 0.5 - 0.5 * pn11.x * pn11.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2\n        R = iResolution.xy,\n        // Cartesian [-1, 1] along shorter axis.\n        uv = (2. * fragCoord - R) / min(R.x, R.y);\n    float\n        T = iTime,\n        // Angle [-PI, PI] and radius.\n        a = atan(uv.x, uv.y),\n        r = length(uv),\n        // Twisted angle\n        w = a - sin(1. / r) * r * ANGLE_SPEED * sin((T - 1./r) / ANGLE_TEMPO);\n\n    vec2 polar = vec2(\n        w * ARMS / PI2,\n        1. / r * DENSITY + T * SPEED \n    );\n\n    // vec3 checker = mix(COLOR1, COLOR2, smoothCheckerboard(polar));\n    vec3 checker =\n         mix(COLOR1, COLOR2,\n         smoothstepCheckerboard(polar));\n    // Light in the center.\n    float light = smoothstep(0.7 + 0.3 * sin(T * PULSE_SPEED), 0.2, r);\n\n    vec3 color = mix(checker, LIGHTCOLOR, light);\n    // Approximate output gamma correction.\n    fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVGDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 307, 349, 431, 963], [965, 965, 1020, 1020, 1885]], "test": "untested"}
{"id": "wty3Dm", "name": "Dark Ocean", "author": "kstyler", "description": "A simple ocean scene.", "tags": ["noise", "raymarch", "water", "ocean"], "likes": 21, "viewed": 780, "published": 3, "date": "1579073308", "time_retrieved": "2024-07-30T21:30:12.700649", "image_code": "const int MAX_DIST = 300;\nconst float EPSI = 0.009;\n\nfloat random(vec2 p){\n\treturn(fract(sin(p.x*431.+p.y*707.)*7443.));\n}\n\nfloat noise(vec2 uv){\n\tvec2 id = floor(uv*10.);\n    vec2 lc = smoothstep(0.,1.,fract(uv*10.));\n    \n    float a = random(id);\n    float b = random(id + vec2(1.,0.));\n    float c = random(id + vec2(0.,1.));\n    float d = random(id + vec2(1.,1.));\n    \n    float ud = mix(a,b,lc.x);\n    float lr = mix(c,d,lc.x);\n    float fin = mix(ud,lr,lc.y);\n    return fin;\n}\n\nfloat octaves(vec2 uv){\n    float amp = 0.5;\n    float f = 0.;\n    for(int i =1; i<5;i++){\n    \tf+=noise(uv)*amp;\n        uv*=2.;\n        amp*=0.5;\n    }\n    return f;\n}\nfloat SDF(vec3 p){\n    vec3 spherePos = vec3(8,6,25);\n    float sphere = length(p-spherePos)-1.;\n    float water = p.y+8.+octaves((p.xz/30.)+(iTime/10.)+sin(length(p.xz*2.))*.04);\n    float mindst = min(water,sphere);\n    return mindst;\n}\n\nfloat rayMarcher(vec3 ro, vec3 rd){\n\tfloat tot = 0.;\n    for(int i=0;i<MAX_DIST;i++){\n    \tvec3 p = ro+rd*tot;\n        float diff = SDF(p);\n        tot+=diff;\n        if(diff<EPSI || tot>float(MAX_DIST)){\n        \ttot = float(i)/float(MAX_DIST-50);\n            break;\n        }\n    }\n    return tot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){     \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x; \n    vec3 ro = vec3(0,0,-8);\n    vec3 rd= normalize(vec3(uv,1.)); \n    vec3 col = vec3(rayMarcher(ro,rd)); \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wty3Dm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 74, 74, 122], [124, 124, 145, 145, 485], [487, 487, 510, 510, 656], [657, 657, 675, 675, 895], [897, 897, 932, 932, 1198], [1200, 1200, 1256, 1256, 1462]], "test": "untested"}
{"id": "wlGGWw", "name": "Spreading grain", "author": "luluco250", "description": "Mixes nearby pixels through a RNG, creating an old film grain effect. Use mouse X to change the spread scale, mouse Y to adjust the amount of grain mixed with the image.", "tags": ["2d", "blur", "filter", "film", "grain", "spread"], "likes": 23, "viewed": 1989, "published": 3, "date": "1579054287", "time_retrieved": "2024-07-30T21:30:13.488543", "image_code": "float rand(vec2 uv, float t) {\n    return fract(sin(dot(uv, vec2(1225.6548, 321.8942))) * 4251.4865 + t);\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    float scale = 50.0;\n    if (iMouse.z > 0.0)\n        scale *= iMouse.x * ps.x * 2.0;\n    \n    vec2 offset = (rand(uv, iTime) - 0.5) * 2.0 * ps * scale;\n    \n    vec3 noise = texture(iChannel0, uv + offset).rgb;\n    color = texture(iChannel0, uv);\n    \n    float amount = 0.5;\n    if (iMouse.z > 0.0)\n        amount = iMouse.y * ps.y;\n    \n    color.rgb = mix(color.rgb, noise, amount);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 107], [109, 109, 153, 153, 617]], "test": "untested"}
{"id": "3tGGDm", "name": "Particle superstorm", "author": "michael0884", "description": "This just happend idk\n[url]JAVASCRIPT: H=location.host;E=(H?window:opener).Effect;P=E.prototype;if(!E.P)E.P=P.Paint;P.Paint=function(...A){for(i=0;i<8;i++)E.P.apply(this,A);};if(!H)close();[/url]", "tags": ["particles", "what"], "likes": 22, "viewed": 534, "published": 3, "date": "1579047991", "time_retrieved": "2024-07-30T21:30:14.238538", "image_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tvec4 particle = texel(ch0, pos);\n    float distr = gauss(pos - particle.xy, prad);\n    vec4 flow = 1.*texel(ch1, pos);\n    fragColor = vec4(sin(flow.xxx*vec3(1,1.2,1.5)), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//voronoi particle tracking \n\n//loop the vector\nvec2 loop_d(vec2 pos)\n{\n\treturn mod(pos + size*0.5, size) - size*0.5;\n}\n\n//loop the space\nvec2 loop(vec2 pos)\n{\n\treturn mod(pos, size);\n}\n\n\nvoid Check(inout vec4 U, vec2 pos, vec2 dx)\n{\n    vec4 Unb = texel(ch0, loop(pos+dx));\n    //check if the stored neighbouring particle is closer to this position \n    if(length(loop_d(Unb.xy - pos)) < length(loop_d(U.xy - pos)))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec2 pos, float r)\n{\n    Check(U, pos, vec2(-r,0));\n    Check(U, pos, vec2(r,0));\n    Check(U, pos, vec2(0,-r));\n    Check(U, pos, vec2(0,r));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 muv = iMouse.xy/size;\n   \n    //this pixel value\n    U = texel(ch0, pos);\n    \n    //check neighbours \n    CheckRadius(U, pos, 1.);\n    CheckRadius(U, pos, 2.);\n    CheckRadius(U, pos, 3.);\n    CheckRadius(U, pos, 4.);\n    CheckRadius(U, pos, 5.);\n   \n    U.xy = loop(U.xy);\n    \n    //cell cloning \n   // if(length(U.xy - pos) > 7.)\n    //\tU.xy += 1.*(hash22(pos)-0.5);\n\n    //syncronizing the particles with the flow\n    \n    vec2 vel0 = pspeed*vec2(cos(U.z), sin(U.z)) + 0.1*(hash22(U.xy+iTime)-0.5);\n    vec4 F =  pixel(ch1, U.xy);\n    vec2 vel1 = F.yz;\n    float dangl = 0.1*F.x*angle_between(vel0,vel1);\n    U.z += dt*(dangl+0.1*(hash12(U.xy+iTime)-0.5)+0.4*sin(U.w));\n   // U.w += dt*0.4;\n   \n    vec2 pvel = pspeed*vec2(cos(U.z), sin(U.z)) + 1.*(hash22(U.xy+iTime)-0.5);;\n    \n    //update the particle\n    U.xy += dt*pvel;\n    \n    U.xy = loop(U.xy);\n    \n    \n    if(iFrame < 1 || (iMouse.z > 0. && length(iMouse.xy - pos) < 30.) || (length(size.xy*0.5 - pos) < 30.))\n    {\n        U.xy = vec2(pdens*round(pos.x/pdens),pdens*round(pos.y/pdens));\n        U.zw = 2.*PI*(hash22(U.xy) - 0.5);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//simulation variables\n#define dt 0.25\n#define prad 1.4\n#define decay 0.04\n\n//particle speed\nfloat pspeed = 6.;\n\n\n#define pdens 2.\n//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p-0.5), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n//functions\nfloat gauss(vec2 x, float r)\n{\n    return exp(-pow(length(x)/r,2.));\n}\n   \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\n//Gradient\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n\n\nfloat angle_between(vec2 a,vec2 b)\n{\n    return atan(a.x*b.y-a.y*b.x,dot(a,b));\n}", "buffer_b_code": "//saving and diffusing the velocity trails \n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    Q = texel(ch1, p);\n   \n    //diffusion equation\n    Q += 0.05*dt*Laplace(ch1, p);\n    \n    vec4 particle = texel(ch0, p);\n    float distr = gauss(p - particle.xy, prad);\n    \n    vec2 pvel = pspeed*vec2(cos(particle.z), sin(particle.z));\n    \n    //pheromone depositing\n    Q += dt*vec4(1., pvel.x, pvel.y, 1.)*distr;\n        \n    //pheromone decay\n    Q += -dt*decay*Q;\n    \n    if(iFrame < 1) Q = vec4(0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGGDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 230]], "test": "untested"}
{"id": "WlyGDw", "name": "CylinderSphereCollision", "author": "BeardThings", "description": "cylinder sphere collision", "tags": ["collision"], "likes": 2, "viewed": 218, "published": 3, "date": "1579038360", "time_retrieved": "2024-07-30T21:30:14.987535", "image_code": "// Based on: https://bartwronski.com/2017/04/13/cull-that-cone/\n// Has similar fail states as the final solution in the linked site.\n// A more robust test could be implemented by finding the closest\n// point to the sphere on the cylinder and\n// testing the distance from that point to the center of the sphere.\n// http://shader-playground.timjones.io/0c8f28cf32450dcbdc5ffd178b06fb16\nbool cylinderSphereTest_imperfect(vec2 cylinderOrg, vec2 cylinderDir, float cylinderHeight, float cylinderRad, vec2 sphereOrg, float sphereRad)\n{\n    vec2 v = sphereOrg-cylinderOrg;\n    float a = dot(cylinderDir, v);\n    float bSqr = dot(v,v) - a*a;\n    \n    bool frontCull = a > cylinderHeight + sphereRad;\n    bool backCull = a < -sphereRad;\n    bool sideCull = bSqr > (sphereRad + cylinderRad) * (sphereRad + cylinderRad);\n    \n    return !(frontCull || backCull || sideCull);\n}\n\nbool cylinderSphereTest(vec2 cylinderOrg, vec2 cylinderDir, float cylinderHeight, float cylinderRad, vec2 sphereOrg, float sphereRad)\n{\n    vec2 v = sphereOrg-cylinderOrg;\n    \n    float da = dot(cylinderDir,v);\n    vec2 a = cylinderDir * clamp(da,0.0,cylinderHeight);\n    \n    vec2 b = v - (cylinderDir * da);\n    float bl = length(b);\n    b = b/bl * min(bl,cylinderRad);\n    \n    vec2 s = cylinderOrg + a + b;\n    float distSqr = dot(s-sphereOrg,s-sphereOrg);\n    \n    return distSqr < sphereRad * sphereRad;\n}\n\nbool circle(vec2 p, vec2 c, float r)\n{\n    return dot(p-c,p-c)<r*r;\n}\n\nbool cylinder(vec2 p, vec2 o, vec2 d, float h, float r)\n{\n    float a=dot(p-o,d);\n    vec2 pr=clamp(a,0.0,h)*d+o;\n    return (dot(pr-p,pr-p)<(r*r))&&a<h&&a>0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cylinderOrg = vec2(cos(iTime),sin(iTime))*0.5+0.6;\n    vec2 cylinderDir = vec2(-cos(iTime),-sin(iTime));\n    float cylinderHeight = 0.5;\n    float cylinderRad = 0.1;\n    \n    vec2 sphereOrg = vec2(0.1,0.0);\n    float sphereRad = 0.3;\n    \n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n    if(cylinder(uv,cylinderOrg,cylinderDir,cylinderHeight,cylinderRad))\n    {\n        fragColor=vec4(1.0);\n    }\n    \n    if(circle(uv,sphereOrg,sphereRad))\n    {\n        bool intersect=cylinderSphereTest(cylinderOrg,cylinderDir,cylinderHeight,cylinderRad,sphereOrg,sphereRad);\n        bool intersect_imperfect=cylinderSphereTest_imperfect(cylinderOrg,cylinderDir,cylinderHeight,cylinderRad,sphereOrg,sphereRad);\n        \n        fragColor = intersect?vec4(0.0,1.0,0.0,1.0):vec4(0.0,0.0,0.0,1.0);\n\t\tfragColor += intersect_imperfect?vec4(1.0,0.0,0.0,1.0):vec4(1.0,1.0,1.0,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyGDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 384, 529, 529, 865], [867, 867, 1002, 1002, 1379], [1381, 1381, 1419, 1419, 1450], [1452, 1452, 1509, 1509, 1614], [1616, 1616, 1673, 1673, 2555]], "test": "untested"}
{"id": "3tyGWw", "name": "Day 26 - Bubblegum river", "author": "jeyko", "description": "Inspired by https://www.shadertoy.com/user/victor_shepardson .\nAlso, his code is more readable than this.", "tags": ["feedback"], "likes": 9, "viewed": 504, "published": 3, "date": "1579034515", "time_retrieved": "2024-07-30T21:30:15.741519", "image_code": "\n\n// Thanks to wyatt and Flexi for their awesome stuff! \n\n// Learned this buffer feedback technique from victor_shepardson\n\n// The whole thing is not very logical :D Mostly random\n// If you'd like to learn how it works, I recommend checking out victor's things.\n\n// There's no fluid dynamics here. It's only buffer feedback stuff.\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R.xy;\n    //U.x += 0.1*R.x;\n\t//U *= 0.92;\n    \n    vec3 colA = T(U).xyz;\n    vec3 col = T(U).xyz;\n\n    col.b = colA.r;\n    col.r = colA.b;\n    col.b *= 0.9;\n    \n    vec3 sh = abs(T(U) - T(U + 2.)).xyz;\n    \n    col = clamp(col, 0., 1.);\n    \n    col.g *= 1. - sh.g*1.;\n    col.r *= 1. - sh.r*1.;\n    //col.b *= 1. - sh.b*1.;\n    col = smoothstep(0.,1.,col);\n    \n    //col = smoothstep(0.,1.,col);\n    //col.x *= sh;\n    \n    //col *= 2.;\n    //col *= vec3(0.45);\n    C = vec4(col.xyz,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define X  A += T(U  + sin(i + 3.4)*T(U - i).yz*2. * (exp(-length(uv*2.))))*0.48\n#define L(x) i*=rot(x*acos(-1.))\n#define Y  i *= 1.1*div\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    #define grad 0.25*vec2(e.x-w.x,n.x-s.x)\n    #define div 0.25*(n.x-s.x+e.x-w.x)\n\n    Neighbros; \n    U -= grad*0.4;\n    vec2 uv = U/R;\n    U += sin(uv.yx*10.5 + iTime*0.4)*0.2;\n    U -= 1.;\n    U *= rot(length(uv*1.4)*0.002 + iTime*0.00005 );\n    U += 0.5;\n    uv -= 0.5;\n\n    vec2 i = vec2(0);\n    vec4 A = T(U)*0.46;\n    U += grad*0.6;\n    X; Y;\n    X; Y;\n\tX; Y*-1.;\n    U -= grad*(0.4 + sin(iTime)*0.2);\n\tX; Y*-1.;\n\tX; Y*-1.;\n    \n\tX; Y*1.;\n\tX*0.9; Y*-1.;\n\t//X; Y;\n\t//X; Y;\n    \n    \n    \n        \n    A *= 0.78 + sin(iTime*0.25)*0.02;\n    //A.g *= 1.001 + sin(iTime)*0.004;\n    C = mix(fract(sin(A.bagr - T(U - 4.*i*cos(iTime))*0.44  -  T(U)*0.1)) ,fract(cos(uv.xyxy)*2.), 0.06);\n    \n    if(iMouse.z > 0.){\n        float dMouse = length((iMouse.xy - U.xy)/R.y );\n        C = mix(C, abs(\n            mix(vec4(1,1.,0,1), vec4(1,0.,0.,0),sin(iTime)*0.5 + 0.5 )\n        )*0.5, smoothstep(0.18,0.15,dMouse));\n    \n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R (iResolution.xy)\n#define T(uv) texture(iChannel0, (uv)/R)\n#define A(uv) T(uv)\n\n#define Neighbros vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w); \n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[332, 332, 373, 373, 883]], "test": "untested"}
{"id": "ttV3WD", "name": "Day 26 - Gold", "author": "jeyko", "description": "So this is day 26 of the thing ", "tags": ["gold", "mdtmjvm"], "likes": 8, "viewed": 387, "published": 3, "date": "1579023278", "time_retrieved": "2024-07-30T21:30:16.493508", "image_code": "// thanks to mla and Kali!\n// They have super nice examples on inversion\n\n// it's really simple, basically\n// p /= dot(p,p);\n// p = sin(p);\n// SDFs\n// return distance*dot(p,p);\n\n\n// and ofc Inigo quilez for pallete!\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    \n    //float m = pow(abs(sin(p.z*0.03)),10.);\n\n    // Radial blur\n    float steps = 10.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,3.)*0.2;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*4.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.91;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*1.; \n    \n    fragColor *= 1.;\n    //fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    \n    //fragColor = max(fragColor, 0.);\n    \n    //fragColor.xyz = pow(fragColor.xyz, vec3(1.5,1. + sin(iTime)*0.2,1. - cos(iTime)*0.4));\n\n    //fragColor = pow(fragColor, vec4(0.4545 + dot(uvn,uvn)*1.7));\n    //fragColor *= 1. - dot(uvn,uvn)*1.8;\n}\n\n\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI acos(-1.)\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n\n\nfloat distributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d\t = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\nfloat D_GGX(float NoH, float roughness)\n{\n\tfloat a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NoH * NoH * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\n\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}", "buffer_b_code": "#define mx (200. + 200.*iMouse.x/iResolution.y)\n\n#define iTime (iTime*0.6 + 23.)\nstruct Mat {\n    vec3 albedo;\n\tfloat metalness; \n\tfloat roughness;\n};\nMat mats[2] = Mat[](\n\tMat(vec3(1)*4.,0.9,0.0),\n\tMat(vec3(1,1,1.),0.1,0.9)\n);  \n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn dir + right*uv.x + up*uv.y;\n}\n\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125 + u.z*12525.215215215)*124115.125235);\n}\nfloat r11(float u){\n\treturn fract(sin(u*4125.57)*1115.125235);\n}\n///  Dave hoskins hash\nvec3 r33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n\n#define rot(x) mat2(cos(x), -sin(x), sin(x),  cos(x))\n#define pmod(p, x) mod(p,x) - x*0.5\nfloat sdBlocksA(vec3 p, float scale) {\n    \n    float modDist = 26.*scale;\n    vec3 r = r33(floor(p/modDist) + 20.2) - 0.5;\n    vec3 rSign = sign(r);\n    \n    //r = smoothstep(0.,1., r*3.);\n    //r *= rSign;\n    vec3 rOrig = r;\n    r = sign(r)*pow(clamp(abs(r)*80.5, 0. ,1.), vec3(20.));\n\tfloat scaleO = scale;    \n\n    scale *= 1. + abs(rOrig.x)*3.;\n    p = pmod(p,modDist);\n    \n\n    \n    if (scale < 3.){\n        scale = 1. + rOrig.y*3.;\n    \tp -= r*6.*scaleO;\n    } else {\n    \tp -= r*6.*scaleO;\n    }\n    //p -= clamp(r*4., vec3(-1.4), vec3(1.4))*6.;\n    \n    p.xy *= rot(r.x*19. + iTime*r.z*1.);\n    p.yz *= rot(r.y*19. + iTime*r.x*1.);\n    //p.xz *= rot(r.z*19. + iTime*r.y*1.);\n    \n    //p.xz *= rot(r.y*29.);\n    p = abs(p);\n    \n    \n    for (int i = 0; i < 2 ; i++){\n    \tp = abs(p);\n        //p.xy *= rot(0.4);\n        //p.yz *= rot(0.4);\n        p.xz *= rot(r.y*0.7 * step(0.,r.x));\n        p.z -= .2;\n        p.xy *= rot(sign(r.x)*PI*0.25);\n        p.yz *= rot(r.y*2.*0.2);\n        //p.y -= 0.2 * r.x*scale*2.;\n    }\n    \n    \n    p -= 1.*scale;\n    float d = max(p.x, max(p.y, p.z));\n    \n    d = max(d, dot(p + 0.33*scale, normalize(vec3(1))));\n    \n    \n    p = max(p,-(abs(p.y*0.5) - 0.7));\n    \n    d *= 0.2;\n    return d;\n\n}\nvec3 glow = vec3(0);\n\n#define dmin(a, b) a.x < b.x ? a : b\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    p.xy *= rot(0.3);\n        \n    d =  dmin(d,vec2(sdBlocksA(p, 1.), 0.));\n    p.xz *= rot(0.4);\n    d =  dmin(d,vec2(sdBlocksA(p, 10.), 0.));\n    p.yz *= rot(0.4);\n    d =  dmin(d,vec2(sdBlocksA(p, 4.), 0.));\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t= vec2(0.1,0.);\n    return normalize( map(p).x -\n    \tvec3(\n        \tmap(p - t.xyy).x,\n        \tmap(p - t.yxy).x,\n        \tmap(p - t.yyx).x\n        )\n    );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n    vec3 ro = vec3(0,0,0. + mx + iTime*90.);\n    ro.y += sin(iTime)*50.;\n    ro.x += sin(iTime + sin(iTime*0.4)*1.5)*100.;\n    vec3 roO = ro;\n    vec3 lookAt = ro + vec3(0,0,1);\n    lookAt.x += sin(iTime);\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    //rd.xz *= rot(sin(iTime*0.1));\n    vec3 rdO = rd;\n    vec3 p = ro; float t = 0., tO = 0.;\n    vec3 att = vec3(1);\n    \n    const int iterations = 200;\n    float bounce = 0.;\n    for (int i  = 0;i <= iterations + min(0, iFrame); i++){\n    \tvec2 d = map(p);\n        glow += vec3( exp(-d.x) );\n        if(d.x < 0.001){\n            vec3 lightPos = roO + vec3(0,1,0);\n            //lightPos = vec3(0,0,0);\n            vec3 lightCol = vec3(1.);\n            \n            vec3 L = normalize(lightPos - p);\n            //L = normalize(vec3(-1));\n            vec3 H = normalize(L - rdO);\n            //H *= 1.;\n            //vec3 lightCol = vec3(0.5,0.5,0.2);\n                  \n\n            int id = int(d.y);\n            float METALNESS = mats[id].metalness;\n            float ROUGHNESS = mats[id].roughness;\n            vec3 albedo = mats[id].albedo;\n            albedo = vec3(1);\n            vec3 N = getNormal(p);\n            vec3 V = normalize(ro - p);\n            //vec3 V = -rd;\n\n            vec3 F0 = vec3(0.04); \n            F0 = mix(F0, albedo, METALNESS);\n\n\n            // calculate per-light radiance\n            float distL    = length(lightPos - p)*0.003;\n            float attenuation = 1.0 / (distL * distL);\n            attenuation = clamp(attenuation, 0. ,10.);\n            //float attenuation = dist*0.02;\n            //attenuation = 1.;\n            vec3 radiance     = lightCol * attenuation;        \n\n            // cook-torrance brdf\n            float NDF = DistributionGGX(N, H, ROUGHNESS);   \n            float G   = GeometrySmith(N, V, L, ROUGHNESS);      \n            vec3 F    = fresnelSchlick(clamp(dot(N, V), 0.0, 1.0), F0);     \n\n            vec3 kS = F;\n            vec3 kD = vec3(1.0) - kS;\n            kD *= 1.0 - METALNESS;\t  \n\n            vec3 numerator    = NDF * G * F;\n            float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n            vec3 specular     = numerator / max(denominator, 0.001);  \n\n            // add to outgoing radiance Lo\n            float NdotL = max(dot(N, L), 0.0); \n            att *= vec3(.62,.576,.388)*1.4;\n            col += (kD * albedo / PI + specular) * radiance * NdotL * attenuation*att; \n  \n            vec3 ambient = vec3(0.01) ;          \n     \n            if (bounce == 0.){\n            \ttO = t;\n            }\n            bounce++;\n            ro = p;\n            rd = reflect(rd, N);\n            t = 0.;\n            d.x = 2.6;\n            if (bounce > 2.){\n                break;\n            }\n \n        }\n            \n        if(t > 300. || i == iterations){\n            if (bounce == 0.){\n            \ttO = t;\n            }\n            break;\n        }   \n        t += d.x;\n    \tp = ro + rd*t;\n    }\n    col += glow*0.0007*vec3(.62,.576,.388)*exp(-tO*0.005);\n    col *= 1.5;\n    //col = mix(col, vec3(0.1), smoothstep(0.,1.,tO*0.002));\n    col = pow(col, vec3(0.45));\n    col = smoothstep(0., 0.8,col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttV3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 276, 276, 1457]], "test": "untested"}
{"id": "3tK3Dh", "name": "Eye Saw", "author": "shau", "description": "2 scenes with font texture. Switches scene every 20 seconds", "tags": ["3d", "tunnel", "text"], "likes": 34, "viewed": 751, "published": 3, "date": "1579014618", "time_retrieved": "2024-07-30T21:30:17.430005", "image_code": "// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\n   Inspired by some of the animations on Isaac Arthur's YouTube channel \n*/\n\nconst float GA =2.399; \n\n// simplified version of Dave Hoskins blur from Virgill\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(.002*R.y/R.x, .002), angle = vec2(0, rad);;\n    rad = 1.;\n\tfor (int j = 0; j < 80; j++) {  \n        rad += 1. / rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nvoid mainImage( out vec4 C, in vec2 U) \n{     \n    vec4 anim = texture(iChannel1, ANIM/R);\n    vec3 pc = vec4(dof(iChannel0, U/R, texture(iChannel0, U/R).w), 1.).xyz;\n    \n    pc = pow(pc*2.0, vec3(1.0/2.3)); //gamma correction\n    pc *= anim.y; //fade\n\n    C = vec4(pc, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//CAMERA\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float AT = mod(T, 40.0),\n          scene = 1.0,\n          fade = min(AT*0.5, 1.0) - clamp(AT - 19.0, 0.0, 1.0) +\n                 clamp(AT - 20.0, 0.0, 1.0) - clamp(AT*0.5 - 19.0, 0.0, 1.0);\n    \n    vec3 lookAt = vec3(2.0, 0.0, T*3.0 + sin(T*0.2)*20.0),\n         camPos = vec3(0.0, 0.0, T*3.0 - 5.0);\n    lookAt += path(lookAt.z);\n    camPos += path(camPos.z);\n    \n    if (AT>20.0)\n    {\n        scene = 0.0; \n        lookAt = vec3(0.0, 0.0, 0.0),\n        camPos = vec3(0.0, sin(T*0.23)*1.8, -5.0 - sin(T*0.1));\n        camPos.xz *= rot(T*0.2);\n    }\n    \n    if (U==ANIM)\n    {\n        C = vec4(scene, fade, 0.0, 0.0);\n    }\n    else if (U==CAM_POS)\n    {\n        C = vec4(camPos, 1.0);    \n    }\n    else if (U==LOOK_AT)\n    {\n        C = vec4(lookAt, 1.0);    \n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDERING\n\n#define EPS 0.005\n#define FAR 100.0\n#define ZERO (min(iFrame,0))\n\n#define S(a,b,v) smoothstep(a,b,v)\n#define TORUS vec2(5.0, 3.0)\n#define TS vec2(0.0625)\n\n//SHADERTOY - TEXT\nconst vec2[9] text = vec2[](vec2(9.0, 10.0),  //Y\n                            vec2(15.0, 11.0), //O\n                            vec2(4.0, 10.0),  //T\n                            vec2(2.0, 10.0),  //R\n                            vec2(5.0, 11.0),  //E\n                            vec2(4.0, 11.0),  //D\n                            vec2(1.0, 11.0),  //A\n                            vec2(8.0, 11.0),  //H\n                            vec2(3.0, 10.0)); //S\n\n//extract letter from texture\nvec4 letter(vec2 uv, vec2 id, float s)\n{\n    vec4 l = vec4(0.0);\n    uv *= s; //scale\n    uv += TS*id - vec2(0.5*s) + TS*0.5; //center\n    \n    if (uv.x>(id.x*TS.x) && uv.x<((id.x + 1.0)*TS.x) && \n        uv.y>(id.y*TS.y) && uv.y<((id.y + 1.0)*TS.y))\n    {\n        l = texture(iChannel0, uv, -1.0);\n    }\n    return l;\n}\n\n//noise IQ - Shane\nfloat n3D(vec3 p) \n{    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//IQ - Usefull little functions\n//https://iquilezles.org/articles/functions\nfloat expImpulse(float x, float k)\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n//IQ - SDF primitives\n//https://iquilezles.org/articles/distfunctions\nfloat sdTorus(vec3 p, vec2 t) \n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nvec3 tunnel(vec3 p)\n{\n    p -= path(p.z); \n\treturn vec3(3.0 - length(p.xy), p.xy);    \n}\n\nvoid ring(inout vec3 pc, vec3 p, vec3 col)\n{\n    float z = fract(p.z*0.04 + -T*0.3),\n          atn1 = (1.0 / (1.0 + z*z*100000.0)) + (1.0 / (1.0 + (1.0 - z)*(1.0 - z)*100000.0)),\n          atn2 = (1.0 / (1.0 + z*z*6000.0)) + (1.0 / (1.0 + (1.0 - z)*(1.0 - z)*6000.0));\n    pc += pc*atn2*16.0;\n    pc += col * length(pc)*atn2*0.2;\n    pc += mix(col, vec3(1), 0.4)*atn1 * n3D(p.zxy*2.3+T*0.2);\n}\n\nvec4 renderTunnel(vec3 ro, vec3 rd, vec3 la, vec3 col)\n{\n    vec3 pc = vec3(0);\n    \n    float t = 0.0, dof = 0.0;\n    vec2 id = vec2(0.0);;\n    for (int i=ZERO; i<100; i++) {\n        vec3 ns = tunnel(ro + rd*t);\n        if (abs(ns.x)<EPS) {\n            id = ns.yz;\n            break;\n        }\n        t += ns.x;\n        \n        if (t>FAR)\n        {\n            t = -1.0;\n            break;\n        }\n    }\n    \n    if (t>0.0)\n    {\n        vec3 p = ro + rd*t;\n        dof = 0.0;\n\t\t//partition surface\n        float a = (atan(id.x, id.y)/6.2831853) + 0.5; //0->1\n\n        vec2 c = vec2(fract(a*60.0), //cell positiom\n                      fract(p.z*10.0)),\n        cid = vec2(floor(a*60.0), //cell id\n                   floor(p.z*10.0));\n        vec3 h3 = hash32(cid+T*0.4);\n\n        //RANDOM CHARACTERS\n        if (h3.z>0.3)\n        {\n            pc = col * letter(vec2(1.0 - c.x, c.y), floor(h3.xy*16.0), 0.1).x;\n            pc *= hash11(cid.y) * n3D(p*0.5) * n3D(p*5.0+T);\n            pc = pc*0.3 + pc*S(0.5, 1.0, n3D(p.zxy*-0.4));\n        }\n        //SHADERTOY\n        vec2 cz = vec2(c.x,\n                       fract(fract(p.z)*9.0));\n        vec2 czid = vec2(cid.x,\n                       floor(fract(p.z)*9.0));\n        if (mod(p.z, 10.0)>9.0 && hash12(czid)>0.3)\n        {\n            pc += col * 2.0 * letter(vec2(1.0 - cz.x, cz.y), text[int(czid.y)], 0.1).x;\n        }\n        \n        //lines\n        float l = length(c.x-0.5); //center line\n        l = 0.3 / (1.0 + l*l*800.);    \n        l *= hash11(cid.x+T*-0.3) * n3D(p*0.5) * n3D(p*5.0+T); //add noise\n        l = l*0.3 + l*S(0.5, 1.0, n3D(p.yxz*0.5)); //more noise   \n        float ls = l*S(1.0, 0.8, fract(p.z))*S(0.0, 0.2, fract(p.z)); //gaps in lines\n        l = mix(ls, l, step(0.8, hash11(cid.x+T*-0.3))); //more noise        \n        pc += col * l * S(0.0, 1.0, n3D((p-32.3)*0.7 + T*0.3)) * 2.0;\n        \n        ring(pc, p, col);\n        p.z += 1.4;\n        ring(pc, p, col);        \n    }\n\n    return vec4(pc, dof);\n}                      \n\nvec4 renderTorus(vec3 ro, vec3 rd, vec3 la, vec3 col)\n{\n    vec3 pc = vec3(0);\n    \n    float t = 0.0, dof = 0.0;\n    for (int i=ZERO; i<100; i++) {\n        float ns = abs(sdTorus(ro + rd*t, TORUS));\n        if (abs(ns)<EPS) break;\n        t += ns;\n        if (t>FAR)\n        {\n            t = -1.0;\n            break;\n        }\n    } \n\n    if (t>0.0)\n    {\n        vec3 p = ro + rd*t;\n        dof = length(la-p) * 0.03;\n        //partition surface\n        float aX = (atan(p.x, p.z)/6.2831853) + 0.5, //0->1\n            aY = (atan(length(p.xz)-TORUS.x, p.y)/6.2831853) + 0.5, //0->1 from BigWings\n            aYR = aY*40.0+T*0.3, //split and rotation\n            aYID = mod(floor(aYR), 40.0), //id\n            h1 = hash11(aYID)*2.0 - 1.2, //biased hash\n            h1r = h1*-1.0, //reversed\n            aXR = aX*60.0 + T*(0.5*sign(h1)+h1) + //split and rotation \n            expImpulse(mod(T*(0.6+abs(h1)), 2.0), 2.0) * sign(h1);\n\n        vec2 c = vec2(fract(aXR), fract(aYR)), //cell co-ordinate\n            cid = vec2(mod(floor(aXR), 60.0), aYID);  //cell id\n        vec3 h3 = hash32(cid); //hash on cell id\n\n        //RANDOM CHARACTERS\n        if (h3.z>0.3)\n        {\n            pc = col * letter(vec2(1.0 - c.x, c.y), floor(h3.xy*16.0), 0.1).x;\n            pc *= hash11(cid.y) * n3D(p*0.5) * n3D(p*5.0+T);\n            //pc = pc*0.3 + pc*S(0.5, 1.0, n3D(p.zxy*-0.4));\n        }\n\n        //SHADERTOY\n        if (cid.y==9.0 && cid.x<9.0)\n        {\n            pc = 2.0 * col * letter(vec2(1.0 - c.x, c.y), text[int(cid.x)], 0.1).x;                \n        }\n        else if (cid.y==15.0 && cid.x>22.0 && cid.x<32.0)\n        {\n            pc = 2.0 * col * letter(vec2(1.0 - c.x, c.y), text[int(cid.x) - 23], 0.1).x;                \n        }\n        else if (cid.y==30.0 && cid.x>39.0 && cid.x<49.0)\n        {\n            pc = 2.0 * col * letter(vec2(1.0 - c.x, c.y), text[int(cid.x) - 40], 0.1).x;                \n        }\n\n        //GLOW LINES\n        //with wrapping\n        vec2 scl = vec2(30.0, 1.0), //scale\n             bp = vec2(fract(T*(0.1 + abs(h1r)*0.1))*scl.x * sign(h1r), 0.5);  //center\n\n        //disk\n        float bd = h1r>0.0 ? -scl.x : 2.0*scl.x;\n        float b = length(bp - vec2(aX, c.y)*scl);\n        b = min(b, length(vec2(bp.x + scl.x, bp.y) - vec2(aX, c.y)*scl));\n        b = min(b, length(vec2(bp.x + bd, bp.y) - vec2(aX, c.y)*scl));\n\n        //line\n        float l = length(c.y - 0.5);\n        float lb1 = length(bp.x/scl.x - aX);\n        float lb2 = length((bp.x + scl.x)/scl.x - aX);\n\n        pc += col / (1.0 + b*b*1000.0);\n        pc += vec3(1) / (1.0 + b*b*6000.0);            \n\n        float clip1 = h1r>0.0 ? step(aX, bp.x/scl.x) : step(bp.x/scl.x, aX);\n        float clip2 = h1r>0.0 ? step(aX, (bp.x + scl.x)/scl.x) : step((bp.x + scl.x)/scl.x, aX);\n        pc += col * S(0.02, 0.0, l) / (1.0 + lb1*lb1*4000.0) * clip1;\n        pc += col * S(0.02, 0.0, l) / (1.0 + lb2*lb2*4000.0) * clip2;\n        pc += vec3(1) * S(0.02, 0.0, l) / (1.0 + lb1*lb1*12000.0) * clip1;\n        pc += vec3(1) * S(0.02, 0.0, l) / (1.0 + lb2*lb2*12000.0) * clip2;\n    }\n\n    return vec4(pc, dof);\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage( out vec4 C, in vec2 U) \n{     \n    vec4 cam = texture(iChannel1, CAM_POS/R),\n         lookAt = texture(iChannel1, LOOK_AT/R),\n         anim = texture(iChannel1, ANIM/R);\n    vec3 col = rotHue(vec3(0,1,0), T*0.2) * 2.0;\n    \n    vec3 rd = camera(U, cam.xyz, lookAt.xyz, 1.8);\n\n    //debug text lookup\n    //vec2 uv = U/R;\n    //vec2 lid = vec2(3.0, 10.0); //S\n    //pc += letter(uv, lid, 0.06);\n    \n    if (anim.x==0.0)\n    {\n        C = renderTorus(cam.xyz, rd, lookAt.xyz, col);\n    }\n    else if (anim.x==1.0)\n    {\n        C = renderTunnel(cam.xyz, rd, lookAt.xyz, col);\n    }\n}", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define PI 3.141592\n#define R iResolution.xy\n#define T mod(iTime, 640.0)\n#define CAM_POS vec2(0.5, 0.5)\n#define LOOK_AT vec2(1.5, 0.5)\n#define ANIM vec2(2.5, 0.5)\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n//Dave Hoskins - Hash without sin\n//https://www.shadertoy.com/view/XdGfRR\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash12(vec2 p) \n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec3 hash32(vec2 q)\n{\n\tuvec3 n = uvec3(ivec3(q.xyx)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n\n//standard path deform - check out any tunnel by Shane or Aiekick for some good examples\nvec3 path(float t) \n{\n    float a = sin(t * PI / 24. + 2.7);\n    float b = cos(t * PI / 24.);\n    return vec3(a * 3., b * a, 0.);\n} ", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tK3Dh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[275, 331, 376, 376, 652], [654, 654, 695, 695, 932]], "test": "untested"}
{"id": "wtV3DW", "name": "Angle bug #18", "author": "FabriceNeyret2", "description": "try #if 0 or 1\nboth should give pink on left , green on right.\nbut on windows Angle, #if 0 ( testing with (cond)?: instead of if;else ) get cyan on right instead of green.\nand on windows Opengl, #if 0/1 both give white on left , green-yellow grade right  ", "tags": ["glsl", "bug", "angle"], "likes": 0, "viewed": 381, "published": 3, "date": "1579009094", "time_retrieved": "2024-07-30T21:30:18.177007", "image_code": "// NB: overparenthesing is useless: just to be sure ;-)\n\nvoid mainImage(out vec4 O,vec2 U) \n{ \n   U /= iResolution.xy; // normalize coordinates\n   O = vec4(0); \n\n#if 0\n    \n  if ( U.x < .5 )         // left: pink\n          (\n             ( O.b = U.y > .5 ?  1. :1. ), // blue\n               O.r = 1.                    // + red\n          );\n        else   O.g = 1.;  // right: green\n#else \n    \n    ( U.x < .5 )          // left: pink\n        ? ( \n             ( O.b = U.y > .5 ?  1. :1. ), // blue\n               O.r = 1.                    // + red\n          )\n        :      O.g = 1.;  // right: green  ( but not on windows Angle )\n\n#endif            \n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtV3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 93, 93, 656]], "test": "untested"}
{"id": "wlK3WW", "name": "Color Oscilloscope", "author": "flemmingdjensen", "description": "Testing an oscilloscope effect", "tags": ["oscilloscope", "sin", "cos", "lissajous"], "likes": 2, "viewed": 642, "published": 3, "date": "1578994408", "time_retrieved": "2024-07-30T21:30:19.009780", "image_code": "// Back to good old times when playing with an oscilloscope in X/Y mode\n\n#define S smoothstep\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n        \n    vec2 rp = vec2(cos(iTime*20.5), sin(iTime*20.));\n    vec2 gp = vec2(cos(iTime*15.5), sin(iTime*17.));\n    vec2 bp = vec2(cos(iTime*17.4), sin(iTime*18.));\n    \n    col += vec3(S(.15, .1, distance(uv, rp * .4)), 0., 0.);\n    col += vec3(0., S(.15, .1, distance(uv, gp * .4)), 0.);\n    col += vec3(0., 0., S(.15, .1, distance(uv, bp * .4)));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlK3WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 152, 152, 633]], "test": "untested"}
{"id": "3tV3DW", "name": "Reflections Test", "author": "cowsed", "description": "reflections test agh recursion", "tags": ["raymarch"], "likes": 4, "viewed": 375, "published": 3, "date": "1578968506", "time_retrieved": "2024-07-30T21:30:19.860506", "image_code": "//    \n// Testing Sebastian Aaltonen's soft shadow improvement\n//\n// The technique is based on estimating a better closest point in ray\n// at each step by triangulating from the previous march step.\n//\n// More info about the technique at slide 39 of this presentation:\n// https://www.dropbox.com/s/s9tzmyj0wqkymmz/Claybook_Simulation_Raytracing_GDC18.pptx?dl=0\n//\n// Traditional technique: https://iquilezles.org/articles/rmshadows\n//\n// Go to lines 54 to compare both.\n\n\n// make this 1 is your machine is too slow\n#define AA 2\n\n#define tMin 0.001\n#define tMax 20.1\n//------------------------------------------------------------------\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n ){\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec2 x ){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\nfloat fbm( vec2 p ){\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nfloat sdSphere( vec3 p ,float r)\n{\n\treturn length(p)-r;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nvec2 min2(vec2 a, vec2 b){\n    return (a.x < b.x) ? a : b;\n}\n\n//------------------------------------------------------------------\n\nvec2 map(vec3 pos){\n    vec3 qos = 1.*vec3( (fract(pos.x+.5)-.5)*1., pos.y,fract(pos.z+0.5)-0.5 );//repeatSpace on xz axis\n    return min2(vec2(sdPlane(pos-vec3(0)),0.)  ,  vec2(sdBox(pos-vec3(0.,.2,0.),vec3(.2)) ,1.));\n}\n//------------------------------------------------------------------\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // traditional technique\n\n        // improved technique\n        \n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n\tfloat mat=-1.;\n\n    \n    float t = tMin;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n        vec2 a=map( ro+rd*t);\n\t    float res =a.x;\n        if( res<precis || t>tMax ){\n            mat=a.y;\n        \tbreak;\n    \t}\n        t += res;\n    }\n\n    if( t>tMax ) t=-1.0;\n    return vec2(t,mat);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\nvec3 shader2(vec2 uv){\n\t//WE NEED TO GO DEEPER\n    uv*=1.5;\n    float r= length(uv);\n    float a=atan(uv.x,uv.y)+iTime;\n    float f=cos(a*4.)/2.;\n    return vec3(clamp(step(f,r),.1,1.)/3.)*texture(iChannel0,uv).xyz/1.3;\n}\nvec3 reflectRay(vec3 rd, vec3 n){\n\n\treturn rd-2.*dot(rd,n)*n;\n}\nvec3 render( in vec3 ro, in vec3 rd, int depth)\n{ \n    vec4 materials[3];\n    //rgb reflection 1 is [perfect mirror. 0 is totally matte\n    materials[0]=vec4(.4,.3,.2,0);//background\n    materials[1]=vec4(.7,.0,0,0.5); \n    materials[2]=vec4(.7,.0,1,0); \n\n    vec3  col = vec3(0);\n    vec2 a = castRay(ro,rd);\n\tfloat t=a.x;\n    for (int i =0; i<= depth; i++){\n    if( t>-.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material       \n        vec2 matUV=mix(mix(vec2(pos.xz),vec2(pos.zy), nor.x), pos.xy ,nor.z);//YAY\n\t\tmaterials[0]=vec4(shader2(fract(matUV-.5)-.5),0.);        \n        //materials[0]=reflect(rd,nor);\n\t\t//materials[1]=reflect(rd,nor);\n\n\t\tvec4 mate = materials[int(a.y)];\n\t\t    // key light\n    \t    vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\n\t        vec3  hal = normalize( lig-rd );\n    \t    float dif = 1.5*clamp( dot( nor, lig ), 0.0, 1.0 ) * \n                    calcSoftshadow( pos, lig, 0.01, 3.0 );\n\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n    \t    float spec=2.;\n        \tvec3 lig_col = vec3(1.0,1.0,1.);\n\t\t\tcol = mate.xyz *2.0*dif*lig_col;\n    \t    col +=      spec*spe*lig_col;\n        \n\t        // ambient light\n    \t    float occ = calcAO( pos, nor );\n\t\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    \t    col += mate.xyz*amb*occ;        \n\t        // fog\n    \t    col *= exp( -0.0005*t*t*t );\n        \n    }\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n\n    vec3 ro = vec3( .0, .8, -3.0 );\n    //ro.y-=iMouse.w/iResolution.y;\n    vec3 ta = vec3( 0.0, -0.4, 1.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\t\t//p.y-=iMouse.y/iResolution.y-1.;//cjhange angle\n                // ray direction\n        vec3 rd = normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, 2);//2 reflections alloed\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tV3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[686, 686, 708, 708, 747], [748, 748, 773, 773, 994], [995, 995, 1015, 1015, 1262], [1264, 1264, 1289, 1289, 1304], [1305, 1305, 1339, 1339, 1362], [1363, 1363, 1394, 1394, 1485], [1486, 1486, 1512, 1512, 1546], [1618, 1618, 1637, 1637, 1839], [1910, 1910, 1988, 1988, 2685], [2687, 2687, 2719, 2719, 2927], [2929, 2929, 2969, 2969, 3284], [3286, 3286, 3328, 3328, 3591], [3592, 3592, 3614, 3638, 3813], [3814, 3814, 3847, 3847, 3877], [3878, 3878, 3927, 3927, 5423], [5425, 5425, 5477, 5477, 5654]], "test": "untested"}
{"id": "3tKGWD", "name": "procedural topography thing", "author": "MickLH", "description": "Based on Jon's world generator tutorial:\nhttp://www.jgallant.com/procedurally-generating-wrapping-world-maps-in-unity-csharp-part-1/\n\nUses Makio64's noise function:\nhttps://www.shadertoy.com/view/Xd3GRf", "tags": ["procedural"], "likes": 2, "viewed": 435, "published": 3, "date": "1578968464", "time_retrieved": "2024-07-30T21:30:20.654383", "image_code": "lowp vec4 permute(in lowp vec4 x) {\n    vec4 z = mod(x*x*34.0+x,vec4(289.0));\n    z = mod(z*z*12.0 + x*z*23.0 + x*x*34.0,vec4(289.0));\n    return z;\n}\nlowp float snoise(in mediump vec3 v) {\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return .5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = fragCoord.xy / iResolution.xy;\n    float noise = 0.0, fac = 0.5, oct = 2.0;\n    for(int i=0;i<6;i++) {\n        noise += fac * snoise(vec3(pos*oct, iTime*0.05 + float(i)*257.0));\n        oct *= 2.0;\n        fac *= 0.5;\n    }\n    noise = smoothstep(0.0, 1.0, noise);\n    vec3 color = vec3(0.0, 0.0, 0.5);\n    if (noise > 0.2) color = vec3( 25.0,  25.0, 150.0) / 255.0;\n    if (noise > 0.4) color = vec3(240.0, 240.0,  64.0) / 255.0;\n    if (noise > 0.5) color = vec3( 50.0, 220.0,  20.0) / 255.0;\n    if (noise > 0.7) color = vec3( 16.0, 160.0,   0.0) / 255.0;\n    if (noise > 0.8) color = vec3(0.5);\n    if (noise > 0.9) color = vec3(1.0);\n    \n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1721, 1721, 1778, 1778, 2467]], "test": "untested"}
{"id": "ttyGWD", "name": "pseudo-Tron screensaver ( 399c )", "author": "FabriceNeyret2", "description": "golfing https://shadertoy.com/view/wly3DW  ( 909 chars )\n", "tags": ["tron", "particles", "short", "golf", "3tweets"], "likes": 9, "viewed": 611, "published": 3, "date": "1578940930", "time_retrieved": "2024-07-30T21:30:21.404378", "image_code": "// golfing https://shadertoy.com/view/wly3DW  ( 909 chars )\nvoid mainImage(out vec4 O, vec2 U) { mi }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 O, vec2 U) { mi }", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// +6: wow: a windows Angle compatibility bug forbids using (cond)?: for iFrame==0 || O.w < 0.\n//                                            cf: https://www.shadertoy.com/view/wtV3DW\n\n#define T(U) texture( iChannel0, U / H.xy )                    //\n#define mi                                                      \\\n    vec4 H = iResolution.xyzz;   int t = iFrame;                \\\n    O = T(U);                                                   \\\n    if (U.y < 1.)  /* move particles */                         \\\n        if ( t < 1 || O.w < 0. )                                \\\n            H = fract( sin( (iTime+U.x) * H ) *4e4 ),           \\\n            O.z = t < 1 ? O = H, H.z*4.                         \\\n                        : mod( O + sign(H-.5), 4.).z,           \\\n            O.w = fract(H.z*4.)*60. ;                           \\\n        else O[ t = int(O.z)%2 ] = fract( O + sign(O.z-2.) * H.y/2e2/H )[t], \\\n            O.w-- ;                                             \\\n    else           /* draw trajectories */                      \\\n        for( H--, O *= .99; H.z++ < 30.; )                      \\\n            O = mix( O, .6 + .6 * cos( H.z + vec4(0,23,21,0) ), \\\n                     clamp( H.y/2e2 - length( U - (H*T(H.zw)).xy )/2., 0.,1. ) ); /*\n\n\n\n\n\n// --- 416 chars\n\n#define T(U) texture( iChannel0, U/H.xy )                    //\n#define mainImage(O,U)                                        \\\n    vec3 h, H = iResolution;                                  \\\n    float i=.5, r = H.y/2e2; int s;                           \\\n    O = T(U);                                                 \\\n    if (U.y < 1.)  /* move particles * /                       \\\n        if ( iFrame==0 || O.w < 0. )                          \\\n            h = fract( sin( (iTime+U.x) * H ) *4e4 ),         \\\n            i = h.z*4.,                                       \\\n            O.z = iFrame==0 ? O.xy = h.xy, i                  \\\n                            : mod( O.z + sign(i-2.), 4.),     \\\n            O.w = fract(i)*60. ;                              \\\n        else O[ s= int(O.z)%2 ] = fract( O[s] + sign(O.z-2.) * r/H[s] ), \\\n            O.w-- ;                                           \\\n    else           /* draw trajectories * /                    \\\n        for( O *= .99; i++ < 30.; )                           \\\n            O = mix( O, .6 + .6 * cos( i + vec4(0,23,21,0) ), \\\n                     clamp( r - length( U - H.xy* T(vec2(i,0)).xy )/2., 0.,1. ) ) /*\n\n\n\n\n\n// --- 452 chars \n\n#define T texture(iChannel0//\n#define mainImage(O,U)                                        \\\n    vec2 R = iResolution.xy;                                  \\\n    float i=.5, r = R.y/2e2; int s; vec3 h;                   \\\n    O = T,U/R);                                               \\\n    if (U.y<1.)  /* move particles * /                         \\\n        if ( iFrame==0 || O.w < 0. )                          \\\n            h = fract( sin( vec2(iTime,U)* mat3x2(12.1,7.7,  29.3,46.1,  13.3,24.6))*4e4), \\\n            i = h.z*4.,                                       \\\n            O.z = iFrame==0 ? O.xy = h.xy, i                  \\\n                            : mod( O.z + sign(i-2.), 4.),     \\\n            O.w = fract(i)*60. ;                              \\\n         else O[ s= int(O.z)%2 ] = fract( O[s] + sign(O.z-2.) * r/R[s] ), \\\n            O.w-- ;                                           \\\n    else         /* draw trajectories * /                      \\\n        for( O *= .99; i++ < 30.; )                           \\\n            O = mix( O, .6 + .6 * cos( i + vec4(0,23,21,0) ), \\\n                     clamp( r - length( U - R* T,vec2(i,0)/R).xy )/2., 0.,1. ) ) /*\n\n\n\n\n\n// --- 477 chars \n\n#define mainImage(O,U)                                        \\\n    vec2 R = iResolution.xy;                                  \\\n    float i=.5; int s; vec3 h;                                \\\n    O = texture(iChannel0,U/R);                               \\\n    if (U.y<1.)  /* move particles * /                         \\\n        iFrame==0 || O.w < 0.                                 \\\n          ? h = fract( sin( vec2(iTime,U)* mat3x2(127.1,74.7,  269.5,246.1,  113.5,124.6))*4e5), \\\n            i = floor(h.z*=4.),                               \\\n            O.z = iFrame==0 ? O.xy = h.xy, i                  \\\n                            : mod( O.z + sign(i-1.5), 4.),    \\\n            O.w = fract(h.z)*60.                              \\\n         :( O[ s= int(O.z)%2 ] = fract(O.xy + sign(O.z-1.5) * R.y/R/2e2 ) [s], \\\n            O.w-- );                                          \\\n    else         /* draw trajectories * /                      \\\n        for( O *= .99; i++ < 30.; )                           \\\n            O = mix( O, .6 + .6 * cos( i + vec4(0,23,21,0) ), \\\n                     clamp( R.y/2e2 - length( U - R*texture(iChannel0,vec2(i,0)/R).xy )/2., 0.,1. ) ) /*\n\n/**/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wly3DW", "name": "pseudo-Tron screensaver", "author": "FabriceNeyret2", "description": "just for fun.\n\ncode golfed here: [url]https://www.shadertoy.com/view/ttyGWD[/url]", "tags": ["tron", "particles"], "likes": 15, "viewed": 632, "published": 3, "date": "1578937564", "time_retrieved": "2024-07-30T21:30:22.150384", "image_code": "// === display buffer ====================================\n\nvoid mainImage( out vec4 O, vec2 U ) { O = T(U); }", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === move particles ====================================\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n    \n    if (iFrame==0 || O.w<0.) {  // --- called at init + particle timer\n        vec3 r = hash3(vec3(U,iTime));\n        if (iFrame==0) O.xy = r.xy *R/R.y;  // xy = normalized location\n        float d = floor(r.z*4.);\n        O.z = iFrame==0 ? d                 // z = direction: random\n                        : mod( O.z + sign(d-1.5), 4.); // or random turn\n        O.w = fract(r.z*4.)*60.;            // w = life time of current move\n        return;\n    }\n    if (U.y>1.) return;                     // limit particles\n    \n                                     // --- move particle\n    float d = sign(O.z-1.5) * radius/2.;    // dir = + or - ?\n    int(O.z)%2==0                           // orientation = x or y ?\n        ? O.x = fract((O.x+d)/ratio)*ratio  // screen wrap\n        : O.y = fract((O.y+d));\n    O.w--;                                  // timelife decrease \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// === utils from https://www.shadertoy.com/view/llySRh ==========\n\n#define radius   .01\n#define T(U)     texelFetch(iChannel0, ivec2(U), 0)\n#define T1(U)    texelFetch(iChannel1, ivec2(U), 0)\n#define R      ( iResolution.xy )\n#define ratio  ( R.x / R.y )\n#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n#define S(v)     smoothstep( 0., -1.5/R.y, v )\n#define hue(c) ( .6 + .6 * cos( 6.3*(c)  + vec4(0,23,21,0)  ) )\n", "buffer_b_code": "// === draw bands ====================================\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U)*.99;                   // keep and fade past \n    \n    for(float i=0.; i++<30.; ) {    // draw particles\n        vec2  V = abs( U/R.y - T1(vec2(i,0)).xy ) / radius;\n        float r = dot(V,V);\n        if (r<1.) O = mix( O, hue(i/30.), S((sqrt(r)-1.)*radius)); // blend\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wly3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 98, 98, 110]], "test": "untested"}
{"id": "3lcGWs", "name": "Day 25 - Jupeia", "author": "jeyko", "description": "\nCode is messy btw.", "tags": ["sound", "audio"], "likes": 7, "viewed": 405, "published": 3, "date": "1578927207", "time_retrieved": "2024-07-30T21:30:23.083888", "image_code": "\n\n// The very awesome IRR bass is from https://www.shadertoy.com/view/XljSD3\n\n\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}    \n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.8+0.5*sin(iTime),1.0);\n\n}", "image_inputs": [], "sound_code": "#define pi acos(-1.)\n#define tau (2.*pi)\n  \n#define tempo 174.\n#define hbeat ((60./tempo)/1.)\n#define qnote (hbeat/2.)\n#define beat  (hbeat*2.)\n#define qbeat  (beat/4.)\n#define measure  (beat*4.*4.)\n#define hmsr  (measure*0.5)\n\n#define P(x) t/measure < x\n#define PL(x) t/measure > x\n   \n\n// here's 11 noise functions\n// thanks to people i got them from xd\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\nfloat hash(float i){\n\treturn fract(sin(114.121*i)*11252.11242512);\n}\nfloat noise( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\n\nfloat rnd(float i){\n\treturn fract(sin(i)*1235.41252156);\n}\nfloat nois(float t){\n    float n = 0.;\n    n = fract(rnd(t)*rnd(t*2.41));\n    vec2 p = vec2(fract(rnd(t*14.11)),fract(rnd(t*124.1)*rnd(t*3.15)));\n    vec2 q = vec2(fract(rnd(t*14.124)*rnd(t*41.15)), n*0.15);\n    n = fract(dot(p,q));\n    \n\treturn n;\n}   \nfloat random(float st){\n    \n\treturn fract(sin(114.121*st)*11252.11242512);\n\t//return fract(sin(st*651.5524)*4.4214);\n}\n\n\nfloat notVeryRandom(float st){\n    return fract(sin(st*451.5524));\n}\nfloat rand(float t) {\n\treturn fract(sin(t*3211251.325235325));\n}\nfloat random( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\n\nfloat noiseB(vec2 p) { // thx to whoever I got this from!\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\n\nfloat arp(float t, float period, float scale) {\n\tfloat n = 0. ;\n    float r = random( mod( floor(t/period), 50.));\n    r *= 7.;\n    r = floor(r);\n    (r == 0.) ? n = note(9., 0.) :\n    (r == 1.) ? n = note(9., 0.) :\n    (r == 2.) ? n = note(9. + 3., 0.) :\n    (r == 3.) ? n = note(9., 0.) :\n    (r == 4.) ? n = note(9. + 5., 0.) :\n    (r == 5.) ? n = note(9. + 7., 0.) :\n    (r == 6.) ? n = note(9. + 12., 0.) :\n    (r == 7.) ? n = note(9., 1.) : 0.;\n    //);\n    return n;\n}\nfloat arpB(float t, float period, float scale, float rep, float seed) {\n\tfloat n = 0. ;\n    float r = random( mod( floor(t/period), rep) + seed);\n    r *= 7.;\n    r = floor(r);\n    (r == 0.) ? n = note(9., 0.) :\n    (r == 1.) ? n = note(9. + 3., 0.) :\n    (r == 2.) ? n = note(9. + 2., 0.) :\n    (r == 3.) ? n = note(9. + 7., 0.) :\n    (r == 4.) ? n = note(9. + 10., 0.) :\n    (r == 5.) ? n = note(9. + 10., 1.) :\n    (r == 6.) ? n = note(9. + 9., 1.) :\n    (r == 7.) ? n = note(9., 1.) : 0.;\n    //);\n    return n;\n}\n\n\n\nvec2 snare(float t) {\n\tvec2 s = vec2(0);\n\tt = mod(t + hbeat, beat);\n    \n    float env = exp(-t*20.);\n    float noise = noise(vec2(t))*env;\n    //s.x += ;\n    s.x += sin((180. + env*150. + noise*20.)*tau*t )*env;\n    s.y = s.x;\n    \n    return s;\n}\nvec2 kickSecond(float t, float phase) {\n    vec2 s = vec2(0);\n    float r = notVeryRandom( mod(floor(t/ hbeat), 26.));\n    float rB = notVeryRandom( mod(floor((t)/ hbeat) + 4., 26.));\n    \n    float limit = 0.26;\n    if (P(4.)){\n  \t\tlimit = 0.02;   \n    }\n    \n    if (rB < limit) {\n        r *= 3.99;\n\t\tr = floor(r);\n        r += 1.;\n        float offs = hbeat * 1./r;\n        if (offs == hbeat) {\n        \toffs -= hbeat/4.;\n        }\n        t = mod(t + offs, hbeat);\n\n        float env = exp(-t*10.);\n        if (phase == 1.) {\n        \ts.x += sin( (140. * env+ 10. ) *tau*t) * env ;\n        } else if (phase == 2.) {\n        \ts.x += sin( (240. * env+ 10. ) *tau*t) * env ;\n        }\n\t\n    \t//s.x += sin( (random(t)) *tau*t) * env*2. ;\n        \n        s.x = clamp(s.x*1.6,-1., 1.);\n\n        \n        s.y = s.x;\n    \n    }\n    \n\treturn s;\n}\nvec2 lead(float t) {\n\tvec2 s = vec2(0);\n    \n    float note;\n    if (P(4.)){\n    \t//note = arpB(t, beat, 1., 4., 14.2);\n        note = arpB(t, beat, 1., 8., 39.9);\n    \tt = mod(t,beat);\n    } else if (P(5. + 3.)){\n    \tnote = arpB(t, beat, 1., 8.,  20.9);\n    \tt = mod(t,beat);\n    } else if (P(8.)){\n    \tnote = arpB(t, beat, 1., 8.,  20.9);\n    }\n    float env = exp(-t*9.);\n    \n    float iterations = 5.;\n    float freq = note;\n    float scale = 1.;\n    for (float i = 0.; i < iterations; i++) {\n        float r = random(i)*10.;\n    \ts.x += sin((note + r)*tau*t )*env*scale;\n    \ts.x += sin(note*tau*(t + 0.05) )*env*scale;\n    \ts.x += sin(0.5*note*tau*(t + 0.06) )*env*scale;\n        scale *= 0.8;\n        s.x * 0.33;\n        note *= 2.01;\n    }\n    s.x /= iterations;\n    s.y = s.x;\n    return s;\n}\nvec2 echoChannel(float t) {\n\tvec2 s = vec2(0);\n\n    float fb = 0.85, tm = qbeat*1.5, cf = 0.9, ct = tm;\n    // tap 1 \n    s += lead(t) * cf; cf *= fb; \n    \n    s += lead(t) * cf; cf *= fb; \n    // tap 2\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 3\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 4\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    // tap 5\n    s += lead(t - ct) * cf; cf *= fb; ct += tm;\n    \n    return s;\n}\n\n\n\nvec2 synthLead (float t) {\n\tvec2 s = vec2(0);\n    \n    float note = arp(t, qnote, 1.);\n    t = mod(t,qnote);\n    float env = exp(-t*20.);\n    \n    float iterations = 5.;\n    float freq = note;\n    float scale = 1.;\n    for (float i = 0.; i < iterations; i++) {\n        float r = random(i)*10.;\n    \ts.x += sin((note + r)*tau*t )*env*scale;\n    \ts.x += sin(note*tau*(t + 0.05) )*env*scale;\n    \ts.x += sin(0.5*note*tau*(t + 0.06) )*env*scale;\n        scale *= 0.8;\n        s.x * 0.33;\n        note *= 2.01;\n    }\n    s.x /= iterations;\n    s.y = s.x;\n    return s;\n}\n\n\nvec2 hats (float t) {\n\tvec2 s = vec2(0);\n\n    t = mod(t, hbeat);\n    float env = exp(-t*20.);\n    \n    float r = random(t);\n    s.x = sin(470.*t*tau + sin(2040.*t*tau + r*4500.)*4. + r*7.*env ) * env;\n    s.y = s.x;\n    \n    return s;\n}\n\nvec2 hatsTwo (float t) {\n\tvec2 s = vec2(0);\n\n    t = mod(t, hbeat/2.);\n    float env = exp(-t*50.);\n    \n    float r = random(t);\n    s.x = sin(570.*t*tau + sin(2040.*t*tau + r*1500.)*4. + r*4. ) * env;\n    s.y = s.x;\n    \n    return s;\n\n}\n\nvec2 hatsThree(float time){\n    \n\tfloat s;\n    int t = int(time*iSampleRate/7.);\n    t = int(time*iSampleRate*2.);\n    float currentMeasure = floor(time/(measure));\n    time = mod(time, qbeat);\n    //time = mod(time, beat);\n\n    t = t % ((t >>3) % t*2);\n    s =float(t & 0xff - 128)/ 128.;\n    s *= pow(exp(-mod(time,qbeat*20.)), 10.);\n    s = (s + (s*noise(time * mod(time, 0.001)*300.).x)*2.*exp(-time));\n    s *= 3.;\n\n\n    \n    return vec2(float(s));\n}\n\n\n\nvec2 makeAmb(float t) {\n\tvec2 s = vec2(0);\n\n    float freqA = note(9., 0.);\n    float freqB = note(9., 1.);\n    float freqC = note(9. + 7., 1.);\n    float scale = 1.;\n    float iters = 6.;\n    for (float i = 0.; i < iters; i++) {\n    \n        s.x += sin(tau*t*freqA    )*scale * 0.5;\n        s.x += sin(tau*t*freqB    )*scale * 0.2;\n        s.x += sin(tau*t*freqC  + smoothstep(0.,1.,sin(t) * noise(vec2(t))*0.5)  )*scale * 0.4;\n    \tfreqA *= 2.002 +random(i)*0.3 + sin(t + i)*0.002;\n    \tfreqC *= 2.002 +random(i)*0.3 + sin(t + i)*0.002;\n    \tfreqB *= 1.501;\n        scale *= 0.2 + smoothstep(0.,1., t*0.2)*0.3 + cos(t * 0.2)*0.1;\n    }\n    s.y = s.x;\n    \n    return s;\n}\n\n// The awesome IRR bass is from https://www.shadertoy.com/view/XljSD3\nfloat Hash( float n )\n{\n\treturn fract( (1.0 + cos(n)) * 415.92653);\n}\n\n//we can use jitter for analog driftness\nfloat genSaw(float time, float freq, bool useJitter)\n{\n    float jitter1 = 0.0;\n    float jitter2 = 0.0;\n\n    if(useJitter)\n    {\n      jitter1 = texture(iChannel0, vec2(time,0.2)*0.01).x;\n      jitter2 = texture(iChannel0, vec2(time-0.01,0.2)*0.01).x;\n    }\n    \n    float val = fract(time*(freq + (jitter1+jitter2)*0.2));\n    return val;\n}\n\nfloat genNiceSaw(float time, float freq, bool useJitter)\n{\n    return (genSaw(time,freq,useJitter) - 0.5) * 2.0;\n}\n#define maxTaps 40\n/* Reso lowpass saw... truncated IIR #yoloswag */\nfloat resoLpSaw(float time, float freq, float fa)\n{\n    \n    fa= sqrt(fa);\n\tfloat reso = 0.1;   \n    float c = pow(0.5, (128.0-fa*128.0)   / 16.0);\n  \tfloat r = pow(0.5, (reso*128.0+24.0) / 16.0);\n    \n    float v0,v1;\n    v0 = 0.0;\n    v1 = 0.0;\n    \n    for(int i = 0; i < maxTaps; i++)\n    {\n          float history = float(maxTaps-i)*(1.0/44100.0);\n\n          float t = time - history;\n          float inp = genNiceSaw(t,freq,false);\n          v0 =  (1.0-r*c)*v0  -  (c)*v1  + (c)*inp;\n  \t\t  v1 =  (1.0-r*c)*v1  +  (c)*v0;\n    }\n    \n    return v1;\n}\nvec2 makeBass (float t) {\n\tvec2 s = vec2(0);\n    \n    float tB = t;\n    float freq = arp(t, qnote, 1.);\n    t = mod(t,qnote);\n    float env = exp(-t*8.);\n    \n    float iterations = 5.;\n    float scale = 1.;\n\n    \n      s.x += resoLpSaw(t, freq, abs(cos(t*5.)*(0.25 + 0.55*smoothstep(0.,1., ((tB/measure)-4.)*0.5)))) * env * scale ;\n    /*\n    if (P(4.)){\n        s.x += resoLpSaw(t, freq, abs(cos(t*5.)*0.25)) * env * scale ;\n        \n    } else {\n        s.x += resoLpSaw(t, freq, abs(cos(t*5.)*(0.25 + 0.75*smoothstep(0.,1., (tB/measure)-4.)))) * env * scale ;\n    }*/\n    //s.x /= iterations;\n    s.y = s.x;\n    return s;\n}\n\nvec2 makeBells(float t, float freq, float scale) {\n    vec2 s = vec2(0);\n    float r = random( mod(floor(t/ hbeat), 26.) + 4.);\n    float rC = r;\n    float rB = random( mod(floor((t + 4.)/ hbeat) + 4., 26.));\n        float env = exp(-t*15.);\n        \n        float iters = 3.;\n    \tfor (float i = 0.; i < iters; i++) {\n            s.x += sin(freq *tau*t) * scale * (2. + sin(t));\n            \n            freq *= 2.01;\n        }\n        s.y = s.x;\n    \n    return s;\n}\n  \n\nvec2 reverbChannelB(float t) {\n\tvec2 s = vec2(0);\n    \n    vec2 reverb = vec2(0);\n    float st = 0.001; float iters = 20.;\n    for (float i = 0.; i < iters; i++) {\n    \treverb += ((makeBells(t - i*st + random(i )*0.4, note(9.,1.), 0.4 ))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st + sin(t)*0.01 + random(i )*0.4, note(16.,1.), 0.7))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st - sin(t*0.8)*0.01 + random(i )*0.4, note(19.,1.), 0.7))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st + 0.02 - sin(t*0.8)*0.01 + random(i )*0.4, note(12.,2.), 0.7))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st - 0.01 + sin(t*0.5 + sin(t*note(16.,2.)*tau*0.5 + sin(t*note(16. + 7.,1.)))*0.13*sin(t*0.8))*0.01 + random(i )*0.4, note(16.,2.), 0.3))/iters) *(1. - i/iters) ;\n    }\n\n    s += ((makeBells(t , note(9.,1.), 0.4 ))/iters)*0.001;\n    s += ((makeBells(t  , note(12.,2.), 0.1))/iters)*0.001;\n    s += ((makeBells(t  , note(18.,2.), 0.5))/iters)*0.001;\n    \n    s += reverb*5.5;\n\treturn s;\n}\n\n\nvec2 chorusChannel(float t){\n\n\tfloat iters = 5.;\n    vec2 s = vec2(0);\n    \n    \n    for(float i = 0.; i < iters; i++){\n        float r = random(i);\n        float rB = fract(r*124.52412);\n    \ts += reverbChannelB(t + r*0.1 + 0.02*r + sin(t*(1. - rB*0.05))*(0. + r*0.01));\n    }\n    s += reverbChannelB(t)*0.5;\n    \n    s /= iters;\n    s*= 0.125;\n    return s;\n}\nvec2 sAmbG(float t, float freq){\n\tvec2 s = vec2(0);\n    t = mod(t, hmsr);\n    float iters = 3. + clamp( exp(-t/2.)*5., 0., 30.);\n    for (float i = 1.;i < iters ; i++){\n    \ts += sin(t*tau*freq*i)/i;\n    }\n    vec2 n = noise(t);\n    vec2 sOrig = s;\n    float tMod = sin(t*8.)*(1. + exp(t/2.- 1.)*0.3);\n    float tMod2 = cos(t*2.)*0.5;\n    s = sOrig*sin(freq*4.*t*tau + n.x*0.4  + tMod          );\n    s += sOrig*sin(freq*2.*t*tau + n.y*0.4 + tMod2        );\n    s += sOrig*(fract(freq*8.*t*tau + n.y*0.4 -tMod + tMod2  ));\n\n    s /= 4.;\n    \n    return s;\n}\nvec2 mainSound( in int samp, float t )\n{\n    vec2 s = vec2(0); \n\n    //t += measure*4.;\n    vec2 sEchno = echoChannel(t)*1.5;\n    vec2 sHats = hats(t)*0.5;\n    vec2 sHatsTwo = hatsTwo(t)*0.4;\n    vec2 sHatsTwoEcho = hatsTwo(t + 0.1)*0.3;\n    vec2 sHatsThree = hatsTwo(t)*1.2;\n    vec2 sChorus = chorusChannel(t);\n    vec2 sBass = makeBass(t);\n    vec2 sKick = kickSecond(t, 1.)*1.5;\n    vec2 sSnare = snare(t)*1.5; \n    \n    vec2 sAmbA = (sAmbG(t, note(9. + 3. ,3.))+sAmbG(t, note(9. ,3.)))*0.3;\n    vec2 sAmbB = (sAmbG(t, note(9. + 0. ,2.))+sAmbG(t, note(9. + 7. ,2.)))*0.3;\n    vec2 sAmbC = (sAmbG(t, note(9. + 3. ,3.))+sAmbG(t, note(9. ,3.)))*0.3;\n    vec2 sAmbD = (sAmbG(t, note(9. + 6. ,3.))+sAmbG(t, note(9. + 6. ,2.)))*0.3;\n    \n\n        \n    if (P(1.)){\n\t\t//s += gIntroAmb(t)*1.;\n        s += sChorus;\n        s += sHats;\n    } else if (P(2.)){\n        s += (sAmbG(t, note(9. + 3. ,3.))+sAmbG(t, note(9. ,3.)))*0.2*smoothstep(1., 0., mod(t/measure,1.));\n \t\ts += sChorus;\n        s += sHats;\n        s += sHatsTwo;\n        s += sHatsTwoEcho;\n    } else if (P(3.)){\n \t\ts += sChorus;\n        s += sHats;\n        s += sHatsTwo;\n        s += sHatsTwoEcho;\n        s += sKick;\n        //s += makeBass(t)*1.;\n        s += sEchno;\n        //s += snare(t)*1.5;        \n    } else if (P(4.)){\n \t\ts += chorusChannel(t + (1. - exp(-mod(t,hbeat)))*noise(t).x*0.0002);\n        s += sHats;\n        s += sHatsTwo;\n        s += sHatsTwoEcho;\n        s += sBass;\n        s += sEchno;\n        //s += snare(t)*1.5;\n    \t\n    } else if (P(5. + 2.)){ \n        s += sHats;\n        s += sHatsThree;\n        s += sHatsTwoEcho;\n        s += sKick;\n        s += sBass;\n        s += sEchno;\n        s += sSnare;\n        if (PL(6. + 0.75)) {\n            s += sAmbA;\n            s += sAmbB;\n            s += sAmbD;\n        } else if (PL(6. + 0.25)){\n            s += sAmbA;\n            s += sAmbB;\n        } else if (PL(6.)){\n            s += sAmbA;\n        }  \n\n\n    } else  if (P(8.)){\n        s += sEchno;\n    } else  if (P(9.)){\n        s += sEchno;\n    }\n    \n    \n\n    s *= 0.2;\n    \n    s = clamp(s, vec2(-1.), vec2(1.));\n    \n    s *= smoothstep(0.,1., t*0.6);\n    \n    s *= 0.1;\n    \n    return s;\n}", "sound_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcGWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 103, 127, 529], [539, 539, 596, 657, 858]], "test": "untested"}
{"id": "3tG3DD", "name": "quick bump mapping test", "author": "szczm_", "description": "nothing to see here move along\n\nmade in ~1 hour, don't expect wonders", "tags": ["shading", "lambert", "bumpmapping", "normal", "mapping", "blinnphong", "tangent", "bitangent"], "likes": 16, "viewed": 926, "published": 3, "date": "1578919424", "time_retrieved": "2024-07-30T21:30:23.827898", "image_code": "// https://github.com/hughsk/glsl-hsv2rgb\n// Used for changing the light colour\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat luminance(vec3 col) {\n    return dot(col, vec3(0.299, 0.587, 0.114));\n}\n\n// Use pixel luminance for height\nfloat texelHeight(vec4 rgba) {\n    return luminance(rgba.rgb);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normal map strength\n    const float normal_strength = 7.0;\n    \n    // Bump height multiplier\n    const float height_multiplier = 4.0;\n    const float texel_offset = 0.5;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 offset = vec3(texel_offset / iChannelResolution[0].xy, 0.0);\n    \n    vec3 surfaceColor = texture(iChannel0, uv).rgb;\n\tfloat height = texelHeight(surfaceColor.rgbb) * height_multiplier;\n    vec3 worldPosition = vec3(uv, height);\n    \n    // Take a difference between the right texel and the left texel\n    float ddX = texelHeight(texture(iChannel0, uv + offset.xz))\n        \t  - texelHeight(texture(iChannel0, uv - offset.xz));\n    \n    // Take a difference between the bottom texel and the top texel\n    float ddY = texelHeight(texture(iChannel0, uv + offset.zy))\n        \t  - texelHeight(texture(iChannel0, uv - offset.zy));\n    \n    ddX *= normal_strength / texel_offset;\n    ddY *= normal_strength / texel_offset;\n    \n    // I'm probably using the wrong nomenclature here don't sue me\n    vec3 tangent   = normalize(vec3(1.0, 0.0, ddX));\n    vec3 bitangent = normalize(vec3(0.0, 1.0, ddY));\n    \n    // As easy as one two seven NaN NaN—±¼¿Ə↔ Segmentation fault\n    vec3 normal = cross(tangent, bitangent);\n    \n    vec2 lightPosition = 0.5 + 0.4 * vec2(cos(iTime), sin(iTime));\n    vec3 lightColor = hsv2rgb(vec3(mod(iTime * 0.1, 1.0), 0.1, 1.0));\n    float lightStrength = 10.0;\n    float lightHeight = 2.8;\n    \n    vec3 lightDir = normalize(vec3(lightPosition, lightHeight) - worldPosition);\n    \n    float attenuation = lightStrength / pow(distance(lightPosition, uv) + lightHeight, 2.0);\n    \n    float lambert = max(0.0, dot(lightDir, normal));\n    float blinnPhong = pow(max(dot(normalize(vec3(vec3(0.0, 0.0, 1.0)) + normal), lightDir), 0.0), 10.0);\n    \n    float ambient = 0.0;\n    float diffuse = 0.5 * lambert;\n    float specular = 0.5 * blinnPhong;\n    \n    vec3 col = ambient + (diffuse * surfaceColor + specular) * attenuation * lightColor;\n    \n    float luma = luminance(col);\n    luma *= 3.5;\n    col /= luma / (luma + 1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tG3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 80, 102, 102, 265], [268, 268, 295, 295, 345], [347, 381, 411, 411, 445], [447, 447, 504, 531, 2654]], "test": "untested"}
{"id": "WlGGWh", "name": "dali", "author": "omis", "description": "a monolite. still incomplete, I'd like to improve sky and add light reflections, but I haven't figured out how yet.\nthe ground is smth I came up on my own, mix of clamped fbm and a sine wave, generating more variationsl.\ncomments are welcome.", "tags": ["raymarch", "ground", "fractures"], "likes": 5, "viewed": 426, "published": 3, "date": "1578915345", "time_retrieved": "2024-07-30T21:30:24.571909", "image_code": "#define AA 1\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n\tp-=ip;\n\tvec3 s=vec3(7, 157, 113);\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\n\tp=p*p*(3.-2.*p);\n\th=mix(fract(43758.5*sin(h)), fract(43758.5*sin(h+s.x)), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm5( vec3 p )\n{\n\t//p += vec3(1.0,1.0,0.8);\n    float f;\n    f  = 0.5000*noise( p); p = p*2.04;\n    f += 0.2500*noise( p); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    //f += 0.0625*noise( p ); p = p*2.02;\n    //f += 0.03125*noise( p ); \n\t\n\tfloat n = noise( p*3.5 );\n    f += 0.03*n*n;\n\t\n    return f;\n}\n\n\nvec2 map(in vec3 p)\n{   \n    // monolite\n    vec3 pm = p; pm.z-=75.0; pm.y+=0.2;\n    pm.z+=iTime;\n    \n    pm.yz *= rot(-2.4)*noise(pm*0.15);\n    //pm.xz+=noise(pm);\n    pm.x = mod(pm.x, 5.0)-2.5;\n    pm.z = mod(pm.z, 10.0)-5.0;\n    \n    vec2 res = vec2(sdCube((pm), vec3(0.25, 5.0+noise(pm*0.1), 0.15)*2.0), 0.1);\n    \n    // monolite fractures\n    // inspired by iq's https://www.shadertoy.com/view/3lsSzf\n    float yy = p.y-0.62+0.45+noise(p*14.0)*1.0*p.x*p.x;\n    res.x += 0.01*(1.0-smoothstep(0.0,0.02,abs(yy)));\n    yy = p.y+0.65-0.95-noise(p*7.0)*3.0*p.x*p.x;\n    res.x += 0.01*(1.0-smoothstep(0.0,0.0015,abs(yy)));\n    yy = p.y-0.15+1.45-noise(p*7.0)*3.0*p.x*p.x;\n    res.x += 0.01*(1.0-smoothstep(0.0,0.0015,abs(yy)));\n    \n    // ground\n    float n = fbm5(p);\n    float h = mix(clamp(n, 0.0, 0.5), sin(p.x*0.2), n);\n    h+=clamp(n, 0.0, 0.5);\n    float m = p.y-1.5+h*1.51;\n    res = smin(res, vec2(m, 2.0), 2.0);\n    return res;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd)\n{\n    float tmin = 0.0001;\n    float tmax = 120.0;\n\tfloat t = tmin;\n    vec2 res = vec2(0, -1);\n    \n    for (int i = 0; i < 100 && t < tmax; i++)\n    {\n    \tvec2 d = map(ro + rd * t);\n        if (d.x < 0.0001*t){\n        \tres = vec2(t, d.y);\n            break;\n        }\n\n        t+=d.x;\n    }\n    if(t>120.0) res = vec2(-1);\n    return res;\n}\n\nvec4 mapClouds( in vec3 p )\n{\n\tfloat d = 1.0-0.3*abs(0.5 - p.y);\n    p.x+=iTime*2.0;\n\td -= 1.1*fbm5( p*0.45 );\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( 0.8*vec3(1.0,0.95,0.8), 0.2*vec3(0.6,0.6,0.6), res.x );\n\tres.xyz *= 0.65;\n\t\n\treturn res;\n}\n\n\nvec3 lig = vec3(-1.1, 0.5, -1.5);\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax, out float rays, ivec2 px )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\trays = 0.0;\n    \n\t//float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tfloat t = 0.1;//*texelFetch( iChannel0, px&ivec2(255), 0 ).x;\n\tfor(int i=0; i<80; i++)\n\t{\n\t\tif( sum.w>0.99 || t>tmax ) break;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\n\t\tfloat dt = max(0.1,0.05*t);\n\t\tfloat h = pos.y;\n\t\tfloat c = noise( (pos + lig*h)*0.35 );\n\t\trays += 0.02*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a)*(1.0-smoothstep(2.75,2.8,pos.y));\n\t\t\n\t\tcol.xyz *= vec3(0.4,0.52,0.6);\n        //col.xyz += vec3(1.0,0.7,0.4)*0.4*pow( sun, 6.0 )*(1.0-col.w);\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*t*t) );\n\t\t\n\t\tcol.a *= 0.5;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += dt;//max(0.1,0.05*t);\n\t}\n    rays = clamp( rays, 0.0, 1.0 );\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nconst float maxHei = 0.8;\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n\n}\n\nvec3 calcCloudsNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.0005;\n    return normalize( e.xyy*mapClouds( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*mapClouds( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*mapClouds( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*mapClouds( pos + e.xxx ).x );\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// lighting from iq - https://www.shadertoy.com/view/Xds3zN\nvec3 render(vec3 ro, vec3 rd, vec2 fragCoord)\n{\n    vec2 t = raymarch(ro, rd);\n    vec3 p = ro+rd*t.x;\n    vec3 col = vec3(0.0);\n    vec3 nor = calcNormal(p);\n\tvec3 cnor = calcNormal(p);\n    \n    if (t.y < 0.0) {\n    \tcol = vec3(0.01);\n        return col;\n    }\n    \n    // monolite\n    if (t.y == 0.1) {\n        //col = vec3(.001);\n        //return col;\n    }\n\n    float tx = t.x*nor.z;\n    col = nor*clamp(tx, -.5, 1.5);\n    col = 0.7 + 0.5*col;\n    \n    // sun reflections\n    col += vec3(1.0,0.5,0.2)*0.35*pow( nor.x, 3.0 );\n\t\n    // fog\n  \tcol = mix( col, vec3(0.0), 1.0-exp( -0.0001*t.x*t.x*t.x) );\n    //col = mix(col, vec3(0.5, 1.1, 0.7), t.x*0.00015);\n    \n    // clouds\t\n    float rays = 0.0;\n    vec3 bcol = vec3(1.0);\n    \n    {\n\tif( t.x<0.0 ) t.x=100.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t.x, rays, ivec2(fragCoord) );\n\tcol = mix(col, 0.5-col*(1.0-res.w) + res.xyz * (vec3(0.9)), res.w*0.81);\n\t}\n\n\t//col = clamp( col, 0.0, 1.0 );\n    \n\t//col = sqrt(col);\n    return col;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\t\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = -1.5;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord/iResolution.xy - 0.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(0.0, 5.0, 10.0+iTime*0.25);\n    vec3 ta = vec3(-9.0, 10.0, 0);\n    \n    ro.x = sin(iTime*0.01);\n    //ta.x = cos(iTime*0.1);\n    \n    vec3 tot = vec3(0.0);\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n\n    \tvec3 rd = getCameraRayDir(p, ro, ta);   \n    \tvec3 col = render(ro, rd, fragCoord);\n        tot+=col;\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    tot /= float(AA*AA);\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// sdf \n\nfloat sdCube(in vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// domain\n\nfloat rep(float x, float d)\n{\n\treturn mod(x, d) - d/2.0;\n}\nmat2 rot(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 35, 35, 271], [273, 273, 295, 322, 593], [596, 596, 617, 636, 1536], [1538, 1538, 1571, 1571, 1914], [1916, 1916, 1945, 1945, 2186], [2223, 2223, 2322, 2322, 3122], [3151, 3196, 3274, 3297, 3685], [3687, 3733, 3765, 3765, 3967], [3969, 3969, 4007, 4007, 4233], [4235, 4235, 4277, 4277, 4590], [4592, 4652, 4699, 4699, 5648], [5650, 5650, 5710, 5795, 6109], [6111, 6111, 6168, 6168, 6883]], "test": "untested"}
{"id": "Wty3WD", "name": "[music] Ghidra", "author": "jeyko", "description": "old shebang\n", "tags": ["sound", "music", "bytebeat", "dnb"], "likes": 19, "viewed": 1033, "published": 3, "date": "1578912890", "time_retrieved": "2024-07-30T21:30:25.607141", "image_code": "\n// REWIND SHADER TO MAKE SOUND WORK.\n\n// Some old stuff I never released\n// THE VISUALS ARE VERY BASED ON https://www.shadertoy.com/view/4t2cR1\n// WAS LEARNING MAKING TUNNELS\n\n// Anyways, the main part is the sound.\n// The drop bass uses a bunch of bytebeats, also the hihats.\n// Bytebeat base code is from someone on shadertoy, but I don't recall who.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n    \n    vec3 f = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    col += f;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define start_offset (0.)\n\n// - time divisions - //\n#define tmp    129.\n#define msr    ((tmp/100.)*8.)\n#define dmsr   (msr*2.)\n#define hmsr   (msr/2.)\n#define qmsr   (hmsr/2.)\n#define bar    (tmp/100.)\n#define hbar   (bar/2.)\n#define beat   (bar/4.)\n#define hbeat   (beat/2.)\n#define qbeat  (beat/4.)\n#define sbeat  (qbeat/4.)\n\n#define pi acos(-1.)\n#define tau acos(-1.)*2.\n\n// - sequencer functions - //\n#define M(N) (floor(t/msr)== N) \n#define Q(synth, env, seq) hit = t-seq<0.?0.:t-seq ; s += synth*env;\n\n// - utils - //\nfloat sidechain(float t){\n    float hit  = mod(t, bar/1.);\n    float hit2 = clamp(mod(t + bar/3. ,bar), 0., 1.);\n    float env1 = exp(-hit*20.); \n    float env2 = exp(-hit2*20.);\n\treturn env1 + env2;\n}\n\n\nfloat rnd(float i){\n\treturn fract(sin(i)*1235.41252156);\n}\n\nfloat nois(float t){\n    float n = 0.;\n    n = fract(rnd(t)*rnd(t*2.41));\n    vec2 p = vec2(fract(rnd(t*14.11)),fract(rnd(t*124.1)*rnd(t*3.15)));\n    vec2 q = vec2(fract(rnd(t*14.124)*rnd(t*41.15)), n*0.15);\n    n = fract(dot(p,q));\n    \n\treturn n;\n}   \nfloat freq(float n, float o){\n\treturn pow(27.5, ((o*12.) + n)/12.);\n}\nfloat n(vec2 i){\n //   i *= 2.;\n //return fract(dot(vec2(i.x*1.6525, i.y*1.512), i)*24124.124124);\n return fract(sin(dot(vec2(i.x*1.6525, i.y*1.512), i)*2124.124124));\n //return fract(sin(dot(vec2(i.x*1.6525, i.y*1.512), i)*2124.124124)*214124.12412);\n}\nfloat hash(float i){\n\treturn fract(sin(114.121*i)*11252.11242512);\n}\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nfloat random( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\nfloat random(float st){\n\treturn fract(sin(st*21451.24124)*st*1.2314);\n}\n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n// ----- sound stuff ----- //\nfloat env(float attack, float hold, float release, float t){\n    float res=0.;\n    float releaseRange = 4.;\n    if (release > releaseRange) release = releaseRange;\n    if (t < attack){\n    \t//res=mix(exp(t - 2.) - exp(-2.), 1.,t/attack);\n        res=mix(0., 1.,t/attack);\n        //res = 0.;\n    } else if (t < attack + hold) {\n    \tres=1.;\n    } else{\n    \tres = exp((-t+attack + hold)*mix(4.,0.,release/releaseRange));\n        // \n    }\n    \n\treturn res;\n}\n\n\nfloat note(float note, float octave){\n\treturn 27.5*pow(2., ((octave*12.) + note )/12.);\n}\n\nmat2 rot(float deg){return mat2(cos(deg), sin(-deg), sin(deg), cos(deg));}\n\nvec3 getRd (vec3 ro,vec3 lookAt ,vec2 uv){\n    vec3 look = normalize(lookAt - ro);\n\tvec3 r = normalize(cross(vec3(0,1,0), look));\n    vec3 u = normalize(cross(look, r));\n    return look + r*uv.x + u*uv.y;\n}", "buffer_a_code": "#define max_steps   250\n#define min_dist \t0.001\n#define max_dist \t400.\n\n#define T           iTime\n#define my          (590.*iMouse.y/iResolution.y + T*20.)\n#define mx          (20.*iMouse.x/iResolution.x)\n\n#define shaking\n//#define pi \t\t\t(acos(-1.))\n\n// -- globals -- //\nint scene = 2;\nint id = 0; // 1 is ground, 2 is struct\nint idS= 0;     // ids for structs. 0 is black, 1 is white, 2 is whatever\nfloat DGROUND = 0.;\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nfloat r31(vec3 p) {\n\tfloat h = dot(p,vec3(127.1,811.7, 542.1));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n\nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n//    fd = smoothstep(0.,1., fd);\n    \n    float ibl = r31(id + vec3(0,-1,0));\n    float ibr = r31(id + vec3(1,-1,0));\n    float itl = r31(id + vec3(0));\n    float itr = r31(id + vec3(1,0,0));\n    \n    \n    float jbl = r31(id + vec3(0,-1,1));\n    float jbr = r31(id + vec3(1,-1,1));\n    float jtl = r31(id + vec3(0,0, 1));\n    float jtr = r31(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    //return j;\n    float h = mix(i, j, fd.z); \n        \n    float res = h;\n    \n\treturn res;\n}\n\nfloat fbm(vec3 uv){\n    \n    uv*= 0.05;\n    \n\tfloat res = 0.;\n    \n    \n//    uv = abs(uv);\n    \n    res += valueNoise(uv*2.)*7.;\n    res += valueNoise(uv*8.)*0.4;\t\n    res += valueNoise(uv*21.)*0.4;\t\n    \n    \n\treturn res;\n}\n\nfloat sdBox(vec3 p,vec3 s){\n    p = abs(p);\n\treturn max(p.y - s.y,max(p.x - s.x, p.z - s.z) );\n\n}\nvec2 offsTunn(vec3 p){\n    vec2 off = vec2(0);\n    \n    p.z *= 0.01;\n    off.x += cos(p.z);\n    off.y += sin(p.z);\n    \n    off *= 100.;\n    \n\treturn off;\n}\nfloat sdGround(vec3 p){\n\tfloat d = 100.;\n    vec3 q = p;\n    q.xy += offsTunn(q);\n    float dGround = -(length(q.xy) -29.);\n    d = min(d, dGround);\n    d = min(d, d - fbm(q)*1.9);\n    d = min(d, d - fbm(q*2.5)*1.9);\n    DGROUND += d;\n    return d/3.;\n}\nfloat curve(float t, float d) {\n  float g=t/d;\n  float it=fract(g);\n  it=smoothstep(0.,1.,it);\n  it=smoothstep(0.,1.,it);\n  it=smoothstep(0.,1.,it);\n  return mix(rnd(floor(g)), rnd(floor(g)+1.), it);\n}\n\nfloat tick(float t, float d) {\n  float g=t/d;\n  float it=fract(g);\n  it=smoothstep(0.,1.,it);\n  it=smoothstep(0.,1.,it);\n  it=smoothstep(0.,1.,it);\n  return floor(g) + it;\n}\n\n\nfloat sdGeometry(vec3 p){\n\tfloat d = 100.;\n    \n    // ----- Geom ----- // \n    // -- base box\n    vec3 pB = vec3(0,-1.,0);\n    vec3 sB = vec3(0.4, 0.05 ,1.0);\n\tfloat dBox = sdBox(p - pB, sB);\n    // -- base2 box\n    vec3 pBU = pB + vec3(0,sB.y,0);\n    vec3 sBU = sB*0.9;\n\tfloat dBoxU = sdBox(p - pBU, sBU);\n    // -- pipes\n    vec3 sP = vec3(0.07,0.5,0.07);\n    vec3 pP = vec3(sB.x*0.75,-0.5,sB.z*0.8);\n    float dPipes = sdBox(p - pP, sP);\n    dPipes = min(dPipes, sdBox(p - vec3(-pP.x,pP.y,pP.z), sP));\n    dPipes = min(dPipes, sdBox(p - vec3(-pP.x,pP.y,-pP.z), sP));\n    dPipes = min(dPipes, sdBox(p - vec3(pP.x,pP.y,-pP.z), sP));\n    // -- top box\n    vec3 sBT = vec3(sB.x*0.3, sB.y, sB.z);\n    vec3 pBT = pB + vec3(sB.x - sBT.x,sP.y*2.,0);\n\tfloat dBoxT = sdBox(p - pBT, sBT);\n\tdBoxT = min(sdBox(p - vec3(-pBT.x, pBT.y, pBT.z), sBT), dBoxT);\n    // -- mid box\n    vec3 sBM = vec3(sB.x/2.,sB.y,sB.z);\n    vec3 pBM = vec3(0.,-1.+sP.y,0);\n    float dBoxM = sdBox(p - pBM, sBM);\n    // -- mid box2\n    vec3 sBM2 = vec3(1.);\n    vec3 pB2M = vec3(0.,-1.+sP.y,0);\n    float dBoxM2 = sdBox(p - pBM, sBM);\n    \n    \n    \n    // ------ end ----- //\n    d = min(d, dBox);\n    d = min(d, dBoxU);\n\td = min(d, dBoxT);\n\td = min(d, dBoxM);\n\td = min(d, dPipes);\n    // -- material ids -- //\n    dBox<=d ? idS=1 : dBoxU<=d ? idS=2 : dPipes<=d ? idS=3 : dBoxT<=d? idS=1 :\n    dBoxM<=d ? idS=4: idS=0;\n    \n\n\t    \n    return d;\n}\n\nfloat sdStructScene1(vec3 p){\n\tfloat d = 100.;\n    vec3 pOrig = p;\n    float sep =  35.;\n    float id = floor(p.z/sep);\n    \n    float dist=50.0;\n    p = (fract(p/dist+.5)-.5)*dist;\n    \t\n    for (float i = 0.; i < 4.; i++ ){\n    \n        p.x -= 2.4;\n        p.y -= 0.1;\n        p.xz *= rot(0.31);\n        p.yz *= rot(0.51);\n        p.z -= 2.9;\n        \n    \tp.x = abs(p.x);\n    \tp.z = abs(p.z);\n    \tp.y = abs(p.y);\n    }\n    \n    \n    \n    \n    d = min(d, sdGeometry(p));\n    \n    return d;\n}\n\nfloat sdStructScene2(vec3 p){\n\tfloat d = 100.;\n    p.xy += offsTunn(p);\n    float sep =  35.;\n    float id = floor(p.z/sep);\n    p.z = mod(p.z, sep) -sep/2.;\n    \n    float reps = 5.;\n\tpModPolar(p.xy, reps);    \n    vec3 polarP = vec3(reps - 1., 0., 0.);\n    \n    for (float i = 0.; i < 3.; i++){\n    \tp.y -= 0.5;\n    \tp.x -= 1.5 - curve(T + id, 1.5)*1.9;\n    \tp=abs(p);\n\t\tp.z -= 0.9 + fract(id*2144.124)*0.5;\n        \n    \tp.yz *= rot(4.5 + sin(T*0.2  + id)*0.5);\n    \tp.xz *= rot(0.4);\n    }\n    \n    p -= polarP;\n    d = min(d, sdGeometry(p));\n    \n    return d;\n}\nfloat map(vec3 p){\n\tfloat d = 100.;\n    float dStruct;\n    float dTunnGround;\n    if (scene == 1){\n    \tdStruct = sdStructScene1(p);\n        dTunnGround = 10000.;\n    }\n    else if (scene == 2){\n    \tdStruct = sdStructScene2(p);\n        dTunnGround = sdGround(p);\n    }\n    d = min(dStruct, d);\n    d = min(d, dTunnGround);\n   \tdStruct <= d ? id = 1 : dTunnGround <= d ? id = 2 : id = 0;\n    return d;\n}\n\nvec3 normal (vec3 p){\n\tvec2 e = vec2(0.001, 0);\n\treturn normalize(map(p) - vec3(\n    \tmap(p - e.xyy),\n    \tmap(p - e.yxy),\n    \tmap(p - e.yyx)\n    ));\n\n}\n\nvec3 shake(vec3 p){\n\tp.y += fract(sin(p.z*1.1))*0.01;\n\tp.x += fract(sin(p.z*2.1))*0.01;\n    return p;\n}\n#define spectra(t) (0.9  + sin(t + 1.5 + 2.*vec3(0.1,0.4,0.6) )*0.4   )\n#define spectra2(t, beat) (-0.5 + beat  + sin(t + 4.9 + 1.*vec3(0.9,0.4,0.6) )*0.6   )\nvec4 render(vec2 uv){\n\tvec3 col = vec3(0);\n\n    vec3 ro;\n    vec3 lookAt;\n    float trig;\n    if (scene == 1){\n        float z = 30.;\n        ro = vec3(0. , 0,-1. );\n        ro.x += sin(mx)*z; ro.z += cos(mx)*z;\n        lookAt = vec3(0. ,0,0.);\n        trig = 1.;\n    } else if (scene == 2){\n        ro = vec3(0. , 0,-11. + my);\n        #ifdef shaking\n    \tro = shake(ro);\n        #endif\n        ro.xy -= offsTunn(ro);\n        lookAt = vec3(0. ,0,-8. + my);\n        lookAt.xy -= offsTunn(ro + vec3(0,0,3));\n        trig = exp(-mod(T, 0.5));\n    }\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 glow = vec3(0);\n    vec3 glow2= vec3(0);\n    float t = 0.; vec3 p = ro;\n    for (int i = 0; i<max_steps; i++){\n    \tfloat h = map(p);\n    \n        if (h < min_dist || t > max_dist) break;\n        glow += spectra(t*0.05)*0.02;\n        glow2+= spectra2(t*0.05, trig)*0.02;\n        t += h;\n        p += h * rd;\n    }\n    if (scene == 1){\n        glow2.g *= 0.9;\n        col =  glow2*20.; \n        col *= 0.1;\n        \n        col -= t*0.0009;\n        //col *= shade(p, ro, rd);\n    }\n    else if (scene == 2){\n        if (id == 2){\n            //col -= DGROUND*0.01;\n            col = glow ;\n            float restraint = clamp(exp(-length(glow)*1.95 + 2.34),0., 1.);\n            //col *= restraint;\n            //col.b *= restraint;\n            //col.b = col.b*0.4 + col.b*restraint*0.6;\n\n            col.g = pow(col.g, 2.);\n            //col.g -= DGROUND*0.001;\n        } else {\n            glow2.g *= 0.9;\n            col =  glow2*20.; \n            col *= 0.1;\n            //col *= shade(p, ro, rd);\n        }\n    \n    }\n    \n    \n    //col += t*0.02;\n    \n    \n    return vec4(col, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    fragColor = vec4(col);\n}", "buffer_a_inputs": [], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n    \n    vec3 f = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    vec3 z = texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n    float d = texelFetch(iChannel1, ivec2(fragCoord), 0).w;\n    \n    \n    float blurAmt = 0. + clamp(exp(-d*5.),0.,1.);\n    \n    \n    \n    \n    col += f*(1. - blurAmt);\n    //col += z*blurAmt*8.5;\n\n    col.g /= d*1.3;\n    col.b/= d*1.3;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\nvec2 sAmbG(float t, float freq){\n\tvec2 s = vec2(0);\n    t = mod(t, hmsr);\n    float iters = 3. + clamp( exp(-t/2.)*5., 0., 30.);\n    for (float i = 1.;i < iters; i++){\n    \ts += sin(t*tau*freq*i)/i;\n    }\n    \n    vec2 n = noise(t);\n    vec2 sOrig = s;\n    float tMod = sin(t*8.)*(1. + exp(t/2.- 1.)*0.3);\n    float tMod2 = cos(t*2.)*0.5;\n    s = sOrig*sin(freq*4.*t*tau + n.x*0.4  + tMod          );\n    s += sOrig*sin(freq*2.*t*tau + n.y*0.4 + tMod2        );\n    s += sOrig*(fract(freq*8.*t*tau + n.y*0.4 -tMod + tMod2  ));\n\n    s /= 4.;\n    \n    return s;\n}\nvec2 gPadSaw(float t){\n\tvec2 s = vec2(0);\n\tfloat hit;\n    \n    if(M(0.) || M(1.)  ){\n        t = mod(t, msr*2.);\n        if (t<hmsr){\n        \ts += sAmbG(t, note(1.,2.));\n    \t\ts += sAmbG(t, note(6.,2.));\n    \t\ts += sAmbG(t, note(9.,2.));\n        } else if (t<msr){\n        \ts += sAmbG(t, note(3.,2.));\n    \t\ts += sAmbG(t, note(7.,2.));\n    \t\ts += sAmbG(t, note(9.,2.));\n            if (t>msr -hmsr/2.) s += sAmbG(t, note(10.,2.));\n        } else if (t<msr+hmsr){\n        \ts += sAmbG(t, note(4.,2.));\n    \t\ts += sAmbG(t, note(7.,2.));\n    \t\ts += sAmbG(t, note(9.,2.));\n        }\n\t\telse if (t<msr*2.){\n        \ts += sAmbG(t, note(3.,2.));\n    \t\ts += sAmbG(t, note(7.,2.));\n    \t\ts += sAmbG(t, note(9.,2.));\n            if (t>msr -hmsr/2.) s += sAmbG(t, note(10.,2.));\n        }    \t\n        \n    } else if (M(2.) || M(3.)){\n        t = mod(t, msr*2.);\n        if (t<hmsr){\n        \ts += sAmbG(t, note(5.,2.));\n    \t\ts += sAmbG(t, note(10.,2.));\n    \t\ts += sAmbG(t, note(13.,2.));\n        } else if (t<msr){\n        \ts += sAmbG(t, note(7.,2.));\n    \t\ts += sAmbG(t, note(11.,2.));\n    \t\ts += sAmbG(t, note(13.,2.));\n            if (t>msr -hmsr/2.) s += sAmbG(t, note(10.,2.));\n        } else if (t<msr+hmsr){\n        \ts += sAmbG(t, note(8.,2.));\n    \t\ts += sAmbG(t, note(11.,2.));\n    \t\ts += sAmbG(t, note(13.,2.));\n        }\n\t\telse if (t<msr*2.){\n            float expMod = exp(-mod(t - msr -hmsr/2., msr)*0.2)*0.5;\n            float revExpMod = exp(mod(msr+hmsr, msr)*0.05 - 1.)*0.5;\n            float pitchDown =  1. + revExpMod*sin(t*(30. + revExpMod*400.))*0.04 - expMod;\n        \ts += sAmbG(t, note(7.,2.)*pitchDown);\n    \t\ts += sAmbG(t, note(11.,2.)*pitchDown);\n    \t\ts += sAmbG(t, note(13.,2.)*pitchDown);\n            if (t>msr -hmsr/2.) s += sAmbG(t, note(10.,2.)*pitchDown);\n        }    \t\n    \n    }\n    return s;\n}\nvec2 gIntroAmb(float t){\n    vec2 s = vec2(0);\n    \n    float iters = 30.;\n    if (M(0.) || M(1.)){\n        for (float i = 0.; i<iters; i++){\n            float f = 1900.+ hash(i)*(170. + sin(t)*300. );\n            f*= 0.33;\n            float tex = texture(iChannel0, vec2(i/1000.)).x;\n            s += (sin(t*f)*noise(vec2(f*i*0.1,f*i*0.11))*tex)/iters;\n        }\n    } else if(M(2.) || M(3.)){\n        for (float i = 0.; i<iters; i++){\n            float m1 = exp(t*0.25 - 4.)*13.;\n            float m2 = sin(t*(1. + m1*0.006));\n            float f = 1900.+ hash(i)*(170. + m1 + m2  );\n            f*= 0.33;\n            \n            if (t>(msr*3.75)){\n                float h = t - msr*3.75;\n                f *= 1. + (1./(h+1.)+ 1.)*4.; \n            }\n            float tex = texture(iChannel0, vec2(i/1000.)).x;\n            s += (sin(t*f)*noise(vec2(f*i*0.1,f*i*0.11))*tex)/iters;\n        }\n    } \n    s *= 4.;\n    return s;\n\n}\n\nvec2 gSub(float t){\n\tvec2 s = vec2(0);\n    \n    \n    if (M(0.)){\n    \n    }\n    else if (M(4.) || M(5.)){\n        if (t < bar)\n        \ts += sin(freq(2.05 + clamp(exp(-mod(t,bar))*4., 0., 8.), 1.)*tau*t);\n        else\n            s += sin(note(10.1,0.)*tau*t);\n        \n    } if ( M(6.) || M(7.) || M(8.) || M(9.)){\n       \ts += sin(note(10.1,0.)*tau*t);\n    }\n    float satAmt = 0.4;\n    \n    \n    // sidechain\n    float hit  = mod(t, bar/1.);\n    float hit2 = clamp(mod(t + bar/3. ,bar), 0., 1.);\n    float env1 = exp(-hit*10.); \n    float env2 = exp(-hit2*10.);\n    s *= clamp( 1. - env1*5. - env2 *5.,0., 1.) ;\n    \n    \n    return s;\n}\nvec2 gKick(float t){\n    vec2 s = vec2(0);\n\tfloat hit  = mod(t, bar/1.);\n    float hit2 = clamp(mod(t + bar/3. ,bar), 0., 1.);\n    \n    if (M(0.) || M(1.) ){\n    \n    } else if(M(2.) || M(3.)){\n        if (t > msr*3.5 && t < msr*3.75){\n        \thit  = mod(t, beat*2.);\n        \ts += sin(tau*(30. + exp(-hit*40.)*10.));\n        }\n        \n    \t else if (t > msr*3.75){\n        \thit  = mod(t, qbeat);\n        \ts += sin(tau*(30. + exp(-hit*40.)*10.));\n        } else {\n            s += sin(tau*(30. + exp(-hit*40.)*10.));\n            s += sin(tau*(30. + exp(-hit2*40.)*10.));\n            s *= 0.4;\n        }\n    }\n    else if (M(4.) || M(5.) || M(6.) || M(7.)|| M(8.) || M(9.)){\n    \tfloat rel = 12.;\n        s += sin(tau*15.*exp(-hit*rel*2./3.))*exp(-hit*rel*2.);\n        s += sin(tau*10.*exp(-hit*66.))*exp(-hit*rel*6.)/2.;\n        s += sin(tau*15.*exp(-hit2*rel*2./3.))*exp(-hit2*rel*2.); \n        s += sin(tau*10.*exp(-hit2*66.))*exp(-hit2*rel*6.)/2.;    \n    }\n\n\n    \n    s  = s + (s / (0.2 + abs(s)));\n    s *= 0.4;\n    s = clamp(s, -1., 1.);\n    s *= 2.;\n    return s;\n}\nvec2 gSnare(float t){\n\tvec2 s = vec2(0);\n    \n    float hit = mod(t + hbar/2.,hbar);\n    \n    if (M(2.) || M(3.)){\n        if (t > msr*3.5){\n        \tfloat tMod = t - msr*3.5;\n            s += sin(tau*( (9.5 + - exp(tMod)*10.)*clamp(exp(-hit*(95. )),0.15,0.5)));\n            //s += sin(tau*( (9.5 + - exp(tMod)*10.)*clamp(exp(-hit*(95. )),0.15,0.5)));\n            s = s/(1.4 - abs(s));\n            \n        } else{\n            s += sin(tau*( 9.5*clamp(exp(-hit*95.),0.15,0.6)));\n            s = s/(1.6 - abs(s));\n        }\n        \n    }\n    else if (M(4.) ||M(5.)  || M(6.) || M(7.) || M(8.) || M(9.)  || M(10.) || M(11.) ){\n    \n    \ts += sin(tau*freq(12.+ 1.2*exp(-hit*26.) ,0.))*exp(-hit*18.);    \t\n            \n        float satAmt = 0.5;\n        s = s*(1.-satAmt) +  (s / (0.99 -abs(s)))*satAmt;\n        //s *= 0.7;\n        s = (s + nois(t + rnd(t))*s*3.)/2.; \n    \n    }\n\n    \n\n    s *= 0.9;\n    s = clamp(s, -1., 1.);\n    \n    return s;\n    \n}\nvec2 gHats(float time){\n    \n\tfloat s;\n    int t = int(time*iSampleRate/7.);\n    t = int(time*iSampleRate);\n    float currentMeasure = floor(time/(msr));\n    if (currentMeasure<4.){\n        if (currentMeasure < 1.)\n        \ttime = mod(time, beat*2.);\n         else \n            time = mod(time, beat);\n        \n    \tt = t % ((t >>3) % t*2);\n        s =float(t & 0xff - 128)/ 128.;\n        s *= pow(exp(-mod(time,qbeat*20.)), 30.);\n        s = (s + (s*nois(time * mod(time, 0.001)*100.))*9.*exp(-time));\n        s *= 3.;\n    }\n    if (currentMeasure==4.){\n        time = mod(time, beat);\n    \tt = t % ((t >>3) % t*2);\n        s =float(t & 0xff - 128)/ 128.;\n        s *= pow(exp(-mod(time,qbeat*20.)), 30.);\n        s = (s + (s*nois(time * mod(time, 0.001)*100.))*9.*exp(-time));\n        s *= 3.;\n    }\n    else if (currentMeasure==5.){\n        time = mod(time, beat);\n    \tt = t % ((t >>2) % t*2);\n        s =float(t & 0xff - 128)/ 128.;\n        s *= pow(exp(-mod(time,qbeat*20.)), 9.);\n        s = (s + (s*nois(time * mod(time, 0.001)*100.))*9.*exp(-time));\n        s *= 4.;\n    } else if (currentMeasure==6. || currentMeasure==7. || currentMeasure==8.|| currentMeasure==9.  ){\n        time = mod(time, beat);\n    \tt = t % ((t >>2) % t*2);\n        s =float(t & 0xff - 128)/ 128.;\n        s *= pow(exp(-mod(time,qbeat*20.)), 9.);\n        s = (s + (s*nois(time * mod(time, 0.001)*100.))*9.*exp(-time));\n        s *= 4.;\n    \n    }\n    \n    \n    //s = clamp(s, -1., 1.);\n    \n    \n    return vec2(float(s));\n}\nvec2 gHats2(float time){\n    if (time < msr*2.) return vec2(0);\n    \n    if (mod(time, hmsr) < 0.25){\n    \ttime = mod(time, qbeat*8.) - hbeat;\n    } else {\n    \ttime = mod(time, qbeat*4.) - hbeat;\n    }\n\t\n\tfloat s;\n    int t = int(time*iSampleRate);\n    \n    t = t % ((t >>2) % t*2);\n    s =float(t & 0xff - 128)/ 128.;\n    s *= pow(exp(-mod(time,qbeat*20.)), 30.);\n    s = (s + (s*nois(time * mod(time, 0.001)*100.))*9.*exp(-time));\n    s *= 3.;\n\treturn vec2(s);\n}\n\nvec2 gBass(float time){\n\tfloat s;\n    int t = int(time*iSampleRate/7.);\n    \n    //time +=hmsr + bar;\n    if (floor(time/msr)==0. || floor(time/msr)==1. || floor(time/msr)==2. || floor(time/msr)==3. ){\n    \treturn vec2(0.);\n    } \n    \n    else if (floor(time/msr)==4.){\n        time = mod(time, msr);\n        t = int(time*iSampleRate/7.);\n    \tif(time < beat)\t\n    \t\tt = t&(t>>6)*(t<<3);\n    \telse if(time < beat*2.)\n    \t\tt = t&(t>>1)*(t<<4);    \n        else if(time < bar)\n           \tt = t&(t>>2)*(t<<4);    \n        else if(time < bar*2.)\n           \tt = t&(t>>1)*(t<<1);    \n        else if(time < bar*4.)\n           \tt = t&(t>>1)*(t<<1);\n        // halfmsr\n        else if(time < hmsr + beat*3.)\n           \tt = t&(t>>5)*(t<<1);    \n        else if(time < hmsr + bar)\n           \tt = t&(t>>6)*(t<<3);    \n        else if(time < hmsr + bar*4.)\n           \t//t = t&((t>>2)*(t<<5))*(t>>int(exp(-mod(time,bar)*2.)*2. + 4.));    \n            t = t&((t>>6)*(t<<3))*(t>>int(exp(-mod(time,bar)*2.)*1. + 6.));    \n        else\n            t = 0;\n    } else if (floor(time/msr)==5.){\n        time = mod(time, msr);\n        //time += hmsr + beat*3.; \n        t = int(time*iSampleRate/7.);\n    \tif(time < beat)\t\n    \t\tt = t&(t>>4)*(t<<3);\n    \telse if(time < beat*2.)\n    \t\tt = t&(t>>6)*(t<<4);    \n        else if(time < bar)\n           \tt = t&(t>>8)*(t<<2);    \n        else if(time < bar*2.)\n           \tt = t&(t>>1)*(t<<1);    \n        else if(time < bar*4.)\n           \tt = t&(t>>1)*(t<<1);\n        // halfmsr\n        else if(time < hmsr + beat*3.)\n           \tt = t&(t>>5)*(t<<1);    \n        else if(time < hmsr + bar)\n           \tt = t&(t>>6)*(t<<3);    \n        else if(time < hmsr + bar*4.){\n            t = int(time*iSampleRate/7.);\n            int tMod = (t*int(sin(time*hmsr) + 1.));\n           \t//t = t<<((t<<29*t)&(t*4));\n            t = t&((t>>6)*(t<<3))*(t>>int(exp(-mod(time,bar)*2.)*2. + 6.));    \n    \t}\n            //t = t&((t>>3)*(t<<2))*(t>>int(exp(-mod(time,bar)*3.)*1. + 2.));    \n        else\n            t = 0;\n    } else if (floor(time/msr)==6.){\n        time = mod(time, msr);\n        t = int(time*iSampleRate/7.);\n    \tif(time < beat)\t\n    \t\tt = t&(t>>2)*(t<<3);\n    \telse if(time < beat*2.)\n    \t\tt = t&(t>>2)*(t<<3);    \n        else if(time < bar)\n           \tt = t&(t>>2)*(t<<4);    \n        else if(time < bar*2.)\n           \tt = t&(t>>1)*(t<<1);    \n        else if(time < bar*3.)\n           \tt = t&(t>>2)*(t<<1);    \n        else if(time < bar*4.)\n           \tt = t&(t>>1)*(t<<1);\n        // halfmsr\n        else if(time < hmsr + beat*3.)\n           \tt = t&(t>>5)*(t<<1);    \n        else if(time < hmsr + bar)\n           \tt = t&(t>>6)*(t<<3);    \n        else if(time < hmsr + bar*2.75)\n           \t//t = t&((t>>2)*(t<<5))*(t>>int(exp(-mod(time,bar)*2.)*2. + 4.));    \n            t = t&((t>>6)*(t<<3))*(t>>int(exp(-mod(time,bar)*2.)*1. + 6.));    \n        else \n            t = t&((t>>6)*(t<<2))*(t>>int(exp(-mod(time,bar)*2.)*1. + 6.));    \n    } else if (floor(time/msr)==7.){\n        time = mod(time, msr);\n        t = int(time*iSampleRate/7.);\n    \tif(time < beat)\t\n    \t\tt = t&(t>>9)*(t<<1);\n    \telse if(time < beat*2.)\n    \t\tt = t&(t>>5)*(t<<1);    \n        else if(time < bar)\n           \tt = t&(t>>2)*(t<<4);    \n        else if(time < bar*2.)\n           \tt = t&(t>>1)*(t<<1);    \n        else if(time < bar*3.)\n           \tt = t&(t>>2)*(t<<3);    \n        else if(time < bar*4.){\n            t = 1*t%(2*(t<<2)&(t<<2)*10);\n            t = (t%190)%(t<<16);\n        }\n       //    \tt = t&(t>>1)*(t<<2);\n        // halfmsr\n        else if(time < hmsr + beat*3.)\n           \tt = t&(t>>5)*(t<<1);    \n        else if(time < hmsr + bar)\n           \tt = t&(t>>6)*(t<<3);    \n        else if(time < hmsr + bar*2.75){\n            t = 1*t%(2*(t<<2)&(t<<2)*10);\n            t = (t%520)%(t<<16);\n        }\n           \t//t = t&((t>>2)*(t<<5))*(t>>int(exp(-mod(time,bar)*2.)*2. + 4.));    \n        //    t = t&((t>>6)*(t<<3))*(t>>int(exp(-mod(time,bar)*2.)*1. + 6.));    \n        else \n            t = t&((t>>6)*(t<<2))*(t>>int(exp(-mod(time,bar)*2.)*1. + 6.)); \n    } else if (floor(time/msr)==8.){\n    \ttime = mod(time, msr);\n        //time += hmsr + bar*0.75;\n        t = int(time*iSampleRate/7.);\n    \tif(time < beat*2.)\t\n    \t\tt = t&(t>>4)*(t<<3);\n    \telse if(time < beat*2.)\n    \t\tt = t&(t>>4)*(t<<4);    \n        else if(time < bar)\n           \tt = t&(t>>5)*(t<<4);    \n        else if(time < hmsr){\n           \tt = 1*t%(2*(t<<2)&(t<<2)*10);\n            t = (t%120)%(t<<16);\n        }\n        // halfmsr\n        else if(time < hmsr + beat*3.)\n           \tt = t&(t>>5)*(t<<1);    \n        else if(time < hmsr + bar)\n           \tt = t&(t>>6)*(t<<3);    \n        else if(time < msr*2.){\n\t\t\tt = t%(1*(t<<1)&(t<<2)*10);\n            //t = (t%900)>>(t>>20);\n        }\n    } else if (floor(time/msr)==9.){\n    \ttime = mod(time, msr);\n        //time += hmsr + bar*0.75;\n        t = int(time*iSampleRate/7.);\n    \tif(time < beat*2.)\t\n    \t\tt = t&(t>>4)*(t<<3);\n    \telse if(time < beat*2.)\n    \t\tt = t&(t>>4)*(t<<4);    \n        else if(time < bar)\n           \tt = t&(t>>5)*(t<<4);    \n        else if(time < hmsr){\n           \tt = 1*t%(2*(t<<2)&(t<<2)*10);\n            t = (t%120)%(t<<16);\n        }\n        // halfmsr\n        else if(time < hmsr + beat*3.)\n           \tt = t&(t>>5)*(t<<1);    \n        else if(time < hmsr + bar)\n           \tt = t&(t>>6)*(t<<3);    \n        else if(time < msr*2.){\n\t\t\tt = t%(1*(t<<1)&(t<<2)*10);\n            //t = (t%900)>>(t>>20);\n        }\n    }\n    \n    s = float(t & 0xff - 128)/128.;\n    s = s*2.- 1.;\n    // FX\n    \n    //sc\n    s *= 1.-(sidechain(time)*2.);\n    s *= 1.-(clamp(exp(-mod(time + hbar/2.,hbar)*6.), 0., 5.))*0.2;\n    //fm\n    s =s + s*sin(tau*time*10200.)*0.3;\n    \n    \n    \n    s = s/(0.1 - abs(s));\n    \n    s = clamp(s, -1., 1.);\n\n\treturn vec2(s);\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    vec2 s = vec2(0);\n    \n    //t*=2.;\n    //t += start_offset;\n    \n    float volHats = 0.6;\n        \n    if (M(5.) || M(6.) || M(7.) || M(8.) ){\n    \tvolHats = 0.94;\n    }\n    \n    \n    \n    s += gKick(t)*0.5;\n    s += gSnare(t)*1.;\n    s += gHats(t)*volHats;\n    s += gHats2(t)*0.2;\n    s += gBass(t)*0.115;\n    s += gSub(t)*0.4;\n    s += gPadSaw(t)*0.2;\n\ts += gIntroAmb(t)*0.5;\n\n    if (t < msr*4.){ s*= 0.45;};\n    if (M(3.)){\n    \tif (t > msr*3.95)\n        {\n        \ts *= exp(-(t - msr*3.95)*0.5);\n        }\n    }\n    \n    s *= 0.6;\n    s = clamp(s, -1., 1.);\n    return s;\n}", "sound_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[355, 355, 412, 412, 617]], "test": "untested"}
{"id": "3tVGDh", "name": "Escher Puddle", "author": "SSHantaram", "description": "This is my attempt to recreate and animate M.C. Eschers 'Rippled Surface'", "tags": ["raymarching", "reflection", "waves", "escher", "reproduction"], "likes": 17, "viewed": 567, "published": 3, "date": "1578908062", "time_retrieved": "2024-07-30T21:30:26.424954", "image_code": "// I have tried to recreate the effect of M.C. Eschers 'Rippled Surface'\n// and animate the scene. The rays are reflected off a displaced\n// plane  into the trees.\n\n// polynomial smooth min (k = 0.1);\n// https://iquilezles.org/articles/smin\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// the wave for each droplet is based on a simple cosine wave\n// the wave in attenuated by the sqared distace to the center\n// for the ring the wave is multiplied by e^(-x^2) to get the rings\n// both the cosine wave and the rings are animated by offsets\n// time is looped in 25 second intervals\n// about the time for the rings to leave the field of view\nfloat waveDisplacement( vec3 p )\n{\n    // drop one\n    float dist = length(p.xz - vec2(-0.5, 6.0));\n    float ring = 10.0*dist - mod(iTime - 8.0, 25.0) + 4.0;\n    float waves = cos(60.0*dist - 10.0*mod(iTime + 2.0, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\n    \n    // drop two\n    dist = length(p.xz - vec2(0.5, 5.5));\n    ring = 10.0*dist - mod(iTime, 25.0) + 4.0;\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\n    \n    // drop three\n    dist = length(p.xz - vec2(-0.0, 5.0));\n    ring = 10.0*dist - mod(iTime - 16.0, 25.0) + 4.0;\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\n    \n    return waves;\n}\n\n// plane with waves\nfloat sdPlane( vec3 p )\n{\n    float dist = p.y;\n    \n    // apply costly displacement only when close\n    if (p.y < 0.1) dist -= 0.0008*waveDisplacement(p);\n    \n    return dist;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// like capsule, but with different radii at each end\n// https://www.shadertoy.com/view/3lsSzf\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\n}\n\nfloat sdTree( vec3 p )\n{\n    // trunk\n    float dist = sdCapsule( p, vec3(0), vec3(0.0, 2.5, 0.0), 0.3 );\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.0, 2.5, 0.0), vec3(0.0, 6.5, 0.0), 0.2), 0.1);\n    \n    // mirror x-axis\n    p.x = abs( p.x );\n    \n    // big branches\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 1.5, 0.0), vec3(1.4, 3.0, 0.0), 0.11), 0.1);\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 2.5, 0.0), vec3(0.7, 3.5, 0.0), 0.10), 0.1);\n    \n    // mirror z-axis\n    p.z = abs( p.z );\n    \n    // small branches\n    dist = sminCubic( dist, sdStick( p , vec3(1.4, 3.0, 0.1), vec3(3.2, 6.5, 3.0), 0.07, 0.02), 0.1);\n    dist = sminCubic( dist, sdStick( p , vec3(0.7, 3.5, 0.08), vec3(2.8, 7.5, 1.0), 0.05, 0.02), 0.1);\n    \n    // lang thin branches\n    dist = min( dist, sdStick( p , vec3(0.7, 0.0, 0.1), vec3(5.8, 10.5, 2.0), 0.05, 0.01));\n    dist = min( dist, sdStick( p , vec3(1.3, 0.0, 2.5), vec3(.3, 3.5, 2.0), 0.02, 0.01));\n    \n    return dist;\n}\n\n// combined SDF for scene\n// water is handled seperately for optimization\nfloat map( vec3 p ) {\n   \t\n    // slight distortion of the space\n    // makes the trees look more organic\n    // this makes a big difference\n    p += vec3(0.3*cos(1.2*p.x), 0.2*sin(1.2*p.y), 0.1*sin(p.z));\n    \n    vec3 p1 = p;\n    \n\t// rotation matrix based on pythagorean tripel\n    p1 *= mat3( 4.0, 0.0, 3.0,\n                0.0, 5.0, 0.0,\n               -3.0, 0.0, 4.0) / 5.0;\n    \n    float tree1 = sdTree(p1);\n    \n    vec3 p2 = p + vec3(3.0, 0.0, 0.0);\n   \t\n    // rotation matrix based on pythagorean tripel\n    p2 *= mat3(-4.0, 0.0, 3.0,\n                0.0, 5.0, 0.0,\n               -3.0, 0.0, -4.0) / 5.0;\n    \n    float tree2 = sdTree(p2);\n    \n    return min(tree1, tree2);\n}\n\n// optimized normal for water\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcWaterNormal( in vec3 pos)\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*sdPlane( pos + e.xyy) + \n\t\t\t\t\t  e.yyx*sdPlane( pos + e.yyx) + \n\t\t\t\t\t  e.yxy*sdPlane( pos + e.yxy) + \n\t\t\t\t\t  e.xxx*sdPlane( pos + e.xxx) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdPlane(pos+0.001*e);\n    }\n    return normalize(n);\n#endif    \n}\n\n// get distance to the water surface\n// the water is close, only a few iterations are needed\n// this helps because the displacement is costly\nfloat ray_march_water( vec3 eye, vec3 ray_dir ) {\n    float dist = 0.0;\n    for (int i = 0; i < 10; i++) {\n        float d = sdPlane( eye + dist * ray_dir );\n        if ( d < 0.001) {\n      \t\tbreak;\n        }\n        dist += d;\n        if ( dist > 10.0 ) {\n            break;\n        }    \n    }\n    return dist;\n}\n\n// get distance to the trees\n// farplane is close to speed things up\nfloat ray_march( vec3 eye, vec3 ray_dir ) {\n    float dist = 0.0;\n    for (int i = 0; i < 70; i++) {\n        float d = map( eye + dist * ray_dir );\n        if ( d < 0.001 * dist) {\n      \t\tbreak;\n        }\n        dist += d;\n        if ( dist > 18.0 ) {\n            break;\n        }\n        \n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get uv between -1 and 1 and fix aspect ratio\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // camera setup\n    float angle = 0.05*(cos(iTime*0.2)) + 0.25;\n    \n    vec3 eye = vec3(3.0*sin(angle),\n                    1.6 + 0.2*(sin(iTime*0.23)),\n                    3.0*cos(angle));\n    \n    eye += vec3(0.3*sin(iTime*0.32), 0.0, 6.0);\n    \n    vec3 look_at = vec3( 0.0, 0.0, 6.0 );\n    vec3 view_dir = normalize( look_at - eye );\n    vec3 right = cross( vec3( 0.0, 1.0, 0.0 ), view_dir );\n    vec3 up = cross( view_dir, right );\n    float focal_dist = 5.0;\n    vec3 ray_dir = normalize( focal_dist*view_dir + uv.x*right + uv.y*up );\n    \n    // background color\n    vec3 col = vec3(0.5);\n    \n    // reflect ray at water surface\n    float dist = ray_march_water( eye, ray_dir );\n    vec3 p = eye + dist*ray_dir;\n    vec3 normal = calcWaterNormal( p );\n    ray_dir = reflect( ray_dir, normal );\n    \n    // raymarch the trees\n\tdist = ray_march( p + normal * 0.01, ray_dir );\n \n    // color trees black\n    if (dist < 18.0) col = vec3(0);\n    \n    // color moon white\n    // moon is at infinity\n    // render based on angle of the reflected ray\n\telse if ( dot( ray_dir, normalize(vec3(-0.35, 0.6, -1.0))) > 0.997) col = vec3(1);\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVGDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 241, 287, 287, 373], [375, 729, 763, 779, 1441], [1443, 1463, 1488, 1488, 1643], [1645, 1694, 1746, 1746, 1860], [1862, 1957, 2032, 2032, 2174], [2176, 2176, 2200, 2213, 3166], [3168, 3242, 3263, 3382, 3930], [3932, 4008, 4044, 4044, 4581], [4583, 4725, 4774, 4774, 5039], [5041, 5110, 5153, 5153, 5426], [5428, 5428, 5485, 5537, 6805]], "test": "untested"}
{"id": "ttK3Dh", "name": "Joseph Albers 3", "author": "danamuise", "description": "By Dana Muise. Original static code by Patricio Gonzalez Vivo.\nInspired by Joseph Albers' Book \"The interaction of Color:  color intervals and transformation interaction of color\"\nThe three rectangles never change, just the background\n", "tags": ["colortheory", "josephalbers"], "likes": 2, "viewed": 2743, "published": 3, "date": "1578869469", "time_retrieved": "2024-07-30T21:30:27.248752", "image_code": "\nuniform float u_time;\n\nfloat rect(in vec2 st, in vec2 size){\n\tsize = 0.25-size*0.25;\n    vec2 uv = step(size,st*(1.0-st));\n\treturn uv.x*uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\n    vec2 st = fragCoord/iResolution.xy;\n    \n    vec3 influenced_color = vec3(0.563,0.580, 0.556);\n    vec3 influencing_color_A = vec3(0.040,0.040,0.040);\n    vec3 influencing_color_B = vec3(0.937,0.981,1.000);\n    \n    vec3 color = vec3(0.);\n    \n    // Background Gradient\n    color = mix( influencing_color_A,\n                 influencing_color_B,\n                 st.y*abs(sin(iTime)));\n    \n    // Foreground rectangle\n    vec2 size = vec2(0.020,0.460);\n    vec2 offset = vec2(.3,0.);\n    color = mix(color,\n               influenced_color,\n               rect(st,size));\n    \n    color = mix(color,\n               influenced_color,\n               rect(st+offset,size));\n    \n    color = mix(color,\n               influenced_color,\n               rect(st-offset,size));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttK3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 61, 61, 144], [146, 146, 203, 203, 1016]], "test": "untested"}
{"id": "3tyGRz", "name": "Marakami Galaxy", "author": "PixelPhil", "description": "Based on Takashi Murakami spherical flower balls, with a planetary twist.\nInvolves an elaborate sphere mapping to tile pattern with minimal distortion and analitical (non-SDF-based) ray casting.\n\nMusic : Flower Dance - DJ Okawari\n", "tags": ["sphere", "flower", "mapping", "tracing", "planets"], "likes": 65, "viewed": 2772, "published": 3, "date": "1578866256", "time_retrieved": "2024-07-30T21:30:28.292960", "image_code": "// Murakami Galaxy by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\n// To follow up on my current obsession with Takashi Murakami (see: Infinite Murakami)\n// I wanted to give a tribute to his spherical flower patterns (put exemple here)\n// but instead of single compositions give it a infinite galaxy scale with a central flower/sun.\n// This idea ended up being quite challenging in many aspects and I learned a lot in the process of\n// bringing it to a reality, especially :\n//\n// Sphere parametrization : The first thing I did was to modify the fower pattern I did for Infinite\n// Murakami to map it onto a sphere. Of course, some pretty bad distortion around the poles due to\n// spherical texture mapping so I had to find a way to compensate for that by reparametrizing polar\n// coordinates. I wrapped my head around the problem for a couple of days (no pun intended) and ended\n// up finding a tiling scheme consising of mappin the sphere with meridian bands with variying number\n// of flowers to compensate for the horizontal stretch and some taper compensation.\n//\n// Fast Ray casting : The approach I first used was a classic SDF ray casting. My SDF was evaluating\n// 27 (3*3*3) adjacent cells (containing zero or one planet each). Empty space had to be traversed with\n// a lot of caution and it was full of hooks and crannies so it ended up being super slow, especially on\n// my laptop (6fps tops). I realized that because my geometry was qhite simple (a bunch of sphere in a grid)\n// I could just traverse the grid using a bresenham-like traching and just evaluate ray/sphere intersection\n// analytically along the way in crossed cells. It gave me 10X speedup which brough me an immense satisfaction.\n// \n// Anti-aliasing was also a challenge and, although the preview looks decent it is much better looking\n// in fullscreen.\n//\n// I think I'll move on from the Murakami theme for my next entries. I'm done for now :D\n//\n\n//#define MSAA // WANING: on some architecture this leads to long compile times\n\n#define MAX_DST 50.0\n#define sat(a) clamp(a,0.0,1.0)\n\nconst float pi = 3.1415926;\nconst float halfPi = pi * 0.5;\nconst float pi2 = pi * 2.0;\n\nconst float quadrant = pi / 6.0;\n\nconst float blackLevel = 0.3; // True black is too aggressive\n\n\n#define S(a,b,t) smoothstep(a,b,t)\n\n// Some hash function 2->1\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n    p = mod(p, vec2(500.0));\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// A 2d Noise used for the sun rays\nfloat Noise(vec2 uv)\n{\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    vec2 diff = fract(uv);\n    \n    diff = diff * diff * (vec2(3) - vec2(2) * diff);\n    \n    return mix(mix(c00, c10, diff.x), mix(c01, c11, diff.x), diff.y);\n}\n\n// An ellipse signed distance function by iq\n// https://iquilezles.org/articles/ellipsedist\nfloat sdEllipse( in vec2 z, in vec2 ab )\n{\n    vec2 p = vec2(abs(z));\n    \n    if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l; float m2 = m*m;\n    float n = ab.y*p.y/l; float n2 = n*n;\n    float c = (m2 + n2 - 1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    \n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 closestPoint = vec2( ab.x*co, ab.y*si );\n\t\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\n\n// rotates pos to align the up vector towards up\nvec2 rotUp(vec2 pos, vec2 up)\n{\n    vec2 left = vec2(-up.y, up.x);\n    return left * pos.x + up * pos.y;\n}\n\n// The mouth is the intersection of two ellipses, I traced them in photoshop to\n// compute the right radii and offsets\nfloat mouthDst(vec2 uv)\n{\n    return max(sdEllipse(uv - vec2(0.0, -0.17), vec2(0.30, 0.2055)),\n               sdEllipse(uv - vec2(0.0,  0.07), vec2(0.14, 0.2055)));\n}\n\n// For the eye, I use simpler circle distance maths in a scales and rotated space\n// as I don't need an accurate distance function to create an outline\nvec4 eye(vec2 uv, vec2 up, vec2 spot1, vec2 spot2, float aa)\n{\n    uv = rotUp(uv, up);\n    uv.x *= 1.5;\n    \n    float len = length(uv);\n    float len2 = length(uv + spot1);// vec2(0.010, 0.025));\n    float len3 = length(uv + spot2);// vec2(-0.005, -0.017));\n    \n    vec4 eye;\n    \n    eye.a = S(0.04 + aa, 0.04 - aa, len);\n    \n    eye.rgb = vec3(S(0.014 + aa, 0.014 - aa, len2) + S(0.02 + aa, 0.02 - aa, len3) + blackLevel);\n    \n    return eye;\n}\n\nconst float cRatio = 1.0 / 255.0;\n\n// I wanted the color palette to be true to the 16 hue rainbow used\n// by Murakami but I didn't manage to reproduce the orange-yellow-green part\n// using simple maths so I defaulted to a palette. Then I realized I couldn't target\n// Webgl < 3.0 (Wich was one of my objectives) with array constructor so I decided\n// to build a function selecting the right color with a dichotomic approch in hope\n// that the compiler will make a decent job of optimizing all those branches.\nvec3 palette(float id)\n{\n\tif (id < 6.0)\n    {\n        //[0 - 5]\n        if (id < 3.0)\n        {   //[0 - 2]\n            if (id < 1.0) return vec3(181.0, 23.0, 118.0) * cRatio;\n            else if (id < 2.0) return vec3(225.0, 27.0, 104.0) * cRatio;\n            else return vec3(230.0, 40.0, 24.0) * cRatio;\n        }\n        else\n        {   //[3 - 5]\n            if (id < 4.0) return vec3(240.0, 110.0, 14.0) * cRatio;\n            else if (id < 5.0) return vec3(253.0, 195.0, 2.0) * cRatio;\n            else return vec3(253.0, 241.0, 121.0) * cRatio;\n        }\n    }\n    else\n    {   //[6 - 11]\n        if (id < 9.0)\n        {   //[6 - 8]\n            if (id < 7.0) return vec3(167.0, 202.0, 56.0) * cRatio;\n            else if (id < 8.0) return  vec3(0.0, 152.0, 69.0) * cRatio;\n            else return vec3(2.0, 170.0, 179.0) * cRatio;\n        }\n        else\n        {   //[9 - 11] The darker color are at the end to be avoided by mod\n            if (id < 10.0) return vec3(25.0, 186.0, 240.0) * cRatio;\n            else if (id < 11.0) return  vec3(0.0, 98.0, 171.0) * cRatio;\n            else return vec3(40.0, 49.0, 118.0) * cRatio;\n        }\n    }\n}\n\n\n// Adapted from BigWIngs\nvec4 N24(vec2 t) {\n    float n = mod(t.x * 458.0 + t.y * 127.3, 100.0);\n\treturn fract(sin(n*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\n\n// Drawing a Murakami flower from a random seed (how poetic)\nvec4 flower(vec2 uv, vec4 rnd, float scale, float aaScale, float petalAngle, out vec3 col, float eyesAA)\n{\n    \n    float rdScale = 1.0;\n    \n    scale *= rdScale; // The border thickness & AA is scale-independant\n    \n    uv.xy *= rdScale;\n    \n    float aa2 = aaScale * 5.0 / iResolution.x; // increase AA over disatnce and facing ratio\n    \n    float centerDst = length(uv);\n        \n    float edge; // Mask for the outline edge\n    \n    vec4 color = vec4(1.0, 1.0, 1.0, 1.0); // Underlying color\n   \n    \n    float thick = 0.002 * scale;\n    \n    float col1Id = mod((rnd.x + rnd.y) * 345.456, 10.0);\n    col = palette(col1Id); // return the 'main' color of the petals\n \n    \n    if (centerDst < 0.2)\n    {\n        //Face part\n        \n        float thres = 0.2 - thick;\n        \n        // inner part of edge circle surrounding the head\n        edge =  S(thres + aa2, thres - aa2, centerDst);\n        \n        float mouth = mouthDst(uv);\n        \n        // edge of the mouth\n        edge *= S(thick - aa2, thick + aa2, abs(mouth));\n        \n        // face color\n        float faceRnd = fract(rnd.x * 45.0 + rnd.y * 23.45);\n        if (faceRnd < 0.5) \n        {\n            // Flowers with classic yellow / red faces\n        \tcolor.rgb = (mouth < 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(1.0, 1.0, 0.0); \n        }\n        else\n        {\n            // Flowers with white face / random color mouth\n            float colId = mod(faceRnd * 545.456, 11.0);\n            color.rgb = (mouth < 0.0) ? palette(colId) : vec3(1.0); \n        }\n        \n        // Eyes\n        vec4 eyeImg;\n        if (uv.x > 0.0)\n        {\n           eyeImg = eye(uv - vec2(0.075, 0.095), vec2(-0.7, 1.2),\n                       vec2(0.007, 0.025), vec2(-0.004, -0.019), aa2 * eyesAA);\n        }\n        else   \n        {\n           eyeImg = eye(uv - vec2(-0.075, 0.095), vec2(0.7, 1.2),\n                       vec2(0.024, 0.010), vec2(-0.016, -0.009), aa2 * eyesAA);\n        }\n\n        color.rgb = mix(color.rgb, eyeImg.rgb, eyeImg.a);\n        \n    }\n    else\n    {\n        float rot = petalAngle;\n        float angle = fract((atan(uv.x, uv.y) + rot) / pi2);\n    \n        float section = angle * 12.0;\n        float sectionId = floor(section);\n        \n        if (rnd.z < 0.1 && rnd.w < 0.1)\n        {\n           // Rainbow flower\n           color.rgb = palette(sectionId);//mod(sectionId + (rnd.x + rnd.y) * 345.456, 12.0));\n        }\n        else if (rnd.y > 0.05)\n        {\n           \n            //Alternating flower\n            if (mod(sectionId, 2.0) == 0.0)\n            {\n                // Color 1\n                color.rgb = col;\n            }\n            else if (rnd.x > 0.75)\n            {\n                // Color 2\n                float colId = mod((rnd.w + rnd.z) * 545.456, 11.0);\n                color.rgb = palette(colId);\n            }\n            // else, Color2 is white by default\n        }\n\t\t// else, fully white petals\n        \n        if (centerDst < 0.36)\n        {\n            //intermediate part, concentric bars\n            \n            float sectionX = fract(section);\n            float edgeDist = 0.5 - abs(sectionX - 0.5);\n            \n            edgeDist *= centerDst; // Untaper bar space so bars have constant thickness\n            \n            float aa = aaScale * 10.0 / iResolution.x;\n            float bar = thick * 1.7;\n            edge = S(bar - aa, bar + aa, edgeDist);\n\n            // outer part of edge circle surrounding the head\n            float thres = 0.2 + thick;\n            float head = S(thres - aa2, thres + aa2, centerDst);\n            edge *= head;\n        }\n        else\n        {\n            // Petal tips are actually ellipses, they could have been approximated them with\n            // circles but I didn't because I have OCD and I needed the ellipse SDF \n            // for the mouth anyways ;)\n            \n            // Angle to the center of the quadrant\n            float quadAngle = (sectionId + 0.5) * quadrant - rot + pi; \n\n            // Center of the ellipse\n            vec2 petalUp = vec2(-sin(quadAngle), -cos(quadAngle));\n            vec2 petalCenter = petalUp * 0.36;\n\n            // Rotation of the ellipse basis\n            vec2 petalSpace = rotUp(uv - petalCenter, petalUp);\n\n            // Signed distance function of the ellipse\n            float petalDst = sdEllipse(petalSpace, vec2(0.0944, 0.09));\n\n            //border edge and alpha mask\n            float borderIn = S(thick + aa2, thick - aa2, petalDst);\n            float borderOut = S(-thick + aa2, -thick - aa2, petalDst);\n\n            edge = (borderOut);\n            \n            color.a = borderIn;\n        }\n    }\n    \n    color.rgb = mix(vec3(blackLevel), color.rgb,edge);\n    \n    return color;\n}\n\nstruct planet\n{\n    vec3 center;\n    float radius;\n};\n\n// randomizes planet position & radius for a sector\nvoid GetPlanet(vec3 sector, out planet res)\n{\n   \tvec4 rnd = N24(vec2(sector.x + sector.z * 1.35, sector.y));\n    float rad = mix(0.0, 0.4, rnd.x * rnd.w);\n    res.radius = rad;\n    res.center = vec3(rad) + rnd.yzw * vec3(1.0 - 2.0 * rad); // the smaller the planet is, the more off center it can get without crossing border\n}\n\n\nfloat remap(float val, float min, float max)\n{\n    return sat((val - min) / (max - min));\n}\n\n// breaks down a band of UV coordinates on a sphere to a repetition of square-ish cells with minimal distortion\nvec2 ringUv(vec2 latLon, float angle, float centerLat)\n{\n    // latlon : latitude / longitude\n    // angle: horizontal angle covered by one rep of the pattern over the equator / angular height of the band\n    // centerLat : center latitude of the band\n    \n    \n    // Compute y coords by remapping latitude \n    float halfAngle = angle * 0.5;\n    float y = remap(latLon.y, centerLat - halfAngle,  centerLat + halfAngle);\n    \n    float centerRatio = cos(centerLat); // stretch of the horizontal arc of the pattern at the center of the \n   \t\t\t\t\t\t\t\t\t\t// band relative to the equator\n    \n    float centerAngle = angle / centerRatio; // local longitudianl angle to compensate for stretching at the center of the band. \n    \n    float nbSpots = floor(pi2 / centerAngle); // with new angle, how many pattern can we fit in the band?\n    float spotWidth = pi2 / nbSpots;          // and what angle would they cover (including spacing padding)?\n    \n    float cellX = fract(latLon.x / spotWidth); // what would be the u in the current cell then?\n                  \n                  \n    float x = (0.5 - cellX) * (spotWidth / centerAngle); // compensate for taper\n    x *= (cos(latLon.y) / centerRatio) * 0.5 + 0.5;\n    \n    vec2 uvs = vec2(x + 0.5, y);\n    return uvs;\n}\n\n\n// Computes the texture of the planet\nvec3 sphereColor(vec3 worldPos, float nDotV, float dist, float worldAngle)\n{    \n    // which planet are we talnikg about already?\n    // This is done way to much for final rendering, could be optimized out\n    planet p;\n\tvec3 sector = floor(worldPos);\n    GetPlanet(sector, p);\n\n    // Scale AA accourding to disatnce and facing ratio\n   \tfloat aaScale = 4.0 - nDotV * 3.8 + min(4.0, dist * dist * 0.025);\n    \n    // Find local position on the sphere\n    vec3 localPos = worldPos - (sector + p.center);\n    \n    // Random seed that will be used for the two flower layers\n    vec4 rnd = N24(vec2(sector.x, sector.y + sector.z * 23.4));\n    vec4 rnd2 = N24(rnd.xy * 5.0);\n    \n    // compensate for the world Z rotation so planets stay upright\n    localPos = (rotationZ(-worldAngle) * vec4(localPos, 0.0)).xyz;\n    // Planet rotation at random speed\n    localPos = (rotationY(iTime * (rnd.w - 0.5)) * vec4(localPos, 0.0)).xyz;\n   \n    \n    // Compute polar coordinates on the sphere\n    float lon = (atan(localPos.z, localPos.x)) + pi;  // 0.0 - 2 * pi\n    float lat  = (atan(length(localPos.xz), localPos.y)) - halfPi; //-halfPi <-> halfPi\n    \n    // Compute the number of flowers at the equator according to the size of the planet\n    float numAtEquator = floor(3.0 + p.radius * 15.0);\n    float angle = pi2 / numAtEquator; // an the angle they cover ath the equator\n    \n    vec3 col1;\n    vec3 col2;\n    \n    float petalAngle = rnd.w * 45.35 + iTime * 0.1;\n    \n    // Compute on layer of flower by dividing the sphere in horizontal bands of 'angle' height \n    float eq = (floor(lat / angle + 0.5)) * angle;\n    vec2 uvs = ringUv(vec2(lon + eq * rnd.y * 45.0, lat), angle, eq);\n    vec4 flPattern1 = flower((vec2(0.5) - uvs) * 0.95, rnd, 2.0, aaScale, petalAngle, col1, 0.8);\n    \n    \n    // Compute a second layer of flowers with bands offset by half angle\n    float eq2 = (floor(lat / angle) + 0.5) * angle;\n    vec2 uvs2 = ringUv(vec2(lon + eq2 * rnd.x * 33.0, lat), angle, eq2);\n    vec4 flPattern2 = flower((vec2(0.5) - uvs2) * 0.95, rnd2, 2.0, aaScale, petalAngle, col2, 0.8);\n    \n\n    // Compute flower with planar mapping on xz to cover the poles. \n    vec4 flPattern3 = flower(localPos.xz / p.radius, rnd2, 2.0, aaScale, petalAngle, col2, 0.8);\n    \n    float bg = (1.0 - nDotV);\n    vec3 bgCol = rnd2.y > 0.5 ? col1 : col2; // sphere background is the color of one of the layers\n    \n    vec3 col = bgCol; \n    \n    // mix the 3 layers of flowers together\n    col = mix(col, flPattern1.rgb, flPattern1.a);\n    col = mix(col, flPattern2.rgb, flPattern2.a);\n    col = mix(col, flPattern3.rgb, flPattern3.a);\n    \n    // add some bogus colored shading\n    \n    //Front lighting\n    //col *= mix(vec3(1.0), bgCol * 0.3, (bg * bg) * 0.8);\n\n    return col;\n}\n\n\n// Analytical nomral compoutation\n// Much faster and acuurate than SDF in my situation\nvec3 calcNormal( vec3 pos )\n{\n    // computes planet in sector\n    planet p;\n    vec3 sector = floor(pos);\n    GetPlanet(sector, p);\n    \n    // return vector \n    return normalize(pos - (sector + p.center));\n}\n\n\n// Lifted from Rye Terrell at https://gist.github.com/wwwtyro/beecc31d65d1004f5a9d\n// modified to compute coverage\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr, out float coverage) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or MAX_DST if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    \n    float inside = b*b - 4.0*a*c;\n    \n    if (inside < 0.0) {\n        return MAX_DST;\n    }\n    \n    float dst = (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n    \n    // This is a fallof around the edge used for AO\n    // chnage the magic value for a smoother border\n    coverage = S(inside, 0.0, 0.65 * sr * dst / iResolution.x);\n    \n    return dst;\n}\n\n// Computes the RGBA of a planet according to intersection result\nvec4 RenderPlanet(vec3 pos, float d, vec3 rayDir, float worldAngle, float coverage)\n{\n\tvec3 n = calcNormal(pos);\n        \n    float nDotV = abs(dot(n, rayDir));\n \n    float fog = sat((MAX_DST - d) * 0.1);\n    \n \n    // compute some rim lighting to kind of blend everything together\n    vec3 burn  = sat(mix(vec3(2.0, 2.0, 1.5), vec3(1.0, 0.4, 0.2), sat((MAX_DST - d) * 0.05) + nDotV) * 0.5);\n    \n    // Compute the flowery 'texture' on the planet\n    vec3 flowers = sphereColor(pos, nDotV, d, worldAngle);\n    \n    \n    // bogus lighting from the sun\n    vec3 lightPos = pos + vec3(-15.0, -20.0, 60.0);\n    float nDotL = sat(dot(n, normalize(lightPos - pos)) * 0.5 + 0.5);\n    flowers *= nDotL * 0.8 + 0.5;\n    \n    // fades the planets at the horizon\n    vec4 col;\n    col.rgb = flowers + burn;\n    \n    \n    col.a = fog * coverage;\n    \n    // Uncomment to debug coverage AA\n    //col.rgb = mix(vec3(0,1,0), col.rgb, coverage);\n    //col.a = fog;\n    \n    return col;\n}\n\n// Blends two colors front to back\nvec4 BlendFTB(vec4 frontPremul, vec4 backRGBA)\n{\n    vec4 res;\n    \n    res.rgb = backRGBA.rgb * (backRGBA.a * (1.0 - frontPremul.a)) + frontPremul.rgb;\n    res.a = 1.0 - ((1.0 - backRGBA.a) * (1.0 - frontPremul.a));\n    \n    return res;\n}\n\n// Finds the intersection of a ray with a planet in a given sector\n// The coverage is an small alpha falllof at the edge for AA\n// thanks iq for the recommendation\nfloat castPlanet(vec3 cell, vec3 pos, vec3 dir, out float coverage)\n{\n\tvec2 pp = cell.xy + cell.xy;\n    if (dot(pp.xy, pp.xy) < 1.5) return MAX_DST; // we leave a 'tunnel' empty along the z axis \n                \n \tplanet p;\n    \n    GetPlanet(cell, p);            \n    if (p.radius < 0.06) return MAX_DST; // cull planets that are too small\n    \n    // ray sphere intersection from the start position\n    \n    return raySphereIntersect(pos, dir,  cell + p.center, p.radius, coverage); \n}\n\n// Traverses the cells grid in a bresenham fashion and test ray/sphere intersection along the way\n// This appoach ended up being much faster than SDF for that 'simple' yet dense geometry\n//\n// Edit: now, this function also performs the accumulation of planet colors according to coverage\n// The colors are coputed with the RenderPlanet function, the ray is stopped when full opacity is\n// reached\nvec4 castRay(vec3 pos, vec3 dir, float maxDst, float worldAngle)\n{\n    // we assume we are traversing space facing Z\n    \n    vec3 dirZ = dir / dir.z; // direction vector that adavance a full cell along Z\n    \n    vec3 cell = floor(pos); // starting cell\n    \n    vec3 start = pos; // saves the start of the ray\n    pos -= fract(pos.z) * dirZ; // pulls back pos on the closes cell boundary behind\n   \n\n    float d = 0.0;\n    float dst;\n    \n    vec2 layers[20];\n    int num = 0;\n\n    float coverage;\n    float opacity = 1.0;\n\n    while (d < MAX_DST)\n    {\n\t\t// Check current cell\n        dst = castPlanet(cell, start, dir, coverage);\n        if (dst < MAX_DST)\n        {\n            // Blends the hit planet behind the previous ones according to coverage\n            //ColorFTB = BlendFTB(ColorFTB, RenderPlanet(start + dst * dir, dst, dir, worldAngle, coverage));\n            layers[num++] = vec2(dst, coverage);\n            opacity *= (1.0 - coverage);\n            if (opacity < 0.01) break;\n        }\n        \n        // Advances a step\n        pos += dirZ;\n        \n        //Compute next cell on y\n        vec3 newCell = floor(pos);\n        \n        bool a = false;\n        bool b = false;\n        float cornerDst = MAX_DST;\n        \n \t\t\n        if (cell.x != newCell.x) // have we crossed a cell diagonally on X ?\n        {\n            vec3 stepCell = vec3(newCell.x, cell.yz);\n\n            dst = castPlanet(stepCell, start, dir, coverage);\n        \tif (dst < cornerDst) cornerDst = dst;\n            a == true;\n        }\n        \n        if (cell.y != newCell.y)  // have we crossed a cell diagonally on Y ?\n        {\n            vec3 stepCell = vec3(cell.x, newCell.y, cell.z);\n\n            dst = castPlanet(stepCell, start, dir, coverage);\n        \tif (dst < cornerDst) cornerDst = dst;\n            b == true;\n        }\n        \n        if (a && b)  // have we crossed a cell diagonally on both X & Y?\n        {\n            vec3 stepCell = vec3(cell.xy, cell.z);\n\n            dst = castPlanet(stepCell, start, dir, coverage);\n        \tif (dst < cornerDst) cornerDst = dst;\n        }\n        \n        if (cornerDst < MAX_DST) // We have hit a planet in a corner intersection\n        {\n            // Blends the hit planet behind the previous ones according to coverage\n            //ColorFTB = BlendFTB(ColorFTB, RenderPlanet(start + cornerDst * dir, cornerDst, dir, worldAngle, coverage));\n            //if (ColorFTB.a > 0.99) return ColorFTB;\n            \n            layers[num++] = vec2(cornerDst, coverage);\n            opacity *= (1.0 - coverage);\n            if (opacity < 0.01) break;\n        }\n        \n        \n       \t// rinse / repeat\n        cell = newCell;\n        d += 1.0;\n    }\n    \n        \n    vec4 ColorFTB = vec4(0.0);\n    \n    for (int i = 0; i < num; i++)\n    {\n        vec2 layer = layers[i];\n        ColorFTB = BlendFTB(ColorFTB, RenderPlanet(start + layer.x * dir, layer.x, dir, worldAngle, layer.y));\n    }\n    \n    return ColorFTB;\n}\n\n\nvec3 render(vec3 camPos, vec3 rayDir, vec2 uv)\n{\n    vec3 col;\n    \n    // rotates the galaxy around the Z axis, \n    // this rotation will be compensated for when computing planet color so they stay upright\n    float worldAngle = iTime * 0.1;\n    rayDir = normalize((rotationZ(worldAngle) * vec4(rayDir, 0.0)).xyz);\n   \n    float coverage;\n    \n    // cast a ray in the planet field\n    vec4 planetCol = castRay(camPos, rayDir, MAX_DST, worldAngle);\n    \n\n    // Compute the central rainbow flower and solar god rays by samplin a 2D noise in polar coordinates\n\tvec3 dummyCol;\n    vec4 fl = flower(uv * 1.5, vec4(0.0, 0.0, 0.0, 0.0), 2.0, 0.5, iTime * 0.1, dummyCol, 2.0);\n   \tcol = fl.rgb;\n    \n    float a = atan(uv.x, uv.y);\n    float cdist = length(uv);\n    vec2 raysUvs = vec2(a * 20.0 + iTime * 0.5, cdist * 5.0 - iTime + a * 3.0);\n    vec3 rays = mix(vec3(2.0, 2.0, 1.5), vec3(1.0, 0.4, 0.2), cdist + Noise(raysUvs) * 0.3);\n \t\n    col = mix(rays, col, fl.a);\n    \n    col = col * (1.0 - planetCol.a) + planetCol.rgb;\n  \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =(fragCoord - .5 * iResolution.xy) / iResolution.y;\n    uv *= 1.2;\n\n    // compute camera ray\n    vec3 camPos = vec3(0.5, 0.5, iTime * 0.5);\n    vec3 camDir = vec3(0.0, 0.0,  1.0);    \n    vec3 rayDir = camDir + vec3(uv * 0.13, 0.0);\n\n\t//vec3 nrmDir = normalize(rayDir);\n    \n    vec3 res = render(camPos, rayDir, uv).rgb;\n\t\n    #ifdef MSAA\n    if (iResolution.x < 850.0) // Added AA for the thumbnail\n    {\n        vec3 offset = vec3(0.05, 0.12, 0.0)  / iResolution.x;\n         \n        for (int i = 0; i < 4 + min(0,iFrame); i++)\n        {\n            res += render(camPos, rayDir + offset, uv).rgb;\n            offset.xy = vec2(-offset.y, offset.x);\n        }\n        res /= 5.0;\n    }\n    #endif\n\n    // Output to screen\n    fragColor = vec4(res.rgb,1.0);\n}", "image_inputs": [{"id": 20815, "src": "https://soundcloud.com/nhan-y-doanh/flower-dance-dj-okawari", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "mat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyGRz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2394, 2421, 2439, 2495, 2667], [2669, 2705, 2727, 2727, 3091], [3093, 3185, 3227, 3227, 4378], [4381, 4430, 4461, 4461, 4536], [4538, 4657, 4682, 4682, 4823], [4825, 4977, 5039, 5039, 5427], [5464, 5938, 5962, 5962, 7092], [7095, 7120, 7138, 7138, 7279], [7281, 7342, 7448, 7448, 12058], [12115, 12167, 12212, 12212, 12493], [12496, 12496, 12542, 12542, 12587], [12589, 12701, 12757, 13009, 13966], [13969, 14007, 14083, 14213, 16777], [16780, 16867, 16896, 16929, 17077], [17080, 17195, 17278, 17502, 17989], [17991, 18057, 18142, 18142, 19029], [19031, 19066, 19114, 19114, 19305], [19307, 19471, 19540, 19540, 19959], [19961, 20358, 20424, 20474, 23326], [23329, 23329, 23377, 23377, 24373], [24376, 24376, 24433, 24483, 25257]], "test": "untested"}
{"id": "ttVGW1", "name": "Smooth Particle Hydrodynamics", "author": "wyatt", "description": "[url]JAVASCRIPT: H=location.host;E=(H?window:opener).Effect;P=E.prototype;if(!E.P)E.P=P.Paint;P.Paint=function(...A){for(i=0;i<4;i++)E.P.apply(this,A);};if(!H)close();[/url]", "tags": ["fluid", "particles"], "likes": 23, "viewed": 680, "published": 3, "date": "1578862637", "time_retrieved": "2024-07-30T21:30:29.057914", "image_code": "float c (vec2 U) {\n   vec4 a = A(U);\n   return .01*a.x+smoothstep(.1,1.,10.*a.x + a.y) ;\n}\nMain\n{\n    vec4 a = A(U), b=C(U);\n   float \n       q = c(U),\n       n = c(U+vec2(0,1)),\n       e = c(U+vec2(1,0)),\n       s = c(U-vec2(0,1)),\n       w = c(U-vec2(1,0));\n    vec3 no = normalize(vec3(e-w,n-s,-.001));\n    no = reflect(no,vec3(0,0,-1));\n    Q = abs(sin((2.*a.x+.1)*vec4(1,2,3,4)+length(a.zw)));\n    Q *= q*(1.+texture(iChannel1,no))*.5;\n    Q *= 1.-.1*smoothstep(2.,0.,length(U-b.xy));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n\n#define Main void mainImage( out vec4 Q, in vec2 U )\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w); \n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define div 0.25*(n.y-s.y+e.x-w.x)\n\n#define N 6.\n#define For for (float i = -(N); i<=(N); i++)\n#define S vec4(3.5,1,4,4)\n#define Gaussian(i) 0.3989422804/S*exp(-.5*(i)*(i)/S/S)\n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)\n#define Mouse if (iMouse.z>0.&&length(U-iMouse.xy)<30.) ", "buffer_a_code": "void X (inout vec4 Q, vec2 U, vec2 r) {\n\tvec4 n = A(U+r);\n    if (length(U-n.xy)<length(U-Q.xy)) Q = n;\n}\nMain\n{\n    Q = A(U);\n    X(Q,U,vec2(1,0));\n    X(Q,U,vec2(0,1));\n    X(Q,U,-vec2(1,0));\n    X(Q,U,-vec2(0,1));\n    X(Q,U,vec2(3,0));\n    X(Q,U,vec2(0,3));\n    X(Q,U,-vec2(3,0));\n    X(Q,U,-vec2(0,3));\n    \n    Q.zw = mix(Q.zw,C(Q.xy).zw,.01);\n    Q.w -= 5e-4;\n    Q.zw += B(Q.xy).xy;\n    Q.xy += Q.zw;\n    \n    if (Q.x<1.) {Q.x = 1.; Q.z *= -1.;}\n    if (Q.y<1.) {Q.y = 1.; Q.w *= -1.;}\n    if (R.x-Q.x<1.) {Q.x = R.x-1.; Q.z *= -1.;}\n    if (R.y-Q.y<1.) {Q.y = R.y-1.; Q.w *= -1.;}\n    \n    if (iMouse.z>0.) {\n    \tif (length(U-iMouse.xy)<length(U-Q.xy))\n            Q.xy = iMouse.xy;\n    }\n    if (iFrame < 1 && length (U-0.5*R) < 30.) Q.xy = U;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n{\n    Q = vec4(0);\n    For {\n        vec4 a = A(U+vec2(i,i));\n        float p = exp(-length(U+vec2(i,i)-a.xy));\n        Q += Gaussian(i) * vec4(vec2(p),a.zw);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n{\n    Q = vec4(0);\n    For Q += Gaussian(i) * A(U+vec2(-i,i));\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n{\n    Neighborhood\n    Q = A(U);\n    Q.xy = (1.5*(Q.x+.01)*vec2(e.x-w.x,n.x-s.x)-0.7*vec2(e.y-w.y,n.y-s.y));\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 90]], "test": "untested"}
{"id": "wtKGW1", "name": "Physarum Circular", "author": "michael0884", "description": "Using Voronoi particle tracking to simulate the dynamics of a slime mold. Use mouse to change parameters.", "tags": ["fast", "particles", "physarum", "polycephalum"], "likes": 60, "viewed": 2167, "published": 3, "date": "1578860862", "time_retrieved": "2024-07-30T21:30:29.847803", "image_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tvec4 particle = texel(ch0, pos);\n    float distr = gauss(pos - particle.xy, prad);\n    vec4 pheromone = 2.*texel(ch1, pos);\n    fragColor = vec4(sin(pheromone.xyz*vec3(1,1.2,1.5)), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//voronoi particle tracking \n//simulating the cells\n\n//loop the vector\nvec2 loop_d(vec2 pos)\n{\n\treturn mod(pos + size*0.5, size) - size*0.5;\n}\n\n//loop the space\nvec2 loop(vec2 pos)\n{\n\treturn mod(pos, size);\n}\n\n\nvoid Check(inout vec4 U, vec2 pos, vec2 dx)\n{\n    vec4 Unb = texel(ch0, loop(pos+dx));\n    //check if the stored neighbouring particle is closer to this position \n    if(length(loop_d(Unb.xy - pos)) < length(loop_d(U.xy - pos)))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec2 pos, float r)\n{\n    Check(U, pos, vec2(-r,0));\n    Check(U, pos, vec2(r,0));\n    Check(U, pos, vec2(0,-r));\n    Check(U, pos, vec2(0,r));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 muv = iMouse.xy/size;\n    \n    if(length(muv.xy) >0.)\n    {\n    \tsdist *= muv.x;\n  \t\tsst *= muv.y; \n    }\n    else\n    {\n        sdist *= 0.8;\n  \t\tsst *= 0.05; \n    }\n   \n    //this pixel value\n    U = texel(ch0, pos);\n    \n    //check neighbours \n    CheckRadius(U, pos, 1.);\n    CheckRadius(U, pos, 2.);\n    CheckRadius(U, pos, 3.);\n    CheckRadius(U, pos, 4.);\n    CheckRadius(U, pos, 5.);\n   \n    U.xy = loop(U.xy);\n    \n    //cell cloning \n    if(length(U.xy - pos) > 10.)\n    \tU.xy += 1.*(hash22(pos)-0.5);\n\n    //sensors\n    vec2 sleft = U.xy + sdist*vec2(cos(U.z+sangl), sin(U.z+sangl));\n    vec2 sright = U.xy + sdist*vec2(cos(U.z-sangl), sin(U.z-sangl));\n    \n    float dangl = (pixel(ch1, sleft).x - pixel(ch1, sright).x);\n    U.z += dt*sst*tanh(3.*dangl);\n   \n    vec2 pvel = pspeed*vec2(cos(U.z), sin(U.z));\n    \n    //update the particle\n    U.xy += dt*pvel;\n    \n    U.xy = loop(U.xy);\n    \n    if(length(size*0.5 - U.xy) > 0.5*min(size.x, size.y))\n    {\n        U.xy = normalize(U.xy- 0.5*size)* 0.5*min(size.x, size.y)+0.5*size;\n        U.z += 3.14;\n    }\n    \n    \n    if(iFrame < 1)\n    {\n        U.xy = vec2(pdens*round(pos.x/pdens),pdens*round(pos.y/pdens));\n        U.zw = hash22(U.xy) - 0.5;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//simulation variables\n#define dt 0.25\n#define prad 1.4\n#define decay 0.15\n\n//cell speed\nfloat pspeed = 7.;\n\n//sensor distance \nfloat sdist = 50.;\n\n//sensor strenght\nfloat sst = 10.;\n\n//sensor angle\nfloat sangl = 0.2; //radians\n\n#define pdens 2.\n//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p-0.5), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n//functions\nfloat gauss(vec2 x, float r)\n{\n    return exp(-pow(length(x)/r,2.));\n}\n   \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\n//Gradient\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n", "buffer_b_code": "//depositing and diffusing the pheromone trails \n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    Q = texel(ch1, p);\n   \n    //diffusion equation\n    Q += dt*Laplace(ch1, p);\n    \n    vec4 particle = texel(ch0, p);\n    float distr = gauss(p - particle.xy, prad);\n    \n    //pheromone depositing\n    Q += dt*distr;\n        \n    //pheromone decay\n    Q += -dt*decay*Q;\n    \n    if(iFrame < 1) Q = vec4(0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 Q, in vec2 p )\n{\n    Q = texel(ch1, p);\n    \n    Q = 0.85*Q + 0.15*texel(ch0, p); \n    if(iFrame < 1) Q =vec4(0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 240]], "test": "untested"}
{"id": "ttVGDh", "name": "Colorful Waves", "author": "ju", "description": "Colorful Waves", "tags": ["2d"], "likes": 22, "viewed": 764, "published": 3, "date": "1578857032", "time_retrieved": "2024-07-30T21:30:30.597797", "image_code": "#define PI 3.14159265359\n#define WAVES 8.\n\nfloat wavePosition(vec2 uv, float i) {\n    return sin((uv.x + i * 8.456) * (sin(iTime * 0.1 + 7.539 + i * 0.139) + 2.) * 0.5) * 0.65\n        + sin(uv.x * (sin(iTime * 0.1 + i * 0.2) + 2.) * 0.3) * 0.3\n        - (i - WAVES / 2.) * 2. - uv.y;\n}\n\n// https://iquilezles.org/articles/palettes\nvec3 colorPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(PI * 2. * (c * t + d));\n}\nvec3 color(float x) {\n    return colorPalette(x, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2., 1., 0.), vec3(0.5, 0.2, 0.25));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec2 waveUv = (2. * fragCoord - iResolution.xy) / iResolution.y * (WAVES - 1.);\n\n    float aa = WAVES * 2. / iResolution.y;\n\n    for (float i = 0.; i < WAVES; i++) {\n        float waveTop = wavePosition(waveUv, i);\n        float waveBottom = wavePosition(waveUv, i + 1.);\n\n        vec3 col = color(i * 0.12 + uv.x * 0.2 + iTime * 0.02);\n\n        col += smoothstep(0.3, 0., waveTop) * 0.05;\n        col += (1. - abs(0.5 - smoothstep(waveTop, waveBottom, 0.))) * 0.06;\n        col += smoothstep(-0.3, 0., waveBottom) * -0.05;\n\n        fragColor.xyz = mix(fragColor.xyz, col, smoothstep(0., aa, waveTop));\n    }\n\n    fragColor.w = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVGDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 81, 81, 285], [287, 331, 391, 391, 440], [441, 441, 462, 462, 574], [576, 576, 631, 631, 1312]], "test": "untested"}
{"id": "tlKGDh", "name": "Physarum Polycephalum Simulation", "author": "michael0884", "description": "Using Voronoi particle tracking to simulate the dynamics of a slime mold. Use mouse to change parameters.", "tags": ["fast", "particles", "physarum", "polycephalum"], "likes": 55, "viewed": 2114, "published": 3, "date": "1578854773", "time_retrieved": "2024-07-30T21:30:31.350784", "image_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tvec4 particle = texel(ch0, pos);\n    float distr = gauss(pos - particle.xy, prad);\n    vec4 pheromone = 2.5*texel(ch1, pos);\n    fragColor = vec4(sin(pheromone.xyz*vec3(1,1.2,1.5)), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//voronoi particle tracking \n//simulating the cells\n\n//loop the vector\nvec2 loop_d(vec2 pos)\n{\n\treturn mod(pos + size*0.5, size) - size*0.5;\n}\n\n//loop the space\nvec2 loop(vec2 pos)\n{\n\treturn mod(pos, size);\n}\n\n\nvoid Check(inout vec4 U, vec2 pos, vec2 dx)\n{\n    vec4 Unb = texel(ch0, loop(pos+dx));\n    //check if the stored neighbouring particle is closer to this position \n    if(length(loop_d(Unb.xy - pos)) < length(loop_d(U.xy - pos)))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec2 pos, float r)\n{\n    Check(U, pos, vec2(-r,0));\n    Check(U, pos, vec2(r,0));\n    Check(U, pos, vec2(0,-r));\n    Check(U, pos, vec2(0,r));\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 muv = iMouse.xy/size;\n    \n    if(length(muv.xy) >0.)\n    {\n    \tsdist *= muv.x;\n  \t\tsst *= muv.y; \n    }\n    else\n    {\n        sdist *= 0.8;\n  \t\tsst *= 0.05; \n    }\n   \n    //this pixel value\n    U = texel(ch0, pos);\n    \n    //check neighbours \n    CheckRadius(U, pos, 1.);\n    CheckRadius(U, pos, 2.);\n    CheckRadius(U, pos, 3.);\n    CheckRadius(U, pos, 4.);\n    CheckRadius(U, pos, 5.);\n   \n    U.xy = loop(U.xy);\n    \n    //cell cloning \n    if(length(U.xy - pos) > 10.)\n    \tU.xy += 1.*(hash22(pos)-0.5);\n\n    //sensors\n    vec2 sleft = U.xy + sdist*vec2(cos(U.z+sangl), sin(U.z+sangl));\n    vec2 sright = U.xy + sdist*vec2(cos(U.z-sangl), sin(U.z-sangl));\n    \n    float dangl = (pixel(ch1, sleft).x - pixel(ch1, sright).x);\n    U.z += dt*sst*tanh(3.*dangl);\n   \n    vec2 pvel = pspeed*vec2(cos(U.z), sin(U.z)) + 0.1*(hash22(U.xy+iTime)-0.5);;\n    \n    //update the particle\n    U.xy += dt*pvel;\n    \n    U.xy = loop(U.xy);\n    \n    \n    if(iFrame < 1)\n    {\n        U.xy = vec2(pdens*round(pos.x/pdens),pdens*round(pos.y/pdens));\n        U.zw = hash22(U.xy) - 0.5;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//simulation variables\n#define dt 0.25\n#define prad 1.4\n#define decay 0.15\n\n//cell speed\nfloat pspeed = 6.;\n\n//sensor distance \nfloat sdist = 10.;\n\n//sensor strenght\nfloat sst = 10.;\n\n//sensor angle\nfloat sangl = 0.3; //radians\n\n#define pdens 2.\n//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p-0.5), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n//functions\nfloat gauss(vec2 x, float r)\n{\n    return exp(-pow(length(x)/r,2.));\n}\n   \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\n//Gradient\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n", "buffer_b_code": "//depositing and diffusing the pheromone trails \n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    Q = texel(ch1, p);\n   \n    //diffusion equation\n    Q += dt*Laplace(ch1, p);\n    \n    vec4 particle = texel(ch0, p);\n    float distr = gauss(p - particle.xy, prad);\n    \n    //pheromone depositing\n    Q += dt*distr;\n        \n    //pheromone decay\n    Q += -dt*decay*Q;\n    \n    if(iFrame < 1) Q = vec4(0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 Q, in vec2 p )\n{\n    Q = texel(ch1, p);\n    \n    Q = 0.9*Q + 0.1*texel(ch0, p); \n    if(iFrame < 1) Q =vec4(0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKGDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 241]], "test": "untested"}
{"id": "tlK3Wh", "name": "Day 24 - Esphaxis", "author": "jeyko", "description": "I was not sure how to name it so, here it goes. Was supposed to look like a crystal, but it looked bad, so I made it glow :D . ", "tags": ["mdtmjvm"], "likes": 11, "viewed": 572, "published": 3, "date": "1578851509", "time_retrieved": "2024-07-30T21:30:32.116736", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define iTime (iTime + 12.)\nfloat r11(float i) {return fract(sin(i*2124.522)*214.124);}\n\n#define mx (200.*iMouse.x/iResolution.x)\nfloat sdBox(vec3 p, vec3 r){\n    p = abs(p);\n\tp -= r;\n    return max(p.x, max(p.y, p.z));\n}\n#define rot(x) mat2(cos(x),-sin(x),sin(x), cos(x))\n//#define sdmin\n#define pi acos(-1.)\n#define pmod(p, x) mod(p, x) - x*0.5\nvec2 map(vec3 p){\n    \n    float modDist = 8.;\n    float id = floor(p.z/modDist);\n    p.z = pmod(p.z, modDist);\n\tvec2 d = vec2(10e5);\n\n    \n    /*\n    const int iters = 6;\n    for (int i = 0; i < iters; i++){\n    \tp = abs(p);\n\n        p.x -= 1.25;\n        p.y -= 0.9;\n        p.z -= 1.;\n        p.xy *= rot(0.5 + sin(t)*0.1);\n        p.yz *= rot(0.1);\n        if (i == iters - 1){\n            p.z += 0.6;\n            p.y -= 0.1;\n        \tp.yz *= rot(0.2);\n        }\n    \n    }*/\n    \n    float t = iTime + id*2.3;\n    const int iters = 4;\n    for (int i = 0; i < iters; i++){\n    \tp = abs(p);\n        \n        p.x -= 1. + sin(id*1.5)*0.4;\n        p.xy *= rot(0.5 + sin(id)*0.3);\n        p.y -= 1.4;\n        p.z -= .5;\n        if (i == 2){\n        \tp.yz*=rot(0.4 + sin(id)*.2);\n            p.y -= 0.2 + sin(id*421.12)*0.2;\n        \n        }\n        \n        //p.zy *= rot(0.7 - float(i)*0.2);\n        //p.zy *= rot(1.2 - float(i)*0.2);\n    \n    }\n    \n  \td.x = min(d.x, sdBox(p,vec3(0.6)));  \n    //d.x = min(d.x, length(p) - 0.1);  \n   \n    d.x *= 0.5;\n\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.01, 0);\n    return normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return dir + right*uv.x + up*uv.y;\n}\n#define pal(x,t) (0.5 + 0.5*sin(vec3(1.4,1.1,1.9)*t + x))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0. + sin(iTime*0.5)*0.7,0. + sin(iTime*0.8)*0.2,-4);\n    //vec3 ro = vec3(0. + 1.5,0. + sin(iTime*0.8)*0.2,-4);\n    \n\tro.z += iTime*10. + mx;\n    vec3 lookAt = ro + vec3(0,0,5);;\n    lookAt +=  vec3(0. + sin(iTime*0.4),0. + sin(iTime*0.4)*0.5,1);\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    float bounce = 0.;\n    vec3 attenuation = vec3(1.);\n    float side = 1.;\n    float t = 0.; vec3 p = ro;\n    float tO = 0.;\n    vec3 pO = p;\n    for (int i = 0; i < 300; i++){\n    \tvec2 d = map(p);\n        d.x *= side;\n        \n        if (d.x < 0.001){\n            vec3 n = getNormal(p)*side;\n            \n            vec3 lD = normalize(vec3(-1,-2,1));\n            vec3 h = normalize(lD - rd);\n            \n            float diff = max(dot(n,lD), 0.); \n            float fres = pow(1. - max(dot(-rd, n), 0.), 8.);\n            float spec = pow(max(dot(n, h), 0.), 2.);\n            vec3 albedo = vec3(0.2,0.5,0.9)*0.1;\n            col += mix(albedo*diff, vec3(pal(fres*4. + 5.,0.9 + fres)*attenuation*(spec*fres)*9.54), 0.7)*attenuation;\n            \n            //col += pow( fres, 5.)*pal(1. - fres*10.,10.5)*attenuation*0.5;\n            //col += pow(1. -fres*spec*200., 5.)*pal(fres*9.,9.5)*attenuation*0.1;\n            \n            \n            \n            if (bounce == 0.){\n                tO = t;\n                pO = p;\n            }\n            attenuation *= vec3(0.6,0.7,0.9)*0.6;\n            //side = -side;\n            bounce++;\n            //rd = refract(rd,n, 1. + n.x*0.4 + n.y*0.3);\n            rd = reflect(rd,n );\n            ro = p;\n            t = 0.;\n            d.x = 0.1;\n        \t//break;\n        }\n        if (t > 100.){\n            if (bounce == 0.){\n            \ttO = t;\n                pO = p;\n            }\n        \tbreak;\n        }\n        \n        t += d.x;\n\t\tp = ro + rd*t;\n    }\n    \n    float T = iTime*4.;\n    if(bounce > 0.){\n        float tInterval = 4.;\n        float tId = floor(iTime/tInterval);\n        float tM = mod(iTime,tInterval);\n        float rC = r11(tId);\n        float rN = r11(tId + 1.);\n        \n        vec3 modeA = pow(0.6 + sin(\n            sin(pO.z*5.4 + T)\n        )*0.5, 50.)*vec3(1.)*pal(5.5 ,9.8 + sin(iTime)*0.1);\n        vec3 modeB = pow(0.6 + sin(\n            sin(pO.x*0.2 + T + pO.y*0.4*sin(iTime )*pO.x*2. + sin(iTime))\n        )*0.5, 100.)*vec3(1.)*pal(2.5 ,6.8 + sin(iTime)*0.1);\n        vec3 modeC = pow(0.6 + sin(\n            sin(pO.y*0.01 + T*1. + pO.z*0.2)\n        )*0.48, 100.)*vec3(1.)*pal(5.5 ,6.8 + sin(iTime)*0.1);\n        vec3 currMode, nextMode = vec3(0);\n        float currId = floor(rC*2.99), nextId = floor(rN*2.99);\n        \n        currId == 0. ? currMode = modeA : currId == 1. ? currMode = modeB : currId == 2. ? currMode = modeC : currMode;\n        nextId == 0. ? nextMode = modeA : nextId == 1. ? nextMode = modeB : nextId == 2. ? nextMode = modeC :  nextMode;\n        \n        col += mix(currMode,nextMode, pow(tM/tInterval, 3.));\n    \n    }\n    //col = mix(col,smoothstep(0.,0.95, col), 0.5);\n    col.g *= 0.98;\n    col = mix(col, vec3(0.,0,0.),pow((tO - 5.2)*0.02, 2.));\n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "ivec2 offsets[8] = ivec2[8]( ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0));\n\nvec3 RGBToYCoCg( vec3 RGB )\n{\n\tfloat Y = dot(RGB, vec3(  1, 2,  1 )) * 0.25;\n\tfloat Co= dot(RGB, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat Cg= dot(RGB, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(Y, Co, Cg);\n}\n\nvec3 YCoCgToRGB( vec3 YCoCg )\n{\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat Cg= YCoCg.z - ( 0.5 * 256.0 / 255.0 );\n\tfloat R= Y + Co-Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co-Cg;\n\treturn vec3(R,G,B);\n}\n\n//#define NO_AA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;    \n    vec3 new = RGBToYCoCg(textureLod(iChannel0, q, 0.0).xyz);\n    vec3 history = RGBToYCoCg(textureLod(iChannel1, q, 0.0).xyz);\n    \n    vec3 colorAvg = new;\n    vec3 colorVar = new*new;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = RGBToYCoCg(texture(iChannel0, ((fragCoord.xy+float(offsets[i])*0.2 )/iResolution.xy)).xyz);\n        colorAvg += fetch;\n        colorVar += fetch*fetch;\n    }\n    colorAvg /= 9.0;\n    colorVar /= 9.0;\n    float gColorBoxSigma = 0.75;\n\tvec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg*colorAvg));\n\tvec3 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec3 colorMax = colorAvg + gColorBoxSigma * sigma;\n    \n    history = clamp(history, colorMin, colorMax);\n  \n\tfragColor = vec4(YCoCgToRGB(mix(new, history, 0.95)), 1.0);\n#ifdef NO_AA\n    fragColor = vec4(YCoCgToRGB(new), 1.0);\n#endif\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlK3Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 137]], "test": "untested"}
{"id": "3tKGW1", "name": "Cornell Box ", "author": "angelo12", "description": "First attempt at GPU path tracing. Super happy with the results! ", "tags": ["pathtracing", "cornell", "indirect"], "likes": 10, "viewed": 680, "published": 3, "date": "1578835043", "time_retrieved": "2024-07-30T21:30:32.862742", "image_code": "/*\n\tShader Sundays! (2/52) \n\t\"Cornell Box\"\n\t\n\tThis week I was\tinspired by watching Luna break down Brutal Knowledge (https://www.shadertoy.com/view/3dyXzD)\n\tin this stream( https://www.youtube.com/watch?v=xAVLCoDc7qo&feature=youtu.be ). Honestly could not be happier\n\twith the results. GPU path tracing turned out to be much simpler than I expected and it looks great! \n\tI got to reuse most of my raymarching knowledge from other SDF experiments so that really simplified things.\n\tThe only real \"new\" stuff is the GI_BOUNCES loop in the render function.  \n\t\n\tFor the future I want to dig into how the rayOnHemisphere function works and see if I can get some blue noise\n\tin here :D. \n\t\n\tOther sources and references from IQ:\n\thttps://www.shadertoy.com/view/3dyXzD //Basic Montecarlo \n\thttps://www.shadertoy.com/view/Xds3zN //SDF Primitives\n*/\n\n#define INV_GAMMA 0.454545\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    //Camera setup\n    vec2 uv = fragPos / iResolution.xy;\n    vec3 col = vec3(0.0);\n\n    //Time averaging previous frames\n    if(iFrame > 0)\n    {\n        col = texture(iChannel0, uv).xyz;\n        col /= float(iFrame);\n    }\n\n    //Postprocessing\n    col *= 2.0;                                     // Exposure\n    col = pow(col, vec3(INV_GAMMA));                // Gamma correction\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[871, 871, 924, 943, 1343]], "test": "untested"}
{"id": "WtK3Dh", "name": "Night Forest", "author": "yasuo", "description": "generative forest", "tags": ["forest"], "likes": 2, "viewed": 348, "published": 3, "date": "1578832532", "time_retrieved": "2024-07-30T21:30:33.610742", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n// https://www.shadertoy.com/view/3sd3Rs\nfloat bnoise( in float x )\n{\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    //float k = hash(uint(i));\n  \t//float k = 0.5+0.5*sin(i);\n  \tfloat k = fract(i*.1731);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\nfloat hash(in vec3 x) { return fract(sin(dot(x, vec3(12.9898, 78.233, 49.256)))*43237.5324); }\n\nvec4 tree(vec3 q, float y) {\n    float tree = sdBox(q-vec3(0.0,1.0+y,0.0),vec3(0.2,2.0,0.2));\n    \n    q.xz *= 0.6;\n    float tree0 = sdPyramid(q-vec3(0.0,1.8+y,0.0), 3.0);\n    q.xz *= 1.2;\n    float tree1 = sdPyramid(q-vec3(0.0,3.1+y,0.0), 2.0);\n    tree = min(tree,min(tree0,tree1));\n    vec4 res = vec4(vec3(0.8),tree);\n    return res;\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    float _floor = p.y;\n\n    float y = -0.5;\n    float t = iTime*2.0;\n    \n    // ground\n    p.x +=t;\n    p += bnoise( p.x*0.1)+bnoise( p.z*0.1);\n    _floor = p.y;\n    vec4 resF = vec4(vec3(0.7),_floor*0.9);\n    \n    // tree\n    p = prevP;\n    p.x += t;\n    \n    vec3 q = p;\n    \n    vec3 c = vec3(20., 0., 5.0);\n    vec3 id = floor(p / c) * vec3(1.0,0.0,1.0);\n\tvec4 q2 = vec4(mod(p, c) - 0.5*c, hash(id));\n    float h = 1.0-q2.w*3.0;\n    q.y -= (h<-0.5)?0.1:h;\n    q = vec3(q2.x, q.y, q2.z);\n    q.x -= 3.0*(q2.w*2.0-1.0);\n    \n    vec4 resTree = tree(q,y);\n    \n    vec4 model = combine(resTree,resF);\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nfloat GetAmbientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - RayMarch(p + n*d,n).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n\n    float ao = GetAmbientOcclusion(p,n);\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif*ao),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(-20.0));\n    ro.yz *= Rot(radians(-20.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col = vec3(1.0);\n        float fullmoon = smoothstep(0.02,-0.02,length(uv-vec2(.6,.35))-0.08);\n        col *= fullmoon;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[514, 514, 555, 555, 646], [648, 648, 684, 684, 726], [728, 728, 757, 757, 841], [843, 843, 878, 878, 1363], [1365, 1406, 1434, 1451, 1780], [1782, 1782, 1805, 1805, 1876], [1878, 1878, 1906, 1906, 2218], [2220, 2220, 2242, 2242, 2891], [2893, 2893, 2926, 2926, 3179], [3181, 3181, 3205, 3205, 3406], [3408, 3408, 3442, 3442, 3756], [4106, 4106, 4129, 4129, 4530], [4532, 4532, 4574, 4574, 4769], [4771, 4771, 4828, 4828, 5612]], "test": "untested"}
{"id": "3tK3Wh", "name": "Infinite Repetition Glitch", "author": "kstyler", "description": "I'm new to shader programming and was trying to get an infinite repetition effect with spheres. After playing around with some of the numbers I got this effect and thought it looked interesting.", "tags": ["raymarch", "glitch", "infinite"], "likes": 10, "viewed": 657, "published": 3, "date": "1578810837", "time_retrieved": "2024-07-30T21:30:34.360736", "image_code": "const float EPSI = 0.01;\n\nfloat SDF(vec3 p){\n    \n    float c = 99.;\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n\treturn length(q)-0.5;\n}\n\nfloat marcher(vec3 ro, vec3 rd){\n    \n\tfloat totalDst = 0.;\n    for(int i =0;i<100;i++){\n    \tvec3 p = ro+totalDst*rd;\n        float dst = SDF(p);\n        totalDst+=dst;\n        if(totalDst>1000. || dst < EPSI)break;\n    }\n    return totalDst;\n}\n\nvec3 normal(vec3 p ){\n    \n\tvec3 norm = normalize(vec3(SDF(vec3(p.x+EPSI,p.y,p.z))-SDF(vec3(p.x-EPSI,p.y,p.z)),\n                               SDF(vec3(p.x,p.y+EPSI,p.z))-SDF(vec3(p.x,p.y-EPSI,p.z)),\n                               SDF(vec3(p.x,p.y,p.z+EPSI))-SDF(vec3(p.x,p.y,p.z-EPSI))));\n    return norm;\n}\n\nfloat lighting(vec3 p){\n    \n    vec3 lightPos= vec3(1,4,9);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = normal(p);\n    float diff = clamp(dot(n,l),0.,1.);\n\treturn diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv =(fragCoord-.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(40.+(0.*iTime),70.*iTime,70.*iTime);\n    vec3 rd = normalize(vec3(uv,1));\n    vec3 col = vec3(lighting(ro+rd*vec3(marcher(ro,rd))));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tK3Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 44, 44, 128], [130, 130, 162, 162, 375], [377, 377, 398, 398, 685], [687, 687, 710, 710, 863], [865, 865, 921, 921, 1169]], "test": "untested"}
{"id": "tlGGWh", "name": "CircleMatrix2D", "author": "Lordinator", "description": "aims to represent matrix multiplication to the math circle coordinates.\nEnter your matrix in matrixModifier.\nYou can make a square if you use pInfinite distance.", "tags": ["math"], "likes": 6, "viewed": 477, "published": 3, "date": "1578783703", "time_retrieved": "2024-07-30T21:30:35.115718", "image_code": "#define pi 3.14159\n\nfloat smoothEquality(float a, float b, float sharpness){\n    return exp(-abs(a-b)*sharpness);\n}\n\nfloat pInfiniteLength(vec2 a){\n    return  max(abs(a.x),abs(a.y));\n}\n\n/*\n\th : given in radians.\n\ts : from 0 to 1.\n\tv : from 0 to 1.\n*/\nvec3 hsvToRgb(vec3 hsv){/* disgusting (and not understood) but from wikipedia :\n\t\t\t\t\t\thttps://fr.wikipedia.org/wiki/Teinte_Saturation_Valeur */\n    float s = hsv.y;\n    float v = hsv.z;\n    \n    \n    vec3 rgb;\n    hsv.x *= 180.f/pi;\n    hsv.x = mod(hsv.x,360.f);\n    int state = int(hsv.x/60.f)%6;\n    float f = hsv.x/60.f - float(state);\n    \n    float l = (1.f - s);\n    float m = (1.f - s * f);\n    float n = (1.f - (1.f-f) * s);\n\t\n    return v * vec3[](vec3(1,n,l),\n                 vec3(m,1,l),\n                 vec3(l,1,n),\n                 vec3(l,m,1),\n                 vec3(n,l,1),\n                 vec3(1,l,m))[state];\n}\n\nvec3 smoothedCircle(vec2 xy, vec2 center,\n                    float radius, float sharpness){\n    xy/=radius;\n    return vec3(hsvToRgb(vec3(pi + atan(xy.y,xy.x),1.0f,\n                              smoothEquality(length(xy-center),radius,sharpness))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = iTime*iTime*0.5;\n        mat2 matrixModifier =mat2(2.0*cos(angle), .1*sin(angle),\n                              -sin(angle), cos(angle));\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 xy = fragCoord;\n\txy -= iResolution.xy * 0.5f;\n    xy *= 0.01;\n    vec2 modifiedXY = xy * inverse(matrixModifier);\n    // Time varying pixel color\n    vec3 col = \tsmoothedCircle(modifiedXY\t,vec2(0,0),1.f,15.f)+\n        \t\tsmoothedCircle(xy\t\t\t,vec2(0,0),0.5f,4.f);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 76, 76, 115], [117, 117, 147, 147, 185], [883, 883, 976, 976, 1136], [1139, 1139, 1196, 1196, 1736]], "test": "untested"}
{"id": "3lyGDh", "name": "Day 23 - glitchy stuff", "author": "jeyko", "description": "Check out the other ones from today here  https://imgur.com/a/pZUxRGK \n\n", "tags": ["glitch", "feedback"], "likes": 27, "viewed": 835, "published": 3, "date": "1578778566", "time_retrieved": "2024-07-30T21:30:35.870700", "image_code": "// I got inspired by victor_shepardson and made a bunch of glitchy stuff today\n// You can check some of them out here https://imgur.com/a/pZUxRGK \n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R.xy;\n\n    C = texture(iChannel0, uv);\n    C = clamp(C,0., 1.);\n    C =  0.01 + 0.9*C;\n    C = pow(C, vec4(0.45));\n}\n\n\n// Sharpen kernel from https://www.shadertoy.com/view/MtdXW4\n\n ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n\n//#define D C += T(U + C.yx*i*1.)*0.1; i *= i + 2.;\n#define D C += T(U + C.yz*i)*1.; i *= -1.2;\n#define F A += T(U + T(U + C.xy*i*200.).xy*0.3   )\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R.xy;\n\tuv *= 0.998;\n    vec2 i = vec2(1. - cos(uv.y*2.),-4. + sin(uv.x*2.));\n    C = mix(uv.yyxx,uv.yxyx, 0.5+sin(iTime)*0.55);\n    D\n    vec4 A =T(uv + C.yx);\n    D\n    F*-0.1;\n    D\n    D\n    F*+0.3;\n    D \n    F*-0.21;\n    D \n    F*+0.2;\n    D \n    F*-0.2;\n    F;\n    D \n    F*-0.9;\n    //vec4 SH = sharpen(iChannel0,U/R, R.xy);\n    //A -= SH*0.1;\n    D;\n    F*-0.3;\n    C = mix(sin(A*1.5), sin(C.barg*1.4), .1);\n    \n    if (iMouse.z > 0.){\n        float dMouse = length((U.xy - iMouse.xy)/iResolution.y);\n    \tC = mix(C, vec4(-0.,0.,0.2, 0.4) ,smoothstep(0.2,0.14, dMouse));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n#define T(uv) texture(iChannel0, uv/R.xy)\n#define Neighbors vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n\n\nvec4 sharpen(sampler2D channel,vec2 uv,vec2 res){\n    vec2 step = 1.0 / res;\n    float kernel [9];vec2 offset [9];\n\n\n    offset[0] = vec2(-step.x, -step.y);\n    offset[1] = vec2(0.0, -step.y);\n    offset[2] = vec2(step.x, -step.y);\n    \n    offset[3] = vec2(-step.x, 0.0);\n    offset[4] = vec2(0.0, 0.0);\n    offset[5] = vec2(step.x, 0.0);\n    \n    offset[6] = vec2(-step.x, step.y);\n    offset[7] = vec2(0.0, step.y);\n    offset[8] = vec2(step.x, step.y);\n    \n    kernel[0] = 0.0; kernel[1] = -0.25; kernel[2] = 0.0;\n    kernel[3] = -0.25; kernel[4] = 1.0; kernel[5] = -0.25;\n    kernel[6] = 0.0; kernel[7] = -0.25; kernel[8] = 0.0;\n    \n    vec4 sum = texture(channel, uv);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 color = texture(channel, uv + offset[i]);\n        sum += color * kernel[i]*2.;\n    }\n    return sum;\n}\n\nvec4 blur(sampler2D channel,vec2 uv,vec2 res){\n    vec2 step = 1.0 / res;\n    float kernel [9];vec2 offset [9];\n\n\n    offset[0] = vec2(-step.x, -step.y);\n    offset[1] = vec2(0.0, -step.y);\n    offset[2] = vec2(step.x, -step.y);\n    \n    offset[3] = vec2(-step.x, 0.0);\n    offset[4] = vec2(0.0, 0.0);\n    offset[5] = vec2(step.x, 0.0);\n    \n    offset[6] = vec2(-step.x, step.y);\n    offset[7] = vec2(0.0, step.y);\n    offset[8] = vec2(step.x, step.y);\n    \n    kernel[0] = 1.0; kernel[1] = 1.; kernel[2] = 1.0;\n    kernel[3] = 1.; kernel[4] = 1.0; kernel[5] = 1.;\n    kernel[6] = 1.0; kernel[7] = 1.; kernel[8] = 1.0;\n    \n    vec4 sum = vec4(0);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 color = texture(channel, uv + offset[i]);\n        sum += color * kernel[i];\n    }\n    sum /= 9.;\n\t\n    return sum;\n}", "buffer_b_code": "\n#define T(uv) texture(iChannel0, uv/R.xy)\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R.xy;\n    \n    //C = sharpen(iChannel1,U/R.xy, R.xy);\n \tC = T(U);   \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyGDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 189, 189, 322]], "test": "untested"}
{"id": "ttyGWh", "name": "Psychedelic Mind Blood", "author": "Nightmare", "description": "Neon Light Psychedelic", "tags": ["mindneon"], "likes": 3, "viewed": 397, "published": 3, "date": "1578778060", "time_retrieved": "2024-07-30T21:30:36.620694", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 UV = fragCoord.xy / iResolution.xy;\n    \n    float XRed = pow(abs((-UV.x + 0.5) * abs(sin(iTime))), 0.5);\n    float YRed = pow(abs((-UV.y + 0.5) * abs(sin(iTime))), 0.5);\n    \n    float XRedB = pow(abs((-UV.x + 0.25) * abs(sin(iTime))), 0.5);\n    float YRedB = pow(abs((-UV.y + 0.25) * abs(sin(iTime))), 0.5);\n    \n    float XRedC = pow(abs((-UV.x + 0.75) * abs(sin(iTime))), 0.5);\n    float YRedC = pow(abs((-UV.y + 0.75) * abs(sin(iTime))), 0.5);\n    \n    \n    float XBlue = pow(abs((-UV.x + 0.5) * abs(sin(iTime * 8.0))), 0.5);\n    float YBlue = pow(abs((-UV.y + 0.5) * abs(sin(iTime * 8.0))), 0.5);\n    \n    float XBlueB = pow(abs((-UV.x + 0.25) * abs(sin(iTime * 8.0))), 0.5);\n    float YBlueB = pow(abs((-UV.y + 0.25) * abs(sin(iTime * 8.0))), 0.5);\n    \n    float XBlueC = pow(abs((-UV.x + 0.75) * abs(sin(iTime * 8.0))), 0.25);\n    float YBlueC = pow(abs((-UV.y + 0.75) * abs(sin(iTime * 8.0))), 0.25);\n    \n    float XGreen = pow(abs((-UV.x + 0.5) * abs(sin(iTime * 16.0))), 0.25);\n    float YGreen = pow(abs((-UV.y + 0.5) * abs(sin(iTime * 16.0))), 0.25);\n    \n    float XGreenB = pow(abs((-UV.x + 0.25) * abs(sin(iTime * 16.0))), 0.25);\n    float YGreenB = pow(abs((-UV.y + 0.25) * abs(sin(iTime * 16.0))), 0.25);\n    \n    float XGreenC = pow(abs((-UV.x + 0.75) * abs(sin(iTime * 16.0))), 0.25);\n    float YGreenC = pow(abs((-UV.y + 0.75) * abs(sin(iTime * 16.0))), 0.25);\n    \n    float FinalRedX = XRed * XRedB * XRedC;\n    float FinalRedY = YRed * YRedB * YRedC;\n    \n    float FinalBlueX = XBlue * XBlueB * XBlueC;\n    float FinalBlueY = YBlue * YBlueB * YBlueC;\n    \n    float FinalGreenX = XGreen * XGreenB * XGreenC;\n    float FinalGreenY = YGreen * YGreenB * YGreenC;\n    \n    float FinalRed = YRed * XRed;\n    float FinalBlue = YBlue * XBlue;\n    float FinalGreen = YGreen * XGreen;\n    \n    float HorizontalOverlay = abs(sin((UV.x * 500.0) + (iTime * 2.0)));\n    float VerticalOverlay = abs(sin((UV.y * 400.0) + (iTime * 2.0)));\n    \n    vec4 FirstPass = vec4(1.0 - FinalRed, 1.0 - FinalGreen, 1.0 - FinalBlue, 1.0);\n    vec4 SecondPass = vec4(HorizontalOverlay, HorizontalOverlay, HorizontalOverlay, 1.0);\n    vec4 ThirdPass = vec4(VerticalOverlay, VerticalOverlay, VerticalOverlay, 1.0);\n    vec4 FourthPass = vec4(FinalRed, FinalBlue, FinalGreen, 0.60);\n    vec4 EirdPass = vec4(VerticalOverlay, VerticalOverlay, VerticalOverlay, 1.0);\n    \n    \n    \n\n    \n    \n    \n    \n    fragColor = FirstPass * SecondPass * ThirdPass;\n    \n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2526]], "test": "untested"}
{"id": "3ly3Dh", "name": "searching — sat.sketch #6", "author": "szczm_", "description": "today's sketch is brought to you by a photo of a tapioca dessert.\n\nhttps://commons.wikimedia.org/wiki/File:Tapioca,_aka_boba.jpg\n\ncode commented nicely so read away~", "tags": ["2d", "voronoi", "noise", "chromaticaberration", "blur", "lens", "lens", "fake", "dof", "cell", "perspective", "microscope", "grain", "aesthetic", "realistic"], "likes": 12, "viewed": 468, "published": 3, "date": "1578758899", "time_retrieved": "2024-07-30T21:30:37.375675", "image_code": "/*************************************\\\n\n searching — saturday sketch #6\n  — Matthias Scherba (szczm_)\n\n\n Today's sketch is brought to you by a photo of a tapioca dessert.\n\n https://commons.wikimedia.org/wiki/File:Tapioca,_aka_boba.jpg\n\n I wanted to do something along the lines of the photo above, but then it went\n totally sideways and I decided to do something different and, hopefully, unique.\n\n My additional goals were to use the derivative functions (and they're cool.)\n\n I wrote Voronoi without any external references on the first try, yay! \\o/\n\n Uses a hardware derivative reconstruction trick from Fabrice Neyret:\n https://www.shadertoy.com/view/3lt3DN\n\n\n This tab contains the post processing, all the other fun stuff is in other tabs:\n — Buffer A: Voronoi (nice, simple, naïve algorithm)\n — Buffer B: derivative trick (deriv. used for uniform line width)\n — Buffer C: final image\n — Image: YOU ARE HERE!\n \n\n Not signing out———\n\n\n\\***************************************************/\n\n\n#define PREVIOUS_BUFFER (iChannel0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 cuv = uv - 0.5;\n    cuv.x *= iResolution.x / iResolution.y;\n    \n    float t1 = iTime + sin(iTime * 1.3);\n    \n    vec3 color = vec3(0.0);\n    // float acc = 0.0;\n    \n    const int samples = 33;\n        \n    // More blur (and noise) the further off we go from the center\n    float offsetStrength = 0.001 + 0.007 * (length(cuv)) * (0.6 + 0.4 * sinf(t1));\n    \n    for (int i = 0; i < samples; i++) {\n        vec3 randomDirection = randomPointOnHemisphere(vec3(0.0, 0.0, 1.0), float(i));\n        \n        vec2 uvOffset = randomDirection.xy * offsetStrength;\n        // float gauss = exp(-2.0 * (1.0 - randomDirection.z));\n\n    \tvec3 col = texture(PREVIOUS_BUFFER, uv + uvOffset).rgb; // * gauss;\n        \n        // help this definitely isn't how you do chromatic abberation\n        int compId = i % 3;\n        color[compId] += col[compId];\n        \n        // color += col;\n        // acc += gauss;\n    }\n    \n    // color /= acc;\n    color /= float(samples) / 3.0;\n    \n    // Color correction\n    color = pow(color, vec3(0.85, 0.95, 1.1));\n    \n    // Subtle vi————gnette\n    color *= 1.0 - 0.5 * pow(offsetStrength * 50.0 + length(cuv) * 0.15, 2.0);\n    \n    // Grain\n    float lum = 1.0 - luminance(color);\n    color = mix(color, vec3(hash(uv * 10.0 + vec2(iTime, iTime + 1.0))), 0.13 * mix(lum, 1.0, offsetStrength * 25.0));\n    \n    fragColor = vec4(color, 1.0);\n}\n             \n#undef PREVIOUS_BUFFER", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Here I— I mean, we, generate the Voronoi. The algorithm is simple: remember\n// the distance to two closest cells, then use the difference. It works surprisingly\n// well, but will look ugly if you simply put that difference on the screen.\n//\n// Solution? \"Normalize\" the difference by dividing it by it's derivative! \\o/\n//\n// How did I come upon this solution? If you put the difference on the screen,\n// you see some cells having a widely spread gradient, and others not so much.\n// Gradient equals derivative.\n//\n// So no magic here, just a simple observation and then some intuition (:\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    const float cell_count = 40.0;\n    const float cell_speed = 0.005;\n        \n    float min1 = 10e6;\n    float min2 = 10e6;\n    \n    for (float i = 0.0; i < cell_count; i += 1.0)\n    {\n        float randomAngle = hash(i) * TAU;\n        \n        vec2 cellPosition = vec2(hash(i + cell_count), hash(i + cell_count * 2.0) + iTime * 0.125);\n        vec2 cellVelocity = vec2(cosf(randomAngle), sinf(randomAngle)) * cell_speed * iTime;\n        \n        cellPosition = mod(cellPosition + cellVelocity, vec2(1.0));\n        \n        cellPosition -= 0.5;\n        \n        cellPosition.y *= iResolution.x / iResolution.y;\n        // This line below makes it more center-centric :'\n        cellPosition *= exp(-1.5 * (1.0 - length(cellPosition)));\n        \n        cellPosition += 0.5;\n        \n        vec2 screenPosition = cellPosition * iResolution.xy;\n        float dist = distance(screenPosition, fragCoord);\n        \n        if (dist < min1) {\n            min2 = min1;\n            min1 = dist;\n        } else if (dist < min2) {\n            min2 = dist;\n        }\n    }\n    \n    // This is is. This is the whole voronoi.\n    \n    fragColor = vec4(min2 - min1);\n}", "buffer_a_inputs": [], "common_code": "// Gotta fix those for my drivers...\n#define TAU 6.28318530718\nfloat sinf(float arg) { return sin(mod(arg, TAU)); }\nfloat cosf(float arg) { return cos(mod(arg, TAU)); }\n// ...there.\n\n\nfloat hash(float i) {\n    return fract(sinf(785172.9189*i) * 20412.021401);\n}\nfloat hash(vec2 i) {\n    return hash(dot(i, vec2(2154.9251, 9253.5219)));\n}\nfloat hash(vec3 i) {\n    return hash(dot(i, vec3(2154.9251, 9253.5219, 5021.2510)));\n}\n\n\nfloat luminance(vec3 col) {\n    return dot(col, vec3(0.299, 0.587, 0.114));\n}\n\n\nvec3 randomPointOnHemisphere(vec3 dir, float seed) {\n    float a = hash(seed);\n    float b = hash(seed + 1.0);\n    float c = hash(seed + 2.0);\n    \n    vec3 point = normalize(-1.0 + 2.0 * vec3(a, b, c));\n    \n    return point * sign(dot(dir, point));\n}", "buffer_b_code": "// As mentioned in Buffer A, we need the derivative. One can get it for free by using\n// dFdx/dFdy/fwidth funcs, which is insanely useful since our \"function\" - iteration\n// through all points and finding the two closest ones - isn't really analytically\n// derivable.\n//\n// The problem is, derivative functions are 2x downsampled, so division results in\n// artifacts. So I'm using a trick that I was recommended on the ShaderToy Discord,\n// stolen from here:\n//\n// https://www.shadertoy.com/view/3lt3DN\n// \n// Thanks a lot, Fabrice Neyret! And to Orm for the recommendation! o/\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float a = texture(iChannel0, U    /iResolution.xy).r,\n          b = texture(iChannel0,(U+1.)/iResolution.xy).r;\n    O.x = a;\n    O.y = fwidth(a);\n    O.z = b;\n    O.w = fwidth(b);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This generates the \"final\" image right before the fancy post processing.\n\n#define NOISE_TEXTURE (iChannel1)\n#define PREVIOUS_BUFFER (iChannel0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float t1 = iTime + sinf(iTime * 1.3 + sinf(iTime * 1.7)) * 0.3;\n    float t2 = iTime + sinf(iTime * 1.7 + sinf(iTime * 1.9));\n    \n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    \n    // Everyone needs a bit of perspective.\n    vec3 ray = vec3(uv, 1.0);\n    ray = normalize(ray);\n    \n    vec2 shake = vec2(cosf(t1), sinf(t1)) * vec2(0.065, 0.032) * 1.5;\n    \n    uv = ray.xy;\n    uv += shake;\n    \n    // The wibbly-wobbly ripple effect.\n    vec2 noiseOrganic = 2.0 * texture(NOISE_TEXTURE, uv * vec2(0.2, 0.6) + hash(iTime)).rg - 1.0;\n    uv += noiseOrganic * mix(0.0015, 0.005, pow(max(cosf(t2), 0.0), 4.0));\n    \n    vec2 cuv = uv;\n    cuv -= shake * 0.5; // parallax! 1.0 is shake-independent, 0.0 is no parallax\n    cuv.x *= 0.95 * iResolution.x / iResolution.y;\n    \n    // \"bleh\" is \"size\" read by someone with a Scottish accent, backwards.\n    const float bleh = 0.45;\n    \n    float border = smoothstep(bleh + 0.045 + 2.0/iResolution.y, bleh + 0.045, length(cuv));\n    float borderInner = smoothstep(bleh + 0.03, bleh + 0.03 + 2.0/iResolution.y, length(cuv));\n    float borderInnerInner = smoothstep(bleh, bleh + 2.0/iResolution.y, length(cuv));\n    \n    // What? The \"lens\" actually make things smaller? Bad me, yeesh.\n    uv *= (2.0 - borderInner) / 2.;\n    \n    uv += 0.5;\n\n    float samples = texture(PREVIOUS_BUFFER, uv).r;\n\n    // This is also a part of the derivative trick…\n    vec2 f = mod(fragCoord -.5, 2.);\n\n    float v = texture(PREVIOUS_BUFFER, uv).y;\n    v = ( v + texture(PREVIOUS_BUFFER, (uv * iResolution.xy -(1.-f))/iResolution.xy).w ) / 2.;\n    // …and it ends here.\n    \n    /*const*/ float edge_width = 0.008 * iResolution.y;\n    \n    // Finally divide by the derivative. IT TOOK ONLY THREE BUFFERS :' )\n    samples /= v;\n    samples = smoothstep(edge_width * 0.5, edge_width, samples);\n    samples = mix(1.0 - samples, samples, borderInnerInner);\n        \n    float samplesFinal = 1.0 - mix(samples, 1.0, borderInnerInner * 0.92);\n    float borderFinal = border * borderInner;\n    \n    vec3 background_color = vec3(0.85) + 0.15 * textureLod(NOISE_TEXTURE, uv * vec2(1.7, 1.0), 4.0).rrr; // rrrrrrr > _>\n    vec3 foreground_color = vec3(0.85, 0.45, 0.45);\n    vec3 border_color = vec3(0.25);\n    \n    vec3 color = mix(background_color, foreground_color, samplesFinal);\n    color = mix(color, border_color, borderFinal);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n#undef NOISE_TEXTURE\n#undef PREVIOUS_BUFFER", "buffer_c_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ly3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1054, 1054, 1111, 1111, 2546]], "test": "untested"}
{"id": "ttGGDz", "name": "BODY BIKE", "author": "flemmingdjensen", "description": "Fun project trying to convert a SVG logo to a nice shader...\nTweaking code from shader \"Genius\" and IQ\nMany fun things could be done to make it more interesting :)", "tags": ["raymarch", "sdf", "remix", "symbol", "svg"], "likes": 4, "viewed": 718, "published": 3, "date": "1578745081", "time_retrieved": "2024-07-30T21:30:38.299206", "image_code": "// Tryout to see if I could convert this SVG file to a shader\n\n// Fork of \"Genius\" by Del. https://shadertoy.com/view/lddcDS\n// 2020-01-10 12:21:02\n\n// Genius - 06/03/2018 - alpha tower + Symbol remix :)\n\n// lighting etc. by IQ\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n#define AA 1   // make this 1 is your machine is too slow\n\n#define PI 3.1415926\n#define DEG2RAD ((PI * 2.0) / 360.0)\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y-0.5;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\n\n//---------------------------------------------------------\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n\n#define XP 0.0\n#define ZP 0.0\n\n//------------------------------------------------------------------\n// old alpha tower version...\nconst vec3 p01 = vec3(XP+0.0,5.95, ZP+0.0);\n\nvec4 SampleDistTexture(vec2 texuv)\n{\n    texuv.y+=1.5;\n    float aspect = iResolution.x/iResolution.y;\n    texuv.y *= aspect*0.6;\n    return texture(iChannel0,vec2(texuv.x, texuv.y)) + vec4(0.0, 0.0, 0.0, 0.00001);\n}\n\n\n\n// alpha tower remix\nvec2 map( in vec3 pos )\n{\n\tvec2 res = vec2( sdPlane(pos), 1.0 ); \t\t\t// floor (checker)\n    pos.x -= 2.0;\n    //pos.x += sin(iTime*1.2)*2.0;\n    //pos.z += cos(iTime*1.2)*2.0;\n    pos = rotateY(pos,-iTime*0.4);\n    pModPolar(pos.xz,2.);\n    pos.y *= 0.5;\n    pos.y += 2.;\n    \n    //pos.x -= 1.0+sin(iTime*0.718)*1.0;\n\n\tvec3 r1;\n    \n    r1 = pos-p01;\n    float d3 = sdCylinder(r1,vec2(3.95,5.0));\n    float d1 = sdCylinder(r1,vec2(4.0,6.0));\n\tvec4 _c = SampleDistTexture( vec2(atan(r1.x,r1.z), r1.y) / PI);\n    float sDistField = _c.w - 0.5;//+1.0/256.0;\n    d1 = max(sDistField,d1);\n    d1-= 0.025;\n    d1*= 0.5;\n    float cval = iTime+47.+(pos.y*2.5);\n    d1 = opS(d1,d3);\n    res = opU(res, vec2( d1, cval)  );\n\treturn res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 30.0;\n       \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            float f = mod( floor(0.5*pos.z) + floor(0.5*pos.x), 2.0);\n            f+= 0.4;\n            col = 0.1 + 0.9*f*vec3(0.45,0.55,0.35);\n        }\n#if 1\n        // lighting        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),4.0);\n        \n        dif *= softshadow( pos, lig, 0.01, 2.5 );\n        dom *= softshadow( pos, ref, 0.01, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 15.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n#endif\n    \tcol = mix( col, vec3(0.05,0.05,0.05), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    if (iMouse.z<0.5)\n        mo = vec2((180.0 * DEG2RAD)/6.0,0.0);\n    \n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        //vec3 ro = vec3( 6.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 6.5*sin(0.1*time + 6.0*mo.x) );\n        \n\t\tfloat ang = 0.0 * DEG2RAD;        \n        vec3 ro = vec3( 9.5*cos(ang+(6.0*mo.x)), 3. + 5.0*mo.y, 9.5*sin(ang+(6.0*mo.x)) );\n        vec3 ta = vec3( 0.0, 1.0, 0.0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,4.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// improved version of https://www.shadertoy.com/view/MlVSWc\n// === SVG Player ====      short spec: https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/paths.html\n\n#define N 100.  // splines discretization. Lower it on slow GPUs\n// absolute main SVG commands\n#define M(x,y)             x0 = _x = x;   y0 = _y = y;\n#define L(x,y)             d = min(d, line(uv, vec2(_x,_y), vec2(x,y)) ); _x=x,_y=y;\n#define C(x1,y1,x2,y2,x,y) d = min(d, bezier(uv, vec2(_x,_y), vec2(x1,y1),vec2(x2,y2), vec2(x,y)) ); _x=x,_y=y; \n#define H(x)               d = min(d, line(uv, vec2(_x,_y), vec2(x,_y)) ); _x=x;\n#define V(y)               d = min(d, line(uv, vec2(_x,_y), vec2(_x,y)) ); _y=y;\n#define Z                  d = min(d, line(uv, vec2(_x,_y), vec2(x0,y0)) );\n// relative main SVG commands\n#define m(x,y)             M(_x+x,_y+y)\n#define l(x,y)             L(_x+x,_y+y)\n#define c(x1,y1,x2,y2,x,y) C(_x+x1,_y+y1,_x+x2,_y+y2,_x+x,_y+y)\n#define h(x)               H(_x+x)\n#define v(y)               V(_y+y)\n#define z                  Z\n\n#define style(f,c)         fill=f; S=1.; COL = mod(vec4((c)/65536,(c)/256,c,1),256.)/255.;\n#define path(cmd)          cmd; draw(d,O);\n\nfloat bezier(vec2,vec2,vec2,vec2,vec2);\nfloat line(vec2,vec2,vec2);\nvoid  draw(float,inout vec4);\nconst float FILL=1., CONTOUR=0.;\nvec4 COL = vec4(0); float fill=FILL, S=1., contrast=1.;  // style state\nfloat d = 1e38;   // global to allow unique distance field\n\n// === SVG drawing ===============================================================\nvoid SVG(vec2 uv, inout vec4 O) \n{\n    float _x, _y, x0, y0; //d = 1e38; \n    uv *= 800.;                             // scaling 1080\n    uv.x += 300.;\n    uv.y -= 250.;\n    uv.y *= -1.;\n    contrast = 1.;\n\n// Copy-paste your SVG pathes here.  Slight adaptations : \n//  - add () around command params and  comma between points, \n//  - split polylines and polybéziers into sets of 1 vs 3 pairs of coordinates\n//  - path( style( FILL/CONTOUR, color(hexa) )\n//          commands \n//        )    \n    \n\tstyle(FILL, 0xffffff)\n\n\t// B\n\tM(301.694,175.144)\n\th(-6.398)\n\tv(10.86)\n\th(6.398)\n\tc(3.913,0.,5.831,-1.238,5.831,-5.401)\n\tC(307.525,176.382,305.607,175.144,301.694,175.144)\n\tM(302.615,193.335)\n\th(-7.378)\n\tv(11.735)\n\th(7.378)\n\tc(4.226,0.,6.279,-1.365,6.279,-5.904)\n\tC(308.895,194.705,306.841,193.335,302.615,193.335)\n\tM(304.61,211.899)\n\th(-21.298)\n\tv(-43.462)\n\th(21.484)\n\tc(2.358,0.,15.467,-0.372,15.467,10.801)\n\tc(0.,8.012,-8.021,8.819,-10.379,9.44)\n\tv(1.61)\n\tc(3.854,0.622,11.494,1.496,11.494,10.188)\n\tC(321.378,210.29,310.881,211.899,304.61,211.899)\n\n\t// O\n\tM(348.508,175.139)\n\tc(-8.941,0.,-10.058,7.581,-10.058,15.027)\n\tc(0.,7.45,1.116,15.023,10.058,15.023)\n\tc(9.99,-0.,10.058,-15.027,10.058,-11.)\n\tC(358.498,182.72,357.449,175.139,348.508,175.139)\n\tM(348.508,213.206)\n\tc(-14.596,0.,-22.481,-9.132,-22.481,-23.04)\n\tc(0.,-13.907,7.886,-22.971,22.481,-22.971)\n\tc(14.528,0.,22.414,9.064,22.414,22.971)\n\tC(370.922,204.073,363.036,213.206,348.508,213.206)\n\n\t// D\n\tM(393.521,175.951)\n\tl(-3.609,0.126)\n\tv(28.06)\n\tl(3.609,0.131)\n\tc(10.176,0.3,14.089,-2.675,14.089,-14.161)\n\tc(0.,-10.,-2.,-13.,-14.089,-14.161)\n\tM(397.925,211.899)\n\th(-19.93)\n\tv(-43.462)\n\th(19.988)\n\tc(12.543,0.,22.042,4.784,22.042,21.357)\n\tC(420.025,204.88,411.033,211.899,397.925,211.899)\n\n\t// Y\n\tM(448.152,196.873)\n\tL(448.152,211.899)\n\tL(436.168,211.899)\n\tL(436.168,197.126) \n\tL(418.792,168.437)\n\tL(433.126,168.437)\n\tL(442.38,187.31)\n\tL(442.93,187.31)\n\tL(452.007,168.437)\n\tL(465.969,168.437)\n\tZ\n\n\t// B\n\tM(337.081,226.876)\n\th(-6.39)\n\tv(10.869)\n\th(6.39)\n\tc(3.913,0.,5.832,-1.234,5.832,-5.4)\n\tC(342.913,228.127,340.994,226.876,337.081,226.876)\n\tM(338.011,245.072)\n\th(-7.387)\n\tv(11.739)\n\th(7.387)\n\tc(4.226,0.,6.271,-1.369,6.271,-5.899)\n\tC(344.282,246.441,342.236,245.072,338.011,245.072)\n\tM(339.997,263.641)\n\th(-21.298)\n\tv(-43.467)\n\th(21.492)\n\tc(2.35,0.,15.449,-0.372,15.449,10.81)\n\tc(0.,8.012,-8.012,8.807,-10.361,9.432)\n\tv(1.606)\n\tc(3.854,0.625,11.478,1.504,11.478,10.192)\n\tC(356.757,262.026,346.276,263.641,339.997,263.641)\n\n\t// I\n\tM(364.144,220.178)\n\tl(11.984,0.)\n\tl(0.,43.462)\n\tl(-11.984,0.)\n\tz\n\n\t// K\n\tM( 428.85,220.178)\n\tl(-17.952,20.542)\n\tl(19.253,22.921)\n\th(-15.585)\n\tl(-17.579,-22.354)\n\tl(17.275,-21.108)\n\tH(428.85)\n\tM(385.011,220.178)\n\th(11.917)\n\tv(43.462)\n\th(-11.917)\n\tV(220.178)\n\n\t// E\n\tM(432.264,263.641)\n\tL(432.264,220.174)\n\tL(465.293,220.174)\n\tL(465.293,228.059)\n\tL(444.248,228.059)\n\tL(444.248,237.626)\n\tL(459.14,237.626)\n\tL(459.14,245.326)\n\tL(444.181,245.326)\n\tL(444.181,255.628)\n\tL(466.154,255.628)\n\tL(466.154,263.641)\n\n\t// (r) commented out - too detailed and small ;)\n\t/*M(472.257,223.039)\n\th(-0.828)\n\tV(225.)\n\th(0.828)\n\tc(0.719,0.,1.149,-0.271,1.149,-0.98)\n\tC(473.406,223.275,472.976,223.039,472.257,223.039)\n\tM(473.592,227.62)\n\tl(-1.335,-2.02)\n\th(-0.828)\n\tv(2.02)\n\th(-0.828)\n\tv(-5.181)\n\th(1.791)\n\tc(1.167,0.,1.91,0.431,1.91,1.563)\n\tc(0.,0.642,-0.321,1.2,-1.2,1.487)\n\tl(1.538,2.13)\n\tH(473.592)\n\n\tM(472.366,220.935)\n\tc(-2.307,0.,-4.166,1.859,-4.166,4.167)\n\tc(0.,2.291,1.859,4.15,4.166,4.15)\n\tc(2.308,0.,4.167,-1.859,4.167,-4.15)\n\tC(476.533,222.794,474.674,220.935,472.366,220.935)\n\tM(472.366,230.02)\n\tc(-2.729,0.,-4.943,-2.214,-4.943,-4.936)\n\tc(0.,-2.729,2.214,-4.944,4.943,-4.944)\n\tc(2.73,0.,4.944,2.214,4.944,4.944)\n\tC(477.311,227.806,475.097,230.02,472.366,230.02)*/\n\n\t// INDOOR CYCLE\n\tM(218.014,277.282)\n\tl(2.734,0.)\n\tl(0.,18.036)\n\tl(-2.734,0.)\n\tz\n\n\tM(240.661,295.317)\n\tL(232.061,280.291)\n\tL(231.93,280.291)\n\tL(232.086,295.317) \n\tL(229.686,295.317)\n\tL(229.686,277.282)\n\tL(233.193,277.282)\n\tL(241.768,292.123)\n\tL(241.924,292.123)\n\tL(241.768,277.282)\n\tL(244.193,277.282)\n\tL(244.193,295.317)\n\n\tM(258.62,279.411)\n\th(-2.759)\n\tv(13.759)\n\th(2.81)\n\tc(3.457,0.,6.571,-0.744,6.571,-6.879)\n\tC(265.242,280.172,262.128,279.411,258.62,279.411)\n\tM(259.47,295.317)\n\th(-6.334)\n\tv(-18.036)\n\th(6.385)\n\tc(4.796,0.,8.523,2.054,8.523,9.009)\n\tC(268.044,292.993,264.333,295.317,259.47,295.317)\n\n\tM(281.934,279.057)\n\tc(-2.966,0.,-5.671,1.876,-5.671,7.243)\n\tc(0.,5.384,2.688,7.235,5.671,7.235)\n\tc(2.958,0.,5.637,-1.851,5.637,-7.235)\n\tc(0.,-5.384,-2.688,-7.235,-5.671,-7.235)\n\tM(281.934,295.672)\n\tc(-5.358,0.,-8.473,-3.55,-8.473,-9.373)\n\tc(0.,-5.,3.114,-9.381,8.473,-9.381)\n\tc(5.333,0.,8.477,3.558,8.477,9.381)\n\tc(0.,5.,-3.114,9.381,-8.473,+9.381)\n\n\tM(304.272,279.057)\n\tc(-2.966,0.,-5.671,1.876,-5.671,7.243)\n\tc(0.,5.384,2.688,7.235,5.671,7.235)\n\tc(2.958,0.,5.637,-1.851,5.637,-7.235)\n\tc(0.,-5.384,-2.688,-7.235,-5.671,-7.235)\n\tM(304.272,295.672)\n\tc(-5.358,0.,-8.473,-3.55,-8.473,-9.373)\n\tc(0.,-5.,3.114,-9.381,8.473,-9.381)\n\tc(5.333,0.,8.477,3.558,8.477,9.381)\n\tc(0.,5.,-3.114,9.381,-8.473,+9.381)\n\n\tM(324.387,279.386)\n\th(-2.831)\n\tv(6.702)\n\th(2.442)\n\tc(2.502,0.,4.488,-0.668,4.488,-3.398)\n\tC(328.486,279.901,326.677,279.386,324.387,279.386)\n\tM(329.356,295.317)\n\tl(-4.716,-7.116)\n\th(-3.085)\n\tv(7.116)\n\th(-2.68)\n\tv(-18.036)\n\th(6.052)\n\tc(4.04,0.,6.305,1.775,6.305,5.409)\n\tc(0.,2.088,-1.149,4.201,-3.651,4.995)\n\tl(-0.101,0.237)\n\tl(5.172,7.395)\n\tH(329.356)\n\n\tM(359.808,295.596)\n\tc(-5.536,0.,-9.221,-3.533,-9.221,-9.331)\n\tc(0.,-5.739,3.685,-9.271,9.348,-9.271)\n\tc(1.344,0.,2.586,0.051,4.04,0.338)\n\tv(2.214)\n\tc(-1.361,-0.228,-2.028,-0.389,-3.617,-0.389)\n\tc(-4.666,0.,-6.965,2.857,-6.965,7.108)\n\tc(0.,4.386,2.299,7.167,6.914,7.167)\n\tc(1.437,0.,2.332,-0.127,3.668,-0.389)\n\tv(2.138)\n\tC(362.419,295.545,361.253,295.596,359.808,295.596)\n\n\tM(377.43,288.252)\n\tL(377.48,295.317)\n\tL(374.691,295.317)\n\tL(374.741,288.252) \n\tL(368.234,277.282)\n\tL(371.395,277.282)\n\tL(376.195,285.834)\n\tL(376.322,285.834)\n\tL(381.098,277.282)\n\tL(383.971,277.282)\n\tZ\n\n\tM(397.426,295.596)\n\tc(-5.544,0.,-9.229,-3.533,-9.229,-9.331)\n\tc(0.,-5.739,3.686,-9.271,9.356,-9.271)\n\tc(1.344,0.,2.578,0.051,4.04,0.338)\n\tv(2.214)\n\tc(-1.369,-0.228,-2.037,-0.389,-3.635,-0.389)\n\tc(-4.656,0.,-6.955,2.857,-6.955,7.108)\n\tc(0.,4.386,2.299,7.167,6.913,7.167)\n\tc(1.437,0.,2.333,-0.127,3.677,-0.389)\n\tv(2.138)\n\tC(400.029,295.545,398.862,295.596,397.426,295.596)\n\n\tM(408.008,295.317)\n\tL(408.008,277.282)\n\tL(410.737,277.282)\n\tL(410.737,293.12) \n\tL(419.012,293.12)\n\tL(419.012,295.317)\n\tZ\n\n\tM(425.198,295.317)\n\tL(425.198,277.282)\n\tL(436.473,277.282)\n\tL(436.473,279.411) \n\tL(427.869,279.411)\n\tL(427.869,285.032)\n\tL(434.419,285.032)\n\tL(434.419,287.136)\n\tL(427.869,287.136)\n\tL(427.869,293.154)\n\tL(436.607,293.154) \n\tL(436.607,295.317)\n\tZ\n\n\t// Circle\n   \tM(144.898,310.125)\n\tc(-46.754,-19.489,-72.067,-49.645,-58.828,-81.474)\n\tc(17.343,-41.73,73.141,-75.275,145.077,-91.692)\n\tc(0.,0.,-0.503,-4.666,-0.554,-7.028)\n\tc(-0.063,-2.362,0.33,-6.812,0.33,-6.812)\n\tc(-77.138,22.384,-138.239,65.75,-156.537,113.899)\n\tc(-13.7,36.055,13.07,67.208,61.596,87.449)\n\tL(144.898,310.125)\n\tz\n\tM(161.068,330.172)\n\tc(35.172,12.035,79.222,18.949,126.568,18.949)\n\tc(125.312,0.,244.101,-61.258,258.181,-136.194)\n\tc(12.356,-65.762,-67.148,-105.797,-192.461,-105.797)\n\tc(-22.363,0.,-44.472,1.91,-65.855,5.443)\n\tc(0.,0.,1.099,4.83,1.479,8.24)\n\tc(0.38,3.397,0.372,8.038,2.372,8.038)\n\tc(16.886,-1.876,34.305,-2.865,52.036,-2.865)\n\tc(116.938,0.,189.672,46.573,178.145,102.667)\n\tc(-13.143,63.895,-122.549,103.702,-239.469,103.702)\n\tc(-39.533,0.,-75.938,-5.629,-105.946,-15.205)\n\tL(161.068,330.172)\n\tz\n\n\t// Head\n\tM(238.666,125.524)\n\tc(-1.42,16.654,6.799,33.553,18.64,34.567)\n\tc(11.841,1.01,22.811,-14.253,24.231,-30.903)\n\tc(1.42,-16.662,-7.243,-28.397,-19.08,-29.412)\n\tC(250.617,98.774,240.086,108.874,238.666,125.524)\n\tz\n\n    // Body\n\tM(119.354,357.936)\n\tc(0.072,-0.118,40.15,-49.552,57.484,-92.148)\n\tc(0.173,-0.422,-0.067,-1.099,-0.439,-1.344)\n\tc(-4.725,-3.186,-14.516,-6.583,-44.228,-23.36)\n\tc(-12.398,-7.006,-10.218,-23.009,-4.335,-29.192)\n\tc(0.296,-0.3,28.537,-40.902,91.548,-66.759)\n\tc(13.467,-5.523,17.854,7.365,20.166,14.524)\n\tc(13.814,50.186,53.372,103.934,53.431,104.103)\n\tc(0.067,0.169,0.102,0.355,0.102,0.541)\n\tc(0.,0.871,-0.693,1.563,-1.555,1.563)\n\tc(-0.372,0.,-0.735,-0.093,-0.963,-0.33)\n\tc(-0.423,-0.457,-44.984,-40.095,-61.363,-66.172)\n\tc(-0.279,-0.452,-0.71,-0.676,-1.285,-0.634)\n\tc(-4.255,0.321,-22.274,4.26,-54.695,13.624)\n\tc(-0.909,0.232,-1.099,1.585,-0.596,2.096)\n\tc(9.491,9.521,32.602,36.997,40.466,46.911)\n\tc(0.676,0.845,1.809,3.187,-1.213,7.015)\n\tc(-9.216,12.12,-88.898,90.821,-90.344,91.667)\n\tc(-0.25,0.135,-0.528,0.237,-0.828,0.237)\n\tc(-0.867,0.,-1.568,-0.693,-1.568,-1.555)\n\tC(119.139,358.434,119.219,358.172,119.354,357.936)\n\tz\n        \n    draw(d,O);\n}\n\n// --- spline interpolation ( inspired from revers https://www.shadertoy.com/view/MlGSz3 )\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t)\n{\n    vec2 A = G4-G1 + 3.*(G2-G3),\n         B = 3.*(G1-2.*G2+G3),\n         C = 3.*(G2-G1),\n         D = G1;\n    return t * (t * (t * A + B) + C) + D;\n}\n\n\nfloat line(vec2 p, vec2 a, vec2 b) \n{\n\tvec2 pa = p - a, ba = b - a,\n\t     d = pa - ba * clamp(dot(pa, ba) / dot(ba, ba) , 0., 1.); // distance to segment\n    if  ( (a.y>p.y) != (b.y>p.y) &&\n           pa.x < ba.x * pa.y / ba.y ) S = -S;     // track interior vs exterior\n\treturn dot(d,d); //length(d);                  // optimization by deferring sqrt\n}\n// interior detection (sign S): ( thanks TimoKinnunen https://www.shadertoy.com/view/4lySWd )\n// see http://web.archive.org/web/20161116163747/https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html - previously on https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\nfloat bezier( vec2 uv, vec2 A, vec2 B, vec2 C, vec2 D)    \n{\n    //float d = 1e5;                               // for global field\n    vec2 p = A;\n    for (float t = 1.; t <= N; t++) {\n        vec2 q = interpolate(A, B, C, D, t/N);\n        float l = line(uv, p, q);\n        d = min(d, l );\n\t\tp = q;\n\t}\n\treturn d;\n}\n\nvoid draw(float d, inout vec4 O) \n{\n    // distance field...\n    if (S>0.0)\n    {\n        d = sqrt(d);\n        d+=1.0;\n        d*=0.01;\n        O = vec4(0.5+(d*S));\n        return;\n    }\n}\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n    vec2 R = iResolution.xy;\n    \n    if (iFrame>0)\n    if ( texture(iChannel0,.5/R).xy == R )     // init or rescale\n    {   // init or rescale\n        O = texture(iChannel0, U/R);\n        return;\n    }\n    if (U==vec2(.5)) { O = vec4(R,1.0,1.0); return; }\n\n    O = vec4(0);\n    U = ( U -.5*iResolution.xy ) / iResolution.y;\n\tSVG( U, O );\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGGDz.jpg", "access": "api", "license": "mit", "functions": [[1494, 1494, 1519, 1519, 1538], [1540, 1540, 1576, 1576, 1675], [1746, 1746, 1779, 1779, 1805], [1807, 1807, 1837, 1837, 1870], [1872, 1872, 1902, 1902, 1931], [1934, 2031, 2104, 2104, 2390], [2393, 2506, 2556, 2556, 2948], [2951, 3011, 3042, 3042, 3148], [3149, 3149, 3180, 3180, 3287], [3288, 3288, 3319, 3319, 3425], [3603, 3603, 3639, 3639, 3819], [3823, 3844, 3869, 3869, 4572], [4574, 4574, 4614, 4614, 4945], [4948, 4948, 5022, 5022, 5282], [5284, 5284, 5316, 5316, 5524], [5526, 5526, 5568, 5568, 5867], [5869, 5869, 5908, 5908, 7512], [7514, 7514, 7566, 7566, 7742]], "test": "untested"}
{"id": "WlVGzR", "name": "GrassTest", "author": "EvilRyu", "description": "Grass test, fullscreen doesn't look good.", "tags": ["noise", "fbm", "grass", "terrian"], "likes": 51, "viewed": 2183, "published": 3, "date": "1578739306", "time_retrieved": "2024-07-30T21:30:39.046209", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Based on kuvkar's Windyplains: https://www.shadertoy.com/view/ltXXRM\n\n#define GRASS_ENV 0.2\n#define FREQ 340.\n#define PI 3.1415926535\n\nfloat hash11(float p)\n{\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337)*0.5+0.5;\n}\n\nvec3 hash33(float n) { return fract(sin(vec3(n,n+7.3,n+13.7))*1313.54531); }\nvec3 noise(float x)\n{\n    float p=floor(x);\n    float f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    return mix(hash33(p+0.0), hash33(p+1.0), f);\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p=floor(x);\n    vec2 f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float n=p.x + p.y*57.0;\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\n}\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    f+=.5*noise(p); p=p*2.01;\n    f+=.25*noise(p); p=p*2.1;\n    f+=.125*noise(p); p=p*2.03;\n    return f;\n}\n\nfloat terrain(vec2 p) \n{\n    float w=0.;\n    float s=1.;\n    p.x*=20.;\n    w+=sin(p.x*.3521)*4.;\n    for (int i=0; i<5; i++) \n    {\n        p.x*=1.53562;\n        p.x+=7.56248;\n        w+=sin(p.x)*s;      \n        s*=.5;\n    }\n    w=w*.5+.5;\n    return smoothstep(0.,0.05,p.y-w*.01-0.02);\n}\n\nvec3 renderTerrian(vec3 ro, vec3 rd, vec3 col)\n{\n    col=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.-terrain(rd.xy));\n\t\n    return col;\n}\n\nfloat mapTerrian(vec3 p)\n{\n    vec2 q=p.xz*1.1-vec2(2.3,0.);\n    float f=0.0;\n    f+=.56*noise(q); q=q*2.01;\n    f+=.25*noise(q); q=q*2.1;\n    //f+=.125*noise(q); q=q*2.03;\n    return f-0.3;\n}\n\nfloat traceTerrian(vec3 ro, vec3 rd)\n{\n    float t=0.01,d,h;\n    float tPrev=t;\n    vec3 p;\n    float grassMint=100.;\n    for(int i=0;i<200;++i)\n    {\n        p=ro+t*rd;\n        h=mapTerrian(p);    \n        d=p.y-h;\n        \n        if(p.y-h-GRASS_ENV < 0.001 && grassMint>99.)\n        {\n\t\t\tgrassMint=tPrev;   \n            break;\n        }\n       \n        if(t>=100.0) { break;}\n        \n        tPrev=t;\n        t+=d;\n    }\n \n    return grassMint;\n}\n\nfloat blades[8];\n    \nvoid rotate(float v)\n{\n    blades[7]=blades[6]; blades[6]=blades[5]; blades[5]=blades[4];\n    blades[4]=blades[3]; blades[3]=blades[2]; blades[2]=blades[1];\n    blades[1]=blades[0]; blades[0]=v;\n}\n\nbool useAA=false;\nfloat oldD=0.;\n\nfloat shear(vec3 p, float t)\n{\n    return sin(t+p.x*3.+p.z*(2.))*.3*(p.y)*(1.-smoothstep(-1.5, 2., p.z));\n}\n\nfloat grassNoise(vec2 p)\n{\n    vec2 l=floor(p);\n    vec2 f=fract(p);\n    f=f*f*(3.-2.*f);\n    float n=l.x+l.y*57.;\n    float d=mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\n    return d;\n}\n\nfloat mapGrass(vec3 p)\n{\n    vec3 q=p;\n    // Shear\n    p.xy=vec2(p.x+shear(p,0.)+.02*shear(p,iTime*2.), p.y);\n    float d=grassNoise(p.xz*FREQ);\n    d*=mix(1.,grassNoise(p.xz*30.),0.6);\n    \n    #if 1\n    if(useAA)\n    {\n        rotate(d);\n        d = (blades[0]+blades[1]+blades[2]+blades[3]\n            +blades[4]+blades[5]+blades[6]+blades[7])*0.125;\n    }\n    #else\n    if(useAA&&oldD>0.)\n    {\n        d=(oldD+d)*.5;\n    }\n    oldD=d;\n    #endif\n    \n    d*=GRASS_ENV;\n    return d;\n}\n\nfloat occlusion(vec3 p)\n{\n    // 1 cell backwards\n \tfloat w=1./FREQ;\n    // check the difference of height\n    float d=p.y-mapGrass(p-vec3(0,0,w))-mapTerrian(p);\n    // normalize\n    return clamp(d/GRASS_ENV, 0.0, 1.0);\n}\n\nfloat bisect(vec3 ro, vec3 rd, float near, float far)\n{\n    float mid=0.;\n    vec3 p=ro+near*rd;\n    float sgn=sign(p.y-mapGrass(p)-mapTerrian(p));\n    for (int i=0; i<6; i++)\n    { \n        mid=(near+far)*.5;\n        p=ro+mid*rd;\n        float d=p.y-mapGrass(p)-mapTerrian(p);\n        if(abs(d)<0.001)break;\n        d*sgn<0. ? far=mid : near=mid;\n    }\n    return (near+far)*.5;\n}\n\nvec4 renderGrass(vec3 ro, vec3 rd, float mint)\n{\n\tfloat t=mint;//((ro.y-GRASS_ENV)/abs(rd.y));\n\n    vec3 p=ro+t*rd;\n    float d=p.y-mapGrass(p)-mapTerrian(p);\n\tfloat sgn=sign(d);\n    float told=0.;\n\tbool doBisect=false;\n\n    useAA=true;\n    \n    for(int i=0;i<500;++i)\n    {\n        d=p.y-mapGrass(p)-mapTerrian(p);\n        if (sign(d)!=sgn)\n        {\n            doBisect=true;\n            break;\n        }\n        \n        if(d<0.003||t>=50.0)\n        {\n            break;\n        }\n        \n        told=t;\n        \n\t    d=max(1e-4, 0.04*d*exp(t*.2));\n        p+=d*rd;\n        t+=d;\n    }\n    if (doBisect)t=bisect(ro,rd,told,t);\n    \n    useAA=false;\n    vec3 col=vec3(0.1,0.5,1.)*3.5;\n    col=renderTerrian(ro,rd,col);\n\n    if(t<50.)\n    {\n        vec3 ld0=normalize(vec3(5., 5.0, 0.));\n        col=vec3(0.1,0.2,0.05)*10.;\n        col=mix(col,vec3(0.12,0.1,0.05)*10.,fbm(p.xz*2.));       \n        col*=smoothstep(GRASS_ENV*0.45,GRASS_ENV*2.,p.y-mapTerrian(p));\n        col*=pow(smoothstep(0.,1.,fbm(p.xz)),2.);\n \n        col*=.7*smoothstep(0.3,0.5,p.y)+.3;\n \n        col*=.8*occlusion(p)+.2;\n        \n        col*=20.;\n    \tcol=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.0-exp(-0.01*t*t));\n    }\n    \n    return vec4(col,t);\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 firecolor(float f)\n{\n\tf=f*f*(3.-2.*f);\n    return min(vec3(f+.8, f*f*1.4+.1, f*f*f*.7)*f, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\tif(abs(p.y)-0.85>0.) { fragColor.xyz=vec3(0); return; }\n    \n    vec3 lookat=vec3(0.0, 0., 0.0);\n\tvec3 ro=vec3(0., .8,-2.5);\n    ro.xy+=vec2(0.04,0.01)*noise(iTime*0.5).xy;\n    \n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 1.6*forward);\n    \n    vec3 col=vec3(0.1,0.5,1.)*0.1;\n\t\n    float grassMint=traceTerrian(ro,rd);\n\tvec4 res=renderGrass(ro,rd,grassMint);\n    col=res.xyz;\n    col+=firecolor(0.5)*pow(clamp(dot(normalize(vec3(.0, 1., 2.)),rd), 0.0, 1.0),10.);\n    col=tonemap(col);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\n    //col=pow(col,vec3(0.85,0.9,1.));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVGzR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[247, 247, 270, 270, 426], [428, 428, 450, 450, 504], [505, 505, 526, 526, 644], [646, 646, 667, 667, 877], [879, 879, 898, 898, 1023], [1025, 1025, 1049, 1049, 1314], [1316, 1316, 1364, 1364, 1444], [1446, 1446, 1472, 1472, 1638], [1640, 1640, 1678, 1678, 2090], [2114, 2114, 2136, 2136, 2310], [2346, 2346, 2376, 2376, 2453], [2455, 2455, 2481, 2481, 2685], [2687, 2687, 2711, 2711, 3177], [3179, 3179, 3204, 3228, 3400], [3402, 3402, 3457, 3457, 3783], [3785, 3785, 3833, 3833, 5007], [5009, 5009, 5032, 5032, 5128], [5130, 5130, 5155, 5155, 5231], [5233, 5233, 5290, 5290, 6241]], "test": "untested"}
{"id": "wlVGDR", "name": "The Path to Keyboard", "author": "Plento", "description": "Experimenting with a few things. ", "tags": ["3d", "raymarch", "piano"], "likes": 24, "viewed": 633, "published": 3, "date": "1578710055", "time_retrieved": "2024-07-30T21:30:39.805179", "image_code": "// Plento\nvec2 R;\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sdRbox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - .05;\n}\n\nfloat minDist = 999.;\nfloat mat = -1.;\n\nvoid cd(float tDist, float m, out float tmat){\n\tif(tDist <minDist){\n\t\tminDist = tDist;\n\t\tmat = m;\n\t\ttmat = m;\n\t}\n}\n\nvec2 map(vec3 rp){\n    float d = 999.;\n    float hmat = -1.;\n    \n    rp.xy *= rot(rp.z*.15);\n    rp.xz *= rot(rp.z*.17);\n    \n    rp.z += iTime;\n    \n    vec3 b = vec3(0., 0., .7);\n    vec3 rpr = mod(rp, b)-b*.5;\n   \n    d = min(d, sdRbox(rpr, vec3(1.25, .15, .3)));\n    cd(d, .0, hmat);\n    \n    rpr = mod(rp-vec3(.6, 0.07, .35), b)-b*0.5;\n    \n    if( ((int(round(rp.z/.7))%7)&3)!=0 )// Iq's fix\n    \td = min(d, sdRbox(rpr, vec3(.65, .2, .05)));\n    \n    cd(d, 1., hmat);\n    \n    rpr = mod(rp-vec3(1.9, 0., .0), b)-b*.5;\n    \n    return vec2(d, hmat);\n}\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy).x + \n        e.yyx * map(pos + e.yyx).x + \n        e.yxy * map(pos + e.yxy).x + \n        e.xxx * map(pos + e.xxx).x);\n}\n\nvec2 march(vec3 rd, vec3 ro){\n \tfloat t = 0.;   \n    vec2 d = vec2(0);\n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \t   \n        if(abs(d.x) < .002 || t > 90.){\n            break;\n        }\n        t += d.x * .75;\n    }   \n    return vec2(t, d.y);\n}\n\nvec3 color(vec3 p, vec3 rd, vec3 n, vec2 u, float t, float m){\n    vec3 lp = vec3(0., 14., -5.);\n    vec3 ld = normalize(lp-p);\n    vec3 ref = reflect( rd, n );\n    \n    float lgd = length(lp - p);\n    float faloff = 1.-exp(-(4. / lgd));\n    \n    float fres = smoothstep(-.5, .5, dot(rd, n));\n    float spec = pow(max(dot(normalize(reflect(ld, n)), rd), 0.), 12.);\n    float dom = smoothstep(-.2, .2, ref.y);\n    float dif = max(dot(n, ld), .0);\n    \n    vec3 col = vec3(0);\n    \n    if(m == 0.)col = vec3(.9);\n    if(m == 1.)col = vec3(.03);   \n    \n    vec3 lig = vec3(0);\n    \n    lig += .4*fres*vec3(1);\n    lig += .25*dom*vec3(.2,.4,1.)*dom;\n    lig += 2.*dif*vec3(1., 1., 1.) * faloff;\n    col *= lig;\n    col += vec3(.75, .8, .8) * spec * .45;\n    \n    col *= smoothstep(.21, 0., t/100.);\n    \n\treturn col;   \n}\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - .5*R.xy)/R.y;\n    vec2 m = iMouse.xy / R.xy-.5; \n    m.x *= R.x/R.y;\n    \n    vec3 rd = normalize(vec3(uv, .6));\n    rd = normalize(vec3(uv, 1. - dot(uv, uv) * .5));\n    vec3 ro = vec3(-2.6, .65, -.55);\n    \n    rd.xz*= rot(-1.45);\n    rd.yz *= rot(.6);\n    \n    vec2 t = march(rd, ro);\n    \n    vec3 n = normal(ro + rd*t.x);\n    vec3 col = color(ro + rd*t.x, rd, n, u, t.x, t.y);\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 38, 38, 90], [92, 92, 123, 123, 216], [258, 258, 304, 304, 372], [933, 933, 960, 960, 1169], [1171, 1171, 1200, 1200, 1438], [1440, 1440, 1502, 1502, 2258], [2259, 2259, 2299, 2299, 2781]], "test": "untested"}
{"id": "wtVGDR", "name": "4D Sun", "author": "Klems", "description": "Rotating/translating 4D grid with motion blur and analytical fog.", "tags": ["3d", "raymarch", "sun", "space", "4d"], "likes": 90, "viewed": 6175, "published": 3, "date": "1578702042", "time_retrieved": "2024-07-30T21:30:40.562156", "image_code": "\n#define PI 3.14159265359\n#define PHI 1.61803398875\n\n#define SAMPLES 5\n#define BLOOM_RADIUS 30.0\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit( in vec3 v ) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted( in vec3 color ) {\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n    return color;\n}\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 bloom = vec3(0);\n    float totfac = 0.0;\n    \n    vec3 rnd = hash33(vec3(fragCoord, iFrame));\n    float offset = rnd.x*2.0*PI;\n    \n    // bloom\n    for (int i = 0 ; i < SAMPLES ; i++) {\n        float theta = 2.0*PI*PHI*float(i) + offset;\n        float radius = sqrt(float(i)) / sqrt(float(SAMPLES));\n        radius *= BLOOM_RADIUS;\n        vec2 offset = vec2(cos(theta), sin(theta))*radius;\n        vec2 delta = vec2( 1.0+exp(-abs(offset.y)*0.1) , 0.5);\n        offset *= delta;\n        vec4 here = textureGrad(iChannel0,(fragCoord+offset)/iResolution.xy, \n                                vec2(0.001, 0)*BLOOM_RADIUS, vec2(0, 0.001)*BLOOM_RADIUS);\n        float fact = smoothstep(BLOOM_RADIUS, 0.0, radius);\n        bloom += here.rgb*0.05*fact;\n        totfac += fact;\n    }\n    \n    bloom /= totfac;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mo = uv*2.0-1.0;\n    mo *= 0.01;\n    fragColor.r = textureLod(iChannel0, uv-mo*0.1, 0.0).r;\n    fragColor.g = textureLod(iChannel0, uv-mo*0.6, 0.0).g;\n    fragColor.b = textureLod(iChannel0, uv-mo*1.0, 0.0).b;\n    \n    fragColor.rgb += bloom*bloom*100.0;\n    vec2 vi = fragCoord / iResolution.xy * 2.0 - 1.0;\n    fragColor.rgb *= (1.0-sqrt(dot(vi,vi)*0.45));\n    fragColor.rgb = ACESFitted(fragColor.rgb);\n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n    fragColor.rgb += (rnd-0.5)*0.1;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n\n#define SAMPLES 4\n\nconst float motionBlurAmount = 5.0;\nconst float nearZ = 2.0;\n\n//#define warm\n//#define complex\n\n#ifdef warm\nconst vec3 sunCol = vec3(0.9, 0.55, 0.1)*9.0;\nconst vec3 subCol = vec3(0.5, 0.8, 0.9)*0.5;\nconst float sunRadius = 2.0;\nconst float sunExponent = -40.0;\nconst float timeScale = 3.0;\n#else\nconst vec3 sunCol = vec3(0.6, 0.2, 0.85)*9.0;\nconst vec3 subCol = vec3(0.5, 0.8, 0.9)*0.5;\nconst float sunRadius = 1.5;\nconst float sunExponent = -30.0;\nconst float timeScale = 2.0;\n#endif\n\nfloat time;\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash( in vec3 center ) {\n    return center + (hash33(center)-0.5) * 0.5;\n}\n\nfloat B2( vec2 _P ) {\n    return mod( 2.0*_P.y + _P.x + 1.0, 4.0 );\n}\n\nfloat B8( vec2 _P ) {\n    vec2\tP1 = mod( _P, 2.0 );\t\t\t\t\t// (P >> 0) & 1\n    vec2\tP2 = floor( 0.5 * mod( _P, 4.0 ) );\t\t// (P >> 1) & 1\n    vec2\tP4 = floor( 0.25 * mod( _P, 8.0 ) );\t// (P >> 2) & 1\n    return 4.0*(4.0*B2(P1) + B2(P2)) + B2(P4);\n}\n\nvec3 voronoi( in vec3 uv, in vec3 no, inout float rough ) {\n    \n    vec3 center = floor(uv) + 0.5;\n    vec3 bestCenterOffset = vec3(0);\n    float bestDist = 9e9;\n    vec3 bestCenterOffset2 = vec3(0);\n    float bestDist2 = 9e9;\n    \n    for (float x = -0.5 ; x < 1.0 ; x+=1.0)\n    for (float y = -0.5 ; y < 1.0 ; y+=1.0)\n    for (float z = -0.5 ; z < 1.0 ; z+=1.0) {\n\t\tvec3 offset = vec3(x, y, z);\n        vec3 newCenter = center + offset;\n        vec3 newCenterOffset = hash(newCenter);\n        vec3 temp = newCenterOffset - uv;\n        float distSq = dot(temp, temp);\n        if (distSq < bestDist) {\n    \t\tbestCenterOffset2 = bestCenterOffset;\n    \t\tbestDist2 = bestDist;\n            bestCenterOffset = newCenterOffset;\n            bestDist = distSq;\n        } else if (distSq < bestDist2) {\n            bestCenterOffset2 = newCenterOffset;\n            bestDist2 = distSq;\n        }\n    }\n    \n    vec3 n1 = normalize(no + hash33(bestCenterOffset)-0.5);\n    vec3 n2 = normalize(no + hash33(bestCenterOffset2)-0.5);\n    float d = (sqrt(bestDist)-sqrt(bestDist2));\n    float aad = 0.02;\n    return mix(n1, n2, smoothstep(-aad, +aad, d*2.0));\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat cross4D(vec4 p) {\n    float aa = length(p.xy)-0.1;\n    float bb = length(p.zw)-0.02;\n    float cc = length(p.yw)-0.03;\n    float de = smin(smin(aa, bb, 0.1), cc, 0.1)-0.03;\n    return de;\n}\n\nfloat de4d(vec4 p) {\n    p.zw *= rot(time*0.148);\n    p.xz *= rot(time*0.241);\n    p.wy *= rot(time*0.187);\n    p.x += time*3.687;\n   \tp.y -= time*0.37454;\n    vec4 inG = (fract(p) - 0.5);\n    return cross4D(inG);\n}\n\nfloat de(vec3 p) {\n    #ifdef complex\n    float d = dot(p, p);\n    d = de4d(vec4(p/d, d))*d;\n    #else\n    vec4 pp = vec4(p, length(p));\n    float d = dot(pp, pp);\n    d = de4d(pp/d)*d;\n    #endif\n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n\tvec3 e = vec3(0.0, 0.001, 0.0);\n\treturn normalize(vec3(\n\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\tde(p+e.xxy)-de(p-e.xxy)));\t\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n    float num = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 computeLighting(in vec3 normal, in vec3 viewDir,\n                     in vec3 albedo, in float metallic, in float roughness,\n                     in vec3 lightDir, in vec3 radiance) {\n    vec3 result = vec3(0);\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, albedo, metallic);\n    float NDF = DistributionGGX(normal, halfwayDir, roughness);\n    float G = GeometrySmith(normal, viewDir, lightDir, roughness);\n    vec3 F = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n    vec3 numerator = NDF * G * F;\n    float denominator = 4.0 * max(dot(normal, viewDir), 0.0) * max(dot(normal, lightDir), 0.0);\n    vec3 specular = numerator / max(denominator, 0.001);\n    float NdotL = max(dot(normal, lightDir), 0.0);\n    result += (kD * albedo / PI + specular) * radiance * NdotL;\n    return result;\n}\n\n// fake subsurface scattering\nvec3 computeSSS(in vec3 normal, in vec3 viewDir, \n                in vec3 albedo, in float trans, in float index,\n                in vec3 lightDir, in vec3 radiance) {\n    float add = 1.0 - index;\n    add *= add;\n    add *= add;\n    add *= add;\n    add *= add;\n    float fr = dot(viewDir, normal)*0.5+0.5;\n    float lu = dot(viewDir, lightDir)*-0.5+0.5;\n    add *= fr*fr;\n    add *= lu;\n    return radiance*add*1.0*trans*albedo;\n}\n\n// approximation of the error function\nfloat erf( in float x ) {\n    //return tanh(1.202760580 * x);\n\tfloat sign_x = sign(x);\n\tfloat t = 1.0/(1.0 + 0.47047*abs(x));\n\tfloat result = 1.0 - t*(0.3480242 + t*(-0.0958798 + t*0.7478556))*exp(-(x*x));\n\treturn result * sign_x;\n}\n\nfloat getIntegral(vec3 start, vec3 dir, float dist) {\n    const float a = sunExponent;\n\tconst float b = sunRadius;\n    float k = start.x;\n    float l = dir.x;\n    float m = start.y;\n    float n = dir.y;\n    float o = start.z;\n    float p = dir.z;\n    float res = sqrt(PI);\n    res *= exp(b+a*(+k*k*(n*n+p*p)\n                    -m*m*(-1.0+n*n)\n                    -o*o*(-1.0+p*p)\n                    -2.0*k*l*o*p\n                    -2.0*m*n*(k*l+o*p) ));\n    res *= - erf(sqrt(-a)*dot(start, dir)) + erf(sqrt(-a)*(dot(start, dir)+dist));\n    res /= 2.0 * sqrt(-a);\n    res *= 500.0;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 acc = vec3(0);\n    \n    for (int i = min(0, iFrame) ; i < SAMPLES ; i++) {\n    \t\n        float bay = B8(floor(fragCoord))/64.0;\n        \n        #if SAMPLES > 1\n        vec3 rnd = hash33(vec3(fragCoord, iFrame*SAMPLES+i));\n        bay = rnd.z;\n        #endif\n        \n        time = (iTime + (1.0/120.0)*bay*motionBlurAmount)*timeScale;\n\n        vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\t\t#if SAMPLES > 1\n        uv += (rnd.xy-0.5) / iResolution.y;\n        #endif\n        \n        vec3 from = vec3(0, 0, -1.4);\n        vec3 dir = normalize(vec3(uv*0.5, 1.0));\n        \n        mat2 rotxz = rot(time*0.3);\n\t\tmat2 rotxy = rot(sin(time*0.1));\n        if (iMouse.z > 0.5) {\n            vec2 delt = iMouse.xy-iMouse.zw;\n            rotxz *= rot(-delt.x*0.01);\n            rotxy *= rot(delt.y*0.01);\n        }\n        \n        from.zy *= rotxy;\n        from.xz *= rotxz;\n        dir.zy  *= rotxy;\n        dir.xz  *= rotxz;\n\n        float totdist = 0.0;\n        totdist += (0.1+pow(bay, 0.2)*0.4)*nearZ;\n        totdist += de(from+dir*totdist)*bay;\n\n        float ao = 0.0;\n        for (int steps = min(0, iFrame) ; steps < 150 ; steps++) {\n            vec3 p = from + totdist * dir;\n            float dist = de(p);\n            totdist += dist*(0.65+bay*0.1);\n            if (dist < 0.0001 || length(p) > 1.4) {\n                ao = float(steps)/149.0;\n                break;\n            }\n        }\n\n        vec3 result = vec3(0);\n        vec3 p = from + totdist * dir;\n\n        if (length(p) < 1.4) {\n\n            vec3 n = -getNormal(p);\n\n            vec3 sunDir = normalize(p);\n            const vec3 subDir = normalize(vec3(2, -7, 3));\n\n            float rough = 0.0;\n            vec3 vor = voronoi(p*600.0, n, rough);\n            n = normalize(n+vor*0.5);\n\n            vec4 albedo = vec4(0.98, 0.8, 0.5, 0.4);\n\n            result += computeLighting(n, dir, albedo.rgb, 0.9, albedo.a, sunDir, sunCol);\n            result += computeLighting(n, dir, albedo.rgb, 0.9, albedo.a, subDir, subCol);\n            result += computeSSS(n, dir, albedo.rgb, albedo.a, ao, sunDir, sunCol);\n            result += computeSSS(n, dir, albedo.rgb, albedo.a, ao, subDir, subCol);\n\n        } else {\n\n            // background\n            float rough = 0.0;\n            vec3 vor = voronoi(dir*800.0, vec3(0), rough);\n            result = vec3(pow(abs(vor.x), 500.0))*3.0;\n\n        }\n\n        fragColor.rgb = result;\n        float sun = getIntegral(from, dir, totdist);\n        fragColor.rgb += sun*0.005*sunCol;\n        \n        acc += fragColor.rgb;\n        \n    }\n    \n    acc /= float(SAMPLES);\n    fragColor.rgb = clamp(acc, vec3(0), vec3(10));\n    \n\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVGDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 364, 396, 396, 520], [522, 522, 556, 556, 714], [716, 716, 738, 738, 862], [864, 864, 921, 921, 2297]], "test": "untested"}
{"id": "WtK3DR", "name": "Gabor/Phasor distance field", "author": "FabriceNeyret2", "description": "Look of phasor/Gabor noise along a distance field (here, to letters).\nUsing convolution with hash grid instead of sparse convolution with random splats.\nMouse.y tunes freq", "tags": ["noise", "perlin", "fluid", "flow", "field", "complex", "screenspace", "curlnoise", "stream", "gabornoise", "phasornoise"], "likes": 5, "viewed": 290, "published": 3, "date": "1578680223", "time_retrieved": "2024-07-30T21:30:41.311153", "image_code": "// Fork of  https://shadertoy.com/view/3tKGWR\n// ( see also https://shadertoy.com/view/wtt3RH )\n\n// --- Gabor params & utils\n\nfloat F = 1.8;                     // frequency\n#define W 12.                      // filtering neighborhood\n#define N int(W*2.+0.)             // sampling = NxN   ( N=2W+1 but smaller may work )\n#define PI 3.14159\n#define TG 1.*iTime                // try 1\n#define CS(a)       vec2( cos(a+TG), sin(a+TG) )\n#define hash2(p)    fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )  // by deMoivre formula\n\n// draw line segment\n#define L(a,b) O+= .3/R.y/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a )\n\n// === Gabor noise =============\n\nvec2 Gabor(vec2 U, vec2 V) {\n    vec2 P, v, s = vec2(0);\n    float T=0., K;    \n    for( int k = 0; k < N*N; k++) {            // Gabor noise: convolve with noise with K*oscill\n        P = vec2( k%N, k/N ) -  W;             // sample neighborhood ( W = float(N-1)/2. )\n        v = CS( 2.*PI* hash2( U+P ));          // random complex signal\n        v = cmul( v, CS(-F*dot(P,V)));         // mul by oscillator in main direction\n        K = .5+.5*cos(PI*min(1.,length(P)/W)); // smoothing kernel\n        s += v * K;\n        T += K;\n    }\n    return s / T; \n}\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug with an old driver\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\n// ========================================================\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 1.2*u/R.y;\n    O -= O;\n    float ofs = .5,\n           n0 = char(U,65).w, //vec2 V = vec2(-dFdy(n),dFdx(n));\n           n1 = char(U-vec2(ofs,0),67).w,\n           n2 = char(U-ofs*vec2(2,0),69).w;\n#define dist(n) max(0.,  1.-(n-.5)/.3 )  \n    n0 = dist(n0), n1 = dist(n1), n2 = dist(n2); \n    vec2 V0 = char(U,65).zy - .5, \n         V1 = char(U-vec2(ofs,0),67).zy - .5,\n         V2 = char(U-ofs*vec2(2,0),69).zy - .5,\n         V;\n  //V = mix(V0,V1,smoothstep(0.,1.,n0/(n0+n1)));\n    V = (n0*V0+n1*V1+n2*V2)/(n0+n1+n2);\n  //V = n0<n1 ? V0 : V1;\n  //V = V0;\n  //V.x+=1.;\n    \n#if 0                                   // --- draw flow ( debug )\n  //O += pow(.5+.5*sin(100.*n),1./2.2); return;\n    float S = R.y/10.;\n    vec2 p = floor(U*S+.5)/S, v;               // draw velocity vectors\n    L ( p-V*2., p+V*2.);  //O.rb = u-u;  \n    return;\n#endif\n \n    vec2 M = iMouse.xy;                 // --- draw Gabor/Phasor noise\n    if (length(M)>10.) F = .2+M.y/R.y*1.8; \n    V = normalize(V);  // direction only\n  //V *= R.y;          // variant: varying length\n#if 1\n    V = vec2(-V.y,V.x); // normal field\n    vec2 s = Gabor(u -.5*R, V );\n    float T = \n         //   4.*length(s);                    // show contrast oscillations\n              .5+.5*normalize(s).x;            // phasor profile\n  T = pow( T, 1./2.2);                       // to sRGB\n    O += T;\n#else                                          // local grid\n    O.r = .5+.5*normalize(Gabor(u -.5*R, V )).x;\n    V = vec2(-V.y,V.x); \n    O.g = .5+.5*normalize(Gabor(u -.5*R, V )).x;\n#endif\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3DR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[731, 731, 759, 759, 1287], [1288, 1288, 1314, 1314, 1651], [1713, 1713, 1751, 1751, 3340]], "test": "untested"}
{"id": "WlKGDR", "name": "glass hourglass apollonean", "author": "ollj", "description": "mouse sets somewhat intuitive and hourglass shaped modifiers.\n\nhttps://www.shadertoy.com/view/4slSzj      glass shader\n+\nhttps://www.shadertoy.com/view/XtVfRW      vesica\n\nalso begs for lathe logic of:\nhttps://www.shadertoy.com/view/MlyfRW", "tags": ["glass", "bone", "vesica", "vesica", "lathe", "linb", "appolonean"], "likes": 2, "viewed": 482, "published": 3, "date": "1578675291", "time_retrieved": "2024-07-30T21:30:42.094060", "image_code": "// Forked from: https://www.shadertoy.com/view/ldfXzn\n\n#define DELTA\t\t\t\t0.001\n#define RAY_COUNT\t\t\t7\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t100\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define REFRACT_FACTOR\t\t0.6\n#define REFRACT_INDEX\t\t1.6\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n#define FADE_POWER\t\t\t1.0\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n#define GLOW_FACTOR\t\t\t1.5\n#define LUMINOSITY_FACTOR\t2.0\n\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz*ry*rx;\n}\n\nvec3 k;\n\nfloat sdVesica(vec2 p, float r, float d\n){p = abs(p)\n ;float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n ;return ((p.y-b)*d > p.x*b) ? length(p-vec2(0.0,b))*sign(d)\n                             : length(p-vec2(-d,0.0))-r;}\n\nfloat getDistance(vec3 p\n){//float a=min(length(p-vec3(0,0,3.5)),length(p))-2.\n ;//float a=sdVesica(vec2(p.y,length(p.xz)),2.,-1.)+1.6\n ;vec2 m=iMouse.xy/iResolution.xy  \n ;//float a=sdVesica(vec2(p.y,length(p.xz)),1.9+m.x,-1.-m.y)+1.5+m.x-m.y\n ;float a=sdVesica(vec2(p.y,length(p.xz)),1.9+m.y*.25+m.x,-1.-m.y)+1.5+m.y*.3-m.y \n ;a=abs(a+.05)\n ;return (a-.05)\n ;}\n\nvec3 getFragmentColor (in vec3 origin, in vec3 direction) {\n\tvec3 lightDirection = normalize (LIGHT);\n\tvec2 delta = vec2 (DELTA, 0.0);\n\n\tvec3 fragColor = vec3 (0.0, 0.0, 0.0);\n\tfloat intensity = 1.0;\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n\n\t\t// Ray marching\n\t\tfloat dist = RAY_LENGTH_MAX;\n\t\tfloat rayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tdist = distanceFactor * getDistance (origin);\n\t\t\tfloat distMin = max (dist, DELTA);\n\t\t\trayLength += distMin;\n\t\t\tif (dist < 0.0 || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * distMin;\n\t\t\t++rayStepCount;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tvec3 backColor = vec3 (0.0, 0.0, 0.1 + 0.2 * max (0.0, dot (-direction, lightDirection)));\n\t\tif (dist >= 0.0) {\n\t\t\tfragColor = fragColor * (1.0 - intensity) + backColor * intensity;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tvec3 normal = normalize (distanceFactor * vec3 (\n\t\t\tgetDistance (origin + delta.xyy) - getDistance (origin - delta.xyy),\n\t\t\tgetDistance (origin + delta.yxy) - getDistance (origin - delta.yxy),\n\t\t\tgetDistance (origin + delta.yyx) - getDistance (origin - delta.yyx)));\n\n\t\t// Basic lighting\n\t\tvec3 reflection = reflect (direction, normal);\n\t\tif (distanceFactor > 0.0) {\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\n\n\t\t\tvec3 localColor = max (sin (k * k), 0.2);\n\t\t\tlocalColor = (AMBIENT + relfectionDiffuse) * localColor + relfectionSpecular;\n\t\t\tlocalColor = mix (backColor, localColor, fade);\n\n\t\t\tfragColor = fragColor * (1.0 - intensity) + localColor * intensity;\n\t\t\tintensity *= REFRACT_FACTOR;\n\t\t}\n\n\t\t// Next ray...\n\t\tvec3 refraction = refract (direction, normal, refractionRatio);\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflection;\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t}\n\t\telse {\n\t\t\tdirection = refraction;\n\t\t\tdistanceFactor = -distanceFactor;\n\t\t\trefractionRatio = 1.0 / refractionRatio;\n\t\t}\n\t}\n\n\t// Return the fragment color\n\treturn fragColor * LUMINOSITY_FACTOR + GLOW_FACTOR * rayStepCount / float (RAY_STEP_MAX * RAY_COUNT);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord\n   ){\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    ;frag*=.3;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Set the fragment color\n\tfragColor = vec4 (getFragmentColor (origin, direction), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKGDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[464, 464, 494, 494, 817], [828, 828, 870, 870, 1078], [1080, 1080, 1107, 1158, 1442], [1444, 1444, 1503, 1503, 3804], [3806, 3806, 3865, 3916, 4523]], "test": "untested"}
{"id": "3tKGWR", "name": "Gabor/Phasor flow", "author": "FabriceNeyret2", "description": "Look of phasor/Gabor noise along a random divergence-free flow from Perlin noise.\nUsing convolution with hash grid instead of sparse convolution with random splats.\n( NB: time evolution is not physically correct: better change slowly )\nMouse.y tunes freq", "tags": ["noise", "perlin", "fluid", "flow", "field", "complex", "screenspace", "curlnoise", "stream", "fingerprint", "gabornoise", "phasornoise"], "likes": 30, "viewed": 1179, "published": 3, "date": "1578672840", "time_retrieved": "2024-07-30T21:30:42.844054", "image_code": "// Fork of \"flow by Perlin noise\"     https://shadertoy.com/view/Xl3Gzj\n//   and \"Moebius Spiral Gabor field\" https://shadertoy.com/view/wtt3RH\n// ( see also https://www.shadertoy.com/view/ldtSzn\n//            https://shadertoy.com/view/wtt3z8 \n//            https://shadertoy.com/view/wtcGRH )\n// see also: distance field variant https://www.shadertoy.com/view/WtK3DR\n\n// --- Gabor params & utils\n\nfloat F = 1.2;                     // frequency\n#define W 12.                      // filtering neighborhood\n#define N int(W*2.+0.)             // sampling = NxN   ( N=2W+1 but smaller may work )\n#define PI 3.14159\n#define TG 0.*iTime                // try 1\n#define CS(a)       vec2( cos(a+TG), sin(a+TG) )\n#define hash2(p)    fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )  // by deMoivre formula\n\n// --- flow params\n\n#define TF .2*iTime                // flow speed\nfloat S = 3.;                      // scaling of flow\n \n\n// --- Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\n//     (extended to 3D)\nvec3 hash( vec3 p )\n{\n\tp *= mat3( 127.1,311.7,-53.7,\n\t\t\t   269.5,183.3, 77.1,\n\t\t\t  -301.7, 27.3,215.3 );\n\n\treturn 2.*fract(sin(p)*43758.5453123) -1.;\n}\n\nfloat noise( vec3 p )\n{\n    vec3 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n \n    return 2.*mix(\n              mix( mix( dot( hash( i + vec3(0,0,0) ), f - vec3(0,0,0) ), \n                        dot( hash( i + vec3(1,0,0) ), f - vec3(1,0,0) ), u.x),\n                   mix( dot( hash( i + vec3(0,1,0) ), f - vec3(0,1,0) ), \n                        dot( hash( i + vec3(1,1,0) ), f - vec3(1,1,0) ), u.x), u.y),\n              mix( mix( dot( hash( i + vec3(0,0,1) ), f - vec3(0,0,1) ), \n                        dot( hash( i + vec3(1,0,1) ), f - vec3(1,0,1) ), u.x),\n                   mix( dot( hash( i + vec3(0,1,1) ), f - vec3(0,1,1) ), \n                        dot( hash( i + vec3(1,1,1) ), f - vec3(1,1,1) ), u.x), u.y), u.z);\n}\n\nfloat Mnoise(vec3 U ) {\n    return noise(U);                      // base turbulence\n  //return -1. + 2.* (1.-abs(noise(U)));  // flame like\n  //return -1. + 2.* (abs(noise(U)));     // cloud like\n}\n\nfloat turb( vec2 U, float t )\n{ \tfloat f = 0., q=1., s=0.;\n\t\n    float m = 2.; \n // mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for (int i=0; i<2; i++) {\n      U -= t*vec2(.6,.2);\n      f += q*Mnoise( vec3(U,t) ); \n      s += q; \n      q /= 2.; U *= m; t *= 1.71;  // because of diff, we may rather use q/=4.;\n    }\n    return f/s; \n}\n// -----------------------------------------------\n\n// draw line segment\n#define L(a,b) O+= .3/R.y/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a )\n\n// === Gabor noise =============\n\nvec2 Gabor(vec2 U, vec2 V) {\n    vec2 P, v, s = vec2(0);\n    float T=0., K;    \n    for( int k = 0; k < N*N; k++) {            // Gabor noise: convolve with noise with K*oscill\n        P = vec2( k%N, k/N ) -  W;             // sample neighborhood ( W = float(N-1)/2. )\n      //v = CS( 2.*PI* hash2( U+P ));          // random complex signal\n      //v = cmul( v, CS(-F*dot(P,V)));         // mul by oscillator in main direction\n        v = CS( 2.*PI* hash2( U+P )            // random complex signal\n                - F* dot(P,V) );               // mul by oscillator in main direction\n        K = .5+.5*cos(PI*min(1.,length(P)/W)); // smoothing kernel\n        s += v * K;\n        T += K;\n    }\n    return s / T; \n}\n\n// ========================================================\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u/R.y;\n    O -= O;\n                                        // --- generates flow\n\tfloat eps = 1e-3;\n    //U -= t*vec2(.3,.1);                      // translation (or do it per band)\n    \n    float n = turb(S*U,TF);                     // pure noise = stream\n \n                                               // flow = rot(stream) \n\tvec2  V = vec2( turb(S*U+vec2(0,-eps),TF) - turb(S*U+vec2(0,eps),TF),\n                    turb(S*U+vec2(eps,0),TF)  - turb(S*U+vec2(-eps,0),TF)\n                  )/ eps;\n    //V += vec2(3,0);                          // linearly combine other base flows\n    V /= R.y;\n    \n#if 0                                   // --- draw flow ( debug )\n  //O += pow(.5+.5*sin(100.*n),1./2.2); return;\n\tO = clamp(vec4(n,0,-n,0),0.,1.);           // draw stream value (note that curl = lapl(stream) so they are very similar)\n    S = R.y/10.;\n    vec2 p = floor(U*S+.5)/S, v;               // draw velocity vectors\n    L ( p-V*2., p+V*2.);  //O.rb = u-u;  \n    //return;\n#endif\n    O += .2*vec4(n,0,-n,0);                    // show stream ( for debug )\n \n    vec2 M = iMouse.xy;                 // --- draw Gabor/Phasor noise\n    if (length(M)>10.) F = .2+M.y/R.y*1.8; \n    V = normalize(V);  // direction only\n  //V *= R.y;          // variant: varying length\n#if 1\n    if (fract(iTime/3.8)>.5) V = vec2(-V.y,V.x); // normal field\n    vec2 s = Gabor(u -.5*R, V );\n    float T = \n         //   4.*length(s);                    // show contrast oscillations\n              .5+.5*normalize(s).x;            // phasor profile\n // T = pow( T, 1./2.2);                       // to sRGB\n    O += T;\n#else                                          // local grid\n    O.r = .5+.5*normalize(Gabor(u -.5*R, V )).x;\n    V = vec2(-V.y,V.x); \n    O.g = .5+.5*normalize(Gabor(u -.5*R, V )).x;\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[986, 1096, 1117, 1117, 1247], [1249, 1249, 1272, 1272, 2000], [2002, 2002, 2025, 2025, 2200], [2202, 2202, 2233, 2233, 2536], [2733, 2733, 2761, 2761, 3447], [3510, 3510, 3548, 3548, 5391]], "test": "untested"}
{"id": "WtV3WR", "name": "Checkerboard tunnel v2", "author": "tombla", "description": "Checkerboard tunnel with improved smoothing.", "tags": ["tunnel", "radial", "checkerboard", "polar"], "likes": 6, "viewed": 377, "published": 3, "date": "1578672448", "time_retrieved": "2024-07-30T21:30:43.615991", "image_code": "// Improved smoothing using smoothstep\n// and mixing trick from \n// https://www.shadertoy.com/view/WdBGzd\n\n#define PI2 6.28318530718\n\n#define COLOR1 vec3(1., 1., 0.6)\n#define COLOR2 vec3(0., 0.1, 0.4)\n#define LIGHTCOLOR  vec3(1., 1., 1.)\n\n#define ARMS 10.\n#define DENSITY 3.\n#define ANGLE_SPEED 1.\n#define SPEED 2.\n#define PULSE_SPEED 4.\n#define SMOOTH 0.08\n\nfloat smoothCheckerboard(in vec2 uv) {    \n    // Shift, as fract gives 0..1 and we will smooth\n    // around 0.25 and 0.75.\n    uv = fract(uv + 0.25);\n    float sm2 = SMOOTH * 0.5;\n    // p01 oscillates between 0 and 1.\n    vec2 p01 =\n        smoothstep(0.25 - sm2, 0.25 + sm2, uv) -\n        smoothstep(0.75 - sm2, 0.75 + sm2, uv);\n    // pn11 oscillates between -1 and 1.\n    vec2 pn11 = (p01 - 0.5) * 2.;\n    // This results in smoothed 0..1 transitions.\n    // We take advantage of the fact that multiplication\n    // of -1/1 behaves like XOR. Then we rescale\n    // -1..1 result of the multiplication to 0..1.\n    return 0.5 - 0.5 * pn11.x * pn11.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2\n        R = iResolution.xy,\n        // Cartesian [-1, 1] along shorter axis.\n        uv = (2. * fragCoord - R) / min(R.x, R.y);\n    float\n        T = iTime,\n        // Angle [-PI, PI] and radius.\n        a = atan(uv.x, uv.y),\n        r = length(uv);\n\n    // Rescale polar coords, as checkerboard generates 1x1 squares.\n    vec2 polar = vec2(\n        a * ARMS / PI2 + T * ANGLE_SPEED,\n        1. / r * DENSITY + T * SPEED \n    );\n\n    vec3 checker = mix(COLOR1, COLOR2, smoothCheckerboard(polar));\n    // Light in the center.\n    float light = smoothstep(0.7 + 0.3 * sin(T * PULSE_SPEED), 0.2, r);\n    vec3 color = mix(checker, LIGHTCOLOR, light);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtV3WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 359, 397, 483, 1015], [1017, 1017, 1072, 1072, 1763]], "test": "untested"}
{"id": "wtyGWz", "name": "Day 22 - Reaction Diffusion 2", "author": "jeyko", "description": "Sharpen kernel from https://www.shadertoy.com/view/MtdXW4\nThere are also some parts of @wyatt's framework left in the code.\n\npotato salad is good! ", "tags": ["diffusion", "reactiondiffusion", "reaction"], "likes": 16, "viewed": 617, "published": 3, "date": "1578663148", "time_retrieved": "2024-07-30T21:30:44.432807", "image_code": "// Sharpen kernel from https://www.shadertoy.com/view/MtdXW4\n// There are also some parts of wyatt's framework left in the code.\n\n// This is convolutional feedback (blur > sharpen feedback)\n// The only thing I have added is some uv displacement\n\n\n#define pal(x,t) (0.5 + 0.5*sin(x*vec3(0.67,0.2,0.7) + t))\n\nvoid mainImage( out vec4 C, in vec2 U )\n{ \n\t#define grad 0.25*vec2(e.z-w.z,n.z-s.z)\n    vec2 uv = (U-0.5*R)/R.y;\n    \n    vec4 CA = C * 1. - mix(0., 1., pow(length(uv)*1.1, 2.));\n    Neighbors;\n    vec4 a = A(U);\n    C = B (U);\n    vec3 no = normalize(vec3(grad,1.1));\n    vec3 re = reflect(no,vec3(0.,0,1));\n    float density = A(U).z;\n    C = sin(0.2*density+0.2*pal(density*2. + no*3. + length(uv)*5. + iTime*2.,3.4).xyzy*density);\n    \n    //C = clamp(C, 0., 1.);\n    C = pow(C, vec4(0.9,1.1,0.8,0.));\n    C = smoothstep(0.,1.,C);\n    C *= 7.5;\n    \n    \n    C = mix(C, CA*pal(iTime*10. , 20.).xyxz*C.x, CA.x);\n    //C = texture(iChannel1, U/R);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define doUVs \\\n\tvec2 uv = U;\\\n    vec2 suv = U/R;\\\n    vec2 uvM = U/iResolution.y;\\\n    uv -= 0.5*R.xy;\\\n    uv *= 0.998;\\\n    uv.xy *= rot(iTime*0.00001);\\\n    vec2 uvC = uv; \\\n    uv.xy *= rot(0.002*length(uvC)/R.x*sin(iTime*0.04 ) );\\\n    uv += 0.5*R.xy;\\\n\tuv /= R;\n\n \n#define distUVs \\\n\tuv += st*lap*-(0.4 + exp(-length(uvC/R)*20.));\\\n\tuv *= 1. - normalize(uvC)*kick*0.001;\n\t//uv += st*lap*(-0.5 +sin(iTime)*0.1)*2.;\\\n\t//uv += st*lap*(0.5 -sin(iTime)*0.05);\\\n        \n#define onMouse \\\n    if (iMouse.z > 0.) { \\\n        float md = 0.1;\\\n        float d = smoothstep(md,md*0.5,length(uvM - iMouse.xy/iResolution.y))*1.;\\\n\t\tuvM *= rot(iTime*1.); \\\n        C.yz = mix(C.yz, vec4(texture(iChannel1, uvM)).yz,d);\\\n    }\n        \n        \n\n\n#define R (iResolution.xy)\n#define A(U) texture(iChannel0,(U)/R)\t\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define iTime (iTime + 60.5)\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define tempo 174.\n#define hbeat ((60./tempo)/1.)\n#define qnote (hbeat/2.)\n#define beat  (hbeat*2.)\n#define qbeat  (beat/4.)\n#define measure  (hbeat*2.)\n\n#define kick exp(-mod(iTime, beat)*10.)*0.4\n#define halfkick exp(-mod(iTime, hbeat)*20.)\n\n#define Neighbors vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n\n#define st 1./R.xy\n#define t vec3(1.,0.,-1.)\n#define T(uv) texture(iChannel0, uv)\n#define TA(uv) texture(iChannel0, uv)\n#define TB(uv) texture(iChannel1, uv)\n#define TC(uv) texture(iChannel2, uv)\n#define TD(uv) texture(iChannel3, uv)\n\n\n\n\n#define s_n  vec2(0.0, st.y)\n#define s_ne  vec2(st.x, st.y)\n#define s_e   vec2(st.x, 0.0)\n#define s_se  vec2(st.x, -st.y)\n#define s_s   vec2(0.0, -st.y)\n#define s_sw  vec2(-st.x, -st.y)\n#define s_w   vec2(-st.x, 0.0)\n#define s_nw  vec2(-st.x, st.y)\n\n#define t_ne  T( U + s_ne).xyz\n#define t_nw  T( U + s_nw).xyz\n#define t_sw  T( U - s_sw).xyz\n#define t_se  T( U - s_se).xyz\n#define t_e  T( U + s_e).xyz\n#define t_n  T( U + s_n).xyz\n#define t_s  T( U + s_s).xyz\n#define t_w  T( U + s_w).xyz\n#define t_c  T( U ).xyz\n\n// sharpen \n\nvec4 sharpen(sampler2D channel,vec2 uv,vec2 res){\n    vec2 step = 1.0 / res;\n    float kernel [9];vec2 offset [9];\n\n\n    offset[0] = vec2(-step.x, -step.y);\n    offset[1] = vec2(0.0, -step.y);\n    offset[2] = vec2(step.x, -step.y);\n    \n    offset[3] = vec2(-step.x, 0.0);\n    offset[4] = vec2(0.0, 0.0);\n    offset[5] = vec2(step.x, 0.0);\n    \n    offset[6] = vec2(-step.x, step.y);\n    offset[7] = vec2(0.0, step.y);\n    offset[8] = vec2(step.x, step.y);\n    \n    kernel[0] = 0.0; kernel[1] = -0.25; kernel[2] = 0.0;\n    kernel[3] = -0.25; kernel[4] = 1.0; kernel[5] = -0.25;\n    kernel[6] = 0.0; kernel[7] = -0.25; kernel[8] = 0.0;\n    \n    vec4 sum = texture(channel, uv);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 color = texture(channel, uv + offset[i]);\n        sum += color * kernel[i]*2.;\n    }\n    return sum;\n}\n\nvec4 blur(sampler2D channel,vec2 uv,vec2 res){\n    vec2 step = 1.0 / res;\n    float kernel [9];vec2 offset [9];\n\n\n    offset[0] = vec2(-step.x, -step.y);\n    offset[1] = vec2(0.0, -step.y);\n    offset[2] = vec2(step.x, -step.y);\n    \n    offset[3] = vec2(-step.x, 0.0);\n    offset[4] = vec2(0.0, 0.0);\n    offset[5] = vec2(step.x, 0.0);\n    \n    offset[6] = vec2(-step.x, step.y);\n    offset[7] = vec2(0.0, step.y);\n    offset[8] = vec2(step.x, step.y);\n    \n    kernel[0] = 1.0; kernel[1] = 1.; kernel[2] = 1.0;\n    kernel[3] = 1.; kernel[4] = 1.0; kernel[5] = 1.;\n    kernel[6] = 1.0; kernel[7] = 1.; kernel[8] = 1.0;\n    \n    vec4 sum = vec4(0);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 color = texture(channel, uv + offset[i]);\n        sum += color * kernel[i];\n    }\n    sum /= 9.;\n\t\n    return sum;\n}", "buffer_a_code": "void mainImage( out vec4 C, in vec2 U )\n{\n    doUVs;\n        \n    #define div 0.25*(n.y-s.y+e.x-w.x)\n    vec2 lap =  vec2(length(T(uv + t.xy*st).xyz) - length(T(uv - t.xy*st).xyz), length(T(uv + t.yx*st).xyz) - length(T(uv - t.yx*st).xyz) );\n    \n    distUVs;\n    C = TA(uv);\n    C = blur(iChannel0, uv, R);\n    \n    C.x -= dot(vec2(A(uv).xz), vec2(1.,-1.))*2.2 * exp(0.1*length(uvC/R.x) - 3.5);\n    onMouse;\n    if (iFrame <3) C = abs(sin(U.xyxy*2.2));\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 C, in vec2 U )\n{\n    #define div 0.25*(n.y-s.y+e.x-w.x)\n\tNeighbors\n    doUVs;\n    vec2 lap =  vec2(T(U + t.xy*st).y - T(U - t.xy*st).y, T(U + t.yx*st).y - T(U - t.yx*st).y);\n    distUVs;\n    C = A(uv);\n    C = sharpen(iChannel0, uv, R);\n    C = C - div*0.1*sin(iTime*2. + length(uvC));\n}\n\n\n\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 307, 348, 348, 958]], "test": "untested"}
{"id": "WdtXz2", "name": "Moving ink", "author": "jaszunio15", "description": "Just learning 2D sdfs :)", "tags": ["2d", "sdf", "ink"], "likes": 63, "viewed": 1981, "published": 3, "date": "1578654385", "time_retrieved": "2024-07-30T21:30:45.180807", "image_code": "//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\nfloat sphereSDF(vec2 point, float radius)\n{\n\treturn length(point) - radius;\n}\n\nvec2 sphereCenter(vec2 rootUV)\n{\n \tfloat hash = hash12(rootUV);\n    vec2 relativePos = vec2(sin(hash * 532.121 + TIME * 2.0), cos(hash * 532.121 + TIME * 2.0)) * 0.5 + 0.5;\n    return rootUV + relativePos;\n}\n\n\nfloat addObjects(float o1, float o2)\n{\n \treturn min(o1, o2);   \n}\n\nfloat addObjectsSmooth(float o1, float o2, float smoothness)\n{\n    float k = clamp((o1 - o2) / smoothness * 0.5 + 0.5, 0.0, 1.0);\n    return mix(o1, o2, k) - k * (1.0 - k) * smoothness;\n}\n\nfloat sphereGridSDF(vec2 point, float radius, float gridScale)\n{\n    point *= gridScale;\n \tvec2 rootUV = floor(point);\n    float minSDF = 99999.0;\n    for (float x = -1.0; x <= 1.0; x++)\n    {\n     \tfor (float y = -1.0; y <= 1.0; y++)\n        {\n        \tfloat sphereSDF = sphereSDF(point - sphereCenter(rootUV + vec2(x, y)), radius);\n            minSDF = addObjectsSmooth(minSDF, sphereSDF, 0.3);\n        }\n    }\n    \n    return minSDF / gridScale;\n}\n\nfloat objSDF(vec2 point)\n{\n \tfloat object = sphereSDF(point, 0.2);\n    \n    vec2 circularMovement = vec2(sin(TIME * 0.2), cos(TIME * 0.2)) * 2.0;\n    vec2 dotsShift = vec2(-cos(TIME * 0.2), sin(TIME * 0.2));\n    float gridSphereRadius = (smoothstep(0.5, 0.0, length(point - dotsShift * 0.1)) - 0.4);\n    float smallGridSphereRadius = (smoothstep(0.4, 0.0, length(point - dotsShift * 0.1)) - 0.5);\n    object = addObjectsSmooth(object, sphereGridSDF(point + circularMovement, gridSphereRadius, 10.0), 0.1);\n    object = addObjectsSmooth(object, sphereGridSDF(point + circularMovement, smallGridSphereRadius, 20.0), 0.01);\n    return object;\n}\n\nvec3 objSDFToTestColor(float objSDF)\n{\n\tvec3 col = vec3(0.0);\n    float positive = smoothstep(-BORDER_WIDTH, BORDER_WIDTH, objSDF);\n    float border = smoothstep(BORDER_WIDTH, BORDER_WIDTH * 0.5, abs(objSDF));\n    \n    float lines = smoothstep(0.5, 0.0, abs(fract(objSDF * 40.0) - 0.5)) * 0.8;\n    \n    col += POSITIVE_COLOR * positive * lines;\n    col += NEGATIVE_COLOR * (1.0 - positive) * lines;\n    col += BORDER_COLOR * border;\n    \n    return col;\n}\n\nvec3 objSDFToColor(float objSDF)\n{\n    float positive = smoothstep(-BORDER_WIDTH, BORDER_WIDTH, objSDF);\n\n    return vec3(1.0) * positive;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n\n    float sdf = objSDF(uv);\n    vec3 col = objSDFToColor(sdf);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "#define NEGATIVE_COLOR vec3(0.4, 0.4, 1.0)\n#define POSITIVE_COLOR vec3(0.4, 1.0, 0.4)\n#define BORDER_COLOR vec3(1.0, 1.0, 1.0)\n#define BORDER_WIDTH 0.004\n\n#define TIME (iTime * 1.0)\n\nfloat hash12(vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(533.59731, 821.49221))) * 4315.212331);   \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtXz2.jpg", "access": "api", "license": "cc-by-3.0", "functions": [[62, 62, 105, 105, 139], [141, 141, 173, 173, 348], [351, 351, 389, 389, 416], [418, 418, 480, 480, 605], [607, 607, 671, 671, 1057], [1059, 1059, 1085, 1085, 1700], [1702, 1702, 1740, 1740, 2157], [2159, 2159, 2193, 2193, 2299], [2302, 2302, 2359, 2359, 2552]], "test": "untested"}
{"id": "tlGGWz", "name": "Simplex Solid LRPN", "author": "H4w0", "description": "Implementation of a Solid Random Phase Noise on a simplex grid.\nMouse.x -> Frequency\nComing next : Filtering ! (Soon)\n\n", "tags": ["procedural", "noise", "texture", "lrpn", "solidnoise"], "likes": 2, "viewed": 382, "published": 3, "date": "1578654290", "time_retrieved": "2024-07-30T21:30:46.005601", "image_code": "//=======================================================\n//= Solid Local Random Phase Noise - Simplex\n//=======================================================\n//== Computing a RandomPhaseNoise on a simplex grid\n//== Need some cleaning... (artefacts, ...)\n//=======================================================\n//== Some great ressources for simplex noise :\n//== *- Stefan Gustavson's \"Simplex noise demystified\"\n//==    http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n//== \n//== I also used some code from :\n//== *- @nikat's commented implementation on Shadertoy \t<---  \n//=   \thttps://www.shadertoy.com/view/XsX3zB\t\t\t<--- \t\n//== *- @candicat's implementation on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sc3z2\n//==\n//== Raymarching Code uses IQ's SDF ( Sphere & Box ) + Subtract Operator\n//== https://iquilezles.org/articles/distfunctions\n//==\n//== Used also some code provided by Lagae et al. [2011]\n//== \"Filtering Solid Gabor Noise\"\n//== http://graphics.cs.kuleuven.be/publications/LD11FSGN/\n//==\n//== Feel free to use it ...\n//==\n//=======================================================\n//== Author : Arthur Cavalier\n//=======================================================\n\n\n\n//-----------------------------------------------------------------------------\n//-- User Parameters ----------------------------------------------------------\nconst uint  LRPN_GLOBAL_SEED \t= 0u;\nconst int   LRPN_COSINES \t\t= 5;\nconst float LRPN_SCALE_FREQ \t= 10.;\nconst float LRPN_SCALE_SPACE \t= 5.;\nconst float LRPN_MAGNITUDE \t\t= 1.;\n#define MOUSE_CONTROL\n//#define PHASE_SHIFT \n\n\n//-----------------------------------------------------------------------------\n//-- Simplex Solid LRPN Code --------------------------------------------------\nfloat gaussian_window_3D(in vec3 st, in float c, in float s)\n{\n    mat3 sig = mat3(s);\n    float body = -0.5*dot(st,inverse(sig)*st);\n    return c*exp(body);\n}\n\nfloat local_random_phase_noise(\n    \tin ivec3 vertex_index,\n    \tin vec3  noise_coords,\n    \tin int   nof_cosines,\n    \tin vec2  range_frequency,\n        in vec2  range_orientation,\n    \tin float window_magni,\n    \tin float window_width\n\t)\n{\n    uint seed    = cell_seed(vertex_index,LRPN_GLOBAL_SEED);\n    uint prng    = wang_hash(seed);\n\n    float sc = 0.; \n    for(int k=0; k<nof_cosines; k++)\n    {\n        float fr = myrand_uniform_m_M(prng,range_frequency.x,range_frequency.y); \t // pick a frequency \n        float or = myrand_uniform_m_M(prng,range_orientation.x,range_orientation.y); // pick an orientation\n        float ph = myrand_uniform_0_1(prng)*m_2_pi; // pick a phase (shift)\n\t\n\t#ifdef PHASE_SHIFT\n        ph = iTime;\n\t#endif\n     \n        float omega_r = fr;\n        float omega_t = or;\n        float omega_p = acos(myrand_uniform_0_1(prng)*2.-1.);\n        vec3 F = omega_r * vec3(cos(omega_t) * sin(omega_p), sin(omega_t) * sin(omega_p), cos(omega_p));\n        \n        sc +=  cos(m_2_pi* dot(F, noise_coords) + ph);\n    }\n    return gaussian_window_3D(noise_coords,window_magni,window_width) * sc / float(nof_cosines);\n}\n\nfloat simplex_solid_random_phase_noise(\n    \tin vec3  P, // Evaluation Point\n    \tin int   C, // Number of Cosines\n    \tin vec2  F, // Frequency Range (freq_min ; freq_max) \n    \tin vec2  O, // Orientation Range (theta_min ; theta_max)\n    \tin float K  // Gaussian Window Magnitude\n\t)\n{\n    const float F3 = 0.333333333; /* -> 1/3 */\n    const float G3 = 0.166666667; /* -> 1/6 : distance edge-to-edge of the simplex grid */\n    const float WW = 0.055555556; /* -> 1/6 * 1/3 : find the width of the gaussian window (3*\\sigma ~ 0) */\n    \n    vec3 i = floor(P + (P.x + P.y + P.z) * F3);\n    vec3 d0 = P - (i - (i.x + i.y + i.z) * G3);\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1. * G3);\n    vec3 d2 = d0 - (i2 - 2. * G3);\n    vec3 d3 = d0 - (1. - 3. * G3);   \n    \n   \tfloat n0 = local_random_phase_noise(ivec3(i + 0.), d0, C, F, O, K, WW);\n    float n1 = local_random_phase_noise(ivec3(i + i1), d1, C, F, O, K, WW);\n    float n2 = local_random_phase_noise(ivec3(i + i2), d2, C, F, O, K, WW);\n    float n3 = local_random_phase_noise(ivec3(i + 1.), d3, C, F, O, K, WW);\n    return(n0+n1+n2+n3);\n}\n\n\n\n//-----------------------------------------------------------------------------\n//-- Raymarching Code ---------------------------------------------------------\nvec3  world_get_background(in vec3 rd)       { return vec3(0.); }\n\nfloat world_get_sdf(vec3 P)\n{        \n    float Sph = sdSphere(P,1.);\n \tfloat Box = sdBox( P-vec3(0.,1.,0.) , vec3(2.,0.5+0.5*cos(0.5*iTime),2.));    \n    \n    float SDF = opSub(Box,Sph);\n\treturn(SDF);\n}\n\nfloat world_raymarch(in vec3 ro, in vec3 rd, in float tmax)\n{\n    float step_count  = WORLD_STEPS;\n    float depth_max   = tmax;\n    float t = 0.01;\n    float R = -1.;\n\n    for(float istep=0.; istep<step_count && t<depth_max; istep+=1.)\n    {\n        float D = world_get_sdf(ro + t * rd);\n        if( D < EPSILON )\n        {\n            R = t;\n            break;\n        }\n        t += D;\n    }\n    return R;\n}\n\nvec3 world_get_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*world_get_sdf( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*world_get_sdf( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*world_get_sdf( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*world_get_sdf( pos + e.xxx ) );  \n}\n\n\nvec3 raymarcher(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(0.);\n\n    float hit_dis = world_raymarch(ro, rd, 10.);\n    \n    if(hit_dis<0.) \n    {\n    \treturn world_get_background(rd);\n    }\n\n    \n    int   C = LRPN_COSINES;\n    vec2  F = vec2(0.3,1.)*LRPN_SCALE_FREQ; \n    vec2  O = vec2(0.,1.)*m_pi;\n    float K = LRPN_MAGNITUDE;   \n    \n#ifdef MOUSE_CONTROL\n    vec2 mouse = clamp(iMouse.xy / iResolution.xy, 0., 1.);\n    F = vec2(0.3, max(0.1,mouse.x) )*LRPN_SCALE_FREQ;     \n#endif\n    \n    \n    vec3  hit_pos = ro+rd*hit_dis;\n    vec3 coords = hit_pos * LRPN_SCALE_SPACE;\n    float noise = simplex_solid_random_phase_noise(coords,C,F,O,K);\n    return vec3( 0.5+0.5*noise );\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Main Render Function -----------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color              = world_get_background(rd);\n    vec2 scene_bouding_box  = intersection_axis_aligned_box(ro, rd, WORLD_BOUNDING_BOX);\n    if(! (scene_bouding_box.x > scene_bouding_box.y || scene_bouding_box.y < 0.0)) \n    {\n        vec3    B = ro + max(scene_bouding_box.x,0.) * rd;\n        vec3    E = ro + scene_bouding_box.y * rd;\n        vec3    V = rd;\n        color = raymarcher(B,V);\n    }\n    return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 screen_coords = ( 2.*(gl_FragCoord.xy) - iResolution.xy ) / iResolution.y;\n    \n    // IQ - Raymarching Primitives https://www.shadertoy.com/view/Xds3zN Camera\n    vec3 camera_origin = vec3( 2.*cos(0.2*iTime) , 2.0 , 2.*sin(0.2*iTime) );\n    vec3 camera_target = vec3(0.);\n    vec3 ray_direction = compute_camera_ray_direction(screen_coords, camera_origin, camera_target, 0.);\n\n    fragColor = vec4( render(camera_origin,ray_direction), 1.);   \n}", "image_inputs": [], "common_code": "//-----------------------------------------------------------------------------\n//-- Scene Constants ----------------------------------------------------------\nconst float EPSILON             = 1e-04;\nconst float WORLD_STEPS       \t= 64.;\nconst vec3  WORLD_BOUNDING_BOX  = vec3(3.);\n\nconst float m_pi = 3.14159265;\nconst float m_2_pi = 2.*m_pi;\n\n//-----------------------------------------------------------------------------\n//-- Scene Intersection Function ----------------------------------------------\nvec2 intersection_axis_aligned_box(in vec3 ray_origin, in vec3 ray_direction, in vec3 box_parameters) \n{\n    vec3 m  = 1.0/ray_direction;\n    vec3 n  = m*ray_origin;\n    vec3 k  = abs(m)*box_parameters;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2(tN,tF);\n}\n\n\n//----------------------------------------------------------------------------------\n// IQ SDF functions ----------------------------------------------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//----------------------------------------------------------------------------------\n// SDF Operators -------------------------------------------------------------------\nfloat opUnn( float d1, float d2 ) { return min( d1, d2); }\nfloat opSub( float d1, float d2 ) { return max(-d1, d2); }\nfloat opInt( float d1, float d2 ) { return max( d1, d2); }\n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n\n\n//----------------------------------------------------------------------------------\n// PRNG ----------------------------------------------------------------------------\n\n// Pseudo Random Number Generation\n// From Texton Noise Source Code provided by Galerne et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                      {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)         {const uint period=1024u; uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  cell_seed(const in ivec3 c, const in uint offset)         {const uint period=1024u; uint s=(((((uint(c.z)%period)*period)+(uint(c.y)%period))*period)+(uint(c.x)%period))+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                      {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                          {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma){return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1592, 1752, 1814, 1814, 1911], [1913, 1913, 2154, 2154, 3051], [3053, 3053, 3339, 3339, 4244], [4248, 4408, 4454, 4454, 4473], [4475, 4475, 4504, 4504, 4678], [4680, 4680, 4741, 4741, 5090], [5092, 5092, 5130, 5130, 5372], [5375, 5375, 5410, 5410, 6051], [6054, 6214, 6251, 6251, 6679], [6681, 6841, 6898, 6898, 7357]], "test": "untested"}
{"id": "ttGGWz", "name": "Polar Patterns in RGB", "author": "tombla", "description": "Two types of patterns (angle- and radius-based) mixed together.", "tags": ["procedural", "radial", "polar", "tuner"], "likes": 4, "viewed": 364, "published": 3, "date": "1578651609", "time_retrieved": "2024-07-30T21:30:46.836380", "image_code": "#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define ARMS 6.\n#define ANGLE_SPEED 3.\n#define DENSITY 3.\n#define SPEED 8.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2\n        R = iResolution.xy,\n        // Cartesian [-1, 1] along shorter axis.\n        uv = (2. * fragCoord - R) / min(R.x, R.y);\n    float\n        T = iTime,\n        // Angle [-PI, PI] and radius.\n        a = atan(uv.x, uv.y),\n        r = length(uv);\n\n    // Patterns based on the angle.\n    float ap1 = sin(a * ARMS + T * ANGLE_SPEED);\n    // Patterns based on radius.\n    float rp1 = sin(1. / r * PI2 * DENSITY + T * SPEED);\n    // Expose interference-like patters in the middle.\n    float rp2 = smoothstep(9., 1., 1. / r);\n\n    vec3 color = vec3(ap1 * rp2, rp1, rp2);\n    fragColor = vec4(color * 1.2, 1.);\n    //gamma22(fragColor, color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 184, 184, 837]], "test": "untested"}
{"id": "ttG3DR", "name": "Draw A Tree ", "author": "shackle", "description": "If nothing, please reset time. ", "tags": ["tree", "grow", "leaves"], "likes": 12, "viewed": 491, "published": 3, "date": "1578645262", "time_retrieved": "2024-07-30T21:30:47.689100", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0,uv).xyz,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.141592654\n\nuint GetIndex(vec2 fragCoord,vec2 iResolution)\n{\n    fragCoord-=0.5;\n    return uint(fragCoord.y * iResolution.x + fragCoord.x);\n}\nvec2 GetUV(uint index,vec2 iResolution)\n{\n    float y=floor(float(index)/iResolution.x);\n    float x=float(index)-y*iResolution.x;\n    return (vec2(x,y)+0.5)/iResolution.xy;\n}\n// setting\n// if FPS is low, the time_rate should be small;\nconst float time_rate=30.0;\nconst float time_begin=0.5;\nconst uint branch=2U;\nconst float stop_thre=0.2;\nconst float atten=0.8;\nconst float leaf_size=0.5;", "buffer_a_code": "\nfloat RadicalInverse(uint Base, uint i)\n{\n    float Digit, Radical, Inverse;\n    Digit = Radical = 1.0 / float(Base);\n    Inverse = 0.0;\n    while (i > 0U) {\n        Inverse += Digit * float(i % Base);\n        Digit *= Radical;\n\n        i /= Base;\n    }\n    return Inverse;\n}\n\nvec2 Rot(vec2 v, float angle)\n{\n    return vec2(v.x * cos(angle) + v.y * sin(angle),\n        v.y * cos(angle) - v.x * sin(angle));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n   \n    float kt=iTime*time_rate;\n    //if(kt<time_begin)    \n    if(iFrame<2)\n    {\n        fragColor=vec4(0.0);\n        return;\n    }\n    kt-=time_begin;\n\n    vec4 preData=texture(iChannel0,uv);\n    if(preData.y>0.0)\n    {\n        fragColor=preData;\n        return;\n    }\n\n    uint drawIndex = uint(kt);\n    uint locIndex=GetIndex(fragCoord,iResolution.xy);\n    if(drawIndex!=locIndex)\n    {\n        fragColor=preData;\n        return;\n    }\n    else if(drawIndex<1U)\n    {\n        fragColor=vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    else if(drawIndex<branch)\n    {\n        fragColor=vec4(0.0,0.3-0.15*float(drawIndex)/float(branch),0.0,1.0);\n        return;\n    }\n    uint rootIndex=drawIndex/branch;\n    vec4 rootData=texture(iChannel0,GetUV(rootIndex,iResolution.xy));\n\n    float rd0=RadicalInverse(2U,drawIndex)*2.0-1.0;//[-1,1]\n    float rd1=RadicalInverse(3U,drawIndex)*0.6+0.4;//[0.4,1]\n\n    vec2 dir=rootData.zw;\n    dir=atten*Rot(dir,0.15*PI*rd0);\n\n    vec2 pos=rootData.xy+dir*0.25*rd1;\n    \n\n    fragColor=vec4(pos,dir);\n    // fragColor=vec4(1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat SDF_line(vec2 P,vec2 O,vec2 D)\n{\n    vec2 OP=P-O;\n    vec2 OH=dot(OP,D)*D;\n    vec2 HP=OP-OH;\n    return length(HP);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    vec2 loc=uv-vec2(0.5,0.0);\n    loc.x*=iResolution.x/iResolution.y;\n\n    float kt=iTime*0.8*time_rate;\n    kt=mod(kt,time_rate+pow(2.0,1.0+ceil(log(stop_thre)/log(atten))));\n\n    //if(kt<time_begin)    \n    if(iFrame<2||kt<time_begin)\n    {\n        fragColor=vec4(vec3(0.0),1.0);\n        return;\n    }\n    kt-=time_begin;\n    vec4 preColor=texture(iChannel0,uv);\n\n    uint drawIndex = uint(kt);\n    float progress=fract(kt);\n    progress=smoothstep(0.0,0.4,progress);\n\n    vec4 data=texture(iChannel1,GetUV(drawIndex,iResolution.xy));\n    vec4 rootData=texture(iChannel1,GetUV(drawIndex/branch,iResolution.xy));\n\n    vec2 dir=data.zw;\n    vec2 root=rootData.xy;\n    vec2 target=data.xy+dir*0.01;\n\n    target=mix(root,target,progress);\n    float len=distance(target,root);\n\n\n    vec3 f=vec3(0.0);\n\n    float p=length(dir);\n\n    if(p>stop_thre)\n    {   \n        float d0=distance(loc,root)+distance(loc,target)-len;\n        float d1=SDF_line(loc,root,normalize(dir));\n        f=vec3(0.7,0.4,0.35)*smoothstep(0.005,-0.00,max(d1,d0));\n    }else if(p>atten*stop_thre)\n    {\n        float kfm=0.8;\n        float d0=distance(loc,root)+kfm*distance(loc,target);\n        f=vec3(0.557,1.0,0.514)*smoothstep(kfm+leaf_size,kfm,d0/len);\n    }\n    \n    // float f=smoothstep(0.01,-0.00,distance(uv,target));\n\n    fragColor=max(preColor,vec4(vec3(f),1.0));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttG3DR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 228]], "test": "untested"}
{"id": "tly3WR", "name": "Pixelated ocean current (edit)", "author": "jarble", "description": "Another edit of one of my shaders.", "tags": ["fractal", "quadtree"], "likes": 2, "viewed": 378, "published": 3, "date": "1578627761", "time_retrieved": "2024-07-30T21:30:48.449068", "image_code": "//this function is from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy+sin(iTime));\n\n}\n\nvec2 magnify(vec2 fragCoord,float mag){\n\treturn hash22(floor(fragCoord/pow(2.0,mag)));\n}\n\nvec2 pixel_above(vec2 fragCoord,float mag){\n\treturn magnify(fragCoord+vec2(pow(2.0,mag),0),mag);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 color1 = vec2(0,0);\n    float maximum = 5.0;\n    for(float i = 1.0; i < 1.0+maximum; i++){\n    \tcolor1 += pixel_above(fragCoord,i+1.0);\n    }\n    color1 /= maximum;\n    fragColor = vec4(0.0,color1,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 83, 83, 228], [230, 230, 269, 269, 318], [320, 320, 363, 363, 418], [420, 420, 477, 477, 691]], "test": "untested"}
{"id": "wlG3WR", "name": "melting checkerboard", "author": "mds2", "description": "attempt to make an animated replica of a piece of generated placeholder art I saw online", "tags": ["simple", "fun", "quick"], "likes": 2, "viewed": 325, "published": 3, "date": "1578623825", "time_retrieved": "2024-07-30T21:30:49.208039", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float h = sin(50.0 * uv.x + 20.0 * sin(12.0 * uv.x + iTime));\n\n    \n    float jiggle = smoothstep(-0.1, 0.1, sin(80.0 * uv.y));\n    h = mix(h, - h, jiggle);\n    vec3 col = mix(vec3(0.8, 0.0, 0.0), vec3(0.0), smoothstep(-0.1, 0.1, h));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlG3WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 481]], "test": "untested"}
{"id": "tlG3WR", "name": "James Bond Rabbit Hole ", "author": "wookworld", "description": "going in then going out", "tags": ["3d", "rabbithole"], "likes": 7, "viewed": 564, "published": 3, "date": "1578623805", "time_retrieved": "2024-07-30T21:30:50.053778", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n \tfloat t = iTime * .2;\n\t//uv *= mat2(cos(t),-sin(t),sin(t),cos(t));\n    vec3 ro = vec3(0, 0, -1);\n    vec3 lookat  = mix(vec3(0),vec3(-1,0,-1),sin(t*1.56)*.5+.5);\n    float zoom = mix(.2,.7,sin(t)*.5+.5);\n    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n                      \n    float radius = .7;\n    float d5, dO;\n    vec3 p;\n                      \n     for(int i = 0; i<100; i++) {\n         p = ro + rd * dO;\n         d5 = -(length(vec2(length(p.xz)-1.,p.y)) - radius);\n     \tif (d5<.001) break;\n     \tdO += d5;\n     }\n   \n    vec3 col = vec3(0);\n\n    if(d5<.001) {\n       float x = atan(p.x,p.z)+t*mix(.4,.8,sin(t)*.01+.5);\n       float y = atan(length(p.xz)-1.,p.y);\n      \n        float bands = sin(y*10.+x*20.);\n        float ripples = sin((x*10.-y*30.)*3.)*.5+.5;\n        float waves = sin(x*2.-y*6.+t*10.);\n        \n       float b1 = smoothstep(-.2,.2, bands);\n       float b2 = smoothstep(-.2,.2, bands-.5);\n        \n        float m = b1*(1.-b2);\n        m = max(m, ripples*b2*b2*max(0.,waves));\n        m += max(0.,waves*.3*b2);\n        \n        col+= mix(m, 1.-m,smoothstep(-.3,.3, sin(x*2.+t)))+texture(iChannel1, uv*.9+iTime*+.001).rgb;\n   \n     col.rg += uv.xy;}\n    fragColor = vec4(col,.2);\n     col.rg = uv;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlG3WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1554]], "test": "untested"}
{"id": "Wty3Dz", "name": "Day 20 - Julias", "author": "jeyko", "description": "\nSDF and coloring from https://www.shadertoy.com/view/WtV3Rw\nMDTMJVM = Middecembertomidjanuaryvember\nA month of coding stuff.\nCoding some of the days at http://twitch.tv/wwrighter", "tags": ["pathtracer", "mdtmjvm"], "likes": 4, "viewed": 389, "published": 3, "date": "1578610468", "time_retrieved": "2024-07-30T21:30:51.163811", "image_code": " \n\n// SDF and coloring from https://www.shadertoy.com/view/WtV3Rw\n\n\n\n#define FOCUS_FORMULA ((abs(texture(iChannel0,uv).w - FOCUS_DISTANCE)*BLUR_AMT ))\n\nconst float blurdist_px = 64.0;\n\n\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n\nvec3 sampletex( vec2 uv )\n{\n    #ifdef SRGBLIN\n    \treturn srgb2lin( texture( iChannel0, uv, -10.0 ).rgb );\n    #else\n    \treturn  texture( iChannel0, uv, -10.0 ).rgb ;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float blurdist = FOCUS_FORMULA;\n\n    //float srnd = hash12n(uv+fract(iTime))-0.5;\n    \n   \tvec3 sumcol0 = vec3(0.0);\n    {\n        vec2 blurdir = vec2( 1.0, 0.577350269189626 );\n    \tvec2 blurvec = normalize(blurdir) / iResolution.xy;\n        vec2 p0 = uv - 0.5 * blurdist * blurvec;\n    \tvec2 p1 = uv + 0.5 * blurdist * blurvec;\n    \tvec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n    \tvec2 p = p0;\n        p += stepvec;\n    \n        for (int i=0;i<NUM_SAMPLES;++i)\n        {\n        \tsumcol0 += sampletex(p);\n            p += stepvec;\n        }\n        sumcol0 /= float(NUM_SAMPLES);\n    }\n    \n    vec3 sumcol1 = vec3(0.0);\n    {\n        vec2 blurdir = vec2( -1.0, 0.577350269189626 );\n        vec2 blurvec = normalize(blurdir) / iResolution.xy;\n        vec2 p0 = uv - 0.5 * blurdist * blurvec;\n        vec2 p1 = uv + 0.5 * blurdist * blurvec;\n        vec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n        vec2 p = p0;\n        p +=  stepvec;\n\n        for (int i=0;i<NUM_SAMPLES;++i)\n        {\n        \tsumcol1 += sampletex(p);\n            p += stepvec;\n        }\n        sumcol1 /= float(NUM_SAMPLES);\n    }\n\n    vec3 sumcol = min( sumcol0, sumcol1 );\n\n    #ifdef SRGBLIN\n    \tfragColor = vec4( lin2srgb( sumcol ), 1.0 );\n    #else\n    \tfragColor = vec4( sumcol , 1.0 );\n    #endif\n    fragColor = 1.*texture(iChannel1, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define fov 0.7\n#define zoom 1.4\n#define BOUNCES 3\n#define MARCH_ITERATIONS 260\n\n\n\n#define mx (20.*iMouse.x/iResolution.x)\n#define my (20.*iMouse.y/iResolution.x)\n#define pmod(p,x) mod(p, x) - x*0.5\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nMaterial materials[5] = Material[](\n\tMaterial(vec3(1.,0.4,1)*30.1,0.,1.), // wall\n\tMaterial(vec3(1.,1.,1.)*0.4,0.0,0.9), // light A\n\tMaterial(vec3(0.)*0.,0.1,0.), // Julia\n\tMaterial(vec3(0.001)*1.,0.9,0.1),\n\tMaterial(vec3(0.3,0.4,1.4)*3.5,0.9,2.0)\n);  \n\n\nvec3 getRd(vec3 o, vec3 lookAt, vec2 uv) {\n    uv += hash(uv.x + uv.y + float(iFrame))*0.002;\t\t\t// thx slerpy\n    vec3 dir = normalize(lookAt - o);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return dir + right*uv.x*fov + up*uv.y*fov;\n}\n\n// ----------------- SDFs ----------------- //\nfloat sdBox (vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.x, max(p.y, p.z));\n}    \nfloat sdSphere (vec3 p, float s){\n\treturn length(p) - s;\n}\nfloat sdFloorA (vec3 p){\n    return p.y;\n}\nfloat sdWall (vec3 p){\n    return -p.x;\n}\nfloat sdBackWall (vec3 p){\n    return -p.z;\n}\n#define ITERATIONS 3.0\n\n#define C vec4(0.09,0.7,0.3,0.3)\n\n\nvec3 qColor = vec3(0);\n#define ASIZE 1.6\n\nObject sdJulia(vec3 p) {\n    Object o = NewObject;\n    p.xz *= rot(0.35 * PI);\n    p.y -= 0.1;\n    \n    \n    for (int i = 0; i < 2; i++){\n    \t\n        p.y -= 0.29;\n        p.x -= 0.4;\n        p.z -= 0.04;\n        if (i > 2) {\n        \tp.x *= atan(p.x,p.z);\n        }\n    \tp.xy *= rot(0.5*PI);\n        p.xz *= rot(0.24 - float(i)*0.01);\n        \n        p = abs(p);\n    }\n    p.z -= .5;\n    //p.zy *= rot(0.2);\n    p -= 0.58;\n    p.x -= 0.7;\n    \n    p.y -= 0.2;\n    /*\n    for (int i = 0; i < 4; i++){\n    \t\n        p.y -= 0.4;\n        if (i > 2) {\n        \tp.x *= atan(p.x,p.z);\n        }\n    \tp.xy *= rot(0.5*PI);\n        p.xz *= rot(0.54);\n        \n        p = abs(p);\n    }\n    */\n    vec4 z = vec4(p, 0.1);\n    vec4 dz = vec4(1, 0, 0, 0);\n    //o = omin(o,sdOcta(p, vec3(0.1)),materials[3]);\n    vec4 c = C;\n    \n    \n    float it;\n    float minDist = 1000.0;\n    float mdX, mdY, mdZ;\n    mdX = minDist; mdY = minDist; mdZ = minDist;\n    //c.w += 0.5*sin(iTime*2.0);\n    for(float x=0.0; x < 13.0; x++)\n    {\n        dz = 2.0*multQuat(z,dz);\n    \tz = squareQuat(z) + c;\n        \n        minDist = min(minDist, length(z - c)); //store minimum distance from starting point\n        mdX = min(mdX, abs(z.x));\n\t\tmdY = min(mdY, abs(z.y));\n\t\tmdZ = min(mdZ, abs(z.z));\n        \n        if(length(z) > 2.0)\n        {\n            it = x;\n            break;\n        }\n    }\n\n    \n    //Coloring based off orbits: https://iquilezles.org/articles/ftrapsgeometric\n    qColor = vec3(0) + vec3(0.7, 0.3, 0.55)*(minDist);\n    qColor += vec3(0.,0.3,0.3)*(mdX);\n    qColor += vec3(0.5,0.2,0)*(mdY);\n    qColor += vec3(0.0,0.1,0.)*(mdZ);\n\n\tmaterials[2].albedo = vec3(qColor)*2.6;\n    o.d = 0.75*length(z)*log(length(z)) / length(dz);\n\treturn o;\n}\n\n// ----------------- MAP ----------------- //\n#define HEIGHT\nObject map(vec3 p) {\n    Object o = NewObject;\n    \n\n    //o = omin(o, sdFloorA(p - vec3(0.,-0.14,0)), materials[0]);\n    \n    //o = omin(o, sdWall(p - vec3(0.9,0.,0)), materials[0]);\n    \n    ////o = omin(o, -sdWall(p - vec3(-0.4,0.,0)), materials[0]);\n    //o = omin(o, sdWall(p - vec3(0.4,0.,0)), materials[1]);\n    //o = omin(o, sdSphere(p - vec3(-.6,0.4,0.6), 0.2), materials[0]);\n    \n    o = omin(o, sdJulia(p - vec3(-0.0,0.0,0.1)).d, materials[2]);\n    //p.xz *= rot(0.1);\n    p.y += 1.7;\n    o = omin(o, sdJulia(p - vec3(4.,6.0,2.)).d, materials[2]);\n    \n    \n    o.didHit = true;\n    o.d *= 0.8;\n    return o;\n}\n\nObject trace(vec3 ro, vec3 rd) {\n    vec3 p = ro + rd*0.1;\n    float t = 0.;\n    for (int i = 0; i < MARCH_ITERATIONS; i++) {\n    \tObject obj = map(p);\n        \n        if (obj.d < 0.0002) {\n            obj.d = t;\n        \treturn obj;\n            break;\n        }\n        \n        if (t > 100.) {\n            obj.didHit = false;\n            return obj;\n        \tbreak;\n        }\n    \n        t += obj.d;\n        p = ro + rd*t;\n    }\n\n\n}\n\nvec3 getNormal(vec3 p) {\n\tvec2 t = vec2(0.0005,0.);    \n    return normalize(vec3(\n    \tmap(p + t.xyy).d - map(p - t.xyy).d,\n    \tmap(p + t.yxy).d - map(p - t.yxy).d,\n    \tmap(p + t.yyx).d - map(p - t.yyx).d\n    ));\n}\n\n// ----------------- MAIN ----------------- //\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv -= normalize(uv)*pow(length(uv)*0.34,3.);\n    vec2 uvs = (fragCoord/iResolution.xy);\n\n    vec4 col = texture(iChannel0, uvs);\n \n    vec3 accum = vec3(0);\n    float attenuation = 1.;\n    \n    vec3 ro = vec3(0,-0.09,0.);\n    \n    ro.x -= 0.9;\n    ro.y -= 1.8;\n    ro.z -= 0.7;\n    //ro.x -= 10.;\n    //ro.y -= 10.;\n    //ro.x += mx;\n    //ro.y += my;\n    vec3 lookAt = vec3(0.9,0,0);\n    vec3 rd = getRd(ro, lookAt, uv);\n    ro -= normalize(lookAt - ro)*zoom;\n    vec3 dir = rd;\n    float seed = hash(float(iFrame) + uv.x*243.124 + uv.y*212.512);\n    \n    float dFirst = 0.;\n    bool hitBg = false;\n    int i = 0;\n    for (; i < BOUNCES; i++){\n    \tObject obj = trace(ro, rd);\n        if (obj.didHit) {       \n            if (i == 0){\n                dFirst = obj.d;\n            }\n            vec3 p = ro + rd * obj.d;  \t\t\t\t\n    \t\tvec3 N = getNormal(p);\n            accum += obj.material.albedo*1. * attenuation;\n            attenuation /= PI; // thx slerpy\n            //accum += obj.material.albedo * attenuation;\n            //seed += 14.5;\n            seed = hash(float(iFrame) + uv.x*24.124 + uv.y*412.512 + float(i)*12.);\n            ro = p;\n            rd = mix(cosineDirection(seed, N),N,obj.material.metalness);\n            accum *= dot(rd,N)*0.4;\n\n            \n\n        } else {\n            hitBg = true;\n            break;\n        }\n        \n    }\n    col.xyz += accum;\n    \n    if (iFrame == 0) {\n        if (hitBg && i == 0 ){\n            col.w = 12345678.;\n        } else {\n            col.w = dFirst;\n        }\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RAND 1\n\n#define NUM_SAMPLES 1\n#define bdist 0.00\n#define PI 3.14159265359\n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nvec4 multQuat(vec4 q1, vec4 q2)\n{\n    vec4 r;\n    r.x   = q1.x*q2.x - dot( q1.yzw, q2.yzw );\n    r.yzw = q1.x*q2.yzw + q2.x*q1.yzw + cross( q1.yzw, q2.yzw );\n    return r;\n}\n\n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nvec4 squareQuat(vec4 q)\n{\n \tvec4 r;\n    r.x   = q.x*q.x - dot( q.yzw, q.yzw );\n    r.yzw = 2.0*q.x*q.yzw;\n    return r;  \n}\n\n#define BLUR_AMT (1.)\n//#define FOCUS_DISTANCE (0.1 + (0.5 + sin(iTime)*0.5))\n#define FOCUS_DIV 3.\n//#define FOCUS_DISTANCE (0.1 + (FOCUS_DIV + sin(iTime)*FOCUS_DIV))\n#define FOCUS_DISTANCE (2.5)\n#define SRGBLIN\n\n#if RAND == 1\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125 + u.z*12525.215215215)*124115.125235);\n}\n#elif RAND == 2\n// by Dave Hoskins\nfloat r31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n#endif\n\n\n\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n// hg_sdf\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\nstruct Material {\n    vec3 albedo;\n\tfloat metalness; \n\tfloat roughness;\n};\n\nstruct Light {\n\tvec3 colour;\n    vec3 pos;\n\tfloat intensity;\n};\nLight lights[1] = Light[](\n    Light(vec3(1.2,1.2,1), vec3(-0.,10.,0.), 0.)\n);    \n\nstruct Object {\n\tfloat d;\n    bool didHit;\n\tMaterial material;\n};\nObject omin(Object a, float bdistance, Material bmaterial) {\n    if (a.d < bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\nObject omin(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, float bdistance, Material bmaterial) {\n    if (a.d > bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\n\n\n#define NewObject Object(1e8,false,materials[0])\n\n\n\n\n// by fizzer: http://www.amietia.com/lambertnotangent.html\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}", "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 tex = texture(iChannel0, uv);\n    fragColor = tex;\n    fragColor.xyz /= float(iFrame);\n    //fragColor.xyz = clamp(fragColor.xyz, 0. ,1.);\n    fragColor.xyz *= 1.9;\n    \n    vec3 fogColor =  mix(vec3(0.6,.26,0.119)*0.05, vec3(0.5,.16,0.319)*0.09, uv.y)*0.2;\n    fragColor.xyz = mix(fragColor.xyz,fogColor, pow(smoothstep(0.,1.,fragColor.w*0.19 - 0.9), 1.04));\n    if (fragColor.w == 12345678.){\n    \t//fragColor.xyz = fogColor;\n    }\n    fragColor.xyz = clamp(fragColor.xyz, 0.03,1.);\n    fragColor.x = fragColor.y;\n    fragColor *= 1.;\n    fragColor.g *= 0.9;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545));\n    fragColor.xyz *= 1.3;\n    fragColor.xyz = smoothstep(0.,1.,fragColor.xyz); // thx to yx for smoothstep col\n    \n    //fragColor.xyz = smoothstep(0.,1.,pow(fragColor.xyz, vec3(0.8)));\n} ", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Depth of Field pass. Code from https://www.shadertoy.com/view/Xd3GDl\n// which is an implementation of DICE's depth of field paper\n\n//#define USE_RANDOM\nconst vec2 blurdir = vec2( 1.0, 1.0 );\n\nconst float blurdist_px = 64.0;\n\n\n//#define FOCUS_FORMULA (abs(texture(iChannel0,uv).w - 2.))\n#define FOCUS_FORMULA ((abs(texture(iChannel0,uv).w - FOCUS_DISTANCE)*BLUR_AMT ))\nconst float MULT = 4.0;\n\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\nvec3 sampletex( vec2 uv )\n{\n    #ifdef SRGBLIN\n    \treturn srgb2lin( texture( iChannel0, uv, -10.0 ).rgb );\n    #else\n    \treturn  texture( iChannel0, uv, -10.0 ).rgb ;\n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 blurdir = vec2( 0.0, 1.0 );\n    vec2 blurvec = normalize(blurdir) / iResolution.xy;\n    vec2 uv = fragCoord / iResolution.xy;\n    float blurdist = FOCUS_FORMULA;\n    \n    vec2 p0 = uv - 0.5 * blurdist * blurvec;\n    vec2 p1 = uv + 0.5 * blurdist * blurvec;\n    vec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n    vec2 p = p0;\n    #if defined(USE_RANDOM)\n    p += (hash12n(uv+fract(iTime))-0.5) * stepvec;\n    #endif\n    \n    vec3 sumcol = vec3(0.0);\n    for (int i=0;i<NUM_SAMPLES;++i)\n    {\n        vec3 smpl = sampletex(p);\n        sumcol += smpl;\n        p += stepvec;\n    }\n    sumcol /= float(NUM_SAMPLES);\n    sumcol = max( sumcol, 0.0 );\n    \n    \n    #ifdef SRGBLIN\n    \tfragColor = vec4( lin2srgb( sumcol * MULT ), texture( iChannel0,uv).w );\n    #else\n    \tfragColor = vec4( sumcol * MULT , texture( iChannel0,uv).w );\n    #endif\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3Dz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 209, 209, 223], [224, 224, 247, 247, 265], [267, 267, 294, 294, 448], [450, 450, 507, 507, 1880]], "test": "untested"}
{"id": "tlVGz1", "name": "Wildflower", "author": "TekF", "description": "An experiment in creating a dense detailed organic scene.", "tags": ["raymarching", "flower", "grass", "organic", "natural"], "likes": 18, "viewed": 842, "published": 3, "date": "1578603672", "time_retrieved": "2024-07-30T21:30:51.981624", "image_code": "/*\n       _\n\\^/ILD|-LOWER\n\nby Hazel Quantock 2020\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n*/\n\n// create a simple repetetive patch of grass,\n// then blend it with copies of itself randomly offset and rotated\n\n\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (uint(p)*M1)\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\nfloat BladeOfGrass( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool stalk )\n{\n    // cone, curved from vertical to tip\n    // subtract a second cone, offset away from tip\n    // maybe curve more on shorter ones\n\n    float v = (pos.y-base.y) / (tip.y - base.y);\n    \n    // curve the blade\n    v = pow(v,1.5);\n\n    // apply the curved slope\n    pos.xz -= mix(base.xz,tip.xz,v);\n\n    // wrap space here, so it can follow the curve without needing duplicate blades\n    // even if blade curves enough to lean into next repeat!\n//    pos.xz = (abs(fract(pos.xz/(tile*2.)-.25)-.5)-.25)*tile*2.;    // this flips the crease inside out but makes the sdf continuous\n    pos.xz = (fract(pos.xz/tile+.5)-.5)*tile;\n    \n    float r = .03*tip.y;\n    vec2 cutBase = -normalize(tip.xz)*r*.3;\n    \n    if ( stalk )\n        r = .0005;\n    else\n        r *= (1.-v);\n    \n    float f = length(pos.xz) - r;\n\n    if ( !stalk )\n    {\n        f = max(f, -(length(pos.xz - cutBase*(1.-v)) - r*1.2) );\n    }\n        \n    return max(pos.y-tip.y-.0, // improve distance values above tip (with a fudge because this is too low!?)\n              f*.8); // HACK gradient too high because of tilt - todo: do this analytically (curve of v is a problem)\n    \t\t\t\t// this breaks looking top-down if pow(,2) or more\n    \t\t\t\t// better options: tilt plane of the circle, maybe sweep it along a circular curve\n}\n\n\nfloat Flower( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool grass )\n{\n    vec3 tpos = pos-tip-vec3(0,-.0004,0);\n    tpos.xz = (fract(tpos.xz/tile+.5)-.5)*tile;\n    \n//\tfloat f = length(tpos)-.003;\n    \n    // tilt, so the flower sits at a nice angle\n    tpos.yz = tpos.yz*sqrt(2./4.) + tpos.zy*sqrt(2./4.)*vec2(-1,1);\n    \n    // petals: mirror tpos in a circle around z\n    tpos.xy = abs(tpos.xy);\n\tif ( tpos.x > tpos.y ) tpos.xy = tpos.yx;\n\n// too thin at the edges\n// better to intersect a thin sphere with a sphere to cut the shape\n/*    float f = max(\n            length(tpos-vec3(.001,.002,.002)*1.1) - .002,\n            -(length(tpos-vec3(.001,.002,.003)) - .0028)\n        );*/\n    float f = max(\n            length(tpos-vec3(.001,.002,.0005)*1.1) - .002, // cut shape\n            abs( length(tpos-vec3(.001,.002,.003)) - .003)-.0001\n        );\n    f = min( f,\n            max(\n\t            length(tpos-vec3(0,0,.000)) -.001,\n\t            length(tpos-vec3(0,0,.001)) -.001\n            )\n            )*.9;\n\n\tif ( grass ) f = min(min( f,\n                             BladeOfGrass( base, tip, tile, pos, true )),\n                             BladeOfGrass( base, tip+vec3(.003,-.008,-.001), tile, pos, false )\n                            );\n    \n\treturn f;\n}\n\n\nfloat Tile( vec3 pos, float invWeight, vec4 rand, bool grass )\n{\n//    if ( rand.w > .2 ) invWeight = 1.; // isolate some of the blades\n    \n//    invWeight = invWeight*invWeight; // should be 0 until about .5\n//    invWeight = smoothstep(.5,1.,invWeight); // should be 0 until about .5\n\n    // vary the height a little to make it look less even\n    pos.y += sqrt(rand.w)*.07;\n    \n    pos.xz += rand.xy;\n    float a = rand.z*6.283;\n    pos.xz = pos.xz*cos(a) + sin(a)*vec2(-1,1)*pos.zx;\n    \n    float f = 1e20;\n    \n    if ( grass )\n    {\n        f = min(f,min(min(min(min(\n            BladeOfGrass(vec3(.01,0,0),vec3(.03,.15,.04),vec2(.06),pos,false),\n            BladeOfGrass(vec3(0),vec3(-.05,.17,.02),vec2(.06),pos,false)),\n            BladeOfGrass(vec3(0),vec3(-.01,.10,.02),vec2(.04),pos,false)),\n            BladeOfGrass(vec3(0,0,-.01),vec3(-.01,.12,-.03),vec2(.03),pos,false)),\n            BladeOfGrass(vec3(.005,0,0),vec3(.03,.16,-.05),vec2(.04),pos,false)\n        )) + (1.-invWeight)*.0;\n    }\n    \n    // flowers\n    f = min(f, Flower(vec3(.1,0,0),vec3(.1,.2,.05),vec2(.13),pos,grass) + (1.-invWeight)*.0 );\n    \n    return mix( max(.03,pos.y-.2), f, invWeight );\n//    return f;\n}\n\nfloat SDF( vec3 pos, bool grass )\n{\n    // bilinearly filter 4 instances of the Tile pattern with random offsets and rotations\n    \n    vec2 gridSize = vec2(.1);//.04);\n    vec2 uv = pos.xz/gridSize;\n    uvec2 idx00 = uvec2(ivec2(floor(uv))+0x10000);\n    uv -= floor(uv);\n    \n    uvec2 d = uvec2(0,1);\n    vec4 rand00 = hash4(coord2(idx00+d.xx));\n    vec4 rand01 = hash4(coord2(idx00+d.yx));\n    vec4 rand10 = hash4(coord2(idx00+d.xy));\n    vec4 rand11 = hash4(coord2(idx00+d.yy));\n\n//    uv = smoothstep(.0,1.,uv); // this causes a steeper gradient in the middle, so get fewer errors without it\n\n    vec2 uvlo = smoothstep(1.,.5,uv);\n    vec2 uvhi = smoothstep(0.,.5,uv);\n\n    return min( pos.y,\n                min(\n                    min(\n                        Tile( pos, uvlo.x*uvlo.y, rand00, grass ),\n                        Tile( pos, uvhi.x*uvlo.y, rand01, grass )\n                    ),\n                    min(\n                        Tile( pos, uvlo.x*uvhi.y, rand10, grass ),\n                        Tile( pos, uvhi.x*uvhi.y, rand11, grass )\n                    )\n                )\n\t\t\t) * 1.;\n/*    return mix(\n                    mix(\n                        Tile( pos, uv.x*uv.y, rand00, grass ),\n                        Tile( pos, (1.-uv.x)*uv.y, rand01, grass ),\n                        uv.x\n                    ),\n                    mix(\n                        Tile( pos, uv.x*(1.-uv.y), rand10, grass ),\n                        Tile( pos, (1.-uv.x)*(1.-uv.y), rand11, grass ),\n                        uv.x\n                    ),\n        \t\t\tuv.y\n                );*/\n}\n\n// adjust trace quality/performance\nconst float epsilon = .00005;\nconst int loopCount = 200;\n\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far )\n{\n\tfloat t = epsilon;\n    for ( int i=0; i < loopCount; i++ )\n    {\n        float h = SDF( rayDirection*t+rayStart, true );\n        t += h;\n        if ( t > far || h < epsilon ) // *t )\n            return t;\n    }\n    \n    return t;\n}\n\n\nvec3 Normal( vec3 pos )\n{\n    vec2 d = vec2(-1,1) * .000004;\n    return\n        normalize(\n            SDF( pos + d.xxx, true )*d.xxx +\n            SDF( pos + d.xyy, true )*d.xyy +\n            SDF( pos + d.yxy, true )*d.yxy +\n            SDF( pos + d.yyx, true )*d.yyx\n        );\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 camAngle = vec2(.5-.03*(iTime/8.-sin(iTime/8.))*8.,.15-cos(iTime/8.)*.08);\n\tif ( iMouse.z > 0. ) camAngle = pow(iMouse.xy/iResolution.xy,vec2(1.,.5))*vec2(6,-1.57) + vec2(0,1.57);\n    vec3 camPos = 1.*vec3(cos(camAngle.y)*sin(camAngle.x),sin(camAngle.y),cos(camAngle.y)*cos(camAngle.x));\n    vec3 camLook = vec3(0,.10,0)+camPos*vec3(1,0,1)*.3;\n    float camZoom = 2.;\n    \n    vec3 camK = normalize(camLook-camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,camZoom);\n    ray = normalize(ray);\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    \n    float t = Trace( camPos, ray, 1e20 );\n    \n    float far = 20.;\n    if ( t < far )\n    {\n        vec3 pos = camPos+ray*t;\n\n        float sdf = SDF(pos,true);\n        float sdfnograss = SDF(pos,false);\n\n        vec3 flowerColour = sin(pos/.03)*.1+.9;\n        vec3 grassColour = mix( vec3(.2,.6,.01), vec3(.5,.7,.2), .5+.5*sin(pos.yxz/.025+2.5) );\n\n        vec3 albedo = mix( grassColour, mix( vec3(.03,.0,.0), flowerColour, smoothstep(.0,.05,pos.y)), step(sdfnograss,sdf) );\n\n        vec3 n = Normal( camPos+ray*t );\n        vec3 ambient = mix( vec3(.06,.1,.02), vec3(.15,.2,.25), n.y*.5+.5 );\n        float nl = dot(n,normalize(vec3(1,3,2)));\n\n        fragColour.rgb = ambient;\n        fragColour.rgb += vec3(.9)*max(0.,nl); // direct light\n        fragColour.rgb += vec3(.3)*pow(albedo*.99,vec3(4))*smoothstep(-1.,.1,nl); // subsurface light\n        fragColour.rgb *= smoothstep(.0,.18,pos.y); // fake combined shadows & AO\n        fragColour.rgb *= albedo;\n    }\n    else\n    {\n        fragColour.rgb = vec3(1);\n        t = far; // so it gets fog applied\n    }\n    \n    fragColour.rgb = mix( vec3(.7,.8,1), fragColour.rgb, exp2(-t/5.)*1.08 );\n \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    fragColour.a = 1.;\n\n//float f = BladeOfGrass( vec3(.8,0,0), vec3(.9,.5,0), vec3(fragCoord/iResolution.y,0) );\n//float f = SDF(vec3(fragCoord/1000.,.1+.1*sin(iTime)).xzy,true);\n//fragColour.rgb = vec3( .5+.5*f/(abs(f)+.001) );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVGz1.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[715, 715, 735, 735, 761], [762, 762, 781, 781, 826], [827, 827, 846, 846, 899], [900, 900, 919, 919, 980], [983, 983, 1059, 1192, 2352], [2355, 2355, 2425, 2425, 3617], [3620, 3620, 3684, 3965, 4814], [4816, 4816, 4851, 4942, 6407], [6503, 6503, 6563, 6563, 6796], [6799, 6799, 6824, 6824, 7080], [7083, 7083, 7141, 7141, 9244]], "test": "untested"}
{"id": "3lG3Wz", "name": "Simplex noise color trip", "author": "Bleuje", "description": "Experimenting with color and 3d simplex noise.", "tags": ["simplexnoise"], "likes": 8, "viewed": 583, "published": 3, "date": "1578601879", "time_retrieved": "2024-07-30T21:30:52.743586", "image_code": "//by @etiennejcb\n//3d simplex noise from https://www.shadertoy.com/view/XsX3zB\n\nconst float PI = 3.1415926535897932384626433832795;\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n\nfloat transformValue(float v){\n    v = 0.5 + 0.5*v;\n    v = pow(v+0.35,7.0);\n    return v;\n}\n\n//from bookofshaders\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy/iResolution.x;\n\tfloat offset = 0.9*simplex3d(vec3(9.*p+vec2(0.,-0.3*iTime),0.2*iTime))*clamp((2.0-5.*length(p-vec2(0.5,0.25))),0.,2.) + 10.*length(p-vec2(0.5,0.25));\n    //float offset2 = simplex3d(vec3(123)+vec3(10.*p+vec2(-1.*iTime,0),0.5*iTime));\n    \n    float change = 9.0;\n    \n    float scl = 5.;\n    \n    float value = simplex3d(vec3(change*(iTime-offset),scl*p.x,scl*p.y));\n\tfloat value2 = simplex3d(vec3(1.1*change*(iTime-offset),123.+scl*p.x,scl*p.y));\n    float value3 = simplex3d(vec3(1.5*change*(iTime-offset),1234.+scl*p.x,scl*p.y));\n    //float value4 = simplex3d(vec3(1.5*change*(iTime-offset),3234.+scl*p.x,scl*p.y));\n    \n\tvalue = transformValue(value);\n    value2 = transformValue(value2);\n    value3 = transformValue(value3);\n\t\n    vec3 color0 = vec3(value+value2,value2+0.*value3,value3+value);\n    \n    vec3 rgb = clamp(color0,0.,1.);\n    \n    vec3 hsb = rgb2hsb(rgb);\n    \n    hsb.x += 0.3*sin(13.*length(p-vec2(0.5,0.25))-1.*iTime)+0.15*iTime;\n    \n    hsb.x = mix(hsb.x,0.5,0.7);\n    \n    hsb.y += 0.2*sin(14.*length(p-vec2(0.5,0.25))-1.1*iTime+0.5)-0.4;\n                \n    rgb = hsb2rgb(hsb);\n    \n\tfragColor = vec4(rgb,1.0);\n\treturn;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lG3Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 206, 228, 228, 401], [508, 531, 556, 809, 1726], [1729, 1729, 1759, 1759, 1821], [1823, 1844, 1870, 1870, 2300], [2302, 2376, 2402, 2402, 2634], [2636, 2636, 2693, 2693, 3882]], "test": "untested"}
{"id": "3lG3WR", "name": "Gears using involute SDF", "author": "Pidhorskyi", "description": "More or less accurate gear geometry. The shape of the cogs is made using an SDF for an involute.", "tags": ["gears", "involute"], "likes": 14, "viewed": 553, "published": 3, "date": "1578592688", "time_retrieved": "2024-07-30T21:30:53.492583", "image_code": "/* \"Gears using involute SDF\" by Stanislav Pidhorskyi - 2020\n * License Creative Commons Attribution 4.0 International License.\n * Contact: stpidhorskyi@mix.wvu.edu\n */\n\n\nfloat Union(float a, float b)\n{\n\treturn min(a, b);\n}\n\nfloat SmoothUnion(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat Substraction(float a, float b)\n{\n    return max(a,-b);\n}\n\nfloat Intersection(float a, float b)\n{\n    return max(a,b);\n}\n\nfloat SmoothIntersection(float a, float b, float k)\n{\n    return Substraction(Intersection(a, b), SmoothUnion(Substraction(a, b), Substraction(b, a), k));\n}\n\nfloat Circle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat Circle(float rho, float r)\n{\n\treturn rho - r;\n}\n\nfloat Gear(vec2 p, float D, float N, float psi, float alpha, float dir)\n{\n    float R = D / 2.0;\n    /* The Pitch Circle Diameter is the diameter of a circle which by a pure rolling action would transmit \n     * the same motion as the actual gear wheel. It should be noted that in the case of wheels which connect\n     * non-parallel shafts, the pitch circle diameter is different for each cross section of the wheel\n     * normal to the axis of rotation.\n     */\n\n    float rho = length(p);\n    \n    float Pd = N / D; // The Diametral Pitch, p_d is the number of teeth per unit length of diameter\n\n    float P = 3.1416 / Pd; // Circular Pitch\n    /* The Circular Pitch, p is the length of arc round the pitch circle between corresponding points \n     * on adjacent teeth.\n     */\n\n    float a = 1.0 / Pd; // Addendum\n    /* The Addendum is the radial length of a tooth from the pitch circle to the tip of the tooth.\n     */\n\n    float Do = D + 2.0 * a; // Outside Diameter\n    float Ro = Do / 2.0; \n\n    float h = 2.2 / Pd;\n\n    float innerR = Ro - h - 0.4;\n    \n    // Early exit\n    if (innerR - rho > 0.0)\n        return innerR - rho;\n    \n    // Early exit\n    if (Ro - rho < -0.2)\n        return rho - Ro;\n    \n    float Db = D * cos(psi); // Base Diameter \n    float Rb = Db / 2.0; \n\n    float fi = atan(p.y, p.x) * dir + alpha;\n    \n    float alphaStride = P / R;\n    \n    float invAlpha = acos(Rb / R);\n    float invPhi = tan(invAlpha) - invAlpha;\n    \n    float shift = alphaStride / 2.0 - 2.0 * invPhi;\n    \n    float fia = mod(fi + shift / 2.0, alphaStride) - shift / 2.0;\n    float fib = mod(-fi - shift + shift / 2.0, alphaStride) - shift / 2.0;\n    \n    float dista = -1.0e6;\n    float distb = -1.0e6;\n    \n    if (Rb < rho)\n    {\n        float acos_rbRho = acos(Rb/rho);\n        \n        float thetaa = fia + acos_rbRho;\n        float thetab = fib + acos_rbRho;\n\n        float ta = sqrt(rho * rho - Rb * Rb);\n\n        // https://math.stackexchange.com/questions/1266689/distance-from-a-point-to-the-involute-of-a-circle\n        dista = ta - Rb * thetaa;\n        distb = ta - Rb * thetab;\n    }\n    \n    float gearOuter = Circle(rho, Ro);\n    float gearBase = Circle(rho, Rb);\n    float gearLowBase = Circle(rho, Ro - h);\n    float crownBase = Circle(rho, innerR);\n    \n    float cogs = Intersection(dista, distb);\n    \n    float baseWalls = Intersection(fia - (alphaStride - shift), fib - (alphaStride - shift));\n    \n    cogs = Intersection(baseWalls, cogs);\n    cogs = SmoothIntersection(gearOuter, cogs, 0.01);\n    cogs = SmoothUnion(gearLowBase, cogs, Rb - Ro + h);\n    \n    cogs = Substraction(cogs, crownBase);\n    return cogs;\n}\n\nfloat Alpha(float d)\n{\n    d *= iResolution.y / 2.0;\n\treturn clamp(-d + 0.7, 0.0, 1.0);\n}\n\n\nfloat AO(float d, float height)\n{\n    return 1.0 - atan(height, d) / 3.14159;\n}\n\nfloat SDF(vec2 p)\n{\n    float N = pow(2.0, mod(floor(iTime / 15.0), 4.0)) * 4.0 + 9.0; // Number of Teeth\n    float psi = 3.096e-5 * N * N -6.557e-3 * N + 0.551;// Pressure Angle\n\t/* The Pressure Angleor Angle of Obliquity  Psi is the angle \n \t * between the common normal LM and the tangent at the pitch point\n \t */\n    float D = 2.8;\n        \n    float gearA = Gear(p + vec2(1.5, 0.0), D, N, psi, iTime / 4.0, 1.0);\n    float gearB = Gear(p + vec2(1.5 - D, 0.0), D, N, psi, iTime / 4.0, -1.0);\n    float dist = Union(gearA, gearB);\n    return dist;\n}\n\nvec2 normal(vec2 p, float dist)\n{\n\tfloat dx = SDF(p + vec2(0.0, 1.0) / iResolution.yy) - dist;\n\tfloat dy = SDF(p + vec2(1.0, 0.0) / iResolution.yy) - dist;\n    return normalize(vec2(dx, dy));\n}\n\nvec3 Render(vec2 p)\n{\n\t// gradient\n\tvec3 color = vec3(0.55, 0.5, 0.45) * (1.3 - length(p / 2.0 / iResolution.xy * iResolution.yy));\n  \n\tcolor = mix(color, vec3(0.1, 0.1, 0.2), 0.2 * Alpha(0.5 * SDF((p - vec2(1.0, 0.0)) / 2.0)));\n    \n    float dist = SDF(p);\n    \n\tcolor *= AO(dist, 0.2);\n    \n\tcolor = mix(color, vec3(0.1, 0.1, 0.1), Alpha(dist));\n    \n    #ifdef ADD_SPECULAR\n    if (dist < 0.0)\n    {\n    \tvec2 n = normal(p, dist);\n        vec3 nn = normalize(vec3(n, -dist * 200.1));\n        \n        float s = dot(nn, normalize(vec3(1.0, 1.0, 1.0)));\n        \n        s = pow(max(s, 0.0), 20.0);\n        \n    \tcolor += vec3(s) * clamp(-dist * iResolution.y / 4.0, 0.0, 1.0);\n    }\n    #endif\n        \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = (fragCoord.xy  + vec2(0.5)) / iResolution.yy;\n    vec2 p = uv.xy * vec2(2.0) - vec2(1.0);\n\tfragColor = vec4(pow(Render(p), vec3(1.0 / 2.2)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lG3WR.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[171, 171, 202, 202, 223], [225, 225, 271, 271, 372], [374, 374, 412, 412, 436], [438, 438, 476, 476, 499], [501, 501, 554, 554, 657], [659, 659, 690, 690, 715], [717, 717, 751, 751, 770], [772, 772, 845, 845, 3423], [3425, 3425, 3447, 3447, 3514], [3517, 3517, 3550, 3550, 3596], [3598, 3598, 3617, 3617, 4150], [4152, 4152, 4185, 4185, 4345], [4347, 4347, 4368, 4381, 5072], [5074, 5074, 5131, 5131, 5295]], "test": "untested"}
{"id": "WlyGWR", "name": "Millennial Tie Dye", "author": "wyatt", "description": "fun", "tags": ["blackmagic"], "likes": 14, "viewed": 503, "published": 3, "date": "1578591161", "time_retrieved": "2024-07-30T21:30:54.254546", "image_code": "Main\n{\n    vec4 a = A(U);\n\tQ = a.xzyw*0.5+.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define Main void mainImage( out vec4 Q, in vec2 U )\n\n#define Them vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n\n#define ro(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat an (vec2 a, vec2 b) {\n\treturn atan(a.x*b.y-a.y*b.x,dot(a.xy,b.xy));\n}", "buffer_a_code": "Main\n{\n    U -= 0.49*R;\n    U *= (1.-.005*length(U)/R.x)*ro(.001);\n    U += 0.49*R;\n\tQ = A(U);\n    Them;\n    Q += .3*(m-Q);\n    Q.xy *= ro(.02*(n.w-s.w+e.z-w.z));\n    if (length(Q.xy)>0.)Q.xy = normalize(Q.xy);\n    Q.zw += vec2(an(e.xy,w.xy),an(n.xy,s.xy));\n    if (length(Q.zw)>0.)\n    \tQ.zw = mix(Q.zw,normalize(Q.zw),.8);\n    if (iMouse.z>0.&&length(U-iMouse.xy)<30.)\n        Q.xy *= ro(.1);\n\n    if (iFrame <1) Q = vec4(sin(.1*U.y),cos(.1*U.x),0,0);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n{\n    U -= 0.49*R;\n    U *= (1.-.005*length(U)/R.x)*ro(.001);\n    U += 0.49*R;\n\tQ = A(U);\n    Them;\n    Q += .3*(m-Q);\n    Q.xy *= ro(.02*(n.w-s.w+e.z-w.z));\n    if (length(Q.xy)>0.)Q.xy = normalize(Q.xy);\n    Q.zw += vec2(an(e.xy,w.xy),an(n.xy,s.xy));\n    if (length(Q.zw)>0.)\n    \tQ.zw = mix(Q.zw,normalize(Q.zw),.8);\n    if (iMouse.z>0.&&length(U-iMouse.xy)<30.)\n        Q.xy *= ro(.1);\n\n    if (iFrame <1) Q = vec4(sin(.1*U.y),cos(.1*U.x),0,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n{\n    U -= 0.49*R;\n    U *= (1.-.005*length(U)/R.x)*ro(.001);\n    U += 0.49*R;\n\tQ = A(U);\n    Them;\n    Q += .3*(m-Q);\n    Q.xy *= ro(.02*(n.w-s.w+e.z-w.z));\n    if (length(Q.xy)>0.)Q.xy = normalize(Q.xy);\n    Q.zw += vec2(an(e.xy,w.xy),an(n.xy,s.xy));\n    if (length(Q.zw)>0.)\n    \tQ.zw = mix(Q.zw,normalize(Q.zw),.8);\n    if (iMouse.z>0.&&length(U-iMouse.xy)<30.)\n        Q.xy *= ro(.1);\n\n    if (iFrame <1) Q = vec4(sin(.1*U.y),cos(.1*U.x),0,0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n{\n    U -= 0.49*R;\n    U *= (1.-.005*length(U)/R.x)*ro(.001);\n    U += 0.49*R;\n    U -= A(U).xy;\n\tQ = A(U);\n    Them;\n    Q += .3*(m-Q);\n    Q.xy *= ro(.02*(n.w-s.w+e.z-w.z));\n    if (length(Q.xy)>0.) Q.xy = normalize(Q.xy);\n    Q.zw += vec2(an(e.xy,w.xy),an(n.xy,s.xy));\n    if (length(Q.zw)>0.)\n    \tQ.zw = mix(Q.zw,normalize(Q.zw),.8);\n    if (iMouse.z>0.&&length(U-iMouse.xy)<30.)\n        Q.xy *= ro(.1);\n\n    if (iFrame <1) Q = vec4(sin(.1*U.y),cos(.1*U.x),0,0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyGWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wtK3Rm", "name": "ReactionDiffusion 10 : Attractor", "author": "aiekick", "description": "drawing => mouse\nspace => reset", "tags": ["diffusion", "10", "reaction"], "likes": 12, "viewed": 464, "published": 3, "date": "1578589961", "time_retrieved": "2024-07-30T21:30:55.013517", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2019 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// tuned with NoodlesPlate : https://github.com/aiekick/NoodlesPlate\n\nvoid mainImage( out vec4 fragColor, in vec2 g )\n{\n    vec2 s = iResolution.xy;\n\tvec2 v = (g+g-s)/s.y;\n    float a = atan(v.x,v.y) + length(v) * 4. - iTime * 2.;\n    float cc = get(iChannel0, g, iResolution.xy, 0., 0.).r;\n    float cc2 = get(iChannel0, g, iResolution.xy, cos(a)*.8, sin(a)*.8).r;\n    fragColor = vec4(uColorBG,1)*vec4(cc*cc);\n\tfragColor = fragColor * .2 + fragColor.grba * .3;\n    fragColor += vec4(uColorLight,1)*max(cc2*cc2*cc2 - cc*cc*cc, 0.0)*iResolution.y*0.2;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 f, in vec2 g )\n{\n    f = frag(iChannel0, g, iResolution.xy, iFrame, iMouse, iChannel1, iTime, iChannel2);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 f, in vec2 g )\n{\n    f = frag(iChannel0, g, iResolution.xy, iFrame, iMouse, iChannel1, iTime, iChannel2);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 f, in vec2 g )\n{\n    f = frag(iChannel0, g, iResolution.xy, iFrame, iMouse, iChannel1, iTime, iChannel2);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 f, in vec2 g )\n{\n    f = frag(iChannel0, g, iResolution.xy, iFrame, iMouse, iChannel1, iTime, iChannel2);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define TORUS_EMITER\n\n// default\nconst float uAA = 0.01131;\nconst float uBB = 0.04;\nconst float uCC = 1.75;\n//uniform sampler2D uCol;\nconst vec3 uColorBG = vec3(0.99999,0.999997,1);\nconst vec3 uColorLight = vec3(1,0.428571,0);\nconst vec2 uDiff = vec2(0.5068,0.7381);\nconst float uE = 1.75;\nconst float uLapCorner = 0.2;\nconst float uScale = 1.0013;\n//uniform sampler2D uSim;\n\n/* laplacian corner ratio */\t#define lc uLapCorner\n/* laplacian side ratio */ \t\t#define ls (1.0-uLapCorner)\n/* key space */ \t\t\t\t#define kbd_space 32\n\nvec4 get(sampler2D sam, vec2 g, vec2 s, float x, float y)\n{\n    g += vec2(x,y);\n\treturn texture(sam, g / s);\n}\n\nvec4 frag(\n    sampler2D sam, vec2 g, vec2 s, \n    int i, vec4 mo, sampler2D kbd, \n    float time, sampler2D noise)\n{\n\tg -= s * 0.5;\n\tg *= uScale;\n\tg += s * 0.5;\n\t\n    vec4 l \t= \tget(sam, g, s, -1. ,  0.);\n\tvec4 lt = \tget(sam, g, s, -1. ,  1.);\n\tvec4 t \t= \tget(sam, g, s,  0. ,  1.);\n\tvec4 rt = \tget(sam, g, s,  1. ,  1.);\n\tvec4 r \t= \tget(sam, g, s,  1. ,  0.);\n\tvec4 rb = \tget(sam, g, s,  1. , -1.);\n\tvec4 b \t= \tget(sam, g, s,  0. , -1.);\n\tvec4 lb = \tget(sam, g, s, -1. , -1.);\n\tvec4 c \t= \tget(sam, g, s,  0. ,  0.);\n\tvec4 lap = (l+t+r+b)/4.*ls + (lt+rt+rb+lb)/4.*lc - c; // laplacian\n\n\t// http://www.math.univ-toulouse.fr/~cbesse/teaching/M2/M2Mapi3/Projet.pdf\n\t// da = Du*lap + f(u,v);\n\t// db = Dv*lap + g(u,v);\n\t// GrayScott : Du!=0,Dv!=0\n\t// f(u,v) = F(1-u) - uv²\n\t// g(u,v) = uv² - (F+K)*v\n\t\n\tvec2 uv = g / s;\n\t\n\tfloat Du = uDiff.x;\n\tfloat Dv = uDiff.y;\n\tfloat re = c.x * c.y * c.y;\n    c.x += Du * lap.x + uAA * (1.0 - c.x) - re;\n\tc.y += Dv * lap.y + re - (uAA + uBB) * c.y;\n\t\n    float kbdValue = texelFetch(kbd, ivec2(kbd_space,1),0).x;\n    \n\tvec2 p = (g-s*0.5)/s.y;\n    float di = length(p)-0.45;\n    float da = abs(di)-0.01;\n    \n    if (i < 1)\tc = vec4(1,0,0,1);\n\tif (kbdValue > 0.) c = vec4(1,0,0,1);\n\tif (length(g - s * 0.5) < 5.) c = vec4(0,1,0,1);\n\t\n#ifdef TORUS_EMITER\n    if (da < 0.0 ) c = vec4(0,1,0,1);\n#endif\n    \n\tif (mo.z > 0.) \n\t{\n\t\tif (length(g - mo.xy) < 5.) \n\t\t\tc = vec4(0,1,0,1);\n\t}\n\t\n\treturn vec4(clamp(c.xy, 0., 1e1), 0, 1);\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtK3Rm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[226, 226, 275, 275, 709]], "test": "untested"}
{"id": "WlGGWR", "name": "Colored Spirals", "author": "aiekick", "description": "Colored Spiral", "tags": ["spiral", "colored"], "likes": 5, "viewed": 389, "published": 3, "date": "1578589752", "time_retrieved": "2024-07-30T21:30:55.760520", "image_code": "void mainImage( out vec4 f, in vec2 g )\n{\n\tvec2 s = iResolution.xy;\n\t\n\tvec2 p = (g-s*0.5)/s.y;\n\t\n\tfloat a = atan(p.x, p.y);\n    \n\tfloat l = log(length(p))-iTime;\n    \n\tfloat d = sin(a + 6.28318 * l);\n    \n\tfloat c = smoothstep(0.5-d, d+0.5, d*sin(d));\n\n    f = vec4(sin(vec3(8,12,10)*c),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGGWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 292]], "test": "untested"}
{"id": "tlV3zw", "name": "Nebula Contraction", "author": "BenoitArbelot", "description": "Fluid simulation to (artistically) represent a nebula contraction. Use mouse to locally speed up the contraction.\n\nFluid simulation from : [url]https://www.shadertoy.com/view/WdyGzy[/url]", "tags": ["fluid", "nebula", "contraction"], "likes": 5, "viewed": 491, "published": 3, "date": "1578578476", "time_retrieved": "2024-07-30T21:30:56.520488", "image_code": "// GET IMAGE FROM BUFFER B\n#define B(U) texture(iChannel0,(U)/R)\nvoid mainImage( out vec4 Q, vec2 U )\n{\n    Q = B(U);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// FLUID EVOLUTION\n#define T(U) texture(iChannel0,(U)/R)\n#define D(U) texture(iChannel1,(U)/R)\n#define B(U) texture(iChannel2,(U)/R)\n\n//Fluid coordinates are\n//x=right\n//y=left\n//z=up\n//w=down\n\n// TRANSLATE COORD BY Velocity THEN LOOKUP STATE\nvec4 A(vec2 U) {\n    U-=.5*v(T(U));\n    U-=.5*v(T(U));\n\treturn T(U);\n}\nvoid mainImage( out vec4 Q, in vec2  U)\n{\n    // THIS PIXEL\n    Q = A(U);\n    // NEIGHBORHOOD\n    vec4 \n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n    // GRADIENT of PRESSURE\n    float px = 0.25*(p(e)-p(w));\n    float py = 0.25*(p(n)-p(s)); \n    \n    \t\t// boundary Energy exchange in :   \n    Q += 0.25*(n.w + e.y + s.z + w.x)\n        \t// boundary Energy exchange out :\n        \t-p(Q)\n        \t// dV/dt = dP/dx,  dEnergy In dTime = dEnergy in dSpace\n        \t-vec4(px,-px,py,-py);\n    \n    // get value from picture buffer\n    float z = .8-length(B(U).xyz);\n    // some kind of viscosity thing \n    Q = mix(mix(Q,0.25*(n+e+s+w),.01),vec4(p(Q)),.01*(1.-z));\n    // gravity towards center\n    vec2 ToCenter = 1.0 * normalize(R * 0.5 - U);\n    float gravityStrength = 0.0002;\n    \n    //Increased gravity on mouse clic\n    if(iMouse.z>0.&&length(U-iMouse.xy)<R.y/5.)\n        gravityStrength = 0.005;\n    \n    Q.xy += gravityStrength*z*ToCenter.x*vec2(1,-1);\n    Q.zw += gravityStrength*z*ToCenter.y*vec2(1,-1);\n    \n    // Init with no velocity and some pressure\n    if (iFrame < 1) Q = vec4(.2);\n    // At boundarys turn all kinetic energy into potential energy\n    //if(U.x<3.||R.x-U.x<3.||U.y<3.||R.y-U.y<3.)Q = vec4(p(Q));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// TRANSLATE LOCATION FIELD WITH v(A(coord)), INIT WITH FragCoord\n#define A(U) texture(iChannel0,(U)/R)\n#define d(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n\nvec4 D(vec2 U) {\n    U-=.5*v(A(U));\n    U-=.5*v(A(U));\n\treturn d(U);\n}\nvoid mainImage( out vec4 Q, in vec2  U)\n{\n    Q = D(U);\n    \n    vec4 \n        q = A(U),\n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0)),\n        N = D(U+vec2(0,1)),\n        E = D(U+vec2(1,0)),\n        S = D(U-vec2(0,1)),\n        W = D(U-vec2(1,0));\n    Q += 0.25*((n.w-q.z)*(N-Q) + (e.y-q.x)*(E-Q) + (s.z-q.w)*(S-Q) + (w.x-q.y)*(W-Q));\n    \n    if (iFrame < 1) Q = vec4(U,0,0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n\n//Velocity\nvec2 v (vec4 b) {\n\treturn vec2(b.x-b.y,b.z-b.w);\n}\n\n// Pressure\nfloat p (vec4 b) {\n\treturn 0.25*(b.x+b.y+b.z+b.w);\n}", "buffer_b_code": "// LOOK UP PICTURE IN LOCATION FROM BUFFER D\n#define T(U) texture(iChannel0,(U)/R)\n#define D(U) texture(iChannel1,(U)/R)\nvoid mainImage( out vec4 Q, vec2 U )\n{\n    Q = texture(iChannel2,D(U).xy/R);\n}", "buffer_b_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlV3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 103, 103, 119]], "test": "untested"}
{"id": "wtV3zw", "name": "Color trail", "author": "icylavah", "description": "Press the mouse button to create color!", "tags": ["color", "hue"], "likes": 5, "viewed": 483, "published": 3, "date": "1578576727", "time_retrieved": "2024-07-30T21:30:57.271480", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 lastColor = texture(iChannel0, uv + vec2((fragCoord.x - iResolution.x * 0.5) * uv.y * uv.y, -150.0) / iResolution.xy * iTimeDelta).xyz;\n    \n    float dtt = iTimeDelta * 1.0;\n    lastColor = lastColor * (1.0 - dtt) + lastColor * lastColor * dtt;\n    if(iMouse.z > 0.5) {\n        float lerp = smoothstep(1.0, 0.2, distance(fragCoord, iMouse.xy) / 50.0);\n        lerp = -cos(3.14 * lerp) * 0.5 + 0.5;\n        float dtt = lerp * iTimeDelta * 20.0;\n        lastColor = hsl2rgb(mod(iTime * 0.5, 1.0), 0.5, 0.5) * dtt +\n            lastColor * (1.0 - dtt);\n    }\n    \n    fragColor = vec4(lastColor,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\n\nvec3 hsl2rgb(float h, float s, float l) {\n    return hsl2rgb(vec3(h, s, l));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtV3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "tly3RD", "name": "RayMarching Sample", "author": "challenge", "description": "A basic raymarching demo", "tags": ["raymarchingsdf"], "likes": 2, "viewed": 315, "published": 3, "date": "1578562581", "time_retrieved": "2024-07-30T21:30:58.021475", "image_code": "const vec3 ambientLight = vec3(0.1);\nconst vec3 specColor = vec3(0.04);\n\nconst float EPSILON = 0.00001;\n\nconst float UNITY_INV_PI = 0.31830988618f;\nconst float UNITY_PI = 3.14159265359f;\n\nconst int maxSteps = 256;\n\n#define SHOW_NORMAL 0\n#define SHOW_DEPTH 0\n#define SHOW_MATERIAL_BASECOLOR 0\n#define SHOW_MATERIAL_SMOTHNESS 0\n\n#define SHOW_FOG 1\n#define CAMERA_ROTATE 1\n#define LIGHT_ROTATE 0\n#define LIGHT_ADD 0\n\n#define SMOTHNESS_TEST 1\n\nfloat showNormal;\nfloat showDepth;\nfloat showReflection;\n\nstruct LightData\n{\n    vec3 pos;\n    float intensity;\n    vec3 color;\n};\n    \nLightData mainLight() {\n    LightData l;\n\n    l.intensity = 1.0;\n\tl.pos = vec3(30.32, 20.77, 0.56);\n    #if LIGHT_ROTATE\n    \tl.pos = vec3(30.32*sin(iTime), 20.77, 0.56*cos(iTime));\n    #endif\n    l.color = vec3(1.0, 1.0, 1.0) * l.intensity;\n    return l;\n}\n\nLightData addLight() {\n    LightData l;\n\n    l.intensity = 1.0;\n\tl.pos = vec3(-30.32, 20.77, 0.56);\n    l.color = vec3(0.2, 0.9, 0.67) * l.intensity;\n    return l;\n}\n\nstruct MaterialData\n{\n    vec3 diffColor;\n    float smoothness; \n};\n\nfloat sdPlane( vec3 p, vec3 o)\n{\n  return p.y;\n}\n\nfloat udBox( vec3 p, vec3 o, vec3 b )\n{\n  return length(max(abs(p - o)-b,0.0));\n}\n\nfloat sdSphere( vec3 p, vec3 o, float s )\n{\n  return length(p - o)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 sceneSDF(vec3 samplePoint) {\n    \n    vec2 res = vec2(1e10, 0.0);\n    \n    vec2 cube = vec2(udBox(samplePoint,vec3(-1.0, 0.8, 0.0), vec3(0.8)), 4.0);\n    vec2 sphere = vec2(sdSphere(samplePoint, vec3(2.0, 1.0, 2.0), 1.0), 2.0);\n    vec2 plane = vec2(sdPlane(samplePoint, vec3(0.0, 0.0, 0.0)), 0.0);\n    vec2 sphere2 = vec2(sdSphere(samplePoint, vec3(2.0, 1.0, -2.0), 1.0), 8.0);\n    \n\tres = opU(res, cube);\n    res = opU(res, sphere);\n    res = opU(res, sphere2);\n    res = opU(res, plane);\n    \n    return res;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nfloat DisneyDiffuse(float NdotV, float NdotL, float LdotH, float perceptualRoughness)\n{\n    float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n    // Two schlick fresnel term\n    float lightScatter   = (1.0 + (fd90 - 1.0) * pow(1.0 - NdotL, 5.0));\n    float viewScatter    = (1.0 + (fd90 - 1.0) * pow(1.0 - NdotV, 5.0));\n\n    return lightScatter * viewScatter;\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n    float a = roughness;\n    float lambdaV = NdotL * (NdotV * (1.0 - a) + a);\n    float lambdaL = NdotV * (NdotL * (1.0 - a) + a);\n    return 0.5f / (lambdaV + lambdaL + 1e-5f);\n}\n\nvec3 FresnelTerm (vec3 F0, float cosA)\n{\n    float t = pow(1.0 - cosA, 5.0);   // ala Schlick interpoliation\n    return F0 + (1.0-F0) * t;\n}\nvec3 FresnelLerp (vec3 F0, vec3 F90, float cosA)\n{\n    float t = pow(1.0 - cosA, 5.0);   // ala Schlick interpoliation\n    return mix (F0, F90, t);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (2.5-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h =sceneSDF( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 BRDF(LightData light, vec3 p, vec3 eye, vec3 rd, MaterialData mat)\n{\n    float smoothness = mat.smoothness;\n    vec3 diffColor = mat.diffColor * 0.96;\n    float perceptualRoughness = 1.0 - smoothness;\n    float roughness = perceptualRoughness * perceptualRoughness;\n    roughness = max(roughness, 0.002);\n    \n    float sd = calcSoftshadow(p, light.pos, 0.03, 2.5);\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(light.pos - p);\n    vec3 viewDir = normalize(eye - p);\n    vec3 H = normalize(L+viewDir);\n    vec3 R = normalize(reflect(-L, N));\n    \n    // 计算反射\n    vec3 ref = reflect(rd, N );\n    float dom = smoothstep( -0.2, 0.2, ref.y);\n    dom *= calcSoftshadow(p, ref, 0.2, 2.5);\n    \n  \n    //return vec3(dom);\n    vec3 reflectColor = smoothness*dom*vec3(0.40,0.60,1.30);\n    \n    if (showReflection > EPSILON) {\n\t\treturn reflectColor;\n    }\n    float NdotL = clamp(dot(N, L), 0.0, 1.0) * sd;\n    float NdotV = clamp(dot(N, viewDir), 0.0, 1.0);\n    float LdotH = clamp(dot(L, H), 0.0, 1.0);\n    float NdotH = clamp(dot(N, H), 0.0, 1.0);\n    \n    float diffuseTerm = DisneyDiffuse(NdotV, NdotL, LdotH, perceptualRoughness) * NdotL;\n    float D = GGXTerm (NdotH, roughness);\n    float V = SmithJointGGXVisibilityTerm (NdotL, NdotV, roughness);\n    float specularTerm = V*D * UNITY_PI;\n    specularTerm = max(0.0, specularTerm * NdotL);\n    \n    float surfaceReduction = 1.0 / (roughness*roughness + 1.0);\n    vec3 grazingTerm = vec3(clamp(smoothness + 0.04, 0.0, 1.0));\n    \n    vec3 color = diffColor *(ambientLight + light.color * diffuseTerm)\n        \t\t+ specularTerm * light.color * FresnelTerm (specColor, LdotH) \n        \t\t+ surfaceReduction * reflectColor * FresnelLerp (specColor, grazingTerm, NdotV);\n    \n    return color;\n}\n\nvec3 illumination (vec3 p, vec3 eye, vec3 rd, MaterialData mat)\n{\n\tLightData light1 = mainLight();\n    \n    vec3 color = BRDF(light1, p, eye, rd, mat);\n    \n    #if LIGHT_ADD\n    \tLightData light2 = addLight();\n        vec3 addColor = BRDF(light2, p, eye, rd, mat);\n        color += addColor;\n    #endif\n    \n    return color;\n}\n\nvec3 ACESToneMapping(vec3 color, float adapted_lum)\n{\n\tconst float A = 2.51f;\n\tconst float B = 0.03f;\n\tconst float C = 2.43f;\n\tconst float D = 0.59f;\n\tconst float E = 0.14f;\n \n\tcolor *= adapted_lum;\n\treturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n\n\nfloat checkers( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod(q.x+q.y,2.);\n}\n\nMaterialData GetDiffColor(vec3 p, float m) \n{\n    MaterialData material;\n    if (m < EPSILON) {\t\n        material.diffColor = checkers(p.xz) * vec3(0.5, 0.0, 0.0);\n        material.smoothness = 1.0;\n    } else if (m - 2.0 < EPSILON) {\n        material.diffColor = vec3(0.0, 0.5, 0.0) ;\n        material.smoothness = 0.9;\n        #if SMOTHNESS_TEST\n        \tmaterial.smoothness = abs(sin(iTime));\n        #endif\n        \n    } else if (m - 4.0 < EPSILON) {\n        material.diffColor = vec3(0.0, 0.0, 0.5) ;\n        material.smoothness = 0.2;\n    } else if (m - 8.0 < EPSILON) {\n        material.diffColor = vec3(0.98, 0.51, 0.91) ;\n        material.smoothness = 0.2;\n    } else {\n        material.diffColor = vec3(0.5);\n    \tmaterial.smoothness = 0.5;\n    }\n    \n    return material;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv1 = fragCoord/iResolution.xy;\n\tvec2 uv = 2.0 * uv1;\n    //vec2 uv = uv1;\n    uv = fract(uv);\n\tuv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv1 -= .5;\n    uv1.x *= iResolution.x / iResolution.y;\n\n    showNormal = step(uv1.x, 0.0) * step(uv1.y, 0.0);\n    showDepth = step(-uv1.x, 0.0) * step(uv1.y, 0.0);\n    showReflection = step(-uv1.x, 0.0) * step(-uv1.y, 0.0);\n   \n    // 设置相机位置\n    vec3 ro = vec3(6.0,6.0, -6.0);\n    //ro += vec3( 4.5*cos(0.1*iTime + 16.0), 1.0 + 2.0, 4.5*sin(iTime + 16.0) );\n    #if CAMERA_ROTATE\n        ro = vec3(10.5*cos(iTime * 0.2), 5.0, -10.5*sin(iTime * 0.2));\n    #endif\n    \t\n\n    float zoom = 1.0;\n   \t// 设置看向的点\n    vec3 lookAt = vec3(0.5, 0.5, 0.5);\n    \n    // 格拉姆—施密特正交化\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0.0, 1.0, 0.0), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    // 将2纬UV 升到 3纬坐标\n    vec3 i = c + uv.x*r + uv.y*u;\n    // 得到相机指向UV点的向量\n\tvec3 rd = i - ro;\n    \n    vec4 color = vec4(0.0);\n    \n    // Ray Marching\n    float t = 0.0;\n    \n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n       \t\n        vec2 res = sceneSDF(p);\n        float d = res.x;\n        float m = res.y;\n        \n        if(d < EPSILON)\n        {\n            if (showNormal > EPSILON) {\n                color.rgb = (estimateNormal(p) + 1.0) * 0.5;\n            } else if (showDepth > EPSILON) {\n                color.rgb = vec3(t/20.0);\n            } else {\n                \n                // 获取命中物体的材质属性\n                MaterialData mat = GetDiffColor(p, m);\n\n                #if SHOW_MATERIAL_BASECOLOR\n                color.rgb = pow(mat.diffColor, vec3(0.4545));\n                #elif SHOW_MATERIAL_SMOTHNESS\n                color.rgb = vec3(mat.smoothness);\n                #else\n                // 渲染\n                color.rgb += illumination(p, ro, rd, mat);\n                #endif\n            }\n            \t\n\n            \n\n            \n            break;\n        }\n\n        float add = d;\n        \n        t += add;\n        \n        #if SHOW_FOG\n        \tcolor.rgb = mix( color.rgb, vec3(0.9), 1.0-exp( -0.00001*t*t ) );\n        #endif\n        \n    }\n    \n    // Tonemapping\n    color.rgb = ACESToneMapping(color.rgb, 1.0);\n    // 抵消屏幕Gamma矫正\n    color.rgb = pow( color.rgb, vec3(0.4545) );\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[576, 576, 599, 599, 833], [835, 835, 857, 857, 1000], [1071, 1071, 1103, 1103, 1119], [1121, 1121, 1160, 1160, 1202], [1204, 1204, 1247, 1247, 1275], [1277, 1277, 1307, 1307, 1340], [1342, 1342, 1375, 1375, 1860], [1862, 1862, 1891, 1891, 2213], [2215, 2215, 2302, 2302, 2588], [2590, 2590, 2636, 2636, 2955], [2957, 2957, 3036, 3036, 3216], [3218, 3218, 3258, 3258, 3358], [3359, 3359, 3409, 3409, 3508], [3510, 3510, 3588, 3611, 4000], [4002, 4002, 4075, 4075, 5765], [5767, 5767, 5832, 5832, 6095], [6097, 6097, 6150, 6150, 6364], [6367, 6367, 6396, 6396, 6449], [6451, 6451, 6496, 6496, 7236], [7239, 7239, 7296, 7296, 9751]], "test": "untested"}
{"id": "WlVGzw", "name": "Gravifluid", "author": "michael0884", "description": "Wave fluid interacting with a scalar grav field", "tags": ["waves", "fluid", "nonlinear"], "likes": 18, "viewed": 524, "published": 3, "date": "1578534166", "time_retrieved": "2024-07-30T21:30:58.791416", "image_code": "// Fork of \"Oil and water\" by michael0884. https://shadertoy.com/view/wtVGzW\n// 2020-01-09 01:38:11\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    vec4 Q = pixel(ch0, p);\n    vec4 Qv = pixel(ch1, p);\n    \n    \n    vec2 g = 0.1*normalize(Grad(ch0, p));\n    vec3 v = vec3(g,  sqrt(1.-sq(g)) );\n    vec3 col = texture(ch2, v).xyz;\n    //fluid 1 amplitude\n    float fd1 = smoothstep(0.0, 0.7, 1.*dot(Q.xy,Q.xy)/sq(a1)) * ( 1. + 0.001*p.y);\n    //fluid 2 amplitude\n    float fd2 = log(Q.z*Q.z+1.);\n\n    // Output to screen\n    fragColor.xyz = col*(sin(vec3(1., 1., 0.)*fd1) + sin(vec3(0., 0.3, 1.)*fd2));\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p-0.5),0)\n#define s2d iResolution.xy\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define dt 0.5\n\n\nconst float scale = .6;\n//fluid 1 density \nconst float a1 = 0.8;\n//fluid 2 density\nconst float a2 = 1.;\n\n#define sign vec4(1.,1.,1,1.)\n\n//set to 0 if you want a gas-like behaviour\n//fluid 1 fluid-like/gas-like regulator \nconst float b1 = 0.99;\n//fluid 2 fluid-like/gas-like regulator \nconst float b2 = 0.;\n\n//interaction energy cost\nconst float ie = -0.1;\n\n//initial conditions for amplitudes\nconst float amp = 0.6;\nconst vec4 fluid1_Q = amp*vec4(a1,0,0,0);\nconst vec4 fluid1_Qv = amp*vec4(0,a1,0,0); //minus for antifluid\nconst vec4 fluid2_Q = 0.*amp*vec4(0,0,a2,0);\nconst vec4 fluid2_Qv = 0.*amp*vec4(0,0,0,a2);\nconst float mouser = 25.;\nconst float initr = 20.;\n\n\nfloat sq(float x){ return x*x; }\nfloat cb(float x){ return x*x*x; }\nfloat sq(vec2 x){ return dot(x,x); }\n\nconst float pressure = 0.001;\n\n//wave potential\nfloat P(vec4 Q, vec2 p)\n{\n    //fluid 1 amplitude\n    float fd1 = length(Q.xy);\n    //fluid 2 amplitude\n    float fd2 = length(Q.zw);\n    \n    //liquifier term 1\n    float liq1 = 1. - b1*exp(-3.*sq(fd1-a1));      \n    //liquifier term 2\n    float liq2 = 1. - b2*exp(-3.*sq(fd2-a2));     \n    float grav = 0.002*length(p - vec2(400,225));\n        \n    float E =(scale*(cb(fd1)*liq1)*(1. - tanh(0.15*Q.z)) + 0.000*sq(Q.z));\n    return 20.*tanh(0.05*E);\n}\n\n//force\n#define d 0.001\nvec4 F(vec4 Q, vec2 p)\n{\n    vec3 dx = 0.5*vec3(-d,0.,d);\n    return vec4(P(Q + dx.zyyy, p) - P(Q + dx.xyyy, p),\n                P(Q + dx.yzyy, p) - P(Q + dx.yxyy, p),\n                P(Q + dx.yyzy, p) - P(Q + dx.yyxy, p),\n                P(Q + dx.yyyz, p) - P(Q + dx.yyyx, p))/d;\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n\nfloat dborder(vec2 x, vec2 s)\n{\n    return min(min(min(x.x, x.y), s.x-x.x),s.y-x.y);\n}\n", "buffer_a_code": "void mouse(inout vec4 Q, inout vec4 Qv, vec2 p)\n{\n    if(iMouse.z > 0.)\n    {\n        float f1 = exp(-sq((p-iMouse.xy)/mouser));\n        Q += 0.1*fluid1_Q*f1;\n        Qv += 0.1*fluid1_Qv*f1;\n    }\n}\n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    //get old value\n    Q = texel(ch0, p);\n    vec4 Qv = texel(ch1, p);\n    \n    Q += Qv*dt + vec4(0.0001,0.0001,0.001,0.001)*Laplace(ch0, p);\n   \n    mouse(Q,Qv,p);\n    \n    Q.z *= 1.-0.1*exp(-0.002*sq(dborder(p, s2d)));\n    \n    if(iFrame < 1) \n    {\n        float f1 = step(sq((p-s2d*0.3)/initr),1.);\n        float f2 = step(sq((p-s2d*0.7)/initr),1.);\n        Q = fluid1_Q*f1*(1.-f2) + fluid1_Q*f2*(1.-f1);\n    }\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mouse(inout vec4 Q, inout vec4 Qv, vec2 p)\n{\n    if(iMouse.z > 0.)\n    {\n        float f1 = exp(-sq((p-iMouse.xy)/mouser));\n        Q += 0.1*fluid1_Q*f1;\n        Qv += 0.1*fluid1_Qv*f1;\n    }\n}\n\n\nvoid mainImage( out vec4 Qv, in vec2 p )\n{\n    //get old value\n    vec4 Q = texel(ch0, p);\n    Qv = texel(ch1, p);\n    \n   \tQv += dt*(Laplace(ch0, p) - sign*F(Q, p));\n    \n    mouse(Q,Qv,p);\n    \n    if(iFrame < 1) \n    {\n        float f1 = step(sq((p-s2d*0.3)/initr),1.);\n        float f2 = step(sq((p-s2d*0.7)/initr),1.);\n        Qv = fluid1_Qv*f1*(1.-f2) + fluid1_Qv*f2*(1.-f1);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mouse(inout vec4 Q, inout vec4 Qv, vec2 p)\n{\n    if(iMouse.z > 0.)\n    {\n        float f1 = exp(-sq((p-iMouse.xy)/mouser));\n        Q += 0.1*fluid1_Q*f1;\n        Qv += 0.1*fluid1_Qv*f1;\n    }\n}\n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    //get old value\n    Q = texel(ch0, p);\n    vec4 Qv = texel(ch1, p);\n    \n    Q += Qv*dt + 0.0005*Laplace(ch0, p);\n   \n    mouse(Q,Qv,p);\n    \n    if(iFrame < 1) \n    {\n        float f1 = step(sq((p-s2d*0.3)/initr),1.);\n        float f2 = step(sq((p-s2d*0.7)/initr),1.);\n        Q = fluid1_Q*f1*(1.-f2) + fluid1_Q*f2*(1.-f1);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mouse(inout vec4 Q, inout vec4 Qv, vec2 p)\n{\n    if(iMouse.z > 0.)\n    {\n        float f1 = exp(-sq((p-iMouse.xy)/mouser));\n        Q += 0.1*fluid1_Q*f1;\n        Qv += 0.1*fluid1_Qv*f1;\n    }\n}\n\n\nvoid mainImage( out vec4 Qv, in vec2 p )\n{\n    //get old value\n    vec4 Q = texel(ch0, p);\n    Qv = texel(ch1, p);\n    \n   \tQv += dt*(Laplace(ch0, p) - sign*F(Q, p));\n    \n    mouse(Q,Qv,p);\n    \n    if(iFrame < 1) \n    {\n        float f1 = step(sq((p-s2d*0.3)/initr),1.);\n        float f2 = step(sq((p-s2d*0.7)/initr),1.);\n        Qv = fluid1_Qv*f1*(1.-f2) + fluid1_Qv*f2*(1.-f1);\n    }\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 150, 150, 609]], "test": "untested"}
{"id": "wtG3zw", "name": "Joseph Albers, Squares 2", "author": "danamuise", "description": "By Dana Muise. Inspired by Joseph Albers' Book \"The interaction of Color:  color intervals and transformation interaction of color figure xiv-2\"\nCredit to FabriceNeyret2 for rotation snippet, Beefburrito and CGK_4 v1.1 for polygon functions", "tags": ["colortheory", "josephalbers", "interactionofcolor"], "likes": 2, "viewed": 2639, "published": 3, "date": "1578531137", "time_retrieved": "2024-07-30T21:30:59.551384", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define rotate(a)  mat2(cos(a), -sin(a), sin(a), cos(a))\n\n//Draw background\nvec3 DrawBox(vec2 uv, float L, float R, float B, float T, vec3 col){\n\tvec3 colorBox = vec3(0.0);\n    \n    if (uv.x>L && uv.x<R && uv.y>B && uv.y<T) {\n       colorBox = vec3(col.r/255.0,col.g/255.0,col.z/255.0);\n    }\n    return colorBox; \n}\n\n//POLYGON FUNCTION\nfloat polygon(vec2 uv, vec2 pos, float size, float blur, int sides){\n    uv = uv-pos;\n    //Angle and radius of polygon\n    float angle = atan(uv.x,uv.y)+PI;\n    float rad = TWO_PI/float(sides);\n    float dist = cos(floor(0.5+angle/rad)*rad-angle)*length(uv);\n    float poly = smoothstep(size, size-blur, dist);\n    \n    return poly;\n}\n\n//spinning function\nmat2 spinspin(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n//Draw box\nvec4 DrawRectangle(vec4 try,vec2 uv){\n\n    vec2 translate = vec2(cos(iTime));\n    //uv += translate*0.15;\n    uv = spinspin(sin(iTime))*uv;\n    float rectangle = polygon(uv, vec2(0.0,0.0), 0.45, 0.009, 4);\n    \n    float pct = abs(sin(iTime*.25));\n    \n    vec3 colorA = vec3(0.149,0.141,0.912);\n\tvec3 colorB = vec3(1.000,0.833,0.224);\n    \n    vec3 rColor = mix(colorA, vec3(0.0,0.5,0.0), pct) * rectangle;\n    try = vec4(rColor,1.0);\n    \n    return try;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 colorA = vec3(168.0, 48.0, 41.0);\n\tvec3 colorB = vec3(221.0, 64.0, 54.0);\n    vec3 colorC = vec3(221.0, 130.0, 125.0);\n\tvec3 colorD = vec3(221.0, 91.0, 82.0);\n    vec3 colorA1 = vec3(0.0, 110.0, 222.0);\n\tvec3 colorB1 = vec3(0.0, 126.0, 255.0);\n    vec3 colorC1 = vec3(63.0, 158.0, 255.0);\n\tvec3 colorD1 = vec3(107.0, 180.0, 255.0);\n    float pct = abs(sin(iTime*.25));\n    \n    // fill top left\n   vec3 color = DrawBox(uv, 0.0, 0.5, 0.5, 1.0, mix(colorA, colorA1, pct));\n    \n    // fill bottom left\n    color += DrawBox(uv, 0.0, 0.5, 0.0, 0.5, mix(colorB, colorB1, pct));\n\n    // fill top right\n    color += DrawBox(uv, 0.5, 1.0, 0.5, 1.0, mix(colorC, colorC1, pct));\n    \n    // fill bottom right\n    color += DrawBox(uv, 0.5, 1.0, 0.0, 0.5, mix(colorD, colorD1, pct));\n    \n    if (uv.x>0.30 && uv.x<0.7 && uv.y>0.20 && uv.y<0.80) {\n       //color /= rectColor;\n    }\n    \n    uv -= 0.5; // move center\n    uv.x *= iResolution.x/iResolution.y;\n  \n\tfragColor+= DrawRectangle(fragColor, uv);\n    fragColor += vec4(color, 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 130, 198, 198, 370], [372, 391, 459, 459, 726], [728, 748, 776, 776, 862], [864, 875, 912, 912, 1333], [1336, 1336, 1393, 1443, 2527]], "test": "untested"}
{"id": "wtV3RD", "name": "Roller Coaster", "author": "Plento", "description": "Roller coaster shaderrr.", "tags": ["2d", "cartoon", "derivative", "rollercoaster"], "likes": 20, "viewed": 637, "published": 3, "date": "1578526935", "time_retrieved": "2024-07-30T21:31:00.385155", "image_code": "// Plento\n\nvec2 R;\n#define st(a, b, t) smoothstep(a, b, t)\n\nvec2 rot(vec2 p, float a){\n \treturn vec2(p.x*cos(a) - p.y*sin(a), p.x*sin(a) + p.y*cos(a));   \n}\n\nfloat height(float x){\n    return sin(x*2.)*.15 + sin(x*3.)*.13 + sin(x*6.)*.02;\n}\n\n\nfloat aDx(float x){\n    float h = .001;\n    float y = height(x+h) - height(x);\n    return atan(y, h);\n}\n\nfloat box(vec2 uv, vec2 dim, float b){\n    uv = abs(uv);\n    float bx = st(b, -b, uv.y - dim.y);\n    bx *= st(b, -b, uv.x - dim.x );\n    return bx;\n}\nfloat circle(vec2 uv, float r, float b){\n \treturn st(r + b, r - b, length(uv));   \n}\nfloat rtr(vec2 uv, vec2 scale, float h,  float b){\n    uv.y -= h;\n    uv *= scale;\n    \n    float tri = st(b, -b, dot(uv, vec2(1., 1.)));\n    tri *= st(-b, b, uv.y + h);\n    tri *= st(-b, b, uv.x);\n    \n    return tri;\n}\n\nvec4 track(vec2 uv){\n    float b = .01;\n    float trk = .0;\n    float sup = .0;\n    \n    trk += st(-.005, .005, uv.y + height(uv.x) + .007);\n    trk *= st(.005, -.005, uv.y + height(uv.x) - .007);\n    \n    vec2 ruv = fract(uv*8.) - .5;\n    \n    sup += st(.08, .07, abs(dot(ruv, vec2(1., 1.))));\n    sup += st(.08, .07, abs(dot(ruv, vec2(-1., 1.))));\n    sup *= st(.001, -.001, uv.y + height(uv.x)+.007);\n    \n    vec3 col = vec3(.7, .7, .7)*trk;\n    \n    return vec4(col, trk + sup);\n}\n\n\nvec4 car(vec2 uv){\n    float b = .02;\n    \n    vec3 col = vec3(0);\n    float a = 0.;\n    float wheel = 0.;\n    \n    a += box(uv, vec2(.7, .1), b);\n    a += box(uv, vec2(0.75, .06), b);\n    a += box(uv - vec2(0., .2), vec2(.5, .1), b);\n    a += box(uv - vec2(0., -.2), vec2(.5, .1), b);\n    \n    a += rtr(vec2(-uv.x, uv.y)-vec2(.5, .1), vec2(1., 1.), .2, b);\n    a += rtr(vec2(-uv.x, -uv.y)-vec2(.5, .1), vec2(1., 1.), .2, b);\n    \n    a += rtr(vec2(uv.x, uv.y)-vec2(.5, .1), vec2(1., 1.), .2, b);\n    a += rtr(vec2(uv.x, -uv.y)-vec2(.5, .1), vec2(1., 1.), .2, b);\n    \n    a -= box(uv-vec2(-.25, .2), vec2(.15, .1), b);\n    a -= box(uv-vec2(.25, .2), vec2(.15, .1), b);\n    \n    a = clamp(a, 0., 1.);\n    \n    wheel += circle(uv-vec2(.4,-.35), .15, .01);\n    wheel += circle(uv-vec2(-.4,-.35), .15, .01);\n    \n    col = a * mix(vec3(.8, 0., 0.),vec3(.8, .8, 0.), \n                  st(.2, .06, abs(uv.y+.2)));\n    col *= st(.01, .4, abs(uv.y+.44));\n    col *= st(.0, .2, abs(uv.y-.38));\n\tcol *= st(.0, .9, abs(uv.x+1.15));\n    \n    col *= 1.-wheel;\n    \n    return vec4(col, a + wheel);\n}\n\nvec4 hill(vec2 uv){\n \tfloat a = st(0.015, -0.015, uv.y - height(uv.x));\n    vec3 col = vec3(0);\n    col += max(uv.y+.9, .1)*vec3(0.1, 0.43, 0.2) * a;\n    return vec4(col, a);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 m = iMouse.xy / R.xy-.5; \n    m.x *= R.x/R.y;\n    \n    vec3 col = mix(vec3(0.6, 0.6, 0.66), vec3(0., .28,.88), uv.y+.5);\n    col = mix(col, vec3(0.9, 0.9, 0.5), exp(-length((uv-vec2(-.6, .3))*14.)));\n    \n    uv *= 1.5;\n    \n    vec2 p = uv, p2 = uv;\n   \n    uv.x += iTime + m.x*5.;\n    \n    vec4 Hill = hill(vec2(2.*uv.x - iTime*.7, uv.y));\n    \n    col = mix(col, Hill.rgb, Hill.a); \n    \n    \n    float pos = -.8;\n    vec4 cars = vec4(0);\n    \n    for(float i = 0.; i < 5.; i++){\n        p = p2;\n        pos +=.25;\n        \n        float ht = height(uv.x - (p.x+pos));    \n    \tp = p2 + vec2(pos , ht);\n    \tp = rot(p, aDx(uv.x - p.x));\n    \n        cars = car((p-vec2(0., .072)) * 7.);\n        col = mix(col,cars.rgb,cars.a); \n    }\n    \n    \n    vec4 trk = track(uv);\n    col = mix(col, trk.rgb,trk.a); \n    \n    //col = 1.-exp(-col*1.4);\n    f = vec4(col, 1.0)*1.05;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtV3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 86, 86, 156], [158, 158, 180, 180, 240], [243, 243, 262, 262, 346], [348, 348, 386, 386, 497], [498, 498, 538, 538, 582], [583, 583, 633, 633, 803], [805, 805, 825, 825, 1290], [1293, 1293, 1311, 1311, 2381], [2383, 2383, 2402, 2402, 2559], [2561, 2561, 2601, 2601, 3550]], "test": "untested"}
{"id": "tly3Rm", "name": "offline S8dertoy 64k THX", "author": "ollj", "description": "after trying many soffline shadertoy canvases on a Samsung S8,I noticed that many of them where incompatible. The smaller ones perfomed a lot better, like THIS 64kOfflineShadertoy.html with focus on webAudio support (and shitty minimal semi-broken IU).", "tags": ["shadertoy", "canvas", "thx", "html", "offline", "hacky", "nofont", "s8dertoy"], "likes": 1, "viewed": 535, "published": 3, "date": "1578515264", "time_retrieved": "2024-07-30T21:31:01.600905", "image_code": "//main feature here is the whole HTML code in the commonTaB\n//when copied into a html file,you get an offlineShadertoy.html\n//this one has dcent Webaudio support on a samsung S8 mobile phone\n//where it plays the THX harmonics intro, within a 64k.html file\n//, within its mobile version of the fiirefox browser.\n\n//this shader has an unlisted \"evil twin\": \n//https://www.shadertoy.com/view/tlGGzm\n//that only has different (more instrumental) opengl code, to play the \"Terminator main theme\"\n\n//on many platforms you may have to klock \"volume\" and then \"reset\" \n//because there the default volume seems to be 0% and not the intended 100% volume\n//and because this is hacky crunched code, its non uniofurm between browsers or platforms.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    ;uv=fract(uv*4.);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n/*\n\n\n\n/*\n\ni have made 3 html files that are [offline shadertoy]\n\ni made 3 html files that are [offline shadertoy]\n\nself     : https://www.shadertoy.com/view/tly3Rm\ngood twin: https://www.shadertoy.com/view/tly3Rm\ncousin: https://www.shadertoy.com/view/WdlSRl\ncousin: https://www.shadertoy.com/view/3slSRl\nthe html code is in the common-tab of these domains.\n\n\nboth are a messy hacky crippled reverse-engineered conversions.\nboth have no codemirror , and are single .html files to edit in a text editor\nif you have a bug in the opengl code, it will nto tell you the right line number within your html file, but it will describe the error.\n\none version only has the imageBuffer and Webaudio (in webgl and webgl2), mouseIn and webm Out.\nand is <61 k in size, can hack a quick 64k demo in [offline shadertoy] with this, has a working volume slider!\n\nthe other version is 220k small and has working features:\n- Webgl, webgl2, with all extensions that shadertoy lists.\n- mouseIn\n- KeyboardIn\n- opengl to webaudio [44,22,11]kHz\n- 4 double buffers whos previous frame can be loaded via texture(ichanel0,uv.xy)\n- Webm recording\n- fullscreen\n- audio syncs nicely with video for 180 seconds, pausing&resuming the audio desyncs it with the video.\n- can still change settings of buffers (thugh my ui is a bit crippled,it may have starting issues like an old car)\nnot managed to make work, but may just work with minor tweaks:\n- soundCloud in (may change a link to a local source somewhere, i didnt look into the httpreq part of that)\n- imageIn (same issue, can not use ANY texture, as these are streamed)\n- videoin (works not, just like ImagweIn...)\n- EnvMap\n- texture3d\n- Buff3d\n- webvr, code is still in, untested, be the forst to try Webvr shadertoy on a plane!\n\n(actually may be easy to add a 5th... double buffer to make up for lack of textureStreaming)\nso, it doesnt give you fast foutierTransformed ideal blue noise buffers, but a bayer matrix is fine , too.\n\ni still need to figure out how to fix its most basic UI issues, its html tables for now, just for simplicity.\n, with all my hacky gluelogic that i bridged over the httpReq and json code\n, i barely know what my [offline shadertoy] can and can not do.\n\nthe boilerplates of both files can \"easily\" be optimized and made roughly half as big, but the art is to not brak anything while crunching it.\n\n/**/\n\n/**/", "image_inputs": [], "common_code": "/*   //remove this line from the html document, and the very last line of it\n\n\n\n<!DOCTYPE html>\n<html><head><title></title><style>\n.n{top:0px;left:0px;width100%;height:474px;position:relative;\n    padding-left:0px;padding-right:0px;margin-left:0px;margin-right:0px;}\n</style><script>\n//boilerplate==tinyFm303 ,<60k webaudio\n//moved to top because it sets opengl context modes,kinda important to debug.\nvar wMs=[\"experimental-webgl\",\"webgl\",\"experimental-webgl2\",\"webgl2\"]\n//var wMs=[\"webgl2\"]\nvar wM=4;//try version wMs[wM],and if that is not supported,diminish wM and retry.\nvar sRs=[44100,22050,11025,5512.5]//[3,6,12,24]min == [90,180,360,720]sec of play time (constrained by bufferSize/sampleRate)\nvar sR=1;//sRs[sR] points at a sample rate that is likely supported by webaudio\nfunction piCreateGlContext(cv,useAlpha,useDepth,usePreserveBuffer,useSupersampling){var opts=\n {alpha:useAlpha\n ,depth:useDepth\n ,stencil:false\n ,premultipliedAlpha:false\n ,antialias:useSupersampling\n ,preserveDrawingBuffer:usePreserveBuffer\n ,powerPreference:\"high-performance\"};//\"low_power\",\"high_performance\",\"default\"\n ;m=null\n ;while(wM>-1&&!m){m=cv.getContext(wMs[wM--],opts)}\n ;wM++\n ;return m;}\n</script><!--commontab code--><script id=\"o\">\n#define viewZoom 2.\n#define fra(u)(u-.5*iResolution.xy)*viewZoom/iResolution.y\n#define dd(a) dot(a,a)\n</script><!--Sound tab code--><script id=\"s\">\n\n\n\n\n//instrument,defined by an array of fourier coefficients,WTF!\n\n// Harmonics taken from\n// https://stackoverflow.com/questions/10702942/note-synthesis-harmonics-violin-piano-guitar-bass-frequencies-midi\n\n//https://www.shadertoy.com/view/XsyfDD\n//thx deep note intro\n\n#define DURATION 8.0\n#define INTRO 6.0\n\nfloat hash(uint x//uint hash via iq\n){uint k=1103515245U//seed\n ;x=((x>>8U)^x)*k\n ;x=((x>>8U)^x)*k\n ;x=((x>>8U)^x)*k\n ;return float(x)*(1.0/float(0xffffffffU));}\n\n\nstruct Intersection{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n    \nfloat hash1(float seed){\n    return fract(sin(seed)*43758.5453 );\n}\n\nfloat hash2D(vec2 x)\n{\n\tfloat i = dot(x,vec2(123.4031,46.5244876));\n\treturn fract(sin(i * 7.13) * 268573.103291);\n}\n\nCamera GetCamera(vec2 uv,float zoom,float time,int seed)\n{\n    float dist = 2.65 / zoom;\n    \n    vec3 target = vec3(0.0,0.0,0.2);\n    vec3 p = vec3(0.0,0.,0.2) + vec3(cos(time),0.0,sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward,vec3(0.0,1.0,0.0)));\n    vec3 up = normalize(cross(forward,left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}\n\nconst float coeff[26] = float[26]\n(1.,.286699025,.150079537,.042909002,\n    .203797365,.229228698,.156931925,\n    .115470898,.0,.097401803,.087653465,\n    .052331036,.052922462,.038850593,\n    .053554676,.053697434,.022270261,\n    .013072562,.008585879,.005771505,\n    .004343925,.002141371,.005343231,\n    .000530244,.004711017,.009014153);\n\nfloat instrBase(float t\n){float r=0.\n ;t*=4.\n ;for(float i = 0.;i< 2.;++i)r+= sin(t*i*acos(-1.))*coeff[int(i)]\n ;for(float i = 0.;i< 3.;++i)r+= sin(t*i*acos(-1.))*coeff[int(i)]\n ;return r;}\n\nfloat instrument(float time\n){float s = 0.0\n ;s += instrBase(time)\n //;s += instrBase(time * .5) * .33\n //;s += instrBase(time * 2.0) * .05\n ;return s;}\n\n// Derivation (or integration :P) based on smootherstep\nfloat smoothChirp(float t,float from,float to,float duration\n){t /= duration\n ;float a = from * duration\n ;float b = to * duration\n ;// a x - (5 a x^4)/2 + (5 b x^4)/2 + 3 a x^5 - 3 b x^5 - a x^6 + b x^6\n ;float phase = a * t\n ;phase -= 5.0 * a * pow(t,4.0) * .5\n ;phase += 5.0 * b * pow(t,4.0) * .5\n ;phase += 3.0 * a * pow(t,5.0)\n ;phase -= 3.0 * b * pow(t,5.0)\n ;phase -= a * pow(t,6.0)\n ;phase += b * pow(t,6.0)\n ;float offset = (a + b) * .5 + .45\n ;float introFix = .375 // hack\n ;if(t > 1.0)        phase = b * t + offset\n ;    else if(t < 0.0)        phase = a * t + introFix\n ;\telse        phase += introFix\n ;  return instrument(phase);}\n\nvec2 mainSound( in int samp,float time\n){int voices = 30\n ; vec2 accum = vec2(0)\n ;for(int i = 0; i < voices; ++i\n ){vec3 r = vec3(hash(uint(i * 7)),hash(uint(i * 31)),hash(uint(i * 17)))\n  ;float r1 = r.x\n  ;float r2 =  r.y\n  ;float from = 100.0 + r1 * 200.0\n  ;float to = 587.0 - 2.6\n  ;int octave = int(r1 * 4.0) - 2\n  ;float oct = pow(2.0,float(octave))\n  ;if(r2 < .33)            to = 369.0\n  ;        else if(r2 < .66)            to = 440.0\n  ;        else            to += 5.0 * (r.z * 2.0 - 1.0)\n  ;        to *= oct\n  ;        from += sin(time * .6 + 1.95) * 7.0 * smoothstep(INTRO,0.0,time)\n  ;        float signal = smoothChirp(time - INTRO,from,to,DURATION)\n  ;        signal *= (1.0 - r1 * r1 * .5) * 2.0\n  ;     float ampByFreq = smoothstep(INTRO,DURATION + INTRO,time)\n  ;        signal *= 1.0 + mix(oct,1.0 / oct,ampByFreq)\n  ;     float offset = float(i) * .25\n  ;        float so = 2.15\n  ;accum += signal*vec2(cos(time * so + offset) * .5 + .5,sin(time * so + offset) * .5 + .5)\n ;}\n ;float bass=0.\n ;bass += instrument(293.0 * .125 * time) * .115\n ;    bass += instrument(587.0 * .25 * time) * .05\n ;    bass += instrument(587.0 * .125 * time) * .25\n ; bass *= .5 * smoothstep(DURATION + INTRO - 3.0,DURATION + INTRO,time)\n ; accum /= float(voices)\n ;    accum *= mix(1.0,1.3,smoothstep(INTRO+DURATION - 3.0,INTRO+DURATION + 2.0,time))\n ;    accum += vec2(bass)\n ;  float gT = time - DURATION\n ;    accum *= smoothstep(.0,INTRO + 2.0,time) * smoothstep(30.0,15.0,time - 4.0)\n ;return accum;}\n\n\n\n\n</script><!--Image tab code--><script id=\"i\">\n//Image\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord\n){vec2 u=fra(fragCoord)\n ;vec4 m=vec4(fra(iMouse.xy),fra(iMouse.zw))\n ;vec2 p=sqrt(vec2(dd(u-m.xy),dd(u-m.zw)))\n ;p=smoothstep(.01,-.01,p-.1)\n ;float c=0.\n ;if(u.x>0.)c=.5+.5*cos(iTime+u.x)\n ;else{vec4 b=texture(iChannel0,fragCoord/iResolution.xy);c=max(max(b.x,b.y),b.z);}\n ;c=fract(c*9.)\n ;fragColor=vec4(p,c,1);}\n</script><script>\n\"use strict\"\n\nfunction gei(a){return document.getElementById(a).textContent;}//stringConcatenationExample:var striii=\"aaaa\"+gei('h')+\"tail\"\n\n//piLibs 2015-2017-https://iquilezles.org/www/material/piLibs/piLibs.htm\n//piFile\n\nfunction piFile(binaryDataArrayBuffer\n){var mDataView=binaryDataArrayBuffer\n ;var mOffset=0\n ;var me={}\n ;me.mDummy=0\n ;me.Seek=function(off){mOffset=off;}\n ;me.ReadUInt8=function(){var res=(new Uint8Array(mDataView,mOffset))[0];mOffset+=1;return res;}\n ;me.ReadUInt16=function(){var res=(new Uint16Array(mDataView,mOffset))[0];mOffset+=2;return res;}\n ;me.ReadUInt32=function(){var res=(new Uint32Array(mDataView,mOffset))[0];mOffset+=4;return res;}\n ;me.ReadUInt64=function(){return me.ReadUInt32()+(me.ReadUInt32()<<32);}\n ;me.ReadFloat32=function(){var res=(new Float32Array(mDataView,mOffset))[0];mOffset+=4;return res;}\n ;me.ReadFloat32Array=function(n\n ){var src=new Float32Array(mDataView,mOffset)\n  ;var res=[];for(var i=0;i<n;i++){res[i]=src[i];}\n  ;mOffset+=4*n\n  ;return res;}\n ;me.ReadFloat32ArrayNative=function(n){var src=new Float32Array(mDataView,mOffset);mOffset+=4*n;return src;}\n ;return me;}\n\nfunction piMesh(){this.mChunks=[];this.mPrimitiveType=0;this.mVertexFormat=null;}\n\npiMesh.prototype.scale=function(x,y,z\n){var stride=this.mVertexFormat.mStride/4\n ;for(var j=0;j<this.mChunks.length;j++\n ){var nv=this.mChunks[j].mNumVertices\n  ;for(var i=0;i<nv;i++\n  ){this.mChunks[j].mVerts[stride*i+0]*=x\n   ;this.mChunks[j].mVerts[stride*i+1]*=y\n   ;this.mChunks[j].mVerts[stride*i+2]*=z;}}}\n\npiMesh.prototype.translate=function(x,y,z\n){var stride=this.mVertexFormat.mStride/4\n ;for(var j=0;j<this.mChunks.length;j++\n ){var nv=this.mChunks[j].mNumVertices\n  ;for(var i=0;i<nv;i++\n  ){this.mChunks[j].mVerts[stride*i+0]+=x\n   ;this.mChunks[j].mVerts[stride*i+1]+=y\n   ;this.mChunks[j].mVerts[stride*i+2]+=z;}}}\n\npiMesh.prototype.GPULoad=function(renderer){return true;}\npiMesh.prototype.GPURender=function(renderer,positions){}\n\n//piLibs 2014-2017-https://iquilezles.org/www/material/piLibs/piLibs.htm\n//piRenderer\n\nvar mIs20=false;\nvar gShaderToy=null;\nvar gCode=null;\nvar gIsLiked=0;\nvar gRes=null;\nvar mAudioContext=null;\nvar mEffect=null;\nvar mTOffset=0;\nvar paused=false;\nvar mForceFrame=false;\nvar mTf=0;\nvar mRestarted=true;\n \nfunction piRenderer(\n){var m=null\n ;var pBindedShader=null\n ;var pFloat32Textures\n ;var pFloat32Filter\n ;var pFloat16Textures\n ;var pDrawBuffers\n ;var pDepthTextures\n ;var pDerivatives\n ;var pFloat32Filter\n ;var pFloat16Filter\n ;var pShaderTextureLOD\n ;var pAnisotropic\n ;var pRenderToFloat32F\n ;var pVBO_Quad=null\n ;var pVBO_Tri=null\n ;var pShaderHeader=[\"\",\"\"]\n ;var pm={}\n ;pm.TEXFMT   ={C4I8:0,C1I8:1,C1F16:2,C4F16:3,C1F32:4,C4F32:5,Z16:6,Z24:7,Z32:8}\n ;pm.TYPE     ={UINT8:0,UINT16:1,UINT32:2,FLOAT16:3,FLOAT32:4,FLOAT64:5}\n ;var iFormatPI2GL=function(format){if(mIs20\n     ){if(format===0)return{mFormat:m.RGBA8          ,mExternal:m.RGBA     ,mType:m.UNSIGNED_BYTE}\n else if(format===1)return{mFormat:m.R8             ,mExternal:m.RED      ,mType:m.UNSIGNED_BYTE}\n else if(format===5)return{mFormat:m.RGBA32F        ,mExternal:m.RGBA     ,mType:m.FLOAT}\n}else{if(format===0)return{mFormat:m.RGBA           ,mExternal:m.RGBA     ,mType:m.UNSIGNED_BYTE}\n else if(format===1)return{mFormat:m.LUMINANCE      ,mExternal:m.LUMINANCE,mType:m.UNSIGNED_BYTE}\n else if(format===5)return{mFormat:m.RGBA           ,mExternal:m.RGBA     ,mType:m.FLOAT}\n else if(format===6)return{mFormat:m.DEPTH_COMPONENT,mExternal:m.DEPTH_COMPONENT,mType:m.UNSIGNED_SHORT}}\n return null;}\n\n ;pm.Initialize=function(gl\n ){m=gl\n  ;mIs20=!(gl instanceof WebGLRenderingContext)\n  ;if(mIs20\n  ){pFloat32Textures=pFloat16Textures=pDerivatives=pDrawBuffers=pDepthTextures =pShaderTextureLOD=true\n   ;pFloat32Filter  =m.getExtension('OES_texture_float_linear')\n   ;pFloat16Filter  =m.getExtension('OES_texture_half_float_linear')\n   ;pAnisotropic=m.getExtension('EXT_texture_filter_anisotropic')\n   ;pRenderToFloat32F=m.getExtension('EXT_color_buffer_float')\n  ;}else\n   {pFloat32Textures=m.getExtension('OES_texture_float')\n   ;pFloat32Filter  =m.getExtension('OES_texture_float_linear')\n   ;pFloat16Textures=m.getExtension('OES_texture_half_float')\n   ;pFloat16Filter  =m.getExtension('OES_texture_half_float_linear')\n   ;pDerivatives    =m.getExtension('OES_standard_derivatives')\n   ;pDrawBuffers    =m.getExtension('WEBGL_draw_buffers')\n   ;pDepthTextures  =m.getExtension('WEBGL_depth_texture')\n   ;pShaderTextureLOD=m.getExtension('EXT_shader_texture_lod')\n   ;pAnisotropic    =m.getExtension('EXT_texture_filter_anisotropic')\n   ;pRenderToFloat32F=pFloat32Textures;}\n  ;var maxTexSize=m.getParameter(m.MAX_TEXTURE_SIZE)\n  ;var maxCubeSize=m.getParameter(m.MAX_CUBE_MAP_TEXTURE_SIZE)\n  ;var maxRenderbufferSize=m.getParameter(m.MAX_RENDERBUFFER_SIZE)\n  ;var extensions=m.getSupportedExtensions()\n  ;var textureUnits=m.getParameter(m.MAX_TEXTURE_IMAGE_UNITS)\n  ;var ph=\"precision highp \"\n  ;pVBO_Quad=m.createBuffer();m.bindBuffer(m.ARRAY_BUFFER,pVBO_Quad);m.bufferData(m.ARRAY_BUFFER\n  ,new Float32Array([-1.0,-1.0,1.0,-1.0,-1.0,1.0,1.0,-1.0,1.0,1.0,-1.0,1.0]),m.STATIC_DRAW);m.bindBuffer(m.ARRAY_BUFFER,null)\n  ;pVBO_Tri=m.createBuffer();m.bindBuffer(m.ARRAY_BUFFER,pVBO_Tri);m.bufferData(m.ARRAY_BUFFER//screenspace filling triangle\n  ,new Float32Array([-1.0,-1.0,3.0,-1.0,-1.0,3.0]),m.STATIC_DRAW);m.bindBuffer(m.ARRAY_BUFFER,null)   \n  ;pShaderHeader[0]=\"\"\n  ;var es300for100=\"float round(float x){return floor(x+0.5);}\\n\"\n  +\"vec2 round(vec2 x){return floor(x+0.5);}\\n\"\n  +\"vec3 round(vec3 x){return floor(x+0.5);}\\n\"\n  +\"vec4 round(vec4 x){return floor(x+0.5);}\\n\"\n  +\"float trunc(float x,float n){return floor(x*n)/n;}\\n\"\n  +\"mat3 transpose(mat3 m){return mat3(m[0].x,m[1].x,m[2].x,m[0].y,m[1].y,m[2].y,m[0].z,m[1].z,m[2].z);}\\n\"\n  +\"float determinant(in mat2 m){return m[0][0]*m[1][1]-m[0][1]*m[1][0];}\\n\"\n  +\"float determinant(mat4 m){\"\n  +\"float b00=m[0][0]*m[1][1]-m[0][1]*m[1][0],b01=m[0][0]*m[1][2]-m[0][2]*m[1][0]\"\n  +\",b02=m[0][0]*m[1][3]-m[0][3]*m[1][0],b03=m[0][1]*m[1][2]-m[0][2]*m[1][1]\"\n  +\",b04=m[0][1]*m[1][3]-m[0][3]*m[1][1],b05=m[0][2]*m[1][3]-m[0][3]*m[1][2]\"+\",b06=m[2][0]*m[3][1]-m[2][1]*m[3][0],b07=m[2][0]*m[3][2]-m[2][2]*m[3][0]\"+\",b08=m[2][0]*m[3][3]-m[2][3]*m[3][0],b09=m[2][1]*m[3][2]-m[2][2]*m[3][1]\"+\",b10=m[2][1]*m[3][3]-m[2][3]*m[3][1],b11=m[2][2]*m[3][3]-m[2][3]*m[3][2];\"+\"return b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;}\\n\"\n  +\"mat2 inverse(mat2 m){float det=determinant(m);return mat2(m[1][1],-m[0][1],-m[1][0],m[0][0])/det;}\\n\"\n  +\"mat4 inverse(mat4 m){\"\n  +\"float inv0 = m[1].y*m[2].z*m[3].w-m[1].y*m[2].w*m[3].z-m[2].y*m[1].z*m[3].w+m[2].y*m[1].w*m[3].z+m[3].y*m[1].z*m[2].w-m[3].y*m[1].w*m[2].z;\"\n  +\"float inv4 =-m[1].x*m[2].z*m[3].w+m[1].x*m[2].w*m[3].z+m[2].x*m[1].z*m[3].w-m[2].x*m[1].w*m[3].z-m[3].x*m[1].z*m[2].w+m[3].x*m[1].w*m[2].z;\"\n  +\"float inv8 = m[1].x*m[2].y*m[3].w-m[1].x*m[2].w*m[3].y-m[2].x*m[1].y*m[3].w+m[2].x*m[1].w*m[3].y+m[3].x*m[1].y*m[2].w-m[3].x*m[1].w*m[2].y;\"\n  +\"float inv12=-m[1].x*m[2].y*m[3].z+m[1].x*m[2].z*m[3].y+m[2].x*m[1].y*m[3].z-m[2].x*m[1].z*m[3].y-m[3].x*m[1].y*m[2].z+m[3].x*m[1].z*m[2].y;\"\n  +\"float inv1 =-m[0].y*m[2].z*m[3].w+m[0].y*m[2].w*m[3].z+m[2].y*m[0].z*m[3].w-m[2].y*m[0].w*m[3].z-m[3].y*m[0].z*m[2].w+m[3].y*m[0].w*m[2].z;\"\n  +\"float inv5 = m[0].x*m[2].z*m[3].w-m[0].x*m[2].w*m[3].z-m[2].x*m[0].z*m[3].w+m[2].x*m[0].w*m[3].z+m[3].x*m[0].z*m[2].w-m[3].x*m[0].w*m[2].z;\"\n  +\"float inv9 =-m[0].x*m[2].y*m[3].w+m[0].x*m[2].w*m[3].y+m[2].x*m[0].y*m[3].w-m[2].x*m[0].w*m[3].y-m[3].x*m[0].y*m[2].w+m[3].x*m[0].w*m[2].y;\"\n  +\"float inv13= m[0].x*m[2].y*m[3].z-m[0].x*m[2].z*m[3].y-m[2].x*m[0].y*m[3].z+m[2].x*m[0].z*m[3].y+m[3].x*m[0].y*m[2].z-m[3].x*m[0].z*m[2].y;\"\n  +\"float inv2 = m[0].y*m[1].z*m[3].w-m[0].y*m[1].w*m[3].z-m[1].y*m[0].z*m[3].w+m[1].y*m[0].w*m[3].z+m[3].y*m[0].z*m[1].w-m[3].y*m[0].w*m[1].z;\"\n  +\"float inv6 =-m[0].x*m[1].z*m[3].w+m[0].x*m[1].w*m[3].z+m[1].x*m[0].z*m[3].w-m[1].x*m[0].w*m[3].z-m[3].x*m[0].z*m[1].w+m[3].x*m[0].w*m[1].z;\"\n  +\"float inv10= m[0].x*m[1].y*m[3].w-m[0].x*m[1].w*m[3].y-m[1].x*m[0].y*m[3].w+m[1].x*m[0].w*m[3].y+m[3].x*m[0].y*m[1].w-m[3].x*m[0].w*m[1].y;\"\n  +\"float inv14=-m[0].x*m[1].y*m[3].z+m[0].x*m[1].z*m[3].y+m[1].x*m[0].y*m[3].z-m[1].x*m[0].z*m[3].y-m[3].x*m[0].y*m[1].z+m[3].x*m[0].z*m[1].y;\"\n  +\"float inv3 =-m[0].y*m[1].z*m[2].w+m[0].y*m[1].w*m[2].z+m[1].y*m[0].z*m[2].w-m[1].y*m[0].w*m[2].z-m[2].y*m[0].z*m[1].w+m[2].y*m[0].w*m[1].z;\"\n  +\"float inv7 = m[0].x*m[1].z*m[2].w-m[0].x*m[1].w*m[2].z-m[1].x*m[0].z*m[2].w+m[1].x*m[0].w*m[2].z+m[2].x*m[0].z*m[1].w-m[2].x*m[0].w*m[1].z;\"\n  +\"float inv11=-m[0].x*m[1].y*m[2].w+m[0].x*m[1].w*m[2].y+m[1].x*m[0].y*m[2].w-m[1].x*m[0].w*m[2].y-m[2].x*m[0].y*m[1].w+m[2].x*m[0].w*m[1].y;\"\n  +\"float inv15= m[0].x*m[1].y*m[2].z-m[0].x*m[1].z*m[2].y-m[1].x*m[0].y*m[2].z+m[1].x*m[0].z*m[2].y+m[2].x*m[0].y*m[1].z-m[2].x*m[0].z*m[1].y;\"\n  +\"float det=m[0].x*inv0+m[0].y*inv4+m[0].z*inv8+m[0].w*inv12;det=1.0/det\"\n  +\";return det*mat4(inv0,inv1,inv2,inv3,inv4,inv5,inv6,inv7,inv8,inv9,inv10,inv11,inv12,inv13,inv14,inv15);}\\n\"\n  +\"float sinh(float x){return (exp(x)-exp(-x))/2.;}\\n float cosh(float x){return (exp(x)+exp(-x))/2.;}\\n\"\n  +\"float tanh(float x){return sinh(x)/cosh(x);}\\n float csch(float x){return 1./sinh(x);}\\n\"\n  +\"float coth(float x){return cosh(x)/sinh(x);}\\n float sech(float x){return 1./cosh(x);}\\n\"\n  +\"float atanh(float x){return .5*log((1.+x)/(1.-x));}\\n float asinh(float x){return log(x+sqrt(x*x+1.));}\\n float asech(float x){return log((1.+sqrt(1.-x*x))/x);}\\n\"\n  +\"float acoth(float x){return .5*log((x+1.)/(x-1.));}\\n float acosh(float x){return log(x+sqrt(x*x-1.));}\\n float acsch(float x){return log((1.+sqrt(1.+x*x))/x);}\\n\"\n  ;var prec=\"#ifdef GL_ES\\n\"+ph+\"float;\\n\"+\"precision highp int;\\n\"\n  ;var v300=\"#version 300 es\\n\"\n  ;var v300e=\"precision mediump sampler3D;\\n\"+\"#endif\\n\"\n  ;if(mIs20)pShaderHeader[0]+=v300+prec+v300e\n  ;else    pShaderHeader[0]+=prec+\"#endif\\n\"+es300for100\n  ;pShaderHeader[1]=\"\"\n  ;if(mIs20){pShaderHeader[1]+=v300+prec+v300e\n  ;}else\n   {if(pDerivatives){pShaderHeader[1]+=\"#ifdef GL_OES_standard_derivatives\\n#extension GL_OES_standard_derivatives:enable\\n#endif\\n\";}\n   ;if(pShaderTextureLOD){pShaderHeader[1]+=\"#extension GL_EXT_shader_texture_lod:enable\\n\";} \n   ;var t4=\"vec4 texture\"\n   ;var ts=t4+\"(sampler\"\n   ;var tc=\"){return textureCube(s,c\"\n   ;var sa=\"(sampler2D s,vec2 c,\"\n   ;var r2=\"){return texture2D\"\n   ;pShaderHeader[1]+=\"#ifdef GL_ES\\n\"+ph+\"float;\\n\"+ph+\"int;\\n\"+\"#endif\\n\"\n  +ts+\"2D   s,vec2 c\"+r2+\"(s,c);}\\n\"+ts+\"2D   s,vec2 c,float b\"+r2+\"(s,c,b);}\\n\"\n  +ts+\"Cube s,vec3 c\"+tc+\");}\\n\"   +ts+\"Cube s,vec3 c,float b\"+tc+\",b);}\\n\"\n  +es300for100\n   ;if(pShaderTextureLOD){pShaderHeader[1]\n   +=t4+\"Lod\"+sa+\"float b         \"+r2+\"LodEXT(s,c,b);}\\n\"\n   +t4+\"Grad\"+sa+\"vec2 dx,vec2 dy\"+r2+\"GradEXT(s,c,dx,dy);}\\n\"}}return true;}\n ;\n ;pm.GetCaps=function(\n ){return{mIsGL20:mIs20\n  ,pFloat32Textures:pFloat32Textures!=null\n  ,pFloat16Textures:pFloat16Textures!=null\n      ,pDrawBuffers:pDrawBuffers!=null\n    ,pDepthTextures:pDepthTextures!=null\n      ,pDerivatives:pDerivatives!=null\n ,pShaderTextureLOD:pShaderTextureLOD!=null};}\n ;\n ;pm.CheckErrors=function(\n ){var error=m.getError()\n  ;if(error!=m.NO_ERROR\n  ){for(var prop in m\n   ){if(typeof m[prop]=='number'\n    ){if(m[prop]==error){console.log(\"GL Error \"+error+\":\"+prop);break;}   }}}}\n ;\n ;pm.Clear=function(flags,ccolor,cdepth,cstencil\n ){var mode=0\n  ;if(flags & 1){mode |=m.COLOR_BUFFER_BIT;m.clearColor(ccolor[0],ccolor[1],ccolor[2],ccolor[3]);}\n  ;if(flags & 2){mode |=m.DEPTH_BUFFER_BIT;m.clearDepth(cdepth);}\n  ;if(flags & 4){mode |=m.STENCIL_BUFFER_BIT;m.clearStencil(cstencil);}\n  ;m.clear(mode);}\n ;\n ;pm.CreateTexture=function(type,x,y,format,filter,wrap,buffer\n ){if(m===null)return null\n  ;var id=m.createTexture()\n  ;var glFoTy=iFormatPI2GL(format)\n  ;var glWrap=1;if(wrap===0)glWrap=m.CLAMP_TO_EDGE\n  ;if(type===0\n  ){m.bindTexture(m.TEXTURE_2D,id)\n   ;m.texImage2D(m.TEXTURE_2D,0,glFoTy.mFormat,x,y,0,glFoTy.mExternal,glFoTy.mType,buffer)\n   ;m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_S,glWrap)\n   ;m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_T,glWrap)\n   ;m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MAG_FILTER,m.NEAREST)\n   ;m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MIN_FILTER,m.NEAREST)\n   ;m.bindTexture(m.TEXTURE_2D,null)\n  ;}\n ;return{mObjectID:id,mXres:x,mYres:y,mFormat:format,mType:type,mFilter:filter,mWrap:wrap,mVFlip:false};}\n ;pm.CreateTextureFromImage=function(type,image,format,filter,wrap,flipY\n ){if(m===null)return null\n  ;var id=m.createTexture()\n  ;var glFoTy=iFormatPI2GL(format)\n  ;var glWrap=1;if(wrap===0)glWrap=m.CLAMP_TO_EDGE\n  ;if(type===0\n  ){m.bindTexture(m.TEXTURE_2D,id)\n   ;m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL,flipY)\n   ;m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL,false)\n   ;if(mIs20)m.pixelStorei(m.UNPACK_COLORSPACE_CONVERSION_WEBGL,m.NONE)\n   ;m.texImage2D(m.TEXTURE_2D,0,glFoTy.mFormat,glFoTy.mExternal,glFoTy.mType,image)\n   ;m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_S,glWrap)\n   ;m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_T,glWrap)\n   ;m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MAG_FILTER,m.NEAREST)\n   ;m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MIN_FILTER,m.NEAREST)\n   ;m.bindTexture(m.TEXTURE_2D,null)\n   ;}\n  ;return{mObjectID:id,mXres:image.width,mYres:image.height,mFormat:format,mType:type,mFilter:filter,mWrap:wrap,mVFlip:flipY};}\n ; ;\n ;pm.UpdateTexture=function(tex,x0,y0,x,y,buffer\n ){var glFoTy=iFormatPI2GL(tex.mFormat)\n  ;if(tex.mType===0\n  ){m.activeTexture(m.TEXTURE0)\n   ;m.bindTexture(m.TEXTURE_2D,tex.mObjectID)\n   ;m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL,tex.mVFlip)\n   ;m.texSubImage2D(m.TEXTURE_2D,0,x0,y0,x,y,glFoTy.mExternal,glFoTy.mType,buffer)\n   ;m.bindTexture(m.TEXTURE_2D,null);}}\n ;\n ;pm.UpdateTextureFromImage=function(tex,image\n ){var glFoTy=iFormatPI2GL(tex.mFormat)\n  ;if(tex.mType===0\n  ){m.activeTexture(m.TEXTURE0)\n   ;m.bindTexture(m.TEXTURE_2D,tex.mObjectID)\n   ;m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL,tex.mVFlip)\n   ;m.texImage2D(m.TEXTURE_2D,0,glFoTy.mFormat,glFoTy.mExternal,glFoTy.mType,image)\n   ;m.bindTexture(m.TEXTURE_2D,null);}};\n ;\n ;pm.CreateRenderTarget=function(color0,color1,color2,color3,depth,wantZbuffer\n ){var i=m.createFramebuffer()\n  ;m.bindFramebuffer(m.FRAMEBUFFER,i)\n  ;if(color0!=null)m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,m.TEXTURE_2D,color0.mObjectID,0)\n  ;m.bindRenderbuffer(m.RENDERBUFFER,null);m.bindFramebuffer(m.FRAMEBUFFER,null);return{mObjectID:i};}\n ;\n ;pm.DestroyRenderTarget=function(tex){m.deleteFramebuffer(tex.mObjectID);}\n ;\n ;pm.SetRenderTarget=function(t){m.bindFramebuffer(m.FRAMEBUFFER,(t===null?null:t.mObjectID));}\n ;\n ;pm.CreateRenderTargetNew=function(wantColor0,wantZbuffer,x,y,samples\n ){var id=m.createFramebuffer()\n  ;m.bindFramebuffer(m.FRAMEBUFFER,id)\n  ;if(want2===true\n  ){var zb=m.createRenderbuffer()\n   ;m.bindRenderbuffer(m.RENDERBUFFER,zb)\n   ;if(samples==1)m.renderbufferStorage(m.RENDERBUFFER,m.DEPTH_COMPONENT16,x,y)\n   ;else          m.renderbufferStorageMultisample(m.RENDERBUFFER,samples,m.DEPTH_COMPONENT16,x,y)\n   ;m.framebufferRenderbuffer(m.FRAMEBUFFER,m.DEPTH_ATTACHMENT,m.RENDERBUFFER,zb);}\n  ;if(wantColor0\n  ){var cb=m.createRenderbuffer()\n   ;m.bindRenderbuffer(m.RENDERBUFFER,cb)\n   ;if(samples==1)m.renderbufferStorage(m.RENDERBUFFER,m.RGBA8,x,y)\n            ;else m.renderbufferStorageMultisample(m.RENDERBUFFER,samples,m.RGBA8,x,y)\n   ;m.framebufferRenderbuffer(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,m.RENDERBUFFER,cb);}\n   ;if(m.checkFramebufferStatus(m.FRAMEBUFFER)!=m.FRAMEBUFFER_COMPLETE){return null;}\n   ;m.bindRenderbuffer(m.RENDERBUFFER,null);m.bindFramebuffer(m.FRAMEBUFFER,null)\n   ;return{mObjectID:id,mXres:x,mYres:y};}\n ;\n ;pm.BlitRenderTarget=function(dst,src\n ){m.bindFramebuffer(m.READ_FRAMEBUFFER,src.mObjectID)\n  ;m.bindFramebuffer(m.DRAW_FRAMEBUFFER,dst.mObjectID)\n  ;m.clearBufferfv(m.COLOR,0,[0.0,0.0,0.0,1.0])\n  ;m.blitFramebuffer(0,0,src.mXres,src.mYres,0,0,src.mXres,src.mYres,m.COLOR_BUFFER_BIT,m.LINEAR);}\n ;\n ;pm.SetViewport=function(vp){m.viewport(vp[0],vp[1],vp[2],vp[3]);}\n ;pm.SetWriteMask=function(c0,c1,c2,c3,z){m.depthMask(z);m.colorMask(c0,c0,c0,c0);}\n ;\n ;pm.SetState=function(stateName,stateValue\n ){}\n ;\n ;pm.SetMultisample=function(v\n ){if(v===true){m.enable(m.SAMPLE_COVERAGE);m.sampleCoverage(1.0,false);}else{m.disable(m.SAMPLE_COVERAGE);}}\n ;\n ;pm.CreateShader=function(vsSource,fsSource\n ){if(m===null)return{mProgram:null,mResult:false,mInfo:\"No WebGL\",mHeaderLines:0}\n  ;var te={mProgram:null,mResult:true,mInfo:\"compile success\",mHeaderLines:0,mErrorType:0}\n  ;var vs=m.createShader(m.VERTEX_SHADER)\n  ;var fs=m.createShader(m.FRAGMENT_SHADER)\n  ;vsSource=pShaderHeader[0]+vsSource\n  ;fsSource=pShaderHeader[1]+fsSource\n  ;m.shaderSource(vs,vsSource)\n  ;m.shaderSource(fs,fsSource)\n  ;m.compileShader(vs)\n  ;m.compileShader(fs)\n  ;if(!m.getShaderParameter(vs,m.COMPILE_STATUS)){var infoLog=m.getShaderInfoLog(vs);;te.mResult=false\n   ;return te;}\n  ;if(!m.getShaderParameter(fs,m.COMPILE_STATUS)\n  ){var infoLog=m.getShaderInfoLog(fs)\n   ;te.mResult=false\n   ;return te;}\n  ;te.mProgram=m.createProgram()\n  ;m.attachShader(te.mProgram,vs)\n  ;m.attachShader(te.mProgram,fs)\n  ;m.linkProgram(te.mProgram)\n  ;if(!m.getProgramParameter(te.mProgram,m.LINK_STATUS)\n  ){var infoLog=m.getProgramInfoLog(te.mProgram)\n   ;m.deleteProgram(te.mProgram)\n   ;te.mResult=false\n   ;return te;}return te;}\n ;\n ;pm.AttachShader=function(s){if(s===null){pBindedShader=null;m.useProgram(null);}else{pBindedShader=s;m.useProgram(s.mProgram);}}\n ;\n ;pm.DetachShader=function(){m.useProgram(null);}\n ;pm.DestroyShader=function(tex){m.deleteProgram(tex.mProgram);}\n ;pm.GetAttribLocation=function(shader,name){return m.getAttribLocation(shader.mProgram,name);}\n ;pm.sscLocation=function(shader,name){return m.getUniformLocation(shader.mProgram,name);}\n ;pm.sscMat4F=function(uname,params,istranspose\n ){var program=pBindedShader\n  ;var pos=m.getUniformLocation(program.mProgram,uname)\n  ;if(pos===null)return false\n  ;if(istranspose===false\n  ){var tmp=new Float32Array([params[0],params[4],params[8],params[12],params[1],params[5],params[9],params[13]\n                            ,params[2],params[6],params[10],params[14],params[3],params[7],params[11],params[15]])\n   ;m.uniformMatrix4fv(pos,false,tmp)\n  ;}else m.uniformMatrix4fv(pos,false,new Float32Array(params))\n  ;return true;}\n ;\n ;pm.gulf=function(m,u){return m.getUniformLocation(pBindedShader.mProgram,u);}\n ;pm.ssc1F =function(u,x){var p=pm.gulf(m,u);if(p===null)return false;m.uniform1f(p,x);return true;}\n ;pm.ssc1I =function(u,x){var p=pm.gulf(m,u);if(p===null)return false;m.uniform1i(p,x);return true;}\n ;pm.ssc2F =function(u,x){var p=pm.gulf(m,u);if(p===null)return false;m.uniform2fv(p,x);return true;}\n ;pm.ssc1FV=function(u,x){var p=pm.gulf(m,u);if(p===null)return false;m.uniform1fv(p,new Float32Array(x));return true;}\n ;pm.ssc3FV=function(u,x){var p=pm.gulf(m,u);if(p===null)return false;m.uniform3fv(p,new Float32Array(x));return true;}\n ;pm.ssc4FV=function(u,x){var p=pm.gulf(m,u);if(p===null)return false;m.uniform4fv(p,new Float32Array(x));return true;}\n ;pm.ssc1F_Pos=function(p,x){m.uniform1f(p,x);return true;}\n ;pm.ssc3F=function(u,x,y,z){var p=pm.gulf(m,u);if(p===null)return false;m.uniform3f(p,x,y,z);return true;}\n ;pm.SetShaderTextureUnit=function(u,unit\n ){var program=pBindedShader;var p=m.getUniformLocation(program.mProgram,u);if(p===null)return false;m.uniform1i(p,unit);return true;}\n ;\n ;pm.DrawFullScreenTriangle_XY=function(v){m.bindBuffer(m.ARRAY_BUFFER,pVBO_Tri)\n  ;m.vertexAttribPointer(v,2,m.FLOAT,false,0,0);m.enableVertexAttribArray(v)\n  ;m.drawArrays(4,0,3);m.disableVertexAttribArray(v);m.bindBuffer(m.ARRAY_BUFFER,null);}\n ;pm.DrawUnitQuad_XY=function(v){m.bindBuffer(m.ARRAY_BUFFER,pVBO_Quad)\n  ;m.vertexAttribPointer(v,2,m.FLOAT,false,0,0);m.enableVertexAttribArray(v)\n  ;m.drawArrays(4,0,6);m.disableVertexAttribArray(v);m.bindBuffer(m.ARRAY_BUFFER,null);};\n\npm.SetBlend=function(t\n){if(t\n ){m.enable(m.BLEND)\n  ;m.blendEquationSeparate(m.FUNC_ADD,m.FUNC_ADD)\n  ;m.blendFuncSeparate(m.SRC_ALPHA,m.ONE_MINUS_SRC_ALPHA,m.ONE,m.ONE_MINUS_SRC_ALPHA)\n ;}else{m.disable(m.BLEND);}};\n\npm.GetPixelData=function(data,x,y\n){m.readPixels(0,0,x,y,m.RGBA,m.UNSIGNED_BYTE,data);};return pm;}\n\n//piLibs 2015-2017-https://iquilezles.org/www/material/piLibs/piLibs.htm\n//piWebUtils\n\nfunction min(a,b){return (a<b)? a:b;}\n\n//RequestAnimationFrame\nwindow.requestAnimFrame=(function(){return window.requestAnimationFrame    \n||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame\n||window.msRequestAnimationFrame||function(cb){window.setTimeout(cb,1000/60);};})();\n\nwindow.getRealTime=(function(){if(\"performance\" in window)return function(){return window.performance.now();}\n           return function(){return (new Date()).getTime();}})();\n\nwindow.URL=window.URL||window.webkitURL;\n\nnavigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;\n\nfunction htmlEntities(str){return str;}\n\n\nvar piGetTime=function(t){if(t==0)return \"\" ;return new Date(t*1000).toISOString().substr(0,10);}\n\nfunction piGetCoords(o){var x=0;var y=0;do{x+=o.offsetLeft;y+=o.offsetTop;}while(o=o.offsetParent);return{mX:x,mY:y};}\n\nfunction piGetMouseCoords(ev,canvasElement\n){var pos=piGetCoords(canvasElement)\n ;var mcx=         (ev.pageX-pos.mX)* canvasElement.width/canvasElement.offsetWidth\n ;var mcy=canvasElement.height-(ev.pageY-pos.mY)* canvasElement.height/canvasElement.offsetHeight\n ;return{mX:mcx,mY:mcy};}\n\nfunction piGetSourceElement(e){var ele=null;if(e.target)ele=e.target;if(e.srcElement)ele=e.srcElement;return ele;}\n\nfunction piRequestFullScreen(ele\n){if(ele==null)ele=document.documentElement\n ;if(ele.requestFullscreen)ele.requestFullscreen()\n ;else if(ele.msRequestFullscreen)ele.msRequestFullscreen()\n ;else if(ele.mozRequestFullScreen)ele.mozRequestFullScreen()\n ;else if(ele.webkitRequestFullscreen)ele.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);}\n\nfunction piIsFullScreen(\n){return document.fullscreen||document.mozFullScreen||document.webkitIsFullScreen||document.msFullscreenElement||false;}\n\nfunction piExitFullScreen(\n){if(document.exitFullscreen)document.exitFullscreen()\n ;else if(document.msExitFullscreen)document.msExitFullscreen()\n ;else if(document.mozCancelFullScreen)document.mozCancelFullScreen()\n ;else if(document.webkitExitFullscreen)document.webkitExitFullscreen();}\n\n\n\n\nfunction piCreateAudioContext(\n){var res=null\n ;try    {if(window.AudioContext)res=new AudioContext()\n  ;if(res==null&&window.webkitAudioContext)res=new webkitAudioContext();}catch(e){res=null;}return res;}\n\n\nfunction piCreateFPSCounter(\n){var mFrame\n ;var mTo\n ;var mFPS\n ;var iReset=function(time){mFrame=0;mTo=time;mFPS=60.0;}\n ;var iCount=function(time\n ){mFrame++\n  ;if((time-mTo)>500.0\n  ){mFPS=1000.0*mFrame/(time-mTo)\n   ;mFrame=0\n   ;mTo=time\n   ;return true;}return false;}\n ;var iGetFPS=function(){return mFPS;}\n ;return{Reset:iReset,Count:iCount,GetFPS:iGetFPS};}\n\nfunction piCanMediaRecorded(canvas\n){if(typeof window.MediaRecorder !=='function'||typeof canvas.captureStream !=='function'){return false;}\n    return true;\n}\nfunction piCreateMediaRecorder(isRecordingCallback,canvas\n){if(piCanMediaRecorded(canvas)==false){return null;}\n ;var mediaRecorder=new MediaRecorder(canvas.captureStream())\n ;var chunks=[]\n ;mediaRecorder.ondataavailable=function(e){if(e.data.size>0){chunks.push(e.data);}}\n ;mediaRecorder.onstart=function(){isRecordingCallback(true);}\n ;mediaRecorder.onstop=function(\n ){isRecordingCallback(false)\n  ;let blob   =new Blob(chunks,{type:\"video/webm\"})\n  ;chunks     =[]\n  ;let videoURL=window.URL.createObjectURL(blob)\n  ;let url    =window.URL.createObjectURL(blob)\n  ;let a      =document.createElement(\"a\")\n  ;document.body.appendChild(a)\n  ;a.style    =\"display:none\"\n  ;a.href     =url\n  ;a.download =\"capture.webm\"\n  ;a.click()\n  ;window.URL.revokeObjectURL(url);}\n  ;return mediaRecorder;}\n\n\n\nfunction EffectPass(renderer,is20,hasShaderTextureLOD,callback,obj,forceMuted,forcePaused,outputGainNode,copyProgram,id\n){this.mID=id\n ;this.mInputs=[null,null,null,null]\n ;this.mOutputs=[null,null,null,null]\n ;this.mSource=null\n ;this.mGainNode=outputGainNode\n ;this.mRenderer=renderer\n ;this.mProgramCopy=copyProgram\n ;this.mType=\"image\"\n ;this.mName=\"none\"\n ;this.mFrame=0\n ;this.pShaderTextureLOD=hasShaderTextureLOD\n ;this.mTextureCallbackFun=callback\n ;this.mTextureCallbackObj=obj\n ;this.mForceMuted=forceMuted\n ;this.mForcePaused=forcePaused ;}\n\nEffectPass.prototype.MakeHeader=function(\n){if(this.mType==\"image\"){this.mHeader=\"uniform vec3  iResolution;uniform float iTime;\"\n +\"uniform float iChannelTime[4];uniform vec4  iMouse;\"  \n }else this.mHeader=\"uniform float iChannelTime[4];uniform float iBlockOffset;\\n\"\n ;this.mHeader+=\"uniform vec4 iDate;uniform float iSampleRate;uniform vec3 iChannelResolution[4];\\n\";\n if(this.mType==\"image\"\n ){this.mHeader+=\"uniform int iFrame;uniform float iTimeDelta;uniform float iFrameRate;\"\n  +\"struct Channel{vec3 resolution;float time;};uniform Channel iChannel[4];\"\n  ;for(var i=0;i<this.mInputs.length;i++){var inp=this.mInputs[i];this.mHeader+=\"uniform sampler2D iChannel\"+i+\";\";}\n  ;this.mHeader+=\"void mainImage(out vec4 c,in vec2 f);\"\n  ;this.mImagePassFooter=(mIs20?\"\\nout vec4 outColor;\":\"\")\n  +\"\\nvoid main(void){vec4 color=vec4(0,0,0,1);mainImage(color,gl_FragCoord.xy);color.w=1.0;\"\n  +(mIs20?\"out\":\"gl_Frag\")+\"Color=color;}\";}}\n\nEffectPass.prototype.Destroy_Sound=function(wa\n){    if(this.mPlayNode!=null)this.mPlayNode.stop()\n ;this.mPlayNode=null\n ;this.mBuffer=null\n ;this.mData=null\n ;this.mRenderer.DestroyTexture(this.mRenderTexture);}\n\nEffectPass.prototype.Create=function(passType,passName,wa\n){this.mType=passType\n ;this.mName=passName\n ;this.mSource=null\n ;this.MakeHeader() \n ;if(passType==\"sound\"\n ){if(mIs20\n  ){this.mSoundPassFooter=\"\\nout vec4 outColor;void main(){\" \n   +\"float t=iBlockOffset+((gl_FragCoord.x-0.5)+(gl_FragCoord.y-0.5)*512.0)/iSampleRate;\" \n   +\"vec2 y=mainSound( in int samp,t);\" \n   +\"vec2 v=floor((0.5+0.5*y)*65536.0);\" \n   +\"vec2 vl=mod(v,256.0)/255.0;\" \n   +\"vec2 vh=floor(v/256.0)/255.0;\"\n   +\"outColor=vec4(vl.x,vh.x,vl.y,vh.y);}\"\n  ;}else{\n   ;this.mSoundPassFooter=\"\\nvoid main(){\"\n   +\"float t=iBlockOffset+((gl_FragCoord.x-0.5)+(gl_FragCoord.y-0.5)*512.0)/iSampleRate;\"\n   +\"vec2 y=mainSound( in int samp,t);\"\n   +\"vec2 v=floor((0.5+0.5*y)*65536.0);\"\n   +\"vec2 vl=mod(v,256.0)/255.0;\"\n   +\"vec2 vh=floor(v/256.0)/255.0;\"\n   +\"gl_FragColor=vec4(vl.x,vh.x,vl.y,vh.y);}\";}\n  ;this.mProgram=null\n  ;this.mSampleRate=sRs[sR]\n  ;this.mPlayTime=60*3*sRs[0]/sRs[sR]\n  ;this.mPlaySamples=this.mPlayTime*this.mSampleRate\n  ;this.mBuffer=wa.createBuffer(2,this.mPlaySamples,this.mSampleRate)\n  ;this.mTextureDimensions=512\n  ;this.mRenderTexture=this.mRenderer.CreateTexture(0\n  ,      this.mTextureDimensions,this.mTextureDimensions\n  ,      this.mRenderer.TEXFMT.C4I8,0,      0,null)\n  ;this.mRenderFBO=this.mRenderer.CreateRenderTarget(this.mRenderTexture,null,null,null,null,false)\n  ;this.mTmpBufferSamples=this.mTextureDimensions*this.mTextureDimensions\n  ;this.mData=new Uint8Array(this.mTmpBufferSamples*4)\n  ;this.mPlayNode=null\n ;}}\n\nEffectPass.prototype.Destroy=function(wa\n){this.mSource=null\n ;if(this.mType==\"sound\")this.Destroy_Sound(wa)\n ;else if(this.mType==\"common\")this.Destroy_Common(wa);}\n\nEffectPass.prototype.NewShader_Sound=function(shaderCode,commonShaderCodes\n){var vsSource=((mIs20)?\"layout(location=0)in\":\"attribute\")+\" vec2 pos;void main(){gl_Position=vec4(pos.xy,0.0,1.0);}\"\n ;var fsSource=this.mHeader\n ;fsSource+=gei('o')\n ;fsSource+=shaderCode\n ;fsSource+=this.mSoundPassFooter\n ;var res=this.mRenderer.CreateShader(vsSource,fsSource)\n ;if(res.mResult==false)return res.mInfo\n ;if(this.mProgram!=null)this.mRenderer.DestroyShader(this.mProgram)\n ;this.mProgram=res\n ;this.mFrame=0\n ;return null;}\n\nEffectPass.prototype.NewShader_Image=function(shaderCode,commonShaderCodes\n){var vsSource=((mIs20)?\"layout(location=0)in\":\"attribute\")+\" vec2 pos;void main(){gl_Position=vec4(pos.xy,0.0,1.0);}\"\n ;var fsSource=this.mHeader\n ;for(var i=0;i<commonShaderCodes.length;i++){fsSource+=commonShaderCodes[i]+'\\n';}\n ;this.mHeaderLength=fsSource.split(/\\r\\n|\\r|\\n/).length\n ;fsSource+=shaderCode\n ;fsSource+=this.mImagePassFooter\n ;var res=this.mRenderer.CreateShader(vsSource,fsSource)\n ;if(res.mResult==false)return res.mInfo\n ;if(this.mProgram!=null)this.mRenderer.DestroyShader(this.mProgram)\n ;this.mProgram=res\n ;this.mSupportsVR=false\n ;return null;}\n\nEffectPass.prototype.NewShader_Common=function(shaderCode\n){var vsSource=((mIs20)?\"layout(location=0)in\":\"attribute\")+\" vec2 pos;void main(){gl_Position=vec4(pos.xy,0.0,1.0);}\"\n ;var fsSource=this.mHeader+shaderCode+this.mImagePassFooter\n ;var res=this.mRenderer.CreateShader(vsSource,fsSource)\n ;if(res.mResult==false)return res.mInfo\n ;if(this.mProgram!=null)this.mRenderer.DestroyShader(this.mProgram)\n ;this.mProgram=res\n ;return null;}\n\nEffectPass.prototype.NewShader=function(shaderCode,commonSourceCodes\n){if(this.mRenderer==null)return null\n ;var res=null\n       ;if(this.mType==\"sound\")res=this.NewShader_Sound(shaderCode,commonSourceCodes)\n ;else if(this.mType==\"image\")res=this.NewShader_Image(shaderCode,commonSourceCodes)\n ;else if(this.mType==\"buffer\")res=this.NewShader_Image(shaderCode,commonSourceCodes)\n ;else if(this.mType==\"common\")res=this.NewShader_Common(shaderCode)\n ;this.mSource=shaderCode\n ;return res;}\n\n\nEffectPass.prototype.DestroyInput=function(id\n){if(this.mInputs[id]==null)return\n ;if(this.mInputs[id].mInfo.mType==\"texture\"){if(this.mInputs[id].globject!=null)this.mRenderer.DestroyTexture(this.mInputs[id].globject);}\n ;if(this.mInputs[id].mInfo.mType==\"volume\"){if(this.mInputs[id].globject!=null)this.mRenderer.DestroyTexture(this.mInputs[id].globject)\n ;}else if(this.mInputs[id].mInfo.mType==\"webcam\"\n ){this.mInputs[id].video.pause()\n  ;this.mInputs[id].video.src=\"\"\n  ;var tracks=this.mInputs[id].video.stream.getVideoTracks()\n  ;if(tracks)tracks[0].stop()\n  ;this.mInputs[id].video=null\n  ;if(this.mInputs[id].globject!=null)this.mRenderer.DestroyTexture(this.mInputs[id].globject)\n ;}else if(this.mInputs[id].mInfo.mType==\"video\"\n ){this.mInputs[id].video.pause()\n  ;this.mInputs[id].video=null\n  ;if(this.mInputs[id].globject!=null)            this.mRenderer.DestroyTexture(this.mInputs[id].globject)\n ;}else if(this.mInputs[id].mInfo.mType==\"music\"||this.mInputs[id].mInfo.mType==\"musicstream\"\n ){this.mInputs[id].audio.pause()\n  ;this.mInputs[id].audio.mSound.mFreqData=null\n  ;this.mInputs[id].audio.mSound.mWaveData=null\n  ;this.mInputs[id].audio=null\n  ;if(this.mInputs[id].globject!=null)            this.mRenderer.DestroyTexture(this.mInputs[id].globject)\n ;}else if(this.mInputs[id].mInfo.mType==\"cubemap\"){if(this.mInputs[id].globject!=null)this.mRenderer.DestroyTexture(this.mInputs[id].globject)\n ;}else if(this.mInputs[id].mInfo.mType==\"keyboard\"\n ){//if(this.mInputs[id].globject!=null)//commented out in the original\n  ;// this.mRenderer.DestroyTexture(this.mInputs[id].globject)//commented out in the original\n ;}else if(this.mInputs[id].mInfo.mType==\"mic\"\n ){this.mInputs[id].mic=null\n  ;if(this.mInputs[id].globject!=null)this.mRenderer.DestroyTexture(this.mInputs[id].globject)  ;}\n ;this.mInputs[id]=null;}\n\n\nEffectPass.prototype.StopInput=function(id\n){var inp=this.mInputs[id]\n ;if(inp==null){\n ;}else if(inp.mInfo.mType==\"music\"||inp.mInfo.mType==\"musicstream\"\n ){if(inp.audio.mPaused==false){inp.audio.pause();inp.audio.mPaused=true;}return inp.audio.mPaused;}\n  ;return null;}\n\nEffectPass.prototype.ResumeInput=function(id\n){var inp=this.mInputs[id]\n ;if(inp==null){\n ;}else if(inp.mInfo.mType==\"music\"||inp.mInfo.mType==\"musicstream\"\n ){if(inp.audio.mPaused){inp.audio.play();inp.audio.mPaused=false;}return inp.audio.mPaused;}\n ;return null;}\n\nEffectPass.prototype.Paint_Image=function(vrData,wa,d,time,dtime,fps,mouseOriX,mouseOriY,mousePosX,mousePosY,x,y,buffers,keyboard\n){var dates=[d.getFullYear(),d.getMonth(),d.getDate()//YYYY,MM,DD,\n ,d.getHours()*60*60+d.getMinutes()*60+d.getSeconds()+d.getMilliseconds()/1000.0]//secondsSince0AM\n ;this.mRenderer.AttachShader(this.mProgram)\n ;this.mRenderer.ssc1F(\"iTime\",time)\n ;this.mRenderer.ssc3F(\"iResolution\",x,y,1.0)\n ;this.mRenderer.ssc4FV(\"iMouse\",[mousePosX,mousePosY,mouseOriX,mouseOriY])\n ;this.mRenderer.ssc4FV(\"iDate\",dates)//YYYY,MM,DD,sssssss.ssss\n ;this.mRenderer.ssc1F(\"iSampleRate\",this.mSampleRate)\n ;this.mRenderer.ssc1I(\"iFrame\",this.mFrame)\n ;this.mRenderer.ssc1F(\"iTimeDelta\",dtime)\n ;this.mRenderer.SetViewport([0,0,x,y])\n ;this.mRenderer.DrawFullScreenTriangle_XY(this.mRenderer.GetAttribLocation(this.mProgram,\"pos\"));}\n\nEffectPass.prototype.Paint_Sound=function(wa,d\n){var dates=[d.getFullYear(),d.getDate(),d.getHours()*60.0*60+d.getMinutes()*60+d.getSeconds()]\n ;var resos=[0,0,0,0,0,0,0,0,0,0,0,0]\n ;this.mRenderer.SetRenderTarget(this.mRenderFBO)\n ;this.mRenderer.SetViewport([0,0,this.mTextureDimensions,this.mTextureDimensions])\n ;this.mRenderer.AttachShader(this.mProgram)\n ;this.mRenderer.SetBlend(false)\n ;var texID=[null,null,null,null]\n ;for(var i=0;i<this.mInputs.length;i++\n ){var inp=this.mInputs[i]\n  ;if(inp==null){}else if(inp.mInfo.mType==\"texture\"\n  ){if(inp.loaded==true\n   ){texID[i]=inp.globject\n    ;resos[3*i+0]=inp.image.width;resos[3*i+1]=inp.image.height;resos[3*i+2]=1\n ;}}else if(inp.mInfo.mType==\"volume\"\n ){if(inp.loaded==true\n  ){texID[i]=inp.globject\n   ;resos[3*i+0]=inp.mImage.mXres\n   ;resos[3*i+1]=inp.mImage.mYres\n   ;resos[3*i+2]=inp.mImage.mZres;}}}\n ;\n ;var l2=this.mRenderer.sscLocation(this.mProgram,\"iBlockOffset\")\n ;this.mRenderer.ssc4FV(\"iDate\",dates)\n ;this.mRenderer.ssc3FV(\"iChannelResolution\",resos)\n ;this.mRenderer.ssc1F(\"iSampleRate\",this.mSampleRate)\n ;var l1=this.mRenderer.GetAttribLocation(this.mProgram,\"pos\")\n ;var numSamples=this.mTmpBufferSamples\n ;var bufL=this.mBuffer.getChannelData(0)//Float32Array\n ;var bufR=this.mBuffer.getChannelData(1)//Float32Array\n ;var numBlocks=this.mPlaySamples/numSamples\n ;for(var j=0;j<numBlocks;j++\n ){var off=j*this.mTmpBufferSamples\n  ;this.mRenderer.ssc1F_Pos(l2,off/this.mSampleRate)\n  ;this.mRenderer.DrawUnitQuad_XY(l1)\n  ;this.mRenderer.GetPixelData(this.mData,this.mTextureDimensions,this.mTextureDimensions)\n  ;for(var i=0;i<numSamples;i++\n  ){bufL[off+i]=-1.0+2.0*(this.mData[4*i+0]+256.0*this.mData[4*i+1])/65535.0\n   ;bufR[off+i]=-1.0+2.0*(this.mData[4*i+2]+256.0*this.mData[4*i+3])/65535.0;}}\n ;this.mRenderer.DetachShader()\n ;this.mRenderer.SetRenderTarget(null)\n ;//below lines are webaudio syntax,the webaudio contexts makes precise synchronization/streaming almost impossible.\n ;if(this.mPlayNode!=null){this.mPlayNode.disconnect();this.mPlayNode.stop();}\n ;this.mPlayNode=wa.createBufferSource()\n ;this.mPlayNode.buffer=this.mBuffer\n ;this.mPlayNode.connect(this.mGainNode)\n ;this.mPlayNode.state=this.mPlayNode.noteOn\n ;this.mPlayNode.start(0);}\n\nEffectPass.prototype.Paint=function(vrData,wa,da,time,dtime,fps,mouseOriX,mouseOriY\n ,mousePosX,mousePosY,x,y,isPaused,bufferID,bufferNeedsMimaps,buffers,keyboard\n){if(this.mType===\"sound\"\n ){if(this.mFrame==0&&!isPaused\n  ){this.Paint_Sound(wa,da)\n   ;this.mFrame++\n ;}}else if(this.mType===\"image\"\n ){this.mRenderer.SetRenderTarget(null)\n  ;this.Paint_Image(vrData,wa,da,time,dtime,fps,mouseOriX,mouseOriY,mousePosX,mousePosY,x,y,buffers,keyboard)\n  ;this.mFrame++\n ;}else if(this.mType===\"common\"){}else if(this.mType==\"buffer\"\n ){}}\n\nEffectPass.prototype.StopOutput_Sound=function(wa  ){if(this.mPlayNode===null)return;this.mPlayNode.disconnect();};\nEffectPass.prototype.ResumeOutput_Sound=function(wa){if(this.mPlayNode===null)return;this.mPlayNode.connect(this.mGainNode);};\nEffectPass.prototype.StopOutput_Image=function(wa){};\nEffectPass.prototype.ResumeOutput_Image=function(wa){};\nEffectPass.prototype.StopOutput=function(wa\n){for(var j=0;j<this.mInputs.length;j++)this.StopInput(j)\n ;if(this.mType==\"sound\")this.StopOutput_Sound(wa)\n ;else this.StopOutput_Image(wa);}\n\nEffectPass.prototype.ResumeOutput=function(wa\n){for(var j=0;j<this.mInputs.length;j++)this.ResumeInput(j)\n ;if(this.mType==\"sound\")         this.ResumeOutput_Sound(wa)\n ;else         this.ResumeOutput_Image(wa);}\n\nfunction Effect(vr,ac,gl,x,y,callback,obj,forceMuted,forcePaused\n){this.eCreated=false\n ;this.mRenderer=null\n ;this.mAudioContext=ac\n ;this.mContext=gl\n ;this.mRenderingStereo=false\n ;this.mXres=x\n ;this.mYres=y\n ;this.mForceMuted=forceMuted\n ;if(ac==null)this.mForceMuted=true\n ;this.mForcePaused=forcePaused\n ;this.mGainNode=null\n ;this.mPasses=[]\n ;this.mFrame=0\n ;this.mTextureCallbackFun=callback\n ;this.mTextureCallbackObj=obj\n ;this.mMaxBuffers=4\n ;this.mMaxPasses=this.mMaxBuffers+1+1//some day decouple passes from buffers\n ;this.mBuffers=[]\n ;if(gl==null)return\n ;this.mRenderer=piRenderer()\n ;if(!this.mRenderer.Initialize(gl))return\n ;var caps=this.mRenderer.GetCaps()\n ,i2=mIs20=caps.mIsGL20\n ,of=(i2?\"out\":\"gl_Frag\")+\"Color=texture\"\n ,oc=i2?\"out vec4 outColor;\":\"\"\n ,vs1=(i2?\"layout(location=0)in\":\"attribute\")+\" vec2 p;void main(){gl_Position=vec4(p.xy,0,1);}\"\n ;this.pShaderTextureLOD=caps.pShaderTextureLOD\n ;if(ac!=null\n ){this.mGainNode=ac.createGain()\n  ;if(!forceMuted){this.mGainNode.connect(ac.destination);}\n  ;if(this.mForceMuted)this.mGainNode.gain.value=0.0\n  ;else this.mGainNode.gain.value=1.0;}\n ;var res=this.mRenderer.CreateShader(vs1,\"uniform vec4 v;uniform sampler2D t;\"+oc+\"void main(){\"+of+(i2?\"Lod\":\"2D\")+\"(t,gl_FragCoord.xy/v.zw,\"+(i2?\"\":\"-10\")+\"0.0);}\")\n ;if(res.mResult==false){console.log(\"Effect().CreateShader() failed:\"+res.mInfo);return;}\n ;this.mProgramCopy=res \n ;var res=this.mRenderer.CreateShader(vs1,\"uniform vec4 v;uniform sampler2D t;\"+oc+\"void main(){vec2 uv=gl_FragCoord.xy/v.zw;\"+of+(i2?\"\":\"2D\")+\"(t,vec2(uv.x,1.-uv.y));}\")\n ;if(res.mResult==false){console.log(\"CreateShader() Failed:\"+res);return;}\n ;this.mProgramDownscale=res\n ;this.ResizeBuffers(null,null)\n ;var keyboardData=new Uint8Array(256*3)\n ;for(var j=0;j<(256*3);j++){keyboardData[j]=0;}\n ;var kayboardTexture=this.mRenderer.CreateTexture(0,256,3,this.mRenderer.TEXFMT.C1I8,0,0,null)\n ;var keyboardImage=new Image()\n ;if(callback!=null)keyboardImage.src=\"/keyboard.png\";//don't load PNG if no UI \n ;this.mKeyboard={mData:keyboardData,mTexture:kayboardTexture,mIcon:keyboardImage}\n ;this.eCreated=true;}\n\nEffect.prototype.ResizeBuffers=function(oldXres,oldYres\n){var needCopy=(oldXres!=null&&oldYres!=null)\n ;if(!needCopy    //first time!\n ){var thumnailRes=[256,128]\n  ;for(var i=0;i<this.mMaxBuffers;i++\n  ){this.mBuffers[i]={mTexture:[null,null]\n   ,mTarget: [null,null]\n   ,mLastRenderDone:0\n   ,mThumbnailRenderTarget:null//thumbnailRenderTarget\n   ,mThumbnailTexture:null//thumbnailTexture\n   ,mThumbnailBuffer: null//thumbnailBuffer\n   ,mThumbnailRes:thumnailRes};}}\n ;//Prepare for rendering\n ;if(needCopy\n ){}\n ;//Resize each double buffer\n ;for(var i=0;i<this.mMaxBuffers;i++\n ){var texture1=this.mRenderer.CreateTexture(0\n  ,this.mXres,this.mYres\n  ,this.mRenderer.TEXFMT.C4F32\n  ,(needCopy)? this.mBuffers[i].mTexture[0].mFilter:0\n  ,(needCopy)? this.mBuffers[i].mTexture[0].mWrap  :0\n  ,null)\n  ;var target1=this.mRenderer.CreateRenderTarget(texture1,null,null,null,null,false)\n  ;var texture2=this.mRenderer.CreateTexture(0\n  ,this.mXres,this.mYres\n  ,this.mRenderer.TEXFMT.C4F32\n  ,(needCopy)? this.mBuffers[i].mTexture[1].mFilter:0\n  ,(needCopy)? this.mBuffers[i].mTexture[1].mWrap  :0\n  ,null)\n  ;var target2=this.mRenderer.CreateRenderTarget(texture2,null,null,null,null,false)\n  ;if(needCopy){//Copy old buffers 1 to new buffer\n   ;this.mRenderer.SetRenderTarget(target1)\n   ;this.mRenderer.DrawUnitQuad_XY(l1)\n   ;//Copy old buffers 2 to new buffer\n   ;this.mRenderer.SetRenderTarget(target2)\n   ;this.mRenderer.DrawUnitQuad_XY(l1)\n   ;//Deallocate old memory\n   ;this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0])\n   ;this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0])\n   ;this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1])\n   ;this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);}\n  ;//Store new buffers\n  ;this.mBuffers[i].mTexture=[texture1,texture2],this.mBuffers[i].mTarget=[target1,target2],this.mBuffers[i].mLastRenderDone=0;}\n ;if(needCopy){this.mRenderer.DetachShader();this.mRenderer.SetRenderTarget(null);};}\n\nEffect.prototype.ToggleVolume=function(\n){this.mForceMuted=!this.mForceMuted\n ;//outp\n ;if(this.mForceMuted)this.mGainNode.gain.value=0.0\n ;else this.mGainNode.gain.value=1.0\n ;//inp\n ;var num=this.mPasses.length\n ;for(var j=0;j<num;j++){for(var i=0;i<this.mPasses[j].mInputs.length;i++){}}\n ;return this.mForceMuted;}\n\nEffect.prototype.SetKeyDown=function(passid,k\n){//alert(\"Effect.prototype.SetKeyDown;\"+passid+\",\"+k)\n ;this.mKeyboard.mData[k+0*256]=255\n ;this.mKeyboard.mData[k+1*256]=255\n ;this.mKeyboard.mData[k+2*256]=255-this.mKeyboard.mData[k+2*256]\n ;this.mRenderer.UpdateTexture(this.mKeyboard.mTexture,0,0,256,3,this.mKeyboard.mData)\n ;var num=this.mPasses.length\n ;for(var j=0;j<num;j++\n ){alert(\"Effect.prototype.SetKeyDown000;\"+j+\" \")\n  ;for(var i=0;i<this.mPasses[j].mInputs.length;i++\n  ){var inp=this.mPasses[j].mInputs[i]\n   ;if(inp!=null&&inp.mInfo.mType==\"keyboard\"\n   ){alert(\"Effect.prototype.SetKeyDown;\"+j+\" \"+i)//never happerns MEH!\n   if(this.mTextureCallbackFun!=null\n   )this.mTextureCallbackFun(this.mTextureCallbackObj,i,{mImage:this.mKeyboard.mIcon,mData:this.mKeyboard.mData}\n   ,false,6,1,-1.0,this.mPasses[j].mID);}}}}\n\nEffect.prototype.SetKeyUp=function(passid,k\n){this.mKeyboard.mData[k+0*256]=0\n ;this.mKeyboard.mData[k+1*256]=0\n ;this.mRenderer.UpdateTexture(this.mKeyboard.mTexture,0,0,256,3,this.mKeyboard.mData)\n ;var num=this.mPasses.length\n ;for(var j=0;j<num;j++\n ){for(var i=0;i<this.mPasses[j].mInputs.length;i++\n  ){var inp=this.mPasses[j].mInputs[i]\n   ;if(inp!=null&&inp.mInfo.mType==\"keyboard\"\n   ){if(this.mTextureCallbackFun!=null\n   )this.mTextureCallbackFun(this.mTextureCallbackObj,i,{mImage:this.mKeyboard.mIcon,mData:this.mKeyboard.mData}\n   ,false,6,1,-1.0,this.mPasses[j].mID);}}}}\n\nEffect.prototype.StopOutputs=function(\n){var wa=this.mAudioContext,num=this.mPasses.length\n ;for(var i=0;i<num;i++){this.mPasses[i].StopOutput(wa);}}\n\nEffect.prototype.ResumeOutputs=function(\n){var wa=this.mAudioContext,num=this.mPasses.length\n ;for(var i=0;i<num;i++){this.mPasses[i].ResumeOutput(wa);}}\n\nEffect.prototype.SetSize=function(x,y\n){if(x !==this.mXres||y !==this.mYres\n ){var oldXres=this.mXres\n  ;var oldYres=this.mYres\n  ;this.mXres=x\n  ;this.mYres=y\n  ;this.ResizeBuffers(oldXres,oldYres)\n  ;return true;}\n ;return false;}\n\n\nEffect.prototype.UpdateInputs=function(passid,fu\n){this.mPasses[passid].UpdateInputs(this.mAudioContext,fu,this.mKeyboard);}\n\nEffect.prototype.ResetTime=function(\n){this.mFrame=0\n ;var num=this.mPasses.length\n ;for(var i=0;i<num;i++){this.mPasses[i].mFrame=0}}\n\nEffect.prototype.RequestAnimationFrame=function(id){requestAnimFrame(id);}\n\nEffect.prototype.Paint=function(time,dtime,fps,mouseOriX,mouseOriY,mousePosX,mousePosY,isPaused\n){var wa=this.mAudioContext\n ;var da=new Date()\n ;var vrData=null\n ;var x=this.mXres/1\n ;var y=this.mYres/1\n ;var num=this.mPasses.length\n ;if(this.mFrame==0\n ){for(var i=0;i<this.mMaxBuffers;i++\n ){this.mRenderer.SetRenderTarget(this.mBuffers[i].mTarget[0])\n  ;this.mRenderer.Clear(1,[0.0,0.0,0.0,0.0],1.0,0)\n  ;this.mRenderer.SetRenderTarget(this.mBuffers[i].mTarget[1])\n  ;this.mRenderer.Clear(1,[0.0,0.0,0.0,0.0],1.0,0);}}\n ;for(var i=0;i<num;i++//render sound first\n ){if(this.mPasses[i].mType!=\"sound\")continue\n  ;if(this.mPasses[i].mProgram==null)continue\n  ;this.mPasses[i].Paint(vrData,wa,da,time,dtime,fps,mouseOriX,mouseOriY,mousePosX,mousePosY,x,y,isPaused,null\n  ,false,this.mBuffers,this.mKeyboard);}\n ;for(var i=0;i<num;i++//render buffers second\n ){if(this.mPasses[i].mType!=\"buffer\")continue\n  ;if(this.mPasses[i].mProgram==null)continue\n  ;//check if any downstream pass needs mipmaps when reading from this buffer\n  ;var needMipMaps=false\n  ;for(var j=0;j<num;j++\n  ){for(var k=0;k<this.mPasses[j].mInputs.length;k++\n   ){var inp=this.mPasses[j].mInputs[k]\n    ;if(inp!=null&&inp.mInfo.mType==\"buffer\"&&inp.id===bufferID&&inp.mInfo.mSampler.filter===\"mipmap\"){needMipMaps=true;break;}}}\n  ;this.mPasses[i].Paint(vrData,wa,da,time,dtime,fps,mouseOriX,mouseOriY,mousePosX,mousePosY,x,y,isPaused\n  ,bufferID,needMipMaps,this.mBuffers,this.mKeyboard);}\n ;for(var i=0;i<num;i++//render image last\n ){if(this.mPasses[i].mType!=\"image\")continue\n  ;if(this.mPasses[i].mProgram==null)continue\n  ;this.mPasses[i].Paint(vrData,wa,da,time,dtime,fps,mouseOriX,mouseOriY,mousePosX,mousePosY,x,y,isPaused,null,false,this.mBuffers,this.mKeyboard);}   \n ;for(var k=0;k<256;k++){this.mKeyboard.mData[k+1*256]=0;} //erase keypresses\n ;this.mRenderer.UpdateTexture(this.mKeyboard.mTexture,0,0,256,3,this.mKeyboard.mData)\n ;this.mFrame++;}\n\nEffect.prototype.NewShader=function(shaderCode,passid\n){var commonSourceCodes=[]\n ;for(var i=0;i<this.mPasses.length;i++){if(this.mPasses[i].mType==\"common\"){commonSourceCodes.push(this.mPasses[i].mSource);}}\n ;return this.mPasses[passid].NewShader(shaderCode,commonSourceCodes);}\n\nEffect.prototype.GetNumPasses=function(){return this.mPasses.length;}\n\nEffect.prototype.GetNumOfType=function(passtype\n){var id=0;for(var j=0;j<this.mPasses.length;j++){if(this.mPasses[j].mType===passtype){id++;}}return id;}\n\nEffect.prototype.GetPassType=function(id){return this.mPasses[id].mType;}\nEffect.prototype.GetPassName=function(id){return this.mPasses[id].mName;}\n\nEffect.prototype.newPass=function(jobj\n){var numPasses=jobj.renderpass.length\n ;//alert(\"Effect.prototype.newPass  jobj.renderpass.length=\"+jobj.renderpass.length)\n ;if(numPasses<1||numPasses>this.mMaxPasses\n ){return{mFailed:true,mError:\"Incorrect number of passes,wrong shader format\",mShader:null};}\n ;var res=[]\n ;res.mFailed=false\n ;for(var j=0;j<numPasses;j++\n ){var rpass=jobj.renderpass[j]\n  ;this.mPasses[j]=new EffectPass(this.mRenderer,mIs20,this.pShaderTextureLOD\n  ,this.mTextureCallbackFun,this.mTextureCallbackObj,this.mForceMuted,this.mForcePaused,this.mGainNode\n  ,this.mProgramDownscale,j)\n  ;//skip sound passes if in thumbnail mode\n  ;if(this.mForceMuted&&rpass.type==\"sound\")continue\n  ;var numInputs=rpass.inputs.length\n  ;for(var i=0;i<numInputs;i++){}\n  ;for(var i=0;i<4;i++){}\n  ;var numOutputs=rpass.outputs.length\n  ;for(var i=0;i<numOutputs;i++){}\n  ;//create some hardcoded names. This should come from the DB\n  ;var rpassName=\"\"\n  ;if(rpass.type==\"common\")rpassName=\"Common\"\n  ;if(rpass.type==\"sound\")rpassName=\"Sound\"\n  ;this.mPasses[j].Create(rpass.type,rpassName,this.mAudioContext);}\n ;for(var pt=0;pt<4;pt++\n ){for(var j=0;j<numPasses;j++\n  ){var rpass=jobj.renderpass[j]\n   ;if(pt==0&&rpass.type!=\"common\")continue\n   ;if(pt==3&&rpass.type!=\"sound\")continue\n   ;if(this.mForceMuted&&rpass.type==\"sound\")continue\n   ;var shaderStr=rpass.code\n   ;var result=this.NewShader(shaderStr,j)\n   ;if(result!=null){res.mFailed=true;res[j]={mFailed:true,mError:result,mShader:shaderStr}\n   ;}else {res[j]={mFailed:false,mError:null,mShader:shaderStr};}}}\n ;return res;}\n\nEffect.prototype.DestroyPass=function(id){this.mPasses[id].Destroy(this.mAudioContext);this.mPasses.splice(id,1);}\n\nEffect.prototype.addep=function(passType,passName\n){var shaderStr=null\n ;if(passType==\"sound\")shaderStr=gei('s') //\"vec2 mainSound( in int samp,float time){return vec2(sin(6.2831*\\n440.0*time)*exp(-3.0*time));}\"\n ;if(passType==\"buffer\")shaderStr=gei('a') //\"void mainImage(out vec4 fragColor,in vec2 fragCoord)\\n{\\n    fragColor=vec4(0.0,0.0,1.0,1.0);\\n}\"\n ;if(passType==\"common\")shaderStr=gei('o')//\"vec4 someFunction(vec4 a,float b)\\n{\\n    return a+b;\\n}\"\n ;var id=this.GetNumPasses()\n ;this.mPasses[id]=new EffectPass(this.mRenderer,mIs20,this.pShaderTextureLOD\n ,this.mTextureCallbackFun,this.mTextureCallbackObj,this.mForceMuted,this.mForcePaused,this.mGainNode,this.mProgramDownscale,id)\n ;this.mPasses[id].Create(passType,passName,this.mAudioContext)\n ;var res=this.NewShader(shaderStr,id)\n ;return{mId:id,mShader:shaderStr,mError:res};}\n\nfunction ShaderToy(\n){var me=this\n ;me.mContext=null\n ;me.mTo=null\n ;me.mCanvas=null\n ;me.mFPS=piCreateFPSCounter()\n ;me.mInfo=null\n ;me.mPass=[]\n ;var devicePixelRatio=window.devicePixelRatio||1\n ;me.mCanvas=document.getElementById(\"demogl\")\n ;me.mCanvas.tabIndex=\"0\"//make it react to keyboard\n ;me.mCanvas.width=me.mCanvas.offsetWidth//* devicePixelRatio\n ;me.mCanvas.height=me.mCanvas.offsetHeight//* devicePixelRatio\n ;me.mHttpReq=new XMLHttpRequest()\n ;me.mTo=getRealTime()\n ;mTf=0\n ;me.mFPS.Reset(me.mTo)\n ;me.mMouseIsDown=false\n ;me.mMouseOriX=0\n ;me.mMouseOriY=0\n ;me.mMousePosX=0\n ;me.mMousePosY=0\n ;me.mContext=piCreateGlContext(me.mCanvas,false,false,true,false)//need preserve-buffe to true in order to capture screenshots\n ;mAudioContext=piCreateAudioContext()\n ;window.onfocus=function(){if(!paused){mTOffset=me.mTf;me.mTo=getRealTime();me.mRestarted=true;}}\n ;var refreshCharsAndFlags=function(){setTimeout(refreshCharsAndFlags,1500);}\n ;me.mEditorState={mCursorChange:false,mViewportChange:false,mCodeChange:false}\n ;me.mErrors=new Array()\n ;\n ;me.mCanvas.onmousedown=function(ev\n ){var rect=me.mCanvas.getBoundingClientRect()\n  ;me.mMouseOriX=Math.floor((ev.clientX-rect.left)/(rect.right-rect.left)*me.mCanvas.width)\n  ;me.mMouseOriY=Math.floor(me.mCanvas.height-(ev.clientY-rect.top)/(rect.bottom-rect.top)*me.mCanvas.height)\n  ;me.mMousePosX=me.mMouseOriX\n  ;me.mMousePosY=me.mMouseOriY\n  ;me.mMouseIsDown=true;}\n ;\n ;me.mCanvas.onmousemove=function(ev\n ){if(me.mMouseIsDown\n  ){var rect=me.mCanvas.getBoundingClientRect()\n   ;me.mMousePosX=Math.floor((ev.clientX-rect.left)/(rect.right-rect.left)*me.mCanvas.width)\n   ;me.mMousePosY=Math.floor(me.mCanvas.height-(ev.clientY-rect.top)/(rect.bottom-rect.top)*me.mCanvas.height);}}\n ;\n ;me.mCanvas.onmouseup=function(ev\n ){me.mMouseIsDown=false\n  ;me.mMouseOriX=-Math.abs(me.mMouseOriX)\n  ;me.mMouseOriY=-Math.abs(me.mMouseOriY);}\n ;\n ;document.getElementById(\"myResetButton\").onclick=function(ev){me.resetTime(true);}\n ;document.getElementById(\"myPauseButton\").onclick=function(ev){me.pauseTime(true);}\n ;document.getElementById(\"myVolume\").onclick=function(ev ){var res=mEffect.ToggleVolume();}\n ;var mFullScreenExitHandler=function(){}\n ;me.mCanvas.addEventListener('webkitfullscreenchange',mFullScreenExitHandler,false)\n ;me.mCanvas.addEventListener('mozfullscreenchange',mFullScreenExitHandler,false)\n ;me.mCanvas.addEventListener('fullscreenchange',mFullScreenExitHandler,false)\n ;me.mCanvas.addEventListener('MSFullscreenChange',mFullScreenExitHandler,false)\n ;document.getElementById(\"myFullScreen\").onclick=function(ev){piRequestFullScreen(me.mCanvas);me.mCanvas.focus();}\n ;mEffect=new Effect(null,mAudioContext,me.mContext,me.mCanvas.width,me.mCanvas.height,me.RefreshTexturThumbail,this,false,false)\n ;if(!mEffect.eCreated){paused=true;return;}\n ;me.mCanvas.addEventListener(\"webglcontextlost\",function(event\n ){event.preventDefault();paused=true;alert('WebGL implementation crashed');},false);\n ;this.mMediaRecorder=null\n ;document.getElementById(\"myRecord\").onclick=function(ev\n ){if(me.mMediaRecorder==null\n  ){me.mMediaRecorder=piCreateMediaRecorder(function(b\n   ){var ele=document.getElementById(\"myRecord\")\n    ;if(b){}else{}//currently recording or not\n   ;},me.mCanvas);}\n  ;if(me.mMediaRecorder==null\n  ){let ele=document.getElementById(\"myRecord\")\n   ;ele.style.background=\"url('/img/themes/classic/recordDisabled.png')\"\n   ;alert('MediaRecord API is not supported in this browser')\n   ;return;}\n  ;if(me.mMediaRecorder.state==\"inactive\"){me.mMediaRecorder.start()\n  ;}else{me.mMediaRecorder.stop();}}\n ;}\n\n\n//all below this line is pretty much minified\n\nShaderToy.prototype.startRendering=function(\n){var me=this\n ;function renderLoop2(\n ){if(me.mContext==null)return\n  ;mEffect.RequestAnimationFrame(renderLoop2)\n  ;if(paused){mEffect.UpdateInputs(me.mActiveDoc,false);return;}\n  ;var time=getRealTime()\n  ;var ltime=0.0\n  ;var dtime=0.0\n  ;if(paused){ltime=me.mTf;dtime=1000.0/60.0\n  ;}else \n   {ltime=mTOffset+time-me.mTo\n   ;if(me.mRestarted)dtime=1000.0/60.0\n   ;else dtime=ltime-me.mTf\n   ;me.mTf=ltime;}\n  ;me.mRestarted=false\n  ;var newFPS=me.mFPS.Count(time)\n  ;mEffect.Paint(ltime/1000.0,dtime/1000.0,me.mFPS.GetFPS(),me.mMouseOriX,me.mMouseOriY,me.mMousePosX,me.mMousePosY,paused)\n  ;document.getElementById(\"myTime\").textContent=(ltime/1000.0).toFixed(2)+\"/\"+90*sRs[0]/sRs[sR]+\".00\"\n  ;if(paused){\n  ;}else{if(newFPS\n    ){document.getElementById(\"myFramerate\").textContent=\" fps:\"+me.mFPS.GetFPS().toFixed(1)+\" \"+wMs[wM];}}}\n ;renderLoop2();}\n\nfunction resize(\n){var s=document.getElementById(\"demogl\");if(s){//is a bit overly excessive.\n ;s.setAttribute(\"width\",s.offsetWidth)\n ;s.setAttribute(\"height\",s.offsetHeight)\n ;s.width=s.offsetWidth;s.height=s.offsetHeight\n ;mEffect.SetSize(s.offsetWidth,s.offsetHeight);}}\n\nShaderToy.prototype.pauseTime=function(doFocusCanvas\n){if(!paused\n ){paused=true;mEffect.StopOutputs()\n ;}else\n  {mTOffset=mTf\n  ;this.mTo=getRealTime()\n  ;paused=false\n  ;mRestarted=true\n  ;mEffect.ResumeOutputs()\n  ;if(doFocusCanvas)this.mCanvas.focus();}}\n\nShaderToy.prototype.resetTime=function(doFocusOnCanvas\n){mTOffset=0\n ;this.mTo=getRealTime()\n ;mTf=0\n ;mRestarted=true\n ;this.mFpsTo=this.mTo\n ;this.mFpsFrame=0\n ;mEffect.ResetTime()\n ;if(doFocusOnCanvas)this.mCanvas.focus();}//put mouse/keyboard focus on canvas\n\n\nfunction watchInit(\n){gShaderToy=new ShaderToy()\n ;var kk={\"renderpass\":\n\t\t      [{\"inputs\":[],\"outputs\":[{\"channel\":0,\"id\":37      }],\"type\":\"image\" ,\"code\":gei('i')}\n\t\t    \t,{\"inputs\":[],\"outputs\":[{\"channel\":0,\"id\":\"none\"  }],\"type\":\"common\",\"code\":gei('o')}\n          ]}\n ;gShaderToy.pauseTime();\n ;gRes=mEffect.newPass(kk) \n ;gShaderToy.pauseTime();\n ;gShaderToy.startRendering()\n ;if(mEffect.GetNumOfType(\"sound\")<1){\n  ;var res=mEffect.addep(\"sound\",\"Sound\")\n  ;gShaderToy.mPass[res.mId]={mDocs:CodeMirror.Doc(res.mShader,\"text/x-glsl\")}\n  ;}\n ;gShaderToy.pauseTime();\n ;} \n\n</script>\n\n</head><body onload=\"watchInit();\" onresize=\"resize()\" class=\"n\">\n\n<table class=\"n\"><tbody class=\"n\"><tr><td>\n <div id=\"passManager\"></div>\n  <span id=\"myTime\">0.00</span><br>\n  <span id=\"myFramerate\">0.5 fps</span><br>\n  <button id=\"myResetButton\">reset</button><br>\n  <button id=\"myPauseButton\">pause</button><br>\n  <button id=\"myVolume\">volume</button><br>\n  <button id=\"myFullScreen\" >fullscreen</button><br>\n  <button id=\"myRecord\">record</button><br>\n  <button id=\"myVR\">vr</button><br>\n  <button  onclick=\"showHelp()\">shade</div><br>\n  </td><td>\n  <canvas id=\"demogl\" class=\"n\" tabindex=\"0\"></canvas>\n</div>\n\n    </td></tr></tbody></table>\n\n\n\n</body></html>\n\n\n\n//remove this line from the html document and the very first line of it /**/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3Rm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[736, 736, 793, 843, 1052]], "test": "untested"}
{"id": "tty3Rm", "name": "Forbidden Path", "author": "yx", "description": "A shadertoy port of my Graphics entry at MAGFest Demoparty 2020. Placed 1st out of 3 entries.\n\nDownload the original executable version here: [url]https://www.pouet.net/prod.php?which=84472[/url]", "tags": ["pathtracer", "magfest"], "likes": 27, "viewed": 1232, "published": 3, "date": "1578514331", "time_retrieved": "2024-07-30T21:31:02.456616", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 tex = texture(iChannel0,uv);\n    \n    // divide by sample-count\n\tvec3 color = tex.rgb/tex.a;\n    \n    // vignette to darken the corners\n\tuv-=.5;\n\tcolor *= 1.-dot(uv,uv)*2.;\n    \n    // tonemap\n    color *= 10.;\n    color /= color+1.;\n    \n    // gamma correction\n\tcolor = pow(color, vec3(.45));\n    \n    // make it pop\n\tcolor = smoothstep(0.,1.,color);\n\t\n    // warm tint\n    color = pow(color,vec3(1,1.05,1.1));\n    \n    // lift the black level\n    color += .02;\n    \n\tfragColor = vec4(color,1);\n}\n\n/*\n         \"Forbidden Path\"\n          by yx/Polarity\n\n      2kb executable graphics\n released at MAGFest Demoparty 2020\n\n     greetings from england <3\n*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi (acos(-1.))\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 hash2( const float n ) {\n\treturn fract(sin(vec2(n,n+1.))*vec2(43758.5453123));\n}\n\nint m;\n\n// distance function\nfloat scenediff(vec3 p)\n{\n    float d = 1e9;\n    \n    float tunnel = length(p.yx)-1.5;\n    d=-tunnel;\n    \n    // ridges\n    {\n        vec3 q=p;\n    \tq.z=mod(q.z,.4)-.2;\n    \td=min(d,sdTorus(q.xzy,vec2(1.51,.02)));\n    }\n    \n    // floor\n    float ground = p.y+1.;\n    d=min(d,ground);\n    \n    // tiles\n    {\n        vec3 q=p;\n        q.y+=.998;\n        q.xz=rotate(q.xz,-pi*.25);\n        q.xz=mod(q.xz,.1)-.05;\n        d=max(d,.005-length(q.yx));\n        d=max(d,.005-length(q.yz));\n    }\n    \n    return d;\n}\n\nfloat scenelite(vec3 p)\n{\n    float d=1e9;\n    \n    // lamps\n    {\n        vec3 q=p;\n        q.x=abs(q.x);\n        q.xy+=vec2(-1.1,1);\n        d=min(d,max(\n            length(q.yx)-.05,\n            abs(mod(q.z-1.,2.)-1.)-.01\n        ));\n        \n        // minus lamps at grill\n        d=max(d,1.-abs(p.z));\n    }\n    \n    //lasers\n    {\n        vec3 q=p;\n        q.xy=rotate(q.xy,-pi*.25);\n        d = min(d,max(\n            abs(q.z)-.1,\n            abs(mod(q.y,.2)-.1)-.01\n        ));\n    }\n    \n    return d;\n}\n\nfloat scene(vec3 p)\n{\n    float diff=scenediff(p);\n    float lite=scenelite(p);\n    m=(lite<diff)?1:0;\n    return min(lite,diff);\n}\n\n// ray bouncing function \"borrowed\" from I can't remember where\nvec2 rv2;\nvec3 B(vec3 n) {\n    float theta = 2. * pi * rv2.x;\n    float phi = acos(1. - 2. * rv2.y);\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    \n    vec3 a = normalize(vec3(x,y,z));\n    return dot(a,n)<0.?-a:a;\n}\n\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    vec3 accum = vec3(1);\n    for(int bounce=0;bounce<4;++bounce)\n    {\n        float t=0.;\n        float k;\n        for(int i=0;i<100;++i)\n        {\n            k = scene(cam+dir*t);\n            t += k;\n            if (abs(k) < .001)\n                break;\n        }\n        \n\t\tvec3 h = cam+dir*t;\n\t\t\t\n        // if we hit something\n        if(abs(k)<.001)\n        {\n            if (m==1){\n                if (abs(h.z)<0.2){\n                    // red laser grill\n                \treturn vec3(1,0.15,0.15) * accum;\n                }else{\n                    // gold orbs\n                    return vec3(5,2,.5) * accum;\n                }\n            }\n            \n\t\t\tvec2 o = vec2(.001, 0);\n\t\t\tk=scene(h);\n\t\t\tvec3 n = normalize(vec3(\n\t\t\t\tscene(h+o.xyy) - k,\n\t\t\t\tscene(h+o.yxy) - k,\n\t\t\t\tscene(h+o.yyx) - k \n\t\t\t));\n\n            float roughness = .85;\n            if (h.y<=-.999) {\n                if (rv2.x<.95){\n                \taccum *= 0.125;\n                \troughness = .01;\n                }\n            }\n            \n            cam = h+n*.001;\n            vec3 mirror = reflect(dir,n);\n            vec3 bounce = B(n);\n            dir= normalize(mix(mirror,bounce,roughness));\n            accum *= mix(1.,dot(dir,n),roughness);\n        }\n    }\n    \n    return vec3(0);\n}\n\nvec2 bokeh(){\n\tvec2 a=rv2;\n    if(a.y>a.x)\n        a=1.-a;\n    a.y*=pi*2./a.x;\n    return a.x*vec2(cos(a.y),sin(a.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // recover previous frame for iterative rendering\n   \tfragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\t\n    \n    // get UVs\n    vec2 uv = fragCoord.xy/iResolution.xy-.5;\n    \n    // deliberately don't seed per-pixel\n    float seed = iTime;\n\trv2 = hash2(seed);\n    \n    // jitter for antialiasing\n    uv += (rv2-.5)/iResolution.xy;\n    \n    // correct UVs for aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n\n    // careful seeding for blocky effect\n    float blockSize=exp2(clamp(floor(length(uv)*9.),2.,9.));\n    seed+=mod(floor(fragCoord.x/blockSize)+.01,1.34672);\n    seed+=mod(floor(fragCoord.y/blockSize)+.01,1.72357);\n    rv2=hash2(seed);\n\t\n    // make a camera\n    vec3 cam = vec3(0,0,-8.);\n    vec3 dir = normalize(vec3(uv,1));\n    \n    // slight bokeh\n    float ds=.005;\n    vec2 bokehJitter=bokeh();\n    cam.xy+=bokehJitter*ds;\n    dir.xy-=bokehJitter*ds*dir.z/8.;\n\n    // move the camera some more\n    cam.y -=.25;\n    dir.yz = rotate(dir.yz, .06);\n    \n    // compute the pixel color\n\tvec4 pixel = vec4(trace(cam,dir),1);\n    \n    // cap the sample-count\n    if (iFrame < 512)\n\t\tfragColor += pixel;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tty3Rm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 603]], "test": "untested"}
{"id": "wlGGRm", "name": "Quantum Rain", "author": "wyatt", "description": "[url]JAVASCRIPT: H=location.host;E=(H?window:opener).Effect;P=E.prototype;if(!E.P)E.P=P.Paint;P.Paint=function(...A){for(i=0;i<8;i++)E.P.apply(this,A);};if(!H)close();[/url]", "tags": ["schrodinger"], "likes": 25, "viewed": 633, "published": 3, "date": "1578509036", "time_retrieved": "2024-07-30T21:31:03.334270", "image_code": "Main\n{\n    Them;\n    vec3 no = normalize(vec3(\n    \tlength(e)-length(w),\n    \tlength(n)-length(s), 5\n    )), re = reflect(no,vec3(0,0,1));\n\tQ = (0.5+0.5*texture(iChannel2,re))*\n        (sin(atan(length(A(U)))*vec4(1,2,3,4)));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Main\n{\n\tQ = A(U);\n    Them;\n    \n    Q.xz += dt*(m-Q+Q*F(Q)).yw;\n    \n    Mouse;\n    Init;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n{\n\tQ = A(U);\n    Them;\n    \n    Q.yw -= dt*(m-Q+Q*F(Q)).xz;\n    Q += Loss*(m-Q);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define Main void mainImage( out vec4 Q, in vec2 U )\n#define Them vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define dt 1.\n#define F(Q) .5*( 1./(1.+length(Q)+dot(Q,Q)) + 1e-3*(U.y)*(iMouse.z>0.?0.:1.))\n#define Loss .00\n#define Init if (length(U-0.5*R) < 10.) Q = vec4(1,1,1,-1);\n#define Mouse if (iMouse.z>0.&&length(U-iMouse.xy)<20.) Q += .03*vec4(1,0,0,-1);", "buffer_c_code": "Main\n{\n\tQ = A(U);\n    Them;\n    \n    Q.xz += dt*(m-Q+Q*F(Q)).yw;\n    \n    Mouse;\n    Init;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n{\n\tQ = A(U);\n    Them;\n    \n    Q.yw -= dt*(m-Q+Q*F(Q)).xz;\n    Q += Loss*(m-Q);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Wsc3Wn", "name": "additive fractal", "author": "unnick", "description": "a thing i made a while ago that im making public", "tags": ["2d", "fractal"], "likes": 9, "viewed": 347, "published": 3, "date": "1578507508", "time_retrieved": "2024-07-30T21:31:04.144104", "image_code": "/* it basically works by making scaled copies of a repeating pattern,\n * summing those copies together, and then using a pallete to turn the sum\n * into a color.\n */\n\n#define SIZE 5.\n#define STRIDE 5\nconst float pattern[] = float[](\n    2.,1. , 0.,1. , 2.,\n    1.,1.5, 1.,1.5, 1.,\n    0.,1. ,-2.,1. , 0.,\n    1.,1.5, 1.,1.5, 1.,\n    2.,1. , 0.,1. , 2.\n);\n\n/*\n#define SIZE 3.\n#define STRIDE 3\nconst float pattern[] = float[](\n    -1., 0.,-1.,\n     0., 1., 0.,\n    -1., 0.,-1.\n);\n*/\n\nmat2 rotmat(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = exp(sin(iTime * 1.5) * .7);\n    \n    vec2 pos = (fragCoord*2. - iResolution.xy) / iResolution.y;\n    pos *= rotmat(iTime * .5);\n    pos *= zoom;\n    pos += vec2(1., 1.5) * iTime;\n    {\n        float tmp = pow(3., SIZE);\n        pos /= tmp; zoom /= tmp;\n    }\n    \n    float detail = (log(iResolution.y / zoom)) / log(SIZE) - 1.3;\n    \n    float sum = detail * -1.;\n    for(int i = 0; i < 16; i++) {\n        pos = fract(pos);\n        pos *= SIZE;\n        if(i >= int(detail)) break;\n        sum += pattern[int(pos.x) + int(pos.y) * STRIDE];\n    };\n    sum += pattern[int(pos.x) + int(pos.y) * STRIDE] * fract(detail);\n    \n    fragColor = sin(sum + vec3(0.,.5,1.) + iTime * 3.).xyzz * .5 + .5;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsc3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[482, 482, 504, 504, 580], [582, 582, 639, 639, 1351]], "test": "untested"}
{"id": "wty3zw", "name": "Linked Twist", "author": "willstall", "description": "Dither-Styled Polar-Coordinate Linked Geometry inspired by the work of @patriciogv on his Spirit Deck Project.\n\nINSTA: instagram.com/willstall/\nWEBSITE: willstall.com\nTWITTER: twitter.com/willstall\n", "tags": ["sdf", "dither", "geometry", "polar", "hex", "hex"], "likes": 4, "viewed": 422, "published": 3, "date": "1578505670", "time_retrieved": "2024-07-30T21:31:04.888115", "image_code": "//------------------------------------------------------------------------\n// Linked Twist\n// by @willstall\n//------------------------------------------------------------------------\n\n#define SIDES 7\n\n#define SECONDS 5.0\n#define COLORS 24.0\n\n#define DITHER_AMOUNT 90.0\n#define DITHER_SIZE 8.0\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\nmat2 rotate(float angle){   return mat2( cos(angle),-sin(angle),sin(angle),cos(angle) );    }\n\nvec2 ratio(vec2 st)\n{\n    return  vec2(\n            max(st.x/st.y,1.0),\n            max(st.y/st.x,1.0)\n            );\n}\n\nvec2 center(vec2 st)\n{\n    float offset = iResolution.x/iResolution.y;\n    st.x = st.x * offset - offset * 0.5 + 0.5;\n    return st;\n}\n\nfloat divide(float x,float a){          return floor(x * a)/a;    }\n\n// cos color palette by iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\treturn a + b*cos( 6.28318*(c*t+d) );\t}\n\nvec3 color_gradient(float x){          return texture(iChannel0, vec2(x,0.5),-10.0).rgb;}\nvec3 color_gradient(float x,float a){   return color_gradient(divide(x,a));    }\n\nfloat random(vec2 st){  return fract( sin( dot(st,vec2(3.678,678.90)) )*678910.0 ); }\n\nfloat dither(vec2 st, float x, float amount)\n{\n    float s = 1.0/DITHER_SIZE;\n\n    st *= amount;\n    st.y += 0.5*step(mod(st.x,2.0),1.0);\n\n    float c = length(fract(st)-0.5)*x*0.5;\n    c = smoothstep(0.75,1.0,1.0-c)*(s)*0.5;   \n    return fract(x + c );\n    //return x+c;\n}\n\n\nfloat hex(vec2 pos)\n{\n    pos = abs(pos);\n    float d = dot(pos,normalize(vec2(1.0,1.73)));\n        d = max(d,pos.x);\n    return d;\n}\n\nvec2 hexCoords(vec2 st, out vec2 position)\n{\n    vec2 aspect = vec2(1.00,1.73);\n    vec2 h_aspect = aspect * 0.5;\n\n    vec2 a = mod(st,aspect)-h_aspect;\n    vec2 b = mod(st-h_aspect,aspect)-h_aspect;\n\n    vec2 grid;\n    if(length(a) <length(b))\n        grid = a;\n    else\n        grid = b;    \n\n    position = st-grid;\n    return vec2(grid.x,grid.y);\n}\n\nfloat cutout(float x, float y, float cut)\n{\n    float z = x;\n    z = max(z,-y+cut);\n    z = min(z,y);\n    return z;\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = fract(iTime/SECONDS);\n    float interval = floor(mod(iTime,SECONDS));\n\n\tvec2 st = fragCoord/iResolution.xy;\n    st = center(st);\n    st = st * 2.0 - 1.0;  \n    \n    vec2 uv = st;\n    \n    st *= 01.35;\n    st *= 1.0 + 0.025*sin(TWO_PI*time);\n    st *= rotate(TWO_PI*.25);      \n\n    float pixelSmoothing = 2.0;\n    float aa = ratio(iResolution.xy).x/iResolution.x;\n    aa *= pixelSmoothing;\n    \n    float cut_size = 0.1125;\n\n    const int n = SIDES;\n    float a = TWO_PI/float(n);\n\n    vec2 pos;\n    vec2 angle_st = hexCoords(st*1.0,pos);\n    float angle = atan(angle_st.x,angle_st.y)/TWO_PI+0.5;\n\n    float debug;\n    float sdf = 1.0;\n\n    float distance_offset = 0.25;\n    \n    for(int i = 0; i <= n*2; i++)\n    {\n        vec2 pos = (st) * rotate(float(i)*a)-distance_offset;\n        float size = .06*(0.5+0.5*sin(TWO_PI*time+HALF_PI*(pos.x-pos.y*.65)));\n        float d = abs(hex(pos)-0.5)+size;\n        float cut = pos.x-pos.y*.65;\n        cut = smoothstep(-aa,aa,sdf);\n        cut = (mod(float(i),2.0) >= 1.0) ? 1.0-cut :cut;\n\n        float m = cutout(d/cut,sdf/cut,cut_size);\n        sdf = min(sdf,m);\n    }\n\n    float texture = dither(st,sdf+a,DITHER_AMOUNT);\n    float cutoff = sdf-0.025;\n    cutoff = smoothstep(-aa,aa,cutoff);\n    \n    st = hexCoords(st*0.44,pos);\n    a = atan(st.x,st.y)/TWO_PI+0.5;\n\t\n    float grad = fract(texture*1.0-time*1.0+a*1.0);\n    vec3 tex = color_gradient(grad,COLORS);\n\t\n    vec3 p = palette(length(tex),vec3(1.25,0.125,0.025),vec3(0.0,0.95,0.125),vec3(1.0, 0.5, 0.0),vec3(0.5));\n    tex = p;\n    \n    float size = hex(st);\n    float outside_cutoff = max(sdf-0.25,-(sdf-0.23));\n    outside_cutoff = smoothstep(-aa,aa,outside_cutoff);\n\t\n    float bg = length(uv)-0.75-0.25*random(uv);\n    vec3 background = vec3(0.9333, 0.9333, 0.9333);\n    vec3 col = vec3(background);\n    \tcol = mix(vec3(1.0),col,bg);\n        col = mix(tex,col,cutoff);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wty3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[377, 377, 402, 402, 470], [472, 472, 493, 493, 591], [593, 593, 615, 615, 727], [729, 729, 759, 759, 796], [798, 825, 896, 896, 935], [937, 937, 966, 966, 1026], [1027, 1027, 1064, 1064, 1107], [1109, 1109, 1131, 1131, 1194], [1196, 1196, 1242, 1242, 1470], [1473, 1473, 1494, 1494, 1606], [1608, 1608, 1652, 1652, 1960], [1962, 1962, 2005, 2005, 2079], [2081, 2081, 2114, 2114, 2261], [2263, 2263, 2320, 2320, 4249]], "test": "untested"}
{"id": "WtyGzm", "name": "Day 20 - Reaction Diffusion", "author": "jeyko", "description": "Combining 3 different reaction diffusion methods.\nMethods and a lot of the code are from wyatt/flexi!", "tags": ["diffusion", "reactiondiffusion", "reaction"], "likes": 14, "viewed": 750, "published": 3, "date": "1578485663", "time_retrieved": "2024-07-30T21:31:05.638110", "image_code": "\n// A MAJORITY of this code is copy-pasted from wyatt and Flexi. \n// Go check them out!\n// Also, Shane has a great tutorial on reaction-diffusion.\n\n\n// I tried to combine 3 methods of reaction diffusion into one.\n// The stripes are one of those.\n// The other one is the vortex.\n// And the third one is the raindrops.\n\n\n#define pal(x,t) (0.5 + 0.5*sin(x*vec3(0.67,0.2,0.7) + t))\n\nMain\n{ \n    vec2 uv = (U-0.5*R)/R.y;\n    vec4 CA = Q * 1. - mix(0., 1., pow(length(uv)*0.9, 2.));\n    \n    Neighborhood\n    vec4 a = A(U);\n    \n    float noise = noise(U + floor(iTime/beat) + iTime );\n    vec3 no = normalize(vec3(grad,.5));\n    vec3 re = reflect(no,vec3(0.,0,1));\n    float density = A(U).z;\n    Q = sin(0.2*density+0.9*pal(density*2. + no*3. + iTime,6.4).xyzy*density);\n    \n    Q *= (1. + kick) + noise*(1. - kick);\n    Q = clamp(Q, 0., 1.);\n    \n    Q = pow(Q, vec4(0.8,1.4,1.1,0.));\n    \n    Q = mix(Q, CA*pal(iTime*10., 20.).xyzz*Q.x, CA.x);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 20781, "src": "https://soundcloud.com/invisiblerecordings/current-value-dna?in=tim-e-aka-current-value/sets/searcher", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "\n#define iTime (iTime + 54.1)\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define tempo 174.\n#define hbeat ((60./tempo)/1.)\n#define qnote (hbeat/2.)\n#define beat  (hbeat*2.)\n#define qbeat  (beat/4.)\n#define measure  (hbeat*2.)\n\n#define grad 0.25*vec2(e.z-w.z,n.z-s.z)\n#define div 0.25*(n.y-s.y+e.x-w.x)\n\n#define kick exp(-mod(iTime, beat)*20.)\n#define halfkick exp(-mod(iTime, hbeat)*20.)\n\n#define T(uv) texture(iChannel0, uv)\n#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n\n#define Main void mainImage( out vec4 Q, in vec2 U )\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w); \n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define N 20.\n#define For for (float i = -(N); i<=(N); i++)\n#define S 3.\n#define Gaussian(i) 0.3989422804/S*exp(-.5*(i)*(i)/S/S)\n#define Init if (iFrame < 1) \n#define Border if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)\n#define Mouse if (iMouse.z>0.&&length(U-iMouse.xy)<30.) \n\n\n#define s_n  vec2(0.0, st.y)\n#define s_ne  vec2(st.x, st.y)\n#define s_e   vec2(st.x, 0.0)\n#define s_se  vec2(st.x, -st.y)\n#define s_s   vec2(0.0, -st.y)\n#define s_sw  vec2(-st.x, -st.y)\n#define s_w   vec2(-st.x, 0.0)\n#define s_nw  vec2(-st.x, st.y)\n\n#define uv_ne  T( U + s_ne).xyz\n#define uv_nw  T( U + s_nw).xyz\n#define uv_sw  T( U - s_sw).xyz\n#define uv_se  T( U - s_se).xyz\n#define uv_e  T( U + s_e).xyz\n#define uv_n  T( U + s_n).xyz\n#define uv_s  T( U + s_s).xyz\n#define uv_w  T( U + s_w).xyz\n#define uv_c  T( U ).xyz\n\nconst float _K0 = -20.0/6.0; // center weight\nconst float _K1 = 4.0/6.0; // edge-neighbors\nconst float _K2 = 1.0/6.0; // vertex-neighbors\nconst float cs = 4.95; // curl scale\nconst float ls = 0.24; // laplacian scale\nconst float ps = -0.06; // laplacian of divergence scale\nconst float ds = -0.08; // divergence scale\nconst float pwr = 0.2; // power when deriving rotation angle from curl\nconst float amp = 1.0; // self-amplification\nconst float sq2 = 0.3; // diagonal weight\nfloat noise( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}", "buffer_a_code": "\nfloat blur(in vec2 p){\n    vec3 e = vec3(1, 0, -1);\n    vec2 px = 1./iResolution.xy;\n\tfloat res = 0.0;\n\tres += T(p + e.xx*px ).x + T(p + e.xz*px ).x + T(p + e.zx*px ).x + T(p + e.zz*px ).x;\n    res += (T(p + e.xy*px ).x + T(p + e.yx*px ).x + T(p + e.yz*px ).x + T(p + e.zy*px ).x)*2.;\n\tres += T(p + e.yy*px ).x*4.;\n    return res/16.;\n}\n\nMain\n{       \n    vec2 st = 1./iResolution.xy;\n    vec2 uv = U/iResolution.xy;\n    vec2 uvM = U/iResolution.y;\n    vec3 t = vec3(1,0,-1);\n    \n    // -- Formulae -- //\n    // Method 1\n    // 1: uv = uv - gaussian\n    // 2: Q = Sample\n    // 3: Q.z = -div   // Q.z = Q.z - S*div\n    // 4. if(gauss>0.) Q.xy = mix(gauss,grad*250., 0.1) //mix(c.xy,(b.xy)*250.+1.5*normalize(b.xy),.09);\n    // Method 2\n    // 1: Q = gaussian - div\n\t// 2: Q = sin(q)\n    // Method 3\n    // 1: y = blur\n    // 2: New.x = uv + lapl\n    // 3: new.x -= dot(newUV, vec2(1,-1.))*0.2 //diffusion\n    // -- Setup -- //\n    \n    float noise = noise(uv + floor(iTime/beat) );\n    U -= 0.5*R;\n    float aaa = 0.04*sin(.7*iTime + kick*20.*noise)*exp(-(3. + kick)*length(U)/R.y);\n    U *= (1.-.005*exp(exp(-length(U)/R.y)))*rot(aaa);\n    U += 0.5*R;\n    \n    // -- Equations -- // \n    vec2 lap =  vec2(T(U + t.xy*st).y - T(U - t.xy*st).y, T(U + t.yx*st).y - T(U - t.yx*st).y);\n    vec3 lapB  = _K0*uv_c + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    #define grad 0.25*vec2(e.z-w.z,n.z-s.z)\n    #define div 0.25*(n.y-s.y+e.x-w.x)\n    float divB  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    //float sd = ds * div;\n\tfloat avg = blur(uv*(1.2 + 2.) );\n    \n    // -- Logic -- //\n    \n    Neighborhood   \n\tU -= lap*st*3.;\n    vec4 a = A(U), c = C(U);\n    vec4 b = B(U + B(U*rot(iTime)).z*20.*lap.xy*sc);\n    Q = a; \n    Q = Q - div*(1. + noise*0.3) ;\n    Q -= dot(vec2(T(U).x, C(U).x), vec2(1.,-1.))*0.1;\n    Q = sin(Q*1.);\n    \n    \n    if (B(U).x > 0.03 ) {\n    \tQ -= mix(B(U),C(U)*150. - normalize(b.x)*20.1*noise, 0.2)*0.07;\n    }\n    \n    if (iMouse.z > 0.) {\n        float md = 0.16;\n        float d = smoothstep(md,md*0.5,length(uvM - iMouse.xy/iResolution.y))*1.;\n    \t//Q = mix(Q, vec4(0. + sc*B(U)*20.),d);\n        Q = mix(Q, vec4(0. - 1.),d);\n    }\n    \n    Init Q = sin(.1*U.xyyx)*cos(U.y);\n    Init Q = sin(.3*U.yxyy);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n{\n    Q = vec4(0);\n    For Q += Gaussian(i) * A(U+vec2(i,i)*1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n{\n    Q = vec4(0);\n    For Q += Gaussian(i) * A(U+vec2(-i,i)*1.);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n{\n    \n    #define grad 0.25*vec2(e.z-w.z,n.z-s.z)\n    Neighborhood\n    Q.xy = grad;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3lKGRW", "name": "Translucency Rendering II", "author": "ikuto", "description": "Move mouse horizontally to control the camera position and vertically to control the light position.", "tags": ["translucency", "translucent"], "likes": 30, "viewed": 832, "published": 3, "date": "1578482616", "time_retrieved": "2024-07-30T21:31:06.379129", "image_code": "#define AA 2\n#define PI 3.14159\n\nstruct Material\n{\n    vec3 \tdiffuseAlbedo;\n    vec3 \tspecularAlbedo;\n    float \tspecularPower;\n    float   bumpiness;\n};\n    \nMaterial materials[] = Material[] \n(\n    Material(vec3(0.0, 0.2, 0.2), vec3(0.3), 4.0, 0.2),\n    Material(vec3(0.0, 0.1, 0.2), vec3(0.3), 4.0, 0.2),\n    Material(vec3(0.0, 0.2, 0.1), vec3(0.3), 4.0, 0.2),\n    Material(vec3(0.1, 0.2, 0.0), vec3(0.3), 8.0, 0.1),\n    Material(vec3(0.2, 0.0, 0.2), vec3(0.3), 4.0, 0.15),\n    Material(vec3(0.4, 0.3, 0.02), vec3(0.2), 1.0, 0.1),\n    Material(vec3(0.2, 0.0, 0.2), vec3(0.2), 1.0, 0.1),\n    Material(vec3(0.0, 0.1, 0.1), vec3(0.2), 1.0, 0.05)\n);\n\nvec2 rotate(vec2 v, float a) { return cos(a)*v + sin(a)*vec2(v.y,-v.x); }\n\n//noise function from https://www.shadertoy.com/view/MsXGWr\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec2 opUnion(vec2 a, vec2 b) { return a.x < b.x ? a : b; }\n\n//distance function from https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 map(vec3 p)\n{\n    float objID = 0.0;\n    vec2 res = vec2(sdRoundBox(p-vec3(0.0, 0.0, 0.0), vec3(0.7, 0.7, 0.7), 0.2), objID++);\n    vec3 p2 = p - vec3(0.0, 1.3, 0.0); p2.xz = rotate(p2.xz, PI/6.0);\n    res = opUnion(res, vec2(sdRoundBox(p2, vec3(0.3, 0.3, 0.3), 0.1), objID++));\n    p2 = p - vec3(0.0, 2.2, 0.0); p2.xz = rotate(p2.xz, PI/9.0);\n    res = opUnion(res, vec2(sdRoundBox(p2, vec3(0.5, 0.3, 0.5), 0.2), objID++));\n    p2 = p - vec3(3.0, 0.3, 0.0); p2.xz = rotate(p2.xz, PI/9.0);\n    res = opUnion(res, vec2(sdRoundBox(p2, vec3(0.7, 1.0, 0.7), 0.2), objID++));\n    p2 = p - vec3(-3.0, -0.2, 0.5); p2.xz = rotate(p2.xz, PI/4.0);\n    res = opUnion(res, vec2(sdRoundBox(p2, vec3(0.5, 0.5, 0.5), 0.2), objID++));\n    p2 = p - vec3(-2.8, 1.3, 0.5); p2.xz = rotate(p2.xz, 0.0);\n    res = opUnion(res, vec2(sdRoundBox(p2, vec3(0.6, 0.6, 0.6), 0.2), objID++));\n    p2 = p - vec3(1.0, -0.4, 2.5); p2.xz = rotate(p2.xz, PI/6.0);\n    res = opUnion(res, vec2(sdRoundBox(p2, vec3(0.4, 0.4, 0.4), 0.1), objID++));\n    res = opUnion(res, vec2(p.y + 0.9, objID++));\n    return res;\n}\n\nvec3 calculateTransmittance(vec3 ro, vec3 rd, float tmin, float tmax, vec3 atten)\n{\n    float thickness = 0.0;\n    for (float t = tmin; t < tmax;)\n    {\n        float h = map(ro + t * rd).x;\n        float dt = (abs(h) < 1e-5) ? 0.01 : min(tmax-t, abs(h));\n        if (h < 0.0) thickness += dt; \n        t += dt;\n    }\n    \n    return exp(-atten * thickness);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n\tfor (float t = tmin; t < tmax;)\n    {\n        vec3 pos = ro + t * rd;\n        vec2 res = map(pos);\n        \n        float dist = res.x;\n        if (dist < 0.001) return vec2(t, res.y);\n        \n        t += dist;\n    }\n    return vec2(1e6, -1.0);\n}\n\nvec3 calculateNormal(vec3 p)\n{\n    vec3 dt = vec3(0.001, 0.0, 0.0);\n    return normalize( vec3 ( map(p+dt.xyy).x - map(p-dt.xyy).x,\n    \t\t\t\t\t\t map(p+dt.yxy).x - map(p-dt.yxy).x,\n                             map(p+dt.yyx).x - map(p-dt.yyx).x ) );\n}\n\nfloat calculateAO(vec3 pos, vec3 nor) //ambient occlusion\n{\n    float ao = 0.0, sca = 1.0;\n    \n    for (int i = 0; i < 5; ++i)\n    {\n    \tfloat h = 0.01 + 0.11*float(i)/4.0;\n        float d = map(pos+h*nor).x;\n        ao += (h-d)*sca;\n        sca *= 0.95;\n    }\n    \n    return clamp(1.0-2.0*ao, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\tvec3 color = vec3(0.0);\n    \n    float an = iMouse.z>0.0 ? 10.0*(iMouse.y/iResolution.y-0.5) : (1.0-0.2*iTime);\n    vec3 lightPos = vec3(3.0*cos(an), 1.3, 3.0*sin(an));\n    vec3 lightColor = vec3(10.0, 8.0+sin(iTime)*6.0, 7.0+cos(iTime)*5.0);\n    \n    vec2 res = rayMarch(ro, rd, 0.01, 15.0);\n    float t = res.x;\n    float objID = res.y;\n    \n    //draw entities\n    if (objID > -0.5)\n    {\n        Material mat = materials[int(objID)];\n        vec3 pos = ro + t * rd;\n        vec3 nor = calculateNormal(pos);\n        vec3 bnor = -1.0 + 2.0 * texturize(iChannel0, 0.5*pos, nor);\n\t\tnor = normalize(nor + mat.bumpiness*bnor);\n       \n        vec3 lightDir = normalize(lightPos - pos);\n        float lightDist = length(lightPos - pos);\t\t\n        float atten = 1.0 / (1.0 + 0.5 * lightDist * lightDist);\n        vec3 light = atten * lightColor;\n        light *= calculateTransmittance(pos+0.01*nor, lightDir, 0.01, min(lightDist, 20.0), vec3(1.0, 0.6, 0.5));\n        \n        float ao = calculateAO(pos, nor);\n        color +=  light * mat.diffuseAlbedo;\n        color += light * mat.specularAlbedo * pow(max(0.0, dot(reflect(lightDir,nor),rd)), mat.specularPower);\n        color *= ao;\n    }\n    \n    //draw lights\n    {\n        vec3 lv = lightPos - ro;\n        float ll = length(lv);\n        if (ll < t)\n        {\n            float angle = acos(clamp(dot(rd, lv/ll), 0.0, 1.0));\n            color += 1e2*lightColor*pow((1.0-smoothstep(0.0, 0.8, angle*ll)), 32.0);    \n        }\n    }\n    \n    return color;\n}\n\nmat3 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 w = normalize(target - eye);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    return mat3(u, v, -w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float an = iMouse.z>0.0 ? 10.0*(iMouse.x/iResolution.x-0.5) : 0.0;\n    \n\tvec3 ro = 5.0*vec3(1.2*sin(an), 0.3, cos(an)+0.2);\n    mat3 viewMat = lookAt(ro, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < AA; ++i) //super sampling\n    {\n        for (int k = 0; k < AA; ++k)\n        {\n            vec2 offset = vec2(float(i)+0.5,float(k)+0.5) / float(AA) - 0.5;\n            vec2 uv = (2.0*(fragCoord+offset)-iResolution.xy)/iResolution.y;    \n    \t    vec3 rd = viewMat * normalize(vec3(uv, -2.0));\n    \t\t\n            color += render(ro, rd);\n        }\n    }\n    \n\tcolor /= float(AA*AA);\n\tcolor = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[650, 650, 680, 680, 723], [725, 785, 833, 833, 986], [988, 988, 1018, 1018, 1046], [1048, 1119, 1164, 1164, 1255], [1257, 1257, 1275, 1275, 2339], [2341, 2341, 2424, 2424, 2701], [2703, 2703, 2760, 2760, 3010], [3012, 3012, 3042, 3042, 3259], [3261, 3261, 3320, 3320, 3570], [3572, 3572, 3603, 3603, 5112], [5114, 5114, 5159, 5159, 5290], [5292, 5292, 5347, 5347, 6059]], "test": "untested"}
{"id": "tlKGzD", "name": "PS1 Startup", "author": "mat44", "description": "basic", "tags": ["2d"], "likes": 10, "viewed": 643, "published": 3, "date": "1578450335", "time_retrieved": "2024-07-30T21:31:07.120147", "image_code": "vec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) {\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y);\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    return abs(vec3(u,v,w));\n}\n\nvec4 thing(vec2 uv) {\n    vec2 a = vec2( 0.0, 0.5);\n    vec2 b = vec2(-0.5, 0.0);\n    vec2 c = vec2( 0.0, -0.5);\n    \n    vec3 bcc = bary(a, b, c, uv);\n    \n    if(bcc.x + bcc.y + bcc.z <= 1.001) {\n    \tvec3 colA = vec3(0.7, 0.12, 0.05);\n        vec3 colB = vec3(0.74, 0.57, 0.07);\n        vec3 col = mix(colB, colA, bcc.y+0.1);\n        return vec4(col, 1.0);\n    } else {\n        return vec4(0.0);\n    }\n}\n\nvec4 mix_alpha(vec4 a, vec4 b) {\n    return mix(a, b, b.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    uv *= 1.3;\n    \n    vec4 col;\n    \n    if (iTime < 1.5) {\n\t\tcol = vec4(mix(0.0, 0.76, clamp(iTime-0.5, 0.0, 1.0)));\n    } else {\n        col = thing(uv);\n\n        col = mix_alpha(col, thing(-uv));\n\n        float t = clamp(iTime - 1.9, 0.0, 1.0);\n        float scale = mix(1.0, 2.2, t);\n        vec2 off = vec2(-0.07, -0.43) * t;\n\n        col = mix_alpha(col, thing(-uv * scale + off));\n\n        col = mix_alpha(col, thing( uv * scale + off));\n\n        col = mix_alpha(vec4(0.76, 0.76, 0.76, 1.0), col);\n\n    }\n    \n    fragColor = vec4(col.rgb, 1.0);\n}", "image_inputs": [{"id": 20788, "src": "https://soundcloud.com/user-979093267/ps1-startup", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 313], [315, 315, 336, 336, 721], [723, 723, 755, 755, 784], [786, 786, 843, 843, 1471]], "test": "untested"}
{"id": "wlVGRD", "name": "Bursting bubble", "author": "michael0884", "description": "2 wave fluid with different densities interacting ", "tags": ["waves", "fluid", "nonlinear"], "likes": 7, "viewed": 463, "published": 3, "date": "1578442555", "time_retrieved": "2024-07-30T21:31:07.879118", "image_code": "// Fork of \"Oil and water\" by michael0884. https://shadertoy.com/view/wtVGzW\n// 2020-01-08 00:13:19\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    vec4 Q = pixel(ch0, p);\n    vec4 Qv = pixel(ch1, p);\n    \n    //fluid 1 amplitude\n    float fd1 = 1.*dot(Q.xy,Q.xy)/sq(a1);\n    //fluid 2 amplitude\n    float fd2 = 1.*dot(Q.zw,Q.zw)/sq(a2);\n\n    // Output to screen\n    fragColor.xyz = sin(vec3(1., 1., 0.2)*fd1) + 0.5*sin(vec3(0.3, 0.3, 1.)*fd2);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p),0)\n#define s2d iResolution.xy\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define dt 0.45\n\n\nconst float scale = .45;\n//fluid 1 density \nconst float a1 = 1.;\n//fluid 2 density\nconst float a2 = 0.74;\n\n//set to 0 if you want a gas-like behaviour\n//fluid 1 fluid-like/gas-like regulator \nconst float b1 = 0.9;\n//fluid 2 fluid-like/gas-like regulator \nconst float b2 = 0.0;\n\n//interaction energy cost\nconst float ie = 0.7;\n\n//initial conditions for amplitudes\nconst float amp = 1.4;\nconst vec4 fluid1_Q = amp*vec4(a1,0,0,0);\nconst vec4 fluid1_Qv = amp*vec4(0,a1,0,0); //minus for antifluid\nconst vec4 fluid2_Q = amp*vec4(0,0,a2,0);\nconst vec4 fluid2_Qv = amp*vec4(0,0,0,a2);\nconst float mouser = 25.;\nconst float initr =130.;\n\n\nfloat sq(float x){ return x*x; }\nfloat cb(float x){ return x*x*x; }\nfloat sq(vec2 x){ return dot(x,x); }\n\nconst float pressure = 0.001;\n\n//wave potential\nfloat P(vec4 Q, vec2 p)\n{\n    //fluid 1 amplitude\n    float fd1 = 5.*tanh(length(Q.xy)/5.);\n    //fluid 2 amplitude\n    float fd2 = 5.*tanh(length(Q.zw)/5.);\n    \n    //liquifier term 1\n    float liq1 = 1. - b1*exp(-4.*sq(fd1-a1));      \n    //liquifier term 2\n    float liq2 = 1. - b2*exp(-4.*sq(fd2-a2));     \n    float grav = 0.000*p.y;\n        \n    return scale*(1.*cb(fd1)*liq1 + cb(fd2)*liq2) + ie*sq(fd1)*sq(fd2) +  (sq(fd1)+sq(fd2))*grav;\n}\n\n//force\n#define d 0.001\nvec4 F(vec4 Q, vec2 p)\n{\n    vec3 dx = 0.5*vec3(-d,0.,d);\n    return vec4(P(Q + dx.zyyy, p) - P(Q + dx.xyyy, p),\n                P(Q + dx.yzyy, p) - P(Q + dx.yxyy, p),\n                P(Q + dx.yyzy, p) - P(Q + dx.yyxy, p),\n                P(Q + dx.yyyz, p) - P(Q + dx.yyyx, p))/d;\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\nfloat ring(vec2 p, vec2 c, float r, float dd)\n{\n    return exp(-0.5*sq((length(p-c)-r)/dd));\n}\n\n", "buffer_a_code": "void mouse(inout vec4 Q, inout vec4 Qv, vec2 p)\n{\n    if(iMouse.z > 0.)\n    {\n        float f1 = exp(-sq((p-iMouse.xy)/mouser));\n        Q += 0.3*fluid1_Q*f1;\n        Qv += 0.3*fluid1_Qv*f1;\n    }\n}\n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    //get old value\n    Q = texel(ch0, p);\n    vec4 Qv = texel(ch1, p);\n    \n    Q += Qv*dt + 0.0005*Laplace(ch0, p);\n   \n    mouse(Q,Qv,p);\n    \n    if(iFrame < 1) \n    {\n     float f1 = ring(p,s2d*0.5,initr,4.);\n       float f2 = ring(p,s2d*0.5,0.5*initr,0.5*initr);\n        //Q = fluid1_Q*f1*(1.-f2) + fluid2_Q*f2*(1.-f1);\n    }\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mouse(inout vec4 Q, inout vec4 Qv, vec2 p)\n{\n    if(iMouse.z > 0.)\n    {\n        float f1 = exp(-sq((p-iMouse.xy)/mouser));\n        Q += 0.3*fluid1_Q*f1;\n        Qv += 0.3*fluid1_Qv*f1;\n    }\n}\n\n\nvoid mainImage( out vec4 Qv, in vec2 p )\n{\n    //get old value\n    vec4 Q = texel(ch0, p);\n    Qv = texel(ch1, p);\n    \n   \tQv += dt*(Laplace(ch0, p) - F(Q, p));\n    \n    mouse(Q,Qv,p);\n    \n    if(iFrame < 1) \n    {\n         float f1 = ring(p,s2d*0.5,initr,2.);\n       float f2 = ring(p,s2d*0.5,0.5*initr,0.5*initr);\n      //  Qv = fluid1_Qv*f1*(1.-f2) + fluid2_Qv*f2*(1.-f1);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mouse(inout vec4 Q, inout vec4 Qv, vec2 p)\n{\n    if(iMouse.z > 0.)\n    {\n        float f1 = exp(-sq((p-iMouse.xy)/mouser));\n        Q += 0.3*fluid1_Q*f1;\n        Qv += 0.3*fluid1_Qv*f1;\n    }\n}\n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    //get old value\n    Q = texel(ch0, p);\n    vec4 Qv = texel(ch1, p);\n    \n    Q += Qv*dt + 0.0005*Laplace(ch0, p);\n   \n    mouse(Q,Qv,p);\n    \n    if(iFrame < 1) \n    {\n         float f1 = ring(p,s2d*0.5,initr,2.);\n        float f2 =ring(p,s2d*0.5,50.*initr,50.*initr);\n        Q = fluid1_Q*f1 + fluid2_Q*f2*(1.-f1);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mouse(inout vec4 Q, inout vec4 Qv, vec2 p)\n{\n    if(iMouse.z > 0.)\n    {\n        float f1 = exp(-sq((p-iMouse.xy)/mouser));\n        Q += 0.3*fluid1_Q*f1;\n        Qv += 0.3*fluid1_Qv*f1;\n    }\n}\n\n\nvoid mainImage( out vec4 Qv, in vec2 p )\n{\n    //get old value\n    vec4 Q = texel(ch0, p);\n    Qv = texel(ch1, p);\n    \n   \tQv += dt*(Laplace(ch0, p) - F(Q, p));\n    \n    mouse(Q,Qv,p);\n    \n    if(iFrame < 1) \n    {\n       float f1 = ring(p,s2d*0.5,initr,2.);\n        float f2 = ring(p,s2d*0.5,50.*initr,50.*initr);\n        Qv = fluid1_Qv*f1 + fluid2_Qv*f2*(1.-f1);\n    }\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 150, 150, 453]], "test": "untested"}
{"id": "wtK3zW", "name": "HX Nightvision Prototype", "author": "hanfling", "description": "Nightvision shader protype intended for HX.\n", "tags": ["hx"], "likes": 1, "viewed": 219, "published": 3, "date": "1578437927", "time_retrieved": "2024-07-30T21:31:08.633102", "image_code": "\n// Center at 0, Right at 1. Integration between 0 and 1/2.\nfloat BoxNearestRight( float OneCenter, float OneRight, float TwoCenter, float TwoRight )\n{\n    return 0.5*OneCenter*TwoCenter;\n}\n\n// Left at -1, Center at 0. Integration between -1/2 and 0.\nfloat BoxNearestLeft( float OneLeft, float OneCenter, float TwoLeft, float TwoCenter )\n{\n    return 0.5*OneCenter*TwoCenter;\n}\n\n\n// Left at -1, Center at 0. Integration between -1/2 and 0.\nfloat TentNearestLeft( float OneLeft, float OneCenter, float TwoLeft, float TwoCenter )\n{\n    float Result = 0.0;\n\n    Result += (1.0/8.0)*OneLeft*TwoLeft;\n    Result += (3.0/8.0)*OneCenter*TwoCenter;\n\n    return Result;\n}\n\n// Center at 0, Right at 1. Integration between 0 and 1/2.\nfloat TentNearestRight( float OneCenter, float OneRight, float TwoCenter, float TwoRight )\n{\n    float Result = 0.0;\n    \n    Result = TentNearestLeft( OneRight, OneCenter, TwoRight, TwoCenter );\n    \n    return Result;\n}\n\n\n// Left at -1, Center at 0. Integration between -1/2 and 0.\nfloat TentLinearLeft( float OneLeft, float OneCenter, float TwoLeft, float TwoCenter )\n{\n    float Result = 0.0;\n\n    Result += (1.0/12.0)*OneLeft*TwoLeft;\n    Result += (1.0/12.0)*OneLeft*TwoCenter;\n    Result += (1.0/12.0)*OneCenter*TwoLeft;\n    Result += (3.0/12.0)*OneCenter*TwoCenter;\n\n    return Result;\n}\n\n// Center at 0, Right at 1. Integration between 0 and 1/2.\nfloat TentLinearRight( float OneCenter, float OneRight, float TwoCenter, float TwoRight )\n{\n    float Result = 0.0;\n    \n    Result = TentLinearLeft( OneRight, OneCenter, TwoRight, TwoCenter );\n    \n    return Result;\n}\n\n// This works more in the sense of a \"spectrum\", which RGB colors are NOT.\nvec3 TentLinearMultiplyColors( vec3 ColorOne, vec3 ColorTwo )\n{\n    vec3 Result = vec3(0.0);\n    \n    // Left of Red.\n    Result.r += BoxNearestLeft( ColorOne.r, ColorOne.r, ColorTwo.r, ColorTwo.r );\n\n    // Right of Red.\n    Result.r += TentLinearRight( ColorOne.r, ColorOne.g, ColorTwo.r, ColorTwo.g );\n\n    // Left of Green.\n    Result.g += TentLinearLeft( ColorOne.r, ColorOne.g, ColorTwo.r, ColorTwo.g );\n\n    // Right of Green.\n    Result.g += TentLinearRight( ColorOne.g, ColorOne.b, ColorTwo.g, ColorTwo.b );\n\n    // Left of Blue.\n    Result.b += TentLinearLeft( ColorOne.g, ColorOne.b, ColorTwo.g, ColorTwo.b );\n\n    // Right of Blue.\n    Result.b += BoxNearestRight( ColorOne.b, ColorOne.b, ColorTwo.b, ColorTwo.b );\n\n\treturn Result;\n}\n\n// Code below assumes Weights sum up to 1.\nvec3 LuminancePreservingClamp( vec3 Color, vec3 Weights ) // !! LuminancePreservingMax\n{\n\t// We need two passes to fully spread.\n\tfor ( int Pass=0; Pass<2; Pass++ )\n\t{\n\t\t// How much a channel is abve 1.0.\n\t\tvec3 Extend = max( vec3(0.0), Color-vec3(1.0) );\n\n\t\t// Relative luminance a component can surrender.\n\t\tvec3 LuminanceExtend = Extend*Weights;\n\n\t\t//\n\t\t// We will be distributing channel a into the two other\n\t\t// channels b and c. We will be using the Weight b on\n\t\t// channel c and vice versa. Before applying the weights\n\t\t// we need to normalize, as the sum of weight b and c\n\t\t// is not one.\n\t\t//\n\t\t// Note that Weight_a+Weight_b equals 1-Weights_c\n\t\t//\n\t\tvec3 NormalizedExtend = LuminanceExtend/(vec3(1.0)-Weights);\n\n#if 1\n\t\tColor += Weights.brg*NormalizedExtend.gbr + Weights.gbr*NormalizedExtend.brg; // Cross product, but with +.\n#else\n\t\t// Spread Red into Green and Blue.\n\t\tColor.g += Weights.b/(Weights.g+Weights.b)*LuminanceExtend.r;\n\t\tColor.b += Weights.g/(Weights.g+Weights.b)*LuminanceExtend.r;\n\n\t\t// Spread Green into Blue and Red.\n\t\tColor.b += Weights.r/(Weights.b+Weights.r)*LuminanceExtend.g;\n\t\tColor.r += Weights.b/(Weights.b+Weights.r)*LuminanceExtend.g;\n\n\t\t// Spread Blue into Red and Green.\n\t\tColor.r += Weights.g/(Weights.r+Weights.g)*LuminanceExtend.b;\n\t\tColor.g += Weights.r/(Weights.r+Weights.g)*LuminanceExtend.b;\n#endif\n\n\t}\n\n\treturn clamp( Color, 0.0, 1.0 );\n}\n\nconst vec3 Rec709LuminanceWeights = vec3( 0.2126, 0.7152, 0.0722 );\n\nvec3 RelativeLuminancePreservingClampRec709( vec3 Color )\n{\n\treturn LuminancePreservingClamp( Color, Rec709LuminanceWeights );\n}\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 NormalizedScreenCoords = FragCoord/iResolution.xy;\n\n    vec3 ColorOne = vec3(0.0,1.0,0.0);\n\n    vec3 ColorTwo = texture(iChannel0,NormalizedScreenCoords).rgb;\n\n    vec3 Result = TentLinearMultiplyColors( ColorOne, ColorTwo );\n    \n    Result *= 5.0 + 4.0*sin(iTime);\n   \n    Result = RelativeLuminancePreservingClampRec709( Result );\n\n    FragColor = vec4(Result, 1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtK3zW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 60, 151, 151, 189], [191, 251, 339, 339, 377], [380, 440, 529, 529, 662], [664, 723, 815, 815, 944], [947, 1007, 1095, 1095, 1318], [1320, 1379, 1470, 1470, 1598], [1600, 1675, 1738, 1738, 2420], [2422, 2465, 2553, 2593, 3858], [3929, 3929, 3988, 3988, 4057], [4059, 4059, 4116, 4163, 4544]], "test": "untested"}
{"id": "tlKGzW", "name": "ShaderDojo 042", "author": "antonOTI", "description": "Trying to do the escher spiraling painting effect without looking at other shader code.\n\nIt is far from perfect but I'm not confident in the lead i've been following :)\n\nInspired by www.shadertoy.com/view/tl3GW2", "tags": ["escher"], "likes": 15, "viewed": 472, "published": 3, "date": "1578437736", "time_retrieved": "2024-07-30T21:31:09.390078", "image_code": "#define TAU 6.28318\n\nmat2 rot(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,-sa,sa,ca);\n}\n\nvec2 spiralize(vec2 uv)\n{\n    float len = length(uv);\n    \n\tuv *= 128.;\n    float r = .045;\n    mat2 mr = rot(r);\n    \n    float a;\n    float acc = 1.;\n    \n    a = atan(uv.y, uv.x) / TAU + .5;\n    a = fract(a + iTime * .05);\n    \n//    a *= (sin( iTime) * .5 + .5);\n    uv *= 1. - a * .50;\n  \n    for(int i = 0; i < 7; ++i)\n    {\n\t\t\n        if(abs(uv.x) < 1. && abs(uv.y) < 1.)\n//        if(length(uv) < 1.)\n        {\n            break;\n        }\n        \n        uv *= .5;\n        \n        /*\n        uv.x += 1.;\n        uv *= mr;\n        uv.x -= 1.;\n        */\n    }\n    \n    return uv;\n}\n\n\nfloat fbm(vec2 p)\n{\n  mat2 m = mat2(.8,-.6,.6,.8);\n  float acc = 0.;\n  p *= -m * m * .5;\n  for(float i = 1.; i < 6.; ++i)\n  {\n    p += vec2(i * 12.675, i * 65.457) + vec2(iTime * .15);\n    p *= m;\n    acc += (sin(p.x * i) + cos(p.y * i)) * 1./(i * .5);\n  }\n\n  return acc;\n}\n\nfloat sdCube(vec3 p)\n{\n  vec3 q = abs(p) - vec3(1.);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p)\n{\n    vec3 cp = p;\n    \n    \n    float dist = p.y + fbm(p.xz *1.5) * .1 + 3.;\n    \n    p = cp;\n    \n    p.xy *= .515;\n    float cu = sdCube(p) - .1;\n    \n    dist = min(dist,cu);\n    \n    p = cp;\n    \n    float r = 4.;\n    p.xz = mod(p.xz + r *.5, r) - r * .5;\n    p.y -= 20.;\n    cu = sdCube(p);\n    dist = min(dist,cu);\n    \n    return dist;\n}\n\nfloat ray(vec3 ro, vec3 rd, out float st)\n{\n    float cd = 0.;\n    float FAR = 100.;\n    for(st = 0.; st < 1.; st += 1. / 128.)\n    {\n    \tfloat d = map(ro + rd * cd);\n        if(abs(d) < .01)\n            break;\n        cd += d * .85;\n    }\n    \n    return cd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n    \n     uv = spiralize(uv);\n    \n    float f = max(abs(uv.x),abs(uv.y));\n    f = smoothstep(.0,0.05, abs(f - 1.));\n    f = iMouse.z < 0. ? 1. : f;\n    \n    vec3 ro = vec3(0.,0.,-5.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    float st;\n    float dist = ray(ro, rd, st);\n    \n    vec3 col = vec3(0.);\n    if(st < 1.)\n    {\n        vec3 cp = ro + rd * dist;\n        \n        col = mix(vec3(1.), vec3(9.,.4,.8), sin(cp.z * .1) * .5 + .5) * (1. - pow(st, 1.5));\n        \n        vec3 lp = vec3(4. * sin(iTime *.25),3. + 1.* cos(iTime * .125),-5. );\n        vec3 ld = normalize(lp - cp);\n        cp += ld * .1;\n        float ldist = ray(cp, ld, st);\n        \n    \n        if(ldist < length(cp - ld))\n        {\n            col *= .1025;\n        }\n    }\n    \n    uv = (uv +1.) * .5;\n    // col = texture(iChannel0,uv).rgb;\n    \n    fragColor = vec4(col, 0.) * f;\n    fragColor = pow(fragColor,vec4(.4545));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKGzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 40, 40, 119], [121, 121, 146, 146, 712], [715, 715, 734, 734, 988], [990, 990, 1012, 1012, 1106], [1108, 1108, 1127, 1127, 1471], [1473, 1473, 1516, 1516, 1735], [1737, 1737, 1794, 1794, 2761]], "test": "untested"}
{"id": "wtVGzW", "name": "Oil and water", "author": "michael0884", "description": "2 wave fluids with different densities interacting in a grav field", "tags": ["waves", "fluid", "nonlinear"], "likes": 12, "viewed": 749, "published": 3, "date": "1578436049", "time_retrieved": "2024-07-30T21:31:10.138078", "image_code": "void mainImage( out vec4 fragColor, in vec2 p )\n{\n    vec4 Q = pixel(ch0, p);\n    vec4 Qv = pixel(ch1, p);\n    \n    \n    vec2 g = 0.04*normalize(Grad(ch0, p));\n    vec3 v = vec3(g,  sqrt(1.-sq(g)) );\n    vec3 col = texture(ch2, v).xyz;\n    //fluid 1 amplitude\n    float fd1 = smoothstep(0., 0.7, 1.*dot(Q.xy,Q.xy)/sq(a1)) * ( 1. + 0.004*p.y);\n    //fluid 2 amplitude\n    float fd2 = smoothstep(0., 0.7, 1.*dot(Q.zw,Q.zw)/sq(a2)) * ( 1. - 0.004*p.y);\n\n    // Output to screen\n    fragColor.xyz = 0.7*(sin(vec3(1., 1., 0.)*fd1) + sin(vec3(0., 0.3, 1.)*fd2)) + 0.5*col*dot(Q,Q);\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p-0.5),0)\n#define s2d iResolution.xy\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define dt 0.5\n\n\nconst float scale = .6;\n//fluid 1 density \nconst float a1 = 0.8;\n//fluid 2 density\nconst float a2 = 1.;\n\n//set to 0 if you want a gas-like behaviour\n//fluid 1 fluid-like/gas-like regulator \nconst float b1 = 0.99;\n//fluid 2 fluid-like/gas-like regulator \nconst float b2 = 0.99;\n\n//interaction energy cost\nconst float ie = 1.5;\n\n//initial conditions for amplitudes\nconst float amp = 0.8;\nconst vec4 fluid1_Q = amp*vec4(a1,0,0,0);\nconst vec4 fluid1_Qv = amp*vec4(0,a1,0,0); //minus for antifluid\nconst vec4 fluid2_Q = amp*vec4(0,0,a2,0);\nconst vec4 fluid2_Qv = amp*vec4(0,0,0,a2);\nconst float mouser = 25.;\nconst float initr = 150.;\n\n\nfloat sq(float x){ return x*x; }\nfloat cb(float x){ return x*x*x; }\nfloat sq(vec2 x){ return dot(x,x); }\n\nconst float pressure = 0.001;\n\n//wave potential\nfloat P(vec4 Q, vec2 p)\n{\n    //fluid 1 amplitude\n    float fd1 = 2.*tanh(0.5*length(Q.xy));\n    //fluid 2 amplitude\n    float fd2 = 2.*tanh(0.5*length(Q.zw));\n    \n    //liquifier term 1\n    float liq1 = 1. - b1*exp(-3.*sq(fd1-a1));      \n    //liquifier term 2\n    float liq2 = 1. - b2*exp(-3.*sq(fd2-a2));     \n    float grav = 0.0005*p.y;\n        \n    return scale*(cb(fd1)*liq1 + cb(fd2)*liq2+ ie*sq(fd1)*sq(fd2))+ (sq(fd1)+sq(fd2))*grav;\n}\n\n//force\n#define d 0.001\nvec4 F(vec4 Q, vec2 p)\n{\n    vec3 dx = 0.5*vec3(-d,0.,d);\n    return vec4(P(Q + dx.zyyy, p) - P(Q + dx.xyyy, p),\n                P(Q + dx.yzyy, p) - P(Q + dx.yxyy, p),\n                P(Q + dx.yyzy, p) - P(Q + dx.yyxy, p),\n                P(Q + dx.yyyz, p) - P(Q + dx.yyyx, p))/d;\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n", "buffer_a_code": "void mouse(inout vec4 Q, inout vec4 Qv, vec2 p)\n{\n    if(iMouse.z > 0.)\n    {\n        float f1 = exp(-sq((p-iMouse.xy)/mouser));\n        Q += 0.3*fluid1_Q*f1;\n        Qv += 0.3*fluid1_Qv*f1;\n    }\n}\n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    //get old value\n    Q = texel(ch0, p);\n    vec4 Qv = texel(ch1, p);\n    \n    Q += Qv*dt + 0.0005*Laplace(ch0, p);\n   \n    mouse(Q,Qv,p);\n    \n    if(iFrame < 1) \n    {\n        float f1 = step(sq((p-s2d*0.3)/initr),1.);\n        float f2 = step(sq((p-s2d*0.7)/initr),1.);\n        Q = fluid1_Q*f1*(1.-f2) + fluid2_Q*f2*(1.-f1);\n    }\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mouse(inout vec4 Q, inout vec4 Qv, vec2 p)\n{\n    if(iMouse.z > 0.)\n    {\n        float f1 = exp(-sq((p-iMouse.xy)/mouser));\n        Q += 0.3*fluid1_Q*f1;\n        Qv += 0.3*fluid1_Qv*f1;\n    }\n}\n\n\nvoid mainImage( out vec4 Qv, in vec2 p )\n{\n    //get old value\n    vec4 Q = texel(ch0, p);\n    Qv = texel(ch1, p);\n    \n   \tQv += dt*(Laplace(ch0, p) - F(Q, p));\n    \n    mouse(Q,Qv,p);\n    \n    if(iFrame < 1) \n    {\n        float f1 = step(sq((p-s2d*0.3)/initr),1.);\n        float f2 = step(sq((p-s2d*0.7)/initr),1.);\n        Qv = fluid1_Qv*f1*(1.-f2) + fluid2_Qv*f2*(1.-f1);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mouse(inout vec4 Q, inout vec4 Qv, vec2 p)\n{\n    if(iMouse.z > 0.)\n    {\n        float f1 = exp(-sq((p-iMouse.xy)/mouser));\n        Q += 0.3*fluid1_Q*f1;\n        Qv += 0.3*fluid1_Qv*f1;\n    }\n}\n\nvoid mainImage( out vec4 Q, in vec2 p )\n{\n    //get old value\n    Q = texel(ch0, p);\n    vec4 Qv = texel(ch1, p);\n    \n    Q += Qv*dt + 0.0005*Laplace(ch0, p);\n   \n    mouse(Q,Qv,p);\n    \n    if(iFrame < 1) \n    {\n        float f1 = step(sq((p-s2d*0.3)/initr),1.);\n        float f2 = step(sq((p-s2d*0.7)/initr),1.);\n        Q = fluid1_Q*f1*(1.-f2) + fluid2_Q*f2*(1.-f1);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mouse(inout vec4 Q, inout vec4 Qv, vec2 p)\n{\n    if(iMouse.z > 0.)\n    {\n        float f1 = exp(-sq((p-iMouse.xy)/mouser));\n        Q += 0.3*fluid1_Q*f1;\n        Qv += 0.3*fluid1_Qv*f1;\n    }\n}\n\n\nvoid mainImage( out vec4 Qv, in vec2 p )\n{\n    //get old value\n    vec4 Q = texel(ch0, p);\n    Qv = texel(ch1, p);\n    \n   \tQv += dt*(Laplace(ch0, p) - F(Q, p));\n    \n    mouse(Q,Qv,p);\n    \n    if(iFrame < 1) \n    {\n        float f1 = step(sq((p-s2d*0.3)/initr),1.);\n        float f2 = step(sq((p-s2d*0.7)/initr),1.);\n        Qv = fluid1_Qv*f1*(1.-f2) + fluid2_Qv*f2*(1.-f1);\n    }\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVGzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 577]], "test": "untested"}
{"id": "WtK3RD", "name": "2 Fluid", "author": "wyatt", "description": "Mouse to make fluid 2", "tags": ["wave", "fluid"], "likes": 11, "viewed": 493, "published": 3, "date": "1578426756", "time_retrieved": "2024-07-30T21:31:11.011742", "image_code": "Main\n{\n    vec4 a = A(U)+C(U), b = B(U)+D(U), c = a*a+b*b;\n    Q = vec4(length(c.xy),length(c.zw),length(c),1);\n\tQ = atan(Q);\n    Q = (sin(Q.x-Q.y+Q.z*vec4(1,2,3,4)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define Main void mainImage( out vec4 Q, in vec2 U )\n\nvec4 F( vec4 Q) {\n    float l = length(Q.xy),\n          g = length(Q.zw);\n    vec4 c = abs(length(Q)-vec4(.55,.55,.5,.5));\n\treturn vec4(vec2(g),vec2(l))+c+3e-3*gl_FragCoord.y;\n}\n\n#define dt .8\n#define K .5\n#define Loss .01\n\n#define Init if (iFrame < 1 || length(U-(0.5+.1*sin(vec2(1,2)*floor(float(iFrame)/4.)*.1))*R)<10.) Q = exp(-.005*length(U-0.5*R))\n#define Mouse if ((iMouse.z>0.&&length(U-iMouse.xy)<30. )|| length(U-(0.8+.05*cos(vec2(1,2)*floor(float(iFrame)/4.)*.1))*R)<10.) Q.xyzw += .3", "buffer_a_code": "Main\n{\n    vec4 \n         N = A(U+vec2(0,1)), \n         E = A(U+vec2(1,0)), \n         S = A(U-vec2(0,1)), \n         W = A(U-vec2(1,0)),\n         M = 0.25*(N+E+S+W),\n         a = A(U), b = B(U);\n    Q = a + dt*b + Loss*(M-a);\n    \n    Mouse*vec4(0,0,-1,0);\n    \n    Init*vec4(1,0,0,0);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n{\n    vec4 \n         M = 0.25*(\n         \tA(U+vec2(0,1))+A(U+vec2(1,0))+\n         \tA(U-vec2(0,1))+A(U-vec2(1,0))\n         ),\n         a = A(U);\n    Q = B(U) + dt*(M-a-K*a*F(a));\n    \n    Mouse*vec4(0,0,0,.3);\n    \n    Init*vec4(0,-.3,0,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n{\n    vec4 \n         N = A(U+vec2(0,1)), \n         E = A(U+vec2(1,0)), \n         S = A(U-vec2(0,1)), \n         W = A(U-vec2(1,0)),\n         M = 0.25*(N+E+S+W),\n         a = A(U), b = B(U);\n    Q = a + dt*b + Loss*(M-a);\n    \n    Mouse*vec4(0,0,-1,0);\n    \n    Init*vec4(1,0,0,0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n{\n    vec4 \n         M = 0.25*(\n         \tA(U+vec2(0,1))+A(U+vec2(1,0))+\n         \tA(U-vec2(0,1))+A(U-vec2(1,0))\n         ),\n         a = A(U);\n    Q = B(U) + dt*(M-a-K*a*F(a));\n    \n    Mouse*vec4(0,0,0,.3);\n    \n    Init*vec4(0,-.3,0,0);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3tV3zD", "name": "Shortest Fluid Demo (231 ch)", "author": "FabriceNeyret2", "description": "re-golfing [url]https://shadertoy.com/view/4lyBDW[/url] ( 324 chars )\nRely on hardware derivative + MIPmap : quite approximative. probably too much.\n\nNB: h,v should be doubled, but unsteady. Or double just its use for O.zw -= ?", "tags": ["fluid", "demo", "2tweets", "golf", "shortest"], "likes": 12, "viewed": 497, "published": 3, "date": "1578426230", "time_retrieved": "2024-07-30T21:31:11.768719", "image_code": "// re-golfing https://shadertoy.com/view/4lyBDW ( 324 chars )\n// variant of https://shadertoy.com/view/ttyGWD\nvoid mainImage(out vec4 O, vec2 U) { mi }\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// variant of https://shadertoy.com/view/ttyGWD\nvoid mainImage(out vec4 O, vec2 U) { mi }", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// + 3 for alternate init (fix strange compatibility issue)\n\n// Storage: x:pressure,  y: density,  zw: speed*dt\n// -> eqns read:  advec all ;  p += -lapl(p) -div(V)\n//                V -= grad(p) or 0 outside ; source: dens=1,Vx=1\n\n#define T texture(iChannel0,                        //\n#define mi                                           \\\n    vec2 R = iResolution.xy,                         \\\n         d = length( U+U - R ) / R;                  \\\n    vec4 D = -T U/R), h = dFdx(D), v = dFdy(D);      \\\n     /* see older version for better derivatives */  \\\n /* O = iFrame < 1 ? O-O : T(D.zw,);    old init */  \\\n    O = T (D.zw+U)/R);               /* alt init */  \\\n    O.x = T U/R,1.).x - (h.z+v.w)/20.;               \\\n    O.zw -= d.y > 1. ? O.zw : vec2(h.x,v);           \\\n    d.y < .02 ? O.zy = R/R : R;                      \\\n    iFrame < 1 ? O-=O : O;           /* alt init */ /*\n        \n     \n\n\n\n// --- 243 chars + 3 for alternate init\n        \n#define T(a,l) texture(iChannel0, (a+U)/R, l+0.)    //\n#define mainImage( O, u )                            \\\n    vec2 U = u,                                      \\\n         R = iResolution.xy,                         \\\n         d = length( U+U - R ) / R;                  \\\n    vec4 D = -T(,), h = dFdx(D), v = dFdy(D);        \\\n      /* h = T(-O.wz,)-T(O.wz,), v = T(-O.zw,)-T(O.zw,); better derivatives */ \\\n /* O = iFrame < 1 ? O-O : T(D.zw,);    old init * /  \\\n    O = T(D.zw,);                    /* alt init * /  \\\n    O.x = T(,1.).x - (h.z+v.w)/20.;                  \\\n    O.zw -= d.y > 1. ? O.zw : vec2(h.x,v);           \\\n    d.y < .02 ? O.zy = R/R : R;                      \\\n    iFrame < 1 ? O-=O : O            /* alt init * /\n        \n/**/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tV3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3ly3RW", "name": "txaa + sharpener", "author": "SigSegOwl", "description": "txaa + sharpener\n\nlooks pretty stable on the shaking video :P", "tags": ["temporal", "txaa", "sharpener"], "likes": 3, "viewed": 587, "published": 3, "date": "1578423686", "time_retrieved": "2024-07-30T21:31:12.519711", "image_code": "//left right comparison\n//left just unprocessed buffer A\n//right txaa + sharpening\n//move mouse up or down wile holding to adjust sharpness\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;                    \n\tvec2 uvMouse = iMouse.xy/iResolution.xy;               \n\tif(uv.x > uvMouse.x){\n\t\tfragColor = texture(iChannel0, uv);             \n\t}else{\n\t\tfragColor = texture(iChannel1, uv);  \n    }\n    if(uv.x > uvMouse.x - 0.002 && uv.x < uvMouse.x + 0.002){\n    \tfragColor = vec4(1.0,1.0,1.0,1.0);\n\t}\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//just filling buffer A for easier testing...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;  \n    \n    fragColor = texture(iChannel0, uv);\n}\n", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Used and adapted txaa from https://www.shadertoy.com/view/4tcXD2\n// thx btw :)\n\n// Temporal AA based on Epic Games' implementation:\n// https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf\n// \n// Originally written by yvt for https://www.shadertoy.com/view/4tcXD2\n// Feel free to use this in your shader!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 lastColor = texture(iChannel1, uv);\n    \n    vec3 antialiased = lastColor.xyz;\n    float mixRate = clamp(lastColor.w, 0.01, 0.5);\n    \n    vec2 off = 1.0 / iResolution.xy;\n    vec3 in0 = texture(iChannel0, uv).xyz;\n    \n    antialiased = mix(antialiased * antialiased, in0 * in0, mixRate);\n    antialiased = sqrt(antialiased);\n    \n    vec3 in1 = texture(iChannel0, uv + vec2(+off.x, 0.0)).xyz;\n    vec3 in2 = texture(iChannel0, uv + vec2(-off.x, 0.0)).xyz;\n    vec3 in3 = texture(iChannel0, uv + vec2(0.0, +off.y)).xyz;\n    vec3 in4 = texture(iChannel0, uv + vec2(0.0, -off.y)).xyz;\n        \n    vec3 minColor = min(min(min(in0, in1), min(in2, in3)), in4);\n    vec3 maxColor = max(max(max(in0, in1), max(in2, in3)), in4);\n\n   \tvec3 preclamping = antialiased;\n    antialiased = clamp(antialiased, minColor, maxColor);\n    \n    mixRate = 1.0 / (1.0 / mixRate + 1.0);\n    \n    vec3 diff = antialiased - preclamping;\n    float clampAmount = dot(diff, diff);\n    \n    mixRate += clampAmount * 4.0;\n\n    fragColor = vec4(antialiased, mixRate);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// sharpening filter\n\nvec3 texSample(const int x, const int y, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * iChannelResolution[0].xy;\n\tuv = (uv + vec2(x, y)) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).xyz;       \n}                                         \nvec3 sharpenFilter(in vec2 fragCoord, float strength){\n\tvec3 f =\n\ttexSample(-1,-1, fragCoord) *  -1. +                     \n\t//texSample( 0,-1, fragCoord) *  -1. +                    \n\ttexSample( 1,-1, fragCoord) *  -1. +                      \n\t//texSample(-1, 0, fragCoord) *  -1. +                    \n\ttexSample( 0, 0, fragCoord) *   5. +                     \n\t//texSample( 1, 0, fragCoord) *  -1. +                      \n\ttexSample(-1, 1, fragCoord) *  -1. +                     \n\t//texSample( 0, 1, fragCoord) *  -1. +                     \n\ttexSample( 1, 1, fragCoord) *  -1.\n\t;                                              \n\treturn mix(texSample( 0, 0, fragCoord), f , strength);    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n\tvec2 uv = fragCoord/iResolution.xy;                    \n\tvec2 uvMouse = iMouse.xy/iResolution.xy;               \n\tif(uv.x > uvMouse.x){\n\t\tfragColor = vec4(sharpenFilter(fragCoord, uvMouse.y * 0.5),1.0);             \n\t}else{\n\t\tfragColor = vec4(texSample( 0, 0, fragCoord),1.0);\n    }\n    if(uv.x > uvMouse.x - 0.002 && uv.x < uvMouse.x + 0.002){\n    \tfragColor = vec4(1.0,1.0,1.0,1.0);\n\t}\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ly3RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 198, 198, 547]], "test": "untested"}
{"id": "3tKGRD", "name": "Yearclock / Circular Calendar", "author": "izutionix", "description": "Visualizing the time inside a year. Millennium version: [url]https://www.shadertoy.com/view/3sBfW1[/url]\nfrom the inside:\n   second\n   minute\n   hour\n   day\n   week (very inaccurate)\n   month (inaccurate)\n   year\n", "tags": ["timer", "calendar"], "likes": 9, "viewed": 833, "published": 3, "date": "1578416740", "time_retrieved": "2024-07-30T21:31:13.277684", "image_code": "#define ss(d) smoothstep(.159155/p.y*b,-.159155/p.y*b, d)\n#define sc(o) smoothstep(1.*b,-1.*b,p.y-r+o)\n\nvec3 pal(float g)\n{\n\treturn pow(cos(.8-g-vec3(0,.25,.5) ), vec3(12) ); // https://www.shadertoy.com/view/WsffWB\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) /iResolution.y;\n\n    vec2 p = vec2(atan(uv.x,uv.y)/6.283185+.5, length(uv));\n    \n    float b = 2./iResolution.y;\t// blur\n    float r = .85;\t// size\n    float bg = .15; // background brightness\n    \n    \n    // year\n    float ty = fract(iDate.y/12. + iDate.z/30./12. + iDate.w/86400./30./12.);\n    float dy = p.x-ty;\n\tfloat sy = ss(dy);\n    float cy = sc(0.);\n    vec3 year = vec3(max(sy*cy, bg*cy) * pal(1./7.));\n    \n    // month (inaccurate)\n    float tm = fract(iDate.z/30. + iDate.w/86400./30.);\n    float dm = p.x-tm;\n\tfloat sm = ss(dm);\n    float cm = sc(1./8.);\n    vec3 month = vec3(max(sm*cm, bg*cm) * pal(2./7.));\n    \n    // week (very inaccurate)\n    float tw = fract(iDate.z/4.7 + iDate.w/86400./30.);\n    float dw = p.x-tw;\n\tfloat sw = ss(dw);\n    float cw = sc(2./8.);\n    vec3 week = vec3(max(sw*cw, bg*cw) * pal(3./7.));\n\n    // day\n    float td = fract(iDate.w/86400.);\n    float dd = p.x-td;\n\tfloat sd = ss(dd);\n    float cd = sc(3./8.);\n    vec3 day = vec3(max(sd*cd, bg*cd) * pal(4./7.));\n    \n    // hour\n    float th = fract(iDate.w/3600.);\n    float dh = p.x-th;\n\tfloat sh = ss(dh);\n    float ch = sc(4./8.);\n    vec3 hour = vec3(max(sh*ch, bg*ch) * pal(5./7.));\n    \n    // minute\n    float tmi = fract(iDate.w/60.);\n    float dmi = p.x-tmi;\n\tfloat smi = ss(dmi);\n    float cmi = sc(5./8.);\n    vec3 minute = vec3(max(smi*cmi, bg*cmi) * pal(6./7.));\n    \n    // second\n    float ts = fract(iDate.w);\n    float ds = p.x-ts;\n\tfloat ss = ss(ds);\n    float cs = sc(6./8.);\n    vec3 second = vec3(max(ss*cs, bg*cs) * pal(1.));\n    \n    \n    vec3 col = mix(mix(mix(mix(mix(mix(\n\tyear,\n\tmonth, cm),\n\tweek, cw),\n\tday, cd),\n\thour, ch),\n\tminute, cmi),\n\tsecond, cs);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 123, 123, 217], [219, 219, 276, 276, 2040]], "test": "untested"}
{"id": "WlV3zW", "name": "Shader1.1.2", "author": "Ditya_M", "description": "Shader", "tags": ["shader"], "likes": 0, "viewed": 251, "published": 3, "date": "1578414428", "time_retrieved": "2024-07-30T21:31:14.019700", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\nfloat capDist(vec3  p,vec3  a,vec3  b,float r){\nvec3 ab = b-a;\nvec3 ap = p-a;\nfloat t = dot(ab,ap)/dot(ab,ab);\nt = clamp(t,0.,1.);\nvec3 c = a + t* ab;\nreturn length(p-c) -r;\n}\nfloat torusDist(vec3 p ,vec3 o,vec2 r){\nvec3 c = p-o;\nvec2 x = vec2((length(c.xz)- r.x),c.y);\n   return length(x) -r.y;\n}\nfloat getDist(vec3 p){\nvec4 sphere = vec4(0,0.5,1.5,0.5);\n vec3 plane = vec3(0,0,0);\n    float ds = length(p-sphere.xyz) - sphere.w;\n    float td = torusDist(p,vec3(0,0.5,1.5),vec2(0.8,0.1));\n    float dp = p.y - plane.y;\n   return min(ds, min(dp,td));\n    \n    \n}\nfloat rayMarching(vec3 ro,vec3 rd){\n    float dO= 0.0;\n    for(int i = 0;i<MAX_STEPS;i++){\n        vec3 p = ro + dO*rd;\n        float ds = getDist(p);\n        dO += ds;\n        if(dO>MAX_DIST || ds < SURF_DIST){\n            break;\n        }\n    }\n    return dO;\n}\nvec3 getnormal(vec3 p){\n    float d = getDist(p);\n    vec2 e = vec2(0.01,0.0);\n    vec3 n = d - vec3( getDist(p- e.xyy), \n                       getDist(p- e.yxy),\n                       getDist(p- e.yxx));\n    return normalize(n);\n}\nfloat getLight(vec3 p){\n    vec3 lightO = vec3(0,4,2);\n    lightO.xz += vec2(cos(iTime),sin(iTime))*2.0;\n    vec3 n = getnormal(p);\n    vec3 ray =  normalize(lightO-p);\n    float light = clamp(dot(ray,n),0.0,1.0);\n    float d = rayMarching(p +n*SURF_DIST*6.0,ray);\n    if(d < length(lightO-p)) light *= 0.1;\n    return light;\n}\n  void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec3 rayO = vec3(0.0,1.5,-2.0);\n    vec3 rayDir = vec3(uv.x,uv.y-0.2,1);\n    float d = rayMarching(rayO,rayDir);\n    vec3 p = rayO + rayDir*d;\n    d /= 3.0;\n    float light = getLight(p);\n      vec3 col = vec3(0.8,0.8,0.9);\n      if(light < 0.) {\n      col = vec3(0.0,0.2,0.9);\n       light = 1.0;\n  }\n     col *= light;\n     fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3zW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 115, 115, 243], [244, 244, 283, 283, 365], [366, 366, 388, 388, 630], [631, 631, 666, 666, 894], [895, 895, 918, 918, 1128], [1129, 1129, 1152, 1152, 1456], [1459, 1459, 1515, 1565, 1985]], "test": "untested"}
{"id": "WlKGRW", "name": "Day 19 - Virus", "author": "jeyko", "description": "It's day 19 of my month of coding daily", "tags": ["virus", "geodesic", "mdtmjvm"], "likes": 50, "viewed": 1630, "published": 3, "date": "1578406371", "time_retrieved": "2024-07-30T21:31:14.949215", "image_code": "// All geodesic reflection functions and are from tdhooper! shadertoy.com/view/4tG3zW\n// They are in common tab! \n\n// Buffer A is draw buffer\n// Buffer B is TAA from https://www.shadertoy.com/view/4dSBDt\n\n\n// These little guys really like fresnel :D\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    col *= 2.;\n    fragColor = col;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI acos(-1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\nint Type=5;\nvec3 nc,pab,pbc,pca;\nvoid initIcosahedron() {\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);\n}\n\nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\nvec3 pIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    if (subdivisions > 0) {\n\n        vec3 A = pbc;\n       \tvec3 C = reflect(A, normalize(cross(pab, pca)));\n        vec3 B = reflect(C, normalize(cross(pbc, pca)));\n       \n        vec3 n;\n\n\n        float d = .5;\n        \n        vec3 p1 = bToC(A, B, C, vec3(1.-d, .0, d));\n        vec3 p2 = bToC(A, B, C, vec3(1.-d, d, .0));\n        n = normalize(cross(p1, p2));\n        pReflect(p, n, 0.);\n        \n        if (subdivisions > 1) {\n\n            A = reflect(A, n);\n            B = p1;\n            C = p2;\n\n            p1 = bToC(A, B, C, vec3(.5, .0, .5));\n            p2 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n            \n\n\t\t\tp2 = bToC(A, B, C, vec3(.0, .5, .5));\n            p1 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n        }\n    }\n    \n    return pca;\n}\n\n\n\n// Inigo quilez\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125 + u.z*12525.215215215)*124115.125235);\n}\nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float ibl = r31(id + vec3(0,-1,0));\n    float ibr = r31(id + vec3(1,-1,0));\n    float itl = r31(id + vec3(0));\n    float itr = r31(id + vec3(1,0,0));\n    \n    \n    float jbl = r31(id + vec3(0,-1,1));\n    float jbr = r31(id + vec3(1,-1,1));\n    float jtl = r31(id + vec3(0,0, 1));\n    float jtr = r31(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    //return j;\n    return mix(i, j, fd.z); \n}\n\nfloat fbmOld(vec3 p){\n\n    float n = 0.;\n    p *= 0.1;\n    \n    float f = valueNoise(p); \n    \n    float q = valueNoise(p*1.4);\n    \n    float j = valueNoise(p*3.);\n    float l = valueNoise(p*6.);\n    \n    float z = valueNoise(p*f*q*4.);\n    float i = valueNoise(p*f*q*4.5);\n   \n    n += f*0.9 + q*1. + z*0.36 + j*0.4 + l * 0.2;\n    //n += f*1.8 + q*0.5 + z*0.5 + i*0.4;\n    \n\treturn n;\n}\n", "buffer_a_code": "#define PI acos(-1.)\n\n\n#define mx (20.*iMouse.x/iResolution.y)\n#define iTime (iTime + mx )\n\n\n\n// Noise (from iq)\nfloat noise (in vec3 p) {\n\tvec3 f = fract (p);\n\tp = floor (p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tf.xy += p.xy + p.z * vec2 (37.0, 17.0);\n\tf.xy = texture (iChannel0, (f.xy + 0.5) / 256.0, -256.0).yx;\n\treturn mix (f.x, f.y, f.z);\n}\n\nfloat fbm (in vec3 p) {\n    \n    float n = 0.; \n    p *= 3.;\n    \n    float f = noise(p); \n    \n    float q = noise(p*1.4);\n    \n    float j = noise(p*3.);\n    float l = noise(p*6.);\n    \n    float z = noise(p*f*q*4.);\n    float i = noise(p*f*q*4.5);\n   \n    n += f*0.9 + q*1. + z*0.36 + j*0.4 + l * 0.2;\n    \n    return n;\n}\n\n\n\n\n#define dmin(a, b) a.x < b.x ? a : b\n\n#define tendrilLength 3.5\n#define orbSize 0.13\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x) , cos(x))\n#define pmod(p, x) mod(p, x) - x*0.5\nvec2 map(vec3 p){\n    \n    #define modDistX 10.\n    #define modDistZ 10.\n    #define modDistY (modDistZ*1.5)\n    vec3 id = vec3(\n    \tfloor(p.x / modDistX ),\n    \tfloor(p.z / modDistZ ),\n    \tfloor(p.y / modDistY ) // wat\n    );    \n\n    float r = fract(sin(id.x*2123.52421 + id.y*214.512 + id.z)*24.123);    \n    \n    \n    p.y += id.x*(2.*r - 1.)*8.;\n    \n    \n    p.z += sin(iTime*r*0.4)*0.2;\n    p.x += sin(iTime*r*2.4)*0.2;\n    p.y += sin(iTime*r*0.4)*2.4;\n    \n    p.x = pmod(p.x, modDistX);\n    \n    p.z = pmod(p.z, modDistZ);\n    p.y = pmod(p.y, modDistY);\n    \n\n    \n    \n\tvec2 d = vec2(10e5);\n    if (id.xy == vec2(0.)){\n        p.xy *= rot(0.2 + iTime*(1. - 2.*r)*0.1);\n        p.xz *= rot(0.2 + iTime*(1. - 2.*fract(r*2214.124))*0.02);\n        \n    } else {\n        p.xy *= rot(0.2 + iTime*(1. - 2.*r)*0.2);\n        p.xz *= rot(0.2 + iTime*(1. - 2.*fract(r*2214.124))*0.2);\n    }\n    //p.xy *= rot(0.2 + iTime*r*0.02);\n    \n    vec3 z = p;\n    \n    //p.z += id.x*modDistX*0.5;\n    \n    \n   \tvec3 n = pIcosahedron(p, int(1));\n\n    //d = dmin(d, vec2(dot(p - 1., n),1.));\n    \n\t\n    float dSphere = min(d.x, length(p) - 1.4);\n    d.x = dSphere;\n    \n    d.x = opSmoothUnion(d.x,max(length(p.xy) - 0.01, (dot(p, n) - tendrilLength)), 0.5);\n    \n    \n    p.z -= tendrilLength + orbSize*2.;\n    d.x = opSmoothUnion(d.x, length(p) - orbSize, 0.1);\n    \n    \n    \n    if (d.x == dSphere){\n    \td.y = 4.;\n    }\n    \n    d.x -= fbm(z)*0.06;\n    \n    \n    \n    d.x *= 0.5;\n    //d = dmin(d, vec2(length(p) - 1.,1.));\n    \n    \n    \n\treturn d;\n}\n\n#define modTime sin(iTime*0.8 +  sin(iTime*0.6))\n#define fov (1. + modTime*0.04)\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 d = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0),d ));\n\tvec3 up = normalize(cross(d,right ));\n    return d + right*uv.x*fov + up*uv.y*fov;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001,0.);\n    return normalize(\n                    -vec3(\n                    \tmap(p - t.xyy).x - map(p + t.xyy).x,\n                    \tmap(p - t.yxy).x - map(p + t.yxy).x,\n                    \tmap(p - t.yyx).x - map(p + t.yyx).x\n                    )\n                    );\n}\n\n    #define zoom 10.\nvec3 render(vec3 ro, vec3 lookAt, vec2 uv, inout float t) {\n    vec3 col = vec3(0);\n    vec3 rd = getRd(ro, lookAt, uv);\n\n    vec3 p = ro; float tL = 0.;\n    rd.xz *= rot(0.1 - modTime*0.04);\n    rd.yz *= rot(sin(iTime*0.6)*0.1);\n    \n    for (int i = 0; i < 100; i ++){\n    \tvec2 d = map(p);\n        \n        if(d.x < 0.002){\n        \t\n            vec3 n = getNormal(p);\n            \n            vec3 lDir = normalize(vec3(1));\n            \n        \tvec3 h = normalize(lDir - rd);\n            \n            float diff = max(dot(n, lDir), 0.);\n            float spec = max(dot(n, h), 0.);\n            float fres = pow(1. - max(dot(n, -rd), 0.), 3.);\n            float fresB = pow(max(dot(n, -rd), 0.), 3.);\n            float fresC = pow(max(dot(n, -rd), 0.)*1., 20.);\n            \n            //col += n*0.5 + 0.5;\n            //col += mix(fresB*vec3(0,0.2,.9)*1., vec3(0.02,0.2,0.5), max(pow(fresC, 0.34) +0.15, 0.));\n            col += fresB*vec3(0,0.34,.9)*1.;\n            \n            if (d.y==4.) {\n            \tcol += fres*vec3(1.,1.,1)*2.;\n            \tcol -= pow(fresC, 0.5)*vec3(0,0.34,.9)*1.;\n            }else {\n             \tcol += vec3(1)*pow(1. - max(dot(n, -rd), 0.), 2.);\n            \tcol -= pow(fresC, 0.5)*vec3(0,0.34,.9)*1.;\n            }\n            break;\n        }\n        if (tL > 40.) {\n        \tbreak;\n        }\n    \n        \n        tL += d.x;\n        p = ro + rd*tL;\n    }\n    \n    t = tL;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initIcosahedron();\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 lookAt = vec3(0. + modDistX*0.5,0. + modTime*0.5 - modDistY*0.5,0. + modDistZ*0.5);\n    vec3 ro = lookAt + vec3(sin(0.2 + sin(iTime*0.2)*0.15)*zoom, 0., cos(0.4)*zoom);\n    ro.x += 3.4;\n    float t = 0.;\n    \n    \n    \n    \n    vec2 st =  0.5/iResolution.xy;\n    col += render(ro, lookAt, uv, t);\n    //col += render(ro, lookAt, uv + st, t);\n\n    \n    //col /= 2.;\n    \n    //col *= 1.;\n    \n    col = clamp(col, 0., 1.);\n    col = mix(col, vec3(0.,0.05,0.8)*0.01, smoothstep(0.,1.,t*0.04));\n    \n    col *= 1. - pow(length(uv)*0.86 + 0.1, 2.)*1.;\n    col = pow(col, vec3(0.45));\n    \n    \n    \n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "ivec2 offsets[8] = ivec2[8]( ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0));\n\nvec3 RGBToYCoCg( vec3 RGB )\n{\n\tfloat Y = dot(RGB, vec3(  1, 2,  1 )) * 0.25;\n\tfloat Co= dot(RGB, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat Cg= dot(RGB, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(Y, Co, Cg);\n}\n\nvec3 YCoCgToRGB( vec3 YCoCg )\n{\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat Cg= YCoCg.z - ( 0.5 * 256.0 / 255.0 );\n\tfloat R= Y + Co-Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co-Cg;\n\treturn vec3(R,G,B);\n}\n\n//#define NO_AA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;    \n    vec3 new = RGBToYCoCg(textureLod(iChannel0, q, 0.0).xyz);\n    vec3 history = RGBToYCoCg(textureLod(iChannel1, q, 0.0).xyz);\n    \n    vec3 colorAvg = new;\n    vec3 colorVar = new*new;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord.xy)+offsets[i], 0).xyz);\n        colorAvg += fetch;\n        colorVar += fetch*fetch;\n    }\n    colorAvg /= 9.0;\n    colorVar /= 9.0;\n    float gColorBoxSigma = 0.75;\n\tvec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg*colorAvg));\n\tvec3 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec3 colorMax = colorAvg + gColorBoxSigma * sigma;\n    \n    history = clamp(history, colorMin, colorMax);\n  \n\tfragColor = vec4(YCoCgToRGB(mix(new, history, 0.95)), 1.0);\n#ifdef NO_AA\n    fragColor = vec4(YCoCgToRGB(new), 1.0);\n#endif\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define tempo 170.\n#define hbeat ((60./tempo)/1.)\n#define qnote (hbeat/2.)\n#define beat  (hbeat*2.)\n#define qbeat  (beat/4.)\n#define measure  (hbeat*2.)\n\n\nfloat note(float note, float octave){\n\treturn 27.5*pow(2., ((octave*12.) + note )/12.);\n}\nfloat noise( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\nfloat random(float st){\n\treturn fract(sin(st*42151.5524124));\n}\nfloat rand(float t) {\n\treturn fract(sin(t*3211251.325235325));\n}\n\n\nvec2 makeBells(float t, float freq, float scale) {\n    vec2 s = vec2(0);\n    float r = random( mod(floor(t/ hbeat), 26.) + 4.);\n    float rC = r;\n    float rB = random( mod(floor((t + 4.)/ hbeat) + 4., 26.));\n        float env = exp(-t*15.);\n        \n        float iters = 2.;\n    \tfor (float i = 0.; i < iters; i++) {\n       \t\t//s.x += sin(freq *tau*t) * env * scale ;\n            s.x += sin(freq *tau*t) * scale * (2. + sin(t));\n            \n            freq *= 3.06;\n        }\n\t\t//s.x /= iters;\n    \t//s.x += sin( (random(t)) *tau*t) * env*2. ;\n        \n        //s.x = clamp(s.x*1.6,-1., 1.);\n\n        \n        s.y = s.x;\n    \n    return s;\n}\n\nvec2 reverbChannelB(float t) {\n\tvec2 s = vec2(0);\n    \n    vec2 reverb = vec2(0);\n    float st = 0.001; float iters = 100.;\n    for (float i = 0.; i < iters; i++) {\n    \treverb += ((makeBells(t - i*st + random(i )*0.4, note(9.,1.), 0.4 ))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st + sin(t*0.2)*0.01 + random(i )*0.4, note(16.,1.), 0.7))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st - sin(t*0.3)*0.01 + random(i )*0.4, note(19.,1.), 0.7))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st + 0.02 - sin(t*0.4)*0.01 + random(i )*0.4, note(12.,2.), 0.7))/iters) *(1. - i/iters) ;\n    \treverb += ((makeBells(t - i*st - 0.01 + sin(t*0.5 + sin(0.2*t*note(16.,2.)*tau*0.5 + sin(0.3*t*note(16. + 7.,1.)))*0.13*sin(t*0.8))*0.01 + random(i )*0.4, note(16.,2.), 0.3))/iters) *(1. - i/iters) ;\n    }\n\n    s += ((makeBells(t , note(9.,1.), 0.4 ))/iters)*0.001;\n    s += ((makeBells(t  , note(12.,2.), 0.1))/iters)*0.001;\n    s += ((makeBells(t  , note(18.,2.), 0.5))/iters)*0.001;\n    \n    //s += makeBells(t, note(9.,1.))*0.01;\n    s += reverb*5.5;\n    //s *= 2.;\n\treturn s;\n}\n\nvec2 droneChannel(float t){\n\tvec2 s = vec2(0);\n\tfloat iters = 20.;\n    \n    \n    for(float i = 0.; i < iters; i++){\n        float r = random(i);\n        float rB = fract(r*124.52412);\n    \ts += reverbChannelB(t + r*0.1 + 0.02*r + sin(0.6*t*(1. - rB*0.05))*(0. + r*0.01));\n    }\n    s += reverbChannelB(t)*0.5;\n    \n    s /= iters;\n    \n    \n    \n    return s;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 s = vec2(0);\n    \n    \n    \n    s += droneChannel(time + random(time)*0.0001*sin(time))*0.5;\n    \n    s *= smoothstep(0.,1.,time*0.5);\n    return s;\n}", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 308, 308, 425]], "test": "untested"}
{"id": "WlVGRW", "name": "iDate.w  in sound vs iFrame 0", "author": "FabriceNeyret2", "description": "press rewind.  Choose iDate.w digit in Common.  \nwhite bar = 1..10 = 1+ digit of iDate.w as seen in fragment shader at init frame.\nbeeps: count of 1+ digit of iDate.w as seen in sound buffer.\n-> no fractions of second in Sound shader ?", "tags": ["sync", "bug", "count", "idatew"], "likes": 1, "viewed": 692, "published": 3, "date": "1578404293", "time_retrieved": "2024-07-30T21:31:15.695220", "image_code": "// === draw iDate.w digit + visual count\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    int   T = DIGIT( T(U).w );     // iDate.w at pixel shader launch\n    float t = float(T);            // test time digit\n\n    U /= iResolution.xy;\n    float x = U.x*10.;\n    \n    if ( floor(x) == t )  O.rg ++; // target\n    if ( floor(x) <= t && ceil(x) < iTime ) O.b ++; // progression\n    \n    if (fract(x) < .1) O.r++;      // separators\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// === beep iDate.w digit \n\nvec2 mainSound( in int samp, float time )\n{\n    int   T = DIGIT(iDate.w);    // iDate.w at sound shader eval\n    float t = float(T);          // test time digit\n    return floor(time) < t+1.  && fract(time) > .7\n        ? vec2( sin(6.2831*440.*time) )\n        : vec2(0);\n}", "sound_inputs": [], "buffer_a_code": "// === sample iDate at pixel shader launch\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = iFrame==0 ? iDate : T(U);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// === select iDate.w digit to compare : \n\n// #define DIGIT(t) ( int(t/10. )) % 10    // test seconds decades\n   #define DIGIT(t) ( int(t     )) % 10    // test seconds low digit\n// #define DIGIT(t) ( int(t*10. )) % 10    // test seconds 10th\n\n#define T(U) texelFetch(iChannel0, ivec2(U) , 0)", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 80, 80, 425]], "test": "untested"}
{"id": "ttdGzX", "name": "Another Wet Brick in the Wall", "author": "crocidb", "description": "Another Wet Brick in the Wall\n\nInteract with mouse to slightly change camera view.", "tags": ["raymarch", "wall", "brick", "rock"], "likes": 7, "viewed": 702, "published": 3, "date": "1578402040", "time_retrieved": "2024-07-30T21:31:16.631716", "image_code": "/* \n * Another Wet Brick in the Wall\n */\n\n// Antialiasing: Any number above 1 will make it look better, but slow.\n#define AA 1\n\n\n#define ZERO (min(iFrame,0))\n#define MAX_STEPS\t\t\t100\n#define MAX_DIST\t\t\t25.0\n#define SURFACE_DIST\t\t0.006\n\n\nvec3 light_pos = vec3(-12.0, 18.5, -12.0);\nvec3 ro = vec3(0.0, 2.8, -4.0);\n\nfloat oTime;\n\nvec2 closest(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 wall(vec3 p)\n{\n    //float abs_noise_1 = abs(noise(p * 50.0));\n    float abs_noise_1 = abs(fbm_2(p * 50.0));\n    float abs_noise_2 = abs(noise(p * 5.0));\n        \n    // wall\n    float f = dot(p, vec3(0.0, 0.0, -1.0));\n                  \n   \tvec2 wall = vec2(f - abs_noise_1 * 0.003 - abs_noise_2 * 0.013, 1.0);\n    \n    // bricks\n    vec3 c = vec3(0.7, 0.65, 0.0);\n    vec3 bp = p - vec3(0.0, 0.0, 0.004);\n    vec3 bp1 = mod(bp + 0.5 * c, c) - 0.5 * c;\n    bp -= vec3(0.35, 0.33, 0.0);\n    vec3 bp2 = mod(bp + 0.5 * c, c) - 0.5 * c;\n    \n    float b = sdBox(bp1, vec3(0.288, 0.08, 0.03));\n    b = min(b, sdBox(bp2, vec3(0.288, 0.09, 0.03)));\n    vec2 bricks = vec2(b - abs_noise_1 * 0.005 - abs_noise_2 * 0.02 - .010, 2.0);\n                  \n    return closest(wall, bricks);\n}\n\nvec2 map(vec3 p)\n{\n    vec3 wall2 = p;\n    wall2.x -= 3.0;\n    wall2.xz = wall2.zx;\n    \n    return closest(wall(p), wall(wall2));\n}\n\nvec3 calcNormal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0001*e).x;\n    }\n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec3 p;\n    vec2 obj;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = ro + t * rd;\n       \t\n        obj = map(p);\n        \n        if (obj.x < SURFACE_DIST || t > MAX_DIST) break;\n        \n        t += obj.x;\n    }\n    \n    obj.x = t;\n    return obj;\n}\n\n// Lighting\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat stepSize = 0.002f;\n\tfloat t = stepSize;\n\tfloat oc = 0.0f;\n\tfor(int i = 0; i < 10; ++i)\n\t{\n\t\tvec2 obj = map(p + n * t);\n\t\toc += t - obj.x;\n\t\tt += pow(float(i), 2.2) * stepSize;\n\t}\n\n\treturn 1.0 - clamp(oc * 0.2, 0.0, 1.0);\n}\n\nfloat getVisibility(vec3 p0, vec3 p1, float k)\n{\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0f * SURFACE_DIST;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0f;\n\twhile(t < maxt || t < MAX_DIST)\n\t{\n\t\tvec2 o = map(p0 + rd * t);\n\n\t\tif(o.x < SURFACE_DIST)\n\t\t\treturn 0.0f;\n\n\t\tf = min(f, k * o.x / t);\n\n\t\tt += o.x;\n\t}\n\n\treturn f;\n}\n\n// Texturing\nvec2 triplanar(vec3 p, vec3 normal)\n{\n    if (abs(dot(normal, vec3(0.0, 1.0, 0.0))) > .8)\n    {\n        return p.xz;\n    }\n    else if (abs(dot(normal, vec3(1.0, 0.0, 0.0))) > .8)\n    {\n        return p.yz;\n    }\n    else\n    {\n        return p.xy;\n    }\n}\n\nvec3 textureWall(vec2 uv)\n{\n    vec2 iuv = floor(uv * 10.0);\n    vec3 col = clamp(smoothstep(0.14, 0.65, noise(uv * 10.4)) + .9, 0.0, 1.0) * vec3(0.4);\n    return col;\n}\n\n// Renderer\nvec3 render(vec2 obj, vec3 p, vec3 rd, vec2 uv)\n{\n    vec3 col;\n    \n    vec3 normal = calcNormal(p);\n    float fog;\n    \n    if (obj.x >= MAX_DIST)\n    {\n        col = vec3(1.0, 0.6, 0.4) * 2.0;\n    }\n    else\n    {\n        vec3 light_dir = normalize(light_pos - p);\n        float diffuse = dot(light_dir, normal);\n        \n        float wet_mask = max(0.0, noise(p * 0.6));\n        vec3 refd = reflect(rd, normal);\n        float spec = pow(max(0.0, dot(refd, light_dir)), 15.0);\n        \n        float green_mask = max(0.0, noise(p * 2.1));\n        \n        fog = pow((obj.x / MAX_DIST), 2.3);\n        float aa = ambientOcclusion(p, normal);\n        float shadow = getVisibility(p, light_pos, 2.5);\n        \n        vec3 wp = p - 0.65 * fract(.5 * floor(2./0.65 * p.y+0.5));\n        wp.xz = wp.xz-3.5*floor(1./0.7*wp.xz+.5);\n        float bricknoise = ((noise(wp * 2.0)) * .5 + 0.7);\n        float wallnoise = ((noise(p * 2.0)) * .2 + 0.7);\n        \n        if (obj.y >= 2.0) // Bricks\n        {\n            vec2 uv = triplanar(p, normal) * 3.0;\n            \n            uv = mod(uv * 0.02 + 0.5, 1.0);\n            vec3 t = vec3(0.805, 0.194, 0.184) * bricknoise;\n            \n            col = t * aa * .5;\n            col += diffuse * t * shadow;\n            col -= max(0.0, 1.0 - wet_mask) * vec3(0.12);\n            col += spec * vec3(1.4) * wet_mask;\n            col += shadow * vec3(0.3, 0.22, 0.16) * 1.0;\n            col *= aa;\n        }\n        else if (obj.y >= 1.0) // Walls\n        {\n            vec2 uv = triplanar(p, normal) * 3.0;\n            \n            uv = mod(uv * 0.02 + 0.5, 1.0);\n            vec3 t = vec3(0.465, 0.454, 0.424) * wallnoise;\n            \n            col = t * aa * .9;\n            col += diffuse * t * shadow;\n            col -= max(0.0, 1.0 - wet_mask) * vec3(0.1);\n            col += shadow * vec3(0.3, 0.22, 0.16) * 1.0;\n            col *= aa;\n        }\n    }\n    \n    return mix(col, vec3(1.0, 0.6, 0.4) * 2.0, fog);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    oTime = iTime;\n    \n    float d = 1.0;\n    float v = ((iMouse.x / iResolution.x) - .6) * -1.5 + sin(iTime * .1) * .4;\n    vec3 ta = ro + vec3(sin(v) * d, clamp((iMouse.y / iResolution.y), -0.5, 0.5), cos(v) * d);\n    \n    ro.y += sin(iTime * .5) * .5;\n    ta.y += sin(iTime * .3) * .2;\n    \n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for(int m=ZERO; m<AA; m++)\n    for(int n=ZERO; n<AA; n++)\n    {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n#else    \n    \tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n#endif       \n        // Ray direction\n        vec3 ww = normalize(ta - ro);\n        vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n        vec3 vv = normalize(cross(uu, ww));\n        \n        vec3 rd = normalize(uv.x * uu + uv.y * vv + 2.3 * ww);\n        \n        // render\t\n        vec2 obj = rayMarch(ro, rd);\n        vec3 p = ro + obj.x * rd;\n    \n   \t\tvec3 col = render(obj, p, rd, uv);\n        \n        // gamma\n    \tcol.xyz = pow( col.xyz, vec3(0.695) );\n        \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n        \n\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "// Math\nconst float PI = 3.1415926535897932384626433832795;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\nmat2 rotate(float psi){\n    float c = cos(psi);\n    float s = sin(psi);\n\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c));\n}\n\n// SDF\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// SDF Operators\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n// Noise\nvec2 random(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noiseo(vec2 st)\n{\n    vec2 f = fract(st);\n    vec2 i = floor(st);\n    \n    vec2 u = f * f * f * (f * (f * 6. - 15.) + 10.);\n    \n    float r = mix( mix( dot( random(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    return r * .5 + .5;\n}\n\nfloat fbm(vec2 st)\n{\n    float value = 0.;\n    float amplitude = .5;\n    float frequency = 0.;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        value += amplitude * noiseo(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    \n    return value;\n}\n\n// Noise and FBM (as seen on iq tutorials)\n//==========================================================================================\n// hashes\n//==========================================================================================\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    p = p*k + k.yx;\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\n//==========================================================================================\n// noises\n//==========================================================================================\n\n// value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                      2.0* du * vec2( k1 + k4*u.y,\n                                      k2 + k4*u.x ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n#if 0\n    p *= 0.3183099;\n    float kx0 = 50.0*fract( p.x );\n    float kx1 = 50.0*fract( p.x+0.3183099 );\n    float ky0 = 50.0*fract( p.y );\n    float ky1 = 50.0*fract( p.y+0.3183099 );\n\n    float a = fract( kx0*ky0*(kx0+ky0) );\n    float b = fract( kx1*ky0*(kx1+ky0) );\n    float c = fract( kx0*ky1*(kx0+ky1) );\n    float d = fract( kx1*ky1*(kx1+ky1) );\n#else\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n#endif\n    \n    return -1.0+2.0*( a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y );\n}\n\n//==========================================================================================\n// fbm constructions\n//==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n//------------------------------------------------------------------------------------------\n\nfloat fbm_2( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<2; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nvec4 fbmd_8( in vec3 x )\n{\n    float f = 1.92;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=0; i<7; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nfloat fbm_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<9; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\nvec3 fbmd_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    vec2  d = vec2(0.0);\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yz;       // accumulate derivatives\n        b *= s;\n        x = f*m2*x;\n        m = f*m2i*m;\n    }\n\treturn vec3( a, d );\n}\n\nfloat fbm_4( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdGzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 326, 356, 356, 388], [390, 390, 409, 457, 1174], [1176, 1176, 1194, 1194, 1308], [1310, 1310, 1335, 1433, 1635], [1637, 1637, 1670, 1670, 1956], [1958, 1970, 2010, 2010, 2240], [2242, 2242, 2290, 2290, 2567], [2569, 2582, 2619, 2619, 2838], [2840, 2840, 2867, 2867, 3009], [3011, 3023, 3072, 3072, 4984]], "test": "untested"}
{"id": "ttGGzD", "name": "triskel b (250 chars)", "author": "FabriceNeyret2", "description": "regolfing 2017' shader [url]https://shadertoy.com/view/XlVXRW[/url] ( 305 chars )\n\nCould it be shorter ? :-p", "tags": ["2d", "2tweets", "short", "golf", "triskel", "celtic"], "likes": 5, "viewed": 351, "published": 3, "date": "1578399827", "time_retrieved": "2024-07-30T21:31:17.434570", "image_code": "// regolfing 2017' shader https://shadertoy.com/view/XlVXRW ( 305 chars )\n\n#define A atan(U.y,U.x)                   //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n    U.y += .1;\n    float p = .1592,\n          c = length( U = 3.* U* mat2(cos( floor(3.*A*p-p)/3./p +.05+ vec4(0,11,33,0)))\n                         - vec2(0,1.73) );\n    O += c + fract( A*p + .4 ) > 2.\n           ? c\n           :  min( 1., abs( c = 5.* sin( A + c/p ) ) )\n            - max( 0.,      c - 3. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 156, 156, 532]], "test": "untested"}
{"id": "WtXGD2", "name": "Tezza Zoom Rotate", "author": "Tezza48", "description": "Messing around with xor and more old skool fx", "tags": ["zoom", "rotate", "xor"], "likes": 5, "viewed": 302, "published": 3, "date": "1578387395", "time_retrieved": "2024-07-30T21:31:18.272330", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = sin(iTime);\n    float c = cos(iTime);\n    \n    ivec2 fc = ivec2(abs(fragCoord * mat2(c, -s, s, c) * s)) % 256;\n    \n    float xor = float(fc.x ^ fc.y) / 256.0;\n    \n    fragColor = vec4(vec3(xor),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 275]], "test": "untested"}
{"id": "wtyGRD", "name": "Snake Worship", "author": "dr2", "description": "Ancient ceremony...", "tags": ["fire", "light", "kinematics", "weave"], "likes": 10, "viewed": 405, "published": 3, "date": "1578385272", "time_retrieved": "2024-07-30T21:31:19.213813", "image_code": "// \"Snake Worship\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// (Mostly from \"Multisegment Floppy Tube\", \"Parthenon 2\" and \"Woven Basket\")\n\n#define AA  1   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Noiseff (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 hxHit;\nvec3 qHit, fCylPos;\nfloat tCur, dstFar, aMin, dLoop, aLoop, hLen, snbRad, fCylRad, fCylLen, flmFlkr;\nint idObj;\nconst int idBask = 1, idEye = 2, idSnk = 3, idAltr = 4, idLogs = 5, idCoal = 6;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float nSeg = 2.;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat SnakeDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 b, c;\n  float d, lb;\n  p.z = 0.6 * (abs (p.z) - 1.5);\n  p.xy = Rot2D (p.xy, 0.5 * pi - 0.5 * aLoop);\n  p.x -= - hLen + (dLoop + snbRad) * sin (0.5 * aLoop);\n  p.xy = Rot2D (p.xy, 0.5 * pi - aLoop);\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (-0.5, -0.5, 0.5) * snbRad;\n  d = PrSphDf (q, 0.3 * snbRad);\n  DMIN (idEye);\n  d = dMin;\n  for (float k = 0.; k < nSeg; k ++) {\n    q = p;\n    q.xy = vec2 (- q.y, q.x);\n    q.xy = Rot2D (vec2 (q.x, q.y - dLoop), aLoop - 0.5 * pi);\n    b = vec2 (length (q.xy) - dLoop, q.z);\n    lb = length (b);\n    c = atan (vec2 (q.y, b.x), vec2 (- q.x, b.y)) * vec2 (4. * dLoop / pi, 1.) / pi;\n    d = max (lb - snbRad, dot (vec2 (q.x, abs (q.y)), sin (aLoop + vec2 (0., 0.5 * pi))));\n    if (k == 0.) d = min (d, PrSphDf (p, snbRad));\n    p.xy = Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.);\n    p.x *= -1.;\n    if (k == nSeg - 1.) d = min (d, PrSphDf (p, snbRad));\n    if (d < dMin) hxHit = vec4 (c, lb, k);\n    DMIN (idSnk);\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 cs;\n  float dMin, d, szFac, rt, rc, h, s;\n  dMin = dstFar;\n  q = p;\n  q.y -= 0.5;\n  d = min (max (max (PrSphDf (q, 0.78), -0.01 + q.y), -0.3 - q.y),\n     PrCylDf ((q - vec3 (0., -0.7, 0.)).xzy, 0.15, 0.42));\n  DMINQ (idAltr);\n  qq = p;\n  qq.y -= fCylPos.y - fCylLen + 0.09;\n  d = PrCylDf (qq.xzy, fCylRad, 0.1);\n  if (d < 0.05) {\n    cs = sin (pi * vec2 (1.3, 0.8));\n    for (int j = 0; j < 5; j ++) {\n      qq.xz = Rot2Cs (qq.xz, cs);\n      q = qq;\n      q.x += 0.21;\n      d = PrRoundCylDf (q, 0.05 - 0.01 * sin (10. * pi * q.z), 0.02, 0.666);\n      DMIN (idLogs);\n    }\n    q = p;\n    q.y -= fCylPos.y - fCylLen - 0.02;\n    d = PrCylDf (q.xzy, fCylRad- 0.03, 0.01);\n    DMIN (idCoal);\n  } else dMin = min (dMin, d);\n  szFac = 0.2;\n  dMin /= szFac;\n  p /= szFac;\n  p.xz = Rot2D (abs (p.xz) - 12., -0.25 * pi);\n  qq = p;\n  rt = 0.1;\n  rc = 16. / pi;\n  h = 2.;\n  p.y -= -2.6 + h + 2. * rt;\n  p.xz *= 1.1 - 0.1 * (p.y + h) / h;\n  q = p;\n  q.xz = vec2 (rc * atan (q.z, - q.x), length (q.xz) - rc);\n  d = length (vec2 (abs (q.y) - h, q.z)) - 2. * rt;\n  q.xy = mod (q.xy + 0.5, 1.) - 0.5;\n  s = rt * cos (2. * pi * q.x);\n  d = min (d, max (min (length (vec2 ((mod ((q.x - q.y) + 0.5, 1.) - 0.5) / sqrt (2.), q.z + s)),\n     length (vec2 ((mod ((q.x + q.y) + 0.5, 1.) - 0.5) / sqrt (2.), q.z - s))) - rt, abs (p.y) - h));\n  q = p;\n  q.y -= - h;\n  d = min (d, PrCylDf (q.xzy, rc, 2. * rt));\n  DMIN (idBask);\n  p = qq;\n  dMin = SnakeDf (p, dMin);\n  dMin *= szFac;\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dLight)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.1, h);\n    if (sh < 0.05 || d > dLight) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec2 CylHit (vec3 ro, vec3 rd, float cylRad, float cylHt)\n{\n  vec3 s;\n  float dCylIn, dCylOut, a, ai, b, w, ws, srdy;\n  dCylIn = dstFar;\n  dCylOut = dstFar;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - cylRad * cylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      ai =  1. / a;\n      dCylIn = (- b - ws) * ai;\n      dCylOut = (- b + ws) * ai;\n    }\n    if (a > 0.) s = ro + dCylIn * rd;\n    else s.y = cylHt;\n    if (abs (s.y) > cylHt) {\n      if (srdy * ro.y < - cylHt) {\n        dCylIn = - (srdy * ro.y + cylHt) / abs (rd.y);\n        if (length (ro.xz + dCylIn * rd.xz) > cylRad) dCylIn = dstFar;\n      } else dCylIn = dstFar;\n    }\n    if (dCylIn < dstFar) {\n      if (a > 0.) s = ro + dCylOut * rd;\n      else s.y = cylHt;\n      if (abs (s.y) > cylHt && srdy * ro.y < cylHt)\n         dCylOut = (- srdy * ro.y + cylHt) / abs (rd.y);\n    }\n  }\n  return vec2 (dCylIn, dCylOut);\n}\n\nfloat FlmAmp (vec3 ro, vec3 rd, vec2 dst)\n{\n  vec3 p, q;\n  float fh, fr, aSum, a, d;\n  const float ns = 24.;\n  p = ro + dst.x * rd;\n  d = dst.x + fCylRad / ns;\n  aSum = 0.;\n  for (float j = 0.; j < ns; j ++) {\n    p = ro + d * rd;\n    fr = 1. - length (p.xz) / fCylRad;\n    fh = 0.5 * (1. - p.y / fCylLen);\n    q = 2. * p;\n    q.xz = Rot2D (q.xz, 0.3 * q.y);\n    a = 1.1 * Fbm3 (q - vec3 (0., 4. * tCur, 0.));\n    q = 5. * p;\n    q.xz = Rot2D (q.xz, -0.4 * q.y);\n    a += 0.9 * Fbm3 (q - vec3 (0., 5. * tCur, 0.));\n    aSum += max (0.3 * fr * fr * fh * (a * a - 0.6), 0.);\n    q = 73. * p;\n    aSum += step (0.85, Fbm3 (q - vec3 (0., 16. * tCur, 0.))) * smoothstep (0.1, 0.2, fr) *\n       smoothstep (0.3, 0.4, fh);\n    d += fCylRad / ns;\n    if (d > dst.y || aSum > 1.) break;\n  }\n  return clamp (aSum, 0., 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nvec4 SnkCol ()\n{\n  vec4 col4;\n  vec2 p, ip;\n  float c, s, sx;\n  sx = sign (hxHit.x);\n  s = sign (2. * mod (hxHit.w, 2.) - 1.);\n  if (hxHit.z < 0.3 * snbRad && hxHit.x < 0.) {\n    col4 = vec4 (0., 0., 1., -1.);\n  } else if (s * sx < 0. && abs (hxHit.y - 0.5 * sx) < 0.03 ||\n     s * sx > 0. && abs (hxHit.y + 0.5 * sx) < 0.03) {\n    col4 = vec4 (1., 0., 0., 0.2);\n  } else {\n    p = 4. * hxHit.xy * vec2 (3. * sqrt3, 3.);\n    ip = PixToHex (p);\n    c = mod (dot (mod (2. * ip + ip.yx, 3.), vec2 (1., 2.)), 3.);\n    col4 = (c == 0.) ? vec4 (0.7, 0.6, 0., 0.2) : ((c == 1.) ? vec4 (0.8, 0.8, 0.4, 0.2) :\n       vec4 (0.4, 0.2, 0., 0.2));\n    col4 *= 0.3 + 0.7 * smoothstep (0.05, 0.07, HexEdgeDist (p - HexToPix (ip)));\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col, foVec;\n  vec2 dstFlm;\n  float dstObj, dstGrnd, tCyc, sLoop, sh, fIntens, f, lDist, grDep;\n  int idObjF;\n  grDep = 0.48;\n  tCyc = 10.;\n  aMin = 0.5;\n  sLoop = aMin + 5. * pow (1. - SmoothBump (0.25, 0.75, 0.24, mod (tCur / tCyc, 1.)), 4.);\n  aLoop = 0.25 * pi / sLoop;\n  dLoop = 7. * 0.25 * pi * sLoop;\n  hLen = 2. * nSeg * dLoop * sin (aLoop);\n  snbRad = 0.25;\n  fCylPos = vec3 (0., 2.53, 0.);\n  fCylRad = 0.8;\n  fCylLen = 2.;\n  dstFlm = CylHit (ro - fCylPos, rd, fCylRad, fCylLen);\n  fIntens = (dstFlm.x < dstFar) ? FlmAmp (ro - fCylPos, rd, dstFlm) : 0.;\n  flmFlkr = Noiseff (tCur * 64.);\n  dstObj = ObjRay (ro, rd);\n  idObjF = idObj;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idBask) {\n      col4 = vec4 (0.4, 0.2, 0., 0.);\n      vn = VaryNf (16. * ro, vn, 2.);\n    } else if (idObj == idEye) {\n      col4 = vec4 (0., 1., 0., -1.);\n    } else if (idObj == idSnk) {\n      col4 = SnkCol ();\n    } else if (idObj == idAltr) {\n      col4 = vec4 (0.1, 0.4, 0.1, 0.2);\n      if (qHit.y < -0.4) col4 = mix (col4, vec4 (0.5, 0., 0., -1.),\n         SmoothBump (0.3, 0.6, 0.05, 0.5 + 0.5 * sin (2. * pi * (4. * qHit.y + 0.5 * tCur))));\n    } else if (idObj == idLogs || idObj == idCoal) {\n       f = clamp (1.2 * Fbm3 ((idObj == idLogs) ? 32. * vec3 (qHit.z,\n          atan (qHit.y, - qHit.x) / (2. * pi), 2. * length (qHit.xy) - 0.03 * tCur) :\n          vec3 (64. * qHit.xz, qHit.y + 0.5 * tCur).xzy) - 0.2, 0.1, 1.);\n       col4.rgb = (idObj == idLogs) ? vec3 (1., 0.7 * f, 0.3 * f * f) * (0.5 +\n          0.5 * max (- dot (rd, VaryNf (4. * qHit, vn, 1.)), 0.)) *\n          (1. - 0.5 * smoothstep (0.5, 0.666, abs (qHit.z))) :\n          f * vec3 (1., 0.2, 0.1) * (1. - 0.5 * pow (length (qHit.xz) / fCylRad, 4.));\n       col4 = vec4 (min (3. * f * col4.rgb * (1. + 0.1 * flmFlkr), 1.), -1.);\n    }\n    if (col4.a >= 0.) {\n      foVec = fCylPos - ro;\n      lDist = length (foVec);\n      foVec /= lDist;\n      sh = ObjSShadow (ro, foVec, lDist);\n      col = col4.rgb * (0.2 + sh * (0.3 + 0.7 * smoothstep (0., 0.05, - dot (rd, vn))) *\n         max (dot (vn, foVec), 0.) * (0.25 + 5. * (0.6 + 0.4 * flmFlkr) *\n         pow (lDist, -1.5) * vec3 (1., 0.3, 0.2)));\n    } else col = col4.rgb * (0.5 + 0.5 * max (- dot (vn, rd), 0.));\n  } else if (rd.y < 0.) {\n    dstGrnd = - (ro.y + grDep) / rd.y;\n    ro += dstGrnd * rd;\n    foVec = fCylPos - ro;\n    lDist = length (foVec);\n    foVec /= lDist;\n    sh = ObjSShadow (ro, foVec, lDist);\n    col = sh * mix (vec3 (0.3, 0.4, 0.3), vec3 (0.4, 0.3, 0.3),\n       smoothstep (0.3, 0.7, Fbm2 (8. * ro.xz))) * pow (lDist, -1.5);\n  } else {\n    col = vec3 (0.03);\n  }\n  if (! (dstObj < dstFar && idObjF == idAltr || dstObj < dstFlm.x))\n     col = mix (col, mix (vec3 (1., 0.2, 0.2), vec3 (0.8, 0.6, 0.2),\n        smoothstep (0.5, 0.8, fIntens)), fIntens);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = -0.1 * pi;\n  az = 0.25 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n  } else {\n    az += 0.3 * pi * sin (0.02 * 2. * pi * tCur);\n    el -= 0.3 * (az - 0.25 * pi) * (az - 0.25 * pi);\n  }\n  zmFac = 4.;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1., -16.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyGRD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1035, 1035, 1071, 1071, 2055], [2057, 2057, 2079, 2079, 3580], [3582, 3582, 3615, 3615, 3813], [3815, 3815, 3836, 3836, 4033], [4035, 4035, 4086, 4086, 4332], [4334, 4334, 4393, 4393, 5300], [5302, 5302, 5345, 5345, 6116], [6118, 6118, 6142, 6142, 6372], [6374, 6374, 6398, 6398, 6458], [6460, 6460, 6488, 6488, 6568], [6570, 6570, 6586, 6586, 7307], [7309, 7309, 7344, 7344, 10234], [10236, 10236, 10289, 10289, 11345], [11347, 11347, 11380, 11380, 11407], [11409, 11409, 11451, 11451, 11502], [11504, 11504, 11561, 11561, 11725], [11727, 11727, 11763, 11763, 11969], [11971, 11971, 12001, 12001, 12114], [12116, 12116, 12147, 12147, 12211], [12213, 12213, 12270, 12270, 12353], [12387, 12387, 12411, 12411, 12464], [12466, 12466, 12490, 12490, 12620], [12622, 12622, 12646, 12646, 12866], [12868, 12868, 12893, 12893, 13039], [13041, 13041, 13066, 13066, 13252], [13254, 13254, 13279, 13279, 13504], [13506, 13506, 13527, 13527, 13682], [13684, 13684, 13705, 13705, 13860], [13862, 13862, 13891, 13891, 14103], [14105, 14105, 14144, 14144, 14329]], "test": "untested"}
{"id": "wtGGRD", "name": "Particles (SK)", "author": "shackle", "description": "Use your mouse to control the track of particles. ", "tags": ["mouse", "particle", "swarm"], "likes": 6, "viewed": 480, "published": 3, "date": "1578382853", "time_retrieved": "2024-07-30T21:31:19.965802", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0,uv).xyz,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.141592654\n\nuint GetIndex(vec2 fragCoord)\n{\n    return uint(fragCoord.y * iResolution.x + fragCoord.x);\n}\nvec2 Rot(vec2 v, float angle)\n{\n    return vec2(v.x * cos(angle) + v.y * sin(angle),\n        v.y * cos(angle) - v.x * sin(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uint index = GetIndex(fragCoord-0.5);\n    if (index > 1000U) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    if (iFrame < 2) {\n        //float y = RadicalInverse(3U, index);\n        vec2 p = vec2(0.0,0.5);\n        fragColor = vec4(p, normalize((0.5-p)));\n        return;\n    }\n\n    vec4 data = texture(iChannel0, uv);\n    vec2 pos = data.xy;\n    vec2 dir = data.zw;\n\n    pos = pos + dir * 0.003;\n    dir = Rot(dir, 0.003 * length(dir) * cos(0.1399 * float(index)));\n\n    if (pos.x < 0.0 || pos.x > 1.0) {\n        pos.x = fract(2.0 - pos.x);\n        dir.x = -dir.x;\n    }\n    if (pos.y < 0.0 || pos.y > 1.0) {\n        pos.y = fract(2.0 - pos.y);\n        dir.y = -dir.y;\n    }\n    if (iMouse.w > 0.1) {\n        vec2 pd = iMouse.xy / iResolution.xy - pos;\n        vec2 fa = cos(length(pd)) * normalize(pd);\n        dir += 0.03 * fa;\n    } else {\n        float kt=iTime*1.0;\n        vec2 pd = 0.5+0.3*vec2(cos(kt),sin(kt)) - pos;\n        vec2 fa = cos(length(pd)) * normalize(pd);\n        dir += 0.01 * fa*(1.0+sin(kt*0.3-PI));\n    }\n\n    if (length(dir) > 1.0) {\n        dir *= 0.99;\n    }else\n    {\n        dir*=1.01;\n    }\n    fragColor = vec4(pos, dir);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec2 GetUV(uint index)\n{\n    float y=floor(float(index)/iResolution.x);\n    float x=float(index)-y*iResolution.x;\n    return vec2(x,y)/iResolution.xy;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n\n    vec2 coord=uv*2.0-1.0;\n    coord.x*=iResolution.x/iResolution.y;\n    vec2 w=1.0/iResolution.xy;\n\n    vec3 f=vec3(0.0);\n    for(uint i=0U;i<500U;i++)\n    {\n        vec4 data=texture(iChannel0,GetUV(i));\n        vec2 pos=data.xy;\n        vec2 dir=data.zw;\n        vec2 pos2=pos+dir*0.003;\n        float fi=float(i);\n        vec3 color=abs(vec3(sin(fi),cos(0.7+2.0*fi),cos(2.7+3.0*fi)));\n        f=max(f,color*smoothstep(0.01,0.0,distance(uv,pos)+distance(uv,pos2)-0.003*length(dir)));\n    }\n    vec4 preColor=texture(iChannel1,uv);\n    fragColor=mix(preColor,5.0*vec4(vec3(f),1.0),0.05);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 229]], "test": "untested"}
{"id": "3lGGRz", "name": "[♪]Yokohama 2020", "author": "Catzpaw", "description": "\"Yokohama 2020\"\ncomposed by Catzpaw 2020", "tags": ["raymarching", "music"], "likes": 32, "viewed": 1109, "published": 3, "date": "1578371729", "time_retrieved": "2024-07-30T21:31:20.977098", "image_code": "//---Yokohama 2020\n// by Catzpaw 2020\n\n#define LINES 288.\n#define ITER 6\n#define DIF 0.002\n#define GAP 0.007\n\nvec3 gettex(vec2 p,float o){\n    vec3 t=texture(iChannel0,p+vec2(o,0)).rgb;\n    t+=hash(p+fract(iTime))*.2-.1;\n    return clamp(t,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv=fragCoord/iResolution.xy;\n    float sl=clamp(abs(sin(fract(uv.y*LINES)*3.14)*1.1),0.,1.);\n    uv.y=floor(uv.y*LINES)/LINES;\n    vec3 tx,yc,rgb=vec3(0);\n    float o=-DIF*float(ITER)/2.;\n    o+=sin(uv.y-iTime)>.999?sin(hash(uv.yy)*.04-.02):0.;\n    for(int i=ZERO;i<ITER;i++){\n\t    tx=gettex(uv,o);yc.x=tx.r*.257+tx.g*.504+tx.b*.098+.0625;\n\t    tx=gettex(uv,o+GAP);yc.y=-tx.r*.148-tx.g*.291+tx.b*.439+.5;\n\t    tx=gettex(uv,o-GAP);yc.z=tx.r*.439-tx.g*.368-tx.b*.071+.5;\n        yc.x+=sin(iTime*40.+uv.y*300.)*.03;\n\t    rgb+=vec3((yc.x-.0625)*1.164+(yc.z-.5)*1.596,\n                (yc.x-.0625)*1.164-(yc.y-.5)*.391-(yc.z-.5)*.813,\n                (yc.x-.0625)*1.164+(yc.y-.5)*2.018);\n        o+=DIF;\n    }\n    rgb/=float(ITER);\n    fragColor = vec4(rgb*sl,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//---Yokohama 2020\n// by Catzpaw 2020\n\n#define ITER 96\n#define EPS 1e-3\n#define NEAR 1.\n#define FAR 100.\n\nconst vec2 e=vec2(EPS,-EPS);\nvec3 h=vec3(.42);\nfloat map(in vec3 p){\n    p.xz=mod(p.xz,1.)-.5;p=abs(p)-h;\n    return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.)-.05;\n}\nfloat trace(in vec3 ro,in vec3 rd,out float c,out vec3 n){\n    float t=NEAR,d;\n    vec3 p;\n\tfor(int i=ZERO;i<ITER;i++){\n        p=ro+rd*t;h.y=fbm(p.xz)*3.;d=map(p);\n        if(abs(d)<EPS||t>FAR)break;\n        t+=step(d,.7)*d+d*.1;c+=1.;\n    }\n\tn=normalize(e.xxx*map(p+e.xxx)+e.xyy*map(p+e.xyy)+e.yxy*map(p+e.yxy)+e.yyx*map(p+e.yyx));\n    float w=(p.y<h.y-.2)&&(mod(p.y*4.,hash(floor(p.xz))*.5+.5)<hash(h.yy))?.7:1.;\n    n*=w;\n    c*=(w<1.)&&(hash(floor((p.xz)*12.))>.2)?.3:1.;\n\treturn min(t,FAR);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec3 n,ro=vec3(0,15,30),rd=vec3(uv,.8),ld=normalize(vec3(0.4,0.2,0.6));\n    ro.xz*=rot(iTime*.2);\n    rd.yz*=rot(-.4+sin(iTime*.25)*.3);\n    rd.xy*=rot(sin(iTime*.14)*.3);\n    rd.xz*=rot(iTime*.23);\n\tfloat c=0.,v=trace(ro,rd,c,n),s=pow(clamp(dot(n,ld),0.,1.),2.);\n    s+=pow(clamp(dot(normalize(rd),ld),0.,1.),5.);\n\tfragColor=vec4(vec3(v/float(FAR),s,s+c/float(ITER)),1);\n}", "buffer_a_inputs": [], "common_code": "//---Yokohama 2020\n// by Catzpaw 2020\n\n#define ZERO min(0,iFrame)\n\nfloat hash(vec2 n){return fract(sin(dot(n,vec2(17.1,3.13)))*41414.1);}\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nfloat fbm(vec2 p){return hash(floor(p*.0625))+hash(floor(p*.25))+hash(floor(p*.5))+hash(floor(p))*2.;}\n", "sound_code": "//MUSIC:\n//\"Yokohama 2020\"\n//composed by Catzpaw 2020\n\n//---Music Renderer https://www.shadertoy.com/view/tttGzB\n// by Catzpaw 2019\n\n//SETUP\nconst float base =432.;\t//A tuning (Hz)\nconst float bpm  =96.;\t//beats per minute\nconst float steps=480.;\t//block length\nconst float start=2.;   //start count (beats)\n\n//STATE\nfloat gtime=0.;\t//time\nint   gchord=0;\t//chord\nfloat garp=0.;\t//arpeggio pattern\nfloat gdyn=1.;\t//dynamics\n\n//RANDOM ARP PATTERN GENERATOR\nfloat hash(float s){s=fract(s*.13);s*=s+33.33;return fract(s+s*s);}\nfloat pgen(float s,float r){\n    int p=0;\n    for(int i=0;i<16;i+=2){p+=int(hash(s)*r)<<i;s+=1.;}\n    return float(p);\n}\n\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){\n    vec2 v=pow(abs(i*p.x),vec2(1./p.y));\n    return clamp(sign(i)*v,-1.,1.)*p.z;\n}\n\n//CHORD\n//  global int gchord ...hex tetrad chord pattern\nfloat chord(float n){ // n:place in gchord (0-3)\n    float c=0.;\n    if(n>2.)c+=float((gchord>>8)&15);\n    if(n>1.)c+=float((gchord>>4)&15);\n    if(n>0.)c+=float(gchord&15);\n    return c; // return:relative note number to add to root note\n}\n\n//ARPEGGIATOR\n//  vec3 p( pattern, step_length, pattern_steps)\n//    arp_gate :p.pattern ...1bit pattern 1-16 steps 0:off 1:on\n//    arp_chord:p.pattern ...2bit pattern 1-8 steps 0-3:note\nfloat arp_gate(float t,vec3 p){\n    float l=15.*p.y/bpm;\n    float g=float((int(p.x)>>int(mod(t/l,p.z)))&1);\n    return (g>0.)?mod(t,l):-1.; // return:gate time or note off (-1)\n}\nfloat arp_chord(float t,vec3 p){\n    return chord(float((int(p.x)>>int(floor(mod(t/(15.*p.y/bpm),p.z))*2.))&3));\n}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\n//single note\nfloat freq(float n){\n    return pow(2.,(n-69.)/12.)*base*6.283;\n}\n//with tetrad chord\nvec4 freq4(float n){\n    vec4 r;\n    r.x=freq(n);\n    r.y=gchord>0?freq(n+chord(1.)):0.;\n    r.z=gchord>16?freq(n+chord(2.)):0.;\n    r.w=gchord>256?freq(n+chord(3.)):0.;\n    return r;\n}\n\n//SOUND GENERATORS\n//  sequence => note pattern => instrument => oscillator\n\n//OSC\nfloat osc_saw(float x,float v){return clamp(mod(x/6.283,1.)*2.-1.,-1.,1.)*v;}\nfloat osc_sin(float x,float v){return clamp(sin(x)*v,-1.,1.);}\nfloat osc_sqr(float x,float v){return clamp(sign(sin(x))*v,-1.,1.);}\nfloat osc_noise(float x,float v){x=floor(x*1e3/v)*1e-3;return fract(sin(x*1717.17)*1313.13)*2.-1.;}\nfloat osc_metal(float x,float v){return fract(sin(x*v*171.17)*313.13)*2.-1.;}\n\n//ENVELOPE\nconst vec4 env0=vec4(0.00,.2,0.60,1.50); //piano\nconst vec4 env1=vec4(0.10,.4,0.50,0.50); //woodwind\nconst vec4 env2=vec4(0.20,.6,0.50,0.50); //string\nconst vec4 env3=vec4(0.00,.2,0.90,1.50); //synth\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\nfloat env_ad(float x,float a,float d){return min(x/max(a,1e-4),max(0.,1.-(x-a)/max(d,1e-4)));}\nfloat env_adsr(float x,vec4 e,float g){return max(0.,min(1.,x/max(e.x,1e-4))-min(1.-e.z,max(x-e.x,0.)*(1.-e.z)/max(e.y,1e-4))-max(x-g,0.)*e.z/max(e.w,1e-4));}\n\n//PERCUSSION INSTRUMENTS (time)\nfloat bass_drum(float x){return osc_sin(x*freq(46./(1.+x*2.)),8.*env_d(x,.07));}\nfloat snare_drum(float x){float f=freq(52./(1.+x*.02))*x;return (osc_noise(x,.05)*env_d(x,.3)*.5+osc_sin(f+osc_sin(f*1.92,.3),5.))*max(env_d(x,.1),env_d(x,.3)*.7);}\nfloat hihat(float x,float d){return osc_metal(x,3.5)*env_d(x,d);}\n\n//MELODIC INSTRUMENTS (freq)\n//float vibe(float f){return osc_sin(f+osc_sin(f*8.+osc_sin(f*.02,1.),.3),1.5);}\n//float harpsi(float f){return osc_saw(f*4.+osc_sin(f*18.,.4),1.3);}\n//float organ(float f){return osc_sin(f,1.3)+osc_sin(f*.5,1.)+osc_sin(f*2.,1.)+osc_sin(f*4.,.5);}\n//float reed(float f){return osc_sin(f,1.)*osc_sqr(f*3.,1.);}\nfloat sawlead(float f){return osc_saw(f,1.)+osc_saw(f*2.01,1.);}\n//float sqrlead(float f){return osc_sqr(f,.7)+osc_sqr(f*2.01,.7);}\n//float synlead(float f){return osc_saw(f,1.)*osc_sqr(f*3.02,1.);}\n\n//MELODIC INSTRUMENTS (freq,time)\n//float piano(float f,float x){return osc_sin(f+osc_sin(f,env_d(x,.5))+osc_sin(f*3.,env_d(x,2.)*.8),1.);}\nfloat epiano(float f,float x){return osc_sin(f+osc_sin(f*15.,.04)+osc_sin(f*.99,.4),1.);}\nfloat bass(float f,float x){return osc_sin(f*.5+osc_sin(f*4.5,env_d(x,.1)*.5)+osc_sin(f*1.5,env_ad(x,.1,.2)*.3),2.)*env_d(x,.6);}\n//float bell(float f,float x){return osc_sin(f+osc_sin(f*3.4,env_d(x,1.)*.2)+osc_sin(f*4.,.5),1.);}\n//float guitar(float f,float x){return osc_sin(f+osc_sin(f*8.,env_d(x,.05)*.3)+osc_sin(f*5.,env_ad(x,.03,5.)*.3),2.);}\n\n//NOTE OPERATORS\n//float bup(float x){return min(x*(bpm/30.)-1.,0.);}\n//float bdwn(float x){return max(1.-x*(bpm/30.),0.);}\n//float pral(float x){float y=20./bpm;return ((x>y/2.)&&(x<y))?2.:0.;}\n//float mord(float x){float y=20./bpm;return ((x>y/2.)&&(x<y))?-2.:0.;}\n//float tril(float x){return sign(sin(3.14+x*bpm*6.28/15.))+1.;}\n\n//NOTE PATTERNS\n//P( note length, num of notes) ...pattern init\n//T( position)                  ...set trigger (for percussion)\n//N( position, note)            ...set note (for melody)\n//NU( position, note)           ...set note with bend up\n//ND( position, note)           ...set note with bend down\n//NP( position, note)           ...set note with pral triller\n//NM( position, note)           ...set note with mordent\n//NT( position, note)           ...set note with trill\n//X( position, macro)           ...execute macro (CHORD_mM7 etc.)\n//X( position, code)            ...execute code (gchord=0x333; etc.)\n#define P(l,s) float x=1e3,y=15.*float(l)/bpm,z=0.,v=mod(t,y*float(s));\n#define T(s) if(v>float(s)*y){x=v-float(s)*y;}\n#define N(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n);}\n/*\n#define NU(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+bup(x);}\n#define ND(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+bdwn(x);}\n#define NP(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+pral(x);}\n#define NM(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+mord(x);}\n#define NT(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+tril(x);}\n*/\n#define X(s,n) if(v>float(s)*y){x=v-float(s)*y;n;}\n\n#define R -1e3\n#define C  60.\n#define Cs 61.\n#define Db 61.\n#define D  62.\n#define Ds 63.\n#define Eb 63.\n#define E  64.\n#define F  65.\n#define Fs 66.\n#define Gb 66.\n#define G  67.\n#define Gs 68.\n#define Ab 68.\n#define A  69.\n#define As 70.\n#define Bb 70.\n#define B  71.\n#define HI  12.+\n#define LO -12.+\n\n/*\n#define CHORD_3        gchord=0x484;\n#define CHORD_4        gchord=0x575;\n#define CHORD_5        gchord=0x757;\n#define CHORD_M        gchord=0x534;\n#define CHORD_on3      gchord=0x453;\n#define CHORD_on5      gchord=0x345;\n#define CHORD_sus4     gchord=0x525;\n*/\n#define CHORD_sus4on4  gchord=0x552;\n/*\n#define CHORD_sus4on5  gchord=0x255;\n#define CHORD_7        gchord=0x334;\n#define CHORD_7sus4    gchord=0x325;\n#define CHORD_7alt     gchord=0x424;\n#define CHORD_M7       gchord=0x434;\n#define CHORD_M7sus4   gchord=0x425;\n#define CHORD_m        gchord=0x543;\n#define CHORD_mon3     gchord=0x354;\n#define CHORD_mon5     gchord=0x435;\n#define CHORD_m7       gchord=0x343;\n#define CHORD_mM7      gchord=0x443;\n#define CHORD_add9     gchord=0x734;\n#define CHORD_madd9    gchord=0x743;\n#define CHORD_add9on5  gchord=0x552;\n*/\n\n#define DYN_ff gdyn=1.0;\n#define DYN_f  gdyn=0.9;\n#define DYN_mf gdyn=0.8;\n#define DYN_mp gdyn=0.7;\n#define DYN_p  gdyn=0.6;\n#define DYN_pp gdyn=0.5;\n\n/*\n#define ARP4_up 58596.\n#define ARP4_down 6939.\n#define ARP4_updown 18148.\n#define ARP4_downup 47387.\n#define ARP4_p1 18118.\n#define ARP4_p2 4656.\n\n#define ARP3_up 18724.\n#define ARP3_down 24966.\n#define ARP3_updown 25700.\n#define ARP3_downup 17990.\n#define ARP3_p1 4486.\n#define ARP3_p2 8480.\n*/\n\n//NOTE PATTERNS:percussion\nvec2 bd(float t,float p){\n    float g=arp_gate(t,vec3(p,1.,16.));\n    return g<0.?vec2(0):amp(vec2(.6*bass_drum(g*1.05),.6*bass_drum(g*.95)),vec3(1,2.2,1));\n}\nvec2 sd(float t,float p){\n    float g=arp_gate(t,vec3(p,1.,16.));\n    return g<0.?vec2(0):vec2(.6*snare_drum(g*.995),.6*snare_drum(g*1.005));\n}\nvec2 hh(float t,float p1,float p2){\n    float g=arp_gate(t,vec3(p1,1.,16.));\n    vec2 r=g<0.?vec2(0):vec2(.2)*hihat(g,.08);\n    g=arp_gate(t,vec3(p2,2.,8.));r+=g<0.?vec2(0):vec2(.15)*hihat(g,.3);\n    return r;\n}\n\n//NOTE PATTERNS:epiano\nvec2 ep(float x,float n){\n    //epiano single note\n\tfloat f=freq(n)*x;\n    return vec2(epiano(f*.995,x),epiano(f*1.005,x))*env_adsr(x,env0,.1)*gdyn;\n}\nvec2 epc(float x,float n){\n    //epiano triad chord\n\tvec4 fl=freq4(n)*x,fr=fl*.995;fl*=1.005;\n    return vec2(\n        (epiano(fl.x,x)+epiano(fl.y,x)+epiano(fl.z,x)),\n        (epiano(fr.x,x)+epiano(fr.y,x)+epiano(fr.z,x)))*env_adsr(x,env0,.1)*gdyn;\n}\nvec2 ep0(float t,float o){\n    //section:A1(triad)\n    P(1,32)\n    N(0,HI Ds) N(1,R)\n    N(3,As)    N(4,R)\n    N(6,HI Cs) N(7,R)\n    N(9,Gs)    N(10,R)\n    N(12,B)    N(13,R)\n    N(15,B)    N(16,R)\n    N(17,B)    N(30,R)\n    return z<0.?vec2(0):epc(x,z+o)*.3;\n}\nvec2 ep1(float t,float o){\n    //section:A2(triad)\n    P(1,32)\n    N(0,HI Ds)  N(1,R)\n    N(3,As)     N(4,R)\n    N(6,HI Cs)  N(7,R)\n    N(9,Gs)     N(10,R)\n    N(12,B)     N(13,R)\n    N(15,HI Cs) N(16,R)\n    N(17,HI Cs) N(30,R)\n    return z<0.?vec2(0):epc(x,z+o)*.3;\n}\nvec2 ep2(float t,float o){\n    //section:B1-1/B2-1\n    P(1,32)\n    N(0,HI Cs)\n    N(8,HI Cs)\n    N(11,HI Ds)\n    N(14,HI Cs)\n    N(16,HI C)\n    N(22,Gs)\n    return z<0.?vec2(0):ep(x,z+o)*.3;\n}\nvec2 ep3(float t,float o){\n    //section:B1-2/B2-2/B3-2\n    P(1,16)\n    N(1,HI F) N(9,R)\n    return z<0.?vec2(0):ep(x,z+o)*.3;\n}\nvec2 ep4(float t,float o){\n    //section:B1-3/B2-3/B3-3\n    P(1,16)\n    N(2,HI Gs) N(10,R)\n    return z<0.?vec2(0):ep(x,z+o)*.3;\n}\nvec2 ep5(float t,float o){\n    //section:B3-1\n    P(1,32)\n    N(0,A)\n    N(8,As)\n    N(11,HI C)\n    N(14,As)\n    N(16,A)\n    N(22,F)\n    return z<0.?vec2(0):ep(x,z+o)*.3;\n}\nvec2 ep6(float t,float o){\n    //section:B4(triad)\n    P(1,32)\n    X(0,gchord=0x642)\n    N(0,Gs) N(1,Gs) N(2,R)\n    N(9,Gs) N(10,R) N(11,Gs) N(12,R)\n    X(18,CHORD_sus4on4)\n    N(18,Gs) N(19,R) N(21,Gs) N(22,R)\n    X(23,gchord=0x642)\n    N(23,Gs) N(31,R)\n    return z<0.?vec2(0):epc(x,z+o)*.3;\n}\n\n//NOTE PATTERNS:bass\nvec2 bs(float x,float n){\n    float f=freq(n-12.)*x;\n    return amp(vec2(bass(f+1.005,x),bass(f*.995,x)),vec3(gdyn,1.8,0.6));\n}\nvec2 bs0(float t,float o){\n    //section:A1a/A2a\n    P(1,16)\n    N(0,F)     N(1,R)\n    N(2,As)\n    N(3,C)\n    N(4,F)\n    N(5,LO As) N(6,R)\n    N(7,Ds)    N(8,R)\n    N(9,LO As)\n    N(10,Ds)\n    N(11,LO Gs)\n    N(12,Fs)\n    N(13,LO B) N(14,R)\n    N(15,Cs)\n    return z<0.?vec2(0):bs(x,z+o);\n}\nvec2 bs1(float t,float o){\n    //section:A1b/A2b\n    P(1,16)\n    N(0,Cs)   N(1,R)\n    N(2,Fs)\n    N(3,LO B)\n    N(4,Cs)\n    N(5,LO B) N(6,R)\n    N(7,Fs)   N(8,R)\n    N(9,Fs)\n    N(10,Cs)\n    N(11,LO B)\n    N(12,Fs)\n    N(13,Cs)  N(14,R)\n    N(15,LO B)\n    return z<0.?vec2(0):bs(x,z+o);\n}\nvec2 bs2(float t,float o){\n    //section:B1-B3(arp3)\n    P(1,8)\n    N(0,0)\n    z=arp_chord(x,vec3(7224.,1.,8.));\n    x=arp_gate(x,vec3(239.,1.,8.));\n    return x<0.?vec2(0):bs(x,z+o);\n}\nvec2 bs3(float t,float o){\n    //section:B4\n    P(1,16)\n    N(0,LO Gs)  N(1,R)\n    N(2,LO Gs)\n    N(3,LO As)\n    N(8,LO Gs)\n    N(11,LO As) N(17,R)\n    N(18,LO Gs) N(19,R)\n    N(21,LO Gs) N(22,R)\n    N(23,LO As) N(31,R)\n    return z<0.?vec2(0):bs(x,z+o);\n}\n\n//NOTE PATTERNS:synth lead(unison)\nvec2 ld(float x,float n){\n\tfloat fl=freq(n)*x,fr=fl*.995;fl*=1.005;\n    return vec2(sawlead(fl)+sawlead(fl*2.),sawlead(fr)+sawlead(fr*2.))*env_adsr(x,env0,1.)*gdyn;     \n}\nvec2 ld0(float t,float o){\n    P(1,32)\n    N(0,LO As) N(2,R)\n    N(4,C)\n    N(8,Ds)    N(10,R)\n    N(12,Cs)\n    N(22,LO B) N(28,R)\n    N(30,LO F)\n    N(31,LO Gs)    \n    return z<0.?vec2(0):ld(x,z+o)*.2;\n}\nvec2 ld1(float t,float o){\n    P(1,32)\n    N(0,LO As) N(2,R)\n    N(4,C)\n    N(8,Ds)    N(10,R)\n    N(12,Cs)\n    N(22,Ds)   N(28,R)\n    N(30,LO F)\n    N(31,LO Gs)    \n    return z<0.?vec2(0):ld(x,z+o)*.2;\n}\nvec2 ld2(float t,float o){\n    P(1,32)\n    N(0,Cs)\n    N(3,Ds)\n    N(6,F) N(15,R)\n    N(16,Gs)\n    N(19,F)\n    N(22,Ds)\n    N(24,C) N(31,R)\n    return z<0.?vec2(0):ld(x,z+o)*.2;\n}\nvec2 ld3(float t,float o){\n    P(1,32)\n    N(0,LO Gs)\n    N(3,LO B)\n    N(6,Cs) N(15,R)\n    N(16,Fs)\n    N(19,E)\n    N(22,Cs)\n    N(24,LO As) N(31,R)\n    return z<0.?vec2(0):ld(x,z+o)*.2;\n}\nvec2 ld4(float t,float o){\n    P(1,32)\n    N(0,LO A)\n    N(3,C)\n    N(6,Ds) N(15,R)\n    N(16,F)\n    N(19,Ds)\n    N(22,C)\n    N(24,LO A)\n    N(28,LO F)\n    return z<0.?vec2(0):ld(x,z+o)*.2;\n}\nvec2 ld5(float t,float o){\n    P(1,32)\n    N(0,LO Gs) N(3,R)\n    N(6,LO Gs) N(9,R)\n    N(12,LO Gs) N(15,R)\n    N(18,LO As) N(19,R)\n    N(21,Ds) N(22,R)\n    N(23,D) N(31,R)\n    return z<0.?vec2(0):ld(x,z+o)*.2;\n}\n\n//SEQUENCE\n#define TRACK t=time;v=vec2(0);\n#define   SEGNO(block,blocks)        if(t>float(block)*l){t=mod(t-float(block)*l,float(blocks)*l);\n#define     REP(block,blocks,repend) if((t>float(block)*l)&&(t<=float(block)*l+float(repend)*l)){t=mod(t-float(block)*l,float(blocks)*l);\n#define       SEQ(block,patterns)    if(t>float(block)*l){v=patterns;v*=d;}\n#define     NEXT                     }\n#define   DS                         }\n#define END                          o+=v;\nvoid sequence(float time,float l,float d,inout vec2 o){vec2 v=vec2(0);float t=time;\n\n    DYN_mf\n\n    TRACK //1 rhythm hh+bd\n      SEGNO(0,16)\n        SEQ(0.0,hh(t,4947.,0.))\n        SEQ(1.0,hh(t,4947.,18440.))\n        SEQ(1.5,hh(t,4947.,18440.)+bd(t,43305.))\n      DS\n    END\n\n    TRACK //2 rhythm sd\n      SEGNO(0,16)\n        REP(0,4,4)\n          SEQ(1.5,sd(t,61456.))\n          SEQ(2.0,sd(t,4112.))\n          SEQ(3.5,sd(t,36880.))\n        NEXT\n        REP(4,2,8)\n          SEQ(0.0,sd(t,4112.))\n          SEQ(1.5,sd(t,61456.))\n        NEXT\n        REP(8,4,16)\n          SEQ(0.0,sd(t,4112.))\n          SEQ(1.5,sd(t,36880.))\n          SEQ(2.0,sd(t,4112.))\n          SEQ(3.5,sd(t,61456.))\n        NEXT\n      DS\n    END\n\n    TRACK //3 epiano\n      DYN_mf\n      SEGNO(0,16)\n        REP(0,2,12)\n          CHORD_sus4on4\n          SEQ(0,ep0(t,0.))\n          SEQ(1,ep1(t,0.))\n        NEXT\n        REP(12,4,16)\n          SEQ(0.0,ep2(t, 0.)+ep3(t, 0.)+ep4(t, 0.))\n          SEQ(1.0,ep2(t,-2.)+ep3(t,-1.)+ep4(t, 0.))\n          SEQ(1.5,ep2(t,-2.)+ep3(t,-4.)+ep4(t,-2.))\n          SEQ(2.0,ep5(t, 0.)+ep3(t,-5.)+ep4(t,-3.))\n          SEQ(3.0,ep6(t, 0.))\n        NEXT\n      DS\n    END\n\n    TRACK //4 bass\n      DYN_mf\n      SEGNO(0,16)\n        REP(1,2,11)\n          SEQ(0.0,bs0(t,0.))\n          SEQ(0.5,bs1(t,2.))\n          SEQ(1.0,bs0(t,0.))\n          SEQ(1.5,bs1(t,0.))\n        NEXT\n        REP(12,4,16)\n          gchord=0x322;\n          SEQ(0.0,bs2(t,Cs))\n          gchord=0x323;\n          SEQ(0.5,bs2(t,C))\n          gchord=0x432;\n          SEQ(1.0,bs2(t,LO B))\n          gchord=0x503;\n          SEQ(1.5,bs2(t,LO As))\n          SEQ(2.0,bs2(t,LO A))\n          SEQ(3.0,bs3(t,0.))\n        NEXT\n      DS\n    END\n\n    TRACK //5 synth lead\n      DYN_mp\n      SEGNO(0,16)\n        REP(0,6,12)\n          REP(2,2,6)\n            SEQ(0,ld0(t,0.))\n            SEQ(1,ld1(t,0.))\n          NEXT\n        NEXT\n        REP(12,4,16)\n          SEQ(0,ld2(t,0.))\n          SEQ(1,ld3(t,0.))\n          SEQ(2,ld4(t,0.))\n          SEQ(3,ld5(t,0.))\n        NEXT\n      DS\n    END\n}\n\n//MASTER SECTION\n#define MASTER_DRIVE    0.4\n#define MASTER_PRESSURE 1.1\n#define DELAY_REPEAT    4\n#define DELAY_WET       0.15\n#define DELAY_FEEDBACK  0.85\n#define DELAY_TIME      0.05\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;vec2 o=vec2(0),v=vec2(0);\n    if(time>170.){vol=(180.-min(time,180.))/10.;}\n    time-=start*60./bpm;if(time<0.)return o;\n    gtime=time;\n    sequence(time,l,1.,o);\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;gtime-=r;\n        sequence(time,l,d,o);\n        d*=DELAY_FEEDBACK;\n        r+=DELAY_TIME;\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGGRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 138, 138, 249], [251, 251, 307, 307, 1077]], "test": "untested"}
{"id": "WtG3RD", "name": "The ring [color remix]", "author": "avin", "description": "Color version of https://www.shadertoy.com/view/wtV3R1", "tags": ["circle", "shine"], "likes": 56, "viewed": 2898, "published": 3, "date": "1578348087", "time_retrieved": "2024-07-30T21:31:21.723103", "image_code": "#define TAU 6.2831852\n#define MOD3 vec3(.1031,.11369,.13787)\n#define BLACK_COL vec3(16,21,25)/255.\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n        \n    float a = sin(atan(uv.y, uv.x));\n    float am = abs(a-.5)/4.;\n    float l = length(uv);                         \n    \n    float m1 = clamp(.1/smoothstep(.0, 1.75, l), 0., 1.);\n    float m2 = clamp(.1/smoothstep(.42, 0., l), 0., 1.);\n    float s1 = (simplex_noise(vec3(uv*2., 1. + iTime*.525))*(max(1.0 - l*1.75, 0.)) + .9);\n    float s2 = (simplex_noise(vec3(uv*1., 15. + iTime*.525))*(max(.0 + l*1., .025)) + 1.25);\n    float s3 = (simplex_noise(vec3(vec2(am, am*100. + iTime*3.)*.15, 30. + iTime*.525))*(max(.0 + l*1., .25)) + 1.5);\n    s3 *= smoothstep(0.0, .3345, l);    \n    \n    float sh = smoothstep(0.15, .35, l);\n    \n    \n    float m = m1*m1*m2 * ((s1*s2*s3) * (1.-l)) * sh;\n    //m = clamp(m, 0., 1.);\n    \n    vec3 col = mix(BLACK_COL, (0.5 + 0.5*cos(iTime+uv.xyx*3.+vec3(0,2,4))), m);\n            \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtG3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 274], [276, 276, 305, 305, 969], [971, 971, 1028, 1028, 1948]], "test": "untested"}
{"id": "wlyGRh", "name": "42PRINT", "author": "zikbakguru", "description": "Yet another 10print stuff..\nWith all those fancy light maths and bitmap rendering.\n(Best enjoyed with Earthbound music)", "tags": ["10print"], "likes": 7, "viewed": 501, "published": 3, "date": "1578344200", "time_retrieved": "2024-07-30T21:31:22.679546", "image_code": "#define HEXRGB(hex) vec3(float((hex & 0xff0000) >> 16) / 255.0, float((hex & 0x00ff00) >> 8) / 255.0, float(hex & 0x0000ff) / 255.0)\n\n// Declare sprite data\nconst int[] sprHead =\n    int[](\n        0xF9, 0xFF, 0xFF, 0xBF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0x3F, 0xF0, \n        0xF, 0xFC, 0xFF, 0xF3, \n        0xFF, 0xFC, 0xD7, 0xF3, \n        0xFF, 0xFC, 0xFF, 0xFF, \n        0xFF, 0xF, 0x0, 0xF8, \n        0xFF, 0x7F, 0x0, 0xFC, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFD, 0xFF, 0xFF, 0xBF, \n        0x0, 0x0, 0x0, 0x0\n    );\n\nconst int[] sprBody1 =\n    int[]\n    (\n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x15, 0xAA, 0x4A, 0x55, \n        0xA5, 0xAA, 0x6A, 0x55, \n        0xA1, 0xA8, 0x2A, 0x55, \n        0x28, 0xA8, 0x2A, 0x55, \n        0x68, 0xA8, 0x2A, 0x7E, \n        0x7F, 0xA8, 0x2A, 0x6E, \n        0x6F, 0xA9, 0x2A, 0x40, \n        0x40, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55\n    );\n\nconst int[] sprBody2 =\n    int[]\n    (\n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xAB, 0xEA, 0xFF, \n        0xFF, 0x54, 0x15, 0xFF, \n        0x7F, 0x55, 0x55, 0xFC, \n        0x4F, 0x1, 0x40, 0xFD, \n        0x4F, 0xFC, 0xF, 0xF5, \n        0xF, 0xFC, 0x3F, 0xC0, \n        0x57, 0xFC, 0x3F, 0x50\n    );\n\nfloat sampleSpriteHead (vec2 uv)\n{\n    vec2 fracuv = fract(uv);\n    int x = int(fracuv.x * 16.0);\n    int y = int(fracuv.y * 16.0);\n    \n    // 16 idx data per row, 1 element & 4 index per 1 element...\n    // => 4 element per row\n    int indexperelement = 4;\n    int elementperrow = 4;\n    int bitsperindex = 2;\n    int arrayidx = y * elementperrow + x / indexperelement;\n    int idx = x % indexperelement;\n    int bitoffset = (idx) * bitsperindex;\n    int mask = 3 << bitoffset;\n    int bits = (sprHead[arrayidx] & mask) >> bitoffset; // test\n\n    float value = float(bits) / 3.0;\n    return (value);\n}\n\nfloat sampleSpriteBody1 (vec2 uv)\n{\n    vec2 fracuv = fract(uv);\n    int x = int(fracuv.x * 16.0);\n    int y = int(fracuv.y * 20.0);\n    \n    // 16 idx data per row, 1 element & 4 index per 1 element...\n    // => 4 element per row\n    int indexperelement = 4;\n    int elementperrow = 4;\n    int bitsperindex = 2;\n    int arrayidx = y * elementperrow + x / indexperelement;\n    int idx = x % indexperelement;\n    int bitoffset = (idx) * bitsperindex;\n    int mask = 3 << bitoffset;\n    int bits = (sprBody1[arrayidx] & mask) >> bitoffset; // test\n\n    float value = float(bits) / 3.0;\n    return (value);\n}\n\nfloat sampleSpriteBody2 (vec2 uv)\n{\n    vec2 fracuv = fract(uv);\n    int x = int(fracuv.x * 16.0);\n    int y = int(fracuv.y * 20.0);\n    \n    // 16 idx data per row, 1 element & 4 index per 1 element...\n    // => 4 element per row\n    int indexperelement = 4;\n    int elementperrow = 4;\n    int bitsperindex = 2;\n    int arrayidx = y * elementperrow + x / indexperelement;\n    int idx = x % indexperelement;\n    int bitoffset = (idx) * bitsperindex;\n    int mask = 3 << bitoffset;\n    int bits = (sprBody2[arrayidx] & mask) >> bitoffset; // test\n\n    float value = float(bits) / 3.0;\n    return (value);\n}\n\nfloat getrectmix (vec2 uv, vec2 sz)\n{\n    float val = 0.0;\n    vec2 rectsz = (vec2(0.5) - sz * 0.5);\n    vec2 rect = step(rectsz, uv);\n    val = rect.x * rect.y;\n    \n    rect = step(rectsz, vec2(1.0) - uv);\n    val *= rect.x * rect.y;\n    return val;\n}\n\nvec3 mixSpriteHead (vec3 orig, vec2 uv)\n{\n    vec3 colour = orig;\n    float spr = sampleSpriteHead(uv * 1.0);\n    \n    vec2 sprUVDelta = step(abs(uv - vec2(0.5, -0.5)), vec2(0.5));\n    float sprMix = sprUVDelta.x * sprUVDelta.y;\n    \n    colour = mix(colour, vec3(spr), sprMix);\n    return colour;\n}\n\nvec3 mixSpriteBody1 (vec3 orig, vec2 uv)\n{\n    vec3 colour = orig;\n    float spr = sampleSpriteBody1(uv * 1.0);\n    \n    vec2 sprUVDelta = step(abs(uv - vec2(0.5, -0.5)), vec2(0.5));\n    float sprMix = sprUVDelta.x * sprUVDelta.y;\n    \n    float discardMask = 1.0 / 3.0; // discard if image idx == 1\n    if (spr == discardMask)\n        sprMix = 0.0;\n    \n    colour = mix(colour, vec3(spr), sprMix);\n    return colour;\n}\n\nvec3 mixSpriteBody2 (vec3 orig, vec2 uv)\n{\n    vec3 colour = orig;\n    float spr = sampleSpriteBody2(uv * 1.0);\n    \n    vec2 sprUVDelta = step(abs(uv - vec2(0.5, -0.5)), vec2(0.5));\n    float sprMix = sprUVDelta.x * sprUVDelta.y;\n    \n    float discardMask = 1.0; // discard if image idx == 3\n    if (spr == discardMask)\n        sprMix = 0.0;\n    \n    colour = mix(colour, vec3(spr), sprMix);\n    return colour;\n}\n\n// Noise functions from\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n)\n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// HSV -> RGB routine from\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat samplenaejang (vec3 uv, float time)\n{\n    // prevent floating point error\n    // time = mod(time, 6.285);\n    \n    // apply wobble\n    vec2 wobblyUV = vec2(uv.x, uv.y);\n    wobblyUV.x += sin(uv.y * 10.0 + mod(time * 0.82, 6.28) + cos(uv.x * 2.5 + time * 0.5) * 0.15) * 0.065;\n    wobblyUV.y += cos(uv.x * 14.2 + mod(time * 0.75, 6.28) + sin(uv.y * 1.5 + time * 0.6) * 0.2) * 0.065;\n    \n    // calculate 10PRINT\n    vec2 uvMult = wobblyUV * 8.0;\n   \tvec2 uvChunky = floor(uvMult) / 8.0;\n    vec2 uvChunkyLocal = fract(uvMult);\n    float chunkFlip = sign(floor(noise(uvChunky * 10.0) + 0.5) - 0.5);\n    \n    vec2 gridDelta = fract(vec2(uvChunkyLocal.x * chunkFlip, uvChunkyLocal.y)) - 0.5;\n    float dist1 = min(distance(vec2(0.5), gridDelta), distance(vec2(0.5), -gridDelta));\n    float dist2 = abs(0.5 - dist1);\n    float thiccness = 0.8 + pow(sin(time), 3.0) * 0.4;\n    float shape = dist2 * thiccness;//smoothstep(0.3, 0.75, dist2 * thiccness);\n    \n    return clamp((1.0 - shape) - uv.z, 0.0, 1.0);\n}\n\nvec3 getnaejangnormal (vec2 uv, float time)\n{\n    vec3 normal;\n    vec2 smol = vec2(0.00001, 0.0);\n    vec3 uv3D = vec3(uv, 0.0);\n    \n    // calculate normal via central whatever method\n    normal.x = (samplenaejang(uv3D - smol.xyy, time) - samplenaejang(uv3D + smol.xyy, time));\n    normal.y = (samplenaejang(uv3D - smol.yxy, time) - samplenaejang(uv3D + smol.yxy, time));\n    normal.z = 2.0 * smol.x;\n    return normalize(normal);\n}\n\nvec3 samplerectBG (vec2 absuv, vec2 rectUV, float time)\n{\n    vec2 uvsize = (iResolution.xy / iResolution.x);\n    vec2 uvsizeHalf = uvsize * 0.5;\n    vec3 colourRect;\n    \n    // Prepare rect properties\n    const float rectScrollPower = 3.0;\n    vec2 rectUVOffset = vec2(pow(sin(time * 0.5), rectScrollPower) * 1.0, pow(cos(time * 0.25), rectScrollPower) * 4.0);\n    rectUV += rectUVOffset; // / (rectHalfSize * 2.0);\n\n    // Foreground : 10PRINT\n    float naejangSDF = samplenaejang(vec3(rectUV, 0.0), time);\n    vec3 naejangNormal = getnaejangnormal(rectUV, time); // vec3(clamp(getnaejangnormal(rectUV, time), -1.0, 1.0), 0.5);\n\tfloat naejangCenterMix = pow(1.0 - pow(1.0 - naejangSDF, 1.0), 4.0);//smoothstep(0.0, 0.75, naejangSDF - 0.1);\n    naejangNormal.xy = mix(naejangNormal.xy, vec2(0.0), naejangCenterMix);\n    naejangNormal.z = 1.0;//mix(0.0, 1.0, naejangCenterMix);\n    \n    // Calculate light\n    vec3 viewVector = vec3(0.0, 0.0, 1.0);\n    float lightTime = mod(time * 2.0, 6.254);\n    vec3 lightPos = vec3(uvsizeHalf + vec2(cos(lightTime), sin(lightTime)) * (uvsizeHalf * 0.75), 1.0);\n    vec3 lightDelta = lightPos - vec3(absuv, 0.05 + naejangSDF * 0.35);\n    vec3 lightDir = normalize(lightDelta);\n    float lightDist = length(lightDelta);\n    \n    // 1] albedo\n    vec3 plasmacolour1 = hsv2rgb(vec3(fract(time * 0.2), 0.5, 1.0));\n    vec3 plasmacolour2 = hsv2rgb(vec3(fract(1.0 - time * 0.2), 1.0, 0.5));\n    \n    vec3 diffuse = mix(plasmacolour2, plasmacolour1, naejangCenterMix);\n    //colourRect = diffuse;\n    \n    // 2] lambert\n    float lightAmbient = 0.5;\n    float lightDot = dot(naejangNormal, lightDir);\n    float lightDistRange = smoothstep(0.3, 0.7, clamp(1.0 / (lightDist * lightDist * 4.0), 0.0, 1.0));\n    float lightLit = clamp((lightDot * lightDistRange + lightAmbient), 0.0, 1.0);\n    colourRect = diffuse * lightLit;\n    \n    // 3] Blinn-phong specular reflection\n    vec3 phongH = normalize(lightDelta + viewVector);\n    float phongDistRange = naejangCenterMix * smoothstep(0.5, 0.7, clamp(1.0 / (lightDist * lightDist * 4.0), 0.0, 1.0));\n    float phongDot = dot(naejangNormal, phongH);\n    float phongClamped = clamp(phongDot, 0.0, 1.0);\n    float phong = pow(phongClamped, 800.0);\n    \n    colourRect += vec3(phong * phongDistRange);\n    \n    return colourRect;\n}\n\nvec3 samplescene (vec2 uv, float time)\n{\n    vec2 uvsize = (iResolution.xy / iResolution.x);\n    vec2 uvsizeHalf = uvsize * 0.5;\n    vec3 final = vec3(0.0);\n    \n    // Prepare rect properties\n    vec2 rectHalfSize = vec2(0.4, 0.225);\n    const float rectUVScale = 1.5;\n    vec2 rectUV = (uv - (uvsizeHalf - rectHalfSize)) * rectUVScale;\n    \n    // Downscale the rectangle's resolution\n    const float crunchfactor = 64.0;\n    vec2 uvcrunchy = floor(rectUV * crunchfactor) / crunchfactor;\n    vec2 uvcrunchylocal = fract(rectUV * crunchfactor);\n    \n    // Commodore colours\n    vec3 colourBG = HEXRGB(0x887ecb);\n    vec3 colourRect = HEXRGB(0x50459b);\n    \n    // Background C64 loading screen-like raster bars\n    float rasterScale = 15.0;\n    float rasterOff = time * 0.5;\n    float rasterMix = floor(fract((uv.y + rasterOff) * rasterScale + (uv.x * sin(time * 3.0)) * 0.5) + 0.5);\n    const vec3 colours[3] = vec3[3](HEXRGB(0x6abfc6), HEXRGB(0xa1683c), HEXRGB(0x9ae29b));\n    \n    colourBG = mix(colours[int(time) % 3], HEXRGB(0xadadad), rasterMix);\n    \n    // Foreground : 10PRINT\n    const float uvdownscaleFactor = 64.0;\n    vec2 uvdownscale = (rectUV * uvdownscaleFactor + 0.5);\n    vec2 uvdownscaleLocal = fract(uvdownscale);\n    uvdownscale = floor(uvdownscale) / uvdownscaleFactor;\n    \n    vec3 rectBG = samplerectBG(uv, uvdownscale, time);\n    float rectBGLuma = clamp(dot(rectBG, rectBG), 0.0, 1.0);\n    \n    // apply LED light effect to foreground's 10PRINT BG(??)\n    float ledDiscRadius = 0.25 * rectBGLuma + 0.20;\n    const float ledDiscRadiusSmooth = 0.1;\n    float ledDiscDelta = distance(vec2(0.5), uvdownscaleLocal);\n    float ledDiscMix = smoothstep(ledDiscRadius + ledDiscRadiusSmooth, ledDiscRadius, ledDiscDelta);\n    colourRect = mix(rectBG * 0.5, rectBG, ledDiscMix);\n    colourRect = clamp(colourRect + pow(1.0 - ledDiscDelta, 2.0) * 0.2, 0.0, 1.0);\n\n    // Foreground : Sprites\n    vec2 sprUV;\n    float sprAnimTime = time * 2.0;\n    float sprRot = sin(sprAnimTime);\n    float sprScale = 8.0;\n    vec2 sprOff = vec2(sin(time * 0.5 + cos(time * 0.1) * 0.01) * 0.05, cos(time * 0.5) * 0.025 + sin(time * 0.1) * 0.01);\n    \n    // body\n    float rot = radians(pow(sprRot, 4.0) * 12.0 * 0.1);\n    sprUV = (vec2(uv.x, uv.y) - uvsizeHalf + sprOff) * sprScale;\n    //sprUV.y -= 0.75;\n    sprUV *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    sprUV += 0.5;\n    sprUV.y *= -1.0;\n    sprUV.y += -0.6;\n    colourRect = mixSpriteBody2(colourRect, sprUV);\n    \n    // body\n    rot = radians(pow(sprRot, 3.0) * 12.0 * 0.3);\n    sprUV = (vec2(uv.x, uv.y) - uvsizeHalf + sprOff) * sprScale;\n    //sprUV.y -= 0.75;\n    sprUV *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    sprUV += 0.5;\n    sprUV.y *= -1.0;\n    sprUV.y += -0.65 + sin(sprAnimTime * 2.0) * 0.05;\n    colourRect = mixSpriteBody1(colourRect, sprUV);\n    \n    // head\n    rot = radians(sprRot * 12.0 * -0.5);\n    sprUV = (vec2(uv.x, uv.y) - uvsizeHalf + sprOff) * sprScale;\n    sprUV *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    sprUV += 0.5;\n    sprUV.y *= -1.0;\n    sprUV.y += sin(sprAnimTime * 2.0) * 0.1;\n    colourRect = mixSpriteHead(colourRect, sprUV);\n    \n    // debug light\n    //float lightCircleMix = smoothstep(0.01, -0.01, length(lightDelta.xy) - 0.01);\n    //colourRect = mix(colourRect, vec3(0.0, 1.0, 1.0), lightCircleMix);\n    \n    // Draw commodore 64-esque screen\n    // shadow\n    vec2 centerDelta = uvsizeHalf - uv + vec2(0.025, -0.025);\n    float rectMinDelta = max(abs(centerDelta.x) - rectHalfSize.x, abs(centerDelta.y) - rectHalfSize.y);\n    float rectfactor = 1.0 - ceil(max(rectMinDelta, 0.0));\n    vec3 rect = mix(colourBG, colourBG * vec3(0.5), rectfactor);\n    \n    // screen\n    centerDelta = uvsizeHalf - uv;\n    rectMinDelta = max(abs(centerDelta.x) - rectHalfSize.x, abs(centerDelta.y) - rectHalfSize.y);\n    rectfactor = 1.0 - ceil(max(rectMinDelta, 0.0));\n    rect = mix(rect, colourRect, rectfactor);\n    \n\treturn rect;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvratio = (iResolution.xy / iResolution.x);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvPixelperfect = fragCoord/iResolution.xy * uvratio;\n\n    // Uh yeah woo yeah woo hoo\n    vec3 col = samplescene(uvPixelperfect, iTime);\n    \n    // Test : sprite\n    // vec3 col = vec3(sampleSpriteHead(vec2(uv.x, 1.0 - uv.y)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2123, 2123, 2157, 2157, 2726], [2728, 2728, 2763, 2763, 3333], [3335, 3335, 3370, 3370, 3940], [3942, 3942, 3979, 3979, 4195], [4197, 4197, 4238, 4238, 4496], [4498, 4498, 4540, 4540, 4918], [4920, 4920, 4962, 4962, 5334], [5336, 5429, 5449, 5449, 5516], [5517, 5517, 5538, 5538, 5747], [5749, 5835, 5857, 5857, 6026], [6028, 6028, 6071, 6164, 7038], [7040, 7040, 7085, 7085, 7475], [7477, 7477, 7534, 7534, 9781], [9783, 9783, 9823, 9823, 13741], [13743, 13743, 13800, 13850, 14239]], "test": "untested"}
{"id": "ttV3z1", "name": "Pastafari/FSM  b (339 chars)", "author": "FabriceNeyret2", "description": "regolfing  2017' version [url]https://shadertoy.com/view/ltKSRG[/url] (422 chars)\nCould it be shorter ? :-)\n\n[url]https://en.wikipedia.org/wiki/Flying_Spaghetti_Monster[/url]\n", "tags": ["flag", "short", "golf", "pastafarianism", "fsm", "reproduction", "3tweets"], "likes": 7, "viewed": 331, "published": 3, "date": "1578332958", "time_retrieved": "2024-07-30T21:31:23.429541", "image_code": "// regolfing 2017' shader https://shadertoy.com/view/ltKSRG (422 chars)\n// ( see animated version here: https://www.shadertoy.com/view/ltGXRK )\n\n// --- 339   -9 by Fab\n\n#define S(v)  o += max( 0., 3. - 80.* abs(v).x )        //\n#define C(a,b,c,d)                                       \\\n              U.x > a && U.x < b+1.                      \\\n              ? S( d + .08* sin( c + 13.*U ) -U.y  ) : o;\\\n              U *= .1 * mat2(9,-5,5,9);//\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 o = iResolution.xy,\n         U = u+u - o, A = abs( U /= o.y );\n    A.y += .7; S( length(A) - u/u ) - o;\n    U.x = A.x;\n    A.x = length( U - vec2(.2,.55) );\n    S( U.y>.3 && U.y<.45 ?  U*.8 - U.y*.3 : A );\n    C( .7, .4 , 3.1,     )\n    C( .55,.25, 4.7, .2  )\n    C( .4,    ,    , .25 )\n    O++; O.gb = S(A-.1);\n} /*\n\n\n\n\n\n// --- 348   -8 by coyote -7 by Fab\n\n#define S(v)  o += smoothstep(.04, .025, abs(v)).x//\n#define C(a,b,f,d)                                       \\\n              U.x > a && U.x < b+1.                      \\\n              ? S( d + .08* sin( f + 13.*U ) -U.y  ) : o;\\\n              U *= .1 * mat2(9,-5,5,9);//\n#define mainImage(O,u)                                   \\\n    vec2 o = iResolution.xy,                             \\\n         U = u+u - o, A = abs( U /= o.y );               \\\n    A.y += .7; S( length(A) - u/u ) - o;                 \\\n    U.x = A.x;                                           \\\n    A.x = length( U - vec2(.2,.55) );                    \\\n    U.y>.3 && U.y<.45 ? S( U*.8 - U.y*.3 )               \\\n                      : S( A );                          \\\n    C( .7, .4 , 3.1,     )                               \\\n    C( .55,.25, 4.7, .2  )                               \\\n    C( .4,    ,    , .25 )                               \\\n    O++; O.gb = S(A-.1)                                 /*\n\n\n\n\n\n// --- 363 chars\n\n#define S(v)        o += smoothstep(.04, .025, abs(v))  //\n#define C(a,b,f,d)  U.x > a && U.x < b                   \\\n           ? S( d + .08* sin( f + 13.*U.x ) -U.y  ) : o; \\\n           U *= mat2(.9,-.5,.5,.9);//\n#define mainImage(O,u)                                   \\\n\tvec2 R = iResolution.xy,                             \\\n         U = ( u+u -R ) / R.y, A = abs(U);               \\\n\tvec4 o = O.wxxw;                                     \\\n    A.y += .7; S( length(A) -1. );                       \\\n    U.x = A.x;                                           \\\n    float l = length( U - vec2(.2,.55) );                \\\n    U.y>.3 && U.y<.45 ? S( U.x*.8-U.y*.3 )               \\\n                      : S(l); S(l-.1);                   \\\n    C( .7, 1.4 , 3.1,     )                              \\\n    C( .55,1.25, 4.7, .2  )                              \\\n    C( .4, 1.  ,    , .25 )  O=o                        /*\n                          \n/**/ ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttV3z1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3lyGRW", "name": "parameteric kcurve", "author": "weepy", "description": "Useful symmetric parameterised map from 0-1 to 0-1\n\n* zero at 0 and 1\n* 2nd parameter s controls curviness\n* transition between saw, sine-ish and reverse saw when s = 1\n\n\nDerived from https://iquilezles.org/articles/functions/functions.htm", "tags": ["kcurve"], "likes": 1, "viewed": 289, "published": 3, "date": "1578332642", "time_retrieved": "2024-07-30T21:31:24.176544", "image_code": "float kcurve( float x, float k, float s )\n{\t\n    float p = (1.-x)/(1.-k);\n    float v = 4.-6.*abs(k-0.5);\n    float h = pow( x/(k*p), k ) * p;\n    \n    return pow( h, v*s*s );\n   \n}\n\nfloat scurve( float x, float k, float s )\n{\t\n   float x1= 1.-fract((x-k)/(1.-k));\n   float x2=fract(x/k);\n \t\n   \n return x < k ? x2 : x1;//*k+x2*(1.-k);\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    float p = kcurve(uv.x, mouse.x, mouse.y*5.);\n    \n\n      fragColor = mix(vec4(0.),  vec4(col,1.0), smoothstep( 0.,0.005, p-uv.y));   \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 181], [183, 183, 226, 226, 341], [343, 343, 400, 450, 829]], "test": "untested"}
{"id": "wtV3R1", "name": "The ring", "author": "avin", "description": "The ring film title replic", "tags": ["circle", "shine"], "likes": 34, "viewed": 1058, "published": 3, "date": "1578323590", "time_retrieved": "2024-07-30T21:31:25.021285", "image_code": "#define TAU 6.2831852\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    \n    // float a = fract(atan(uv.y, uv.x)/TAU);\n    float a = sin(atan(uv.y, uv.x));\n    float am = abs(a-.5)/4.;\n    float l = length(uv);                     \n    \n    \n    float m1 = clamp(.1/smoothstep(.0, 1.75, l), 0., 1.);\n    float m2 = clamp(.1/smoothstep(.42, 0., l), 0., 1.);\n    float s1 = (simplex_noise(vec3(uv*2., 1. + iTime*.525))*(max(1.0 - l*1.75, 0.)) + .9);\n    float s2 = (simplex_noise(vec3(uv*1., 15. + iTime*.525))*(max(.0 + l*1., .025)) + 1.25);\n    float s3 = (simplex_noise(vec3(vec2(am, am*100. + iTime*1.)*.15, 30. + iTime*.525))*(max(.0 + l*1., .025)) + 1.25);\n    s3 *= smoothstep(0.0, .3345, l);    \n    \n    float sh = smoothstep(0.15, .35, l);\n    float sh2 = smoothstep(0.75, .3, l);    \n    \n    float m = m1*m2 * ((s1*s2*s3) * (1.-l)) * sh * sh2;\n    m = m*m;\n            \n    fragColor = vec4(m);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtV3R1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 84, 84, 236], [238, 238, 267, 267, 931], [933, 933, 990, 990, 1892]], "test": "untested"}
{"id": "3lK3RR", "name": "Translucency Rendering", "author": "ikuto", "description": " ", "tags": ["translucency", "translucent"], "likes": 24, "viewed": 739, "published": 3, "date": "1578319795", "time_retrieved": "2024-07-30T21:31:25.816160", "image_code": "#define AA 2\n\nstruct Material\n{\n    vec3 \tdiffuseAlbedo;\n    vec3 \tspecularAlbedo;\n    float \tspecularPower;\n};\n\nMaterial materials[] = Material[] \n(\n    Material(vec3(0.0, 0.2, 0.2), vec3(0.3), 8.0),\n    Material(vec3(0.2, 0.2, 0.0), vec3(0.3), 8.0),\n    Material(vec3(0.2, 0.0, 0.2), vec3(0.3), 8.0),\n    Material(vec3(0.2, 0.2, 0.2), vec3(0.2), 8.0)\n);\n\nvec2 opU(vec2 a, vec2 b) { return a.x < b.x ? a : b; }\n\n//distance functions from https://iquilezles.org/articles/distfunctions\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 map(vec3 p)\n{\n    float objID = 0.0;\n    vec2 res = vec2(sdTorus(p-vec3(0.0, 0.0, -2.0), vec2(1.0, 0.3)), objID++);\n    res = opU(res, vec2(sdRoundBox(p-vec3(1.5, 0.0, 0.5), vec3(0.7, 0.7, 0.7), 0.2), objID++));\n    res = opU(res, vec2(sdOctahedron(p-vec3(-1.5, 0.2, 0.5), 1.2), objID++));\n    res = opU(res, vec2(p.y + 1.0, objID++));    \n    return res;\n}\n\nvec3 calculateTransmittance(vec3 ro, vec3 rd, float tmin, float tmax, float atten)\n{\n    const int MAX_DEPTH = 4;\n    float hitPoints[MAX_DEPTH];\n    int depth = 0;\n    \n    for (float t = tmin; t < tmax;)\n    {\n        float h = abs(map(ro + t * rd).x);\n        if (h < 1e-5) { hitPoints[depth++] = t; t += 0.01; };\n        if (depth >= MAX_DEPTH) break;\n        t += h;\n    }\n    \n    float thickness = 0.0;\n    for (int i = 0; i < depth - 1; i += 2) thickness += hitPoints[i+1] - hitPoints[i];\n    \n    return vec3(1.0) * exp(-atten * thickness * thickness);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n\tfor (float t = tmin; t < tmax;)\n    {\n        vec3 pos = ro + t * rd;\n        vec2 res = map(pos);\n        \n        float dist = res.x;\n        if (dist < 0.001) return vec2(t, res.y);\n        \n        t += dist;\n    }\n    return vec2(-1.0, -1.0);\n}\n\nvec3 calculateNormal(vec3 p)\n{\n    vec3 dt = vec3(0.001, 0.0, 0.0);\n    return normalize( vec3 ( map(p+dt.xyy).x - map(p-dt.xyy).x,\n    \t\t\t\t\t\t map(p+dt.yxy).x - map(p-dt.yxy).x,\n                             map(p+dt.yyx).x - map(p-dt.yyx).x ) );\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\tvec3 color = vec3(0.0);\n    \n    vec2 res = rayMarch(ro, rd, 0.01, 20.0);\n    float t = res.x;\n    float objID = res.y;\n    \n    if (objID > -0.5)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calculateNormal(pos);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.5, -1.0));\n        vec3 lightColor = vec3(1.0);\n        Material mat = materials[int(objID)];\n        \n        float t = clamp(0.5 + 0.5 * sin(iTime), 0.2, 1.0);\n        vec3 light = t * lightColor * calculateTransmittance(pos+nor*vec3(0.01), lightDir, 0.01, 10.0, 2.0);\n        light += (1.0 - t) * calculateTransmittance(pos+nor*vec3(0.01), rd, 0.01, 10.0, 0.5);\n        color =  light * mat.diffuseAlbedo;\n        color += light * mat.specularAlbedo * pow(max(0.0, dot(reflect(lightDir,nor),rd)), 4.0);\n    }\n    \n    return color;\n}\n\nmat3 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 w = normalize(target - eye);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    return mat3(u, v, -w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float an = iMouse.z>0.0 ? 10.0*(iMouse.x/iResolution.x-0.5) : 0.0;\n    \n\tvec3 ro = 5.0*vec3(sin(an), 0.3, cos(an));\n    mat3 viewMat = lookAt(ro, vec3(0.0, -1.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < AA; ++i)\n    {\n        for (int k = 0; k < AA; ++k)\n        {\n            vec2 offset = vec2(float(i)+0.5,float(k)+0.5) / float(AA) - 0.5;\n            vec2 uv = (2.0*(fragCoord+offset)-iResolution.xy)/iResolution.y;    \n    \t    vec3 rd = viewMat * normalize(vec3(uv, -1.5));\n    \t\t\n            color += render(ro, rd);\n        }\n    }\n    \n\tcolor /= float(AA*AA);\n\tcolor = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lK3RR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 357, 383, 383, 411], [413, 485, 523, 523, 576], [578, 578, 611, 611, 676], [678, 678, 723, 723, 814], [816, 816, 834, 834, 1178], [1180, 1180, 1264, 1264, 1743], [1745, 1745, 1802, 1802, 2053], [2055, 2055, 2085, 2085, 2302], [2304, 2304, 2335, 2335, 3154], [3156, 3156, 3201, 3201, 3332], [3334, 3334, 3389, 3389, 4077]], "test": "untested"}
{"id": "3lt3WS", "name": "Recursive Platonic solids", "author": "tomoe", "description": "generalization of Sierpinski's method", "tags": ["imi202001"], "likes": 10, "viewed": 458, "published": 3, "date": "1578290810", "time_retrieved": "2024-07-30T21:31:26.815488", "image_code": "#define PI 3.14159265359\n#define PHI 1.618033988749895\n#define v1 vec3(1.0, 0.0, 0.0)\n#define v3 vec3(0.0, 0.0, 1.0)\nvec3 v2, w1, w2, w3;\nvec3 vtxP, edgN, faceN;\nfloat rad = 1.0;\nvoid init(float m) {\n    v2 = vec3(-0.5, sqrt(0.75 - pow(cos(PI / m), 2.0)), - cos(PI / m));\n    float triProd = dot(cross(v1, v2), v3);\n    w1 = normalize(cross(v3, v2) / triProd);\n    w2 = normalize(cross(v1, v3) / triProd);\n    w3 = normalize(cross(v2, v1) / triProd);\n}\nfloat edgSDF(vec3 p, float t) {// t:thickness\n    return max(abs(dot(p - vtxP, faceN)), abs(dot(p - vtxP, edgN))) - t;\n}\nfloat vtxSDF(vec3 p, float t) {\n    return length(p - vtxP) - t;\n}\nfloat faceSDF(vec3 p, float t) {\n    return dot(p - vtxP, faceN) - t;\n}\n#define fold(w)p = p - 2.0 * max(dot(w, p), 0.0) * w;\nfloat tetraSDF(vec3 p) {\n    init(3.0);\n    float scale = 2.0;\n    float scalePow = 1.0;\n    vtxP = rad * w1;\n    for(int i = 0; i < 4; i ++ ) {\n        fold(v1)fold(v3)fold(v2)fold(v3)fold(v1)fold(v2)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }  \n    edgN = w2;\n    faceN = w3;\n    return edgSDF(p, 0.1) / scalePow;\n}\nfloat cubeSDF(vec3 p) {\n    init(4.0);\n    vtxP = rad * w3;\n    float scale = 2.5;\n    float scalePow = 1.0;\n    for(int i = 0; i < 4; i ++ ) {\n        fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }\n    edgN = w2;\n    faceN = w1;\n    return faceSDF(p, 0.5) / scalePow;\n}\nfloat octaSDF(vec3 p) {\n    init(4.0);\n    vtxP = rad * w1;\n    float scale = 2.0;\n    float scalePow = 1.0;\n    for(int i = 0; i < 3; i ++ ) {\n        fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }\n    edgN = w2;\n    faceN = w3;\n    return min(edgSDF(p, 0.02), vtxSDF(p, 0.3)) / scalePow;\n}\nfloat dodecaSDF(vec3 p) {\n    init(5.0); \n    vtxP = rad * w1;\n    float scale = PHI + 1.0;\n    float scalePow = 1.0;\n    for(int i = 0; i < 3; i ++ ) {\n        fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }\n    edgN = w2;\n    faceN = w3;\n    return faceSDF(p, 0.0) / scalePow;\n}\nfloat icosaSDF(vec3 p) {\n    init(5.0);\n    vtxP = rad * w3;\n    float scale = PHI + 1.0;\n    float scalePow = 1.0;\n    for(int i = 0; i < 3; i ++ ) {\n        fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }\n    edgN = w2;\n    faceN = w1;\n    return edgSDF(p, 0.08) / scalePow;\n}\nmat3 euler(float h, float p, float r) {\n    return mat3(\n        cos(r) * cos(h) - sin(r) * sin(p) * sin(h), - sin(r) * cos(p), cos(r) * sin(h) + sin(r) * sin(p) * cos(h),\n        sin(r) * cos(h) + cos(r) * sin(p) * sin(h), cos(r) * cos(p), sin(r) * sin(h) - cos(r) * sin(p) * cos(h),\n        - cos(p) * sin(h), sin(p), cos(p) * cos(h)\n    );\n}\n#define seq(v, s)d = mix(d, v, smoothstep(s - 0.3, s, t));\nfloat sceneSDF(vec3 p) {\n    float seqStep = 5.0;\n    float t = abs(mod(iTime * 0.5, seqStep * 2.0) - seqStep);\n    float d = tetraSDF(p);\n    seq(cubeSDF(p), 1.0)\n    seq(octaSDF(p), 2.0)\n    seq(dodecaSDF(p), 3.0)\n    seq(icosaSDF(p), 4.0)\n    return d;\n}\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n            sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p + vec3(-d, 0.0, 0.0)),\n            sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p + vec3(0.0, - d, 0.0)),\n            sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p + vec3(0.0, 0.0, - d))\n        ));\n    }\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    //camera transform\n    float t = 0.3 * iTime;\n    mat3 g = euler(t, t, t);\n\n    // camera\n    vec3 cPos = g * vec3(0.0, 0.0, 2.0);\n    vec3 cDir = g * vec3(0.0, - 0.0, - 1.0);\n    vec3 cUp = g * vec3(0.0, 1.0, 0.0);\n    float targetDepth = 1.0;\n    vec3 cSide = cross(cDir, cUp);\n\n    // light\n    vec3 lightPos = g * vec3(0.0, 1.0, 1.0);\n\n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    vec3 rPos = cPos ;\n\n    // marching loop\n    for(int i = 0; i < 60; i ++ ) {\n        rPos += sceneSDF(rPos) * ray;\n    }\n\n    // collision detection\n    if (sceneSDF(rPos) < 0.001) {\n        vec3 normal = gradSDF(rPos);\n        float diff = clamp(dot(normalize(lightPos - rPos), normal), 0.01, 1.0);\n        vec3 amb = vec3(0.0, 1.0, 0.0);\n        fragColor = vec4(diff * amb, 1.0);\n    } else {\n        fragColor = vec4(1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lt3WS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 199, 199, 452], [453, 453, 484, 498, 573], [574, 574, 605, 605, 640], [641, 641, 673, 673, 712], [2803, 2803, 2842, 2842, 3147], [3465, 3465, 3487, 3487, 3795], [3796, 3796, 3851, 3876, 4831]], "test": "untested"}
{"id": "WlcGR2", "name": "Lerp between spheres ", "author": "tomoe", "description": "Lerp between spheres ", "tags": ["raymarching", "imi202001"], "likes": 3, "viewed": 377, "published": 3, "date": "1578290783", "time_retrieved": "2024-07-30T21:31:27.618341", "image_code": "#define PI 3.14159265359\nmat3 rotX(float t) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), sin(t),\n        0.0, - sin(t), cos(t)\n    );\n}\nmat3 rotY(float t) {\n    return mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        - sin(t), 0.0, cos(t)\n    );\n}\nmat3 rotZ(float t) {\n    return mat3(\n        cos(t), sin(t), 0.0,\n        - sin(t), cos(t), 0.0,\n        0.0, 0.0, 1.0\n    );\n}\nfloat sphereSDF(vec3 p, vec3 cent, float rad) {\n    return distance(p, cent) - rad;\n}\nfloat sceneSDF(vec3 p){\n    float t = 0.5* iTime;\n    p *= rotY(t) * rotX(t) * rotZ(t);\n    float dist = 1.0;\n    for (float i = 0.0; i < 6.0; i++){\n        vec3 cent = vec3(cos(2.0 * PI * i / 6.0), sin(2.0 * PI * i / 6.0), 0.0);\n        dist = min(dist, sphereSDF(p, cent, 0.2));\n    }\n    return mix(dist, sphereSDF(p, vec3(0.0), 1.), abs(mod(t, 2.0) - 1.0));\n}\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p + vec3(-d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p + vec3(0.0, - d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p + vec3(0.0, 0.0, - d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera\n    vec3 cPos = vec3(0.0, 0.0, 2.0);\n    vec3 cDir = vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    // light\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    // lightDir *= rotY(u_time);\n\n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    // marching loop\n    vec3 rPos = cPos;\n    for(int i = 0; i < 40; i++ ) {\n        rPos += ray * sceneSDF(rPos);\n    }\n    \n    // collision detection\n    if (abs(sceneSDF(rPos)) < 0.001) {\n        vec3 normal = gradSDF(rPos);\n        float diff = clamp(dot(lightDir, gradSDF(rPos)), 0.1, 1.0);\n        fragColor = vec4(vec3(diff), 1.0);\n    } else {\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 45, 45, 153], [154, 154, 174, 174, 282], [283, 283, 303, 303, 411], [412, 412, 459, 459, 497], [498, 498, 521, 521, 861], [862, 862, 884, 884, 1172], [1174, 1174, 1230, 1255, 2123]], "test": "untested"}
{"id": "Wtt3WS", "name": "Deformation of Platonic solids", "author": "tomoe", "description": "platonic solids are made from reflection groups", "tags": ["imi202001"], "likes": 6, "viewed": 364, "published": 3, "date": "1578290761", "time_retrieved": "2024-07-30T21:31:28.436155", "image_code": "#define PI 3.14159265359\n#define EPSILON 1e-4\n#define v1 vec3(1.0, 0.0, 0.0)\n#define v3 vec3(0.0, 0.0, 1.0)\nvec3 v2, w1, w2, w3;\nvec3 vtxP, edgN, faceN;\nfloat rad = 1.0;\nvoid init(float m){\n    v2 = vec3(-0.5, sqrt(0.75 - pow(cos(PI / m), 2.0)), -cos(PI / m));\n    float a = dot(cross(v1, v2), v3);\n    w1 = normalize(cross(v3, v2) / a);\n    w2 = normalize(cross(v1, v3) / a);\n    w3 = normalize(cross(v2, v1) / a);\n}\nfloat edgSDF(vec3 p, float t){\n    return max(abs(dot(p - vtxP, faceN)), abs(dot(p - vtxP, edgN))) - t;\n}\nfloat vtxSDF(vec3 p, float t){\n    return length(p - vtxP) - t;\n}\nfloat faceSDF(vec3 p, float t){\n    return dot(p - vtxP, faceN)- t;\n}\n#define fold(w)p = p - 2.0 * max(dot(w, p), 0.0) * w;\nfloat tetraSDF(vec3 p){\n    init(3.0);\n    fold(v1)fold(v3)fold(v2)fold(v3)fold(v1)fold(v2)\n    vtxP = rad * w1;\n    edgN = w2;\n    faceN = w3;\n    return min(edgSDF(p, 0.01), vtxSDF(p, 0.05));\n}\nfloat cubeSDF(vec3 p) {\n    init(4.0);\n    fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n    vtxP = rad * w3;\n    edgN = w2;\n    faceN = w1;\n    return edgSDF(p, 0.1);\n}\nfloat octaSDF(vec3 p) {\n    init(4.0);\n    fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n    vtxP = rad * w1;\n    edgN = w2;\n    faceN = w3;\n    return min(faceSDF(p, 0.06), edgSDF(p, 0.01));\n}\nfloat dodecaSDF(vec3 p) {\n    init(5.0);\n    fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n    vtxP = rad * w1;\n    edgN = w2;\n    faceN = w3;\n    return min(vtxSDF(p, 0.05), edgSDF(p, 0.002));\n}\nfloat icosaSDF(vec3 p) {\n    init(5.0);\n    fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n    vtxP = rad * w3;\n    edgN = w2;\n    faceN = w1;\n    return faceSDF(p, 0.0);\n}\nmat3 euler(float h, float p, float r) {\n    return mat3(\n        cos(r) * cos(h) - sin(r) * sin(p) * sin(h), - sin(r) * cos(p), cos(r) * sin(h) + sin(r) * sin(p) * cos(h),\n        sin(r) * cos(h) + cos(r) * sin(p) * sin(h), cos(r) * cos(p), sin(r) * sin(h) - cos(r) * sin(p) * cos(h),\n        - cos(p) * sin(h), sin(p), cos(p) * cos(h)\n    );\n}\n\n#define seq(v, s)d = mix(d, v, smoothstep(s - 0.3, s, t));\nfloat sceneSDF(vec3 p) {\n    float seqStep = 5.0;\n    float t = abs(mod(iTime * 0.5, seqStep * 2.0) - seqStep);\n    float d = tetraSDF(p);\n    seq(cubeSDF(p), 1.0)\n    seq(octaSDF(p), 2.0)\n    seq(dodecaSDF(p), 3.0)\n    seq(icosaSDF(p), 4.0)\n    return d;\n}\n\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n            sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p),\n            sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p),\n            sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p)\n        ));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    //camera transform\n    float t = 0.3 * iTime;\n    mat3 g = euler(t, t, t);\n\n    // camera\n    vec3 cPos = g * vec3(0.0, 0.0, 2.0);\n    vec3 cDir = g * vec3(0.0, - 0.0, - 1.0);\n    vec3 cUp = g * vec3(0.0, 1.0, 0.0);\n    float targetDepth = 1.0;\n    vec3 cSide = cross(cDir, cUp);\n\n    // light\n    vec3 lightPos = g * vec3(0.0, 1.0, 1.0);\n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    vec3 rPos = cPos ;    \n    // marching loop\n    for(int i = 0; i < 60; i ++ ) {\n        rPos += sceneSDF(rPos) * ray;\n    }\n\n    // collision detection\n    if (sceneSDF(rPos) < 0.001) {\n        vec3 normal = gradSDF(rPos);\n        float diff = clamp(dot(normalize(lightPos - rPos), normal), 0.01, 1.0);\n        vec3 amb = vec3(0.0, 1.0, 0.0);\n        fragColor = vec4(diff * amb, 1.0);\n    } else {\n        fragColor = vec4(1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtt3WS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 189, 189, 417], [418, 418, 448, 448, 523], [524, 524, 554, 554, 589], [590, 590, 621, 621, 659], [714, 714, 737, 737, 909], [910, 910, 933, 933, 1106], [1107, 1107, 1130, 1130, 1327], [1328, 1328, 1353, 1353, 1598], [1599, 1599, 1623, 1623, 1845], [1846, 1846, 1885, 1885, 2190], [2510, 2510, 2532, 2532, 2771], [2772, 2772, 2826, 2851, 3812]], "test": "untested"}
{"id": "3ld3zB", "name": "Boolean operation", "author": "tomoe", "description": "Boolean operation", "tags": ["imi202001"], "likes": 1, "viewed": 296, "published": 3, "date": "1578290743", "time_retrieved": "2024-07-30T21:31:29.183157", "image_code": "float sphereSDF(vec3 p, vec3 cent, float rad) {\n    return distance(p, cent) - rad;\n}\nfloat sceneSDF(vec3 p){\n    float cup = min(sphereSDF(p, vec3(0.0, sin(iTime), 0.0), 0.3), sphereSDF(p, vec3(0.0), 0.5));\n    float diff = max(sphereSDF(p, vec3(1.0, sin(iTime), 0.0), 0.3), -sphereSDF(p, vec3(1.0, 0.0,0.0), 0.5));\n    float cap = max(sphereSDF(p, vec3(-1.0, sin(iTime), 0.0), 0.3), sphereSDF(p, vec3(-1.0, 0.0, 0.0), 0.5));\n    return min(min(diff, cap), cup);\n}\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p + vec3(-d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p + vec3(0.0, - d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p + vec3(0.0, 0.0, - d))\n    ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // fragment position\n     vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera\n    vec3 cPos = vec3(0.0, 0.0, 2.0);\n    vec3 cDir = vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    // light\n    vec3 lightDir = vec3(1.0, 0.0, 1.0);\n\n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    // marching loop\n    vec3 rPos = cPos;\n    for(int i = 0; i < 40; i++ ) {\n        rPos += ray * sceneSDF(rPos);\n    }\n    \n    // collision detection\n    if (abs(sceneSDF(rPos)) < 0.001) {\n        vec3 normal = gradSDF(rPos);\n        float diff = clamp(dot(lightDir, gradSDF(rPos)), 0.1, 1.0);\n        fragColor = vec4(vec3(diff), 1.0);\n    } else {\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ld3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 85], [86, 86, 109, 109, 465], [466, 466, 488, 488, 776], [777, 777, 833, 858, 1694]], "test": "untested"}
{"id": "tl33Rl", "name": "Ball in several metric spaces", "author": "tomoe", "description": "ball, cube and octahedron", "tags": ["imi202001"], "likes": 2, "viewed": 291, "published": 3, "date": "1578290734", "time_retrieved": "2024-07-30T21:31:30.048844", "image_code": "const float PI = 3.14159265359;\nfloat kyoto(vec3 p){\n    float scale = 1.0 / sqrt(2.0);\n    return scale * (abs(p.x) + abs(p.y) + abs(p.z));\n}\nfloat shogi(vec3 p) {\n    float scale = sqrt(2.0);\n    return scale * max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\nfloat euc(vec3 p){\n    float scale = 1.0;\n    return scale * length(p);\n}\nfloat dist(vec3 p){\n    float t = abs(mod(0.5 * iTime, 4.0) - 2.0);\n    return mix(\n        mix(euc(p), shogi(p), clamp(t, 0.0, 1.0)),\n        kyoto(p), clamp(t - 1.0, 0.0, 1.0)\n    );\n}\nfloat ballSDF(vec3 p) {\n    return dist(p) - 1.;\n}\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n        ballSDF(p + vec3(d, 0.0, 0.0)) - ballSDF(p + vec3(-d, 0.0, 0.0)),\n        ballSDF(p + vec3(0.0, d, 0.0)) - ballSDF(p + vec3(0.0, - d, 0.0)),\n        ballSDF(p + vec3(0.0, 0.0, d)) - ballSDF(p + vec3(0.0, 0.0, - d))\n    ));\n}\nmat3 euler(float h, float p, float r){\n    return mat3(\n        cos(r)*cos(h)-sin(r)*sin(p)*sin(h), -sin(r)*cos(p), cos(r)*sin(h)+sin(r)*sin(p)*cos(h),\n        sin(r)*cos(h)+cos(r)*sin(p)*sin(h), cos(r)*cos(p), sin(r)*sin(h)-cos(r)*sin(p)*cos(h),\n        -cos(p)*sin(h), sin(p), cos(p)*cos(h)\n    ); \n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // transformation\n    float t = 0.5 * iTime;\n    mat3 g = euler(t, t, t);\n\n    // camera\n    vec3 cPos = g * vec3(0.0, 0.0, 2.0);\n    vec3 cDir = g * vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = g * vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    // light\n    vec3 lightPos = g *vec3(0.0, 1.0, 1.0);\n\n    // ray\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    ray = ray / dist(ray);\n    \n    // marching loop\n    vec3 rPos = cPos;\n    for(int i = 0; i < 60; i++ ) {\n        rPos += ray * ballSDF(rPos);\n    }\n    \n    if (abs(ballSDF(rPos)) < 0.001) { //object\n        vec3 normal = gradSDF(rPos);\n        float diff = clamp(dot(normalize(lightPos - rPos), gradSDF(rPos)), 0.0, 1.0);\n        vec3 col = vec3(0.0, 1.0, 0.0);\n        fragColor = vec4(diff * col, 1.0);\n    } else {    //background\n        fragColor = vec4(1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl33Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 52, 52, 142], [143, 143, 164, 164, 254], [255, 255, 273, 273, 328], [329, 329, 348, 348, 515], [516, 516, 539, 539, 566], [567, 567, 589, 589, 871], [872, 872, 910, 910, 1174], [1175, 1175, 1230, 1255, 2239]], "test": "untested"}
{"id": "tttGWM", "name": "sphere_exmple", "author": "tomoe", "description": "sphere", "tags": ["sphere", "imi202001"], "likes": 0, "viewed": 243, "published": 3, "date": "1578290707", "time_retrieved": "2024-07-30T21:31:30.936470", "image_code": "float sdf(vec3 p) {\n    return length(p) - 1.0;\n}\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n        sdf(p + vec3(d, 0.0, 0.0)) - sdf(p + vec3(-d, 0.0, 0.0)),\n        sdf(p + vec3(0.0, d, 0.0)) - sdf(p + vec3(0.0, - d, 0.0)),\n        sdf(p + vec3(0.0, 0.0, d)) - sdf(p + vec3(0.0, 0.0, - d))\n    ));\n}\nmat3 rotY(float t) {\n    return mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        - sin(t), 0.0, cos(t)\n    );\n}    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // fragment position\n     vec2 pos = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    \n    // camera\n    vec3 cPos = vec3(0.0, 0.0, 2.0);\n    vec3 cDir = vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    // light\n    vec3 lightDir = vec3(1.0, 0.0, 0.0);\n    lightDir = rotY(iTime) * lightDir;\n\n    // ray\n    vec3 ray = normalize(cSide * pos.x + cUp * pos.y + cDir * targetDepth);\n    \n    // marching loop\n    vec3 rPos = cPos;\n    for(int i = 0; i < 40; i++ ) {\n        rPos += ray * sdf(rPos);\n    }\n    \n    // collision detection\n    if (abs(sdf(rPos)) < 0.001) {\n        vec3 normal = gradSDF(rPos);\n        float diff = clamp(dot(lightDir, gradSDF(rPos)), 0.1, 1.0);\n        fragColor = vec4(vec3(diff), 1.0);\n    } else {\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 49], [50, 50, 72, 72, 330], [331, 331, 351, 351, 459], [464, 464, 520, 545, 1417]], "test": "untested"}
{"id": "tlcGD4", "name": "disc_example", "author": "tomoe", "description": "disc", "tags": ["test", "imi202001"], "likes": 0, "viewed": 256, "published": 3, "date": "1578290678", "time_retrieved": "2024-07-30T21:31:31.743312", "image_code": "float disc(vec2 p){\n    return length(p) - 1.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 pos = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // Output to screen\n    fragColor = vec4(vec3(step(disc(pos), 0.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcGD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 49], [50, 50, 107, 158, 330]], "test": "untested"}
{"id": "3lKGR1", "name": "Pulsing Stars", "author": "atsn", "description": "pulsing stars in outer space", "tags": ["space", "stars"], "likes": 2, "viewed": 379, "published": 3, "date": "1578287065", "time_retrieved": "2024-07-30T21:31:32.584064", "image_code": "float rand21(vec2 uv){\n    vec2 t = fract(vec2(uv.x*236.73,uv.y*678.47));\n    float u = dot(uv*(t+143.66),t);\n    return fract(t.x*u*345.87 + 365.22+t.y*u*475.57);\n}\nfloat rand21p(vec2 uv){\n    vec2 p = floor(uv);\n    vec2 fr = fract(uv);\n    \n    float grad = (\n        rand21(p+vec2(0.,0.)) * (1.-fr.x) * (1.-fr.y) + \n        rand21(p+vec2(1.,0.)) * (fr.x) * (1.-fr.y) +\n        rand21(p+vec2(0.,1.)) * (1.-fr.x) * (fr.y) +\n        rand21(p+vec2(1.,1.)) * (fr.x) * (fr.y)\n    );\n    return grad;\n}\nfloat perlin(vec2 uv, float layers){\n    float ret = 0.;\n    for(float i=0.;i<layers;i++){\n        ret += rand21p(uv*pow(2.,i)) / layers;\n    }\n    return ret;\n}\nfloat splatter(float time, vec2 uv){\n    float n0 = perlin(uv+rand21(uv*dot(uv,vec2(time))),9.);\n    return smoothstep(0.5,0.55,n0);\n}\nfloat ease(float time, vec2 uv){\n    float cur = splatter(floor(time),uv);\n    float next = splatter(floor(time)+1.,uv);\n    float f = fract(time);\n    return (1.-f)*cur + f*next;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5/iResolution.xy)/iResolution.y;\n    \n   \tfloat stars = pow(rand21(uv),200.) * (ease(iTime*2.,uv)*.7+.3);\n    \n    float atmo = pow(smoothstep(4.,3.5,length(uv-vec2(.9,-3.6))),2.);\n    vec3 atmo_col = vec3(.5,.5,1.);\n    \n    vec3 col = vec3(stars);\n    col = max(atmo_col*atmo,stars);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKGR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 165], [166, 166, 189, 189, 499], [500, 500, 536, 536, 661], [662, 662, 698, 698, 796], [797, 797, 829, 829, 978], [979, 979, 1036, 1036, 1387]], "test": "untested"}
{"id": "wlyGz1", "name": "deforming sphere along xyz axis", "author": "percentcer", "description": "Just messing around with atan. Use the mouse to orbit around the shape (x) or change the period of the deformation (y)", "tags": ["simple", "experiment"], "likes": 1, "viewed": 337, "published": 3, "date": "1578270717", "time_retrieved": "2024-07-30T21:31:33.391905", "image_code": "#define MAXD 100.\n\nmat3 roty(float a) {\n    return mat3(\n    \tcos(a), 0., sin(a),\n        0., 1., 0.,\n        -sin(a), 0., cos(a)\n    );\n}\n\nfloat shape(vec3 p) {\n    float sweepX = atan(p.z, p.y);\n    float sweepY = atan(p.x, p.z);\n    float sweepZ = atan(p.y, p.x);\n    float period = floor(iMouse.y / iResolution.y * 10.);\n    float radiusOffset = \n        (sin(sweepY * period))\n        * (sin(sweepX * period))\n        * (sin(sweepZ * period));\n    \n    return length(p) - (1. + radiusOffset*.2);\n}\n\nvec2 map(vec3 p) {\n    // return a distance and a material id\n    return vec2(shape(p), 1.);\n}\n\nvec3 norm(vec3 p) { \n    vec2 ep = vec2(0.001, 0.0);\n    return normalize(map(p).r - vec3(\n        map(p - ep.xyy).r,\n        map(p - ep.yxy).r,\n        map(p - ep.yyx).r\n    ));\n}\n\nvec4 march(vec3 ro, vec3 rd) {\n    float t = 0.;\n    vec4 ret;\n    for (int i = 0; i < 100; i++) {\n        \n        ret.xyz = ro + rd * t;\n        vec2 d = map(ret.xyz);\n        \n        if (d.x < .001) {\n        \tret.w = d.y;\n            break;\n        }\n        \n        t += d.x;\n        \n        if (t > MAXD) {\n            break;\n        }\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.5);\n    \n    vec3 ro = vec3(0., 0., 2.);\n    vec3 rd = normalize(vec3(uv.xy, -1.));\n    \n    mat3 rot = roty((iMouse.x / iResolution.x - .5)*10.);\n    ro *= rot;\n    rd *= rot;\n    \n    vec4 p = march(ro, rd);\n    \n    if (p.w > 0.) {\n        col = norm(p.xyz);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 39, 39, 138], [140, 140, 161, 161, 502], [504, 504, 522, 565, 598], [600, 600, 619, 619, 780], [782, 782, 812, 812, 1150], [1152, 1152, 1209, 1209, 1595]], "test": "untested"}
{"id": "wtG3zh", "name": "Evaporation and recondensation", "author": "michael0884", "description": "Thought I should upload this", "tags": ["wave", "fluid"], "likes": 5, "viewed": 343, "published": 3, "date": "1578256540", "time_retrieved": "2024-07-30T21:31:34.399211", "image_code": "// Fork of \"Wavy Fluid*\" by wyatt. https://shadertoy.com/view/wty3Rh\n// 2020-01-05 20:33:13\n\nMain\n{\n    vec4 a = A(U);\n    vec4 b = B(U);\n    float d = 4.*dot(b.xy,b.xy);\n\tQ = sin(2.*d*vec4(1,2,3,4));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define Main void mainImage( out vec4 Q, in vec2 U )\n\n#define F(x) (sqrt(x)+(0.5+0.5*sin(0.35*iTime))*exp(-50.*(x))+U.y*1e-3)\n\n#define dt .8\n#define K .5\n#define Loss .001\n\n#define Border if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q *= 0.;\n#define Init if (iFrame < 1) Q = exp(-.01*length(U-0.5*R))\n#define Mouse if (iMouse.z>0.) Q.xyzw += .5*exp(-.001*dot(U-iMouse.xy,U-iMouse.xy))", "buffer_a_code": "Main\n{\n    vec4 \n         N = A(U+vec2(0,1)), \n         E = A(U+vec2(1,0)), \n         S = A(U-vec2(0,1)), \n         W = A(U-vec2(1,0)),\n         M = 0.25*(N+E+S+W),\n         a = A(U), b = B(U);\n    Q = a + dt*b + Loss*(M-a);\n    \n    Mouse*vec4(1,0,-1,0);\n    \n    Init*vec4(1,0,-1,0);\n    Border\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n{\n    vec4 \n         M = 0.125*(\n         \tA(U+vec2(0,1))+A(U+vec2(1,0))+\n         \tA(U-vec2(0,1))+A(U-vec2(1,0))+\n            A(U+vec2(1,1))+A(U+vec2(1,-1))+\n         \tA(U-vec2(1,1))+A(U-vec2(1,-1))\n         ),\n         a = A(U);\n    float P = F(dot(a.xy,a.xy));\n    Q = B(U) + dt*(M-a-K*a*P);\n    \n    Mouse*vec4(0,K,0,-K);\n    \n    Init*vec4(0,K,0,-K);\n    Border\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wty3Rh", "name": "Wavy Fluid*", "author": "wyatt", "description": "wave fluid", "tags": ["wave", "fluid"], "likes": 11, "viewed": 432, "published": 3, "date": "1578250964", "time_retrieved": "2024-07-30T21:31:35.300801", "image_code": "Main\n{\n    vec4 a = A(U);\n    vec4 b = B(U);\n    vec4 c = C(U);\n    vec4 d = D(U);\n    float e = dot(a,a)+dot(b,b);\n\tQ = sin(a*a+e*vec4(1,2,3,4));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define Main void mainImage( out vec4 Q, in vec2 U )\n\n#define F(x) (abs((x)-.5)+U.y*1e-3)\n\n#define dt .75\n#define K .75\n#define Loss .01\n\n#define Border if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q *= 0.;\n#define Init if (iFrame < 1) Q = exp(-.04*length(U-0.5*R))\n#define Mouse if (iMouse.z>0.) Q.xyzw += .5*exp(-.001*dot(U-iMouse.xy,U-iMouse.xy))", "buffer_a_code": "Main\n{\n    vec4 \n         N = A(U+vec2(0,1)), \n         E = A(U+vec2(1,0)), \n         S = A(U-vec2(0,1)), \n         W = A(U-vec2(1,0)),\n         M = 0.25*(N+E+S+W),\n         a = A(U), b = B(U);\n    Q = a + dt*b + Loss*(M-a);\n    \n    Mouse*vec4(1,0,-1,0);\n    \n    Init*vec4(1,0,-1,0);\n    Border\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n{\n    vec4 \n         M = 0.125*(\n         \tA(U+vec2(0,1))+A(U+vec2(1,0))+\n         \tA(U-vec2(0,1))+A(U-vec2(1,0))+\n            A(U+vec2(1,1))+A(U+vec2(1,-1))+\n         \tA(U-vec2(1,1))+A(U-vec2(1,-1))\n         ),\n         a = A(U);\n    float P = F(length(a));\n    Q = B(U) + dt*(M-a-K*a*P);\n    \n    Mouse*vec4(0,K,0,-K);\n    \n    Init*vec4(0,K,0,-K);\n    Border\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n{\n    vec4 \n         N = A(U+vec2(0,1)), \n         E = A(U+vec2(1,0)), \n         S = A(U-vec2(0,1)), \n         W = A(U-vec2(1,0)),\n         M = 0.25*(N+E+S+W),\n         a = A(U), b = B(U);\n    Q = a + dt*b + Loss*(M-a);\n    \n    Mouse*vec4(1,0,-1,0);\n    \n    Init*vec4(1,0,-1,0);\n    Border\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n{\n    vec4 \n         M = 0.125*(\n         \tA(U+vec2(0,1))+A(U+vec2(1,0))+\n         \tA(U-vec2(0,1))+A(U-vec2(1,0))+\n            A(U+vec2(1,1))+A(U+vec2(1,-1))+\n         \tA(U-vec2(1,1))+A(U-vec2(1,-1))\n         ),\n         a = A(U);\n    float P = F(length(a));\n    Q = B(U) + dt*(M-a-K*a*P);\n    \n    Mouse*vec4(0,K,0,-K);\n    \n    Init*vec4(0,K,0,-K);\n    Border\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wty3Rh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Wty3R1", "name": "Terrain-", "author": "Subash", "description": "new to shaders and raymarch", "tags": ["noise", "raymarch", "beginner"], "likes": 3, "viewed": 278, "published": 3, "date": "1578232394", "time_retrieved": "2024-07-30T21:31:36.185435", "image_code": "#define MAX_DIST 100.\n#define MIN_DIST 0.01\n#define MAX_COUNT 100\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(uv.x * 1033.5 + uv.y) * 23930.58);\n}\nmat2 rotate(float ang){\n    float ca = cos(ang);\n    float sa = sin(ang);\n    return mat2(ca, sa, -sa, ca);\n}\nfloat noise(vec2 uv){\n \tvec2 xy = floor(uv);\n    vec2 frac = fract(uv);\n    frac = frac * frac * (3. - 2. * frac);\n    \n    vec2 bl = xy;\n    vec2 tl = xy + vec2(0.,1.);\n    vec2 br = xy + vec2(1.,0.);\n    vec2 tr = xy + vec2(1.,1.);\n\n    float a = rand(tl);\n    float b = rand(tr);\n    float c = rand(bl);\n    float d = rand(br);\n    \n    float top = mix(a, b, frac.x);\n    float bottom = mix(c, d, frac.x);\n    \n    return mix(bottom, top, frac.y);\n}\n\nfloat fbm(vec2 uv){\n \tfloat res = 0.;\n    float amp = .5;\n    float freq = .5;\n    \n    for(int i = 0; i < 8; ++i)\n    {\n        uv *= rotate(80.);\n        res += amp * noise(uv * freq + 3.0);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\n\nfloat getDist(vec3 p){   \n    float disp = fbm(p.xz*0.08);\n    //return disp;\n    return (p.y+disp*50.)*.3;\n}\n\n\nvec3 normal(vec3 p){\n\tvec2 e = vec2(.001, 0.0);\n    return normalize(vec3(\n    \tgetDist(p + e.xyy) - getDist(p - e.xyy),\n        getDist(p + e.yxy) - getDist(p - e.yxy),\n        getDist(p + e.yyx) - getDist(p - e.yyx)\n    ));\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd){\n \tfloat R0 = 0.;\n    for(int i = 0; i < MAX_COUNT; i++){\n     \tvec3 p = ro + R0 * rd;\n        float d = getDist(p);\n        R0 += d;\n        if(d < MIN_DIST || R0 > MAX_DIST) break;\n    }\n    return R0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy * 100.;\n\tvec3 ro = vec3(0., 2., -30.);\n    ro.xz *= rotate(mouse.x);\n    float zoom = .5;\n    vec3 target = vec3(0.0);\n    ro.z += iTime * 5.;\n    target.z +=iTime * 5.;\n    vec3 ww = normalize(target - ro);\n    vec3 uu = normalize(cross(vec3(0., 1., 0.), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(uu * uv.x + vv * uv.y + ww * zoom);\n    vec3 col = vec3(0.);\n    float d0 = rayMarch(ro, rd);\n    col = vec3(d0)/100.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3R1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 88, 88, 146], [147, 147, 170, 170, 256], [257, 257, 278, 278, 709], [711, 711, 730, 730, 968], [971, 971, 993, 993, 1080], [1083, 1083, 1103, 1103, 1310], [1313, 1313, 1346, 1346, 1551], [1553, 1553, 1610, 1610, 2198]], "test": "untested"}
{"id": "wlyGRz", "name": "Procedural Music Sequencer", "author": "TekF", "description": "Inspired by Andrew Huang's superb introduction to music theory: https://www.youtube.com/watch?v=rgaTLrZGlk0", "tags": ["music"], "likes": 38, "viewed": 884, "published": 3, "date": "1578229574", "time_retrieved": "2024-07-30T21:31:37.155841", "image_code": "// Procedural Music Sequencer\n// by Hazel Quantock 2020\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n\n// Sound code is in ^Sound^ tab\n// This just prints the text\n\n\n// text rendering from: https://www.shadertoy.com/view/WdBXWd\n\n// quality of font anti-aliasing - number of samples doubles with each level of quality\n#define AA_QUALITY 3\n\n// allow a little bleed between pixels - this looks more photographic, but blurrier\n#define AA_ROUND false\n#define AA_ROUND_RADIUS 0.7071\n\n\n// Font Definitions\nstruct Typeface\n{\n    vec2 scale;\n    vec2 padding;\n    vec2 bias;\n    float biasAngle;\n    float threshold;\n};\n\nconst Typeface Deco = Typeface( vec2(.6,.7), vec2(0), vec2(-.02,.025), 0., -.02 );\nconst Typeface Deco_Light = Typeface( vec2(.63,.7), vec2(-1,0), vec2(-.01,.04), 0., -.02 );\n\nconst Typeface Impactful = Typeface( vec2(.5,1), vec2(4,2), vec2(-.02,.01), 0., .01 );\n\nconst Typeface Elegant = Typeface( vec2(.6,.9), vec2(-2,0), vec2(.05,-.005), -1.04, -.022 );\nconst Typeface Elegant_Condensed = Typeface( vec2(.5,1.), vec2(0,1), vec2(.0,.1), -1., -.02 );\n\nconst Typeface Timely = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.0), -.5, -.02 );\nconst Typeface Timely_Light = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.02,.02), -.5, -.01 );\nconst Typeface Timely_Heavy = Typeface( vec2(.8,.7), vec2(4,1), vec2(-.03,.02), 2.5, .01 );\n\nconst Typeface Neat = Typeface( vec2(.6,.7), vec2(-1,1), vec2(-.017,.02), -.3, -.02 );\n\nconst Typeface Comic = Typeface( vec2(.8,.7), vec2(2,1), vec2(-.05,.0), 1., -.02 );\nconst Typeface Comic_Title = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.0), 1., .0 );\n\nconst Typeface WildWest = Typeface( vec2(.9), vec2(2,0), vec2(-.05,.0), 0., -.02 );\nconst Typeface WildWest_Wide = Typeface( vec2(1,.7), vec2(0,2), vec2(.05,.0), 0., .02 );\n\nconst Typeface Gothic = Typeface( vec2(.9,.7), vec2(0,2), vec2(.05,.0), 1., .01 );\nconst Typeface Gothic_Light = Typeface( vec2(.9,.7), vec2(0,2), vec2(.05,.0), 1., -.01 );\nconst Typeface Gothic_Condensed = Typeface( vec2(.5,1.), vec2(0), vec2(.05,.0), -1.04, .02 );\nconst Typeface Gothic_Book = Typeface( vec2(.6,.7), vec2(0,2), vec2(.1,.0), 1., .0 );\n\nconst Typeface Haunted = Typeface( vec2(.75,.9), vec2(2,0), vec2(.0,.03), 0., .01 );\nconst Typeface Haunted_Condensed = Typeface( vec2(.5,1), vec2(4,0), vec2(-.02,.03), 0., .01 );\nconst Typeface Haunted_Script = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.05), .7, .0 );\n\n// Round-tipped font (actually not round in close-up)\nconst Typeface Round = Typeface( vec2(1), vec2(0,6), vec2(-.02,-.02), 0., -.01 );\nconst Typeface Round_Bold = Typeface( vec2(1), vec2(4,6), vec2(-.04,-.04), 0., -.01 );\n\n\n\nfloat RenderFont_NoAA\n    (\n        vec2 uv,\n        Typeface font,\n        uint text[10]\n    )\n{\n    // each char is in a 64x64 space, trim off the white boundary\n    vec2 charBottomLeft = vec2(18,3) - font.padding/2.;\n    vec2 charDims = vec2(28,52) + font.padding;\n\n    uv = uv/font.scale; //+vec2(iTime*200.,0);\n    \n    if ( uv.x < 0. || uv.y < .0 || uv.y >= charDims.y ) return 1.;\n    \n    uint index = uint(uv.x/charDims.x);\n    ivec2 res = ivec2(iResolution.xy);\n    uint index4 = index/4u;\n\n    if ( index4 >= uint(text.length()) ) return 1.;\n    \n    uint char = ( text[index4] >> (8u*(index&3u)) )&0xffu;\n    \n    char = char^0xf0u; // flip the y coord\n    \n    uv.x = fract(uv.x/charDims.x)*charDims.x;\n    uv += vec2(ivec2(char&0xfu,char>>4u)) * iChannelResolution[0].xy/16.;\n    uv += charBottomLeft;\n                            \n    vec4 v = texture( iChannel0, uv/iChannelResolution[0].xy ) -.5;\n                            \n    vec2 bias = 2.*v.yz;\n    bias = bias*cos(font.biasAngle) + bias.yx*sin(font.biasAngle)*vec2(1,-1);\n    bias = pow(abs(bias),vec2(3));\n    \n    // view the SDF\n//    float f = v.w + dot( font.bias, bias ) - font.threshold; return .5+.5*f/(abs(f)+.04);\n    \n    return step( font.threshold, v.w + dot( font.bias, bias ) );\n}\n\n\n\n// RenderFont\n//\n// Output:\n//\t\tA linear brightness value where 0 = text, 1 = background.\n//\t\tI recommend applying a gamma curve before displaying.\n//\n// uv\n//\t\tRelative to the bottom left of the line of text, most fonts are about 40 units tall\n//\n// font\n//\t\tOne of the Typefaces defined earlier\n//\n// text\n//\t\tA line of text, encoded using my tool here: https://tekf.github.io/Misc-Tools/StringToHex.html\n//\t\tEach byte is 4-bit u, 4-bit v coord of a character in the font texture.\n//\nfloat RenderFont\n    (\n        vec2 uv,\n        Typeface font,\n\t\tuint text[10]\n    )\n{\n    const int numSamples = 1<<(AA_QUALITY);\n    \n    float sum = 0.;\n    vec2 duvdx = dFdx(uv); // adjust anti aliasing without needing to know what scale we're working at!\n    vec2 duvdy = dFdy(uv);\n\n    // anti-alias the font\n    // this would be more efficient run per-character inside the font render function\n    // (the SDFs on some of the fonts are good enough that I could probably just soften the step function)\n    for ( int i=0; i < numSamples; i++ )\n    {\n        // ideal 2D quasirandom sequence from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n        uvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\n        uint seed = uint(i);\n        //seed += uint(iFrame*numSamples); // randomize per frame - causes shimmering\n        //seed += uint(fragCoord.x)*quasi2.x+uint(fragCoord.y)*quasi2.y; // randomize per pixel - this looks bad at low sample counts (and at high counts it's less important)\n        vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n\n        if ( AA_ROUND )\n        {\n            // circle of confusion slightly bigger than a pixel - should look more photographic\n            jitter.x *= 6.283185;\n            jitter = AA_ROUND_RADIUS*(1.-jitter.y*jitter.y)*vec2(cos(jitter.x),sin(jitter.x));\n        }\n        else\n        {\n            jitter -= .5;\n        }\n\n        sum += RenderFont_NoAA( uv + jitter.x*duvdx + jitter.y*duvdy, font, text );\n    }\n   \n    return sum/float(numSamples);\n}\n\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-vec2(20,0))*400./iResolution.y;\n\n    // Text encoded using my tool here: https://tekf.github.io/Misc-Tools/StringToHex.html\n\tfloat f = RenderFont( uv-vec2(135,160), Round_Bold, uint[]( 0x6f53200bU, 0x20646e75U, 0x0b206e4fU, 0x20202020u, 0x20202020u, 0x20202020u, 0x20202020u, 0x20202020u, 0x20202020u, 0x20202020u ) );\n    \n    if ( iTime > 5. )\n    \tf = min( f, RenderFont( uv-vec2(0,0), Neat,\n            // It used to regenerate on rewind, but apparently iDate is now captured when the page loads\n            //uint[]( 0x72502013U, 0x20737365U, 0x69776572U, 0x7420646eU, 0x6567206fU, 0x20612074U, 0x66666964U, 0x6e657265U, 0x75742074U, 0x2021656eU )\n            uint[]( 0x65522020U, 0x64616f6cU, 0x67617020U, 0x6f742065U, 0x74656720U, 0x64206120U, 0x65666669U, 0x746e6572U, 0x6e757420U, 0x20202165U ) // length 40 = 0x28\n        ) );\n    \n    // Output to screen\n    fragColour.rgb = mix( vec3(0), vec3(1), f );\n    \n    // flash the screen when we start to give visual feedback when people press rewind\n    fragColour.rgb *= smoothstep(0.,1.,iTime);\n    \n    fragColour.rgb = pow( fragColour.rgb, vec3(1./2.2) );\n    fragColour.a = 1.;\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// Procedural Music Sequencer\n// by Hazel Quantock 2020\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) ((p)*M1)\n#define coord2(p) ((p).x*M1^(p).y*M2)\n#define coord3(p) ((p).x*M1^(p).y*M2^(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\n\nint key;\nfloat bps;\n\nint majorScale( int index )\n{\n    return (index*12)/7; //0,2,4,6,7,9,11,12,14,16,18,19,...\n}\n\nint pentatonicScale( int index )\n{\n    return (index*12)/5; //0,2,4,7,9,12,14,16,19,...\n}\n\nfloat frequency( int note )\n{\n    return 440. * exp2( float(note + key) / 12. );\n}\n\nvec2 triangleWave( int note, float time )\n{\n    return fract(vec2(0,0)+frequency(note)*time)*2.-1.;\n}\n\nvec2 squareWave( int note, float time )\n{\n    return step(.5,fract(vec2(0,0)+frequency(note)*time))*2.-1.;\n}\n\nvec2 sineWave( int note, float time )\n{\n    return sin(6.283185*( vec2(0,0)+frequency(note)*time ));\n}\n\nvoid beat( out int i, out float f, float beatLength, float time )\n{\n    f = time*bps/beatLength;\n    i = int(floor( f ));\n    f -= float(i);\n}\n\nint invert( int note, int inversion )\n{\n    return ((note+48-inversion)%12)+inversion;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n\t// emulate lower sample rate\n//\ttime = floor(time*5000.f)/5000.f;\n\t// emulate lower quality float (gradually loses precision over time)\n//\tfloat e = exp2( floor(log2(time)) - 16. ); // number of mantissa bits (roughly)\n//\ttime = floor( time/e ) * e;\n    \n    // YES!! iDate.w changes every time and sound is regenerated on rewind!\n    uint seed = coord1(uint(iDate.w));//uvec3(iDate));\n    vec4 rand = hash4(seed);\n    seed = coord1(seed);\n    \n    // todo: vary these on initialisation\n    key = int(rand.x*12.999)-15;//-9; // relative to middle A\n    int inversion = int(rand.y*12.999)-5;\n    bps = 140./60.;\n    ivec4 triads = ivec4(hash4(seed)*6.999);\n    seed = coord1(seed);\n    \n    int beatsPerBar = 4*int(exp2(floor(rand.y*2.999)));\n    int barsPerPhrase = 4; // this currently has to match the number of triads\n    \n    // timings\n// this would be neater with a function taking number of beats returning int and float\n// which would also work for arp\n    int beat = int(floor(time*bps));\n    float beatf = time*bps-float(beat);\n    int bar = beat/beatsPerBar;\n    float barf = (float(beat-bar*beatsPerBar)+beatf)/float(beatsPerBar);\n    int phrase = bar/barsPerPhrase;\n    float phrasef = (float(bar-phrase*barsPerPhrase)+barf)/float(barsPerPhrase);\n// todo: have verse phrase, chorus phrase alternate a few times, then bridge phrase and final chorus phrase\n// only difference between phrases should be random seed\n\n    int barInPhrase = bar%barsPerPhrase;\n    int beatInBar = beat%beatsPerBar;\n    int beatInPhrase = beat%(beatsPerBar*barsPerPhrase);\n\n    // note frequencies are: exp2(i/12.+octave)*baseFreq\n    \n    // 6 triads = alternate notes in the scale, starting on the first 6 notes\n    \n    // pick a triad for the bar\n    int triadBaseNote = triads[barInPhrase];\n\n    // invert the triads into the same range\n    ivec3 triad =\n        ivec3(\n        \tinvert(majorScale(triadBaseNote),inversion),\n        \tinvert(majorScale(triadBaseNote+2),inversion),\n        \tinvert(majorScale(triadBaseNote+4),inversion)\n        );\n    \n    // sort these notes! this is important for arp and bass\n    if ( triad.x < triad.y )\n    {\n        if ( triad.y < triad.z ) triad.xyz = triad.xyz;\n        else if ( triad.x < triad.z ) triad.xyz = triad.xzy;\n            else triad.xyz = triad.zxy;\n    }\n    else\n    {\n        if ( triad.x < triad.z ) triad.xyz = triad.yxz;\n        else if ( triad.y < triad.z ) triad.xyz = triad.yzx;\n            else triad.xyz = triad.zyx;\n    }\n\n    vec2 f = vec2(0);\n    \n    // play the chord as pads\n    float padAmp = .1*smoothstep(0.,.15,barf)*smoothstep(1.,.5,barf);\n    f += (triangleWave(triad[0],time) + triangleWave(triad[1],time) + triangleWave(triad[2],time))*padAmp;\n    \n    // arpeggiator\n    int arpPerBeat = int(floor(pow(rand.w,2.)*4.999))+2; // I thought 5 would sound bad but it's ok actually\n    float arpf = time*bps * float(arpPerBeat);\n    int arpb = int(floor(arpf));\n    arpf -= float(arpb);\n    \n    // run through the notes of the triad\n    vec4 randArp = hash4(seed);\n    vec4 randArp2 = hash4(coord2(uvec2(seed,barInPhrase)));\n    seed = coord1(seed);\n    int range = int(randArp2.y*5.999+3.); // use arp2 so range changes from bar to bar, sounds more interesting\n    int arpNote =\n        randArp.z > .5 ?\n        abs(((arpb+int(randArp.x*100.999))%(range*2))-(range-1)) // yoyo\n    \t: arpb%range; // ascending\n    arpNote += int(randArp.w*5.999)-2;\n    float arpAmp = .1*step(arpf,.5);//smoothstep(0.,.001,arpf)*smoothstep(.5,.499,arpf);//pow(1.-arpf,2.);\n    \n    int octFudge = 2; // mods go wrong on -ves\n    arpNote += octFudge*3;\n    f += squareWave(triad[arpNote%3] + 12*(arpNote/3 - octFudge),time)*arpAmp;\n    \n    \n    // bass line - play the bottom note of the chord in a random rhythm\n\t// it's ok but the randomness is a bit too random\n    if ( hash1(coord2(uvec2(seed,barInPhrase)))*.9+.1 > hash1(coord2(uvec2(beatInBar,seed)))*2.*float(beatInBar)/float(beatsPerBar) )\n    {\n        float bassAmp = .25*smoothstep(.0,.001,beatf)*pow(1.-beatf,1.);\n        int note = triad[0];\n        int vary = int(20.999*hash1(coord2(uvec2(beatInPhrase,seed))));\n        // I thought this would sound good but it really doesn't\n        //if ( vary < 5 ) note = invert( pentatonicScale(vary), inversion-6 );\n        if ( vary < 5 ) note = triad[2]-12;\n        if ( vary < 2 ) note = triad[1];\n        f += mix(\n            \tsineWave(note-12,time)*3.,\n            \ttriangleWave(note-24,time),\n            //mix(0.,.5,pow(1.-beatf,2.))) // quite a nice pluck effect\n            mix(0.,.3+.4*hash1(coord1(uint(beat))),pow(1.-beatf,3.))) // add a little randomness to the \"harshness\" of the pluck\n            * bassAmp;\n    }\n    \n    \n    // todo: Melody\n    // more complicated rhyhm than bass\n    // pick notes randomly from the pentatonic scale for the melody\n    // but start and end each phrase with a note from the triad\n    \n    \n    return f*.3;\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGRz.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[4000, 4486, 4572, 4572, 6031]], "test": "untested"}
{"id": "ttVGzz", "name": "schrodinger fluid", "author": "unnick", "description": "more info in the comments of the code\nclick to make the sim faster: [url]JAVASCRIPT:H=location.host;E=(H?window:opener).Effect;P=E.prototype;if(!E.P)E.P=P.Paint;P.Paint=function(...A){for(i=0;i<4;i++)E.P.apply(this,A);};if(!H)close();[/url]", "tags": ["test"], "likes": 9, "viewed": 536, "published": 3, "date": "1578220431", "time_retrieved": "2024-07-30T21:31:37.919798", "image_code": "/* more info:\n *\n * apparently you can simulate fluids using the schrodinger equations!\n *\n *   i learned about this from this guy:   https://www.shadertoy.com/view/WtyGzz\n * who learned about this from this guy:   https://www.shadertoy.com/view/tsyGWG\n * who learned about this from this paper: http://page.math.tu-berlin.de/~chern/projects/PhDThesis/thesis_reduced.pdf\n * archived link: https://web.archive.org/web/20200105155955/http://page.math.tu-berlin.de/~chern/projects/PhDThesis/thesis_reduced.pdf\n */\n\nvoid mainImage(out vec4 col, in vec2 pos) {\n    vec4 state = fetch(pos);\n    //col = normalize(state.xy).xyxy * .5 + .5; return;\n    float tmp = dot(state.xy, state.xy)*.5;\n    col = mix(vec4(1), vec4(0,.5,1,1), min(tmp, 1.));\n    col *= min(2.-tmp, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 state, in vec2 pos) {\n    state = fetch(pos);\n    vec4 r1 = fetch(pos+vec2(1,0)),\n         r2 = fetch(pos+vec2(2,0)),\n         u1 = fetch(pos+vec2(0,1)),\n         u2 = fetch(pos+vec2(0,2)),\n         l1 = fetch(pos-vec2(1,0)),\n         l2 = fetch(pos-vec2(2,0)),\n         d1 = fetch(pos-vec2(0,1)),\n         d2 = fetch(pos-vec2(0,2)),\n         L = ((r1+u1+l1+d1)*8. + (r2+u2+l2+d2)*1. - state*36.) * scale;\n    \n    state.xy += dt*L.xy*smoothing;\n    \n    float p  = pressure(dot(state.xy, state.xy));\n          p  = min(p, max_p);\n          p += pos.y/iResolution.y*grav;\n    \n    state.zw += dt*(L.xy - state.xy*p);\n    state.xy += dt*state.zw;\n    \n    state = mix(state, vec4(1,0,0,1), smoothstep(30., 25., length(iMouse.xy - pos)) * step(.5,iMouse.z)); //mouse stuff idk\n    if(iFrame < 1) state = vec4(2,0,0,2) * smoothstep(.8, .7, length(res.xy - pos*2.) / iResolution.y);\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define fetch(p) texture(iChannel0, (p)/iResolution.xy)\n\n#define dt .2\n#define grav 2.\n#define max_p 3.\n#define smoothing 2.3e-3\n#define scale (6. / 24.)\n\nfloat pressure(float x) { //x = density\n    return pow(abs(x-1.), 3.) + 1./(1.+10.*sqrt(x));\n}\n\n#define res (iResolution.xy)\n", "buffer_b_code": "void mainImage(out vec4 state, in vec2 pos) {\n    state = fetch(pos);\n    vec4 r1 = fetch(pos+vec2(1,0)),\n         r2 = fetch(pos+vec2(2,0)),\n         u1 = fetch(pos+vec2(0,1)),\n         u2 = fetch(pos+vec2(0,2)),\n         l1 = fetch(pos-vec2(1,0)),\n         l2 = fetch(pos-vec2(2,0)),\n         d1 = fetch(pos-vec2(0,1)),\n         d2 = fetch(pos-vec2(0,2)),\n         L = ((r1+u1+l1+d1)*8. + (r2+u2+l2+d2)*1. - state*36.) * scale;\n    \n    state.xy += dt*L.xy*smoothing;\n    \n    float p  = pressure(dot(state.xy, state.xy));\n          p  = min(p, max_p);\n          p += pos.y/iResolution.y*grav;\n    \n    state.zw += dt*(L.xy - state.xy*p);\n    state.xy += dt*state.zw;\n    \n    state = mix(state, vec4(1,0,0,1), smoothstep(30., 25., length(iMouse.xy - pos)) * step(.5,iMouse.z)); //mouse stuff idk\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 state, in vec2 pos) {\n    state = fetch(pos);\n    vec4 r1 = fetch(pos+vec2(1,0)),\n         r2 = fetch(pos+vec2(2,0)),\n         u1 = fetch(pos+vec2(0,1)),\n         u2 = fetch(pos+vec2(0,2)),\n         l1 = fetch(pos-vec2(1,0)),\n         l2 = fetch(pos-vec2(2,0)),\n         d1 = fetch(pos-vec2(0,1)),\n         d2 = fetch(pos-vec2(0,2)),\n         L = ((r1+u1+l1+d1)*8. + (r2+u2+l2+d2)*1. - state*36.) * scale;\n    \n    state.xy += dt*L.xy*smoothing;\n    \n    float p  = pressure(dot(state.xy, state.xy));\n          p  = min(p, max_p);\n          p += pos.y/iResolution.y*grav;\n    \n    state.zw += dt*(L.xy - state.xy*p);\n    state.xy += dt*state.zw;\n    \n    state = mix(state, vec4(1,0,0,1), smoothstep(30., 25., length(iMouse.xy - pos)) * step(.5,iMouse.z)); //mouse stuff idk\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 state, in vec2 pos) {\n    state = fetch(pos);\n    vec4 r1 = fetch(pos+vec2(1,0)),\n         r2 = fetch(pos+vec2(2,0)),\n         u1 = fetch(pos+vec2(0,1)),\n         u2 = fetch(pos+vec2(0,2)),\n         l1 = fetch(pos-vec2(1,0)),\n         l2 = fetch(pos-vec2(2,0)),\n         d1 = fetch(pos-vec2(0,1)),\n         d2 = fetch(pos-vec2(0,2)),\n         L = ((r1+u1+l1+d1)*8. + (r2+u2+l2+d2)*1. - state*36.) * scale;\n    \n    state.xy += dt*L.xy*smoothing;\n    \n    float p  = pressure(dot(state.xy, state.xy));\n          p  = min(p, max_p);\n          p += pos.y/iResolution.y*grav;\n    \n    state.zw += dt*(L.xy - state.xy*p);\n    state.xy += dt*state.zw;\n    \n    state = mix(state, vec4(1,0,0,1), smoothstep(30., 25., length(iMouse.xy - pos)) * step(.5,iMouse.z)); //mouse stuff idk\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVGzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[512, 512, 555, 555, 768]], "test": "untested"}
{"id": "tl3GW2", "name": "Portal 1", "author": "tmst", "description": "- Standard \"Escher-Droste\" effect with a procedural terrain and skybox.\n- Use mouse drag to change some parameters.", "tags": ["procedural", "terrain", "droste", "escher", "aurora", "desert"], "likes": 154, "viewed": 2718, "published": 3, "date": "1578203120", "time_retrieved": "2024-07-30T21:31:39.221318", "image_code": "#define TWOPI 6.283185307179586\n\n#define IMAGE_ASPECT_WIDTH_OVER_HEIGHT 1.0\n\n#define FIXED_UP vec3(0.0, 1.0, 0.0)\n#define TAN_HALF_FOVY 0.7673269879789604\n#define CAM_Z_NEAR 0.1\n#define CAM_Z_FAR 50.0\n\n#define MIN_DIST 0.005\n#define MAX_DIST 50.0\n#define RAY_STEPS 30\n#define RAY_STEPS_SHADOW 10\n#define POM_QUALITY 100\n#define POM_QUALITY_REFL 40\n\n#define TEX_SCALE 40.0\n#define BUMP_TEX_DEPTH 0.12\n#define BOUNDARY_RADIUS 0.2\n#define PLANE_DEPTH 3.0\n#define NV_PLANE_N vec3(0.0, 1.0, 0.0)\n\n#define TWIST\n#define TWIST_EXPONENT 1.0\n#define DROSTE\n\n// =============================================\n// Some generic helpers\n// =============================================\n\n// Find t so that mix(a,b,t) = x\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nfloat lensq(vec3 p, vec3 q) {\n    vec3 pq = q - p;\n    return dot(pq, pq);\n}\n\nfloat hitPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p, vec3 v) {\n    return dot(planePoint - p, nvPlaneN) / dot(v, nvPlaneN);\n}\n\nmat4 getClipToWorld(float aspectWoverH, vec3 nvCamFw) {\n    mat4 clipToEye = mat4(\n        aspectWoverH * TAN_HALF_FOVY, 0.0, 0.0, 0.0,\n        0.0, TAN_HALF_FOVY, 0.0, 0.0,\n        0.0, 0.0,  0.0, (CAM_Z_NEAR - CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR),\n        0.0, 0.0, -1.0, (CAM_Z_NEAR + CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR)\n    );\n\n    vec3 nvCamRt = normalize(cross(nvCamFw, FIXED_UP));\n    vec3 nvCamUp = cross(nvCamRt, nvCamFw);\n    mat4 eyeToWorld = mat4(\n         nvCamRt, 0.0,\n         nvCamUp, 0.0,\n        -nvCamFw, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return eyeToWorld * clipToEye;\n}\n\nvec3 nvDirFromClip(mat4 clipToWorld, vec2 clip) {\n    vec4 world = clipToWorld * vec4(clip, 1.0, 1.0);\n    return normalize(world.xyz / world.w);\n}\n\nvoid computeLighting(\n    in float diffuseCoefficient,\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 lightColor,\n    in vec3 texColor,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam,\n    out vec3 diffuse,\n    out vec3 specular\n) {\n    float valDiffuse = max(0.0, dot(nvNormal, nvFragToLight));\n    valDiffuse *= diffuseCoefficient;\n\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    diffuse = valDiffuse * texColor * lightColor;\n    specular = valSpecular * lightColor;\n}\n\n// =============================================\n// \"Portal object\" rendering\n// =============================================\n\nvec3 cpPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p) {\n    float t = dot(p - planePoint, nvPlaneN);\n    return p - t*nvPlaneN;\n}\n\nvec3 cpSeg(vec3 q0, vec3 q1, vec3 p) {\n    vec3 vEdge = q1 - q0;\n    float t = dot(p - q0, vEdge) / dot(vEdge, vEdge);\n    return q0 + clamp(t, 0.0, 1.0)*vEdge;\n}\n\nvec3 cpTuple2(vec3 q0, vec3 q1, vec3 p) {\n    vec3 q = q0;\n    return mix(q, q1, step( lensq(p,q1), lensq(p,q) ));\n}\n\nvec3 cpTuple3(vec3 q0, vec3 q1, vec3 q2, vec3 p) {\n    vec3 q = cpTuple2(q0,q1, p);\n    return mix(q, q2, step( lensq(p,q2), lensq(p,q) ));\n}\n\nvec3 cpTuple4(vec3 q0, vec3 q1, vec3 q2, vec3 q3, vec3 p) {\n    vec3 q = cpTuple3(q0,q1,q2, p);\n    return mix(q, q3, step( lensq(p,q3), lensq(p,q) ));\n}\n\nvec3 cpTriBoundary(vec3 q0, vec3 q1, vec3 q2, vec3 p) {\n    return cpTuple3(cpSeg(q0,q1, p), cpSeg(q1,q2, p), cpSeg(q2,q0, p), p);\n}\n\nvec3 cpQuadBoundary(vec3 q0, vec3 q1, vec3 q2, vec3 q3, vec3 p) {\n    return cpTuple4(\n        cpSeg(q0,q1, p), cpSeg(q1,q2, p),\n        cpSeg(q2,q3, p), cpSeg(q3,q0, p), p\n    );\n}\n\nfloat pointInTri(vec3 q0, vec3 q1, vec3 q2, vec3 p) {\n    vec3 v01 = cross(q1-q0, p-q0);\n    vec3 v12 = cross(q2-q1, p-q1);\n    vec3 v20 = cross(q0-q2, p-q2);\n    return step(0.0, dot(v01,v12)) * step(0.0, dot(v01,v20));\n}\n\nvec3 cpTri(vec3 q0, vec3 q1, vec3 q2, vec3 p) {\n    vec3 nvPlaneN = normalize(cross(q1-q0, q2-q0));\n    vec3 xp = cpPlane(q0, nvPlaneN, p);\n    return mix(cpTriBoundary(q0,q1,q2, p), xp, pointInTri(q0,q1,q2, xp));\n}\n\nvec3 cpQuad(vec3 q0, vec3 q1, vec3 q2, vec3 q3, vec3 p) {\n    return cpTuple2(cpTri(q0,q1,q2, p), cpTri(q0,q2,q3, p), p);\n}\n\nfloat sdQuadBoundary(vec3 q0, vec3 q1, vec3 q2, vec3 q3, float r, vec3 p) {\n    vec3 x = cpQuadBoundary(q0,q1,q2,q3, p);\n    return distance(x, p) - r;\n}\n\nvec3 normalQuadBoundary(vec3 q0, vec3 q1, vec3 q2, vec3 q3, vec3 p) {\n    vec3 x = cpQuadBoundary(q0,q1,q2,q3, p);\n    return normalize(p - x);\n}\n\nfloat sdQuad(vec3 q0, vec3 q1, vec3 q2, vec3 q3, float r, vec3 p) {\n    vec3 x = cpQuad(q0,q1,q2,q3, p);\n    return distance(x, p) - r;\n}\n\nvoid hitObject(\n    in vec3 startPos, in vec3 nvRayDir,\n    in vec3 q00, in vec3 q10, in vec3 q11, in vec3 q01,\n    out float didHit, out vec3 hitPos\n){\n    didHit = 0.0;\n    float travel = 0.0;\n    vec3 curPos = startPos;\n\n    for (int k = 0; k < RAY_STEPS; k++) {\n        float sdCur = sdQuadBoundary(q00,q10,q11,q01, BOUNDARY_RADIUS, curPos);\n\n        if (sdCur < MIN_DIST) {\n            didHit = 1.0;\n            break;\n        }\n\n        curPos += sdCur * nvRayDir;\n        travel += sdCur;\n        if (travel > MAX_DIST) {\n            break;\n        }\n    }\n\n    hitPos = curPos;\n}\n\nvoid hitShadow(\n    in vec3 startPos, in vec3 nvRayDir,\n    in vec3 q00, in vec3 q10, in vec3 q11, in vec3 q01,\n    out float lightPercent\n){\n    lightPercent = 1.0;\n    float travel = 0.0;\n    vec3 curPos = startPos;\n\n    for (int k = 0; k < RAY_STEPS_SHADOW; k++) {\n        float sdCur = sdQuad(q00,q10,q11,q01, BOUNDARY_RADIUS, curPos);\n\n        float curLightPercent = abs(sdCur)/(0.02*travel);\n        lightPercent = min(lightPercent, curLightPercent);\n\n        if (sdCur < MIN_DIST) {\n            lightPercent = 0.0;\n            break;\n        }\n\n        curPos += sdCur * nvRayDir;\n        travel += sdCur;\n        if (travel > MAX_DIST) {\n            break;\n        }\n    }\n}\n\n// =============================================\n// Terrain and sky rendering\n// =============================================\n\nvec4 bumpTex(vec2 uv) {\n    float r = textureLod(iChannel0, uv, 0.0).r;\n\n    float ang = (r + fract(uv.x) + fract(uv.y)) * TWOPI;\n    vec2 q = uv + 0.1*vec2( cos(ang), sin(ang) );\n\n    float height = textureLod(iChannel0, q, 0.0).r;\n    vec3 color = mix(vec3(0.0), vec3(1.0, 0.2, 0.1), height);\n\n    return vec4(color, height);\n}\n\nvec2 skyTex(vec2 uv) {\n    vec4 data = textureLod(iChannel0, uv, 0.0);\n\n    float starIntensity = data.b;\n    \n    float ang = (data.g + iTime*0.1) * TWOPI;\n    vec2 q = uv + 0.05*vec2( cos(ang), sin(ang) );\n    float cloudIntensity = textureLod(iChannel0, q, 0.0).g;\n    \n    return vec2(cloudIntensity, starIntensity);\n}\n\nvec3 bumpTexNormal(vec2 uv) {\n    vec2 uvPixel = 1.0 / iResolution.xy;\n    float hSA = bumpTex(uv + vec2(-uvPixel.s, 0.0)).a;\n    float hSB = bumpTex(uv + vec2( uvPixel.s, 0.0)).a;\n    float hTA = bumpTex(uv + vec2(0.0,-uvPixel.t)).a;\n    float hTB = bumpTex(uv + vec2(0.0, uvPixel.t)).a;\n\n    vec2 dhdt = vec2(hSB-hSA, hTB-hTA) / (2.0 * uvPixel);\n    vec2 gradh = BUMP_TEX_DEPTH * dhdt;\n    return normalize(vec3( -gradh, 1.0 ));\n}\n\nvec3 skyColor(vec3 nvDir) {\n    float yy = clamp(nvDir.y+0.1, 0.0, 1.0);\n    float horiz0 = pow(1.0 - yy, 30.0);\n    float horiz1 = pow(1.0 - yy, 5.0);\n    \n    vec3 sv = nvDir - vec3(0.0, -1.0, 0.0);\n    vec2 uvCloud = 0.25*(sv.xz / sv.y) + vec2(0.5);\n    vec2 skyTexVal = skyTex(uvCloud);\n\n    float cloudIntensity = pow(skyTexVal.x, 2.0);\n    float starIntensity = pow(skyTexVal.y, 2.0);\n\n    vec3 c = vec3(0.0);\n    c = mix(c, vec3(0.2, 0.0, 0.5), horiz1);\n    c = mix(c, vec3(1.0), horiz0);\n    c = mix(c, vec3(0.45, 0.5, 0.48), (1.0-horiz0)*cloudIntensity);\n    c = mix(c, vec3(1.0), (1.0-horiz1)*starIntensity);\n    return c;\n}\n\nvoid getParallaxMaxOffsets(\n    in vec3 tangentS,\n    in vec3 tangentT,\n    in vec3 nvNormal,\n    in vec3 camToFrag,\n    in float depthMax,\n    out vec2 maxTexOffset,\n    out vec3 maxPosOffset\n){\n    // Scale camToFrag so that its depth into the surface == depthMax\n    float camDist = -dot(camToFrag, nvNormal);\n    maxPosOffset = (depthMax / camDist) * camToFrag;\n\n    // maxPosOffset = a*tangentS + b*tangentT + N <=> maxTexOffset = [a,b]\n    float dss = dot(tangentS, tangentS);\n    float dst = dot(tangentS, tangentT);\n    float dtt = dot(tangentT, tangentT);\n    float dcs = dot(maxPosOffset, tangentS);\n    float dct = dot(maxPosOffset, tangentT);\n    float invDet = 1.0 / (dss * dtt - dst * dst);\n    maxTexOffset = invDet * vec2(dtt*dcs - dst*dct, -dst*dcs + dss*dct);\n}\n\nfloat getParallaxDepthFactor(vec2 uvInitial, vec2 maxTexOffset, int steps) {\n    vec2 uvMax = uvInitial + maxTexOffset;\n    float dt = 1.0 / float(steps);\n\n    float tOld = 0.0, depthOld = 0.0;\n    float tCur = 0.0, depthCur = 0.0;\n\n    for(int i=0; i<=steps; ++i){\n        tOld = tCur;\n        tCur = float(i)*dt;\n\n        depthOld = depthCur;\n        depthCur = 1.0 - bumpTex(mix(uvInitial, uvMax, tCur)).a;\n\n        if(tCur > depthCur){\n            tCur = mix(tOld, tCur, unmix(depthOld-tOld, depthCur-tCur, 0.0));\n            break;\n        }\n    }\n\n    return tCur;\n}\n\nvoid terrainAndSky(\n    in vec3 startPos, in vec3 nvRayDir, in vec3 lightPos, in int pomSteps,\n    in vec3 q00, in vec3 q10, in vec3 q11, in vec3 q01,\n    out vec3 hitColor\n) {\n    float tPlane = hitPlane(\n        vec3(0.0, -PLANE_DEPTH, 0.0), NV_PLANE_N,\n        startPos, nvRayDir\n    );\n    float didHitPlane = step(0.0, tPlane);\n\n    if (didHitPlane > 0.5) {\n\n        vec3 hitPos = startPos + tPlane*nvRayDir;\n        vec2 hitTex = hitPos.xz / TEX_SCALE;\n\n        vec2 maxTexOffset;\n        vec3 maxPosOffset;\n        getParallaxMaxOffsets(\n            vec3(TEX_SCALE, 0.0, 0.0),\n            vec3(0.0, 0.0, TEX_SCALE),\n            vec3(0.0, 1.0, 0.0),\n            hitPos - startPos,\n            BUMP_TEX_DEPTH * TEX_SCALE,\n            maxTexOffset,\n            maxPosOffset\n        );\n        float depthPct = getParallaxDepthFactor(hitTex, maxTexOffset, pomSteps);\n        vec2 hitTexBump = hitTex + depthPct*maxTexOffset;\n        vec3 hitPosBump = hitPos + depthPct*maxPosOffset;\n\n        vec3 bumpColor = bumpTex(hitTexBump).rgb;\n        vec3 nvNormal = bumpTexNormal(hitTexBump);\n        vec3 nvBumpNormal = normalize(vec3(nvNormal.x, 1.0, nvNormal.y));\n\n        if (distance(startPos, hitPosBump) < MAX_DIST) {\n\n            // Hit terrain: Compute fog, lighting, and shadow\n\n            vec3 nvBumpPosToLight = normalize(lightPos - hitPosBump);\n            vec3 vBumpPosToStart = startPos - hitPosBump;\n            float dHit = length(vBumpPosToStart);\n            vec3 nvBumpPosToStart = vBumpPosToStart / dHit;\n\n            float lightPercent = 1.0;\n            hitShadow(\n                hitPosBump, nvBumpPosToLight,\n                q00,q10,q11,q01,\n                lightPercent\n            );\n            lightPercent *= mix(1.0, 0.0, depthPct);\n\n            vec3 diffuse;\n            vec3 specular;\n            computeLighting(\n                0.8, 0.3, 5.0,\n                vec3(1.0), bumpColor,\n                nvBumpNormal, nvBumpPosToLight, nvBumpPosToStart,\n                diffuse, specular\n            );\n            vec3 ambient = 0.1 * bumpColor;\n            vec3 matColor = ambient + lightPercent*(diffuse + specular);\n\n            float fogMin = 0.0;\n            float fogMax = 0.8;\n            vec3 fogColor = vec3(0.9, 0.8, 1.0);\n            float fogT = mix(fogMin, fogMax, unmix(0.0, MAX_DIST, dHit) );\n            float fogAmount = pow(fogT, 1.5);\n\n            hitColor = mix(matColor, fogColor, fogAmount);\n\n        } else {\n\n            // Too far, use skybox\n            hitColor = skyColor(nvRayDir);\n\n        }\n\n    } else {\n\n        // Didn't hit plane, use skybox\n        hitColor = skyColor(nvRayDir);\n    }\n}\n\n// =============================================\n// Overall scene\n// =============================================\n\nfloat subrectSize() {\n    float isMousePressed = clamp(iMouse.z, 0.0, 1.0);\n    float valDefault = 0.25;\n    float valPressed = mix(0.04, 0.6, iMouse.x/iResolution.x);\n    return mix(valDefault, valPressed, isMousePressed);\n}\n\nvec4 scene(vec2 p) {\n\n    // Camera\n    // ---------------------------\n    vec3 camPos = 4.0 * vec3(cos(iTime*0.2), 0.0, sin(iTime*0.2));\n    camPos += vec3(0.0, 0.75 + 0.5*cos(iTime*0.5), 0.0);\n    vec3 lookTarget = vec3(0.0);\n\n    vec3 movement = vec3(2.0, 0.0, -iTime*2.0);\n    camPos += movement;\n    lookTarget += movement;\n\n    vec3 nvCamFw = normalize(lookTarget - camPos);\n\n    mat4 clipToWorld = getClipToWorld(IMAGE_ASPECT_WIDTH_OVER_HEIGHT, nvCamFw);\n    vec3 nvCamDir = nvDirFromClip(clipToWorld, p);\n\n    // Portal geometry\n    // ---------------------------\n    float a = subrectSize();\n\n    vec3 nv00 = nvDirFromClip(clipToWorld, vec2(-a,-a));\n    vec3 nv10 = nvDirFromClip(clipToWorld, vec2( a,-a));\n    vec3 nv01 = nvDirFromClip(clipToWorld, vec2(-a, a));\n    vec3 nv11 = nvDirFromClip(clipToWorld, vec2( a, a));\n\n    float minY = -PLANE_DEPTH + 2.5*BOUNDARY_RADIUS;\n    float tL = hitPlane(vec3(0.0,  minY, 0.0),  NV_PLANE_N, camPos, nv00);\n    float tU = hitPlane(vec3(0.0, -minY, 0.0), -NV_PLANE_N, camPos, nv01);\n    float tPortal = min(12.0, min(\n        mix(MAX_DIST, tL, step(0.0, tL)),\n        mix(MAX_DIST, tU, step(0.0, tU))\n    ));\n\n    vec3 q00 = camPos + tPortal*nv00;\n    vec3 q10 = camPos + tPortal*nv10;\n    vec3 q01 = camPos + tPortal*nv01;\n    vec3 q11 = camPos + tPortal*nv11;\n\n    vec3 portalVX = normalize(q10 - q00);\n    vec3 portalVY = normalize(q01 - q00);\n    vec3 portalVZ = cross(portalVX, portalVY);\n\n    q00 += BOUNDARY_RADIUS * ( -portalVX - portalVY );\n    q10 += BOUNDARY_RADIUS * (  portalVX - portalVY );\n    q01 += BOUNDARY_RADIUS * ( -portalVX + portalVY );\n    q11 += BOUNDARY_RADIUS * (  portalVX + portalVY );\n\n    // Light placement\n    // ---------------------------\n    vec3 lightPos = 0.5*(q01 + q11) + 1.0*portalVY + 5.0*portalVZ;\n\n    // Render scene\n    // ---------------------------\n    vec3 sceneColor = vec3(0.0);\n\n    float didHitPortal;\n    vec3 hitPos;\n    hitObject(camPos, nvCamDir, q00,q10,q11,q01, didHitPortal, hitPos);\n\n    if (didHitPortal > 0.5) {\n\n        vec3 n = normalQuadBoundary(q00,q10,q11,q01, hitPos);\n        vec3 nvRefl = normalize(reflect( hitPos-camPos, n ));\n\n        vec3 diffuse;\n        vec3 specular;\n        computeLighting(\n            0.2, 0.8, 20.0,\n            vec3(1.0), 0.4*vec3(1.0, 0.5, 1.0),\n            n, normalize(lightPos - hitPos), normalize(camPos - hitPos),\n            diffuse, specular\n        );\n        vec3 matColor = diffuse + specular;\n\n        vec3 terrainColor;\n        terrainAndSky(\n            hitPos, nvRefl, lightPos, POM_QUALITY_REFL,\n            q00,q10,q11,q01,\n            terrainColor\n        );\n\n        sceneColor = matColor + 0.8*terrainColor;\n\n    } else {\n\n        terrainAndSky(\n            camPos, nvCamDir, lightPos, POM_QUALITY,\n            q00,q10,q11,q01,\n            sceneColor\n        );\n\n    }\n\n    return vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n}\n\n// ------------------------------------------\n// Helpers to achieve \"Escher effect\"\n// ------------------------------------------\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 clog(vec2 a) {\n    return vec2(0.5*log(dot(a,a)), atan(a.y, a.x));\n}\n\nvec2 cexp(vec2 a) {\n    return exp(a.x)*vec2(cos(a.y), sin(a.y));\n}\n\nvec2 twist(vec2 p) {\n#ifdef TWIST\n    float a = subrectSize();\n\n    vec2 r = vec2(TWIST_EXPONENT, log(a)/TWOPI);\n    return cexp(cmul(r, clog(p)));\n#else\n    return p;\n#endif\n}\n\nvec2 droste(vec2 p) {\n#ifdef DROSTE\n    float a = subrectSize();\n\n    float isMousePressed = clamp(iMouse.z, 0.0, 1.0);\n    float apow = mix(\n        fract(iTime*0.2), 4.0*iMouse.y/iResolution.y, isMousePressed\n    );\n    p *= pow(a, apow);\n\n    vec2 log_a = log(abs(p)) / log(a);\n    float adjust = min(floor(log_a.x), floor(log_a.y));\n    log_a -= vec2(adjust);\n\n    return sign(p) * pow(vec2(a), log_a);\n#else\n    return p;\n#endif\n}\n\n// ------------------------------------------\n// Put it all together!\n// ------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 p = (2.0*uv - 1.0);\n    p.x *= (iResolution.x / iResolution.y) / IMAGE_ASPECT_WIDTH_OVER_HEIGHT;\n\n    vec2 radv = uv - vec2(0.5, 0.5);\n    float dCorner = length(radv);\n    float vignetteFactor = 1.0 - mix(0.0, 0.3, smoothstep(0.2, 0.707, dCorner));\n\n    fragColor = vignetteFactor * scene(droste(twist(p)));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Find t so that mix(a,b,t) = x\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nfloat rand(in vec2 p) {\n    return fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(in vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n\n    float r00 = rand(vec2(pi.x    ,pi.y    ));\n    float r10 = rand(vec2(pi.x+1.0,pi.y    ));\n    float r01 = rand(vec2(pi.x    ,pi.y+1.0));\n    float r11 = rand(vec2(pi.x+1.0,pi.y+1.0));\n\n    return mix(mix(r00, r10, pf.x), mix(r01, r11, pf.x), pf.y);\n}\n\nfloat fbm(vec2 uv) {\n    vec2 p = uv*256.0;\n    \n    float v = noise(p);\n\n    p *= 0.3;\n    v = mix(v, noise(p), 0.8);\n\n    p *= 0.3;\n    v = mix(v, noise(p), 0.8);\n\n    p *= 0.3;\n    v = mix(v, noise(p), 0.8);\n\n    return v;\n}\n\nfloat nearInt(float x) {\n    return pow(0.5 + 0.5*cos(x*6.28),10.0);\n}\n\nfloat fbmWithBorder(vec2 uv) {\n    float r = fbm(uv);\n    return mix(1.0, fbm(uv), (1.0-nearInt(uv.x))*(1.0-nearInt(uv.y)) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float heightTerrain = fbmWithBorder(uv);\n    float cloudIntensity = heightTerrain;\n    \n    float starVal = noise(uv*1024.0);\n    float starIntensity = unmix(0.95, 1.0, starVal) * step(0.95, starVal);\n\n    fragColor = vec4(heightTerrain, cloudIntensity, starIntensity, 0.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3GW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[672, 705, 745, 745, 775], [777, 777, 806, 806, 853], [855, 855, 919, 919, 982], [984, 984, 1039, 1039, 1595], [1597, 1597, 1646, 1646, 1744], [1746, 1746, 2033, 2033, 2407], [2537, 2537, 2591, 2591, 2665], [2667, 2667, 2705, 2705, 2829], [2831, 2831, 2872, 2872, 2947], [2949, 2949, 2999, 2999, 3090], [3092, 3092, 3151, 3151, 3245], [3247, 3247, 3302, 3302, 3379], [3381, 3381, 3446, 3446, 3562], [3564, 3564, 3617, 3617, 3786], [3788, 3788, 3835, 3835, 4003], [4005, 4005, 4062, 4062, 4128], [4130, 4130, 4205, 4205, 4283], [4285, 4285, 4354, 4354, 4430], [4432, 4432, 4499, 4499, 4569], [4571, 4571, 4723, 4723, 5158], [5160, 5160, 5301, 5301, 5843], [5973, 5973, 5996, 5996, 6302], [6304, 6304, 6326, 6326, 6626], [6628, 6628, 6657, 6657, 7060], [7062, 7062, 7089, 7089, 7696], [7698, 7698, 7893, 7963, 8477], [8479, 8479, 8555, 8555, 9051], [9053, 9053, 9229, 9229, 11701], [11819, 11819, 11840, 11840, 12044], [12046, 12046, 12066, 12116, 14939], [15072, 15072, 15099, 15099, 15156], [15158, 15158, 15177, 15177, 15231], [15233, 15233, 15252, 15252, 15300], [15302, 15302, 15322, 15322, 15478], [15480, 15480, 15501, 15501, 15915], [16034, 16034, 16089, 16089, 16450]], "test": "untested"}
{"id": "tlV3Rz", "name": "asdfasdfgasdfgdsafa", "author": "jeyko", "description": "adf", "tags": ["asdf"], "likes": 4, "viewed": 375, "published": 3, "date": "1578180044", "time_retrieved": "2024-07-30T21:31:39.972311", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    #define tx(u) texture(iChannel0, u)\n    \n    #define pi acos(-1.)\n    #define tau (2.*pi)\n    #define taps 1\n    \n    float distToCenter = length(camera);\n    \n    //float range = pow((abs(tx(uv).z - 0.5)*0.02)*5., 2.);\n    float range = abs(tx(uv).z - distToCenter*0.02)*0.000;\n    vec3 accum = vec3(0);\n    for (int i = 0; i < taps ; i++){\n        float idx = float(i)/float(taps);\n        vec2 offs =  vec2(sin(idx*tau),cos(idx*tau))*range;\n    \taccum += tx(uv + offs ).xyz;\n    \n    }\n    \n    vec3 col = accum/float(taps);\n\n    \n    col *= 1. - pow(length(uv - 0.5)*2. - 0.5, 4.)*1.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define focusD(d) \n\n#define iTime (iTime + 3.)\n\n  #define ZOOMFACTOR  (sin(iTime*0.4) + sin(iTime*0.5)*1.4)\n  #define ZOOM (20. + (sin(iTime) - ZOOMFACTOR*2.))\n  #define ROTSPEED 0.1\n//#define camera vec3(0. + sin(iTime*ROTSPEED)*ZOOM,0.01 + sin(ZOOMFACTOR*1.)*4. ,0. + cos(iTime*ROTSPEED)*ZOOM)\n#define camera vec3(0. + sin(iTime*ROTSPEED)*ZOOM + ZOOM,0.01 + sin(ZOOMFACTOR*1.)*4. ,20.)\n// thx inigo quilez! \nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }", "buffer_a_code": "\n\n#define dmin(a, b) (a.x < b.x) ? a : b\n\n#define fov 0.5\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv) {\n  vec3 dir = normalize(lookAt - ro);\n  vec3 right = normalize(cross(vec3(0,1,0), dir));\n  vec3 up = normalize(cross(dir, right));\n  \n  return dir*1. + right*uv.x*fov + up*uv.y*fov;\n}\n\n\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define PI acos(-1.)\n#define tau (1.*pi)\n\n#define dmin(a, b) (a.x < b.x) ? a : b // takes 2 vec2, does a minimum of them \n#define dmax(a, b) (a.x > b.x) ? a : b\n\n#define pmod(p, x) (mod(p,x) - x*0.5)\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\n\n// Thx knighty and tdhooper for icosahedron!! \n// https://www.shadertoy.com/view/XlX3zB\n//\n\n// Barycentric to Cartesian \nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\nint Type=4;\n\nvec3 nc,pab,pbc,pca;\nvec3 icoF0;\nvec3 icoF1a;\nvec3 icoA0;\nvec3 icoB0;\nvec3 icoC0;\nvec3 icoA1;\nvec3 icoB1;\nvec3 icoC1;\nvec3 fold1;\nvec3 fold2;\nvec3 fold3;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n\n    vec3 A = pbc;\n    vec3 C = reflect(A, normalize(cross(pab, pca)));\n    vec3 B = reflect(C, normalize(cross(pbc, pca)));\n    \n    icoF0 = pca;\n    \n\ticoA0 = A;\n\ticoC0 = B;\n\ticoB0 = C;\n\n    vec3 p1 = bToC(A, B, C, vec3(.5, .0, .5));\n    vec3 p2 = bToC(A, B, C, vec3(.5, .5, .0));\n    fold1 = normalize(cross(p1, p2));\n    \n    // Get corners of triangle created by fold\n    vec3 A2 = reflect(A, fold1);\n    vec3 B2 = p1;\n    vec3 C2 = p2;\n    \n    icoF1a = pca;\n    \n    icoA1 = A2;\n    icoB1 = normalize(B2);\n    icoC1 = normalize(C2);\n    \n    p1 = bToC(A2, B2, C2, vec3(.5, .0, .5));\n    p2 = bToC(A2, B2, C2, vec3(.5, .5, .0));\n    fold2 = normalize(cross(p1, p2));\n    \n\tp1 = bToC(A2, B2, C2, vec3(.0, .5, .5));\n    fold3 = normalize(cross(p2, p1));\n}\n\n\n\nfloat pModIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    float i = 0.;\n    \n    if (subdivisions > 0) {\n\n        // Fold in corner A \n        i += pReflect(p, fold1, 0.) / 2. + .5;\n        \n        if (subdivisions > 1) {\n            \n            // Fold in corner A\n            pReflect(p, fold2, 0.);\n            \n            // Fold in corner B\n            pReflect(p, fold3, 0.);\n        }\n    }\n\n    return i;\n}\n  \n  \n#define modMult 1.2 \n\n\n// thx Luna for dividing space thingie\n\nvec2 map(vec3 p) {\n    float distBetweenZ = 6.7;\n    float zId = floor(p.z/distBetweenZ);\n    p.z = pmod(p.z, distBetweenZ);\n    \n    \n    p.xy *= rot( (sin(iTime) - iTime*sin(zId*521424.2524) ) * 0.5);\n    for (int i = 0; i < 4; i++){\n        p = abs(p);\n    \tp.xy *= rot(0.4 + sin(zId*0.2)*0.1);\n        \n        //p.xz *= rot(0.05);\n        p -= 0.9;\n        p.x -= float(i)*0.7 + sin(zId*0.1);\n    }\n        p.y -= 2.4;\n    \n    \n  p.y *= 0.8 + sin(ZOOMFACTOR + 2.)*0.1;\n  vec2 d = vec2(10e9);\n    \n  vec3 z = p;\n  \n  z.y *= modMult;\n  \n  float floorId = floor(z.y);\n    \n    \n    \n  vec3 q = p;\n    \n \n  z.y = pmod(z.y, 1.);\n    \n    \n  //p.xz *= rot(fract(sin(floorId)*124314.124 )* iTime*sign(sin(floorId*5214242.4412))*0.4);\n  \n  float i = pModIcosahedron(p, 1);\n  p -= 4.;\n    \n  \n  float dObject = p.z + 0.5;\n  \n  \n  float dFloor =  abs(z.y) - 0.01 ;\n  \n  floorId = mod(floorId + zId, 3.);\n  if (floorId == 0.) {\n    dFloor -= length(sin(p*vec3(1,1,2.7)))*0.1;\n    dFloor = max(dFloor, -sin(p.x*4. + p.y*2.));\n  }\n  if (floorId == 1.) {\n    //dFloor -= length(sin(p*vec3(1,1,2.7)))*0.1;\n    dFloor = opSmoothIntersection(dFloor - 0.1, sin(p.z*5. + p.x*4.),0.5);\n  }\n     if (floorId == 2.) {\n    //dFloor -= length(sin(p*vec3(1,1,2.7)))*0.1;\n  } \n  \n  \n  d = dmin(d,vec2(max(dObject,dFloor), floorId));\n  \n    \n   i = pModIcosahedron(q, 2);\n  \n    q -= 20.3;\n  \n    //d = dmin(d,vec2(abs(q.z - 9.) - 0.1, 1.));\n    \n    \n  d.x *= 0.25; \n  \n  \n  \n  return d;\n  \n}\n\nvec3 getNormal(vec3 p) {\n    vec2 t = vec2(0.001, 0.);\n  return normalize(map(p).x - vec3(\n    map(p - t.xyy).x,\n    map(p - t.yxy).x,\n    map(p - t.yyx).x\n  ));\n}\n\n\n\nvec3 glow = vec3(0);\n\n#define spectra(x,t) (0.5 + 0.6*sin(vec3(0.8,0.4,0.9)*t + x)) \n\n\n// ------- Main ------- //\nvec4 render(vec2 uv) {\n  vec3 col = vec3 (0);\n\n  initIcosahedron();\n  \n    \n  vec3 ro = camera;\n    \n  vec3 lookAt = vec3(0.001,0. + sin(iTime)*0.2,-20.  + iTime);\n  vec3 rd = getRd(ro, lookAt, uv);\n  \n  vec3 p = ro; float t = 0., tBeforeRefraction = 0.;\n  \n  \n  float side = 1.;\n  \n  bool refracted = false;\n  bool didHit = false;\n    \n  vec3 attenuation = vec3(1);\n  \n  #define ITERS 300\n  for (int i = 0; i <= ITERS; i++) {\n    vec2 d = map(p);\n    d.x = d.x * side;\n    glow += spectra(d.x - 8. + p.z*0.25 - sin(iTime), 18.)*0.1;\n    if(d.x < 0.001) {\n    \n      vec3 n = getNormal(p) * side;\n      \n      //vec3 l = normalize(vec3(sin(iTime*0.28),sin(iTime*0.6), cos(iTime*0.25)))*25.21;;\n      vec3 l = normalize(vec3(1,1,-1))*25.21;\n      vec3 lDir = normalize(l - p);\n      vec3 lDirB = normalize(vec3(1));\n      \n      vec3 l1Col = vec3(0.98,0.02,0.68);\n      vec3 l2Col = vec3(0.1,0.2,0.95);\n      //vec3 lDir = normalize(vec3(1));\n      vec3 h = normalize(lDir - rd);\n      vec3 hB = normalize(lDirB - rd);\n      \n      float lightAttenuation= 1./(length(p - l)*length(p - l));\n      float lBAttenuation = 0.02;\n      \n      float diff = max(dot(lDir,n), 0.);\n      float fres = pow(1. - abs(dot(n, -rd)), 9.);\n      float spec = pow(max(dot(h, n), 0.), 1.);\n        \n      float diffB = max(dot(lDirB,n), 0.);\n      float fresB = pow(max(dot(n, -rd), 0.), 4.);\n      float specB = pow(max(dot(hB, n), 0.), 1.);\n      \n      //col += 1.;\n          if (!didHit){\n          \ttBeforeRefraction = t;\n          }      \n      \n      if (d.y == 1.) { // refract\n        vec3 surfaceCol = vec3(0.9,0.9,1);\n        refracted = true;\n        side = -side;\n        ro = p;\n        rd = refract(rd, n, 1. + rd.y*0.02 + length(sin(p.xz))*0.001);\n        t = 0.;\n        d.x = 0.2;\n        const float shininess = 0.9;\n        col += mix(vec3(diff)*l1Col*surfaceCol,vec3(fres * spec*l1Col), shininess)*attenuation;\n        col += mix(vec3(diffB)*l2Col*surfaceCol,vec3(fresB * specB*l2Col), shininess)*lBAttenuation;\n        \n        col = clamp(col, 0., 1.);\n        //col += glow*0.001;\n        attenuation *= 0.9;\n\n        \n      } else if (d.y == 0.) { // diffuse\n        vec3 albedo = vec3(.1,.9,0.9);\n      \t\ttBeforeRefraction = t;\n        col += mix(vec3(diff*albedo)*l1Col,vec3(pow(fres, 10.) * spec*l1Col), 0.9)*attenuation;\n        col += mix(vec3(diffB)*l2Col,vec3(pow(fresB, 10.) * specB*l2Col), 0.3)*lBAttenuation;\n        rd = refract(rd, n, 1. + rd.y*0.2);\n        break; \n      } else if (d.y == 2.) { //reflect\n        refracted = true;\n        col += mix(vec3(diff)*l1Col,vec3(fres* spec*l1Col), 0.8)*attenuation;\n        col += mix(vec3(diffB)*l2Col,vec3(fresB* specB*l2Col), 0.8)*lBAttenuation;\n        rd = reflect(rd, n  + sin(n.y*0.1 + p.x*0.1)*0.05);\n        ro = p;\n        t = 0.;\n        d.x = 0.1;\n        attenuation *= vec3(0.8,0.7,0.9)*0.1;\n        \n      }\n      \n      attenuation *= lightAttenuation;\n      didHit = true;\n      \n      }\n    if(t > 100. || i == ITERS ) {\n        if (!didHit) {\n      \t\ttBeforeRefraction = t;\n        }\n      break;\n    }\n      \n    t += d.x;\n    p = ro + rd*t;\n  }\n  col += glow*0.003*vec3(0.3,0.,0.2);\n  col *= 2.;\n  col *= vec3(1.17,1.1,1);\n\n    col = max(col, vec3(0.));\n\n  col = pow(col, vec3(0.45));\n\n  //col = mix(col, vec3(0)*0., clamp(vec3(pow(0.1 + tBeforeRefraction*0.01,1.5)*1.4),vec3(0.),vec3(1.)));      \n    \n  col = clamp(col, 0. ,1.);\n  return vec4(col, t);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    fragColor = vec4(col);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlV3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 732]], "test": "untested"}
{"id": "wtK3Rz", "name": "The Second After Midnight", "author": "angelo12", "description": "First in my weekly shader series for 2020. Let's see where this takes us! ", "tags": ["time", "clock", "challenge", "weekly"], "likes": 3, "viewed": 455, "published": 3, "date": "1578178574", "time_retrieved": "2024-07-30T21:31:40.791121", "image_code": "/*\n    Sunday Shader: 1/52 \"The second after Midnight\"\n    New years resolution: make a shader every week & upload them on Sunday.\n    Yeah this one is pretty simple but you gotta start somewhere.\n    Suggestions, feedback & help is always welcome :D\n\n\tAngel Ortiz\n*/\n\n#define INV_GAMMA 0.454545\n#define AA 4\n#define M_PI 3.1415926535\n\n#define CLOCKFACE_ID 1.0f\n#define CLOCKFACE_RADIUS 0.35f\n\n#define BOX_ID 2.0f\n#define BOX_SIZE vec2(0.0025, 0.17)\n\n#define ONETOZERO(num) (num + 1.0f) / 2.0f\n#define DEBUGCOL vec3(1.0, 0.0,1.0)\n\n/*Game Plan:\n    Todo\n\n    In progress\n\n    Done\n    - [x] Draw clock face\n    - [x] Mark the 12 hours \n    - [x] Background\n    - [x] Clock hands\n    - [x] Moving the clock hands\n\n    Maybe next time\n    [ ] Draw Roman Numerals\n    [ ] Fireworks from behind the clock\n    [ ] Buildings w/ lights\n    [ ] Hand strikes twelve\n*/\n\nfloat\nsdCircle(vec2 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat\nsdBox(vec2 pos, vec2 sizes)\n{\n    return length(max(abs(pos) - sizes, vec2(0.0)));\n}\n\nfloat\nMap(vec2 uv) \n{\n    float res = -1.0;\n\n    vec2 trans = vec2(0.0, -0.12);\n    vec2 bigHand = uv - vec2(0.0, 0.12) - trans;\n    float a = M_PI* (-iTime / 60.0);\n    mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n    bigHand = bigHand * (rot) + trans  ;\n\n    trans = vec2(0.0, -0.09);\n    vec2 littleHand = uv - vec2(0.0, 0.09) - trans;\n    a = M_PI* (-iTime / (60.0 * 60.0));\n    rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n    littleHand = littleHand * (rot) + trans;\n\n    //If you're inside the sdf, return it's ID\n    res = (sdCircle(uv - vec2(0.0, 0.0), CLOCKFACE_RADIUS) <= 0.0) ? CLOCKFACE_ID : res;  \n    res = (sdBox(bigHand, BOX_SIZE) <= 0.0) ? BOX_ID : res;  \n    res = (sdBox(littleHand, vec2(0.0025, 0.12)) <= 0.0) ? BOX_ID : res;  \n    res = (sdCircle(uv - vec2(0.0, 0.0), 0.01) <= 0.0) ? 3.0f : res;  \n\n    return res;\n}\n\nvec3\nShading(vec2 uv, float id)\n{\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n\n    vec3 col;\n    //Default case\n    if (id  == -1.0f)\n    {\n        bool inRadius = r > 0.36 && r < 0.37;\n        bool inAngle = true;\n        bool inCircle = inRadius && inAngle;\n\n        if (inCircle)\n        {\n            col = vec3(0.831, 0.686, 0.216);\n        }\n        else \n        {\n            col = vec3(0.5)* (uv.y + 0.3);\n            col = pow(col, vec3(2.0));\n        }\n\n    }\n\n    if (id == BOX_ID)\n    {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n\n    if (id == CLOCKFACE_ID)\n    {\n        col = vec3(1.0, 0.95, 0.85);\n\n\n        //Tick markers\n        {\n            bool inRadius = r > 0.26 && r < 0.325;\n            if (cos(a * 12.0) > 0.97 && inRadius)\n            {\n                col = vec3(0.0);\n            }\n        }\n\n    }\n\n    return col;\n}\n\nvec3\nRender(vec2 uv)\n{\n    //Geometry\n    float id = Map(uv);\n\n    //Shading\n    vec3 col = Shading(uv,id);\n\n    return col;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    vec3 tot;\n\n    //Supersampling AA\n#if AA > 1\n    for(int i = 0; i < AA; ++i)\n    for(int j = 0; j < AA; ++j)\n    {\n        vec2 offset = vec2(i, j) / float(AA) - 0.5;\n        vec2 uv = ((fragPos + offset) - 0.5*iResolution.xy) / iResolution.y;\n#else\n        vec2 uv = ((fragPos) - 0.5*iResolution.xy) / iResolution.y;\n#endif\n\n        //Rendering\n        vec3 col = Render(uv);\n\n        //Gamma correction\n        col = pow(col, vec3(INV_GAMMA));\n        tot += col;\n#if AA > 1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtK3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[860, 860, 900, 900, 935], [937, 937, 972, 972, 1027], [1029, 1029, 1050, 1050, 1872], [1874, 1874, 1907, 1907, 2733], [2735, 2735, 2757, 2772, 2861]], "test": "untested"}
{"id": "wlVGRz", "name": "Echeveria", "author": "tdhooper", "description": "Click to see different distributions", "tags": ["plant", "succulent"], "likes": 155, "viewed": 5221, "published": 3, "date": "1578176135", "time_retrieved": "2024-07-30T21:31:41.719639", "image_code": "const float PI  = 3.14159265359;\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat time;\n\nvec4 leaf(vec3 p, vec2 uv) {\n    float thick = clamp(uv.y, .7, 1.);\n    thick = 1.;\n    float th = thick * .16;\n    pR(p.xz, -uv.x);\n    float width = mix(.5, .1, min(uv.y, 1.));\n    width = .75 / uv.y;\n    width *= thick;\n    vec3 n = normalize(vec3(1,0,width));\n    float d = -dot(p, n);\n    d = max(d, dot(p, n * vec3(1,1,-1)));\n    float len = mix(PI / 1.2, PI / 2., pow(uv.y/2.9, 2.));\n    len = max(len, 0.);\n    pR(p.yz, PI / 2. - len);\n    d = smax(d, p.y, thick);\n    d = smax(d, abs(length(p) - uv.y) - thick * th, th);\n    vec2 uuv = vec2(\n        atan(p.y, p.z) / -len,\n        p.x\n   \t);\n    vec3 col = mix(vec3(0), vec3(.5,1,.7) * .05, 1.-smoothstep(.0, .5, uuv.x));\n    col += vec3(.06,.0,.03) * max(1. - uv.y / 2., 0.);\n    col = mix(col, col * .2, 1.-smoothstep(.0, .2, uuv.x));\n    return vec4(d, col);\n}\n\nbool lightingPass;\n\nvec4 opU(vec4 a, vec4 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec4 bloom(vec3 p) {\n\n    float bound = length(p - vec3(0,-1.2,0)) - 3.3;\n    bound = max(bound, p.y - 1.1);\n    if (bound > .01 && ! lightingPass) {\n        return vec4(bound, 0, 0, 0);\n    }\n\n    vec2 cc = vec2(5., 8.);\n    if (iMouse.z > 0.) {\n    \tcc = floor(iMouse.xy / iResolution.xy * 10.);\n    }\n    float aa = atan(cc.x / cc.y);\n    float r = (PI*2.) / sqrt(cc.x*cc.x + cc.y*cc.y);\n    mat2 rot = mat2(cos(aa), -sin(aa), sin(aa), cos(aa));\n    \n    vec2 offset = vec2(1, 2) * time * r * rot;\n    \n    vec2 uv = vec2(\n        atan(p.x, p.z),\n        length(p)\n    );\n\n    uv -= offset;\n\n    uv = rot * uv;\n    vec2 cell = round(uv / r);\n\n    vec4 d = vec4(1e12, vec3(0));\n\n    d = opU(d, leaf(p, ((cell + vec2(-1, 0)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(0, -1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(0, 0)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(1, -1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(1, 0)) * rot * r) + offset));\n\n    //*\n    d = opU(d, leaf(p, ((cell + vec2(-1, -1)) * rot * r) + offset));\n   \td = opU(d, leaf(p, ((cell + vec2(-1, 1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(0, 1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(1, 1)) * rot * r) + offset));\n\t//*/\n\n    return d;\n}\n\nvec4 map(vec3 p) {\n    return bloom(p);\n}\n\nvec3 calcNormal(vec3 pos){\n    float eps = .0005;\n    vec2 e = vec2(1.0,-1.0) * 0.5773;\n    return normalize(\n        e.xyy * map(pos + e.xyy * eps).x + \n\t\te.yyx * map(pos + e.yyx * eps).x + \n\t\te.yxy * map(pos + e.yxy * eps).x + \n\t\te.xxx * map(pos + e.xxx * eps).x\n    );\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n//#define AA 3\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 col;\n    vec3 tot = vec3(0.0);\n\n    float mTime = mod(iTime / 2., 1.);\n    time = mTime;\n\n    vec2 o = vec2(0);\n\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    // pixel coordinates\n    o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    // time coordinate (motion blurred, shutter=0.5)\n    float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n    time = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n        lightingPass = false;\n\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\n        vec3 camPos = vec3(0.5, 7.4, -8.7) * .9;\n        mat3 camMat = calcLookAtMatrix( camPos, vec3(0,-1.4,0), -0.5);\n        vec3 rd = normalize( camMat * vec3(p.xy,2.8) );\n\n        vec3 pos = camPos;\n        float rayLength = 0.;\n        float dist = 0.;\n        bool bg = false;\n        vec4 res;\n\n        for (int i = 0; i < 100; i++) {\n            rayLength += dist;\n            pos = camPos + rd * rayLength;\n            res = map(pos);\n            dist = res.x;\n\n            if (abs(dist) < .001) {\n                break;\n            }\n            \n            if (rayLength > 16.) {\n                bg = true;\n                break;\n            }\n        }\n\n        col = vec3(.19,.19,.22) * 1.9;\n        col = vec3(.35,.24,.0) * 1.8;\n\t\tcol = vec3(.5,1,.7) * .05;\n        \n        if ( ! bg) {\n            \n            lightingPass = true;\n            \n\t\t\tvec3 nor = calcNormal(pos);\n            float occ = calcAO( pos, nor );\n            vec3  lig = normalize( vec3(-.2, 1.5, .3) );\n            vec3  lba = normalize( vec3(.5, -1., -.5) );\n            vec3  hal = normalize( lig - rd );\n            float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n            float bac = clamp( dot( nor, lba ), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n            float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n            occ = mix(1., occ, .8);\n            \n            dif *= softshadow( pos, lig, 0.001, .9 );\n\n            float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                        dif *\n                        (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n            vec3 lin = vec3(0.0);\n            lin += 2.80*dif*vec3(1.30,1.00,0.70);\n            lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n            lin += 1.55*bac*vec3(0.25,0.25,0.25)*occ*vec3(2,0,1);\n            lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\n            col = res.yzw;\n        \tcol = col*lin;\n\t\t\tcol += 5.00*spe*vec3(1.10,0.90,0.70);\n\n            //col = nor * .5 + .5;\n            //col = max(dot(vec3(.1,1,-.2), nor), 0.) * vec3(.2);\n        }\n\n        tot += col;\n    #ifdef AA\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    col = tot;\n    col *= 1.3;    \n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 66, 66, 111], [113, 113, 151, 151, 262], [264, 264, 303, 303, 334], [349, 349, 377, 377, 1171], [1193, 1193, 1219, 1219, 1251], [1253, 1253, 1273, 1273, 2574], [2576, 2576, 2594, 2594, 2617], [2619, 2619, 2645, 2645, 2892], [2894, 2935, 3009, 3009, 3296], [3298, 3339, 3381, 3381, 3683], [3685, 3685, 3749, 3749, 3927]], "test": "untested"}
{"id": "ttKGRR", "name": "Raymarch Tutorial v04", "author": "tombla", "description": "Raymarching with repetition trick", "tags": ["raymarch", "sdf", "repetition"], "likes": 1, "viewed": 352, "published": 3, "date": "1578159165", "time_retrieved": "2024-07-30T21:31:42.471628", "image_code": "// Based on youtube tutorial\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n// and SDF functions article at\n// https://iquilezles.org/articles/distfunctions\n\n#define SPHERE_POS_1 vec3(0., 0., 0.)\n#define SPHERE_RAD_1 1.\n#define SPHERE_POS_2 vec3(-0.6, 0., -0.6)\n#define SPHERE_RAD_2 0.9\n#define PLANE_POS -4.\n#define LIGHT_POS vec3(-0., 2.1, 0.2)\n#define JUMP_SPEED 1.4\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define CLOSENESS 0.01\n\nvec2 rescale(in vec2 p) {\n    return vec2((p - 0.5 * iResolution.xy) / iResolution.y);\n}\n\nfloat twoUnion(float a, float b) {\n    return min(a, b);\n}\n\nfloat twoSubtract(float a, float b) {\n    return max(a, -b);\n}\n\nfloat twoIntersect(float a, float b) {\n    return max(a, b);\n}\n\nfloat getOnion(float d, float r) {\n    return abs(d) - r;\n}\n\nvec3 getInfiniteRep(in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p + 0.5 * c, c) - 0.5 * c;\n    return q;\n}\n\n// Get distance to sphere 1.\nfloat getDistSphere1(vec3 p) {\n    vec3 spherePos = SPHERE_POS_1;\n    float dS = length(spherePos - p) - SPHERE_RAD_1;\n    return dS;\n}\n\n// Get distance to sphere 2.\nfloat getDistSphere2(vec3 p) {\n    vec3 spherePos = SPHERE_POS_2;\n    float dS = length(spherePos - p) - SPHERE_RAD_2;\n    return dS;\n}\n\n// Get distance to both spheres.\nfloat getDistSpheres(vec3 p) {\n    float density = 4. + sin(iTime);\n    vec3 rep = getInfiniteRep(p, vec3(density, density, 11.));\n    float dS1 = getDistSphere1(rep);\n    float dS2 = getDistSphere2(rep);\n    float diff = twoSubtract(dS1, dS2);\n    //float onion = getOnion(diff, 0.003);\n    return diff;\n}\n\n// Get distance to plane and spheres.\nfloat getDistAll(vec3 p) {\n    float dS = getDistSpheres(p);\n    float dP = p.y - PLANE_POS;\n    //float dP = dS;\n    return min(dS, dP);\n}\n\nfloat rayMarch(vec3 origin, vec3 direction) {\n    float dist = 0.;\n    for(int i=0; i < MAX_STEPS; ++i) {\n        vec3 ray = origin + direction * dist;\n        float step = getDistAll(ray);\n        dist += step;\n        if (step < CLOSENESS || dist > MAX_DIST) break;\n    }\n    return min(dist, MAX_DIST);\n}\n\nvec3 getNormal(vec3 p) {\n    float toSurface = getDistAll(p);\n    vec2 e = vec2(0.01, 0.);\n    vec3 plane = toSurface - vec3(\n        getDistAll(p - e.xyy),\n        getDistAll(p - e.yxy),\n        getDistAll(p - e.yyx));\n    return normalize(plane);\n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = LIGHT_POS;\n    lightPos.xz += 2. * vec2(sin(iTime), cos(iTime));\n    vec3 lightVector = normalize(lightPos - p);\n    vec3 surfaceVector = getNormal(p);\n//    float diffusion = dot(surfaceVector, lightVector);\n    float diffusion = dot(lightVector, surfaceVector);\n    diffusion = clamp(diffusion, 0., 1.);\n\n    float toLight = rayMarch(p + surfaceVector * 1.05 * CLOSENESS, lightVector);\n    if (toLight < length(p - lightPos)) {\n        diffusion *= 0.3;\n    }\n\n    return diffusion;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = rescale(fragCoord);\n    vec3 color = vec3(1., 0.9, 0.7);\n\n    // Camera position\n    vec3 ro = vec3(0., 0.5, -9.);\n    // Camera direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    // Distance to a shape.\n    float dist = rayMarch(ro, rd);\n    // Point at the shape\n    vec3 ray = ro + rd * dist;\n    // Light diffusion\n    float diffusion = getLight(ray);\n    color *= diffusion;\n    // Sky\n    vec3 sky = vec3(0.1, 0.5, 0.8);\n    float skyMix = smoothstep(MAX_DIST * 0.6, MAX_DIST * 0.9, dist);\n\n    // Final color\n    vec3 final = mix(color, sky, skyMix);\n\n\n    fragColor = vec4(final, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKGRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 439, 464, 464, 527], [529, 529, 563, 563, 587], [589, 589, 626, 626, 651], [653, 653, 691, 691, 715], [717, 717, 751, 751, 776], [778, 778, 821, 821, 881], [883, 912, 942, 942, 1047], [1049, 1078, 1108, 1108, 1213], [1215, 1248, 1278, 1278, 1554], [1556, 1594, 1620, 1620, 1733], [1735, 1735, 1780, 1780, 2042], [2044, 2044, 2068, 2068, 2294], [2296, 2296, 2320, 2320, 2827], [2829, 2829, 2884, 2884, 3503]], "test": "untested"}
{"id": "3lV3zR", "name": "Bug: Mouse Y-coordinate off-by-1", "author": "TimoKinnunen", "description": "Use the cross-hair in fullscreen mode to test that it can cover the green marks at every screen edge. BUG: bottom row cannot be reached and at the top it goes off the screen.", "tags": ["bug"], "likes": 2, "viewed": 366, "published": 3, "date": "1578136306", "time_retrieved": "2024-07-30T21:31:43.246556", "image_code": "///////////\n//\n// Shadertoy mouse Y-coordinate off-by-1 bug\n//\n// The bug affects both normal mode canvas and full-screen canvas,\n// it's easiest to test in full-screen mode.\n//\n// The cause is found in mouse event handling code where the Y-coordinate\n// origin is changed from top-left to bottom-left. To do this the code\n// subtracts the top-left Y-coordinate from the height of the canvas.\n// But for 800x450 canvas, the topmost line is line number 449 and not 450,\n// as the first line at the bottom is line number 0.\n//\nvec2 R;\nvec4 mains(vec2 U) {\n    if(any(equal(ivec2(iMouse.xy),ivec2(U))) && distance(iMouse.xy+0.5,U) > 3.0) {\n        return vec4(1);\n    }\n    float pat = floor(mod(U.x+U.y+iTime*8.,16.0)/8.);\n    return any(equal(ivec4(U.xyxy),ivec4(0,0,R-1.))) ? vec4(0,pat,0,1) : vec4(0,0,pat,1);\n}\nvoid mainImage(out vec4 O, vec2 U) {R=iResolution.xy;O=mains(U);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lV3zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 533, 553, 553, 812], [813, 813, 849, 849, 878]], "test": "untested"}
{"id": "WlK3RR", "name": "Lost Satellite Orbit", "author": "Plento", "description": "Year after year it goes around.", "tags": ["3d", "sound", "space", "postprocess", "stars", "buffer", "gpusound"], "likes": 6, "viewed": 550, "published": 3, "date": "1578113425", "time_retrieved": "2024-07-30T21:31:44.089303", "image_code": "// Plento\nvec3 t(vec2 p){\n \treturn texelFetch(iChannel0, ivec2(p),0).xyz;   \n}\n\n// Give the stars some twinklyness and it also doubled as an aa blur thingy sorta.\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec3 acc = vec3(0);\n    \n    for(float i = -8.; i < 8. ;i++){\n     \tacc += t(u+vec2(0.,i));\n        acc += t(u+vec2(i,0.));\n    }\n    acc = max(acc, .1);\n    acc/=35.;\n    f = vec4((acc + t(u))/2., 1.);\n    //f = vec4(t(u), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 R;\nconst float pi = 3.14159;\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// 3D simplex noise stuff from: https://www.shadertoy.com/view/XsX3zB\nconst float F3 =  .3333333;\nconst float G3 =  .1666667;\nvec3 random3(vec3 c) {\n\tfloat j = 4096.*sin(dot(c,vec3(17., 59.4, 15.)));\n\tvec3 r;\n\tr.z = fract(512.*j);\n\tj *= .125;\n\tr.x = fract(512.*j);\n\tj *= .125;\n\tr.y = fract(512.*j);\n\treturn r-.5;\n}\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t vec3 e = step(vec3(0.), x - x.yzx);\n\t vec3 i1 = e*(1. - e.zxy);\n\t vec3 i2 = 1. - e.zxy*(1. - e);\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.*G3;\n\t vec3 x3 = x - 1. + 3.*G3;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(.6 - w, 0.);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t return dot(d, vec4(52.));\n}\n\n// Sdf stuff\nfloat Box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,.0)) + min(max(q.x,max(q.y,q.z)),.0);\n}\nfloat Cylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),.0) + length(max(d,.0));\n}\n\n// Satellite\nfloat sat(vec3 rp){  \n    float body=99., wings = 99., sr = .6;\n    \n    vec3 pan = vec3(1.5,.6,.025);\n \tvec3 p0 = rp - vec3(1.7+sr, .4, 6.5);\n    vec3 p1 = rp - vec3(0, .4, 6.5);\n    vec3 p2 = rp - vec3(0, 1.1, 6.5); \n    vec3 p3 = rp - vec3(0, .5, 6.5); \n    \n    p3.xy*=rot(pi/2.);\n    p0.yz*=rot(.5);\n    p1.yz*=rot(-.5);\n    p2.yz*=rot(-.5);\n    \n    for(float i = 0.; i < 2.;i++){\n    \twings = min(wings,Box(p0, pan));\n        p0.x+=(pan.x*2.+sr*2.)*1.1;\n    }\n    \n    body = min(body, Cylinder(p1, sr, 1.1));\n    body = max(-Cylinder(p2, sr+.25, .25), body);\n    body = min(body, Cylinder(p1, sr-.25, 1.3));\n    body = min(body, Cylinder(p3, .05, 1.3));\n    \n    return min(wings, body);\n}\n\n\nfloat map(vec3 rp){\n \tvec3 p = rp - vec3(-iTime-8., .0, 18.);\n    vec3 b = vec3(50.,0.,0.);\n    p = mod(p, b)-b*.5;  \n    p.xy*=rot(iTime);\n    \n    return sat(p);\n}\n\nfloat trace(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;   \n    \n    for(int i = 0; i < 32; i++){\n    \td = map(ro + rd*t); \t   \n        \n        if(abs(d) < .006){break;}\n        t += d * .95;\n    }   \n    return t;\n}\n\n// stars and star\nvec3 cm(vec3 rd){\n    float star = smoothstep(.55,.96, simplex3d(rd*150.))*2.;\n    vec3 sun = vec3(.83, .4, .0)*exp(-rd.y*9.)*.2;\n    return sun + star;\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - .5*R.xy)/R.y;\n    vec3 ro = vec3(0), d = normalize(vec3(uv, 1.));\n    \n    d.yz *= rot(1.-exp(-.6*iTime) - 1.0); // initial camera movement\n    \n    f = vec4(mix( vec3(0), cm(d), step(35., trace(d, ro)) ), 1.);\n}\n\n\n\n", "buffer_a_inputs": [], "sound_code": "const float pi2 = 6.28318;\nconst float c = 32.03;\nfloat osc(float t, float hz){return sin(t*hz*pi2);}\n\nvec2 EndOfWorld(float t){\n    \n    float stp = c * -6.;\n    float f = floor(mod(1.+t*.66,2.));\n    float ow = 0.;\n    \n    ow = f*792.;\n    ow += (1.-f)*392.;\n    \n    vec2 wave = vec2(osc(t, 261.63 + stp), osc(t, 262.63 + stp))\n        + vec2(osc(t, 329.63 + stp), osc(t, 330.63 + stp))\n        + vec2(osc(t, ow + stp), osc(t, 393. + stp));\n    \n    wave /= 3.;\n    wave = clamp(wave, vec2(-.5), vec2(.5));\n    \n    return wave;\n}\n\nvec2 mainSound( in int samp, float time ){\n    \n    return EndOfWorld(time) * (1.-exp(-time*.2)) * .2; // fade in;\n    return vec2(0);\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlK3RR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 10, 25, 25, 78], [80, 163, 203, 203, 438]], "test": "untested"}
{"id": "wlc3Wl", "name": "More stairs", "author": "Plento", "description": "Staircase", "tags": ["3d", "raymarch", "stairs"], "likes": 9, "viewed": 448, "published": 3, "date": "1578088576", "time_retrieved": "2024-07-30T21:31:44.902130", "image_code": "vec2 R;\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat map(vec3 rp){\n    float d = 99.;\n    \n    d = min(rp.y - floor(rp.z), 1.- (rp.z - floor(rp.y)));\n    d = min(min(10. - rp.x, 1. + rp.x), d);\n    \n    return d;\n}\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;   \n    \n    for(int i = 0; i < 64; i++){\n    \td = map(ro + rd*t); \t   \n        if(abs(d) < .002){\n            break;\n        }\n        t += d * .75;\n    }   \n    return t;\n}\nvec3 color(vec3 ro, vec3 rd, vec3 n, float t){\n    vec3 lp = ro + vec3(.1, .3, -.01)*2.;\n    vec3 ld = lp-ro;\n    float dif = max(dot(n, ld), .0);\n    \n    vec3 col = vec3(0);\n    vec2 id = vec2(0);\n    float chk = 0.;\n    \n    ro.x*=.5;\n    if(abs(n.x)>.99){\n    \tid = floor((ro.yz)*2.);\n    \tchk = mod(id.x + id.y, 2.);\n    \tcol = mix(vec3(.5, .6, 0.), vec3(.5, 0., .6), chk)*.2;\n    }\n    else{\n    \tid = floor((ro.xy+ro.xz)*2.);\n    \tchk = mod(id.x + id.y, 2.);\n    \tcol = mix(vec3(.5, .6, 0.), vec3(.5, 0., .6), chk) *dif;  \n    }\n\treturn col;   \n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 1. - dot(uv, uv) * .35));\n    vec3 ro = vec3(.0,iTime - 5., -12. + iTime);\n    \n    rd.yz*=rot(.2);\n    rd.xz*=rot(-.5);\n    \n    float t = march(rd, ro);\n    \n    ro += rd*t;\n    \n    vec3 n = normal(ro);\n    vec3 col = color(ro, rd, n, t);\n    \n    f = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlc3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 28, 28, 80], [82, 82, 101, 101, 249], [250, 250, 277, 277, 478], [480, 480, 510, 510, 708], [709, 709, 755, 755, 1262], [1264, 1264, 1304, 1304, 1703]], "test": "untested"}
{"id": "wtyGRR", "name": "Large scale ball sandbox", "author": "michael0884", "description": "Using voronoi particle tracking in 3d. M - change mouse mode to view/manipulation. Use WASD/arrow + mouse to move around, Q/E - camera speed. C - clear box, space - shoot ball (inside box). P - pause. ", "tags": ["3d", "voronoi", "simulation", "particles", "molecular"], "likes": 22, "viewed": 983, "published": 3, "date": "1578076290", "time_retrieved": "2024-07-30T21:31:45.845607", "image_code": "// Fork of \"Lorentz Attractor 3D\" by michael0884. https://shadertoy.com/view/3lt3WX\n// 2019-12-31 20:33:24\n\n// Fork of \"Volumetric shader template\" by michael0884. https://shadertoy.com/view/tlc3Wf\n// 2019-12-30 20:57:24\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\nvec4 ambient_occlusion(in vec4 pos, inout vec4 norm, in vec3 dir)\n{\t\n\tvec3 pos0 = pos.xyz;\n\t\n\tfloat occlusion_angle = 0.;\n\t\n\t//step out\n    vec3 color = vec3(0.);\n    float mind =  max(0.05*norm.w, sphere_rad*0.5);\n\tpos.xyz += mind*norm.xyz;\n    norm.xyz = cosdistr(norm.xyz, 0.01);\n\t//march in the direction of the normal\n\tfor(int i = 0; i < 2; i++)\n\t{\n        pos.w = abs(map(pos.xyz));\n\t\tpos.xyz += pos.w*norm.xyz;\n\t\t\n\t\tnorm.w = length(pos0 - pos.xyz);\n       \n\t\tocclusion_angle += clamp((pos.w - mind)/(norm.w),0.,1.);\n\t}\n     color += 2.*ambient_sky_color(norm.xyz)  + 5.*texture(ch2, reflect(dir.xyz, norm.xyz).xzy).xyz;\n\treturn vec4(color*(occlusion_angle*0.85+0.15), occlusion_angle)/2.;\n}\n\n\n\n\nvec3 lighting(vec4 color, vec2 pbr, vec4 pos, vec4 dir, vec4 norm, float shadow) \n{\n\tvec3 albedo = color.xyz;\n\tnorm.w = dir.w;\n    vec3 N = norm.xyz;\n\tvec4 ambient_color = ambient_occlusion(pos, norm,dir.xyz);\n\t\n\tfloat metallic = pbr.x;\n\tvec3 F0 = vec3(0.04); \n\tF0 = mix(F0, albedo, metallic);\n\t\n\t//reflectance equation\n\tvec3 Lo = vec3(0.0);\n\tvec3 V = -dir.xyz;\n\t\n\t\n\t{ //ambient occlusion contribution\n\t\tfloat roughness = pbr.y;\n\t\tvec3 L = normalize(norm.xyz);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = ambient_color.xyz;        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\t\n\tvec3 sun_color = sky_color(light);\n\n\t{ //light contribution\n\t\tfloat roughness = pbr.y;\n\t\tvec3 L = normalize(light);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = sun_color*shadow;        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\t\n\treturn Lo;\n}\n\n#define sky vec3(20,80,235)/255.\nvec3 ray_march(vec3 p, vec3 r)\n{\n    float td = 0.;\n    int i;\n    for(i = 0; i < MAX_MARCHES; i++)\n    {\n    \tfloat de = map(p);\n        if(de < rayfov*td || td > MAX_DIST)\n        {\n            break;\n        }\n        p += de*r;\n        td += de;\n    }\n    vec3 col = vec3(0);\n    if(td > MAX_DIST || i > MAX_MARCHES)\n    {\n        col = sky_color(r);\n    }\n    else\n    {\n        vec4 norm = calcNormal(p,MIN_DIST);\n        //sampling color at the closest point\n        col = sdcolor(p - norm.w*norm.xyz);\n        p += r*(norm.w-rayfov*td);\n        #ifdef SHADOWS\n      \t\tfloat shad = shadow_march(vec4(p+norm.xyz*0.05,0.), vec4(light,0.), 400.,0.03);\n        #else\n        \tfloat shad = 1.;\n        #endif\n       \n        col = lighting(vec4(col,0.), vec2(0.2,0.3), vec4(p, 0.), vec4(r, td), norm, shad);\n    }\n   \n    return col;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + fragCoord.x + fragCoord.y*3.141592653;\n    rayfov = FOV/650.;\n     SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n   \n    vec2 uv = (fragCoord - 0.5*size)/max(size.x, size.y);\n\n    vec2 angles = texelFetch(iChannel3,  ivec2(ANGLE_INDX,0), 0).xy;\n \tvec3 ray = getRay(angles, uv);\n    vec3 cray = getRay(angles, vec2(0.));\n    \n    vec4 cpos = texelFetch(iChannel3,  ivec2(POS_INDX,0), 0);\n    \n    light = vec3(0.6,0.50,1.);\n    light.z = max(light.z, 0.9);\n    light = normalize(light);\n   \t\n    vec3 pos = cpos.xyz;\n\n    // Output to screen\n    vec4 t = texel(ch0, fragCoord);\n    vec3 p = dim3from2(fragCoord);\n    #ifdef VOLUMETRIC\n   \t fragColor = 2.*ray_march_vol(pos, ray);\n    #else\n     fragColor = 1.*vec4(HDRmapping(ray_march(pos, ray), 0.8),1);\n\t#endif\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p, s) texture(a, p/vec2(s))\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n//#define VOLUMETRIC\n#define SHADOWS\n\n//shows bonds/links between atoms, is unstable\n//#define LINKS\n#define FULL_UNION\n#define sphere_rad 1.2\n\n#define MAX_MARCHES 300\n#define DX 1.5\n#define OPACITY 0.2\n\nfloat rayfov;\nvec3 light;\n\n#define shadow_steps 90\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.\n\nfloat dt = 0.5;\n\n#define MOUSE_INDX 0\n#define ANGLE_INDX 1\n#define POS_INDX   2\n#define VEL_INDX   3\n#define SPEED_INDX 4\n#define MANIP_INDX 5\n\n//3d slice aspect ratio \n#define ar vec2(0.9,0.85)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, round(dim2from3(p3d)), textureSize(ch, 0));\n}\n\nvec4 texel(sampler2D ch, ivec2 p)\n{\n    return pixel(ch, vec2(p + 1), textureSize(ch, 0));\n}\n\nvec4 texel(sampler2D ch, vec2 p)\n{\n    return pixel(ch, round(p+1.), textureSize(ch, 0));\n}\n\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n\nfloat seed = 0.;\nfloat rand()\n{\n    float r = hash(seed);\n    seed = r;\n    return r;\n}\n\nvec3 rand3()\n{\n    vec3 r = hash31(seed);\n    seed = r.x*1.54879 + r.y*2.554963 + r.z*0.857836;\n    return r;\n}\n\nvec4 rand4()\n{\n    vec4 r = hash41(seed);\n    seed = r.x*1.54879 + r.y*2.554963 + r.z*0.857836 + r.w*3.5823758;\n    return r;\n}\n\n//normally distributed random numbers\nvec3 randn()\n{\n    vec4 rand = rand4();\n    vec3 box_muller = sqrt(-2.*log(max(vec3(rand.x,rand.x,rand.z),1e-8)))*vec3(sin(2.*PI*rand.y),cos(2.*PI*rand.y),sin(2.*PI*rand.w));\n    return box_muller;\n}\n\n//uniformly inside a sphere\nvec3 random_sphere()\n{\n    return normalize(randn())*pow(rand(),0.333333);\n}\n\nvec3 cosdistr(vec3 dir, float w)\n{\n    vec3 rand_dir = normalize(randn());\n    vec3 norm_dir = normalize(rand_dir - dot(dir,rand_dir)*dir);\n    float u = w*rand();\n    return normalize(dir*sqrt(1. - u) + norm_dir*sqrt(u));\n}\n\nbool inside(vec3 p)\n{\n    if(p.x > 1. && p.y > 1. && p.z > 1. && p.x < float(size3d.x)-1. && p.y < float(size3d.y)-1. && p.z < float(size3d.z)-1.)\n    {\n        return true;\n    }\n    else return false;\n}\n\n#define FOV 2.5\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat maxv(vec3 a)\n{\n    return max(max(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d - 1.) - p;\n    return min(minv(p),minv(a)) + 1.;\n}\n\nvec4 border_grad(vec3 p)\n{\n    const float dx = 0.001;\n    const vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*distance2border(p + k.xyy*dx) +\n\t\t\t k.yyxx*distance2border(p + k.yyx*dx) +\n\t\t\t k.yxyx*distance2border(p + k.yxy*dx) +\n\t\t\t k.xxxx*distance2border(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\n//encoding 2 values in one number\nfloat scaleFactor = 65530.0;\nfloat cp = 256.0 * 256.0;\n\n\n/* packs given two floats into one float */\nvec4 enc(vec4 x, vec4 y) {\n    vec4 x1 = round(x * scaleFactor);\n    vec4 y1 = round(y * scaleFactor);\n    vec4 f = (y1 * cp) + x1;\n    return f;\n}\n\n/* unpacks given float to two floats */\nvoid dec(in vec4 f, out vec4 x, out vec4 y){\n  vec4 dy = floor(f / cp);\n  vec4 dx = f - (dy * cp);\n  y = (dy / scaleFactor);\n  x = (dx / scaleFactor);\n}\n\nstruct particle\n{\n    vec4 pos;\n    vec4 vel;\n};\n\nparticle get(sampler2D ch, vec3 p)\n{\n    p = clamp(p, vec3(0.), size3d);\n    vec4 data = voxel(ch, p);\n    particle part;\n    dec(data, part.pos, part.vel);\n    part.pos.xyz *= size3d;\n    part.vel *= 10.;\n    return part;\n}\n\nvec4 save(particle a)\n{\n    //scale the numbers to be in a [-1,1] range\n    a.pos.xyz /= size3d;\n    return enc(a.pos, 0.1*a.vel);\n}\n    \nfloat force(float d)\n{\n    d *= 4.;\n    return -2.*(0.5*exp(-0.5*d) - 2.*exp(-3.*d));\n}\n\n\n//ray marching primitives, credits to Inigo Quilez \n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdLineBox(vec3 p, vec3 b, float r)\n{\n    p = abs(p);\n    float cx = sdCapsule(p, b, vec3(b.x,b.y,0), r);\n    float cy = sdCapsule(p, b, vec3(0,b.y, b.z), r);\n    float cz = sdCapsule(p, b, vec3(b.x,0, b.z), r);\n    return min(min(cx, cy),cz);\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\n//SIMULATION STUFF\nuniform sampler2D fakech0;\n    \nvoid Check(inout particle U, vec3 pos, vec3 dx)\n{\n    particle neighbor = get(fakech0, pos + dx);\n    //check if the stored neighbouring particle is closer to this position \n    if(length(neighbor.pos.xyz - pos) < length(U.pos.xyz - pos))\n    {\n        U = neighbor; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout particle U, vec3 p, int r)\n{\n    Check(U, p, vec3(-r, 0, 0));\n    Check(U, p, vec3(r, 0, 0));\n    Check(U, p, vec3(0, -r, 0));\n    Check(U, p, vec3(0, r, 0));\n    Check(U, p, vec3(0, 0, -r));\n    Check(U, p, vec3(0, 0, r));\n}\n\n//get the force from a particle in p0 to a particle at p\nvec3 getForce(vec3 p0, vec3 p)\n{\n\tparticle neighbor = get(fakech0, p0);\n    vec3 dx = neighbor.pos.xyz - p;\n    //only count if neighbor particle is inside of its cell to exclude repeated forces\n    if(maxv(abs(neighbor.pos.xyz - round(p0))) <= 0.5)\n        return normalize(dx)*force(length(dx));\n    else\n        return vec3(0.);\n}\n\n#define rad 2\nvec3 calc_force(vec3 p)\n{\n    vec3 p0 = round(p);\n    vec3 force = vec3(0.);\n    for( int i=-rad; i<=rad; i++ )\n        for( int j=-rad; j<=rad; j++ )\n            for( int k=-rad; k<=rad; k++ )\n    {\n        vec3 dx = vec3(i,j,k);\n        if(dx != vec3(0))\n          force += getForce(p0+dx, p);\n    }\n    \n    return force;\n}\n\n\nvoid init(out particle U, in vec3 p)\n{\n    if(distance2border(p) > 10.)\n    {\n        U.pos.xyz = vec3(3.*floor(p.xyz/3.));\n        vec3 rnd = hash33(U.pos.xyz+0.5);\n        U.pos.w = rnd.x;\n        U.vel.xyz = 0.05*(rnd*2. - 1.);\n        U.vel.w = clamp(0.4*(rnd.z)+sphere_rad,0.,2.);\n    }    \n    else\n    {\n        U.pos = vec4(-100.);\n        U.vel = vec4(0.);\n    }\n}\n\nvoid SimulationStep(inout particle U)\n{\n    vec4 border = border_grad(U.pos.xyz);\n    vec3 cvec = -U.pos.xyz*vec3(0,0,1);\n    vec3 G = 0.15*normalize(cvec)/size3d;\n   \n    vec3 force =calc_force(U.pos.xyz);\n    vec3 bound =1.*normalize(border.xyz)*exp(-0.4*border.w*border.w);\n    float cooling = 1. - (1.-exp(-0.3*length(U.vel.xyz)))*(0.01*exp(-0.05*dot(cvec,cvec)) + 0.01*exp(-0.4*border.w*border.w) + 0.08*exp(-0.1*dot(force,force)));\n    U.vel.xyz =  U.vel.xyz*cooling + dt*(bound+force+G);\n    U.pos.xyz += dt*U.vel.xyz;\n}\n\nvoid UpdateVoronoi(inout particle U, in vec3 p)\n{\n    //check neighbours \n    CheckRadius(U, p, 1);\n    CheckRadius(U, p, 2);\n    CheckRadius(U, p, 3);\n    CheckRadius(U, p, 4);\n}\n\n\n\n\n//Rendering \n\nfloat SDF_particle(vec3 p0, vec3 p)\n{\n    particle point = get(fakech0, p0);\n    return length(point.pos.xyz - p) - point.vel.w;\n}\n\nfloat SDF_particle_wlink(vec3 p0, vec3 p, vec3 p1)\n{\n    particle point = get(fakech0, p0);\n    float pde = length(point.pos.xyz - p) - point.vel.w;\n    #ifdef LINKS\n        if(length(point.pos.xyz - p1) < 3.)\n        {\n             pde = min(pde, sdCapsule(p, point.pos.xyz, p1, sphere_rad*0.2));\n        }\n    #endif\n    return pde;\n}\n\nvec4 opunion(vec4 a, vec4 b)\n{\n    if(a.w < b.w) return a;\n    else return b;\n}\n\n//distance estimator to the voronoi particle field\nfloat DE(vec3 p)\n{\n\tfloat de = 1e5;\n   \n   \tvec3 p0 =  round(clamp(p, vec3(0), size3d));\n    if(minv(abs(p - size3d*0.5)) > 0.55*maxv(size3d)) \n        de = length(p - size3d*0.5);\n    else\n    {\n        particle centr_partic = get(fakech0, p0);\n        vec3 p1 = centr_partic.pos.xyz;\n        de = min(de, length(p1-p) - centr_partic.vel.w);\n        de = min(de, SDF_particle_wlink(p0+vec3(1,0,0), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(-1,0,0), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(0,1,0), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(0,-1,0), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(0,0,1), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(0,0,-1), p, p1));\n        if(de < sphere_rad*2.)\n        {\n            de = min(de, SDF_particle_wlink(p0+vec3(1,1,1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(-1,1,1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(-1,-1,1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(-1,-1,-1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(1,-1,-1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(1,1,-1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(-1,1,-1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(1,-1,1), p, p1));\n        }\n    }\n    \n    return de;\n}\n\nvec3 particle_color(vec3 p)\n{\n    vec4 a = vec4(1e5);\n    vec3 p0 = round(p);\n    for( int i=-1; i<=1; i++ )\n        for( int j=-1; j<=1; j++ )\n            for( int k=-1; k<=1; k++ )\n    {\n        vec3 dx = vec3(i,j,k);\n        particle thisp = get(fakech0, p0+dx);\n        a = opunion(a, vec4(jet_range(thisp.pos.w, -0.1, 1.2), SDF_particle(p0+dx, p)));\n    }\n    return a.xyz;\n}\n\nvec3 COL(vec3 p)\n{\n    if(inside(p))\n    {\n        return particle_color(p)*exp(-0.25*pow(max(DE(p),0.),2.));\n    }\n    else return vec3(0.);\n}\n\nvec4 ray_march_vol(vec3 p, vec3 r)\n{\n    vec4 color = vec4(0., 0., 0., 0.);\n    vec4 background = vec4(0.1);\n    for(int i = 0; i < 90; i++)\n    {\n        vec3 tcolor = COL(p);\n        float density = length(tcolor);\n        float noise  =(1.+0.5*rand());\n        float d = 4.*DX*exp(-2.*min(density,2.))*noise;\n        float opacity = 1.-exp(-OPACITY*density*d);\n        float newa = max(color.w + (1. - color.w)*opacity,0.0001);\n        color.xyz = (color.xyz*color.w + (1.-color.w)*opacity*tcolor)/newa;\n        color.w = newa;\n        if(1. - newa < 0.02) break;\n        p += r*d;\n    }\n    return background + color;\n}\n\nvec3 truchet(vec2 p)\n{\n    float rnd = hash(floor(p.x) + floor(p.y)*1.55463);\n    bool cond = (rnd>0.5)?(mod(p.x,1.)+mod(p.y,1.)>1.):(mod(p.x,1.)+mod(p.y,1.)<1.);\n    return cond?jet_colormap(0.8*sin(5.*((1.-rnd)*p.x+rnd*p.y))):vec3(1.);\n}\n\nvec3 sdcolor(vec3 p)\n{\n    vec3 c = vec3(0.);\n    if(inside(0.8*(p-size3d*0.5) + size3d*0.5))\n    {  \n        c = particle_color(p);\n    }\n    else c = vec3(1.);\n    if(p.z < 2.)\n    {\t\n        c = 0.5 + 0.5*truchet(0.1*p.xy);\n    }\n    if(sdLineBox(p - size3d*0.5, size3d*0.5, 0.5) < 0.2) c = 0.15+0.85*jet_colormap(0.9*sin(0.1*(p.x+p.y+p.z)));\n    return c;\n}\n\n\nfloat map(vec3 p)\n{\n    float de_partic = DE(p); \n    de_partic = min(de_partic, sdPlane(p, vec4(0,0,1,0)));\n    return min(de_partic, sdLineBox(p - size3d*0.5, size3d*0.5, 0.5));\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*map(p + k.xyy*dx) +\n\t\t\t k.yyxx*map(p + k.yyx*dx) +\n\t\t\t k.yxyx*map(p + k.yxy*dx) +\n\t\t\t k.xxxx*map(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//usual ray marching stuff\n\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n\tfloat dDEdt = 0.;\n\tpos.w = map(pos.xyz);\n\tint i = 0;\n\tfor (; i < shadow_steps; i++) {\n\t\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n        vec3 ra =rand3()-0.5;\n        \n\t\tpos.w = (1. + 0.1*ra.x)*abs(map(pos.xyz));\n        dir.xyz = normalize(dir.xyz + 0.01*pos.w*ra/2.5*rayfov*dir.w);\n\t\n\t\tfloat angle = max((pos.w - 2.5*rayfov*dir.w)/(max(0.0001,dir.w)*light_angle), 0.);\n\t\t\n        light_visibility = min(light_visibility, angle);\n\t\t\n\t\tph = pos.w;\n\t\t\n        if(dir.w >= distance2light)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(dir.w > MAX_DIST || pos.w < max(2.*rayfov*dir.w, MIN_DIST))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(i >= shadow_steps)\n\t{\n\t\tlight_visibility=0.;\n\t}\n\t//return light_visibility; //bad\n\tlight_visibility = clamp(2.*light_visibility - 1.,-1.,1.);\n\treturn  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)\n}\n\n\n///PBR functions \nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n///END PBR functions\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(in vec3 pos)\n{\n    pos = pos.xzy;\n\t// Atmosphere Scattering\n\tvec3 fsun = light.xzy;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(pos.y-0.1),0.)),2.)+0.1));\n\tif(pos.y < 0.)\n\t{\n\t\tpos.y = 0.;\n\t\tpos.xyz = normalize(pos.xyz);\n\t}\n    float mu = dot(normalize(pos), normalize(fsun));\n\t\n\tvec3 extinction = mix(exp(-exp(-((pos.y + fsun.y * 4.0) * (exp(-pos.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-pos.y * 16.0) + 0.1) * Kr / Br) * exp(-pos.y * exp(-pos.y * 8.0 ) * 4.0) * exp(-pos.y * 2.0) * 4.0, vec3(1.0 - exp(fsun.y)) * 0.2, -fsun.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,10.);\n\treturn pow(sky_col,vec3(1./0.7)); \n}\n\nvec3 ambient_sky_color(in vec3 pos)\n{\n\tfloat y = pos.z;\n    pos.z = 0.;\n\treturn sky_color(pos)*exp(-abs(y));\n}\n\n\n\n\n\n", "buffer_a_code": "//3d voronoi particle tracking\nvoid Interactivity(inout particle U, vec3 p)\n{\n    vec2 angles = texel(ch3,  ivec2(ANGLE_INDX,0)).xy;\n    vec3 cray = getRay(angles, vec2(0.));\n    vec3 cpos = texelFetch(ch3,  ivec2(POS_INDX,0), 0).xyz;\n    vec4 manip = texelFetch(ch3,  ivec2(MANIP_INDX,0), 0);\n    vec2 uv = (iMouse.xy - 0.5*size)/max(size.x, size.y);\n    vec3 attract_pos = cpos + length(size3d*0.5 - cpos)*getRay(angles, uv);\n    //add particle\n    if(manip.x > 0.5) \n    {\n        if(length(p - cpos) < 4.) \n        {\n            U.pos.xyz = cpos+cray*0.6;\n            U.vel.xyz = cray*0.6;\n            U.pos.w = rand();\n            U.vel.w = 0.4*rand()+sphere_rad;\n        }\n        else if(!inside(cpos)  && length(p - size3d*0.5)<4. )\n        {\n            U.pos.xyz = size3d*0.5;\n            U.vel.xyz = -normalize(size3d*0.5 - attract_pos)*0.6;\n            U.pos.w = rand();\n            U.vel.w = 0.4*rand()+sphere_rad;\n        }\n    }\n    if(manip.w > 0.5 && iMouse.z>0.)\n    {\n       \n        U.vel.xyz += 0.02*dt*normalize(attract_pos - U.pos.xyz)/(2.*length((attract_pos - U.pos.xyz)/size3d)+1.); \n    }\n    //remove everything\n    if(manip.y > 0.5) \n    {\n        U.pos.xyz = vec3(10.);\n        U.vel.xyz = vec3(0.);\n        U.pos.w = 0.;\n        U.vel.w = 0.;\n    }\n}\n\nvoid mainImage( out vec4 pix, in vec2 pos )\n{\n     seed = iTime;\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n     vec4 manip = texelFetch(ch3,  ivec2(MANIP_INDX,0), 0);\n    dt = manip.z*dt;\n    //voxel pos\n    vec3 p = dim3from2(pos);\n    \n    //this particle\n    particle U;\n    \n    if(iFrame < 1)\n    {\n        init(U, p);\n    }\n    else\n    {\n        //get voxel particle\n        U = get(ch0, p);\n        UpdateVoronoi(U,p);\n        Interactivity(U, p);\n        SimulationStep(U);\n    }\n    \n    pix = save(U);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//3d voronoi particle tracking\n\nvoid mainImage( out vec4 pix, in vec2 pos )\n{\n     seed = iTime + pos.x + pos.y*3.141592653;\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    \n      vec4 manip = texelFetch(ch3,  ivec2(MANIP_INDX,0), 0);\n    dt = manip.z*dt;\n    \n    //voxel pos\n    vec3 p = dim3from2(pos);\n    \n    //this particle\n    particle U;\n    \n    if(iFrame < 1)\n    {\n        init(U, p);\n    }\n    else\n    {\n        //get voxel particle\n        U = get(ch0, p);\n        UpdateVoronoi(U,p);\n       // Interactivity(U, p);\n        SimulationStep(U);\n    }\n    \n    pix = save(U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//3d voronoi particle tracking\n\nvoid mainImage( out vec4 pix, in vec2 pos )\n{\n    seed = iTime + pos.x + pos.y*3.141592653;\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    \n    vec4 manip = texelFetch(ch3,  ivec2(MANIP_INDX,0), 0);\n    dt = manip.z*dt;\n    \n    //voxel pos\n    vec3 p = dim3from2(pos);\n    \n    //this particle\n    particle U;\n    \n    if(iFrame < 1)\n    {\n        init(U, p);\n    }\n    else\n    {\n        //get voxel particle\n        U = get(ch0, p);\n        UpdateVoronoi(U,p);\n        //Interactivity(U, p);\n        SimulationStep(U);\n    }\n    \n    pix = save(U);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/// UTILITY\n///\n/// Using the GPU as the CPU here, pretty inefficient I guess\n\n\n#define N_instructions 10.\n\n#define CAMERA_SPEED 1.\n#define MOUSE_SENSITIVITY 0.15/60.\n\n//Keyboard constants\nconst int KEY_SPACE  = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( ch3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.);\n    }\n    \n    if(fragCoord.x <= N_instructions && fragCoord.y <= 1.)\n    {\n        seed = iTime + fragCoord.x + fragCoord.y*3.141592653;\n        SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n  \t    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    \n        //instruction\n        int I = int(fragCoord.x); \n        fragColor = texelFetch(ch1,  ivec2(I,0), 0);\n        vec4 mouse = texelFetch(ch1,  ivec2(MOUSE_INDX,0), 0);\n        vec2 mousespeed = texelFetch(ch1,  ivec2(MOUSE_INDX,0), 0).xy;\n        vec4 angles = texelFetch(ch1,  ivec2(ANGLE_INDX,0), 0);\n        mat3 camera = transpose(getCamera(angles.xy));\n        vec4 posit = texelFetch(ch1,  ivec2(POS_INDX,0), 0);\n        vec4 vel = texelFetch(ch1,  ivec2(VEL_INDX,0), 0);\n\t\tvec4 speed = texelFetch(ch1,  ivec2(SPEED_INDX,0), 0);\n        vec4 modes = texelFetch(ch1,  ivec2(MANIP_INDX,0), 0);\n        vec4 norm = calcNormal(posit.xyz, 0.01);\n        norm.xyz = norm.xyz/(length(norm.xyz) + 0.01);\n        switch(I)\n        {\n        case MOUSE_INDX:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n  \t\t    {\n   \t\t\t\tfragColor.xy = iMouse.xy - fragColor.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    fragColor.xy = vec2(0.);\n                }\n            }\n            else\n            {\n\t\t\t\tfragColor.xy = vec2(0.); // mouse delta\n            }\n    \t\tfragColor.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case ANGLE_INDX:  //angle computation\n           \n   \t\t\tfragColor.xy = fragColor.xy + fragColor.zw*MOUSE_SENSITIVITY; // angle delta\n            fragColor.y = clamp(fragColor.y, -PI*0.5, PI*0.5);\n            if(modes.w <0.5)\n            {\n                fragColor.zw += vec2(1,-1)*mouse.xy; // mouse pos\n                fragColor.zw *= 0.8;\n                fragColor.y *= 1.- 0.01*clamp(length(vel.xyz),0.,1.);\n            }\n    \t\t\n             if(iFrame < 1)\n            {\n                fragColor.xy = vec2(-PI,0.1);\n            }\n            break;\n            \n        case POS_INDX:  //position\n          \n            float DeX = length(vel.xyz*speed.x)+0.0001;\n            float MAXDX = map(fragColor.xyz + vel.xyz*speed.x) + norm.w;\n            if(DeX > MAXDX)\n                vel *= 0.25;\n            fragColor.xyz += vel.xyz*speed.x;\n   \t\t\tfragColor.w = vel.w;\n            if(iFrame < 1)\n            {\n                fragColor.xyz = size3d*vec3(0.5,1.7,0.7);\n            }\n           \n            break;\n         case VEL_INDX:  //velocity\n          \n            fragColor.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            fragColor.xyz *= 0.8; //slowing down\n            \n            //collision detection, removing the normal velocity component \n            #define collision_dist 0.1\n          \tfragColor.xyz += norm.xyz*max(dot(fragColor.xyz, -norm.xyz),0.)*exp(-max(norm.w,0.)/collision_dist);\n            break;\n          case SPEED_INDX: //camera max speed\n            if(isKeyPressed(KEY_Q))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 1.01;\n            }\n            if(isKeyPressed(KEY_E))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 0.99;\n            }\n            if(iFrame < 1)\n            {\n                fragColor.x = CAMERA_SPEED;\n            }\n            break; \n          case MANIP_INDX:\n            if(isKeyPressed(KEY_SPACE) && iFrame%10==0)\n   \t   \t\t{\n   \t\t\t\tfragColor.x = 1.;\n            }\n            else\n            {\n                fragColor.x = 0.;\n            }\n            \n            if(isKeyPressed(KEY_C))\n   \t   \t\t{\n   \t\t\t\tfragColor.y = 1.;\n            }\n            else\n            {\n                fragColor.y = 0.;\n            }\n            \n            if(isKeyPressed(KEY_P) && iFrame%10==0)\n   \t   \t\t{\n   \t\t\t\tfragColor.z = 1. - fragColor.z;\n            }\n            \n            if(isKeyPressed(KEY_M) && iFrame%10==0)\n   \t   \t\t{\n   \t\t\t\tfragColor.w = 1. - fragColor.w;\n            }\n            \n            if(iFrame < 1)\n            {\n                fragColor = vec4(0.,0.,1., 1.);\n            }\n            break; \n        }   \n    } else discard;\n    \n   \n    \n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyGRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 245, 245, 385], [387, 387, 432, 458, 572], [574, 574, 641, 641, 1271], [1276, 1276, 1359, 1359, 3206], [3241, 3241, 3273, 3273, 4079], [4083, 4083, 4140, 4140, 5005]], "test": "untested"}
{"id": "tlGGRR", "name": "Truchet Noise", "author": "michael0884", "description": "Just a random thing I thought about", "tags": ["noise"], "likes": 8, "viewed": 396, "published": 3, "date": "1578075262", "time_retrieved": "2024-07-30T21:31:46.624524", "image_code": "\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 truchet(vec2 p)\n{\n    float rnd = hash(floor(p.x) + floor(p.y)*1.55463);\n    bool cond = (rnd>0.5)?(mod(p.x,1.)+mod(p.y,1.)>1.):(mod(p.x,1.)+mod(p.y,1.)<1.);\n    return cond?jet_colormap(0.8*sin(5.*((1.-rnd)*p.x+rnd*p.y))):vec3(1.);\n}\n\nvec3 truchet_noise(vec2 p)\n{\n    float scale =1.;\n    float amp = 1.;\n    float norm = 0.;\n    vec3 col = vec3(0);\n    for(int i = 0; i < 5; i++)\n    {\n        vec3 trc = truchet(scale*p+2.*pow(scale,0.3)*vec2(sin(iTime),cos(iTime)));\n        col += amp*trc;\n        norm += amp;\n        if(length(trc) > 1.5) break; //if white\n        scale*= 1.7;\n        amp*=0.55;\n    }\n    return col/norm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    // Output to screen\n    fragColor = vec4(1.05*truchet_noise(10.*uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGGRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 34, 105, 105, 149], [151, 151, 175, 175, 431], [433, 433, 461, 461, 517], [519, 519, 562, 562, 623], [626, 626, 647, 647, 732], [734, 734, 756, 756, 973], [975, 975, 1003, 1003, 1371], [1373, 1373, 1430, 1480, 1600]], "test": "untested"}
{"id": "WtyGzz", "name": "Wavy Fluid", "author": "wyatt", "description": "..", "tags": ["wave"], "likes": 10, "viewed": 486, "published": 3, "date": "1578068374", "time_retrieved": "2024-07-30T21:31:47.568002", "image_code": "float d (vec2 U) {\n\tvec4 a = (A(U)+B(U)+C(U)+D(U))/3.;\n    return dot(a,a);\n}\nMain\n{\n\tQ = sin(d(U)*vec4(1,2,3,4));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define Main void mainImage( out vec4 Q, in vec2 U )\n\n#define F(x) (sqrt(x)+exp(-40.*(x))+U.y*0e-4)\n\n#define dt 1.\n#define K .25\n#define Loss .01\n\n#define Border if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q *= 0.;\n#define Init if (iFrame < 1) Q = exp(-.01*length(U-0.5*R))*vec4(1,0,0,.5);\n#define Mouse if (iMouse.z>0.) Q.xyzw += .5*exp(-.001*dot(U-iMouse.xy,U-iMouse.xy))", "buffer_a_code": "Main\n{\n    vec4 \n         N = A(U+vec2(0,1)), \n         E = A(U+vec2(1,0)), \n         S = A(U-vec2(0,1)), \n         W = A(U-vec2(1,0)),\n         M = 0.25*(N+E+S+W); \n    Q = A(U);\n    float P = F(Q.x*Q.x+Q.y*Q.y);\n    vec2 L = (M-Q).xy;\n    Q.zw += dt*(L-K*Q.xy*P);\n\tQ.xy += dt*(Q.zw)+Loss*L;\n    Mouse*vec4(1,0,0,.5);\n    \n    Init\n    Border\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main\n{\n    vec4 \n         N = A(U+vec2(0,1)), \n         E = A(U+vec2(1,0)), \n         S = A(U-vec2(0,1)), \n         W = A(U-vec2(1,0)),\n         M = 0.25*(N+E+S+W); \n    Q = A(U);\n    float P = F(Q.x*Q.x+Q.y*Q.y);\n    vec2 L = (M-Q).xy;\n    Q.zw += dt*(L-K*Q.xy*P);\n\tQ.xy += dt*(Q.zw)+Loss*L;\n    Mouse*vec4(1,0,0,.5);\n    \n    Init\n    Border\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n{\n    vec4 \n         N = A(U+vec2(0,1)), \n         E = A(U+vec2(1,0)), \n         S = A(U-vec2(0,1)), \n         W = A(U-vec2(1,0)),\n         M = 0.25*(N+E+S+W); \n    Q = A(U);\n    float P = F(Q.x*Q.x+Q.y*Q.y);\n    vec2 L = (M-Q).xy;\n    Q.zw += dt*(L-K*Q.xy*P);\n\tQ.xy += dt*(Q.zw)+Loss*L;\n    Mouse*vec4(1,0,0,.5);\n    \n    Init\n    Border\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n{\n    vec4 \n         N = A(U+vec2(0,1)), \n         E = A(U+vec2(1,0)), \n         S = A(U-vec2(0,1)), \n         W = A(U-vec2(1,0)),\n         M = 0.25*(N+E+S+W); \n    Q = A(U);\n    float P = F(Q.x*Q.x+Q.y*Q.y);\n    vec2 L = (M-Q).xy;\n    Q.zw += dt*(L-K*Q.xy*P);\n\tQ.xy += dt*(Q.zw)+Loss*L;\n    Mouse*vec4(1,0,0,.5);\n    \n    Init\n    Border\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyGzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 77]], "test": "untested"}
{"id": "3lGGzR", "name": "Day 15", "author": "jeyko", "description": "asdf", "tags": ["asdf"], "likes": 8, "viewed": 527, "published": 3, "date": "1578055429", "time_retrieved": "2024-07-30T21:31:48.575309", "image_code": "\n#define iTime (iTime + 9.)\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define PI acos(-1.)\n#define pi acos(-1.)\n#define dmin(a, b) a.x < b.x ? a : b\n#define fov (0.8 + sin(iTime)*0.05)\n\n// thx nusan for refractions\n// and knighty/lsdlive/tdhooper and others for folding\n\nvec3 fold(vec3 p) {\n\tvec3 nc = vec3(-.5, -.809017, .309017 + sin(iTime)*0.002);\n\tfor (int i = 0; i < 5; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2.*min(0., dot(p, nc))*nc;\n\t}\n\treturn p - vec3(0, 0, 1.275);\n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return dir + right*uv.x*fov + up*uv.y*fov;\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e5);\n    \n    \n    vec3 q = p;\n    p = fold(p);\n    vec3 z = p;\n    float b = pow((1. + sin(p.x*3.)), 0.7) - 1.;\n    vec3 l = p;\n    l.xz *= rot(sin(iTime*0.7)*0.4 - 0.2);\n    b = min(b, sin(l.x*3.)*3.);\n    z.z += 0.2;\n    z.x += 0.82;\n    d = dmin(d, vec2(mix(dot(z - 0.6, vec3(0.1,0.1,0.2)), b, 0.1),1.));\n    q = fold(q) - vec3(0.5,0.6,-0.2);\n    q = abs(q);\n    q.z -= 0.2;\n    d = dmin(d, vec2( dot(q, normalize(vec3(1))),2.));\n    p.x -= 0.2;\n    p.y += 0.7;\n    \n    p = fold(p) - vec3(0.4,0.4,20.);\n    p = fold(p) - vec3(0.,0.4,20.);\n    p = fold(p) - vec3(0.,0.,1.);\n    \n    for (int i = 0;i < 2; i++){\n    \tp = abs(p);\n        p.x -= 0.2;\n    }\n    \n    p -= 7.;\n    \n    p = fold(p);\n    \n    p -= 0.6;\n    d = dmin(d, vec2( max(p.x, p.y), 1. ));\n    p.xy *= rot(2.5);\n    \n    d.x *= 1.;\n    d.x += sin(p.x*10.)*0.06;\n    return d;\n}\n    \n   \nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0.);\n    return normalize(map(p).x - vec3(\n        map(p - t.xyy).x,\n        map(p - t.yxy).x,\n        map(p - t.yyx).x\n    ));\n}\n\n\n#define zoom (7. + sin(iTime)*0.4)\n#define rotSpeed (iTime*0.2 + cos(iTime*0.7)*0.5 - sin(iTime*0.5)*0.9)\n\n#define pal(x,t) (0.5 + sin(x*vec3(2.9,5.,1.2) + t + sin(iTime)))\n\nvec3 glow = vec3(0);\n#define mx (20.*iMouse.x/iResolution.x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(sin(rotSpeed + mx)*zoom,0. + sin(iTime),cos(rotSpeed + mx)*zoom);\n    vec3 lookAt = vec3(0);\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 p = ro; float t, tBeforeRefraction = 0.;\n    \n    float bounce = 0.;\n    vec3 attenuation = vec3(1);\n    float side = 1.;\n    #define ITERS 200.\n    for(float i = 0.; i <= ITERS ; i ++){\n    \tvec2 d = map(p);\n        d.x *= side;\n\t\tglow += pal(t*0.2 + exp(-d.x*10.) + 2., 2.6)* .095 / (.01 + d.x*d.x);\n        \n        if (d.x < 0.002){\n            vec3 lDir = normalize(vec3(1));\n            vec3 n = getNormal(p)*side;\n            vec3 h = normalize(lDir - rd);\n            \n            float diff = max(dot(lDir,n),0.);\n            float fres = pow(1. - max(dot(-rd,n),0.), 20.);\n            float spec = pow(max(dot(h,n),0.), 10.);\n            if (d.y == 2.) {\n            \tcol += mix( (sin(vec3(2.9,2.9,2.6)*glow*0.005) + 7.)*0.1 *diff ,vec3(0.005*glow*min(fres*spec*diff, 1.)), 0.2)*attenuation;\n                break;\n            } else {\n                col += mix( 0.001*glow *diff ,vec3(0.005*glow*min(fres*spec, 1.)), 0.5)*attenuation;\n                attenuation *= vec3(0.2,0.4,0.9)*0.6;\n                ro = p;\n                rd = refract(rd, n, 1. + n.y*0.07 + n.x*0.2);\n                side = -side;\n                bounce++;\n                if(bounce == 1.) {\n                    tBeforeRefraction = t;\n                }\n\n                t = 0.;\n                d.x = 0.2;\n            }\n            \n\n            \n            //break;\n        }\n        if (t > 50. || i == ITERS) {\n            if (bounce == 0.) {\n\t\t\t\ttBeforeRefraction = t;\n            }\n        \tbreak;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    col -= exp(-7. +tBeforeRefraction*0.14);\n    \n    col *= 1.9;\n    col = clamp(col, 0., 1.);\n    \n    col = mix(col, vec3(0.02,0.03,0.05),smoothstep(0.,1.,0.2 + tBeforeRefraction*0.01));\n    col = pow(col, vec3(0.45));\n    \n    col *= 1.5;\n    col *= 1. - pow(length(uv)*0.5 + 0.37, 4.);\n    fragColor = vec4(col,tBeforeRefraction);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGGzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 301, 301, 482], [485, 485, 527, 527, 709], [711, 711, 728, 728, 1594], [1604, 1604, 1627, 1627, 1781], [2020, 2020, 2077, 2077, 4215]], "test": "untested"}
{"id": "wtd3Ds", "name": "Noise Fun #3 - Freaky Eyes", "author": "ndxbxrme", "description": "#don't you open that trap doooor#", "tags": ["noise", "bezier", "pixel", "spooky"], "likes": 3, "viewed": 460, "published": 3, "date": "1578040597", "time_retrieved": "2024-07-30T21:31:49.454957", "image_code": "vec2 bezier(in vec2 p1, in vec2 p2, in vec2 p3, in float t)\n{\n    float oneminust = 1. - t;\n    return oneminust * oneminust * p1 + 2. * oneminust * t * p2 + t * t * p3;\n}\n\nfloat eye(in vec2 uv, in float startY, in float endY)\n{\n    float blink = snoise(vec3(iTime, 1., 1.));\n    float f = bezier(vec2(0., startY), vec2(.5, 1.2), vec2(1., endY), uv.x).y;\n    f = smoothstep(f, f + 0.01, uv.y);\n    float f1 = bezier(vec2(0., startY), vec2(0.), vec2(1., endY), uv.x).y;\n    f1 = smoothstep(f1, f1 + 0.01, uv.y);\n    float pnoise = snoise(vec3(iTime * .1, 1., 1.));\n    float pnoise2 = snoise(vec3(1., iTime * .1, 1.));\n    float r = length(vec2(uv - vec2(0.5 + pnoise * .3, 0.44 + pnoise2 * .2)));\n    float p = smoothstep(0.2, 0.1, r);\n    float iris = smoothstep(0.3, 0.2, r);\n\treturn blink > .4 ? 0.0 : clamp(((1. - f) * f1) - p - (iris * .6), 0., 1.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5*iResolution.xy) / iResolution.y;\n    float pixelsize = 0.025;\n\tuv = floor(uv/pixelsize)*pixelsize;\n    //uv -= mod(uv,pixelsize)-pixelsize*0.5;\n    float f = eye((uv * 1.5) - vec2(-1.05, -0.4), 0.3, 0.2);\n    f += eye((uv * 1.5) - vec2(0.05, -0.4), 0.2, 0.3);\n    vec3 col = vec3(f);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//simplex noise from https://thebookofshaders.com/edit.php#11/iching-03.frag\nvec3 random3(vec3 c) {\n    float j = 43960.0*sin(dot(c,vec3(170.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nconst float F3 =  0.3333333333;\nconst float G3 =  0.1666666667;\nfloat snoise(vec3 p) {\n\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    vec4 w, d;\n\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    w = max(0.6 - w, 0.0);\n\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    w *= w;\n    w *= w;\n    d *= w;\n\n    return dot(d, vec4(52.0));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtd3Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 171], [173, 173, 228, 228, 861], [863, 863, 920, 920, 1266]], "test": "untested"}
{"id": "tlt3Ds", "name": "Noise Fun #2", "author": "ndxbxrme", "description": "simplex noise and a 3 point bezier curve came out a bit playstationish", "tags": ["2d", "noise", "bezier", "simplex"], "likes": 8, "viewed": 540, "published": 3, "date": "1578027249", "time_retrieved": "2024-07-30T21:31:50.266787", "image_code": "\nvec2 bezier(in vec2 p1, in vec2 p2, in vec2 p3, in float t)\n{\n    float oneminust = 1. - t;\n    return oneminust * oneminust * p1 + 2. * oneminust * t * p2 + t * t * p3;\n}\n\nfloat wobbler(in vec2 uv, in float offset)\n{\n    float n = snoise(uv.xyx + iTime * offset);\n\tvec2 p1 = vec2(0.0, .5 + .2 * sin(iTime) + n * .2);\n    vec2 p2 = vec2(0.5, 0.5 + n * .1);\n    vec2 p3 = vec2(1.0, .5 + .2 * cos(iTime) + n * .2);\n    vec2 p = bezier(p1, p2, p3, uv.x);\n    float y = p.y + n * .1;\n    return pow(smoothstep(p.y + .34, p.y + .3, uv.y) * smoothstep(y, y + .04, uv.y), 5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y += .2;\n    float f = wobbler(uv, .1) * .3;\n    f += wobbler(uv, .2) * .3;\n    f += wobbler(uv, .11) * .3;\n    vec3 col = vec3(0.2, 0.5, 0.7) * vec3(f) * 1.5 + .2 - length(uv - vec2(.5, .8)) * .1;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//simplex noise from https://thebookofshaders.com/edit.php#11/iching-03.frag\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    vec4 w, d;\n\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    w = max(0.6 - w, 0.0);\n\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    w *= w;\n    w *= w;\n    d *= w;\n\n    return dot(d, vec4(52.0));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlt3Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 62, 62, 172], [174, 174, 218, 218, 572], [574, 574, 631, 631, 909]], "test": "untested"}
{"id": "wltGWs", "name": "Noise Fun #1", "author": "ndxbxrme", "description": "a bit underwatery", "tags": ["2d", "noise", "radial"], "likes": 3, "viewed": 402, "published": 3, "date": "1578017148", "time_retrieved": "2024-07-30T21:31:51.118509", "image_code": "\nvec2 rotate(in vec2 uv, in float a)\n{\n\t//uv -= .5;\n    uv *= mat2(cos(a), -sin(a),\n               sin(a), cos(a));\n    //uv += .5;\n    return uv;\n}\nfloat pn(vec3 p) {\n\t//noise function by CPU https://www.shadertoy.com/view/4sfGRH\n    vec3 i = floor(p); \n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*3.141592653589793)*(-.5) + .5;  \n\ta = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y);   \n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat getNoise(vec2 pos, float pulse, float time) {\n\tvec3 q = vec3(pos * 2., pos.x-pos.y + time * 0.3);\n\tfloat b = (pulse * 1.6) + pn(q * 2.) + 2.8;\n\tb +=  .25 * pn(q * 4.);\n\tb +=  .25  * pn(q * 8.);\n\tb +=  .5  * pn(vec3(pos, pos.x-pos.y + time * 0.3) * 12.23);\n\tb = pow(b,0.5);\t\n\treturn b;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.y += 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float r = length(uv) * 2.;\n    float f = 0.;\n    uv = rotate(uv, iTime * .1);\n    for(int j; j<10; j++)\n    {\n        uv = rotate(uv, 1.12);\n        float p = 0.0 + (getNoise(uv * 2., 0., iTime)) * .2 * abs(uv.x);\n        float a = length(uv.y);\n        f += smoothstep(p - .1, p, a) * smoothstep(p + .1, p, a);\n    }\n    f = smoothstep(.6, .9, f);\n    vec3 col = vec3(0.5, 0.5 + .2 * cos(iTime + uv.y), 1.) * (f + f * .5) * 2. - r;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltGWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 38, 51, 148], [149, 149, 167, 230, 493], [495, 495, 546, 546, 787], [788, 788, 845, 845, 1454]], "test": "untested"}
{"id": "wtdGWl", "name": "Tree Tutorial", "author": "specialsaucewc", "description": "Making trees and parallax", "tags": ["tutorial", "parallax", "trees", "snow", "winter", "boxcutting"], "likes": 10, "viewed": 820, "published": 3, "date": "1577998162", "time_retrieved": "2024-07-30T21:31:52.057997", "image_code": "#define S(a, b, t) smoothstep(a,b,t)\n#define LAYER_COUNT 10.\n#define MOON_SIZE .15\n#define TREE_COL vec3(.8, .8, 1.)\n#define ORBIT_SPEED .025\n#define SCROLL_SPEED .3\n#define ROT -0.785398\n#define ZOOM .4\n#define STAR_SPEED .25\n\nfloat N11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat N21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat DistLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n    return length(pa - ba*t);\n}\n\n\nfloat DrawLine(vec2 p, vec2 a, vec2 b) {\n    float d = DistLine(p, a, b);\n    float m = S(.00125, .000001, d);\n    float d2 = length(a-b);\n    m *= S(1., .5, d2) + S(.04, .03, abs(d2-.75));\n    return m;\n}\n\nfloat ShootingStar(vec2 uv) {    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float h = N21(id);\n    \n    float line = DrawLine(gv, vec2(0., h), vec2(.1, h));\n    float trail = S(.12, .0, gv.x);\n\t\n    return line * trail;\n}\n\nfloat LayerShootingStars(vec2 uv) {\n    float t = iTime * STAR_SPEED;\n    vec2 rv1 = vec2(uv.x - t, uv.y + t);\n    rv1.x *= 1.05;\n    \n    float r = 3. * ROT;\n    float s = sin(r);\n    float c = cos(r);\n    mat2 rot = mat2(c, -s, s, c);\n    rv1 *= rot;\n    rv1 *= ZOOM * .9;\n    \n    vec2 rv2 = uv + t * 1.2;\n    rv2.x *= 1.05;\n    \n    r = ROT;\n    s = sin(r);\n    c = cos(r);\n    rot = mat2(c, -s, s, c);\n    rv2 *= rot;\n    rv2 *= ZOOM * 1.1;\n    \n    float star1 = ShootingStar(rv1);\n    float star2 = ShootingStar(rv2);\n    return clamp(0., 1., star1 + star2);\n}\n\nfloat GetHeight(float x) {\n    return sin(x*.412213)+sin(x)*.512347;\n}\n\nfloat TaperBox(vec2 p, float wb, float wt, float yb, float yt, float blur) {\n    //bottom edge\n    float m = S(-blur, blur, p.y - yb);\n    //top edge\n    m *= S(blur, -blur, p.y - yt);\n    //mirror x to get both edges\n    p.x = abs(p.x);\n    //side edges\n    // 0 p.y = yb 1 p.y = yt\n    float w = mix(wb, wt, (p.y - yb) / (yt - yb));\n    m *= S(blur, -blur, p.x - w);\n    return m;\n}\n\nvec4 Tree(vec2 uv, vec3 col, float blur) {\n    float m = TaperBox(uv, .03, .03, -.05, .25, blur); //trunk\n    m += TaperBox(uv, .2, .1, .25, .5, blur); //canopy 1\n    m += TaperBox(uv, .15, .05, .5, .75, blur); //canopy 2\n    m += TaperBox(uv, .1, .0, .75, 1., blur); //top\n    \n    blur *= 3.;\n    float shadow = TaperBox(uv-vec2(.2,0.), .1, .5, .15, .253, blur);\n    shadow += TaperBox(uv+vec2(.25,0.), .1, .5, .45, .503, blur);\n    shadow += TaperBox(uv-vec2(.25,0.), .1, .5, .7, .753, blur);\n    col -= shadow*.8;\n    \n    return vec4(col, m);\n}\n\nvec4 Layer(vec2 uv, float blur) {\n    vec4 col = vec4(0);\n    float id = floor(uv.x);\n    \n    //random [-1, 1]\n    float n = N11(id)*2.-1.;\n    float x = n*.3;\n    float y = GetHeight(uv.x);\n    \n    //ground\n    float ground = S(blur, -blur, uv.y-y);\n    col += ground;\n    \n    y = GetHeight(id + .5 - x);\n    \n    //vertical grid\n    uv.x = fract(uv.x)-.5;\n    //\t\t\t\t\t offset\t\tscale tree size\t\tcolor\n    vec4 tree = Tree((uv+vec2(x,-y))*vec2(1, 1.+n*.2), vec3(1), blur);\n    \n    col = mix(col, tree, tree.a);\n    col.a = max(ground, tree.a);\n    return col;\n}\n\nvec2 MoonPos() {\n    float t = iTime * ORBIT_SPEED;\n    return vec2(sin(t), cos(t))/2.;\n}\n\nvec4 MoonGlow(vec2 uv) {\n    vec2 moonPos = MoonPos();\n    float md = length(uv-(moonPos - vec2(.07, 0.01)));\n    float moon = S(.1, -.01, md-MOON_SIZE*8.);\n    moon = mix(0., moon, clamp((moonPos.y + .2)*3., 0., 1.));\n    \n    vec4 col = vec4(moon);\n    md = clamp(1.-md, 0., 1.);\n    md *= md;\n    col.rgb *= md;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy/iResolution.xy)*2.-1.;\n    float t = iTime * SCROLL_SPEED;\n    float blur = .005;\n    \n    float twinkle = dot(length(sin(uv+t)), length(cos(uv*vec2(22., 6.7)-t*3.)));\n    twinkle = sin(twinkle*5.)*.5+.5;\n    float stars = pow(N21(uv*1000.), 1024.)*twinkle;\n    vec4 col = vec4(stars);\n    \n    vec2 moonPos = MoonPos();\n    float moon = S(.01, -.01, length(uv-moonPos)-MOON_SIZE);\n    col *= 1.-moon;\n    moon *= S(-.01, .05, length(uv-(moonPos+vec2(.1,.05)))-MOON_SIZE);\n    col += moon;\n    \n    col += LayerShootingStars(uv);\n    \n    vec4 layer;\n    for (float i=0.; i <1.; i+=1./LAYER_COUNT) {\n        float scale = mix(30., 1., i);\n        blur = mix(.05, .005, i);\n        layer = Layer(uv*scale+vec2(t+i*100.,i)-M, blur);\n        layer.rgb *= (1.-i) * TREE_COL;\n        col = mix(col, layer, layer.a);\n    }\n    col += MoonGlow(uv);\n    \n    layer = Layer(uv+vec2(t,1.)-M, .07);\n    col = mix(col, layer*.05, layer.a);\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdGWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 248, 248, 333], [335, 335, 354, 354, 471], [473, 473, 513, 513, 638], [641, 641, 681, 681, 846], [848, 848, 877, 877, 1089], [1091, 1091, 1126, 1126, 1658], [1660, 1660, 1686, 1686, 1730], [1732, 1732, 1808, 1826, 2116], [2118, 2118, 2160, 2160, 2667], [2669, 2669, 2702, 2702, 3233], [3235, 3235, 3251, 3251, 3324], [3326, 3326, 3350, 3350, 3658], [3660, 3660, 3717, 3717, 4758]], "test": "untested"}
{"id": "wtt3WX", "name": "Murakami Infinity", "author": "PixelPhil", "description": "An infinite field of smiling flowers based on the artwork of Takeshi Murakami.\nI hope this brings you joy.\n\nMusic : Towa No Hana (Flowers of Eternity) by Yoko Ishida", "tags": ["procedural", "art", "flowers", "takashi", "murakami"], "likes": 48, "viewed": 1628, "published": 3, "date": "1577990695", "time_retrieved": "2024-07-30T21:31:52.868829", "image_code": "//\n// Murakami Infinity by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// I have recently grown a fascination towards the art of Takashi Murakami, \n// especially his colorful flower series.\n// His vision is, not unlike Andy Warhol, that art can be mass produced with\n// endless variations of a basic concept. This led me to the thinking that, \n// at the extreme, these compositions could be auto-generated.\n//\n// I tried to reproduce Murakami's compositions following rules that are as true as\n// possible to the reference painting.\n//\n// I stuck with the black & white eyes although they are red and blue on most of the\n// paintings because I find them more pleasing this way. I might make a variation someday.\n//\n// The flower is re-created with a serie of ellipses in polar coordinates.\n//\n// I hope this brings you joy.\n\n// p.s : I just realized mhnewman attempted something similar, oh well... ;)\n\n\n#define S(a,b,t) smoothstep(a,b,t)\n\n// An ellipse signed distance function by iq\n// https://iquilezles.org/articles/ellipsedist\nfloat sdEllipse( in vec2 z, in vec2 ab )\n{\n    vec2 p = vec2(abs(z));\n    \n    if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l; float m2 = m*m;\n    float n = ab.y*p.y/l; float n2 = n*n;\n    float c = (m2 + n2 - 1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 closestPoint = vec2( ab.x*co, ab.y*si );\n\t\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\n\n// rotates pos to align the up vector towards up\nvec2 rotUp(vec2 pos, vec2 up)\n{\n    vec2 left = vec2(-up.y, up.x);\n    return left * pos.x + up * pos.y;\n}\n\nconst float pi = 3.1415926;\nconst float pi2 = 6.2831853;\nconst float quadrant = pi / 6.0;\n\nconst float blackLevel = 0.3; // True black is too aggressive\n\n\n\n// The mouth is the intersection of two ellipses, I traced them in photoshop to\n// compute the right radii and offsets\nfloat mouthDst(vec2 uv)\n{\n    return max(sdEllipse(uv - vec2(0.0, -0.17), vec2(0.30, 0.2055)),\n               sdEllipse(uv - vec2(0.0,  0.07), vec2(0.14, 0.2055)));\n}\n\n// For the eye, I use simpler circle distance maths in a scales and rotated space\n// as I don't need an accurate distance function to create an outline\nvec4 eye(vec2 uv, vec2 up, vec2 spot1, vec2 spot2, float scale)\n{\n    uv = rotUp(uv, up);\n    uv.x *= 1.5;\n    \n    float len = length(uv);\n    float len2 = length(uv + spot1);// vec2(0.010, 0.025));\n    float len3 = length(uv + spot2);// vec2(-0.005, -0.017));\n    \n    float aa = scale * 4.0 / iResolution.x;\n    \n    vec4 eye;\n    \n    eye.a = S(0.04 + aa, 0.04, len);\n    \n    eye.rgb = vec3(S(0.014, 0.014 - aa, len2) + S(0.02, 0.02 - aa, len3) + blackLevel);\n    \n    return eye;\n}\n\nconst float cRatio = 1.0 / 255.0;\n\n// I wanted the color palette to be true to the 16 hue rainbow used\n// by Murakami but I didn't manage to reproduce the orange-yellow-green part\n// using simple maths so I defaulted to a palette. Then I realized I couldn't target\n// Webgl < 3.0 (Wich was one of my objectives) with array constructor so I decided\n// to build a function selecting the right color with a dichotomic approch in hope\n// that the compiler will make a decent job of optimizing all those branches.\nvec3 palette(float id)\n{\n\tif (id < 6.0)\n    {\n        //[0 - 5]\n        if (id < 3.0)\n        {   //[0 - 2]\n            if (id < 1.0) return vec3(181.0, 23.0, 118.0) * cRatio;\n            else if (id < 2.0) return vec3(225.0, 27.0, 104.0) * cRatio;\n            else return vec3(230.0, 40.0, 24.0) * cRatio;\n        }\n        else\n        {   //[3 - 5]\n            if (id < 4.0) return vec3(240.0, 110.0, 14.0) * cRatio;\n            else if (id < 5.0) return vec3(253.0, 195.0, 2.0) * cRatio;\n            else return vec3(253.0, 241.0, 121.0) * cRatio;\n        }\n    }\n    else\n    {   //[6 - 11]\n        if (id < 9.0)\n        {   //[6 - 8]\n            if (id < 7.0) return vec3(167.0, 202.0, 56.0) * cRatio;\n            else if (id < 8.0) return  vec3(0.0, 152.0, 69.0) * cRatio;\n            else return vec3(2.0, 170.0, 179.0) * cRatio;\n        }\n        else\n        {   //[9 - 11] The darker color are at the end to be avoided by mod\n            if (id < 10.0) return vec3(25.0, 186.0, 240.0) * cRatio;\n            else if (id < 11.0) return  vec3(0.0, 98.0, 171.0) * cRatio;\n            else return vec3(40.0, 49.0, 118.0) * cRatio;\n        }\n    }\n}\n\n\n\n// Adapted from BigWIngs\nvec4 N24(vec2 t) {\n    float n = mod(t.x * 458.0 + t.y * 127.3, 100.0);\n\treturn fract(sin(n*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\n\n// That's where the meat of the shader is, drawing a flower\nvec4 flower(vec2 uv, vec2 id, float minSz, float maxSz, float scale)\n{\n    vec4 rnd = N24(id);//mod(id.x, 300.0) * mod(id.y, 500.0) * 13.56);\n    \n    float rdScale = mix(minSz, maxSz, rnd.z);\n    \n    scale *= rdScale; // The border thickness & AA is scale-independant\n    \n    uv.xy *= rdScale;\n    \n    uv.x += 0.1 + rnd.x * 0.5;\n    uv.y += 0.25 + rnd.y * 0.2;\n    uv.y += sin(iTime * mix(0.4, 1.0, rnd.y) + (rnd.w * 45.0)) * 0.2;\n\n    \n    float aa2 = scale * 3.0 / iResolution.x;\n    \n    float centerDst = length(uv);\n    \n    if (centerDst > 0.5) return vec4(0.0);\n    \n    float edge; // Mask for the outline edge\n    \n    vec4 color = vec4(1.0, 1.0, 1.0, 1.0); // Underlying color\n   \n    \n    float thick = 0.002 * scale;\n    \n    if (centerDst < 0.2)\n    {\n        //Face part\n        \n        float thres = 0.2 - thick;\n        \n        // inner part of edge circle surrounding the head\n        edge =  S(thres, thres - aa2, centerDst);\n        \n        float mouth = mouthDst(uv);\n        \n        // edge of the mouth\n        edge *= S(thick, thick + aa2, abs(mouth));\n        \n        // face color\n        float faceRnd = fract(rnd.x * 45.0 + rnd.y * 23.45);\n        if (faceRnd < 0.5) \n        {\n            // Flowers with classic yellow / red faces\n        \tcolor.rgb = (mouth < 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(1.0, 1.0, 0.0); \n        }\n        else\n        {\n            // Flowers with white face / random color mouth\n            float colId = mod(faceRnd * 545.456, 11.0);\n            color.rgb = (mouth < 0.0) ? palette(colId) : vec3(1.0); \n        }\n        \n        // Eyes\n        vec4 eyeImg;\n        if (uv.x > 0.0)\n        {\n           eyeImg = eye(uv - vec2(0.075, 0.095), vec2(-0.7, 1.2),\n                       vec2(0.007, 0.025), vec2(-0.004, -0.019), scale);\n        }\n        else   \n        {\n           eyeImg = eye(uv - vec2(-0.075, 0.095), vec2(0.7, 1.2),\n                       vec2(0.024, 0.010), vec2(-0.016, -0.009), scale);\n        }\n\n        color.rgb = mix(color.rgb, eyeImg.rgb, eyeImg.a);\n    }\n    else\n    {\n        float rot = iTime * rnd.y * 0.5;\n        float angle = fract((atan(uv.x, uv.y) + rot) / pi2);\n    \n        float section = angle * 12.0;\n        float sectionId = floor(section);\n        \n        if (rdScale < 0.86 && rnd.w > 0.55)\n        {\n           // Rainbow flower\n           color.rgb = palette(sectionId);//mod(sectionId + (rnd.x + rnd.y) * 345.456, 12.0));\n        }\n        else if (rnd.y > 0.05)\n        {\n            //Alternating flower\n            if (mod(sectionId, 2.0) == 0.0)\n            {\n                // Color 1\n                float colId = mod((rnd.x + rnd.y) * 345.456, 10.0);\n                color.rgb = palette(colId);\n            }\n            else if (rnd.x > 0.75)\n            {\n                // Color 2\n                float colId = mod((rnd.w + rnd.z) * 545.456, 11.0);\n                color.rgb = palette(colId);\n            }\n            // else, Color2 is white by default\n        }\n\t\t// else, fully white petals\n        \n        if (centerDst < 0.36)\n        {\n            //intermediate part, concentric bars\n            \n            float sectionX = fract(section);\n            float edgeDist = 0.5 - abs(sectionX - 0.5);\n            \n            edgeDist *= centerDst; // Untaper bar space so bars have constant thickness\n            \n            float aa = scale * 7.0 / iResolution.x;\n            float bar = thick * 1.7;\n            edge = S(bar, bar + aa, edgeDist);\n\n            // outer part of edge circle surrounding the head\n            float thres = 0.2 + thick;\n            float head = S(thres, thres + aa2, centerDst);\n            edge *= head;\n        }\n        else\n        {\n            // Petal tips are actually ellipses, they could have been approximated them with\n            // circles but I didn't because I have OCD and I needed the ellipse SDF \n            // for the mouth anyways ;)\n            \n            // Angle to the center of the quadrant\n            float quadAngle = (sectionId + 0.5) * quadrant - rot + pi; \n\n            // Center of the ellipse\n            vec2 petalUp = vec2(-sin(quadAngle), -cos(quadAngle));\n            vec2 petalCenter = petalUp * 0.36;\n\n            // Rotation of the ellipse basis\n            vec2 petalSpace = rotUp(uv - petalCenter, petalUp);\n\n            // Signed distance function of the ellipse\n            float petalDst = sdEllipse(petalSpace, vec2(0.0944, 0.09));\n\n            //border edge and alpha mask\n            float borderIn = S(thick + aa2, thick, petalDst);\n            float borderOut = S(-thick, -thick - aa2, petalDst);\n\n            edge = (borderOut);\n            \n            color.a = borderIn;\n        }\n    }\n    \n    color.rgb = mix(vec3(blackLevel), color.rgb,edge);\n    \n    return color;\n}\n\n\nvec3 flowerLayer(vec2 uv, vec3 bg, float minSz, float maxSz, float scale)\n{\n    vec2 cellId = floor(uv);\n    vec2 cellUv = fract(uv) - vec2(0.5);\n   \n    //Check only 4 cells because the flower function is rather costly\n    for (float x = 0.0; x <= 1.0; x += 1.0)\n    {\n        for (float y = 0.0; y <= 1.0; y += 1.0)\n    \t{\n            vec2 offset = vec2(x, y);\n            \n            vec4 f = flower(cellUv - offset, cellId + offset, minSz, maxSz, scale);\n    \t\tbg = mix(bg, f.rgb, f.a);\n    \t}\n    }\n    \n    return bg;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y; \n    \n    float sc = 1.65 + cos(iTime* 0.1) * 0.25;\n    \n    uv.xy *= sc;\n    \n    uv.x += 35.9;\n    uv.y += 45.0;\n    \n \n    float scroll = iTime * 0.25;\n    \n\n   \tfloat t = iTime * 0.23;\n    vec3 col = vec3(0.8) + vec3(0.2) * sin(t + vec3(0.0, pi * 0.5, pi));\n    \n    col = flowerLayer(uv * 4.0 + vec2(scroll, -scroll * 0.3 + 59.0), col, 0.8, 1.0, 2.0 * sc);\n    col = flowerLayer(uv * 3.0 + vec2(scroll, -scroll * 0.2 + 59.0), col, 0.7, 1.25, 1.5 * sc);\n    col = flowerLayer(uv * 2.0 + vec2(scroll, -scroll * 0.1 + 345.0), col, 0.8, 2.0, 1.0 * sc);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 20710, "src": "https://soundcloud.com/anime-easy/ai-yori-aoshi-towa-no-hana", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtt3WX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1047, 1139, 1181, 1181, 2327], [2330, 2379, 2410, 2410, 2485], [2643, 2762, 2787, 2787, 2928], [2930, 3082, 3147, 3147, 3569], [3606, 4080, 4104, 4104, 5234], [5238, 5263, 5281, 5281, 5422], [5424, 5484, 5554, 5554, 10278], [10281, 10281, 10356, 10356, 10807], [10811, 10811, 10868, 10868, 11550]], "test": "untested"}
{"id": "3tdGDs", "name": "sin functions - 001", "author": "catafest", "description": "... a simple sin function using the abs(y - sin(x)) function to show it ", "tags": ["sin", "functions", "catafest"], "likes": 2, "viewed": 781, "published": 3, "date": "1577989906", "time_retrieved": "2024-07-30T21:31:53.991827", "image_code": "// sin function graphic\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set uv \n    vec2 uv = fragCoord/iResolution.xy;\n    // set the resolution by double uv move with 1.0\n    vec2 resolution = uv*2.0 - 1.0;\n   \tresolution.x *= iResolution.x / iResolution.y;\n    \n    // set coordonate x and y by resolution\n    float x = resolution.x * 2.0;\n    float y = resolution.y;\n    // y = sin(x) \n    // need a absolute referenced value y - sin(x) because I used resolution var\n    float ref = abs(y - sin(x));\n    // create color output function var \n    vec3 color = ref * vec3(0.0, 0.0, 76.0);  \n    // show the function using the vec4 \n    fragColor = vec4( color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 97, 686]], "test": "untested"}
{"id": "3ld3Wl", "name": "Cheap normal map with sobel", "author": "boysx", "description": "normal map generator with sobel operator", "tags": ["map", "normal", "generator"], "likes": 13, "viewed": 684, "published": 3, "date": "1577967740", "time_retrieved": "2024-07-30T21:31:55.279384", "image_code": "float lum(vec3 c)\n{\n    return 0.2126*c.r + 0.7152*c.g + 0.0722*c.b;\n    // fast alternative\n    // const float oneThird = 1./3.;\n    // return (c.x + c.y + c.z) * oneThird;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texelsize = 1. / iResolution.xy;\n\n    float dx = 0.;\n    float dy = 0.;\n    \n    dx -= lum(texture(iChannel0, vec2(uv.x - texelsize.x, uv.y - texelsize.y)).rgb) * 1.0;\n\tdx -= lum(texture(iChannel0, vec2(uv.x - texelsize.x, uv.y              )).rgb) * 2.0;\n\tdx -= lum(texture(iChannel0, vec2(uv.x - texelsize.x, uv.y + texelsize.y)).rgb) * 1.0;\n\tdx += lum(texture(iChannel0, vec2(uv.x + texelsize.x, uv.y - texelsize.y)).rgb) * 1.0;\n\tdx += lum(texture(iChannel0, vec2(uv.x + texelsize.x, uv.y              )).rgb) * 2.0;\n\tdx += lum(texture(iChannel0, vec2(uv.x + texelsize.x, uv.y + texelsize.y)).rgb) * 1.0;\n    \n    dy -= lum(texture(iChannel0, vec2(uv.x - texelsize.x, uv.y - texelsize.y)).rgb) * 1.0;\n\tdy -= lum(texture(iChannel0, vec2(uv.x              , uv.y - texelsize.y)).rgb) * 2.0;\n\tdy -= lum(texture(iChannel0, vec2(uv.x + texelsize.x, uv.y - texelsize.y)).rgb) * 1.0;\n\tdy += lum(texture(iChannel0, vec2(uv.x - texelsize.x, uv.y + texelsize.y)).rgb) * 1.0;\n\tdy += lum(texture(iChannel0, vec2(uv.x              , uv.y + texelsize.y)).rgb) * 2.0;\n\tdy += lum(texture(iChannel0, vec2(uv.x + texelsize.x, uv.y + texelsize.y)).rgb) * 1.0;\n    \n    float nx = dx;\n    float ny = dy;\n    vec3 norm = vec3(dx, dy, sqrt(1.0 - dx*dx - dy*dy));\n    \n    fragColor = vec4(norm * vec3(0.5, 0.5, 1.0) + vec3(0.5, 0.5, 0.0), 1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ld3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 175], [177, 177, 234, 234, 1611]], "test": "untested"}
{"id": "Wtt3Wl", "name": "OTF Lobster Shadertoy render", "author": "NinjaKoala", "description": "Lobster OTF font rendering using my cubic bezier distance approximation from https://www.shadertoy.com/view/3lsSzS\nand simple intersection number computation. Generated from svg file by\nhttps://gist.github.com/Ninja-Koala/74fa7652fb4de248949ce1e27b989c14", "tags": ["2d", "font", "shadertoy", "vector", "svg", "otf"], "likes": 31, "viewed": 1830, "published": 3, "date": "1577965516", "time_retrieved": "2024-07-30T21:31:56.554974", "image_code": "#define ZERO min(0,iFrame)\n\nfloat border;\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tfor(int i=ZERO;i<3;i++){\n\t\tt=params[i];\n\t\tfor(int j=ZERO;j<3;j++){\n\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\n//segment_dis_sq by iq\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n\t\n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n\t\tnor=vec2(nor.y,-nor.x);\n\t\t\n\t\tfloat sgn;\n\t\t\n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n\t\telse{\n\t\t\tsgn=-1.;\n\t\t}\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n    \n    int n_ints=0;\n    \n    if(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n    else{\n\n        if(abs(cu) < .0001){\n            n_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n        }\n        else{\n            n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n        }\n\n        for(int i=ZERO;i<n_roots;i++){\n            if(roots[i] >= 0. && roots[i] <= 1.){\n                float x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n                x_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n                x_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n                x_pos = x_pos * roots[i] + p0.x;\n\n                if(x_pos > uv.x){\n                    n_ints++;\n                }\n            }\n        }\n    }\n\n\treturn n_ints;\n}\n\nfloat path0_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[48] p=vec2[](vec2(-0.297242,0.075528),\n\t                  vec2(-0.297242,0.0973915),\n\t                  vec2(-0.3199,0.0993791),\n\t                  vec2(-0.329242,0.0993791),\n\t                  vec2(-0.354882,0.0993791),\n\t                  vec2(-0.375155,0.0844722),\n\t                  vec2(-0.375155,0.0638014),\n\t                  vec2(-0.375155,0.0345839),\n\t                  vec2(-0.33441,0.0224597),\n\t                  vec2(-0.33441,-0.011528),\n\t                  vec2(-0.33441,-0.0282236),\n\t                  vec2(-0.344149,-0.0379628),\n\t                  vec2(-0.357466,-0.0379628),\n\t                  vec2(-0.370186,-0.0379628),\n\t                  vec2(-0.376547,-0.0288199),\n\t                  vec2(-0.376547,-0.018882),\n\t                  vec2(-0.376547,-0.00516764),\n\t                  vec2(-0.364025,-0.000198714),\n\t                  vec2(-0.353292,-0.000198714),\n\t                  vec2(-0.353888,0.0101367),\n\t                  vec2(-0.363826,0.0129192),\n\t                  vec2(-0.370783,0.0129192),\n\t                  vec2(-0.384696,0.0129192),\n\t                  vec2(-0.4,0.00178888),\n\t                  vec2(-0.4,-0.019677),\n\t                  vec2(-0.4,-0.0439255),\n\t                  vec2(-0.380522,-0.0538634),\n\t                  vec2(-0.357863,-0.0538634),\n\t                  vec2(-0.329043,-0.0538634),\n\t                  vec2(-0.302012,-0.0375652),\n\t                  vec2(-0.302012,-0.0041739),\n\t                  vec2(-0.302012,0.0387578),\n\t                  vec2(-0.346733,0.042733),\n\t                  vec2(-0.346733,0.0719504),\n\t                  vec2(-0.346733,0.083876),\n\t                  vec2(-0.339379,0.0900374),\n\t                  vec2(-0.328447,0.0900374),\n\t                  vec2(-0.317515,0.0900374),\n\t                  vec2(-0.313739,0.0836772),\n\t                  vec2(-0.313739,0.0767207),\n\t                  vec2(-0.313739,0.0701616),\n\t                  vec2(-0.317317,0.0628076),\n\t                  vec2(-0.322683,0.0596274),\n\t                  vec2(-0.320099,0.0566461),\n\t                  vec2(-0.317118,0.0554536),\n\t                  vec2(-0.31354,0.0554536),\n\t                  vec2(-0.303602,0.0554536),\n\t                  vec2(-0.297242,0.0640001));\n\n\tivec4[16] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,42),\n\t                        ivec4(42,43,44,45),\n\t                        ivec4(45,46,47,0));\n\n\tif(all(lessThan(uv,vec2(-0.297242,0.0993791)+border)) && all(greaterThan(uv,vec2(-0.4,-0.0538634)-border))){\n\t\tfor(int i=ZERO;i<16;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path1_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[36] p=vec2[](vec2(-0.234832,0.0222609),\n\t                  vec2(-0.234832,0.00954037),\n\t                  vec2(-0.243776,-0.0149068),\n\t                  vec2(-0.243776,-0.0284223),\n\t                  vec2(-0.243776,-0.0397516),\n\t                  vec2(-0.237615,-0.0508821),\n\t                  vec2(-0.220323,-0.0508821),\n\t                  vec2(-0.209789,-0.0508821),\n\t                  vec2(-0.194484,-0.0467081),\n\t                  vec2(-0.183354,-0.0141118),\n\t                  vec2(-0.191702,-0.0141118),\n\t                  vec2(-0.196074,-0.0244473),\n\t                  vec2(-0.199652,-0.0316026),\n\t                  vec2(-0.208397,-0.0316026),\n\t                  vec2(-0.21436,-0.0316026),\n\t                  vec2(-0.216348,-0.0282236),\n\t                  vec2(-0.216348,-0.0232546),\n\t                  vec2(-0.216348,-0.0121242),\n\t                  vec2(-0.206807,0.0119255),\n\t                  vec2(-0.206807,0.0280249),\n\t                  vec2(-0.206807,0.0439255),\n\t                  vec2(-0.216149,0.0504845),\n\t                  vec2(-0.228869,0.0504845),\n\t                  vec2(-0.235031,0.0504845),\n\t                  vec2(-0.243776,0.0488945),\n\t                  vec2(-0.252124,0.0393542),\n\t                  vec2(-0.241391,0.0894412),\n\t                  vec2(-0.270807,0.085466),\n\t                  vec2(-0.299627,-0.0496894),\n\t                  vec2(-0.271006,-0.0496894),\n\t                  vec2(-0.257292,0.0149068),\n\t                  vec2(-0.256099,0.0202733),\n\t                  vec2(-0.249938,0.0323976),\n\t                  vec2(-0.242186,0.0323976),\n\t                  vec2(-0.237217,0.0323976),\n\t                  vec2(-0.234832,0.02882));\n\n\tivec2[6] seg=ivec2[](ivec2(9,10),\n\t                     ivec2(25,26),\n\t                     ivec2(26,27),\n\t                     ivec2(27,28),\n\t                     ivec2(28,29),\n\t                     ivec2(29,30));\n\n\tivec4[10] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(10,11,12,13),\n\t                        ivec4(13,14,15,16),\n\t                        ivec4(16,17,18,19),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(22,23,24,25),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,0));\n\n\tif(all(lessThan(uv,vec2(-0.183354,0.0894412)+border)) && all(greaterThan(uv,vec2(-0.299627,-0.0508821)-border))){\n\t\tfor(int i=ZERO;i<6;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<10;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path2_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[45] p=vec2[](vec2(-0.124919,0.0496896),\n\t                  vec2(-0.127105,0.0391554),\n\t                  vec2(-0.127105,0.0405467),\n\t                  vec2(-0.127105,0.0463107),\n\t                  vec2(-0.131876,0.0506833),\n\t                  vec2(-0.143205,0.0506833),\n\t                  vec2(-0.177789,0.0506833),\n\t                  vec2(-0.194286,0.00795032),\n\t                  vec2(-0.194286,-0.018882),\n\t                  vec2(-0.194286,-0.0425342),\n\t                  vec2(-0.181366,-0.0508821),\n\t                  vec2(-0.167851,-0.0508821),\n\t                  vec2(-0.153739,-0.0508821),\n\t                  vec2(-0.144397,-0.0417392),\n\t                  vec2(-0.138236,-0.0325963),\n\t                  vec2(-0.137043,-0.0445217),\n\t                  vec2(-0.129888,-0.0508821),\n\t                  vec2(-0.118758,-0.0508821),\n\t                  vec2(-0.108025,-0.0508821),\n\t                  vec2(-0.0901364,-0.0465093),\n\t                  vec2(-0.0788071,-0.0141118),\n\t                  vec2(-0.087155,-0.0141118),\n\t                  vec2(-0.0901364,-0.0240497),\n\t                  vec2(-0.0955028,-0.0327951),\n\t                  vec2(-0.103254,-0.0327951),\n\t                  vec2(-0.10882,-0.0327951),\n\t                  vec2(-0.111403,-0.0298137),\n\t                  vec2(-0.111403,-0.0242485),\n\t                  vec2(-0.111403,-0.0224597),\n\t                  vec2(-0.111205,-0.0204721),\n\t                  vec2(-0.110609,-0.0178882),\n\t                  vec2(-0.0962985,0.0496896),\n\t                  vec2(-0.137043,0.0383603),\n\t                  vec2(-0.130683,0.0383603),\n\t                  vec2(-0.128894,0.0331926),\n\t                  vec2(-0.128894,0.0308075),\n\t                  vec2(-0.138435,-0.0141118),\n\t                  vec2(-0.14082,-0.0256398),\n\t                  vec2(-0.149168,-0.0316026),\n\t                  vec2(-0.154931,-0.0316026),\n\t                  vec2(-0.158509,-0.0316026),\n\t                  vec2(-0.164869,-0.0314042),\n\t                  vec2(-0.164869,-0.0160994),\n\t                  vec2(-0.164869,0.00258385),\n\t                  vec2(-0.153938,0.0383603));\n\n\tivec2[6] seg=ivec2[](ivec2(0,1),\n\t                     ivec2(1,2),\n\t                     ivec2(20,21),\n\t                     ivec2(30,31),\n\t                     ivec2(31,0),\n\t                     ivec2(35,36));\n\n\tivec4[13] c_bez=ivec4[](ivec4(2,3,4,5),\n\t                        ivec4(5,6,7,8),\n\t                        ivec4(8,9,10,11),\n\t                        ivec4(11,12,13,14),\n\t                        ivec4(14,15,16,17),\n\t                        ivec4(17,18,19,20),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(32,33,34,35),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,42),\n\t                        ivec4(42,43,44,32));\n\n\tif(all(lessThan(uv,vec2(-0.0788071,0.0506833)+border)) && all(greaterThan(uv,vec2(-0.194286,-0.0508821)-border))){\n\t\tfor(int i=ZERO;i<6;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<13;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path3_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[46] p=vec2[](vec2(-0.0128197,0.085466),\n\t                  vec2(-0.0225589,0.0397516),\n\t                  vec2(-0.0225589,0.0405471),\n\t                  vec2(-0.0225589,0.0463111),\n\t                  vec2(-0.027329,0.0506837),\n\t                  vec2(-0.0386581,0.0506837),\n\t                  vec2(-0.0732421,0.0506837),\n\t                  vec2(-0.089739,0.00795077),\n\t                  vec2(-0.089739,-0.0188816),\n\t                  vec2(-0.089739,-0.0425337),\n\t                  vec2(-0.0768197,-0.0508816),\n\t                  vec2(-0.0633042,-0.0508816),\n\t                  vec2(-0.0491924,-0.0508816),\n\t                  vec2(-0.0398508,-0.0417387),\n\t                  vec2(-0.033888,-0.0325958),\n\t                  vec2(-0.0322979,-0.0437263),\n\t                  vec2(-0.0251426,-0.049689),\n\t                  vec2(-0.0144097,-0.049689),\n\t                  vec2(-0.00367677,-0.049689),\n\t                  vec2(0.0142115,-0.0465089),\n\t                  vec2(0.0255407,-0.0141113),\n\t                  vec2(0.0171928,-0.0141113),\n\t                  vec2(0.0142115,-0.0240493),\n\t                  vec2(0.00884499,-0.0316021),\n\t                  vec2(0.00109338,-0.0316021),\n\t                  vec2(-0.00447185,-0.0316021),\n\t                  vec2(-0.00705565,-0.0298133),\n\t                  vec2(-0.00705565,-0.024248),\n\t                  vec2(-0.00705565,-0.0224592),\n\t                  vec2(-0.00685733,-0.0204716),\n\t                  vec2(-0.00626124,-0.0178877),\n\t                  vec2(0.016596,0.0894417),\n\t                  vec2(-0.0340868,-0.0151056),\n\t                  vec2(-0.0366707,-0.0260373),\n\t                  vec2(-0.0448197,-0.0316026),\n\t                  vec2(-0.0503849,-0.0316026),\n\t                  vec2(-0.0539626,-0.0316026),\n\t                  vec2(-0.0603228,-0.0314042),\n\t                  vec2(-0.0603228,-0.0160994),\n\t                  vec2(-0.0603228,0.00258385),\n\t                  vec2(-0.0493911,0.0383603),\n\t                  vec2(-0.0324967,0.0383603),\n\t                  vec2(-0.0265339,0.0383603),\n\t                  vec2(-0.0247451,0.0337889),\n\t                  vec2(-0.0243477,0.0314038),\n\t                  vec2(-0.0340868,-0.0141118));\n\n\tivec2[7] seg=ivec2[](ivec2(0,1),\n\t                     ivec2(1,2),\n\t                     ivec2(20,21),\n\t                     ivec2(30,31),\n\t                     ivec2(31,0),\n\t                     ivec2(44,45),\n\t                     ivec2(45,32));\n\n\tivec4[13] c_bez=ivec4[](ivec4(2,3,4,5),\n\t                        ivec4(5,6,7,8),\n\t                        ivec4(8,9,10,11),\n\t                        ivec4(11,12,13,14),\n\t                        ivec4(14,15,16,17),\n\t                        ivec4(17,18,19,20),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(32,33,34,35),\n\t                        ivec4(35,36,37,38),\n\t                        ivec4(38,39,40,41),\n\t                        ivec4(41,42,43,44));\n\n\tif(all(lessThan(uv,vec2(0.0255407,0.0894417)+border)) && all(greaterThan(uv,vec2(-0.089739,-0.0508816)-border))){\n\t\tfor(int i=ZERO;i<7;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<13;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path4_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[34] p=vec2[](vec2(0.044025,-0.0174906),\n\t                  vec2(0.044025,-0.0151056),\n\t                  vec2(0.0442233,-0.0123229),\n\t                  vec2(0.0444228,-0.00954037),\n\t                  vec2(0.0682738,-0.00814909),\n\t                  vec2(0.0901371,0.00954037),\n\t                  vec2(0.0901371,0.0323976),\n\t                  vec2(0.0901371,0.0423355),\n\t                  vec2(0.0859633,0.0514784),\n\t                  vec2(0.0682738,0.0514784),\n\t                  vec2(0.0275284,0.0514784),\n\t                  vec2(0.0146091,0.0035777),\n\t                  vec2(0.0146091,-0.0192795),\n\t                  vec2(0.0146091,-0.0417392),\n\t                  vec2(0.0269321,-0.0508821),\n\t                  vec2(0.0456153,-0.0508821),\n\t                  vec2(0.0720502,-0.0508821),\n\t                  vec2(0.0889446,-0.0323975),\n\t                  vec2(0.100274,-0.0141118),\n\t                  vec2(0.0935161,-0.0141118),\n\t                  vec2(0.0835781,-0.025441),\n\t                  vec2(0.0740377,-0.0341864),\n\t                  vec2(0.0583358,-0.0341864),\n\t                  vec2(0.0487955,-0.0341864),\n\t                  vec2(0.0440252,-0.0310062),\n\t                  vec2(0.0748326,0.0327951),\n\t                  vec2(0.0748326,0.0162982),\n\t                  vec2(0.0613171,0.000993797),\n\t                  vec2(0.0460126,5.63409e-08),\n\t                  vec2(0.0499878,0.0196771),\n\t                  vec2(0.0597269,0.0409442),\n\t                  vec2(0.0698636,0.0409442),\n\t                  vec2(0.07364,0.0409442),\n\t                  vec2(0.0748326,0.0377641));\n\n\tivec2[1] seg=ivec2[](ivec2(18,19));\n\n\tivec4[11] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(22,23,24,0),\n\t                        ivec4(25,26,27,28),\n\t                        ivec4(28,29,30,31),\n\t                        ivec4(31,32,33,25));\n\n\tif(all(lessThan(uv,vec2(0.100274,0.0514784)+border)) && all(greaterThan(uv,vec2(0.0146091,-0.0508821)-border))){\n\t\tfor(int i=ZERO;i<1;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<11;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path5_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[20] p=vec2[](vec2(0.107031,0.0496896),\n\t                  vec2(0.0859628,-0.0496894),\n\t                  vec2(0.114584,-0.0496894),\n\t                  vec2(0.130485,0.0258385),\n\t                  vec2(0.135454,0.03041),\n\t                  vec2(0.139031,0.0333914),\n\t                  vec2(0.144994,0.0333914),\n\t                  vec2(0.150957,0.0333914),\n\t                  vec2(0.145392,0.0202733),\n\t                  vec2(0.156522,0.0202733),\n\t                  vec2(0.166261,0.0202733),\n\t                  vec2(0.170833,0.0278261),\n\t                  vec2(0.170833,0.0347827),\n\t                  vec2(0.170833,0.0423355),\n\t                  vec2(0.166062,0.0496896),\n\t                  vec2(0.157118,0.0496896),\n\t                  vec2(0.147578,0.0496896),\n\t                  vec2(0.140025,0.0433292),\n\t                  vec2(0.133069,0.0373666),\n\t                  vec2(0.135652,0.0496896));\n\n\tivec2[5] seg=ivec2[](ivec2(0,1),\n\t                     ivec2(1,2),\n\t                     ivec2(2,3),\n\t                     ivec2(18,19),\n\t                     ivec2(19,0));\n\n\tivec4[5] c_bez=ivec4[](ivec4(3,4,5,6),\n\t                       ivec4(6,7,8,9),\n\t                       ivec4(9,10,11,12),\n\t                       ivec4(12,13,14,15),\n\t                       ivec4(15,16,17,18));\n\n\tif(all(lessThan(uv,vec2(0.170833,0.0496896)+border)) && all(greaterThan(uv,vec2(0.0859628,-0.0496894)-border))){\n\t\tfor(int i=ZERO;i<5;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<5;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path6_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[30] p=vec2[](vec2(0.187727,0.0771182),\n\t                  vec2(0.181764,0.0496896),\n\t                  vec2(0.175205,0.0496896),\n\t                  vec2(0.173615,0.0417392),\n\t                  vec2(0.180174,0.0417392),\n\t                  vec2(0.168249,-0.0141118),\n\t                  vec2(0.167255,-0.018882),\n\t                  vec2(0.166658,-0.0232546),\n\t                  vec2(0.166658,-0.0270311),\n\t                  vec2(0.166658,-0.0437268),\n\t                  vec2(0.176,-0.0508821),\n\t                  vec2(0.187926,-0.0508821),\n\t                  vec2(0.198659,-0.0508821),\n\t                  vec2(0.218336,-0.0465093),\n\t                  vec2(0.229665,-0.0141118),\n\t                  vec2(0.221317,-0.0141118),\n\t                  vec2(0.218336,-0.0240497),\n\t                  vec2(0.21118,-0.0316026),\n\t                  vec2(0.203429,-0.0316026),\n\t                  vec2(0.197863,-0.0316026),\n\t                  vec2(0.19528,-0.0298137),\n\t                  vec2(0.19528,-0.0242485),\n\t                  vec2(0.19528,-0.0224597),\n\t                  vec2(0.195478,-0.0204721),\n\t                  vec2(0.196074,-0.0178882),\n\t                  vec2(0.208795,0.0417392),\n\t                  vec2(0.22072,0.0417392),\n\t                  vec2(0.22231,0.0496896),\n\t                  vec2(0.210385,0.0496896),\n\t                  vec2(0.217142,0.0810933));\n\n\tivec2[12] seg=ivec2[](ivec2(0,1),\n\t                      ivec2(1,2),\n\t                      ivec2(2,3),\n\t                      ivec2(3,4),\n\t                      ivec2(4,5),\n\t                      ivec2(14,15),\n\t                      ivec2(24,25),\n\t                      ivec2(25,26),\n\t                      ivec2(26,27),\n\t                      ivec2(27,28),\n\t                      ivec2(28,29),\n\t                      ivec2(29,0));\n\n\tivec4[6] c_bez=ivec4[](ivec4(5,6,7,8),\n\t                       ivec4(8,9,10,11),\n\t                       ivec4(11,12,13,14),\n\t                       ivec4(15,16,17,18),\n\t                       ivec4(18,19,20,21),\n\t                       ivec4(21,22,23,24));\n\n\tif(all(lessThan(uv,vec2(0.229665,0.0810933)+border)) && all(greaterThan(uv,vec2(0.166658,-0.0508821)-border))){\n\t\tfor(int i=ZERO;i<12;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<6;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path7_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[40] p=vec2[](vec2(0.272994,0.0514784),\n\t                  vec2(0.23205,0.0514784),\n\t                  vec2(0.218534,0.00377647),\n\t                  vec2(0.218534,-0.0190808),\n\t                  vec2(0.218534,-0.0417392),\n\t                  vec2(0.231851,-0.0504845),\n\t                  vec2(0.250335,-0.0504845),\n\t                  vec2(0.274783,-0.0504845),\n\t                  vec2(0.294658,-0.0274286),\n\t                  vec2(0.297839,0.00934171),\n\t                  vec2(0.312348,0.0117267),\n\t                  vec2(0.325466,0.0176895),\n\t                  vec2(0.333019,0.0258385),\n\t                  vec2(0.33123,0.031205),\n\t                  vec2(0.322683,0.0252423),\n\t                  vec2(0.309764,0.0192796),\n\t                  vec2(0.300621,0.0192796),\n\t                  vec2(0.300025,0.0192796),\n\t                  vec2(0.29923,0.0192796),\n\t                  vec2(0.298435,0.0196773),\n\t                  vec2(0.298435,0.0405469),\n\t                  vec2(0.290087,0.0514786),\n\t                  vec2(0.258286,-0.0325963),\n\t                  vec2(0.250733,-0.0325963),\n\t                  vec2(0.248149,-0.029615),\n\t                  vec2(0.248149,-0.0164969),\n\t                  vec2(0.248149,0.00298139),\n\t                  vec2(0.260472,0.0393542),\n\t                  vec2(0.274584,0.0393542),\n\t                  vec2(0.279752,0.0393542),\n\t                  vec2(0.281739,0.0361739),\n\t                  vec2(0.282137,0.0278261),\n\t                  vec2(0.278559,0.0262361),\n\t                  vec2(0.275975,0.0226584),\n\t                  vec2(0.275975,0.0170932),\n\t                  vec2(0.275975,0.013118),\n\t                  vec2(0.277168,0.00973914),\n\t                  vec2(0.281342,0.0087454),\n\t                  vec2(0.278161,-0.0147081),\n\t                  vec2(0.268025,-0.0325963));\n\n\tivec2[1] seg=ivec2[](ivec2(12,13));\n\n\tivec4[13] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(13,14,15,16),\n\t                        ivec4(16,17,18,19),\n\t                        ivec4(19,20,21,0),\n\t                        ivec4(22,23,24,25),\n\t                        ivec4(25,26,27,28),\n\t                        ivec4(28,29,30,31),\n\t                        ivec4(31,32,33,34),\n\t                        ivec4(34,35,36,37),\n\t                        ivec4(37,38,39,22));\n\n\tif(all(lessThan(uv,vec2(0.333019,0.0514786)+border)) && all(greaterThan(uv,vec2(0.218534,-0.0504845)-border))){\n\t\tfor(int i=ZERO;i<1;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<13;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path8_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[44] p=vec2[](vec2(0.322087,0.0496896),\n\t                  vec2(0.308571,-0.0141118),\n\t                  vec2(0.307577,-0.018882),\n\t                  vec2(0.306981,-0.0232546),\n\t                  vec2(0.306981,-0.0270311),\n\t                  vec2(0.306981,-0.0437268),\n\t                  vec2(0.316323,-0.0508821),\n\t                  vec2(0.328248,-0.0508821),\n\t                  vec2(0.335006,-0.0508821),\n\t                  vec2(0.34395,-0.0490932),\n\t                  vec2(0.352497,-0.039354),\n\t                  vec2(0.350509,-0.0480994),\n\t                  vec2(0.331627,-0.0536646),\n\t                  vec2(0.316124,-0.0594286),\n\t                  vec2(0.316124,-0.0779132),\n\t                  vec2(0.316124,-0.0908324),\n\t                  vec2(0.327453,-0.0993791),\n\t                  vec2(0.339578,-0.0993791),\n\t                  vec2(0.352696,-0.0993791),\n\t                  vec2(0.369789,-0.0940126),\n\t                  vec2(0.375751,-0.0655902),\n\t                  vec2(0.4,0.0496896),\n\t                  vec2(0.37118,0.0496896),\n\t                  vec2(0.357664,-0.0141118),\n\t                  vec2(0.354683,-0.0240497),\n\t                  vec2(0.349515,-0.0316026),\n\t                  vec2(0.341764,-0.0316026),\n\t                  vec2(0.337192,-0.0316026),\n\t                  vec2(0.335801,-0.0274286),\n\t                  vec2(0.335801,-0.0228571),\n\t                  vec2(0.335801,-0.021267),\n\t                  vec2(0.335999,-0.0194782),\n\t                  vec2(0.336397,-0.0178882),\n\t                  vec2(0.350708,0.0496896),\n\t                  vec2(0.327056,-0.0751305),\n\t                  vec2(0.327056,-0.0643976),\n\t                  vec2(0.336596,-0.0586336),\n\t                  vec2(0.349118,-0.0544597),\n\t                  vec2(0.346733,-0.0661864),\n\t                  vec2(0.344149,-0.0779132),\n\t                  vec2(0.338981,-0.0816896),\n\t                  vec2(0.335006,-0.0816896),\n\t                  vec2(0.330633,-0.0816896),\n\t                  vec2(0.327056,-0.0779132));\n\n\tivec2[8] seg=ivec2[](ivec2(0,1),\n\t                     ivec2(10,11),\n\t                     ivec2(20,21),\n\t                     ivec2(21,22),\n\t                     ivec2(22,23),\n\t                     ivec2(32,33),\n\t                     ivec2(33,0),\n\t                     ivec2(37,38));\n\n\tivec4[12] c_bez=ivec4[](ivec4(1,2,3,4),\n\t                        ivec4(4,5,6,7),\n\t                        ivec4(7,8,9,10),\n\t                        ivec4(11,12,13,14),\n\t                        ivec4(14,15,16,17),\n\t                        ivec4(17,18,19,20),\n\t                        ivec4(23,24,25,26),\n\t                        ivec4(26,27,28,29),\n\t                        ivec4(29,30,31,32),\n\t                        ivec4(34,35,36,37),\n\t                        ivec4(38,39,40,41),\n\t                        ivec4(41,42,43,34));\n\n\tif(all(lessThan(uv,vec2(0.4,0.0496896)+border)) && all(greaterThan(uv,vec2(0.306981,-0.0993791)-border))){\n\t\tfor(int i=ZERO;i<8;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<12;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tborder=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\n    vec2 mouse=vec2(0);\n\n\tif(iMouse.x>0.0){\n\t\tmouse = iMouse.xy / iResolution.y;\n\t\tmouse.x -= .5 * iResolution.x / iResolution.y;\n\t\tmouse.y -= .75;\n\t}\n    \n    const float pi=3.14159265358979;\n\n\tfloat t0=smoothstep(0.,5.,iTime);\n\tfloat t1=t0*6.*pi;\n\n\tmat2 rot=mat2(cos(t1),sin(t1),-sin(t1),cos(t1));\n\n\tborder*=exp(4.*mouse.y)*exp(1.-1.*t0);\n\tuv*=exp(4.*mouse.y)*exp(1.-1.*t0);\n\tuv*=rot;\n\n\tuv.x+=mouse.x;\n\n\tfloat dis_sq=1e38;\n\n\tif(all(lessThan(uv,vec2(0.4,0.0993791)+border)) && all(greaterThan(uv,vec2(-0.4,-0.0993791)-border))){\n\t\tdis_sq=min(dis_sq,path0_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path1_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path2_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path3_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path4_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path5_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path6_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path7_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path8_dis_sq(uv));\n\t}\n\n\tfloat dis=sign(dis_sq)*sqrt(abs(dis_sq));\n\n\tfragColor=vec4(smoothstep(0., border, dis));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtt3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 164, 213, 248, 428], [430, 515, 558, 558, 1573], [1575, 1575, 1656, 1675, 1850], [1852, 1852, 1930, 1930, 2360], [2362, 2385, 2410, 2410, 2429], [2431, 2431, 2478, 2478, 2589], [2591, 2591, 2639, 2639, 2909], [2911, 2911, 2982, 2982, 4026], [31678, 31678, 31732, 31732, 32820]], "test": "untested"}
{"id": "wl33Ds", "name": "sin(x*x+y*y)=cos(x*y)", "author": "changjiu", "description": "the graph of the function:sin(x*x+y*y)=cos(x*y)", "tags": ["mathfunction"], "likes": 3, "viewed": 339, "published": 3, "date": "1577954959", "time_retrieved": "2024-07-30T21:31:57.575245", "image_code": "bool near(float a, float b){\n\treturn abs(a-b)<0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float t = iTime;\n    while(t>6.){\n    \tt = t - 6.;\n    }\n    float scale = t*10.-float(int(t*10./50.))/50.+10.;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (fragCoord-0.5*iResolution.xy)/scale;\n    \n    float x= uv.x;\n    float y= uv.y;\n\n    float gray;\n    \n    if(near(sin(x*x+y*y),cos(x*y))){\n        gray = 1.;\n    }else{\n    \tgray = 0.;\n    }\n\n\n    float r = gray;\n    float g = gray;\n    float b = gray;\n    \n    vec3 col = vec3(r,g,b);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl33Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 52], [54, 54, 111, 111, 598]], "test": "untested"}
{"id": "wt33Ds", "name": "y=x*x*x", "author": "changjiu", "description": "the graph of the function", "tags": ["mathfunction"], "likes": 2, "viewed": 324, "published": 3, "date": "1577953571", "time_retrieved": "2024-07-30T21:31:58.333219", "image_code": "bool near(float a, float b){\n\treturn abs(a-b)<10.;\n}\n\nfloat f(float x){\n\treturn 0.00005*x*x*x;\n}\n\n/*\nfloat f(float x){\n\treturn 100.*sin(0.01*x);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = fragCoord-0.5*iResolution.xy;\n    \n    float x= uv.x;\n    float y= uv.y;\n\n    float gray;\n    \n    if(((y+0.5)-f(x-0.5))*((y-0.5)-f(x+0.5))<=0.){\n        gray = 1.;\n    }else if(((y+0.5)-f(x+0.5))*((y-0.5)-f(x-0.5))<=0.){\n    \tgray = 1.;\n    }else{\n    \tgray = 0.;\n    }\n\n\n    float r = gray;\n    float g = gray;\n    float b = gray;\n    \n    vec3 col = vec3(r,g,b);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt33Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 52], [54, 54, 71, 71, 96], [151, 151, 208, 258, 730]], "test": "untested"}
{"id": "wlcGDs", "name": "グシグシ", "author": "ShnitzelKiller", "description": "これいいな", "tags": ["oscillation"], "likes": 3, "viewed": 381, "published": 3, "date": "1577946112", "time_retrieved": "2024-07-30T21:31:59.192920", "image_code": "// Cubic interpolation\nfloat cubemix(float a, float b, float t) {\n    float c = t*t*(3.-2.*t);\n    return mix(a, b, c);\n}\n\nfloat rand( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(10000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat valuenoise(vec2 uv) {\n    vec2 iuv = floor(uv);\n    vec2 offset = vec2(0.,1.);\n    float v00 = rand(iuv);\n    float v01 = rand(iuv+offset.xy);\n    float v10 = rand(iuv+offset.yx);\n    float v11 = rand(iuv+offset.yy);\n    vec2 disp = fract(uv);\n    float v0 = cubemix(v00, v01, disp.y);\n    float v1 = cubemix(v10, v11, disp.y);\n    return cubemix(v0, v1, disp.x)*.5+.5;\n}\n\nfloat fractalnoise(vec2 uv, float mag) {\n    float d = valuenoise(uv);\n    int i;\n    float fac = 1.;\n    vec2 disp = vec2(0., 1.);\n    for (i=0; i<3; i++) {\n        uv -= mag * iTime * disp * fac;\n        fac *= 0.5;\n        d += valuenoise(uv/fac)*fac;\n    }\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x*20.;\n\tuv.y -= iTime*10.;\n    float val = fractalnoise(uv, 5.);\n    vec3 col = mix(vec3(1., 0.2, 0.), vec3(1., 1., 0.5), smoothstep(0.5, 1., val));\n    float phase1 = iTime * 20.5;\n    float offset = smoothstep(-0.5, 0.5, sin(iTime*20.))*40.;\n    float offset2 = sin(iTime*15.25) * 40.;\n\tfloat left = iResolution.x*(0.5 + 0.1*(sin(phase1) - 1.)) + offset + offset2;\n    float right = iResolution.x*(0.5 - 0.1*(cos(phase1) - 1.)) + offset + offset2;\n    float bottom = iResolution.y*0.2 + offset * 0.5;\n    float top = iResolution.y*0.55 + offset*0.5;\n    if (fragCoord.x < left || fragCoord.x > right || (fragCoord.y < top && fragCoord.y > bottom)) {\n    \tcol = vec3(0.);   \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 23, 65, 65, 121], [123, 123, 145, 145, 378], [380, 380, 407, 407, 757], [759, 759, 799, 799, 1035], [1038, 1038, 1095, 1095, 1846]], "test": "untested"}
{"id": "wtcGDs", "name": "\"Cell\"", "author": "tono", "description": "cellernoise", "tags": ["raymarching"], "likes": 3, "viewed": 427, "published": 3, "date": "1577939404", "time_retrieved": "2024-07-30T21:32:00.201227", "image_code": "//i posted the shader on neort and shadertoy\n\n#define A 3\n\nmat2 rot(float a)\n{\n    float s = sin(a),c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 random33(vec3 st)\n{\n    st = vec3(dot(st,vec3(127.1, 311.7,811.5)),\n                dot(st, vec3(269.5, 183.3,211.91)),\n                dot(st, vec3(511.3, 631.19,431.81))\n                );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat norm(vec3 p, float n)\n{\n    vec3 t=pow(abs(p),vec3(n));\n    return pow(t.x+t.y,1./n);\n}\n\nvec4 celler3D(vec3 i,vec3 sepc)\n{\n    float stime = iTime / 1.5;\n    vec3 sep = i * sepc;\n    vec3 fp = floor(sep);\n    vec3 sp = fract(sep);\n    float dist = 5.;\n    vec3 mp = vec3(0.);\n\n    for (int z = -1; z <= 1; z++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(x, y ,z);\n                vec3 pos = vec3(random33(fp+neighbor));\n                pos = sin( (pos*50. +stime/(230. + 100.*cos(stime/130.))) )* 0.5 + 0.5;\n                \n                float shape = 0.5 + clamp(sin(stime),0.,1.) *30.;\n                float rate = clamp( (sin(stime/2.)),0.,1.);\n                float divs = norm(neighbor + pos - sp,shape);\n                divs = mix(length(neighbor + pos - sp),divs,rate);\n                mp = (dist >divs)?pos:mp;\n                dist = (dist > divs)?divs:dist;\n            }\n        }\n    }\n    return vec4(mp,dist);\n}\n\nvoid scene(out vec3 color,in vec2 F)\n{\n    vec2 p = (F.xy * 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n    //vec3 color = vec3(0.);\n    \n    vec3 cp = vec3(0.,0.,-5.);\n    vec3 cd = vec3(0.,0.,1.);\n    vec3 cu = vec3(0.,1.,0.);\n    vec3 cs = normalize(cross(cd,cu));\n    cu = normalize(cross(cd,cs));\n    \n    float target = 5.0;\n    \n    vec3 rd = normalize(vec3(p.x * cs + p.y * cu + cd * target));\n    \n    float depth = 0.;\n    \n    float stime = iTime/ 150.;\n    \n    for(int i = 0 ; i < 3 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec4 celler = celler3D(rp,vec3(50.)+1.1*sin(stime) );\n        float w = celler.w;\n        w = max(celler.w,0.001);\n        \n        if (celler.w - 0.3 < 0.0001 && depth > 0.0001)\n        {\n            color += celler.xyz - celler.w;\n            break;\n        }\n        if(depth > 1.){break;}\n        depth += w;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //supersampling | oversampling\n\t//https://youtu.be/Pcph14WlLsk   \n    \n    vec3 color = vec3(0.);\n    \n    for(int i = 0;i < A;i++ )\n    {\n        for(int j = 0; j < A;j++)\n        {\n            vec2 d = vec2(float(i),float(j)) - vec2(float(i),float(j))/2.;\n            d /= float(A);\n            scene(color,fragCoord + d);\n        }\n    }\n    color /= float(A * A);\n    \n    fragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 78, 78, 140], [142, 142, 166, 166, 395], [397, 397, 426, 426, 490], [492, 492, 525, 525, 1434], [1436, 1436, 1474, 1474, 2322], [2324, 2324, 2381, 2451, 2794]], "test": "untested"}
{"id": "wl33Ws", "name": "watermelon", "author": "lomateron", "description": "click to explore\nsame algorithm as https://www.shadertoy.com/view/tlcGWs\nbut with different constants", "tags": ["fractal"], "likes": 4, "viewed": 403, "published": 3, "date": "1577936387", "time_retrieved": "2024-07-30T21:32:01.304275", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 3.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = 8.*(2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    float pi = 3.14159265359;\n\n    vec2 p = cos(4.1+vec2(0.,pi*.5))*(2.7+sin(iTime)*.2);\n    if(iMouse.z > .5) p = m;\n    \n    u = u*length(p);\n\n    for(float i = .5; i < 20.; ++i)\n    {\n        float e = mod(i,2.)-.5;\n        e = mix(   6.,\t\t\t\t//close hand fan\n                1./6.,\t\t\t\t//open  hand fan\n                e);\t\t\t\t\t\t\t\t\t\t\n        u = sin(atan(u.x,u.y)*e+vec2(0.,pi*.5))*pow(length(u),e);\n        u-= p;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    }\n    fragColor = .5+.5*sin(6.28*(.55+length(u)/length(p)+vec4(.2,.05,.1,.0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl33Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 692]], "test": "untested"}
{"id": "tlcGWs", "name": "open-close hand fan fractal", "author": "lomateron", "description": "uses https://www.shadertoy.com/view/tt3GW2\nclick to explore\n", "tags": ["twirl"], "likes": 3, "viewed": 361, "published": 3, "date": "1577934070", "time_retrieved": "2024-07-30T21:32:02.103139", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 2.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = 8.*(2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    float pi = 3.14159265359;\n\n    vec2 p = cos(pi*11./6.+vec2(0.,pi*.5))*(4.+sin(iTime));\n    if(iMouse.z > .5) p = m;\n    \n    u = u*length(p);\n\n    for(float i = .5; i < 20.; ++i)\n    {\n        float e = mod(i,2.)-.5;\n        e = mix(   3.,\t\t\t\t\t\t\t\t\t\t\t\t//close hand fan\n                1./3.,\t\t\t\t\t\t\t\t\t\t\t\t//open  hand fan\n                e);\t\t\t\t\t\t\t\t\t\t\n        u = sin(atan(u.x,u.y)*e+vec2(0.,pi*.5))*pow(length(u),e);\t//space wrap\n        u-= p;\t\t\t\t\t\t\t\t\t\t\t\t\t\t//move space\t\n    }\n    fragColor = vec4(.2,.2,.3,.0)*length(p)/length(u);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcGWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 713]], "test": "untested"}
{"id": "ttcGWs", "name": "Just sum stairs", "author": "Plento", "description": "Wanted to make a stair sdf thing. ", "tags": ["3d", "raymarch", "color", "stars", "stairs"], "likes": 4, "viewed": 368, "published": 3, "date": "1577931393", "time_retrieved": "2024-07-30T21:32:02.967827", "image_code": "// Plento\nvec2 R;\nconst float pi = 3.14159;\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n#define s iTime*3.8\n\n// The stairs sdf\nfloat map(vec3 rp){\n    //float k = floor(rp.x*.75)*.25;\n    rp.yz += s;\n    return min(rp.y - floor(rp.z), 1.- (rp.z - floor(rp.y)));\n}\n\n\n\nvec3 normal( in vec3 pos ){ // Can def get rid of this\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;   \n    \n    for(int i = 0; i < 44; i++){\n    \td = map(ro + rd*t); \t   \n        \n        if(abs(d) < .005 || t > 64.){\n            break;\n        }\n        \n        t += d * .75;\n    }\n    \n    return t;\n}\n\n// Color the stairs and also fake the staircase width\nvec3 render(vec3 ro, vec3 rd, vec3 n, vec2 u, float t){\n    vec3 lp = ro + vec3(0., .016, -.7);\n    vec3 ld = lp-ro;\n   \n    float dif = max(dot(n, ld), .0);\n    vec3 col = vec3(0);\n    \n    \n    ro.yz+=s;\n    ro.x*=.5;\n    \n    float c = smoothstep(0.1, 0.15, sin(ro.x*4.));\n    vec3 cc = .4 + .34*cos(2.*pi*(vec3(0.7, 4.8, 0.5)*floor(ro.z)));\n    \n    col = mix(vec3(.0), cc, c)*dif;\n    col = mix(vec3(0), col,  smoothstep(9.9, 10.1, 30./abs(ro.x-4.33)));\n    \n\treturn col;   \n}\n\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 ro = vec3(0.5,6.6 , -6.);\n    \n    rd.yz*=rot(.4);\n    rd.xz*=rot(-.75);\n    \n    float t = march(rd, ro);\n    \n    ro += rd*t;\n    \n    vec3 n = normal(ro);\n    vec3 col = render(ro, rd, n, u, t);\n    \n    col*=smoothstep(.52, .2, uv.y);\n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcGWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 64, 64, 116], [139, 157, 176, 213, 293], [297, 297, 324, 351, 552], [554, 554, 584, 584, 813], [815, 869, 924, 924, 1350], [1354, 1354, 1394, 1394, 1803]], "test": "untested"}
{"id": "tl33Dl", "name": "Joseph Albers, Squares 1", "author": "danamuise", "description": " This is a color experiment based on Color Squares by Joseph Albers. The two smaller boxes are the same color. They appear to change as their surrounding colors change. This is an illusion, showing how they eye is influenced by multiple colors. ", "tags": ["josephalbers"], "likes": 2, "viewed": 2759, "published": 3, "date": "1577923416", "time_retrieved": "2024-07-30T21:32:03.801598", "image_code": "vec3 DrawBox(vec2 uv, float L, float R, float B, float T, vec3 col){\n\tvec3 colorBox = vec3(0.0);\n    \n    if (uv.x>L && uv.x<R && uv.y>B && uv.y<T) {\n       colorBox = vec3(col.r/255.0,col.g/255.0,col.z/255.0);\n    }\n    return colorBox; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 colorA = vec3(237.0, 139.0, 53.0);\n\tvec3 colorB = vec3(239.0, 234.0, 106.0);\n    vec3 colorC = vec3(56.0, 61.0, 127.0);\n\tvec3 colorD = vec3(85.0, 138.0, 176.0);\n    vec3 brown = vec3(162.0/255.0,94.0/255.0,36.0/255.0);\n    \n    // Time varying pixel color\n    vec3 color = vec3(0.5);\n    \n    float pct = abs(sin(iTime*.25));\n\n    // fill left1\n    color = DrawBox(uv, 0.0, 0.25, 0.0, 1.0, mix(colorA, colorC, pct));\n\n    // fill left2\n    color += DrawBox(uv, 0.25, 0.5, 0.0, 1.0, mix(colorB, colorD, pct));\n    \n    // fill right1\n    color += DrawBox(uv, 0.5, 0.75, 0.0, 1.0, mix(colorC, colorA, pct));\n    \n    // fill right2\n    color += DrawBox(uv, 0.75, 1.0, 0.0, 1.0, mix(colorD, colorB, pct));\n    \n    // fill boxL\n    \n    if (uv.x>0.25*0.5 && uv.x<0.25 && uv.y>0.5*0.75 && uv.y<0.5/0.75) {\n       color = brown;\n    }\n    \n    // fill boxR\n    if (uv.x>0.75 && uv.x<0.75/.85 && uv.y>0.5*0.75 && uv.y<0.5/0.75) {\n       color = brown;\n    }\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl33Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 240], [242, 242, 299, 349, 1414]], "test": "untested"}
{"id": "Wl3GDl", "name": "Day 14", "author": "jeyko", "description": "swirly. \nthere's a bunch of stuff i'd like to change, but at least it runs :D", "tags": ["mdtmjvm"], "likes": 14, "viewed": 485, "published": 3, "date": "1577904719", "time_retrieved": "2024-07-30T21:32:04.596474", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 curr = texture(iChannel0, uv);\n    fragColor = curr;\n    \n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvec2 v=vec2(0.,1.);\n\n\n#define iTime (iTime + 10.)\n#define fov 0.3\n#define SIZE 0.0\n\n\n#define mx (20.*iMouse.x/iResolution.y)\n#define my (20.*iMouse.y/iResolution.y)\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define dmin(a,b) a.x < b.x ? a : b\n#define pmod(a,x) mod(a,x) - 0.5*x\n#define rot(x) mat2(cos(x),-sin(x),sin(x), cos(x))\n\nfloat random(float st){\n\treturn fract(sin(st*345.4124)*2124.6254);\n}\nfloat rand(float t) {\n\treturn fract(sin(t*3211251.325235325));\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv) {\n  vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n  vec3 up = normalize(cross(dir, right));\n  \n  return dir*1. + right*uv.x*fov + up*uv.y*fov;\n}\n\nfloat sdSphere(vec3 p, float r){\n\treturn length(p) - r;\n}\nvec3 pO;\nfloat sdThingieB(vec3 p){\n    p = abs(p);\n    \n    p -= vec3(0.5,0.5,0.8);\n    \n    float d = max(p.x, max(p.y, p.z));\n    d = max(d, dot(p.xz + 0.26, normalize(vec2(1))));\n    d = max(d, dot(p.yz + 0.25, normalize(vec2(1))));\t\n\t\n    \n    return d;\n}\n\nfloat sdPolyhedron(vec3 p){\n    vec3 z = p;\n    p = abs(p);\n    if (iTime > iTime*pi*6.){\n        for(int i = 0; i< 3; i++){\n            p = abs(p);\n            p.xz *= rot(-0.0 -0.05*sin(iTime)*0.05);\n            p.xy *= rot(0.0 + sin(iTime)*0.05);\n        }\n    }\n    \n    p.x /= 0.4; // wat\n    //0.5/x = 0.2\n    p -= vec3(0.5,0.5,0.5);\n    \n    //p.y -= 0.2;\n    float d = max(p.x, max(p.y, p.z));\n    d = max(d, dot(p.xz + 0.26, normalize(vec2(1))));\n    d = max(d, dot(p.yz + 0.25, normalize(vec2(1))));\n    \n    //d = max(d, -abs(p.y) + 0.09);\n    float wall = 0.15;\n    d = max(d, -abs(pO.y + 0.5) + wall);\n    d = max(d, pO.y - 0.5 - wall);\n    //d = max(d, pO.y  + 0.1);\n    return d;\n}\nfloat mpow(float a, float b) {\n  for(float i = 0.; i < b; i++) {\n      a = a * a;\n  }\n  return a;\n}\nvec2 map(vec3 p) {\n\tvec2 d = vec2(10e8);\n\t\n\n    \n    float repsX = 8.;\n    float repsY = 8.;\n    float repsXIn = pi/repsX;\n    float repsYIn = 1.; // wat\n    \n    float yID = floor(length(p.xz)/repsYIn);\n    float xID = floor(atan(p.x,p.z)/repsXIn);\n    \n    p.y *= 0.8 + SIZE;\n    vec3 z = vec3(atan(p.x,p.z),length(p.xz),p.y);\n\n    //z.x *= 0.4;\n\n\t#define tBetweenPhases 1.\n\t#define cntPhases 3.\n    \n    float T = iTime - yID*0.2 + sin(iTime)*0.1;\n    \n    float rA = random(floor(T/tBetweenPhases));\n    float rB = random(floor(T/tBetweenPhases) + 215.56);\n    \n    rA = max(floor(rA*cntPhases - 0.001),0.);\n    rB = max(floor(rB*cntPhases - 0.002),0.);\n    \n\n    float r = random(rB*10.);\n    r = sin(r*tau);\n    float rSign = sign(r);\n    r = rSign * max(r, 0.5);\n    \n    \n    //rA = 3.;\n    //rB = 0.;\n    if (rA == 2.) {\n     \tz.x += -rSign*mpow( sin((fract(T/tBetweenPhases))*r*pi )*.4 , 0.6 )*17.;\n    }\n    \n    \n    if (rA == 0.) {\n        float m =  rSign*mpow( sin((fract(T/tBetweenPhases))*r )*0.8 , 3. );\n        float mB =  rSign*mpow( sin((fract(T/tBetweenPhases))*pi*1. )*0.8 , 1. );\n     \tz.x += m*20.;\n        \n        if (rB == 0.) {\n            //z.yz *= rot(0.4);\n        \tz.yz *= rot(pi*mB*0.25);\n        }\n    \t//z.y *= 0.5;\n    }\n\n    \n    pO = vec3(z.y,pmod(z.y,repsYIn), p.y);\n    if(rB == 0.) {\n        z.z += mpow( sin((fract(T/tBetweenPhases))*pi*1. )*1. , 3. );\n     \t//z.z *=  1. + mpow( sin((fract(T/tBetweenPhases))*pi*2. )*0.8 , 2. )*1.;\n    }    \n        \n        \n    \n    if (!(yID < 1.))  {\n        z.x = pmod(z.x,repsXIn);\n        z.y = pmod(z.y,repsYIn);\n    }\n    \n    if(rB == 2.) {\n     \tz.z += mpow( sin((fract(T/tBetweenPhases))*pi*1. )*0.2 , 0.9 );\n    }\n\t\n    if(rB == 3.){\n        float m = mpow( sin((fract(T/tBetweenPhases))*pi*1. )*1. , 1.5 );\n        z.yx *= rot(-m*4.);\n    }\n    \n    \n    if (rA == 1. && rB <= 1. && !(yID < 1.)) {\n        float m = mpow( sin((fract(T/tBetweenPhases))*pi*1. )*1. , 0.7 );\n        \n\t\tz = vec3(atan(p.x,p.z),length(p.xz),p.y);\n        \n        z.x = pmod(z.x,repsXIn);\n        z.y = pmod(z.y,repsYIn);\n        \n        z.z += 0.1*m;\n        z.y -= 0.1*m;\n        //z.zy *= rot(m*0.5);\n        z.yx *= rot(-m*4.*r);\n        //z.yz *= rot(-m*1.*r);\n    }\n    if (yID == 0.) {\n        pO = vec3(z.y,pmod(z.y,repsYIn), p.y);\n        //return vec2(sdThingieB(p));\n        return vec2(0.1);\n    }\n    \n    if (yID <= 1.) {\n        z.z *= 1.7;\n        z.z += 0.1;\n    }     \n\n    //z.y = pmod(z.y,pi/repsY);\n    \n    //z.z += sin(yID + iTime*(0.8 + sin(iTime)*0.1))*0.5;\n    z.z += sin(yID*0.8 + iTime*(0.6 ))*0.5;\n    \n    //z.y *= 1.;\n    \n    z.z += length(p.xz)*(0. + sin(iTime*0.3)*0.27 ); // incline\n    \n\t\n    \n    //z.x *= 1. + length(p.xz); // resize A\n    //z.y *= 1. - length(p.xz)*0.6; // resize A\n    //z.z *= exp( - length(p.xz)*0.1); // resize A\n    \n    d = dmin(d, vec2(sdPolyhedron(z - vec3(0.,0.,0)) , 1.));\n\n\treturn d;\n}\nvec3 getNormal(vec3 p) {\n    vec2 t = vec2(0.001,0.);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\n\n\n// soft shadows from inigo quilez, who got them from somewhere else\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; \n    \n    for( int i=0; i<72; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n\n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#define spectra(x,t) (0.5 + sin(vec3(0.5,0.9,0.4)*x + t))\nvec4 render(vec2 uv) {\n\tvec3 col = vec3(0);\n\n\tvec3 ro = vec3(0. + sin(iTime*0.4)*20.,29.+ sin(iTime)*2.,0. - 40. - sin(iTime*0.2)*10. );\n    vec3 lookAt = vec3(0,0.,0);\n\tvec3 rd = getRd(ro, lookAt, uv);\n    \n    float rand=random(uv.x + 2. + uv.y);\t\t\t\t// thx nusan for dither\n    float dither = 0.2+0.01*rand;\n    //dither = 1.;\n    \n    vec3 p = ro; float t = 0.;\n    for(int i = 0; i < 300; i++){\n    \tvec2 d = map(p)*dither;\n    \t\n        if(d.x < 0.005){\n            \n            vec3 lPos = vec3(1,5,0.);\n            vec3 lDir = normalize(lPos - p);\n            //vec3 lDir = normalize(-vec3(1,1,0));\n        \tvec3 n = getNormal(p);\n            vec3 h = normalize(lDir - rd);\n            \n            float diff = max(dot(n, lDir),0.);\n            float fres = pow(max(dot(n, -rd),0.),6.);\n            float spec = max(dot(n, h),0.);\n            float shad = calcSoftshadow(p, lDir, 0.01, 1.0, 0 );\n            float att  = 1./(length(lPos - p)*length(lPos - p));\n            \n            \n            //att = 0.02;\n            col += mix(diff*1., fres* spec, 0.1);\n            \n            col *= shad;\n            col *= att;\n            \n            //col += 1.;\n            break;\n        }\n    \n        if(t > 100.){\n            //col += 1.;\n        \tbreak;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    col *= 15.;\n    \n    \n    col *= vec3(1.5,1.1,1.02);\n    col = pow(col, vec3(1.04,1.,1.));\n    col = pow(col, vec3(0.45));\n    \n    \n    return vec4(col, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    fragColor = render(uv);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 prev = texture(iChannel1, uv);\n    vec4 curr = texture(iChannel0, uv);\n    \n    \n    fragColor = mix(prev,curr,0.7);\n    \n    \n    //fragColor;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3GDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 166]], "test": "untested"}
{"id": "3tcGDs", "name": "Liquid metal ocean", "author": "Alkama", "description": "Happy new year 2020!\n\nThis is faked to the bones, demoscene style :D", "tags": ["raymarching", "distancefield", "liveshading"], "likes": 22, "viewed": 1235, "published": 3, "date": "1577903228", "time_retrieved": "2024-07-30T21:32:05.394339", "image_code": "#define sat(a) clamp(a, 0., 1.)\nfloat t=0.;\n\nfloat scene(vec3 p) {\n    // the sphere\n\tfloat s = length(p-vec3(0,.3,0)) - 1.;\n\n    // the ocean is just a plane with different levels of noise going opposite directions and with different scale\n    // of course this breaks continuity so we compensate by undershooting our marching\n  \tfloat pl = p.y +\n  \t0.1 * texture(iChannel0, sin( t*.008)+t*.008+p.xz*.50).r +\n  \t0.2 * texture(iChannel0, cos(-t*.004)-t*.004+p.xz*.15).r +\n  \t0.9 * texture(iChannel0, sin( t*.020)+t*.010+p.xz*.05).r;\n\n  \treturn min(s,pl);\n}\n\n// returns distance, iteration count and if it hit (1) or not (0)\nvec3 march(in vec3 ro, in vec3 rd) {\n  \tfloat d = 0.;\n  \tvec3 p = ro;\n  \tfloat li=0.;\n  \tfor(float i=0.; i<200.; i++) {\n    \tfloat h = scene(p)*.5; // undershoot the march by half\n    \tif(abs(h)<.001*d) return vec3(d,i,1);\n    \tif(d>100.) return vec3(d,i,0);\n    \td+=h;\n    \tp+=rd*h;\n        li = i;\n  \t}\n  \treturn vec3(d, li, 0);\n}\n\nvec3 wrecked_normals(vec3 p) {\n    // normals epsilons are way overshot, this is what gives the ocean smoothness\n    const vec2 e = vec2(0.3,0.0);\n    return normalize(scene(p)-vec3(scene(p-e.xyy), scene(p-e.yxy), scene(p-e.yyx)));\n}\n\nvec3 getcam(vec2 uv, vec3 o, vec3 tg, float z) {\n  \tvec3 f = normalize(tg-o);\n  \tvec3 s = normalize(cross(vec3(0,1,0), f));\n  \tvec3 u = normalize(cross(f,s));\n  \treturn normalize(f*z+uv.x*s+uv.y*u);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = mod(iTime, 100.);\n    vec2 uv = ((fragCoord/iResolution.xy)-0.5) / vec2(iResolution.y / iResolution.x, 1);\n    \n    vec3 eye = vec3(0,1,-2);\n    // animate camera\n  \teye.xz += 5.*vec2(sin(t*.025), cos(t*.025));\n  \tvec3 target = vec3(0);\n  \tvec3 dir = getcam(uv,eye,target,.75);\n  \n  \tvec3 lp = 3.*vec3(1,2,2);\n  \n  \tvec3 col = vec3(0);\n  \tvec3 m = march(eye, dir);\n  \tif(m.z == 1.) {\n    \tvec3 p = eye+dir*m.x;\n    \tvec3 n = wrecked_normals(p);\n    \tvec3 ld = normalize(lp-p);\n    \tfloat diff = sat(max(0., dot(n,ld)));\n    \tfloat spec = sat(pow(max(0., dot(dir,reflect(ld,n))), 40.));\n    \tfloat fres = sat(pow(max(0., 1.-dot(-dir,n)), 2.));\n    \tcol = sat(vec3(diff+spec)*fres*cos(dir)*vec3(.8, .7, 1.1));\n  \t} else {\n    \tcol = cos(dir)*vec3(.8, .7, 1.1)*smoothstep(0.,.1,dir.y);\n  \t}\n    // all the look comes from that shaped iteration glow\n  \tcol += pow(m.y/70., 2.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 66, 84, 556], [558, 624, 660, 660, 956], [958, 958, 988, 1070, 1191], [1193, 1193, 1241, 1241, 1393], [1395, 1395, 1452, 1452, 2372]], "test": "untested"}
{"id": "3l3GDs", "name": "Molecular dynamics 3D v2", "author": "michael0884", "description": "Use WASD/arrow + mouse to move around. C -clear box, space - shoot ball. P- pause. Molecular dynamics in 3d on a fragment shader! lol^3", "tags": ["3d", "voronoi", "simulation", "particles", "molecular"], "likes": 13, "viewed": 612, "published": 3, "date": "1577900142", "time_retrieved": "2024-07-30T21:32:06.616073", "image_code": "// Fork of \"Lorentz Attractor 3D\" by michael0884. https://shadertoy.com/view/3lt3WX\n// 2019-12-31 20:33:24\n\n// Fork of \"Volumetric shader template\" by michael0884. https://shadertoy.com/view/tlc3Wf\n// 2019-12-30 20:57:24\n\n//hack \n#define fakech0 ch0\n#define fakech1 ch1\n#define fakech2 ch2\n#define fakech3 ch3\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\nvec4 ambient_occlusion(in vec4 pos, inout vec4 norm)\n{\t\n\tvec3 pos0 = pos.xyz;\n\t\n\tfloat occlusion_angle = 0.;\n\t\n\t//step out\n    vec3 color = vec3(0.);\n    float mind =  max(0.05*norm.w, sphere_rad*0.5);\n\tpos.xyz += mind*norm.xyz;\n    norm.xyz = cosdistr(norm.xyz, 0.01);\n\t//march in the direction of the normal\n\tfor(int i = 0; i < 2; i++)\n\t{\n        pos.w = abs(map(pos.xyz));\n\t\tpos.xyz += pos.w*norm.xyz;\n\t\t\n\t\tnorm.w = length(pos0 - pos.xyz);\n       \n\t\tocclusion_angle += clamp((pos.w - mind)/(norm.w),0.,1.);\n\t}\n     color += 2.*ambient_sky_color(norm.xyz)  + 5.*texture(ch2, norm.xzy).xyz;\n\treturn vec4(color*(occlusion_angle*0.65+0.35), occlusion_angle)/2.;\n}\n\n\n\n\nvec3 lighting(vec4 color, vec2 pbr, vec4 pos, vec4 dir, vec4 norm, float shadow) \n{\n\tvec3 albedo = color.xyz;\n\tnorm.w = dir.w;\n    vec3 N = norm.xyz;\n\tvec4 ambient_color = ambient_occlusion(pos, norm);\n\t\n\tfloat metallic = pbr.x;\n\tvec3 F0 = vec3(0.04); \n\tF0 = mix(F0, albedo, metallic);\n\t\n\t//reflectance equation\n\tvec3 Lo = vec3(0.0);\n\tvec3 V = -dir.xyz;\n\t\n\t\n\t{ //ambient occlusion contribution\n\t\tfloat roughness = pbr.y;\n\t\tvec3 L = normalize(norm.xyz);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = ambient_color.xyz;        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\t\n\tvec3 sun_color = sky_color(light);\n\n\t{ //light contribution\n\t\tfloat roughness = pbr.y;\n\t\tvec3 L = normalize(light);\n\t\tvec3 H = normalize(V + L);\n\t\tvec3 radiance = sun_color*shadow;        \n\t\t\n\t\t// cook-torrance brdf\n\t\tfloat NDF = DistributionGGX(N, H, roughness);        \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);      \n\t\tvec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n\t\t\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic;\t  \n\t\t\n\t\tvec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);  \n\t\t\t\n\t\t// add to outgoing radiance Lo\n\t\tfloat NdotL = max(dot(N, L), 0.0);                \n\t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t}\n\t\n\treturn Lo;\n}\n\n#define sky vec3(20,80,235)/255.\nvec3 ray_march(vec3 p, vec3 r)\n{\n    float td = 0.;\n    int i;\n    for(i = 0; i < MAX_MARCHES; i++)\n    {\n    \tfloat de = map(p);\n        if(de < rayfov*td || td > MAX_DIST)\n        {\n            break;\n        }\n        p += de*r;\n        td += de;\n    }\n    vec3 col =sdcolor(p);\n    if(td > MAX_DIST || i > MAX_MARCHES)\n    {\n        col = sky_color(r);\n    }\n    else\n    {\n        vec4 norm = calcNormal(p,MIN_DIST);\n        p += r*(norm.w-rayfov*td);\n        #ifdef SHADOWS\n      \t\tfloat shad = shadow_march(vec4(p+norm.xyz*0.05,0.), vec4(light,0.), 400.,0.03);\n        #else\n        \tfloat shad = 1.;\n        #endif\n        \n        col = lighting(vec4(col,0.), vec2(0.2,0.3), vec4(p, 0.), vec4(r, td), norm, shad);\n    }\n   \n    return col;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + fragCoord.x + fragCoord.y*3.141592653;\n    rayfov = FOV/iResolution.x;\n     SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n   \n    vec2 uv = (fragCoord - 0.5*size)/max(size.x, size.y);\n\n    vec2 angles = texelFetch(iChannel3,  ivec2(ANGLE_INDX,0), 0).xy;\n \tvec3 ray = getRay(angles, uv);\n    vec3 cray = getRay(angles, vec2(0.));\n    \n    vec4 cpos = texelFetch(iChannel3,  ivec2(POS_INDX,0), 0);\n    \n    light = vec3(0.6,0.50,1.);\n    light.z = max(light.z, 0.9);\n    light = normalize(light);\n   \t\n    vec3 pos = cpos.xyz;\n\n    // Output to screen\n    vec4 t = texel(ch0, fragCoord);\n    vec3 p = dim3from2(fragCoord);\n    #ifdef VOLUMETRIC\n   \t fragColor = 2.*ray_march_vol(pos, ray);\n    #else\n     fragColor = 1.*vec4(HDRmapping(ray_march(pos, ray), 0.8),1);\n\t#endif\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define pixel(a, p, s) texture(a, p/vec2(s))\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n//#define VOLUMETRIC\n#define SHADOWS\n\n//shows bonds/links between atoms, is unstable\n//#define LINKS\n#define FULL_UNION\n#define sphere_rad 1.2\n\n#define MAX_MARCHES 300\n#define DX 1.5\n#define OPACITY 0.2\n\nfloat rayfov;\nvec3 light;\n\n#define shadow_steps 90\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.\n\nfloat dt = 0.5;\n\n#define MOUSE_INDX 0\n#define ANGLE_INDX 1\n#define POS_INDX   2\n#define VEL_INDX   3\n#define SPEED_INDX 4\n#define MANIP_INDX 5\n\n//3d slice aspect ratio \n#define ar vec2(1.35,0.8)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, dim2from3(p3d), textureSize(ch, 0));\n}\n\nvec4 texel(sampler2D ch, ivec2 p)\n{\n    return pixel(ch, vec2(p + 1), textureSize(ch, 0));\n}\n\nvec4 texel(sampler2D ch, vec2 p)\n{\n    return pixel(ch, round(p+1.), textureSize(ch, 0));\n}\n\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n\nfloat seed = 0.;\nfloat rand()\n{\n    float r = hash(seed);\n    seed = r;\n    return r;\n}\n\nvec3 rand3()\n{\n    vec3 r = hash31(seed);\n    seed = r.x*1.54879 + r.y*2.554963 + r.z*0.857836;\n    return r;\n}\n\nvec4 rand4()\n{\n    vec4 r = hash41(seed);\n    seed = r.x*1.54879 + r.y*2.554963 + r.z*0.857836 + r.w*3.5823758;\n    return r;\n}\n\n//normally distributed random numbers\nvec3 randn()\n{\n    vec4 rand = rand4();\n    vec3 box_muller = sqrt(-2.*log(max(vec3(rand.x,rand.x,rand.z),1e-8)))*vec3(sin(2.*PI*rand.y),cos(2.*PI*rand.y),sin(2.*PI*rand.w));\n    return box_muller;\n}\n\n//uniformly inside a sphere\nvec3 random_sphere()\n{\n    return normalize(randn())*pow(rand(),0.333333);\n}\n\nvec3 cosdistr(vec3 dir, float w)\n{\n    vec3 rand_dir = normalize(randn());\n    vec3 norm_dir = normalize(rand_dir - dot(dir,rand_dir)*dir);\n    float u = w*rand();\n    return normalize(dir*sqrt(1. - u) + norm_dir*sqrt(u));\n}\n\nbool inside(vec3 p)\n{\n    if(p.x > 1. && p.y > 1. && p.z > 1. && p.x < float(size3d.x)-1. && p.y < float(size3d.y)-1. && p.z < float(size3d.z)-1.)\n    {\n        return true;\n    }\n    else return false;\n}\n\n#define FOV 2.5\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat maxv(vec3 a)\n{\n    return max(max(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d - 1.) - p;\n    return min(minv(p),minv(a)) + 1.;\n}\n\nvec4 border_grad(vec3 p)\n{\n    const float dx = 0.001;\n    const vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*distance2border(p + k.xyy*dx) +\n\t\t\t k.yyxx*distance2border(p + k.yyx*dx) +\n\t\t\t k.yxyx*distance2border(p + k.yxy*dx) +\n\t\t\t k.xxxx*distance2border(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\n//encoding 2 values in one number\nfloat scaleFactor = 65530.0;\nfloat cp = 256.0 * 256.0;\n\n\n/* packs given two floats into one float */\nvec4 enc(vec4 x, vec4 y) {\n    vec4 x1 = round(x * scaleFactor);\n    vec4 y1 = round(y * scaleFactor);\n    vec4 f = (y1 * cp) + x1;\n    return f;\n}\n\n/* unpacks given float to two floats */\nvoid dec(in vec4 f, out vec4 x, out vec4 y){\n  vec4 dy = floor(f / cp);\n  vec4 dx = f - (dy * cp);\n  y = (dy / scaleFactor);\n  x = (dx / scaleFactor);\n}\n\nstruct particle\n{\n    vec4 pos;\n    vec4 vel;\n};\n\nparticle get(sampler2D ch, vec3 p)\n{\n    p = clamp(p, vec3(0.), size3d);\n    vec4 data = voxel(ch, p);\n    particle part;\n    dec(data, part.pos, part.vel);\n    part.pos.xyz *= size3d;\n    part.vel *= 10.;\n    return part;\n}\n\nvec4 save(particle a)\n{\n    //scale the numbers to be in a [-1,1] range\n    a.pos.xyz /= size3d;\n    return enc(a.pos, 0.1*a.vel);\n}\n    \nfloat force(float d)\n{\n    d *= 4.;\n    return -2.*(0.5*exp(-0.5*d) - 2.*exp(-3.*d));\n}\n\n\n//ray marching primitives, credits to Inigo Quilez \n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdLineBox(vec3 p, vec3 b, float r)\n{\n    p = abs(p);\n    float cx = sdCapsule(p, b, vec3(b.x,b.y,0), r);\n    float cy = sdCapsule(p, b, vec3(0,b.y, b.z), r);\n    float cz = sdCapsule(p, b, vec3(b.x,0, b.z), r);\n    return min(min(cx, cy),cz);\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\n//SIMULATION STUFF\nuniform sampler2D fakech0;\nuniform sampler2D fakech1;\nuniform sampler2D fakech2;\nuniform sampler2D fakech3;\n    \nvoid Check(inout particle U, vec3 pos, vec3 dx)\n{\n    particle neighbor = get(fakech0, pos + dx);\n    //check if the stored neighbouring particle is closer to this position \n    if(length(neighbor.pos.xyz - pos) < length(U.pos.xyz - pos))\n    {\n        U = neighbor; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout particle U, vec3 p, int r)\n{\n    Check(U, p, vec3(-r, 0, 0));\n    Check(U, p, vec3(r, 0, 0));\n    Check(U, p, vec3(0, -r, 0));\n    Check(U, p, vec3(0, r, 0));\n    Check(U, p, vec3(0, 0, -r));\n    Check(U, p, vec3(0, 0, r));\n}\n\n//get the force from a particle in p0 to a particle at p\nvec3 getForce(vec3 p0, vec3 p)\n{\n\tparticle neighbor = get(fakech0, p0);\n    vec3 dx = neighbor.pos.xyz - p;\n    //only count if neighbor particle is inside of its cell to exclude repeated forces\n    if(maxv(abs(neighbor.pos.xyz - round(p0))) <= 0.5)\n        return normalize(dx)*force(length(dx));\n    else\n        return vec3(0.);\n}\n\n#define rad 2\nvec3 calc_force(vec3 p)\n{\n    vec3 p0 = round(p);\n    vec3 force = vec3(0.);\n    for( int i=-rad; i<=rad; i++ )\n        for( int j=-rad; j<=rad; j++ )\n            for( int k=-rad; k<=rad; k++ )\n    {\n        vec3 dx = vec3(i,j,k);\n        if(dx != vec3(0))\n          force += getForce(p0+dx, p);\n    }\n    \n    return force;\n}\n\n\nvoid init(out particle U, in vec3 p)\n{\n    if(distance2border(p) > 10.)\n    {\n        U.pos.xyz = vec3(4.*floor(p.xyz/4.));\n        U.pos.w = hash13(U.pos.xyz+10.);\n        U.vel.xyz = 0.05*(hash33(U.pos.xyz+0.1)*2. - 1.);\n    }    \n    else\n    {\n        U.pos = vec4(1e5);\n        U.vel = vec4(0.);\n    }\n}\n\nvoid SimulationStep(inout particle U)\n{\n    vec4 border = border_grad(U.pos.xyz);\n    vec3 cvec = -U.pos.xyz*vec3(0,0,1);\n    vec3 G = 0.15*normalize(cvec)/size3d;\n   \n    vec3 force =calc_force(U.pos.xyz);\n    vec3 bound =1.*normalize(border.xyz)*exp(-0.4*border.w*border.w);\n    float cooling = 1. - (1.-exp(-0.3*length(U.vel.xyz)))*(0.01*exp(-0.05*dot(cvec,cvec)) + 0.01*exp(-0.4*border.w*border.w) + 0.04*exp(-0.1*dot(force,force)));\n    U.vel.xyz =  U.vel.xyz*cooling + dt*(bound+force+G);\n    U.pos.xyz += dt*U.vel.xyz;\n}\n\nvoid UpdateVoronoi(inout particle U, in vec3 p)\n{\n    //check neighbours \n    CheckRadius(U, p, 1);\n    CheckRadius(U, p, 2);\n    CheckRadius(U, p, 3);\n    CheckRadius(U, p, 4);\n}\n\n\n\n\n//Rendering \n\nfloat SDF_particle(vec3 p0, vec3 p)\n{\n    particle point = get(fakech0, p0);\n    return length(point.pos.xyz - p) - sphere_rad;\n}\n\nfloat SDF_particle_wlink(vec3 p0, vec3 p, vec3 p1)\n{\n    particle point = get(fakech0, p0);\n    float pde = length(point.pos.xyz - p) - sphere_rad;\n    #ifdef LINKS\n        if(length(point.pos.xyz - p1) < 4.)\n        {\n             pde = min(pde, sdCapsule(p, point.pos.xyz, p1, sphere_rad*0.2));\n        }\n    #endif\n    return pde;\n}\n\nvec4 opunion(vec4 a, vec4 b)\n{\n    if(a.w < b.w) return a;\n    else return b;\n}\n\n//distance estimator to the voronoi particle field\nfloat DE(vec3 p)\n{\n\tfloat de = 1e5;\n   \n   \tvec3 p0 =  round(clamp(p, vec3(0), size3d));\n    if(minv(abs(p - size3d*0.5)) > 0.55*maxv(size3d)) \n        de = length(p - size3d*0.5);\n    else\n    {\n        particle centr_partic = get(fakech0, p0);\n        vec3 p1 = centr_partic.pos.xyz;\n        de = min(de, length(p1-p) - sphere_rad);\n        de = min(de, SDF_particle_wlink(p0+vec3(1,0,0), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(-1,0,0), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(0,1,0), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(0,-1,0), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(0,0,1), p, p1));\n        de = min(de, SDF_particle_wlink(p0+vec3(0,0,-1), p, p1));\n        if(de < sphere_rad*2.)\n        {\n            de = min(de, SDF_particle_wlink(p0+vec3(1,1,1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(-1,1,1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(-1,-1,1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(-1,-1,-1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(1,-1,-1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(1,1,-1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(-1,1,-1), p, p1));\n            de = min(de, SDF_particle_wlink(p0+vec3(1,-1,1), p, p1));\n        }\n    }\n    \n    return de;\n}\n\nvec3 particle_color(vec3 p)\n{\n    vec4 a = vec4(1e5);\n    vec3 p0 = round(p);\n    for( int i=-1; i<=1; i++ )\n        for( int j=-1; j<=1; j++ )\n            for( int k=-1; k<=1; k++ )\n    {\n        vec3 dx = vec3(i,j,k);\n        particle thisp = get(fakech0, p0+dx);\n        a = opunion(a, vec4(jet_range(thisp.pos.w, -0.1, 1.2), SDF_particle(p0+dx, p)));\n    }\n    return a.xyz;\n}\n\nvec3 COL(vec3 p)\n{\n    if(inside(p))\n    {\n        return particle_color(p)*exp(-0.25*pow(max(DE(p),0.),2.));\n    }\n    else return vec3(0.);\n}\n\nvec4 ray_march_vol(vec3 p, vec3 r)\n{\n    vec4 color = vec4(0., 0., 0., 0.);\n    vec4 background = vec4(0.1);\n    for(int i = 0; i < 90; i++)\n    {\n        vec3 tcolor = COL(p);\n        float density = length(tcolor);\n        float noise  =(1.+0.5*rand());\n        float d = 4.*DX*exp(-2.*min(density,2.))*noise;\n        float opacity = 1.-exp(-OPACITY*density*d);\n        float newa = max(color.w + (1. - color.w)*opacity,0.0001);\n        color.xyz = (color.xyz*color.w + (1.-color.w)*opacity*tcolor)/newa;\n        color.w = newa;\n        if(1. - newa < 0.02) break;\n        p += r*d;\n    }\n    return background + color;\n}\n\nvec3 sdcolor(vec3 p)\n{\n    vec3 c = vec3(0.);\n    if(inside(0.8*(p-size3d*0.5) + size3d*0.5))\n    {  \n        c = particle_color(p);\n    }\n    else c = vec3(1.);\n    if(sdLineBox(p - size3d*0.5, size3d*0.5, 0.5) < 1. || p.z < 1.) c = vec3(1.);\n    return c;\n}\n\n\nfloat map(vec3 p)\n{\n    float de_partic = DE(p); \n    de_partic = min(de_partic, sdPlane(p, vec4(0,0,1,0)));\n    return min(de_partic, sdLineBox(p - size3d*0.5, size3d*0.5, 0.5));\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*map(p + k.xyy*dx) +\n\t\t\t k.yyxx*map(p + k.yyx*dx) +\n\t\t\t k.yxyx*map(p + k.yxy*dx) +\n\t\t\t k.xxxx*map(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//usual ray marching stuff\n\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n\tfloat dDEdt = 0.;\n\tpos.w = map(pos.xyz);\n\tint i = 0;\n\tfor (; i < shadow_steps; i++) {\n\t\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n        vec3 ra =rand3()-0.5;\n        \n\t\tpos.w = (1. + 0.1*ra.x)*abs(map(pos.xyz));\n        dir.xyz = normalize(dir.xyz + 0.01*pos.w*ra/2.5*rayfov*dir.w);\n\t\n\t\tfloat angle = max((pos.w - 2.5*rayfov*dir.w)/(max(0.0001,dir.w)*light_angle), 0.);\n\t\t\n        light_visibility = min(light_visibility, angle);\n\t\t\n\t\tph = pos.w;\n\t\t\n        if(dir.w >= distance2light)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(dir.w > MAX_DIST || pos.w < max(2.*rayfov*dir.w, MIN_DIST))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(i >= shadow_steps)\n\t{\n\t\tlight_visibility=0.;\n\t}\n\t//return light_visibility; //bad\n\tlight_visibility = clamp(2.*light_visibility - 1.,-1.,1.);\n\treturn  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)\n}\n\n\n///PBR functions \nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n///END PBR functions\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(in vec3 pos)\n{\n    pos = pos.xzy;\n\t// Atmosphere Scattering\n\tvec3 fsun = light.xzy;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(pos.y-0.1),0.)),2.)+0.1));\n\tif(pos.y < 0.)\n\t{\n\t\tpos.y = 0.;\n\t\tpos.xyz = normalize(pos.xyz);\n\t}\n    float mu = dot(normalize(pos), normalize(fsun));\n\t\n\tvec3 extinction = mix(exp(-exp(-((pos.y + fsun.y * 4.0) * (exp(-pos.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-pos.y * 16.0) + 0.1) * Kr / Br) * exp(-pos.y * exp(-pos.y * 8.0 ) * 4.0) * exp(-pos.y * 2.0) * 4.0, vec3(1.0 - exp(fsun.y)) * 0.2, -fsun.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,10.);\n\treturn pow(sky_col,vec3(1./0.7)); \n}\n\nvec3 ambient_sky_color(in vec3 pos)\n{\n\tfloat y = pos.z;\n    pos.z = 0.;\n\treturn sky_color(pos)*exp(-abs(y));\n}\n\n\n\n\n\n", "buffer_a_code": "//3d voronoi particle tracking\nvoid Interactivity(inout particle U, vec3 p)\n{\n    vec2 angles = texel(ch3,  ivec2(ANGLE_INDX,0)).xy;\n    vec3 cray = getRay(angles, vec2(0.));\n    vec3 cpos = texelFetch(ch3,  ivec2(POS_INDX,0), 0).xyz;\n    vec4 manip = texelFetch(ch3,  ivec2(MANIP_INDX,0), 0);\n    //add particle\n    if(manip.x > 0.5) \n    {\n        if(length(p - cpos) < 4.) \n        {\n            U.pos.xyz = cpos+cray*0.6;\n            U.vel.xyz = cray*0.6;\n            U.pos.w = 0.5*sin(iTime)+0.5;\n            U.vel.w = 0.5*sin(iTime)+0.5;\n        }\n    }\n    //remove everything\n    if(manip.y > 0.5) \n    {\n        U.pos.xyz = vec3(10.);\n        U.vel.xyz = vec3(0.);\n        U.pos.w = 0.;\n        U.vel.w = 0.;\n    }\n}\n\n\n//hack \n#define fakech0 ch1\n#define fakech1 ch1\n#define fakech2 ch2\n#define fakecha ch3\n\n\nvoid mainImage( out vec4 pix, in vec2 pos )\n{\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n     vec4 manip = texelFetch(ch3,  ivec2(MANIP_INDX,0), 0);\n    dt = manip.z*dt;\n    //voxel pos\n    vec3 p = dim3from2(pos);\n    \n    //this particle\n    particle U;\n    \n    if(iFrame < 1)\n    {\n        init(U, p);\n    }\n    else\n    {\n        //get voxel particle\n        U = get(ch0, p);\n        UpdateVoronoi(U,p);\n        Interactivity(U, p);\n        SimulationStep(U);\n    }\n    \n    pix = save(U);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//3d voronoi particle tracking\n//hack \n#define fakech0 ch0\n#define fakech1 ch1\n#define fakech2 ch2\n#define fakech3 ch3\nvoid mainImage( out vec4 pix, in vec2 pos )\n{\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    \n      vec4 manip = texelFetch(ch3,  ivec2(MANIP_INDX,0), 0);\n    dt = manip.z*dt;\n    \n    //voxel pos\n    vec3 p = dim3from2(pos);\n    \n    //this particle\n    particle U;\n    \n    if(iFrame < 1)\n    {\n        init(U, p);\n    }\n    else\n    {\n        //get voxel particle\n        U = get(ch0, p);\n        UpdateVoronoi(U,p);\n       // Interactivity(U, p);\n        SimulationStep(U);\n    }\n    \n    pix = save(U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//3d voronoi particle tracking\n//hack \n#define fakech0 ch0\n#define fakech1 ch1\n#define fakech2 ch2\n#define fakech3 ch3\nvoid mainImage( out vec4 pix, in vec2 pos )\n{\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    \n    vec4 manip = texelFetch(ch3,  ivec2(MANIP_INDX,0), 0);\n    dt = manip.z*dt;\n    \n    //voxel pos\n    vec3 p = dim3from2(pos);\n    \n    //this particle\n    particle U;\n    \n    if(iFrame < 1)\n    {\n        init(U, p);\n    }\n    else\n    {\n        //get voxel particle\n        U = get(ch0, p);\n        UpdateVoronoi(U,p);\n        //Interactivity(U, p);\n        SimulationStep(U);\n    }\n    \n    pix = save(U);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/// UTILITY\n///\n/// Using the GPU as the CPU here, pretty inefficient I guess\n\n//hack \n#define fakech0 ch0\n#define fakech1 ch1\n#define fakech2 ch2\n#define fakech3 ch3\n\n#define N_instructions 10.\n\n#define CAMERA_SPEED 1.\n#define MOUSE_SENSITIVITY 0.15/60.\n\n//Keyboard constants\nconst int KEY_SPACE  = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( ch3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.);\n    }\n    \n    if(fragCoord.x <= N_instructions && fragCoord.y <= 1.)\n    {\n        SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n  \t    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    \n        //instruction\n        int I = int(fragCoord.x); \n        fragColor = texelFetch(ch1,  ivec2(I,0), 0);\n        vec4 mouse = texelFetch(ch1,  ivec2(MOUSE_INDX,0), 0);\n        vec2 mousespeed = texelFetch(ch1,  ivec2(MOUSE_INDX,0), 0).xy;\n        vec4 angles = texelFetch(ch1,  ivec2(ANGLE_INDX,0), 0);\n        mat3 camera = transpose(getCamera(angles.xy));\n        vec4 posit = texelFetch(ch1,  ivec2(POS_INDX,0), 0);\n        vec4 vel = texelFetch(ch1,  ivec2(VEL_INDX,0), 0);\n\t\tvec4 speed = texelFetch(ch1,  ivec2(SPEED_INDX,0), 0);\n        vec4 norm = calcNormal(posit.xyz, 0.01);\n        norm.xyz = norm.xyz/(length(norm.xyz) + 0.01);\n        switch(I)\n        {\n        case MOUSE_INDX:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n  \t\t    {\n   \t\t\t\tfragColor.xy = iMouse.xy - fragColor.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    fragColor.xy = vec2(0.);\n                }\n            }\n            else\n            {\n\t\t\t\tfragColor.xy = vec2(0.); // mouse delta\n            }\n    \t\tfragColor.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case ANGLE_INDX:  //angle computation\n           \n   \t\t\tfragColor.xy = fragColor.xy + fragColor.zw*MOUSE_SENSITIVITY; // angle delta\n            fragColor.y = clamp(fragColor.y, -PI*0.5, PI*0.5);\n    \t\tfragColor.zw += vec2(1,-1)*mouse.xy; // mouse pos\n            fragColor.zw *= 0.8;\n            fragColor.y *= 1.- 0.01*clamp(length(vel.xyz),0.,1.);\n             if(iFrame < 1)\n            {\n                fragColor.xy = vec2(-PI*0.5,0.2);\n            }\n            break;\n            \n        case POS_INDX:  //position\n          \n            float DeX = length(vel.xyz*speed.x)+0.0001;\n            float MAXDX = map(fragColor.xyz + vel.xyz*speed.x) + norm.w;\n            if(DeX > MAXDX)\n                vel *= 0.25;\n            fragColor.xyz += vel.xyz*speed.x;\n   \t\t\tfragColor.w = vel.w;\n            if(iFrame < 1)\n            {\n                fragColor.xyz = size3d*vec3(1.7,0.3,0.7);\n            }\n           \n            break;\n         case VEL_INDX:  //velocity\n          \n            fragColor.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            fragColor.xyz *= 0.8; //slowing down\n            \n            //collision detection, removing the normal velocity component \n            #define collision_dist 0.1\n          \tfragColor.xyz += norm.xyz*max(dot(fragColor.xyz, -norm.xyz),0.)*exp(-max(norm.w,0.)/collision_dist);\n            break;\n          case SPEED_INDX: //camera max speed\n            if(isKeyPressed(KEY_Q))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 1.01;\n            }\n            if(isKeyPressed(KEY_E))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 0.99;\n            }\n            if(iFrame < 1)\n            {\n                fragColor.x = CAMERA_SPEED;\n            }\n            break; \n          case MANIP_INDX:\n            if(isKeyPressed(KEY_SPACE) && iFrame%10==0)\n   \t   \t\t{\n   \t\t\t\tfragColor.x = 1.;\n            }\n            else\n            {\n                fragColor.x = 0.;\n            }\n            \n            if(isKeyPressed(KEY_C))\n   \t   \t\t{\n   \t\t\t\tfragColor.y = 1.;\n            }\n            else\n            {\n                fragColor.y = 0.;\n            }\n            \n            if(isKeyPressed(KEY_P) && iFrame%10==0)\n   \t   \t\t{\n   \t\t\t\tfragColor.z = 1. - fragColor.z;\n            }\n            \n             if(iFrame < 1)\n            {\n                fragColor.xyz = vec3(0.,0.,1.);\n            }\n            break; \n        }   \n    } else discard;\n    \n   \n    \n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3GDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 311, 334, 334, 474], [476, 476, 521, 547, 661], [663, 663, 717, 717, 1325], [1330, 1330, 1413, 1413, 3252], [3287, 3287, 3319, 3319, 4038], [4042, 4042, 4099, 4099, 4973]], "test": "untested"}
{"id": "Wt3GWs", "name": "1.2.3.4.", "author": "wyatt", "description": "My pet theory of everything\n[url]JAVASCRIPT: H=location.host;E=(H?window:opener).Effect;P=E.prototype;if(!E.P)E.P=P.Paint;P.Paint=function(...A){for(i=0;i<4;i++)E.P.apply(this,A);};if(!H)close();[/url]", "tags": ["wave"], "likes": 12, "viewed": 503, "published": 3, "date": "1577892319", "time_retrieved": "2024-07-30T21:32:07.380030", "image_code": "Main\n{\n    vec4 a = C(U), b = D(U);\n    Q = a*a+b*b;\n    Q += Q.z;\n    Q = abs(sin(atan(Q)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define Main void mainImage( out vec4 Q, in vec2 U )\n\n#define F(x) 1./(1.+(x))\n\n#define dt 1.\n#define K .5\n\n#define Border if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q *= 0.;\n#define Init if (iFrame < 1) Q = length(U-0.5*R)<30.?vec4(sin(U.x)+sin(.5*U.y),cos(.1*U.y)+cos(.5*U.x),1,0):vec4(0);\n#define Mouse if (iMouse.z>0.) Q.xyzw += exp(-.01*dot(U-iMouse.xy,U-iMouse.xy))*vec4(sin(.5*U.x),cos(.25*U.x),sin(iTime),0);", "buffer_a_code": "// m+- 1\nMain\n{\n    vec4 N = C(U+vec2(0,1)), E = C(U+vec2(1,0)), S = C(U-vec2(0,1)), W = C(U-vec2(1,0)), M = 0.25*(N+E+S+W); \n    Q = A(U);\n    vec4 c = C(U), d = D(U);\n    float m = c.x, p = c.y, n = c.z, r = d.x, g = d.y, b = d.z;\n    \n    vec4 P = \n        \t+1./6.*F(vec4(m*m,p*p,n*n,0))\n        \t-vec4(1./6.,.5,.5,0)*F(vec4(m*m,vec2(p*p+n*n),0))\n        \t+F((m*m+p*p+n*n+r*r+g*g+b*b)) ;\n    \n    Q += dt*(M-c-K*c*P);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// rgb 1\nMain\n{\n    vec4 N = D(U+vec2(0,1)), E = D(U+vec2(1,0)), S = D(U-vec2(0,1)), W = D(U-vec2(1,0)), M = 0.25*(N+E+S+W); \n    Q = A(U);\n    vec4 c = C(U), d = D(U);\n    float m = c.x, p = c.y, n = c.z, r = d.x, g = d.y, b = d.z;\n    \n    vec4 P = \n        \t1./6.*F(vec4(r*r,g*g,b*b,0))\n        \t-vec4(1./3.)*F(r*r+g*g+b*b)\n        \t+F((m*m+p*p+n*n+r*r+g*g+b*b)) ;\n    \n    Q += dt*(M-d-K*d*P);\n\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// m+- 2\nMain\n{\n    Q = A(U)+dt*B(U);\n    Mouse\n    Init\n    Border\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// rgb 2\nMain\n{\n    Q = A(U)+dt*B(U);\n    Mouse\n    Init\n    Border\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3GWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WdGSDd", "name": "2020 - A celebration of new year", "author": "PixelPhil", "description": "Happy New Year 2020 !\nThis year, instead of a boring card I decided to wish everyone my best wished for the new year 2020 with a shader.\n", "tags": ["bokeh", "numbers", "distance", "vector", "happy", "new", "outline", "fields", "year"], "likes": 56, "viewed": 4385, "published": 3, "date": "1577881103", "time_retrieved": "2024-07-30T21:32:08.136009", "image_code": "//\n// 2020 - A celebration of new year by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// Note: This shader is a fairly standard 2D composition with two layers. The digits\n// are produced with bespoke signed distance functions (the fact that 2020 has only two diferent\n// digits made the process easier).\n// The background is itslef a composition of 3 layers of cellular bokeh with some color tweaks\n// similar to techniques shown in BigWings tutorials.\n//\n// There is no huge technical feat but I wanted to create a warm and colorfull image.\n// Tell me what you think :D\n\n\n#define S(a,b,c) smoothstep(a,b,c)\n\n// outputs a colored shape with a white border from distance field (RGBA premultiplied)\nvec4 border(vec3 color, float dist)\n{\n    vec4 res;\n    \n    float aa = 30. / iResolution.x;\n    \n    res.a = S(0.25 + aa, 0.25, dist); \n    res.rgb = mix(color, vec3(res.a),  S(0.1, 0.1 + aa, dist)); \n    \n    return res;\n}\n\n// Blend a premultiplied rbga color onto rgb\nvec3 premulBlend(vec4 src, vec3 dst)\n{\n    return dst * (1.0 - src.a) + src.rgb;\n}\n\n// Blend a premultiplied rbga color onto rgba (accurate alpha handling)\nvec4 premulBlend(vec4 src, vec4 dst)\n{\n    vec4 res;\n    res.rgb = dst.rgb * (1.0 - src.a) + src.rgb;\n    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a); \n    \n    return res;\n}\n\n\n// Distance field to the digit 0\nfloat zeroDst(vec2 uv)\n{\n    float dist;\n    \n    uv.y -= 0.5;\n    \n    if (uv.y > 0.0) // upper part\n    {\n        uv.y = pow(uv.y, 1.8);\n    \tdist = length(uv);\n    }\n    else if (uv.y > -1.1) // middle part\n    {\n        dist = abs(uv.x);\n    }\n    else  // lower part\n    {\n        uv.y += 1.1;\n        uv.y = pow(-uv.y, 1.8);\n    \tdist = length(uv);\n    }\n    \n    return (abs(dist - 0.725) - 0.275);\n}\n\n// a box distance function\nfloat box(vec2 p, vec2 b )\n{\n\tvec2 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// Distance field to the digit 2\nfloat twoDst(vec2 uv)\n{\n    uv.y -= 0.5;\n    \n    float topBar = box((uv + vec2(0.725, 0.0)) * vec2(1.0, 1.4), vec2(0.275, 0.0));\n    \n    if (uv.y > 0.0) // Top 'curve'\n    {\n        uv.y = pow(uv.y, 1.8);\n    \tfloat dist = length(uv);\n        return max(-topBar, (abs(dist - 0.725) - 0.275));\n    }\n    else\n    {\n        float bottomBar = box((uv + vec2(0.0, 1.83)) * vec2(1.0, 1.4), vec2(0.95, 0.299));\n        \n        float two = min(topBar, bottomBar);\n        \n        if (uv.y > -1.8)\n        {    \n            float curve = (cos(uv.y * 2.0) - 1.0) * 0.7;\n            float x = 0.0 + uv.x - curve;\n            float mid = abs(uv.y + 0.4) * 0.7;\n            float x2 = 0.0 + uv.x - curve - mid * mid * 0.15 + 0.01;\n         \n            two = min(two, max(-x + 0.45, x2 -1.0));\n        }\n    \treturn two;\n    }\n\n}\n\n\n// Coordinate transform from global uv space to charcter space with poition and rotation\nvec2 letterUVs(vec2 uv, vec2 pos, float angle)\n{\n    float c = sin(angle);\n    float s = cos(angle);\n    float sc = 1.35;\n    uv -= pos;\n    return uv.x * vec2(s * sc, c) + uv.y * vec2(-c * sc, s);\n}\n\nfloat shadowsIntensity = 0.74;\nfloat shadowRadius = 1.1;\n\n// Character two with outline and shadow (premultiplied RGBA)\nvec4 twoCol(vec2 uv, vec3 col, vec2 pos, float angle)\n{\n    uv = letterUVs(uv, pos, angle);\n    vec4 res = border(col, twoDst(uv));\n    \n    uv.y += 0.14;\n    res.a = min(res.a +  S(shadowRadius, -1.0, twoDst(uv)) * shadowsIntensity, 1.0);\n    \n    return res;\n}\n\n// Character zero with outline and shadow (premultiplied RGBA)\nvec4 zeroCol(vec2 uv, vec3 col, vec2 pos, float angle)\n{\n    uv = letterUVs(uv, pos, angle);\n    vec4 res = border(col, zeroDst(uv));\n    \n    uv.y += 0.14;\n    res.a = min(res.a +  S(shadowRadius, -1.0, zeroDst(uv)) * shadowsIntensity, 1.0);\n    \n    return res;\n}\n\n\nvec3 red = vec3(0.9, 0.01, 0.16);\nvec3 yellow = vec3(0.96, 0.70, 0.19); // 248, 181, 51\nvec3 green = vec3(0.00, 0.63, 0.34);  //1, 162, 88\nvec3 blue = vec3(0.01, 0.57, 0.76);   //5, 142, 197\n\n// 2020 with colors and shadows (premultiplied rgba)\nvec4 yearCol(vec2 uv)\n{\n    float angle = sin(iTime) * 0.3;\n    \n    vec4 date = twoCol(uv, red, vec2(-2.5, 0.0), angle);\n    date = premulBlend(zeroCol(uv, yellow, vec2(-0.8, 0.0), angle), date);\n    date = premulBlend(twoCol(uv, green, vec2(0.8, 0.0), angle), date);\n    date = premulBlend(zeroCol(uv, blue, vec2(2.5, 0.0), angle), date);\n    \n    return  date;\n}\n\n// Borrowed from BigWIngs (random 1 -> 4)\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 104., 145., 24.))*vec4(657., 345., 879., 154.));\n}\n\n\n// Compute a randomized Bokeh spot inside a grid cell\nfloat bokehSpot(vec2 uv, vec2 id, float decimation)\n{\n    float accum = 0.0;\n    \n    for (float x = -1.0; x <= 1.0; x += 1.0)\n    {\n        for (float y = -1.0; y <= 1.0; y += 1.0)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 cellId = id + offset;\n            vec4 rnd = N14(mod(cellId.x, 300.0) * 25.3 + mod(cellId.y, 300.0) * 6.67);\n    \n            vec2 cellUV = uv - offset + rnd.yz * 0.5;\n\n            float dst = length(cellUV);\n\n            float radSeed = sin(iTime * 0.02 + rnd.x * 40.0);\n            float rad =  (abs(radSeed) - decimation) / (1.0 - decimation);\n\n            float intensity = S(rad, rad - 0.15, dst);\n            \n            accum += intensity;\n        }\n    }\n    \n    return accum;\n}\n\n// Computes a random layer of bokeh spots\nfloat bokehLayer(vec2 uv, float decimation)\n{\n    vec2 id = floor(uv);\n    vec2 cellUV = (uv - id) - vec2(0.5, 0.5) ;\n\n    float intensity = bokehSpot(cellUV, id, decimation);\n    \n    return intensity;\n}\n\n\n// Computes the bokeh background\nvec3 bokeh(vec2 uv)\n{\n    //accumulates several layers of bokeh\n    float intensity = bokehLayer(uv * 1.4 + vec2(iTime * 0.3, 0.0), 0.9) * 0.2;\n    //intensity += bokehLayer(uv * 0.8 + vec2(200.0 + iTime * 0.3, 134.0), 0.9) * 0.3;\n    intensity += bokehLayer(uv * 0.5 + vec2(0.0 + iTime * 0.3, 334.0), 0.95) * 0.15;  \n    intensity += bokehLayer(uv * 3.0 + vec2(iTime * 0.3, 99.0), 0.95) * 0.05;\n    \n    float cDist = max(0.0, 1.0 - length(uv) * 0.05);\n    \n    intensity = cDist + intensity;\n    \n    // Vary color with intensity\n    vec3 chroma = mix(vec3(1.0, 1.0, 0.4), vec3(1.0, 0.7, 0.5), uv.y * 0.1 + 0.4 + intensity * 0.4);\n    \n    return chroma * intensity;\n}\n\n\n// Final composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    uv *= 3.0;\n    \n    vec4 dateCol =  yearCol(uv); // 2020\n    \n    vec3 bg = bokeh(uv);\n    \n    //add a bit of light\n    dateCol.rgb -= uv.y * 0.15 * dateCol.a;\n    bg.rgb -= uv.y * 0.03;\n    \n    // blend 2020 and BG\n    vec3 col = premulBlend(dateCol, bg);\n    \n    // Gamma correction to make the image warmer\n    float gamma = 0.8;\n    col.rgb = pow(col.rgb, vec3(gamma));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGSDd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[716, 804, 841, 841, 1028], [1030, 1075, 1113, 1113, 1157], [1159, 1231, 1269, 1269, 1405], [1408, 1441, 1465, 1465, 1848], [1850, 1877, 1905, 1905, 1981], [1983, 2016, 2039, 2039, 2837], [2840, 2929, 2977, 2977, 3128], [3188, 3250, 3305, 3305, 3512], [3514, 3577, 3633, 3633, 3842], [4037, 4090, 4113, 4113, 4455], [4457, 4499, 4518, 4518, 4600], [4603, 4657, 4710, 4710, 5392], [5394, 5436, 5481, 5481, 5640], [5643, 5676, 5697, 5739, 6346], [6349, 6370, 6427, 6477, 6952]], "test": "untested"}
{"id": "3l3GWl", "name": "球形的光线步进（sphere ray marching）", "author": "ywqy", "description": "用光线步进做个球。\nuse ray marching make a sphere.\nlearn by the art of code\nhttps://www.youtube.com/watch?v=Ff0jJyyiVyw", "tags": ["raymarching", "artofcodetutorial"], "likes": 2, "viewed": 399, "published": 3, "date": "1577857209", "time_retrieved": "2024-07-30T21:32:08.896974", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\n//球形\nfloat sdSphere(vec3 point, vec3 offset, float radius) {\n\treturn length(point - offset) - radius;\n}\n\n//平面\nfloat sdPlane(vec3 point, vec3 offset, vec3 normal) {\n\treturn dot(point - offset, normal.xyz);\n}\n\n//计算射线上的点到物体的最小距离\nfloat GetDist(vec3 point) {\n    \n    float sphereDistance = sdSphere(point, vec3(0, 1, 6), 1.0);\n    float planeDistance = sdPlane(point, vec3(0, 0, 6), normalize(vec3(0, 1, -0.4)));\n    \n    float minDistance = min(sphereDistance, planeDistance);\n    \n    return minDistance;\n}\n\n//使用光线步进\nfloat RayMarch(vec3 rayOrigin, vec3 rayDrection) {\n\tfloat distanceFromOrigin = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 point = rayOrigin + rayDrection * distanceFromOrigin;\n        float minDistance = GetDist(point);\n        distanceFromOrigin += minDistance;\n\n        if(distanceFromOrigin > MAX_DIST || minDistance < SURF_DIST) \n            break;\n    }\n    \n    return distanceFromOrigin;\n}\n\n//运用偏移得到法向量\nvec3 GetNormal(vec3 hitPoint) {\n\tfloat hitDistance = GetDist(hitPoint);\n    vec2 epsilon = vec2(.01, 0);\n    \n    vec3 hitNormal = hitDistance - vec3(\n        \tGetDist(hitPoint - epsilon.xyy),\n        \tGetDist(hitPoint - epsilon.yxy),\n        \tGetDist(hitPoint - epsilon.yyx)\n    \t);\n    \n    return normalize(hitNormal);\n}\n\n//漫反射和其阴影\nfloat GetDiffuseLight(vec3 hitPoint) {\n\tvec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 10.0;\n    \n    vec3 lightDirection = normalize(lightPos - hitPoint);\n    vec3 hitNormal = GetNormal(hitPoint);\n    \n    float diffuseLight = dot(hitNormal, lightDirection);\n    diffuseLight = clamp(diffuseLight, 0.0, 1.0);\n    \n    float shadowTolightDist = RayMarch(hitPoint + hitNormal * SURF_DIST * 2.0, lightDirection);\n    if(shadowTolightDist < length(lightPos - hitPoint)) \n        diffuseLight *= .1;\n    \n    return diffuseLight;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 rayOrigin = vec3(0, 3, -3);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    float dist = RayMarch(rayOrigin, rayDirection);\n    vec3 hitPoint = rayOrigin + dist * rayDirection;\n    float diffuseLight = GetDiffuseLight(hitPoint);\n    \n    vec3 col = vec3(diffuseLight);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3GWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 78, 133, 133, 176], [178, 187, 240, 240, 283], [285, 333, 360, 360, 611], [613, 634, 684, 684, 1048], [1050, 1080, 1111, 1111, 1403], [1405, 1429, 1467, 1467, 1990], [1993, 1993, 2049, 2049, 2440]], "test": "untested"}
{"id": "3t3GWl", "name": "Puma Stripe Logo", "author": "yasuo", "description": "Happy New Year!", "tags": ["puma"], "likes": 2, "viewed": 314, "published": 3, "date": "1577851679", "time_retrieved": "2024-07-30T21:32:09.752687", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define PI 3.14159265\n\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/wdGXzK\n// http://mercury.sexy/hg_sdf/\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n    float angle = 2.0*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.*fix;\n    p = vec2(cos(a), sin(a))*r;\n\n    return p;\n}\n\n// puma logo\nfloat dPumaLogo(vec3 p, float artifact) {\n    float y = 0.25;\n    // stripe\n    mat3 rot = matRotateX(radians(90.0));\n    float dstripe0 = sdCappedCylinder((p-vec3(0.0,1.0+y,0.0))*rot,1.0,0.1);\n    float dstripe1 = sdCappedCylinder((p-vec3(-1.15,1.0+y,0.0))*rot,1.0,0.2);\n    \n    mat3 rotZ = matRotateZ(radians(6.0));\n    vec3 bp = (p-vec3(-0.63,1.88+y,0.0));\n    \n    const float k = -1.0;\n    float c = cos(k*bp.x);\n    float s = sin(k*bp.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*bp.xy,bp.z);\n    \n    mat3 rotZ2 = matRotateZ(radians(3.5));\n    vec3 bp2 = (p-vec3(-0.85,1.87+y,0.0));\n    float sc = mix(1.5,0.77,smoothstep(-1.0,1.0,bp2.x));\n    bp2.y *= sc;    \n    \n    float dstripe2 = sdBox(q*rotZ,vec3(1.0,0.15,0.1))*0.6;\n    float dstripe3 = sdBox(bp2*rotZ2,vec3(1.0,0.15,0.1))*0.6;\n    \n    float dstripe = min(max(-p.y+1.3,max(-dstripe1,dstripe0 )),min(max(-p.x-0.5, dstripe2),dstripe3));\n    \n    // logo outline\n    p.x *= 0.55;\n    float doutline0 = sdCappedCylinder((p-vec3(-0.2,1.55+y,0.0))*rot,1.1,0.1)*artifact;\n    float doutline1 = sdCappedCylinder((p-vec3(-0.2,1.55+y,0.0))*rot,1.0,0.2)*artifact;\n    float doutline = max(-doutline1,doutline0);\n    return min(dstripe,doutline);\n}\n\nvec4 pumaLogo(vec3 p){\n    p.y -= iTime*5.0;\n    p.y = mod(p.y,10.0)-5.0;\n    p *=  matRotateY(radians(-90.0));\n    p*=0.8;\n    \n    \n    float dlogo = dPumaLogo(p,0.3);\n    \n    return vec4(vec3(1.0),dlogo*0.9);\n}\n\nfloat dTwoZeroX2(vec3 p) {\n    vec3 prevP = p;\n    p.x = mod(p.x,2.8)-1.4;\n    \n    vec3 twoPos = vec3(-0.7,0.0,0.0);\n    float dtwo = sdBox(p+twoPos,vec3(0.6,1.0,0.1));\n    float dtwo1 = sdBox(p+twoPos+vec3(-0.6,-0.4,0.0),vec3(0.8,0.25,0.2));\n    float dtwo2 = sdBox(p+twoPos+vec3(0.6,0.45,0.0),vec3(0.8,0.25,0.2));\n    float dresTwo = max(-dtwo2,max(-dtwo1,dtwo))*0.9;\n    \n    vec3 zeroPos = vec3(0.7,0.0,0.0);\n    float dzero = sdBox(p+zeroPos,vec3(0.6,1.0,0.1));\n    float dzero1 = sdBox(p+zeroPos,vec3(0.3,0.7,0.2));\n    float dresZero = max(-dzero1,dzero)*0.9;\n    \n    p = prevP;\n    \n    float dres = max(sdBox(p,vec3(2.8,2.0,0.3)),min(dresTwo,dresZero));\n    return dres*0.9;\n}\n\nfloat cubicInOut(float t) {\n    return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\n// A smart way to control the animation. function is from \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\nfloat animscene(in float t, float w, float s) {\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.xz = pModPolar(p.xz,10.0,1.0);\n    p.x -= 20.0;\n    \n    vec4 logo = pumaLogo(p);\n    \n    p = prevP;\n    float d2020 = dTwoZeroX2(p);\n    float dlogo = dPumaLogo(p+vec3(0.0,1.7,0.0),0.6);\n    \n    float animTime = mod(iTime,6.0);\n    float morphVal = 0.0;\n    morphVal += cubicInOut(animscene(animTime, 1.0, 1.0))*1.0;\n    morphVal -= cubicInOut(animscene(animTime, 3.0, 1.0))*1.0;\n    \n    vec4 logo2 = vec4(vec3(1.0),mix(dlogo,d2020,morphVal));\n    \n    vec4 model = combine(logo,logo2);\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nfloat GetAmbientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - RayMarch(p + n*d,n).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n\n    float ao = GetAmbientOcclusion(p,n);\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif*ao),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 bg(vec2 p){\n    vec3 col = .94*max(mix(vec3(0.0,0.5,0.0)+(.1-length(p)/3.),vec3(1),.1),0.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(iTime*-30.0));\n    ro.yz *= Rot(radians(30.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,r.y),20.);\n        float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n        col = mix(bg(r.xy),vec3(dif),0.5)+spec;\n    } else {\n        // background\n        col = bg(uv);\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3GWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[537, 537, 573, 573, 615], [617, 617, 646, 646, 730], [732, 732, 784, 784, 891], [893, 965, 1025, 1025, 1245], [1247, 1260, 1301, 1301, 2474], [2476, 2476, 2498, 2498, 2690], [2692, 2692, 2718, 2718, 3379], [3381, 3381, 3408, 3408, 3494], [3496, 3608, 3655, 3655, 3696], [3698, 3698, 3720, 3720, 4262], [4264, 4264, 4297, 4297, 4550], [4552, 4552, 4576, 4576, 4777], [4779, 4779, 4813, 4813, 5127], [5477, 5477, 5500, 5500, 5901], [5903, 5903, 5945, 5945, 6140], [6142, 6142, 6158, 6158, 6256], [6258, 6258, 6315, 6315, 7111]], "test": "untested"}
{"id": "tt3GRN", "name": "Happy 2020!", "author": "piyushslayer", "description": "Happy new year everyone!\n\nv1.1 Added an initial bright flash at the starting of each explosion. (Thanks bigwings)\nv1.2 Improved water reflections.\nv1.3 Added a crescent moon.\nv1.4 Rockets slow down nearing apex.", "tags": ["noise", "reflection", "fbm", "water", "particles", "city", "lights", "fireworks"], "likes": 82, "viewed": 5460, "published": 3, "date": "1577835221", "time_retrieved": "2024-07-30T21:32:10.543572", "image_code": "/**\n This shader is basically an improvement upon a previous fireworks shader I did a while\n ago (www.shadertoy.com/view/Ws3SRS). Here, each firework spawns at a random position\n instead of the just following the same pattern in a loop, so the fireworks show can be\n watched and enjoyed infinitely. The fireworks spawn from behind the buildings, but in\n front of the mountains. I hope everyone finds watching this relaxing and enjoyable!\n\n I wish a very happy and a prosperous new year to everyone!\n*/\n\n#define PI  3.141592653589793\n#define TAU 6.283185307179586\n#define EPS 1e-4\n\n// Helper macros \n#define C(x) clamp(x, 0., 1.)\n#define S(a, b, x) smoothstep(a, b, x)\n#define F(x, f) (floor(x * f) / f)\n\n// Fireworks control variables\n#define FIREWORK_COUNT 6\n#define FIREWORK_DURATION 8.5\n#define FIREWORK_LOW .75\n#define FIREWORK_HIGH 1.05\n#define ROCKET_PARTICES 16\n#define ROCKET_DURATION 1.5\n#define FLASH_DURATION ROCKET_DURATION + .2 \n#define THRUSTER_SPEED .25\n#define EXPLOSION_STRENGTH .025;\n#define EXPLOSION_PARTICLES 128\n\n// Hash functions by Dave_Hoskins\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\nvec3 hash31(float p)\n{\n\tuvec3 n = uint(int(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\treturn vec3(n) * (1. / float(0xffffffffU));\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * uvec2(1597334673U, 3812015801U);\n\tuint q = (n.x ^ n.y) * 1597334673U;\n\treturn float(q) * (1. / float(0xffffffffU));\n}\n\n// Function to remap a value from [a, b] to [c, d]\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\n// Noise (from iq)\nfloat noise (in vec3 p) {\n\tvec3 f = fract (p);\n\tp = floor (p);\n\tf = f * f * (3. - 2. * f);\n\tf.xy += p.xy + p.z * vec2 (37., 17.);\n\tf.xy = texture (iChannel0, (f.xy + .5) / 256., -256.).yx;\n\treturn mix (f.x, f.y, f.z);\n}\n\n// Tiny fbm\nfloat fbm (in vec3 p) {\n\treturn noise (p) + noise (p * 2.) / 2. + noise (p * 4.) / 4.;\n}\n\n// Building window lights from www.shadertoy.com/view/wtt3WB\nfloat windows (vec2 uv, float offset)\n{\n    vec2 grid = vec2(20., 1.);\n    uv.x += offset;\n    float n1 = fbm((vec2(ivec2(uv * grid)) + .5).xxx);\n    uv.x *= n1 * 6.;\n    vec2 id = vec2(ivec2(uv * grid)) + .5;\n    float n = fbm(id.xxx);\n    vec2 lightGrid = vec2(79. * (n + .5), 250. * n);\n    float n2 = fbm((vec2(ivec2(uv * lightGrid + floor(iTime * .4) * .2)) + .5).xyx);\n    vec2 lPos = fract(uv * lightGrid);\n    n2 = (lPos.y < .2 || lPos.y > .7) ? 0. : n2;\n    n2 = (lPos.x < .5 || lPos.y > .7) ? 0. : n2;\n    n2 = smoothstep(.225, .5, n2);\n\treturn (uv.y < n - 0.01) ? n2 : 0.;\n}\n\n// Building skyline \nfloat buildings(vec2 st)\n{\n    // An fbm style amalgamation of various cos functions\n    float b = .1 * F(cos(st.x*4.0 + 1.7), 1.0);\n    b += (b + .3) * 0.3 * F(cos(st.x*4.-0.1), 2.0);\n    b += (b-.01) * 0.1 * F(cos(st.x*12.0), 4.);\n    b += (b-.05) * 0.3 * F(cos(st.x*24.0), 1.0);\n    return C((st.y + b - .1) * 100.);\n}\n\n// Twinkly stars, derived and modified from: www.shadertoy.com/view/4s33zf\nfloat stars(vec2 st, vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.y += .3;\n    uv.y = abs(uv.y);\n    float t = iTime * .1;\n    vec2 h = pow(hash21(uv.x * iResolution.y + uv.y), vec2(50.));\n    float twinkle = sin((st.x + t + cos(st.y * 50. + t)) * 25.);\n    twinkle *= cos((st.y * .187 - t * 4.16 + sin(st.x * 11.8 + t * .347)) * 6.57);\n    twinkle = twinkle * .5 + .5;\n    return h.x * h.y * twinkle * 1.5;\n}\n\n// Fireworks improved upon my previous shader: https://www.shadertoy.com/view/Ws3SRS\nvec3 fireworks(vec2 st)\n{\n\tvec2 fireworkPos, particlePos;\n    float radius, theta, radiusScale, spark, sparkDistFromOrigin, shimmer,\n        shimmerThreshold, fade, timeHash, timeOffset, rocketPath;\n    vec3 particleHash, fireworkHash, fireworkCol, finalCol;\n    for (int j = 0; j < FIREWORK_COUNT; ++j)\n    {\n        timeHash = hash11(float(j + 1) * 9.6144 + 78.6118);\n        timeOffset = float(j + 1) + float(j + 1) * timeHash;\n        // This hash changes after each firework cycle (rocket + explosion)\n        fireworkHash = hash31(471.5277 * float(j) + 1226.9146\n\t\t\t+ float(int((iTime+timeOffset) / FIREWORK_DURATION))) * 2. - 1.;\n        fireworkCol = fireworkHash * .5 + .5;\n    \tfireworkHash.y = remap(fireworkHash.y, -1., 1., FIREWORK_LOW, FIREWORK_HIGH);\n        // Random firework x coordinate but confined to a certain column based on j\n        fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .25)\n\t\t\t/ float(FIREWORK_COUNT)) * 2. - 1.;\n        // Duration of each firework with a random start time\n        float time = mod(iTime + timeOffset, FIREWORK_DURATION);\n        if (time > ROCKET_DURATION)\n        {\n            fireworkPos = vec2(fireworkHash.x, fireworkHash.y);\n            for (int i = 0; i < EXPLOSION_PARTICLES; ++i)\n            {\n                // Unique hash that yeilds a separate spread pattern for each explosion\n                particleHash = hash31(float(j) * 1291.1978 + float(i) \n\t\t\t\t\t* 1619.8196 + 469.7119);\n                theta = remap(particleHash.x, 0., 1., 0., TAU); // [0, 2.*PI]\n                radiusScale = particleHash.y * EXPLOSION_STRENGTH;\n                // Radius expands exponentially over time, i.e. explosion effect\n                radius = radiusScale * time * time;\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\n                // particlePos.y -= 8. * pow(particlePos.x, 4.); \n                // willow effect\n                particlePos.y -= max(EPS, pow(length(particlePos) - 0.05, 2.0) * 1.25);\n                // slightly descend back down due to gravity\n                particlePos.y -= pow(radius / radiusScale, 3.0) * 4e-5; \n                // bloom\n                spark = .0003 / pow(length(st - particlePos - fireworkPos), 1.7);\n                sparkDistFromOrigin = 2. * length(fireworkPos - particlePos);\n                // Shimmering effect for explosion particles\n                shimmer = max(0., sqrt(sparkDistFromOrigin) \n                    * (sin((iTime * max(1.3, fireworkHash.z * 2.0) + particleHash.y * TAU) * 18.)));\n                shimmerThreshold = FIREWORK_DURATION * .9;\n                // Fade after a certain time threshold\n                fade = C((FIREWORK_DURATION * 2.) * radiusScale - radius);\n                finalCol += mix(spark, spark * shimmer, smoothstep(shimmerThreshold\n\t\t\t\t\t* radiusScale, (shimmerThreshold + 1.) * radiusScale , radius))\n                    * fade * fireworkCol;\n            }\n            \n            // Initial instant flash for the explosion\n            if(time < FLASH_DURATION)\n            \tfinalCol += spark / (.01 + mod(time, ROCKET_DURATION));\n        }\n        else\n        {\n            rocketPath = mod(time, ROCKET_DURATION) / ROCKET_DURATION;\n            // ease out sine\n            rocketPath = sin(rocketPath / (ROCKET_DURATION * .75) * PI * .5);\n            fireworkPos = vec2(fireworkHash.x, \n                    rocketPath * fireworkHash.y);\n            // Slight random wiggle for the rocket's path\n    \t\tfireworkPos.x += sin(st.y * 50. + time) * fireworkCol.z * .0035;\n            \n            // Rockets flying before the explosion\n            for (int i = 0; i < ROCKET_PARTICES; ++i)\n            {\n                particleHash = hash31((float(i) * 603.6837) + 1472.3486);\n                // rocket trail size\n                float t = time * (2. - time);\n                radius = mod(time + particleHash.y, THRUSTER_SPEED) / THRUSTER_SPEED\n\t\t\t\t\t* particleHash.z * .1;\n                // Confine theta to a small value for a vertical thrust effect\n                theta = remap(particleHash.x, 0., 1., 0., PI * .1) + PI * 1.45;\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\n                finalCol += 8e-5 / pow(length(st - particlePos - fireworkPos), 1.1)\n                    * mix(vec3(1.4, .7, .2), vec3(1.4), radius * 16.);\n            }\n        }\n    }  \n    return finalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    uv.y += .3; // shift the horizon a bit lower\n    float reflection = 0.;\n    \n    if (uv.y < 0.)\n    {\n        reflection = 1.;\n        // watery distortion in the lake (improved)\n        /**\n        uv.x += sin((uv.y * 64. + sin(iTime) * .2)\n\t\t\t* cos(uv.y * 128. - cos(iTime) * .1)) * .15;\n\t\t*/\n        \n        // slightly better looking water waves\n        uv.x += cos(uv.y * 192. - iTime * .6) * sin(uv.y * 96. + iTime * .75) * .042;\n    }\n\n    // Our special uv coord that gives us reflection effect for pratically free\n    vec2 st = vec2(uv.x, abs(uv.y));\n    vec3 col = vec3(0.);\n    \n    // Background mountain\n    float mountain = sin(1.69 * st.x * 1.38 * cos(2.74 * st.x) + 4.87\n\t\t* sin(1.17 * st.x)) * .1 - .18 + st.y;\n    mountain = C(S(-.005, .005, mountain));\n    \n    float building = buildings(st);\n    \n    // Finally blend everything together\n    \n    // Sky color\n    col += vec3(.18 - st.y * .1, .18 - st.y * .1, .1 + st.y * .03);\n    // Blend the mountain and the sky\n    col = col * mountain + vec3(.1 - st.y * .1, .1 - st.y * .1, .08) * (1. - mountain);\n    // Occlude the mountain with the building skyline\n    col *= building;\n    \n    // Yellow-ish window color tint\n    col += windows(st * .8, 2.) * (1.-building) * vec3(1.2, 1., .8); \n    \n    // Moon white circle\n    float moon = smoothstep(.3, .29, length(st-vec2(1., .8)));\n    \n    //Twinkly stars, masked by the buildings, mountain, and the moon\n    col += stars(st, fragCoord) * mountain * building * (1. - moon);\n    \n    // Cut the main moon circle with an offset inverted one to make a crescent\n    moon *= smoothstep(.32, .48, length(st-vec2(.92, .88))) * 1.25;\n    \n    // Add the moon to the scene\n    col += moon * vec3(1.2, 1.18, 1.);\n    \n    \n    // Fireworks launch from behind the buildings, but in front of the mountains\n    col += C(fireworks(st)) * (building + moon);\n    \n    // Slightly change of the reflections to watery blueish-green\n    col.r -= reflection * .05;\n    col.gb += reflection * .01;\n    \n    fragColor = vec4(col - hash11(fragCoord.x * fragCoord.y * 0.2 * (iTime + 50.0)) * 0.008, 1.0);\n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3GRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1035, 1069, 1091, 1091, 1224], [1226, 1226, 1248, 1248, 1438], [1440, 1440, 1463, 1463, 1607], [1609, 1660, 1718, 1718, 1768], [1770, 1789, 1814, 1814, 2008], [2010, 2022, 2045, 2045, 2110], [2112, 2173, 2212, 2212, 2758], [2760, 2781, 2807, 2865, 3102], [3104, 3179, 3217, 3217, 3633], [8118, 8118, 8175, 8175, 10376]], "test": "untested"}
{"id": "wtd3Wf", "name": "Molecular dynamics 3D v1", "author": "michael0884", "description": "Molecular dynamics in 3d on a shader lol^3", "tags": ["3d", "voronoi", "particles", "chaos", "lorentz"], "likes": 7, "viewed": 454, "published": 3, "date": "1577834786", "time_retrieved": "2024-07-30T21:32:11.561849", "image_code": "// Fork of \"Lorentz Attractor 3D\" by michael0884. https://shadertoy.com/view/3lt3WX\n// 2019-12-31 20:33:24\n\n// Fork of \"Volumetric shader template\" by michael0884. https://shadertoy.com/view/tlc3Wf\n// 2019-12-30 20:57:24\n\n//#define VOLUMETRIC\n#define FULL_UNION\n#define sphere_rad 1.5\n\nfloat SDF_particle(vec3 p0, vec3 p)\n{\n    particle point = get(ch0, p0);\n    return length(point.pos.xyz - p) - sphere_rad;\n}\n\nvec4 opunion(vec4 a, vec4 b)\n{\n    if(a.w < b.w) return a;\n    else return b;\n}\n\n//distance estimator to the voronoi particle field\nfloat DE(vec3 p)\n{\n\tfloat de = 1e5;\n   \n   \tvec3 p0 =  round(clamp(p, vec3(0), size3d));\n    if(length(p - size3d*0.5) > 0.7*length(size3d)) \n        de = length(p - size3d*0.6);\n    else\n    {\t\n        de = min(de, SDF_particle(p0, p));\n        de = min(de, SDF_particle(p0+vec3(1,0,0), p));\n        de = min(de, SDF_particle(p0+vec3(-1,0,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,1,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,-1,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,0,1), p));\n        de = min(de, SDF_particle(p0+vec3(0,0,-1), p));\n    }\n    \n    if(de < sphere_rad*2.)\n    {\n\t\tde = min(de, SDF_particle(p0+vec3(1,1,0), p));\n        de = min(de, SDF_particle(p0+vec3(-1,-1,0), p));\n        de = min(de, SDF_particle(p0+vec3(0,1,1), p));\n        de = min(de, SDF_particle(p0+vec3(0,-1,-1), p));\n        de = min(de, SDF_particle(p0+vec3(1,0,1), p));\n        de = min(de, SDF_particle(p0+vec3(-1,0,-1), p));\n        //reduces the number of artifacts even further, since it is using all neighboring voxels in a 3*3*3 cube\n        #ifdef FULL_UNION\n            de = min(de, SDF_particle(p0+vec3(1,-1,0), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,0), p));\n            de = min(de, SDF_particle(p0+vec3(0,-1,1), p));\n            de = min(de, SDF_particle(p0+vec3(0,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,0,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,0,-1), p));\n            de = min(de, SDF_particle(p0+vec3(1,-1,0), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,0), p));\n            de = min(de, SDF_particle(p0+vec3(0,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(0,-1,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,0,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,0,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,1,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(1,-1,1), p));\n            de = min(de, SDF_particle(p0+vec3(1,-1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,1,-1), p));\n            de = min(de, SDF_particle(p0+vec3(-1,-1,-1), p));\n        #endif\n    }\n    \n    return de;\n}\n\nvec3 particle_color(vec3 p)\n{\n    vec4 a = vec4(1e5);\n    vec3 p0 = round(p);\n    for( int i=-1; i<=1; i++ )\n        for( int j=-1; j<=1; j++ )\n            for( int k=-1; k<=1; k++ )\n    {\n        vec3 dx = vec3(i,j,k);\n        particle thisp = get(ch0, p0+dx);\n        a = opunion(a, vec4(jet_range(thisp.pos.w, -0.1, 1.2), SDF_particle(p0+dx, p)));\n    }\n    return a.xyz;\n}\n\nvec3 COL(vec3 p)\n{\n    if(inside(p))\n    {\n        return particle_color(p)*exp(-0.25*pow(max(DE(p),0.),2.));\n    }\n    else return vec3(0.);\n}\n\n#define MAX_MARCHES 130\n#define DX 1.5\n#define OPACITY 0.2\nvec4 ray_march_vol(vec3 p, vec3 r)\n{\n    vec4 color = vec4(0., 0., 0., 0.);\n    vec4 background = vec4(0.1);\n    for(int i = 0; i < MAX_MARCHES; i++)\n    {\n        vec3 tcolor = COL(p);\n        float density = length(tcolor);\n        float noise  =(1.+0.25*sin(1754.*length(p)+p.x));\n        float d = DX*exp(-2.*min(density,2.))*noise;\n        float opacity = 1.-exp(-OPACITY*density*d);\n        float newa = max(color.w + (1. - color.w)*opacity,0.0001);\n        color.xyz = (color.xyz*color.w + (1.-color.w)*opacity*tcolor)/newa;\n        color.w = newa;\n        if(1. - newa < 0.01) break;\n        p += r*d;\n    }\n    return background + color;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdLineBox(vec3 p, vec3 b, float r)\n{\n    p = abs(p);\n    float cx = sdCapsule(p, b, vec3(b.x,b.y,0), r);\n    float cy = sdCapsule(p, b, vec3(0,b.y, b.z), r);\n    float cz = sdCapsule(p, b, vec3(b.x,0, b.z), r);\n    return min(min(cx, cy),cz);\n}\n\nvec3 sdcolor(vec3 p)\n{\n    vec3 c = vec3(0.);\n    if(inside(0.8*(p-size3d*0.5) + size3d*0.5))\n    {  \n        c = particle_color(p);\n    }\n    else c = vec3(0.1);\n    if(sdLineBox(p - size3d*0.5, size3d*0.5, 0.5) < 1. || p.z < 1.) c = vec3(1.);\n    return c;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat map(vec3 p)\n{\n    float de_partic = DE(p); \n    de_partic = min(de_partic, sdPlane(p, vec4(0,0,1,0)));\n    return min(de_partic, sdLineBox(p - size3d*0.5, size3d*0.5, 0.5));\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*map(p + k.xyy*dx) +\n\t\t\t k.yyxx*map(p + k.yyx*dx) +\n\t\t\t k.yxyx*map(p + k.yxy*dx) +\n\t\t\t k.xxxx*map(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//usual ray marching stuff\nfloat rayfov;\nvec3 light;\n\n#define shadow_steps 256\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.\nfloat shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle)\n{\n\tfloat light_visibility = 1.;\n\tfloat ph = 1e5;\n\tfloat dDEdt = 0.;\n\tpos.w = map(pos.xyz);\n\tint i = 0;\n\tfor (; i < shadow_steps; i++) {\n\t\n\t\tdir.w += pos.w;\n\t\tpos.xyz += pos.w*dir.xyz;\n        float noise  =(1.+0.1*sin(1754.*length(pos)+pos.x));\n\t\tpos.w = noise*map(pos.xyz);\n\t\t\n\t\tfloat y = pos.w*pos.w/(2.0*ph);\n        float d = (pos.w+ph)*0.5*(1.-dDEdt);\n\t\tfloat angle = d/(max(MIN_DIST,dir.w-y)*light_angle);\n\t\t\n        light_visibility = min(light_visibility, angle);\n\t\t\n\t\t//minimizing banding even further\n\t\tdDEdt = dDEdt*0.75 + 0.25*(pos.w-ph)/ph;\n\t\t\n\t\tph = pos.w;\n\t\t\n        if(dir.w >= distance2light)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(dir.w > MAX_DIST || pos.w < max(0.5*rayfov*dir.w, MIN_DIST))\n\t\t{\n\t\t\treturn 0.;\n\t\t}\n\t}\n\t\n\tif(i >= shadow_steps)\n\t{\n\t\tlight_visibility=0.;\n\t}\n\t//return light_visibility; //bad\n\tlight_visibility = clamp(2.*light_visibility - 1.,-1.,1.);\n\treturn  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)\n}\n\nfloat ambient_occlusion(in vec4 pos, in vec4 norm)\n{\t\n\tvec3 pos0 = pos.xyz;\n\t\n\tfloat occlusion_angle = 0.;\n\tvec3 direction = normalize(norm.xyz);\n\t//step out\n\tpos.xyz += 0.1*norm.w*direction;\n\t//march in the direction of the normal\n\tfor(int i = 0; i < 2; i++)\n\t{\n\t\tpos.xyz += pos.w*direction;\n\t\tpos.w = map(pos.xyz);\n\t\t\n\t\tnorm.w = length(pos0 - pos.xyz);\n\t\tocclusion_angle += clamp(pos.w/norm.w,0.,1.);\n\t}\n\t\n\tocclusion_angle /= 2.; // average weighted by importance\n\treturn (0.5-cos(3.14159265*occlusion_angle)*0.5);\n}\n\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float td = 0.;\n    int i;\n    for(i = 0; i < 100; i++)\n    {\n    \tfloat de = map(p);\n        if(de < rayfov*td || td > MAX_DIST)\n        {\n            break;\n        }\n        p += de*r;\n        td += de;\n    }\n    vec3 col =sdcolor(p);\n    vec4 norm = calcNormal(p,MIN_DIST);\n    p += r*(norm.w-rayfov*td);\n    float ao = ambient_occlusion(vec4(p,0.), vec4(norm.xyz, td));\n    float shad = shadow_march(vec4(p+norm.xyz*0.05,0.), vec4(light,0.), 400.,0.03);\n    float ill = max(dot(norm.xyz, light)*(shad  + 0.35*ao*(1. - shad)), 0.0);\n    return vec4(col*ill,1.);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rayfov = FOV/iResolution.x;\n     SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n   \n    vec2 uv = (fragCoord - 0.5*size)/max(size.x, size.y);\n\n    vec2 angles = vec2(2.*PI, PI)*(iMouse.xy/iResolution.xy - 0.5);\n\n    if(iMouse.w < 1.)\n    {\n        angles = vec2(0.2*iTime, 0.3*sin(0.2*iTime)+0.2);\n    }\n    vec3 ray = getRay(angles, uv);\n    vec3 cray = getRay(angles, vec2(0.));\n    light = vec3(0.6,0.50,1.);\n    light.z = max(light.z, 0.9);\n    light = normalize(light);\n    float d = sqrt(dot(vec3(size3d), vec3(size3d)))*0.55;\n    vec3 pos = vec3(size3d)*0.5 - cray*d;\n\n    // Output to screen\n    vec4 t = texel(ch0, fragCoord);\n    vec3 p = dim3from2(fragCoord);\n    #ifdef VOLUMETRIC\n   \t fragColor = 2.*ray_march_vol(pos, ray);\n    #else\n     fragColor = 1.5*ray_march(pos, ray);\n\t#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//definitions\n#define size iResolution.xy\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define pixel(a, p, s) texture(a, p/vec2(s))\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n#define dt 2.\n\n#define ar vec2(1.35,0.8)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, dim2from3(p3d), textureSize(ch, 0));\n}\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nbool inside(vec3 p)\n{\n    if(p.x > 1. && p.y > 1. && p.z > 1. && p.x < float(size3d.x)-1. && p.y < float(size3d.y)-1. && p.z < float(size3d.z)-1.)\n    {\n        return true;\n    }\n    else return false;\n}\n\n#define FOV 2.5\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat maxv(vec3 a)\n{\n    return max(max(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d + 1.) - p;\n    return min(minv(p),minv(a));\n}\n\nvec4 border_grad(vec3 p)\n{\n    const float dx = 0.001;\n    const vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*distance2border(p + k.xyy*dx) +\n\t\t\t k.yyxx*distance2border(p + k.yyx*dx) +\n\t\t\t k.yxyx*distance2border(p + k.yxy*dx) +\n\t\t\t k.xxxx*distance2border(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\n//encoding 2 values in one number\nfloat scaleFactor = 65530.0;\nfloat cp = 256.0 * 256.0;\n\n\n/* packs given two floats into one float */\nvec4 enc(vec4 x, vec4 y) {\n    vec4 x1 = floor(x * scaleFactor);\n    vec4 y1 = floor(y * scaleFactor);\n    vec4 f = (y1 * cp) + x1;\n    return f;\n}\n\n/* unpacks given float to two floats */\nvoid dec(in vec4 f, out vec4 x, out vec4 y){\n  vec4 dy = floor(f / cp);\n  vec4 dx = f - (dy * cp);\n  y = (dy / scaleFactor);\n  x = (dx / scaleFactor);\n}\n\nstruct particle\n{\n    vec4 pos;\n    vec4 vel;\n};\n\nparticle get(sampler2D ch, vec3 p)\n{\n    p = clamp(p, vec3(0.), size3d);\n    vec4 data = voxel(ch, p);\n    particle part;\n    dec(data, part.pos, part.vel);\n    part.pos.xyz *= size3d;\n    part.vel *= 10.;\n    return part;\n}\n\nvec4 save(particle a)\n{\n    //scale the numbers to be in a [-1,1] range\n    a.pos.xyz /= size3d;\n    return enc(a.pos, 0.1*a.vel);\n}\n    \nfloat force(float d)\n{\n    d *= 2.3;\n    return -(0.5*exp(-0.5*d) - 3.*exp(-3.*d));\n}", "buffer_a_code": "//3d voronoi particle tracking\n\nvoid Check(inout particle U, vec3 pos, vec3 dx)\n{\n    particle neighbor = get(ch0, pos + dx);\n    //check if the stored neighbouring particle is closer to this position \n    if(length(neighbor.pos.xyz - pos) < length(U.pos.xyz - pos))\n    {\n        U = neighbor; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout particle U, vec3 p, int r)\n{\n    Check(U, p, vec3(-r, 0, 0));\n    Check(U, p, vec3(r, 0, 0));\n    Check(U, p, vec3(0, -r, 0));\n    Check(U, p, vec3(0, r, 0));\n    Check(U, p, vec3(0, 0, -r));\n    Check(U, p, vec3(0, 0, r));\n}\n\n//get the force from a particle in p0 to a particle at p\nvec3 getForce(vec3 p0, vec3 p)\n{\n\tparticle neighbor = get(ch0, p0);\n    vec3 dx = neighbor.pos.xyz - p;\n    //only count if neighbor particle is inside of its cell to exclude repeated forces\n    if(maxv(abs(neighbor.pos.xyz - p0)) <= 0.5)\n        return normalize(dx)*force(length(dx));\n    else\n        return vec3(0.);\n}\n\nvec3 calc_force(vec3 p)\n{\n    vec3 p0 = round(p);\n    vec3 force = vec3(0.);\n    for( int i=-2; i<=2; i++ )\n        for( int j=-2; j<=2; j++ )\n            for( int k=-2; k<=2; k++ )\n    {\n        vec3 dx = vec3(i,j,k);\n        if(dx != vec3(0))\n          force += getForce(p0+dx, p);\n    }\n    \n    return force;\n}\n\n\nvoid mainImage( out vec4 pix, in vec2 pos )\n{\n    SCALE = floor(ar*pow(iResolution.x*iResolution.y,0.1666666));\n    size3d = vec3(floor(iResolution.xy/SCALE), SCALE.x*SCALE.y);\n    //voxel\n    vec3 p = dim3from2(pos);\n    \n    //this particle\n    particle U;\n    if(iFrame < 1)\n    {\n        if(distance2border(p) > 10.)\n        {\n             U.pos.xyz = vec3(2.*round(p.xyz/2.));\n             U.pos.w = hash13(U.pos.xyz+10.);\n             U.vel.xyz = 0.4*(hash33(U.pos.xyz+0.1)*2. - 1.);\n        }    \n        else\n        {\n            U.pos = vec4(1e5);\n        \tU.vel = vec4(1e5);\n        }\n    }\n    else\n    {\n        //this particle\n        U = get(ch0, p);\n\n        //check neighbours \n        CheckRadius(U, p, 1);\n        CheckRadius(U, p, 2);\n        CheckRadius(U, p, 3);\n        CheckRadius(U, p, 4);\n\n        vec4 border = border_grad(U.pos.xyz);\n\n        U.vel.xyz =  U.vel.xyz*0.6 + dt*(4.*normalize(border.xyz)*exp(-0.4*border.w*border.w)+calc_force(U.pos.xyz)-vec3(0, 0., 0.01));\n        U.pos.xyz += dt*U.vel.xyz;\n \n    }\n    pix = save(U);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtd3Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[286, 286, 323, 323, 411], [413, 413, 443, 443, 492], [494, 545, 563, 563, 2814], [2816, 2816, 2845, 2845, 3192], [3194, 3194, 3212, 3212, 3337], [3398, 3398, 3434, 3434, 4046], [4048, 4048, 4079, 4079, 4170], [4172, 4172, 4225, 4225, 4284], [4286, 4286, 4338, 4338, 4459], [4461, 4461, 4503, 4503, 4711], [4713, 4713, 4735, 4735, 4973], [4975, 4975, 5008, 5034, 5065], [5067, 5067, 5086, 5086, 5248], [5250, 5250, 5285, 5285, 5475], [5602, 5602, 5683, 5683, 6743], [6745, 6745, 6797, 6797, 7263], [7265, 7265, 7297, 7297, 7868], [7874, 7874, 7931, 7931, 8815]], "test": "untested"}
